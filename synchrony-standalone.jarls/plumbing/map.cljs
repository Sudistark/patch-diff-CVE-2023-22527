(ns plumbing.map
  "Common operations on maps (both Clojure immutable and mutable Java stuff)"
  (:refer-clojure :exclude [flatten])
  (:require
   [plumbing.core :as plumbing :include-macros true]
   [plumbing.fnk.schema :as schema :include-macros true]
          [clojure.set :as set]))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Clojure immutable maps

(defn safe-select-keys
  "Like select-keys, but asserts that all keys are present."
  [m ks]
  (let [missing (remove (partial contains? m) ks)]
    (schema/assert-iae (empty? missing) "Keys %s not found in %s" (vec missing)
                       (binding [*print-length* 200]
                         (print-str (mapv key m)))))
  (select-keys m ks))

(defn merge-disjoint
  "Like merge, but throws with any key overlap between maps"
  ([] {})
  ([m] m)
  ([m1 m2]
   (let [duplicates (filter (partial contains? m2) (keys m1))]
     (schema/assert-iae (empty? duplicates) "Duplicate keys %s"
                        (vec duplicates)))
   (into (or m2 {}) m1))
  ([m1 m2 & maps]
     (reduce merge-disjoint m1 (cons m2 maps))))

(defn merge-with-key
  "Like merge-with, but the merging function takes the key being merged
   as the first argument"
  [f & maps]
  (when (some identity maps)
    (let [merge-entry (fn [m e]
                        (let [k (key e) v (val e)]
                          (if (contains? m k)
                            (assoc m k (f k (get m k) v))
                            (assoc m k v))))
          merge2 (fn [m1 m2]
                   (reduce merge-entry (or m1 {}) (seq m2)))]
      (reduce merge2 maps))))

(defn flatten
  "Transform a nested map into a seq of [keyseq leaf-val] pairs"
  [m]
  (when m
    ((fn flatten-helper [keyseq m]
       (when m
         (if (map? m)
           (mapcat (fn [[k v]] (flatten-helper (conj keyseq k) v)) m)
           [[keyseq m]])))
     [] m)))

(defn unflatten
  "Transform a seq of [keyseq leaf-val] pairs into a nested map.
   If one keyseq is a prefix of another, you're on your own."
  [s]
  (reduce (fn [m [ks v]] (if (seq ks) (assoc-in m ks v) v)) {} s))


;; TODO: make sure we're safe with false here -- pretty sure we're not.  Same for nil.
(defn map-leaves-and-path
  "Takes a nested map and returns a nested map with the same shape, where each
   (non-map) leaf v is transformed to (f key-seq v).
   key-seq is the sequence of keys to reach this leaf, starting at the root."
  ([f m] (when m (map-leaves-and-path f [] m)))
  ([f ks m]
     (if-not (map? m)
       (f ks m)
       (plumbing/for-map [[k v] m]
         k
         (map-leaves-and-path f (conj ks k) v)))))

(defn keep-leaves-and-path
  "Takes a nested map and returns a nested map with the same shape, where each
   (non-map) leaf v is transformed to (f key-seq v), or removed if it returns nil.
   key-seq is the sequence of keys to reach this leaf, starting at the root.
   Empty maps produced by this pruning are themselves pruned from the output."
  ([f m] (keep-leaves-and-path f [] m))
  ([f ks m]
     (if-not (map? m)
       (f ks m)
       (plumbing/for-map [[k ov] m
                          :let [nv (keep-leaves-and-path f (conj ks k) ov)]
                          :when (not (or (nil? nv) (and (map? nv) (empty? nv))))]
         k nv))))

(defn map-leaves
  "Takes a nested map and returns a nested map with the same shape, where each
   (non-map) leaf v is transformed to (f v)."
  ([f m] (map-leaves-and-path (fn [_ l] (f l)) m)))

(defn keep-leaves
  "Takes a nested map and returns a nested map with the same shape, where each
   (non-map) leaf v is transformed to (f v), or removed if it returns nil.
   Empty maps produced by this pruning are themselves pruned from the output."
  ([f m] (keep-leaves-and-path (fn [_ l] (f l)) m)))

                     
                                                                           
                

                          
                        

                         
          
                                 
                                                                               
                                               

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Java mutable Maps

     
   
                   
                                                               
                           
                                 
                                  
                                             

                
                                                                              
                                                                         
                                                     

                                                        
                      
                                      
                       
                                   
                             
                    

                
                                                                     
                                  
                                    
                                
                    

                   
                                                                         
                                                                              
                                   
                          
                                                           
                                 


                                  
                                                                     
                 
                                 
                                
                         
         

                                       
                                                                        
                   
                                 
                                   
                             
          

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Ops on graphs represented as maps.

     
                      
                                                                             
                                                                                
                                                                  
                                                                                  
                                                                               
                                 
                                                        
                               
                             
                                  
                       
                                                                         
                                     
                             
                   
                                 
                                
                          
                                        
                        
                         
                                      
                         
                               
                                 
                                                                                                          
                  

      
(defn topological-sort
  [child-map & [include-leaves?]]
  (let [e (atom child-map)
        re (atom {})
        s (atom [])]
    (doseq [[p children] child-map
            c children]
      (when include-leaves? (when-not (find @e c) (swap! e assoc c nil)))
      (swap! re update c #(cons p %)))
    (while (seq @e)
      ((fn dfs1 [n]
         (when-let [[_ nns] (find @e n)]
           (swap! e dissoc n)
           (doseq [nn nns] (dfs1 nn))
           (swap! s conj n)))
       (first (keys @e))))
    (let [candidate (reverse @s)]
      (doseq [c candidate
              :let [rs (@re c)
                    _ (swap! re dissoc c)]
              r rs]
        (when (find @re r)
          (throw (ex-info (str "Graph contains a cycle containing " c " and " r) {:nodes [c r]}))))
      candidate)))

;;;;;;;;;;;; This file autogenerated from src/plumbing/map.cljx
