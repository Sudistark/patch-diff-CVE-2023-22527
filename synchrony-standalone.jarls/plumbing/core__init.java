package plumbing;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class core__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__3;
  
  public static final AFn const__4;
  
  public static final Var const__5;
  
  public static final Var const__6;
  
  public static final AFn const__13;
  
  public static final Keyword const__14;
  
  public static final Var const__15;
  
  public static final AFn const__19;
  
  public static final Var const__20;
  
  public static final AFn const__23;
  
  public static final Var const__24;
  
  public static final AFn const__27;
  
  public static final Var const__28;
  
  public static final AFn const__31;
  
  public static final Var const__32;
  
  public static final AFn const__35;
  
  public static final Var const__36;
  
  public static final AFn const__39;
  
  public static final Var const__40;
  
  public static final AFn const__43;
  
  public static final Var const__44;
  
  public static final AFn const__48;
  
  public static final Var const__49;
  
  public static final AFn const__52;
  
  public static final Var const__53;
  
  public static final AFn const__56;
  
  public static final Var const__57;
  
  public static final AFn const__60;
  
  public static final Var const__61;
  
  public static final AFn const__64;
  
  public static final Var const__65;
  
  public static final AFn const__68;
  
  public static final Var const__69;
  
  public static final AFn const__72;
  
  public static final Var const__73;
  
  public static final AFn const__76;
  
  public static final Var const__77;
  
  public static final AFn const__80;
  
  public static final Var const__81;
  
  public static final AFn const__84;
  
  public static final Var const__85;
  
  public static final AFn const__88;
  
  public static final Var const__89;
  
  public static final AFn const__92;
  
  public static final Var const__93;
  
  public static final AFn const__96;
  
  public static final Var const__97;
  
  public static final AFn const__100;
  
  public static final Var const__101;
  
  public static final AFn const__104;
  
  public static final Var const__105;
  
  public static final AFn const__108;
  
  public static final Var const__109;
  
  public static final AFn const__112;
  
  public static final Var const__113;
  
  public static final AFn const__116;
  
  public static final Var const__117;
  
  public static final AFn const__120;
  
  public static final Var const__121;
  
  public static final AFn const__124;
  
  public static final Var const__125;
  
  public static final AFn const__128;
  
  public static final Var const__129;
  
  public static final AFn const__131;
  
  public static final Var const__132;
  
  public static final Var const__133;
  
  public static final Var const__134;
  
  public static final Var const__135;
  
  public static final AFn const__138;
  
  public static final Var const__139;
  
  public static final AFn const__142;
  
  public static final Var const__143;
  
  public static final AFn const__146;
  
  public static final Var const__147;
  
  public static final AFn const__150;
  
  public static final Var const__151;
  
  public static final AFn const__154;
  
  public static final Var const__155;
  
  public static final AFn const__158;
  
  public static final Var const__159;
  
  public static final AFn const__162;
  
  public static final Var const__163;
  
  public static final AFn const__166;
  
  public static final Var const__167;
  
  public static final AFn const__170;
  
  public static final Var const__171;
  
  public static final AFn const__174;
  
  public static final Var const__175;
  
  public static final AFn const__178;
  
  public static final Var const__179;
  
  public static final AFn const__182;
  
  public static final Var const__183;
  
  public static final AFn const__186;
  
  public static final Var const__187;
  
  public static final AFn const__190;
  
  public static final Var const__191;
  
  public static final AFn const__194;
  
  public static final Var const__195;
  
  public static final AFn const__198;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new core.fn__23478());
    const__6.setMeta((IPersistentMap)const__13);
    const__6.bindRoot(const__14);
    const__15.setMeta((IPersistentMap)const__19);
    const__15.bindRoot(new core.for_map());
    ((Var)const__15)




















      
      .setMacro();
    const__20.setMeta((IPersistentMap)const__23);
    const__20.bindRoot(new core._unless_update());
    ((Var)const__20)

















      
      .setMacro();
    const__24.setMeta((IPersistentMap)const__27);
    const__24.bindRoot(new core.map_vals());
    const__28.setMeta((IPersistentMap)const__31);
    const__28.bindRoot(new core.map_keys());
    const__32.setMeta((IPersistentMap)const__35);
    const__32.bindRoot(new core.map_from_keys());
    const__36.setMeta((IPersistentMap)const__39);
    const__36.bindRoot(new core.map_from_vals());
    const__40.setMeta((IPersistentMap)const__43);
    const__40.bindRoot(new core.dissoc_in());
    const__44.setMeta((IPersistentMap)const__48);
    const__44.bindRoot(new core.keywordize_map());
    const__49.setMeta((IPersistentMap)const__52);
    const__49.bindRoot(new core.lazy_get());
    ((Var)const__49)
















































































      
      .setMacro();
    const__53.setMeta((IPersistentMap)const__56);
    const__53.bindRoot(new core.safe_get());
    const__57.setMeta((IPersistentMap)const__60);
    const__57.bindRoot(new core.safe_get_in());
    const__61.setMeta((IPersistentMap)const__64);
    const__61.bindRoot(new core.assoc_when());
    const__65.setMeta((IPersistentMap)const__68);
    const__65.bindRoot(new core.update_in_when());
    const__69.setMeta((IPersistentMap)const__72);
    const__69.bindRoot(new core.grouped_map());
    const__73.setMeta((IPersistentMap)const__76);
    const__73.bindRoot(new core.aconcat());
    const__77.setMeta((IPersistentMap)const__80);
    const__77.bindRoot(new core.unchunk());
    const__81.setMeta((IPersistentMap)const__84);
    const__81.bindRoot(new core.sum());
    const__85.setMeta((IPersistentMap)const__88);
    const__85.bindRoot(new core.singleton());
    const__89.setMeta((IPersistentMap)const__92);
    const__89.bindRoot(new core.indexed());
    const__93.setMeta((IPersistentMap)const__96);
    const__93.bindRoot(new core.positions());
    const__97.setMeta((IPersistentMap)const__100);
    const__97.bindRoot(new core.frequencies_fast());
    const__101.setMeta((IPersistentMap)const__104);
    const__101.bindRoot(new core.distinct_fast());
    const__105.setMeta((IPersistentMap)const__108);
    const__105.bindRoot(new core.distinct_by());
    const__109.setMeta((IPersistentMap)const__112);
    const__109.bindRoot(new core.distinct_id());
    const__113.setMeta((IPersistentMap)const__116);
    const__113.bindRoot(new core.interleave_all());
    const__117.setMeta((IPersistentMap)const__120);
    const__117.bindRoot(new core.count_when());
    const__121.setMeta((IPersistentMap)const__124);
    const__121.bindRoot(new core.conj_when());
    const__125.setMeta((IPersistentMap)const__128);
    const__125.bindRoot(new core.cons_when());
    const__129.setMeta((IPersistentMap)const__131);
    const__129










































































































































































      
      .bindRoot(((IFn)const__132.getRawRoot()).invoke(const__133.getRawRoot(), const__134.getRawRoot()));
    const__135.setMeta((IPersistentMap)const__138);
    const__135.bindRoot(new core._QMARK__GT__GT_());
    ((Var)const__135)



      
      .setMacro();
    const__139.setMeta((IPersistentMap)const__142);
    const__139.bindRoot(new core._QMARK__GT_());
    ((Var)const__139)





      
      .setMacro();
    const__143.setMeta((IPersistentMap)const__146);
    const__143.bindRoot(new core.fn__GT_());
    ((Var)const__143)





      
      .setMacro();
    const__147.setMeta((IPersistentMap)const__150);
    const__147.bindRoot(new core.fn__GT__GT_());
    ((Var)const__147)



      
      .setMacro();
    const__151.setMeta((IPersistentMap)const__154);
    const__151.bindRoot(new core._LT__());
    ((Var)const__151)



      
      .setMacro();
    const__155.setMeta((IPersistentMap)const__158);
    const__155.bindRoot(new core.as__GT__GT_());
    ((Var)const__155)








      
      .setMacro();
    const__159.setMeta((IPersistentMap)const__162);
    const__159.bindRoot(new core.memoized_fn());
    ((Var)const__159)



      
      .setMacro();
    const__163.setMeta((IPersistentMap)const__166);
    const__163.bindRoot(new core.swap_pair_BANG_());
    const__167.setMeta((IPersistentMap)const__170);
    const__167.bindRoot(new core.get_and_set_BANG_());
    const__171.setMeta((IPersistentMap)const__174);
    const__171.bindRoot(new core.millis());
    const__175.setMeta((IPersistentMap)const__178);
    const__175.bindRoot(new core.mapply());
    const__179.setMeta((IPersistentMap)const__182);
    const__179.bindRoot(new core.letk());
    ((Var)const__179)
















































      
      .setMacro();
    const__183.setMeta((IPersistentMap)const__186);
    const__183.bindRoot(new core.if_letk());
    ((Var)const__183)




































      
      .setMacro();
    const__187.setMeta((IPersistentMap)const__190);
    const__187.bindRoot(new core.when_letk());
    ((Var)const__187)















      
      .setMacro();
    const__191.setMeta((IPersistentMap)const__194);
    const__191.bindRoot(new core.fnk());
    ((Var)const__191)





      
      .setMacro();
    const__195.setMeta((IPersistentMap)const__198);
    const__195.bindRoot(new core.defnk());
    ((Var)const__195)




















      
      .setMacro();
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "plumbing.core")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Utility belt for Clojure in the wild" }));
    const__3 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Utility belt for Clojure in the wild" });
    const__4 = (AFn)Symbol.intern(null, "clojure.core");
    const__5 = (Var)RT.var("clojure.core", "*warn-on-reflection*");
    const__6 = (Var)RT.var("plumbing.core", "+none+");
    const__13 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(16), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj", RT.keyword(null, "doc"), "A sentinel value representing missing portions of the input data." });
    const__14 = (Keyword)RT.keyword("plumbing.core", "missing");
    const__15 = (Var)RT.var("plumbing.core", "for-map");
    const__19 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "seq-exprs"), Symbol.intern(null, "key-expr"), Symbol.intern(null, "val-expr")), Tuple.create(Symbol.intern(null, "m-sym"), Symbol.intern(null, "seq-exprs"), Symbol.intern(null, "key-expr"), Symbol.intern(null, "val-expr")) })), RT.keyword(null, "doc"), "Like 'for' for building maps. Same bindings except the body should have a\n  key-expression and value-expression. If a key is repeated, the last\n  value (according to \"for\" semantics) will be retained.\n\n  (= (for-map [i (range 2) j (range 2)] [i j] (even? (+ i j)))\n     {[0 0] true, [0 1] false, [1 0] false, [1 1] true})\n\n  An optional symbol can be passed as a first argument, which will be\n  bound to the transient map containing the entries produced so far.", RT.keyword(null, "line"), Integer.valueOf(23), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__20 = (Var)RT.var("plumbing.core", "-unless-update");
    const__23 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Execute and yield body only if Clojure version preceeds introduction\n  of 'update' into core namespace.", RT.keyword(null, "line"), Integer.valueOf(42), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__24 = (Var)RT.var("plumbing.core", "map-vals");
    const__27 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), "Build map k -> (f v) for [k v] in map, preserving the initial type", RT.keyword(null, "line"), Integer.valueOf(68), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__28 = (Var)RT.var("plumbing.core", "map-keys");
    const__31 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), "Build map (f k) -> v for [k v] in map m", RT.keyword(null, "line"), Integer.valueOf(79), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__32 = (Var)RT.var("plumbing.core", "map-from-keys");
    const__35 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "ks")) })), RT.keyword(null, "doc"), "Build map k -> (f k) for keys in ks", RT.keyword(null, "line"), Integer.valueOf(86), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__36 = (Var)RT.var("plumbing.core", "map-from-vals");
    const__39 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "vs")) })), RT.keyword(null, "doc"), "Build map (f v) -> v for vals in vs", RT.keyword(null, "line"), Integer.valueOf(91), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__40 = (Var)RT.var("plumbing.core", "dissoc-in");
    const__43 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Tuple.create(Symbol.intern(null, "k"), Symbol.intern(null, "&"), Symbol.intern(null, "ks"))) })), RT.keyword(null, "doc"), "Dissociate this keyseq from m, removing any empty maps created as a result\n   (including at the top-level).", RT.keyword(null, "line"), Integer.valueOf(96), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__44 = (Var)RT.var("plumbing.core", "keywordize-map");
    const__48 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "deprecated"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "DEPRECATED.  prefer clojure.walk/keywordize-keys.\n\n   Recursively convert maps in m (including itself)\n   to have keyword keys instead of string", RT.keyword(null, "line"), Integer.valueOf(107), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "plumbing/core.clj" });
    const__49 = (Var)RT.var("plumbing.core", "lazy-get");
    const__52 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "k"), Symbol.intern(null, "d")) })), RT.keyword(null, "doc"), "Like get but lazy about default", RT.keyword(null, "line"), Integer.valueOf(124), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__53 = (Var)RT.var("plumbing.core", "safe-get");
    const__56 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "k")) })), RT.keyword(null, "doc"), "Like get but throw an exception if not found", RT.keyword(null, "line"), Integer.valueOf(131), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__57 = (Var)RT.var("plumbing.core", "safe-get-in");
    const__60 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ks")) })), RT.keyword(null, "doc"), "Like get-in but throws exception if not found", RT.keyword(null, "line"), Integer.valueOf(140), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__61 = (Var)RT.var("plumbing.core", "assoc-when");
    const__64 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "&"), Symbol.intern(null, "kvs")) })), RT.keyword(null, "doc"), "Like assoc but only assocs when value is truthy", RT.keyword(null, "line"), Integer.valueOf(147), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__65 = (Var)RT.var("plumbing.core", "update-in-when");
    const__68 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "key-seq"), Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Like update-in but returns m unchanged if key-seq is not present.", RT.keyword(null, "line"), Integer.valueOf(156), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__69 = (Var)RT.var("plumbing.core", "grouped-map");
    const__72 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "key-fn"), Symbol.intern(null, "map-fn"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Like group-by, but accepts a map-fn that is applied to values before\n   collected.", RT.keyword(null, "line"), Integer.valueOf(164), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__73 = (Var)RT.var("plumbing.core", "aconcat");
    const__76 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Like (apply concat s) but lazier (and shorter) ", RT.keyword(null, "line"), Integer.valueOf(179), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__77 = (Var)RT.var("plumbing.core", "unchunk");
    const__80 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Takes a seqable and returns a lazy sequence that\n   is maximally lazy and doesn't realize elements due to either\n   chunking or apply.\n\n   Useful when you don't want chunking, for instance,\n   (first awesome-website? (map slurp +a-bunch-of-urls+))\n   may slurp up to 31 unneed webpages, wherease\n   (first awesome-website? (map slurp (unchunk +a-bunch-of-urls+)))\n   is guaranteed to stop slurping after the first awesome website.\n\n  Taken from http://stackoverflow.com/questions/3407876/how-do-i-avoid-clojures-chunking-behavior-for-lazy-seqs-that-i-want-to-short-ci", RT.keyword(null, "line"), Integer.valueOf(184), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__81 = (Var)RT.var("plumbing.core", "sum");
    const__84 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "xs")), Tuple.create(Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "Return sum of (f x) for each x in xs", RT.keyword(null, "line"), Integer.valueOf(201), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__85 = (Var)RT.var("plumbing.core", "singleton");
    const__88 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "returns (first xs) when xs has only 1 element", RT.keyword(null, "line"), Integer.valueOf(206), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__89 = (Var)RT.var("plumbing.core", "indexed");
    const__92 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Returns [idx x] for x in seqable s", RT.keyword(null, "line"), Integer.valueOf(213), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__93 = (Var)RT.var("plumbing.core", "positions");
    const__96 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Returns indices idx of sequence s where (f (nth s idx))", RT.keyword(null, "line"), Integer.valueOf(218), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__97 = (Var)RT.var("plumbing.core", "frequencies-fast");
  }
  
  public static void __init1() {
    const__100 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "Like clojure.core/frequencies, but faster.\n   Uses Java's equal/hash, so may produce incorrect results if\n   given values that are = but not .equal", RT.keyword(null, "line"), Integer.valueOf(224), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__101 = (Var)RT.var("plumbing.core", "distinct-fast");
    const__104 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "Like clojure.core/distinct, but faster.\n   Uses Java's equal/hash, so may produce incorrect results if\n   given values that are = but not .equal", RT.keyword(null, "line"), Integer.valueOf(235), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__105 = (Var)RT.var("plumbing.core", "distinct-by");
    const__108 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "Returns elements of xs which return unique\n   values according to f. If multiple elements of xs return the same\n   value under f, the first is returned", RT.keyword(null, "line"), Integer.valueOf(243), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__109 = (Var)RT.var("plumbing.core", "distinct-id");
    const__112 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "Like distinct but uses reference rather than value identity, very clojurey", RT.keyword(null, "line"), Integer.valueOf(256), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__113 = (Var)RT.var("plumbing.core", "interleave-all");
    const__116 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "colls")) })), RT.keyword(null, "doc"), "Analogy: partition:partition-all :: interleave:interleave-all", RT.keyword(null, "line"), Integer.valueOf(264), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__117 = (Var)RT.var("plumbing.core", "count-when");
    const__120 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "Returns # of elements of xs where pred holds", RT.keyword(null, "line"), Integer.valueOf(274), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__121 = (Var)RT.var("plumbing.core", "conj-when");
    const__124 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "x"), Symbol.intern(null, "&"), Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "Like conj but ignores non-truthy values", RT.keyword(null, "line"), Integer.valueOf(279), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__125 = (Var)RT.var("plumbing.core", "cons-when");
    const__128 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Like cons but does nothing if x is non-truthy.", RT.keyword(null, "line"), Integer.valueOf(289), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__129 = (Var)RT.var("plumbing.core", "rsort-by");
    const__131 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(294), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj", RT.keyword(null, "doc"), "Like sort-by, but prefers higher values rather than lower ones." });
    const__132 = (Var)RT.var("clojure.core", "comp");
    const__133 = (Var)RT.var("clojure.core", "reverse");
    const__134 = (Var)RT.var("clojure.core", "sort-by");
    const__135 = (Var)RT.var("plumbing.core", "?>>");
    const__138 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "do-it?"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Conditional double-arrow operation (->> nums (?>> inc-all? (map inc)))", RT.keyword(null, "line"), Integer.valueOf(301), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__139 = (Var)RT.var("plumbing.core", "?>");
    const__142 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "arg"), Symbol.intern(null, "do-it?"), Symbol.intern(null, "&"), Symbol.intern(null, "rest")) })), RT.keyword(null, "doc"), "Conditional single-arrow operation (-> m (?> add-kv? (assoc :k :v)))", RT.keyword(null, "line"), Integer.valueOf(308), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__143 = (Var)RT.var("plumbing.core", "fn->");
    const__146 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Equivalent to `(fn [x] (-> x ~@body))", RT.keyword(null, "line"), Integer.valueOf(315), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__147 = (Var)RT.var("plumbing.core", "fn->>");
    const__150 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Equivalent to `(fn [x] (->> x ~@body))", RT.keyword(null, "line"), Integer.valueOf(320), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__151 = (Var)RT.var("plumbing.core", "<-");
    const__154 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Converts a ->> to a ->\n\n   (->> (range 10) (map inc) (<- (doto prn)) (reduce +))\n\n   Jason W01fe is happy to give a talk anywhere any time on\n   the calculus of arrow macros", RT.keyword(null, "line"), Integer.valueOf(325), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__155 = (Var)RT.var("plumbing.core", "as->>");
    const__158 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "forms-and-expr")) })), RT.keyword(null, "doc"), "Like as->, but can be used in double arrow.", RT.keyword(null, "line"), Integer.valueOf(335), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__159 = (Var)RT.var("plumbing.core", "memoized-fn");
    const__162 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "args"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Like fn, but memoized (including recursive calls).\n\n   The clojure.core memoize correctly caches recursive calls when you do a top-level def\n   of your memoized function, but if you want an anonymous fibonacci function, you must use\n   memoized-fn rather than memoize to cache the recursive calls.", RT.keyword(null, "line"), Integer.valueOf(340), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__163 = (Var)RT.var("plumbing.core", "swap-pair!");
    const__166 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "a"), Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "a"), Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Like swap! but returns a pair [old-val new-val]", RT.keyword(null, "line"), Integer.valueOf(360), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__167 = (Var)RT.var("plumbing.core", "get-and-set!");
    const__170 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "a"), Symbol.intern(null, "new-val")) })), RT.keyword(null, "doc"), "Like reset! but returns old-val", RT.keyword(null, "line"), Integer.valueOf(372), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__171 = (Var)RT.var("plumbing.core", "millis");
    const__174 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create()).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })) })), RT.keyword(null, "line"), Integer.valueOf(377), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__175 = (Var)RT.var("plumbing.core", "mapply");
    const__178 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "m")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "arg"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Like apply, but applies a map to a function with positional map\n  arguments. Can take optional initial args just like apply.", RT.keyword(null, "line"), Integer.valueOf(381), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__179 = (Var)RT.var("plumbing.core", "letk");
    const__182 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Keyword let.  Accepts an interleaved sequence of binding forms and map forms like:\n   (letk [[a {b 2} [:f g h] c d {e 4} :as m & more] a-map ...] & body)\n   a, c, d, and f are required keywords, and letk will barf if not in a-map.\n   b and e are optional, and will be bound to default values if not present.\n   g and h are required keys in the map found under :f.\n   m will be bound to the entire map (a-map).\n   more will be bound to all the unbound keys (ie (dissoc a-map :a :b :c :d :e)).\n   :as and & are both optional, but must be at the end in the specified order if present.\n   The same symbol cannot be bound multiple times within the same destructing level.\n\n   Optional values can reference symbols bound earlier within the same binding, i.e.,\n   (= [2 2] (let [a 1] (letk [[a {b a}] {:a 2}] [a b]))) but\n   (= [2 1] (let [a 1] (letk [[{b a} a] {:a 2}] [a b])))\n\n   If present, :as and :& symbols are bound before other symbols within the binding.\n\n   Namespaced keys are supported by specifying fully-qualified key in binding form. The bound\n   symbol uses the _name_ portion of the namespaced key, i.e,\n   (= 1 (letk [[a/b] {:a/b 1}] b)).\n\n   Map destructuring bindings can be mixed with ordinary symbol bindings.", RT.keyword(null, "line"), Integer.valueOf(390), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__183 = (Var)RT.var("plumbing.core", "if-letk");
    const__186 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "then")), Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "then"), Symbol.intern(null, "else")) })), RT.keyword(null, "doc"), "bindings => binding-form test\n\n  If test is true, evaluates then with binding-form bound to the value of\n  test, if not, yields else", RT.keyword(null, "line"), Integer.valueOf(428), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__187 = (Var)RT.var("plumbing.core", "when-letk");
    const__190 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "bindings => binding-form test\n\n  When test is true, evaluates body with binding-form bound to the value of test", RT.keyword(null, "line"), Integer.valueOf(445), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__191 = (Var)RT.var("plumbing.core", "fnk");
    const__194 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Keyword fn, using letk.  Generates a prismatic/schema schematized fn that\n   accepts a single explicit map i.e., (f {:foo :bar}).\n\n   Explicit top-level map structure will be recorded in output spec, or\n   to capture implicit structure use an explicit prismatic/schema hint on the\n   function name.\n\n   Individual inputs can also be schematized by putting :- schemas after the\n   binding symbol.  Schemas can also be used on & more symbols to describe\n   additional map inputs, or on entire [] bindings to override the automatically\n   generated schema for the contents (caveat emptor).\n\n   By default, input schemas allow for arbitrary additional mappings\n   ({s/Keyword s/Any}) unless explicit binding or & more schemas are provided.", RT.keyword(null, "line"), Integer.valueOf(452), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
    const__195 = (Var)RT.var("plumbing.core", "defnk");
    const__198 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "defnk-args")) })), RT.keyword(null, "doc"), "Analogy: fn:fnk :: defn::defnk", RT.keyword(null, "line"), Integer.valueOf(474), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/core.clj" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("plumbing.core__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
