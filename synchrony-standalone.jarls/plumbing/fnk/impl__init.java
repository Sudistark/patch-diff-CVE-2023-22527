package plumbing.fnk;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class impl__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__3;
  
  public static final AFn const__4;
  
  public static final Var const__5;
  
  public static final AFn const__13;
  
  public static final Var const__14;
  
  public static final AFn const__17;
  
  public static final Var const__18;
  
  public static final AFn const__21;
  
  public static final Var const__22;
  
  public static final AFn const__26;
  
  public static final Var const__27;
  
  public static final AFn const__30;
  
  public static final Var const__31;
  
  public static final AFn const__34;
  
  public static final Var const__35;
  
  public static final AFn const__38;
  
  public static final Var const__39;
  
  public static final AFn const__42;
  
  public static final Var const__43;
  
  public static final AFn const__46;
  
  public static final Var const__47;
  
  public static final AFn const__50;
  
  public static final AFn const__53;
  
  public static final Var const__54;
  
  public static final AFn const__56;
  
  public static final Keyword const__57;
  
  public static final Var const__58;
  
  public static final AFn const__61;
  
  public static final Var const__62;
  
  public static final AFn const__65;
  
  public static final Var const__66;
  
  public static final AFn const__69;
  
  public static final Var const__70;
  
  public static final AFn const__73;
  
  public static final Var const__74;
  
  public static final AFn const__77;
  
  public static final Var const__78;
  
  public static final AFn const__81;
  
  public static final Var const__82;
  
  public static final AFn const__85;
  
  public static void load() { LockingTransaction.runInTransaction((Callable)new impl.fn__23342());
    const__5.setMeta((IPersistentMap)const__13);
    const__5.bindRoot(new impl.name_sym());
    const__14.setMeta((IPersistentMap)const__17);
    const__14.bindRoot(new impl.qualified_sym());
    const__18.setMeta((IPersistentMap)const__21);
    const__22.setMeta((IPersistentMap)const__26);
    const__22.bindRoot(new impl.any_schema_QMARK_());
    const__27.setMeta((IPersistentMap)const__30);
    const__27.bindRoot(new impl.assert_unschematized());
    const__31.setMeta((IPersistentMap)const__34);
    const__31.bindRoot(new impl.ensure_schema_metadata());
    const__35.setMeta((IPersistentMap)const__38);
    const__35.bindRoot(new impl.schema_override());
    const__39.setMeta((IPersistentMap)const__42);
    const__39.bindRoot(new impl.process_schematized_map());
    const__43.setMeta((IPersistentMap)const__46);
    const__43.bindRoot(new impl.letk_arg_bind_sym_and_body_form());
    const__47.setMeta((IPersistentMap)const__50);
    const__47.bindRoot(new impl.extract_special_args());
    const__18.setMeta((IPersistentMap)const__53);
    const__18.bindRoot(new impl.letk_input_schema_and_body_form());
    const__54.setMeta((IPersistentMap)const__56);
    const__54.bindRoot(const__57);
    const__58.setMeta((IPersistentMap)const__61);
    const__58.bindRoot(new impl.positional_arg_bind_sym_and_body());
    const__62.setMeta((IPersistentMap)const__65);
    const__62.bindRoot(new impl.positional_arg_bind_syms_and_body());
    const__66.setMeta((IPersistentMap)const__69);
    const__66.bindRoot(new impl.positional_info());
    const__70.setMeta((IPersistentMap)const__73);
    const__70.bindRoot(new impl.efficient_call_forms());
    const__74.setMeta((IPersistentMap)const__77);
    const__74.bindRoot(new impl.positional_fn());
    const__78.setMeta((IPersistentMap)const__81);
    const__78.bindRoot(new impl.positional_fnk_form());
    const__82.setMeta((IPersistentMap)const__85);
    const__82.bindRoot(new impl.fnk_form()); }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "plumbing.fnk.impl")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Core utilities for parsing our 'fnk'-style binding syntax.\n   Documented and tested through the actual 'letk','fnk', and 'defnk'\n   macros in plumbing.core.\n\n   The core entry points into this namespace are 'letk*' and 'fnk*',\n   which parse the new binding syntax and generate fnk bodies,\n   respectively.\n\n   For efficiency, two different methods of generating fnk bodies are\n   used.  If the fnk takes a fixed set of arguments (i.e., no & or\n   :as), then a 'positional' version of the fnk that is called like an\n   ordinary Clojure fn (e.g., (f a b) rather than (f {:a a :b b}) is\n   generated as an implementation detail, and stored in metadata of\n   the actual keyword fnk (which is just a thin wrapper around the\n   positional version).  If '& or :as are used, no such positional\n   function is generated.\n\n   The advantage of these 'positional' functions is that they can be\n   accessed using 'efficient-call-forms' or 'positional-fn' to call\n   the fnk without incurring the overhead of producing and then\n   destructuring a top-level map.  See plumbing.graph.positional for\n   an example use." }));
    const__3 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Core utilities for parsing our 'fnk'-style binding syntax.\n   Documented and tested through the actual 'letk','fnk', and 'defnk'\n   macros in plumbing.core.\n\n   The core entry points into this namespace are 'letk*' and 'fnk*',\n   which parse the new binding syntax and generate fnk bodies,\n   respectively.\n\n   For efficiency, two different methods of generating fnk bodies are\n   used.  If the fnk takes a fixed set of arguments (i.e., no & or\n   :as), then a 'positional' version of the fnk that is called like an\n   ordinary Clojure fn (e.g., (f a b) rather than (f {:a a :b b}) is\n   generated as an implementation detail, and stored in metadata of\n   the actual keyword fnk (which is just a thin wrapper around the\n   positional version).  If '& or :as are used, no such positional\n   function is generated.\n\n   The advantage of these 'positional' functions is that they can be\n   accessed using 'efficient-call-forms' or 'positional-fn' to call\n   the fnk without incurring the overhead of producing and then\n   destructuring a top-level map.  See plumbing.graph.positional for\n   an example use." });
    const__4 = (AFn)Symbol.intern(null, "clojure.core");
    const__5 = (Var)RT.var("plumbing.fnk.impl", "name-sym");
    const__13 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns symbol of x's name.\n   Converts a keyword/string to symbol, or removes namespace (if any) of symbol", RT.keyword(null, "line"), Integer.valueOf(35), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/impl.clj" });
    const__14 = (Var)RT.var("plumbing.fnk.impl", "qualified-sym");
    const__17 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns qualified symbol of x, an instance of Named", RT.keyword(null, "line"), Integer.valueOf(41), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/impl.clj" });
    const__18 = (Var)RT.var("plumbing.fnk.impl", "letk-input-schema-and-body-form");
    const__21 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(48), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/impl.clj" });
    const__22 = (Var)RT.var("plumbing.fnk.impl", "any-schema?");
    const__26 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "line"), Integer.valueOf(50), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/impl.clj" });
    const__27 = (Var)RT.var("plumbing.fnk.impl", "assert-unschematized");
    const__30 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(53), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/impl.clj" });
    const__31 = (Var)RT.var("plumbing.fnk.impl", "ensure-schema-metadata");
    const__34 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "env"), Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(57), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/impl.clj" });
    const__35 = (Var)RT.var("plumbing.fnk.impl", "schema-override");
    const__38 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sym"), Symbol.intern(null, "schema")) })), RT.keyword(null, "line"), Integer.valueOf(60), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/impl.clj" });
    const__39 = (Var)RT.var("plumbing.fnk.impl", "process-schematized-map");
    const__42 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "env"), Symbol.intern(null, "binding")) })), RT.keyword(null, "doc"), "Take an optional binding map like {a 2} or {a :- Number 2} and convert the schema\n   information to canonical metadata, if present.", RT.keyword(null, "line"), Integer.valueOf(63), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "plumbing/fnk/impl.clj" });
    const__43 = (Var)RT.var("plumbing.fnk.impl", "letk-arg-bind-sym-and-body-form");
    const__46 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "env"), Symbol.intern(null, "map-sym"), Symbol.intern(null, "binding"), Symbol.intern(null, "key-path"), Symbol.intern(null, "body-form")) })), RT.keyword(null, "doc"), "Given a single element of a single letk binding form and a current body form, return\n   a map {:schema-entry :body-form} where schema-entry is a tuple\n   [bound-key schema external-schema?], and body-form wraps body with destructuring\n   for this binding as necessary.", RT.keyword(null, "line"), Integer.valueOf(77), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/impl.clj" });
    const__47 = (Var)RT.var("plumbing.fnk.impl", "extract-special-args");
    const__50 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "env"), Symbol.intern(null, "special-arg-signifier-set"), Symbol.intern(null, "binding-form"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "pre"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "set?"), Symbol.intern(null, "special-arg-signifier-set") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(123), RT.keyword(null, "column"), Integer.valueOf(10) }))) })) })), RT.keyword(null, "doc"), "Extract trailing & sym and :as sym, possibly with schema metadata. Returns\n  [more-bindings special-args-map] where special-args-map is a map from each\n  special symbol found to the symbol that was found.", RT.keyword(null, "line"), Integer.valueOf(118), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "plumbing/fnk/impl.clj" });
    const__53 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "env"), Symbol.intern(null, "binding-form"), Symbol.intern(null, "key-path"), Symbol.intern(null, "body-form")) })), RT.keyword(null, "doc"), "Given a single letk binding form, value form, key path, and body\n   form, return a map {:input-schema :external-input-schema :map-sym :body-form}\n   where input-schema is the schema imposed by binding-form, external-input-schema\n   is like input-schema but includes user overrides for binding vectors,\n   map-sym is the symbol which it expects the bound value to be bound to,\n   and body-form wraps body in the bindings from binding-form from map-sym.", RT.keyword(null, "line"), Integer.valueOf(138), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/impl.clj" });
    const__54 = (Var)RT.var("plumbing.fnk.impl", "+none+");
    const__56 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(198), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/impl.clj", RT.keyword(null, "doc"), "A sentinel value used to indicate a non-provided optional value in a positional form." });
    const__57 = (Keyword)RT.keyword("plumbing.fnk.impl", "none");
    const__58 = (Var)RT.var("plumbing.fnk.impl", "positional-arg-bind-sym-and-body");
    const__61 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "env"), Symbol.intern(null, "binding"), Symbol.intern(null, "body-form")) })), RT.keyword(null, "doc"), "Given a single element of a fnk binding form and a current body form, return\n   a pair [[k bind-sym] new-body-form] where bind-sym is a suitable symbol to bind\n   to k in the fnk arglist (including tag metadata if applicable) and new-body-form\n   is wrapped with destructuring for this binding as necessary.", RT.keyword(null, "line"), Integer.valueOf(202), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/impl.clj" });
    const__62 = (Var)RT.var("plumbing.fnk.impl", "positional-arg-bind-syms-and-body");
    const__65 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "env"), Symbol.intern(null, "bind"), Symbol.intern(null, "body-form")) })), RT.keyword(null, "doc"), "Given a fnk binding form and body form, return a pair\n   [bind-sym-map new-body-form] where bind-sym-map is a map from keyword args\n   to binding symbols and and new-body-form wraps body to do any extra processing\n   of nested or optional bindings above and beyond the bindings achieved by\n   bind-sym-vector.", RT.keyword(null, "line"), Integer.valueOf(232), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/impl.clj" });
    const__66 = (Var)RT.var("plumbing.fnk.impl", "positional-info");
    const__69 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fnk")) })), RT.keyword(null, "doc"), "If fnk has a positional function implementation, return the pair\n   [positional-fn positional-arg-ks] such that if positional-arg-ks is [:a :b :c],\n   calling (positional-fn a b c) is equivalent to calling (fnk {:a a :b b :c c}),\n   but faster.  Optional values to fnk can be simulated by passing +none+ as the\n   value, i.e., (positional-fn +none+ b +none) is like (fnk {:b b}).", RT.keyword(null, "line"), Integer.valueOf(247), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/impl.clj" });
    const__70 = (Var)RT.var("plumbing.fnk.impl", "efficient-call-forms");
    const__73 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fnk"), Symbol.intern(null, "arg-form-map")) })), RT.keyword(null, "doc"), "Get [f arg-forms] that can be used to call a fnk most efficiently, using the\n   positional version if available, or otherwise the raw fnk.  arg-form-map\n   is a map from keywords representing arguments to fnk to *forms* that evaluate\n   to the corresponding arguments.\n\n   The basic idea is that (eval (cons f arg-forms)) would yield code for an\n   efficient call to fnk.  However, this form is not returned directly, because\n   in most cases the literal function f cannot be directly evaluated due to\n   a quirk in Clojure -- e.g., try (eval `(~(let [x 1] (fn [y] (+ y x))) 2)).\n\n   For examples of how this is used, see 'positional-fn' below, or the positional\n   compilation in plumbing.graph.positional.", RT.keyword(null, "line"), Integer.valueOf(256), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/impl.clj" });
    const__74 = (Var)RT.var("plumbing.fnk.impl", "positional-fn");
    const__77 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fnk"), Symbol.intern(null, "arg-ks")) })), RT.keyword(null, "doc"), "Given argument order in arg-ks, produce an ordinary fn that can be called\n   with arguments in this order. arg-ks must include all required keys of fnk.\n\n   Example: (= ((positional-fn a-fnk [:b :a]) [1 2]) (a-fnk {:a 2 :b 1}))\n\n   Can only be applied to fnks with a positional form, and should yield\n   a function that is significantly faster than calling fnk directly by\n   avoiding the construction and destructuring of the outer map.  Uses 'eval',\n   so while the produced function is fast, the actual production of the\n   positional-fn is generally relatively slow.", RT.keyword(null, "line"), Integer.valueOf(278), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/impl.clj" });
    const__78 = (Var)RT.var("plumbing.fnk.impl", "positional-fnk-form");
    const__81 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fn-name"), Symbol.intern(null, "external-input-schema"), Symbol.intern(null, "ordered-ks->opt"), Symbol.intern(null, "arg-sym-map"), Symbol.intern(null, "body"), Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Takes an optional name, input schema, seq of ordered [key optional?] pairs,\n   an arg-sym-map from these keywords to symbols, and and a positional fn body\n   that can reference these symbols.\n   Produces a form generating a IFn/PFnk that can be called as a keyword function,\n   and has metadata containing the positional function for efficient compilation\n   as described in 'efficient-call-forms' and 'positional-fn' above, with\n   argument order the same as in input-schema by default.   Example:\n\n   (def f (eval (i/positional-fnk-form 'foo {:x s/Any (s/optional-key :y) s/Any}\n                   [`(+ ~'x (if (= ~'y i/+none+) 5 ~'y))])))\n\n   (= [6 3] [(f {:x 1}) (f {:x 1 :y 2})])\n   (= [6 3] [((i/positional-fn f [:x]) 1) ((i/positional-fn f [:y :x]) 2 1)]).", RT.keyword(null, "line"), Integer.valueOf(310), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/impl.clj" });
    const__82 = (Var)RT.var("plumbing.fnk.impl", "fnk-form");
    const__85 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "env"), Symbol.intern(null, "name?"), Symbol.intern(null, "bind"), Symbol.intern(null, "body"), Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Take an optional name, binding form, and body for a fnk, and make an\n   IFn/PFnk for these arguments.\n\n   For efficiency, two different methods of generating fnk bodies are\n   used.  If the fnk takes a fixed set of arguments (i.e., no & or\n   :as), then a 'positional' version of the fnk that is called like an\n   ordinary Clojure fn (e.g., (f a b) rather than (f {:a a :b b}) is\n   generated as an implementation detail, and stored in metadata of\n   the actual keyword fnk (which is just a thin wrapper around the\n   positional version).  If '& or :as are used, no such positional\n   function is generated.", RT.keyword(null, "line"), Integer.valueOf(346), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/impl.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("plumbing.fnk.impl__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
