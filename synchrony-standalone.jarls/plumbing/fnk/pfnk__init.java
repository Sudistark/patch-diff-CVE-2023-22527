package plumbing.fnk;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class pfnk__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Keyword const__2;
  
  public static final AFn const__3;
  
  public static final AFn const__4;
  
  public static final Var const__5;
  
  public static final Object const__6;
  
  public static final Var const__7;
  
  public static final Var const__8;
  
  public static final Var const__9;
  
  public static final Var const__10;
  
  public static final ISeq const__11;
  
  public static final Var const__12;
  
  public static final Var const__13;
  
  public static final AFn const__17;
  
  public static final Keyword const__18;
  
  public static final AFn const__19;
  
  public static final Keyword const__20;
  
  public static final Keyword const__21;
  
  public static final Keyword const__22;
  
  public static final AFn const__23;
  
  public static final Keyword const__24;
  
  public static final Var const__25;
  
  public static final Var const__26;
  
  public static final Var const__27;
  
  public static final AFn const__28;
  
  public static final AFn const__29;
  
  public static final Keyword const__30;
  
  public static final Var const__31;
  
  public static final AFn const__32;
  
  public static final Var const__33;
  
  public static final AFn const__41;
  
  public static final Var const__42;
  
  public static final AFn const__45;
  
  public static final Var const__46;
  
  public static final Object const__47;
  
  public static final Var const__48;
  
  public static final AFn const__51;
  
  public static final Var const__52;
  
  public static final AFn const__55;
  
  public static final Var const__56;
  
  public static final AFn const__59;
  
  public static final Var const__60;
  
  public static final AFn const__63;
  
  public static final Var const__64;
  
  public static final AFn const__67;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new pfnk.fn__23305());
    const__33.setMeta((IPersistentMap)const__41);
    const__33.bindRoot(new pfnk.input());
    const__42.setMeta((IPersistentMap)const__45);
    const__42.bindRoot(new pfnk.output());
    const__48.setMeta((IPersistentMap)const__51);
    const__48.bindRoot(new pfnk.input_schema());
    const__52.setMeta((IPersistentMap)const__55);
    const__52.bindRoot(new pfnk.output_schema());
    const__56.setMeta((IPersistentMap)const__59);
    const__56.bindRoot(new pfnk.input_schema_keys());
    const__60.setMeta((IPersistentMap)const__63);
    const__60.bindRoot(new pfnk.fn__GT_fnk());
    const__64.setMeta((IPersistentMap)const__67);
    const__64.bindRoot(new pfnk.fnk_name());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "plumbing.fnk.pfnk")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Core protocol and helpers for schema.core to extract and attach\n   input and output schemas to fnks. This protocol says nothing about\n   how fnks are created, so users are free to create PFnks directly\n   using fn->fnk, or using custom binding syntax (of which 'fnk' et al\n   are one possible example)." }));
    const__2 = (Keyword)RT.keyword(null, "doc");
    const__3 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Core protocol and helpers for schema.core to extract and attach\n   input and output schemas to fnks. This protocol says nothing about\n   how fnks are created, so users are free to create PFnks directly\n   using fn->fnk, or using custom binding syntax (of which 'fnk' et al\n   are one possible example)." });
    const__4 = (AFn)Symbol.intern(null, "clojure.core");
    const__5 = (Var)RT.var("clojure.core", "*warn-on-reflection*");
    const__6 = RT.classForName("plumbing.fnk.pfnk.PFnk");
    const__7 = (Var)RT.var("clojure.core", "alter-meta!");
    const__8 = (Var)RT.var("plumbing.fnk.pfnk", "PFnk");
    const__9 = (Var)RT.var("clojure.core", "assoc");
    const__10 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__11 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "io-schemata")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a pair of [input-schema output-schema], as specified in plumbing.fnk.schema.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })) }));
    const__12 = (Var)RT.var("clojure.core", "alter-var-root");
    const__13 = (Var)RT.var("clojure.core", "merge");
    const__17 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "plumbing.fnk.pfnk.PFnk"), RT.keyword(null, "on-interface"), RT.classForName("plumbing.fnk.pfnk.PFnk"), RT.keyword(null, "doc"), "Protocol for keyword functions and their specifications, e.g., fnks and graphs." });
    const__18 = (Keyword)RT.keyword(null, "sigs");
    const__19 = (AFn)RT.map(new Object[] { RT.keyword(null, "io-schemata"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "io-schemata")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a pair of [input-schema output-schema], as specified in plumbing.fnk.schema.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return a pair of [input-schema output-schema], as specified in plumbing.fnk.schema." }) });
    const__20 = (Keyword)RT.keyword(null, "var");
    const__21 = (Keyword)RT.keyword(null, "method-map");
    const__22 = (Keyword)RT.keyword(null, "io-schemata");
    const__23 = (AFn)RT.map(new Object[] { RT.keyword(null, "io-schemata"), RT.keyword(null, "io-schemata") });
    const__24 = (Keyword)RT.keyword(null, "method-builders");
    const__25 = (Var)RT.var("clojure.core", "intern");
    const__26 = (Var)RT.var("clojure.core", "*ns*");
    const__27 = (Var)RT.var("clojure.core", "with-meta");
    const__28 = (AFn)((IObj)Symbol.intern(null, "io-schemata")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a pair of [input-schema output-schema], as specified in plumbing.fnk.schema.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__29 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "io-schemata")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a pair of [input-schema output-schema], as specified in plumbing.fnk.schema.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return a pair of [input-schema output-schema], as specified in plumbing.fnk.schema." });
    const__30 = (Keyword)RT.keyword(null, "protocol");
    const__31 = (Var)RT.var("clojure.core", "-reset-methods");
    const__32 = (AFn)Symbol.intern(null, "PFnk");
    const__33 = (Var)RT.var("plumbing.fnk.pfnk", "input");
    const__41 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "schema.core.FnSchema") }))) })), RT.keyword(null, "line"), Integer.valueOf(18), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/pfnk.clj" });
    const__42 = (Var)RT.var("plumbing.fnk.pfnk", "output");
    const__45 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "schema.core.FnSchema") }))) })), RT.keyword(null, "line"), Integer.valueOf(27), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/pfnk.clj" });
    const__46 = (Var)RT.var("clojure.core", "extend");
    const__47 = RT.classForName("clojure.lang.Fn");
    const__48 = (Var)RT.var("plumbing.fnk.pfnk", "input-schema");
    const__51 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pfnk")) })), RT.keyword(null, "line"), Integer.valueOf(36), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/pfnk.clj" });
    const__52 = (Var)RT.var("plumbing.fnk.pfnk", "output-schema");
    const__55 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pfnk")) })), RT.keyword(null, "line"), Integer.valueOf(39), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/pfnk.clj" });
    const__56 = (Var)RT.var("plumbing.fnk.pfnk", "input-schema-keys");
    const__59 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")) })), RT.keyword(null, "line"), Integer.valueOf(42), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/pfnk.clj" });
    const__60 = (Var)RT.var("plumbing.fnk.pfnk", "fn->fnk");
    const__63 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "io")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "name"), Tuple.create(Symbol.intern(null, "input-schema"), Symbol.intern(null, "output-schema"), RT.keyword(null, "as"), Symbol.intern(null, "io"))) })), RT.keyword(null, "doc"), "Make a keyword function into a PFnk, by associating input and output schema metadata.", RT.keyword(null, "line"), Integer.valueOf(45), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/pfnk.clj" });
    const__64 = (Var)RT.var("plumbing.fnk.pfnk", "fnk-name");
    const__67 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Get the name of a fnk, if named", RT.keyword(null, "line"), Integer.valueOf(51), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/pfnk.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("plumbing.fnk.pfnk__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
