package plumbing.fnk;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class schema__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__3;
  
  public static final AFn const__4;
  
  public static final Var const__5;
  
  public static final AFn const__11;
  
  public static final Var const__12;
  
  public static final Var const__13;
  
  public static final Var const__14;
  
  public static final Keyword const__15;
  
  public static final AFn const__16;
  
  public static final Keyword const__17;
  
  public static final Var const__18;
  
  public static final AFn const__20;
  
  public static final Var const__21;
  
  public static final Var const__22;
  
  public static final Var const__23;
  
  public static final Object const__24;
  
  public static final Var const__25;
  
  public static final AFn const__27;
  
  public static final Var const__28;
  
  public static final AFn const__30;
  
  public static final Var const__31;
  
  public static final AFn const__32;
  
  public static final AFn const__33;
  
  public static final Var const__34;
  
  public static final AFn const__36;
  
  public static final Var const__37;
  
  public static final AFn const__39;
  
  public static final Var const__40;
  
  public static final AFn const__42;
  
  public static final AFn const__43;
  
  public static final AFn const__44;
  
  public static final Var const__45;
  
  public static final AFn const__49;
  
  public static final Var const__50;
  
  public static final AFn const__53;
  
  public static final Var const__54;
  
  public static final AFn const__57;
  
  public static final Var const__58;
  
  public static final AFn const__61;
  
  public static final Var const__62;
  
  public static final AFn const__65;
  
  public static final Var const__66;
  
  public static final AFn const__69;
  
  public static final Var const__70;
  
  public static final AFn const__74;
  
  public static final Var const__75;
  
  public static final AFn const__78;
  
  public static final Var const__79;
  
  public static final AFn const__82;
  
  public static final Var const__83;
  
  public static final AFn const__86;
  
  public static final Var const__87;
  
  public static final AFn const__90;
  
  public static final Var const__91;
  
  public static final AFn const__94;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new schema.fn__22911());
    const__5.setMeta((IPersistentMap)const__11);
    const__5



















      
      .bindRoot(((IFn)const__12.getRawRoot()).invoke(((IFn)const__13.getRawRoot()).invoke(const__14.getRawRoot()), RT.mapUniqueKeys(new Object[] { const__15, const__16, const__17, new schema.fn__22913() })));
    const__18.setMeta((IPersistentMap)const__20);
    const__18
      .bindRoot(RT.mapUniqueKeys(new Object[] { ((IFn)const__21.getRawRoot()).invoke(((IFn)const__22.getRawRoot()).invoke(const__23.getRawRoot()), const__24, const__23.getRawRoot()), const__5.getRawRoot() }));
    const__25.setMeta((IPersistentMap)const__27);
    const__25.bindRoot(const__5.getRawRoot());
    const__28.setMeta((IPersistentMap)const__30);
    const__28
      
      .bindRoot(Tuple.create(((IFn)const__31.getRawRoot()).invoke(const__18.getRawRoot(), const__32), ((IFn)const__31.getRawRoot()).invoke(const__25.getRawRoot(), const__33)));
    const__34.setMeta((IPersistentMap)const__36);
    const__34
      
      .bindRoot(RT.mapUniqueKeys(new Object[] { ((IFn)const__21.getRawRoot()).invoke(const__24, const__23.getRawRoot()), const__5.getRawRoot() }));
    const__37.setMeta((IPersistentMap)const__39);
    const__37.bindRoot(RT.mapUniqueKeys(new Object[] { const__23.getRawRoot(), const__5.getRawRoot() }));
    const__40.setMeta((IPersistentMap)const__42);
    const__40
      
      .bindRoot(Tuple.create(((IFn)const__31.getRawRoot()).invoke(const__34.getRawRoot(), const__43), ((IFn)const__31.getRawRoot()).invoke(const__37.getRawRoot(), const__44)));
    const__45.setMeta((IPersistentMap)const__49);
    const__45.bindRoot(new schema.assert_iae());
    ((Var)const__45)


      
      .setMacro();
    const__50.setMeta((IPersistentMap)const__53);
    const__50.bindRoot(new schema.assert_distinct());
    const__54.setMeta((IPersistentMap)const__57);
    const__54.bindRoot(new schema.safe_get());
    const__58.setMeta((IPersistentMap)const__61);
    const__58.bindRoot(new schema.non_map_union());
    const__62.setMeta((IPersistentMap)const__65);
    const__62.bindRoot(new schema.non_map_diff());
    const__66.setMeta((IPersistentMap)const__69);
    const__66.bindRoot(new schema.map_schema_QMARK_());
    const__70.setMeta((IPersistentMap)const__74);
    const__70.bindRoot(new schema.merge_on_with());
    const__75.setMeta((IPersistentMap)const__78);
    const__75.bindRoot(new schema.guess_expr_output_schema());
    const__79.setMeta((IPersistentMap)const__82);
    const__79.bindRoot(new schema.schema_diff());
    const__83.setMeta((IPersistentMap)const__86);
    const__83.bindRoot(new schema.assert_satisfies_schema());
    const__87.setMeta((IPersistentMap)const__90);
    const__87.bindRoot(new schema.schema_key());
    const__91.setMeta((IPersistentMap)const__94);
    const__91.bindRoot(new schema.possibly_contains_QMARK_());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "plumbing.fnk.schema")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "A very simple type system for a subset of schemas consisting of nested\n   maps with optional or required keyword keys; used by fnk and kin.\n\n   Since schemas are turing-complete and not really designed for type inference,\n   (and for simplicity) we err on the side of completeness (allowing all legal programs)\n   at the cost of soundness.\n\n   These operations also bake in some logic specific to reasoning about Graphs,\n   namely that all input keys to a node must be explicitly mentioned as optional or\n   required, or provided via `instance`, and will thus deliberately drop extra key\n   schemas on inputs as appropriate.  Output schemas may not have optional keys." }));
    const__3 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "A very simple type system for a subset of schemas consisting of nested\n   maps with optional or required keyword keys; used by fnk and kin.\n\n   Since schemas are turing-complete and not really designed for type inference,\n   (and for simplicity) we err on the side of completeness (allowing all legal programs)\n   at the cost of soundness.\n\n   These operations also bake in some logic specific to reasoning about Graphs,\n   namely that all input keys to a node must be explicitly mentioned as optional or\n   required, or provided via `instance`, and will thus deliberately drop extra key\n   schemas on inputs as appropriate.  Output schemas may not have optional keys." });
    const__4 = (AFn)Symbol.intern(null, "clojure.core");
    const__5 = (Var)RT.var("plumbing.fnk.schema", "Schema");
    const__11 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(22), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/schema.clj" });
    const__12 = (Var)RT.var("clojure.core", "with-meta");
    const__13 = (Var)RT.var("schema.core", "->Protocol");
    const__14 = (Var)RT.var("schema.core", "Schema");
    const__15 = (Keyword)RT.keyword(null, "proto-sym");
    const__16 = (AFn)Symbol.intern("s", "Schema");
    const__17 = (Keyword)RT.keyword(null, "proto-pred");
    const__18 = (Var)RT.var("plumbing.fnk.schema", "InputSchema");
    const__20 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(23), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/schema.clj" });
    const__21 = (Var)RT.var("schema.core", "cond-pre");
    const__22 = (Var)RT.var("schema.core", "eq");
    const__23 = (Var)RT.var("schema.core", "Keyword");
    const__24 = RT.classForName("schema.core.OptionalKey");
    const__25 = (Var)RT.var("plumbing.fnk.schema", "OutputSchema");
    const__27 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(24), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/schema.clj" });
    const__28 = (Var)RT.var("plumbing.fnk.schema", "IOSchemata");
    const__30 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(25), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/schema.clj" });
    const__31 = (Var)RT.var("schema.core", "one");
    const__32 = (AFn)Symbol.intern(null, "input");
    const__33 = (AFn)Symbol.intern(null, "output");
    const__34 = (Var)RT.var("plumbing.fnk.schema", "GraphInputSchema");
    const__36 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(27), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/schema.clj" });
    const__37 = (Var)RT.var("plumbing.fnk.schema", "MapOutputSchema");
    const__39 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(28), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/schema.clj" });
    const__40 = (Var)RT.var("plumbing.fnk.schema", "GraphIOSchemata");
    const__42 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(29), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/schema.clj" });
    const__43 = (AFn)Symbol.intern(null, "input");
    const__44 = (AFn)Symbol.intern(null, "output");
    const__45 = (Var)RT.var("plumbing.fnk.schema", "assert-iae");
    const__49 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "&"), Symbol.intern(null, "format-args")) })), RT.keyword(null, "doc"), "Like assert, but throws a RuntimeException in Clojure (not an AssertionError),\n   and also takes args to format.", RT.keyword(null, "line"), Integer.valueOf(33), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/schema.clj" });
    const__50 = (Var)RT.var("plumbing.fnk.schema", "assert-distinct");
    const__53 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "things")) })), RT.keyword(null, "doc"), "Like (assert (distinct? things)) but with a more helpful error message.", RT.keyword(null, "line"), Integer.valueOf(39), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/schema.clj" });
    const__54 = (Var)RT.var("plumbing.fnk.schema", "safe-get");
    const__57 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "k"), Symbol.intern(null, "key-path")) })), RT.keyword(null, "doc"), "Like (get m k), but throws if k is not present in m.", RT.keyword(null, "line"), Integer.valueOf(48), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/schema.clj" });
    const__58 = (Var)RT.var("plumbing.fnk.schema", "non-map-union");
    const__61 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s1"), Symbol.intern(null, "s2")) })), RT.keyword(null, "line"), Integer.valueOf(60), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/schema.clj" });
    const__62 = (Var)RT.var("plumbing.fnk.schema", "non-map-diff");
    const__65 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s1"), Symbol.intern(null, "s2")) })), RT.keyword(null, "doc"), "Return a difference of schmas s1 and s2, where one is not a map.\n   Punt for now, assuming s2 always satisfies s1.", RT.keyword(null, "line"), Integer.valueOf(66), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/schema.clj" });
    const__66 = (Var)RT.var("plumbing.fnk.schema", "map-schema?");
    const__69 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })), RT.keyword(null, "line"), Integer.valueOf(72), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/schema.clj" });
    const__70 = (Var)RT.var("plumbing.fnk.schema", "merge-on-with");
    const__74 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "key-project"), Symbol.intern(null, "key-combine"), Symbol.intern(null, "val-combine"), Symbol.intern(null, "&"), Symbol.intern(null, "maps")) })), RT.keyword(null, "doc"), "Like merge-with, but also projects keys to a smaller space and merges them similar to the\n   values.", RT.keyword(null, "line"), Integer.valueOf(111), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "plumbing/fnk/schema.clj" });
    const__75 = (Var)RT.var("plumbing.fnk.schema", "guess-expr-output-schema");
    const__78 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "expr")) })), RT.keyword(null, "doc"), "Guess an output schema for an expr.  Currently just looks for literal map structure and\n   all keyword keys.", RT.keyword(null, "line"), Integer.valueOf(157), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/schema.clj" });
    const__79 = (Var)RT.var("plumbing.fnk.schema", "schema-diff");
    const__82 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "input-schema"), Symbol.intern(null, "output-schema")) })), RT.keyword(null, "doc"), "Subtract output-schema from input-schema, returning nil if it's possible that an object\n   satisfying the output-schema satisfies the input-schema, or otherwise a description\n   of the part(s) of input-schema not met by output-schema.  Strict about the map structure\n   of output-schema matching input-schema, but loose about everything else (only looks at\n   required keys of output-schema.", RT.keyword(null, "line"), Integer.valueOf(168), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/schema.clj" });
    const__83 = (Var)RT.var("plumbing.fnk.schema", "assert-satisfies-schema");
    const__86 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "input-schema"), Symbol.intern(null, "output-schema")) })), RT.keyword(null, "line"), Integer.valueOf(196), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/schema.clj" });
    const__87 = (Var)RT.var("plumbing.fnk.schema", "schema-key");
    const__90 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "k")) })), RT.keyword(null, "line"), Integer.valueOf(210), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/schema.clj" });
    const__91 = (Var)RT.var("plumbing.fnk.schema", "possibly-contains?");
    const__94 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "k")) })), RT.keyword(null, "line"), Integer.valueOf(219), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "plumbing/fnk/schema.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("plumbing.fnk.schema__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
