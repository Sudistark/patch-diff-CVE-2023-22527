package manifold;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class stream__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Keyword const__3;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final Var const__7;
  
  public static final AFn const__8;
  
  public static final Var const__9;
  
  public static final Keyword const__10;
  
  public static final Keyword const__12;
  
  public static final Keyword const__14;
  
  public static final Object const__15;
  
  public static final Keyword const__16;
  
  public static final AFn const__17;
  
  public static final Var const__18;
  
  public static final AFn const__21;
  
  public static final Var const__22;
  
  public static final AFn const__25;
  
  public static final Var const__26;
  
  public static final AFn const__29;
  
  public static final Var const__30;
  
  public static final AFn const__33;
  
  public static final Var const__34;
  
  public static final AFn const__37;
  
  public static final Var const__38;
  
  public static final Var const__39;
  
  public static final Keyword const__40;
  
  public static final Var const__41;
  
  public static final AFn const__44;
  
  public static final Var const__45;
  
  public static final AFn const__48;
  
  public static final Var const__49;
  
  public static final AFn const__52;
  
  public static final Var const__53;
  
  public static final AFn const__56;
  
  public static final Var const__57;
  
  public static final AFn const__60;
  
  public static final Var const__61;
  
  public static final AFn const__64;
  
  public static final Var const__65;
  
  public static final AFn const__68;
  
  public static final Var const__69;
  
  public static final AFn const__72;
  
  public static final Var const__73;
  
  public static final AFn const__76;
  
  public static final Var const__77;
  
  public static final AFn const__80;
  
  public static final Var const__81;
  
  public static final AFn const__84;
  
  public static final Var const__85;
  
  public static final AFn const__88;
  
  public static final Var const__89;
  
  public static final Object const__90;
  
  public static final Object const__91;
  
  public static final Var const__92;
  
  public static final AFn const__95;
  
  public static final Var const__96;
  
  public static final Object const__97;
  
  public static final Object const__98;
  
  public static final Var const__99;
  
  public static final Object const__100;
  
  public static final Object const__101;
  
  public static final Var const__102;
  
  public static final Object const__103;
  
  public static final Object const__104;
  
  public static final AFn const__105;
  
  public static final AFn const__108;
  
  public static final Var const__109;
  
  public static final AFn const__112;
  
  public static final Var const__113;
  
  public static final AFn const__116;
  
  public static final Var const__117;
  
  public static final AFn const__120;
  
  public static final Var const__121;
  
  public static final AFn const__124;
  
  public static final Var const__125;
  
  public static final AFn const__128;
  
  public static final Var const__129;
  
  public static final Keyword const__130;
  
  public static final AFn const__133;
  
  public static final Var const__134;
  
  public static final AFn const__137;
  
  public static final Var const__138;
  
  public static final AFn const__141;
  
  public static final Var const__142;
  
  public static final AFn const__145;
  
  public static final Var const__146;
  
  public static final AFn const__149;
  
  public static final Var const__150;
  
  public static final AFn const__152;
  
  public static final Var const__153;
  
  public static final AFn const__156;
  
  public static final Var const__157;
  
  public static final AFn const__160;
  
  public static final Var const__161;
  
  public static final AFn const__164;
  
  public static final Var const__165;
  
  public static final AFn const__168;
  
  public static final Var const__169;
  
  public static final AFn const__172;
  
  public static final Var const__173;
  
  public static final AFn const__176;
  
  public static final Var const__177;
  
  public static final AFn const__180;
  
  public static final Var const__181;
  
  public static final AFn const__184;
  
  public static final Var const__185;
  
  public static final AFn const__188;
  
  public static final Var const__189;
  
  public static final AFn const__192;
  
  public static final Var const__193;
  
  public static final AFn const__196;
  
  public static final Var const__197;
  
  public static final AFn const__200;
  
  public static final Var const__201;
  
  public static final AFn const__204;
  
  public static final Var const__205;
  
  public static final AFn const__209;
  
  public static final Var const__210;
  
  public static final AFn const__213;
  
  public static final Var const__214;
  
  public static final Var const__215;
  
  public static final Var const__216;
  
  public static final Var const__217;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new stream.fn__16216());
    const__9.setMeta((IPersistentMap)const__17);
    const__9.bindRoot(new stream.__GT_sink());
    const__18.setMeta((IPersistentMap)const__21);
    const__18.bindRoot(new stream.__GT_source());
    const__22.setMeta((IPersistentMap)const__25);
    const__26.setMeta((IPersistentMap)const__29);
    const__26.bindRoot(new stream.source_only());
    const__30.setMeta((IPersistentMap)const__33);
    const__30.bindRoot(new stream.sink_only());
    const__34.setMeta((IPersistentMap)const__37);
    const__34.bindRoot(new stream.onto());
    const__41.setMeta((IPersistentMap)const__44);
    const__41.bindRoot(new stream.stream_QMARK_());
    const__45.setMeta((IPersistentMap)const__48);
    const__45.bindRoot(new stream.source_QMARK_());
    const__49.setMeta((IPersistentMap)const__52);
    const__49.bindRoot(new stream.sink_QMARK_());
    const__53.setMeta((IPersistentMap)const__56);
    const__53.bindRoot(new stream.description());
    const__57.setMeta((IPersistentMap)const__60);
    const__57.bindRoot(new stream.downstream());
    const__61.setMeta((IPersistentMap)const__64);
    const__61.bindRoot(new stream.weak_handle());
    const__65.setMeta((IPersistentMap)const__68);
    const__65.bindRoot(new stream.synchronous_QMARK_());
    const__69.setMeta((IPersistentMap)const__72);
    const__69.bindRoot(new stream.close_BANG_());
    const__73.setMeta((IPersistentMap)const__76);
    const__73.bindRoot(new stream.closed_QMARK_());
    const__77.setMeta((IPersistentMap)const__80);
    const__77.bindRoot(new stream.on_closed());
    const__81.setMeta((IPersistentMap)const__84);
    const__81.bindRoot(new stream.drained_QMARK_());
    const__85.setMeta((IPersistentMap)const__88);
    const__85.bindRoot(new stream.on_drained());
    const__89.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__10, const__90, const__3, "Puts a value into a sink, returning a deferred that yields `true` if it succeeds,\n   and `false` if it fails.  Guaranteed to be non-blocking.", const__40, new stream.put_BANG___inliner__16763(), const__12, const__91, const__14, const__15, 
            const__16, "manifold/stream.clj" }));
    const__89.bindRoot(new stream.put_BANG_());
    const__92.setMeta((IPersistentMap)const__95);
    const__92.bindRoot(new stream.put_all_BANG_());
    const__96.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__10, const__97, const__3, "Puts a value into a stream if the put can successfully be completed in `timeout`\n   milliseconds.  Returns a promise that yields `true` if it succeeds, and `false`\n   if it fails or times out.  Guaranteed to be non-blocking.\n\n   A special `timeout-val` may be specified, if it is important to differentiate\n   between failure due to timeout and other failures.", const__40, new stream.try_put_BANG___inliner__16784(), const__12, const__98, const__14, const__15, 
            const__16, "manifold/stream.clj" }));
    const__96.bindRoot(new stream.try_put_BANG_());
    const__99.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__10, const__100, const__3, "Takes a value from a stream, returning a deferred that yields the value when it\n   is available, or `nil` if the take fails.  Guaranteed to be non-blocking.\n\n   A special `default-val` may be specified, if it is important to differentiate\n   between actual `nil` values and failures.", const__40, new stream.take_BANG___inliner__16787(), const__12, const__101, const__14, const__15, 
            const__16, "manifold/stream.clj" }));
    const__99.bindRoot(new stream.take_BANG_());
    const__102.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__10, const__103, const__3, "Takes a value from a stream, returning a deferred that yields the value if it is\n   available within `timeout` milliseconds, or `nil` if it fails or times out.\n   Guaranteed to be non-blocking.\n\n   Special `timeout-val` and `default-val` values may be specified, if it is\n   important to differentiate between actual `nil` values and timeouts/failures.", const__40, new stream.try_take_BANG___inliner__16790(), const__12, const__104, const__14, const__15, 
            const__16, "manifold/stream.clj" }));
    const__102.bindRoot(new stream.try_take_BANG_());
    const__22.setMeta((IPersistentMap)const__108);
    const__22.bindRoot(new stream.connect());
    const__109.setMeta((IPersistentMap)const__112);
    const__109.bindRoot(new stream.stream());
    const__113.setMeta((IPersistentMap)const__116);
    const__113.bindRoot(new stream.stream_STAR_());
    const__117.setMeta((IPersistentMap)const__120);
    const__117.bindRoot(new stream.splice());
    const__121.setMeta((IPersistentMap)const__124);
    const__121.bindRoot(new stream.consume_async());
    const__125.setMeta((IPersistentMap)const__128);
    const__125.bindRoot(new stream.connect_via());
    const__129.setMeta((IPersistentMap)const__133);
    const__129.bindRoot(new stream.connect_via_proxy());
    const__134.setMeta((IPersistentMap)const__137);
    const__134.bindRoot(new stream.drain_into());
    const__138.setMeta((IPersistentMap)const__141);
    const__138.bindRoot(new stream.stream__GT_seq());
    const__142.setMeta((IPersistentMap)const__145);
    const__142.bindRoot(new stream.periodically_());
    const__146.setMeta((IPersistentMap)const__149);
    const__146.bindRoot(new stream.periodically());
    const__150.setMeta((IPersistentMap)const__152);
    const__153.setMeta((IPersistentMap)const__156);
    const__153.bindRoot(new stream.transform());
    const__157.setMeta((IPersistentMap)const__160);
    const__157.bindRoot(new stream.map());
    const__161.setMeta((IPersistentMap)const__164);
    const__161.bindRoot(new stream.realize_each());
    const__165.setMeta((IPersistentMap)const__168);
    const__165.bindRoot(new stream.filter());
    const__169.setMeta((IPersistentMap)const__172);
    const__169.bindRoot(new stream.reductions());
    const__173.setMeta((IPersistentMap)const__176);
    const__173.bindRoot(new stream.reduce());
    const__177.setMeta((IPersistentMap)const__180);
    const__177.bindRoot(new stream.mapcat());
    const__181.setMeta((IPersistentMap)const__184);
    const__181.bindRoot(new stream.lazily_partition_by());
    const__185.setMeta((IPersistentMap)const__188);
    const__185.bindRoot(new stream.concat());
    const__189.setMeta((IPersistentMap)const__192);
    const__189.bindRoot(new stream.buffered_stream());
    const__193.setMeta((IPersistentMap)const__196);
    const__193.bindRoot(new stream.buffer());
    const__197.setMeta((IPersistentMap)const__200);
    const__197.bindRoot(new stream.batch());
    const__201.setMeta((IPersistentMap)const__204);
    const__201.bindRoot(new stream.throttle());
    const__205.setMeta((IPersistentMap)const__209);
    const__205.bindRoot(new stream.dropping_stream());
    const__210.setMeta((IPersistentMap)const__213);
    const__210.bindRoot(new stream.sliding_stream());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "manifold.stream")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "author"), "Zach Tellman", RT.keyword(null, "doc"), "Methods for creating, transforming, and interacting with asynchronous streams of values." }));
    const__3 = (Keyword)RT.keyword(null, "doc");
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "author"), "Zach Tellman", RT.keyword(null, "doc"), "Methods for creating, transforming, and interacting with asynchronous streams of values." });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.core", "*unchecked-math*");
    const__7 = (Var)RT.var("clojure.core", "require");
    const__8 = (AFn)Symbol.intern(null, "manifold.stream.async");
    const__9 = (Var)RT.var("manifold.stream", "->sink");
    const__10 = (Keyword)RT.keyword(null, "arglists");
    const__12 = (Keyword)RT.keyword(null, "line");
    const__14 = (Keyword)RT.keyword(null, "column");
    const__15 = Integer.valueOf(1);
    const__16 = (Keyword)RT.keyword(null, "file");
    const__17 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "default-val")) })), RT.keyword(null, "doc"), "Converts, if possible, the object to a Manifold sink, or `default-val` if it cannot.  If no\n   default value is given, an `IllegalArgumentException` is thrown.", RT.keyword(null, "line"), Integer.valueOf(61), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__18 = (Var)RT.var("manifold.stream", "->source");
    const__21 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "default-val")) })), RT.keyword(null, "doc"), "Converts, if possible, the object to a Manifold source, or `default-val` if it cannot.  If no\n   default value is given, an `IllegalArgumentException` is thrown.", RT.keyword(null, "line"), Integer.valueOf(77), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__22 = (Var)RT.var("manifold.stream", "connect");
    const__25 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(115), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__26 = (Var)RT.var("manifold.stream", "source-only");
    const__29 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Returns a view of the stream which is only a source.", RT.keyword(null, "line"), Integer.valueOf(142), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__30 = (Var)RT.var("manifold.stream", "sink-only");
    const__33 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Returns a view of the stream which is only a sink.", RT.keyword(null, "line"), Integer.valueOf(147), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__34 = (Var)RT.var("manifold.stream", "onto");
    const__37 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "executor"), Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Returns an identical stream whose deferred callbacks will be executed\n   on `executor`.", RT.keyword(null, "line"), Integer.valueOf(152), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__38 = (Var)RT.var("clojure.core", "alter-meta!");
    const__39 = (Var)RT.var("clojure.core", "assoc");
    const__40 = (Keyword)RT.keyword(null, "inline");
    const__41 = (Var)RT.var("manifold.stream", "stream?");
    const__44 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if the object is a Manifold stream.", RT.keyword(null, "line"), Integer.valueOf(160), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__45 = (Var)RT.var("manifold.stream", "source?");
    const__48 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if the object is a Manifold source.", RT.keyword(null, "line"), Integer.valueOf(165), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__49 = (Var)RT.var("manifold.stream", "sink?");
    const__52 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if the object is a Manifold sink.", RT.keyword(null, "line"), Integer.valueOf(170), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__53 = (Var)RT.var("manifold.stream", "description");
    const__56 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns a description of the stream.", RT.keyword(null, "line"), Integer.valueOf(175), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__57 = (Var)RT.var("manifold.stream", "downstream");
    const__60 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns all sinks downstream of the given source as a sequence of 2-tuples, with the\n   first element containing the connection's description, and the second element containing\n   the sink.", RT.keyword(null, "line"), Integer.valueOf(180), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__61 = (Var)RT.var("manifold.stream", "weak-handle");
    const__64 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns a weak reference that can be used to construct topologies of streams.", RT.keyword(null, "line"), Integer.valueOf(187), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__65 = (Var)RT.var("manifold.stream", "synchronous?");
    const__68 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if the underlying abstraction behaves synchronously, using thread blocking\n   to provide backpressure.", RT.keyword(null, "line"), Integer.valueOf(192), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__69 = (Var)RT.var("manifold.stream", "close!");
    const__72 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sink")) })), RT.keyword(null, "doc"), "Closes a source or sink, so that it can't emit or accept any more messages.", RT.keyword(null, "line"), Integer.valueOf(198), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__73 = (Var)RT.var("manifold.stream", "closed?");
    const__76 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sink")) })), RT.keyword(null, "doc"), "Returns true if the event sink is closed.", RT.keyword(null, "line"), Integer.valueOf(203), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__77 = (Var)RT.var("manifold.stream", "on-closed");
    const__80 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sink"), Symbol.intern(null, "callback")) })), RT.keyword(null, "doc"), "Registers a no-arg callback which is invoked when the sink is closed.", RT.keyword(null, "line"), Integer.valueOf(208), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__81 = (Var)RT.var("manifold.stream", "drained?");
    const__84 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "source")) })), RT.keyword(null, "doc"), "Returns true if the event source is drained.", RT.keyword(null, "line"), Integer.valueOf(213), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__85 = (Var)RT.var("manifold.stream", "on-drained");
    const__88 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "source"), Symbol.intern(null, "callback")) })), RT.keyword(null, "doc"), "Registers a no-arg callback which is invoked when the source is drained.", RT.keyword(null, "line"), Integer.valueOf(218), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__89 = (Var)RT.var("manifold.stream", "put!");
    const__90 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "sink")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IEventSink") })), Symbol.intern(null, "x")) }));
    const__91 = Integer.valueOf(223);
    const__92 = (Var)RT.var("manifold.stream", "put-all!");
    const__95 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "sink")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IEventSink") })), Symbol.intern(null, "msgs")) })), RT.keyword(null, "doc"), "Puts all values into the sink, returning a deferred that yields `true` if all puts\n   are successful, or `false` otherwise.  If the sink provides backpressure, will\n   pause. Guaranteed to be non-blocking.", RT.keyword(null, "line"), Integer.valueOf(231), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__96 = (Var)RT.var("manifold.stream", "try-put!");
    const__97 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "sink")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IEventSink") })), Symbol.intern(null, "x"), ((IObj)Symbol.intern(null, "timeout")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "double") }))), Tuple.create(((IObj)Symbol.intern(null, "sink")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IEventSink") })), Symbol.intern(null, "x"), ((IObj)Symbol.intern(null, "timeout")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "double") })), Symbol.intern(null, "timeout-val")) }));
    const__98 = Integer.valueOf(245);
    const__99 = (Var)RT.var("manifold.stream", "take!");
  }
  
  public static void __init1() {
    const__100 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "source")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IEventSource") }))), Tuple.create(((IObj)Symbol.intern(null, "source")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IEventSource") })), Symbol.intern(null, "default-val")) }));
    const__101 = Integer.valueOf(262);
    const__102 = (Var)RT.var("manifold.stream", "try-take!");
    const__103 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "source")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IEventSource") })), ((IObj)Symbol.intern(null, "timeout")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "double") }))), Tuple.create(((IObj)Symbol.intern(null, "source")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IEventSource") })), Symbol.intern(null, "default-val"), ((IObj)Symbol.intern(null, "timeout")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "double") })), Symbol.intern(null, "timeout-val")) }));
    const__104 = Integer.valueOf(278);
    const__105 = (AFn)Tuple.create(Symbol.intern(null, "manifold.stream.graph"));
    const__108 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), Tuple.create(Tuple.create(Symbol.intern(null, "source"), Symbol.intern(null, "sink")), Tuple.create(Symbol.intern(null, "source"), Symbol.intern(null, "sink"), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "upstream?"), Symbol.intern(null, "downstream?"), Symbol.intern(null, "timeout"), Symbol.intern(null, "description")), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "upstream?"), Boolean.FALSE, Symbol.intern(null, "downstream?"), Boolean.TRUE }) }))), RT.keyword(null, "doc"), "Connects a source to a sink, propagating all messages from the former into the latter.\n\n   Optionally takes a map of parameters:\n\n   |:---|:---\n   | `upstream?` | if closing the sink should always close the source, even if there are other sinks downstream of the source.  Defaults to `false`.  Note that if the sink is the only thing downstream of the source, the source will always be closed, unless it is permanent.\n   | `downstream?` | if closing the source will close the sink.  Defaults to `true`.\n   | `timeout` | if defined, the maximum time, in milliseconds, that will be spent trying to put a message into the sink before closing it.  Useful when there are multiple sinks downstream of a source, and you want to avoid a single backed up sink from blocking all the others.\n   | `description` | describes the connection, useful for traversing the stream topology via `downstream`.", RT.keyword(null, "line"), Integer.valueOf(299), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__109 = (Var)RT.var("manifold.stream", "stream");
    const__112 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "buffer-size")), Tuple.create(Symbol.intern(null, "buffer-size"), Symbol.intern(null, "xform")), Tuple.create(Symbol.intern(null, "buffer-size"), Symbol.intern(null, "xform"), Symbol.intern(null, "executor")) })), RT.keyword(null, "doc"), "Returns a Manifold stream with a configurable `buffer-size`.  If a capacity is specified,\n   `put!` will yield `true` when the message is in the buffer.  Otherwise it will only yield\n   `true` once it has been consumed.\n\n   `xform` is an optional transducer, which will transform all messages that are enqueued\n   via `put!` before they are dequeued via `take!`.\n\n   `executor`, if defined, specifies which java.util.concurrent.Executor will be used to\n   handle the deferreds returned by `put!` and `take!`.", RT.keyword(null, "line"), Integer.valueOf(334), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__113 = (Var)RT.var("manifold.stream", "stream*");
    const__116 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), Tuple.create(Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "permanent?"), Symbol.intern(null, "buffer-size"), Symbol.intern(null, "description"), Symbol.intern(null, "executor"), Symbol.intern(null, "xform")) }))), RT.keyword(null, "doc"), "An alternate way to build a stream, via a map of parameters.\n\n   |:---|:---\n   | `permanent?` | if `true`, the channel cannot be closed\n   | `buffer-size` | the number of messages that can accumulate in the channel before backpressure is applied\n   | `description` | the description of the channel, which is a single arg function that takes the base properties and returns an enriched map.\n   | `executor` | the `java.util.concurrent.Executor` that will execute all callbacks registered on the deferreds returns by `put!` and `take!`\n   | `xform` | a transducer which will transform all messages that are enqueued via `put!` before they are dequeued via `take!`.", RT.keyword(null, "line"), Integer.valueOf(353), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__117 = (Var)RT.var("manifold.stream", "splice");
    const__120 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sink"), Symbol.intern(null, "source")) })), RT.keyword(null, "doc"), "Splices together two halves of a stream, such that all messages enqueued via `put!` go\n   into `sink`, and all messages dequeued via `take!` come from `source`.", RT.keyword(null, "line"), Integer.valueOf(422), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__121 = (Var)RT.var("manifold.stream", "consume-async");
    const__124 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "callback"), Symbol.intern(null, "source")) })), RT.keyword(null, "doc"), "Feeds all messages from `source` into `callback`, which must return a deferred yielding\n   `true` or `false`.  If the returned value yields `false`, the consumption will be cancelled.\n\n   Messages will be processed only as quickly as the deferred values are realized. Returns a\n   deferred which yields `true` when `source` is exhausted or `callback` yields `false`.", RT.keyword(null, "line"), Integer.valueOf(482), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__125 = (Var)RT.var("manifold.stream", "connect-via");
    const__128 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "src"), Symbol.intern(null, "callback"), Symbol.intern(null, "dst")), Tuple.create(Symbol.intern(null, "src"), Symbol.intern(null, "callback"), Symbol.intern(null, "dst"), Symbol.intern(null, "options")) })), RT.keyword(null, "doc"), "Feeds all messages from `src` into `callback`, with the understanding that they will\n   eventually be propagated into `dst` in some form.  The return value of `callback`\n   should be a deferred yielding either `true` or `false`. When `false`,  the downstream\n   sink is assumed to be closed, and the connection is severed.\n\n   Returns a deferred which yields `true` when `src` is exhausted or `callback` yields `false`.", RT.keyword(null, "line"), Integer.valueOf(499), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__129 = (Var)RT.var("manifold.stream", "connect-via-proxy");
    const__130 = (Keyword)RT.keyword(null, "private");
    const__133 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "src"), Symbol.intern(null, "proxy"), Symbol.intern(null, "dst")), Tuple.create(Symbol.intern(null, "src"), Symbol.intern(null, "proxy"), Symbol.intern(null, "dst"), Symbol.intern(null, "options")) })), RT.keyword(null, "line"), Integer.valueOf(520), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__134 = (Var)RT.var("manifold.stream", "drain-into");
    const__137 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "src"), Symbol.intern(null, "dst")) })), RT.keyword(null, "doc"), "Takes all messages from `src` and puts them into `dst`, and returns a deferred that\n   yields `true` once `src` is drained or `dst` is closed.  If `src` is closed or drained,\n   `dst` will not be closed.", RT.keyword(null, "line"), Integer.valueOf(536), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__138 = (Var)RT.var("manifold.stream", "stream->seq");
    const__141 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")), Tuple.create(Symbol.intern(null, "s"), Symbol.intern(null, "timeout-interval")) })), RT.keyword(null, "doc"), "Transforms a stream into a lazy sequence.  If a `timeout-interval` is defined, the sequence\n   will terminate if `timeout-interval` milliseconds elapses without a new event.", RT.keyword(null, "line"), Integer.valueOf(551), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__142 = (Var)RT.var("manifold.stream", "periodically-");
    const__145 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "stream"), Symbol.intern(null, "period"), Symbol.intern(null, "initial-delay"), Symbol.intern(null, "f")) })), RT.keyword(null, "line"), Integer.valueOf(565), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__146 = (Var)RT.var("manifold.stream", "periodically");
    const__149 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "period"), Symbol.intern(null, "initial-delay"), Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "period"), Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Creates a stream which emits the result of invoking `(f)` every `period` milliseconds.", RT.keyword(null, "line"), Integer.valueOf(593), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__150 = (Var)RT.var("manifold.stream", "zip");
    const__152 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(602), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__153 = (Var)RT.var("manifold.stream", "transform");
    const__156 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xform"), Symbol.intern(null, "s")), Tuple.create(Symbol.intern(null, "xform"), Symbol.intern(null, "buffer-size"), ((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IEventSource") }))) })), RT.keyword(null, "doc"), "Takes a transducer `xform` and returns a source which applies it to source `s`. A buffer-size\n   may optionally be defined for the output source.", RT.keyword(null, "line"), Integer.valueOf(604), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__157 = (Var)RT.var("manifold.stream", "map");
    const__160 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "s")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "s"), Symbol.intern(null, "&"), Symbol.intern(null, "rest")) })), RT.keyword(null, "doc"), "Equivalent to Clojure's `map`, but for streams instead of sequences.", RT.keyword(null, "line"), Integer.valueOf(614), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__161 = (Var)RT.var("manifold.stream", "realize-each");
    const__164 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Takes a stream of potentially deferred values, and returns a stream of realized values.", RT.keyword(null, "line"), Integer.valueOf(628), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__165 = (Var)RT.var("manifold.stream", "filter");
    const__168 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Equivalent to Clojure's `filter`, but for streams instead of sequences.", RT.keyword(null, "line"), Integer.valueOf(673), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__169 = (Var)RT.var("manifold.stream", "reductions");
    const__172 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "s")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "initial-value"), Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Equivalent to Clojure's `reductions`, but for streams instead of sequences.", RT.keyword(null, "line"), Integer.valueOf(686), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__173 = (Var)RT.var("manifold.stream", "reduce");
    const__176 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "s")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "initial-value"), Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Equivalent to Clojure's `reduce`, but returns a deferred representing the return value.\n\n  The deferred will be realized once the stream is closed or if the accumulator\n  functions returns a `reduced` value.", RT.keyword(null, "line"), Integer.valueOf(717), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__177 = (Var)RT.var("manifold.stream", "mapcat");
    const__180 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "s")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "s"), Symbol.intern(null, "&"), Symbol.intern(null, "rest")) })), RT.keyword(null, "doc"), "Equivalent to Clojure's `mapcat`, but for streams instead of sequences.", RT.keyword(null, "line"), Integer.valueOf(742), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__181 = (Var)RT.var("manifold.stream", "lazily-partition-by");
    const__184 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Equivalent to Clojure's `partition-by`, but returns a stream of streams.  This means that\n   if a sub-stream is not completely consumed, the next sub-stream will never be emitted.\n\n   Use with caution.  If you're not totally sure you want a stream of streams, use\n   `(transform (partition-by f))` instead.", RT.keyword(null, "line"), Integer.valueOf(760), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__185 = (Var)RT.var("manifold.stream", "concat");
    const__188 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Takes a stream of streams, and flattens it into a single stream.", RT.keyword(null, "line"), Integer.valueOf(799), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__189 = (Var)RT.var("manifold.stream", "buffered-stream");
    const__192 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "buffer-size")), Tuple.create(Symbol.intern(null, "metric"), Symbol.intern(null, "limit")), Tuple.create(Symbol.intern(null, "metric"), Symbol.intern(null, "limit"), Symbol.intern(null, "description")) })), RT.keyword(null, "doc"), "A stream which will buffer at most `limit` data, where the size of each message\n   is defined by `(metric message)`.", RT.keyword(null, "line"), Integer.valueOf(952), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__193 = (Var)RT.var("manifold.stream", "buffer");
    const__196 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "limit"), Symbol.intern(null, "s")), Tuple.create(Symbol.intern(null, "metric"), Symbol.intern(null, "limit"), Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Takes a stream, and returns a stream which is a buffered view of that stream.  The buffer\n   size may either be measured in messages, or if a `metric` is defined, by the sum of `metric`\n   mapped over all messages currently buffered.", RT.keyword(null, "line"), Integer.valueOf(986), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__197 = (Var)RT.var("manifold.stream", "batch");
  }
  
  public static void __init2() {
    const__200 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "batch-size"), Symbol.intern(null, "s")), Tuple.create(Symbol.intern(null, "max-size"), Symbol.intern(null, "max-latency"), Symbol.intern(null, "s")), Tuple.create(Symbol.intern(null, "metric"), Symbol.intern(null, "max-size"), Symbol.intern(null, "max-latency"), Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Batches messages, either into groups of fixed size, or according to upper bounds on size and\n   latency, in milliseconds.  By default, each message is of size `1`, but a custom `metric` function that\n   returns the size of each message may be defined.", RT.keyword(null, "line"), Integer.valueOf(999), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__201 = (Var)RT.var("manifold.stream", "throttle");
    const__204 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "max-rate"), Symbol.intern(null, "s")), Tuple.create(Symbol.intern(null, "max-rate"), Symbol.intern(null, "max-backlog"), Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Limits the `max-rate` that messages are emitted, per second.\n\n   The `max-backlog` dictates how much \"memory\" the throttling mechanism has, or how many\n   messages it will emit immediately after a long interval without any messages.  By default,\n   this is set to one second's worth.", RT.keyword(null, "line"), Integer.valueOf(1066), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__205 = (Var)RT.var("manifold.stream", "dropping-stream");
    const__209 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "source")) })), RT.keyword(null, "doc"), "Creates a new stream with a buffer of size `n`, which will drop\n   incoming items when full.\n\n   If `source` is supplied, inserts a dropping stream after `source`\n   with the provided capacity.", RT.keyword(null, "author"), "Ryan Schmukler", RT.keyword(null, "added"), "0.3.0", RT.keyword(null, "line"), Integer.valueOf(1107), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__210 = (Var)RT.var("manifold.stream", "sliding-stream");
    const__213 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "source")) })), RT.keyword(null, "doc"), "Creates a new stream with a buffer of size `n`, which will drop\n   the oldest items when full to make room for new items.\n\n   If `source` is supplied, inserts a sliding stream after `source`\n   with the provided capacity.", RT.keyword(null, "author"), "Ryan Schmukler", RT.keyword(null, "added"), "0.3.0", RT.keyword(null, "line"), Integer.valueOf(1134), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/stream.clj" });
    const__214 = (Var)RT.var("manifold.stream", "->Callback");
    const__215 = (Var)RT.var("manifold.stream", "->SinkProxy");
    const__216 = (Var)RT.var("manifold.stream", "->SourceProxy");
    const__217 = (Var)RT.var("manifold.stream", "->SplicedStream");
  }
  
  static  {
    __init0();
    __init1();
    __init2();
    Compiler.pushNSandLoader(RT.classForName("manifold.stream__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
