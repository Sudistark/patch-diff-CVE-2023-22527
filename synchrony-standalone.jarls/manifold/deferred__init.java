package manifold;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentHashSet;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;
import manifold.deferred.SuccessDeferred;

public class deferred__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Keyword const__3;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final Var const__7;
  
  public static final Object const__8;
  
  public static final Var const__9;
  
  public static final Var const__10;
  
  public static final Var const__11;
  
  public static final Var const__12;
  
  public static final ISeq const__13;
  
  public static final Var const__14;
  
  public static final Var const__15;
  
  public static final AFn const__19;
  
  public static final Keyword const__20;
  
  public static final AFn const__21;
  
  public static final Keyword const__22;
  
  public static final Keyword const__23;
  
  public static final Keyword const__24;
  
  public static final AFn const__25;
  
  public static final Keyword const__26;
  
  public static final Var const__27;
  
  public static final Var const__28;
  
  public static final Var const__29;
  
  public static final AFn const__30;
  
  public static final AFn const__31;
  
  public static final Keyword const__32;
  
  public static final Var const__33;
  
  public static final AFn const__34;
  
  public static final Var const__35;
  
  public static final Keyword const__36;
  
  public static final Keyword const__38;
  
  public static final Keyword const__40;
  
  public static final Object const__41;
  
  public static final Keyword const__42;
  
  public static final AFn const__43;
  
  public static final Keyword const__44;
  
  public static final Var const__45;
  
  public static final AFn const__49;
  
  public static final Var const__50;
  
  public static final AFn const__53;
  
  public static final Var const__54;
  
  public static final AFn const__57;
  
  public static final Var const__58;
  
  public static final AFn const__61;
  
  public static final Var const__62;
  
  public static final AFn const__65;
  
  public static final Var const__66;
  
  public static final Keyword const__67;
  
  public static final AFn const__69;
  
  public static final Var const__70;
  
  public static final Var const__71;
  
  public static final AFn const__74;
  
  public static final Var const__75;
  
  public static final AFn const__78;
  
  public static final Var const__79;
  
  public static final AFn const__82;
  
  public static final Var const__83;
  
  public static final AFn const__86;
  
  public static final Var const__87;
  
  public static final AFn const__90;
  
  public static final Var const__91;
  
  public static final AFn const__94;
  
  public static final Var const__95;
  
  public static final AFn const__98;
  
  public static final Var const__99;
  
  public static final AFn const__102;
  
  public static final Var const__103;
  
  public static final AFn const__106;
  
  public static final Var const__107;
  
  public static final AFn const__110;
  
  public static final Var const__111;
  
  public static final AFn const__114;
  
  public static final Var const__115;
  
  public static final AFn const__118;
  
  public static final Var const__119;
  
  public static final AFn const__122;
  
  public static final Var const__123;
  
  public static final AFn const__125;
  
  public static final Var const__126;
  
  public static final AFn const__128;
  
  public static final Var const__129;
  
  public static final AFn const__131;
  
  public static final Var const__132;
  
  public static final AFn const__135;
  
  public static final Var const__136;
  
  public static final AFn const__139;
  
  public static final Var const__140;
  
  public static final AFn const__143;
  
  public static final Var const__144;
  
  public static final AFn const__147;
  
  public static final Var const__148;
  
  public static final AFn const__151;
  
  public static final Var const__152;
  
  public static final AFn const__155;
  
  public static final Var const__156;
  
  public static final AFn const__159;
  
  public static final Var const__160;
  
  public static final AFn const__163;
  
  public static final Var const__164;
  
  public static final AFn const__167;
  
  public static final Var const__168;
  
  public static final AFn const__171;
  
  public static final Var const__172;
  
  public static final Object const__173;
  
  public static final Object const__174;
  
  public static final Object const__175;
  
  public static final Object const__176;
  
  public static final Var const__177;
  
  public static final AFn const__180;
  
  public static final Var const__181;
  
  public static final AFn const__184;
  
  public static final Var const__185;
  
  public static final AFn const__188;
  
  public static final Var const__189;
  
  public static final AFn const__192;
  
  public static final Var const__193;
  
  public static final Object const__194;
  
  public static final Keyword const__195;
  
  public static final AFn const__197;
  
  public static final Object const__198;
  
  public static final Var const__199;
  
  public static final Object const__200;
  
  public static final AFn const__201;
  
  public static final Object const__202;
  
  public static final Var const__203;
  
  public static final AFn const__206;
  
  public static final Var const__207;
  
  public static final AFn const__210;
  
  public static final Var const__211;
  
  public static final AFn const__214;
  
  public static final Var const__215;
  
  public static final AFn const__218;
  
  public static final Var const__219;
  
  public static final AFn const__222;
  
  public static final Var const__223;
  
  public static final AFn const__226;
  
  public static final Var const__227;
  
  public static final Object const__228;
  
  public static final Var const__229;
  
  public static final AFn const__232;
  
  public static final Var const__233;
  
  public static final AFn const__236;
  
  public static final Var const__237;
  
  public static final AFn const__240;
  
  public static final Var const__241;
  
  public static final AFn const__244;
  
  public static final Var const__245;
  
  public static final Object const__246;
  
  public static final Var const__247;
  
  public static final Object const__248;
  
  public static final Var const__249;
  
  public static final Var const__250;
  
  public static final Var const__251;
  
  public static final Var const__252;
  
  public static final Var const__253;
  
  public static final Var const__254;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new deferred.fn__15071());
    const__35.setMeta((IPersistentMap)const__43);
    const__35.bindRoot(new deferred.realized_QMARK_());
    const__45.setMeta((IPersistentMap)const__49);
    const__45.bindRoot(new deferred.success_value());
    const__50.setMeta((IPersistentMap)const__53);
    const__50.bindRoot(new deferred.error_value());
    const__54.setMeta((IPersistentMap)const__57);
    const__54.bindRoot(new deferred.success_error_unrealized());
    ((Var)const__54)

      
      .setMacro();
    const__58.setMeta((IPersistentMap)const__61);
    const__58.bindRoot(new deferred.on_realized());
    const__62.setMeta((IPersistentMap)const__65);
    const__62.bindRoot(new deferred.deferred_QMARK_());
    const__66.setMeta((IPersistentMap)const__69);
    const__66




      
      .bindRoot(((IFn)const__70.getRawRoot()).invoke(const__10));
    const__71.setMeta((IPersistentMap)const__74);
    const__71.bindRoot(new deferred.deferrable_QMARK_());
    const__75.setMeta((IPersistentMap)const__78);
    const__75.bindRoot(new deferred.register_future_callbacks());
    const__79.setMeta((IPersistentMap)const__82);
    const__79.bindRoot(new deferred.__GT_deferred());
    const__83.setMeta((IPersistentMap)const__86);
    const__83.bindRoot(new deferred.listener());
    const__87.setMeta((IPersistentMap)const__90);
    const__87.bindRoot(new deferred.success_BANG_());
    const__91.setMeta((IPersistentMap)const__94);
    const__91.bindRoot(new deferred.error_BANG_());
    const__95.setMeta((IPersistentMap)const__98);
    const__95.bindRoot(new deferred.claim_BANG_());
    const__99.setMeta((IPersistentMap)const__102);
    const__99.bindRoot(new deferred.add_listener_BANG_());
    const__103.setMeta((IPersistentMap)const__106);
    const__103.bindRoot(new deferred.cancel_listener_BANG_());
    const__107.setMeta((IPersistentMap)const__110);
    const__107.bindRoot(new deferred.set_deferred());
    ((Var)const__107)




































      
      .setMacro();
    const__111.setMeta((IPersistentMap)const__114);
    const__111.bindRoot(new deferred.throw_SINGLEQUOTE_());
    ((Var)const__111)
































      
      .setMacro();
    const__115.setMeta((IPersistentMap)const__118);
    const__115.bindRoot(new deferred.deref_deferred());
    ((Var)const__115)



      
      .setMacro();
    const__119.setMeta((IPersistentMap)const__122);
    const__119.bindRoot(new deferred.both());
    ((Var)const__119)

















      
      .setMacro();
    const__123.setMeta((IPersistentMap)const__125);
    const__123.bindRoot(new SuccessDeferred(Boolean.TRUE, null, null));
    const__126.setMeta((IPersistentMap)const__128);
    const__126.bindRoot(new SuccessDeferred(Boolean.FALSE, null, null));
    const__129.setMeta((IPersistentMap)const__131);
    const__129.bindRoot(new SuccessDeferred(null, null, null));
    const__132.setMeta((IPersistentMap)const__135);
    const__132.bindRoot(new deferred.success_deferred());
    const__136.setMeta((IPersistentMap)const__139);
    const__136.bindRoot(new deferred.error_deferred());
    const__140.setMeta((IPersistentMap)const__143);
    const__144.setMeta((IPersistentMap)const__147);
    const__144.bindRoot(new deferred.unwrap_SINGLEQUOTE_());
    const__148.setMeta((IPersistentMap)const__151);
    const__148.bindRoot(new deferred.unwrap());
    const__152.setMeta((IPersistentMap)const__155);
    const__152.bindRoot(new deferred.connect());
    const__156.setMeta((IPersistentMap)const__159);
    const__156.bindRoot(new deferred.onto());
    const__160.setMeta((IPersistentMap)const__163);
    const__160.bindRoot(new deferred.future_with());
    ((Var)const__160)
























































































      
      .setMacro();
    const__164.setMeta((IPersistentMap)const__167);
    const__164.bindRoot(new deferred.future());
    ((Var)const__164)











      
      .setMacro();
    const__168.setMeta((IPersistentMap)const__171);
    const__168.bindRoot(new deferred.unroll_chain());
    const__172.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__36, const__173, const__3, "Like `chain`, but does not coerce deferrable values.  This is useful both when coercion\n   is undesired, or for 2-4x better performance than `chain`.", const__44, new deferred.chain_SINGLEQUOTE___inliner__15511(), const__38, const__174, const__40, const__41, 
            const__42, "manifold/deferred.clj" }));
    const__172.bindRoot(new deferred.chain_SINGLEQUOTE_());
    const__140.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__36, const__175, const__3, "Composes functions, left to right, over the value `x`, returning a deferred containing\n   the result.  When composing, either `x` or the returned values may be values which can\n   be converted to a deferred, causing the composition to be paused.\n\n   The returned deferred will only be realized once all functions have been applied and their\n   return values realized.\n\n       @(chain 1 inc #(future (inc %))) => 3\n\n       @(chain (future 1) inc inc) => 3\n\n   ", const__44, new deferred.chain__inliner__15514(), const__38, const__176, const__40, const__41, 
            const__42, "manifold/deferred.clj" }));
    const__140.bindRoot(new deferred.chain());
    const__177.setMeta((IPersistentMap)const__180);
    const__177.bindRoot(new deferred.catch_SINGLEQUOTE_());
    const__181.setMeta((IPersistentMap)const__184);
    const__181.bindRoot(new deferred.catch());
    const__185.setMeta((IPersistentMap)const__188);
    const__185.bindRoot(new deferred.finally_SINGLEQUOTE_());
    const__189.setMeta((IPersistentMap)const__192);
    const__189.bindRoot(new deferred.finally());
    const__193.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__36, const__194, const__3, "Like `zip`, but only unwraps Manifold deferreds.", const__44, new deferred.zip_SINGLEQUOTE___inliner__15543(), const__195, const__197, const__38, const__198, 
            const__40, const__41, const__42, "manifold/deferred.clj" }));
    const__193.bindRoot(new deferred.zip_SINGLEQUOTE_());
    const__199.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__36, const__200, const__3, "Takes a list of values, some of which may be deferrable, and returns a deferred that will yield a list\n   of realized values.\n\n        @(zip 1 2 3) => [1 2 3]\n        @(zip (future 1) 2 3) => [1 2 3]\n\n  ", const__44, new deferred.zip__inliner__15555(), const__195, const__201, const__38, const__202, 
            const__40, const__41, const__42, "manifold/deferred.clj" }));
    const__199.bindRoot(new deferred.zip());
    const__203.setMeta((IPersistentMap)const__206);
    const__203.bindRoot(new deferred.random_array());
    const__207.setMeta((IPersistentMap)const__210);
    const__207.bindRoot(new deferred.alt_SINGLEQUOTE_());
    const__211.setMeta((IPersistentMap)const__214);
    const__211.bindRoot(new deferred.alt());
    const__215.setMeta((IPersistentMap)const__218);
    const__215.bindRoot(new deferred.timeout_BANG_());
    const__219.setMeta((IPersistentMap)const__222);
    const__219.bindRoot(new deferred.recur());
    const__223.setMeta((IPersistentMap)const__226);
    const__223.bindRoot(new deferred.loop());
    ((Var)const__223)







      
      .setMacro();
    const__229.setMeta((IPersistentMap)const__232);
    const__229.bindRoot(new deferred.back_references());
    const__233.setMeta((IPersistentMap)const__236);
    const__233.bindRoot(new deferred.expand_let_flow());
    const__237.setMeta((IPersistentMap)const__240);
    const__237.bindRoot(new deferred.let_flow());
    ((Var)const__237)













































































      
      .setMacro();
    const__241.setMeta((IPersistentMap)const__244);
    const__241.bindRoot(new deferred.let_flow_SINGLEQUOTE_());
    ((Var)const__241)






















      
      .setMacro();
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "manifold.deferred")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "author"), "Zach Tellman", RT.keyword(null, "doc"), "Methods for creating, transforming, and interacting with asynchronous values." }));
    const__3 = (Keyword)RT.keyword(null, "doc");
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "author"), "Zach Tellman", RT.keyword(null, "doc"), "Methods for creating, transforming, and interacting with asynchronous values." });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.core", "*warn-on-reflection*");
    const__7 = (Var)RT.var("clojure.core", "*unchecked-math*");
    const__8 = RT.classForName("manifold.deferred.Deferrable");
    const__9 = (Var)RT.var("clojure.core", "alter-meta!");
    const__10 = (Var)RT.var("manifold.deferred", "Deferrable");
    const__11 = (Var)RT.var("clojure.core", "assoc");
    const__12 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__13 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "to-deferred")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Provides a conversion mechanism to manifold deferreds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) })) }));
    const__14 = (Var)RT.var("clojure.core", "alter-var-root");
    const__15 = (Var)RT.var("clojure.core", "merge");
    const__19 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "manifold.deferred.Deferrable"), RT.keyword(null, "on-interface"), RT.classForName("manifold.deferred.Deferrable") });
    const__20 = (Keyword)RT.keyword(null, "sigs");
    const__21 = (AFn)RT.map(new Object[] { RT.keyword(null, "to-deferred"), RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "to-deferred")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Provides a conversion mechanism to manifold deferreds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })), RT.keyword(null, "doc"), "Provides a conversion mechanism to manifold deferreds." }) });
    const__22 = (Keyword)RT.keyword(null, "var");
    const__23 = (Keyword)RT.keyword(null, "method-map");
    const__24 = (Keyword)RT.keyword(null, "to-deferred");
    const__25 = (AFn)RT.map(new Object[] { RT.keyword(null, "to-deferred"), RT.keyword(null, "to-deferred") });
    const__26 = (Keyword)RT.keyword(null, "method-builders");
    const__27 = (Var)RT.var("clojure.core", "intern");
    const__28 = (Var)RT.var("clojure.core", "*ns*");
    const__29 = (Var)RT.var("clojure.core", "with-meta");
    const__30 = (AFn)((IObj)Symbol.intern(null, "to-deferred")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Provides a conversion mechanism to manifold deferreds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) }));
    const__31 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "to-deferred")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Provides a conversion mechanism to manifold deferreds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })), RT.keyword(null, "doc"), "Provides a conversion mechanism to manifold deferreds." });
    const__32 = (Keyword)RT.keyword(null, "protocol");
    const__33 = (Var)RT.var("clojure.core", "-reset-methods");
    const__34 = (AFn)Symbol.intern(null, "Deferrable");
    const__35 = (Var)RT.var("manifold.deferred", "realized?");
    const__36 = (Keyword)RT.keyword(null, "arglists");
    const__38 = (Keyword)RT.keyword(null, "line");
    const__40 = (Keyword)RT.keyword(null, "column");
    const__41 = Integer.valueOf(1);
    const__42 = (Keyword)RT.keyword(null, "file");
    const__43 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if the manifold deferred is realized.", RT.keyword(null, "line"), Integer.valueOf(51), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__44 = (Keyword)RT.keyword(null, "inline");
    const__45 = (Var)RT.var("manifold.deferred", "success-value");
    const__49 = (AFn)RT.map(new Object[] { RT.keyword(null, "no-doc"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "default-value")) })), RT.keyword(null, "line"), Integer.valueOf(56), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__50 = (Var)RT.var("manifold.deferred", "error-value");
    const__53 = (AFn)RT.map(new Object[] { RT.keyword(null, "no-doc"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "default-value")) })), RT.keyword(null, "line"), Integer.valueOf(59), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__54 = (Var)RT.var("manifold.deferred", "success-error-unrealized");
    const__57 = (AFn)RT.map(new Object[] { RT.keyword(null, "no-doc"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "deferred"), Symbol.intern(null, "success-value"), Symbol.intern(null, "success-clause"), Symbol.intern(null, "error-value"), Symbol.intern(null, "error-clause"), Symbol.intern(null, "unrealized-clause")) })), RT.keyword(null, "line"), Integer.valueOf(62), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__58 = (Var)RT.var("manifold.deferred", "on-realized");
    const__61 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "on-success"), Symbol.intern(null, "on-error")) })), RT.keyword(null, "doc"), "Registers callbacks with the manifold deferred for both success and error outcomes.", RT.keyword(null, "line"), Integer.valueOf(78), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__62 = (Var)RT.var("manifold.deferred", "deferred?");
    const__65 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if the object is an instance of a Manifold deferred.", RT.keyword(null, "line"), Integer.valueOf(85), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__66 = (Var)RT.var("manifold.deferred", "satisfies-deferrable?");
    const__67 = (Keyword)RT.keyword(null, "private");
    const__69 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(90), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__70 = (Var)RT.var("manifold.utils", "fast-satisfies");
    const__71 = (Var)RT.var("manifold.deferred", "deferrable?");
    const__74 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if the object can be coerced to a Manifold deferred.", RT.keyword(null, "line"), Integer.valueOf(93), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__75 = (Var)RT.var("manifold.deferred", "register-future-callbacks");
    const__78 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "on-success"), Symbol.intern(null, "on-error")) })), RT.keyword(null, "line"), Integer.valueOf(103), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__79 = (Var)RT.var("manifold.deferred", "->deferred");
    const__82 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "default-val")) })), RT.keyword(null, "doc"), "Transforms `x` into a deferred if possible, or returns `default-val`.  If no default value\n   is given, an `IllegalArgumentException` is thrown.", RT.keyword(null, "line"), Integer.valueOf(119), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__83 = (Var)RT.var("manifold.deferred", "listener");
    const__86 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "on-success")), Tuple.create(Symbol.intern(null, "on-success"), Symbol.intern(null, "on-error")) })), RT.keyword(null, "doc"), "Creates a listener which can be registered or cancelled via `add-listener!` and `cancel-listener!`.", RT.keyword(null, "line"), Integer.valueOf(223), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__87 = (Var)RT.var("manifold.deferred", "success!");
    const__90 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "deferred")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IMutableDeferred") })), Symbol.intern(null, "x")), Tuple.create(((IObj)Symbol.intern(null, "deferred")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IMutableDeferred") })), Symbol.intern(null, "x"), Symbol.intern(null, "claim-token")) })), RT.keyword(null, "doc"), "Equivalent to `deliver`, but allows a `claim-token` to be passed in.", RT.keyword(null, "line"), Integer.valueOf(239), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__91 = (Var)RT.var("manifold.deferred", "error!");
    const__94 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "deferred")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IMutableDeferred") })), Symbol.intern(null, "x")), Tuple.create(((IObj)Symbol.intern(null, "deferred")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IMutableDeferred") })), Symbol.intern(null, "x"), Symbol.intern(null, "claim-token")) })), RT.keyword(null, "doc"), "Puts the deferred into an error state.", RT.keyword(null, "line"), Integer.valueOf(246), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__95 = (Var)RT.var("manifold.deferred", "claim!");
    const__98 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "deferred")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IMutableDeferred") }))) })), RT.keyword(null, "doc"), "Attempts to claim the deferred for future updates.  If successful, a claim token is returned, otherwise returns `nil`.", RT.keyword(null, "line"), Integer.valueOf(253), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__99 = (Var)RT.var("manifold.deferred", "add-listener!");
  }
  
  public static void __init1() {
    const__102 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "deferred")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IMutableDeferred") })), Symbol.intern(null, "listener")) })), RT.keyword(null, "doc"), "Registers a listener which can be cancelled via `cancel-listener!`.  Unless this is useful, prefer `on-realized`.", RT.keyword(null, "line"), Integer.valueOf(258), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__103 = (Var)RT.var("manifold.deferred", "cancel-listener!");
    const__106 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "deferred")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IMutableDeferred") })), Symbol.intern(null, "listener")) })), RT.keyword(null, "doc"), "Cancels a listener which has been registered via `add-listener!`.", RT.keyword(null, "line"), Integer.valueOf(263), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__107 = (Var)RT.var("manifold.deferred", "set-deferred");
    const__110 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val"), Symbol.intern(null, "token"), Symbol.intern(null, "success?"), Symbol.intern(null, "claimed?"), Symbol.intern(null, "executor")) })), RT.keyword(null, "line"), Integer.valueOf(268), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__111 = (Var)RT.var("manifold.deferred", "throw'");
    const__114 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val")) })), RT.keyword(null, "line"), Integer.valueOf(302), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__115 = (Var)RT.var("manifold.deferred", "deref-deferred");
    const__118 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "timeout-value"), Symbol.intern(null, "&"), Symbol.intern(null, "await-args")) })), RT.keyword(null, "line"), Integer.valueOf(307), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__119 = (Var)RT.var("manifold.deferred", "both");
    const__122 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "body")) })), RT.keyword(null, "line"), Integer.valueOf(326), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__123 = (Var)RT.var("manifold.deferred", "true-deferred-");
    const__125 = (AFn)RT.map(new Object[] { RT.keyword(null, "no-doc"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(568), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__126 = (Var)RT.var("manifold.deferred", "false-deferred-");
    const__128 = (AFn)RT.map(new Object[] { RT.keyword(null, "no-doc"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(569), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__129 = (Var)RT.var("manifold.deferred", "nil-deferred-");
    const__131 = (AFn)RT.map(new Object[] { RT.keyword(null, "no-doc"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(570), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__132 = (Var)RT.var("manifold.deferred", "success-deferred");
    const__135 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val")), Tuple.create(Symbol.intern(null, "val"), Symbol.intern(null, "executor")) })), RT.keyword(null, "doc"), "A deferred which already contains a realized value", RT.keyword(null, "line"), Integer.valueOf(572), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__136 = (Var)RT.var("manifold.deferred", "error-deferred");
    const__139 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "error")), Tuple.create(Symbol.intern(null, "error"), Symbol.intern(null, "executor")) })), RT.keyword(null, "doc"), "A deferred which already contains a realized error", RT.keyword(null, "line"), Integer.valueOf(593), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__140 = (Var)RT.var("manifold.deferred", "chain");
    const__143 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(600), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__144 = (Var)RT.var("manifold.deferred", "unwrap'");
    const__147 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(602), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__148 = (Var)RT.var("manifold.deferred", "unwrap");
    const__151 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(610), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__152 = (Var)RT.var("manifold.deferred", "connect");
    const__155 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "a"), Symbol.intern(null, "b")) })), RT.keyword(null, "doc"), "Conveys the realized value of `a` into `b`.", RT.keyword(null, "line"), Integer.valueOf(619), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__156 = (Var)RT.var("manifold.deferred", "onto");
    const__159 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "d")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IDeferred") })), Symbol.intern(null, "executor")) })), RT.keyword(null, "doc"), "Returns a deferred whose callbacks will be run on `executor`.", RT.keyword(null, "line"), Integer.valueOf(637), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__160 = (Var)RT.var("manifold.deferred", "future-with");
    const__163 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "executor"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Equivalent to Clojure's `future`, but allows specification of the executor\n   and returns a Manifold deferred.", RT.keyword(null, "line"), Integer.valueOf(646), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__164 = (Var)RT.var("manifold.deferred", "future");
    const__167 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Equivalent to Clojure's `future`, but returns a Manifold deferred.", RT.keyword(null, "line"), Integer.valueOf(659), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__168 = (Var)RT.var("manifold.deferred", "unroll-chain");
    const__171 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "unwrap-fn"), Symbol.intern(null, "v"), Symbol.intern(null, "&"), Symbol.intern(null, "fs")) })), RT.keyword(null, "line"), Integer.valueOf(666), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__172 = (Var)RT.var("manifold.deferred", "chain'");
    const__173 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "f"), Symbol.intern(null, "g")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "f"), Symbol.intern(null, "g"), Symbol.intern(null, "&"), Symbol.intern(null, "fs")) }));
    const__174 = Integer.valueOf(891);
    const__175 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "f"), Symbol.intern(null, "g")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "f"), Symbol.intern(null, "g"), Symbol.intern(null, "&"), Symbol.intern(null, "fs")) }));
    const__176 = Integer.valueOf(907);
    const__177 = (Var)RT.var("manifold.deferred", "catch'");
    const__180 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "error-handler")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "error-class"), Symbol.intern(null, "error-handler")) })), RT.keyword(null, "doc"), "Like `catch`, but does not coerce deferrable values.", RT.keyword(null, "line"), Integer.valueOf(933), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__181 = (Var)RT.var("manifold.deferred", "catch");
    const__184 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "error-handler")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "error-class"), Symbol.intern(null, "error-handler")) })), RT.keyword(null, "doc"), "An equivalent of the catch clause, which takes an `error-handler` function that will be invoked\n   with the exception, and whose return value will be yielded as a successful outcome.  If an\n   `error-class` is specified, only exceptions of that type will be caught.  If not, all exceptions\n   will be caught.\n\n       (-> d\n           (chain f g h)\n           (catch IOException #(str \"oh no, IO: \" (.getMessage %)))\n           (catch             #(str \"something unexpected: \" (.getMessage %))))\n    ", RT.keyword(null, "line"), Integer.valueOf(968), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__185 = (Var)RT.var("manifold.deferred", "finally'");
    const__188 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Like `finally`, but doesn't coerce deferrable values.", RT.keyword(null, "line"), Integer.valueOf(989), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__189 = (Var)RT.var("manifold.deferred", "finally");
    const__192 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "An equivalent of the finally clause, which takes a no-arg side-effecting function that executes\n   no matter what the result.", RT.keyword(null, "line"), Integer.valueOf(1020), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__193 = (Var)RT.var("manifold.deferred", "zip'");
    const__194 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "vals")) }));
    const__195 = (Keyword)RT.keyword(null, "inline-arities");
    const__197 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(1L) });
    const__198 = Integer.valueOf(1028);
    const__199 = (Var)RT.var("manifold.deferred", "zip");
  }
  
  public static void __init2() {
    const__200 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "vals")) }));
    const__201 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(1L) });
    const__202 = Integer.valueOf(1076);
    const__203 = (Var)RT.var("manifold.deferred", "random-array");
    const__206 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "line"), Integer.valueOf(1092), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__207 = (Var)RT.var("manifold.deferred", "alt'");
    const__210 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "vals")) })), RT.keyword(null, "doc"), "Like `alt`, but only unwraps Manifold deferreds.", RT.keyword(null, "line"), Integer.valueOf(1102), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__211 = (Var)RT.var("manifold.deferred", "alt");
    const__214 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "vals")) })), RT.keyword(null, "doc"), "Takes a list of values, some of which may be deferrable, and returns a\n  deferred that will yield the value which was realized first.\n\n    @(alt 1 2) => 1\n    @(alt (future (Thread/sleep 1) 1)\n          (future (Thread/sleep 1) 2)) => 1 or 2 depending on the thread scheduling\n\n  The values are not tried in-order, but iterated over with an initial random shuffle.", RT.keyword(null, "line"), Integer.valueOf(1123), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__215 = (Var)RT.var("manifold.deferred", "timeout!");
    const__218 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "d"), Symbol.intern(null, "interval")), Tuple.create(Symbol.intern(null, "d"), Symbol.intern(null, "interval"), Symbol.intern(null, "timeout-value")) })), RT.keyword(null, "doc"), "Takes a deferred, and sets a timeout on it, such that it will be realized as `timeout-value`\n   (or a TimeoutException if none is specified) if it is not realized in `interval` ms.  Returns\n   the deferred that was passed in.\n\n   This will act directly on the deferred value passed in.  If the deferred represents a value\n   returned by `chain`, all actions not yet completed will be short-circuited upon timeout.", RT.keyword(null, "line"), Integer.valueOf(1137), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__219 = (Var)RT.var("manifold.deferred", "recur");
    const__222 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "A special recur that can be used with `manifold.deferred/loop`.", RT.keyword(null, "line"), Integer.valueOf(1181), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__223 = (Var)RT.var("manifold.deferred", "loop");
    const__226 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "A version of Clojure's loop which allows for asynchronous loops, via `manifold.deferred/recur`.\n  `loop` will always return a deferred value, even if the body is synchronous.  Note that `loop` does **not** coerce values to deferreds, actual Manifold deferreds must be used.\n\n   (loop [i 1e6]\n     (chain (future i)\n       #(if (zero? %)\n          %\n          (recur (dec %)))))", RT.keyword(null, "line"), Integer.valueOf(1186), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__227 = (Var)RT.var("clojure.core", "extend");
    const__228 = RT.classForName("java.util.concurrent.CompletableFuture");
    const__229 = (Var)RT.var("manifold.deferred", "back-references");
    const__232 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "marker"), Symbol.intern(null, "form")) })), RT.keyword(null, "line"), Integer.valueOf(1275), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__233 = (Var)RT.var("manifold.deferred", "expand-let-flow");
    const__236 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "chain-fn"), Symbol.intern(null, "zip-fn"), Symbol.intern(null, "bindings"), Symbol.intern(null, "body")) })), RT.keyword(null, "line"), Integer.valueOf(1285), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__237 = (Var)RT.var("manifold.deferred", "let-flow");
    const__240 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "A version of `let` where deferred values that are let-bound or closed over can be treated\n   as if they are realized values.  The body will only be executed once all of the let-bound\n   values, even ones only used for side effects, have been computed.\n\n   Returns a deferred value, representing the value returned by the body.\n\n      (let-flow [x (future 1)]\n        (+ x 1))\n\n      (let-flow [x (future 1)\n                 y (future (+ x 1))]\n        (+ y 1))\n\n      (let [x (future 1)]\n        (let-flow [y (future (+ x 1))]\n          (+ y 1)))", RT.keyword(null, "line"), Integer.valueOf(1339), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__241 = (Var)RT.var("manifold.deferred", "let-flow'");
    const__244 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Like `let-flow`, but only for Manifold deferreds.", RT.keyword(null, "line"), Integer.valueOf(1363), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/deferred.clj" });
    const__245 = (Var)RT.var("clojure.core", "print-method");
    const__246 = RT.classForName("manifold.deferred.IDeferred");
    const__247 = (Var)RT.var("clojure.core", "prefer-method");
    const__248 = RT.classForName("clojure.lang.IDeref");
    const__249 = (Var)RT.var("manifold.deferred", "->Deferred");
    const__250 = (Var)RT.var("manifold.deferred", "->LeakAwareDeferred");
    const__251 = (Var)RT.var("manifold.deferred", "->ErrorDeferred");
    const__252 = (Var)RT.var("manifold.deferred", "->SuccessDeferred");
    const__253 = (Var)RT.var("manifold.deferred", "->Listener");
    const__254 = (Var)RT.var("manifold.deferred", "->Recur");
  }
  
  static  {
    __init0();
    __init1();
    __init2();
    Compiler.pushNSandLoader(RT.classForName("manifold.deferred__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
