package manifold.stream;

import clojure.lang.AFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.Keyword;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import manifold.stream.core.IEventSink;
import manifold.stream.core.IEventStream;

public final class Callback implements IEventStream, IEventSink, IType {
  public final Object f;
  
  public final Object close_callback;
  
  public final Object downstream;
  
  public final Object constant_response;
  
  private static Class __cached_class__0;
  
  private static Class __cached_class__1;
  
  public static final AFn const__1 = (AFn)RT.map(new Object[] { RT.keyword(null, "type"), "callback" });
  
  public static final Var const__4 = (Var)RT.var("clojure.tools.logging.impl", "get-logger");
  
  public static final Var const__5 = (Var)RT.var("clojure.tools.logging", "*logger-factory*");
  
  public static final Object const__6 = RT.readString("#=(find-ns ^#=(clojure.lang.PersistentArrayMap/create {:author \"Zach Tellman\", :doc \"Methods for creating, transforming, and interacting with asynchronous streams of values.\"}) manifold.stream)");
  
  public static final Var const__7 = (Var)RT.var("clojure.tools.logging.impl", "enabled?");
  
  public static final Keyword const__8 = (Keyword)RT.keyword(null, "error");
  
  public static final Var const__11 = (Var)RT.var("clojure.tools.logging", "log*"), const__12 = (Var)RT.var("clojure.core", "print-str"), const__13 = (Var)RT.var("manifold.deferred", "success-deferred");
  
  public Callback(Object paramObject1, Object paramObject2, Object paramObject3, Object paramObject4) { this.f = paramObject1;
    this.close_callback = paramObject2;
    this.downstream = paramObject3;
    this.constant_response = paramObject4; }
  
  public static IPersistentVector getBasis() { return Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "close-callback"), ((IObj)Symbol.intern(null, "downstream")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IEventSink") })), Symbol.intern(null, "constant-response")); }
  
  public Object onClosed(Object callback) {
    if (this.downstream != null) {
      if (this.downstream != Boolean.FALSE)
        callback = null; 
    } else {
      this.downstream;
    } 
    return null;
  }
  
  public Object isClosed() {
    if (this.downstream != null) {
      if (this.downstream != Boolean.FALSE);
    } else {
      this.downstream;
    } 
    return Boolean.FALSE;
  }
  
  public Object put(Object x, Object default_val, Object _, Object _) { x = null;
    default_val = null;
    return ((IEventSink)this).put(x, default_val); }
  
  public Object put(Object x, Object _) { // Byte code:
    //   0: aload_0
    //   1: getfield f : Ljava/lang/Object;
    //   4: checkcast clojure/lang/IFn
    //   7: aload_1
    //   8: aconst_null
    //   9: astore_1
    //   10: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   15: astore_3
    //   16: aload_0
    //   17: getfield constant_response : Ljava/lang/Object;
    //   20: aconst_null
    //   21: invokestatic identical : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   24: ifeq -> 34
    //   27: aload_3
    //   28: aconst_null
    //   29: astore_3
    //   30: goto -> 38
    //   33: athrow
    //   34: aload_0
    //   35: getfield constant_response : Ljava/lang/Object;
    //   38: astore #4
    //   40: goto -> 314
    //   43: astore_3
    //   44: getstatic manifold/stream/Callback.const__5 : Lclojure/lang/Var;
    //   47: invokevirtual get : ()Ljava/lang/Object;
    //   50: dup
    //   51: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   54: getstatic manifold/stream/Callback.__cached_class__0 : Ljava/lang/Class;
    //   57: if_acmpeq -> 74
    //   60: dup
    //   61: instanceof clojure/tools/logging/impl/LoggerFactory
    //   64: ifne -> 92
    //   67: dup
    //   68: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   71: putstatic manifold/stream/Callback.__cached_class__0 : Ljava/lang/Class;
    //   74: getstatic manifold/stream/Callback.const__4 : Lclojure/lang/Var;
    //   77: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   80: swap
    //   81: getstatic manifold/stream/Callback.const__6 : Ljava/lang/Object;
    //   84: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   89: goto -> 103
    //   92: checkcast clojure/tools/logging/impl/LoggerFactory
    //   95: getstatic manifold/stream/Callback.const__6 : Ljava/lang/Object;
    //   98: invokeinterface get_logger : (Ljava/lang/Object;)Ljava/lang/Object;
    //   103: astore #5
    //   105: aload #5
    //   107: dup
    //   108: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   111: getstatic manifold/stream/Callback.__cached_class__1 : Ljava/lang/Class;
    //   114: if_acmpeq -> 131
    //   117: dup
    //   118: instanceof clojure/tools/logging/impl/Logger
    //   121: ifne -> 149
    //   124: dup
    //   125: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   128: putstatic manifold/stream/Callback.__cached_class__1 : Ljava/lang/Class;
    //   131: getstatic manifold/stream/Callback.const__7 : Lclojure/lang/Var;
    //   134: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   137: swap
    //   138: getstatic manifold/stream/Callback.const__8 : Lclojure/lang/Keyword;
    //   141: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   146: goto -> 160
    //   149: checkcast clojure/tools/logging/impl/Logger
    //   152: getstatic manifold/stream/Callback.const__8 : Lclojure/lang/Keyword;
    //   155: invokeinterface enabled_QMARK_ : (Ljava/lang/Object;)Ljava/lang/Object;
    //   160: dup
    //   161: ifnull -> 279
    //   164: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   167: if_acmpeq -> 280
    //   170: aload_3
    //   171: aconst_null
    //   172: astore_3
    //   173: astore #6
    //   175: aload #6
    //   177: instanceof java/lang/Throwable
    //   180: ifeq -> 231
    //   183: getstatic manifold/stream/Callback.const__11 : Lclojure/lang/Var;
    //   186: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   189: checkcast clojure/lang/IFn
    //   192: aload #5
    //   194: aconst_null
    //   195: astore #5
    //   197: getstatic manifold/stream/Callback.const__8 : Lclojure/lang/Keyword;
    //   200: aload #6
    //   202: aconst_null
    //   203: astore #6
    //   205: getstatic manifold/stream/Callback.const__12 : Lclojure/lang/Var;
    //   208: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   211: checkcast clojure/lang/IFn
    //   214: ldc 'error in stream handler'
    //   216: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   221: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   226: pop
    //   227: goto -> 276
    //   230: athrow
    //   231: getstatic manifold/stream/Callback.const__11 : Lclojure/lang/Var;
    //   234: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   237: checkcast clojure/lang/IFn
    //   240: aload #5
    //   242: aconst_null
    //   243: astore #5
    //   245: getstatic manifold/stream/Callback.const__8 : Lclojure/lang/Keyword;
    //   248: aconst_null
    //   249: getstatic manifold/stream/Callback.const__12 : Lclojure/lang/Var;
    //   252: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   255: checkcast clojure/lang/IFn
    //   258: aload #6
    //   260: aconst_null
    //   261: astore #6
    //   263: ldc 'error in stream handler'
    //   265: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   270: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   275: pop
    //   276: goto -> 282
    //   279: pop
    //   280: aconst_null
    //   281: pop
    //   282: aload_0
    //   283: checkcast manifold/stream/core/IEventStream
    //   286: invokeinterface close : ()Ljava/lang/Object;
    //   291: pop
    //   292: getstatic manifold/stream/Callback.const__13 : Lclojure/lang/Var;
    //   295: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   298: checkcast clojure/lang/IFn
    //   301: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   304: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   309: astore #4
    //   311: goto -> 314
    //   314: aload #4
    //   316: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #430	-> 0
    //   #453	-> 4
    //   #453	-> 10
    //   #454	-> 16
    //   #454	-> 21
    //   #458	-> 44
    //   #458	-> 84
    //   #458	-> 105
    //   #458	-> 105
    //   #458	-> 141
    //   #458	-> 175
    //   #458	-> 189
    //   #458	-> 211
    //   #458	-> 216
    //   #458	-> 221
    //   #458	-> 237
    //   #458	-> 255
    //   #458	-> 265
    //   #458	-> 270
    //   #459	-> 286
    //   #460	-> 298
    //   #460	-> 304
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   16	22	3	rsp	Ljava/lang/Object;
    //   175	101	6	x__8621__auto__16809	Ljava/lang/Object;
    //   105	177	5	logger__8620__auto__16810	Ljava/lang/Object;
    //   43	268	3	e	Ljava/lang/Object;
    //   0	316	0	this	Lmanifold/stream/Callback;
    //   0	316	1	x	Ljava/lang/Object;
    //   0	316	2	_	Ljava/lang/Object;
    // Exception table:
    //   from	to	target	type
    //   0	33	43	java/lang/Throwable
    //   34	40	43	java/lang/Throwable }
  
  public Object downstream() {
    if (this.downstream != null) {
      if (this.downstream != Boolean.FALSE);
    } else {
      this.downstream;
    } 
    return null;
  }
  
  public Object description() { return const__1; }
  
  public Object weakHandle(Object ref_queue) { // Byte code:
    //   0: aload_0
    //   1: getfield downstream : Ljava/lang/Object;
    //   4: dup
    //   5: ifnull -> 32
    //   8: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   11: if_acmpeq -> 33
    //   14: aload_0
    //   15: getfield downstream : Ljava/lang/Object;
    //   18: checkcast manifold/stream/core/IEventStream
    //   21: aload_1
    //   22: aconst_null
    //   23: astore_1
    //   24: invokeinterface weakHandle : (Ljava/lang/Object;)Ljava/lang/Object;
    //   29: goto -> 44
    //   32: pop
    //   33: new java/lang/IllegalArgumentException
    //   36: dup
    //   37: invokespecial <init> : ()V
    //   40: checkcast java/lang/Throwable
    //   43: athrow
    //   44: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #430	-> 0
    //   #442	-> 0
    //   #443	-> 24
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   0	44	0	this	Lmanifold/stream/Callback;
    //   0	44	1	ref_queue	Ljava/lang/Object; }
  
  public Object close() {
    if (this.close_callback != null) {
      if (this.close_callback != Boolean.FALSE)
        this = null; 
    } else {
      this.close_callback;
    } 
    return null;
  }
  
  public Object isSynchronous() { return Boolean.FALSE; }
}
