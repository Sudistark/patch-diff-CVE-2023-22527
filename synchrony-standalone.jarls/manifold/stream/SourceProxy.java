package manifold.stream;

import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import manifold.stream.core.IEventSource;
import manifold.stream.core.IEventStream;

public final class SourceProxy implements IEventStream, IEventSource, IType {
  public final Object source;
  
  public SourceProxy(Object paramObject) { this.source = paramObject; }
  
  public static IPersistentVector getBasis() { return Tuple.create(((IObj)Symbol.intern(null, "source")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IEventSource") }))); }
  
  public Object connector(Object sink) { return new fn__16664(this.source); }
  
  public Object onDrained(Object callback) { callback = null;
    return ((IEventSource)this.source).onDrained(callback); }
  
  public Object isDrained() { return ((IEventSource)this.source).isDrained(); }
  
  public Object take(Object default_val, Object blocking_QMARK_, Object timeout, Object timeout_val) { default_val = null;
    blocking_QMARK_ = null;
    timeout = null;
    timeout_val = null;
    return ((IEventSource)this.source).take(default_val, blocking_QMARK_, timeout, timeout_val); }
  
  public Object take(Object default_val, Object blocking_QMARK_) { default_val = null;
    blocking_QMARK_ = null;
    return ((IEventSource)this.source).take(default_val, blocking_QMARK_); }
  
  public Object weakHandle(Object ref_queue) { ref_queue = null;
    return ((IEventStream)this.source).weakHandle(ref_queue); }
  
  public Object close() { return ((IEventStream)this.source).close(); }
  
  public Object downstream() { return ((IEventStream)this.source).downstream(); }
  
  public Object isSynchronous() { return ((IEventStream)this.source).isSynchronous(); }
  
  public Object description() { return ((IEventStream)this.source).description(); }
  
  static  {
  
  }
}
