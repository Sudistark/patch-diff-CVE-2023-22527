package manifold;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentHashSet;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class executor__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__2;
  
  public static final Var const__3;
  
  public static final AFn const__11;
  
  public static final Var const__12;
  
  public static final AFn const__16;
  
  public static final Var const__17;
  
  public static final Var const__18;
  
  public static final Keyword const__19;
  
  public static final Var const__20;
  
  public static final AFn const__23;
  
  public static final Var const__24;
  
  public static final AFn const__30;
  
  public static final Var const__31;
  
  public static final AFn const__35;
  
  public static final Var const__36;
  
  public static final AFn const__39;
  
  public static final Var const__40;
  
  public static final AFn const__42;
  
  public static final Var const__43;
  
  public static final Object const__44;
  
  public static final Var const__45;
  
  public static final AFn const__48;
  
  public static final Var const__49;
  
  public static final AFn const__52;
  
  public static final Var const__53;
  
  public static final AFn const__56;
  
  public static final Var const__57;
  
  public static final AFn const__59;
  
  public static final Var const__60;
  
  public static final AFn const__63;
  
  public static final Var const__64;
  
  public static final AFn const__67;
  
  public static final Var const__68;
  
  public static final AFn const__70;
  
  public static final Var const__71;
  
  public static final AFn const__74;
  
  public static final Var const__75;
  
  public static final AFn const__78;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new executor.fn__14781());
    const__3.setMeta((IPersistentMap)const__11);
    const__3.bindRoot(new ThreadLocal());
    const__12.setMeta((IPersistentMap)const__16);
    const__12.bindRoot(new executor.executor());
    const__20.setMeta((IPersistentMap)const__23);
    const__20.bindRoot(new executor.with_executor());
    ((Var)const__20)

      
      .setMacro();
    const__24.setMeta((IPersistentMap)const__30);
    const__24.bindRoot(new executor.new_thread());
    const__31.setMeta((IPersistentMap)const__35);
    const__31.bindRoot(new executor.thread_factory());
    const__36.setMeta((IPersistentMap)const__39);
    const__36.bindRoot(new executor.stats__GT_map());
    const__40.setMeta((IPersistentMap)const__42);
    const__40









































































      
      .bindRoot(((IFn)const__43.getRawRoot()).invoke(const__44));
    const__45.setMeta((IPersistentMap)const__48);
    const__45.bindRoot(new executor.instrumented_executor());
    const__49.setMeta((IPersistentMap)const__52);
    const__49.bindRoot(new executor.fixed_thread_executor());
    const__53.setMeta((IPersistentMap)const__56);
    const__53.bindRoot(new executor.utilization_executor());
    const__57.setMeta((IPersistentMap)const__59);
    const__57

































































































      
      .bindRoot(((IFn)const__43.getRawRoot()).invoke(PersistentHashSet.EMPTY));
    const__60.setMeta((IPersistentMap)const__63);
    const__60.bindRoot(new executor.register_wait_pool_stats_callback());
    const__64.setMeta((IPersistentMap)const__67);
    const__64.bindRoot(new executor.unregister_wait_pool_stats_callback());
    const__68.setMeta((IPersistentMap)const__70);
    const__68
















      
      .bindRoot(((IFn)const__43.getRawRoot()).invoke(PersistentHashSet.EMPTY));
    const__71.setMeta((IPersistentMap)const__74);
    const__71.bindRoot(new executor.register_execute_pool_stats_callback());
    const__75.setMeta((IPersistentMap)const__78);
    const__75.bindRoot(new executor.unregister_execute_pool_stats_callback());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "manifold.executor");
    const__2 = (AFn)Symbol.intern(null, "clojure.core");
    const__3 = (Var)RT.var("manifold.executor", "executor-thread-local");
    const__11 = (AFn)RT.map(new Object[] { RT.keyword(null, "tag"), RT.classForName("java.lang.ThreadLocal"), RT.keyword(null, "line"), Integer.valueOf(22), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/executor.clj" });
    const__12 = (Var)RT.var("manifold.executor", "executor");
    const__16 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "line"), Integer.valueOf(24), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/executor.clj" });
    const__17 = (Var)RT.var("clojure.core", "alter-meta!");
    const__18 = (Var)RT.var("clojure.core", "assoc");
    const__19 = (Keyword)RT.keyword(null, "inline");
    const__20 = (Var)RT.var("manifold.executor", "with-executor");
    const__23 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "executor"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "line"), Integer.valueOf(27), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/executor.clj" });
    const__24 = (Var)RT.var("manifold.executor", "new-thread");
    const__30 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.Thread"), RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "group"), Symbol.intern(null, "target"), Symbol.intern(null, "name"), Symbol.intern(null, "stack-size")) })), RT.keyword(null, "doc"), "Creates a new `java.lang.Thread`.\n\n  It represents the default implementation on `thread-factory` when the\n  `new-thread-fn` argument is not passed.\n\n  Some libraries require a different implementation of a `java.lang.Thread`.\n  That's the case of Netty which behaves differently when\n  running on a `io.netty.util.concurrent.FastThreadLocalThread`.", RT.keyword(null, "line"), Integer.valueOf(35), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/executor.clj" });
    const__31 = (Var)RT.var("manifold.executor", "thread-factory");
    const__35 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.util.concurrent.ThreadFactory"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name-generator"), Symbol.intern(null, "executor-promise")), Tuple.create(Symbol.intern(null, "name-generator"), Symbol.intern(null, "executor-promise"), Symbol.intern(null, "stack-size")), Tuple.create(Symbol.intern(null, "name-generator"), Symbol.intern(null, "executor-promise"), Symbol.intern(null, "stack-size"), Symbol.intern(null, "daemon?")), Tuple.create(Symbol.intern(null, "name-generator"), Symbol.intern(null, "executor-promise"), Symbol.intern(null, "stack-size"), Symbol.intern(null, "daemon?"), Symbol.intern(null, "new-thread-fn")) })), RT.keyword(null, "doc"), "Returns a `java.util.concurrent.ThreadFactory`.\n\n   |:---|:----\n   | `name-generator` | a zero-argument function, which, when invoked returns the name of the `java.lang.Thread` that will be created. |\n   | `executor-promise` | a promise eventually containing a `java.util.concurrent.Executor` that will be stored on `manifold.executor/executor-thread-local`. |\n   | `stack-size` | the desired stack size for the new thread, or nil/zero to indicate that this parameter is to be ignored. |\n   | `daemon?` | marks the created threads as either daemon or user threads. The Java Virtual Machine exits when the only threads running are all daemon threads. |\n   | `new-thread-fn` | a four arguments function which returns an implementation of `java.lang.Thread` when called. |", RT.keyword(null, "line"), Integer.valueOf(47), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "manifold/executor.clj" });
    const__36 = (Var)RT.var("manifold.executor", "stats->map");
    const__39 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")), Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Stats") })), Symbol.intern(null, "quantiles")) })), RT.keyword(null, "doc"), "Converts a Dirigiste `Stats` object into a map of values onto quantiles.", RT.keyword(null, "line"), Integer.valueOf(78), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/executor.clj" });
    const__40 = (Var)RT.var("manifold.executor", "factory-count");
    const__42 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(102), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/executor.clj" });
    const__43 = (Var)RT.var("clojure.core", "atom");
    const__44 = Long.valueOf(0L);
    const__45 = (Var)RT.var("manifold.executor", "instrumented-executor");
    const__48 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), RT.vector(new Object[] { Symbol.intern(null, "thread-factory"), Symbol.intern(null, "queue-length"), Symbol.intern(null, "stats-callback"), Symbol.intern(null, "sample-period"), Symbol.intern(null, "control-period"), Symbol.intern(null, "controller"), Symbol.intern(null, "metrics"), Symbol.intern(null, "initial-thread-count"), Symbol.intern(null, "onto?") }), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "initial-thread-count"), Long.valueOf(1L), Symbol.intern(null, "sample-period"), Long.valueOf(25L), Symbol.intern(null, "control-period"), Long.valueOf(10000L), Symbol.intern(null, "metrics"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern("EnumSet", "allOf"), Symbol.intern(null, "Stats$Metric") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(129), RT.keyword(null, "column"), Integer.valueOf(33) })), Symbol.intern(null, "onto?"), Boolean.TRUE }) })) })), RT.keyword(null, "doc"), "Returns a `java.util.concurrent.ExecutorService`, using [Dirigiste](https://github.com/ztellman/dirigiste).\n\n   |:---|:----\n   | `thread-factory` | an optional `java.util.concurrent.ThreadFactory` that creates the executor's threads. |\n   | `queue-length` | the maximum number of pending tasks before `.execute()` begins throwing `java.util.concurrent.RejectedExecutionException`, defaults to `0`.\n   | `stats-callback` | a function that will be invoked every `control-period` with the relevant statistics for the executor.\n   | `sample-period` | the interval, in milliseconds, between sampling the state of the executor for resizing and gathering statistics, defaults to `25`.\n   | `control-period` | the interval, in milliseconds, between use of the controller to adjust the size of the executor, defaults to `10000`.\n   | `controller` | the Dirigiste controller that is used to guide the pool's size.\n   | `metrics` | an `EnumSet` of the metrics that should be gathered for the controller, defaults to all.\n   | `initial-thread-count` | the number of threads that the pool should begin with.\n   | `onto?` | if true, all streams and deferred generated in the scope of this executor will also be 'on' this executor.", RT.keyword(null, "line"), Integer.valueOf(104), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/executor.clj" });
    const__49 = (Var)RT.var("manifold.executor", "fixed-thread-executor");
    const__52 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "num-threads")), Tuple.create(Symbol.intern(null, "num-threads"), Symbol.intern(null, "options")) })), RT.keyword(null, "doc"), "Returns an executor which has a fixed number of threads.", RT.keyword(null, "line"), Integer.valueOf(168), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/executor.clj" });
    const__53 = (Var)RT.var("manifold.executor", "utilization-executor");
    const__56 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "utilization")), Tuple.create(Symbol.intern(null, "utilization"), Symbol.intern(null, "max-threads")), Tuple.create(Symbol.intern(null, "utilization"), Symbol.intern(null, "max-threads"), Symbol.intern(null, "options")) })), RT.keyword(null, "doc"), "Returns an executor which sizes the thread pool according to target utilization, within\n   `[0,1]`, up to `max-threads`.  The `queue-length` for this executor is always `0`, and by\n   default has an unbounded number of threads.", RT.keyword(null, "line"), Integer.valueOf(184), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/executor.clj" });
    const__57 = (Var)RT.var("manifold.executor", "wait-pool-stats-callbacks");
    const__59 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(201), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/executor.clj" });
    const__60 = (Var)RT.var("manifold.executor", "register-wait-pool-stats-callback");
    const__63 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "c")) })), RT.keyword(null, "doc"), "Registers a callback which will be called with wait-pool stats.", RT.keyword(null, "line"), Integer.valueOf(203), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/executor.clj" });
    const__64 = (Var)RT.var("manifold.executor", "unregister-wait-pool-stats-callback");
    const__67 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "c")) })), RT.keyword(null, "doc"), "Unregisters a previous wait-pool stats callback.", RT.keyword(null, "line"), Integer.valueOf(208), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/executor.clj" });
    const__68 = (Var)RT.var("manifold.executor", "execute-pool-stats-callbacks");
    const__70 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(231), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/executor.clj" });
    const__71 = (Var)RT.var("manifold.executor", "register-execute-pool-stats-callback");
    const__74 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "c")) })), RT.keyword(null, "doc"), "Registers a callback which will be called with execute-pool stats.", RT.keyword(null, "line"), Integer.valueOf(233), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/executor.clj" });
    const__75 = (Var)RT.var("manifold.executor", "unregister-execute-pool-stats-callback");
    const__78 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "c")) })), RT.keyword(null, "doc"), "Unregisters a previous execute-pool stats callback.", RT.keyword(null, "line"), Integer.valueOf(238), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/executor.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("manifold.executor__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
