package manifold.deferred;

import clojure.lang.IFn;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Util;

public final class Listener implements IDeferredListener, IType {
  public final Object on_success;
  
  public final Object on_error;
  
  public Listener(Object paramObject1, Object paramObject2) { this.on_success = paramObject1;
    this.on_error = paramObject2; }
  
  public static IPersistentVector getBasis() { return Tuple.create(Symbol.intern(null, "on-success"), Symbol.intern(null, "on-error")); }
  
  public int hashCode() {
    return System.identityHashCode(this.on_success);
  }
  
  public boolean equals(Object x) { x = null;
    return Util.identical(this, x); }
  
  public Object onError(Object err) { err = null;
    this = null;
    return ((IFn)this.on_error).invoke(err); }
  
  public Object onSuccess(Object x) { x = null;
    this = null;
    return ((IFn)this.on_success).invoke(x); }
  
  static  {
  
  }
}
