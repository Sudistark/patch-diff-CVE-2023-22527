package manifold.deferred;

import clojure.lang.IBlockingDeref;
import clojure.lang.IDeref;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPending;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IReference;
import clojure.lang.ISeq;
import clojure.lang.IType;
import clojure.lang.Keyword;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Util;
import clojure.lang.Var;
import java.util.concurrent.Executor;

public final class ErrorDeferred implements IMutableDeferred, IPending, IBlockingDeref, IDeferred, IReference, IDeref, IFn, IType {
  public final Object error;
  
  public final Object executor;
  
  private static Class __cached_class__0;
  
  private static Class __cached_class__1;
  
  public static final Var const__0 = (Var)RT.var("clojure.core", "not");
  
  public static final Var const__1 = (Var)RT.var("manifold.debug", "*dropped-error-logging-enabled?*");
  
  public static final Var const__2 = (Var)RT.var("clojure.tools.logging.impl", "get-logger");
  
  public static final Var const__3 = (Var)RT.var("clojure.tools.logging", "*logger-factory*");
  
  public static final Object const__4 = RT.readString("#=(find-ns ^#=(clojure.lang.PersistentArrayMap/create {:author \"Zach Tellman\", :doc \"Methods for creating, transforming, and interacting with asynchronous values.\"}) manifold.deferred)");
  
  public static final Var const__5 = (Var)RT.var("clojure.tools.logging.impl", "enabled?");
  
  public static final Keyword const__6 = (Keyword)RT.keyword(null, "warn");
  
  public static final Var const__9 = (Var)RT.var("clojure.tools.logging", "log*");
  
  public static final Var const__10 = (Var)RT.var("clojure.core", "print-str");
  
  public static final Var const__11 = (Var)RT.var("clojure.core", "apply");
  
  public static final Var const__14 = (Var)RT.var("clojure.core", "ex-info");
  
  public static final Keyword const__15 = (Keyword)RT.keyword(null, "error");
  
  public ErrorDeferred(Object paramObject1, Object paramObject2, Object paramObject3, Object paramObject4) { this.error = paramObject1;
    this.mta = paramObject2;
    this.consumed_QMARK_ = paramObject3;
    this.executor = paramObject4; }
  
  public static IPersistentVector getBasis() { return Tuple.create(((IObj)Symbol.intern(null, "error")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Throwable") })), ((IObj)Symbol.intern(null, "mta")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "volatile-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "consumed?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "volatile-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "executor")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Executor") }))); }
  
  public Object deref(long time, Object paramObject) {
    this.consumed_QMARK_ = Boolean.TRUE;
    if (this.error instanceof Throwable)
      throw (Throwable)this.error; 
    throw (Throwable)((IFn)const__14.getRawRoot()).invoke("", RT.mapUniqueKeys(new Object[] { const__15, this.error }));
  }
  
  public Object deref() {
    this.consumed_QMARK_ = Boolean.TRUE;
    if (this.error instanceof Throwable)
      throw (Throwable)this.error; 
    throw (Throwable)((IFn)const__14.getRawRoot()).invoke("", RT.mapUniqueKeys(new Object[] { const__15, this.error }));
  }
  
  public boolean isRealized() { this = null;
    return ((IDeferred)this).realized(); }
  
  public Object errorValue(Object default_value) { this.consumed_QMARK_ = Boolean.TRUE;
    return this.error; }
  
  public Object successValue(Object default_value) { return null; }
  
  public Object onRealized(Object on_success, Object on_error) {
    this.consumed_QMARK_ = Boolean.TRUE;
    on_error = null;
    this = null;
    on_error = null;
    ((Executor)this.executor).execute((Runnable)new fn__15379(on_error, this.error));
    return Util.identical(this.executor, null) ? ((IFn)on_error).invoke(this.error) : null;
  }
  
  public boolean realized() { return ((Boolean)Boolean.TRUE).booleanValue(); }
  
  public Object executor() { return this.executor; }
  
  public Object invoke(Object x) { return null; }
  
  public Object error(Object x, Object token) { return Boolean.FALSE; }
  
  public Object error(Object x) { return Boolean.FALSE; }
  
  public Object success(Object x, Object token) { return Boolean.FALSE; }
  
  public Object success(Object x) { return Boolean.FALSE; }
  
  public Object cancelListener(Object listener) { return Boolean.FALSE; }
  
  public Object addListener(Object listener) {
    this.consumed_QMARK_ = Boolean.TRUE;
    listener = null;
    ((IDeferredListener)listener).onError(this.error);
    return Boolean.TRUE;
  }
  
  public Object claim() { return Boolean.FALSE; }
  
  public IPersistentMap alterMeta(IFn f, ISeq args) {
    Object object;
    lockee__5714__auto__15382 = this;
    /* monitor enter ClassFileLocalVariableReferenceExpression{type=ObjectType{java/lang/Object}, name=lockee__5714__auto__15382} */
    try {
      null;
      f = null;
      args = null;
      object = this.mta = ((IFn)const__11.getRawRoot()).invoke(f, this.mta, args);
    } finally {
      lockee__5714__auto__15382 = null;
      /* monitor exit ClassFileLocalVariableReferenceExpression{type=ObjectType{java/lang/Object}, name=lockee__5714__auto__15382} */
      null;
    } 
    return (IPersistentMap)object;
  }
  
  public IPersistentMap resetMeta(IPersistentMap m) { this.mta = m = null;
    return (IPersistentMap)this.mta; }
  
  public IPersistentMap meta() { return (IPersistentMap)this.mta; }
  
  public void finalize() throws Throwable { // Byte code:
    //   0: getstatic manifold/deferred/ErrorDeferred.const__0 : Lclojure/lang/Var;
    //   3: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   6: checkcast clojure/lang/IFn
    //   9: aload_0
    //   10: getfield consumed_QMARK_ : Ljava/lang/Object;
    //   13: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   18: astore_1
    //   19: aload_1
    //   20: dup
    //   21: ifnull -> 39
    //   24: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   27: if_acmpeq -> 40
    //   30: getstatic manifold/deferred/ErrorDeferred.const__1 : Lclojure/lang/Var;
    //   33: invokevirtual get : ()Ljava/lang/Object;
    //   36: goto -> 43
    //   39: pop
    //   40: aload_1
    //   41: aconst_null
    //   42: astore_1
    //   43: dup
    //   44: ifnull -> 284
    //   47: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   50: if_acmpeq -> 285
    //   53: getstatic manifold/deferred/ErrorDeferred.const__3 : Lclojure/lang/Var;
    //   56: invokevirtual get : ()Ljava/lang/Object;
    //   59: dup
    //   60: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   63: getstatic manifold/deferred/ErrorDeferred.__cached_class__0 : Ljava/lang/Class;
    //   66: if_acmpeq -> 83
    //   69: dup
    //   70: instanceof clojure/tools/logging/impl/LoggerFactory
    //   73: ifne -> 101
    //   76: dup
    //   77: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   80: putstatic manifold/deferred/ErrorDeferred.__cached_class__0 : Ljava/lang/Class;
    //   83: getstatic manifold/deferred/ErrorDeferred.const__2 : Lclojure/lang/Var;
    //   86: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   89: swap
    //   90: getstatic manifold/deferred/ErrorDeferred.const__4 : Ljava/lang/Object;
    //   93: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   98: goto -> 112
    //   101: checkcast clojure/tools/logging/impl/LoggerFactory
    //   104: getstatic manifold/deferred/ErrorDeferred.const__4 : Ljava/lang/Object;
    //   107: invokeinterface get_logger : (Ljava/lang/Object;)Ljava/lang/Object;
    //   112: astore_1
    //   113: aload_1
    //   114: dup
    //   115: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   118: getstatic manifold/deferred/ErrorDeferred.__cached_class__1 : Ljava/lang/Class;
    //   121: if_acmpeq -> 138
    //   124: dup
    //   125: instanceof clojure/tools/logging/impl/Logger
    //   128: ifne -> 156
    //   131: dup
    //   132: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   135: putstatic manifold/deferred/ErrorDeferred.__cached_class__1 : Ljava/lang/Class;
    //   138: getstatic manifold/deferred/ErrorDeferred.const__5 : Lclojure/lang/Var;
    //   141: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   144: swap
    //   145: getstatic manifold/deferred/ErrorDeferred.const__6 : Lclojure/lang/Keyword;
    //   148: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   153: goto -> 167
    //   156: checkcast clojure/tools/logging/impl/Logger
    //   159: getstatic manifold/deferred/ErrorDeferred.const__6 : Lclojure/lang/Keyword;
    //   162: invokeinterface enabled_QMARK_ : (Ljava/lang/Object;)Ljava/lang/Object;
    //   167: dup
    //   168: ifnull -> 279
    //   171: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   174: if_acmpeq -> 280
    //   177: aload_0
    //   178: getfield error : Ljava/lang/Object;
    //   181: astore_2
    //   182: aload_2
    //   183: instanceof java/lang/Throwable
    //   186: ifeq -> 234
    //   189: getstatic manifold/deferred/ErrorDeferred.const__9 : Lclojure/lang/Var;
    //   192: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   195: checkcast clojure/lang/IFn
    //   198: aload_1
    //   199: aconst_null
    //   200: astore_1
    //   201: getstatic manifold/deferred/ErrorDeferred.const__6 : Lclojure/lang/Keyword;
    //   204: aload_2
    //   205: aconst_null
    //   206: astore_2
    //   207: getstatic manifold/deferred/ErrorDeferred.const__10 : Lclojure/lang/Var;
    //   210: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   213: checkcast clojure/lang/IFn
    //   216: ldc 'unconsumed deferred in error state, make sure you're using `catch`.'
    //   218: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   223: aconst_null
    //   224: astore_0
    //   225: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   230: goto -> 276
    //   233: athrow
    //   234: getstatic manifold/deferred/ErrorDeferred.const__9 : Lclojure/lang/Var;
    //   237: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   240: checkcast clojure/lang/IFn
    //   243: aload_1
    //   244: aconst_null
    //   245: astore_1
    //   246: getstatic manifold/deferred/ErrorDeferred.const__6 : Lclojure/lang/Keyword;
    //   249: aconst_null
    //   250: getstatic manifold/deferred/ErrorDeferred.const__10 : Lclojure/lang/Var;
    //   253: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   256: checkcast clojure/lang/IFn
    //   259: aload_2
    //   260: aconst_null
    //   261: astore_2
    //   262: ldc 'unconsumed deferred in error state, make sure you're using `catch`.'
    //   264: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   269: aconst_null
    //   270: astore_0
    //   271: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   276: goto -> 281
    //   279: pop
    //   280: aconst_null
    //   281: goto -> 286
    //   284: pop
    //   285: aconst_null
    //   286: pop
    //   287: return
    // Line number table:
    //   Java source line number -> byte code offset
    //   #494	-> 0
    //   #502	-> 0
    //   #503	-> 6
    //   #503	-> 13
    //   #502	-> 19
    //   #505	-> 53
    //   #505	-> 93
    //   #505	-> 113
    //   #505	-> 113
    //   #505	-> 148
    //   #505	-> 182
    //   #505	-> 195
    //   #505	-> 213
    //   #505	-> 218
    //   #505	-> 223
    //   #505	-> 240
    //   #505	-> 256
    //   #505	-> 264
    //   #505	-> 269
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   19	24	1	and__5514__auto__15383	Ljava/lang/Object;
    //   182	94	2	x__8621__auto__15384	Ljava/lang/Object;
    //   113	168	1	logger__8620__auto__15385	Ljava/lang/Object;
    //   0	287	0	this	Lmanifold/deferred/ErrorDeferred; }
}
