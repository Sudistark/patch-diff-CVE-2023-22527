package manifold.deferred;

import clojure.lang.IBlockingDeref;
import clojure.lang.IDeref;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPending;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IReference;
import clojure.lang.ISeq;
import clojure.lang.IType;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Util;
import clojure.lang.Var;
import java.util.concurrent.Executor;

public final class SuccessDeferred implements IMutableDeferred, IPending, IBlockingDeref, IDeferred, IReference, IDeref, IFn, IType {
  public final Object val;
  
  public final Object executor;
  
  public static final Var const__0 = (Var)RT.var("clojure.core", "apply");
  
  public SuccessDeferred(Object paramObject1, Object paramObject2, Object paramObject3) { this.val = paramObject1;
    this.mta = paramObject2;
    this.executor = paramObject3; }
  
  public static IPersistentVector getBasis() { return Tuple.create(Symbol.intern(null, "val"), ((IObj)Symbol.intern(null, "mta")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "volatile-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "executor")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Executor") }))); }
  
  public Object deref(long time, Object paramObject) { return this.val; }
  
  public Object deref() { return this.val; }
  
  public boolean isRealized() { this = null;
    return ((IDeferred)this).realized(); }
  
  public Object errorValue(Object default_value) { return null; }
  
  public Object successValue(Object default_value) { return this.val; }
  
  public Object onRealized(Object on_success, Object on_error) {
    if (this.executor != null) {
      if (this.executor != Boolean.FALSE) {
        on_success = null;
        ((Executor)this.executor).execute((Runnable)new fn__15371(on_success, this.val));
      } 
    } else {
      this.executor;
    } 
    on_success = null;
    this = null;
    return ((IFn)on_success).invoke(this.val);
  }
  
  public boolean realized() { return ((Boolean)Boolean.TRUE).booleanValue(); }
  
  public Object executor() { return this.executor; }
  
  public Object invoke(Object x) { return null; }
  
  public Object error(Object x, Object token) { return Boolean.FALSE; }
  
  public Object error(Object x) { return Boolean.FALSE; }
  
  public Object success(Object x, Object token) { return Boolean.FALSE; }
  
  public Object success(Object x) { return Boolean.FALSE; }
  
  public Object cancelListener(Object listener) { return Boolean.FALSE; }
  
  public Object addListener(Object listener) {
    if (Util.identical(this.executor, null)) {
      listener = null;
      ((IDeferredListener)listener).onSuccess(this.val);
    } else {
      listener = null;
      ((Executor)this.executor).execute((Runnable)new fn__15369(listener, this.val));
      null;
    } 
    return Boolean.TRUE;
  }
  
  public Object claim() { return Boolean.FALSE; }
  
  public IPersistentMap alterMeta(IFn f, ISeq args) {
    Object object;
    lockee__5714__auto__15374 = this;
    /* monitor enter ClassFileLocalVariableReferenceExpression{type=ObjectType{java/lang/Object}, name=lockee__5714__auto__15374} */
    try {
      null;
      f = null;
      args = null;
      object = this.mta = ((IFn)const__0.getRawRoot()).invoke(f, this.mta, args);
    } finally {
      lockee__5714__auto__15374 = null;
      /* monitor exit ClassFileLocalVariableReferenceExpression{type=ObjectType{java/lang/Object}, name=lockee__5714__auto__15374} */
      null;
    } 
    return (IPersistentMap)object;
  }
  
  public IPersistentMap resetMeta(IPersistentMap m) { this.mta = m = null;
    return (IPersistentMap)this.mta; }
  
  public IPersistentMap meta() { return (IPersistentMap)this.mta; }
}
