package manifold.deferred;

import clojure.lang.IBlockingDeref;
import clojure.lang.IDeref;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPending;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IReference;
import clojure.lang.ISeq;
import clojure.lang.IType;
import clojure.lang.Keyword;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Util;
import clojure.lang.Var;
import java.util.LinkedList;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;

public final class LeakAwareDeferred implements IMutableDeferred, IPending, IBlockingDeref, IDeferred, IReference, IDeref, IFn, IType {
  public final Object lock;
  
  public final Object listeners;
  
  public final Object executor;
  
  private static Class __cached_class__0;
  
  private static Class __cached_class__1;
  
  public static final Var const__0 = (Var)RT.var("clojure.core", "identical?");
  
  public static final Keyword const__1 = (Keyword)RT.keyword("manifold.deferred", "error");
  
  public static final Var const__2 = (Var)RT.var("clojure.core", "not");
  
  public static final Var const__3 = (Var)RT.var("clojure.tools.logging.impl", "get-logger");
  
  public static final Var const__4 = (Var)RT.var("clojure.tools.logging", "*logger-factory*");
  
  public static final Object const__5 = RT.readString("#=(find-ns ^#=(clojure.lang.PersistentArrayMap/create {:author \"Zach Tellman\", :doc \"Methods for creating, transforming, and interacting with asynchronous values.\"}) manifold.deferred)");
  
  public static final Var const__6 = (Var)RT.var("clojure.tools.logging.impl", "enabled?");
  
  public static final Keyword const__7 = (Keyword)RT.keyword(null, "warn");
  
  public static final Var const__10 = (Var)RT.var("clojure.tools.logging", "log*");
  
  public static final Var const__11 = (Var)RT.var("clojure.core", "print-str");
  
  public static final Var const__12 = (Var)RT.var("clojure.core", "apply");
  
  public static final Keyword const__13 = (Keyword)RT.keyword("manifold.deferred", "unset");
  
  public static final Keyword const__14 = (Keyword)RT.keyword("manifold.deferred", "claimed");
  
  public static final Keyword const__15 = (Keyword)RT.keyword("manifold.deferred", "success");
  
  public static final Keyword const__16 = (Keyword)RT.keyword("manifold.deferred", "set");
  
  public static final Var const__17 = (Var)RT.var("manifold.deferred", "success!");
  
  public static final Var const__18 = (Var)RT.var("manifold.deferred", "add-listener!");
  
  public static final Var const__19 = (Var)RT.var("manifold.deferred", "listener");
  
  public static final Var const__21 = (Var)RT.var("clojure.core", "ex-info");
  
  public static final Keyword const__22 = (Keyword)RT.keyword(null, "error");
  
  public LeakAwareDeferred(Object paramObject1, Object paramObject2, Object paramObject3, Object paramObject4, Object paramObject5, Object paramObject6, Object paramObject7, Object paramObject8) { this.val = paramObject1;
    this.state = paramObject2;
    this.claim_token = paramObject3;
    this.lock = paramObject4;
    this.listeners = paramObject5;
    this.mta = paramObject6;
    this.consumed_QMARK_ = paramObject7;
    this.executor = paramObject8; }
  
  public static IPersistentVector getBasis() { return RT.vector(new Object[] { ((IObj)Symbol.intern(null, "val")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "volatile-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "state")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "volatile-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "claim-token")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "volatile-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "lock")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Lock") })), ((IObj)Symbol.intern(null, "listeners")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "LinkedList") })), ((IObj)Symbol.intern(null, "mta")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "volatile-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "consumed?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "volatile-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "executor")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Executor") })) }); }
  
  public Object deref(long time, Object paramObject) {
    this.consumed_QMARK_ = Boolean.TRUE;
    Object pred__15229 = const__0.getRawRoot(), expr__15230 = this.state;
    if (((IFn)pred__15229).invoke(const__15, expr__15230) != null) {
      if (((IFn)pred__15229).invoke(const__15, expr__15230) != Boolean.FALSE);
    } else {
      ((IFn)pred__15229).invoke(const__15, expr__15230);
    } 
    pred__15229 = null;
    expr__15230 = null;
    if (((IFn)pred__15229).invoke(const__1, expr__15230) != null) {
      if (((IFn)pred__15229).invoke(const__1, expr__15230) != Boolean.FALSE) {
        if (this.val instanceof Throwable)
          throw (Throwable)this.val; 
        throw (Throwable)((IFn)const__21.getRawRoot()).invoke("", RT.mapUniqueKeys(new Object[] { const__22, this.val }));
      } 
    } else {
      ((IFn)pred__15229).invoke(const__1, expr__15230);
    } 
    Object latch15228 = new CountDownLatch(RT.uncheckedIntCast(1L)), f__15171__auto__15236 = new f__15171__auto____15231(latch15228), x__15114__auto__15234 = this;
    f__15171__auto__15236 = null;
    ((IDeferred)x__15114__auto__15234).onRealized(f__15171__auto__15236, f__15171__auto__15236);
    latch15228 = null;
    boolean result__15173__auto__15235 = ((CountDownLatch)latch15228).await(time, (TimeUnit)TimeUnit.MILLISECONDS);
    if (result__15173__auto__15235) {
      if (Util.identical(const__15, this.state)) {
      
      } else {
        if (this.val instanceof Throwable)
          throw (Throwable)this.val; 
        throw (Throwable)((IFn)const__21.getRawRoot()).invoke("", RT.mapUniqueKeys(new Object[] { const__22, this.val }));
      } 
    } else {
      paramObject = null;
    } 
    return paramObject;
  }
  
  public Object deref() { // Byte code:
    //   0: aload_0
    //   1: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   4: putfield consumed_QMARK_ : Ljava/lang/Object;
    //   7: getstatic manifold/deferred/LeakAwareDeferred.const__0 : Lclojure/lang/Var;
    //   10: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   13: astore_1
    //   14: aload_0
    //   15: getfield state : Ljava/lang/Object;
    //   18: astore_2
    //   19: aload_1
    //   20: checkcast clojure/lang/IFn
    //   23: getstatic manifold/deferred/LeakAwareDeferred.const__15 : Lclojure/lang/Keyword;
    //   26: aload_2
    //   27: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   32: dup
    //   33: ifnull -> 49
    //   36: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   39: if_acmpeq -> 50
    //   42: aload_0
    //   43: getfield val : Ljava/lang/Object;
    //   46: goto -> 305
    //   49: pop
    //   50: aload_1
    //   51: aconst_null
    //   52: astore_1
    //   53: checkcast clojure/lang/IFn
    //   56: getstatic manifold/deferred/LeakAwareDeferred.const__1 : Lclojure/lang/Keyword;
    //   59: aload_2
    //   60: aconst_null
    //   61: astore_2
    //   62: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   67: dup
    //   68: ifnull -> 142
    //   71: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   74: if_acmpeq -> 143
    //   77: aload_0
    //   78: getfield val : Ljava/lang/Object;
    //   81: instanceof java/lang/Throwable
    //   84: ifeq -> 99
    //   87: aload_0
    //   88: getfield val : Ljava/lang/Object;
    //   91: checkcast java/lang/Throwable
    //   94: athrow
    //   95: nop
    //   96: nop
    //   97: athrow
    //   98: athrow
    //   99: getstatic manifold/deferred/LeakAwareDeferred.const__21 : Lclojure/lang/Var;
    //   102: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   105: checkcast clojure/lang/IFn
    //   108: ldc ''
    //   110: iconst_2
    //   111: anewarray java/lang/Object
    //   114: dup
    //   115: iconst_0
    //   116: getstatic manifold/deferred/LeakAwareDeferred.const__22 : Lclojure/lang/Keyword;
    //   119: aastore
    //   120: dup
    //   121: iconst_1
    //   122: aload_0
    //   123: getfield val : Ljava/lang/Object;
    //   126: aastore
    //   127: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   130: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   135: checkcast java/lang/Throwable
    //   138: athrow
    //   139: nop
    //   140: nop
    //   141: athrow
    //   142: pop
    //   143: new java/util/concurrent/CountDownLatch
    //   146: dup
    //   147: lconst_1
    //   148: invokestatic uncheckedIntCast : (J)I
    //   151: invokespecial <init> : (I)V
    //   154: astore_3
    //   155: new manifold/deferred/LeakAwareDeferred$f__15171__auto____15226
    //   158: dup
    //   159: aload_3
    //   160: invokespecial <init> : (Ljava/lang/Object;)V
    //   163: astore #4
    //   165: aload_0
    //   166: astore #5
    //   168: aload #5
    //   170: checkcast manifold/deferred/IDeferred
    //   173: aload #4
    //   175: aload #4
    //   177: aconst_null
    //   178: astore #4
    //   180: invokeinterface onRealized : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   185: pop
    //   186: aload_3
    //   187: aconst_null
    //   188: astore_3
    //   189: checkcast java/util/concurrent/CountDownLatch
    //   192: invokevirtual await : ()V
    //   195: aconst_null
    //   196: pop
    //   197: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   200: astore #5
    //   202: aload #5
    //   204: aconst_null
    //   205: astore #5
    //   207: dup
    //   208: ifnull -> 303
    //   211: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   214: if_acmpeq -> 304
    //   217: getstatic manifold/deferred/LeakAwareDeferred.const__15 : Lclojure/lang/Keyword;
    //   220: aload_0
    //   221: getfield state : Ljava/lang/Object;
    //   224: invokestatic identical : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   227: ifeq -> 238
    //   230: aload_0
    //   231: getfield val : Ljava/lang/Object;
    //   234: goto -> 300
    //   237: athrow
    //   238: aload_0
    //   239: getfield val : Ljava/lang/Object;
    //   242: instanceof java/lang/Throwable
    //   245: ifeq -> 260
    //   248: aload_0
    //   249: getfield val : Ljava/lang/Object;
    //   252: checkcast java/lang/Throwable
    //   255: athrow
    //   256: nop
    //   257: nop
    //   258: athrow
    //   259: athrow
    //   260: getstatic manifold/deferred/LeakAwareDeferred.const__21 : Lclojure/lang/Var;
    //   263: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   266: checkcast clojure/lang/IFn
    //   269: ldc ''
    //   271: iconst_2
    //   272: anewarray java/lang/Object
    //   275: dup
    //   276: iconst_0
    //   277: getstatic manifold/deferred/LeakAwareDeferred.const__22 : Lclojure/lang/Keyword;
    //   280: aastore
    //   281: dup
    //   282: iconst_1
    //   283: aload_0
    //   284: getfield val : Ljava/lang/Object;
    //   287: aastore
    //   288: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   291: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   296: checkcast java/lang/Throwable
    //   299: athrow
    //   300: goto -> 305
    //   303: pop
    //   304: aconst_null
    //   305: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #339	-> 0
    //   #440	-> 19
    //   #440	-> 20
    //   #440	-> 27
    //   #440	-> 50
    //   #440	-> 53
    //   #440	-> 62
    //   #440	-> 77
    //   #440	-> 105
    //   #440	-> 130
    //   #440	-> 180
    //   #440	-> 192
    //   #440	-> 202
    //   #440	-> 217
    //   #440	-> 224
    //   #440	-> 238
    //   #440	-> 266
    //   #440	-> 291
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   168	18	5	x__15114__auto__15237	Ljava/lang/Object;
    //   202	103	5	result__15173__auto__15238	Ljava/lang/Object;
    //   155	150	3	latch15223	Ljava/lang/Object;
    //   165	140	4	f__15171__auto__15239	Ljava/lang/Object;
    //   14	291	1	pred__15224	Ljava/lang/Object;
    //   19	286	2	expr__15225	Ljava/lang/Object;
    //   0	305	0	this	Lmanifold/deferred/LeakAwareDeferred; }
  
  public boolean isRealized() { this = null;
    return ((IDeferred)this).realized(); }
  
  public Object errorValue(Object default_value) { this.consumed_QMARK_ = Boolean.TRUE;
    default_value = null;
    return Util.identical(const__1, this.state) ? this.val : default_value; }
  
  public Object successValue(Object default_value) { this.consumed_QMARK_ = Boolean.TRUE;
    default_value = null;
    return Util.identical(const__15, this.state) ? this.val : default_value; }
  
  public Object onRealized(Object on_success, Object on_error) { on_success = null;
    on_error = null;
    this = null;
    return ((IFn)const__18.getRawRoot()).invoke(this, ((IFn)const__19.getRawRoot()).invoke(on_success, on_error)); }
  
  public boolean realized() {
    Object state = this.state;
    boolean or__5516__auto__15240 = Util.identical(const__15, state);
    state = null;
    return or__5516__auto__15240 ? or__5516__auto__15240 : Util.identical(const__1, state);
  }
  
  public Object executor() { return this.executor; }
  
  public Object invoke(Object x) { x = null;
    if (((IFn)const__17.getRawRoot()).invoke(this, x) != null) {
      if (((IFn)const__17.getRawRoot()).invoke(this, x) != Boolean.FALSE);
    } else {
      ((IFn)const__17.getRawRoot()).invoke(this, x);
    } 
    return null; }
  
  public Object error(Object x, Object token) {
    Object lock__14925__auto__15243 = this.lock;
    ((Lock)lock__14925__auto__15243).lock();
    null;
    boolean and__5514__auto__15241 = Util.identical(const__14, this.state);
    this.val = x;
    this.state = const__1;
    Object x__14926__auto__15242 = (and__5514__auto__15241 ? Util.identical(this.claim_token, token) : and__5514__auto__15241) ? Boolean.TRUE : null;
    lock__14925__auto__15243 = null;
    ((Lock)lock__14925__auto__15243).unlock();
    null;
    x__14926__auto__15242 = null;
    if (x__14926__auto__15242 != null) {
      if (x__14926__auto__15242 != Boolean.FALSE) {
        while (true) {
          Object temp__5735__auto__15245 = ((LinkedList)this.listeners).poll();
          if (temp__5735__auto__15245 != null) {
            if (temp__5735__auto__15245 != Boolean.FALSE) {
              Object l__15167__auto__15244 = temp__5735__auto__15245 = null;
              l__15167__auto__15244 = null;
              ((IFn)new fn__15215(l__15167__auto__15244, x, this.executor)).invoke();
              continue;
            } 
            break;
          } 
          temp__5735__auto__15245;
          break;
        } 
        null;
      } 
    } else {
      x__14926__auto__15242;
    } 
    token = null;
    throw (Throwable)new IllegalStateException((String)(Util.identical(this.claim_token, token) ? "deferred isn't claimed" : "invalid claim-token"));
  }
  
  public Object error(Object x) {
    Object lock__14925__auto__15247 = this.lock;
    ((Lock)lock__14925__auto__15247).lock();
    null;
    this.val = x;
    this.state = const__1;
    Object x__14926__auto__15246 = Util.identical(const__13, this.state) ? Boolean.TRUE : null;
    lock__14925__auto__15247 = null;
    ((Lock)lock__14925__auto__15247).unlock();
    null;
    x__14926__auto__15246 = null;
    if (x__14926__auto__15246 != null) {
      if (x__14926__auto__15246 != Boolean.FALSE) {
        while (true) {
          Object temp__5735__auto__15249 = ((LinkedList)this.listeners).poll();
          if (temp__5735__auto__15249 != null) {
            if (temp__5735__auto__15249 != Boolean.FALSE) {
              Object l__15167__auto__15248 = temp__5735__auto__15249 = null;
              l__15167__auto__15248 = null;
              ((IFn)new fn__15207(l__15167__auto__15248, x, this.executor)).invoke();
              continue;
            } 
            break;
          } 
          temp__5735__auto__15249;
          break;
        } 
        null;
      } 
    } else {
      x__14926__auto__15246;
    } 
    return Boolean.FALSE;
  }
  
  public Object success(Object x, Object token) {
    Object lock__14925__auto__15252 = this.lock;
    ((Lock)lock__14925__auto__15252).lock();
    null;
    boolean and__5514__auto__15250 = Util.identical(const__14, this.state);
    this.val = x;
    this.state = const__15;
    Object x__14926__auto__15251 = (and__5514__auto__15250 ? Util.identical(this.claim_token, token) : and__5514__auto__15250) ? Boolean.TRUE : null;
    lock__14925__auto__15252 = null;
    ((Lock)lock__14925__auto__15252).unlock();
    null;
    x__14926__auto__15251 = null;
    if (x__14926__auto__15251 != null) {
      if (x__14926__auto__15251 != Boolean.FALSE) {
        while (true) {
          Object temp__5735__auto__15254 = ((LinkedList)this.listeners).poll();
          if (temp__5735__auto__15254 != null) {
            if (temp__5735__auto__15254 != Boolean.FALSE) {
              Object l__15167__auto__15253 = temp__5735__auto__15254 = null;
              l__15167__auto__15253 = null;
              ((IFn)new fn__15199(x, this.executor, l__15167__auto__15253)).invoke();
              continue;
            } 
            break;
          } 
          temp__5735__auto__15254;
          break;
        } 
        null;
      } 
    } else {
      x__14926__auto__15251;
    } 
    token = null;
    throw (Throwable)new IllegalStateException((String)(Util.identical(this.claim_token, token) ? "deferred isn't claimed" : "invalid claim-token"));
  }
  
  public Object success(Object x) {
    Object lock__14925__auto__15256 = this.lock;
    ((Lock)lock__14925__auto__15256).lock();
    null;
    this.val = x;
    this.state = const__15;
    Object x__14926__auto__15255 = Util.identical(const__13, this.state) ? Boolean.TRUE : null;
    lock__14925__auto__15256 = null;
    ((Lock)lock__14925__auto__15256).unlock();
    null;
    x__14926__auto__15255 = null;
    if (x__14926__auto__15255 != null) {
      if (x__14926__auto__15255 != Boolean.FALSE) {
        while (true) {
          Object temp__5735__auto__15258 = ((LinkedList)this.listeners).poll();
          if (temp__5735__auto__15258 != null) {
            if (temp__5735__auto__15258 != Boolean.FALSE) {
              Object l__15167__auto__15257 = temp__5735__auto__15258 = null;
              l__15167__auto__15257 = null;
              ((IFn)new fn__15191(this.executor, x, l__15167__auto__15257)).invoke();
              continue;
            } 
            break;
          } 
          temp__5735__auto__15258;
          break;
        } 
        null;
      } 
    } else {
      x__14926__auto__15255;
    } 
    return Boolean.FALSE;
  }
  
  public Object cancelListener(Object listener) {
    Object lock__14925__auto__15261 = this.lock;
    ((Lock)lock__14925__auto__15261).lock();
    null;
    Object state = this.state;
    boolean or__5516__auto__15259 = Util.identical(const__13, state);
    state = null;
    listener = null;
    x__14926__auto__15260 = (or__5516__auto__15259 ? or__5516__auto__15259 : Util.identical(const__16, state)) ? (((LinkedList)this.listeners).remove(listener) ? Boolean.TRUE : Boolean.FALSE) : Boolean.FALSE;
    lock__14925__auto__15261 = null;
    ((Lock)lock__14925__auto__15261).unlock();
    null;
    return null;
  }
  
  public Object addListener(Object listener) { // Byte code:
    //   0: aload_0
    //   1: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   4: putfield consumed_QMARK_ : Ljava/lang/Object;
    //   7: aload_0
    //   8: getfield lock : Ljava/lang/Object;
    //   11: astore_2
    //   12: aload_2
    //   13: checkcast java/util/concurrent/locks/Lock
    //   16: invokeinterface lock : ()V
    //   21: aconst_null
    //   22: pop
    //   23: getstatic manifold/deferred/LeakAwareDeferred.const__0 : Lclojure/lang/Var;
    //   26: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   29: astore_3
    //   30: aload_0
    //   31: getfield state : Ljava/lang/Object;
    //   34: astore #4
    //   36: aload_3
    //   37: checkcast clojure/lang/IFn
    //   40: getstatic manifold/deferred/LeakAwareDeferred.const__15 : Lclojure/lang/Keyword;
    //   43: aload #4
    //   45: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   50: dup
    //   51: ifnull -> 77
    //   54: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   57: if_acmpeq -> 78
    //   60: new manifold/deferred/LeakAwareDeferred$fn__15187
    //   63: dup
    //   64: aload_0
    //   65: getfield val : Ljava/lang/Object;
    //   68: aload_1
    //   69: aconst_null
    //   70: astore_1
    //   71: invokespecial <init> : (Ljava/lang/Object;Ljava/lang/Object;)V
    //   74: goto -> 152
    //   77: pop
    //   78: aload_3
    //   79: aconst_null
    //   80: astore_3
    //   81: checkcast clojure/lang/IFn
    //   84: getstatic manifold/deferred/LeakAwareDeferred.const__1 : Lclojure/lang/Keyword;
    //   87: aload #4
    //   89: aconst_null
    //   90: astore #4
    //   92: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   97: dup
    //   98: ifnull -> 124
    //   101: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   104: if_acmpeq -> 125
    //   107: new manifold/deferred/LeakAwareDeferred$fn__15189
    //   110: dup
    //   111: aload_0
    //   112: getfield val : Ljava/lang/Object;
    //   115: aload_1
    //   116: aconst_null
    //   117: astore_1
    //   118: invokespecial <init> : (Ljava/lang/Object;Ljava/lang/Object;)V
    //   121: goto -> 152
    //   124: pop
    //   125: aload_0
    //   126: getfield listeners : Ljava/lang/Object;
    //   129: checkcast java/util/LinkedList
    //   132: aload_1
    //   133: aconst_null
    //   134: astore_1
    //   135: invokevirtual add : (Ljava/lang/Object;)Z
    //   138: ifeq -> 147
    //   141: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   144: goto -> 150
    //   147: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   150: pop
    //   151: aconst_null
    //   152: astore_3
    //   153: aload_2
    //   154: aconst_null
    //   155: astore_2
    //   156: checkcast java/util/concurrent/locks/Lock
    //   159: invokeinterface unlock : ()V
    //   164: aconst_null
    //   165: pop
    //   166: aload_3
    //   167: aconst_null
    //   168: astore_3
    //   169: astore_2
    //   170: aload_2
    //   171: dup
    //   172: ifnull -> 238
    //   175: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   178: if_acmpeq -> 239
    //   181: aload_2
    //   182: aconst_null
    //   183: astore_2
    //   184: astore_3
    //   185: aload_0
    //   186: getfield executor : Ljava/lang/Object;
    //   189: dup
    //   190: ifnull -> 222
    //   193: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   196: if_acmpeq -> 223
    //   199: aload_0
    //   200: getfield executor : Ljava/lang/Object;
    //   203: checkcast java/util/concurrent/Executor
    //   206: aload_3
    //   207: aconst_null
    //   208: astore_3
    //   209: checkcast java/lang/Runnable
    //   212: invokeinterface execute : (Ljava/lang/Runnable;)V
    //   217: aconst_null
    //   218: pop
    //   219: goto -> 235
    //   222: pop
    //   223: aload_3
    //   224: aconst_null
    //   225: astore_3
    //   226: checkcast clojure/lang/IFn
    //   229: invokeinterface invoke : ()Ljava/lang/Object;
    //   234: pop
    //   235: goto -> 241
    //   238: pop
    //   239: aconst_null
    //   240: pop
    //   241: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   244: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #339	-> 0
    //   #378	-> 16
    //   #379	-> 36
    //   #379	-> 37
    //   #379	-> 45
    //   #379	-> 78
    //   #379	-> 81
    //   #379	-> 92
    //   #383	-> 135
    //   #378	-> 159
    //   #378	-> 170
    //   #385	-> 185
    //   #386	-> 212
    //   #387	-> 226
    //   #387	-> 229
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   30	122	3	pred__15185	Ljava/lang/Object;
    //   36	116	4	expr__15186	Ljava/lang/Object;
    //   153	16	3	x__14926__auto__15262	Ljava/lang/Object;
    //   12	157	2	lock__14925__auto__15263	Ljava/lang/Object;
    //   185	50	3	f	Ljava/lang/Object;
    //   170	71	2	temp__5735__auto__15264	Ljava/lang/Object;
    //   0	244	0	this	Lmanifold/deferred/LeakAwareDeferred;
    //   0	244	1	listener	Ljava/lang/Object; }
  
  public Object claim() {
    Object lock__14925__auto__15266 = this.lock;
    ((Lock)lock__14925__auto__15266).lock();
    null;
    this.state = const__14;
    this.claim_token = new Object();
    x__14926__auto__15265 = Util.identical(this.state, const__13) ? this.claim_token : null;
    lock__14925__auto__15266 = null;
    ((Lock)lock__14925__auto__15266).unlock();
    null;
    return null;
  }
  
  public IPersistentMap alterMeta(IFn f, ISeq args) {
    Object lock__14925__auto__15268 = this.lock;
    ((Lock)lock__14925__auto__15268).lock();
    null;
    f = null;
    args = null;
    Object x__14926__auto__15267 = this.mta = ((IFn)const__12.getRawRoot()).invoke(f, this.mta, args);
    lock__14925__auto__15268 = null;
    ((Lock)lock__14925__auto__15268).unlock();
    null;
    x__14926__auto__15267 = null;
    return (IPersistentMap)x__14926__auto__15267;
  }
  
  public IPersistentMap resetMeta(IPersistentMap m) {
    Object lock__14925__auto__15270 = this.lock;
    ((Lock)lock__14925__auto__15270).lock();
    null;
    Object x__14926__auto__15269 = this.mta = m = null;
    lock__14925__auto__15270 = null;
    ((Lock)lock__14925__auto__15270).unlock();
    null;
    x__14926__auto__15269 = null;
    return (IPersistentMap)x__14926__auto__15269;
  }
  
  public IPersistentMap meta() { return (IPersistentMap)this.mta; }
  
  public void finalize() throws Throwable { // Byte code:
    //   0: aload_0
    //   1: getfield lock : Ljava/lang/Object;
    //   4: astore_1
    //   5: aload_1
    //   6: checkcast java/util/concurrent/locks/Lock
    //   9: invokeinterface lock : ()V
    //   14: aconst_null
    //   15: pop
    //   16: getstatic manifold/deferred/LeakAwareDeferred.const__1 : Lclojure/lang/Keyword;
    //   19: aload_0
    //   20: getfield state : Ljava/lang/Object;
    //   23: invokestatic identical : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   26: istore_2
    //   27: iload_2
    //   28: ifeq -> 53
    //   31: getstatic manifold/deferred/LeakAwareDeferred.const__2 : Lclojure/lang/Var;
    //   34: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   37: checkcast clojure/lang/IFn
    //   40: aload_0
    //   41: getfield consumed_QMARK_ : Ljava/lang/Object;
    //   44: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   49: goto -> 66
    //   52: athrow
    //   53: iload_2
    //   54: ifeq -> 63
    //   57: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   60: goto -> 66
    //   63: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   66: dup
    //   67: ifnull -> 305
    //   70: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   73: if_acmpeq -> 306
    //   76: getstatic manifold/deferred/LeakAwareDeferred.const__4 : Lclojure/lang/Var;
    //   79: invokevirtual get : ()Ljava/lang/Object;
    //   82: dup
    //   83: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   86: getstatic manifold/deferred/LeakAwareDeferred.__cached_class__0 : Ljava/lang/Class;
    //   89: if_acmpeq -> 106
    //   92: dup
    //   93: instanceof clojure/tools/logging/impl/LoggerFactory
    //   96: ifne -> 124
    //   99: dup
    //   100: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   103: putstatic manifold/deferred/LeakAwareDeferred.__cached_class__0 : Ljava/lang/Class;
    //   106: getstatic manifold/deferred/LeakAwareDeferred.const__3 : Lclojure/lang/Var;
    //   109: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   112: swap
    //   113: getstatic manifold/deferred/LeakAwareDeferred.const__5 : Ljava/lang/Object;
    //   116: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   121: goto -> 135
    //   124: checkcast clojure/tools/logging/impl/LoggerFactory
    //   127: getstatic manifold/deferred/LeakAwareDeferred.const__5 : Ljava/lang/Object;
    //   130: invokeinterface get_logger : (Ljava/lang/Object;)Ljava/lang/Object;
    //   135: astore_2
    //   136: aload_2
    //   137: dup
    //   138: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   141: getstatic manifold/deferred/LeakAwareDeferred.__cached_class__1 : Ljava/lang/Class;
    //   144: if_acmpeq -> 161
    //   147: dup
    //   148: instanceof clojure/tools/logging/impl/Logger
    //   151: ifne -> 179
    //   154: dup
    //   155: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   158: putstatic manifold/deferred/LeakAwareDeferred.__cached_class__1 : Ljava/lang/Class;
    //   161: getstatic manifold/deferred/LeakAwareDeferred.const__6 : Lclojure/lang/Var;
    //   164: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   167: swap
    //   168: getstatic manifold/deferred/LeakAwareDeferred.const__7 : Lclojure/lang/Keyword;
    //   171: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   176: goto -> 190
    //   179: checkcast clojure/tools/logging/impl/Logger
    //   182: getstatic manifold/deferred/LeakAwareDeferred.const__7 : Lclojure/lang/Keyword;
    //   185: invokeinterface enabled_QMARK_ : (Ljava/lang/Object;)Ljava/lang/Object;
    //   190: dup
    //   191: ifnull -> 300
    //   194: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   197: if_acmpeq -> 301
    //   200: aload_0
    //   201: getfield val : Ljava/lang/Object;
    //   204: astore_3
    //   205: aload_3
    //   206: instanceof java/lang/Throwable
    //   209: ifeq -> 256
    //   212: getstatic manifold/deferred/LeakAwareDeferred.const__10 : Lclojure/lang/Var;
    //   215: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   218: checkcast clojure/lang/IFn
    //   221: aload_2
    //   222: aconst_null
    //   223: astore_2
    //   224: getstatic manifold/deferred/LeakAwareDeferred.const__7 : Lclojure/lang/Keyword;
    //   227: aload_3
    //   228: aconst_null
    //   229: astore_3
    //   230: getstatic manifold/deferred/LeakAwareDeferred.const__11 : Lclojure/lang/Var;
    //   233: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   236: checkcast clojure/lang/IFn
    //   239: ldc_w 'unconsumed deferred in error state, make sure you're using `catch`.'
    //   242: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   247: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   252: goto -> 297
    //   255: athrow
    //   256: getstatic manifold/deferred/LeakAwareDeferred.const__10 : Lclojure/lang/Var;
    //   259: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   262: checkcast clojure/lang/IFn
    //   265: aload_2
    //   266: aconst_null
    //   267: astore_2
    //   268: getstatic manifold/deferred/LeakAwareDeferred.const__7 : Lclojure/lang/Keyword;
    //   271: aconst_null
    //   272: getstatic manifold/deferred/LeakAwareDeferred.const__11 : Lclojure/lang/Var;
    //   275: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   278: checkcast clojure/lang/IFn
    //   281: aload_3
    //   282: aconst_null
    //   283: astore_3
    //   284: ldc_w 'unconsumed deferred in error state, make sure you're using `catch`.'
    //   287: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   292: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   297: goto -> 302
    //   300: pop
    //   301: aconst_null
    //   302: goto -> 307
    //   305: pop
    //   306: aconst_null
    //   307: astore #4
    //   309: aload_1
    //   310: aconst_null
    //   311: astore_1
    //   312: checkcast java/util/concurrent/locks/Lock
    //   315: invokeinterface unlock : ()V
    //   320: aconst_null
    //   321: pop
    //   322: goto -> 343
    //   325: astore #5
    //   327: aload_1
    //   328: aconst_null
    //   329: astore_1
    //   330: checkcast java/util/concurrent/locks/Lock
    //   333: invokeinterface unlock : ()V
    //   338: aconst_null
    //   339: pop
    //   340: aload #5
    //   342: athrow
    //   343: aload #4
    //   345: pop
    //   346: return
    // Line number table:
    //   Java source line number -> byte code offset
    //   #339	-> 0
    //   #356	-> 9
    //   #357	-> 16
    //   #357	-> 23
    //   #357	-> 27
    //   #357	-> 37
    //   #357	-> 44
    //   #358	-> 76
    //   #358	-> 116
    //   #358	-> 136
    //   #358	-> 136
    //   #358	-> 171
    //   #358	-> 205
    //   #358	-> 218
    //   #358	-> 236
    //   #358	-> 242
    //   #358	-> 247
    //   #358	-> 262
    //   #358	-> 278
    //   #358	-> 287
    //   #358	-> 292
    //   #356	-> 315
    //   #356	-> 333
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   27	39	2	and__5514__auto__15271	Z
    //   205	92	3	x__8621__auto__15272	Ljava/lang/Object;
    //   136	166	2	logger__8620__auto__15273	Ljava/lang/Object;
    //   5	340	1	lock__14923__auto__15274	Ljava/lang/Object;
    //   0	346	0	this	Lmanifold/deferred/LeakAwareDeferred;
    // Exception table:
    //   from	to	target	type
    //   16	52	325	finally
    //   53	255	325	finally
    //   256	309	325	finally }
}
