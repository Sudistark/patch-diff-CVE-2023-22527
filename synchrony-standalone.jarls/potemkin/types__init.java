package potemkin;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentHashSet;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;
import java.util.regex.Pattern;

public class types__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__2;
  
  public static final Var const__3;
  
  public static final AFn const__11;
  
  public static final Var const__12;
  
  public static final AFn const__16;
  
  public static final Var const__17;
  
  public static final AFn const__20;
  
  public static final Var const__21;
  
  public static final AFn const__25;
  
  public static final Var const__26;
  
  public static final AFn const__29;
  
  public static final Var const__30;
  
  public static final AFn const__33;
  
  public static final Var const__34;
  
  public static final AFn const__35;
  
  public static final Var const__36;
  
  public static final AFn const__39;
  
  public static final Var const__40;
  
  public static final AFn const__43;
  
  public static final Var const__44;
  
  public static final AFn const__47;
  
  public static final Var const__48;
  
  public static final AFn const__51;
  
  public static final AFn const__54;
  
  public static final Var const__55;
  
  public static final AFn const__58;
  
  public static final Var const__59;
  
  public static final AFn const__62;
  
  public static final AFn const__65;
  
  public static final Var const__66;
  
  public static final AFn const__69;
  
  public static final Var const__70;
  
  public static final AFn const__73;
  
  public static final Var const__74;
  
  public static final AFn const__76;
  
  public static final AFn const__95;
  
  public static final Var const__96;
  
  public static final AFn const__99;
  
  public static final Var const__100;
  
  public static final AFn const__103;
  
  public static final Var const__104;
  
  public static final AFn const__107;
  
  public static final Var const__108;
  
  public static final AFn const__111;
  
  public static final Var const__112;
  
  public static final AFn const__115;
  
  public static final Var const__116;
  
  public static final AFn const__119;
  
  public static final Var const__120;
  
  public static final AFn const__123;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new types.fn__25972());
    const__3.setMeta((IPersistentMap)const__11);
    const__3.bindRoot(new types.protocol_QMARK_());
    const__12.setMeta((IPersistentMap)const__16);
    const__12.bindRoot(new types.extend_implementations());
    const__17.setMeta((IPersistentMap)const__20);
    const__17.bindRoot(new types.register_impl_callback());
    const__21.setMeta((IPersistentMap)const__25);
    const__21.bindRoot(new types.extend_protocol_PLUS_());
    ((Var)const__21)
























      
      .setMacro();
    const__26.setMeta((IPersistentMap)const__29);
    const__26.bindRoot(new types.clean_deftype());
    const__30.setMeta((IPersistentMap)const__33);
    const__34.setMeta((IPersistentMap)const__35);
    const__36.setMeta((IPersistentMap)const__39);
    const__36.bindRoot(new types.abstract_type_QMARK_());
    const__40.setDynamic(true).setMeta((IPersistentMap)const__43);
    const__40.setDynamic(true).bindRoot(PersistentHashSet.EMPTY);
    const__44.setMeta((IPersistentMap)const__47);
    const__44.bindRoot(new types.expand_deftype());
    const__48.setMeta((IPersistentMap)const__51);
    const__48.bindRoot(new types.transform_deftype_STAR_());
    const__34.setMeta((IPersistentMap)const__54);
    const__34.bindRoot(new types.deftype__GT_deftype_STAR_());
    const__55.setMeta((IPersistentMap)const__58);
    const__55.bindRoot(new types.deftype_STAR___GT_deftype());
    const__59.setMeta((IPersistentMap)const__62);
    const__59.bindRoot(new types.deftype_STAR___GT_fn_map());
    const__30.setMeta((IPersistentMap)const__65);
    const__30.bindRoot(new types.merge_deftypes_STAR_());
    const__66.setMeta((IPersistentMap)const__69);
    const__66.bindRoot(new types.def_abstract_type());
    ((Var)const__66)





























































































































      
      .setMacro();
    const__70.setMeta((IPersistentMap)const__73);
    const__70.bindRoot(new types.defprotocol_PLUS_());
    ((Var)const__70)





      
      .setMacro();
    const__74.setMeta((IPersistentMap)const__76);
    const__74.bindRoot(const__95);
    const__96.setMeta((IPersistentMap)const__99);
    const__96.bindRoot(new types.munge_fn_name());
    const__100.setMeta((IPersistentMap)const__103);
    const__100.bindRoot(new types.resolve_tag());
    const__104.setMeta((IPersistentMap)const__107);
    const__104.bindRoot(new types.untag());
    const__108.setMeta((IPersistentMap)const__111);
    const__108.bindRoot(new types.definterface_PLUS_());
    ((Var)const__108)











































      
      .setMacro();
    const__112.setMeta((IPersistentMap)const__115);
    const__112.bindRoot(new types.deftype_PLUS_());
    ((Var)const__112)
      
      .setMacro();
    const__116.setMeta((IPersistentMap)const__119);
    const__116.bindRoot(new types.reify_PLUS_());
    ((Var)const__116)





















      
      .setMacro();
    const__120.setMeta((IPersistentMap)const__123);
    const__120.bindRoot(new types.defrecord_PLUS_());
    ((Var)const__120)










      
      .setMacro();
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "potemkin.types");
    const__2 = (AFn)Symbol.intern(null, "clojure.core");
    const__3 = (Var)RT.var("potemkin.types", "protocol?");
    const__11 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(16), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__12 = (Var)RT.var("potemkin.types", "extend-implementations");
    const__16 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "proto"), Symbol.intern(null, "impls"), Symbol.intern(null, "body")) })), RT.keyword(null, "line"), Integer.valueOf(21), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__17 = (Var)RT.var("potemkin.types", "register-impl-callback");
    const__20 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "proto-var"), Symbol.intern(null, "callback")) })), RT.keyword(null, "line"), Integer.valueOf(33), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__21 = (Var)RT.var("potemkin.types", "extend-protocol+");
    const__25 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "proto"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "A variant of `extend-protocol` that allows `proto` to be extended over other protocols, as well as classes and `nil`.", RT.keyword(null, "line"), Integer.valueOf(38), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__26 = (Var)RT.var("potemkin.types", "clean-deftype");
    const__29 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(71), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__30 = (Var)RT.var("potemkin.types", "merge-deftypes*");
    const__33 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(79), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__34 = (Var)RT.var("potemkin.types", "deftype->deftype*");
    const__35 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(79), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__36 = (Var)RT.var("potemkin.types", "abstract-type?");
    const__39 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(81), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__40 = (Var)RT.var("potemkin.types", "*expanded-types*");
    const__43 = (AFn)RT.map(new Object[] { RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(84), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__44 = (Var)RT.var("potemkin.types", "expand-deftype");
    const__47 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(86), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__48 = (Var)RT.var("potemkin.types", "transform-deftype*");
    const__51 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(109), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__54 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(116), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__55 = (Var)RT.var("potemkin.types", "deftype*->deftype");
    const__58 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(133), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__59 = (Var)RT.var("potemkin.types", "deftype*->fn-map");
    const__62 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(137), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__65 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "a")), Tuple.create(Symbol.intern(null, "a"), Symbol.intern(null, "b"), Symbol.intern(null, "&"), Symbol.intern(null, "rest")) })), RT.keyword(null, "line"), Integer.valueOf(144), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__66 = (Var)RT.var("potemkin.types", "def-abstract-type");
    const__69 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "An abstract type, which can be used in conjunction with deftype+.", RT.keyword(null, "line"), Integer.valueOf(165), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__70 = (Var)RT.var("potemkin.types", "defprotocol+");
    const__73 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "A protocol that won't evaluate if an equivalent protocol with the same name already exists.", RT.keyword(null, "line"), Integer.valueOf(172), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__74 = (Var)RT.var("potemkin.types", "clojure-fn-subs");
    const__76 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(184), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__95 = (AFn)RT.vector(new Object[] { Tuple.create(Pattern.compile("\\?"), "_QMARK_"), Tuple.create(Pattern.compile("\\-"), "_"), Tuple.create(Pattern.compile("!"), "_BANG_"), Tuple.create(Pattern.compile("\\+"), "_PLUS_"), Tuple.create(Pattern.compile(">"), "_GT_"), Tuple.create(Pattern.compile("<"), "_LT_"), Tuple.create(Pattern.compile("="), "_EQ_"), Tuple.create(Pattern.compile("\\*"), "_STAR_"), Tuple.create(Pattern.compile("/"), "_SLASH_") });
    const__96 = (Var)RT.var("potemkin.types", "munge-fn-name");
    const__99 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "line"), Integer.valueOf(195), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
  }
  
  public static void __init1() {
    const__100 = (Var)RT.var("potemkin.types", "resolve-tag");
    const__103 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "line"), Integer.valueOf(205), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__104 = (Var)RT.var("potemkin.types", "untag");
    const__107 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "line"), Integer.valueOf(214), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__108 = (Var)RT.var("potemkin.types", "definterface+");
    const__111 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "An interface that won't evaluate if an interface with that name already exists.\n\n   Self parameters and multiple arities are defined like defprotocol, as well as wrapping\n   functions for each, so it can be used to replace defprotocol seamlessly.", RT.keyword(null, "line"), Integer.valueOf(217), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__112 = (Var)RT.var("potemkin.types", "deftype+");
    const__115 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "params"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "A deftype that won't evaluate if an equivalent datatype with the same name already exists,\n   and allows abstract types to be used.", RT.keyword(null, "line"), Integer.valueOf(291), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__116 = (Var)RT.var("potemkin.types", "reify+");
    const__119 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "A reify that supports abstract types.", RT.keyword(null, "line"), Integer.valueOf(314), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
    const__120 = (Var)RT.var("potemkin.types", "defrecord+");
    const__123 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "A defrecord that won't evaluate if an equivalent datatype with the same name already exists.", RT.keyword(null, "line"), Integer.valueOf(326), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "potemkin/types.clj" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("potemkin.types__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
