package ring.middleware;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class session__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__3;
  
  public static final AFn const__4;
  
  public static final Var const__5;
  
  public static final AFn const__14;
  
  public static final Var const__15;
  
  public static final AFn const__18;
  
  public static final Var const__19;
  
  public static final AFn const__23;
  
  public static final Var const__24;
  
  public static final AFn const__27;
  
  public static final Var const__28;
  
  public static final AFn const__31;
  
  public static final Var const__32;
  
  public static final AFn const__35;
  
  public static void load() { LockingTransaction.runInTransaction((Callable)new session.fn__60210());
    const__5.setMeta((IPersistentMap)const__14);
    const__5.bindRoot(new session.session_options());
    const__15.setMeta((IPersistentMap)const__18);
    const__15.bindRoot(new session.bare_session_request());
    const__19.setMeta((IPersistentMap)const__23);
    const__19.bindRoot(new session.session_request());
    const__24.setMeta((IPersistentMap)const__27);
    const__24.bindRoot(new session.bare_session_response());
    const__28.setMeta((IPersistentMap)const__31);
    const__28.bindRoot(new session.session_response());
    const__32.setMeta((IPersistentMap)const__35);
    const__32.bindRoot(new session.wrap_session()); }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "ring.middleware.session")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Middleware for maintaining browser sessions using cookies.\n\n  Sessions are stored using types that adhere to the\n  ring.middleware.session.store/SessionStore protocol.\n  Ring comes with two stores included:\n\n    ring.middleware.session.memory/memory-store\n    ring.middleware.session.cookie/cookie-store" }));
    const__3 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Middleware for maintaining browser sessions using cookies.\n\n  Sessions are stored using types that adhere to the\n  ring.middleware.session.store/SessionStore protocol.\n  Ring comes with two stores included:\n\n    ring.middleware.session.memory/memory-store\n    ring.middleware.session.cookie/cookie-store" });
    const__4 = (AFn)Symbol.intern(null, "clojure.core");
    const__5 = (Var)RT.var("ring.middleware.session", "session-options");
    const__14 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "options")) })), RT.keyword(null, "line"), Integer.valueOf(14), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ring/middleware/session.clj" });
    const__15 = (Var)RT.var("ring.middleware.session", "bare-session-request");
    const__18 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "request"), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "cookie-name")) })) })), RT.keyword(null, "line"), Integer.valueOf(24), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ring/middleware/session.clj" });
    const__19 = (Var)RT.var("ring.middleware.session", "session-request");
    const__23 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "request")), Tuple.create(Symbol.intern(null, "request"), Symbol.intern(null, "options")) })), RT.keyword(null, "doc"), "Reads current HTTP session map and adds it to :session key of the request.\n  See: wrap-session.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(32), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "ring/middleware/session.clj" });
    const__24 = (Var)RT.var("ring.middleware.session", "bare-session-response");
    const__27 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "response"), RT.map(new Object[] { Symbol.intern(null, "session-key"), RT.keyword("session", "key") }), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "cookie-name"), Symbol.intern(null, "cookie-attrs")) })) })), RT.keyword(null, "line"), Integer.valueOf(43), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ring/middleware/session.clj" });
    const__28 = (Var)RT.var("ring.middleware.session", "session-response");
    const__31 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "response"), Symbol.intern(null, "request")), Tuple.create(Symbol.intern(null, "response"), Symbol.intern(null, "request"), Symbol.intern(null, "options")) })), RT.keyword(null, "doc"), "Updates session based on :session key in response. See: wrap-session.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(66), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "ring/middleware/session.clj" });
    const__32 = (Var)RT.var("ring.middleware.session", "wrap-session");
    const__35 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "handler")), Tuple.create(Symbol.intern(null, "handler"), Symbol.intern(null, "options")) })), RT.keyword(null, "doc"), "Reads in the current HTTP session map, and adds it to the :session key on\n  the request. If a :session key is added to the response by the handler, the\n  session is updated with the new value. If the value is nil, the session is\n  deleted.\n\n  Accepts the following options:\n\n  :store        - An implementation of the SessionStore protocol in the\n                  ring.middleware.session.store namespace. This determines how\n                  the session is stored. Defaults to in-memory storage using\n                  ring.middleware.session.store/memory-store.\n\n  :root         - The root path of the session. Any path above this will not be\n                  able to see this session. Equivalent to setting the cookie's\n                  path attribute. Defaults to \"/\".\n\n  :cookie-name  - The name of the cookie that holds the session key. Defaults to\n                  \"ring-session\".\n\n  :cookie-attrs - A map of attributes to associate with the session cookie.\n                  Defaults to {:http-only true}. This may be overridden on a\n                  per-response basis by adding :session-cookie-attrs to the\n                  response.", RT.keyword(null, "line"), Integer.valueOf(77), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ring/middleware/session.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("ring.middleware.session__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
