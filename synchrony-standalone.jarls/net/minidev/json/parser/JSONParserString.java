package net.minidev.json.parser;

import net.minidev.json.JSONValue;
import net.minidev.json.writer.JsonReaderI;

class JSONParserString extends JSONParserMemory {
  private String in;
  
  public JSONParserString(int permissiveMode) { super(permissiveMode); }
  
  public Object parse(String in) throws ParseException { return parse(in, JSONValue.defaultReader.DEFAULT); }
  
  public <T> T parse(String in, JsonReaderI<T> mapper) throws ParseException {
    this.base = mapper.base;
    this.in = in;
    this.len = in.length();
    return (T)parse(mapper);
  }
  
  protected void extractString(int beginIndex, int endIndex) { this.xs = this.in.substring(beginIndex, endIndex); }
  
  protected void extractStringTrim(int start, int stop) {
    while (start < stop - 1 && Character.isWhitespace(this.in.charAt(start)))
      start++; 
    while (stop - 1 > start && Character.isWhitespace(this.in.charAt(stop - 1)))
      stop--; 
    extractString(start, stop);
  }
  
  protected int indexOf(char c, int pos) { return this.in.indexOf(c, pos); }
  
  protected void read() {
    if (++this.pos >= this.len) {
      this.c = '\032';
    } else {
      this.c = this.in.charAt(this.pos);
    } 
  }
  
  protected void readS() {
    if (++this.pos >= this.len) {
      this.c = '\032';
    } else {
      this.c = this.in.charAt(this.pos);
    } 
  }
  
  protected void readNoEnd() {
    if (++this.pos >= this.len) {
      this.c = '\032';
      throw new ParseException(this.pos - 1, 3, "EOF");
    } 
    this.c = this.in.charAt(this.pos);
  }
}
