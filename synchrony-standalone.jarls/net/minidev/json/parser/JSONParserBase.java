package net.minidev.json.parser;

import java.io.IOException;
import java.math.BigDecimal;
import java.math.BigInteger;
import net.minidev.json.writer.JsonReader;
import net.minidev.json.writer.JsonReaderI;

abstract class JSONParserBase {
  protected char c;
  
  public static final int MAX_DEPTH = 400;
  
  protected int depth;
  
  JsonReader base;
  
  public static final byte EOI = 26;
  
  protected static final char MAX_STOP = '~';
  
  private String lastKey;
  
  protected static boolean[] stopAll = new boolean[126];
  
  protected static boolean[] stopArray = new boolean[126];
  
  protected static boolean[] stopKey = new boolean[126];
  
  protected static boolean[] stopValue = new boolean[126];
  
  protected static boolean[] stopX = new boolean[126];
  
  protected final MSB sb;
  
  protected Object xo;
  
  protected String xs;
  
  protected int pos;
  
  protected final boolean acceptLeadinZero;
  
  protected final boolean acceptNaN;
  
  protected final boolean acceptNonQuote;
  
  protected final boolean acceptSimpleQuote;
  
  protected final boolean acceptUselessComma;
  
  protected final boolean checkTaillingData;
  
  protected final boolean checkTaillingSpace;
  
  protected final boolean ignoreControlChar;
  
  protected final boolean useHiPrecisionFloat;
  
  protected final boolean useIntegerStorage;
  
  protected final boolean reject127;
  
  protected final boolean unrestictBigDigit;
  
  static  {
    stopKey[26] = true;
    stopKey[58] = true;
    stopValue[26] = true;
    stopValue[125] = true;
    stopValue[44] = true;
    stopArray[26] = true;
    stopArray[93] = true;
    stopArray[44] = true;
    stopX[26] = true;
    stopAll[58] = true;
    stopAll[44] = true;
    stopAll[26] = true;
    stopAll[125] = true;
    stopAll[93] = true;
  }
  
  public JSONParserBase(int permissiveMode) {
    this.depth = 0;
    this.sb = new MSB(15);
    this.acceptNaN = ((permissiveMode & 0x4) > 0);
    this.acceptNonQuote = ((permissiveMode & 0x2) > 0);
    this.acceptSimpleQuote = ((permissiveMode & true) > 0);
    this.ignoreControlChar = ((permissiveMode & 0x8) > 0);
    this.useIntegerStorage = ((permissiveMode & 0x10) > 0);
    this.acceptLeadinZero = ((permissiveMode & 0x20) > 0);
    this.acceptUselessComma = ((permissiveMode & 0x40) > 0);
    this.useHiPrecisionFloat = ((permissiveMode & 0x80) > 0);
    this.checkTaillingData = ((permissiveMode & 0x300) != 768);
    this.checkTaillingSpace = ((permissiveMode & 0x200) == 0);
    this.reject127 = ((permissiveMode & 0x400) > 0);
    this.unrestictBigDigit = ((permissiveMode & 0x800) > 0);
  }
  
  public void checkControleChar() throws ParseException {
    if (this.ignoreControlChar)
      return; 
    int l = this.xs.length();
    for (int i = 0; i < l; i++) {
      char c = this.xs.charAt(i);
      if (c >= '\000') {
        if (c <= '\037')
          throw new ParseException(this.pos + i, 0, Character.valueOf(c)); 
        if (c == '' && 
          this.reject127)
          throw new ParseException(this.pos + i, 0, Character.valueOf(c)); 
      } 
    } 
  }
  
  public void checkLeadinZero() throws ParseException {
    int len = this.xs.length();
    if (len == 1)
      return; 
    if (len == 2) {
      if (this.xs.equals("00"))
        throw new ParseException(this.pos, 6, this.xs); 
      return;
    } 
    char c1 = this.xs.charAt(0);
    char c2 = this.xs.charAt(1);
    if (c1 == '-') {
      char c3 = this.xs.charAt(2);
      if (c2 == '0' && c3 >= '0' && c3 <= '9')
        throw new ParseException(this.pos, 6, this.xs); 
      return;
    } 
    if (c1 == '0' && c2 >= '0' && c2 <= '9')
      throw new ParseException(this.pos, 6, this.xs); 
  }
  
  protected Number extractFloat() throws ParseException {
    if (!this.acceptLeadinZero)
      checkLeadinZero(); 
    try {
      if (!this.useHiPrecisionFloat)
        return Float.valueOf(Float.parseFloat(this.xs)); 
      if (this.xs.length() > 18) {
        if (!this.unrestictBigDigit) {
          double asDouble = Double.parseDouble(this.xs);
          String doubleStr = String.valueOf(asDouble);
          if (compareDoublePrecision(doubleStr, this.xs))
            return Double.valueOf(asDouble); 
        } 
        return new BigDecimal(this.xs);
      } 
      return Double.valueOf(Double.parseDouble(this.xs));
    } catch (NumberFormatException e) {
      throw new ParseException(this.pos, 1, this.xs);
    } 
  }
  
  private boolean compareDoublePrecision(String convert, String origin) {
    char[] charArray = convert.toCharArray();
    char[] originArray = origin.toCharArray();
    if (charArray.length > originArray.length)
      return false; 
    int j = 0;
    for (int i = 0; i < charArray.length; i++) {
      if (charArray[i] < '0' || charArray[i] > '9') {
        if (originArray[j] >= '0' && originArray[j] <= '9')
          return false; 
        j++;
        if (originArray[j] == '+')
          j++; 
      } else {
        if (charArray[i] != originArray[j])
          return false; 
        j++;
      } 
    } 
    return (j == originArray.length);
  }
  
  protected <T> T parse(JsonReaderI<T> mapper) throws ParseException {
    T result;
    this.pos = -1;
    try {
      read();
      result = (T)readFirst(mapper);
      if (this.checkTaillingData) {
        if (!this.checkTaillingSpace)
          skipSpace(); 
        if (this.c != '\032')
          throw new ParseException(this.pos - 1, 1, Character.valueOf(this.c)); 
      } 
    } catch (IOException e) {
      throw new ParseException(this.pos, e);
    } 
    this.xs = null;
    this.xo = null;
    return result;
  }
  
  protected Number parseNumber(String s) throws ParseException {
    boolean mustCheck, neg;
    int p = 0;
    int l = s.length();
    int max = 19;
    if (s.charAt(0) == '-') {
      p++;
      max++;
      neg = true;
      if (!this.acceptLeadinZero && l >= 3 && s.charAt(1) == '0')
        throw new ParseException(this.pos, 6, s); 
    } else {
      neg = false;
      if (!this.acceptLeadinZero && l >= 2 && s.charAt(0) == '0')
        throw new ParseException(this.pos, 6, s); 
    } 
    if (l < max) {
      max = l;
      mustCheck = false;
    } else {
      if (l > max)
        return new BigInteger(s, 10); 
      max = l - 1;
      mustCheck = true;
    } 
    long r = 0L;
    while (p < max)
      r = r * 10L + ('0' - s.charAt(p++)); 
    if (mustCheck) {
      boolean isBig;
      if (r > -922337203685477580L) {
        isBig = false;
      } else if (r < -922337203685477580L) {
        isBig = true;
      } else if (neg) {
        isBig = (s.charAt(p) > '8');
      } else {
        isBig = (s.charAt(p) > '7');
      } 
      if (isBig)
        return new BigInteger(s, 10); 
      r = r * 10L + ('0' - s.charAt(p));
    } 
    if (neg) {
      if (this.useIntegerStorage && r >= -2147483648L)
        return Integer.valueOf((int)r); 
      return Long.valueOf(r);
    } 
    r = -r;
    if (this.useIntegerStorage && r <= 2147483647L)
      return Integer.valueOf((int)r); 
    return Long.valueOf(r);
  }
  
  protected <T> T readArray(JsonReaderI<T> mapper) throws ParseException {
    if (this.c != '[')
      throw new RuntimeException("Internal Error"); 
    if (++this.depth > 400)
      throw new ParseException(this.pos, 7, Character.valueOf(this.c)); 
    Object current = mapper.createArray();
    read();
    boolean needData = false;
    if (this.c == ',' && !this.acceptUselessComma)
      throw new ParseException(this.pos, 0, Character.valueOf(this.c)); 
    while (true) {
      switch (this.c) {
        case '\t':
        case '\n':
        case '\r':
        case ' ':
          read();
          continue;
        case ']':
          if (needData && !this.acceptUselessComma)
            throw new ParseException(this.pos, 0, Character.valueOf(this.c)); 
          this.depth--;
          read();
          return (T)mapper.convert(current);
        case ':':
        case '}':
          throw new ParseException(this.pos, 0, Character.valueOf(this.c));
        case ',':
          if (needData && !this.acceptUselessComma)
            throw new ParseException(this.pos, 0, Character.valueOf(this.c)); 
          read();
          needData = true;
          continue;
        case '\032':
          throw new ParseException(this.pos - 1, 3, "EOF");
      } 
      mapper.addValue(current, readMain(mapper, stopArray));
      needData = false;
    } 
  }
  
  protected <T> T readFirst(JsonReaderI<T> mapper) throws ParseException {
    while (true) {
      switch (this.c) {
        case '\t':
        case '\n':
        case '\r':
        case ' ':
          read();
          continue;
        case ':':
        case ']':
        case '}':
          throw new ParseException(this.pos, 0, Character.valueOf(this.c));
        case '{':
          return (T)readObject(mapper);
        case '[':
          return (T)readArray(mapper);
        case '"':
        case '\'':
          readString();
          return (T)mapper.convert(this.xs);
        case 'n':
          readNQString(stopX);
          if ("null".equals(this.xs))
            return null; 
          if (!this.acceptNonQuote)
            throw new ParseException(this.pos, 1, this.xs); 
          return (T)mapper.convert(this.xs);
        case 'f':
          readNQString(stopX);
          if ("false".equals(this.xs))
            return (T)mapper.convert(Boolean.FALSE); 
          if (!this.acceptNonQuote)
            throw new ParseException(this.pos, 1, this.xs); 
          return (T)mapper.convert(this.xs);
        case 't':
          readNQString(stopX);
          if ("true".equals(this.xs))
            return (T)mapper.convert(Boolean.TRUE); 
          if (!this.acceptNonQuote)
            throw new ParseException(this.pos, 1, this.xs); 
          return (T)mapper.convert(this.xs);
        case 'N':
          readNQString(stopX);
          if (!this.acceptNaN)
            throw new ParseException(this.pos, 1, this.xs); 
          if ("NaN".equals(this.xs))
            return (T)mapper.convert(Float.valueOf(NaNF)); 
          if (!this.acceptNonQuote)
            throw new ParseException(this.pos, 1, this.xs); 
          return (T)mapper.convert(this.xs);
        case '-':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          this.xo = readNumber(stopX);
          return (T)mapper.convert(this.xo);
      } 
      break;
    } 
    readNQString(stopX);
    if (!this.acceptNonQuote)
      throw new ParseException(this.pos, 1, this.xs); 
    return (T)mapper.convert(this.xs);
  }
  
  protected Object readMain(JsonReaderI<?> mapper, boolean[] stop) throws ParseException, IOException {
    while (true) {
      switch (this.c) {
        case '\t':
        case '\n':
        case '\r':
        case ' ':
          read();
          continue;
        case ':':
        case ']':
        case '}':
          throw new ParseException(this.pos, 0, Character.valueOf(this.c));
        case '{':
          return readObject(mapper.startObject(this.lastKey));
        case '[':
          return readArray(mapper.startArray(this.lastKey));
        case '"':
        case '\'':
          readString();
          return this.xs;
        case 'n':
          readNQString(stop);
          if ("null".equals(this.xs))
            return null; 
          if (!this.acceptNonQuote)
            throw new ParseException(this.pos, 1, this.xs); 
          return this.xs;
        case 'f':
          readNQString(stop);
          if ("false".equals(this.xs))
            return Boolean.FALSE; 
          if (!this.acceptNonQuote)
            throw new ParseException(this.pos, 1, this.xs); 
          return this.xs;
        case 't':
          readNQString(stop);
          if ("true".equals(this.xs))
            return Boolean.TRUE; 
          if (!this.acceptNonQuote)
            throw new ParseException(this.pos, 1, this.xs); 
          return this.xs;
        case 'N':
          readNQString(stop);
          if (!this.acceptNaN)
            throw new ParseException(this.pos, 1, this.xs); 
          if ("NaN".equals(this.xs))
            return Float.valueOf(NaNF); 
          if (!this.acceptNonQuote)
            throw new ParseException(this.pos, 1, this.xs); 
          return this.xs;
        case '-':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          return readNumber(stop);
      } 
      break;
    } 
    readNQString(stop);
    if (!this.acceptNonQuote)
      throw new ParseException(this.pos, 1, this.xs); 
    return this.xs;
  }
  
  protected <T> T readObject(JsonReaderI<T> mapper) throws ParseException {
    if (this.c != '{')
      throw new RuntimeException("Internal Error"); 
    if (++this.depth > 400)
      throw new ParseException(this.pos, 7, Character.valueOf(this.c)); 
    Object current = mapper.createObject();
    boolean needData = false;
    boolean acceptData = true;
    while (true) {
      read();
      switch (this.c) {
        case '\t':
        case '\n':
        case '\r':
        case ' ':
          continue;
        case ':':
        case '[':
        case ']':
        case '{':
          throw new ParseException(this.pos, 0, Character.valueOf(this.c));
        case '}':
          if (needData && !this.acceptUselessComma)
            throw new ParseException(this.pos, 0, Character.valueOf(this.c)); 
          this.depth--;
          read();
          return (T)mapper.convert(current);
        case ',':
          if (needData && !this.acceptUselessComma)
            throw new ParseException(this.pos, 0, Character.valueOf(this.c)); 
          acceptData = needData = true;
          continue;
      } 
      if (this.c == '"' || this.c == '\'') {
        readString();
      } else {
        readNQString(stopKey);
        if (!this.acceptNonQuote)
          throw new ParseException(this.pos, 1, this.xs); 
      } 
      String key = this.xs;
      if (!acceptData)
        throw new ParseException(this.pos, 1, key); 
      skipSpace();
      if (this.c != ':') {
        if (this.c == '\032')
          throw new ParseException(this.pos - 1, 3, null); 
        throw new ParseException(this.pos - 1, 0, Character.valueOf(this.c));
      } 
      readNoEnd();
      this.lastKey = key;
      Object value = readMain(mapper, stopValue);
      mapper.setValue(current, key, value);
      this.lastKey = null;
      skipSpace();
      if (this.c == '}') {
        this.depth--;
        read();
        return (T)mapper.convert(current);
      } 
      if (this.c == '\032')
        throw new ParseException(this.pos - 1, 3, null); 
      if (this.c == ',') {
        acceptData = needData = true;
        continue;
      } 
      break;
    } 
    throw new ParseException(this.pos - 1, 1, Character.valueOf(this.c));
  }
  
  protected void readString2() throws ParseException {
    char sep = this.c;
    while (true) {
      read();
      switch (this.c) {
        case '\032':
          throw new ParseException(this.pos - 1, 3, null);
        case '"':
        case '\'':
          if (sep == this.c) {
            read();
            this.xs = this.sb.toString();
            return;
          } 
          this.sb.append(this.c);
          continue;
        case '\\':
          read();
          switch (this.c) {
            case 't':
              this.sb.append('\t');
              continue;
            case 'n':
              this.sb.append('\n');
              continue;
            case 'r':
              this.sb.append('\r');
              continue;
            case 'f':
              this.sb.append('\f');
              continue;
            case 'b':
              this.sb.append('\b');
              continue;
            case '\\':
              this.sb.append('\\');
              continue;
            case '/':
              this.sb.append('/');
              continue;
            case '\'':
              this.sb.append('\'');
              continue;
            case '"':
              this.sb.append('"');
              continue;
            case 'u':
              this.sb.append(readUnicode(4));
              continue;
            case 'x':
              this.sb.append(readUnicode(2));
              continue;
          } 
          continue;
        case '\000':
        case '\001':
        case '\002':
        case '\003':
        case '\004':
        case '\005':
        case '\006':
        case '\007':
        case '\b':
        case '\t':
        case '\n':
        case '\013':
        case '\f':
        case '\r':
        case '\016':
        case '\017':
        case '\020':
        case '\021':
        case '\022':
        case '\023':
        case '\024':
        case '\025':
        case '\026':
        case '\027':
        case '\030':
        case '\031':
        case '\033':
        case '\034':
        case '\035':
        case '\036':
        case '\037':
          if (this.ignoreControlChar)
            continue; 
          throw new ParseException(this.pos, 0, Character.valueOf(this.c));
        case '':
          if (this.ignoreControlChar)
            continue; 
          if (this.reject127)
            throw new ParseException(this.pos, 0, Character.valueOf(this.c)); 
          break;
      } 
      this.sb.append(this.c);
    } 
  }
  
  protected char readUnicode(int totalChars) throws ParseException, IOException {
    int value = 0;
    for (int i = 0; i < totalChars; i++) {
      value *= 16;
      read();
      if (this.c <= '9' && this.c >= '0') {
        value += this.c - '0';
      } else if (this.c <= 'F' && this.c >= 'A') {
        value += this.c - 'A' + '\n';
      } else if (this.c >= 'a' && this.c <= 'f') {
        value += this.c - 'a' + '\n';
      } else {
        if (this.c == '\032')
          throw new ParseException(this.pos, 3, "EOF"); 
        throw new ParseException(this.pos, 4, Character.valueOf(this.c));
      } 
    } 
    return (char)value;
  }
  
  protected void skipDigits() throws ParseException {
    while (true) {
      if (this.c < '0' || this.c > '9')
        return; 
      readS();
    } 
  }
  
  protected void skipNQString(boolean[] stop) throws IOException {
    while (true) {
      if (this.c == '\032' || (this.c >= '\000' && this.c < '~' && stop[this.c]))
        return; 
      readS();
    } 
  }
  
  protected void skipSpace() throws ParseException {
    while (true) {
      if (this.c > ' ' || this.c == '\032')
        return; 
      readS();
    } 
  }
  
  protected abstract void read() throws ParseException;
  
  protected abstract void readNoEnd() throws ParseException;
  
  protected abstract void readNQString(boolean[] paramArrayOfBoolean) throws IOException;
  
  protected abstract Object readNumber(boolean[] paramArrayOfBoolean) throws ParseException, IOException;
  
  abstract void readS() throws ParseException;
  
  protected abstract void readString() throws ParseException;
}
