package net.minidev.json.writer;

import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.concurrent.ConcurrentHashMap;
import net.minidev.json.JSONAwareEx;

public class JsonReader {
  private final ConcurrentHashMap<Type, JsonReaderI<?>> cache;
  
  public JsonReaderI<JSONAwareEx> DEFAULT;
  
  public JsonReaderI<JSONAwareEx> DEFAULT_ORDERED;
  
  public JsonReader() {
    this.cache = new ConcurrentHashMap(100);
    this.cache.put(java.util.Date.class, BeansMapper.MAPPER_DATE);
    this.cache.put(int[].class, ArraysMapper.MAPPER_PRIM_INT);
    this.cache.put(Integer[].class, ArraysMapper.MAPPER_INT);
    this.cache.put(short[].class, ArraysMapper.MAPPER_PRIM_INT);
    this.cache.put(Short[].class, ArraysMapper.MAPPER_INT);
    this.cache.put(long[].class, ArraysMapper.MAPPER_PRIM_LONG);
    this.cache.put(Long[].class, ArraysMapper.MAPPER_LONG);
    this.cache.put(byte[].class, ArraysMapper.MAPPER_PRIM_BYTE);
    this.cache.put(Byte[].class, ArraysMapper.MAPPER_BYTE);
    this.cache.put(char[].class, ArraysMapper.MAPPER_PRIM_CHAR);
    this.cache.put(Character[].class, ArraysMapper.MAPPER_CHAR);
    this.cache.put(float[].class, ArraysMapper.MAPPER_PRIM_FLOAT);
    this.cache.put(Float[].class, ArraysMapper.MAPPER_FLOAT);
    this.cache.put(double[].class, ArraysMapper.MAPPER_PRIM_DOUBLE);
    this.cache.put(Double[].class, ArraysMapper.MAPPER_DOUBLE);
    this.cache.put(boolean[].class, ArraysMapper.MAPPER_PRIM_BOOL);
    this.cache.put(Boolean[].class, ArraysMapper.MAPPER_BOOL);
    this.DEFAULT = new DefaultMapper(this);
    this.DEFAULT_ORDERED = new DefaultMapperOrdered(this);
    this.cache.put(JSONAwareEx.class, this.DEFAULT);
    this.cache.put(net.minidev.json.JSONAware.class, this.DEFAULT);
    this.cache.put(net.minidev.json.JSONArray.class, this.DEFAULT);
    this.cache.put(net.minidev.json.JSONObject.class, this.DEFAULT);
  }
  
  public <T> void remapField(Class<T> type, String fromJson, String toJava) {
    MapperRemapped mapperRemapped = getMapper(type);
    if (!(mapperRemapped instanceof MapperRemapped)) {
      mapperRemapped = new MapperRemapped(mapperRemapped);
      registerReader(type, mapperRemapped);
    } 
    ((MapperRemapped)mapperRemapped).renameField(fromJson, toJava);
  }
  
  public <T> void registerReader(Class<T> type, JsonReaderI<T> mapper) { this.cache.put(type, mapper); }
  
  public <T> JsonReaderI<T> getMapper(Type type) {
    if (type instanceof ParameterizedType)
      return getMapper((ParameterizedType)type); 
    return getMapper((Class)type);
  }
  
  public <T> JsonReaderI<T> getMapper(Class<T> type) {
    BeansMapper.Bean bean = (JsonReaderI)this.cache.get(type);
    if (bean != null)
      return bean; 
    if (type instanceof Class) {
      DefaultMapperCollection defaultMapperCollection;
      if (java.util.Map.class.isAssignableFrom(type)) {
        defaultMapperCollection = new DefaultMapperCollection(this, type);
      } else if (java.util.List.class.isAssignableFrom(type)) {
        defaultMapperCollection = new DefaultMapperCollection(this, type);
      } 
      if (defaultMapperCollection != null) {
        this.cache.put(type, defaultMapperCollection);
        return defaultMapperCollection;
      } 
    } 
    if (type.isArray()) {
      ArraysMapper.GenericMapper genericMapper = new ArraysMapper.GenericMapper(this, type);
    } else if (java.util.List.class.isAssignableFrom(type)) {
      CollectionMapper.ListClass listClass = new CollectionMapper.ListClass(this, type);
    } else if (java.util.Map.class.isAssignableFrom(type)) {
      CollectionMapper.MapClass mapClass = new CollectionMapper.MapClass(this, type);
    } else {
      bean = new BeansMapper.Bean(this, type);
    } 
    this.cache.putIfAbsent(type, bean);
    return bean;
  }
  
  public <T> JsonReaderI<T> getMapper(ParameterizedType type) {
    CollectionMapper.MapType mapType = (JsonReaderI)this.cache.get(type);
    if (mapType != null)
      return mapType; 
    Class<T> clz = (Class)type.getRawType();
    if (java.util.List.class.isAssignableFrom(clz)) {
      CollectionMapper.ListType listType = new CollectionMapper.ListType(this, type);
    } else if (java.util.Map.class.isAssignableFrom(clz)) {
      mapType = new CollectionMapper.MapType(this, type);
    } 
    this.cache.putIfAbsent(type, mapType);
    return mapType;
  }
}
