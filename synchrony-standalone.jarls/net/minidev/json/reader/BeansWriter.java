package net.minidev.json.reader;

import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import net.minidev.json.JSONStyle;
import net.minidev.json.JSONUtil;

public class BeansWriter extends Object implements JsonWriterI<Object> {
  public <E> void writeJSONString(E value, Appendable out, JSONStyle compression) throws IOException {
    try {
      Class<?> nextClass = value.getClass();
      boolean needSep = false;
      compression.objectStart(out);
      while (nextClass != Object.class) {
        Field[] fields = nextClass.getDeclaredFields();
        for (Field field : fields) {
          int m = field.getModifiers();
          if ((m & 0x98) > 0)
            continue; 
          Object v = null;
          if ((m & true) > 0) {
            v = field.get(value);
          } else {
            String g = JSONUtil.getGetterName(field.getName());
            Method mtd = null;
            try {
              mtd = nextClass.getDeclaredMethod(g, new Class[0]);
            } catch (Exception exception) {}
            if (mtd == null) {
              Class<?> c2 = field.getType();
              if (c2 == boolean.class || c2 == Boolean.class) {
                g = JSONUtil.getIsName(field.getName());
                mtd = nextClass.getDeclaredMethod(g, new Class[0]);
              } 
            } 
            if (mtd == null)
              continue; 
            v = mtd.invoke(value, new Object[0]);
          } 
          if (v != null || !compression.ignoreNull()) {
            if (needSep) {
              compression.objectNext(out);
            } else {
              needSep = true;
            } 
            String key = field.getName();
            JsonWriter.writeJSONKV(key, v, out, compression);
          } 
          continue;
        } 
        nextClass = nextClass.getSuperclass();
      } 
      compression.objectStop(out);
    } catch (Exception e) {
      throw new RuntimeException(e);
    } 
  }
}
