package net.minidev.json.reader;

import java.io.IOException;
import java.util.LinkedList;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import net.minidev.json.JSONAware;
import net.minidev.json.JSONAwareEx;
import net.minidev.json.JSONStreamAwareEx;
import net.minidev.json.JSONStyle;
import net.minidev.json.JSONValue;

public class JsonWriter {
  private ConcurrentHashMap<Class<?>, JsonWriterI<?>> data;
  
  private LinkedList<WriterByInterface> writerInterfaces;
  
  public JsonWriter() {
    this.data = new ConcurrentHashMap();
    this.writerInterfaces = new LinkedList();
    init();
  }
  
  public <T> void remapField(Class<T> type, String fromJava, String toJson) {
    BeansWriterASMRemap beansWriterASMRemap = getWrite(type);
    if (!(beansWriterASMRemap instanceof BeansWriterASMRemap)) {
      beansWriterASMRemap = new BeansWriterASMRemap();
      registerWriter(beansWriterASMRemap, new Class[] { type });
    } 
    ((BeansWriterASMRemap)beansWriterASMRemap).renameField(fromJava, toJson);
  }
  
  public JsonWriterI getWriterByInterface(Class<?> clazz) {
    for (WriterByInterface w : this.writerInterfaces) {
      if (w._interface.isAssignableFrom(clazz))
        return w._writer; 
    } 
    return null;
  }
  
  public JsonWriterI getWrite(Class cls) { return (JsonWriterI)this.data.get(cls); }
  
  public static final JsonWriterI<JSONStreamAwareEx> JSONStreamAwareWriter = new Object();
  
  public static final JsonWriterI<JSONStreamAwareEx> JSONStreamAwareExWriter = new Object();
  
  public static final JsonWriterI<JSONAwareEx> JSONJSONAwareExWriter = new Object();
  
  public static final JsonWriterI<JSONAware> JSONJSONAwareWriter = new Object();
  
  public static final JsonWriterI<Iterable<? extends Object>> JSONIterableWriter = new Object();
  
  public static final JsonWriterI<Enum<?>> EnumWriter = new Object();
  
  public static final JsonWriterI<Map<String, ? extends Object>> JSONMapWriter = new Object();
  
  public static final JsonWriterI<Object> beansWriterASM = new BeansWriterASM();
  
  public static final JsonWriterI<Object> beansWriter = new BeansWriter();
  
  public static final JsonWriterI<Object> arrayWriter = new ArrayWriter();
  
  public static final JsonWriterI<Object> toStringWriter = new Object();
  
  public void init() {
    registerWriter(new Object(this), new Class[] { String.class });
    registerWriter(new Object(this), new Class[] { Double.class });
    registerWriter(new Object(this), new Class[] { java.util.Date.class });
    registerWriter(new Object(this), new Class[] { Float.class });
    registerWriter(toStringWriter, new Class[] { Integer.class, Long.class, Byte.class, Short.class, java.math.BigInteger.class, java.math.BigDecimal.class });
    registerWriter(toStringWriter, new Class[] { Boolean.class });
    registerWriter(new Object(this), new Class[] { int[].class });
    registerWriter(new Object(this), new Class[] { short[].class });
    registerWriter(new Object(this), new Class[] { long[].class });
    registerWriter(new Object(this), new Class[] { float[].class });
    registerWriter(new Object(this), new Class[] { double[].class });
    registerWriter(new Object(this), new Class[] { boolean[].class });
    registerWriterInterface(JSONStreamAwareEx.class, JSONStreamAwareExWriter);
    registerWriterInterface(net.minidev.json.JSONStreamAware.class, JSONStreamAwareWriter);
    registerWriterInterface(JSONAwareEx.class, JSONJSONAwareExWriter);
    registerWriterInterface(JSONAware.class, JSONJSONAwareWriter);
    registerWriterInterface(Map.class, JSONMapWriter);
    registerWriterInterface(Iterable.class, JSONIterableWriter);
    registerWriterInterface(Enum.class, EnumWriter);
    registerWriterInterface(Number.class, toStringWriter);
  }
  
  public void addInterfaceWriterFirst(Class<?> interFace, JsonWriterI<?> writer) { registerWriterInterfaceFirst(interFace, writer); }
  
  public void addInterfaceWriterLast(Class<?> interFace, JsonWriterI<?> writer) { registerWriterInterfaceLast(interFace, writer); }
  
  public void registerWriterInterfaceLast(Class<?> interFace, JsonWriterI<?> writer) { this.writerInterfaces.addLast(new WriterByInterface(interFace, writer)); }
  
  public void registerWriterInterfaceFirst(Class<?> interFace, JsonWriterI<?> writer) { this.writerInterfaces.addFirst(new WriterByInterface(interFace, writer)); }
  
  public void registerWriterInterface(Class<?> interFace, JsonWriterI<?> writer) { registerWriterInterfaceLast(interFace, writer); }
  
  public <T> void registerWriter(JsonWriterI<T> writer, Class... cls) {
    for (Class<?> c : cls)
      this.data.put(c, writer); 
  }
  
  public static void writeJSONKV(String key, Object value, Appendable out, JSONStyle compression) throws IOException {
    if (key == null) {
      out.append("null");
    } else if (!compression.mustProtectKey(key)) {
      out.append(key);
    } else {
      out.append('"');
      JSONValue.escape(key, out, compression);
      out.append('"');
    } 
    compression.objectEndOfKey(out);
    if (value instanceof String) {
      compression.writeString(out, (String)value);
    } else {
      JSONValue.writeJSONString(value, out, compression);
    } 
    compression.objectElmStop(out);
  }
}
