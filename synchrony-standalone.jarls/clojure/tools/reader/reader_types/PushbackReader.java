package clojure.tools.reader.reader_types;

import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.Numbers;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Util;
import clojure.lang.Var;
import java.io.Closeable;
import java.io.IOException;

public final class PushbackReader implements IPushbackReader, Reader, Closeable, IType {
  public final Object rdr;
  
  public final Object buf;
  
  public final long buf_len;
  
  long buf_pos;
  
  private static Class __cached_class__0;
  
  private static Class __cached_class__1;
  
  public static final Var const__0 = (Var)RT.var("clojure.tools.reader.impl.utils", "char"), const__5 = (Var)RT.var("clojure.tools.reader.reader-types", "read-char"), const__6 = (Var)RT.var("clojure.tools.reader.reader-types", "peek-char");
  
  public PushbackReader(Object paramObject1, Object paramObject2, long paramLong1, long paramLong2) { this.rdr = paramObject1;
    this.buf = paramObject2;
    this.buf_len = paramLong1;
    this.buf_pos = paramLong2; }
  
  public static IPersistentVector getBasis() { return Tuple.create(Symbol.intern(null, "rdr"), ((IObj)Symbol.intern(null, "buf")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), "[Ljava.lang.Object;" })), ((IObj)Symbol.intern(null, "buf-len")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "buf-pos")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long"), RT.keyword(null, "unsynchronized-mutable"), Boolean.TRUE }))); }
  
  public void close() throws IOException { ((Closeable)this.rdr)
      .close();
    (this.rdr instanceof Closeable) ? null : null; }
  
  public Object unread(Object ch) {
    if (ch != null) {
      if (ch != Boolean.FALSE) {
        if (this.buf_pos == 0L)
          throw (Throwable)new RuntimeException((String)"Pushback buffer is full"); 
        null;
        this.buf_pos = Numbers.dec(this.buf_pos);
        ch = null;
        this = null;
      } 
    } else {
      ch;
    } 
    return null;
  }
  
  public Object peek_char() { if (Util.classOf(this.rdr) != __cached_class__1)
      if (!(this.rdr instanceof Reader)) {
        __cached_class__1 = Util.classOf(this.rdr);
      } else {
        this = null;
        return ((IFn)const__0.getRawRoot()).invoke(((Reader)this.rdr).peek_char());
      }  
    this = null;
    return ((IFn)const__0.getRawRoot()).invoke((this.buf_pos < this.buf_len) ? RT.aget((Object[])this.buf, RT.intCast(this.buf_pos)) : const__6.getRawRoot().invoke(this.rdr)); }
  
  public Object read_char() {
    Object r = RT.aget((Object[])this.buf, RT.intCast(this.buf_pos));
    this.buf_pos = Numbers.inc(this.buf_pos);
    r = null;
    if (Util.classOf(this.rdr) != __cached_class__0)
      if (!(this.rdr instanceof Reader)) {
        __cached_class__0 = Util.classOf(this.rdr);
      } else {
        this = null;
        return ((IFn)const__0.getRawRoot()).invoke(((Reader)this.rdr).read_char());
      }  
    this = null;
    return ((IFn)const__0.getRawRoot()).invoke((this.buf_pos < this.buf_len) ? r : const__5.getRawRoot().invoke(this.rdr));
  }
}
