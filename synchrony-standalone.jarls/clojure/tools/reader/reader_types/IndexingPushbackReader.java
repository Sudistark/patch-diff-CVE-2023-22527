package clojure.tools.reader.reader_types;

import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Util;
import clojure.lang.Var;
import java.io.Closeable;
import java.io.IOException;

public final class IndexingPushbackReader implements IndexingReader, IPushbackReader, Reader, Closeable, IType {
  public final Object rdr;
  
  long line;
  
  long column;
  
  Object line_start_QMARK_;
  
  Object prev;
  
  long prev_column;
  
  public final Object file_name;
  
  private static Class __cached_class__0;
  
  private static Class __cached_class__1;
  
  private static Class __cached_class__2;
  
  public static final Var const__0 = (Var)RT.var("clojure.tools.reader.reader-types", "read-char"), const__1 = (Var)RT.var("clojure.tools.reader.reader-types", "normalize-newline"), const__2 = (Var)RT.var("clojure.tools.reader.impl.utils", "newline?"), const__5 = (Var)RT.var("clojure.tools.reader.reader-types", "peek-char"), const__7 = (Var)RT.var("clojure.tools.reader.reader-types", "unread");
  
  public IndexingPushbackReader(Object paramObject1, long paramLong1, long paramLong2, Object paramObject2, Object paramObject3, long paramLong3, Object paramObject4) { this.rdr = paramObject1;
    this.line = paramLong1;
    this.column = paramLong2;
    this.line_start_QMARK_ = paramObject2;
    this.prev = paramObject3;
    this.prev_column = paramLong3;
    this.file_name = paramObject4; }
  
  public static IPersistentVector getBasis() { return RT.vector(new Object[] { Symbol.intern(null, "rdr"), ((IObj)Symbol.intern(null, "line")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long"), RT.keyword(null, "unsynchronized-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "column")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long"), RT.keyword(null, "unsynchronized-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "line-start?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "unsynchronized-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "prev")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "unsynchronized-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "prev-column")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long"), RT.keyword(null, "unsynchronized-mutable"), Boolean.TRUE })), Symbol.intern(null, "file-name") }); }
  
  public void close() throws IOException { ((Closeable)this.rdr)
      .close();
    (this.rdr instanceof Closeable) ? null : null; }
  
  public Object get_file_name() { return this.file_name; }
  
  public Object get_column_number() {
    this = null;
    return Integer.valueOf(RT.intCast(this.column));
  }
  
  public Object get_line_number() {
    this = null;
    return Integer.valueOf(RT.intCast(this.line));
  }
  
  public Object unread(Object ch) { // Byte code:
    //   0: aload_0
    //   1: getfield line_start_QMARK_ : Ljava/lang/Object;
    //   4: dup
    //   5: ifnull -> 36
    //   8: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   11: if_acmpeq -> 37
    //   14: aload_0
    //   15: aload_0
    //   16: getfield line : J
    //   19: invokestatic dec : (J)J
    //   22: putfield line : J
    //   25: aload_0
    //   26: aload_0
    //   27: getfield prev_column : J
    //   30: putfield column : J
    //   33: goto -> 48
    //   36: pop
    //   37: aload_0
    //   38: aload_0
    //   39: getfield column : J
    //   42: invokestatic dec : (J)J
    //   45: putfield column : J
    //   48: aload_0
    //   49: aload_0
    //   50: getfield prev : Ljava/lang/Object;
    //   53: putfield line_start_QMARK_ : Ljava/lang/Object;
    //   56: aload_0
    //   57: getfield rdr : Ljava/lang/Object;
    //   60: dup
    //   61: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   64: getstatic clojure/tools/reader/reader_types/IndexingPushbackReader.__cached_class__2 : Ljava/lang/Class;
    //   67: if_acmpeq -> 84
    //   70: dup
    //   71: instanceof clojure/tools/reader/reader_types/IPushbackReader
    //   74: ifne -> 104
    //   77: dup
    //   78: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   81: putstatic clojure/tools/reader/reader_types/IndexingPushbackReader.__cached_class__2 : Ljava/lang/Class;
    //   84: getstatic clojure/tools/reader/reader_types/IndexingPushbackReader.const__7 : Lclojure/lang/Var;
    //   87: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   90: swap
    //   91: aload_1
    //   92: aconst_null
    //   93: astore_1
    //   94: aconst_null
    //   95: astore_0
    //   96: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   101: goto -> 115
    //   104: checkcast clojure/tools/reader/reader_types/IPushbackReader
    //   107: aload_1
    //   108: aconst_null
    //   109: astore_1
    //   110: invokeinterface unread : (Ljava/lang/Object;)Ljava/lang/Object;
    //   115: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #115	-> 0
    //   #137	-> 0
    //   #138	-> 19
    //   #140	-> 42
    //   #142	-> 56
    //   #142	-> 94
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   0	115	0	this	Lclojure/tools/reader/reader_types/IndexingPushbackReader;
    //   0	115	1	ch	Ljava/lang/Object; }
  
  public Object peek_char() { if (Util.classOf(this.rdr) != __cached_class__1)
      if (!(this.rdr instanceof Reader)) {
        __cached_class__1 = Util.classOf(this.rdr);
      } else {
        return ((Reader)this.rdr).peek_char();
      }  
    this = null; }
  
  public Object read_char() { // Byte code:
    //   0: aload_0
    //   1: getfield rdr : Ljava/lang/Object;
    //   4: dup
    //   5: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   8: getstatic clojure/tools/reader/reader_types/IndexingPushbackReader.__cached_class__0 : Ljava/lang/Class;
    //   11: if_acmpeq -> 28
    //   14: dup
    //   15: instanceof clojure/tools/reader/reader_types/Reader
    //   18: ifne -> 43
    //   21: dup
    //   22: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   25: putstatic clojure/tools/reader/reader_types/IndexingPushbackReader.__cached_class__0 : Ljava/lang/Class;
    //   28: getstatic clojure/tools/reader/reader_types/IndexingPushbackReader.const__0 : Lclojure/lang/Var;
    //   31: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   34: swap
    //   35: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   40: goto -> 51
    //   43: checkcast clojure/tools/reader/reader_types/Reader
    //   46: invokeinterface read_char : ()Ljava/lang/Object;
    //   51: astore_1
    //   52: aload_1
    //   53: dup
    //   54: ifnull -> 177
    //   57: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   60: if_acmpeq -> 178
    //   63: aload_1
    //   64: aconst_null
    //   65: astore_1
    //   66: astore_2
    //   67: getstatic clojure/tools/reader/reader_types/IndexingPushbackReader.const__1 : Lclojure/lang/Var;
    //   70: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   73: checkcast clojure/lang/IFn
    //   76: aload_0
    //   77: getfield rdr : Ljava/lang/Object;
    //   80: aload_2
    //   81: aconst_null
    //   82: astore_2
    //   83: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   88: astore_3
    //   89: aload_0
    //   90: aload_0
    //   91: getfield line_start_QMARK_ : Ljava/lang/Object;
    //   94: putfield prev : Ljava/lang/Object;
    //   97: aload_0
    //   98: getstatic clojure/tools/reader/reader_types/IndexingPushbackReader.const__2 : Lclojure/lang/Var;
    //   101: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   104: checkcast clojure/lang/IFn
    //   107: aload_3
    //   108: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   113: putfield line_start_QMARK_ : Ljava/lang/Object;
    //   116: aload_0
    //   117: getfield line_start_QMARK_ : Ljava/lang/Object;
    //   120: dup
    //   121: ifnull -> 157
    //   124: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   127: if_acmpeq -> 158
    //   130: aload_0
    //   131: aload_0
    //   132: getfield column : J
    //   135: putfield prev_column : J
    //   138: aload_0
    //   139: lconst_0
    //   140: putfield column : J
    //   143: aload_0
    //   144: aload_0
    //   145: getfield line : J
    //   148: invokestatic inc : (J)J
    //   151: putfield line : J
    //   154: goto -> 160
    //   157: pop
    //   158: aconst_null
    //   159: pop
    //   160: aload_0
    //   161: aload_0
    //   162: getfield column : J
    //   165: invokestatic inc : (J)J
    //   168: putfield column : J
    //   171: aload_3
    //   172: aconst_null
    //   173: astore_3
    //   174: goto -> 179
    //   177: pop
    //   178: aconst_null
    //   179: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #115	-> 0
    //   #121	-> 0
    //   #121	-> 35
    //   #121	-> 52
    //   #122	-> 73
    //   #122	-> 83
    //   #124	-> 104
    //   #124	-> 108
    //   #125	-> 116
    //   #128	-> 148
    //   #129	-> 165
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   89	85	3	ch	Ljava/lang/Object;
    //   67	107	2	ch	Ljava/lang/Object;
    //   52	127	1	temp__5735__auto__3361	Ljava/lang/Object;
    //   0	179	0	this	Lclojure/tools/reader/reader_types/IndexingPushbackReader; }
}
