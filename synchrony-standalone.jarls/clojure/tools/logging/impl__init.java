package clojure.tools.logging;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class impl__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Keyword const__3;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Object const__6;
  
  public static final Var const__7;
  
  public static final Var const__8;
  
  public static final Var const__9;
  
  public static final Var const__10;
  
  public static final ISeq const__11;
  
  public static final Var const__12;
  
  public static final Var const__13;
  
  public static final AFn const__17;
  
  public static final Keyword const__18;
  
  public static final AFn const__19;
  
  public static final Keyword const__20;
  
  public static final Keyword const__21;
  
  public static final AFn const__24;
  
  public static final Keyword const__25;
  
  public static final Var const__26;
  
  public static final Var const__27;
  
  public static final Var const__28;
  
  public static final AFn const__29;
  
  public static final AFn const__30;
  
  public static final Keyword const__31;
  
  public static final AFn const__32;
  
  public static final AFn const__33;
  
  public static final Var const__34;
  
  public static final AFn const__35;
  
  public static final Object const__36;
  
  public static final Var const__37;
  
  public static final ISeq const__38;
  
  public static final AFn const__40;
  
  public static final AFn const__41;
  
  public static final AFn const__44;
  
  public static final AFn const__45;
  
  public static final AFn const__46;
  
  public static final AFn const__47;
  
  public static final AFn const__48;
  
  public static final AFn const__49;
  
  public static final Var const__50;
  
  public static final AFn const__56;
  
  public static final AFn const__59;
  
  public static final Var const__60;
  
  public static final AFn const__62;
  
  public static final AFn const__64;
  
  public static final Var const__65;
  
  public static final AFn const__69;
  
  public static final Var const__70;
  
  public static final AFn const__73;
  
  public static final Var const__74;
  
  public static final AFn const__77;
  
  public static final Var const__78;
  
  public static final AFn const__81;
  
  public static final Var const__82;
  
  public static final AFn const__85;
  
  public static final Var const__86;
  
  public static final AFn const__89;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new impl.fn__8493());
    const__50.setMeta((IPersistentMap)const__56);
    const__50.bindRoot(((IObj)new impl.reify__8563(null)).withMeta((IPersistentMap)const__59));
    const__60.setMeta((IPersistentMap)const__62);
    const__60.bindRoot(((IObj)new impl.reify__8565(null)).withMeta((IPersistentMap)const__64));
    const__65.setMeta((IPersistentMap)const__69);
    const__65.bindRoot(new impl.slf4j_factory());
    const__70.setMeta((IPersistentMap)const__73);
    const__70.bindRoot(new impl.cl_factory());
    const__74.setMeta((IPersistentMap)const__77);
    const__74.bindRoot(new impl.log4j_factory());
    const__78.setMeta((IPersistentMap)const__81);
    const__78.bindRoot(new impl.log4j2_factory());
    const__82.setMeta((IPersistentMap)const__85);
    const__82.bindRoot(new impl.jul_factory());
    const__86.setMeta((IPersistentMap)const__89);
    const__86.bindRoot(new impl.find_factory());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.tools.logging.impl")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "author"), "Alex Taggart", RT.keyword(null, "doc"), "Protocols used to allow access to logging implementations.\n            This namespace only need be used by those providing logging\n            implementations to be consumed by the core api." }));
    const__3 = (Keyword)RT.keyword(null, "doc");
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "author"), "Alex Taggart", RT.keyword(null, "doc"), "Protocols used to allow access to logging implementations.\n            This namespace only need be used by those providing logging\n            implementations to be consumed by the core api." });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = RT.classForName("clojure.tools.logging.impl.Logger");
    const__7 = (Var)RT.var("clojure.core", "alter-meta!");
    const__8 = (Var)RT.var("clojure.tools.logging.impl", "Logger");
    const__9 = (Var)RT.var("clojure.core", "assoc");
    const__10 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__11 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "enabled?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Check if a particular level is enabled for the given Logger.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "logger"), Symbol.intern(null, "level")) })) })), ((IObj)Symbol.intern(null, "write!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Writes a log message to the given Logger.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "logger"), Symbol.intern(null, "level"), Symbol.intern(null, "throwable"), Symbol.intern(null, "message")) })) })) }));
    const__12 = (Var)RT.var("clojure.core", "alter-var-root");
    const__13 = (Var)RT.var("clojure.core", "merge");
    const__17 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.tools.logging.impl.Logger"), RT.keyword(null, "on-interface"), RT.classForName("clojure.tools.logging.impl.Logger"), RT.keyword(null, "doc"), "The protocol through which the core api will interact with an underlying logging\n  implementation.  Implementations should at least support the six standard\n  logging levels if they wish to work from the level-specific macros." });
    const__18 = (Keyword)RT.keyword(null, "sigs");
    const__19 = (AFn)RT.map(new Object[] { RT.keyword(null, "enabled?"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "enabled?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Check if a particular level is enabled for the given Logger.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "logger"), Symbol.intern(null, "level")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "logger"), Symbol.intern(null, "level")) })), RT.keyword(null, "doc"), "Check if a particular level is enabled for the given Logger." }), RT.keyword(null, "write!"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "write!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Writes a log message to the given Logger.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "logger"), Symbol.intern(null, "level"), Symbol.intern(null, "throwable"), Symbol.intern(null, "message")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "logger"), Symbol.intern(null, "level"), Symbol.intern(null, "throwable"), Symbol.intern(null, "message")) })), RT.keyword(null, "doc"), "Writes a log message to the given Logger." }) });
    const__20 = (Keyword)RT.keyword(null, "var");
    const__21 = (Keyword)RT.keyword(null, "method-map");
    const__24 = (AFn)RT.map(new Object[] { RT.keyword(null, "enabled?"), RT.keyword(null, "enabled?"), RT.keyword(null, "write!"), RT.keyword(null, "write!") });
    const__25 = (Keyword)RT.keyword(null, "method-builders");
    const__26 = (Var)RT.var("clojure.core", "intern");
    const__27 = (Var)RT.var("clojure.core", "*ns*");
    const__28 = (Var)RT.var("clojure.core", "with-meta");
    const__29 = (AFn)((IObj)Symbol.intern(null, "enabled?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Check if a particular level is enabled for the given Logger.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "logger"), Symbol.intern(null, "level")) })) }));
    const__30 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "enabled?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Check if a particular level is enabled for the given Logger.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "logger"), Symbol.intern(null, "level")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "logger"), Symbol.intern(null, "level")) })), RT.keyword(null, "doc"), "Check if a particular level is enabled for the given Logger." });
    const__31 = (Keyword)RT.keyword(null, "protocol");
    const__32 = (AFn)((IObj)Symbol.intern(null, "write!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Writes a log message to the given Logger.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "logger"), Symbol.intern(null, "level"), Symbol.intern(null, "throwable"), Symbol.intern(null, "message")) })) }));
    const__33 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "write!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Writes a log message to the given Logger.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "logger"), Symbol.intern(null, "level"), Symbol.intern(null, "throwable"), Symbol.intern(null, "message")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "logger"), Symbol.intern(null, "level"), Symbol.intern(null, "throwable"), Symbol.intern(null, "message")) })), RT.keyword(null, "doc"), "Writes a log message to the given Logger." });
    const__34 = (Var)RT.var("clojure.core", "-reset-methods");
    const__35 = (AFn)Symbol.intern(null, "Logger");
    const__36 = RT.classForName("clojure.tools.logging.impl.LoggerFactory");
    const__37 = (Var)RT.var("clojure.tools.logging.impl", "LoggerFactory");
    const__38 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "name")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns some text identifying the underlying implementation.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "factory")) })) })), ((IObj)Symbol.intern(null, "get-logger")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns an implementation-specific Logger by namespace.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "factory"), Symbol.intern(null, "logger-ns")) })) })) }));
    const__40 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.tools.logging.impl.LoggerFactory"), RT.keyword(null, "on-interface"), RT.classForName("clojure.tools.logging.impl.LoggerFactory"), RT.keyword(null, "doc"), "The protocol through which the core api will obtain an instance satisfying Logger\n  as well as providing information about the particular implementation being used.\n  Implementations should be bound to *logger-factory* in order to be picked up by\n  this library." });
    const__41 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "name")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns some text identifying the underlying implementation.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "factory")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "factory")) })), RT.keyword(null, "doc"), "Returns some text identifying the underlying implementation." }), RT.keyword(null, "get-logger"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-logger")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns an implementation-specific Logger by namespace.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "factory"), Symbol.intern(null, "logger-ns")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "factory"), Symbol.intern(null, "logger-ns")) })), RT.keyword(null, "doc"), "Returns an implementation-specific Logger by namespace." }) });
    const__44 = (AFn)RT.map(new Object[] { RT.keyword(null, "get-logger"), RT.keyword(null, "get-logger"), RT.keyword(null, "name"), RT.keyword(null, "name") });
    const__45 = (AFn)((IObj)Symbol.intern(null, "name")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns some text identifying the underlying implementation.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "factory")) })) }));
    const__46 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "name")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns some text identifying the underlying implementation.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "factory")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "factory")) })), RT.keyword(null, "doc"), "Returns some text identifying the underlying implementation." });
    const__47 = (AFn)((IObj)Symbol.intern(null, "get-logger")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns an implementation-specific Logger by namespace.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "factory"), Symbol.intern(null, "logger-ns")) })) }));
    const__48 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-logger")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns an implementation-specific Logger by namespace.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "factory"), Symbol.intern(null, "logger-ns")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "factory"), Symbol.intern(null, "logger-ns")) })), RT.keyword(null, "doc"), "Returns an implementation-specific Logger by namespace." });
    const__49 = (AFn)Symbol.intern(null, "LoggerFactory");
    const__50 = (Var)RT.var("clojure.tools.logging.impl", "disabled-logger");
    const__56 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(35), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging/impl.clj", RT.keyword(null, "doc"), "A Logger that is not enabled and does nothing on write." });
    const__59 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(37), RT.keyword(null, "column"), Integer.valueOf(3) });
    const__60 = (Var)RT.var("clojure.tools.logging.impl", "disabled-logger-factory");
    const__62 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(41), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging/impl.clj", RT.keyword(null, "doc"), "A LoggerFactory that always provides the disabled-logger." });
    const__64 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(43), RT.keyword(null, "column"), Integer.valueOf(3) });
    const__65 = (Var)RT.var("clojure.tools.logging.impl", "slf4j-factory");
    const__69 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Returns a SLF4J-based implementation of the LoggerFactory protocol, or nil if\n  not available.", RT.keyword(null, "line"), Integer.valueOf(47), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging/impl.clj" });
    const__70 = (Var)RT.var("clojure.tools.logging.impl", "cl-factory");
    const__73 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Returns a Commons Logging-based implementation of the LoggerFactory protocol, or\n  nil if not available.", RT.keyword(null, "line"), Integer.valueOf(94), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging/impl.clj" });
    const__74 = (Var)RT.var("clojure.tools.logging.impl", "log4j-factory");
    const__77 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Returns a Log4j-based implementation of the LoggerFactory protocol, or nil if\n  not available.", RT.keyword(null, "line"), Integer.valueOf(140), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging/impl.clj" });
    const__78 = (Var)RT.var("clojure.tools.logging.impl", "log4j2-factory");
    const__81 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Returns a Log4j2-based implementation of the LoggerFactory protocol, or nil if\n  not available.", RT.keyword(null, "line"), Integer.valueOf(171), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging/impl.clj" });
    const__82 = (Var)RT.var("clojure.tools.logging.impl", "jul-factory");
    const__85 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Returns a java.util.logging-based implementation of the LoggerFactory protocol,\n  or nil if not available.", RT.keyword(null, "line"), Integer.valueOf(208), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging/impl.clj" });
    const__86 = (Var)RT.var("clojure.tools.logging.impl", "find-factory");
    const__89 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Returns the first non-nil value from slf4j-factory, cl-factory,\n   log4j2-factory, log4j-factory, and jul-factory.", RT.keyword(null, "line"), Integer.valueOf(240), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging/impl.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("clojure.tools.logging.impl__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
