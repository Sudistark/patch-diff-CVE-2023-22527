package clojure.tools.analyzer;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class passes__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__3;
  
  public static final AFn const__4;
  
  public static final Var const__5;
  
  public static final AFn const__14;
  
  public static final Var const__15;
  
  public static final AFn const__18;
  
  public static final Var const__19;
  
  public static final AFn const__22;
  
  public static final Var const__23;
  
  public static final AFn const__26;
  
  public static final Var const__27;
  
  public static final AFn const__30;
  
  public static final Var const__31;
  
  public static final AFn const__34;
  
  public static final Var const__35;
  
  public static final AFn const__38;
  
  public static final Var const__39;
  
  public static final AFn const__42;
  
  public static final Var const__43;
  
  public static final AFn const__46;
  
  public static final Var const__47;
  
  public static final AFn const__49;
  
  public static final Var const__50;
  
  public static final Var const__51;
  
  public static final Var const__52;
  
  public static final Var const__53;
  
  public static final AFn const__56;
  
  public static final Var const__57;
  
  public static final AFn const__60;
  
  public static final Var const__61;
  
  public static final AFn const__64;
  
  public static final Var const__65;
  
  public static final AFn const__68;
  
  public static final Var const__69;
  
  public static final AFn const__72;
  
  public static final Var const__73;
  
  public static final AFn const__76;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new passes.fn__1047());
    const__5.setMeta((IPersistentMap)const__14);
    const__5.bindRoot(new passes.has_deps_QMARK_());
    const__15.setMeta((IPersistentMap)const__18);
    const__15.bindRoot(new passes.indicize());
    const__19.setMeta((IPersistentMap)const__22);
    const__19.bindRoot(new passes.remove_pass());
    const__23.setMeta((IPersistentMap)const__26);
    const__23.bindRoot(new passes.desugar_deps());
    const__27.setMeta((IPersistentMap)const__30);
    const__27.bindRoot(new passes.calc_deps());
    const__31.setMeta((IPersistentMap)const__34);
    const__31.bindRoot(new passes.calculate_deps());
    const__35.setMeta((IPersistentMap)const__38);
    const__35.bindRoot(new passes.group());
    const__39.setMeta((IPersistentMap)const__42);
    const__39.bindRoot(new passes.satisfies_affected_QMARK_());
    const__43.setMeta((IPersistentMap)const__46);
    const__43.bindRoot(new passes.maybe_looping_pass());
    const__47.setMeta((IPersistentMap)const__49);
    const__47
















































































































      
      .bindRoot(((IFn)const__50.getRawRoot()).invoke(const__51.getRawRoot(), const__52.getRawRoot()));
    const__53.setMeta((IPersistentMap)const__56);
    const__53.bindRoot(new passes.first_walk());
    const__57.setMeta((IPersistentMap)const__60);
    const__57.bindRoot(new passes.schedule_STAR_());
    const__61.setMeta((IPersistentMap)const__64);
    const__61.bindRoot(new passes.collapse());
    const__65.setMeta((IPersistentMap)const__68);
    const__65.bindRoot(new passes.schedule_passes());
    const__69.setMeta((IPersistentMap)const__72);
    const__69.bindRoot(new passes.compile_passes());
    const__73.setMeta((IPersistentMap)const__76);
    const__73.bindRoot(new passes.schedule());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.tools.analyzer.passes")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Utilities for pass scheduling" }));
    const__3 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Utilities for pass scheduling" });
    const__4 = (AFn)Symbol.intern(null, "clojure.core");
    const__5 = (Var)RT.var("clojure.tools.analyzer.passes", "has-deps?");
    const__14 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pass")) })), RT.keyword(null, "doc"), "Returns true if the pass has some dependencies", RT.keyword(null, "line"), Integer.valueOf(6), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/analyzer/passes.clj" });
    const__15 = (Var)RT.var("clojure.tools.analyzer.passes", "indicize");
    const__18 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "passes")) })), RT.keyword(null, "doc"), "Takes a set of pass-infos and returns a map of pass-name -> pass-info", RT.keyword(null, "line"), Integer.valueOf(11), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/analyzer/passes.clj" });
    const__19 = (Var)RT.var("clojure.tools.analyzer.passes", "remove-pass");
    const__22 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "passes"), Symbol.intern(null, "pass")) })), RT.keyword(null, "doc"), "Takes a set of pass-infos and a pass, and removes the pass from the set of\n   pass-infos, updating :dependencies and :dependants aswell", RT.keyword(null, "line"), Integer.valueOf(16), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/analyzer/passes.clj" });
    const__23 = (Var)RT.var("clojure.tools.analyzer.passes", "desugar-deps");
    const__26 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "passes")) })), RT.keyword(null, "doc"), "Takes a map of pass-name -> pass deps and puts the :after :affects and :before passes\n   in the appropriate pass :depends", RT.keyword(null, "line"), Integer.valueOf(24), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/passes.clj" });
    const__27 = (Var)RT.var("clojure.tools.analyzer.passes", "calc-deps");
    const__30 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "k"), Symbol.intern(null, "deps"), Symbol.intern(null, "passes")) })), RT.keyword(null, "doc"), "Takes a map of pass-name -> pass deps, a pass name, the explicit pass dependencies\n   and a set of available pass-infos.\n   Resolves all the transitive deps of the pass and assocs them to the map, indexed by\n   the pass name.", RT.keyword(null, "line"), Integer.valueOf(33), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/analyzer/passes.clj" });
    const__31 = (Var)RT.var("clojure.tools.analyzer.passes", "calculate-deps");
    const__34 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "passes")) })), RT.keyword(null, "doc"), "Takes a map of pass-name -> pass-info and adds to each pass-info :dependencies and\n   :dependants info, which also contain the transitive dependencies", RT.keyword(null, "line"), Integer.valueOf(46), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/passes.clj" });
    const__35 = (Var)RT.var("clojure.tools.analyzer.passes", "group");
    const__38 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "state")) })), RT.keyword(null, "doc"), "Takes a scheduler state and returns a vector of three elements (or nil):\n   * the :walk of the current group\n   * a vector of consecutive passes that can be collapsed in a single pass (the current group)\n   * the remaining scheduler state\n\n   E.g. given:\n   [{:walk :any .. } {:walk :pre ..} {:walk :post ..} {:walk :pre ..}]\n   it will return:\n   [:pre [{:walk :any ..} {:walk :pre ..}] [{:walk :post ..} {:walk :pre ..}]]", RT.keyword(null, "line"), Integer.valueOf(61), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/passes.clj" });
    const__39 = (Var)RT.var("clojure.tools.analyzer.passes", "satisfies-affected?");
    const__42 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "affects"), Symbol.intern(null, "walk")) }), Symbol.intern(null, "passes")) })), RT.keyword(null, "line"), Integer.valueOf(92), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/passes.clj" });
    const__43 = (Var)RT.var("clojure.tools.analyzer.passes", "maybe-looping-pass");
    const__46 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "free"), Symbol.intern(null, "passes")) })), RT.keyword(null, "line"), Integer.valueOf(99), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/passes.clj" });
    const__47 = (Var)RT.var("clojure.tools.analyzer.passes", "ffilter");
    const__49 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(115), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/passes.clj" });
    const__50 = (Var)RT.var("clojure.core", "comp");
    const__51 = (Var)RT.var("clojure.core", "first");
    const__52 = (Var)RT.var("clojure.core", "filter");
    const__53 = (Var)RT.var("clojure.tools.analyzer.passes", "first-walk");
    const__56 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "c")) })), RT.keyword(null, "line"), Integer.valueOf(117), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/passes.clj" });
    const__57 = (Var)RT.var("clojure.tools.analyzer.passes", "schedule*");
    const__60 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "state"), Symbol.intern(null, "passes")) })), RT.keyword(null, "line"), Integer.valueOf(120), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/passes.clj" });
    const__61 = (Var)RT.var("clojure.tools.analyzer.passes", "collapse");
    const__64 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "state")) })), RT.keyword(null, "line"), Integer.valueOf(134), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/passes.clj" });
    const__65 = (Var)RT.var("clojure.tools.analyzer.passes", "schedule-passes");
    const__68 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "passes")) })), RT.keyword(null, "line"), Integer.valueOf(143), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/passes.clj" });
    const__69 = (Var)RT.var("clojure.tools.analyzer.passes", "compile-passes");
    const__72 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "passes"), Symbol.intern(null, "walk"), Symbol.intern(null, "info")) })), RT.keyword(null, "line"), Integer.valueOf(155), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/passes.clj" });
    const__73 = (Var)RT.var("clojure.tools.analyzer.passes", "schedule");
    const__76 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "passes"), Symbol.intern(null, "&"), Tuple.create(Symbol.intern(null, "opts")))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "pre"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "set?"), Symbol.intern(null, "passes") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(206), RT.keyword(null, "column"), Integer.valueOf(10) })), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "every?"), Symbol.intern(null, "var?"), Symbol.intern(null, "passes") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(207), RT.keyword(null, "column"), Integer.valueOf(10) }))) })) })), RT.keyword(null, "doc"), "Takes a set of Vars that represent tools.analyzer passes and returns a function\n   that takes an AST and applies all the passes and their dependencies to the AST,\n   trying to compose together as many passes as possible to reduce the number of\n   full tree traversals.\n\n   Each pass must have a :pass-info element in its Var's metadata and it must point\n   to a map with the following parameters (:before, :after, :affects and :state are\n   optional):\n   * :after    a set of Vars, the passes that must be run before this pass\n   * :before   a set of Vars, the passes that must be run after this pass\n   * :depends  a set of Vars, the passes this pass depends on, implies :after\n   * :walk     a keyword, one of:\n                 - :none if the pass does its own tree walking and cannot be composed\n                         with other passes\n                 - :post if the pass requires a postwalk and can be composed with other\n                         passes\n                 - :pre  if the pass requires a prewalk and can be composed with other\n                         passes\n                 - :any  if the pass can be composed with other passes in both a prewalk\n                         or a postwalk\n   * :affects  a set of Vars, this pass must be the last in the same tree traversal that all\n               the specified passes must partecipate in\n               This pass must take a function as argument and return the actual pass, the\n               argument represents the reified tree traversal which the pass can use to\n               control a recursive traversal, implies :depends\n   * :state    a no-arg function that should return an atom holding an init value that will be\n               passed as the first argument to the pass (the pass will thus take the ast\n               as the second parameter), the atom will be the same for the whole tree traversal\n               and thus can be used to preserve state across the traversal\n   An opts map might be provided, valid parameters:\n   * :debug?   if true, returns a vector of the scheduled passes rather than the concrete\n               function", RT.keyword(null, "line"), Integer.valueOf(172), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/passes.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("clojure.tools.analyzer.passes__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
