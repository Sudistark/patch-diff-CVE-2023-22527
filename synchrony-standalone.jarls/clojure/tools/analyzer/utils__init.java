package clojure.tools.analyzer;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class utils__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__2;
  
  public static final Var const__3;
  
  public static final AFn const__12;
  
  public static final Var const__13;
  
  public static final AFn const__16;
  
  public static final Var const__17;
  
  public static final AFn const__20;
  
  public static final Var const__21;
  
  public static final AFn const__24;
  
  public static final Var const__25;
  
  public static final AFn const__28;
  
  public static final Var const__29;
  
  public static final AFn const__32;
  
  public static final Var const__33;
  
  public static final AFn const__36;
  
  public static final Var const__37;
  
  public static final AFn const__40;
  
  public static final Var const__41;
  
  public static final AFn const__44;
  
  public static final Var const__45;
  
  public static final AFn const__48;
  
  public static final Var const__49;
  
  public static final AFn const__52;
  
  public static final Var const__53;
  
  public static final AFn const__56;
  
  public static final Var const__57;
  
  public static final AFn const__60;
  
  public static final Var const__61;
  
  public static final AFn const__64;
  
  public static final Var const__65;
  
  public static final AFn const__68;
  
  public static final Var const__69;
  
  public static final AFn const__72;
  
  public static final Var const__73;
  
  public static final AFn const__76;
  
  public static final Var const__77;
  
  public static final AFn const__80;
  
  public static final Var const__81;
  
  public static final AFn const__84;
  
  public static final Var const__85;
  
  public static final AFn const__88;
  
  public static final Var const__89;
  
  public static final AFn const__92;
  
  public static final Var const__93;
  
  public static final AFn const__96;
  
  public static final Var const__97;
  
  public static final AFn const__100;
  
  public static final Var const__101;
  
  public static final AFn const__104;
  
  public static final Var const__105;
  
  public static final AFn const__108;
  
  public static final Var const__109;
  
  public static final AFn const__112;
  
  public static final Var const__113;
  
  public static final AFn const__116;
  
  public static final Var const__117;
  
  public static final AFn const__120;
  
  public static final Var const__121;
  
  public static final AFn const__124;
  
  public static final Var const__125;
  
  public static final AFn const__128;
  
  public static final Var const__129;
  
  public static final AFn const__131;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new utils.fn__647());
    const__3.setMeta((IPersistentMap)const__12);
    const__3.bindRoot(new utils.into_BANG_());
    const__13.setMeta((IPersistentMap)const__16);
    const__13.bindRoot(new utils.rseqv());
    const__17.setMeta((IPersistentMap)const__20);
    const__17.bindRoot(new utils.ctx());
    const__21.setMeta((IPersistentMap)const__24);
    const__21.bindRoot(new utils.dissoc_env());
    const__25.setMeta((IPersistentMap)const__28);
    const__25.bindRoot(new utils.butlast_PLUS_last());
    const__29.setMeta((IPersistentMap)const__32);
    const__29.bindRoot(new utils.update_vals());
    const__33.setMeta((IPersistentMap)const__36);
    const__33.bindRoot(new utils.update_keys());
    const__37.setMeta((IPersistentMap)const__40);
    const__37.bindRoot(new utils.update_kv());
    const__41.setMeta((IPersistentMap)const__44);
    const__41.bindRoot(new utils.record_QMARK_());
    const__45.setMeta((IPersistentMap)const__48);
    const__45.bindRoot(new utils.type_QMARK_());
    const__49.setMeta((IPersistentMap)const__52);
    const__49.bindRoot(new utils.obj_QMARK_());
    const__53.setMeta((IPersistentMap)const__56);
    const__53.bindRoot(new utils.reference_QMARK_());
    const__57.setMeta((IPersistentMap)const__60);
    const__57.bindRoot(new utils.compile_if());
    ((Var)const__57)






































































      
      .setMacro();
    const__61.setMeta((IPersistentMap)const__64);
    const__61.bindRoot(new utils.regex_QMARK_());
    const__65.setMeta((IPersistentMap)const__68);
    const__65.bindRoot(new utils.boolean_QMARK_());
    const__69.setMeta((IPersistentMap)const__72);
    const__69.bindRoot(new utils.classify());
    const__73.setMeta((IPersistentMap)const__76);
    const__73.bindRoot(new utils.private_QMARK_());
    const__77.setMeta((IPersistentMap)const__80);
    const__77.bindRoot(new utils.macro_QMARK_());
    const__81.setMeta((IPersistentMap)const__84);
    const__81.bindRoot(new utils.constant_QMARK_());
    const__85.setMeta((IPersistentMap)const__88);
    const__85.bindRoot(new utils.dynamic_QMARK_());
    const__89.setMeta((IPersistentMap)const__92);
    const__89.bindRoot(new utils.protocol_node_QMARK_());
    const__93.setMeta((IPersistentMap)const__96);
    const__93.bindRoot(new utils.resolve_ns());
    const__97.setMeta((IPersistentMap)const__100);
    const__97.bindRoot(new utils.resolve_sym());
    const__101.setMeta((IPersistentMap)const__104);
    const__101.bindRoot(new utils.arglist_for_arity());
    const__105.setMeta((IPersistentMap)const__108);
    const__105.bindRoot(new utils.select_keys_SINGLEQUOTE_());
    const__109.setMeta((IPersistentMap)const__112);
    const__109.bindRoot(new utils.merge_SINGLEQUOTE_());
    const__113.setMeta((IPersistentMap)const__116);
    const__113.bindRoot(new utils.mapv_SINGLEQUOTE_());
    const__117.setMeta((IPersistentMap)const__120);
    const__117.bindRoot(new utils.source_info());
    const__121.setMeta((IPersistentMap)const__124);
    const__121.bindRoot(new utils._source_info());
    const__125.setMeta((IPersistentMap)const__128);
    const__125.bindRoot(new utils.const_val());
    const__129.setMeta((IPersistentMap)const__131);
    const__129.bindRoot(new utils.mmerge());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "clojure.tools.analyzer.utils");
    const__2 = (AFn)Symbol.intern(null, "clojure.core");
    const__3 = (Var)RT.var("clojure.tools.analyzer.utils", "into!");
    const__12 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "to"), Symbol.intern(null, "from")) })), RT.keyword(null, "doc"), "Like into, but for transients", RT.keyword(null, "line"), Integer.valueOf(15), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__13 = (Var)RT.var("clojure.tools.analyzer.utils", "rseqv");
    const__16 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "v")) })), RT.keyword(null, "doc"), "Same as (comp vec rseq)", RT.keyword(null, "line"), Integer.valueOf(20), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__17 = (Var)RT.var("clojure.tools.analyzer.utils", "ctx");
    const__20 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "env"), Symbol.intern(null, "ctx")) })), RT.keyword(null, "doc"), "Returns a copy of the passed environment with :context set to ctx", RT.keyword(null, "line"), Integer.valueOf(25), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__21 = (Var)RT.var("clojure.tools.analyzer.utils", "dissoc-env");
    const__24 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ast")) })), RT.keyword(null, "doc"), "Dissocs :env from the ast", RT.keyword(null, "line"), Integer.valueOf(30), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__25 = (Var)RT.var("clojure.tools.analyzer.utils", "butlast+last");
    const__28 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Returns same value as (juxt butlast last), but slightly more\n   efficient since it only traverses the input sequence s once, not\n   twice.", RT.keyword(null, "line"), Integer.valueOf(35), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__29 = (Var)RT.var("clojure.tools.analyzer.utils", "update-vals");
    const__32 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Applies f to all the vals in the map", RT.keyword(null, "line"), Integer.valueOf(46), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__33 = (Var)RT.var("clojure.tools.analyzer.utils", "update-keys");
    const__36 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Applies f to all the keys in the map", RT.keyword(null, "line"), Integer.valueOf(51), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__37 = (Var)RT.var("clojure.tools.analyzer.utils", "update-kv");
    const__40 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Applies f to all the keys and vals in the map", RT.keyword(null, "line"), Integer.valueOf(56), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__41 = (Var)RT.var("clojure.tools.analyzer.utils", "record?");
    const__44 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x is a record", RT.keyword(null, "line"), Integer.valueOf(61), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__45 = (Var)RT.var("clojure.tools.analyzer.utils", "type?");
    const__48 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x is a type", RT.keyword(null, "line"), Integer.valueOf(66), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__49 = (Var)RT.var("clojure.tools.analyzer.utils", "obj?");
    const__52 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x implements IObj", RT.keyword(null, "line"), Integer.valueOf(71), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__53 = (Var)RT.var("clojure.tools.analyzer.utils", "reference?");
    const__56 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x implements IReference", RT.keyword(null, "line"), Integer.valueOf(76), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__57 = (Var)RT.var("clojure.tools.analyzer.utils", "compile-if");
    const__60 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "exp"), Symbol.intern(null, "then"), Symbol.intern(null, "&"), Symbol.intern(null, "else")) })), RT.keyword(null, "line"), Integer.valueOf(81), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__61 = (Var)RT.var("clojure.tools.analyzer.utils", "regex?");
    const__64 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x is a regex", RT.keyword(null, "line"), Integer.valueOf(88), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__65 = (Var)RT.var("clojure.tools.analyzer.utils", "boolean?");
    const__68 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x is a boolean", RT.keyword(null, "line"), Integer.valueOf(96), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__69 = (Var)RT.var("clojure.tools.analyzer.utils", "classify");
    const__72 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Returns a keyword describing the form type", RT.keyword(null, "line"), Integer.valueOf(101), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__73 = (Var)RT.var("clojure.tools.analyzer.utils", "private?");
    const__76 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "var")), Tuple.create(Symbol.intern(null, "var"), Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), "Returns true if the var is private", RT.keyword(null, "line"), Integer.valueOf(123), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__77 = (Var)RT.var("clojure.tools.analyzer.utils", "macro?");
    const__80 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "var")), Tuple.create(Symbol.intern(null, "var"), Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), "Returns true if the var maps to a macro", RT.keyword(null, "line"), Integer.valueOf(129), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__81 = (Var)RT.var("clojure.tools.analyzer.utils", "constant?");
    const__84 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "var")), Tuple.create(Symbol.intern(null, "var"), Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), "Returns true if the var is a const", RT.keyword(null, "line"), Integer.valueOf(135), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__85 = (Var)RT.var("clojure.tools.analyzer.utils", "dynamic?");
    const__88 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "var")), Tuple.create(Symbol.intern(null, "var"), Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), "Returns true if the var is dynamic", RT.keyword(null, "line"), Integer.valueOf(141), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__89 = (Var)RT.var("clojure.tools.analyzer.utils", "protocol-node?");
    const__92 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "var")), Tuple.create(Symbol.intern(null, "var"), Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), "Returns true if the var maps to a protocol function", RT.keyword(null, "line"), Integer.valueOf(149), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__93 = (Var)RT.var("clojure.tools.analyzer.utils", "resolve-ns");
    const__96 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ns-sym"), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "ns")) })) })), RT.keyword(null, "doc"), "Resolves the ns mapped by the given sym in the global env", RT.keyword(null, "line"), Integer.valueOf(155), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__97 = (Var)RT.var("clojure.tools.analyzer.utils", "resolve-sym");
  }
  
  public static void __init1() {
    const__100 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sym"), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "ns")), RT.keyword(null, "as"), Symbol.intern(null, "env") })) })), RT.keyword(null, "doc"), "Resolves the value mapped by the given sym in the global env", RT.keyword(null, "line"), Integer.valueOf(163), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__101 = (Var)RT.var("clojure.tools.analyzer.utils", "arglist-for-arity");
    const__104 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fn"), Symbol.intern(null, "argc")) })), RT.keyword(null, "doc"), "Takes a fn node and an argc and returns the matching arglist", RT.keyword(null, "line"), Integer.valueOf(174), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__105 = (Var)RT.var("clojure.tools.analyzer.utils", "select-keys'");
    const__108 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "map"), Symbol.intern(null, "keyseq")) })), RT.keyword(null, "doc"), "Like clojure.core/select-keys, but uses transients and doesn't preserve meta", RT.keyword(null, "line"), Integer.valueOf(185), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__109 = (Var)RT.var("clojure.tools.analyzer.utils", "merge'");
    const__112 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "&"), Symbol.intern(null, "mms")) })), RT.keyword(null, "doc"), "Like merge, but uses transients", RT.keyword(null, "line"), Integer.valueOf(197), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__113 = (Var)RT.var("clojure.tools.analyzer.utils", "mapv'");
    const__116 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "v")) })), RT.keyword(null, "doc"), "Like mapv, but short-circuits on reduced", RT.keyword(null, "line"), Integer.valueOf(202), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__117 = (Var)RT.var("clojure.tools.analyzer.utils", "source-info");
    const__120 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), "Returns the available source-info keys from a map", RT.keyword(null, "line"), Integer.valueOf(214), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__121 = (Var)RT.var("clojure.tools.analyzer.utils", "-source-info");
    const__124 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "env")) })), RT.keyword(null, "doc"), "Returns the source-info of x", RT.keyword(null, "line"), Integer.valueOf(220), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__125 = (Var)RT.var("clojure.tools.analyzer.utils", "const-val");
    const__128 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "val")) })) })), RT.keyword(null, "doc"), "Returns the value of a constant node (either :quote or :const)", RT.keyword(null, "line"), Integer.valueOf(229), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj" });
    const__129 = (Var)RT.var("clojure.tools.analyzer.utils", "mmerge");
    const__131 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(234), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/utils.clj", RT.keyword(null, "doc"), "Same as (fn [m1 m2] (merge-with merge m2 m1))" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("clojure.tools.analyzer.utils__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
