package clojure.tools.analyzer;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentHashSet;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class jvm__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__3;
  
  public static final AFn const__4;
  
  public static final Var const__5;
  
  public static final AFn const__11;
  
  public static final Var const__12;
  
  public static final Var const__13;
  
  public static final AFn const__14;
  
  public static final Var const__15;
  
  public static final AFn const__19;
  
  public static final Var const__20;
  
  public static final AFn const__23;
  
  public static final Var const__24;
  
  public static final AFn const__27;
  
  public static final Var const__28;
  
  public static final AFn const__31;
  
  public static final Var const__32;
  
  public static final AFn const__35;
  
  public static final Var const__36;
  
  public static final AFn const__39;
  
  public static final Var const__40;
  
  public static final AFn const__43;
  
  public static final Var const__44;
  
  public static final AFn const__47;
  
  public static final Var const__48;
  
  public static final AFn const__51;
  
  public static final Var const__52;
  
  public static final AFn const__55;
  
  public static final Var const__56;
  
  public static final AFn const__59;
  
  public static final Var const__60;
  
  public static final AFn const__63;
  
  public static final Var const__64;
  
  public static final AFn const__67;
  
  public static final Var const__68;
  
  public static final AFn const__71;
  
  public static final Var const__72;
  
  public static final AFn const__75;
  
  public static final Var const__76;
  
  public static final AFn const__79;
  
  public static final Var const__80;
  
  public static final AFn const__83;
  
  public static final Var const__84;
  
  public static final AFn const__87;
  
  public static final Var const__88;
  
  public static final AFn const__91;
  
  public static final Var const__92;
  
  public static final AFn const__94;
  
  public static final Var const__95;
  
  public static final Var const__96;
  
  public static final Var const__97;
  
  public static final Var const__98;
  
  public static final Var const__99;
  
  public static final Var const__100;
  
  public static final Var const__101;
  
  public static final Var const__102;
  
  public static final Var const__103;
  
  public static final Var const__104;
  
  public static final Var const__105;
  
  public static final Var const__106;
  
  public static final Var const__107;
  
  public static final Var const__108;
  
  public static final AFn const__110;
  
  public static final Var const__111;
  
  public static final Var const__112;
  
  public static final AFn const__116;
  
  public static final Var const__117;
  
  public static final AFn const__119;
  
  public static final AFn const__135;
  
  public static final Var const__136;
  
  public static final AFn const__139;
  
  public static final Var const__140;
  
  public static final AFn const__144;
  
  public static final Var const__145;
  
  public static final AFn const__148;
  
  public static final Var const__149;
  
  public static final AFn const__152;
  
  public static final Var const__153;
  
  public static final AFn const__156;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new jvm.fn__3752());
    const__5.setMeta((IPersistentMap)const__11);
    const__5










































      
      .bindRoot(((IFn)const__12.getRawRoot()).invoke(const__13.getRawRoot(), const__14));
    const__15.setMeta((IPersistentMap)const__19);
    const__15.bindRoot(new jvm.build_ns_map());
    const__20.setMeta((IPersistentMap)const__23);
    const__20.bindRoot(new jvm.update_ns_map_BANG_());
    const__24.setMeta((IPersistentMap)const__27);
    const__24.bindRoot(new jvm.global_env());
    const__28.setMeta((IPersistentMap)const__31);
    const__28.bindRoot(new jvm.empty_env());
    const__32.setMeta((IPersistentMap)const__35);
    const__32.bindRoot(new jvm.desugar_symbol());
    const__36.setMeta((IPersistentMap)const__39);
    const__36.bindRoot(new jvm.desugar_host_expr());
    const__40.setMeta((IPersistentMap)const__43);
    const__40.bindRoot(new jvm.macroexpand_1());
    const__44.setMeta((IPersistentMap)const__47);
    const__44.bindRoot(new jvm.qualify_arglists());
    const__48.setMeta((IPersistentMap)const__51);
    const__48.bindRoot(new jvm.create_var());
    const__52.setMeta((IPersistentMap)const__55);
    const__52.bindRoot(new jvm.parse_monitor_enter());
    const__56.setMeta((IPersistentMap)const__59);
    const__56.bindRoot(new jvm.parse_monitor_exit());
    const__60.setMeta((IPersistentMap)const__63);
    const__60.bindRoot(new jvm.parse_import_STAR_());
    const__64.setMeta((IPersistentMap)const__67);
    const__64.bindRoot(new jvm.analyze_method_impls());
    const__68.setMeta((IPersistentMap)const__71);
    const__68.bindRoot(new jvm._deftype());
    const__72.setMeta((IPersistentMap)const__75);
    const__72.bindRoot(new jvm.parse_reify_STAR_());
    const__76.setMeta((IPersistentMap)const__79);
    const__76.bindRoot(new jvm.parse_opts_PLUS_methods());
    const__80.setMeta((IPersistentMap)const__83);
    const__80.bindRoot(new jvm.parse_deftype_STAR_());
    const__84.setMeta((IPersistentMap)const__87);
    const__84.bindRoot(new jvm.parse_case_STAR_());
    const__88.setMeta((IPersistentMap)const__91);
    const__88.bindRoot(new jvm.parse());
    const__92.setMeta((IPersistentMap)const__94);
    const__92.bindRoot(RT.set(new Object[] { 
            const__95, const__96, const__97, const__98, const__99, const__100, const__101, const__102, const__103, const__104, 
            const__105, const__106, const__107 }));
    const__108.setMeta((IPersistentMap)const__110);
    const__108









































































































































































































































































































































































      
      .bindRoot(((IFn)const__111.getRawRoot()).invoke(const__92.getRawRoot()));
    const__112.setDynamic(true).setMeta((IPersistentMap)const__116);
    const__112.setDynamic(true).bindRoot(new jvm.run_passes());
    const__117.setMeta((IPersistentMap)const__119);
    const__117.bindRoot(const__135);
    const__136.setMeta((IPersistentMap)const__139);
    const__136.bindRoot(new jvm.analyze());
    const__140.setMeta((IPersistentMap)const__144);
    const__140.bindRoot(new jvm.throw_BANG_());
    const__145.setMeta((IPersistentMap)const__148);
    const__145.bindRoot(new jvm.analyze_PLUS_eval());
    const__149.setMeta((IPersistentMap)const__152);
    const__149.bindRoot(new jvm.analyze_ns());
    const__153.setMeta((IPersistentMap)const__156);
    const__153.bindRoot(new jvm.macroexpand_all());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.tools.analyzer.jvm")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Analyzer for clojure code, extends tools.analyzer with JVM specific passes/forms" }));
    const__3 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Analyzer for clojure code, extends tools.analyzer with JVM specific passes/forms" });
    const__4 = (AFn)Symbol.intern(null, "clojure.core");
    const__5 = (Var)RT.var("clojure.tools.analyzer.jvm", "specials");
    const__11 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(51), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj", RT.keyword(null, "doc"), "Set of the special forms for clojure in the JVM" });
    const__12 = (Var)RT.var("clojure.core", "into");
    const__13 = (Var)RT.var("clojure.tools.analyzer", "specials");
    const__14 = (AFn)PersistentHashSet.create(new Object[] { Symbol.intern(null, "monitor-exit"), Symbol.intern(null, "case*"), Symbol.intern(null, "reify*"), Symbol.intern("clojure.core", "import*"), Symbol.intern(null, "deftype*"), Symbol.intern(null, "monitor-enter") });
    const__15 = (Var)RT.var("clojure.tools.analyzer.jvm", "build-ns-map");
    const__19 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "line"), Integer.valueOf(56), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__20 = (Var)RT.var("clojure.tools.analyzer.jvm", "update-ns-map!");
    const__23 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "line"), Integer.valueOf(65), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__24 = (Var)RT.var("clojure.tools.analyzer.jvm", "global-env");
    const__27 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "line"), Integer.valueOf(68), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__28 = (Var)RT.var("clojure.tools.analyzer.jvm", "empty-env");
    const__31 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Returns an empty env map", RT.keyword(null, "line"), Integer.valueOf(74), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__32 = (Var)RT.var("clojure.tools.analyzer.jvm", "desugar-symbol");
    const__35 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(81), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__36 = (Var)RT.var("clojure.tools.analyzer.jvm", "desugar-host-expr");
    const__39 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(90), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__40 = (Var)RT.var("clojure.tools.analyzer.jvm", "macroexpand-1");
    const__43 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")), Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env")) })), RT.keyword(null, "doc"), "If form represents a macro form or an inlineable function,returns its expansion,\n   else returns form.", RT.keyword(null, "line"), Integer.valueOf(124), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__44 = (Var)RT.var("clojure.tools.analyzer.jvm", "qualify-arglists");
    const__47 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "arglists")) })), RT.keyword(null, "line"), Integer.valueOf(173), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__48 = (Var)RT.var("clojure.tools.analyzer.jvm", "create-var");
    const__51 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sym"), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "ns")) })) })), RT.keyword(null, "doc"), "Creates a Var for sym and returns it.\n   The Var gets interned in the env namespace.", RT.keyword(null, "line"), Integer.valueOf(187), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__52 = (Var)RT.var("clojure.tools.analyzer.jvm", "parse-monitor-enter");
    const__55 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "target"), RT.keyword(null, "as"), Symbol.intern(null, "form")), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(201), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__56 = (Var)RT.var("clojure.tools.analyzer.jvm", "parse-monitor-exit");
    const__59 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "target"), RT.keyword(null, "as"), Symbol.intern(null, "form")), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(213), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__60 = (Var)RT.var("clojure.tools.analyzer.jvm", "parse-import*");
    const__63 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "class"), RT.keyword(null, "as"), Symbol.intern(null, "form")), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(225), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__64 = (Var)RT.var("clojure.tools.analyzer.jvm", "analyze-method-impls");
    const__67 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "method"), Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "&"), Symbol.intern(null, "params"), RT.keyword(null, "as"), Symbol.intern(null, "args")), Symbol.intern(null, "&"), Symbol.intern(null, "body"), RT.keyword(null, "as"), Symbol.intern(null, "form")), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(236), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__68 = (Var)RT.var("clojure.tools.analyzer.jvm", "-deftype");
    const__71 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "class-name"), Symbol.intern(null, "args"), Symbol.intern(null, "interfaces")) })), RT.keyword(null, "line"), Integer.valueOf(269), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__72 = (Var)RT.var("clojure.tools.analyzer.jvm", "parse-reify*");
    const__75 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "interfaces"), Symbol.intern(null, "&"), Symbol.intern(null, "methods"), RT.keyword(null, "as"), Symbol.intern(null, "form")), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(280), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__76 = (Var)RT.var("clojure.tools.analyzer.jvm", "parse-opts+methods");
    const__79 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "methods")) })), RT.keyword(null, "line"), Integer.valueOf(301), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__80 = (Var)RT.var("clojure.tools.analyzer.jvm", "parse-deftype*");
    const__83 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.vector(new Object[] { Symbol.intern(null, "_"), Symbol.intern(null, "name"), Symbol.intern(null, "class-name"), Symbol.intern(null, "fields"), Symbol.intern(null, "_"), Symbol.intern(null, "interfaces"), Symbol.intern(null, "&"), Symbol.intern(null, "methods"), RT.keyword(null, "as"), Symbol.intern(null, "form") }), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(307), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__84 = (Var)RT.var("clojure.tools.analyzer.jvm", "parse-case*");
    const__87 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.vector(new Object[] { 
                      Symbol.intern(null, "_"), Symbol.intern(null, "expr"), Symbol.intern(null, "shift"), Symbol.intern(null, "mask"), Symbol.intern(null, "default"), Symbol.intern(null, "case-map"), Symbol.intern(null, "switch-type"), Symbol.intern(null, "test-type"), Symbol.intern(null, "&"), Tuple.create(Symbol.intern(null, "skip-check?")), 
                      RT.keyword(null, "as"), Symbol.intern(null, "form") }), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(342), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__88 = (Var)RT.var("clojure.tools.analyzer.jvm", "parse");
    const__91 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env")) })), RT.keyword(null, "doc"), "Extension to tools.analyzer/-parse for JVM special forms", RT.keyword(null, "line"), Integer.valueOf(380), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__92 = (Var)RT.var("clojure.tools.analyzer.jvm", "default-passes");
    const__94 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(393), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj", RT.keyword(null, "doc"), "Set of passes that will be run by default on the AST by #'run-passes" });
    const__95 = (Var)RT.var("clojure.tools.analyzer.passes.jvm.warn-on-reflection", "warn-on-reflection");
    const__96 = (Var)RT.var("clojure.tools.analyzer.passes.warn-earmuff", "warn-earmuff");
    const__97 = (Var)RT.var("clojure.tools.analyzer.passes.elide-meta", "elide-meta");
    const__98 = (Var)RT.var("clojure.tools.analyzer.passes.jvm.validate", "validate");
    const__99 = (Var)RT.var("clojure.tools.analyzer.passes.jvm.validate-loop-locals", "validate-loop-locals");
  }
  
  public static void __init1() {
    const__100 = (Var)RT.var("clojure.tools.analyzer.passes.jvm.analyze-host-expr", "analyze-host-expr");
    const__101 = (Var)RT.var("clojure.tools.analyzer.passes.jvm.box", "box");
    const__102 = (Var)RT.var("clojure.tools.analyzer.passes.trim", "trim");
    const__103 = (Var)RT.var("clojure.tools.analyzer.passes.jvm.classify-invoke", "classify-invoke");
    const__104 = (Var)RT.var("clojure.tools.analyzer.passes.source-info", "source-info");
    const__105 = (Var)RT.var("clojure.tools.analyzer.passes.jvm.infer-tag", "infer-tag");
    const__106 = (Var)RT.var("clojure.tools.analyzer.passes.uniquify", "uniquify-locals");
    const__107 = (Var)RT.var("clojure.tools.analyzer.passes.jvm.constant-lifter", "constant-lift");
    const__108 = (Var)RT.var("clojure.tools.analyzer.jvm", "scheduled-default-passes");
    const__110 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(415), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__111 = (Var)RT.var("clojure.tools.analyzer.passes", "schedule");
    const__112 = (Var)RT.var("clojure.tools.analyzer.jvm", "run-passes");
    const__116 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ast")) })), RT.keyword(null, "doc"), "Function that will be invoked on the AST tree immediately after it has been constructed,\n   by default runs the passes declared in #'default-passes, should be rebound if a different\n   set of passes is required.\n\n   Use #'clojure.tools.analyzer.passes/schedule to get a function from a set of passes that\n   run-passes can be bound to.", RT.keyword(null, "line"), Integer.valueOf(418), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__117 = (Var)RT.var("clojure.tools.analyzer.jvm", "default-passes-opts");
    const__119 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(428), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj", RT.keyword(null, "doc"), "Default :passes-opts for `analyze`" });
    const__135 = (AFn)RT.map(new Object[] { RT.keyword("collect", "what"), PersistentHashSet.create(new Object[] { RT.keyword(null, "callsites"), RT.keyword(null, "constants") }), RT.keyword("collect", "where"), PersistentHashSet.create(new Object[] { RT.keyword(null, "deftype"), RT.keyword(null, "fn"), RT.keyword(null, "reify") }), RT.keyword("collect", "top-level?"), Boolean.FALSE, RT.keyword("collect-closed-overs", "where"), PersistentHashSet.create(new Object[] { RT.keyword(null, "deftype"), RT.keyword(null, "fn"), RT.keyword(null, "reify"), RT.keyword(null, "loop"), RT.keyword(null, "try") }), RT.keyword("collect-closed-overs", "top-level?"), Boolean.FALSE });
    const__136 = (Var)RT.var("clojure.tools.analyzer.jvm", "analyze");
    const__139 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")), Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env")), Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Analyzes a clojure form using tools.analyzer augmented with the JVM specific special ops\n   and returns its AST, after running #'run-passes on it.\n\n   If no configuration option is provides, analyze will setup tools.analyzer using the extension\n   points declared in this namespace.\n\n   If provided, opts should be a map of options to analyze, currently the only valid\n   options are :bindings and :passes-opts (if not provided, :passes-opts defaults to the\n   value of `default-passes-opts`).\n   If provided, :bindings should be a map of Var->value pairs that will be merged into the\n   default bindings for tools.analyzer, useful to provide custom extension points.\n   If provided, :passes-opts should be a map of pass-name-kw->pass-config-map pairs that\n   can be used to configure the behaviour of each pass.\n\n   E.g.\n   (analyze form env {:bindings  {#'ana/macroexpand-1 my-mexpand-1}})", RT.keyword(null, "line"), Integer.valueOf(436), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__140 = (Var)RT.var("clojure.tools.analyzer.jvm", "throw!");
    const__144 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "e")) })), RT.keyword(null, "line"), Integer.valueOf(474), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__145 = (Var)RT.var("clojure.tools.analyzer.jvm", "analyze+eval");
    const__148 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")), Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env")), Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env"), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "handle-evaluation-exception")), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "handle-evaluation-exception"), Symbol.intern(null, "throw!") }), RT.keyword(null, "as"), Symbol.intern(null, "opts") })) })), RT.keyword(null, "doc"), "Like analyze but evals the form after the analysis and attaches the\n   returned value in the :result field of the AST node.\n\n   If evaluating the form will cause an exception to be thrown, the exception\n   will be caught and wrapped in an ExceptionThrown object, containing the\n   exception in the `e` field and the AST in the `ast` field.\n\n   The ExceptionThrown object is then passed to `handle-evaluation-exception`,\n   which by defaults throws the original exception, but can be used to provide\n   a replacement return value for the evaluation of the AST.\n\n   Unrolls `do` forms to handle the Gilardi scenario.\n\n   Useful when analyzing whole files/namespaces.", RT.keyword(null, "line"), Integer.valueOf(477), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__149 = (Var)RT.var("clojure.tools.analyzer.jvm", "analyze-ns");
    const__152 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ns")), Tuple.create(Symbol.intern(null, "ns"), Symbol.intern(null, "env")), Tuple.create(Symbol.intern(null, "ns"), Symbol.intern(null, "env"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Analyzes a whole namespace, returns a vector of the ASTs for all the\n   top-level ASTs of that namespace.\n   Evaluates all the forms.", RT.keyword(null, "line"), Integer.valueOf(540), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
    const__153 = (Var)RT.var("clojure.tools.analyzer.jvm", "macroexpand-all");
    const__156 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")), Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env")), Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Like clojure.walk/macroexpand-all but correctly handles lexical scope", RT.keyword(null, "line"), Integer.valueOf(572), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/jvm.clj" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("clojure.tools.analyzer.jvm__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
