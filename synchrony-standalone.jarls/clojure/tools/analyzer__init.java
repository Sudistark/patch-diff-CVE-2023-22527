package clojure.tools;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentHashSet;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class analyzer__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__3;
  
  public static final AFn const__4;
  
  public static final Var const__5;
  
  public static final Keyword const__6;
  
  public static final Keyword const__7;
  
  public static final Var const__8;
  
  public static final AFn const__15;
  
  public static final Var const__16;
  
  public static final AFn const__17;
  
  public static final Var const__18;
  
  public static final AFn const__19;
  
  public static final Var const__20;
  
  public static final AFn const__21;
  
  public static final Var const__22;
  
  public static final AFn const__23;
  
  public static final Var const__24;
  
  public static final AFn const__25;
  
  public static final Var const__26;
  
  public static final AFn const__29;
  
  public static final Var const__30;
  
  public static final Object const__31;
  
  public static final Object const__32;
  
  public static final Object const__33;
  
  public static final Object const__34;
  
  public static final Object const__35;
  
  public static final Object const__36;
  
  public static final Var const__37;
  
  public static final Object const__38;
  
  public static final Keyword const__39;
  
  public static final Var const__40;
  
  public static final AFn const__44;
  
  public static final Var const__45;
  
  public static final AFn const__48;
  
  public static final Var const__49;
  
  public static final AFn const__52;
  
  public static final Var const__53;
  
  public static final AFn const__56;
  
  public static final Var const__57;
  
  public static final AFn const__60;
  
  public static final Var const__61;
  
  public static final AFn const__64;
  
  public static final Var const__65;
  
  public static final AFn const__68;
  
  public static final Var const__69;
  
  public static final AFn const__72;
  
  public static final AFn const__75;
  
  public static final AFn const__78;
  
  public static final AFn const__81;
  
  public static final AFn const__84;
  
  public static final Var const__85;
  
  public static final AFn const__87;
  
  public static final AFn const__88;
  
  public static final Var const__89;
  
  public static final AFn const__92;
  
  public static final AFn const__95;
  
  public static final AFn const__98;
  
  public static final Var const__99;
  
  public static final AFn const__102;
  
  public static final Var const__103;
  
  public static final AFn const__106;
  
  public static final Var const__107;
  
  public static final AFn const__110;
  
  public static final Var const__111;
  
  public static final AFn const__114;
  
  public static final Var const__115;
  
  public static final AFn const__118;
  
  public static final Var const__119;
  
  public static final AFn const__122;
  
  public static final Var const__123;
  
  public static final AFn const__126;
  
  public static final Var const__127;
  
  public static final AFn const__131;
  
  public static final Var const__132;
  
  public static final AFn const__134;
  
  public static final Var const__135;
  
  public static final AFn const__138;
  
  public static final AFn const__141;
  
  public static final Var const__142;
  
  public static final AFn const__145;
  
  public static final Var const__146;
  
  public static final AFn const__149;
  
  public static final Var const__150;
  
  public static final AFn const__153;
  
  public static final Var const__154;
  
  public static final AFn const__157;
  
  public static final Var const__158;
  
  public static final AFn const__161;
  
  public static final Var const__162;
  
  public static final AFn const__165;
  
  public static final Var const__166;
  
  public static final AFn const__169;
  
  public static final Var const__170;
  
  public static final AFn const__173;
  
  public static final Var const__174;
  
  public static final AFn const__177;
  
  public static final Var const__178;
  
  public static final AFn const__181;
  
  public static final Var const__182;
  
  public static final AFn const__185;
  
  public static final Var const__186;
  
  public static final AFn const__189;
  
  public static final Var const__190;
  
  public static final AFn const__193;
  
  public static final Var const__194;
  
  public static final AFn const__197;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new analyzer.fn__726());
    const__8.setMeta((IPersistentMap)const__15);
    const__16.setMeta((IPersistentMap)const__17);
    const__18.setMeta((IPersistentMap)const__19);
    const__20.setMeta((IPersistentMap)const__21);
    const__22.setMeta((IPersistentMap)const__23);
    const__24.setMeta((IPersistentMap)const__25);
    const__26.setDynamic(true).setMeta((IPersistentMap)const__29);
    const__26.setDynamic(true).bindRoot(const__30.getRawRoot());
    const__40.setMeta((IPersistentMap)const__44);
    const__40.bindRoot(new analyzer.analyze());
    const__45.setMeta((IPersistentMap)const__48);
    const__45.bindRoot(new analyzer.empty_env());
    const__49.setMeta((IPersistentMap)const__52);
    const__49.bindRoot(new analyzer.analyze_in_env());
    const__53.setDynamic(true).setMeta((IPersistentMap)const__56);
    const__57.setDynamic(true).setMeta((IPersistentMap)const__60);
    const__61.setDynamic(true).setMeta((IPersistentMap)const__64);
    const__65.setDynamic(true).setMeta((IPersistentMap)const__68);
    const__69.setMeta((IPersistentMap)const__72);
    const__69.bindRoot(new analyzer.wrapping_meta());
    const__24.setMeta((IPersistentMap)const__75);
    const__24.bindRoot(new analyzer.analyze_const());
    const__16.setMeta((IPersistentMap)const__78);
    const__16.bindRoot(new analyzer.analyze_vector());
    const__18.setMeta((IPersistentMap)const__81);
    const__18.bindRoot(new analyzer.analyze_map());
    const__20.setMeta((IPersistentMap)const__84);
    const__20.bindRoot(new analyzer.analyze_set());
    const__85.setMeta((IPersistentMap)const__87);
    const__85.bindRoot(const__88);
    const__89.setMeta((IPersistentMap)const__92);
    const__89.bindRoot(new analyzer.macroexpand());
    const__8.setMeta((IPersistentMap)const__95);
    const__8.bindRoot(new analyzer.analyze_symbol());
    const__22.setMeta((IPersistentMap)const__98);
    const__22.bindRoot(new analyzer.analyze_seq());
    const__99.setMeta((IPersistentMap)const__102);
    const__99.bindRoot(new analyzer.parse_do());
    const__103.setMeta((IPersistentMap)const__106);
    const__103.bindRoot(new analyzer.parse_if());
    const__107.setMeta((IPersistentMap)const__110);
    const__107.bindRoot(new analyzer.parse_new());
    const__111.setMeta((IPersistentMap)const__114);
    const__111.bindRoot(new analyzer.parse_quote());
    const__115.setMeta((IPersistentMap)const__118);
    const__115.bindRoot(new analyzer.parse_set_BANG_());
    const__119.setMeta((IPersistentMap)const__122);
    const__119.bindRoot(new analyzer.analyze_body());
    const__123.setMeta((IPersistentMap)const__126);
    const__123.bindRoot(new analyzer.valid_binding_symbol_QMARK_());
    const__127.setMeta((IPersistentMap)const__131);
    const__127.bindRoot(new analyzer.split_with_SINGLEQUOTE_());
    const__132.setMeta((IPersistentMap)const__134);
    const__135.setMeta((IPersistentMap)const__138);
    const__135.bindRoot(new analyzer.parse_try());
    const__132.setMeta((IPersistentMap)const__141);
    const__132.bindRoot(new analyzer.parse_catch());
    const__142.setMeta((IPersistentMap)const__145);
    const__142.bindRoot(new analyzer.parse_throw());
    const__146.setMeta((IPersistentMap)const__149);
    const__146.bindRoot(new analyzer.validate_bindings());
    const__150.setMeta((IPersistentMap)const__153);
    const__150.bindRoot(new analyzer.parse_letfn_STAR_());
    const__154.setMeta((IPersistentMap)const__157);
    const__154.bindRoot(new analyzer.analyze_let());
    const__158.setMeta((IPersistentMap)const__161);
    const__158.bindRoot(new analyzer.parse_let_STAR_());
    const__162.setMeta((IPersistentMap)const__165);
    const__162.bindRoot(new analyzer.parse_loop_STAR_());
    const__166.setMeta((IPersistentMap)const__169);
    const__166.bindRoot(new analyzer.parse_recur());
    const__170.setMeta((IPersistentMap)const__173);
    const__170.bindRoot(new analyzer.analyze_fn_method());
    const__174.setMeta((IPersistentMap)const__177);
    const__174.bindRoot(new analyzer.parse_fn_STAR_());
    const__178.setMeta((IPersistentMap)const__181);
    const__178.bindRoot(new analyzer.parse_def());
    const__182.setMeta((IPersistentMap)const__185);
    const__182.bindRoot(new analyzer.parse_dot());
    const__186.setMeta((IPersistentMap)const__189);
    const__186.bindRoot(new analyzer.parse_invoke());
    const__190.setMeta((IPersistentMap)const__193);
    const__190.bindRoot(new analyzer.parse_var());
    const__194.setMeta((IPersistentMap)const__197);
    const__194.bindRoot(new analyzer._parse());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.tools.analyzer")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Analyzer for clojure code, host agnostic.\n\n   Entry point:\n   * analyze\n\n   Platform implementers must provide dynamic bindings for:\n   * macroexpand-1\n   * parse\n   * create-var\n   * var?\n\n   Setting up the global env is also required, see clojure.tools.analyzer.env\n\n   See clojure.tools.analyzer.core-test for an example on how to setup the analyzer." }));
    const__3 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Analyzer for clojure code, host agnostic.\n\n   Entry point:\n   * analyze\n\n   Platform implementers must provide dynamic bindings for:\n   * macroexpand-1\n   * parse\n   * create-var\n   * var?\n\n   Setting up the global env is also required, see clojure.tools.analyzer.env\n\n   See clojure.tools.analyzer.core-test for an example on how to setup the analyzer." });
    const__4 = (AFn)Symbol.intern(null, "clojure.core");
    const__5 = (Var)RT.var("clojure.core", "derive");
    const__6 = (Keyword)RT.keyword("ctx", "return");
    const__7 = (Keyword)RT.keyword("ctx", "expr");
    const__8 = (Var)RT.var("clojure.tools.analyzer", "analyze-symbol");
    const__15 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(33), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__16 = (Var)RT.var("clojure.tools.analyzer", "analyze-vector");
    const__17 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(33), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__18 = (Var)RT.var("clojure.tools.analyzer", "analyze-map");
    const__19 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(33), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__20 = (Var)RT.var("clojure.tools.analyzer", "analyze-set");
    const__21 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(33), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__22 = (Var)RT.var("clojure.tools.analyzer", "analyze-seq");
    const__23 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(33), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__24 = (Var)RT.var("clojure.tools.analyzer", "analyze-const");
    const__25 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(33), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__26 = (Var)RT.var("clojure.tools.analyzer", "analyze-form");
    const__29 = (AFn)RT.map(new Object[] { RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(40), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj", RT.keyword(null, "doc"), "Like analyze, but does not mark the form with :top-level true" });
    const__30 = (Var)RT.var("clojure.tools.analyzer", "-analyze-form");
    const__31 = RT.classForName("clojure.lang.Symbol");
    const__32 = RT.classForName("clojure.lang.IPersistentVector");
    const__33 = RT.classForName("clojure.lang.IPersistentMap");
    const__34 = RT.classForName("clojure.lang.IPersistentSet");
    const__35 = RT.classForName("clojure.lang.ISeq");
    const__36 = RT.classForName("clojure.lang.IType");
    const__37 = (Var)RT.var("clojure.core", "prefer-method");
    const__38 = RT.classForName("clojure.lang.IRecord");
    const__39 = (Keyword)RT.keyword(null, "default");
    const__40 = (Var)RT.var("clojure.tools.analyzer", "analyze");
    const__44 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env")) })), RT.keyword(null, "doc"), "Given a form to analyze and an environment, a map containing:\n   * :locals     a map from binding symbol to AST of the binding value\n   * :context    a keyword describing the form's context from the :ctx/* hierarchy.\n    ** :ctx/expr      the form is an expression: its value is used\n    ** :ctx/return    the form is an expression in return position, derives :ctx/expr\n    ** :ctx/statement the value of the form is not used\n   * :ns         a symbol representing the current namespace of the form to be\n                 analyzed\n\n   returns an AST for that form.\n\n   Every node in the AST is a map that is *guaranteed* to have the following keys:\n   * :op   a keyword describing the AST node\n   * :form the form represented by the AST node\n   * :env  the environment map of the AST node\n\n   Additionaly if the AST node contains sub-nodes, it is guaranteed to have:\n   * :children a vector of the keys of the AST node mapping to the sub-nodes,\n               ordered, when that makes sense\n\n   It is considered a node either the top-level node (marked with :top-level true)\n   or a node that can be reached via :children; if a node contains a node-like\n   map that is not reachable by :children, there's no guarantee that such a map\n   will contain the guaranteed keys.", RT.keyword(null, "line"), Integer.valueOf(88), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__45 = (Var)RT.var("clojure.tools.analyzer", "empty-env");
    const__48 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Returns an empty env", RT.keyword(null, "line"), Integer.valueOf(117), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__49 = (Var)RT.var("clojure.tools.analyzer", "analyze-in-env");
    const__52 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "env")) })), RT.keyword(null, "doc"), "Takes an env map and returns a function that analyzes a form in that env", RT.keyword(null, "line"), Integer.valueOf(124), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__53 = (Var)RT.var("clojure.tools.analyzer", "macroexpand-1");
    const__56 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(130), RT.keyword(null, "column"), Integer.valueOf(19) })), RT.keyword(null, "doc"), "If form represents a macro form, returns its expansion,\n                  else returns form.", RT.keyword(null, "line"), Integer.valueOf(129), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__57 = (Var)RT.var("clojure.tools.analyzer", "parse");
    const__60 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "op"), Symbol.intern(null, "&"), Symbol.intern(null, "args")), Symbol.intern(null, "env")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(136), RT.keyword(null, "column"), Integer.valueOf(19) })), RT.keyword(null, "doc"), "Multimethod that dispatches on op, should default to -parse", RT.keyword(null, "line"), Integer.valueOf(135), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__61 = (Var)RT.var("clojure.tools.analyzer", "create-var");
    const__64 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sym"), Symbol.intern(null, "env")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(141), RT.keyword(null, "column"), Integer.valueOf(19) })), RT.keyword(null, "doc"), "Creates a var for sym and returns it", RT.keyword(null, "line"), Integer.valueOf(140), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__65 = (Var)RT.var("clojure.tools.analyzer", "var?");
    const__68 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "obj")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(146), RT.keyword(null, "column"), Integer.valueOf(19) })), RT.keyword(null, "doc"), "Returns true if obj represent a var form as returned by create-var", RT.keyword(null, "line"), Integer.valueOf(145), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__69 = (Var)RT.var("clojure.tools.analyzer", "wrapping-meta");
    const__72 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env")), RT.keyword(null, "as"), Symbol.intern(null, "expr") })) })), RT.keyword(null, "line"), Integer.valueOf(152), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__75 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env"), Symbol.intern(null, "&"), Tuple.create(Symbol.intern(null, "type"))) })), RT.keyword(null, "line"), Integer.valueOf(165), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__78 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(180), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__81 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(191), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__84 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(207), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__85 = (Var)RT.var("clojure.tools.analyzer", "specials");
    const__87 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(218), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj", RT.keyword(null, "doc"), "Set of special forms common to every clojure variant" });
    const__88 = (AFn)PersistentHashSet.create(new Object[] { 
          Symbol.intern(null, "try"), Symbol.intern(null, "finally"), Symbol.intern(null, "loop*"), Symbol.intern(null, "do"), Symbol.intern(null, "letfn*"), Symbol.intern(null, "if"), Symbol.intern(null, "new"), Symbol.intern(null, "let*"), Symbol.intern(null, "fn*"), Symbol.intern(null, "recur"), 
          Symbol.intern(null, "set!"), Symbol.intern(null, "."), Symbol.intern(null, "var"), Symbol.intern(null, "quote"), Symbol.intern(null, "catch"), Symbol.intern(null, "throw"), Symbol.intern(null, "def") });
    const__89 = (Var)RT.var("clojure.tools.analyzer", "macroexpand");
    const__92 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env")) })), RT.keyword(null, "doc"), "Repeatedly calls macroexpand-1 on form until it no longer\n   represents a macro form, then returns it.", RT.keyword(null, "line"), Integer.valueOf(224), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__95 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sym"), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(234), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__98 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(262), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__99 = (Var)RT.var("clojure.tools.analyzer", "parse-do");
  }
  
  public static void __init1() {
    const__102 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "&"), Symbol.intern(null, "exprs"), RT.keyword(null, "as"), Symbol.intern(null, "form")), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(276), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__103 = (Var)RT.var("clojure.tools.analyzer", "parse-if");
    const__106 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "test"), Symbol.intern(null, "then"), Symbol.intern(null, "else"), RT.keyword(null, "as"), Symbol.intern(null, "form")), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(292), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__107 = (Var)RT.var("clojure.tools.analyzer", "parse-new");
    const__110 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "class"), Symbol.intern(null, "&"), Symbol.intern(null, "args"), RT.keyword(null, "as"), Symbol.intern(null, "form")), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(310), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__111 = (Var)RT.var("clojure.tools.analyzer", "parse-quote");
    const__114 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "expr"), RT.keyword(null, "as"), Symbol.intern(null, "form")), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(325), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__115 = (Var)RT.var("clojure.tools.analyzer", "parse-set!");
    const__118 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "target"), Symbol.intern(null, "val"), RT.keyword(null, "as"), Symbol.intern(null, "form")), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(339), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__119 = (Var)RT.var("clojure.tools.analyzer", "analyze-body");
    const__122 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "body"), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(354), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__123 = (Var)RT.var("clojure.tools.analyzer", "valid-binding-symbol?");
    const__126 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "line"), Integer.valueOf(358), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__127 = (Var)RT.var("clojure.tools.analyzer", "split-with'");
    const__131 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "coll")) })), RT.keyword(null, "line"), Integer.valueOf(363), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__132 = (Var)RT.var("clojure.tools.analyzer", "parse-catch");
    const__134 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(372), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__135 = (Var)RT.var("clojure.tools.analyzer", "parse-try");
    const__138 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "&"), Symbol.intern(null, "body"), RT.keyword(null, "as"), Symbol.intern(null, "form")), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(373), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__141 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.vector(new Object[] { Symbol.intern(null, "_"), Symbol.intern(null, "etype"), Symbol.intern(null, "ename"), Symbol.intern(null, "&"), Symbol.intern(null, "body"), RT.keyword(null, "as"), Symbol.intern(null, "form") }), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(406), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__142 = (Var)RT.var("clojure.tools.analyzer", "parse-throw");
    const__145 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "throw"), RT.keyword(null, "as"), Symbol.intern(null, "form")), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(427), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__146 = (Var)RT.var("clojure.tools.analyzer", "validate-bindings");
    const__149 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "op"), Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "_"), RT.keyword(null, "as"), Symbol.intern(null, "form")), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(439), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__150 = (Var)RT.var("clojure.tools.analyzer", "parse-letfn*");
    const__153 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body"), RT.keyword(null, "as"), Symbol.intern(null, "form")), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(455), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__154 = (Var)RT.var("clojure.tools.analyzer", "analyze-let");
    const__157 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "op"), Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body"), RT.keyword(null, "as"), Symbol.intern(null, "form")), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "context"), Symbol.intern(null, "loop-id")), RT.keyword(null, "as"), Symbol.intern(null, "env") })) })), RT.keyword(null, "line"), Integer.valueOf(490), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__158 = (Var)RT.var("clojure.tools.analyzer", "parse-let*");
    const__161 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(523), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__162 = (Var)RT.var("clojure.tools.analyzer", "parse-loop*");
    const__165 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(530), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__166 = (Var)RT.var("clojure.tools.analyzer", "parse-recur");
    const__169 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "&"), Symbol.intern(null, "exprs"), RT.keyword(null, "as"), Symbol.intern(null, "form")), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "context"), Symbol.intern(null, "loop-locals"), Symbol.intern(null, "loop-id")), RT.keyword(null, "as"), Symbol.intern(null, "env") })) })), RT.keyword(null, "line"), Integer.valueOf(540), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__170 = (Var)RT.var("clojure.tools.analyzer", "analyze-fn-method");
    const__173 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "params"), Symbol.intern(null, "&"), Symbol.intern(null, "body"), RT.keyword(null, "as"), Symbol.intern(null, "form")), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "locals"), Symbol.intern(null, "local")), RT.keyword(null, "as"), Symbol.intern(null, "env") })) })), RT.keyword(null, "line"), Integer.valueOf(564), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__174 = (Var)RT.var("clojure.tools.analyzer", "parse-fn*");
    const__177 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "op"), Symbol.intern(null, "&"), Symbol.intern(null, "args"), RT.keyword(null, "as"), Symbol.intern(null, "form")), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(630), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__178 = (Var)RT.var("clojure.tools.analyzer", "parse-def");
    const__181 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "sym"), Symbol.intern(null, "&"), Symbol.intern(null, "expr"), RT.keyword(null, "as"), Symbol.intern(null, "form")), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "ns")), RT.keyword(null, "as"), Symbol.intern(null, "env") })) })), RT.keyword(null, "line"), Integer.valueOf(677), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__182 = (Var)RT.var("clojure.tools.analyzer", "parse-dot");
    const__185 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "target"), Symbol.intern(null, "&"), Tuple.create(Symbol.intern(null, "m-or-f"), Symbol.intern(null, "&"), Symbol.intern(null, "args")), RT.keyword(null, "as"), Symbol.intern(null, "form")), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(737), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__186 = (Var)RT.var("clojure.tools.analyzer", "parse-invoke");
    const__189 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "args"), RT.keyword(null, "as"), Symbol.intern(null, "form")), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(777), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__190 = (Var)RT.var("clojure.tools.analyzer", "parse-var");
    const__193 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "var"), RT.keyword(null, "as"), Symbol.intern(null, "form")), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(792), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
    const__194 = (Var)RT.var("clojure.tools.analyzer", "-parse");
    const__197 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "env")) })), RT.keyword(null, "doc"), "Takes a form and an env map and dispatches on the head of the form, that is\n   a special form.", RT.keyword(null, "line"), Integer.valueOf(805), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer.clj" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("clojure.tools.analyzer__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
