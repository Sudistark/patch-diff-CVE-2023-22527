package clojure;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class set__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final AFn const__15;
  
  public static final Var const__16;
  
  public static final AFn const__20;
  
  public static final Var const__21;
  
  public static final AFn const__24;
  
  public static final Var const__25;
  
  public static final AFn const__28;
  
  public static final Var const__29;
  
  public static final AFn const__32;
  
  public static final Var const__33;
  
  public static final AFn const__36;
  
  public static final Var const__37;
  
  public static final AFn const__40;
  
  public static final Var const__41;
  
  public static final AFn const__44;
  
  public static final Var const__45;
  
  public static final AFn const__48;
  
  public static final Var const__49;
  
  public static final AFn const__52;
  
  public static final Var const__53;
  
  public static final AFn const__56;
  
  public static final Var const__57;
  
  public static final AFn const__62;
  
  public static final Var const__63;
  
  public static final AFn const__66;
  
  public static void load() { LockingTransaction.runInTransaction((Callable)new set.fn__9183());
    const__6.setMeta((IPersistentMap)const__15);
    const__6.bindRoot(new set.bubble_max_key());
    const__16.setMeta((IPersistentMap)const__20);
    const__16.bindRoot(new set.union());
    const__21.setMeta((IPersistentMap)const__24);
    const__21.bindRoot(new set.intersection());
    const__25.setMeta((IPersistentMap)const__28);
    const__25.bindRoot(new set.difference());
    const__29.setMeta((IPersistentMap)const__32);
    const__29.bindRoot(new set.select());
    const__33.setMeta((IPersistentMap)const__36);
    const__33.bindRoot(new set.project());
    const__37.setMeta((IPersistentMap)const__40);
    const__37.bindRoot(new set.rename_keys());
    const__41.setMeta((IPersistentMap)const__44);
    const__41.bindRoot(new set.rename());
    const__45.setMeta((IPersistentMap)const__48);
    const__45.bindRoot(new set.index());
    const__49.setMeta((IPersistentMap)const__52);
    const__49.bindRoot(new set.map_invert());
    const__53.setMeta((IPersistentMap)const__56);
    const__53.bindRoot(new set.join());
    const__57.setMeta((IPersistentMap)const__62);
    const__57.bindRoot(new set.subset_QMARK_());
    const__63.setMeta((IPersistentMap)const__66);
    const__63.bindRoot(new set.superset_QMARK_()); }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.set")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Set operations such as union/intersection.", RT.keyword(null, "author"), "Rich Hickey" }));
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Set operations such as union/intersection.", RT.keyword(null, "author"), "Rich Hickey" });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.set", "bubble-max-key");
    const__15 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "k"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Move a maximal element of coll according to fn k (which returns a\n  number) to the front of coll.", RT.keyword(null, "line"), Integer.valueOf(13), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/set.clj" });
    const__16 = (Var)RT.var("clojure.set", "union");
    const__20 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "s1")), Tuple.create(Symbol.intern(null, "s1"), Symbol.intern(null, "s2")), Tuple.create(Symbol.intern(null, "s1"), Symbol.intern(null, "s2"), Symbol.intern(null, "&"), Symbol.intern(null, "sets")) })), RT.keyword(null, "doc"), "Return a set that is the union of the input sets", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(20), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/set.clj" });
    const__21 = (Var)RT.var("clojure.set", "intersection");
    const__24 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s1")), Tuple.create(Symbol.intern(null, "s1"), Symbol.intern(null, "s2")), Tuple.create(Symbol.intern(null, "s1"), Symbol.intern(null, "s2"), Symbol.intern(null, "&"), Symbol.intern(null, "sets")) })), RT.keyword(null, "doc"), "Return a set that is the intersection of the input sets", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(33), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/set.clj" });
    const__25 = (Var)RT.var("clojure.set", "difference");
    const__28 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s1")), Tuple.create(Symbol.intern(null, "s1"), Symbol.intern(null, "s2")), Tuple.create(Symbol.intern(null, "s1"), Symbol.intern(null, "s2"), Symbol.intern(null, "&"), Symbol.intern(null, "sets")) })), RT.keyword(null, "doc"), "Return a set that is the first set without elements of the remaining sets", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(49), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/set.clj" });
    const__29 = (Var)RT.var("clojure.set", "select");
    const__32 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "xset")) })), RT.keyword(null, "doc"), "Returns a set of the elements for which pred is true", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(65), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/set.clj" });
    const__33 = (Var)RT.var("clojure.set", "project");
    const__36 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xrel"), Symbol.intern(null, "ks")) })), RT.keyword(null, "doc"), "Returns a rel of the elements of xrel with only the keys in ks", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(72), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/set.clj" });
    const__37 = (Var)RT.var("clojure.set", "rename-keys");
    const__40 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "map"), Symbol.intern(null, "kmap")) })), RT.keyword(null, "doc"), "Returns the map with the keys in kmap renamed to the vals in kmap", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(78), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/set.clj" });
    const__41 = (Var)RT.var("clojure.set", "rename");
    const__44 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xrel"), Symbol.intern(null, "kmap")) })), RT.keyword(null, "doc"), "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(89), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/set.clj" });
    const__45 = (Var)RT.var("clojure.set", "index");
    const__48 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xrel"), Symbol.intern(null, "ks")) })), RT.keyword(null, "doc"), "Returns a map of the distinct values of ks in the xrel mapped to a\n  set of the maps in xrel with the corresponding values of ks.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(95), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/set.clj" });
    const__49 = (Var)RT.var("clojure.set", "map-invert");
    const__52 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), "Returns the map with the vals mapped to the keys.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(106), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/set.clj" });
    const__53 = (Var)RT.var("clojure.set", "join");
    const__56 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xrel"), Symbol.intern(null, "yrel")), Tuple.create(Symbol.intern(null, "xrel"), Symbol.intern(null, "yrel"), Symbol.intern(null, "km")) })), RT.keyword(null, "doc"), "When passed 2 rels, returns the rel corresponding to the natural\n  join. When passed an additional keymap, joins on the corresponding\n  keys.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(111), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/set.clj" });
    const__57 = (Var)RT.var("clojure.set", "subset?");
    const__62 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "set1"), Symbol.intern(null, "set2")) })), RT.keyword(null, "doc"), "Is set1 a subset of set2?", RT.keyword(null, "added"), "1.2", RT.keyword(null, "tag"), RT.classForName("java.lang.Boolean"), RT.keyword(null, "line"), Integer.valueOf(142), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/set.clj" });
    const__63 = (Var)RT.var("clojure.set", "superset?");
    const__66 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "set1"), Symbol.intern(null, "set2")) })), RT.keyword(null, "doc"), "Is set1 a superset of set2?", RT.keyword(null, "added"), "1.2", RT.keyword(null, "tag"), RT.classForName("java.lang.Boolean"), RT.keyword(null, "line"), Integer.valueOf(150), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/set.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("clojure.set__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
