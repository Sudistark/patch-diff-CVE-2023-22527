package clojure;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class walk__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final AFn const__15;
  
  public static final Var const__16;
  
  public static final AFn const__19;
  
  public static final Var const__20;
  
  public static final AFn const__23;
  
  public static final Var const__24;
  
  public static final AFn const__27;
  
  public static final Var const__28;
  
  public static final AFn const__31;
  
  public static final Var const__32;
  
  public static final AFn const__35;
  
  public static final Var const__36;
  
  public static final AFn const__39;
  
  public static final Var const__40;
  
  public static final AFn const__43;
  
  public static final Var const__44;
  
  public static final AFn const__47;
  
  public static final Var const__48;
  
  public static final AFn const__51;
  
  public static void load() { LockingTransaction.runInTransaction((Callable)new walk.fn__9552());
    const__6.setMeta((IPersistentMap)const__15);
    const__6.bindRoot(new walk.walk());
    const__16.setMeta((IPersistentMap)const__19);
    const__16.bindRoot(new walk.postwalk());
    const__20.setMeta((IPersistentMap)const__23);
    const__20.bindRoot(new walk.prewalk());
    const__24.setMeta((IPersistentMap)const__27);
    const__24.bindRoot(new walk.postwalk_demo());
    const__28.setMeta((IPersistentMap)const__31);
    const__28.bindRoot(new walk.prewalk_demo());
    const__32.setMeta((IPersistentMap)const__35);
    const__32.bindRoot(new walk.keywordize_keys());
    const__36.setMeta((IPersistentMap)const__39);
    const__36.bindRoot(new walk.stringify_keys());
    const__40.setMeta((IPersistentMap)const__43);
    const__40.bindRoot(new walk.prewalk_replace());
    const__44.setMeta((IPersistentMap)const__47);
    const__44.bindRoot(new walk.postwalk_replace());
    const__48.setMeta((IPersistentMap)const__51);
    const__48.bindRoot(new walk.macroexpand_all()); }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.walk")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "author"), "Stuart Sierra", RT.keyword(null, "doc"), "This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \"walk\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function." }));
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "author"), "Stuart Sierra", RT.keyword(null, "doc"), "This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \"walk\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function." });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.walk", "walk");
    const__15 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "inner"), Symbol.intern(null, "outer"), Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "line"), Integer.valueOf(35), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/walk.clj" });
    const__16 = (Var)RT.var("clojure.walk", "postwalk");
    const__19 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "line"), Integer.valueOf(53), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/walk.clj" });
    const__20 = (Var)RT.var("clojure.walk", "prewalk");
    const__23 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Like postwalk, but does pre-order traversal.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "line"), Integer.valueOf(61), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/walk.clj" });
    const__24 = (Var)RT.var("clojure.walk", "postwalk-demo");
    const__27 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Demonstrates the behavior of postwalk by printing each form as it is\n  walked.  Returns form.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "line"), Integer.valueOf(80), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/walk.clj" });
    const__28 = (Var)RT.var("clojure.walk", "prewalk-demo");
    const__31 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Demonstrates the behavior of prewalk by printing each form as it is\n  walked.  Returns form.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "line"), Integer.valueOf(87), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/walk.clj" });
    const__32 = (Var)RT.var("clojure.walk", "keywordize-keys");
    const__35 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), "Recursively transforms all map keys from strings to keywords.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "line"), Integer.valueOf(94), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/walk.clj" });
    const__36 = (Var)RT.var("clojure.walk", "stringify-keys");
    const__39 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), "Recursively transforms all map keys from keywords to strings.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "line"), Integer.valueOf(102), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/walk.clj" });
    const__40 = (Var)RT.var("clojure.walk", "prewalk-replace");
    const__43 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "smap"), Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "line"), Integer.valueOf(110), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/walk.clj" });
    const__44 = (Var)RT.var("clojure.walk", "postwalk-replace");
    const__47 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "smap"), Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "line"), Integer.valueOf(118), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/walk.clj" });
    const__48 = (Var)RT.var("clojure.walk", "macroexpand-all");
    const__51 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Recursively performs all possible macroexpansions in form.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "line"), Integer.valueOf(126), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/walk.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("clojure.walk__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
