package clojure;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class zip__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final AFn const__15;
  
  public static final Var const__16;
  
  public static final AFn const__19;
  
  public static final Var const__20;
  
  public static final AFn const__23;
  
  public static final Var const__24;
  
  public static final AFn const__27;
  
  public static final Var const__28;
  
  public static final AFn const__31;
  
  public static final Var const__32;
  
  public static final AFn const__35;
  
  public static final Var const__36;
  
  public static final AFn const__39;
  
  public static final Var const__40;
  
  public static final AFn const__43;
  
  public static final Var const__44;
  
  public static final AFn const__47;
  
  public static final Var const__48;
  
  public static final AFn const__51;
  
  public static final Var const__52;
  
  public static final AFn const__55;
  
  public static final Var const__56;
  
  public static final AFn const__59;
  
  public static final Var const__60;
  
  public static final AFn const__63;
  
  public static final Var const__64;
  
  public static final AFn const__67;
  
  public static final Var const__68;
  
  public static final AFn const__71;
  
  public static final Var const__72;
  
  public static final AFn const__75;
  
  public static final Var const__76;
  
  public static final AFn const__79;
  
  public static final Var const__80;
  
  public static final AFn const__83;
  
  public static final Var const__84;
  
  public static final AFn const__87;
  
  public static final Var const__88;
  
  public static final AFn const__91;
  
  public static final Var const__92;
  
  public static final AFn const__95;
  
  public static final Var const__96;
  
  public static final AFn const__99;
  
  public static final Var const__100;
  
  public static final AFn const__103;
  
  public static final Var const__104;
  
  public static final AFn const__107;
  
  public static final Var const__108;
  
  public static final AFn const__111;
  
  public static final Var const__112;
  
  public static final AFn const__115;
  
  public static final Var const__116;
  
  public static final AFn const__119;
  
  public static final Var const__120;
  
  public static final AFn const__123;
  
  public static void load() { LockingTransaction.runInTransaction((Callable)new zip.fn__9321());
    const__6.setMeta((IPersistentMap)const__15);
    const__6.bindRoot(new zip.zipper());
    const__16.setMeta((IPersistentMap)const__19);
    const__16.bindRoot(new zip.seq_zip());
    const__20.setMeta((IPersistentMap)const__23);
    const__20.bindRoot(new zip.vector_zip());
    const__24.setMeta((IPersistentMap)const__27);
    const__24.bindRoot(new zip.xml_zip());
    const__28.setMeta((IPersistentMap)const__31);
    const__28.bindRoot(new zip.node());
    const__32.setMeta((IPersistentMap)const__35);
    const__32.bindRoot(new zip.branch_QMARK_());
    const__36.setMeta((IPersistentMap)const__39);
    const__36.bindRoot(new zip.children());
    const__40.setMeta((IPersistentMap)const__43);
    const__40.bindRoot(new zip.make_node());
    const__44.setMeta((IPersistentMap)const__47);
    const__44.bindRoot(new zip.path());
    const__48.setMeta((IPersistentMap)const__51);
    const__48.bindRoot(new zip.lefts());
    const__52.setMeta((IPersistentMap)const__55);
    const__52.bindRoot(new zip.rights());
    const__56.setMeta((IPersistentMap)const__59);
    const__56.bindRoot(new zip.down());
    const__60.setMeta((IPersistentMap)const__63);
    const__60.bindRoot(new zip.up());
    const__64.setMeta((IPersistentMap)const__67);
    const__64.bindRoot(new zip.root());
    const__68.setMeta((IPersistentMap)const__71);
    const__68.bindRoot(new zip.right());
    const__72.setMeta((IPersistentMap)const__75);
    const__72.bindRoot(new zip.rightmost());
    const__76.setMeta((IPersistentMap)const__79);
    const__76.bindRoot(new zip.left());
    const__80.setMeta((IPersistentMap)const__83);
    const__80.bindRoot(new zip.leftmost());
    const__84.setMeta((IPersistentMap)const__87);
    const__84.bindRoot(new zip.insert_left());
    const__88.setMeta((IPersistentMap)const__91);
    const__88.bindRoot(new zip.insert_right());
    const__92.setMeta((IPersistentMap)const__95);
    const__92.bindRoot(new zip.replace());
    const__96.setMeta((IPersistentMap)const__99);
    const__96.bindRoot(new zip.edit());
    const__100.setMeta((IPersistentMap)const__103);
    const__100.bindRoot(new zip.insert_child());
    const__104.setMeta((IPersistentMap)const__107);
    const__104.bindRoot(new zip.append_child());
    const__108.setMeta((IPersistentMap)const__111);
    const__108.bindRoot(new zip.next());
    const__112.setMeta((IPersistentMap)const__115);
    const__112.bindRoot(new zip.prev());
    const__116.setMeta((IPersistentMap)const__119);
    const__116.bindRoot(new zip.end_QMARK_());
    const__120.setMeta((IPersistentMap)const__123);
    const__120.bindRoot(new zip.remove()); }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.zip")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet", RT.keyword(null, "author"), "Rich Hickey" }));
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet", RT.keyword(null, "author"), "Rich Hickey" });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.zip", "zipper");
    const__15 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "branch?"), Symbol.intern(null, "children"), Symbol.intern(null, "make-node"), Symbol.intern(null, "root")) })), RT.keyword(null, "doc"), "Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(18), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__16 = (Var)RT.var("clojure.zip", "seq-zip");
    const__19 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "root")) })), RT.keyword(null, "doc"), "Returns a zipper for nested sequences, given a root sequence", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(35), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__20 = (Var)RT.var("clojure.zip", "vector-zip");
    const__23 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "root")) })), RT.keyword(null, "doc"), "Returns a zipper for nested vectors, given a root vector", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(44), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__24 = (Var)RT.var("clojure.zip", "xml-zip");
    const__27 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "root")) })), RT.keyword(null, "doc"), "Returns a zipper for xml elements (as from xml/parse),\n  given a root element", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(53), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__28 = (Var)RT.var("clojure.zip", "node");
    const__31 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc")) })), RT.keyword(null, "doc"), "Returns the node at loc", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(64), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__32 = (Var)RT.var("clojure.zip", "branch?");
    const__35 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc")) })), RT.keyword(null, "doc"), "Returns true if the node at loc is a branch", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(69), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__36 = (Var)RT.var("clojure.zip", "children");
    const__39 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc")) })), RT.keyword(null, "doc"), "Returns a seq of the children of node at loc, which must be a branch", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(75), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__40 = (Var)RT.var("clojure.zip", "make-node");
    const__43 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc"), Symbol.intern(null, "node"), Symbol.intern(null, "children")) })), RT.keyword(null, "doc"), "Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(83), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__44 = (Var)RT.var("clojure.zip", "path");
    const__47 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc")) })), RT.keyword(null, "doc"), "Returns a seq of nodes leading to this loc", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(90), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__48 = (Var)RT.var("clojure.zip", "lefts");
    const__51 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc")) })), RT.keyword(null, "doc"), "Returns a seq of the left siblings of this loc", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(96), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__52 = (Var)RT.var("clojure.zip", "rights");
    const__55 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc")) })), RT.keyword(null, "doc"), "Returns a seq of the right siblings of this loc", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(102), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__56 = (Var)RT.var("clojure.zip", "down");
    const__59 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc")) })), RT.keyword(null, "doc"), "Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(109), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__60 = (Var)RT.var("clojure.zip", "up");
    const__63 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc")) })), RT.keyword(null, "doc"), "Returns the loc of the parent of the node at this loc, or nil if at\n  the top", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(123), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__64 = (Var)RT.var("clojure.zip", "root");
    const__67 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc")) })), RT.keyword(null, "doc"), "zips all the way up and returns the root node, reflecting any\n changes.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(137), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__68 = (Var)RT.var("clojure.zip", "right");
    const__71 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc")) })), RT.keyword(null, "doc"), "Returns the loc of the right sibling of the node at this loc, or nil", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(149), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__72 = (Var)RT.var("clojure.zip", "rightmost");
    const__75 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc")) })), RT.keyword(null, "doc"), "Returns the loc of the rightmost sibling of the node at this loc, or self", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(157), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__76 = (Var)RT.var("clojure.zip", "left");
    const__79 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc")) })), RT.keyword(null, "doc"), "Returns the loc of the left sibling of the node at this loc, or nil", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(166), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__80 = (Var)RT.var("clojure.zip", "leftmost");
    const__83 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc")) })), RT.keyword(null, "doc"), "Returns the loc of the leftmost sibling of the node at this loc, or self", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(174), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__84 = (Var)RT.var("clojure.zip", "insert-left");
    const__87 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc"), Symbol.intern(null, "item")) })), RT.keyword(null, "doc"), "Inserts the item as the left sibling of the node at this loc,\n without moving", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(183), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__88 = (Var)RT.var("clojure.zip", "insert-right");
    const__91 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc"), Symbol.intern(null, "item")) })), RT.keyword(null, "doc"), "Inserts the item as the right sibling of the node at this loc,\n  without moving", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(193), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__92 = (Var)RT.var("clojure.zip", "replace");
    const__95 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc"), Symbol.intern(null, "node")) })), RT.keyword(null, "doc"), "Replaces the node at this loc, without moving", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(203), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__96 = (Var)RT.var("clojure.zip", "edit");
    const__99 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc"), Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Replaces the node at this loc with the value of (f node args)", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(210), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
  }
  
  public static void __init1() {
    const__100 = (Var)RT.var("clojure.zip", "insert-child");
    const__103 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc"), Symbol.intern(null, "item")) })), RT.keyword(null, "doc"), "Inserts the item as the leftmost child of the node at this loc,\n  without moving", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(216), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__104 = (Var)RT.var("clojure.zip", "append-child");
    const__107 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc"), Symbol.intern(null, "item")) })), RT.keyword(null, "doc"), "Inserts the item as the rightmost child of the node at this loc,\n  without moving", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(223), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__108 = (Var)RT.var("clojure.zip", "next");
    const__111 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc")) })), RT.keyword(null, "doc"), "Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(230), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__112 = (Var)RT.var("clojure.zip", "prev");
    const__115 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc")) })), RT.keyword(null, "doc"), "Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(246), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__116 = (Var)RT.var("clojure.zip", "end?");
    const__119 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc")) })), RT.keyword(null, "doc"), "Returns true if loc represents the end of a depth-first walk", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(258), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
    const__120 = (Var)RT.var("clojure.zip", "remove");
    const__123 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "loc")) })), RT.keyword(null, "doc"), "Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(264), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/zip.clj" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("clojure.zip__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
