package clojure;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class string__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final Var const__7;
  
  public static final AFn const__18;
  
  public static final Var const__19;
  
  public static final AFn const__22;
  
  public static final Var const__23;
  
  public static final AFn const__27;
  
  public static final Var const__28;
  
  public static final AFn const__31;
  
  public static final Var const__32;
  
  public static final AFn const__35;
  
  public static final Var const__36;
  
  public static final AFn const__39;
  
  public static final Var const__40;
  
  public static final AFn const__43;
  
  public static final Var const__44;
  
  public static final AFn const__47;
  
  public static final Var const__48;
  
  public static final AFn const__51;
  
  public static final Var const__52;
  
  public static final AFn const__55;
  
  public static final Var const__56;
  
  public static final AFn const__59;
  
  public static final Var const__60;
  
  public static final AFn const__63;
  
  public static final Var const__64;
  
  public static final AFn const__67;
  
  public static final Var const__68;
  
  public static final AFn const__71;
  
  public static final Var const__72;
  
  public static final AFn const__75;
  
  public static final Var const__76;
  
  public static final AFn const__79;
  
  public static final Var const__80;
  
  public static final AFn const__83;
  
  public static final Var const__84;
  
  public static final AFn const__87;
  
  public static final Var const__88;
  
  public static final AFn const__91;
  
  public static final Var const__92;
  
  public static final AFn const__95;
  
  public static final Var const__96;
  
  public static final AFn const__99;
  
  public static final Var const__100;
  
  public static final AFn const__103;
  
  public static final Var const__104;
  
  public static final AFn const__107;
  
  public static final Var const__108;
  
  public static final AFn const__111;
  
  public static final Var const__112;
  
  public static final AFn const__115;
  
  public static void load() { LockingTransaction.runInTransaction((Callable)new string.fn__11762());
    const__7.setMeta((IPersistentMap)const__18);
    const__7.bindRoot(new string.reverse());
    const__19.setMeta((IPersistentMap)const__22);
    const__19.bindRoot(new string.re_quote_replacement());
    const__23.setMeta((IPersistentMap)const__27);
    const__23.bindRoot(new string.replace_by());
    const__28.setMeta((IPersistentMap)const__31);
    const__28.bindRoot(new string.replace());
    const__32.setMeta((IPersistentMap)const__35);
    const__32.bindRoot(new string.replace_first_by());
    const__36.setMeta((IPersistentMap)const__39);
    const__36.bindRoot(new string.replace_first_char());
    const__40.setMeta((IPersistentMap)const__43);
    const__40.bindRoot(new string.replace_first_str());
    const__44.setMeta((IPersistentMap)const__47);
    const__44.bindRoot(new string.replace_first());
    const__48.setMeta((IPersistentMap)const__51);
    const__48.bindRoot(new string.join());
    const__52.setMeta((IPersistentMap)const__55);
    const__52.bindRoot(new string.capitalize());
    const__56.setMeta((IPersistentMap)const__59);
    const__56.bindRoot(new string.upper_case());
    const__60.setMeta((IPersistentMap)const__63);
    const__60.bindRoot(new string.lower_case());
    const__64.setMeta((IPersistentMap)const__67);
    const__64.bindRoot(new string.split());
    const__68.setMeta((IPersistentMap)const__71);
    const__68.bindRoot(new string.split_lines());
    const__72.setMeta((IPersistentMap)const__75);
    const__72.bindRoot(new string.trim());
    const__76.setMeta((IPersistentMap)const__79);
    const__76.bindRoot(new string.triml());
    const__80.setMeta((IPersistentMap)const__83);
    const__80.bindRoot(new string.trimr());
    const__84.setMeta((IPersistentMap)const__87);
    const__84.bindRoot(new string.trim_newline());
    const__88.setMeta((IPersistentMap)const__91);
    const__88.bindRoot(new string.blank_QMARK_());
    const__92.setMeta((IPersistentMap)const__95);
    const__92.bindRoot(new string.escape());
    const__96.setMeta((IPersistentMap)const__99);
    const__96.bindRoot(new string.index_of());
    const__100.setMeta((IPersistentMap)const__103);
    const__100.bindRoot(new string.last_index_of());
    const__104.setMeta((IPersistentMap)const__107);
    const__104.bindRoot(new string.starts_with_QMARK_());
    const__108.setMeta((IPersistentMap)const__111);
    const__108.bindRoot(new string.ends_with_QMARK_());
    const__112.setMeta((IPersistentMap)const__115);
    const__112.bindRoot(new string.includes_QMARK_()); }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.string")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Clojure String utilities\n\nIt is poor form to (:use clojure.string). Instead, use require\nwith :as to specify a prefix, e.g.\n\n(ns your.namespace.here\n  (:require [clojure.string :as str]))\n\nDesign notes for clojure.string:\n\n1. Strings are objects (as opposed to sequences). As such, the\n   string being manipulated is the first argument to a function;\n   passing nil will result in a NullPointerException unless\n   documented otherwise. If you want sequence-y behavior instead,\n   use a sequence.\n\n2. Functions are generally not lazy, and call straight to host\n   methods where those are available and efficient.\n\n3. Functions take advantage of String implementation details to\n   write high-performing loop/recurs instead of using higher-order\n   functions. (This is not idiomatic in general-purpose application\n   code.)\n\n4. When a function is documented to accept a string argument, it\n   will take any implementation of the correct *interface* on the\n   host platform. In Java, this is CharSequence, which is more\n   general than String. In ordinary usage you will almost always\n   pass concrete strings. If you are doing something unusual,\n   e.g. passing a mutable implementation of CharSequence, then\n   thread-safety is your responsibility.", RT.keyword(null, "author"), "Stuart Sierra, Stuart Halloway, David Liebke" }));
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Clojure String utilities\n\nIt is poor form to (:use clojure.string). Instead, use require\nwith :as to specify a prefix, e.g.\n\n(ns your.namespace.here\n  (:require [clojure.string :as str]))\n\nDesign notes for clojure.string:\n\n1. Strings are objects (as opposed to sequences). As such, the\n   string being manipulated is the first argument to a function;\n   passing nil will result in a NullPointerException unless\n   documented otherwise. If you want sequence-y behavior instead,\n   use a sequence.\n\n2. Functions are generally not lazy, and call straight to host\n   methods where those are available and efficient.\n\n3. Functions take advantage of String implementation details to\n   write high-performing loop/recurs instead of using higher-order\n   functions. (This is not idiomatic in general-purpose application\n   code.)\n\n4. When a function is documented to accept a string argument, it\n   will take any implementation of the correct *interface* on the\n   host platform. In Java, this is CharSequence, which is more\n   general than String. In ordinary usage you will almost always\n   pass concrete strings. If you are doing something unusual,\n   e.g. passing a mutable implementation of CharSequence, then\n   thread-safety is your responsibility.", RT.keyword(null, "author"), "Stuart Sierra, Stuart Halloway, David Liebke" });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.core", "*warn-on-reflection*");
    const__7 = (Var)RT.var("clojure.string", "reverse");
    const__18 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") }))) })), RT.keyword(null, "doc"), "Returns s with its characters reversed.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(48), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/string.clj" });
    const__19 = (Var)RT.var("clojure.string", "re-quote-replacement");
    const__22 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "replacement")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") }))) })), RT.keyword(null, "doc"), "Given a replacement string that you wish to be a literal\n   replacement for a pattern match in replace or replace-first, do the\n   necessary escaping of special characters in the replacement.", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(54), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/string.clj" });
    const__23 = (Var)RT.var("clojure.string", "replace-by");
    const__27 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") })), Symbol.intern(null, "re"), Symbol.intern(null, "f")) })), RT.keyword(null, "line"), Integer.valueOf(62), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/string.clj" });
    const__28 = (Var)RT.var("clojure.string", "replace");
    const__31 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") })), Symbol.intern(null, "match"), Symbol.intern(null, "replacement")) })), RT.keyword(null, "doc"), "Replaces all instance of match with replacement in s.\n\n   match/replacement can be:\n\n   string / string\n   char / char\n   pattern / (string or function of match).\n\n   See also replace-first.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (clojure.string/replace \"Almost Pig Latin\" #\"\\b(\\w)(\\w+)\\b\" \"$2$1ay\")\n   -> \"lmostAay igPay atinLay\"", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(75), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/string.clj" });
    const__32 = (Var)RT.var("clojure.string", "replace-first-by");
    const__35 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") })), ((IObj)Symbol.intern(null, "re")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Pattern") })), Symbol.intern(null, "f")) })), RT.keyword(null, "line"), Integer.valueOf(111), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/string.clj" });
    const__36 = (Var)RT.var("clojure.string", "replace-first-char");
    const__39 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") })), ((IObj)Symbol.intern(null, "match")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Character") })), Symbol.intern(null, "replace")) })), RT.keyword(null, "line"), Integer.valueOf(122), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/string.clj" });
    const__40 = (Var)RT.var("clojure.string", "replace-first-str");
    const__43 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") })), ((IObj)Symbol.intern(null, "match")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })), ((IObj)Symbol.intern(null, "replace")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))) })), RT.keyword(null, "line"), Integer.valueOf(130), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/string.clj" });
    const__44 = (Var)RT.var("clojure.string", "replace-first");
    const__47 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") })), Symbol.intern(null, "match"), Symbol.intern(null, "replacement")) })), RT.keyword(null, "doc"), "Replaces the first instance of match with replacement in s.\n\n   match/replacement can be:\n\n   char / char\n   string / string\n   pattern / (string or function of match).\n\n   See also replace.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (clojure.string/replace-first \"swap first two words\"\n                                 #\"(\\w+)(\\s+)(\\w+)\" \"$3$2$1\")\n   -> \"first swap two words\"", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(138), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/string.clj" });
    const__48 = (Var)RT.var("clojure.string", "join");
    const__51 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "separator"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a string of all elements in coll, as returned by (seq coll),\n   separated by an optional separator.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(180), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/string.clj" });
    const__52 = (Var)RT.var("clojure.string", "capitalize");
    const__55 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") }))) })), RT.keyword(null, "doc"), "Converts first character of the string to upper-case, all other\n  characters to lower-case.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(196), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/string.clj" });
    const__56 = (Var)RT.var("clojure.string", "upper-case");
    const__59 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") }))) })), RT.keyword(null, "doc"), "Converts string to all upper-case.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(207), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/string.clj" });
    const__60 = (Var)RT.var("clojure.string", "lower-case");
    const__63 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") }))) })), RT.keyword(null, "doc"), "Converts string to all lower-case.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(213), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/string.clj" });
    const__64 = (Var)RT.var("clojure.string", "split");
    const__67 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") })), ((IObj)Symbol.intern(null, "re")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Pattern") }))), Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") })), ((IObj)Symbol.intern(null, "re")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Pattern") })), Symbol.intern(null, "limit")) })), RT.keyword(null, "doc"), "Splits string on a regular expression.  Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(219), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/string.clj" });
    const__68 = (Var)RT.var("clojure.string", "split-lines");
    const__71 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") }))) })), RT.keyword(null, "doc"), "Splits s on \\n or \\r\\n.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(228), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/string.clj" });
    const__72 = (Var)RT.var("clojure.string", "trim");
    const__75 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") }))) })), RT.keyword(null, "doc"), "Removes whitespace from both ends of string.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(234), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/string.clj" });
    const__76 = (Var)RT.var("clojure.string", "triml");
    const__79 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") }))) })), RT.keyword(null, "doc"), "Removes whitespace from the left side of string.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(251), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/string.clj" });
    const__80 = (Var)RT.var("clojure.string", "trimr");
    const__83 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") }))) })), RT.keyword(null, "doc"), "Removes whitespace from the right side of string.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(263), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/string.clj" });
    const__84 = (Var)RT.var("clojure.string", "trim-newline");
    const__87 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") }))) })), RT.keyword(null, "doc"), "Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(274), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/string.clj" });
    const__88 = (Var)RT.var("clojure.string", "blank?");
    const__91 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") }))) })), RT.keyword(null, "doc"), "True if s is nil, empty, or contains only whitespace.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(287), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/string.clj" });
    const__92 = (Var)RT.var("clojure.string", "escape");
    const__95 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") })), Symbol.intern(null, "cmap")) })), RT.keyword(null, "doc"), "Return a new string, using cmap to escape each character ch\n   from s as follows:\n   \n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(300), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/string.clj" });
    const__96 = (Var)RT.var("clojure.string", "index-of");
    const__99 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") })), Symbol.intern(null, "value")), Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") })), Symbol.intern(null, "value"), ((IObj)Symbol.intern(null, "from-index")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") }))) })), RT.keyword(null, "doc"), "Return index of value (string or char) in s, optionally searching\n  forward from from-index. Return nil if value not found.", RT.keyword(null, "added"), "1.8", RT.keyword(null, "line"), Integer.valueOf(318), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/string.clj" });
  }
  
  public static void __init1() {
    const__100 = (Var)RT.var("clojure.string", "last-index-of");
    const__103 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") })), Symbol.intern(null, "value")), Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") })), Symbol.intern(null, "value"), ((IObj)Symbol.intern(null, "from-index")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") }))) })), RT.keyword(null, "doc"), "Return last index of value (string or char) in s, optionally\n  searching backward from from-index. Return nil if value not found.", RT.keyword(null, "added"), "1.8", RT.keyword(null, "line"), Integer.valueOf(339), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/string.clj" });
    const__104 = (Var)RT.var("clojure.string", "starts-with?");
    const__107 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") })), ((IObj)Symbol.intern(null, "substr")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))) })), RT.keyword(null, "doc"), "True if s starts with substr.", RT.keyword(null, "added"), "1.8", RT.keyword(null, "line"), Integer.valueOf(360), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/string.clj" });
    const__108 = (Var)RT.var("clojure.string", "ends-with?");
    const__111 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") })), ((IObj)Symbol.intern(null, "substr")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))) })), RT.keyword(null, "doc"), "True if s ends with substr.", RT.keyword(null, "added"), "1.8", RT.keyword(null, "line"), Integer.valueOf(366), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/string.clj" });
    const__112 = (Var)RT.var("clojure.string", "includes?");
    const__115 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") })), ((IObj)Symbol.intern(null, "substr")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") }))) })), RT.keyword(null, "doc"), "True if s includes substr.", RT.keyword(null, "added"), "1.8", RT.keyword(null, "line"), Integer.valueOf(372), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/string.clj" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("clojure.string__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
