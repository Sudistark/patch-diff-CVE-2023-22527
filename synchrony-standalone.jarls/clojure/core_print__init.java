package clojure;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.Keyword;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;

public class core_print__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Var const__2;
  
  public static final Var const__3;
  
  public static final AFn const__12;
  
  public static final Var const__13;
  
  public static final AFn const__15;
  
  public static final Var const__16;
  
  public static final AFn const__18;
  
  public static final Var const__19;
  
  public static final AFn const__21;
  
  public static final Var const__22;
  
  public static final AFn const__27;
  
  public static final Var const__28;
  
  public static final AFn const__31;
  
  public static final Var const__32;
  
  public static final AFn const__35;
  
  public static final Var const__36;
  
  public static final Keyword const__37;
  
  public static final Var const__38;
  
  public static final Var const__39;
  
  public static final AFn const__42;
  
  public static final Var const__43;
  
  public static final AFn const__46;
  
  public static final Var const__47;
  
  public static final AFn const__50;
  
  public static final Object const__51;
  
  public static final Object const__52;
  
  public static final Object const__53;
  
  public static final Object const__54;
  
  public static final Object const__55;
  
  public static final Object const__56;
  
  public static final Var const__57;
  
  public static final Object const__58;
  
  public static final Object const__59;
  
  public static final Object const__60;
  
  public static final Object const__61;
  
  public static final Object const__62;
  
  public static final Object const__63;
  
  public static final Object const__64;
  
  public static final Object const__65;
  
  public static final Var const__66;
  
  public static final Object const__68;
  
  public static final AFn const__70;
  
  public static final AFn const__78;
  
  public static final Object const__79;
  
  public static final Var const__80;
  
  public static final AFn const__83;
  
  public static final Var const__84;
  
  public static final AFn const__87;
  
  public static final Var const__88;
  
  public static final AFn const__91;
  
  public static final Var const__92;
  
  public static final AFn const__95;
  
  public static final Object const__96;
  
  public static final Object const__97;
  
  public static final Object const__98;
  
  public static final Object const__99;
  
  public static final Object const__100;
  
  public static final Object const__101;
  
  public static final Var const__102;
  
  public static final AFn const__104;
  
  public static final AFn const__106;
  
  public static final Object const__107;
  
  public static final Object const__108;
  
  public static final Object const__109;
  
  public static final Object const__110;
  
  public static final Object const__111;
  
  public static final Object const__112;
  
  public static final Object const__113;
  
  public static final Object const__114;
  
  public static final Object const__115;
  
  public static final Var const__116;
  
  public static final AFn const__118;
  
  public static final Object const__119;
  
  public static final Object const__120;
  
  public static final Object const__121;
  
  public static final Var const__122;
  
  public static final AFn const__125;
  
  public static final Object const__126;
  
  public static final Object const__127;
  
  public static final Var const__128;
  
  public static final AFn const__131;
  
  public static final Var const__132;
  
  public static final AFn const__135;
  
  public static final Var const__136;
  
  public static final AFn const__139;
  
  public static final Object const__140;
  
  public static final Object const__141;
  
  public static final Object const__142;
  
  public static final Var const__143;
  
  public static final AFn const__145;
  
  public static final Var const__146;
  
  public static final AFn const__150;
  
  public static void load() {
    const__3.setDynamic(true).setMeta((IPersistentMap)const__12);
    const__3.setDynamic(true).bindRoot(null);
    const__13.setDynamic(true).setMeta((IPersistentMap)const__15);
    const__13.setDynamic(true).bindRoot(null);
    const__16.setDynamic(true).setMeta((IPersistentMap)const__18);
    const__16.setDynamic(true).bindRoot(Boolean.FALSE);
    const__19.setDynamic(true).setMeta((IPersistentMap)const__21);
    const__19.setDynamic(true).bindRoot(Boolean.FALSE);
    const__22.setMeta((IPersistentMap)const__27);
    const__22.bindRoot(new core.print_sequential());
    const__28.setMeta((IPersistentMap)const__31);
    const__28.bindRoot(new core.print_meta());
    const__32.setMeta((IPersistentMap)const__35);
    const__32.bindRoot(new core.print_simple());
    const__39.setMeta((IPersistentMap)const__42);
    const__39.bindRoot(new core.print_ctor());
    const__43.setMeta((IPersistentMap)const__46);
    const__43.bindRoot(new core.print_tagged_object());
    const__47.setMeta((IPersistentMap)const__50);
    const__47.bindRoot(new core.print_object());
    const__66.setMeta((IPersistentMap)const__70);
    const__66.bindRoot(const__78);
    const__80.setMeta((IPersistentMap)const__83);
    const__80.bindRoot(new core.print_prefix_map());
    const__84.setMeta((IPersistentMap)const__87);
    const__84.bindRoot(new core.print_map());
    const__88.setMeta((IPersistentMap)const__91);
    const__88.bindRoot(new core.strip_ns());
    const__92.setMeta((IPersistentMap)const__95);
    const__92.bindRoot(new core.lift_ns());
    const__102.setMeta((IPersistentMap)const__104);
    const__102.bindRoot(const__106);
    const__116.setMeta((IPersistentMap)const__118);
    const__116
      
      .bindRoot(RT.map(new Object[] { 
            float.class, "Float/TYPE", int.class, "Integer/TYPE", long.class, "Long/TYPE", boolean.class, "Boolean/TYPE", char.class, "Character/TYPE", 
            double.class, "Double/TYPE", byte.class, "Byte/TYPE", short.class, "Short/TYPE" }));
    const__122.setMeta((IPersistentMap)const__125);
    const__122.bindRoot(new core.deref_as_map());
    const__128.setMeta((IPersistentMap)const__131);
    const__128.bindRoot(new core.StackTraceElement__GT_vec());
    const__132.setMeta((IPersistentMap)const__135);
    const__132.bindRoot(new core.Throwable__GT_map());
    const__136.setMeta((IPersistentMap)const__139);
    const__136.bindRoot(new core.print_throwable());
    const__143.setMeta((IPersistentMap)const__145);
    const__143.bindRoot(Boolean.TRUE);
    const__146.setMeta((IPersistentMap)const__150);
    const__146.bindRoot(new core.PrintWriter_on());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "clojure.core");
    const__2 = (Var)RT.var("clojure.core", "*warn-on-reflection*");
    const__3 = (Var)RT.var("clojure.core", "*print-length*");
    const__12 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(16), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__13 = (Var)RT.var("clojure.core", "*print-level*");
    const__15 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(27), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__16 = (Var)RT.var("clojure.core", "*verbose-defrecords*");
    const__18 = (AFn)RT.map(new Object[] { RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(39), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__19 = (Var)RT.var("clojure.core", "*print-namespace-maps*");
    const__21 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax. It defaults to false, but the REPL binds\n  to true.", RT.keyword(null, "added"), "1.9", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(41), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__22 = (Var)RT.var("clojure.core", "print-sequential");
    const__27 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "begin")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })), Symbol.intern(null, "print-one"), ((IObj)Symbol.intern(null, "sep")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })), ((IObj)Symbol.intern(null, "end")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })), Symbol.intern(null, "sequence"), ((IObj)Symbol.intern(null, "w")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Writer") }))) })), RT.keyword(null, "line"), Integer.valueOf(48), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__28 = (Var)RT.var("clojure.core", "print-meta");
    const__31 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "o"), ((IObj)Symbol.intern(null, "w")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Writer") }))) })), RT.keyword(null, "line"), Integer.valueOf(72), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__32 = (Var)RT.var("clojure.core", "print-simple");
    const__35 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "o"), ((IObj)Symbol.intern(null, "w")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Writer") }))) })), RT.keyword(null, "line"), Integer.valueOf(83), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__36 = (Var)RT.var("clojure.core", "print-method");
    const__37 = (Keyword)RT.keyword(null, "default");
    const__38 = (Var)RT.var("clojure.core", "print-dup");
    const__39 = (Var)RT.var("clojure.core", "print-ctor");
    const__42 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "o"), Symbol.intern(null, "print-args"), ((IObj)Symbol.intern(null, "w")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Writer") }))) })), RT.keyword(null, "line"), Integer.valueOf(97), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__43 = (Var)RT.var("clojure.core", "print-tagged-object");
    const__46 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "o"), Symbol.intern(null, "rep"), ((IObj)Symbol.intern(null, "w")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Writer") }))) })), RT.keyword(null, "line"), Integer.valueOf(104), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__47 = (Var)RT.var("clojure.core", "print-object");
    const__50 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "o"), ((IObj)Symbol.intern(null, "w")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Writer") }))) })), RT.keyword(null, "line"), Integer.valueOf(117), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__51 = RT.classForName("java.lang.Object");
    const__52 = RT.classForName("clojure.lang.Keyword");
    const__53 = RT.classForName("java.lang.Number");
    const__54 = RT.classForName("java.lang.Double");
    const__55 = RT.classForName("java.lang.Float");
    const__56 = RT.classForName("clojure.lang.Fn");
    const__57 = (Var)RT.var("clojure.core", "prefer-method");
    const__58 = RT.classForName("clojure.lang.IPersistentCollection");
    const__59 = RT.classForName("java.util.Map");
    const__60 = RT.classForName("java.util.Collection");
    const__61 = RT.classForName("java.lang.Boolean");
    const__62 = RT.classForName("clojure.lang.Symbol");
    const__63 = RT.classForName("clojure.lang.Var");
    const__64 = RT.classForName("clojure.lang.ISeq");
    const__65 = RT.classForName("clojure.lang.IPersistentList");
    const__66 = (Var)RT.var("clojure.core", "char-escape-string");
    const__68 = RT.classForName("java.lang.String");
    const__70 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "doc"), "Returns escape string for char or nil if none", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(200), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__78 = (AFn)RT.map(new Object[] { 
          Character.valueOf('\n'), "\\n", Character.valueOf('\t'), "\\t", Character.valueOf('\r'), "\\r", Character.valueOf('"'), "\\\"", Character.valueOf('\\'), "\\\\", 
          Character.valueOf('\f'), "\\f", Character.valueOf('\b'), "\\b" });
    const__79 = RT.classForName("clojure.lang.IPersistentVector");
    const__80 = (Var)RT.var("clojure.core", "print-prefix-map");
    const__83 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "prefix"), Symbol.intern(null, "m"), Symbol.intern(null, "print-one"), Symbol.intern(null, "w")) })), RT.keyword(null, "line"), Integer.valueOf(229), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__84 = (Var)RT.var("clojure.core", "print-map");
    const__87 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "print-one"), Symbol.intern(null, "w")) })), RT.keyword(null, "line"), Integer.valueOf(238), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__88 = (Var)RT.var("clojure.core", "strip-ns");
    const__91 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "named")) })), RT.keyword(null, "line"), Integer.valueOf(241), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__92 = (Var)RT.var("clojure.core", "lift-ns");
    const__95 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), "Returns [lifted-ns lifted-map] or nil if m can't be lifted.", RT.keyword(null, "line"), Integer.valueOf(247), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__96 = RT.classForName("clojure.lang.IPersistentMap");
    const__97 = RT.classForName("java.util.RandomAccess");
    const__98 = RT.classForName("java.util.List");
    const__99 = RT.classForName("java.util.Set");
  }
  
  public static void __init1() {
    const__100 = RT.classForName("clojure.lang.IRecord");
    const__101 = RT.classForName("clojure.lang.IPersistentSet");
    const__102 = (Var)RT.var("clojure.core", "char-name-string");
    const__104 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "doc"), "Returns name string for char or nil if none", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(342), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__106 = (AFn)RT.map(new Object[] { 
          Character.valueOf('\n'), "newline", Character.valueOf('\t'), "tab", Character.valueOf(' '), "space", Character.valueOf('\b'), "backspace", Character.valueOf('\f'), "formfeed", 
          Character.valueOf('\r'), "return" });
    const__107 = RT.classForName("java.lang.Character");
    const__108 = RT.classForName("java.lang.Long");
    const__109 = RT.classForName("clojure.lang.Ratio");
    const__110 = RT.classForName("java.math.BigDecimal");
    const__111 = RT.classForName("clojure.lang.BigInt");
    const__112 = RT.classForName("clojure.lang.PersistentHashMap");
    const__113 = RT.classForName("clojure.lang.PersistentHashSet");
    const__114 = RT.classForName("clojure.lang.PersistentVector");
    const__115 = RT.classForName("clojure.lang.LazilyPersistentVector");
    const__116 = (Var)RT.var("clojure.core", "primitives-classnames");
    const__118 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(372), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__119 = RT.classForName("java.lang.Class");
    const__120 = RT.classForName("java.util.regex.Pattern");
    const__121 = RT.classForName("clojure.lang.Namespace");
    const__122 = (Var)RT.var("clojure.core", "deref-as-map");
    const__125 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "o")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IDeref") }))) })), RT.keyword(null, "line"), Integer.valueOf(436), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__126 = RT.classForName("clojure.lang.IDeref");
    const__127 = RT.classForName("java.lang.StackTraceElement");
    const__128 = (Var)RT.var("clojure.core", "StackTraceElement->vec");
    const__131 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "o")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "StackTraceElement") }))) })), RT.keyword(null, "doc"), "Constructs a data representation for a StackTraceElement: [class method file line]", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(465), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__132 = (Var)RT.var("clojure.core", "Throwable->map");
    const__135 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "o")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Throwable") }))) })), RT.keyword(null, "doc"), "Constructs a data representation for a Throwable with keys:\n    :cause - root cause message\n    :phase - error phase\n    :via - cause chain, with cause keys:\n             :type - exception class symbol\n             :message - exception message\n             :data - ex-data\n             :at - top stack element\n    :trace - root cause stack elements", RT.keyword(null, "added"), "1.7", RT.keyword(null, "line"), Integer.valueOf(471), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__136 = (Var)RT.var("clojure.core", "print-throwable");
    const__139 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "o")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Throwable") })), ((IObj)Symbol.intern(null, "w")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Writer") }))) })), RT.keyword(null, "line"), Integer.valueOf(507), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__140 = RT.classForName("java.lang.Throwable");
    const__141 = RT.classForName("clojure.lang.TaggedLiteral");
    const__142 = RT.classForName("clojure.lang.ReaderConditional");
    const__143 = (Var)RT.var("clojure.core", "print-initialized");
    const__145 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(557), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_print.clj" });
    const__146 = (Var)RT.var("clojure.core", "PrintWriter-on");
    const__150 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.io.PrintWriter"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "flush-fn"), Symbol.intern(null, "close-fn")) })), RT.keyword(null, "doc"), "implements java.io.PrintWriter given flush-fn, which will be called\n  when .flush() is called, with a string built up since the last call to .flush().\n  if not nil, close-fn will be called with no arguments when .close is called", RT.keyword(null, "added"), "1.10", RT.keyword(null, "line"), Integer.valueOf(559), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_print.clj" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("clojure.core_print__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
