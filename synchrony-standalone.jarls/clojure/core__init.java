package clojure;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.Numbers;
import clojure.lang.PersistentArrayMap;
import clojure.lang.PersistentHashSet;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class core__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Keyword const__2;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final Keyword const__7;
  
  public static final Keyword const__9;
  
  public static final Object const__10;
  
  public static final Keyword const__11;
  
  public static final AFn const__12;
  
  public static final Var const__13;
  
  public static final AFn const__15;
  
  public static final Var const__16;
  
  public static final Keyword const__17;
  
  public static final Keyword const__19;
  
  public static final AFn const__21;
  
  public static final Var const__22;
  
  public static final Keyword const__24;
  
  public static final AFn const__26;
  
  public static final Var const__27;
  
  public static final AFn const__30;
  
  public static final Var const__31;
  
  public static final AFn const__33;
  
  public static final Var const__34;
  
  public static final AFn const__36;
  
  public static final Var const__37;
  
  public static final AFn const__40;
  
  public static final Var const__41;
  
  public static final Keyword const__43;
  
  public static final AFn const__46;
  
  public static final Var const__47;
  
  public static final AFn const__50;
  
  public static final Var const__51;
  
  public static final AFn const__54;
  
  public static final Var const__55;
  
  public static final AFn const__58;
  
  public static final Var const__59;
  
  public static final AFn const__62;
  
  public static final Var const__63;
  
  public static final AFn const__66;
  
  public static final Var const__67;
  
  public static final AFn const__70;
  
  public static final Var const__71;
  
  public static final AFn const__74;
  
  public static final Var const__75;
  
  public static final AFn const__78;
  
  public static final Var const__79;
  
  public static final AFn const__82;
  
  public static final Var const__83;
  
  public static final AFn const__86;
  
  public static final Var const__87;
  
  public static final AFn const__90;
  
  public static final Var const__91;
  
  public static final AFn const__94;
  
  public static final Var const__95;
  
  public static final AFn const__98;
  
  public static final Var const__99;
  
  public static final AFn const__102;
  
  public static final Var const__103;
  
  public static final AFn const__106;
  
  public static final Var const__107;
  
  public static final AFn const__110;
  
  public static final Var const__111;
  
  public static final AFn const__114;
  
  public static final Var const__115;
  
  public static final AFn const__119;
  
  public static final Var const__120;
  
  public static final AFn const__122;
  
  public static final Var const__123;
  
  public static final AFn const__126;
  
  public static final Var const__127;
  
  public static final AFn const__130;
  
  public static final Var const__131;
  
  public static final AFn const__134;
  
  public static final Var const__135;
  
  public static final AFn const__138;
  
  public static final Var const__139;
  
  public static final AFn const__142;
  
  public static final Var const__143;
  
  public static final AFn const__146;
  
  public static final Var const__147;
  
  public static final AFn const__150;
  
  public static final Var const__151;
  
  public static final AFn const__154;
  
  public static final Var const__155;
  
  public static final AFn const__158;
  
  public static final Var const__159;
  
  public static final AFn const__162;
  
  public static final Var const__163;
  
  public static final AFn const__166;
  
  public static final Var const__167;
  
  public static final AFn const__170;
  
  public static final Var const__171;
  
  public static final AFn const__174;
  
  public static final Var const__175;
  
  public static final Object const__176;
  
  public static final Object const__177;
  
  public static final Object const__178;
  
  public static final Keyword const__179;
  
  public static final Var const__180;
  
  public static final AFn const__183;
  
  public static final Var const__184;
  
  public static final AFn const__187;
  
  public static final Var const__188;
  
  public static final AFn const__191;
  
  public static final Var const__192;
  
  public static final AFn const__195;
  
  public static final Var const__196;
  
  public static final AFn const__199;
  
  public static final Var const__200;
  
  public static final AFn const__203;
  
  public static final Var const__204;
  
  public static final AFn const__207;
  
  public static final Var const__208;
  
  public static final AFn const__211;
  
  public static final Var const__212;
  
  public static final AFn const__215;
  
  public static final Var const__216;
  
  public static final AFn const__220;
  
  public static final Var const__221;
  
  public static final AFn const__224;
  
  public static final Var const__225;
  
  public static final AFn const__228;
  
  public static final Var const__229;
  
  public static final AFn const__232;
  
  public static final Var const__233;
  
  public static final AFn const__237;
  
  public static final Var const__238;
  
  public static final AFn const__241;
  
  public static final Var const__242;
  
  public static final AFn const__246;
  
  public static final Var const__247;
  
  public static final AFn const__250;
  
  public static final Var const__251;
  
  public static final AFn const__254;
  
  public static final Var const__255;
  
  public static final AFn const__258;
  
  public static final Var const__259;
  
  public static final AFn const__262;
  
  public static final Var const__263;
  
  public static final AFn const__266;
  
  public static final Var const__267;
  
  public static final AFn const__270;
  
  public static final Var const__271;
  
  public static final AFn const__275;
  
  public static final Var const__276;
  
  public static final AFn const__279;
  
  public static final Var const__280;
  
  public static final AFn const__284;
  
  public static final Var const__285;
  
  public static final AFn const__288;
  
  public static final Var const__289;
  
  public static final AFn const__292;
  
  public static final Var const__293;
  
  public static final AFn const__296;
  
  public static final Var const__297;
  
  public static final AFn const__300;
  
  public static final Var const__301;
  
  public static final AFn const__304;
  
  public static final Var const__305;
  
  public static final AFn const__308;
  
  public static final Var const__309;
  
  public static final AFn const__312;
  
  public static final Var const__313;
  
  public static final AFn const__316;
  
  public static final Var const__317;
  
  public static final AFn const__320;
  
  public static final Var const__321;
  
  public static final AFn const__324;
  
  public static final Var const__325;
  
  public static final Object const__326;
  
  public static final Keyword const__327;
  
  public static final AFn const__329;
  
  public static final Object const__330;
  
  public static final Var const__331;
  
  public static final Object const__332;
  
  public static final AFn const__333;
  
  public static final Object const__334;
  
  public static final Var const__335;
  
  public static final AFn const__338;
  
  public static final Var const__339;
  
  public static final Object const__340;
  
  public static final Object const__341;
  
  public static final Var const__342;
  
  public static final AFn const__345;
  
  public static final Var const__346;
  
  public static final AFn const__349;
  
  public static final Var const__350;
  
  public static final Object const__351;
  
  public static final Object const__352;
  
  public static final Var const__353;
  
  public static final Object const__354;
  
  public static final Object const__355;
  
  public static final Var const__356;
  
  public static final Object const__357;
  
  public static final Object const__358;
  
  public static final Var const__359;
  
  public static final Object const__360;
  
  public static final AFn const__362;
  
  public static final Object const__363;
  
  public static final Var const__364;
  
  public static final Object const__365;
  
  public static final AFn const__366;
  
  public static final Object const__367;
  
  public static final Var const__368;
  
  public static final Object const__369;
  
  public static final Object const__370;
  
  public static final Var const__371;
  
  public static final Object const__372;
  
  public static final Object const__373;
  
  public static final Var const__374;
  
  public static final AFn const__377;
  
  public static final Var const__378;
  
  public static final AFn const__381;
  
  public static final Var const__382;
  
  public static final AFn const__385;
  
  public static final Var const__386;
  
  public static final AFn const__389;
  
  public static final Var const__390;
  
  public static final AFn const__393;
  
  public static final Var const__394;
  
  public static final Object const__395;
  
  public static final AFn const__396;
  
  public static final Object const__397;
  
  public static final Var const__398;
  
  public static final Object const__399;
  
  public static final AFn const__400;
  
  public static final AFn const__401;
  
  public static final Object const__402;
  
  public static final Var const__403;
  
  public static final Object const__404;
  
  public static final AFn const__405;
  
  public static final Object const__406;
  
  public static final Var const__407;
  
  public static final Object const__408;
  
  public static final AFn const__409;
  
  public static final AFn const__410;
  
  public static final Object const__411;
  
  public static final Var const__412;
  
  public static final Object const__413;
  
  public static final AFn const__414;
  
  public static final Object const__415;
  
  public static final Var const__416;
  
  public static final Object const__417;
  
  public static final AFn const__418;
  
  public static final Object const__419;
  
  public static final Var const__420;
  
  public static final Object const__421;
  
  public static final AFn const__422;
  
  public static final AFn const__423;
  
  public static final Object const__424;
  
  public static final Var const__425;
  
  public static final Object const__426;
  
  public static final AFn const__427;
  
  public static final Object const__428;
  
  public static final Var const__429;
  
  public static final Object const__430;
  
  public static final AFn const__431;
  
  public static final Object const__432;
  
  public static final Var const__433;
  
  public static final Object const__434;
  
  public static final AFn const__435;
  
  public static final Object const__436;
  
  public static final Var const__437;
  
  public static final Object const__438;
  
  public static final AFn const__439;
  
  public static final Object const__440;
  
  public static final Var const__441;
  
  public static final Object const__442;
  
  public static final AFn const__443;
  
  public static final Object const__444;
  
  public static final Var const__445;
  
  public static final Object const__446;
  
  public static final AFn const__447;
  
  public static final Object const__448;
  
  public static final Var const__449;
  
  public static final Object const__450;
  
  public static final Object const__451;
  
  public static final Var const__452;
  
  public static final Object const__453;
  
  public static final Object const__454;
  
  public static final Var const__455;
  
  public static final Object const__456;
  
  public static final Object const__457;
  
  public static final Var const__458;
  
  public static final Object const__459;
  
  public static final Object const__460;
  
  public static final Var const__461;
  
  public static final Object const__462;
  
  public static final Object const__463;
  
  public static final Var const__464;
  
  public static final Object const__465;
  
  public static final Object const__466;
  
  public static final Var const__467;
  
  public static final Object const__468;
  
  public static final Object const__469;
  
  public static final Var const__470;
  
  public static final Object const__471;
  
  public static final Object const__472;
  
  public static final Var const__473;
  
  public static final Object const__474;
  
  public static final Object const__475;
  
  public static final Var const__476;
  
  public static final Object const__477;
  
  public static final Object const__478;
  
  public static final Var const__479;
  
  public static final Object const__480;
  
  public static final Object const__481;
  
  public static final Var const__482;
  
  public static final Object const__483;
  
  public static final Object const__484;
  
  public static final Var const__485;
  
  public static final Object const__486;
  
  public static final Object const__487;
  
  public static final Var const__488;
  
  public static final Object const__489;
  
  public static final Object const__490;
  
  public static final Var const__491;
  
  public static final Object const__492;
  
  public static final Object const__493;
  
  public static final Var const__494;
  
  public static final Object const__495;
  
  public static final Object const__496;
  
  public static final Var const__497;
  
  public static final Object const__498;
  
  public static final Object const__499;
  
  public static final Var const__500;
  
  public static final Object const__501;
  
  public static final Object const__502;
  
  public static final Var const__503;
  
  public static final Object const__504;
  
  public static final Object const__505;
  
  public static final Var const__506;
  
  public static final Object const__507;
  
  public static final Object const__508;
  
  public static final Var const__509;
  
  public static final AFn const__512;
  
  public static final Var const__513;
  
  public static final Object const__514;
  
  public static final Object const__515;
  
  public static final Var const__516;
  
  public static final Object const__517;
  
  public static final AFn const__518;
  
  public static final Object const__519;
  
  public static final Var const__520;
  
  public static final Object const__521;
  
  public static final AFn const__522;
  
  public static final Object const__523;
  
  public static final Var const__524;
  
  public static final Object const__525;
  
  public static final AFn const__526;
  
  public static final Object const__527;
  
  public static final Var const__528;
  
  public static final Object const__529;
  
  public static final Object const__530;
  
  public static final AFn const__531;
  
  public static final Var const__532;
  
  public static final AFn const__535;
  
  public static final Var const__536;
  
  public static final AFn const__539;
  
  public static final Var const__540;
  
  public static final AFn const__543;
  
  public static final Var const__544;
  
  public static final AFn const__547;
  
  public static final Var const__548;
  
  public static final Object const__549;
  
  public static final Object const__550;
  
  public static final Var const__551;
  
  public static final Object const__552;
  
  public static final Object const__553;
  
  public static final Var const__554;
  
  public static final Object const__555;
  
  public static final Object const__556;
  
  public static final Var const__557;
  
  public static final AFn const__560;
  
  public static final Var const__561;
  
  public static final AFn const__564;
  
  public static final Var const__565;
  
  public static final AFn const__568;
  
  public static final Var const__569;
  
  public static final AFn const__572;
  
  public static final Var const__573;
  
  public static final AFn const__576;
  
  public static final Var const__577;
  
  public static final AFn const__580;
  
  public static final Var const__581;
  
  public static final AFn const__584;
  
  public static final Var const__585;
  
  public static final AFn const__588;
  
  public static final Var const__589;
  
  public static final AFn const__592;
  
  public static final Var const__593;
  
  public static final AFn const__596;
  
  public static final Var const__597;
  
  public static final AFn const__600;
  
  public static final Var const__601;
  
  public static final AFn const__604;
  
  public static final Var const__605;
  
  public static final AFn const__608;
  
  public static final Var const__609;
  
  public static final AFn const__612;
  
  public static final Var const__613;
  
  public static final AFn const__616;
  
  public static final Var const__617;
  
  public static final Object const__618;
  
  public static final AFn const__619;
  
  public static final Object const__620;
  
  public static final Var const__621;
  
  public static final AFn const__624;
  
  public static final Var const__625;
  
  public static final AFn const__628;
  
  public static final Var const__629;
  
  public static final AFn const__632;
  
  public static final Var const__633;
  
  public static final AFn const__636;
  
  public static final Var const__637;
  
  public static final AFn const__640;
  
  public static final Var const__641;
  
  public static final AFn const__644;
  
  public static final Var const__645;
  
  public static final AFn const__648;
  
  public static final Var const__649;
  
  public static final AFn const__652;
  
  public static final Var const__653;
  
  public static final AFn const__656;
  
  public static final Var const__657;
  
  public static final AFn const__660;
  
  public static final Var const__661;
  
  public static final AFn const__664;
  
  public static final Var const__665;
  
  public static final Object const__666;
  
  public static final Object const__667;
  
  public static final Var const__668;
  
  public static final AFn const__671;
  
  public static final Var const__672;
  
  public static final AFn const__675;
  
  public static final Var const__676;
  
  public static final AFn const__679;
  
  public static final Var const__680;
  
  public static final AFn const__683;
  
  public static final Var const__684;
  
  public static final AFn const__687;
  
  public static final Var const__688;
  
  public static final AFn const__691;
  
  public static final Var const__692;
  
  public static final AFn const__695;
  
  public static final Var const__696;
  
  public static final AFn const__699;
  
  public static final Var const__700;
  
  public static final AFn const__703;
  
  public static final Var const__704;
  
  public static final AFn const__707;
  
  public static final Var const__708;
  
  public static final AFn const__711;
  
  public static final Var const__712;
  
  public static final AFn const__714;
  
  public static final Var const__715;
  
  public static final AFn const__718;
  
  public static final Var const__719;
  
  public static final AFn const__721;
  
  public static final Var const__722;
  
  public static final AFn const__725;
  
  public static final Var const__726;
  
  public static final AFn const__729;
  
  public static final Var const__730;
  
  public static final AFn const__733;
  
  public static final Var const__734;
  
  public static final AFn const__737;
  
  public static final Var const__738;
  
  public static final AFn const__741;
  
  public static final Var const__742;
  
  public static final AFn const__745;
  
  public static final Var const__746;
  
  public static final AFn const__749;
  
  public static final Var const__750;
  
  public static final AFn const__753;
  
  public static final Var const__754;
  
  public static final AFn const__757;
  
  public static final Var const__758;
  
  public static final AFn const__761;
  
  public static final Var const__762;
  
  public static final AFn const__765;
  
  public static final Var const__766;
  
  public static final AFn const__769;
  
  public static final Var const__770;
  
  public static final AFn const__773;
  
  public static final Var const__774;
  
  public static final AFn const__777;
  
  public static final Var const__778;
  
  public static final AFn const__781;
  
  public static final Var const__782;
  
  public static final AFn const__785;
  
  public static final Var const__786;
  
  public static final AFn const__789;
  
  public static final Var const__790;
  
  public static final AFn const__793;
  
  public static final Var const__794;
  
  public static final AFn const__797;
  
  public static final Var const__798;
  
  public static final AFn const__801;
  
  public static final Var const__802;
  
  public static final AFn const__805;
  
  public static final Var const__806;
  
  public static final AFn const__809;
  
  public static final Var const__810;
  
  public static final AFn const__813;
  
  public static final Var const__814;
  
  public static final AFn const__817;
  
  public static final Var const__818;
  
  public static final AFn const__821;
  
  public static final Var const__822;
  
  public static final AFn const__825;
  
  public static final Var const__826;
  
  public static final AFn const__829;
  
  public static final Var const__830;
  
  public static final AFn const__833;
  
  public static final Var const__834;
  
  public static final AFn const__837;
  
  public static final Var const__838;
  
  public static final AFn const__841;
  
  public static final Var const__842;
  
  public static final AFn const__845;
  
  public static final Var const__846;
  
  public static final AFn const__849;
  
  public static final Var const__850;
  
  public static final AFn const__853;
  
  public static final Var const__854;
  
  public static final AFn const__857;
  
  public static final Var const__858;
  
  public static final AFn const__861;
  
  public static final Var const__862;
  
  public static final AFn const__865;
  
  public static final Var const__866;
  
  public static final AFn const__869;
  
  public static final Var const__870;
  
  public static final AFn const__873;
  
  public static final Var const__874;
  
  public static final AFn const__877;
  
  public static final Var const__878;
  
  public static final AFn const__882;
  
  public static final Var const__883;
  
  public static final AFn const__886;
  
  public static final Var const__887;
  
  public static final AFn const__890;
  
  public static final Var const__891;
  
  public static final AFn const__894;
  
  public static final Var const__895;
  
  public static final AFn const__898;
  
  public static final Var const__899;
  
  public static final AFn const__902;
  
  public static final Var const__903;
  
  public static final AFn const__906;
  
  public static final Var const__907;
  
  public static final AFn const__910;
  
  public static final Var const__911;
  
  public static final AFn const__914;
  
  public static final Var const__915;
  
  public static final AFn const__918;
  
  public static final Var const__919;
  
  public static final AFn const__922;
  
  public static final Var const__923;
  
  public static final AFn const__926;
  
  public static final Var const__927;
  
  public static final AFn const__930;
  
  public static final Var const__931;
  
  public static final AFn const__934;
  
  public static final Var const__935;
  
  public static final AFn const__938;
  
  public static final Var const__939;
  
  public static final AFn const__942;
  
  public static final Var const__943;
  
  public static final AFn const__946;
  
  public static final Var const__947;
  
  public static final AFn const__950;
  
  public static final Var const__951;
  
  public static final AFn const__954;
  
  public static final Var const__955;
  
  public static final AFn const__958;
  
  public static final Var const__959;
  
  public static final AFn const__962;
  
  public static final Var const__963;
  
  public static final AFn const__966;
  
  public static final Var const__967;
  
  public static final AFn const__970;
  
  public static final Var const__971;
  
  public static final AFn const__974;
  
  public static final Var const__975;
  
  public static final AFn const__978;
  
  public static final Var const__979;
  
  public static final AFn const__983;
  
  public static final Var const__984;
  
  public static final AFn const__987;
  
  public static final Var const__988;
  
  public static final AFn const__991;
  
  public static final Var const__992;
  
  public static final AFn const__995;
  
  public static final Var const__996;
  
  public static final AFn const__999;
  
  public static final Var const__1000;
  
  public static final AFn const__1003;
  
  public static final Var const__1004;
  
  public static final AFn const__1007;
  
  public static final Var const__1008;
  
  public static final AFn const__1011;
  
  public static final Var const__1012;
  
  public static final AFn const__1015;
  
  public static final Var const__1016;
  
  public static final AFn const__1019;
  
  public static final Var const__1020;
  
  public static final AFn const__1023;
  
  public static final Var const__1024;
  
  public static final AFn const__1027;
  
  public static final Var const__1028;
  
  public static final AFn const__1031;
  
  public static final AFn const__1034;
  
  public static final Var const__1035;
  
  public static final AFn const__1038;
  
  public static final Var const__1039;
  
  public static final AFn const__1042;
  
  public static final Var const__1043;
  
  public static final AFn const__1046;
  
  public static final Var const__1047;
  
  public static final AFn const__1050;
  
  public static final Var const__1051;
  
  public static final AFn const__1054;
  
  public static final Var const__1055;
  
  public static final AFn const__1058;
  
  public static final Var const__1059;
  
  public static final Object const__1060;
  
  public static final AFn const__1062;
  
  public static final Object const__1063;
  
  public static final Var const__1064;
  
  public static final AFn const__1067;
  
  public static final Var const__1068;
  
  public static final AFn const__1071;
  
  public static final Var const__1072;
  
  public static final AFn const__1075;
  
  public static final Var const__1076;
  
  public static final AFn const__1079;
  
  public static final Var const__1080;
  
  public static final AFn const__1083;
  
  public static final Var const__1084;
  
  public static final AFn const__1087;
  
  public static final Var const__1088;
  
  public static final AFn const__1091;
  
  public static final Var const__1092;
  
  public static final AFn const__1095;
  
  public static final Var const__1096;
  
  public static final AFn const__1099;
  
  public static final Var const__1100;
  
  public static final AFn const__1103;
  
  public static final Var const__1104;
  
  public static final AFn const__1107;
  
  public static final Var const__1108;
  
  public static final AFn const__1111;
  
  public static final Var const__1112;
  
  public static final AFn const__1115;
  
  public static final Var const__1116;
  
  public static final AFn const__1119;
  
  public static final Var const__1120;
  
  public static final AFn const__1123;
  
  public static final Var const__1124;
  
  public static final AFn const__1127;
  
  public static final Var const__1128;
  
  public static final AFn const__1131;
  
  public static final Var const__1132;
  
  public static final AFn const__1135;
  
  public static final Var const__1136;
  
  public static final AFn const__1139;
  
  public static final Var const__1140;
  
  public static final AFn const__1143;
  
  public static final Var const__1144;
  
  public static final AFn const__1147;
  
  public static final Var const__1148;
  
  public static final AFn const__1151;
  
  public static final Var const__1152;
  
  public static final AFn const__1155;
  
  public static final Var const__1156;
  
  public static final AFn const__1159;
  
  public static final Var const__1160;
  
  public static final AFn const__1163;
  
  public static final Var const__1164;
  
  public static final AFn const__1167;
  
  public static final Var const__1168;
  
  public static final AFn const__1171;
  
  public static final Var const__1172;
  
  public static final AFn const__1175;
  
  public static final Var const__1176;
  
  public static final AFn const__1179;
  
  public static final Var const__1180;
  
  public static final AFn const__1183;
  
  public static final Var const__1184;
  
  public static final AFn const__1187;
  
  public static final Var const__1188;
  
  public static final AFn const__1191;
  
  public static final AFn const__1194;
  
  public static final Var const__1195;
  
  public static final AFn const__1198;
  
  public static final Var const__1199;
  
  public static final AFn const__1202;
  
  public static final Var const__1203;
  
  public static final AFn const__1206;
  
  public static final Var const__1207;
  
  public static final AFn const__1210;
  
  public static final Var const__1211;
  
  public static final AFn const__1214;
  
  public static final Var const__1215;
  
  public static final AFn const__1218;
  
  public static final Var const__1219;
  
  public static final AFn const__1222;
  
  public static final Var const__1223;
  
  public static final AFn const__1226;
  
  public static final Var const__1227;
  
  public static final AFn const__1230;
  
  public static final Var const__1231;
  
  public static final AFn const__1234;
  
  public static final Var const__1235;
  
  public static final AFn const__1238;
  
  public static final Var const__1239;
  
  public static final AFn const__1242;
  
  public static final Var const__1243;
  
  public static final AFn const__1246;
  
  public static final Var const__1247;
  
  public static final Object const__1248;
  
  public static final Object const__1249;
  
  public static final Object const__1250;
  
  public static final Var const__1251;
  
  public static final Object const__1252;
  
  public static final Object const__1253;
  
  public static final Var const__1254;
  
  public static final Object const__1255;
  
  public static final Object const__1256;
  
  public static final Var const__1257;
  
  public static final Object const__1258;
  
  public static final Object const__1259;
  
  public static final Var const__1260;
  
  public static final Object const__1261;
  
  public static final Object const__1262;
  
  public static final Var const__1263;
  
  public static final Object const__1264;
  
  public static final Object const__1265;
  
  public static final Var const__1266;
  
  public static final Object const__1267;
  
  public static final Object const__1268;
  
  public static final Var const__1269;
  
  public static final Object const__1270;
  
  public static final Object const__1271;
  
  public static final Var const__1272;
  
  public static final Object const__1273;
  
  public static final Object const__1274;
  
  public static final Var const__1275;
  
  public static final Object const__1276;
  
  public static final Object const__1277;
  
  public static final Var const__1278;
  
  public static final Object const__1279;
  
  public static final Object const__1280;
  
  public static final Var const__1281;
  
  public static final Object const__1282;
  
  public static final Object const__1283;
  
  public static final Var const__1284;
  
  public static final Object const__1285;
  
  public static final Object const__1286;
  
  public static final Var const__1287;
  
  public static final Object const__1288;
  
  public static final Object const__1289;
  
  public static final Var const__1290;
  
  public static final AFn const__1293;
  
  public static final Var const__1294;
  
  public static final AFn const__1297;
  
  public static final Var const__1298;
  
  public static final AFn const__1301;
  
  public static final Var const__1302;
  
  public static final AFn const__1306;
  
  public static final Var const__1307;
  
  public static final AFn const__1310;
  
  public static final Var const__1311;
  
  public static final AFn const__1314;
  
  public static final Var const__1315;
  
  public static final AFn const__1318;
  
  public static final Var const__1319;
  
  public static final AFn const__1322;
  
  public static final Var const__1323;
  
  public static final AFn const__1327;
  
  public static final Var const__1328;
  
  public static final AFn const__1331;
  
  public static final Var const__1332;
  
  public static final AFn const__1336;
  
  public static final Var const__1337;
  
  public static final AFn const__1339;
  
  public static final Var const__1340;
  
  public static final AFn const__1343;
  
  public static final Var const__1344;
  
  public static final AFn const__1347;
  
  public static final Var const__1348;
  
  public static final AFn const__1350;
  
  public static final Var const__1351;
  
  public static final AFn const__1354;
  
  public static final Var const__1355;
  
  public static final AFn const__1358;
  
  public static final Var const__1359;
  
  public static final AFn const__1362;
  
  public static final Var const__1363;
  
  public static final AFn const__1366;
  
  public static final Var const__1367;
  
  public static final AFn const__1370;
  
  public static final Var const__1371;
  
  public static final AFn const__1374;
  
  public static final Var const__1375;
  
  public static final AFn const__1378;
  
  public static final Var const__1379;
  
  public static final AFn const__1382;
  
  public static final Var const__1383;
  
  public static final AFn const__1386;
  
  public static final Var const__1387;
  
  public static final AFn const__1390;
  
  public static final Var const__1391;
  
  public static final AFn const__1394;
  
  public static final Var const__1395;
  
  public static final AFn const__1398;
  
  public static final Var const__1399;
  
  public static final AFn const__1402;
  
  public static final Var const__1403;
  
  public static final AFn const__1406;
  
  public static final Var const__1407;
  
  public static final Object const__1408;
  
  public static final Object const__1409;
  
  public static final Var const__1410;
  
  public static final Object const__1411;
  
  public static final Object const__1412;
  
  public static final Var const__1413;
  
  public static final Object const__1414;
  
  public static final AFn const__1415;
  
  public static final Object const__1416;
  
  public static final Var const__1417;
  
  public static final Object const__1418;
  
  public static final AFn const__1419;
  
  public static final Object const__1420;
  
  public static final Var const__1421;
  
  public static final AFn const__1424;
  
  public static final Var const__1425;
  
  public static final AFn const__1428;
  
  public static final Var const__1429;
  
  public static final AFn const__1432;
  
  public static final Var const__1433;
  
  public static final AFn const__1436;
  
  public static final Var const__1437;
  
  public static final AFn const__1440;
  
  public static final Var const__1441;
  
  public static final AFn const__1444;
  
  public static final Var const__1445;
  
  public static final AFn const__1448;
  
  public static final Var const__1449;
  
  public static final AFn const__1452;
  
  public static final Var const__1453;
  
  public static final AFn const__1456;
  
  public static final Var const__1457;
  
  public static final AFn const__1460;
  
  public static final Var const__1461;
  
  public static final AFn const__1464;
  
  public static final Var const__1465;
  
  public static final AFn const__1468;
  
  public static final Var const__1469;
  
  public static final AFn const__1472;
  
  public static final Var const__1473;
  
  public static final AFn const__1476;
  
  public static final Var const__1477;
  
  public static final AFn const__1480;
  
  public static final Var const__1481;
  
  public static final AFn const__1484;
  
  public static final Var const__1485;
  
  public static final AFn const__1488;
  
  public static final Var const__1489;
  
  public static final AFn const__1492;
  
  public static final Var const__1493;
  
  public static final AFn const__1496;
  
  public static final Var const__1497;
  
  public static final AFn const__1500;
  
  public static final Var const__1501;
  
  public static final AFn const__1504;
  
  public static final Var const__1505;
  
  public static final AFn const__1508;
  
  public static final Var const__1509;
  
  public static final AFn const__1512;
  
  public static final Var const__1513;
  
  public static final AFn const__1516;
  
  public static final Var const__1517;
  
  public static final AFn const__1520;
  
  public static final Var const__1521;
  
  public static final AFn const__1524;
  
  public static final Var const__1525;
  
  public static final AFn const__1528;
  
  public static final Var const__1529;
  
  public static final AFn const__1532;
  
  public static final Var const__1533;
  
  public static final AFn const__1536;
  
  public static final Var const__1537;
  
  public static final AFn const__1540;
  
  public static final Var const__1541;
  
  public static final AFn const__1544;
  
  public static final Var const__1545;
  
  public static final AFn const__1548;
  
  public static final Var const__1549;
  
  public static final AFn const__1552;
  
  public static final Var const__1553;
  
  public static final AFn const__1556;
  
  public static final Var const__1557;
  
  public static final AFn const__1560;
  
  public static final Var const__1561;
  
  public static final AFn const__1564;
  
  public static final Var const__1565;
  
  public static final AFn const__1568;
  
  public static final Var const__1569;
  
  public static final AFn const__1572;
  
  public static final Var const__1573;
  
  public static final AFn const__1576;
  
  public static final Var const__1577;
  
  public static final AFn const__1580;
  
  public static final Var const__1581;
  
  public static final AFn const__1584;
  
  public static final Var const__1585;
  
  public static final AFn const__1588;
  
  public static final Var const__1589;
  
  public static final AFn const__1592;
  
  public static final Var const__1593;
  
  public static final AFn const__1596;
  
  public static final Var const__1597;
  
  public static final AFn const__1600;
  
  public static final Var const__1601;
  
  public static final AFn const__1604;
  
  public static final Var const__1605;
  
  public static final AFn const__1608;
  
  public static final Var const__1609;
  
  public static final AFn const__1612;
  
  public static final AFn const__1618;
  
  public static final Var const__1619;
  
  public static final AFn const__1622;
  
  public static final AFn const__1626;
  
  public static final AFn const__1630;
  
  public static final Var const__1631;
  
  public static final AFn const__1634;
  
  public static final Var const__1635;
  
  public static final AFn const__1638;
  
  public static final Var const__1639;
  
  public static final AFn const__1642;
  
  public static final Var const__1643;
  
  public static final AFn const__1646;
  
  public static final Var const__1647;
  
  public static final AFn const__1650;
  
  public static final Var const__1651;
  
  public static final AFn const__1654;
  
  public static final Var const__1655;
  
  public static final AFn const__1658;
  
  public static final Var const__1659;
  
  public static final AFn const__1662;
  
  public static final Var const__1663;
  
  public static final AFn const__1666;
  
  public static final Var const__1667;
  
  public static final AFn const__1670;
  
  public static final Var const__1671;
  
  public static final AFn const__1674;
  
  public static final Var const__1675;
  
  public static final AFn const__1678;
  
  public static final Var const__1679;
  
  public static final AFn const__1682;
  
  public static final Var const__1683;
  
  public static final AFn const__1686;
  
  public static final Var const__1687;
  
  public static final AFn const__1690;
  
  public static final Var const__1691;
  
  public static final AFn const__1694;
  
  public static final Var const__1695;
  
  public static final AFn const__1698;
  
  public static final Var const__1699;
  
  public static final AFn const__1703;
  
  public static final Var const__1704;
  
  public static final AFn const__1708;
  
  public static final Var const__1709;
  
  public static final AFn const__1712;
  
  public static final Var const__1713;
  
  public static final AFn const__1716;
  
  public static final Var const__1717;
  
  public static final AFn const__1720;
  
  public static final Var const__1721;
  
  public static final AFn const__1724;
  
  public static final Var const__1725;
  
  public static final AFn const__1728;
  
  public static final Var const__1729;
  
  public static final AFn const__1732;
  
  public static final Var const__1733;
  
  public static final AFn const__1736;
  
  public static final Var const__1737;
  
  public static final AFn const__1740;
  
  public static final Var const__1741;
  
  public static final AFn const__1744;
  
  public static final Var const__1745;
  
  public static final AFn const__1748;
  
  public static final Var const__1749;
  
  public static final AFn const__1752;
  
  public static final Var const__1753;
  
  public static final AFn const__1756;
  
  public static final Var const__1757;
  
  public static final AFn const__1760;
  
  public static final Var const__1761;
  
  public static final AFn const__1764;
  
  public static final Var const__1765;
  
  public static final AFn const__1768;
  
  public static final Var const__1769;
  
  public static final AFn const__1772;
  
  public static final Var const__1773;
  
  public static final AFn const__1776;
  
  public static final Var const__1777;
  
  public static final AFn const__1780;
  
  public static final Var const__1781;
  
  public static final AFn const__1784;
  
  public static final Var const__1785;
  
  public static final AFn const__1788;
  
  public static final Var const__1789;
  
  public static final AFn const__1792;
  
  public static final Var const__1793;
  
  public static final AFn const__1796;
  
  public static final Var const__1797;
  
  public static final AFn const__1800;
  
  public static final Var const__1801;
  
  public static final AFn const__1804;
  
  public static final Var const__1805;
  
  public static final AFn const__1808;
  
  public static final Var const__1809;
  
  public static final AFn const__1812;
  
  public static final Var const__1813;
  
  public static final AFn const__1816;
  
  public static final Var const__1817;
  
  public static final AFn const__1820;
  
  public static final Var const__1821;
  
  public static final AFn const__1824;
  
  public static final Var const__1825;
  
  public static final AFn const__1828;
  
  public static final Var const__1829;
  
  public static final AFn const__1832;
  
  public static final Var const__1833;
  
  public static final AFn const__1836;
  
  public static final Var const__1837;
  
  public static final AFn const__1840;
  
  public static final Var const__1841;
  
  public static final Object const__1842;
  
  public static final AFn const__1843;
  
  public static final Object const__1844;
  
  public static final Var const__1845;
  
  public static final Object const__1846;
  
  public static final AFn const__1847;
  
  public static final Object const__1848;
  
  public static final Var const__1849;
  
  public static final Object const__1850;
  
  public static final AFn const__1851;
  
  public static final Object const__1852;
  
  public static final Var const__1853;
  
  public static final Object const__1854;
  
  public static final AFn const__1855;
  
  public static final Object const__1856;
  
  public static final Var const__1857;
  
  public static final Object const__1858;
  
  public static final AFn const__1859;
  
  public static final Object const__1860;
  
  public static final Var const__1861;
  
  public static final Object const__1862;
  
  public static final AFn const__1863;
  
  public static final Object const__1864;
  
  public static final Var const__1865;
  
  public static final Object const__1866;
  
  public static final AFn const__1867;
  
  public static final Object const__1868;
  
  public static final Var const__1869;
  
  public static final Object const__1870;
  
  public static final AFn const__1871;
  
  public static final Object const__1872;
  
  public static final Var const__1873;
  
  public static final Object const__1874;
  
  public static final AFn const__1875;
  
  public static final Object const__1876;
  
  public static final Var const__1877;
  
  public static final AFn const__1880;
  
  public static final Var const__1881;
  
  public static final AFn const__1884;
  
  public static final Var const__1885;
  
  public static final AFn const__1888;
  
  public static final Var const__1889;
  
  public static final AFn const__1892;
  
  public static final Var const__1893;
  
  public static final AFn const__1896;
  
  public static final Var const__1897;
  
  public static final AFn const__1900;
  
  public static final Var const__1901;
  
  public static final AFn const__1904;
  
  public static final Var const__1905;
  
  public static final AFn const__1908;
  
  public static final Var const__1909;
  
  public static final AFn const__1912;
  
  public static final Var const__1913;
  
  public static final AFn const__1916;
  
  public static final Var const__1917;
  
  public static final AFn const__1920;
  
  public static final Var const__1921;
  
  public static final AFn const__1924;
  
  public static final Var const__1925;
  
  public static final AFn const__1928;
  
  public static final Var const__1929;
  
  public static final AFn const__1932;
  
  public static final Var const__1933;
  
  public static final AFn const__1935;
  
  public static final Var const__1936;
  
  public static final AFn const__1939;
  
  public static final AFn const__1942;
  
  public static final Var const__1943;
  
  public static final AFn const__1946;
  
  public static final Var const__1947;
  
  public static final AFn const__1950;
  
  public static final Var const__1951;
  
  public static final AFn const__1954;
  
  public static final Var const__1955;
  
  public static final AFn const__1958;
  
  public static final Var const__1959;
  
  public static final AFn const__1962;
  
  public static final AFn const__1964;
  
  public static final Var const__1965;
  
  public static final AFn const__1968;
  
  public static final Var const__1969;
  
  public static final AFn const__1972;
  
  public static final Var const__1973;
  
  public static final AFn const__1976;
  
  public static final Var const__1977;
  
  public static final AFn const__1980;
  
  public static final Var const__1981;
  
  public static final AFn const__1984;
  
  public static final Var const__1985;
  
  public static final AFn const__1988;
  
  public static final Var const__1989;
  
  public static final AFn const__1992;
  
  public static final Var const__1993;
  
  public static final AFn const__1996;
  
  public static final Var const__1997;
  
  public static final AFn const__1999;
  
  public static final Var const__2000;
  
  public static final AFn const__2003;
  
  public static final Var const__2004;
  
  public static final AFn const__2007;
  
  public static final Var const__2008;
  
  public static final AFn const__2011;
  
  public static final Var const__2012;
  
  public static final AFn const__2015;
  
  public static final Var const__2016;
  
  public static final AFn const__2019;
  
  public static final Var const__2020;
  
  public static final AFn const__2023;
  
  public static final Var const__2024;
  
  public static final AFn const__2027;
  
  public static final Var const__2028;
  
  public static final AFn const__2030;
  
  public static final Var const__2031;
  
  public static final AFn const__2034;
  
  public static final Var const__2035;
  
  public static final AFn const__2038;
  
  public static final Var const__2039;
  
  public static final AFn const__2042;
  
  public static final Var const__2043;
  
  public static final AFn const__2046;
  
  public static final Var const__2047;
  
  public static final AFn const__2050;
  
  public static final Var const__2051;
  
  public static final AFn const__2054;
  
  public static final Var const__2055;
  
  public static final AFn const__2058;
  
  public static final Var const__2059;
  
  public static final AFn const__2062;
  
  public static final Var const__2063;
  
  public static final AFn const__2066;
  
  public static final Var const__2067;
  
  public static final AFn const__2070;
  
  public static final Var const__2071;
  
  public static final AFn const__2074;
  
  public static final Var const__2075;
  
  public static final AFn const__2078;
  
  public static final Var const__2079;
  
  public static final AFn const__2082;
  
  public static final Var const__2083;
  
  public static final AFn const__2086;
  
  public static final Var const__2087;
  
  public static final AFn const__2090;
  
  public static final Var const__2091;
  
  public static final AFn const__2094;
  
  public static final Var const__2095;
  
  public static final AFn const__2098;
  
  public static final Var const__2099;
  
  public static final AFn const__2102;
  
  public static final Var const__2103;
  
  public static final AFn const__2106;
  
  public static final Var const__2107;
  
  public static final AFn const__2110;
  
  public static final AFn const__2113;
  
  public static final Var const__2114;
  
  public static final AFn const__2117;
  
  public static final Var const__2118;
  
  public static final AFn const__2121;
  
  public static final Var const__2122;
  
  public static final AFn const__2125;
  
  public static final Var const__2126;
  
  public static final AFn const__2129;
  
  public static final Var const__2130;
  
  public static final AFn const__2133;
  
  public static final Var const__2134;
  
  public static final AFn const__2137;
  
  public static final Var const__2138;
  
  public static final AFn const__2141;
  
  public static final Var const__2142;
  
  public static final AFn const__2145;
  
  public static final Var const__2146;
  
  public static final AFn const__2149;
  
  public static final Var const__2150;
  
  public static final AFn const__2153;
  
  public static final Var const__2154;
  
  public static final AFn const__2157;
  
  public static final Var const__2158;
  
  public static final AFn const__2161;
  
  public static final Var const__2162;
  
  public static final AFn const__2165;
  
  public static final Var const__2166;
  
  public static final AFn const__2169;
  
  public static final Var const__2170;
  
  public static final AFn const__2173;
  
  public static final Var const__2174;
  
  public static final AFn const__2177;
  
  public static final Var const__2178;
  
  public static final AFn const__2181;
  
  public static final Var const__2182;
  
  public static final AFn const__2184;
  
  public static final Var const__2185;
  
  public static final AFn const__2187;
  
  public static final Var const__2188;
  
  public static final AFn const__2190;
  
  public static final Var const__2191;
  
  public static final AFn const__2193;
  
  public static final Var const__2194;
  
  public static final AFn const__2197;
  
  public static final Var const__2198;
  
  public static final AFn const__2201;
  
  public static final Var const__2202;
  
  public static final AFn const__2205;
  
  public static final Var const__2206;
  
  public static final AFn const__2209;
  
  public static final Var const__2210;
  
  public static final AFn const__2213;
  
  public static final Var const__2214;
  
  public static final Var const__2215;
  
  public static final Var const__2216;
  
  public static final AFn const__2219;
  
  public static final Var const__2220;
  
  public static final AFn const__2221;
  
  public static final Var const__2222;
  
  public static final AFn const__2223;
  
  public static final Var const__2224;
  
  public static final AFn const__2225;
  
  public static final Var const__2226;
  
  public static final AFn const__2227;
  
  public static final Var const__2228;
  
  public static final AFn const__2229;
  
  public static final Var const__2230;
  
  public static final AFn const__2231;
  
  public static final Var const__2232;
  
  public static final AFn const__2233;
  
  public static final Var const__2234;
  
  public static final AFn const__2235;
  
  public static final Var const__2236;
  
  public static final AFn const__2237;
  
  public static final Var const__2238;
  
  public static final AFn const__2239;
  
  public static final Var const__2240;
  
  public static final AFn const__2241;
  
  public static final Var const__2242;
  
  public static final AFn const__2243;
  
  public static final Var const__2244;
  
  public static final AFn const__2245;
  
  public static final Var const__2246;
  
  public static final AFn const__2247;
  
  public static final Var const__2248;
  
  public static final AFn const__2249;
  
  public static final Var const__2250;
  
  public static final AFn const__2251;
  
  public static final Var const__2252;
  
  public static final AFn const__2255;
  
  public static final Var const__2256;
  
  public static final AFn const__2259;
  
  public static final Var const__2260;
  
  public static final AFn const__2265;
  
  public static final Var const__2266;
  
  public static final AFn const__2269;
  
  public static final Var const__2270;
  
  public static final AFn const__2273;
  
  public static final Var const__2274;
  
  public static final AFn const__2276;
  
  public static final Object const__2277;
  
  public static final Var const__2278;
  
  public static final AFn const__2280;
  
  public static final Var const__2281;
  
  public static final AFn const__2284;
  
  public static final Var const__2285;
  
  public static final AFn const__2288;
  
  public static final Var const__2289;
  
  public static final AFn const__2292;
  
  public static final Var const__2293;
  
  public static final AFn const__2296;
  
  public static final Var const__2297;
  
  public static final AFn const__2300;
  
  public static final Var const__2301;
  
  public static final AFn const__2304;
  
  public static final Var const__2305;
  
  public static final AFn const__2308;
  
  public static final AFn const__2309;
  
  public static final Var const__2310;
  
  public static final AFn const__2313;
  
  public static final Object const__2314;
  
  public static final Var const__2315;
  
  public static final Var const__2316;
  
  public static final ISeq const__2317;
  
  public static final AFn const__2321;
  
  public static final Keyword const__2322;
  
  public static final AFn const__2323;
  
  public static final Keyword const__2324;
  
  public static final Keyword const__2325;
  
  public static final Keyword const__2326;
  
  public static final AFn const__2327;
  
  public static final Keyword const__2328;
  
  public static final AFn const__2329;
  
  public static final AFn const__2330;
  
  public static final Keyword const__2331;
  
  public static final Var const__2332;
  
  public static final AFn const__2333;
  
  public static final Var const__2334;
  
  public static final Object const__2335;
  
  public static final Var const__2336;
  
  public static final AFn const__2339;
  
  public static final Var const__2340;
  
  public static final AFn const__2343;
  
  public static final Object const__2344;
  
  public static final Var const__2345;
  
  public static final AFn const__2348;
  
  public static final Var const__2349;
  
  public static final AFn const__2352;
  
  public static final Var const__2353;
  
  public static final Keyword const__2354;
  
  public static final Object const__2355;
  
  public static final Object const__2356;
  
  public static final Var const__2357;
  
  public static final AFn const__2360;
  
  public static final Var const__2361;
  
  public static final AFn const__2364;
  
  public static final Var const__2365;
  
  public static final AFn const__2368;
  
  public static final Var const__2369;
  
  public static final AFn const__2372;
  
  public static final Var const__2373;
  
  public static final AFn const__2376;
  
  public static final Var const__2377;
  
  public static final AFn const__2380;
  
  public static final AFn const__2381;
  
  public static final Var const__2382;
  
  public static final AFn const__2385;
  
  public static final Var const__2386;
  
  public static final AFn const__2389;
  
  public static final Var const__2390;
  
  public static final AFn const__2393;
  
  public static final Var const__2394;
  
  public static final AFn const__2397;
  
  public static final Var const__2398;
  
  public static final AFn const__2401;
  
  public static final Var const__2402;
  
  public static final AFn const__2405;
  
  public static final Var const__2406;
  
  public static final AFn const__2409;
  
  public static final Var const__2410;
  
  public static final AFn const__2413;
  
  public static final Var const__2414;
  
  public static final AFn const__2417;
  
  public static final Var const__2418;
  
  public static final AFn const__2421;
  
  public static final Var const__2422;
  
  public static final AFn const__2423;
  
  public static final Var const__2424;
  
  public static final AFn const__2427;
  
  public static final Var const__2428;
  
  public static final AFn const__2431;
  
  public static final Var const__2432;
  
  public static final AFn const__2435;
  
  public static final AFn const__2438;
  
  public static final Var const__2439;
  
  public static final AFn const__2442;
  
  public static final Var const__2443;
  
  public static final AFn const__2446;
  
  public static final Var const__2447;
  
  public static final AFn const__2450;
  
  public static final Var const__2451;
  
  public static final AFn const__2454;
  
  public static final Var const__2455;
  
  public static final AFn const__2458;
  
  public static final Var const__2459;
  
  public static final AFn const__2462;
  
  public static final Var const__2463;
  
  public static final AFn const__2466;
  
  public static final Var const__2467;
  
  public static final AFn const__2470;
  
  public static final Var const__2471;
  
  public static final AFn const__2474;
  
  public static final Var const__2475;
  
  public static final AFn const__2478;
  
  public static final Var const__2479;
  
  public static final AFn const__2482;
  
  public static final Var const__2483;
  
  public static final AFn const__2486;
  
  public static final Var const__2487;
  
  public static final AFn const__2490;
  
  public static final AFn const__2493;
  
  public static final Var const__2494;
  
  public static final AFn const__2497;
  
  public static final Var const__2498;
  
  public static final AFn const__2501;
  
  public static final Var const__2502;
  
  public static final AFn const__2505;
  
  public static final Var const__2506;
  
  public static final AFn const__2509;
  
  public static final Var const__2510;
  
  public static final AFn const__2513;
  
  public static final Var const__2514;
  
  public static final AFn const__2517;
  
  public static final Var const__2518;
  
  public static final AFn const__2521;
  
  public static final Var const__2522;
  
  public static final AFn const__2525;
  
  public static final Var const__2526;
  
  public static final AFn const__2529;
  
  public static final AFn const__2532;
  
  public static final Var const__2533;
  
  public static final AFn const__2536;
  
  public static final Var const__2537;
  
  public static final AFn const__2540;
  
  public static final Var const__2541;
  
  public static final AFn const__2544;
  
  public static final Var const__2545;
  
  public static final AFn const__2548;
  
  public static final Var const__2549;
  
  public static final Object const__2550;
  
  public static final Var const__2551;
  
  public static final AFn const__2554;
  
  public static final Var const__2555;
  
  public static final AFn const__2558;
  
  public static final Var const__2559;
  
  public static final AFn const__2562;
  
  public static final Var const__2563;
  
  public static final AFn const__2566;
  
  public static final Var const__2567;
  
  public static final AFn const__2570;
  
  public static final Var const__2571;
  
  public static final AFn const__2573;
  
  public static final AFn const__2574;
  
  public static final Var const__2575;
  
  public static final Var const__2576;
  
  public static final AFn const__2578;
  
  public static final Var const__2579;
  
  public static final AFn const__2581;
  
  public static final Var const__2582;
  
  public static final AFn const__2585;
  
  public static final Var const__2586;
  
  public static final AFn const__2589;
  
  public static final Var const__2590;
  
  public static final AFn const__2593;
  
  public static final Var const__2594;
  
  public static final AFn const__2597;
  
  public static final Var const__2598;
  
  public static final AFn const__2601;
  
  public static final Var const__2602;
  
  public static final AFn const__2605;
  
  public static final Var const__2606;
  
  public static final AFn const__2609;
  
  public static final Var const__2610;
  
  public static final AFn const__2613;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new core.fn__5374());
    const__6.setMeta((IPersistentMap)const__12);
    const__13.setMeta((IPersistentMap)const__15);
    const__16.setMeta((IPersistentMap)const__21);
    const__16









      
      .bindRoot(PersistentList.creator);
    const__22.setMeta((IPersistentMap)const__26);
    const__22.bindRoot(new core.cons__5376());
    const__27.setMeta((IPersistentMap)const__30);
    const__27.bindRoot(new core.let__5378());
    const__31.setMeta((IPersistentMap)const__33);
    const__31.bindRoot(new core.loop__5380());
    const__34.setMeta((IPersistentMap)const__36);
    const__34.bindRoot(new core.fn__5382());
    const__37.setMeta((IPersistentMap)const__40);
    const__37.bindRoot(new core.first__5384());
    const__41.setMeta((IPersistentMap)const__46);
    const__41.bindRoot(new core.next__5386());
    const__47.setMeta((IPersistentMap)const__50);
    const__47.bindRoot(new core.rest__5388());
    const__51.setMeta((IPersistentMap)const__54);
    const__51.bindRoot(new core.conj__5390());
    const__55.setMeta((IPersistentMap)const__58);
    const__55.bindRoot(new core.second__5392());
    const__59.setMeta((IPersistentMap)const__62);
    const__59.bindRoot(new core.ffirst__5394());
    const__63.setMeta((IPersistentMap)const__66);
    const__63.bindRoot(new core.nfirst__5396());
    const__67.setMeta((IPersistentMap)const__70);
    const__67.bindRoot(new core.fnext__5398());
    const__71.setMeta((IPersistentMap)const__74);
    const__71.bindRoot(new core.nnext__5400());
    const__75.setMeta((IPersistentMap)const__78);
    const__75.bindRoot(new core.seq__5402());
    const__79.setMeta((IPersistentMap)const__82);
    const__79.bindRoot(new core.instance_QMARK___5404());
    const__83.setMeta((IPersistentMap)const__86);
    const__83.bindRoot(new core.seq_QMARK___5406());
    const__87.setMeta((IPersistentMap)const__90);
    const__87.bindRoot(new core.char_QMARK___5408());
    const__91.setMeta((IPersistentMap)const__94);
    const__91.bindRoot(new core.string_QMARK___5410());
    const__95.setMeta((IPersistentMap)const__98);
    const__95.bindRoot(new core.map_QMARK___5412());
    const__99.setMeta((IPersistentMap)const__102);
    const__99.bindRoot(new core.vector_QMARK___5414());
    const__103.setMeta((IPersistentMap)const__106);
    const__103.bindRoot(new core.assoc__5416());
    const__107.setMeta((IPersistentMap)const__110);
    const__107.bindRoot(new core.meta__5418());
    const__111.setMeta((IPersistentMap)const__114);
    const__111.bindRoot(new core.with_meta__5420());
    const__115.setDynamic(true).setMeta((IPersistentMap)const__119);
    const__115.setDynamic(true).bindRoot(new core.assert_valid_fdecl());
    const__120.setMeta((IPersistentMap)const__122);
    const__120.bindRoot(new core.sigs());
    const__123.setMeta((IPersistentMap)const__126);
    const__123.bindRoot(new core.last__5428());
    const__127.setMeta((IPersistentMap)const__130);
    const__127.bindRoot(new core.butlast__5430());
    const__131.setMeta((IPersistentMap)const__134);
    const__131.bindRoot(new core.defn__5432());
    ((Var)const__131)


























































































































































































































































































































      
      .setMacro();
    const__135.setMeta((IPersistentMap)const__138);
    const__135.bindRoot(new core.to_array());
    const__139.setMeta((IPersistentMap)const__142);
    const__139.bindRoot(new core.cast());
    const__143.setMeta((IPersistentMap)const__146);
    const__143.bindRoot(new core.vector());
    const__147.setMeta((IPersistentMap)const__150);
    const__147.bindRoot(new core.vec());
    const__151.setMeta((IPersistentMap)const__154);
    const__151.bindRoot(new core.hash_map());
    const__155.setMeta((IPersistentMap)const__158);
    const__155.bindRoot(new core.hash_set());
    const__159.setMeta((IPersistentMap)const__162);
    const__159.bindRoot(new core.sorted_map());
    const__163.setMeta((IPersistentMap)const__166);
    const__163.bindRoot(new core.sorted_map_by());
    const__167.setMeta((IPersistentMap)const__170);
    const__167.bindRoot(new core.sorted_set());
    const__171.setMeta((IPersistentMap)const__174);
    const__171.bindRoot(new core.sorted_set_by());
    const__175.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__19, "1.0", const__11, "clojure/core.clj", const__24, Boolean.TRUE, const__9, const__10, const__7, const__176, 
            const__43, const__177, const__17, const__178, const__2, "Returns true if x is nil, false otherwise.", const__179, new core.nil_QMARK___inliner__5444() }));
    const__175.bindRoot(new core.nil_QMARK_());
    const__180.setMeta((IPersistentMap)const__183);
    const__180.bindRoot(new core.defmacro());
    ((Var)const__180)

























































































































































      
      .setMacro();
    const__184.setMeta((IPersistentMap)const__187);
    const__184.bindRoot(new core.when());
    ((Var)const__184)
      
      .setMacro();
    const__188.setMeta((IPersistentMap)const__191);
    const__188.bindRoot(new core.when_not());
    ((Var)const__188)




      
      .setMacro();
    const__192.setMeta((IPersistentMap)const__195);
    const__192.bindRoot(new core.false_QMARK_());
    const__196.setMeta((IPersistentMap)const__199);
    const__196.bindRoot(new core.true_QMARK_());
    const__200.setMeta((IPersistentMap)const__203);
    const__200.bindRoot(new core.boolean_QMARK_());
    const__204.setMeta((IPersistentMap)const__207);
    const__204.bindRoot(new core.not());
    const__208.setMeta((IPersistentMap)const__211);
    const__208.bindRoot(new core.some_QMARK_());
    const__212.setMeta((IPersistentMap)const__215);
    const__212.bindRoot(new core.any_QMARK_());
    const__216.setMeta((IPersistentMap)const__220);
    const__216.bindRoot(new core.str());
    const__221.setMeta((IPersistentMap)const__224);
    const__221.bindRoot(new core.symbol_QMARK_());
    const__225.setMeta((IPersistentMap)const__228);
    const__225.bindRoot(new core.keyword_QMARK_());
    const__229.setMeta((IPersistentMap)const__232);
    const__229.bindRoot(new core.cond());
    ((Var)const__229)









































































      
      .setMacro();
    const__233.setMeta((IPersistentMap)const__237);
    const__233.bindRoot(new core.symbol());
    const__238.setMeta((IPersistentMap)const__241);
    const__238.bindRoot(new core.gensym());
    const__242.setMeta((IPersistentMap)const__246);
    const__242.bindRoot(new core.keyword());
    const__247.setMeta((IPersistentMap)const__250);
    const__247.bindRoot(new core.find_keyword());
    const__251.setMeta((IPersistentMap)const__254);
    const__251.bindRoot(new core.spread());
    const__255.setMeta((IPersistentMap)const__258);
    const__255.bindRoot(new core.list_STAR_());
    const__259.setMeta((IPersistentMap)const__262);
    const__259.bindRoot(new core.apply());
    const__263.setMeta((IPersistentMap)const__266);
    const__263.bindRoot(new core.vary_meta());
    const__267.setMeta((IPersistentMap)const__270);
    const__267.bindRoot(new core.lazy_seq());
    ((Var)const__267)











































































































      
      .setMacro();
    const__271.setMeta((IPersistentMap)const__275);
    const__271.bindRoot(new core.chunk_buffer());
    const__276.setMeta((IPersistentMap)const__279);
    const__276.bindRoot(new core.chunk_append());
    const__280.setMeta((IPersistentMap)const__284);
    const__280.bindRoot(new core.chunk());
    const__285.setMeta((IPersistentMap)const__288);
    const__285.bindRoot(new core.chunk_first());
    const__289.setMeta((IPersistentMap)const__292);
    const__289.bindRoot(new core.chunk_rest());
    const__293.setMeta((IPersistentMap)const__296);
    const__293.bindRoot(new core.chunk_next());
    const__297.setMeta((IPersistentMap)const__300);
    const__297.bindRoot(new core.chunk_cons());
    const__301.setMeta((IPersistentMap)const__304);
    const__301.bindRoot(new core.chunked_seq_QMARK_());
    const__305.setMeta((IPersistentMap)const__308);
    const__305.bindRoot(new core.concat());
    const__309.setMeta((IPersistentMap)const__312);
    const__309.bindRoot(new core.delay());
    ((Var)const__309)





























































      
      .setMacro();
    const__313.setMeta((IPersistentMap)const__316);
    const__313.bindRoot(new core.delay_QMARK_());
    const__317.setMeta((IPersistentMap)const__320);
    const__317.bindRoot(new core.force());
    const__321.setMeta((IPersistentMap)const__324);
    const__321.bindRoot(new core.if_not());
    ((Var)const__321)



















      
      .setMacro();
    const__325.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__326, const__2, "Tests if 2 arguments are the same object", const__179, new core.identical_QMARK___inliner__5504(), const__327, const__329, const__19, "1.0", 
            const__7, const__330, const__9, const__10, const__11, "clojure/core.clj" }));
    const__325.bindRoot(new core.identical_QMARK_());
    const__331.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__332, const__2, "Equality. Returns true if x equals y, false if not. Same as\n  Java x.equals(y) except it also works for nil, and compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define equals() (and thus =) as a value, not an identity,\n  comparison.", const__179, new core._EQ___inliner__5507(), const__327, const__333, const__19, "1.0", 
            const__7, const__334, const__9, const__10, const__11, "clojure/core.clj" }));
    const__331.bindRoot(new core._EQ_());
    const__335.setMeta((IPersistentMap)const__338);
    const__335.bindRoot(new core.not_EQ_());
    const__339.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__340, const__2, "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Same as Java x.compareTo(y) except it also works for nil, and\n  compares numbers and collections in a type-independent manner. x\n  must implement Comparable", const__179, new core.compare__inliner__5511(), const__19, "1.0", const__7, const__341, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__339.bindRoot(new core.compare());
    const__342.setMeta((IPersistentMap)const__345);
    const__342.bindRoot(new core.and());
    ((Var)const__342)









































































      
      .setMacro();
    const__346.setMeta((IPersistentMap)const__349);
    const__346.bindRoot(new core.or());
    ((Var)const__346)










      
      .setMacro();
    const__350.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__351, const__2, "Returns true if num is zero, else false", const__179, new core.zero_QMARK___inliner__5518(), const__19, "1.0", const__7, const__352, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__350.bindRoot(new core.zero_QMARK_());
    const__353.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__354, const__2, "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Java Collections and Maps", const__179, new core.count__inliner__5521(), const__19, "1.0", const__7, const__355, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__353.bindRoot(new core.count());
    const__356.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__357, const__2, "Coerce to int", const__179, new core.int__inliner__5524(), const__19, "1.0", const__7, const__358, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__356.bindRoot(new core.int());
    const__359.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__360, const__2, "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, Java arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", const__179, new core.nth__inliner__5527(), const__327, const__362, const__19, "1.0", 
            const__7, const__363, const__9, const__10, const__11, "clojure/core.clj" }));
    const__359.bindRoot(new core.nth());
    const__364.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__365, const__2, "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", const__179, new core._LT___inliner__5530(), const__327, const__366, const__19, "1.0", 
            const__7, const__367, const__9, const__10, const__11, "clojure/core.clj" }));
    const__364.bindRoot(new core._LT_());
    const__368.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__369, const__2, "Returns a number one greater than num. Supports arbitrary precision.\n  See also: inc", const__179, new core.inc_SINGLEQUOTE___inliner__5533(), const__19, "1.0", const__7, const__370, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__368.bindRoot(new core.inc_SINGLEQUOTE_());
    const__371.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__372, const__2, "Returns a number one greater than num. Does not auto-promote\n  longs, will throw on overflow. See also: inc'", const__179, new core.inc__inliner__5536(), const__19, "1.2", const__7, const__373, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__371.bindRoot(new core.inc());
    const__374.setMeta((IPersistentMap)const__377);
    const__374.bindRoot(new core.reduce1());
    const__378.setMeta((IPersistentMap)const__381);
    const__378.bindRoot(new core.reverse());
    const__382.setMeta((IPersistentMap)const__385);
    const__382.bindRoot(new core.nary_inline());
    const__386.setMeta((IPersistentMap)const__389);
    const__386.bindRoot(new core._GT_1_QMARK_());
    const__390.setMeta((IPersistentMap)const__393);
    const__390.bindRoot(new core._GT_0_QMARK_());
    const__394























































































































      
      .setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__395, const__2, "Returns the sum of nums. (+') returns 0. Supports arbitrary precision.\n  See also: +", const__179, ((IFn)const__382.getRawRoot()).invoke(const__396), const__327, const__386.getRawRoot(), const__19, "1.0", 
            const__7, const__397, const__9, const__10, const__11, "clojure/core.clj" }));
    const__394.bindRoot(new core._PLUS__SINGLEQUOTE_());
    const__398










      
      .setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__399, const__2, "Returns the sum of nums. (+) returns 0. Does not auto-promote\n  longs, will throw on overflow. See also: +'", const__179, ((IFn)const__382.getRawRoot()).invoke(const__400, const__401), const__327, const__386.getRawRoot(), const__19, "1.2", 
            const__7, const__402, const__9, const__10, const__11, "clojure/core.clj" }));
    const__398.bindRoot(new core._PLUS_());
    const__403










      
      .setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__404, const__2, "Returns the product of nums. (*') returns 1. Supports arbitrary precision.\n  See also: *", const__179, ((IFn)const__382.getRawRoot()).invoke(const__405), const__327, const__386.getRawRoot(), const__19, "1.0", 
            const__7, const__406, const__9, const__10, const__11, "clojure/core.clj" }));
    const__403.bindRoot(new core._STAR__SINGLEQUOTE_());
    const__407










      
      .setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__408, const__2, "Returns the product of nums. (*) returns 1. Does not auto-promote\n  longs, will throw on overflow. See also: *'", const__179, ((IFn)const__382.getRawRoot()).invoke(const__409, const__410), const__327, const__386.getRawRoot(), const__19, "1.2", 
            const__7, const__411, const__9, const__10, const__11, "clojure/core.clj" }));
    const__407.bindRoot(new core._STAR_());
    const__412










      
      .setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__413, const__2, "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", const__179, ((IFn)const__382.getRawRoot()).invoke(const__414), const__327, const__386.getRawRoot(), const__19, "1.0", 
            const__7, const__415, const__9, const__10, const__11, "clojure/core.clj" }));
    const__412.bindRoot(new core._SLASH_());
    const__416










      
      .setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__417, const__2, "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Supports arbitrary precision.\n  See also: -", const__179, ((IFn)const__382.getRawRoot()).invoke(const__418), const__327, const__390.getRawRoot(), const__19, "1.0", 
            const__7, const__419, const__9, const__10, const__11, "clojure/core.clj" }));
    const__416.bindRoot(new core.__SINGLEQUOTE_());
    const__420










      
      .setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__421, const__2, "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Does not auto-promote\n  longs, will throw on overflow. See also: -'", const__179, ((IFn)const__382.getRawRoot()).invoke(const__422, const__423), const__327, const__390.getRawRoot(), const__19, "1.2", 
            const__7, const__424, const__9, const__10, const__11, "clojure/core.clj" }));
    const__420.bindRoot(new core._());
    const__425.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__426, const__2, "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", const__179, new core._LT__EQ___inliner__5555(), const__327, const__427, const__19, "1.0", 
            const__7, const__428, const__9, const__10, const__11, "clojure/core.clj" }));
    const__425.bindRoot(new core._LT__EQ_());
    const__429.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__430, const__2, "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", const__179, new core._GT___inliner__5558(), const__327, const__431, const__19, "1.0", 
            const__7, const__432, const__9, const__10, const__11, "clojure/core.clj" }));
    const__429.bindRoot(new core._GT_());
    const__433.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__434, const__2, "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", const__179, new core._GT__EQ___inliner__5561(), const__327, const__435, const__19, "1.0", 
            const__7, const__436, const__9, const__10, const__11, "clojure/core.clj" }));
    const__433.bindRoot(new core._GT__EQ_());
    const__437.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__438, const__2, "Returns non-nil if nums all have the equivalent\n  value (type-independent), otherwise false", const__179, new core._EQ__EQ___inliner__5564(), const__327, const__439, const__19, "1.0", 
            const__7, const__440, const__9, const__10, const__11, "clojure/core.clj" }));
    const__437.bindRoot(new core._EQ__EQ_());
    const__441






































































      
      .setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__442, const__2, "Returns the greatest of the nums.", const__19, "1.0", const__327, const__386.getRawRoot(), const__179, ((IFn)const__382.getRawRoot()).invoke(const__443), 
            const__7, const__444, const__9, const__10, const__11, "clojure/core.clj" }));
    const__441.bindRoot(new core.max());
    const__445








      
      .setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__446, const__2, "Returns the least of the nums.", const__19, "1.0", const__327, const__386.getRawRoot(), const__179, ((IFn)const__382.getRawRoot()).invoke(const__447), 
            const__7, const__448, const__9, const__10, const__11, "clojure/core.clj" }));
    const__445.bindRoot(new core.min());
    const__449.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__450, const__2, "Returns a number one less than num. Supports arbitrary precision.\n  See also: dec", const__179, new core.dec_SINGLEQUOTE___inliner__5569(), const__19, "1.0", const__7, const__451, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__449.bindRoot(new core.dec_SINGLEQUOTE_());
    const__452.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__453, const__2, "Returns a number one less than num. Does not auto-promote\n  longs, will throw on overflow. See also: dec'", const__179, new core.dec__inliner__5572(), const__19, "1.2", const__7, const__454, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__452.bindRoot(new core.dec());
    const__455.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__456, const__2, "Returns a number one greater than x, an int.\n  Note - uses a primitive operator subject to overflow.", const__179, new core.unchecked_inc_int__inliner__5575(), const__19, "1.0", const__7, const__457, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__455.bindRoot(new core.unchecked_inc_int());
    const__458.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__459, const__2, "Returns a number one greater than x, a long.\n  Note - uses a primitive operator subject to overflow.", const__179, new core.unchecked_inc__inliner__5578(), const__19, "1.0", const__7, const__460, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__458.bindRoot(new core.unchecked_inc());
    const__461.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__462, const__2, "Returns a number one less than x, an int.\n  Note - uses a primitive operator subject to overflow.", const__179, new core.unchecked_dec_int__inliner__5581(), const__19, "1.0", const__7, const__463, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__461.bindRoot(new core.unchecked_dec_int());
    const__464.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__465, const__2, "Returns a number one less than x, a long.\n  Note - uses a primitive operator subject to overflow.", const__179, new core.unchecked_dec__inliner__5584(), const__19, "1.0", const__7, const__466, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__464.bindRoot(new core.unchecked_dec());
    const__467.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__468, const__2, "Returns the negation of x, an int.\n  Note - uses a primitive operator subject to overflow.", const__179, new core.unchecked_negate_int__inliner__5587(), const__19, "1.0", const__7, const__469, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__467.bindRoot(new core.unchecked_negate_int());
    const__470.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__471, const__2, "Returns the negation of x, a long.\n  Note - uses a primitive operator subject to overflow.", const__179, new core.unchecked_negate__inliner__5590(), const__19, "1.0", const__7, const__472, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__470.bindRoot(new core.unchecked_negate());
    const__473.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__474, const__2, "Returns the sum of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", const__179, new core.unchecked_add_int__inliner__5593(), const__19, "1.0", const__7, const__475, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__473.bindRoot(new core.unchecked_add_int());
    const__476.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__477, const__2, "Returns the sum of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", const__179, new core.unchecked_add__inliner__5596(), const__19, "1.0", const__7, const__478, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__476.bindRoot(new core.unchecked_add());
    const__479.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__480, const__2, "Returns the difference of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", const__179, new core.unchecked_subtract_int__inliner__5599(), const__19, "1.0", const__7, const__481, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__479.bindRoot(new core.unchecked_subtract_int());
    const__482.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__483, const__2, "Returns the difference of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", const__179, new core.unchecked_subtract__inliner__5602(), const__19, "1.0", const__7, const__484, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__482.bindRoot(new core.unchecked_subtract());
    const__485.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__486, const__2, "Returns the product of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", const__179, new core.unchecked_multiply_int__inliner__5605(), const__19, "1.0", const__7, const__487, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__485.bindRoot(new core.unchecked_multiply_int());
    const__488.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__489, const__2, "Returns the product of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", const__179, new core.unchecked_multiply__inliner__5608(), const__19, "1.0", const__7, const__490, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__488.bindRoot(new core.unchecked_multiply());
    const__491.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__492, const__2, "Returns the division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.", const__179, new core.unchecked_divide_int__inliner__5611(), const__19, "1.0", const__7, const__493, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__491.bindRoot(new core.unchecked_divide_int());
    const__494.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__495, const__2, "Returns the remainder of division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.", const__179, new core.unchecked_remainder_int__inliner__5614(), const__19, "1.0", const__7, const__496, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__494.bindRoot(new core.unchecked_remainder_int());
    const__497.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__498, const__2, "Returns true if num is greater than zero, else false", const__179, new core.pos_QMARK___inliner__5617(), const__19, "1.0", const__7, const__499, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__497.bindRoot(new core.pos_QMARK_());
    const__500.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__501, const__2, "Returns true if num is less than zero, else false", const__179, new core.neg_QMARK___inliner__5620(), const__19, "1.0", const__7, const__502, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__500.bindRoot(new core.neg_QMARK_());
    const__503.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__504, const__2, "quot[ient] of dividing numerator by denominator.", const__19, "1.0", const__24, Boolean.TRUE, const__179, new core.quot__inliner__5623(), 
            const__7, const__505, const__9, const__10, const__11, "clojure/core.clj" }));
    const__503.bindRoot(new core.quot());
    const__506.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__507, const__2, "remainder of dividing numerator by denominator.", const__19, "1.0", const__24, Boolean.TRUE, const__179, new core.rem__inliner__5626(), 
            const__7, const__508, const__9, const__10, const__11, "clojure/core.clj" }));
    const__506.bindRoot(new core.rem());
    const__509.setMeta((IPersistentMap)const__512);
    const__509.bindRoot(new core.rationalize());
    const__513.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__514, const__2, "Bitwise complement", const__179, new core.bit_not__inliner__5630(), const__19, "1.0", const__7, const__515, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__513.bindRoot(new core.bit_not());
    const__516




































































































































































      
      .setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__517, const__2, "Bitwise and", const__179, ((IFn)const__382.getRawRoot()).invoke(const__518), const__327, const__386.getRawRoot(), const__19, "1.0", 
            const__7, const__519, const__9, const__10, const__11, "clojure/core.clj" }));
    const__516.bindRoot(new core.bit_and());
    const__520







      
      .setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__521, const__2, "Bitwise or", const__179, ((IFn)const__382.getRawRoot()).invoke(const__522), const__327, const__386.getRawRoot(), const__19, "1.0", 
            const__7, const__523, const__9, const__10, const__11, "clojure/core.clj" }));
    const__520.bindRoot(new core.bit_or());
    const__524







      
      .setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__525, const__2, "Bitwise exclusive or", const__179, ((IFn)const__382.getRawRoot()).invoke(const__526), const__327, const__386.getRawRoot(), const__19, "1.0", 
            const__7, const__527, const__9, const__10, const__11, "clojure/core.clj" }));
    const__524.bindRoot(new core.bit_xor());
    const__528







      
      .setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__19, "1.0", const__11, "clojure/core.clj", const__24, Boolean.TRUE, const__327, const__386.getRawRoot(), const__9, const__10, 
            const__7, const__529, const__17, const__530, const__2, "Bitwise and with complement", const__179, ((IFn)const__382.getRawRoot()).invoke(const__531) }));
    const__528.bindRoot(new core.bit_and_not());
    const__532.setMeta((IPersistentMap)const__535);
    const__532.bindRoot(new core.bit_clear());
    const__536.setMeta((IPersistentMap)const__539);
    const__536.bindRoot(new core.bit_set());
    const__540.setMeta((IPersistentMap)const__543);
    const__540.bindRoot(new core.bit_flip());
    const__544.setMeta((IPersistentMap)const__547);
    const__544.bindRoot(new core.bit_test());
    const__548.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__549, const__2, "Bitwise shift left", const__179, new core.bit_shift_left__inliner__5641(), const__19, "1.0", const__7, const__550, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__548.bindRoot(new core.bit_shift_left());
    const__551.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__552, const__2, "Bitwise shift right", const__179, new core.bit_shift_right__inliner__5644(), const__19, "1.0", const__7, const__553, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__551.bindRoot(new core.bit_shift_right());
    const__554.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__555, const__2, "Bitwise shift right, without sign-extension.", const__179, new core.unsigned_bit_shift_right__inliner__5647(), const__19, "1.6", const__7, const__556, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__554.bindRoot(new core.unsigned_bit_shift_right());
    const__557.setMeta((IPersistentMap)const__560);
    const__557.bindRoot(new core.integer_QMARK_());
    const__561.setMeta((IPersistentMap)const__564);
    const__561.bindRoot(new core.even_QMARK_());
    const__565.setMeta((IPersistentMap)const__568);
    const__565.bindRoot(new core.odd_QMARK_());
    const__569.setMeta((IPersistentMap)const__572);
    const__569.bindRoot(new core.int_QMARK_());
    const__573.setMeta((IPersistentMap)const__576);
    const__573.bindRoot(new core.pos_int_QMARK_());
    const__577.setMeta((IPersistentMap)const__580);
    const__577.bindRoot(new core.neg_int_QMARK_());
    const__581.setMeta((IPersistentMap)const__584);
    const__581.bindRoot(new core.nat_int_QMARK_());
    const__585.setMeta((IPersistentMap)const__588);
    const__585.bindRoot(new core.double_QMARK_());
    const__589.setMeta((IPersistentMap)const__592);
    const__589.bindRoot(new core.complement());
    const__593.setMeta((IPersistentMap)const__596);
    const__593.bindRoot(new core.constantly());
    const__597.setMeta((IPersistentMap)const__600);
    const__597.bindRoot(new core.identity());
    const__601.setMeta((IPersistentMap)const__604);
    const__601.bindRoot(new core.peek());
    const__605.setMeta((IPersistentMap)const__608);
    const__605.bindRoot(new core.pop());
    const__609.setMeta((IPersistentMap)const__612);
    const__609.bindRoot(new core.map_entry_QMARK_());
    const__613.setMeta((IPersistentMap)const__616);
    const__613.bindRoot(new core.contains_QMARK_());
    const__617.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__618, const__2, "Returns the value mapped to key, not-found or nil if key not present.", const__179, new core.get__inliner__5680(), const__327, const__619, const__19, "1.0", 
            const__7, const__620, const__9, const__10, const__11, "clojure/core.clj" }));
    const__617.bindRoot(new core.get());
    const__621.setMeta((IPersistentMap)const__624);
    const__621.bindRoot(new core.dissoc());
    const__625.setMeta((IPersistentMap)const__628);
    const__625.bindRoot(new core.disj());
    const__629.setMeta((IPersistentMap)const__632);
    const__629.bindRoot(new core.find());
    const__633.setMeta((IPersistentMap)const__636);
    const__633.bindRoot(new core.select_keys());
    const__637.setMeta((IPersistentMap)const__640);
    const__637.bindRoot(new core.keys());
    const__641.setMeta((IPersistentMap)const__644);
    const__641.bindRoot(new core.vals());
    const__645.setMeta((IPersistentMap)const__648);
    const__645.bindRoot(new core.key());
    const__649.setMeta((IPersistentMap)const__652);
    const__649.bindRoot(new core.val());
    const__653.setMeta((IPersistentMap)const__656);
    const__653.bindRoot(new core.rseq());
    const__657.setMeta((IPersistentMap)const__660);
    const__657.bindRoot(new core.name());
    const__661.setMeta((IPersistentMap)const__664);
    const__661.bindRoot(new core.namespace());
    const__665.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__666, const__2, "Coerce to boolean", const__179, new core.boolean__inliner__5694(), const__19, "1.0", const__7, const__667, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__665.bindRoot(new core.boolean());
    const__668.setMeta((IPersistentMap)const__671);
    const__668.bindRoot(new core.ident_QMARK_());
    const__672.setMeta((IPersistentMap)const__675);
    const__672.bindRoot(new core.simple_ident_QMARK_());
    const__676.setMeta((IPersistentMap)const__679);
    const__676.bindRoot(new core.qualified_ident_QMARK_());
    const__680.setMeta((IPersistentMap)const__683);
    const__680.bindRoot(new core.simple_symbol_QMARK_());
    const__684.setMeta((IPersistentMap)const__687);
    const__684.bindRoot(new core.qualified_symbol_QMARK_());
    const__688.setMeta((IPersistentMap)const__691);
    const__688.bindRoot(new core.simple_keyword_QMARK_());
    const__692.setMeta((IPersistentMap)const__695);
    const__692.bindRoot(new core.qualified_keyword_QMARK_());
    const__696.setMeta((IPersistentMap)const__699);
    const__696.bindRoot(new core.locking());
    ((Var)const__696)



































































































































































































































































































































      
      .setMacro();
    const__700.setMeta((IPersistentMap)const__703);
    const__700.bindRoot(new core._DOT__DOT_());
    ((Var)const__700)










      
      .setMacro();
    const__704.setMeta((IPersistentMap)const__707);
    const__704.bindRoot(new core.__GT_());
    ((Var)const__704)
















      
      .setMacro();
    const__708.setMeta((IPersistentMap)const__711);
    const__708.bindRoot(new core.__GT__GT_());
    ((Var)const__708)














      
      .setMacro();
    const__712.setMeta((IPersistentMap)const__714);
    const__715.setMeta((IPersistentMap)const__718);
    const__715.bindRoot(new core.check_valid_options());
    const__719.setMeta((IPersistentMap)const__721);
    const__722.setMeta((IPersistentMap)const__725);
    const__722.bindRoot(new core.defmulti());
    ((Var)const__722)






























      
      .setMacro();
    const__726.setMeta((IPersistentMap)const__729);
    const__726.bindRoot(new core.defmethod());
    ((Var)const__726)
























































      
      .setMacro();
    const__730.setMeta((IPersistentMap)const__733);
    const__730.bindRoot(new core.remove_all_methods());
    const__734.setMeta((IPersistentMap)const__737);
    const__734.bindRoot(new core.remove_method());
    const__738.setMeta((IPersistentMap)const__741);
    const__738.bindRoot(new core.prefer_method());
    const__742.setMeta((IPersistentMap)const__745);
    const__742.bindRoot(new core.methods());
    const__746.setMeta((IPersistentMap)const__749);
    const__746.bindRoot(new core.get_method());
    const__750.setMeta((IPersistentMap)const__753);
    const__750.bindRoot(new core.prefers());
    const__754.setMeta((IPersistentMap)const__757);
    const__754.bindRoot(new core.assert_args());
    ((Var)const__754)















































      
      .setMacro();
    const__758.setMeta((IPersistentMap)const__761);
    const__758.bindRoot(new core.if_let());
    ((Var)const__758)







      
      .setMacro();
    const__762.setMeta((IPersistentMap)const__765);
    const__762.bindRoot(new core.when_let());
    ((Var)const__762)


















      
      .setMacro();
    const__766.setMeta((IPersistentMap)const__769);
    const__766.bindRoot(new core.if_some());
    ((Var)const__766)













      
      .setMacro();
    const__770.setMeta((IPersistentMap)const__773);
    const__770.bindRoot(new core.when_some());
    ((Var)const__770)


















      
      .setMacro();
    const__774.setMeta((IPersistentMap)const__777);
    const__774.bindRoot(new core.push_thread_bindings());
    const__778.setMeta((IPersistentMap)const__781);
    const__778.bindRoot(new core.pop_thread_bindings());
    const__782.setMeta((IPersistentMap)const__785);
    const__782.bindRoot(new core.get_thread_bindings());
    const__786.setMeta((IPersistentMap)const__789);
    const__786.bindRoot(new core.binding());
    ((Var)const__786)

















































      
      .setMacro();
    const__790.setMeta((IPersistentMap)const__793);
    const__790.bindRoot(new core.with_bindings_STAR_());
    const__794.setMeta((IPersistentMap)const__797);
    const__794.bindRoot(new core.with_bindings());
    ((Var)const__794)





































      
      .setMacro();
    const__798.setMeta((IPersistentMap)const__801);
    const__798.bindRoot(new core.bound_fn_STAR_());
    const__802.setMeta((IPersistentMap)const__805);
    const__802.bindRoot(new core.bound_fn());
    ((Var)const__802)


















      
      .setMacro();
    const__806.setMeta((IPersistentMap)const__809);
    const__806.bindRoot(new core.find_var());
    const__810.setMeta((IPersistentMap)const__813);
    const__810.bindRoot(new core.binding_conveyor_fn());
    const__814.setMeta((IPersistentMap)const__817);
    const__814.bindRoot(new core.setup_reference());
    const__818.setMeta((IPersistentMap)const__821);
    const__818.bindRoot(new core.agent());
    const__822.setMeta((IPersistentMap)const__825);
    const__822.bindRoot(new core.set_agent_send_executor_BANG_());
    const__826.setMeta((IPersistentMap)const__829);
    const__826.bindRoot(new core.set_agent_send_off_executor_BANG_());
    const__830.setMeta((IPersistentMap)const__833);
    const__830.bindRoot(new core.send_via());
    const__834.setMeta((IPersistentMap)const__837);
    const__834.bindRoot(new core.send());
    const__838.setMeta((IPersistentMap)const__841);
    const__838.bindRoot(new core.send_off());
    const__842.setMeta((IPersistentMap)const__845);
    const__842.bindRoot(new core.release_pending_sends());
    const__846.setMeta((IPersistentMap)const__849);
    const__846.bindRoot(new core.add_watch());
    const__850.setMeta((IPersistentMap)const__853);
    const__850.bindRoot(new core.remove_watch());
    const__854.setMeta((IPersistentMap)const__857);
    const__854.bindRoot(new core.agent_error());
    const__858.setMeta((IPersistentMap)const__861);
    const__858.bindRoot(new core.restart_agent());
    const__862.setMeta((IPersistentMap)const__865);
    const__862.bindRoot(new core.set_error_handler_BANG_());
    const__866.setMeta((IPersistentMap)const__869);
    const__866.bindRoot(new core.error_handler());
    const__870.setMeta((IPersistentMap)const__873);
    const__870.bindRoot(new core.set_error_mode_BANG_());
    const__874.setMeta((IPersistentMap)const__877);
    const__874.bindRoot(new core.error_mode());
    const__878.setMeta((IPersistentMap)const__882);
    const__878.bindRoot(new core.agent_errors());
    const__883.setMeta((IPersistentMap)const__886);
    const__883.bindRoot(new core.clear_agent_errors());
    const__887.setMeta((IPersistentMap)const__890);
    const__887.bindRoot(new core.shutdown_agents());
    const__891.setMeta((IPersistentMap)const__894);
    const__891.bindRoot(new core.ref());
    const__895.setMeta((IPersistentMap)const__898);
    const__895.bindRoot(new core.deref_future());
    const__899.setMeta((IPersistentMap)const__902);
    const__899.bindRoot(new core.deref());
    const__903.setMeta((IPersistentMap)const__906);
    const__903.bindRoot(new core.atom());
    const__907.setMeta((IPersistentMap)const__910);
    const__907.bindRoot(new core.swap_BANG_());
    const__911.setMeta((IPersistentMap)const__914);
    const__911.bindRoot(new core.swap_vals_BANG_());
    const__915.setMeta((IPersistentMap)const__918);
    const__915.bindRoot(new core.compare_and_set_BANG_());
    const__919.setMeta((IPersistentMap)const__922);
    const__919.bindRoot(new core.reset_BANG_());
    const__923.setMeta((IPersistentMap)const__926);
    const__923.bindRoot(new core.reset_vals_BANG_());
    const__927.setMeta((IPersistentMap)const__930);
    const__927.bindRoot(new core.set_validator_BANG_());
    const__931.setMeta((IPersistentMap)const__934);
    const__931.bindRoot(new core.get_validator());
    const__935.setMeta((IPersistentMap)const__938);
    const__935.bindRoot(new core.alter_meta_BANG_());
    const__939.setMeta((IPersistentMap)const__942);
    const__939.bindRoot(new core.reset_meta_BANG_());
    const__943.setMeta((IPersistentMap)const__946);
    const__943.bindRoot(new core.commute());
    const__947.setMeta((IPersistentMap)const__950);
    const__947.bindRoot(new core.alter());
    const__951.setMeta((IPersistentMap)const__954);
    const__951.bindRoot(new core.ref_set());
    const__955.setMeta((IPersistentMap)const__958);
    const__955.bindRoot(new core.ref_history_count());
    const__959.setMeta((IPersistentMap)const__962);
    const__959.bindRoot(new core.ref_min_history());
    const__963.setMeta((IPersistentMap)const__966);
    const__963.bindRoot(new core.ref_max_history());
    const__967.setMeta((IPersistentMap)const__970);
    const__967.bindRoot(new core.ensure());
    const__971.setMeta((IPersistentMap)const__974);
    const__971.bindRoot(new core.sync());
    ((Var)const__971)










































































































































































































































































































































































































































































































      
      .setMacro();
    const__975.setMeta((IPersistentMap)const__978);
    const__975.bindRoot(new core.io_BANG_());
    ((Var)const__975)












      
      .setMacro();
    const__979.setMeta((IPersistentMap)const__983);
    const__979.bindRoot(new core.volatile_BANG_());
    const__984.setMeta((IPersistentMap)const__987);
    const__984.bindRoot(new core.vreset_BANG_());
    const__988.setMeta((IPersistentMap)const__991);
    const__988.bindRoot(new core.vswap_BANG_());
    ((Var)const__988)

























      
      .setMacro();
    const__992.setMeta((IPersistentMap)const__995);
    const__992.bindRoot(new core.volatile_QMARK_());
    const__996.setMeta((IPersistentMap)const__999);
    const__996.bindRoot(new core.comp());
    const__1000.setMeta((IPersistentMap)const__1003);
    const__1000.bindRoot(new core.juxt());
    const__1004.setMeta((IPersistentMap)const__1007);
    const__1004.bindRoot(new core.partial());
    const__1008.setMeta((IPersistentMap)const__1011);
    const__1008.bindRoot(new core.sequence());
    const__1012.setMeta((IPersistentMap)const__1015);
    const__1012.bindRoot(new core.every_QMARK_());
    const__1016.setMeta((IPersistentMap)const__1019);
    const__1016





















































































































































      
      .bindRoot(((IFn)const__996.getRawRoot()).invoke(const__204.getRawRoot(), const__1012.getRawRoot()));
    const__1020.setMeta((IPersistentMap)const__1023);
    const__1020.bindRoot(new core.some());
    const__1024.setMeta((IPersistentMap)const__1027);
    const__1024

















      
      .bindRoot(((IFn)const__996.getRawRoot()).invoke(const__204.getRawRoot(), const__1020.getRawRoot()));
    const__1028.setMeta((IPersistentMap)const__1031);
    const__1028.bindRoot(new core.dotimes());
    ((Var)const__1028)

      
      .setMacro();
    const__712.setMeta((IPersistentMap)const__1034);
    const__712.bindRoot(new core.map());
    const__1035.setMeta((IPersistentMap)const__1038);
    const__1035.bindRoot(new core.declare());
    ((Var)const__1035)






























































      
      .setMacro();
    const__1039.setMeta((IPersistentMap)const__1042);
    const__1043.setMeta((IPersistentMap)const__1046);
    const__1043.bindRoot(new core.mapcat());
    const__1047.setMeta((IPersistentMap)const__1050);
    const__1047.bindRoot(new core.filter());
    const__1051.setMeta((IPersistentMap)const__1054);
    const__1051.bindRoot(new core.remove());
    const__1055.setMeta((IPersistentMap)const__1058);
    const__1055.bindRoot(new core.reduced());
    const__1059.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1060, const__2, "Returns true if x is the result of a call to reduced", const__179, new core.reduced_QMARK___inliner__5900(), const__327, const__1062, const__19, "1.5", 
            const__7, const__1063, const__9, const__10, const__11, "clojure/core.clj" }));
    const__1059.bindRoot(new core.reduced_QMARK_());
    const__1064.setMeta((IPersistentMap)const__1067);
    const__1064.bindRoot(new core.ensure_reduced());
    const__1068.setMeta((IPersistentMap)const__1071);
    const__1068.bindRoot(new core.unreduced());
    const__1072.setMeta((IPersistentMap)const__1075);
    const__1072.bindRoot(new core.take());
    const__1076.setMeta((IPersistentMap)const__1079);
    const__1076.bindRoot(new core.take_while());
    const__1080.setMeta((IPersistentMap)const__1083);
    const__1080.bindRoot(new core.drop());
    const__1084.setMeta((IPersistentMap)const__1087);
    const__1084.bindRoot(new core.drop_last());
    const__1088.setMeta((IPersistentMap)const__1091);
    const__1088.bindRoot(new core.take_last());
    const__1092.setMeta((IPersistentMap)const__1095);
    const__1092.bindRoot(new core.drop_while());
    const__1096.setMeta((IPersistentMap)const__1099);
    const__1096.bindRoot(new core.cycle());
    const__1100.setMeta((IPersistentMap)const__1103);
    const__1100.bindRoot(new core.split_at());
    const__1104.setMeta((IPersistentMap)const__1107);
    const__1104.bindRoot(new core.split_with());
    const__1108.setMeta((IPersistentMap)const__1111);
    const__1108.bindRoot(new core.repeat());
    const__1112.setMeta((IPersistentMap)const__1115);
    const__1112.bindRoot(new core.replicate());
    const__1116.setMeta((IPersistentMap)const__1119);
    const__1116.bindRoot(new core.iterate());
    const__1120.setMeta((IPersistentMap)const__1123);
    const__1120.bindRoot(new core.range());
    const__1124.setMeta((IPersistentMap)const__1127);
    const__1124.bindRoot(new core.merge());
    const__1128.setMeta((IPersistentMap)const__1131);
    const__1128.bindRoot(new core.merge_with());
    const__1132.setMeta((IPersistentMap)const__1135);
    const__1132.bindRoot(new core.zipmap());
    const__1136.setMeta((IPersistentMap)const__1139);
    const__1136.bindRoot(new core.line_seq());
    const__1140.setMeta((IPersistentMap)const__1143);
    const__1140.bindRoot(new core.comparator());
    const__1144.setMeta((IPersistentMap)const__1147);
    const__1144.bindRoot(new core.sort());
    const__1148.setMeta((IPersistentMap)const__1151);
    const__1148.bindRoot(new core.sort_by());
    const__1152.setMeta((IPersistentMap)const__1155);
    const__1152.bindRoot(new core.dorun());
    const__1156.setMeta((IPersistentMap)const__1159);
    const__1156.bindRoot(new core.doall());
    const__1160.setMeta((IPersistentMap)const__1163);
    const__1160.bindRoot(new core.nthnext());
    const__1164.setMeta((IPersistentMap)const__1167);
    const__1164.bindRoot(new core.nthrest());
    const__1168.setMeta((IPersistentMap)const__1171);
    const__1168.bindRoot(new core.partition());
    const__1172.setMeta((IPersistentMap)const__1175);
    const__1172.bindRoot(new core.eval());
    const__1176.setMeta((IPersistentMap)const__1179);
    const__1176.bindRoot(new core.doseq());
    ((Var)const__1176)






















































































































































































































































































































































































































































      
      .setMacro();
    const__1180.setMeta((IPersistentMap)const__1183);
    const__1180.bindRoot(new core.await());
    const__1184.setMeta((IPersistentMap)const__1187);
    const__1184.bindRoot(new core.await1());
    const__1188.setMeta((IPersistentMap)const__1191);
    const__1188.bindRoot(new core.await_for());
    const__1028.setMeta((IPersistentMap)const__1194);
    const__1028.bindRoot(new core.dotimes());
    ((Var)const__1028)































































































      
      .setMacro();
    const__1195.setMeta((IPersistentMap)const__1198);
    const__1195.bindRoot(new core.transient());
    const__1199.setMeta((IPersistentMap)const__1202);
    const__1199.bindRoot(new core.persistent_BANG_());
    const__1203.setMeta((IPersistentMap)const__1206);
    const__1203.bindRoot(new core.conj_BANG_());
    const__1207.setMeta((IPersistentMap)const__1210);
    const__1207.bindRoot(new core.assoc_BANG_());
    const__1211.setMeta((IPersistentMap)const__1214);
    const__1211.bindRoot(new core.dissoc_BANG_());
    const__1215.setMeta((IPersistentMap)const__1218);
    const__1215.bindRoot(new core.pop_BANG_());
    const__1219.setMeta((IPersistentMap)const__1222);
    const__1219.bindRoot(new core.disj_BANG_());
    const__1223.setMeta((IPersistentMap)const__1226);
    const__1223.bindRoot(new core.into1());
    const__1227.setMeta((IPersistentMap)const__1230);
    const__1227.bindRoot(new core.import());
    ((Var)const__1227)














































































































      
      .setMacro();
    const__1231.setMeta((IPersistentMap)const__1234);
    const__1231.bindRoot(new core.into_array());
    const__1235.setMeta((IPersistentMap)const__1238);
    const__1235.bindRoot(new core.array());
    const__1239.setMeta((IPersistentMap)const__1242);
    const__1239.bindRoot(new core.class());
    const__1243.setMeta((IPersistentMap)const__1246);
    const__1243.bindRoot(new core.type());
    const__1247.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1248, const__2, "Coerce to Number", const__43, const__1249, const__179, new core.num__inliner__6049(), const__19, "1.0", 
            const__7, const__1250, const__9, const__10, const__11, "clojure/core.clj" }));
    const__1247.bindRoot(new core.num());
    const__1251.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1252, const__2, "Coerce to long", const__179, new core.long__inliner__6052(), const__19, "1.0", const__7, const__1253, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__1251.bindRoot(new core.long());
    const__1254.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1255, const__2, "Coerce to float", const__179, new core.float__inliner__6055(), const__19, "1.0", const__7, const__1256, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__1254.bindRoot(new core.float());
    const__1257.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1258, const__2, "Coerce to double", const__179, new core.double__inliner__6058(), const__19, "1.0", const__7, const__1259, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__1257.bindRoot(new core.double());
    const__1260.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1261, const__2, "Coerce to short", const__179, new core.short__inliner__6061(), const__19, "1.0", const__7, const__1262, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__1260.bindRoot(new core.short());
    const__1263.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1264, const__2, "Coerce to byte", const__179, new core.byte__inliner__6064(), const__19, "1.0", const__7, const__1265, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__1263.bindRoot(new core.byte());
    const__1266.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1267, const__2, "Coerce to char", const__179, new core.char__inliner__6067(), const__19, "1.1", const__7, const__1268, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__1266.bindRoot(new core.char());
    const__1269.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1270, const__2, "Coerce to byte. Subject to rounding or truncation.", const__179, new core.unchecked_byte__inliner__6070(), const__19, "1.3", const__7, const__1271, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__1269.bindRoot(new core.unchecked_byte());
    const__1272.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1273, const__2, "Coerce to short. Subject to rounding or truncation.", const__179, new core.unchecked_short__inliner__6073(), const__19, "1.3", const__7, const__1274, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__1272.bindRoot(new core.unchecked_short());
    const__1275.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1276, const__2, "Coerce to char. Subject to rounding or truncation.", const__179, new core.unchecked_char__inliner__6076(), const__19, "1.3", const__7, const__1277, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__1275.bindRoot(new core.unchecked_char());
    const__1278.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1279, const__2, "Coerce to int. Subject to rounding or truncation.", const__179, new core.unchecked_int__inliner__6079(), const__19, "1.3", const__7, const__1280, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__1278.bindRoot(new core.unchecked_int());
    const__1281.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1282, const__2, "Coerce to long. Subject to rounding or truncation.", const__179, new core.unchecked_long__inliner__6082(), const__19, "1.3", const__7, const__1283, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__1281.bindRoot(new core.unchecked_long());
    const__1284.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1285, const__2, "Coerce to float. Subject to rounding.", const__179, new core.unchecked_float__inliner__6085(), const__19, "1.3", const__7, const__1286, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__1284.bindRoot(new core.unchecked_float());
    const__1287.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1288, const__2, "Coerce to double. Subject to rounding.", const__179, new core.unchecked_double__inliner__6088(), const__19, "1.3", const__7, const__1289, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__1287.bindRoot(new core.unchecked_double());
    const__1290.setMeta((IPersistentMap)const__1293);
    const__1290.bindRoot(new core.number_QMARK_());
    const__1294.setMeta((IPersistentMap)const__1297);
    const__1294.bindRoot(new core.mod());
    const__1298.setMeta((IPersistentMap)const__1301);
    const__1298.bindRoot(new core.ratio_QMARK_());
    const__1302.setMeta((IPersistentMap)const__1306);
    const__1302.bindRoot(new core.numerator());
    const__1307.setMeta((IPersistentMap)const__1310);
    const__1307.bindRoot(new core.denominator());
    const__1311.setMeta((IPersistentMap)const__1314);
    const__1311.bindRoot(new core.decimal_QMARK_());
    const__1315.setMeta((IPersistentMap)const__1318);
    const__1315.bindRoot(new core.float_QMARK_());
    const__1319.setMeta((IPersistentMap)const__1322);
    const__1319.bindRoot(new core.rational_QMARK_());
    const__1323.setMeta((IPersistentMap)const__1327);
    const__1323.bindRoot(new core.bigint());
    const__1328.setMeta((IPersistentMap)const__1331);
    const__1328.bindRoot(new core.biginteger());
    const__1332.setMeta((IPersistentMap)const__1336);
    const__1332.bindRoot(new core.bigdec());
    const__1337.setDynamic(true).setMeta((IPersistentMap)const__1339);
    const__1337.setDynamic(true).bindRoot(Boolean.FALSE);
    const__1340.setMeta((IPersistentMap)const__1343);
    const__1340.bindRoot(new core.pr_on());
    const__1344.setDynamic(true).setMeta((IPersistentMap)const__1347);
    const__1344.setDynamic(true).bindRoot(new core.pr());
    const__1348.setMeta((IPersistentMap)const__1350);
    const__1348



























      
      .bindRoot(System.getProperty((String)"line.separator"));
    const__1351.setMeta((IPersistentMap)const__1354);
    const__1351.bindRoot(new core.newline());
    const__1355.setMeta((IPersistentMap)const__1358);
    const__1355.bindRoot(new core.flush());
    const__1359.setMeta((IPersistentMap)const__1362);
    const__1359.bindRoot(new core.prn());
    const__1363.setMeta((IPersistentMap)const__1366);
    const__1363.bindRoot(new core.print());
    const__1367.setMeta((IPersistentMap)const__1370);
    const__1367.bindRoot(new core.println());
    const__1371.setMeta((IPersistentMap)const__1374);
    const__1371.bindRoot(new core.read());
    const__1375.setMeta((IPersistentMap)const__1378);
    const__1375.bindRoot(new core.read_PLUS_string());
    const__1379.setMeta((IPersistentMap)const__1382);
    const__1379.bindRoot(new core.read_line());
    const__1383.setMeta((IPersistentMap)const__1386);
    const__1383.bindRoot(new core.read_string());
    const__1387.setMeta((IPersistentMap)const__1390);
    const__1387.bindRoot(new core.subvec());
    const__1391.setMeta((IPersistentMap)const__1394);
    const__1391.bindRoot(new core.with_open());
    ((Var)const__1391)






































































































































      
      .setMacro();
    const__1395.setMeta((IPersistentMap)const__1398);
    const__1395.bindRoot(new core.doto());
    ((Var)const__1395)



















      
      .setMacro();
    const__1399.setMeta((IPersistentMap)const__1402);
    const__1399.bindRoot(new core.memfn());
    ((Var)const__1399)

















      
      .setMacro();
    const__1403.setMeta((IPersistentMap)const__1406);
    const__1403.bindRoot(new core.time());
    ((Var)const__1403)











      
      .setMacro();
    const__1407.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1408, const__2, "Returns the length of the Java array. Works on arrays of all\n  types.", const__179, new core.alength__inliner__6139(), const__19, "1.0", const__7, const__1409, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__1407.bindRoot(new core.alength());
    const__1410.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1411, const__2, "Returns a clone of the Java array. Works on arrays of known\n  types.", const__179, new core.aclone__inliner__6142(), const__19, "1.0", const__7, const__1412, 
            const__9, const__10, const__11, "clojure/core.clj" }));
    const__1410.bindRoot(new core.aclone());
    const__1413.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1414, const__2, "Returns the value at the index/indices. Works on Java arrays of all\n  types.", const__179, new core.aget__inliner__6145(), const__327, const__1415, const__19, "1.0", 
            const__7, const__1416, const__9, const__10, const__11, "clojure/core.clj" }));
    const__1413.bindRoot(new core.aget());
    const__1417.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1418, const__2, "Sets the value at the index/indices. Works on Java arrays of\n  reference types. Returns val.", const__179, new core.aset__inliner__6148(), const__327, const__1419, const__19, "1.0", 
            const__7, const__1420, const__9, const__10, const__11, "clojure/core.clj" }));
    const__1417.bindRoot(new core.aset());
    const__1421.setMeta((IPersistentMap)const__1424);
    const__1421.bindRoot(new core.def_aset());
    ((Var)const__1421)

















































      
      .setMacro();
    const__1425.setMeta((IPersistentMap)const__1428);
    const__1425.bindRoot(new core.aset_int());
    const__1429.setMeta((IPersistentMap)const__1432);
    const__1429.bindRoot(new core.aset_long());
    const__1433.setMeta((IPersistentMap)const__1436);
    const__1433.bindRoot(new core.aset_boolean());
    const__1437.setMeta((IPersistentMap)const__1440);
    const__1437.bindRoot(new core.aset_float());
    const__1441.setMeta((IPersistentMap)const__1444);
    const__1441.bindRoot(new core.aset_double());
    const__1445.setMeta((IPersistentMap)const__1448);
    const__1445.bindRoot(new core.aset_short());
    const__1449.setMeta((IPersistentMap)const__1452);
    const__1449.bindRoot(new core.aset_byte());
    const__1453.setMeta((IPersistentMap)const__1456);
    const__1453.bindRoot(new core.aset_char());
    const__1457.setMeta((IPersistentMap)const__1460);
    const__1457.bindRoot(new core.make_array());
    const__1461.setMeta((IPersistentMap)const__1464);
    const__1461.bindRoot(new core.to_array_2d());
    const__1465.setMeta((IPersistentMap)const__1468);
    const__1465.bindRoot(new core.macroexpand_1());
    const__1469.setMeta((IPersistentMap)const__1472);
    const__1469.bindRoot(new core.macroexpand());
    const__1473.setMeta((IPersistentMap)const__1476);
    const__1473.bindRoot(new core.create_struct());
    const__1477.setMeta((IPersistentMap)const__1480);
    const__1477.bindRoot(new core.defstruct());
    ((Var)const__1477)












































































































      
      .setMacro();
    const__1481.setMeta((IPersistentMap)const__1484);
    const__1481.bindRoot(new core.struct_map());
    const__1485.setMeta((IPersistentMap)const__1488);
    const__1485.bindRoot(new core.struct());
    const__1489.setMeta((IPersistentMap)const__1492);
    const__1489.bindRoot(new core.accessor());
    const__1493.setMeta((IPersistentMap)const__1496);
    const__1493.bindRoot(new core.load_reader());
    const__1497.setMeta((IPersistentMap)const__1500);
    const__1497.bindRoot(new core.load_string());
    const__1501.setMeta((IPersistentMap)const__1504);
    const__1501.bindRoot(new core.set_QMARK_());
    const__1505.setMeta((IPersistentMap)const__1508);
    const__1505.bindRoot(new core.set());
    const__1509.setMeta((IPersistentMap)const__1512);
    const__1509.bindRoot(new core.filter_key());
    const__1513.setMeta((IPersistentMap)const__1516);
    const__1513.bindRoot(new core.find_ns());
    const__1517.setMeta((IPersistentMap)const__1520);
    const__1517.bindRoot(new core.create_ns());
    const__1521.setMeta((IPersistentMap)const__1524);
    const__1521.bindRoot(new core.remove_ns());
    const__1525.setMeta((IPersistentMap)const__1528);
    const__1525.bindRoot(new core.all_ns());
    const__1529.setMeta((IPersistentMap)const__1532);
    const__1529.bindRoot(new core.the_ns());
    const__1533.setMeta((IPersistentMap)const__1536);
    const__1533.bindRoot(new core.ns_name());
    const__1537.setMeta((IPersistentMap)const__1540);
    const__1537.bindRoot(new core.ns_map());
    const__1541.setMeta((IPersistentMap)const__1544);
    const__1541.bindRoot(new core.ns_unmap());
    const__1545.setMeta((IPersistentMap)const__1548);
    const__1545.bindRoot(new core.ns_publics());
    const__1549.setMeta((IPersistentMap)const__1552);
    const__1549.bindRoot(new core.ns_imports());
    const__1553.setMeta((IPersistentMap)const__1556);
    const__1553.bindRoot(new core.ns_interns());
    const__1557.setMeta((IPersistentMap)const__1560);
    const__1557.bindRoot(new core.refer());
    const__1561.setMeta((IPersistentMap)const__1564);
    const__1561.bindRoot(new core.ns_refers());
    const__1565.setMeta((IPersistentMap)const__1568);
    const__1565.bindRoot(new core.alias());
    const__1569.setMeta((IPersistentMap)const__1572);
    const__1569.bindRoot(new core.ns_aliases());
    const__1573.setMeta((IPersistentMap)const__1576);
    const__1573.bindRoot(new core.ns_unalias());
    const__1577.setMeta((IPersistentMap)const__1580);
    const__1577.bindRoot(new core.take_nth());
    const__1581.setMeta((IPersistentMap)const__1584);
    const__1581.bindRoot(new core.interleave());
    const__1585.setMeta((IPersistentMap)const__1588);
    const__1585.bindRoot(new core.var_get());
    const__1589.setMeta((IPersistentMap)const__1592);
    const__1589.bindRoot(new core.var_set());
    const__1593.setMeta((IPersistentMap)const__1596);
    const__1593.bindRoot(new core.with_local_vars());
    ((Var)const__1593)





































































































































































































































































































      
      .setMacro();
    const__1597.setMeta((IPersistentMap)const__1600);
    const__1597.bindRoot(new core.ns_resolve());
    const__1601.setMeta((IPersistentMap)const__1604);
    const__1601.bindRoot(new core.resolve());
    const__1605.setMeta((IPersistentMap)const__1608);
    const__1605.bindRoot(new core.array_map());
    const__1609.setMeta((IPersistentMap)const__1612);
    const__1609.bindRoot(new core.destructure());
    const__27.setMeta((IPersistentMap)const__1618);
    const__27.bindRoot(new core.let());
    ((Var)const__27)











































































































































      
      .setMacro();
    const__1619.setMeta((IPersistentMap)const__1622);
    const__1619.bindRoot(new core.maybe_destructured());
    const__34.setMeta((IPersistentMap)const__1626);
    const__34.bindRoot(new core.fn());
    ((Var)const__34)






























      
      .setMacro();
    const__31.setMeta((IPersistentMap)const__1630);
    const__31.bindRoot(new core.loop());
    ((Var)const__31)




























































      
      .setMacro();
    const__1631.setMeta((IPersistentMap)const__1634);
    const__1631.bindRoot(new core.when_first());
    ((Var)const__1631)























      
      .setMacro();
    const__1635.setMeta((IPersistentMap)const__1638);
    const__1635.bindRoot(new core.lazy_cat());
    ((Var)const__1635)












      
      .setMacro();
    const__1639.setMeta((IPersistentMap)const__1642);
    const__1639.bindRoot(new core.for());
    ((Var)const__1639)








      
      .setMacro();
    const__1643.setMeta((IPersistentMap)const__1646);
    const__1643.bindRoot(new core.comment());
    ((Var)const__1643)





















































































      
      .setMacro();
    const__1647.setMeta((IPersistentMap)const__1650);
    const__1647.bindRoot(new core.with_out_str());
    ((Var)const__1647)



      
      .setMacro();
    const__1651.setMeta((IPersistentMap)const__1654);
    const__1651.bindRoot(new core.with_in_str());
    ((Var)const__1651)









      
      .setMacro();
    const__1655.setMeta((IPersistentMap)const__1658);
    const__1655.bindRoot(new core.pr_str());
    const__1659.setMeta((IPersistentMap)const__1662);
    const__1659.bindRoot(new core.prn_str());
    const__1663.setMeta((IPersistentMap)const__1666);
    const__1663.bindRoot(new core.print_str());
    const__1667.setMeta((IPersistentMap)const__1670);
    const__1667.bindRoot(new core.println_str());
    const__1671.setMeta((IPersistentMap)const__1674);
    const__1671.bindRoot(new core.elide_top_frames());
    const__1675.setMeta((IPersistentMap)const__1678);
    const__1675.bindRoot(new core.ex_info());
    const__1679.setMeta((IPersistentMap)const__1682);
    const__1679.bindRoot(new core.ex_data());
    const__1683.setMeta((IPersistentMap)const__1686);
    const__1683.bindRoot(new core.ex_message());
    const__1687.setMeta((IPersistentMap)const__1690);
    const__1687.bindRoot(new core.ex_cause());
    const__1691.setMeta((IPersistentMap)const__1694);
    const__1691.bindRoot(new core.assert());
    ((Var)const__1691)























































































      
      .setMacro();
    const__1695.setMeta((IPersistentMap)const__1698);
    const__1695.bindRoot(new core.test());
    const__1699.setMeta((IPersistentMap)const__1703);
    const__1699.bindRoot(new core.re_pattern());
    const__1704.setMeta((IPersistentMap)const__1708);
    const__1704.bindRoot(new core.re_matcher());
    const__1709.setMeta((IPersistentMap)const__1712);
    const__1709.bindRoot(new core.re_groups());
    const__1713.setMeta((IPersistentMap)const__1716);
    const__1713.bindRoot(new core.re_seq());
    const__1717.setMeta((IPersistentMap)const__1720);
    const__1717.bindRoot(new core.re_matches());
    const__1721.setMeta((IPersistentMap)const__1724);
    const__1721.bindRoot(new core.re_find());
    const__1725.setMeta((IPersistentMap)const__1728);
    const__1725.bindRoot(new core.rand());
    const__1729.setMeta((IPersistentMap)const__1732);
    const__1729.bindRoot(new core.rand_int());
    const__1733.setMeta((IPersistentMap)const__1736);
    const__1733.bindRoot(new core.defn_());
    ((Var)const__1733)











































































































      
      .setMacro();
    const__1737.setMeta((IPersistentMap)const__1740);
    const__1737.bindRoot(new core.tree_seq());
    const__1741.setMeta((IPersistentMap)const__1744);
    const__1741.bindRoot(new core.file_seq());
    const__1745.setMeta((IPersistentMap)const__1748);
    const__1745.bindRoot(new core.xml_seq());
    const__1749.setMeta((IPersistentMap)const__1752);
    const__1749.bindRoot(new core.special_symbol_QMARK_());
    const__1753.setMeta((IPersistentMap)const__1756);
    const__1753.bindRoot(new core.var_QMARK_());
    const__1757.setMeta((IPersistentMap)const__1760);
    const__1757.bindRoot(new core.subs());
    const__1761.setMeta((IPersistentMap)const__1764);
    const__1761.bindRoot(new core.max_key());
    const__1765.setMeta((IPersistentMap)const__1768);
    const__1765.bindRoot(new core.min_key());
    const__1769.setMeta((IPersistentMap)const__1772);
    const__1769.bindRoot(new core.distinct());
    const__1773.setMeta((IPersistentMap)const__1776);
    const__1773.bindRoot(new core.replace());
    const__1777.setMeta((IPersistentMap)const__1780);
    const__1777.bindRoot(new core.dosync());
    ((Var)const__1777)





















































































































































      
      .setMacro();
    const__1781.setMeta((IPersistentMap)const__1784);
    const__1781.bindRoot(new core.with_precision());
    ((Var)const__1781)








      
      .setMacro();
    const__1785.setMeta((IPersistentMap)const__1788);
    const__1785.bindRoot(new core.mk_bound_fn());
    const__1789.setMeta((IPersistentMap)const__1792);
    const__1789.bindRoot(new core.subseq());
    const__1793.setMeta((IPersistentMap)const__1796);
    const__1793.bindRoot(new core.rsubseq());
    const__1797.setMeta((IPersistentMap)const__1800);
    const__1797.bindRoot(new core.repeatedly());
    const__1801.setMeta((IPersistentMap)const__1804);
    const__1801.bindRoot(new core.add_classpath());
    const__1805.setMeta((IPersistentMap)const__1808);
    const__1805.bindRoot(new core.hash());
    const__1809.setMeta((IPersistentMap)const__1812);
    const__1809.bindRoot(new core.mix_collection_hash());
    const__1813.setMeta((IPersistentMap)const__1816);
    const__1813.bindRoot(new core.hash_ordered_coll());
    const__1817.setMeta((IPersistentMap)const__1820);
    const__1817.bindRoot(new core.hash_unordered_coll());
    const__1821.setMeta((IPersistentMap)const__1824);
    const__1821.bindRoot(new core.interpose());
    const__1825.setMeta((IPersistentMap)const__1828);
    const__1825.bindRoot(new core.definline());
    ((Var)const__1825)













































































































































      
      .setMacro();
    const__1829.setMeta((IPersistentMap)const__1832);
    const__1829.bindRoot(new core.empty());
    const__1833.setMeta((IPersistentMap)const__1836);
    const__1833.bindRoot(new core.amap());
    ((Var)const__1833)


















      
      .setMacro();
    const__1837.setMeta((IPersistentMap)const__1840);
    const__1837.bindRoot(new core.areduce());
    ((Var)const__1837)














      
      .setMacro();
    const__1841.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1842, const__2, "Creates an array of floats", const__179, new core.float_array__inliner__6490(), const__327, const__1843, const__19, "1.0", 
            const__7, const__1844, const__9, const__10, const__11, "clojure/core.clj" }));
    const__1841.bindRoot(new core.float_array());
    const__1845.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1846, const__2, "Creates an array of booleans", const__179, new core.boolean_array__inliner__6493(), const__327, const__1847, const__19, "1.1", 
            const__7, const__1848, const__9, const__10, const__11, "clojure/core.clj" }));
    const__1845.bindRoot(new core.boolean_array());
    const__1849.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1850, const__2, "Creates an array of bytes", const__179, new core.byte_array__inliner__6496(), const__327, const__1851, const__19, "1.1", 
            const__7, const__1852, const__9, const__10, const__11, "clojure/core.clj" }));
    const__1849.bindRoot(new core.byte_array());
    const__1853.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1854, const__2, "Creates an array of chars", const__179, new core.char_array__inliner__6499(), const__327, const__1855, const__19, "1.1", 
            const__7, const__1856, const__9, const__10, const__11, "clojure/core.clj" }));
    const__1853.bindRoot(new core.char_array());
    const__1857.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1858, const__2, "Creates an array of shorts", const__179, new core.short_array__inliner__6502(), const__327, const__1859, const__19, "1.1", 
            const__7, const__1860, const__9, const__10, const__11, "clojure/core.clj" }));
    const__1857.bindRoot(new core.short_array());
    const__1861.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1862, const__2, "Creates an array of doubles", const__179, new core.double_array__inliner__6505(), const__327, const__1863, const__19, "1.0", 
            const__7, const__1864, const__9, const__10, const__11, "clojure/core.clj" }));
    const__1861.bindRoot(new core.double_array());
    const__1865.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1866, const__2, "Creates an array of objects", const__179, new core.object_array__inliner__6508(), const__327, const__1867, const__19, "1.2", 
            const__7, const__1868, const__9, const__10, const__11, "clojure/core.clj" }));
    const__1865.bindRoot(new core.object_array());
    const__1869.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1870, const__2, "Creates an array of ints", const__179, new core.int_array__inliner__6511(), const__327, const__1871, const__19, "1.0", 
            const__7, const__1872, const__9, const__10, const__11, "clojure/core.clj" }));
    const__1869.bindRoot(new core.int_array());
    const__1873.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__17, const__1874, const__2, "Creates an array of longs", const__179, new core.long_array__inliner__6514(), const__327, const__1875, const__19, "1.0", 
            const__7, const__1876, const__9, const__10, const__11, "clojure/core.clj" }));
    const__1873.bindRoot(new core.long_array());
    const__1877.setMeta((IPersistentMap)const__1880);
    const__1877.bindRoot(new core.booleans());
    const__1881.setMeta((IPersistentMap)const__1884);
    const__1881.bindRoot(new core.bytes());
    const__1885.setMeta((IPersistentMap)const__1888);
    const__1885.bindRoot(new core.chars());
    const__1889.setMeta((IPersistentMap)const__1892);
    const__1889.bindRoot(new core.shorts());
    const__1893.setMeta((IPersistentMap)const__1896);
    const__1893.bindRoot(new core.floats());
    const__1897.setMeta((IPersistentMap)const__1900);
    const__1897.bindRoot(new core.ints());
    const__1901.setMeta((IPersistentMap)const__1904);
    const__1901.bindRoot(new core.doubles());
    const__1905.setMeta((IPersistentMap)const__1908);
    const__1905.bindRoot(new core.longs());
    const__1909.setMeta((IPersistentMap)const__1912);
    const__1909.bindRoot(new core.bytes_QMARK_());
    const__1913.setMeta((IPersistentMap)const__1916);
    const__1913.bindRoot(new core.seque());
    const__1917.setMeta((IPersistentMap)const__1920);
    const__1917.bindRoot(new core.class_QMARK_());
    const__1921.setMeta((IPersistentMap)const__1924);
    const__1921.bindRoot(new core.is_annotation_QMARK_());
    const__1925.setMeta((IPersistentMap)const__1928);
    const__1925.bindRoot(new core.is_runtime_annotation_QMARK_());
    const__1929.setMeta((IPersistentMap)const__1932);
    const__1929.bindRoot(new core.descriptor());
    const__1933.setMeta((IPersistentMap)const__1935);
    const__1936.setMeta((IPersistentMap)const__1939);
    const__1936.bindRoot(new core.add_annotation());
    const__1933.setMeta((IPersistentMap)const__1942);
    const__1933.bindRoot(new core.process_annotation());
    const__1943.setMeta((IPersistentMap)const__1946);
    const__1943.bindRoot(new core.add_annotations());
    const__1947.setMeta((IPersistentMap)const__1950);
    const__1947.bindRoot(new core.alter_var_root());
    const__1951.setMeta((IPersistentMap)const__1954);
    const__1951.bindRoot(new core.bound_QMARK_());
    const__1955.setMeta((IPersistentMap)const__1958);
    const__1955.bindRoot(new core.thread_bound_QMARK_());
    const__1959.setMeta((IPersistentMap)const__1962);
    const__1959.bindRoot(new core.make_hierarchy());
    const__719.setMeta((IPersistentMap)const__1964);
    const__719






















































































































































      
      .bindRoot(((IFn)const__1959.getRawRoot()).invoke());
    const__1965.setMeta((IPersistentMap)const__1968);
    const__1965.bindRoot(new core.not_empty());
    const__1969.setMeta((IPersistentMap)const__1972);
    const__1969.bindRoot(new core.bases());
    const__1973.setMeta((IPersistentMap)const__1976);
    const__1973.bindRoot(new core.supers());
    const__1977.setMeta((IPersistentMap)const__1980);
    const__1977.bindRoot(new core.isa_QMARK_());
    const__1981.setMeta((IPersistentMap)const__1984);
    const__1981.bindRoot(new core.parents());
    const__1985.setMeta((IPersistentMap)const__1988);
    const__1985.bindRoot(new core.ancestors());
    const__1989.setMeta((IPersistentMap)const__1992);
    const__1989.bindRoot(new core.descendants());
    const__1993.setMeta((IPersistentMap)const__1996);
    const__1993.bindRoot(new core.derive());
    const__1997.setMeta((IPersistentMap)const__1999);
    const__2000.setMeta((IPersistentMap)const__2003);
    const__2000.bindRoot(new core.underive());
    const__2004.setMeta((IPersistentMap)const__2007);
    const__2004.bindRoot(new core.distinct_QMARK_());
    const__2008.setMeta((IPersistentMap)const__2011);
    const__2008.bindRoot(new core.resultset_seq());
    const__2012.setMeta((IPersistentMap)const__2015);
    const__2012.bindRoot(new core.iterator_seq());
    const__2016.setMeta((IPersistentMap)const__2019);
    const__2016.bindRoot(new core.enumeration_seq());
    const__2020.setMeta((IPersistentMap)const__2023);
    const__2020.bindRoot(new core.format());
    const__2024.setMeta((IPersistentMap)const__2027);
    const__2024.bindRoot(new core.printf());
    const__2028.setMeta((IPersistentMap)const__2030);
    const__2031.setMeta((IPersistentMap)const__2034);
    const__2031.bindRoot(new core.with_loading_context());
    ((Var)const__2031)


























































































































































































































      
      .setMacro();
    const__2035.setMeta((IPersistentMap)const__2038);
    const__2035.bindRoot(new core.ns());
    ((Var)const__2035)







      
      .setMacro();
    const__2039.setMeta((IPersistentMap)const__2042);
    const__2039.bindRoot(new core.refer_clojure());
    ((Var)const__2039)
























































      
      .setMacro();
    const__2043.setMeta((IPersistentMap)const__2046);
    const__2043.bindRoot(new core.defonce());
    ((Var)const__2043)




      
      .setMacro();
    const__2047.setMeta((IPersistentMap)const__2050);
    const__2047.bindRoot(new core.throw_if());
    const__2051.setMeta((IPersistentMap)const__2054);
    const__2051.bindRoot(new core.libspec_QMARK_());
    const__2055.setMeta((IPersistentMap)const__2058);
    const__2055.bindRoot(new core.prependss());
    const__2059.setMeta((IPersistentMap)const__2062);
    const__2059.bindRoot(new core.root_resource());
    const__2063.setMeta((IPersistentMap)const__2066);
    const__2063.bindRoot(new core.root_directory());
    const__2067.setMeta((IPersistentMap)const__2070);
    const__2071.setMeta((IPersistentMap)const__2074);
    const__2071.bindRoot(new core.load_one());
    const__2075.setMeta((IPersistentMap)const__2078);
    const__2075.bindRoot(new core.load_all());
    const__2079.setMeta((IPersistentMap)const__2082);
    const__2079.bindRoot(new core.load_lib());
    const__2083.setMeta((IPersistentMap)const__2086);
    const__2083.bindRoot(new core.load_libs());
    const__2087.setMeta((IPersistentMap)const__2090);
    const__2087.bindRoot(new core.check_cyclic_dependency());
    const__2091.setMeta((IPersistentMap)const__2094);
    const__2091.bindRoot(new core.require());
    const__2095.setMeta((IPersistentMap)const__2098);
    const__2095.bindRoot(new core.serialized_require());
    const__2099.setMeta((IPersistentMap)const__2102);
    const__2099.bindRoot(new core.requiring_resolve());
    const__2103.setMeta((IPersistentMap)const__2106);
    const__2103.bindRoot(new core.use());
    const__2107.setMeta((IPersistentMap)const__2110);
    const__2107.bindRoot(new core.loaded_libs());
    const__2067.setMeta((IPersistentMap)const__2113);
    const__2067.bindRoot(new core.load());
    const__2114.setMeta((IPersistentMap)const__2117);
    const__2114.bindRoot(new core.compile());
    const__2118.setMeta((IPersistentMap)const__2121);
    const__2118.bindRoot(new core.get_in());
    const__2122.setMeta((IPersistentMap)const__2125);
    const__2122.bindRoot(new core.assoc_in());
    const__2126.setMeta((IPersistentMap)const__2129);
    const__2126.bindRoot(new core.update_in());
    const__2130.setMeta((IPersistentMap)const__2133);
    const__2130.bindRoot(new core.update());
    const__2134.setMeta((IPersistentMap)const__2137);
    const__2134.bindRoot(new core.empty_QMARK_());
    const__2138.setMeta((IPersistentMap)const__2141);
    const__2138.bindRoot(new core.coll_QMARK_());
    const__2142.setMeta((IPersistentMap)const__2145);
    const__2142.bindRoot(new core.list_QMARK_());
    const__2146.setMeta((IPersistentMap)const__2149);
    const__2146.bindRoot(new core.seqable_QMARK_());
    const__2150.setMeta((IPersistentMap)const__2153);
    const__2150.bindRoot(new core.ifn_QMARK_());
    const__2154.setMeta((IPersistentMap)const__2157);
    const__2154.bindRoot(new core.fn_QMARK_());
    const__2158.setMeta((IPersistentMap)const__2161);
    const__2158.bindRoot(new core.associative_QMARK_());
    const__2162.setMeta((IPersistentMap)const__2165);
    const__2162.bindRoot(new core.sequential_QMARK_());
    const__2166.setMeta((IPersistentMap)const__2169);
    const__2166.bindRoot(new core.sorted_QMARK_());
    const__2170.setMeta((IPersistentMap)const__2173);
    const__2170.bindRoot(new core.counted_QMARK_());
    const__2174.setMeta((IPersistentMap)const__2177);
    const__2174.bindRoot(new core.reversible_QMARK_());
    const__2178.setMeta((IPersistentMap)const__2181);
    const__2178.bindRoot(new core.indexed_QMARK_());
    const__2182.setDynamic(true).setMeta((IPersistentMap)const__2184);
    const__2185.setDynamic(true).setMeta((IPersistentMap)const__2187);
    const__2188.setDynamic(true).setMeta((IPersistentMap)const__2190);
    const__2191.setDynamic(true).setMeta((IPersistentMap)const__2193);
    const__2194.setMeta((IPersistentMap)const__2197);
    const__2194.bindRoot(new core.trampoline());
    const__2198.setMeta((IPersistentMap)const__2201);
    const__2198.bindRoot(new core.intern());
    const__2202.setMeta((IPersistentMap)const__2205);
    const__2202.bindRoot(new core.while());
    ((Var)const__2202)


































































































































































































































































































































































































































































































      
      .setMacro();
    const__2206.setMeta((IPersistentMap)const__2209);
    const__2206.bindRoot(new core.memoize());
    const__2210.setMeta((IPersistentMap)const__2213);
    const__2210.bindRoot(new core.condp());
    ((Var)const__2210)
























      
      .setMacro();
    const__2216.setMeta((IPersistentMap)const__2219);
    const__2216.bindRoot(new core.add_doc_and_meta());
    ((Var)const__2216)
      
      .setMacro();
    const__2252.setMeta((IPersistentMap)const__2255);
    const__2252.bindRoot(new core.future_QMARK_());
    const__2256.setMeta((IPersistentMap)const__2259);
    const__2256.bindRoot(new core.future_done_QMARK_());
    const__2260.setMeta((IPersistentMap)const__2265);
    const__2260.bindRoot(new core.letfn());
    ((Var)const__2260)





































      
      .setMacro();
    const__2266.setMeta((IPersistentMap)const__2269);
    const__2266.bindRoot(new core.fnil());
    const__2270.setMeta((IPersistentMap)const__2273);
    const__2270.bindRoot(new core.shift_mask());
    const__2274.setMeta((IPersistentMap)const__2276);
    const__2274.bindRoot(const__2277);
    const__2278.setMeta((IPersistentMap)const__2280);
    const__2278










































      
      .bindRoot(Numbers.num(Numbers.shiftLeft(1L, const__2274.getRawRoot())));
    const__2281.setMeta((IPersistentMap)const__2284);
    const__2281.bindRoot(new core.maybe_min_hash());
    const__2285.setMeta((IPersistentMap)const__2288);
    const__2285.bindRoot(new core.case_map());
    const__2289.setMeta((IPersistentMap)const__2292);
    const__2289.bindRoot(new core.fits_table_QMARK_());
    const__2293.setMeta((IPersistentMap)const__2296);
    const__2293.bindRoot(new core.prep_ints());
    const__2297.setMeta((IPersistentMap)const__2300);
    const__2297.bindRoot(new core.merge_hash_collisions());
    const__2301.setMeta((IPersistentMap)const__2304);
    const__2301.bindRoot(new core.prep_hashes());
    const__2305.setMeta((IPersistentMap)const__2308);
    const__2305.bindRoot(new core.case());
    ((Var)const__2305)












































































































      
      .setMacro();
    const__2310.setMeta((IPersistentMap)const__2313);
    const__2310.bindRoot(new core.when_class());
    ((Var)const__2310)
      
      .setMacro();
    const__2336.setMeta((IPersistentMap)const__2339);
    const__2336.bindRoot(new core.inst_ms());
    const__2340.setMeta((IPersistentMap)const__2343);
    const__2340.bindRoot(new core.inst_QMARK_());
    const__2345.setMeta((IPersistentMap)const__2348);
    const__2345.bindRoot(new core.uuid_QMARK_());
    const__2349.setMeta((IPersistentMap)const__2352);
    const__2349.bindRoot(new core.reduce());
    const__2357.setMeta((IPersistentMap)const__2360);
    const__2357.bindRoot(new core.reduce_kv());
    const__2361.setMeta((IPersistentMap)const__2364);
    const__2361.bindRoot(new core.completing());
    const__2365.setMeta((IPersistentMap)const__2368);
    const__2365.bindRoot(new core.transduce());
    const__2369.setMeta((IPersistentMap)const__2372);
    const__2369.bindRoot(new core.into());
    const__2373.setMeta((IPersistentMap)const__2376);
    const__2373.bindRoot(new core.mapv());
    const__2377.setMeta((IPersistentMap)const__2380);
    const__2377.bindRoot(new core.filterv());
    const__2382.setMeta((IPersistentMap)const__2385);
    const__2382.bindRoot(new core.normalize_slurp_opts());
    const__2386.setMeta((IPersistentMap)const__2389);
    const__2386.bindRoot(new core.slurp());
    const__2390.setMeta((IPersistentMap)const__2393);
    const__2390.bindRoot(new core.spit());
    const__2394.setMeta((IPersistentMap)const__2397);
    const__2394.bindRoot(new core.future_call());
    const__2398.setMeta((IPersistentMap)const__2401);
    const__2398.bindRoot(new core.future());
    ((Var)const__2398)
























































      
      .setMacro();
    const__2402.setMeta((IPersistentMap)const__2405);
    const__2402.bindRoot(new core.future_cancel());
    const__2406.setMeta((IPersistentMap)const__2409);
    const__2406.bindRoot(new core.future_cancelled_QMARK_());
    const__2410.setMeta((IPersistentMap)const__2413);
    const__2410.bindRoot(new core.pmap());
    const__2414.setMeta((IPersistentMap)const__2417);
    const__2414.bindRoot(new core.pcalls());
    const__2418.setMeta((IPersistentMap)const__2421);
    const__2418.bindRoot(new core.pvalues());
    ((Var)const__2418)




















































      
      .setMacro();
    const__2424.setMeta((IPersistentMap)const__2427);
    const__2424.bindRoot(new core.clojure_version());
    const__2428.setMeta((IPersistentMap)const__2431);
    const__2428.bindRoot(new core.promise());
    const__2432.setMeta((IPersistentMap)const__2435);
    const__2432.bindRoot(new core.deliver());
    const__1997.setMeta((IPersistentMap)const__2438);
    const__1997.bindRoot(new core.flatten());
    const__2439.setMeta((IPersistentMap)const__2442);
    const__2439.bindRoot(new core.group_by());
    const__2443.setMeta((IPersistentMap)const__2446);
    const__2443.bindRoot(new core.partition_by());
    const__2447.setMeta((IPersistentMap)const__2450);
    const__2447.bindRoot(new core.frequencies());
    const__2451.setMeta((IPersistentMap)const__2454);
    const__2451.bindRoot(new core.reductions());
    const__2455.setMeta((IPersistentMap)const__2458);
    const__2455.bindRoot(new core.rand_nth());
    const__2459.setMeta((IPersistentMap)const__2462);
    const__2459.bindRoot(new core.partition_all());
    const__2463.setMeta((IPersistentMap)const__2466);
    const__2463.bindRoot(new core.shuffle());
    const__2467.setMeta((IPersistentMap)const__2470);
    const__2467.bindRoot(new core.map_indexed());
    const__2471.setMeta((IPersistentMap)const__2474);
    const__2471.bindRoot(new core.keep());
    const__2475.setMeta((IPersistentMap)const__2478);
    const__2475.bindRoot(new core.keep_indexed());
    const__2479.setMeta((IPersistentMap)const__2482);
    const__2479.bindRoot(new core.bounded_count());
    const__2483.setMeta((IPersistentMap)const__2486);
    const__2483.bindRoot(new core.every_pred());
    const__2487.setMeta((IPersistentMap)const__2490);
    const__2487.bindRoot(new core.some_fn());
    const__115.setDynamic(true).setMeta((IPersistentMap)const__2493);
    const__115.setDynamic(true).bindRoot(new core.assert_valid_fdecl());
    const__2494.setMeta((IPersistentMap)const__2497);
    const__2494.bindRoot(new core.with_redefs_fn());
    const__2498.setMeta((IPersistentMap)const__2501);
    const__2498.bindRoot(new core.with_redefs());
    ((Var)const__2498)


























































































































































































































































































































































































































































      
      .setMacro();
    const__2502.setMeta((IPersistentMap)const__2505);
    const__2502.bindRoot(new core.realized_QMARK_());
    const__2506.setMeta((IPersistentMap)const__2509);
    const__2506.bindRoot(new core.cond__GT_());
    ((Var)const__2506)


















      
      .setMacro();
    const__2510.setMeta((IPersistentMap)const__2513);
    const__2510.bindRoot(new core.cond__GT__GT_());
    ((Var)const__2510)















      
      .setMacro();
    const__2514.setMeta((IPersistentMap)const__2517);
    const__2514.bindRoot(new core.as__GT_());
    ((Var)const__2514)















      
      .setMacro();
    const__2518.setMeta((IPersistentMap)const__2521);
    const__2518.bindRoot(new core.some__GT_());
    ((Var)const__2518)










      
      .setMacro();
    const__2522.setMeta((IPersistentMap)const__2525);
    const__2522.bindRoot(new core.some__GT__GT_());
    ((Var)const__2522)












      
      .setMacro();
    const__2526.setMeta((IPersistentMap)const__2529);
    const__2526.bindRoot(new core.preserving_reduced());
    const__1039.setMeta((IPersistentMap)const__2532);
    const__1039.bindRoot(new core.cat());
    const__2533.setMeta((IPersistentMap)const__2536);
    const__2533.bindRoot(new core.halt_when());
    const__2537.setMeta((IPersistentMap)const__2540);
    const__2537.bindRoot(new core.dedupe());
    const__2541.setMeta((IPersistentMap)const__2544);
    const__2541.bindRoot(new core.random_sample());
    const__2545.setMeta((IPersistentMap)const__2548);
    const__2545.bindRoot(new core.eduction());
    const__2551.setMeta((IPersistentMap)const__2554);
    const__2551.bindRoot(new core.run_BANG_());
    const__2555.setMeta((IPersistentMap)const__2558);
    const__2555.bindRoot(new core.tagged_literal_QMARK_());
    const__2559.setMeta((IPersistentMap)const__2562);
    const__2559.bindRoot(new core.tagged_literal());
    const__2563.setMeta((IPersistentMap)const__2566);
    const__2563.bindRoot(new core.reader_conditional_QMARK_());
    const__2567.setMeta((IPersistentMap)const__2570);
    const__2567.bindRoot(new core.reader_conditional());
    const__2571.setMeta((IPersistentMap)const__2573);
    const__2571















































      
      .bindRoot(((IFn)const__1124.getRawRoot()).invoke(RT.mapUniqueKeys(new Object[] { const__2574, const__2575 }, ), ((IFn)new core.fn__8797())
          
          .invoke()));
    const__2576.setDynamic(true).setMeta((IPersistentMap)const__2578);
    const__2576.setDynamic(true).bindRoot(PersistentArrayMap.EMPTY);
    const__2579.setDynamic(true).setMeta((IPersistentMap)const__2581);
    const__2579.setDynamic(true).bindRoot(null);
    const__2582.setMeta((IPersistentMap)const__2585);
    const__2582.bindRoot(new core.data_reader_urls());
    const__2586.setMeta((IPersistentMap)const__2589);
    const__2586.bindRoot(new core.data_reader_var());
    const__2590.setMeta((IPersistentMap)const__2593);
    const__2590.bindRoot(new core.load_data_reader_file());
    const__2594.setMeta((IPersistentMap)const__2597);
    const__2594.bindRoot(new core.load_data_readers());
    const__2598.setMeta((IPersistentMap)const__2601);
    const__2598.bindRoot(new core.uri_QMARK_());
    const__2602.setMeta((IPersistentMap)const__2605);
    const__2602.bindRoot(new core.add_tap());
    const__2606.setMeta((IPersistentMap)const__2609);
    const__2606.bindRoot(new core.remove_tap());
    const__2610.setMeta((IPersistentMap)const__2613);
    const__2610.bindRoot(new core.tap_GT_());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.core")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The core Clojure language.", RT.keyword(null, "author"), "Rich Hickey" }));
    const__2 = (Keyword)RT.keyword(null, "doc");
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "The core Clojure language.", RT.keyword(null, "author"), "Rich Hickey" });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.core", "unquote");
    const__7 = (Keyword)RT.keyword(null, "line");
    const__9 = (Keyword)RT.keyword(null, "column");
    const__10 = Integer.valueOf(1);
    const__11 = (Keyword)RT.keyword(null, "file");
    const__12 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(13), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__13 = (Var)RT.var("clojure.core", "unquote-splicing");
    const__15 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(14), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__16 = (Var)RT.var("clojure.core", "list");
    const__17 = (Keyword)RT.keyword(null, "arglists");
    const__19 = (Keyword)RT.keyword(null, "added");
    const__21 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "items")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(17), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Creates a new list containing the items.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(16), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__22 = (Var)RT.var("clojure.core", "cons");
    const__24 = (Keyword)RT.keyword(null, "static");
    const__26 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "seq")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(23), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Returns a new seq where x is the first element and seq is\n    the rest.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(22), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__27 = (Var)RT.var("clojure.core", "let");
    const__30 = (AFn)RT.map(new Object[] { RT.keyword(null, "macro"), Boolean.TRUE, RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(32), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__31 = (Var)RT.var("clojure.core", "loop");
    const__33 = (AFn)RT.map(new Object[] { RT.keyword(null, "macro"), Boolean.TRUE, RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(37), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__34 = (Var)RT.var("clojure.core", "fn");
    const__36 = (AFn)RT.map(new Object[] { RT.keyword(null, "macro"), Boolean.TRUE, RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(42), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__37 = (Var)RT.var("clojure.core", "first");
    const__40 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(50), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Returns the first item in the collection. Calls seq on its\n    argument. If coll is nil, returns nil.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(49), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__41 = (Var)RT.var("clojure.core", "next");
    const__43 = (Keyword)RT.keyword(null, "tag");
    const__46 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(58), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "tag"), RT.classForName("clojure.lang.ISeq"), RT.keyword(null, "doc"), "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(57), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__47 = (Var)RT.var("clojure.core", "rest");
    const__50 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(67), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "tag"), RT.classForName("clojure.lang.ISeq"), RT.keyword(null, "doc"), "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(66), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__51 = (Var)RT.var("clojure.core", "conj");
    const__54 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "x"), Symbol.intern(null, "&"), Symbol.intern(null, "xs")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(76), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "conj[oin]. Returns a new collection with the xs\n    'added'. (conj nil item) returns (item).  The 'addition' may\n    happen at different 'places' depending on the concrete type.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(75), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__55 = (Var)RT.var("clojure.core", "second");
    const__58 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "Same as (first (next x))", RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(93), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(91), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__59 = (Var)RT.var("clojure.core", "ffirst");
    const__62 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "Same as (first (first x))", RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(100), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(98), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__63 = (Var)RT.var("clojure.core", "nfirst");
    const__66 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "Same as (next (first x))", RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(107), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(105), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__67 = (Var)RT.var("clojure.core", "fnext");
    const__70 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "Same as (first (next x))", RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(114), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(112), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__71 = (Var)RT.var("clojure.core", "nnext");
    const__74 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "Same as (next (next x))", RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(121), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(119), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__75 = (Var)RT.var("clojure.core", "seq");
    const__78 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "coll"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.ISeq") })) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(127), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Returns a seq on the collection. If the collection is\n    empty, returns nil.  (seq nil) returns nil. seq also works on\n    Strings, native Java arrays (of reference types) and any objects\n    that implement Iterable. Note that seqs cache values, thus seq\n    should not be used on any Iterable whose iterator repeatedly\n    returns the same mutable object.", RT.keyword(null, "tag"), RT.classForName("clojure.lang.ISeq"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(126), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__79 = (Var)RT.var("clojure.core", "instance?");
    const__82 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") })), Symbol.intern(null, "x")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(140), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Evaluates x and tests if it is an instance of the class\n    c. Returns true or false", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(139), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__83 = (Var)RT.var("clojure.core", "seq?");
    const__86 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(147), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Return true if x implements ISeq", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(146), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__87 = (Var)RT.var("clojure.core", "char?");
    const__90 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(154), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Return true if x is a Character", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(153), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__91 = (Var)RT.var("clojure.core", "string?");
    const__94 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(161), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Return true if x is a String", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(160), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__95 = (Var)RT.var("clojure.core", "map?");
    const__98 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(168), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Return true if x implements IPersistentMap", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(167), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__99 = (Var)RT.var("clojure.core", "vector?");
  }
  
  public static void __init1() {
    const__102 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(175), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Return true if x implements IPersistentVector", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(174), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__103 = (Var)RT.var("clojure.core", "assoc");
    const__106 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "map"), Symbol.intern(null, "key"), Symbol.intern(null, "val")), Tuple.create(Symbol.intern(null, "map"), Symbol.intern(null, "key"), Symbol.intern(null, "val"), Symbol.intern(null, "&"), Symbol.intern(null, "kvs")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(182), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "assoc[iate]. When applied to a map, returns a new map of the\n    same (hashed/sorted) type, that contains the mapping of key(s) to\n    val(s). When applied to a vector, returns a new vector that\n    contains val at index. Note - index must be <= (count vector).", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(181), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__107 = (Var)RT.var("clojure.core", "meta");
    const__110 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "obj")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(203), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Returns the metadata of obj, returns nil if there is no metadata.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(202), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__111 = (Var)RT.var("clojure.core", "with-meta");
    const__114 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "obj")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IObj") })), Symbol.intern(null, "m")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(212), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Returns an object of the same type and value as obj, with\n    map m as its metadata.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(211), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__115 = (Var)RT.var("clojure.core", "assert-valid-fdecl");
    const__119 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(220), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__120 = (Var)RT.var("clojure.core", "sigs");
    const__122 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(223), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__123 = (Var)RT.var("clojure.core", "last");
    const__126 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(263), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Return the last item in coll, in linear time", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(262), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__127 = (Var)RT.var("clojure.core", "butlast");
    const__130 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(273), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Return a seq of all but the last item in coll, in linear time", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(272), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__131 = (Var)RT.var("clojure.core", "defn");
    const__134 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.", RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "doc-string?"), Symbol.intern(null, "attr-map?"), Tuple.create(Symbol.intern(null, "params*")), Symbol.intern(null, "prepost-map?"), Symbol.intern(null, "body")), Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "doc-string?"), Symbol.intern(null, "attr-map?"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "params*")), Symbol.intern(null, "prepost-map?"), Symbol.intern(null, "body") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(290), RT.keyword(null, "column"), Integer.valueOf(45) })), Symbol.intern(null, "+"), Symbol.intern(null, "attr-map?")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(289), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(283), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__135 = (Var)RT.var("clojure.core", "to-array");
    const__138 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns an array of Objects containing the contents of coll, which\n  can be any Collection.  Maps to java.util.Collection.toArray().", RT.keyword(null, "tag"), "[Ljava.lang.Object;", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(338), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__139 = (Var)RT.var("clojure.core", "cast");
    const__142 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") })), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Throws a ClassCastException if x is not a c, else returns x.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(346), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__143 = (Var)RT.var("clojure.core", "vector");
    const__146 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "a")), Tuple.create(Symbol.intern(null, "a"), Symbol.intern(null, "b")), Tuple.create(Symbol.intern(null, "a"), Symbol.intern(null, "b"), Symbol.intern(null, "c")), Tuple.create(Symbol.intern(null, "a"), Symbol.intern(null, "b"), Symbol.intern(null, "c"), Symbol.intern(null, "d")), Tuple.create(Symbol.intern(null, "a"), Symbol.intern(null, "b"), Symbol.intern(null, "c"), Symbol.intern(null, "d"), Symbol.intern(null, "e")), Tuple.create(Symbol.intern(null, "a"), Symbol.intern(null, "b"), Symbol.intern(null, "c"), Symbol.intern(null, "d"), Symbol.intern(null, "e"), Symbol.intern(null, "f")), RT.vector(new Object[] { Symbol.intern(null, "a"), Symbol.intern(null, "b"), Symbol.intern(null, "c"), Symbol.intern(null, "d"), Symbol.intern(null, "e"), Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "args") }) })), RT.keyword(null, "doc"), "Creates a new vector containing the args.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(353), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__147 = (Var)RT.var("clojure.core", "vec");
    const__150 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Creates a new vector containing the contents of coll. Java arrays\n  will be aliased and should not be modified.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(367), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__151 = (Var)RT.var("clojure.core", "hash-map");
    const__154 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "keyvals")) })), RT.keyword(null, "doc"), "keyval => key val\n  Returns a new hash map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(379), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__155 = (Var)RT.var("clojure.core", "hash-set");
    const__158 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "keys")) })), RT.keyword(null, "doc"), "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(389), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__159 = (Var)RT.var("clojure.core", "sorted-map");
    const__162 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "keyvals")) })), RT.keyword(null, "doc"), "keyval => key val\n  Returns a new sorted map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(398), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__163 = (Var)RT.var("clojure.core", "sorted-map-by");
    const__166 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "comparator"), Symbol.intern(null, "&"), Symbol.intern(null, "keyvals")) })), RT.keyword(null, "doc"), "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied\n  comparator.  If any keys are equal, they are handled as if by\n  repeated uses of assoc.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(407), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__167 = (Var)RT.var("clojure.core", "sorted-set");
    const__170 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "keys")) })), RT.keyword(null, "doc"), "Returns a new sorted set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(417), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__171 = (Var)RT.var("clojure.core", "sorted-set-by");
    const__174 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "comparator"), Symbol.intern(null, "&"), Symbol.intern(null, "keys")) })), RT.keyword(null, "doc"), "Returns a new sorted set with supplied keys, using the supplied\n  comparator.  Any equal keys are handled as if by repeated uses of\n  conj.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(425), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__175 = (Var)RT.var("clojure.core", "nil?");
    const__176 = Integer.valueOf(436);
    const__177 = RT.classForName("java.lang.Boolean");
    const__178 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }));
    const__179 = (Keyword)RT.keyword(null, "inline");
    const__180 = (Var)RT.var("clojure.core", "defmacro");
    const__183 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.", RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "doc-string?"), Symbol.intern(null, "attr-map?"), Tuple.create(Symbol.intern(null, "params*")), Symbol.intern(null, "body")), Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "doc-string?"), Symbol.intern(null, "attr-map?"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "params*")), Symbol.intern(null, "body") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(450), RT.keyword(null, "column"), Integer.valueOf(46) })), Symbol.intern(null, "+"), Symbol.intern(null, "attr-map?")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(449), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(444), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__184 = (Var)RT.var("clojure.core", "when");
    const__187 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "test"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Evaluates test. If logical true, evaluates body in an implicit do.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(493), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__188 = (Var)RT.var("clojure.core", "when-not");
    const__191 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "test"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Evaluates test. If logical false, evaluates body in an implicit do.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(499), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__192 = (Var)RT.var("clojure.core", "false?");
    const__195 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x is the value false, false otherwise.", RT.keyword(null, "tag"), RT.classForName("java.lang.Boolean"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(505), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__196 = (Var)RT.var("clojure.core", "true?");
    const__199 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x is the value true, false otherwise.", RT.keyword(null, "tag"), RT.classForName("java.lang.Boolean"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(512), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
  }
  
  public static void __init2() {
    const__200 = (Var)RT.var("clojure.core", "boolean?");
    const__203 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x is a Boolean", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(519), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__204 = (Var)RT.var("clojure.core", "not");
    const__207 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x is logical false, false otherwise.", RT.keyword(null, "tag"), RT.classForName("java.lang.Boolean"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(524), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__208 = (Var)RT.var("clojure.core", "some?");
    const__211 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x is not nil, false otherwise.", RT.keyword(null, "tag"), RT.classForName("java.lang.Boolean"), RT.keyword(null, "added"), "1.6", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(531), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__212 = (Var)RT.var("clojure.core", "any?");
    const__215 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true given any argument.", RT.keyword(null, "tag"), RT.classForName("java.lang.Boolean"), RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(538), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__216 = (Var)RT.var("clojure.core", "str");
    const__220 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create()).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.lang.String") })), ((IObj)Tuple.create(((IObj)Symbol.intern(null, "x")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Object") })))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.lang.String") })), ((IObj)Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "&"), Symbol.intern(null, "ys"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.lang.String") })) })), RT.keyword(null, "doc"), "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(544), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__221 = (Var)RT.var("clojure.core", "symbol?");
    const__224 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x is a Symbol", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(562), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__225 = (Var)RT.var("clojure.core", "keyword?");
    const__228 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x is a Keyword", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(568), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__229 = (Var)RT.var("clojure.core", "cond");
    const__232 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "clauses")) })), RT.keyword(null, "doc"), "Takes a set of test/expr pairs. It evaluates each test one at a\n  time.  If a test returns logical true, cond evaluates and returns\n  the value of the corresponding expr and doesn't evaluate any of the\n  other tests or exprs. (cond) returns nil.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(574), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__233 = (Var)RT.var("clojure.core", "symbol");
    const__237 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name")), Tuple.create(Symbol.intern(null, "ns"), Symbol.intern(null, "name")) })), RT.keyword(null, "doc"), "Returns a Symbol with the given namespace and name. Arity-1 works\n  on strings, keywords, and vars.", RT.keyword(null, "tag"), RT.classForName("clojure.lang.Symbol"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(589), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__238 = (Var)RT.var("clojure.core", "gensym");
    const__241 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "prefix-string")) })), RT.keyword(null, "doc"), "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(604), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__242 = (Var)RT.var("clojure.core", "keyword");
    const__246 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name")), Tuple.create(Symbol.intern(null, "ns"), Symbol.intern(null, "name")) })), RT.keyword(null, "doc"), "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", RT.keyword(null, "tag"), RT.classForName("clojure.lang.Keyword"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(614), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__247 = (Var)RT.var("clojure.core", "find-keyword");
    const__250 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name")), Tuple.create(Symbol.intern(null, "ns"), Symbol.intern(null, "name")) })), RT.keyword(null, "doc"), "Returns a Keyword with the given namespace and name if one already\n  exists.  This function will not intern a new keyword. If the keyword\n  has not already been interned, it will return nil.  Do not use :\n  in the keyword strings, it will be added automatically.", RT.keyword(null, "tag"), RT.classForName("clojure.lang.Keyword"), RT.keyword(null, "added"), "1.3", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(625), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__251 = (Var)RT.var("clojure.core", "spread");
    const__254 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "arglist")) })), RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(639), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__255 = (Var)RT.var("clojure.core", "list*");
    const__258 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "args")), Tuple.create(Symbol.intern(null, "a"), Symbol.intern(null, "args")), Tuple.create(Symbol.intern(null, "a"), Symbol.intern(null, "b"), Symbol.intern(null, "args")), Tuple.create(Symbol.intern(null, "a"), Symbol.intern(null, "b"), Symbol.intern(null, "c"), Symbol.intern(null, "args")), Tuple.create(Symbol.intern(null, "a"), Symbol.intern(null, "b"), Symbol.intern(null, "c"), Symbol.intern(null, "d"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) })), RT.keyword(null, "doc"), "Creates a new seq containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(648), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__259 = (Var)RT.var("clojure.core", "apply");
    const__262 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "f")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IFn") })), Symbol.intern(null, "args")), Tuple.create(((IObj)Symbol.intern(null, "f")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IFn") })), Symbol.intern(null, "x"), Symbol.intern(null, "args")), Tuple.create(((IObj)Symbol.intern(null, "f")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IFn") })), Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "args")), Tuple.create(((IObj)Symbol.intern(null, "f")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IFn") })), Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "z"), Symbol.intern(null, "args")), RT.vector(new Object[] { ((IObj)Symbol.intern(null, "f")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IFn") })), Symbol.intern(null, "a"), Symbol.intern(null, "b"), Symbol.intern(null, "c"), Symbol.intern(null, "d"), Symbol.intern(null, "&"), Symbol.intern(null, "args") }) })), RT.keyword(null, "doc"), "Applies fn f to the argument list formed by prepending intervening arguments to args.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(660), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__263 = (Var)RT.var("clojure.core", "vary-meta");
    const__266 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "obj"), Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(675), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__267 = (Var)RT.var("clojure.core", "lazy-seq");
    const__270 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Takes a body of expressions that returns an ISeq or nil, and yields\n  a Seqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls. See also - realized?", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(683), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__271 = (Var)RT.var("clojure.core", "chunk-buffer");
    const__275 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("clojure.lang.ChunkBuffer"), RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "capacity"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.ChunkBuffer") })) })), RT.keyword(null, "line"), Integer.valueOf(692), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__276 = (Var)RT.var("clojure.core", "chunk-append");
    const__279 = (AFn)RT.map(new Object[] { RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "b")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.ChunkBuffer") })), Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(695), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__280 = (Var)RT.var("clojure.core", "chunk");
    const__284 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("clojure.lang.IChunk"), RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "b")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.ChunkBuffer") }))) })), RT.keyword(null, "line"), Integer.valueOf(698), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__285 = (Var)RT.var("clojure.core", "chunk-first");
    const__288 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("clojure.lang.IChunk"), RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IChunkedSeq") })))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IChunk") })) })), RT.keyword(null, "line"), Integer.valueOf(701), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__289 = (Var)RT.var("clojure.core", "chunk-rest");
    const__292 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("clojure.lang.ISeq"), RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IChunkedSeq") })))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.ISeq") })) })), RT.keyword(null, "line"), Integer.valueOf(704), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__293 = (Var)RT.var("clojure.core", "chunk-next");
    const__296 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("clojure.lang.ISeq"), RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IChunkedSeq") })))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.ISeq") })) })), RT.keyword(null, "line"), Integer.valueOf(707), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__297 = (Var)RT.var("clojure.core", "chunk-cons");
  }
  
  public static void __init3() {
    const__300 = (AFn)RT.map(new Object[] { RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "chunk"), Symbol.intern(null, "rest")) })), RT.keyword(null, "line"), Integer.valueOf(710), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__301 = (Var)RT.var("clojure.core", "chunked-seq?");
    const__304 = (AFn)RT.map(new Object[] { RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "line"), Integer.valueOf(715), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__305 = (Var)RT.var("clojure.core", "concat");
    const__308 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "zs")) })), RT.keyword(null, "doc"), "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(718), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__309 = (Var)RT.var("clojure.core", "delay");
    const__312 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls. See also - realized?", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(746), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__313 = (Var)RT.var("clojure.core", "delay?");
    const__316 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "returns true if x is a Delay created with delay", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(755), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__317 = (Var)RT.var("clojure.core", "force");
    const__320 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "If x is a Delay, returns the (possibly cached) value of its expression, else returns x", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(761), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__321 = (Var)RT.var("clojure.core", "if-not");
    const__324 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "test"), Symbol.intern(null, "then")), Tuple.create(Symbol.intern(null, "test"), Symbol.intern(null, "then"), Symbol.intern(null, "else")) })), RT.keyword(null, "doc"), "Evaluates test. If logical false, evaluates and returns then expr, \n  otherwise else expr, if supplied, else nil.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(767), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__325 = (Var)RT.var("clojure.core", "identical?");
    const__326 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")) }));
    const__327 = (Keyword)RT.keyword(null, "inline-arities");
    const__329 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(2L) });
    const__330 = Integer.valueOf(775);
    const__331 = (Var)RT.var("clojure.core", "=");
    const__332 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }));
    const__333 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(2L) });
    const__334 = Integer.valueOf(783);
    const__335 = (Var)RT.var("clojure.core", "not=");
    const__338 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) })), RT.keyword(null, "doc"), "Same as (not (= obj1 obj2))", RT.keyword(null, "tag"), RT.classForName("java.lang.Boolean"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(819), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__339 = (Var)RT.var("clojure.core", "compare");
    const__340 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")) }));
    const__341 = Integer.valueOf(831);
    const__342 = (Var)RT.var("clojure.core", "and");
    const__345 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "&"), Symbol.intern(null, "next")) })), RT.keyword(null, "doc"), "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(842), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__346 = (Var)RT.var("clojure.core", "or");
    const__349 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "&"), Symbol.intern(null, "next")) })), RT.keyword(null, "doc"), "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(854), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__350 = (Var)RT.var("clojure.core", "zero?");
    const__351 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "num")) }));
    const__352 = Integer.valueOf(867);
    const__353 = (Var)RT.var("clojure.core", "count");
    const__354 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) }));
    const__355 = Integer.valueOf(874);
    const__356 = (Var)RT.var("clojure.core", "int");
    const__357 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }));
    const__358 = Integer.valueOf(882);
    const__359 = (Var)RT.var("clojure.core", "nth");
    const__360 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "index")), Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "index"), Symbol.intern(null, "not-found")) }));
    const__362 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(3L), Long.valueOf(2L) });
    const__363 = Integer.valueOf(889);
    const__364 = (Var)RT.var("clojure.core", "<");
    const__365 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }));
    const__366 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(2L) });
    const__367 = Integer.valueOf(900);
    const__368 = (Var)RT.var("clojure.core", "inc'");
    const__369 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }));
    const__370 = Integer.valueOf(915);
    const__371 = (Var)RT.var("clojure.core", "inc");
    const__372 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }));
    const__373 = Integer.valueOf(922);
    const__374 = (Var)RT.var("clojure.core", "reduce1");
    const__377 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "val"), Symbol.intern(null, "coll")) })), RT.keyword(null, "line"), Integer.valueOf(930), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__378 = (Var)RT.var("clojure.core", "reverse");
    const__381 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a seq of the items in coll in reverse order. Not lazy.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(947), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__382 = (Var)RT.var("clojure.core", "nary-inline");
    const__385 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "op")), Tuple.create(Symbol.intern(null, "op"), Symbol.intern(null, "unchecked-op")) })), RT.keyword(null, "line"), Integer.valueOf(955), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__386 = (Var)RT.var("clojure.core", ">1?");
    const__389 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "line"), Integer.valueOf(969), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__390 = (Var)RT.var("clojure.core", ">0?");
    const__393 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "line"), Integer.valueOf(970), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__394 = (Var)RT.var("clojure.core", "+'");
    const__395 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }));
    const__396 = (AFn)Symbol.intern(null, "addP");
    const__397 = Integer.valueOf(972);
    const__398 = (Var)RT.var("clojure.core", "+");
    const__399 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }));
  }
  
  public static void __init4() {
    const__400 = (AFn)Symbol.intern(null, "add");
    const__401 = (AFn)Symbol.intern(null, "unchecked_add");
    const__402 = Integer.valueOf(984);
    const__403 = (Var)RT.var("clojure.core", "*'");
    const__404 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }));
    const__405 = (AFn)Symbol.intern(null, "multiplyP");
    const__406 = Integer.valueOf(996);
    const__407 = (Var)RT.var("clojure.core", "*");
    const__408 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }));
    const__409 = (AFn)Symbol.intern(null, "multiply");
    const__410 = (AFn)Symbol.intern(null, "unchecked_multiply");
    const__411 = Integer.valueOf(1008);
    const__412 = (Var)RT.var("clojure.core", "/");
    const__413 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }));
    const__414 = (AFn)Symbol.intern(null, "divide");
    const__415 = Integer.valueOf(1020);
    const__416 = (Var)RT.var("clojure.core", "-'");
    const__417 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }));
    const__418 = (AFn)Symbol.intern(null, "minusP");
    const__419 = Integer.valueOf(1031);
    const__420 = (Var)RT.var("clojure.core", "-");
    const__421 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }));
    const__422 = (AFn)Symbol.intern(null, "minus");
    const__423 = (AFn)Symbol.intern(null, "unchecked_minus");
    const__424 = Integer.valueOf(1043);
    const__425 = (Var)RT.var("clojure.core", "<=");
    const__426 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }));
    const__427 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(2L) });
    const__428 = Integer.valueOf(1055);
    const__429 = (Var)RT.var("clojure.core", ">");
    const__430 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }));
    const__431 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(2L) });
    const__432 = Integer.valueOf(1070);
    const__433 = (Var)RT.var("clojure.core", ">=");
    const__434 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }));
    const__435 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(2L) });
    const__436 = Integer.valueOf(1085);
    const__437 = (Var)RT.var("clojure.core", "==");
    const__438 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }));
    const__439 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(2L) });
    const__440 = Integer.valueOf(1100);
    const__441 = (Var)RT.var("clojure.core", "max");
    const__442 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }));
    const__443 = (AFn)Symbol.intern(null, "max");
    const__444 = Integer.valueOf(1115);
    const__445 = (Var)RT.var("clojure.core", "min");
    const__446 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }));
    const__447 = (AFn)Symbol.intern(null, "min");
    const__448 = Integer.valueOf(1125);
    const__449 = (Var)RT.var("clojure.core", "dec'");
    const__450 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }));
    const__451 = Integer.valueOf(1135);
    const__452 = (Var)RT.var("clojure.core", "dec");
    const__453 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }));
    const__454 = Integer.valueOf(1142);
    const__455 = (Var)RT.var("clojure.core", "unchecked-inc-int");
    const__456 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }));
    const__457 = Integer.valueOf(1149);
    const__458 = (Var)RT.var("clojure.core", "unchecked-inc");
    const__459 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }));
    const__460 = Integer.valueOf(1156);
    const__461 = (Var)RT.var("clojure.core", "unchecked-dec-int");
    const__462 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }));
    const__463 = Integer.valueOf(1163);
    const__464 = (Var)RT.var("clojure.core", "unchecked-dec");
    const__465 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }));
    const__466 = Integer.valueOf(1170);
    const__467 = (Var)RT.var("clojure.core", "unchecked-negate-int");
    const__468 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }));
    const__469 = Integer.valueOf(1177);
    const__470 = (Var)RT.var("clojure.core", "unchecked-negate");
    const__471 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }));
    const__472 = Integer.valueOf(1184);
    const__473 = (Var)RT.var("clojure.core", "unchecked-add-int");
    const__474 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")) }));
    const__475 = Integer.valueOf(1191);
    const__476 = (Var)RT.var("clojure.core", "unchecked-add");
    const__477 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")) }));
    const__478 = Integer.valueOf(1198);
    const__479 = (Var)RT.var("clojure.core", "unchecked-subtract-int");
    const__480 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")) }));
    const__481 = Integer.valueOf(1205);
    const__482 = (Var)RT.var("clojure.core", "unchecked-subtract");
    const__483 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")) }));
    const__484 = Integer.valueOf(1212);
    const__485 = (Var)RT.var("clojure.core", "unchecked-multiply-int");
    const__486 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")) }));
    const__487 = Integer.valueOf(1219);
    const__488 = (Var)RT.var("clojure.core", "unchecked-multiply");
    const__489 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")) }));
    const__490 = Integer.valueOf(1226);
    const__491 = (Var)RT.var("clojure.core", "unchecked-divide-int");
    const__492 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")) }));
    const__493 = Integer.valueOf(1233);
    const__494 = (Var)RT.var("clojure.core", "unchecked-remainder-int");
    const__495 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")) }));
    const__496 = Integer.valueOf(1240);
    const__497 = (Var)RT.var("clojure.core", "pos?");
    const__498 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "num")) }));
    const__499 = Integer.valueOf(1247);
  }
  
  public static void __init5() {
    const__500 = (Var)RT.var("clojure.core", "neg?");
    const__501 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "num")) }));
    const__502 = Integer.valueOf(1254);
    const__503 = (Var)RT.var("clojure.core", "quot");
    const__504 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "num"), Symbol.intern(null, "div")) }));
    const__505 = Integer.valueOf(1261);
    const__506 = (Var)RT.var("clojure.core", "rem");
    const__507 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "num"), Symbol.intern(null, "div")) }));
    const__508 = Integer.valueOf(1269);
    const__509 = (Var)RT.var("clojure.core", "rationalize");
    const__512 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "num")) })), RT.keyword(null, "doc"), "returns the rational value of num", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1277), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__513 = (Var)RT.var("clojure.core", "bit-not");
    const__514 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }));
    const__515 = Integer.valueOf(1286);
    const__516 = (Var)RT.var("clojure.core", "bit-and");
    const__517 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }));
    const__518 = (AFn)Symbol.intern(null, "and");
    const__519 = Integer.valueOf(1293);
    const__520 = (Var)RT.var("clojure.core", "bit-or");
    const__521 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }));
    const__522 = (AFn)Symbol.intern(null, "or");
    const__523 = Integer.valueOf(1302);
    const__524 = (Var)RT.var("clojure.core", "bit-xor");
    const__525 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }));
    const__526 = (AFn)Symbol.intern(null, "xor");
    const__527 = Integer.valueOf(1311);
    const__528 = (Var)RT.var("clojure.core", "bit-and-not");
    const__529 = Integer.valueOf(1320);
    const__530 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }));
    const__531 = (AFn)Symbol.intern(null, "andNot");
    const__532 = (Var)RT.var("clojure.core", "bit-clear");
    const__535 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Clear bit at index n", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1331), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__536 = (Var)RT.var("clojure.core", "bit-set");
    const__539 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Set bit at index n", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1337), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__540 = (Var)RT.var("clojure.core", "bit-flip");
    const__543 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Flip bit at index n", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1343), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__544 = (Var)RT.var("clojure.core", "bit-test");
    const__547 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Test bit at index n", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1349), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__548 = (Var)RT.var("clojure.core", "bit-shift-left");
    const__549 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "n")) }));
    const__550 = Integer.valueOf(1356);
    const__551 = (Var)RT.var("clojure.core", "bit-shift-right");
    const__552 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "n")) }));
    const__553 = Integer.valueOf(1362);
    const__554 = (Var)RT.var("clojure.core", "unsigned-bit-shift-right");
    const__555 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "n")) }));
    const__556 = Integer.valueOf(1368);
    const__557 = (Var)RT.var("clojure.core", "integer?");
    const__560 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Returns true if n is an integer", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1374), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__561 = (Var)RT.var("clojure.core", "even?");
    const__564 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Returns true if n is even, throws an exception if n is not an integer", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1386), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__565 = (Var)RT.var("clojure.core", "odd?");
    const__568 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Returns true if n is odd, throws an exception if n is not an integer", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1394), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__569 = (Var)RT.var("clojure.core", "int?");
    const__572 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x is a fixed precision integer", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(1400), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__573 = (Var)RT.var("clojure.core", "pos-int?");
    const__576 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x is a positive fixed precision integer", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(1408), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__577 = (Var)RT.var("clojure.core", "neg-int?");
    const__580 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x is a negative fixed precision integer", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(1414), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__581 = (Var)RT.var("clojure.core", "nat-int?");
    const__584 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x is a non-negative fixed precision integer", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(1420), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__585 = (Var)RT.var("clojure.core", "double?");
    const__588 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x is a Double", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(1426), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__589 = (Var)RT.var("clojure.core", "complement");
    const__592 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1433), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__593 = (Var)RT.var("clojure.core", "constantly");
    const__596 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns a function that takes any number of arguments and returns x.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1445), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__597 = (Var)RT.var("clojure.core", "identity");
  }
  
  public static void __init6() {
    const__600 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns its argument.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1451), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__601 = (Var)RT.var("clojure.core", "peek");
    const__604 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1460), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__605 = (Var)RT.var("clojure.core", "pop");
    const__608 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item. If\n  the collection is empty, throws an exception.  Note - not the same\n  as next/butlast.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1467), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__609 = (Var)RT.var("clojure.core", "map-entry?");
    const__612 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x is a map entry", RT.keyword(null, "added"), "1.8", RT.keyword(null, "line"), Integer.valueOf(1478), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__613 = (Var)RT.var("clojure.core", "contains?");
    const__616 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "key")) })), RT.keyword(null, "doc"), "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and Java arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1484), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__617 = (Var)RT.var("clojure.core", "get");
    const__618 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "map"), Symbol.intern(null, "key")), Tuple.create(Symbol.intern(null, "map"), Symbol.intern(null, "key"), Symbol.intern(null, "not-found")) }));
    const__619 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(3L), Long.valueOf(2L) });
    const__620 = Integer.valueOf(1494);
    const__621 = (Var)RT.var("clojure.core", "dissoc");
    const__624 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "map")), Tuple.create(Symbol.intern(null, "map"), Symbol.intern(null, "key")), Tuple.create(Symbol.intern(null, "map"), Symbol.intern(null, "key"), Symbol.intern(null, "&"), Symbol.intern(null, "ks")) })), RT.keyword(null, "doc"), "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1504), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__625 = (Var)RT.var("clojure.core", "disj");
    const__628 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "set")), Tuple.create(((IObj)Symbol.intern(null, "set")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IPersistentSet") })), Symbol.intern(null, "key")), Tuple.create(Symbol.intern(null, "set"), Symbol.intern(null, "key"), Symbol.intern(null, "&"), Symbol.intern(null, "ks")) })), RT.keyword(null, "doc"), "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1518), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__629 = (Var)RT.var("clojure.core", "find");
    const__632 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "map"), Symbol.intern(null, "key")) })), RT.keyword(null, "doc"), "Returns the map entry for key, or nil if key not present.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1534), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__633 = (Var)RT.var("clojure.core", "select-keys");
    const__636 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "map"), Symbol.intern(null, "keyseq")) })), RT.keyword(null, "doc"), "Returns a map containing only those entries in map whose key is in keys", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1540), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__637 = (Var)RT.var("clojure.core", "keys");
    const__640 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "map")) })), RT.keyword(null, "doc"), "Returns a sequence of the map's keys, in the same order as (seq map).", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1555), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__641 = (Var)RT.var("clojure.core", "vals");
    const__644 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "map")) })), RT.keyword(null, "doc"), "Returns a sequence of the map's values, in the same order as (seq map).", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1561), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__645 = (Var)RT.var("clojure.core", "key");
    const__648 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "e")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.Map$Entry") }))) })), RT.keyword(null, "doc"), "Returns the key of the map entry.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1567), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__649 = (Var)RT.var("clojure.core", "val");
    const__652 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "e")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.Map$Entry") }))) })), RT.keyword(null, "doc"), "Returns the value in the map entry.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1574), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__653 = (Var)RT.var("clojure.core", "rseq");
    const__656 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "rev")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Reversible") }))) })), RT.keyword(null, "doc"), "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1581), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__657 = (Var)RT.var("clojure.core", "name");
    const__660 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns the name String of a string, symbol or keyword.", RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(1589), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__661 = (Var)RT.var("clojure.core", "namespace");
    const__664 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "x")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Named") }))) })), RT.keyword(null, "doc"), "Returns the namespace String of a symbol or keyword, or nil if not present.", RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(1597), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__665 = (Var)RT.var("clojure.core", "boolean");
    const__666 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }));
    const__667 = Integer.valueOf(1605);
    const__668 = (Var)RT.var("clojure.core", "ident?");
    const__671 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x is a symbol or keyword", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(1612), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__672 = (Var)RT.var("clojure.core", "simple-ident?");
    const__675 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x is a symbol or keyword without a namespace", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(1617), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__676 = (Var)RT.var("clojure.core", "qualified-ident?");
    const__679 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x is a symbol or keyword with a namespace", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(1622), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__680 = (Var)RT.var("clojure.core", "simple-symbol?");
    const__683 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x is a symbol without a namespace", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(1627), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__684 = (Var)RT.var("clojure.core", "qualified-symbol?");
    const__687 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x is a symbol with a namespace", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(1632), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__688 = (Var)RT.var("clojure.core", "simple-keyword?");
    const__691 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x is a keyword without a namespace", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(1637), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__692 = (Var)RT.var("clojure.core", "qualified-keyword?");
    const__695 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x is a keyword with a namespace", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(1642), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__696 = (Var)RT.var("clojure.core", "locking");
    const__699 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Executes exprs in an implicit do, while holding the monitor of x.\n  Will release the monitor of x in all circumstances.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(1647), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
  }
  
  public static void __init7() {
    const__700 = (Var)RT.var("clojure.core", "..");
    const__703 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "form")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "form"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) })), RT.keyword(null, "doc"), "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n  Expands into a member access (.) of the first member on the first\n  argument, followed by the next member on the result, etc. For\n  instance:\n\n  (.. System (getProperties) (get \"os.name\"))\n\n  expands to:\n\n  (. (. System (getProperties)) (get \"os.name\"))\n\n  but is easier to write, read, and understand.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(1659), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__704 = (Var)RT.var("clojure.core", "->");
    const__707 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "&"), Symbol.intern(null, "forms")) })), RT.keyword(null, "doc"), "Threads the expr through the forms. Inserts x as the\n  second item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  second item in second form, etc.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(1677), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__708 = (Var)RT.var("clojure.core", "->>");
    const__711 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "&"), Symbol.intern(null, "forms")) })), RT.keyword(null, "doc"), "Threads the expr through the forms. Inserts x as the\n  last item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  last item in second form, etc.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "line"), Integer.valueOf(1693), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__712 = (Var)RT.var("clojure.core", "map");
    const__714 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(1709), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__715 = (Var)RT.var("clojure.core", "check-valid-options");
    const__718 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "options"), Symbol.intern(null, "&"), Symbol.intern(null, "valid-keys")) })), RT.keyword(null, "doc"), "Throws an exception if the given option map contains keys not listed\n  as valid, else returns nil.", RT.keyword(null, "line"), Integer.valueOf(1711), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__719 = (Var)RT.var("clojure.core", "global-hierarchy");
    const__721 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(1723), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__722 = (Var)RT.var("clojure.core", "defmulti");
    const__725 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "docstring?"), Symbol.intern(null, "attr-map?"), Symbol.intern(null, "dispatch-fn"), Symbol.intern(null, "&"), Symbol.intern(null, "options")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(1748), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Creates a new multimethod with the associated dispatch function.\n  The docstring and attr-map are optional.\n\n  Options are key-value pairs and may be one of:\n\n  :default\n\n  The default dispatch value, defaults to :default\n\n  :hierarchy\n\n  The value used for hierarchical dispatch (e.g. ::square is-a ::shape)\n\n  Hierarchies are type-like relationships that do not depend upon type\n  inheritance. By default Clojure's multimethods dispatch off of a\n  global hierarchy map.  However, a hierarchy relationship can be\n  created with the derive function used to augment the root ancestor\n  created with make-hierarchy.\n\n  Multimethods expect the value of the hierarchy option to be supplied as\n  a reference type e.g. a var (i.e. via the Var-quote dispatch macro #'\n  or the var special form).", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(1725), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__726 = (Var)RT.var("clojure.core", "defmethod");
    const__729 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "multifn"), Symbol.intern(null, "dispatch-val"), Symbol.intern(null, "&"), Symbol.intern(null, "fn-tail")) })), RT.keyword(null, "doc"), "Creates and installs a new method of multimethod associated with dispatch-value. ", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(1783), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__730 = (Var)RT.var("clojure.core", "remove-all-methods");
    const__733 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "multifn")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.MultiFn") }))) })), RT.keyword(null, "doc"), "Removes all of the methods of multimethod.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1789), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__734 = (Var)RT.var("clojure.core", "remove-method");
    const__737 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "multifn")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.MultiFn") })), Symbol.intern(null, "dispatch-val")) })), RT.keyword(null, "doc"), "Removes the method of multimethod associated with dispatch-value.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1796), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__738 = (Var)RT.var("clojure.core", "prefer-method");
    const__741 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "multifn")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.MultiFn") })), Symbol.intern(null, "dispatch-val-x"), Symbol.intern(null, "dispatch-val-y")) })), RT.keyword(null, "doc"), "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y \n   when there is a conflict", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1803), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__742 = (Var)RT.var("clojure.core", "methods");
    const__745 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "multifn")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.MultiFn") }))) })), RT.keyword(null, "doc"), "Given a multimethod, returns a map of dispatch values -> dispatch fns", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1811), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__746 = (Var)RT.var("clojure.core", "get-method");
    const__749 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "multifn")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.MultiFn") })), Symbol.intern(null, "dispatch-val")) })), RT.keyword(null, "doc"), "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1817), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__750 = (Var)RT.var("clojure.core", "prefers");
    const__753 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "multifn")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.MultiFn") }))) })), RT.keyword(null, "doc"), "Given a multimethod, returns a map of preferred value -> set of other values", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1824), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__754 = (Var)RT.var("clojure.core", "assert-args");
    const__757 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "pairs")) })), RT.keyword(null, "line"), Integer.valueOf(1832), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__758 = (Var)RT.var("clojure.core", "if-let");
    const__761 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "then")), Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "then"), Symbol.intern(null, "else"), Symbol.intern(null, "&"), Symbol.intern(null, "oldform")) })), RT.keyword(null, "doc"), "bindings => binding-form test\n\n  If test is true, evaluates then with binding-form bound to the value of \n  test, if not, yields else", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(1841), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__762 = (Var)RT.var("clojure.core", "when-let");
    const__765 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "bindings => binding-form test\n\n  When test is true, evaluates body with binding-form bound to the value of test", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(1861), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__766 = (Var)RT.var("clojure.core", "if-some");
    const__769 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "then")), Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "then"), Symbol.intern(null, "else"), Symbol.intern(null, "&"), Symbol.intern(null, "oldform")) })), RT.keyword(null, "doc"), "bindings => binding-form test\n\n   If test is not nil, evaluates then with binding-form bound to the\n   value of test, if not, yields else", RT.keyword(null, "added"), "1.6", RT.keyword(null, "line"), Integer.valueOf(1876), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__770 = (Var)RT.var("clojure.core", "when-some");
    const__773 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "bindings => binding-form test\n\n   When test is not nil, evaluates body with binding-form bound to the\n   value of test", RT.keyword(null, "added"), "1.6", RT.keyword(null, "line"), Integer.valueOf(1896), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__774 = (Var)RT.var("clojure.core", "push-thread-bindings");
    const__777 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings")) })), RT.keyword(null, "doc"), "WARNING: This is a low-level function. Prefer high-level macros like\n  binding where ever possible.\n\n  Takes a map of Var/value pairs. Binds each Var to the associated value for\n  the current thread. Each call *MUST* be accompanied by a matching call to\n  pop-thread-bindings wrapped in a try-finally!\n  \n      (push-thread-bindings bindings)\n      (try\n        ...\n        (finally\n          (pop-thread-bindings)))", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1913), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__778 = (Var)RT.var("clojure.core", "pop-thread-bindings");
    const__781 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Pop one set of bindings pushed with push-binding before. It is an error to\n  pop bindings without pushing before.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1931), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__782 = (Var)RT.var("clojure.core", "get-thread-bindings");
    const__785 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Get a map with the Var/value pairs which is currently in effect for the\n  current thread.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1939), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__786 = (Var)RT.var("clojure.core", "binding");
    const__789 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(1947), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__790 = (Var)RT.var("clojure.core", "with-bindings*");
    const__793 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "binding-map"), Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then calls f with the supplied arguments.\n  Pops the installed bindings after f returned. Returns whatever f returns.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1973), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__794 = (Var)RT.var("clojure.core", "with-bindings");
    const__797 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "binding-map"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then executes body. Pops the installed\n  bindings after body was evaluated. Returns the value of body.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "line"), Integer.valueOf(1986), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__798 = (Var)RT.var("clojure.core", "bound-fn*");
  }
  
  public static void __init8() {
    const__801 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Returns a function, which will install the same bindings in effect as in\n  the thread at the time bound-fn* was called and then call f with any given\n  arguments. This may be used to define a helper function which runs on a\n  different thread, but needs the same bindings in place.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1994), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__802 = (Var)RT.var("clojure.core", "bound-fn");
    const__805 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "fntail")) })), RT.keyword(null, "doc"), "Returns a function defined by the given fntail, which will install the\n  same bindings in effect as in the thread at the time bound-fn was called.\n  This may be used to define a helper function which runs on a different\n  thread, but needs the same bindings in place.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "line"), Integer.valueOf(2006), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__806 = (Var)RT.var("clojure.core", "find-var");
    const__809 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sym")) })), RT.keyword(null, "doc"), "Returns the global var named by the namespace-qualified symbol, or\n  nil if no var with that name.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2015), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__810 = (Var)RT.var("clojure.core", "binding-conveyor-fn");
    const__813 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")) })), RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "added"), "1.3", RT.keyword(null, "line"), Integer.valueOf(2022), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__814 = (Var)RT.var("clojure.core", "setup-reference");
    const__817 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "r")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.ARef") })), Symbol.intern(null, "options")) })), RT.keyword(null, "line"), Integer.valueOf(2045), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__818 = (Var)RT.var("clojure.core", "agent");
    const__821 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "state"), Symbol.intern(null, "&"), Symbol.intern(null, "options")) })), RT.keyword(null, "doc"), "Creates and returns an agent with an initial value of state and\n  zero or more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :error-handler handler-fn\n\n  :error-mode mode-keyword\n\n  If metadata-map is supplied, it will become the metadata on the\n  agent. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.  handler-fn is called if an\n  action throws an exception or if validate-fn rejects a new state --\n  see set-error-handler! for details.  The mode-keyword may be either\n  :continue (the default if an error-handler is given) or :fail (the\n  default if no error-handler is given) -- see set-error-mode! for\n  details.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2054), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__822 = (Var)RT.var("clojure.core", "set-agent-send-executor!");
    const__825 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "executor")) })), RT.keyword(null, "doc"), "Sets the ExecutorService to be used by send", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(2089), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__826 = (Var)RT.var("clojure.core", "set-agent-send-off-executor!");
    const__829 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "executor")) })), RT.keyword(null, "doc"), "Sets the ExecutorService to be used by send-off", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(2095), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__830 = (Var)RT.var("clojure.core", "send-via");
    const__833 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "executor"), ((IObj)Symbol.intern(null, "a")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Agent") })), Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread supplied by executor, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(2101), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__834 = (Var)RT.var("clojure.core", "send");
    const__837 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "a")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Agent") })), Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread from a thread pool, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2111), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__838 = (Var)RT.var("clojure.core", "send-off");
    const__841 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "a")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Agent") })), Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Dispatch a potentially blocking action to an agent. Returns the\n  agent immediately. Subsequently, in a separate thread, the state of\n  the agent will be set to the value of:\n\n  (apply action-fn state-of-agent args)", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2122), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__842 = (Var)RT.var("clojure.core", "release-pending-sends");
    const__845 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Normally, actions sent directly or indirectly during another action\n  are held until the action completes (changes the agent's\n  state). This function can be used to dispatch any pending sent\n  actions immediately. This has no impact on actions sent during a\n  transaction, which are still held until commit. If no action is\n  occurring, does nothing. Returns the number of actions dispatched.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2133), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__846 = (Var)RT.var("clojure.core", "add-watch");
    const__849 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "reference")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IRef") })), Symbol.intern(null, "key"), Symbol.intern(null, "fn")) })), RT.keyword(null, "doc"), "Adds a watch function to an agent/atom/var/ref reference. The watch\n  fn must be a fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch fn\n  will be called synchronously, on the agent's thread if an agent,\n  before any pending sends if agent or ref. Note that an atom's or\n  ref's state may have changed again prior to the fn call, so use\n  old/new-state rather than derefing the reference. Note also that watch\n  fns may be called from multiple threads simultaneously. Var watchers\n  are triggered only by root binding changes, not thread-local\n  set!s. Keys must be unique per reference, and can be used to remove\n  the watch with remove-watch, but are otherwise considered opaque by\n  the watch mechanism.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2144), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__850 = (Var)RT.var("clojure.core", "remove-watch");
    const__853 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "reference")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IRef") })), Symbol.intern(null, "key")) })), RT.keyword(null, "doc"), "Removes a watch (set by add-watch) from a reference", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2162), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__854 = (Var)RT.var("clojure.core", "agent-error");
    const__857 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "a")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Agent") }))) })), RT.keyword(null, "doc"), "Returns the exception thrown during an asynchronous action of the\n  agent if the agent is failed.  Returns nil if the agent is not\n  failed.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2169), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__858 = (Var)RT.var("clojure.core", "restart-agent");
    const__861 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "a")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Agent") })), Symbol.intern(null, "new-state"), Symbol.intern(null, "&"), Symbol.intern(null, "options")) })), RT.keyword(null, "doc"), "When an agent is failed, changes the agent state to new-state and\n  then un-fails the agent so that sends are allowed again.  If\n  a :clear-actions true option is given, any actions queued on the\n  agent that were being held while it was failed will be discarded,\n  otherwise those held actions will proceed.  The new-state must pass\n  the validator if any, or restart will throw an exception and the\n  agent will remain failed with its old state and error.  Watchers, if\n  any, will NOT be notified of the new state.  Throws an exception if\n  the agent is not failed.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2177), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__862 = (Var)RT.var("clojure.core", "set-error-handler!");
    const__865 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "a")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Agent") })), Symbol.intern(null, "handler-fn")) })), RT.keyword(null, "doc"), "Sets the error-handler of agent a to handler-fn.  If an action\n  being run by the agent throws an exception or doesn't pass the\n  validator fn, handler-fn will be called with two arguments: the\n  agent and the exception.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2194), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__866 = (Var)RT.var("clojure.core", "error-handler");
    const__869 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "a")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Agent") }))) })), RT.keyword(null, "doc"), "Returns the error-handler of agent a, or nil if there is none.\n  See set-error-handler!", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2204), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__870 = (Var)RT.var("clojure.core", "set-error-mode!");
    const__873 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "a")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Agent") })), Symbol.intern(null, "mode-keyword")) })), RT.keyword(null, "doc"), "Sets the error-mode of agent a to mode-keyword, which must be\n  either :fail or :continue.  If an action being run by the agent\n  throws an exception or doesn't pass the validator fn, an\n  error-handler may be called (see set-error-handler!), after which,\n  if the mode is :continue, the agent will continue as if neither the\n  action that caused the error nor the error itself ever happened.\n  \n  If the mode is :fail, the agent will become failed and will stop\n  accepting new 'send' and 'send-off' actions, and any previously\n  queued actions will be held until a 'restart-agent'.  Deref will\n  still work, returning the state of the agent before the error.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2212), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__874 = (Var)RT.var("clojure.core", "error-mode");
    const__877 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "a")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Agent") }))) })), RT.keyword(null, "doc"), "Returns the error-mode of agent a.  See set-error-mode!", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2229), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__878 = (Var)RT.var("clojure.core", "agent-errors");
    const__882 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "a")) })), RT.keyword(null, "doc"), "DEPRECATED: Use 'agent-error' instead.\n  Returns a sequence of the exceptions thrown during asynchronous\n  actions of the agent.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "deprecated"), "1.2", RT.keyword(null, "line"), Integer.valueOf(2236), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__883 = (Var)RT.var("clojure.core", "clear-agent-errors");
    const__886 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "a")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Agent") }))) })), RT.keyword(null, "doc"), "DEPRECATED: Use 'restart-agent' instead.\n  Clears any exceptions thrown during asynchronous actions of the\n  agent, allowing subsequent actions to occur.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "deprecated"), "1.2", RT.keyword(null, "line"), Integer.valueOf(2246), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__887 = (Var)RT.var("clojure.core", "shutdown-agents");
    const__890 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Initiates a shutdown of the thread pools that back the agent\n  system. Running actions will complete, but no new actions will be\n  accepted", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2254), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__891 = (Var)RT.var("clojure.core", "ref");
    const__894 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "&"), Symbol.intern(null, "options")) })), RT.keyword(null, "doc"), "Creates and returns a Ref with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :min-history (default 0)\n  :max-history (default 10)\n\n  If metadata-map is supplied, it will become the metadata on the\n  ref. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception. validate-fn will be called on\n  transaction commit, when all refs have their final values.\n\n  Normally refs accumulate history dynamically as needed to deal with\n  read demands. If you know in advance you will need history you can\n  set :min-history to ensure it will be available when first needed (instead\n  of after a read fault). History is limited, and the limit can be set\n  with :max-history.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2262), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__895 = (Var)RT.var("clojure.core", "deref-future");
    const__898 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "fut")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.concurrent.Future") }))), Tuple.create(((IObj)Symbol.intern(null, "fut")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.concurrent.Future") })), Symbol.intern(null, "timeout-ms"), Symbol.intern(null, "timeout-val")) })), RT.keyword(null, "line"), Integer.valueOf(2298), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__899 = (Var)RT.var("clojure.core", "deref");
  }
  
  public static void __init9() {
    const__902 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ref")), Tuple.create(Symbol.intern(null, "ref"), Symbol.intern(null, "timeout-ms"), Symbol.intern(null, "timeout-val")) })), RT.keyword(null, "doc"), "Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,\n  returns the in-transaction-value of ref, else returns the\n  most-recently-committed value of ref. When applied to a var, agent\n  or atom, returns its current state. When applied to a delay, forces\n  it if not already forced. When applied to a future, will block if\n  computation not complete. When applied to a promise, will block\n  until a value is delivered.  The variant taking a timeout can be\n  used for blocking references (futures and promises), and will return\n  timeout-val if the timeout (in milliseconds) is reached before a\n  value is available. See also - realized?.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2306), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__903 = (Var)RT.var("clojure.core", "atom");
    const__906 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "&"), Symbol.intern(null, "options")) })), RT.keyword(null, "doc"), "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will become the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2327), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__907 = (Var)RT.var("clojure.core", "swap!");
    const__910 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "atom")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IAtom") })), Symbol.intern(null, "f")), Tuple.create(((IObj)Symbol.intern(null, "atom")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IAtom") })), Symbol.intern(null, "f"), Symbol.intern(null, "x")), Tuple.create(((IObj)Symbol.intern(null, "atom")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IAtom") })), Symbol.intern(null, "f"), Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(((IObj)Symbol.intern(null, "atom")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IAtom") })), Symbol.intern(null, "f"), Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2345), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__911 = (Var)RT.var("clojure.core", "swap-vals!");
    const__914 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(((IObj)Symbol.intern(null, "atom")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IAtom2") })), Symbol.intern(null, "f"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IPersistentVector") })), ((IObj)Tuple.create(((IObj)Symbol.intern(null, "atom")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IAtom2") })), Symbol.intern(null, "f"), Symbol.intern(null, "x"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IPersistentVector") })), ((IObj)Tuple.create(((IObj)Symbol.intern(null, "atom")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IAtom2") })), Symbol.intern(null, "f"), Symbol.intern(null, "x"), Symbol.intern(null, "y"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IPersistentVector") })), ((IObj)Tuple.create(((IObj)Symbol.intern(null, "atom")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IAtom2") })), Symbol.intern(null, "f"), Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "args"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IPersistentVector") })) })), RT.keyword(null, "doc"), "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(2357), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__915 = (Var)RT.var("clojure.core", "compare-and-set!");
    const__918 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "atom")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IAtom") })), Symbol.intern(null, "oldval"), Symbol.intern(null, "newval")) })), RT.keyword(null, "doc"), "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is identical to oldval. Returns true if\n  set happened, else false", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2368), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__919 = (Var)RT.var("clojure.core", "reset!");
    const__922 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "atom")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IAtom") })), Symbol.intern(null, "newval")) })), RT.keyword(null, "doc"), "Sets the value of atom to newval without regard for the\n  current value. Returns newval.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2376), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__923 = (Var)RT.var("clojure.core", "reset-vals!");
    const__926 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(((IObj)Symbol.intern(null, "atom")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IAtom2") })), Symbol.intern(null, "newval"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IPersistentVector") })) })), RT.keyword(null, "doc"), "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(2383), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__927 = (Var)RT.var("clojure.core", "set-validator!");
    const__930 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "iref")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IRef") })), Symbol.intern(null, "validator-fn")) })), RT.keyword(null, "doc"), "Sets the validator-fn for a var/ref/agent/atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an exception. If the current state (root\n  value if var) is not acceptable to the new validator, an exception\n  will be thrown and the validator will not be changed.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2389), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__931 = (Var)RT.var("clojure.core", "get-validator");
    const__934 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "iref")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IRef") }))) })), RT.keyword(null, "doc"), "Gets the validator-fn for a var/ref/agent/atom.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2400), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__935 = (Var)RT.var("clojure.core", "alter-meta!");
    const__938 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "iref")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IReference") })), Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2406), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__939 = (Var)RT.var("clojure.core", "reset-meta!");
    const__942 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "iref")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IReference") })), Symbol.intern(null, "metadata-map")) })), RT.keyword(null, "doc"), "Atomically resets the metadata for a namespace/var/ref/agent/atom", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2416), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__943 = (Var)RT.var("clojure.core", "commute");
    const__946 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "ref")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Ref") })), Symbol.intern(null, "fun"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.\n\n  At the commit point of the transaction, sets the value of ref to be:\n\n  (apply fun most-recently-committed-value-of-ref args)\n\n  Thus fun should be commutative, or, failing that, you must accept\n  last-one-in-wins behavior.  commute allows for more concurrency than\n  ref-set.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2422), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__947 = (Var)RT.var("clojure.core", "alter");
    const__950 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "ref")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Ref") })), Symbol.intern(null, "fun"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2443), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__951 = (Var)RT.var("clojure.core", "ref-set");
    const__954 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "ref")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Ref") })), Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "Must be called in a transaction. Sets the value of ref.\n  Returns val.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2455), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__955 = (Var)RT.var("clojure.core", "ref-history-count");
    const__958 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "ref")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Ref") }))) })), RT.keyword(null, "doc"), "Returns the history count of a ref", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2463), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__959 = (Var)RT.var("clojure.core", "ref-min-history");
    const__962 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "ref")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Ref") }))), Tuple.create(((IObj)Symbol.intern(null, "ref")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Ref") })), Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Gets the min-history of a ref, or sets it and returns the ref", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2470), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__963 = (Var)RT.var("clojure.core", "ref-max-history");
    const__966 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "ref")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Ref") }))), Tuple.create(((IObj)Symbol.intern(null, "ref")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Ref") })), Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Gets the max-history of a ref, or sets it and returns the ref", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2479), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__967 = (Var)RT.var("clojure.core", "ensure");
    const__970 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "ref")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Ref") }))) })), RT.keyword(null, "doc"), "Must be called in a transaction. Protects the ref from modification\n  by other transactions.  Returns the in-transaction-value of\n  ref. Allows for more concurrency than (ref-set ref @ref)", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2488), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__971 = (Var)RT.var("clojure.core", "sync");
    const__974 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "flags-ignored-for-now"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "transaction-flags => TBD, pass nil for now\n\n  Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of sync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(2498), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__975 = (Var)RT.var("clojure.core", "io!");
    const__978 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "If an io! block occurs in a transaction, throws an\n  IllegalStateException, else runs body in an implicit do. If the\n  first expression in body is a literal string, will use that as the\n  exception message.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(2512), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__979 = (Var)RT.var("clojure.core", "volatile!");
    const__983 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "Creates and returns a Volatile with an initial value of val.", RT.keyword(null, "added"), "1.7", RT.keyword(null, "tag"), RT.classForName("clojure.lang.Volatile"), RT.keyword(null, "line"), Integer.valueOf(2525), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__984 = (Var)RT.var("clojure.core", "vreset!");
    const__987 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "vol")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Volatile") })), Symbol.intern(null, "newval")) })), RT.keyword(null, "doc"), "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", RT.keyword(null, "added"), "1.7", RT.keyword(null, "line"), Integer.valueOf(2532), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__988 = (Var)RT.var("clojure.core", "vswap!");
    const__991 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "vol"), Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in.", RT.keyword(null, "added"), "1.7", RT.keyword(null, "line"), Integer.valueOf(2539), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__992 = (Var)RT.var("clojure.core", "volatile?");
    const__995 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x is a volatile.", RT.keyword(null, "added"), "1.7", RT.keyword(null, "line"), Integer.valueOf(2548), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__996 = (Var)RT.var("clojure.core", "comp");
    const__999 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "g")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "g"), Symbol.intern(null, "&"), Symbol.intern(null, "fs")) })), RT.keyword(null, "doc"), "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2557), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
  }
  
  public static void __init10() {
    const__1000 = (Var)RT.var("clojure.core", "juxt");
    const__1003 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "g")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "g"), Symbol.intern(null, "h")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "g"), Symbol.intern(null, "h"), Symbol.intern(null, "&"), Symbol.intern(null, "fs")) })), RT.keyword(null, "doc"), "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2576), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1004 = (Var)RT.var("clojure.core", "partial");
    const__1007 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "arg1")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "arg1"), Symbol.intern(null, "arg2")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "arg1"), Symbol.intern(null, "arg2"), Symbol.intern(null, "arg3")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "arg1"), Symbol.intern(null, "arg2"), Symbol.intern(null, "arg3"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) })), RT.keyword(null, "doc"), "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2614), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1008 = (Var)RT.var("clojure.core", "sequence");
    const__1011 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "xform"), Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "xform"), Symbol.intern(null, "coll"), Symbol.intern(null, "&"), Symbol.intern(null, "colls")) })), RT.keyword(null, "doc"), "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2647), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1012 = (Var)RT.var("clojure.core", "every?");
    const__1015 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns true if (pred x) is logical true for every x in coll, else\n  false.", RT.keyword(null, "tag"), RT.classForName("java.lang.Boolean"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(2672), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1016 = (Var)RT.var("clojure.core", "not-every?");
    const__1019 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.Boolean"), RT.keyword(null, "doc"), "Returns false if (pred x) is logical true for every x in\n  coll, else true.", RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "coll")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(2688), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(2684), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1020 = (Var)RT.var("clojure.core", "some");
    const__1023 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2692), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1024 = (Var)RT.var("clojure.core", "not-any?");
    const__1027 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.Boolean"), RT.keyword(null, "doc"), "Returns false if (pred x) is logical true for any x in coll,\n  else true.", RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "coll")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(2707), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(2703), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1028 = (Var)RT.var("clojure.core", "dotimes");
    const__1031 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(2712), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1034 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "c1"), Symbol.intern(null, "c2")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "c1"), Symbol.intern(null, "c2"), Symbol.intern(null, "c3")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "c1"), Symbol.intern(null, "c2"), Symbol.intern(null, "c3"), Symbol.intern(null, "&"), Symbol.intern(null, "colls")) })), RT.keyword(null, "doc"), "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2727), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1035 = (Var)RT.var("clojure.core", "declare");
    const__1038 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "names")) })), RT.keyword(null, "doc"), "defs the supplied var names with no bindings, useful for making forward declarations.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(2776), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1039 = (Var)RT.var("clojure.core", "cat");
    const__1042 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2781), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1043 = (Var)RT.var("clojure.core", "mapcat");
    const__1046 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "colls")) })), RT.keyword(null, "doc"), "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2783), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1047 = (Var)RT.var("clojure.core", "filter");
    const__1050 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred")), Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2793), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1051 = (Var)RT.var("clojure.core", "remove");
    const__1054 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred")), Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2826), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1055 = (Var)RT.var("clojure.core", "reduced");
    const__1058 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Wraps x in a way such that a reduce will terminate with the value x", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(2836), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1059 = (Var)RT.var("clojure.core", "reduced?");
    const__1060 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }));
    const__1062 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(1L) });
    const__1063 = Integer.valueOf(2842);
    const__1064 = (Var)RT.var("clojure.core", "ensure-reduced");
    const__1067 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "If x is already reduced?, returns it, else returns (reduced x)", RT.keyword(null, "added"), "1.7", RT.keyword(null, "line"), Integer.valueOf(2849), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1068 = (Var)RT.var("clojure.core", "unreduced");
    const__1071 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "If x is reduced?, returns (deref x), else returns x", RT.keyword(null, "added"), "1.7", RT.keyword(null, "line"), Integer.valueOf(2855), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1072 = (Var)RT.var("clojure.core", "take");
    const__1075 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2861), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1076 = (Var)RT.var("clojure.core", "take-while");
    const__1079 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred")), Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a lazy sequence of successive items from coll while\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2888), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1080 = (Var)RT.var("clojure.core", "drop");
    const__1083 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2909), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1084 = (Var)RT.var("clojure.core", "drop-last");
    const__1087 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Return a lazy sequence of all but the last n (default 1) items in coll", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2934), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1088 = (Var)RT.var("clojure.core", "take-last");
    const__1091 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2941), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1092 = (Var)RT.var("clojure.core", "drop-while");
    const__1095 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred")), Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2952), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1096 = (Var)RT.var("clojure.core", "cycle");
    const__1099 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2979), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
  }
  
  public static void __init11() {
    const__1100 = (Var)RT.var("clojure.core", "split-at");
    const__1103 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a vector of [(take n coll) (drop n coll)]", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2985), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1104 = (Var)RT.var("clojure.core", "split-with");
    const__1107 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a vector of [(take-while pred coll) (drop-while pred coll)]", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2992), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1108 = (Var)RT.var("clojure.core", "repeat");
    const__1111 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(2999), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1112 = (Var)RT.var("clojure.core", "replicate");
    const__1115 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "DEPRECATED: Use 'repeat' instead.\n   Returns a lazy seq of n xs.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "deprecated"), "1.3", RT.keyword(null, "line"), Integer.valueOf(3006), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1116 = (Var)RT.var("clojure.core", "iterate");
    const__1119 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3013), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1120 = (Var)RT.var("clojure.core", "range");
    const__1123 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "end")), Tuple.create(Symbol.intern(null, "start"), Symbol.intern(null, "end")), Tuple.create(Symbol.intern(null, "start"), Symbol.intern(null, "end"), Symbol.intern(null, "step")) })), RT.keyword(null, "doc"), "Returns a lazy seq of nums from start (inclusive) to end\n  (exclusive), by step, where start defaults to 0, step to 1, and end to\n  infinity. When step is equal to 0, returns an infinite sequence of\n  start. When start is equal to end, returns empty list.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3019), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1124 = (Var)RT.var("clojure.core", "merge");
    const__1127 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "maps")) })), RT.keyword(null, "doc"), "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3041), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1128 = (Var)RT.var("clojure.core", "merge-with");
    const__1131 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "maps")) })), RT.keyword(null, "doc"), "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3051), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1132 = (Var)RT.var("clojure.core", "zipmap");
    const__1135 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "keys"), Symbol.intern(null, "vals")) })), RT.keyword(null, "doc"), "Returns a map with the keys mapped to the corresponding vals.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3071), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1136 = (Var)RT.var("clojure.core", "line-seq");
    const__1139 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "rdr")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.io.BufferedReader") }))) })), RT.keyword(null, "doc"), "Returns the lines of text from rdr as a lazy sequence of strings.\n  rdr must implement java.io.BufferedReader.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3085), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1140 = (Var)RT.var("clojure.core", "comparator");
    const__1143 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred")) })), RT.keyword(null, "doc"), "Returns an implementation of java.util.Comparator based upon pred.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3094), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1144 = (Var)RT.var("clojure.core", "sort");
    const__1147 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")), Tuple.create(((IObj)Symbol.intern(null, "comp")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.Comparator") })), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a sorted sequence of the items in coll. If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\n  not be reordered.  If coll is a Java array, it will be modified.  To\n  avoid this, sort a copy of the array.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3102), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1148 = (Var)RT.var("clojure.core", "sort-by");
    const__1151 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "keyfn"), Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "keyfn"), ((IObj)Symbol.intern(null, "comp")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.Comparator") })), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a sorted sequence of the items in coll, where the sort\n  order is determined by comparing (keyfn item).  If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\n  not be reordered.  If coll is a Java array, it will be modified.  To\n  avoid this, sort a copy of the array.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3119), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1152 = (Var)RT.var("clojure.core", "dorun");
    const__1155 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3133), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1156 = (Var)RT.var("clojure.core", "doall");
    const__1159 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3148), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1160 = (Var)RT.var("clojure.core", "nthnext");
    const__1163 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Returns the nth next of coll, (seq coll) when n is 0.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3164), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1164 = (Var)RT.var("clojure.core", "nthrest");
    const__1167 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Returns the nth rest of coll, coll when n is 0.", RT.keyword(null, "added"), "1.3", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3174), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1168 = (Var)RT.var("clojure.core", "partition");
    const__1171 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "step"), Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "step"), Symbol.intern(null, "pad"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition upto n items. In case there are\n  not enough padding elements, return a partition with less than n items.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3184), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1172 = (Var)RT.var("clojure.core", "eval");
    const__1175 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Evaluates the form data structure (not text!) and returns the result.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3210), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1176 = (Var)RT.var("clojure.core", "doseq");
    const__1179 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "seq-exprs"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(3216), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1180 = (Var)RT.var("clojure.core", "await");
    const__1183 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "agents")) })), RT.keyword(null, "doc"), "Blocks the current thread (indefinitely!) until all actions\n  dispatched thus far, from this thread or agent, to the agent(s) have\n  occurred.  Will block on failed agents.  Will never return if\n  a failed agent is restarted with :clear-actions true or shutdown-agents was called.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3274), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1184 = (Var)RT.var("clojure.core", "await1");
    const__1187 = (AFn)RT.map(new Object[] { RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "a")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Agent") }))) })), RT.keyword(null, "line"), Integer.valueOf(3291), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1188 = (Var)RT.var("clojure.core", "await-for");
    const__1191 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "timeout-ms"), Symbol.intern(null, "&"), Symbol.intern(null, "agents")) })), RT.keyword(null, "doc"), "Blocks the current thread until all actions dispatched thus\n  far (from this thread or agent) to the agents have occurred, or the\n  timeout (in milliseconds) has elapsed. Returns logical false if\n  returning due to timeout, logical true otherwise.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3296), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1194 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(3313), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1195 = (Var)RT.var("clojure.core", "transient");
    const__1198 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "coll")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IEditableCollection") }))) })), RT.keyword(null, "doc"), "Returns a new, transient version of the collection, in constant time.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3342), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1199 = (Var)RT.var("clojure.core", "persistent!");
  }
  
  public static void __init12() {
    const__1202 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "coll")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.ITransientCollection") }))) })), RT.keyword(null, "doc"), "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3349), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1203 = (Var)RT.var("clojure.core", "conj!");
    const__1206 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "coll")), Tuple.create(((IObj)Symbol.intern(null, "coll")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.ITransientCollection") })), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3358), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1207 = (Var)RT.var("clojure.core", "assoc!");
    const__1210 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "coll")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.ITransientAssociative") })), Symbol.intern(null, "key"), Symbol.intern(null, "val")), Tuple.create(((IObj)Symbol.intern(null, "coll")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.ITransientAssociative") })), Symbol.intern(null, "key"), Symbol.intern(null, "val"), Symbol.intern(null, "&"), Symbol.intern(null, "kvs")) })), RT.keyword(null, "doc"), "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3368), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1211 = (Var)RT.var("clojure.core", "dissoc!");
    const__1214 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "map")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.ITransientMap") })), Symbol.intern(null, "key")), Tuple.create(((IObj)Symbol.intern(null, "map")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.ITransientMap") })), Symbol.intern(null, "key"), Symbol.intern(null, "&"), Symbol.intern(null, "ks")) })), RT.keyword(null, "doc"), "Returns a transient map that doesn't contain a mapping for key(s).", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3381), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1215 = (Var)RT.var("clojure.core", "pop!");
    const__1218 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "coll")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.ITransientVector") }))) })), RT.keyword(null, "doc"), "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3392), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1219 = (Var)RT.var("clojure.core", "disj!");
    const__1222 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "set")), Tuple.create(((IObj)Symbol.intern(null, "set")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.ITransientSet") })), Symbol.intern(null, "key")), Tuple.create(((IObj)Symbol.intern(null, "set")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.ITransientSet") })), Symbol.intern(null, "key"), Symbol.intern(null, "&"), Symbol.intern(null, "ks")) })), RT.keyword(null, "doc"), "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3400), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1223 = (Var)RT.var("clojure.core", "into1");
    const__1226 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "to"), Symbol.intern(null, "from")) })), RT.keyword(null, "doc"), "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(3415), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1227 = (Var)RT.var("clojure.core", "import");
    const__1230 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "import-symbols-or-lists")) })), RT.keyword(null, "doc"), "import-list => (package-symbol class-name-symbols*)\n\n  For each name in class-name-symbols, adds a mapping from name to the\n  class named by package.name to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(3425), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1231 = (Var)RT.var("clojure.core", "into-array");
    const__1234 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "aseq")), Tuple.create(Symbol.intern(null, "type"), Symbol.intern(null, "aseq")) })), RT.keyword(null, "doc"), "Returns an array with components set to the values in aseq. The array's\n  component type is type if provided, or the type of the first value in\n  aseq if present, or Object. All values in aseq must be compatible with\n  the component type. Class objects for the primitive types can be obtained\n  using, e.g., Integer/TYPE.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3443), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1235 = (Var)RT.var("clojure.core", "array");
    const__1238 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "items")) })), RT.keyword(null, "line"), Integer.valueOf(3456), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1239 = (Var)RT.var("clojure.core", "class");
    const__1242 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(((IObj)Symbol.intern(null, "x")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Object") })))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.lang.Class") })) })), RT.keyword(null, "doc"), "Returns the Class of x", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3460), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1243 = (Var)RT.var("clojure.core", "type");
    const__1246 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns the :type metadata of x, or its Class if none", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3466), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1247 = (Var)RT.var("clojure.core", "num");
    const__1248 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }));
    const__1249 = RT.classForName("java.lang.Number");
    const__1250 = Integer.valueOf(3473);
    const__1251 = (Var)RT.var("clojure.core", "long");
    const__1252 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "x")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Number") }))) }));
    const__1253 = Integer.valueOf(3480);
    const__1254 = (Var)RT.var("clojure.core", "float");
    const__1255 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "x")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Number") }))) }));
    const__1256 = Integer.valueOf(3486);
    const__1257 = (Var)RT.var("clojure.core", "double");
    const__1258 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "x")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Number") }))) }));
    const__1259 = Integer.valueOf(3492);
    const__1260 = (Var)RT.var("clojure.core", "short");
    const__1261 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "x")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Number") }))) }));
    const__1262 = Integer.valueOf(3498);
    const__1263 = (Var)RT.var("clojure.core", "byte");
    const__1264 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "x")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Number") }))) }));
    const__1265 = Integer.valueOf(3504);
    const__1266 = (Var)RT.var("clojure.core", "char");
    const__1267 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }));
    const__1268 = Integer.valueOf(3510);
    const__1269 = (Var)RT.var("clojure.core", "unchecked-byte");
    const__1270 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "x")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Number") }))) }));
    const__1271 = Integer.valueOf(3516);
    const__1272 = (Var)RT.var("clojure.core", "unchecked-short");
    const__1273 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "x")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Number") }))) }));
    const__1274 = Integer.valueOf(3522);
    const__1275 = (Var)RT.var("clojure.core", "unchecked-char");
    const__1276 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) }));
    const__1277 = Integer.valueOf(3528);
    const__1278 = (Var)RT.var("clojure.core", "unchecked-int");
    const__1279 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "x")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Number") }))) }));
    const__1280 = Integer.valueOf(3534);
    const__1281 = (Var)RT.var("clojure.core", "unchecked-long");
    const__1282 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "x")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Number") }))) }));
    const__1283 = Integer.valueOf(3540);
    const__1284 = (Var)RT.var("clojure.core", "unchecked-float");
    const__1285 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "x")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Number") }))) }));
    const__1286 = Integer.valueOf(3546);
    const__1287 = (Var)RT.var("clojure.core", "unchecked-double");
    const__1288 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "x")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Number") }))) }));
    const__1289 = Integer.valueOf(3552);
    const__1290 = (Var)RT.var("clojure.core", "number?");
    const__1293 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x is a Number", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3559), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1294 = (Var)RT.var("clojure.core", "mod");
    const__1297 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "num"), Symbol.intern(null, "div")) })), RT.keyword(null, "doc"), "Modulus of num and div. Truncates toward negative infinity.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3566), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1298 = (Var)RT.var("clojure.core", "ratio?");
  }
  
  public static void __init13() {
    const__1301 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Returns true if n is a Ratio", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3576), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1302 = (Var)RT.var("clojure.core", "numerator");
    const__1306 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "r")) })), RT.keyword(null, "doc"), "Returns the numerator part of a Ratio.", RT.keyword(null, "tag"), RT.classForName("java.math.BigInteger"), RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(3582), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1307 = (Var)RT.var("clojure.core", "denominator");
    const__1310 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "r")) })), RT.keyword(null, "doc"), "Returns the denominator part of a Ratio.", RT.keyword(null, "tag"), RT.classForName("java.math.BigInteger"), RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(3590), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1311 = (Var)RT.var("clojure.core", "decimal?");
    const__1314 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Returns true if n is a BigDecimal", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3598), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1315 = (Var)RT.var("clojure.core", "float?");
    const__1318 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Returns true if n is a floating point number", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3604), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1319 = (Var)RT.var("clojure.core", "rational?");
    const__1322 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Returns true if n is a rational number", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3612), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1323 = (Var)RT.var("clojure.core", "bigint");
    const__1327 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Coerce to BigInt", RT.keyword(null, "tag"), RT.classForName("clojure.lang.BigInt"), RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "added"), "1.3", 
          RT.keyword(null, "line"), Integer.valueOf(3619), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1328 = (Var)RT.var("clojure.core", "biginteger");
    const__1331 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Coerce to BigInteger", RT.keyword(null, "tag"), RT.classForName("java.math.BigInteger"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(3633), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1332 = (Var)RT.var("clojure.core", "bigdec");
    const__1336 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Coerce to BigDecimal", RT.keyword(null, "tag"), RT.classForName("java.math.BigDecimal"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(3647), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1337 = (Var)RT.var("clojure.core", "print-initialized");
    const__1339 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3661), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1340 = (Var)RT.var("clojure.core", "pr-on");
    const__1343 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "w")) })), RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3668), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1344 = (Var)RT.var("clojure.core", "pr");
    const__1347 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) })), RT.keyword(null, "doc"), "Prints the object(s) to the output stream that is the current value\n  of *out*.  Prints the object(s), separated by spaces if there is\n  more than one.  By default, pr and prn print in a way that objects\n  can be read by the reader", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(3677), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1348 = (Var)RT.var("clojure.core", "system-newline");
    const__1350 = (AFn)RT.map(new Object[] { RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3694), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1351 = (Var)RT.var("clojure.core", "newline");
    const__1354 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Writes a platform-specific newline to *out*", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3697), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1355 = (Var)RT.var("clojure.core", "flush");
    const__1358 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Flushes the output stream that is the current value of\n  *out*", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3705), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1359 = (Var)RT.var("clojure.core", "prn");
    const__1362 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "more")) })), RT.keyword(null, "doc"), "Same as pr followed by (newline). Observes *flush-on-newline*", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3714), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1363 = (Var)RT.var("clojure.core", "print");
    const__1366 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "more")) })), RT.keyword(null, "doc"), "Prints the object(s) to the output stream that is the current value\n  of *out*.  print and println produce output for human consumption.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3724), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1367 = (Var)RT.var("clojure.core", "println");
    const__1370 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "more")) })), RT.keyword(null, "doc"), "Same as print followed by (newline)", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3733), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1371 = (Var)RT.var("clojure.core", "read");
    const__1374 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "stream")), Tuple.create(Symbol.intern(null, "stream"), Symbol.intern(null, "eof-error?"), Symbol.intern(null, "eof-value")), Tuple.create(Symbol.intern(null, "stream"), Symbol.intern(null, "eof-error?"), Symbol.intern(null, "eof-value"), Symbol.intern(null, "recursive?")), Tuple.create(Symbol.intern(null, "opts"), Symbol.intern(null, "stream")) })), RT.keyword(null, "doc"), "Reads the next object from stream, which must be an instance of\n  java.io.PushbackReader or some derivee.  stream defaults to the\n  current value of *in*.\n\n  Opts is a persistent map with valid keys:\n    :read-cond - :allow to process reader conditionals, or\n                 :preserve to keep all branches\n    :features - persistent set of feature keywords for reader conditionals\n    :eof - on eof, return value unless :eofthrow, then throw.\n           if not specified, will throw\n\n  Note that read can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use clojure.edn/read", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3741), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1375 = (Var)RT.var("clojure.core", "read+string");
    const__1378 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "stream")), Tuple.create(Symbol.intern(null, "stream"), Symbol.intern(null, "eof-error?"), Symbol.intern(null, "eof-value")), Tuple.create(((IObj)Symbol.intern(null, "stream")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.LineNumberingPushbackReader") })), Symbol.intern(null, "eof-error?"), Symbol.intern(null, "eof-value"), Symbol.intern(null, "recursive?")), Tuple.create(Symbol.intern(null, "opts"), ((IObj)Symbol.intern(null, "stream")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.LineNumberingPushbackReader") }))) })), RT.keyword(null, "doc"), "Like read, and taking the same args. stream must be a LineNumberingPushbackReader.\n  Returns a vector containing the object read and the (whitespace-trimmed) string read.", RT.keyword(null, "added"), "1.10", RT.keyword(null, "line"), Integer.valueOf(3770), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1379 = (Var)RT.var("clojure.core", "read-line");
    const__1382 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Reads the next line from stream that is the current value of *in* .", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3796), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1383 = (Var)RT.var("clojure.core", "read-string");
    const__1386 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")), Tuple.create(Symbol.intern(null, "opts"), Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Reads one object from the string s. Optionally include reader\n  options, as specified in read.\n\n  Note that read-string can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use clojure.edn/read-string", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3805), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1387 = (Var)RT.var("clojure.core", "subvec");
    const__1390 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "v"), Symbol.intern(null, "start")), Tuple.create(Symbol.intern(null, "v"), Symbol.intern(null, "start"), Symbol.intern(null, "end")) })), RT.keyword(null, "doc"), "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3818), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1391 = (Var)RT.var("clojure.core", "with-open");
    const__1394 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "bindings => [name init ...]\n\n  Evaluates body in a try expression with names bound to the values\n  of the inits, and a finally clause that calls (.close name) on each\n  name in reverse order.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(3831), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1395 = (Var)RT.var("clojure.core", "doto");
    const__1398 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "&"), Symbol.intern(null, "forms")) })), RT.keyword(null, "doc"), "Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(3852), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1399 = (Var)RT.var("clojure.core", "memfn");
  }
  
  public static void __init14() {
    const__1402 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a Java method as\n  a first-class fn. name may be type-hinted with the method receiver's\n  type in order to avoid reflective calls.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(3871), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1403 = (Var)RT.var("clojure.core", "time");
    const__1406 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "expr")) })), RT.keyword(null, "doc"), "Evaluates expr and prints the time it took.  Returns the value of\n expr.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(3884), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1407 = (Var)RT.var("clojure.core", "alength");
    const__1408 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "array")) }));
    const__1409 = Integer.valueOf(3898);
    const__1410 = (Var)RT.var("clojure.core", "aclone");
    const__1411 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "array")) }));
    const__1412 = Integer.valueOf(3905);
    const__1413 = (Var)RT.var("clojure.core", "aget");
    const__1414 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx")), Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx"), Symbol.intern(null, "&"), Symbol.intern(null, "idxs")) }));
    const__1415 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(2L) });
    const__1416 = Integer.valueOf(3912);
    const__1417 = (Var)RT.var("clojure.core", "aset");
    const__1418 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx"), Symbol.intern(null, "val")), Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx"), Symbol.intern(null, "idx2"), Symbol.intern(null, "&"), Symbol.intern(null, "idxv")) }));
    const__1419 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(3L) });
    const__1420 = Integer.valueOf(3923);
    const__1421 = (Var)RT.var("clojure.core", "def-aset");
    const__1424 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "method"), Symbol.intern(null, "coerce")) })), RT.keyword(null, "line"), Integer.valueOf(3935), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1425 = (Var)RT.var("clojure.core", "aset-int");
    const__1428 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "Sets the value at the index/indices. Works on arrays of int. Returns val.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx"), Symbol.intern(null, "val")), Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx"), Symbol.intern(null, "idx2"), Symbol.intern(null, "&"), Symbol.intern(null, "idxv")) })), RT.keyword(null, "line"), Integer.valueOf(3946), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1429 = (Var)RT.var("clojure.core", "aset-long");
    const__1432 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "Sets the value at the index/indices. Works on arrays of long. Returns val.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx"), Symbol.intern(null, "val")), Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx"), Symbol.intern(null, "idx2"), Symbol.intern(null, "&"), Symbol.intern(null, "idxv")) })), RT.keyword(null, "line"), Integer.valueOf(3951), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1433 = (Var)RT.var("clojure.core", "aset-boolean");
    const__1436 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "Sets the value at the index/indices. Works on arrays of boolean. Returns val.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx"), Symbol.intern(null, "val")), Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx"), Symbol.intern(null, "idx2"), Symbol.intern(null, "&"), Symbol.intern(null, "idxv")) })), RT.keyword(null, "line"), Integer.valueOf(3956), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1437 = (Var)RT.var("clojure.core", "aset-float");
    const__1440 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "Sets the value at the index/indices. Works on arrays of float. Returns val.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx"), Symbol.intern(null, "val")), Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx"), Symbol.intern(null, "idx2"), Symbol.intern(null, "&"), Symbol.intern(null, "idxv")) })), RT.keyword(null, "line"), Integer.valueOf(3961), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1441 = (Var)RT.var("clojure.core", "aset-double");
    const__1444 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "Sets the value at the index/indices. Works on arrays of double. Returns val.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx"), Symbol.intern(null, "val")), Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx"), Symbol.intern(null, "idx2"), Symbol.intern(null, "&"), Symbol.intern(null, "idxv")) })), RT.keyword(null, "line"), Integer.valueOf(3966), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1445 = (Var)RT.var("clojure.core", "aset-short");
    const__1448 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "Sets the value at the index/indices. Works on arrays of short. Returns val.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx"), Symbol.intern(null, "val")), Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx"), Symbol.intern(null, "idx2"), Symbol.intern(null, "&"), Symbol.intern(null, "idxv")) })), RT.keyword(null, "line"), Integer.valueOf(3971), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1449 = (Var)RT.var("clojure.core", "aset-byte");
    const__1452 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "Sets the value at the index/indices. Works on arrays of byte. Returns val.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx"), Symbol.intern(null, "val")), Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx"), Symbol.intern(null, "idx2"), Symbol.intern(null, "&"), Symbol.intern(null, "idxv")) })), RT.keyword(null, "line"), Integer.valueOf(3976), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1453 = (Var)RT.var("clojure.core", "aset-char");
    const__1456 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "Sets the value at the index/indices. Works on arrays of char. Returns val.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx"), Symbol.intern(null, "val")), Tuple.create(Symbol.intern(null, "array"), Symbol.intern(null, "idx"), Symbol.intern(null, "idx2"), Symbol.intern(null, "&"), Symbol.intern(null, "idxv")) })), RT.keyword(null, "line"), Integer.valueOf(3981), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1457 = (Var)RT.var("clojure.core", "make-array");
    const__1460 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "type")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") })), Symbol.intern(null, "len")), Tuple.create(((IObj)Symbol.intern(null, "type")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") })), Symbol.intern(null, "dim"), Symbol.intern(null, "&"), Symbol.intern(null, "more-dims")) })), RT.keyword(null, "doc"), "Creates and returns an array of instances of the specified class of\n  the specified dimension(s).  Note that a class object is required.\n  Class objects can be obtained by using their imported or\n  fully-qualified name.  Class objects for the primitive types can be\n  obtained using, e.g., Integer/TYPE.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(3986), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1461 = (Var)RT.var("clojure.core", "to-array-2d");
    const__1464 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "coll")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.Collection") }))) })), RT.keyword(null, "doc"), "Returns a (potentially-ragged) 2-dimensional array of Objects\n  containing the contents of coll, which can be any Collection of any\n  Collection.", RT.keyword(null, "tag"), "[[Ljava.lang.Object;", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(4003), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1465 = (Var)RT.var("clojure.core", "macroexpand-1");
    const__1468 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "If form represents a macro form, returns its expansion,\n  else returns form.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4018), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1469 = (Var)RT.var("clojure.core", "macroexpand");
    const__1472 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4026), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1473 = (Var)RT.var("clojure.core", "create-struct");
    const__1476 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "keys")) })), RT.keyword(null, "doc"), "Returns a structure basis object.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4038), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1477 = (Var)RT.var("clojure.core", "defstruct");
    const__1480 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "keys")) })), RT.keyword(null, "doc"), "Same as (def name (create-struct keys...))", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4045), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1481 = (Var)RT.var("clojure.core", "struct-map");
    const__1484 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s"), Symbol.intern(null, "&"), Symbol.intern(null, "inits")) })), RT.keyword(null, "doc"), "Returns a new structmap instance with the keys of the\n  structure-basis. keyvals may contain all, some or none of the basis\n  keys - where values are not supplied they will default to nil.\n  keyvals can also contain keys not in the basis.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4052), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1485 = (Var)RT.var("clojure.core", "struct");
    const__1488 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s"), Symbol.intern(null, "&"), Symbol.intern(null, "vals")) })), RT.keyword(null, "doc"), "Returns a new structmap instance with the keys of the\n  structure-basis. vals must be supplied for basis keys in order -\n  where values are not supplied they will default to nil.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4062), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1489 = (Var)RT.var("clojure.core", "accessor");
    const__1492 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s"), Symbol.intern(null, "key")) })), RT.keyword(null, "doc"), "Returns a fn that, given an instance of a structmap with the basis,\n  returns the value at the key.  The key must be in the basis. The\n  returned function should be (slightly) more efficient than using\n  get, but such use of accessors should be limited to known\n  performance-critical areas.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4071), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1493 = (Var)RT.var("clojure.core", "load-reader");
    const__1496 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr")) })), RT.keyword(null, "doc"), "Sequentially read and evaluate the set of forms contained in the\n  stream/file", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4082), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1497 = (Var)RT.var("clojure.core", "load-string");
  }
  
  public static void __init15() {
    const__1500 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Sequentially read and evaluate the set of forms contained in the\n  string", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4089), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1501 = (Var)RT.var("clojure.core", "set?");
    const__1504 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x implements IPersistentSet", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4099), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1505 = (Var)RT.var("clojure.core", "set");
    const__1508 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a set of the distinct elements of coll.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4105), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1509 = (Var)RT.var("clojure.core", "filter-key");
    const__1512 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "keyfn"), Symbol.intern(null, "pred"), Symbol.intern(null, "amap")) })), RT.keyword(null, "line"), Integer.valueOf(4116), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1513 = (Var)RT.var("clojure.core", "find-ns");
    const__1516 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sym")) })), RT.keyword(null, "doc"), "Returns the namespace named by the symbol or nil if it doesn't exist.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4126), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1517 = (Var)RT.var("clojure.core", "create-ns");
    const__1520 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sym")) })), RT.keyword(null, "doc"), "Create a new namespace named by the symbol if one doesn't already\n  exist, returns it or the already-existing namespace of the same\n  name.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4132), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1521 = (Var)RT.var("clojure.core", "remove-ns");
    const__1524 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sym")) })), RT.keyword(null, "doc"), "Removes the namespace named by the symbol. Use with caution.\n  Cannot be used to remove the clojure namespace.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4140), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1525 = (Var)RT.var("clojure.core", "all-ns");
    const__1528 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Returns a sequence of all namespaces.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4147), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1529 = (Var)RT.var("clojure.core", "the-ns");
    const__1532 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "x"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Namespace") })) })), RT.keyword(null, "doc"), "If passed a namespace, returns it. Else, when passed a symbol,\n  returns the namespace named by it, throwing an exception if not\n  found.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4153), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1533 = (Var)RT.var("clojure.core", "ns-name");
    const__1536 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ns")) })), RT.keyword(null, "doc"), "Returns the name of the namespace, a symbol.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4164), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1537 = (Var)RT.var("clojure.core", "ns-map");
    const__1540 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ns")) })), RT.keyword(null, "doc"), "Returns a map of all the mappings for the namespace.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4171), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1541 = (Var)RT.var("clojure.core", "ns-unmap");
    const__1544 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ns"), Symbol.intern(null, "sym")) })), RT.keyword(null, "doc"), "Removes the mappings for the symbol from the namespace.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4178), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1545 = (Var)RT.var("clojure.core", "ns-publics");
    const__1548 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ns")) })), RT.keyword(null, "doc"), "Returns a map of the public intern mappings for the namespace.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4189), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1549 = (Var)RT.var("clojure.core", "ns-imports");
    const__1552 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ns")) })), RT.keyword(null, "doc"), "Returns a map of the import mappings for the namespace.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4200), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1553 = (Var)RT.var("clojure.core", "ns-interns");
    const__1556 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ns")) })), RT.keyword(null, "doc"), "Returns a map of the intern mappings for the namespace.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4207), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1557 = (Var)RT.var("clojure.core", "refer");
    const__1560 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ns-sym"), Symbol.intern(null, "&"), Symbol.intern(null, "filters")) })), RT.keyword(null, "doc"), "refers to all public vars of ns, subject to filters.\n  filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :only list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  For each public interned var in the namespace named by the symbol,\n  adds a mapping from the name of the var to the var to the current\n  namespace.  Throws an exception if name is already mapped to\n  something else in the current namespace. Filters can be used to\n  select a subset, via inclusion or exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent\n  clashes. Use :use in the ns macro in preference to calling this directly.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(4217), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1561 = (Var)RT.var("clojure.core", "ns-refers");
    const__1564 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ns")) })), RT.keyword(null, "doc"), "Returns a map of the refer mappings for the namespace.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4254), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1565 = (Var)RT.var("clojure.core", "alias");
    const__1568 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "alias"), Symbol.intern(null, "namespace-sym")) })), RT.keyword(null, "doc"), "Add an alias in the current namespace to another\n  namespace. Arguments are two symbols: the alias to be used, and\n  the symbolic name of the target namespace. Use :as in the ns macro in preference\n  to calling this directly.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4264), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1569 = (Var)RT.var("clojure.core", "ns-aliases");
    const__1572 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ns")) })), RT.keyword(null, "doc"), "Returns a map of the aliases for the namespace.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4274), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1573 = (Var)RT.var("clojure.core", "ns-unalias");
    const__1576 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ns"), Symbol.intern(null, "sym")) })), RT.keyword(null, "doc"), "Removes the alias for the symbol from the namespace.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4281), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1577 = (Var)RT.var("clojure.core", "take-nth");
    const__1580 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4288), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1581 = (Var)RT.var("clojure.core", "interleave");
    const__1584 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "c1")), Tuple.create(Symbol.intern(null, "c1"), Symbol.intern(null, "c2")), Tuple.create(Symbol.intern(null, "c1"), Symbol.intern(null, "c2"), Symbol.intern(null, "&"), Symbol.intern(null, "colls")) })), RT.keyword(null, "doc"), "Returns a lazy seq of the first item in each coll, then the second etc.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4309), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1585 = (Var)RT.var("clojure.core", "var-get");
    const__1588 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "x")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Var") }))) })), RT.keyword(null, "doc"), "Gets the value in the var object", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4327), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1589 = (Var)RT.var("clojure.core", "var-set");
    const__1592 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "x")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Var") })), Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "Sets the value in the var object to val. The var must be\n thread-locally bound.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4333), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1593 = (Var)RT.var("clojure.core", "with-local-vars");
    const__1596 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name-vals-vec"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "varbinding=> symbol init-expr\n\n  Executes the exprs in a context in which the symbols are bound to\n  vars with per-thread bindings to the init-exprs.  The symbols refer\n  to the var objects themselves, and must be accessed with var-get and\n  var-set", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(4340), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1597 = (Var)RT.var("clojure.core", "ns-resolve");
  }
  
  public static void __init16() {
    const__1600 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ns"), Symbol.intern(null, "sym")), Tuple.create(Symbol.intern(null, "ns"), Symbol.intern(null, "env"), Symbol.intern(null, "sym")) })), RT.keyword(null, "doc"), "Returns the var or Class to which a symbol will be resolved in the\n  namespace (unless found in the environment), else nil.  Note that\n  if the symbol is fully qualified, the var/Class to which it resolves\n  need not be present in the namespace.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4359), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1601 = (Var)RT.var("clojure.core", "resolve");
    const__1604 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sym")), Tuple.create(Symbol.intern(null, "env"), Symbol.intern(null, "sym")) })), RT.keyword(null, "doc"), "same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &env symbol)", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4372), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1605 = (Var)RT.var("clojure.core", "array-map");
    const__1608 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "keyvals")) })), RT.keyword(null, "doc"), "Constructs an array-map. If any keys are equal, they are handled as\n  if by repeated uses of assoc.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4379), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1609 = (Var)RT.var("clojure.core", "destructure");
    const__1612 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings")) })), RT.keyword(null, "line"), Integer.valueOf(4389), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1618 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "binding => binding-form init-expr\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "special-form"), Boolean.TRUE, RT.keyword(null, "forms"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "let"), Tuple.create(Symbol.intern(null, "bindings*")), Symbol.intern(null, "exprs*") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(4487), RT.keyword(null, "column"), Integer.valueOf(47) }))), 
          RT.keyword(null, "line"), Integer.valueOf(4481), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1619 = (Var)RT.var("clojure.core", "maybe-destructured");
    const__1622 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "params"), Symbol.intern(null, "body")) })), RT.keyword(null, "line"), Integer.valueOf(4494), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1626 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "sigs")) })), RT.keyword(null, "doc"), "params => positional-params* , or positional-params* & next-param\n  positional-param => binding-form\n  next-param => binding-form\n  name => symbol\n\n  Defines a function", RT.keyword(null, "added"), "1.0", RT.keyword(null, "special-form"), Boolean.TRUE, RT.keyword(null, "forms"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "fn"), Symbol.intern(null, "name?"), Tuple.create(Symbol.intern(null, "params*")), Symbol.intern(null, "exprs*") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(4521), RT.keyword(null, "column"), Integer.valueOf(13) })), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "fn"), Symbol.intern(null, "name?"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "params*")), Symbol.intern(null, "exprs*") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(4521), RT.keyword(null, "column"), Integer.valueOf(52) })), Symbol.intern(null, "+") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(4521), RT.keyword(null, "column"), Integer.valueOf(42) }))), 
          RT.keyword(null, "line"), Integer.valueOf(4513), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1630 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "special-form"), Boolean.TRUE, RT.keyword(null, "forms"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "loop"), Tuple.create(Symbol.intern(null, "bindings*")), Symbol.intern(null, "exprs*") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(4579), RT.keyword(null, "column"), Integer.valueOf(47) }))), 
          RT.keyword(null, "line"), Integer.valueOf(4575), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1631 = (Var)RT.var("clojure.core", "when-first");
    const__1634 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "bindings => x xs\n\n  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(4600), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1635 = (Var)RT.var("clojure.core", "lazy-cat");
    const__1638 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "colls")) })), RT.keyword(null, "doc"), "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed. \n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(4614), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1639 = (Var)RT.var("clojure.core", "for");
    const__1642 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "seq-exprs"), Symbol.intern(null, "body-expr")) })), RT.keyword(null, "doc"), "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)] [x y]))", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(4624), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1643 = (Var)RT.var("clojure.core", "comment");
    const__1646 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Ignores body, yields nil", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(4711), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1647 = (Var)RT.var("clojure.core", "with-out-str");
    const__1650 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Evaluates exprs in a context in which *out* is bound to a fresh\n  StringWriter.  Returns the string created by any nested printing\n  calls.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(4716), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1651 = (Var)RT.var("clojure.core", "with-in-str");
    const__1654 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Evaluates body in a context in which *in* is bound to a fresh\n  StringReader initialized with the string s.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(4727), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1655 = (Var)RT.var("clojure.core", "pr-str");
    const__1658 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "pr to a string, returning it", RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(4736), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1659 = (Var)RT.var("clojure.core", "prn-str");
    const__1662 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "prn to a string, returning it", RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(4745), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1663 = (Var)RT.var("clojure.core", "print-str");
    const__1666 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "print to a string, returning it", RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(4754), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1667 = (Var)RT.var("clojure.core", "println-str");
    const__1670 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "println to a string, returning it", RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(4763), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1671 = (Var)RT.var("clojure.core", "elide-top-frames");
    const__1674 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "ex")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Throwable") })), Symbol.intern(null, "class-name")) })), RT.keyword(null, "line"), Integer.valueOf(4774), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1675 = (Var)RT.var("clojure.core", "ex-info");
    const__1678 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "msg"), Symbol.intern(null, "map")), Tuple.create(Symbol.intern(null, "msg"), Symbol.intern(null, "map"), Symbol.intern(null, "cause")) })), RT.keyword(null, "doc"), "Create an instance of ExceptionInfo, a RuntimeException subclass\n   that carries a map of additional data.", RT.keyword(null, "added"), "1.4", RT.keyword(null, "line"), Integer.valueOf(4783), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1679 = (Var)RT.var("clojure.core", "ex-data");
    const__1682 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ex")) })), RT.keyword(null, "doc"), "Returns exception data (a map) if ex is an IExceptionInfo.\n   Otherwise returns nil.", RT.keyword(null, "added"), "1.4", RT.keyword(null, "line"), Integer.valueOf(4792), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1683 = (Var)RT.var("clojure.core", "ex-message");
    const__1686 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ex")) })), RT.keyword(null, "doc"), "Returns the message attached to ex if ex is a Throwable.\n  Otherwise returns nil.", RT.keyword(null, "added"), "1.10", RT.keyword(null, "line"), Integer.valueOf(4800), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1687 = (Var)RT.var("clojure.core", "ex-cause");
    const__1690 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ex")) })), RT.keyword(null, "doc"), "Returns the cause of ex if ex is a Throwable.\n  Otherwise returns nil.", RT.keyword(null, "added"), "1.10", RT.keyword(null, "line"), Integer.valueOf(4808), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1691 = (Var)RT.var("clojure.core", "assert");
    const__1694 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "message")) })), RT.keyword(null, "doc"), "Evaluates expr and throws an exception if it does not evaluate to\n  logical true.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(4816), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1695 = (Var)RT.var("clojure.core", "test");
    const__1698 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "v")) })), RT.keyword(null, "doc"), "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(4829), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1699 = (Var)RT.var("clojure.core", "re-pattern");
  }
  
  public static void __init17() {
    const__1703 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Returns an instance of java.util.regex.Pattern, for use, e.g. in\n  re-matcher.", RT.keyword(null, "tag"), RT.classForName("java.util.regex.Pattern"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(4839), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1704 = (Var)RT.var("clojure.core", "re-matcher");
    const__1708 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "re")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.regex.Pattern") })), Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Returns an instance of java.util.regex.Matcher, for use, e.g. in\n  re-find.", RT.keyword(null, "tag"), RT.classForName("java.util.regex.Matcher"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(4849), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1709 = (Var)RT.var("clojure.core", "re-groups");
    const__1712 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "m")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.regex.Matcher") }))) })), RT.keyword(null, "doc"), "Returns the groups from the most recent match/find. If there are no\n  nested groups, returns a string of the entire match. If there are\n  nested groups, returns a vector of the groups, the first element\n  being the entire match.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4858), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1713 = (Var)RT.var("clojure.core", "re-seq");
    const__1716 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "re")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.regex.Pattern") })), Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Returns a lazy sequence of successive matches of pattern in string,\n  using java.util.regex.Matcher.find(), each such match processed with\n  re-groups.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4874), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1717 = (Var)RT.var("clojure.core", "re-matches");
    const__1720 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "re")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.regex.Pattern") })), Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Returns the match, if any, of string to pattern, using\n  java.util.regex.Matcher.matches().  Uses re-groups to return the\n  groups.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4886), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1721 = (Var)RT.var("clojure.core", "re-find");
    const__1724 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "m")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.regex.Matcher") }))), Tuple.create(((IObj)Symbol.intern(null, "re")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.regex.Pattern") })), Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Returns the next regex match, if any, of string to pattern, using\n  java.util.regex.Matcher.find().  Uses re-groups to return the\n  groups.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4898), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1725 = (Var)RT.var("clojure.core", "rand");
    const__1728 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4911), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1729 = (Var)RT.var("clojure.core", "rand-int");
    const__1732 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Returns a random integer between 0 (inclusive) and n (exclusive).", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4919), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1733 = (Var)RT.var("clojure.core", "defn-");
    const__1736 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "decls")) })), RT.keyword(null, "doc"), "same as defn, yielding non-public def", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(4925), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1737 = (Var)RT.var("clojure.core", "tree-seq");
    const__1740 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "branch?"), Symbol.intern(null, "children"), Symbol.intern(null, "root")) })), RT.keyword(null, "doc"), "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4931), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1741 = (Var)RT.var("clojure.core", "file-seq");
    const__1744 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "dir")) })), RT.keyword(null, "doc"), "A tree seq on java.io.Files", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4948), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1745 = (Var)RT.var("clojure.core", "xml-seq");
    const__1748 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "root")) })), RT.keyword(null, "doc"), "A tree seq on the xml elements as per xml/parse", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4958), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1749 = (Var)RT.var("clojure.core", "special-symbol?");
    const__1752 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Returns true if s names a special form", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4968), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1753 = (Var)RT.var("clojure.core", "var?");
    const__1756 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "v")) })), RT.keyword(null, "doc"), "Returns true if v is of type clojure.lang.Var", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4975), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1757 = (Var)RT.var("clojure.core", "subs");
    const__1760 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })), Symbol.intern(null, "start"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.lang.String") })), ((IObj)Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })), Symbol.intern(null, "start"), Symbol.intern(null, "end"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.lang.String") })) })), RT.keyword(null, "doc"), "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4981), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1761 = (Var)RT.var("clojure.core", "max-key");
    const__1764 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "k"), Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "k"), Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "k"), Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) })), RT.keyword(null, "doc"), "Returns the x for which (k x), a number, is greatest.\n\n  If there are multiple such xs, the last one is returned.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(4989), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1765 = (Var)RT.var("clojure.core", "min-key");
    const__1768 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "k"), Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "k"), Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "k"), Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) })), RT.keyword(null, "doc"), "Returns the x for which (k x), a number, is least.\n\n  If there are multiple such xs, the last one is returned.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5009), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1769 = (Var)RT.var("clojure.core", "distinct");
    const__1772 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5029), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1773 = (Var)RT.var("clojure.core", "replace");
    const__1776 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "smap")), Tuple.create(Symbol.intern(null, "smap"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5058), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1777 = (Var)RT.var("clojure.core", "dosync");
    const__1780 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "exprs")) })), RT.keyword(null, "doc"), "Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of dosync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(5076), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1781 = (Var)RT.var("clojure.core", "with-precision");
    const__1784 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "precision"), Symbol.intern(null, "&"), Symbol.intern(null, "exprs")) })), RT.keyword(null, "doc"), "Sets the precision and rounding mode to be used for BigDecimal operations.\n\n  Usage: (with-precision 10 (/ 1M 3))\n  or:    (with-precision 10 :rounding HALF_DOWN (/ 1M 3))\n\n  The rounding mode is one of CEILING, FLOOR, HALF_UP, HALF_DOWN,\n  HALF_EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF_UP.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(5086), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1785 = (Var)RT.var("clojure.core", "mk-bound-fn");
    const__1788 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "sc")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Sorted") })), Symbol.intern(null, "test"), Symbol.intern(null, "key")) })), RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5103), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1789 = (Var)RT.var("clojure.core", "subseq");
    const__1792 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "sc")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Sorted") })), Symbol.intern(null, "test"), Symbol.intern(null, "key")), Tuple.create(((IObj)Symbol.intern(null, "sc")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Sorted") })), Symbol.intern(null, "start-test"), Symbol.intern(null, "start-key"), Symbol.intern(null, "end-test"), Symbol.intern(null, "end-key")) })), RT.keyword(null, "doc"), "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5109), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1793 = (Var)RT.var("clojure.core", "rsubseq");
    const__1796 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "sc")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Sorted") })), Symbol.intern(null, "test"), Symbol.intern(null, "key")), Tuple.create(((IObj)Symbol.intern(null, "sc")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Sorted") })), Symbol.intern(null, "start-test"), Symbol.intern(null, "start-key"), Symbol.intern(null, "end-test"), Symbol.intern(null, "end-key")) })), RT.keyword(null, "doc"), "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5126), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1797 = (Var)RT.var("clojure.core", "repeatedly");
  }
  
  public static void __init18() {
    const__1800 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5143), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1801 = (Var)RT.var("clojure.core", "add-classpath");
    const__1804 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "url")) })), RT.keyword(null, "doc"), "DEPRECATED \n\n  Adds the url (String or URL object) to the classpath per\n  URLClassLoader.addURL", RT.keyword(null, "added"), "1.0", RT.keyword(null, "deprecated"), "1.1", RT.keyword(null, "line"), Integer.valueOf(5152), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1805 = (Var)RT.var("clojure.core", "hash");
    const__1808 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns the hash code of its argument. Note this is the hash code\n  consistent with =, and thus is different than .hashCode for Integer,\n  Short, Byte and Clojure collections.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5165), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1809 = (Var)RT.var("clojure.core", "mix-collection-hash");
    const__1812 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(((IObj)Symbol.intern(null, "hash-basis")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "count")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })) })), RT.keyword(null, "doc"), "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms.", RT.keyword(null, "added"), "1.6", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5175), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1813 = (Var)RT.var("clojure.core", "hash-ordered-coll");
    const__1816 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "coll"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })) })), RT.keyword(null, "doc"), "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms.", RT.keyword(null, "added"), "1.6", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5186), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1817 = (Var)RT.var("clojure.core", "hash-unordered-coll");
    const__1820 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "coll"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })) })), RT.keyword(null, "doc"), "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms.", RT.keyword(null, "added"), "1.6", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5195), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1821 = (Var)RT.var("clojure.core", "interpose");
    const__1824 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sep")), Tuple.create(Symbol.intern(null, "sep"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5206), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1825 = (Var)RT.var("clojure.core", "definline");
    const__1828 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "decl")) })), RT.keyword(null, "doc"), "Experimental - like defmacro, except defines a named function whose\n  body is the expansion, calls to which may be expanded inline as if\n  it were a macro. Cannot be used with variadic (&) args.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(5229), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1829 = (Var)RT.var("clojure.core", "empty");
    const__1832 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns an empty collection of the same category as coll, or nil", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5241), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1833 = (Var)RT.var("clojure.core", "amap");
    const__1836 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "a"), Symbol.intern(null, "idx"), Symbol.intern(null, "ret"), Symbol.intern(null, "expr")) })), RT.keyword(null, "doc"), "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting \n  each element of ret to the evaluation of expr, returning the new \n  array ret.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(5249), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1837 = (Var)RT.var("clojure.core", "areduce");
    const__1840 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "a"), Symbol.intern(null, "idx"), Symbol.intern(null, "ret"), Symbol.intern(null, "init"), Symbol.intern(null, "expr")) })), RT.keyword(null, "doc"), "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the \n  evaluation of expr at each step, returning ret.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(5265), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1841 = (Var)RT.var("clojure.core", "float-array");
    const__1842 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "size-or-seq")), Tuple.create(Symbol.intern(null, "size"), Symbol.intern(null, "init-val-or-seq")) }));
    const__1843 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(1L), Long.valueOf(2L) });
    const__1844 = Integer.valueOf(5277);
    const__1845 = (Var)RT.var("clojure.core", "boolean-array");
    const__1846 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "size-or-seq")), Tuple.create(Symbol.intern(null, "size"), Symbol.intern(null, "init-val-or-seq")) }));
    const__1847 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(1L), Long.valueOf(2L) });
    const__1848 = Integer.valueOf(5285);
    const__1849 = (Var)RT.var("clojure.core", "byte-array");
    const__1850 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "size-or-seq")), Tuple.create(Symbol.intern(null, "size"), Symbol.intern(null, "init-val-or-seq")) }));
    const__1851 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(1L), Long.valueOf(2L) });
    const__1852 = Integer.valueOf(5293);
    const__1853 = (Var)RT.var("clojure.core", "char-array");
    const__1854 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "size-or-seq")), Tuple.create(Symbol.intern(null, "size"), Symbol.intern(null, "init-val-or-seq")) }));
    const__1855 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(1L), Long.valueOf(2L) });
    const__1856 = Integer.valueOf(5301);
    const__1857 = (Var)RT.var("clojure.core", "short-array");
    const__1858 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "size-or-seq")), Tuple.create(Symbol.intern(null, "size"), Symbol.intern(null, "init-val-or-seq")) }));
    const__1859 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(1L), Long.valueOf(2L) });
    const__1860 = Integer.valueOf(5309);
    const__1861 = (Var)RT.var("clojure.core", "double-array");
    const__1862 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "size-or-seq")), Tuple.create(Symbol.intern(null, "size"), Symbol.intern(null, "init-val-or-seq")) }));
    const__1863 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(1L), Long.valueOf(2L) });
    const__1864 = Integer.valueOf(5317);
    const__1865 = (Var)RT.var("clojure.core", "object-array");
    const__1866 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "size-or-seq")) }));
    const__1867 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(1L) });
    const__1868 = Integer.valueOf(5325);
    const__1869 = (Var)RT.var("clojure.core", "int-array");
    const__1870 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "size-or-seq")), Tuple.create(Symbol.intern(null, "size"), Symbol.intern(null, "init-val-or-seq")) }));
    const__1871 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(1L), Long.valueOf(2L) });
    const__1872 = Integer.valueOf(5332);
    const__1873 = (Var)RT.var("clojure.core", "long-array");
    const__1874 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "size-or-seq")), Tuple.create(Symbol.intern(null, "size"), Symbol.intern(null, "init-val-or-seq")) }));
    const__1875 = (AFn)PersistentHashSet.create(new Object[] { Long.valueOf(1L), Long.valueOf(2L) });
    const__1876 = Integer.valueOf(5340);
    const__1877 = (Var)RT.var("clojure.core", "booleans");
    const__1880 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "Casts to boolean[]", RT.keyword(null, "added"), "1.1", RT.keyword(null, "line"), Integer.valueOf(5348), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1881 = (Var)RT.var("clojure.core", "bytes");
    const__1884 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "Casts to bytes[]", RT.keyword(null, "added"), "1.1", RT.keyword(null, "line"), Integer.valueOf(5353), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1885 = (Var)RT.var("clojure.core", "chars");
    const__1888 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "Casts to chars[]", RT.keyword(null, "added"), "1.1", RT.keyword(null, "line"), Integer.valueOf(5358), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1889 = (Var)RT.var("clojure.core", "shorts");
    const__1892 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "Casts to shorts[]", RT.keyword(null, "added"), "1.1", RT.keyword(null, "line"), Integer.valueOf(5363), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1893 = (Var)RT.var("clojure.core", "floats");
    const__1896 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "Casts to float[]", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(5368), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1897 = (Var)RT.var("clojure.core", "ints");
  }
  
  public static void __init19() {
    const__1900 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "Casts to int[]", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(5373), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1901 = (Var)RT.var("clojure.core", "doubles");
    const__1904 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "Casts to double[]", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(5378), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1905 = (Var)RT.var("clojure.core", "longs");
    const__1908 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xs")) })), RT.keyword(null, "doc"), "Casts to long[]", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(5383), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1909 = (Var)RT.var("clojure.core", "bytes?");
    const__1912 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x is a byte array", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(5388), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1913 = (Var)RT.var("clojure.core", "seque");
    const__1916 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")), Tuple.create(Symbol.intern(null, "n-or-q"), Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Creates a queued seq on another (presumably lazy) seq s. The queued\n  seq will produce a concrete seq in the background, and can get up to\n  n items ahead of the consumer. n-or-q can be an integer n buffer\n  size, or an instance of java.util.concurrent BlockingQueue. Note\n  that reading from a seque can block if the reader gets ahead of the\n  producer.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5397), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1917 = (Var)RT.var("clojure.core", "class?");
    const__1920 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x is an instance of Class", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5443), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1921 = (Var)RT.var("clojure.core", "is-annotation?");
    const__1924 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "c")) })), RT.keyword(null, "line"), Integer.valueOf(5449), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1925 = (Var)RT.var("clojure.core", "is-runtime-annotation?");
    const__1928 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") }))) })), RT.keyword(null, "line"), Integer.valueOf(5453), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1929 = (Var)RT.var("clojure.core", "descriptor");
    const__1932 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") }))) })), RT.keyword(null, "line"), Integer.valueOf(5460), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1933 = (Var)RT.var("clojure.core", "process-annotation");
    const__1935 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5462), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1936 = (Var)RT.var("clojure.core", "add-annotation");
    const__1939 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "av")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.asm.AnnotationVisitor") })), Symbol.intern(null, "name"), Symbol.intern(null, "v")) })), RT.keyword(null, "line"), Integer.valueOf(5463), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1942 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "av"), Symbol.intern(null, "v")) })), RT.keyword(null, "line"), Integer.valueOf(5483), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1943 = (Var)RT.var("clojure.core", "add-annotations");
    const__1946 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "visitor"), Symbol.intern(null, "m")), Tuple.create(Symbol.intern(null, "visitor"), Symbol.intern(null, "m"), Symbol.intern(null, "i")) })), RT.keyword(null, "line"), Integer.valueOf(5489), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1947 = (Var)RT.var("clojure.core", "alter-var-root");
    const__1950 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "v")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Var") })), Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Atomically alters the root binding of var v by applying f to its\n  current value plus any args", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5505), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1951 = (Var)RT.var("clojure.core", "bound?");
    const__1954 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "vars")) })), RT.keyword(null, "doc"), "Returns true if all of the vars provided as arguments have any bound value, root or thread-local.\n   Implies that deref'ing the provided vars will succeed. Returns true if no vars are provided.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5512), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1955 = (Var)RT.var("clojure.core", "thread-bound?");
    const__1958 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "vars")) })), RT.keyword(null, "doc"), "Returns true if all of the vars provided as arguments have thread-local bindings.\n   Implies that set!'ing the provided vars will succeed.  Returns true if no vars are provided.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5520), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1959 = (Var)RT.var("clojure.core", "make-hierarchy");
    const__1962 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Creates a hierarchy object for use with derive, isa? etc.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5528), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1964 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5534), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1965 = (Var)RT.var("clojure.core", "not-empty");
    const__1968 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "If coll is empty, returns nil, else coll", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5537), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1969 = (Var)RT.var("clojure.core", "bases");
    const__1972 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") }))) })), RT.keyword(null, "doc"), "Returns the immediate superclass and direct interfaces of c, if any", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5543), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1973 = (Var)RT.var("clojure.core", "supers");
    const__1976 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "class")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") }))) })), RT.keyword(null, "doc"), "Returns the immediate and indirect superclasses and interfaces of c, if any", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5553), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__1977 = (Var)RT.var("clojure.core", "isa?");
    const__1980 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "child"), Symbol.intern(null, "parent")), Tuple.create(Symbol.intern(null, "h"), Symbol.intern(null, "child"), Symbol.intern(null, "parent")) })), RT.keyword(null, "doc"), "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a Java type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(5564), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1981 = (Var)RT.var("clojure.core", "parents");
    const__1984 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "tag")), Tuple.create(Symbol.intern(null, "h"), Symbol.intern(null, "tag")) })), RT.keyword(null, "doc"), "Returns the immediate parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(5585), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1985 = (Var)RT.var("clojure.core", "ancestors");
    const__1988 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "tag")), Tuple.create(Symbol.intern(null, "h"), Symbol.intern(null, "tag")) })), RT.keyword(null, "doc"), "Returns the immediate and indirect parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(5598), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1989 = (Var)RT.var("clojure.core", "descendants");
    const__1992 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "tag")), Tuple.create(Symbol.intern(null, "h"), Symbol.intern(null, "tag")) })), RT.keyword(null, "doc"), "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on Java type inheritance\n  relationships.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(5614), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1993 = (Var)RT.var("clojure.core", "derive");
    const__1996 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "tag"), Symbol.intern(null, "parent")), Tuple.create(Symbol.intern(null, "h"), Symbol.intern(null, "tag"), Symbol.intern(null, "parent")) })), RT.keyword(null, "doc"), "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(5626), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__1997 = (Var)RT.var("clojure.core", "flatten");
    const__1999 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5662), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
  }
  
  public static void __init20() {
    const__2000 = (Var)RT.var("clojure.core", "underive");
    const__2003 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "tag"), Symbol.intern(null, "parent")), Tuple.create(Symbol.intern(null, "h"), Symbol.intern(null, "tag"), Symbol.intern(null, "parent")) })), RT.keyword(null, "doc"), "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(5664), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2004 = (Var)RT.var("clojure.core", "distinct?");
    const__2007 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) })), RT.keyword(null, "doc"), "Returns true if no two of the arguments are =", RT.keyword(null, "tag"), RT.classForName("java.lang.Boolean"), RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, 
          RT.keyword(null, "line"), Integer.valueOf(5685), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2008 = (Var)RT.var("clojure.core", "resultset-seq");
    const__2011 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "rs")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.sql.ResultSet") }))) })), RT.keyword(null, "doc"), "Creates and returns a lazy sequence of structmaps corresponding to\n  the rows in the java.sql.ResultSet rs", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(5702), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2012 = (Var)RT.var("clojure.core", "iterator-seq");
    const__2015 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "iter")) })), RT.keyword(null, "doc"), "Returns a seq on a java.util.Iterator. Note that most collections\n  providing iterators implement Iterable and thus support seq directly.\n  Seqs cache values, thus iterator-seq should not be used on any\n  iterator that repeatedly returns the same mutable object.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5721), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2016 = (Var)RT.var("clojure.core", "enumeration-seq");
    const__2019 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "e")) })), RT.keyword(null, "doc"), "Returns a seq on a java.util.Enumeration", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5731), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2020 = (Var)RT.var("clojure.core", "format");
    const__2023 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "fmt"), Symbol.intern(null, "&"), Symbol.intern(null, "args"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.lang.String") })) })), RT.keyword(null, "doc"), "Formats a string using java.lang.String.format, see java.util.Formatter for format\n  string syntax", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5738), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2024 = (Var)RT.var("clojure.core", "printf");
    const__2027 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fmt"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Prints formatted output, as per format", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5746), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2028 = (Var)RT.var("clojure.core", "gen-class");
    const__2030 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5753), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2031 = (Var)RT.var("clojure.core", "with-loading-context");
    const__2034 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "line"), Integer.valueOf(5755), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2035 = (Var)RT.var("clojure.core", "ns");
    const__2038 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "docstring?"), Symbol.intern(null, "attr-map?"), Symbol.intern(null, "references*")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(5785), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Sets *ns* to the namespace named by name (unevaluated), creating it\n  if needed.  references can be zero or more of: (:refer-clojure ...)\n  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)\n  with the syntax of refer-clojure/require/use/import/load/gen-class\n  respectively, except the arguments are unevaluated and need not be\n  quoted. (:gen-class ...), when supplied, defaults to :name\n  corresponding to the ns name, :main true, :impl-ns same as ns, and\n  :init-impl-ns true. All options of gen-class are\n  supported. The :gen-class directive is ignored when not\n  compiling. If :gen-class is not supplied, when compiled only an\n  nsname__init.class will be generated. If :refer-clojure is not used, a\n  default (refer 'clojure.core) is used.  Use of ns is preferred to\n  individual calls to in-ns/require/use/import:\n\n  (ns foo.bar\n    (:refer-clojure :exclude [ancestors printf])\n    (:require (clojure.contrib sql combinatorics))\n    (:use (my.lib this that))\n    (:import (java.util Date Timer Random)\n             (java.sql Connection Statement)))", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(5764), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2039 = (Var)RT.var("clojure.core", "refer-clojure");
    const__2042 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "filters")) })), RT.keyword(null, "doc"), "Same as (refer 'clojure.core <filters>)", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(5822), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2043 = (Var)RT.var("clojure.core", "defonce");
    const__2046 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "expr")) })), RT.keyword(null, "doc"), "defs name to have the root value of the expr iff the named var has no root value,\n  else expr is unevaluated", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(5828), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2047 = (Var)RT.var("clojure.core", "throw-if");
    const__2050 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "fmt"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Throws a CompilerException with a message if pred is true", RT.keyword(null, "line"), Integer.valueOf(5854), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2051 = (Var)RT.var("clojure.core", "libspec?");
    const__2054 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x is a libspec", RT.keyword(null, "line"), Integer.valueOf(5870), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2055 = (Var)RT.var("clojure.core", "prependss");
    const__2058 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Prepends a symbol or a seq to coll", RT.keyword(null, "line"), Integer.valueOf(5879), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2059 = (Var)RT.var("clojure.core", "root-resource");
    const__2062 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "lib")) })), RT.keyword(null, "doc"), "Returns the root directory path for a lib", RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "line"), Integer.valueOf(5886), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2063 = (Var)RT.var("clojure.core", "root-directory");
    const__2066 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "lib")) })), RT.keyword(null, "doc"), "Returns the root resource path for a lib", RT.keyword(null, "line"), Integer.valueOf(5895), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2067 = (Var)RT.var("clojure.core", "load");
    const__2070 = (AFn)RT.map(new Object[] { RT.keyword(null, "redef"), Boolean.TRUE, RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(5901), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2071 = (Var)RT.var("clojure.core", "load-one");
    const__2074 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "lib"), Symbol.intern(null, "need-ns"), Symbol.intern(null, "require")) })), RT.keyword(null, "doc"), "Loads a lib given its name. If need-ns, ensures that the associated\n  namespace exists after loading. If require, records the load so any\n  duplicate loads can be skipped.", RT.keyword(null, "line"), Integer.valueOf(5903), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2075 = (Var)RT.var("clojure.core", "load-all");
    const__2078 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "lib"), Symbol.intern(null, "need-ns"), Symbol.intern(null, "require")) })), RT.keyword(null, "doc"), "Loads a lib given its name and forces a load of any libs it directly or\n  indirectly loads. If need-ns, ensures that the associated namespace\n  exists after loading. If require, records the load so any duplicate loads\n  can be skipped.", RT.keyword(null, "line"), Integer.valueOf(5916), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2079 = (Var)RT.var("clojure.core", "load-lib");
    const__2082 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "prefix"), Symbol.intern(null, "lib"), Symbol.intern(null, "&"), Symbol.intern(null, "options")) })), RT.keyword(null, "doc"), "Loads a lib with options", RT.keyword(null, "line"), Integer.valueOf(5928), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2083 = (Var)RT.var("clojure.core", "load-libs");
    const__2086 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Loads libs, interpreting libspecs, prefix lists, and flags for\n  forwarding to load-lib", RT.keyword(null, "line"), Integer.valueOf(5969), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2087 = (Var)RT.var("clojure.core", "check-cyclic-dependency");
    const__2090 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "path")) })), RT.keyword(null, "doc"), "Detects and rejects non-trivial cyclic load dependencies. The\n  exception message shows the dependency chain with the cycle\n  highlighted. Ignores the trivial case of a file attempting to load\n  itself because that can occur when a gen-class'd class loads its\n  implementation.", RT.keyword(null, "line"), Integer.valueOf(5992), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2091 = (Var)RT.var("clojure.core", "require");
    const__2094 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib, a prefix list that identifies\n  multiple libs whose names share a common prefix, or a flag that modifies\n  how all the identified libs are loaded. Use :require in the ns macro\n  in preference to calling this directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of Clojure code. Lib names are symbols and each lib is associated\n  with a Clojure namespace and a Java package that share its name. A lib's\n  name also locates its root directory within classpath using Java's\n  package name to classpath-relative path mapping. All resources in a lib\n  should be contained in the directory structure under its root directory.\n  All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj, or\n  <classpath>/x/y/z.cljc if <classpath>/x/y/z.clj does not exist. The\n  root resource should contain code to create the lib's\n  namespace (usually by using the ns macro) and load any additional\n  lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :refer takes a list of symbols to refer from the namespace or the :all\n    keyword to bring in all public vars.\n\n  Prefix Lists\n\n  It's common for Clojure code to depend on several libs whose names have\n  the same prefix. When specifying libs, prefix lists can be used to reduce\n  repetition. A prefix list contains the shared prefix followed by libspecs\n  with the shared prefix removed from the lib names. After removing the\n  prefix, the names that remain must not contain any periods.\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the libraries clojure.zip and clojure.set\n  abbreviated as 's'.\n\n  (require '(clojure zip [set :as s]))", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(6007), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2095 = (Var)RT.var("clojure.core", "serialized-require");
    const__2098 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Like 'require', but serializes loading.\n  Interim function preferred over 'require' for known asynchronous loads.\n  Future changes may make these equivalent.", RT.keyword(null, "added"), "1.10", RT.keyword(null, "line"), Integer.valueOf(6073), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2099 = (Var)RT.var("clojure.core", "requiring-resolve");
  }
  
  public static void __init21() {
    const__2102 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sym")) })), RT.keyword(null, "doc"), "Resolves namespace-qualified sym per 'resolve'. If initial resolve\nfails, attempts to require sym's namespace and retries.", RT.keyword(null, "added"), "1.10", RT.keyword(null, "line"), Integer.valueOf(6082), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2103 = (Var)RT.var("clojure.core", "use");
    const__2106 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Like 'require, but also refers to each lib's namespace using\n  clojure.core/refer. Use :use in the ns macro in preference to calling\n  this directly.\n\n  'use accepts additional options in libspecs: :exclude, :only, :rename.\n  The arguments and semantics for :exclude, :only, and :rename are the same\n  as those documented for clojure.core/refer.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(6093), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2107 = (Var)RT.var("clojure.core", "loaded-libs");
    const__2110 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Returns a sorted set of symbols naming the currently loaded libs", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(6104), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2113 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "paths")) })), RT.keyword(null, "doc"), "Loads Clojure code from resources in classpath. A path is interpreted as\n  classpath-relative if it begins with a slash or relative to the root\n  directory for the current namespace otherwise.", RT.keyword(null, "redef"), Boolean.TRUE, RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(6109), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2114 = (Var)RT.var("clojure.core", "compile");
    const__2117 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "lib")) })), RT.keyword(null, "doc"), "Compiles the namespace named by the symbol lib into a set of\n  classfiles. The source for the lib must be in a proper\n  classpath-relative directory. The output files will go into the\n  directory specified by *compile-path*, and that directory too must\n  be in the classpath.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(6128), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2118 = (Var)RT.var("clojure.core", "get-in");
    const__2121 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ks")), Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ks"), Symbol.intern(null, "not-found")) })), RT.keyword(null, "doc"), "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key\n  is not present, or the not-found value if supplied.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6142), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2122 = (Var)RT.var("clojure.core", "assoc-in");
    const__2125 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Tuple.create(Symbol.intern(null, "k"), Symbol.intern(null, "&"), Symbol.intern(null, "ks")), Symbol.intern(null, "v")) })), RT.keyword(null, "doc"), "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6161), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2126 = (Var)RT.var("clojure.core", "update-in");
    const__2129 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ks"), Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6172), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2130 = (Var)RT.var("clojure.core", "update");
    const__2133 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "k"), Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "k"), Symbol.intern(null, "f"), Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "k"), Symbol.intern(null, "f"), Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "k"), Symbol.intern(null, "f"), Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "z")), RT.vector(new Object[] { Symbol.intern(null, "m"), Symbol.intern(null, "k"), Symbol.intern(null, "f"), Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "z"), Symbol.intern(null, "&"), Symbol.intern(null, "more") }) })), RT.keyword(null, "doc"), "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", RT.keyword(null, "added"), "1.7", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6188), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2134 = (Var)RT.var("clojure.core", "empty?");
    const__2137 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6206), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2138 = (Var)RT.var("clojure.core", "coll?");
    const__2141 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x implements IPersistentCollection", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6213), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2142 = (Var)RT.var("clojure.core", "list?");
    const__2145 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x implements IPersistentList", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6219), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2146 = (Var)RT.var("clojure.core", "seqable?");
    const__2149 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if the seq function is supported for x", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(6225), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2150 = (Var)RT.var("clojure.core", "ifn?");
    const__2153 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x implements IFn. Note that many data structures\n  (e.g. sets and maps) implement IFn", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6230), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2154 = (Var)RT.var("clojure.core", "fn?");
    const__2157 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x implements Fn, i.e. is an object created via fn.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6237), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2158 = (Var)RT.var("clojure.core", "associative?");
    const__2161 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns true if coll implements Associative", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6244), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2162 = (Var)RT.var("clojure.core", "sequential?");
    const__2165 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns true if coll implements Sequential", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6250), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2166 = (Var)RT.var("clojure.core", "sorted?");
    const__2169 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns true if coll implements Sorted", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6256), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2170 = (Var)RT.var("clojure.core", "counted?");
    const__2173 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns true if coll implements count in constant time", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6262), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2174 = (Var)RT.var("clojure.core", "reversible?");
    const__2177 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns true if coll implements Reversible", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6268), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2178 = (Var)RT.var("clojure.core", "indexed?");
    const__2181 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Return true if coll implements Indexed, indicating efficient lookup by index", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(6274), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2182 = (Var)RT.var("clojure.core", "*1");
    const__2184 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "bound in a repl thread to the most recent value printed", RT.keyword(null, "added"), "1.0", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6279), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2185 = (Var)RT.var("clojure.core", "*2");
    const__2187 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "bound in a repl thread to the second most recent value printed", RT.keyword(null, "added"), "1.0", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6284), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2188 = (Var)RT.var("clojure.core", "*3");
    const__2190 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "bound in a repl thread to the third most recent value printed", RT.keyword(null, "added"), "1.0", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6289), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2191 = (Var)RT.var("clojure.core", "*e");
    const__2193 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "bound in a repl thread to the most recent exception caught by the repl", RT.keyword(null, "added"), "1.0", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6294), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2194 = (Var)RT.var("clojure.core", "trampoline");
    const__2197 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6299), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2198 = (Var)RT.var("clojure.core", "intern");
  }
  
  public static void __init22() {
    const__2201 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ns"), ((IObj)Symbol.intern(null, "name")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Symbol") }))), Tuple.create(Symbol.intern(null, "ns"), Symbol.intern(null, "name"), Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "Finds or creates a var named by the symbol name in the namespace\n  ns (which can be a symbol or a namespace), setting its root binding\n  to val if supplied. The namespace must exist. The var will adopt any\n  metadata from the name symbol.  Returns the var.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6317), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2202 = (Var)RT.var("clojure.core", "while");
    const__2205 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "test"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Repeatedly executes body while test expression is true. Presumes\n  some side-effect will cause test to become false/nil. Returns nil", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(6333), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2206 = (Var)RT.var("clojure.core", "memoize");
    const__2209 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6343), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2210 = (Var)RT.var("clojure.core", "condp");
    const__2213 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "expr"), Symbol.intern(null, "&"), Symbol.intern(null, "clauses")) })), RT.keyword(null, "doc"), "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an\n  IllegalArgumentException is thrown.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(6359), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2214 = (Var)RT.var("clojure.core", "*agent*");
    const__2215 = (Var)RT.var("clojure.core", "load-file");
    const__2216 = (Var)RT.var("clojure.core", "add-doc-and-meta");
    const__2219 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "docstring"), Symbol.intern(null, "meta")) })), RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6406), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2220 = (Var)RT.var("clojure.core", "*file*");
    const__2221 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.0" });
    const__2222 = (Var)RT.var("clojure.core", "*command-line-args*");
    const__2223 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.0" });
    const__2224 = (Var)RT.var("clojure.core", "*warn-on-reflection*");
    const__2225 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.0" });
    const__2226 = (Var)RT.var("clojure.core", "*compile-path*");
    const__2227 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.0" });
    const__2228 = (Var)RT.var("clojure.core", "*compile-files*");
    const__2229 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.0" });
    const__2230 = (Var)RT.var("clojure.core", "*unchecked-math*");
    const__2231 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.3" });
    const__2232 = (Var)RT.var("clojure.core", "*compiler-options*");
    const__2233 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.4" });
    const__2234 = (Var)RT.var("clojure.core", "*ns*");
    const__2235 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.0" });
    const__2236 = (Var)RT.var("clojure.core", "*in*");
    const__2237 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.0" });
    const__2238 = (Var)RT.var("clojure.core", "*out*");
    const__2239 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.0" });
    const__2240 = (Var)RT.var("clojure.core", "*err*");
    const__2241 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.0" });
    const__2242 = (Var)RT.var("clojure.core", "*flush-on-newline*");
    const__2243 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.0" });
    const__2244 = (Var)RT.var("clojure.core", "*print-meta*");
    const__2245 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.0" });
    const__2246 = (Var)RT.var("clojure.core", "*print-dup*");
    const__2247 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.0" });
    const__2248 = (Var)RT.var("clojure.core", "*print-readably*");
    const__2249 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.0" });
    const__2250 = (Var)RT.var("clojure.core", "*read-eval*");
    const__2251 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.0" });
    const__2252 = (Var)RT.var("clojure.core", "future?");
    const__2255 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x is a future", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6530), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2256 = (Var)RT.var("clojure.core", "future-done?");
    const__2259 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "f")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.concurrent.Future") }))) })), RT.keyword(null, "doc"), "Returns true if future f is done", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6536), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2260 = (Var)RT.var("clojure.core", "letfn");
    const__2265 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "added"), "1.0", RT.keyword(null, "special-form"), Boolean.TRUE, RT.keyword(null, "file"), "clojure/core.clj", RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "line"), Integer.valueOf(6543), 
          RT.keyword(null, "url"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fnspecs"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n  Takes a vector of function specs and a body, and generates a set of\n  bindings of functions to their names. All of the names are available\n  in all of the definitions of the functions, as well as the body.", RT.keyword(null, "forms"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "letfn"), Tuple.create(Symbol.intern(null, "fnspecs*")), Symbol.intern(null, "exprs*") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(6549), RT.keyword(null, "column"), Integer.valueOf(27) }))) });
    const__2266 = (Var)RT.var("clojure.core", "fnil");
    const__2269 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "x"), Symbol.intern(null, "y")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "x"), Symbol.intern(null, "y"), Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6556), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2270 = (Var)RT.var("clojure.core", "shift-mask");
    const__2273 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "shift"), Symbol.intern(null, "mask"), Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(6583), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2274 = (Var)RT.var("clojure.core", "max-mask-bits");
    const__2276 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6586), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2277 = Long.valueOf(13L);
    const__2278 = (Var)RT.var("clojure.core", "max-switch-table-size");
    const__2280 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6587), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2281 = (Var)RT.var("clojure.core", "maybe-min-hash");
    const__2284 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "hashes")) })), RT.keyword(null, "doc"), "takes a collection of hashes and returns [shift mask] or nil if none found", RT.keyword(null, "line"), Integer.valueOf(6589), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2285 = (Var)RT.var("clojure.core", "case-map");
    const__2288 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "case-f"), Symbol.intern(null, "test-f"), Symbol.intern(null, "tests"), Symbol.intern(null, "thens")) })), RT.keyword(null, "doc"), "Transforms a sequence of test constants and a corresponding sequence of then\n  expressions into a sorted map to be consumed by case*. The form of the map\n  entries are {(case-f test) [(test-f test) then]}.", RT.keyword(null, "line"), Integer.valueOf(6599), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2289 = (Var)RT.var("clojure.core", "fits-table?");
    const__2292 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ints")) })), RT.keyword(null, "doc"), "Returns true if the collection of ints can fit within the\n  max-table-switch-size, false otherwise.", RT.keyword(null, "line"), Integer.valueOf(6610), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2293 = (Var)RT.var("clojure.core", "prep-ints");
    const__2296 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "tests"), Symbol.intern(null, "thens")) })), RT.keyword(null, "doc"), "Takes a sequence of int-sized test constants and a corresponding sequence of\n  then expressions. Returns a tuple of [shift mask case-map switch-type] where\n  case-map is a map of int case values to [test then] tuples, and switch-type\n  is either :sparse or :compact.", RT.keyword(null, "line"), Integer.valueOf(6616), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2297 = (Var)RT.var("clojure.core", "merge-hash-collisions");
  }
  
  public static void __init23() {
    const__2300 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "expr-sym"), Symbol.intern(null, "default"), Symbol.intern(null, "tests"), Symbol.intern(null, "thens")) })), RT.keyword(null, "doc"), "Takes a case expression, default expression, and a sequence of test constants\n  and a corresponding sequence of then expressions. Returns a tuple of\n  [tests thens skip-check-set] where no tests have the same hash. Each set of\n  input test constants with the same hash is replaced with a single test\n  constant (the case int), and their respective thens are combined into:\n  (condp = expr\n    test-1 then-1\n    ...\n    test-n then-n\n    default).\n  The skip-check is a set of case ints for which post-switch equivalence\n  checking must not be done (the cases holding the above condp thens).", RT.keyword(null, "line"), Integer.valueOf(6632), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2301 = (Var)RT.var("clojure.core", "prep-hashes");
    const__2304 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "expr-sym"), Symbol.intern(null, "default"), Symbol.intern(null, "tests"), Symbol.intern(null, "thens")) })), RT.keyword(null, "doc"), "Takes a sequence of test constants and a corresponding sequence of then\n  expressions. Returns a tuple of [shift mask case-map switch-type skip-check]\n  where case-map is a map of int case values to [test then] tuples, switch-type\n  is either :sparse or :compact, and skip-check is a set of case ints for which\n  post-switch equivalence checking must not be done (occurs with hash\n  collisions).", RT.keyword(null, "line"), Integer.valueOf(6668), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2305 = (Var)RT.var("clojure.core", "case");
    const__2308 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "e"), Symbol.intern(null, "&"), Symbol.intern(null, "clauses")) })), RT.keyword(null, "doc"), "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an IllegalArgumentException is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (Clojure) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(6697), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2309 = (AFn)Symbol.intern(null, "clojure.core");
    const__2310 = (Var)RT.var("clojure.core", "when-class");
    const__2313 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "class-name"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "line"), Integer.valueOf(6771), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2314 = RT.classForName("clojure.core.Inst");
    const__2315 = (Var)RT.var("clojure.core", "Inst");
    const__2316 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__2317 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "inst-ms*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "inst")) })) })) }));
    const__2321 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.core.Inst"), RT.keyword(null, "on-interface"), RT.classForName("clojure.core.Inst") });
    const__2322 = (Keyword)RT.keyword(null, "sigs");
    const__2323 = (AFn)RT.map(new Object[] { RT.keyword(null, "inst-ms*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "inst-ms*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "inst")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "inst")) })), RT.keyword(null, "doc"), null }) });
    const__2324 = (Keyword)RT.keyword(null, "var");
    const__2325 = (Keyword)RT.keyword(null, "method-map");
    const__2326 = (Keyword)RT.keyword(null, "inst-ms*");
    const__2327 = (AFn)RT.map(new Object[] { RT.keyword(null, "inst-ms*"), RT.keyword(null, "inst-ms*") });
    const__2328 = (Keyword)RT.keyword(null, "method-builders");
    const__2329 = (AFn)((IObj)Symbol.intern(null, "inst-ms*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "inst")) })) }));
    const__2330 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "inst-ms*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "inst")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "inst")) })), RT.keyword(null, "doc"), null });
    const__2331 = (Keyword)RT.keyword(null, "protocol");
    const__2332 = (Var)RT.var("clojure.core", "-reset-methods");
    const__2333 = (AFn)Symbol.intern(null, "Inst");
    const__2334 = (Var)RT.var("clojure.core", "extend");
    const__2335 = RT.classForName("java.util.Date");
    const__2336 = (Var)RT.var("clojure.core", "inst-ms");
    const__2339 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "inst")) })), RT.keyword(null, "doc"), "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(6787), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2340 = (Var)RT.var("clojure.core", "inst?");
    const__2343 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x satisfies Inst", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(6793), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2344 = RT.classForName("java.time.Instant");
    const__2345 = (Var)RT.var("clojure.core", "uuid?");
    const__2348 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x is a java.util.UUID", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(6805), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2349 = (Var)RT.var("clojure.core", "reduce");
    const__2352 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "val"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(6810), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2353 = (Var)RT.var("clojure.core.protocols", "IKVReduce");
    const__2354 = (Keyword)RT.keyword(null, "kv-reduce");
    const__2355 = RT.classForName("clojure.lang.IPersistentMap");
    const__2356 = RT.classForName("clojure.lang.IKVReduce");
    const__2357 = (Var)RT.var("clojure.core", "reduce-kv");
    const__2360 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "init"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", RT.keyword(null, "added"), "1.4", RT.keyword(null, "line"), Integer.valueOf(6847), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2361 = (Var)RT.var("clojure.core", "completing");
    const__2364 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "cf")) })), RT.keyword(null, "doc"), "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", RT.keyword(null, "added"), "1.7", RT.keyword(null, "line"), Integer.valueOf(6858), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2365 = (Var)RT.var("clojure.core", "transduce");
    const__2368 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xform"), Symbol.intern(null, "f"), Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "xform"), Symbol.intern(null, "f"), Symbol.intern(null, "init"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", RT.keyword(null, "added"), "1.7", RT.keyword(null, "line"), Integer.valueOf(6870), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2369 = (Var)RT.var("clojure.core", "into");
    const__2372 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "to")), Tuple.create(Symbol.intern(null, "to"), Symbol.intern(null, "from")), Tuple.create(Symbol.intern(null, "to"), Symbol.intern(null, "xform"), Symbol.intern(null, "from")) })), RT.keyword(null, "doc"), "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6887), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2373 = (Var)RT.var("clojure.core", "mapv");
    const__2376 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "c1"), Symbol.intern(null, "c2")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "c1"), Symbol.intern(null, "c2"), Symbol.intern(null, "c3")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "c1"), Symbol.intern(null, "c2"), Symbol.intern(null, "c3"), Symbol.intern(null, "&"), Symbol.intern(null, "colls")) })), RT.keyword(null, "doc"), "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", RT.keyword(null, "added"), "1.4", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6903), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2377 = (Var)RT.var("clojure.core", "filterv");
    const__2380 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a vector of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.", RT.keyword(null, "added"), "1.4", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6921), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2381 = (AFn)Tuple.create(Symbol.intern(null, "clojure.java.io"), RT.keyword(null, "as"), Symbol.intern(null, "jio"));
    const__2382 = (Var)RT.var("clojure.core", "normalize-slurp-opts");
    const__2385 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "opts")) })), RT.keyword(null, "line"), Integer.valueOf(6934), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2386 = (Var)RT.var("clojure.core", "slurp");
    const__2389 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Opens a reader on f and reads all its contents, returning a string.\n  See clojure.java.io/reader for a complete list of supported arguments.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "line"), Integer.valueOf(6942), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2390 = (Var)RT.var("clojure.core", "spit");
    const__2393 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "content"), Symbol.intern(null, "&"), Symbol.intern(null, "options")) })), RT.keyword(null, "doc"), "Opposite of slurp.  Opens f with writer, writes content, then\n  closes f. Options passed to clojure.java.io/writer.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(6954), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2394 = (Var)RT.var("clojure.core", "future-call");
    const__2397 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Takes a function of no args and yields a future object that will\n  invoke the function in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant\n  of deref with timeout is used. See also - realized?.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(6963), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2398 = (Var)RT.var("clojure.core", "future");
  }
  
  public static void __init24() {
    const__2401 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Takes a body of expressions and yields a future object that will\n  invoke the body in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant of\n  deref with timeout is used. See also - realized?.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "line"), Integer.valueOf(6990), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2402 = (Var)RT.var("clojure.core", "future-cancel");
    const__2405 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "f")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.concurrent.Future") }))) })), RT.keyword(null, "doc"), "Cancels the future, if possible.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(7000), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2406 = (Var)RT.var("clojure.core", "future-cancelled?");
    const__2409 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "f")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.concurrent.Future") }))) })), RT.keyword(null, "doc"), "Returns true if future f is cancelled", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(7006), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2410 = (Var)RT.var("clojure.core", "pmap");
    const__2413 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "coll"), Symbol.intern(null, "&"), Symbol.intern(null, "colls")) })), RT.keyword(null, "doc"), "Like map, except f is applied in parallel. Semi-lazy in that the\n  parallel computation stays ahead of the consumption, but doesn't\n  realize the entire result unless required. Only useful for\n  computationally intensive functions where the time of f dominates\n  the coordination overhead.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(7012), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2414 = (Var)RT.var("clojure.core", "pcalls");
    const__2417 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "fns")) })), RT.keyword(null, "doc"), "Executes the no-arg fns in parallel, returning a lazy sequence of\n  their values", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(7037), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2418 = (Var)RT.var("clojure.core", "pvalues");
    const__2421 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "exprs")) })), RT.keyword(null, "doc"), "Returns a lazy sequence of the values of the exprs, which are\n  evaluated in parallel", RT.keyword(null, "added"), "1.0", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(7044), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2422 = (Var)RT.var("clojure.core", "*clojure-version*");
    const__2423 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.0" });
    const__2424 = (Var)RT.var("clojure.core", "clojure-version");
    const__2427 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Returns clojure version as a printable string.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(7081), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2428 = (Var)RT.var("clojure.core", "promise");
    const__2431 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Returns a promise object that can be read with deref/@, and set,\n  once only, with deliver. Calls to deref/@ prior to delivery will\n  block, unless the variant of deref with timeout is used. All\n  subsequent derefs will return the same delivered value without\n  blocking. See also - realized?.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(7096), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2432 = (Var)RT.var("clojure.core", "deliver");
    const__2435 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "promise"), Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "Delivers the supplied value to the promise, releasing any pending\n  derefs. A subsequent call to deliver on a promise will have no effect.", RT.keyword(null, "added"), "1.1", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(7127), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2438 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat lazy sequence.\n  (flatten nil) returns an empty sequence.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(7136), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2439 = (Var)RT.var("clojure.core", "group-by");
    const__2442 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(7146), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2443 = (Var)RT.var("clojure.core", "partition-by");
    const__2446 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(7160), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2447 = (Var)RT.var("clojure.core", "frequencies");
    const__2450 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a map from distinct items in coll to the number of times\n  they appear.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(7203), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2451 = (Var)RT.var("clojure.core", "reductions");
    const__2454 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "init"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(7214), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2455 = (Var)RT.var("clojure.core", "rand-nth");
    const__2458 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(7231), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2459 = (Var)RT.var("clojure.core", "partition-all");
    const__2462 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "n")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") }))), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "step"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(7240), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2463 = (Var)RT.var("clojure.core", "shuffle");
    const__2466 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "coll")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.Collection") }))) })), RT.keyword(null, "doc"), "Return a random permutation of coll", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(7274), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2467 = (Var)RT.var("clojure.core", "map-indexed");
    const__2470 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(7283), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2471 = (Var)RT.var("clojure.core", "keep");
    const__2474 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(7313), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2475 = (Var)RT.var("clojure.core", "keep-indexed");
    const__2478 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(7346), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2479 = (Var)RT.var("clojure.core", "bounded-count");
    const__2482 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "If coll is counted? returns its count, else will count at most the first n\n  elements of coll using its seq", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(7384), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2483 = (Var)RT.var("clojure.core", "every-pred");
    const__2486 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p")), Tuple.create(Symbol.intern(null, "p1"), Symbol.intern(null, "p2")), Tuple.create(Symbol.intern(null, "p1"), Symbol.intern(null, "p2"), Symbol.intern(null, "p3")), Tuple.create(Symbol.intern(null, "p1"), Symbol.intern(null, "p2"), Symbol.intern(null, "p3"), Symbol.intern(null, "&"), Symbol.intern(null, "ps")) })), RT.keyword(null, "doc"), "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", RT.keyword(null, "added"), "1.3", RT.keyword(null, "line"), Integer.valueOf(7396), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2487 = (Var)RT.var("clojure.core", "some-fn");
    const__2490 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p")), Tuple.create(Symbol.intern(null, "p1"), Symbol.intern(null, "p2")), Tuple.create(Symbol.intern(null, "p1"), Symbol.intern(null, "p2"), Symbol.intern(null, "p3")), Tuple.create(Symbol.intern(null, "p1"), Symbol.intern(null, "p2"), Symbol.intern(null, "p3"), Symbol.intern(null, "&"), Symbol.intern(null, "ps")) })), RT.keyword(null, "doc"), "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", RT.keyword(null, "added"), "1.3", RT.keyword(null, "line"), Integer.valueOf(7436), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2493 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fdecl")) })), RT.keyword(null, "doc"), "A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn.", RT.keyword(null, "line"), Integer.valueOf(7476), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2494 = (Var)RT.var("clojure.core", "with-redefs-fn");
    const__2497 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "binding-map"), Symbol.intern(null, "func")) })), RT.keyword(null, "doc"), "Temporarily redefines Vars during a call to func.  Each val of\n  binding-map will replace the root value of its key which must be\n  a Var.  After func is called with no args, the root values of all\n  the Vars will be set back to their old values.  These temporary\n  changes will be visible in all threads.  Useful for mocking out\n  functions during testing.", RT.keyword(null, "added"), "1.3", RT.keyword(null, "line"), Integer.valueOf(7498), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2498 = (Var)RT.var("clojure.core", "with-redefs");
  }
  
  public static void __init25() {
    const__2501 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "binding => var-symbol temp-value-expr\n\n  Temporarily redefines Vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its Var.  After the body is\n  executed, the root values of all the Vars will be set back to their\n  old values.  These temporary changes will be visible in all threads.\n  Useful for mocking out functions during testing.", RT.keyword(null, "added"), "1.3", RT.keyword(null, "line"), Integer.valueOf(7518), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2502 = (Var)RT.var("clojure.core", "realized?");
    const__2505 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "x")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IPending") }))) })), RT.keyword(null, "doc"), "Returns true if a value has been produced for a promise, delay, future or lazy sequence.", RT.keyword(null, "added"), "1.3", RT.keyword(null, "line"), Integer.valueOf(7533), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2506 = (Var)RT.var("clojure.core", "cond->");
    const__2509 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "expr"), Symbol.intern(null, "&"), Symbol.intern(null, "clauses")) })), RT.keyword(null, "doc"), "Takes an expression and a set of test/form pairs. Threads expr (via ->)\n  through each form for which the corresponding test\n  expression is true. Note that, unlike cond branching, cond-> threading does\n  not short circuit after the first true test expression.", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(7538), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2510 = (Var)RT.var("clojure.core", "cond->>");
    const__2513 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "expr"), Symbol.intern(null, "&"), Symbol.intern(null, "clauses")) })), RT.keyword(null, "doc"), "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n  through each form for which the corresponding test expression\n  is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n  after the first true test expression.", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(7555), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2514 = (Var)RT.var("clojure.core", "as->");
    const__2517 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "expr"), Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "forms")) })), RT.keyword(null, "doc"), "Binds name to expr, evaluates the first form in the lexical context\n  of that binding, then binds name to that result, repeating for each\n  successive form, returning the result of the last form.", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(7572), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2518 = (Var)RT.var("clojure.core", "some->");
    const__2521 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "expr"), Symbol.intern(null, "&"), Symbol.intern(null, "forms")) })), RT.keyword(null, "doc"), "When expr is not nil, threads it into the first form (via ->),\n  and when that result is not nil, through the next etc", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(7584), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2522 = (Var)RT.var("clojure.core", "some->>");
    const__2525 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "expr"), Symbol.intern(null, "&"), Symbol.intern(null, "forms")) })), RT.keyword(null, "doc"), "When expr is not nil, threads it into the first form (via ->>),\n  and when that result is not nil, through the next etc", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(7598), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2526 = (Var)RT.var("clojure.core", "preserving-reduced");
    const__2529 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rf")) })), RT.keyword(null, "line"), Integer.valueOf(7612), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2532 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rf")) })), RT.keyword(null, "doc"), "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", RT.keyword(null, "added"), "1.7", RT.keyword(null, "line"), Integer.valueOf(7619), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2533 = (Var)RT.var("clojure.core", "halt-when");
    const__2536 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred")), Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "retf")) })), RT.keyword(null, "doc"), "Returns a transducer that ends transduction when pred returns true\n  for an input. When retf is supplied it must be a fn of 2 arguments -\n  it will be passed the (completed) result so far and the input that\n  triggered the predicate, and its return value (if it does not throw\n  an exception) will be the return value of the transducer. If retf\n  is not supplied, the input that triggered the predicate will be\n  returned. If the predicate never returns true the transduction is\n  unaffected.", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(7631), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2537 = (Var)RT.var("clojure.core", "dedupe");
    const__2540 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", RT.keyword(null, "added"), "1.7", RT.keyword(null, "line"), Integer.valueOf(7655), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2541 = (Var)RT.var("clojure.core", "random-sample");
    const__2544 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "prob")), Tuple.create(Symbol.intern(null, "prob"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", RT.keyword(null, "added"), "1.7", RT.keyword(null, "line"), Integer.valueOf(7673), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2545 = (Var)RT.var("clojure.core", "eduction");
    const__2548 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xform*"), Symbol.intern(null, "coll")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(7699), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called.", RT.keyword(null, "added"), "1.7", RT.keyword(null, "line"), Integer.valueOf(7694), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2549 = (Var)RT.var("clojure.core", "print-method");
    const__2550 = RT.classForName("clojure.core.Eduction");
    const__2551 = (Var)RT.var("clojure.core", "run!");
    const__2554 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "proc"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil", RT.keyword(null, "added"), "1.7", RT.keyword(null, "line"), Integer.valueOf(7710), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2555 = (Var)RT.var("clojure.core", "tagged-literal?");
    const__2558 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "value")) })), RT.keyword(null, "doc"), "Return true if the value is the data representation of a tagged literal", RT.keyword(null, "added"), "1.7", RT.keyword(null, "line"), Integer.valueOf(7719), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2559 = (Var)RT.var("clojure.core", "tagged-literal");
    const__2562 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "tag")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.Symbol") })), Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Construct a data representation of a tagged literal from a\n  tag symbol and a form.", RT.keyword(null, "added"), "1.7", RT.keyword(null, "line"), Integer.valueOf(7725), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2563 = (Var)RT.var("clojure.core", "reader-conditional?");
    const__2566 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "value")) })), RT.keyword(null, "doc"), "Return true if the value is the data representation of a reader conditional", RT.keyword(null, "added"), "1.7", RT.keyword(null, "line"), Integer.valueOf(7732), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2567 = (Var)RT.var("clojure.core", "reader-conditional");
    const__2570 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), ((IObj)Symbol.intern(null, "splicing?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Boolean") }))) })), RT.keyword(null, "doc"), "Construct a data representation of a reader conditional.\n  If true, splicing? indicates read-cond-splicing.", RT.keyword(null, "added"), "1.7", RT.keyword(null, "line"), Integer.valueOf(7738), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2571 = (Var)RT.var("clojure.core", "default-data-readers");
    const__2573 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.4", RT.keyword(null, "line"), Integer.valueOf(7750), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj", RT.keyword(null, "doc"), "Default map of data reader functions provided by Clojure. May be\n  overridden by binding *data-readers*." });
    const__2574 = (AFn)Symbol.intern(null, "uuid");
    const__2575 = (Var)RT.var("clojure.uuid", "default-uuid-reader");
    const__2576 = (Var)RT.var("clojure.core", "*data-readers*");
    const__2578 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "added"), "1.4", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(7758), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj", 
          RT.keyword(null, "doc"), "Map from reader tag symbols to data reader Vars.\n\n  When Clojure starts, it searches for files named 'data_readers.clj'\n  and 'data_readers.cljc' at the root of the classpath. Each such file\n  must contain a literal map of symbols, like this:\n\n      {foo/bar my.project.foo/bar\n       foo/baz my.project/baz}\n\n  The first symbol in each pair is a tag that will be recognized by\n  the Clojure reader. The second symbol in the pair is the\n  fully-qualified name of a Var which will be invoked by the reader to\n  parse the form following the tag. For example, given the\n  data_readers.clj file above, the Clojure reader would parse this\n  form:\n\n      #foo/bar [1 2 3]\n\n  by invoking the Var #'my.project.foo/bar on the vector [1 2 3]. The\n  data reader function is invoked on the form AFTER it has been read\n  as a normal Clojure data structure by the reader.\n\n  Reader tags without namespace qualifiers are reserved for\n  Clojure. Default reader tags are defined in\n  clojure.core/default-data-readers but may be overridden in\n  data_readers.clj, data_readers.cljc, or by rebinding this Var." });
    const__2579 = (Var)RT.var("clojure.core", "*default-data-reader-fn*");
    const__2581 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "added"), "1.5", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(7787), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj", 
          RT.keyword(null, "doc"), "When no data reader is found for a tag and *default-data-reader-fn*\n  is non-nil, it will be called with two arguments,\n  the tag and the value.  If *default-data-reader-fn* is nil (the\n  default), an exception will be thrown for the unknown tag." });
    const__2582 = (Var)RT.var("clojure.core", "data-reader-urls");
    const__2585 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "line"), Integer.valueOf(7794), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2586 = (Var)RT.var("clojure.core", "data-reader-var");
    const__2589 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sym")) })), RT.keyword(null, "line"), Integer.valueOf(7800), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2590 = (Var)RT.var("clojure.core", "load-data-reader-file");
    const__2593 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "mappings"), ((IObj)Symbol.intern(null, "url")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.net.URL") }))) })), RT.keyword(null, "line"), Integer.valueOf(7804), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2594 = (Var)RT.var("clojure.core", "load-data-readers");
    const__2597 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "line"), Integer.valueOf(7833), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core.clj" });
    const__2598 = (Var)RT.var("clojure.core", "uri?");
  }
  
  public static void __init26() {
    const__2601 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true if x is a java.net.URI", RT.keyword(null, "added"), "1.9", RT.keyword(null, "line"), Integer.valueOf(7845), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2602 = (Var)RT.var("clojure.core", "add-tap");
    const__2605 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "adds f, a fn of one argument, to the tap set. This function will be called with anything sent via tap>.\n  This function may (briefly) block (e.g. for streams), and will never impede calls to tap>,\n  but blocking indefinitely may cause tap values to be dropped.\n  Remember f in order to remove-tap", RT.keyword(null, "added"), "1.10", RT.keyword(null, "line"), Integer.valueOf(7868), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2606 = (Var)RT.var("clojure.core", "remove-tap");
    const__2609 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Remove f from the tap set.", RT.keyword(null, "added"), "1.10", RT.keyword(null, "line"), Integer.valueOf(7879), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
    const__2610 = (Var)RT.var("clojure.core", "tap>");
    const__2613 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "sends x to any taps. Will not block. Returns true if there was room in the queue,\n  false if not (dropped).", RT.keyword(null, "added"), "1.10", RT.keyword(null, "line"), Integer.valueOf(7886), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core.clj" });
  }
  
  static  {
    __init0();
    __init1();
    __init2();
    __init3();
    __init4();
    __init5();
    __init6();
    __init7();
    __init8();
    __init9();
    __init10();
    __init11();
    __init12();
    __init13();
    __init14();
    __init15();
    __init16();
    __init17();
    __init18();
    __init19();
    __init20();
    __init21();
    __init22();
    __init23();
    __init24();
    __init25();
    __init26();
    Compiler.pushNSandLoader(RT.classForName("clojure.core__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
