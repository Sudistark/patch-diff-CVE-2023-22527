package clojure.core.match;

import clojure.core.match.protocols.INodeCompile;
import clojure.lang.AFn;
import clojure.lang.APersistentMap;
import clojure.lang.Associative;
import clojure.lang.Counted;
import clojure.lang.IFn;
import clojure.lang.IHashEq;
import clojure.lang.IKeywordLookup;
import clojure.lang.ILookup;
import clojure.lang.ILookupThunk;
import clojure.lang.IMapEntry;
import clojure.lang.IObj;
import clojure.lang.IPersistentCollection;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IRecord;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.KeywordLookupSite;
import clojure.lang.MapEntry;
import clojure.lang.Numbers;
import clojure.lang.PersistentHashSet;
import clojure.lang.RT;
import clojure.lang.RecordIterator;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Util;
import clojure.lang.Var;
import java.io.Serializable;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public final class SwitchNode implements INodeCompile, IRecord, IHashEq, IObj, ILookup, IKeywordLookup, IPersistentMap, Map, Serializable {
  public final Object occurrence;
  
  public final Object cases;
  
  public final Object default;
  
  public final Object __meta;
  
  public final Object __extmap;
  
  int __hash;
  
  int __hasheq;
  
  private static Class __cached_class__0;
  
  private static Class __cached_class__1;
  
  private static Class __cached_class__2;
  
  public static final Var const__0 = (Var)RT.var("clojure.core", "set");
  
  public static final Var const__1 = (Var)RT.var("clojure.core", "vals");
  
  public static final Var const__2 = (Var)RT.var("clojure.core", "keys");
  
  public static final Var const__4 = (Var)RT.var("clojure.core", "some");
  
  public static final Var const__7 = (Var)RT.var("clojure.core", "contains?");
  
  public static final Keyword const__8 = (Keyword)RT.keyword(null, "default");
  
  public static final Keyword const__9 = (Keyword)RT.keyword(null, "cases");
  
  public static final Keyword const__10 = (Keyword)RT.keyword(null, "occurrence");
  
  public static final AFn const__11 = (AFn)PersistentHashSet.create(new Object[] { RT.keyword(null, "default"), RT.keyword(null, "cases"), RT.keyword(null, "occurrence") });
  
  public static final Var const__12 = (Var)RT.var("clojure.core", "dissoc");
  
  public static final Var const__13 = (Var)RT.var("clojure.core", "with-meta");
  
  public static final Var const__14 = (Var)RT.var("clojure.core", "into");
  
  public static final Var const__15 = (Var)RT.var("clojure.core", "not-empty");
  
  public static final Var const__16 = (Var)RT.var("clojure.core", "identical?");
  
  public static final Var const__17 = (Var)RT.var("clojure.core", "assoc");
  
  public static final AFn const__18 = (AFn)Tuple.create(RT.keyword(null, "occurrence"), RT.keyword(null, "cases"), RT.keyword(null, "default"));
  
  public static final Var const__19 = (Var)RT.var("clojure.core", "seq");
  
  public static final Var const__20 = (Var)RT.var("clojure.core", "concat");
  
  public static final Var const__21 = (Var)RT.var("clojure.core", "not");
  
  public static final Var const__22 = (Var)RT.var("clojure.core", "class");
  
  public static final Var const__23 = (Var)RT.var("clojure.core", "imap-cons");
  
  public static final Var const__24 = (Var)RT.var("clojure.core", "str");
  
  public static final Var const__33 = (Var)RT.var("clojure.core", "doall");
  
  public static final Var const__34 = (Var)RT.var("clojure.core", "mapcat");
  
  public static final Var const__35 = (Var)RT.var("clojure.core", "partial");
  
  public static final Var const__36 = (Var)RT.var("clojure.core", "apply");
  
  public static final Var const__37 = (Var)RT.var("clojure.core.match", "dag-clause-to-clj");
  
  public static final Var const__39 = (Var)RT.var("clojure.core", "meta");
  
  public static final Var const__40 = (Var)RT.var("clojure.core.match", "*recur-present*");
  
  public static final Var const__41 = (Var)RT.var("clojure.core", "list");
  
  public static final AFn const__42 = (AFn)Symbol.intern("clojure.core", "cond");
  
  public static final Keyword const__43 = (Keyword)RT.keyword(null, "else");
  
  public static final Var const__44 = (Var)RT.var("clojure.core.match.protocols", "n-to-clj");
  
  public static final AFn const__45 = (AFn)Symbol.intern("clojure.core", "cond");
  
  public static final Var const__46 = (Var)RT.var("clojure.core.match", "backtrack-expr");
  
  public static final AFn const__47 = (AFn)Symbol.intern("clojure.core", "let");
  
  public static final Var const__48 = (Var)RT.var("clojure.core", "vector");
  
  public static final AFn const__49 = (AFn)Symbol.intern(null, "try");
  
  public static final AFn const__50 = (AFn)Symbol.intern("clojure.core", "let");
  
  public static final Var const__51 = (Var)RT.var("clojure.core.match", "catch-error");
  
  public static final AFn const__52 = (AFn)Symbol.intern(null, "try");
  
  static final KeywordLookupSite __site__0__;
  
  static ILookupThunk __thunk__0__ = __site__0__ = new KeywordLookupSite(RT.keyword(null, "bind-expr"));
  
  public SwitchNode(Object paramObject1, Object paramObject2, Object paramObject3, Object paramObject4, Object paramObject5, int paramInt1, int paramInt2) { this.occurrence = paramObject1;
    this.cases = paramObject2;
    this.default = paramObject3;
    this.__meta = paramObject4;
    this.__extmap = paramObject5;
    this.__hash = paramInt1;
    this.__hasheq = paramInt2; }
  
  public SwitchNode(Object paramObject1, Object paramObject2, Object paramObject3) { this(paramObject1, paramObject2, paramObject3, null, null, 0, 0); }
  
  public SwitchNode(Object paramObject1, Object paramObject2, Object paramObject3, Object paramObject4, Object paramObject5) { this(paramObject1, paramObject2, paramObject3, paramObject4, paramObject5, 0, 0); }
  
  public static IPersistentVector getBasis() { return Tuple.create(Symbol.intern(null, "occurrence"), Symbol.intern(null, "cases"), Symbol.intern(null, "default")); }
  
  public static SwitchNode create(IPersistentMap paramIPersistentMap) {
    Object object1 = paramIPersistentMap.valAt(Keyword.intern("occurrence"), null);
    paramIPersistentMap = paramIPersistentMap.without(Keyword.intern("occurrence"));
    Object object2 = paramIPersistentMap.valAt(Keyword.intern("cases"), null);
    paramIPersistentMap = paramIPersistentMap.without(Keyword.intern("cases"));
    Object object3 = paramIPersistentMap.valAt(Keyword.intern("default"), null);
    paramIPersistentMap = paramIPersistentMap.without(Keyword.intern("default"));
    return new SwitchNode(object1, object2, object3, null, RT.seqOrElse(paramIPersistentMap), 0, 0);
  }
  
  public Object n_to_clj() { // Byte code:
    //   0: getstatic clojure/core/match/SwitchNode.const__33 : Lclojure/lang/Var;
    //   3: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   6: checkcast clojure/lang/IFn
    //   9: getstatic clojure/core/match/SwitchNode.const__34 : Lclojure/lang/Var;
    //   12: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   15: checkcast clojure/lang/IFn
    //   18: getstatic clojure/core/match/SwitchNode.const__35 : Lclojure/lang/Var;
    //   21: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   24: checkcast clojure/lang/IFn
    //   27: getstatic clojure/core/match/SwitchNode.const__36 : Lclojure/lang/Var;
    //   30: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   33: getstatic clojure/core/match/SwitchNode.const__37 : Lclojure/lang/Var;
    //   36: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   39: aload_0
    //   40: getfield occurrence : Ljava/lang/Object;
    //   43: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   48: aload_0
    //   49: getfield cases : Ljava/lang/Object;
    //   52: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   57: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   62: astore_1
    //   63: getstatic clojure/core/match/SwitchNode.__thunk__0__ : Lclojure/lang/ILookupThunk;
    //   66: dup
    //   67: getstatic clojure/core/match/SwitchNode.const__39 : Lclojure/lang/Var;
    //   70: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   73: checkcast clojure/lang/IFn
    //   76: aload_0
    //   77: getfield occurrence : Ljava/lang/Object;
    //   80: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   85: dup_x2
    //   86: invokeinterface get : (Ljava/lang/Object;)Ljava/lang/Object;
    //   91: dup_x2
    //   92: if_acmpeq -> 99
    //   95: pop
    //   96: goto -> 121
    //   99: swap
    //   100: pop
    //   101: dup
    //   102: getstatic clojure/core/match/SwitchNode.__site__0__ : Lclojure/lang/KeywordLookupSite;
    //   105: swap
    //   106: invokeinterface fault : (Ljava/lang/Object;)Lclojure/lang/ILookupThunk;
    //   111: dup
    //   112: putstatic clojure/core/match/SwitchNode.__thunk__0__ : Lclojure/lang/ILookupThunk;
    //   115: swap
    //   116: invokeinterface get : (Ljava/lang/Object;)Ljava/lang/Object;
    //   121: astore_2
    //   122: getstatic clojure/core/match/SwitchNode.const__40 : Lclojure/lang/Var;
    //   125: invokevirtual get : ()Ljava/lang/Object;
    //   128: dup
    //   129: ifnull -> 327
    //   132: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   135: if_acmpeq -> 328
    //   138: getstatic clojure/core/match/SwitchNode.const__33 : Lclojure/lang/Var;
    //   141: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   144: checkcast clojure/lang/IFn
    //   147: getstatic clojure/core/match/SwitchNode.const__20 : Lclojure/lang/Var;
    //   150: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   153: checkcast clojure/lang/IFn
    //   156: getstatic clojure/core/match/SwitchNode.const__19 : Lclojure/lang/Var;
    //   159: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   162: checkcast clojure/lang/IFn
    //   165: getstatic clojure/core/match/SwitchNode.const__20 : Lclojure/lang/Var;
    //   168: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   171: checkcast clojure/lang/IFn
    //   174: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   177: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   180: checkcast clojure/lang/IFn
    //   183: getstatic clojure/core/match/SwitchNode.const__42 : Lclojure/lang/AFn;
    //   186: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   191: aload_1
    //   192: aconst_null
    //   193: astore_1
    //   194: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   199: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   204: getstatic clojure/core/match/SwitchNode.const__19 : Lclojure/lang/Var;
    //   207: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   210: checkcast clojure/lang/IFn
    //   213: getstatic clojure/core/match/SwitchNode.const__20 : Lclojure/lang/Var;
    //   216: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   219: checkcast clojure/lang/IFn
    //   222: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   225: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   228: checkcast clojure/lang/IFn
    //   231: getstatic clojure/core/match/SwitchNode.const__43 : Lclojure/lang/Keyword;
    //   234: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   239: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   242: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   245: checkcast clojure/lang/IFn
    //   248: aload_0
    //   249: getfield default : Ljava/lang/Object;
    //   252: dup
    //   253: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   256: getstatic clojure/core/match/SwitchNode.__cached_class__0 : Ljava/lang/Class;
    //   259: if_acmpeq -> 276
    //   262: dup
    //   263: instanceof clojure/core/match/protocols/INodeCompile
    //   266: ifne -> 291
    //   269: dup
    //   270: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   273: putstatic clojure/core/match/SwitchNode.__cached_class__0 : Ljava/lang/Class;
    //   276: getstatic clojure/core/match/SwitchNode.const__44 : Lclojure/lang/Var;
    //   279: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   282: swap
    //   283: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   288: goto -> 299
    //   291: checkcast clojure/core/match/protocols/INodeCompile
    //   294: invokeinterface n_to_clj : ()Ljava/lang/Object;
    //   299: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   304: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   309: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   314: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   319: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   324: goto -> 477
    //   327: pop
    //   328: getstatic clojure/core/match/SwitchNode.const__33 : Lclojure/lang/Var;
    //   331: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   334: checkcast clojure/lang/IFn
    //   337: getstatic clojure/core/match/SwitchNode.const__20 : Lclojure/lang/Var;
    //   340: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   343: checkcast clojure/lang/IFn
    //   346: getstatic clojure/core/match/SwitchNode.const__19 : Lclojure/lang/Var;
    //   349: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   352: checkcast clojure/lang/IFn
    //   355: getstatic clojure/core/match/SwitchNode.const__20 : Lclojure/lang/Var;
    //   358: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   361: checkcast clojure/lang/IFn
    //   364: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   367: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   370: checkcast clojure/lang/IFn
    //   373: getstatic clojure/core/match/SwitchNode.const__45 : Lclojure/lang/AFn;
    //   376: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   381: aload_1
    //   382: aconst_null
    //   383: astore_1
    //   384: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   389: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   394: getstatic clojure/core/match/SwitchNode.const__19 : Lclojure/lang/Var;
    //   397: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   400: checkcast clojure/lang/IFn
    //   403: getstatic clojure/core/match/SwitchNode.const__20 : Lclojure/lang/Var;
    //   406: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   409: checkcast clojure/lang/IFn
    //   412: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   415: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   418: checkcast clojure/lang/IFn
    //   421: getstatic clojure/core/match/SwitchNode.const__43 : Lclojure/lang/Keyword;
    //   424: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   429: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   432: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   435: checkcast clojure/lang/IFn
    //   438: getstatic clojure/core/match/SwitchNode.const__46 : Lclojure/lang/Var;
    //   441: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   444: checkcast clojure/lang/IFn
    //   447: invokeinterface invoke : ()Ljava/lang/Object;
    //   452: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   457: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   462: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   467: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   472: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   477: astore_3
    //   478: getstatic clojure/core/match/SwitchNode.const__40 : Lclojure/lang/Var;
    //   481: invokevirtual get : ()Ljava/lang/Object;
    //   484: dup
    //   485: ifnull -> 704
    //   488: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   491: if_acmpeq -> 705
    //   494: aload_2
    //   495: dup
    //   496: ifnull -> 697
    //   499: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   502: if_acmpeq -> 698
    //   505: getstatic clojure/core/match/SwitchNode.const__33 : Lclojure/lang/Var;
    //   508: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   511: checkcast clojure/lang/IFn
    //   514: getstatic clojure/core/match/SwitchNode.const__20 : Lclojure/lang/Var;
    //   517: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   520: checkcast clojure/lang/IFn
    //   523: getstatic clojure/core/match/SwitchNode.const__19 : Lclojure/lang/Var;
    //   526: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   529: checkcast clojure/lang/IFn
    //   532: getstatic clojure/core/match/SwitchNode.const__20 : Lclojure/lang/Var;
    //   535: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   538: checkcast clojure/lang/IFn
    //   541: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   544: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   547: checkcast clojure/lang/IFn
    //   550: getstatic clojure/core/match/SwitchNode.const__47 : Lclojure/lang/AFn;
    //   553: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   558: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   561: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   564: checkcast clojure/lang/IFn
    //   567: getstatic clojure/core/match/SwitchNode.const__36 : Lclojure/lang/Var;
    //   570: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   573: checkcast clojure/lang/IFn
    //   576: getstatic clojure/core/match/SwitchNode.const__48 : Lclojure/lang/Var;
    //   579: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   582: getstatic clojure/core/match/SwitchNode.const__19 : Lclojure/lang/Var;
    //   585: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   588: checkcast clojure/lang/IFn
    //   591: getstatic clojure/core/match/SwitchNode.const__20 : Lclojure/lang/Var;
    //   594: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   597: checkcast clojure/lang/IFn
    //   600: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   603: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   606: checkcast clojure/lang/IFn
    //   609: aload_0
    //   610: getfield occurrence : Ljava/lang/Object;
    //   613: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   618: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   621: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   624: checkcast clojure/lang/IFn
    //   627: aload_2
    //   628: aconst_null
    //   629: astore_2
    //   630: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   635: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   640: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   645: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   650: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   655: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   660: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   665: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   668: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   671: checkcast clojure/lang/IFn
    //   674: aload_3
    //   675: aconst_null
    //   676: astore_3
    //   677: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   682: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   687: aconst_null
    //   688: astore_0
    //   689: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   694: goto -> 701
    //   697: pop
    //   698: aload_3
    //   699: aconst_null
    //   700: astore_3
    //   701: goto -> 1190
    //   704: pop
    //   705: aload_2
    //   706: dup
    //   707: ifnull -> 1046
    //   710: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   713: if_acmpeq -> 1047
    //   716: getstatic clojure/core/match/SwitchNode.const__19 : Lclojure/lang/Var;
    //   719: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   722: checkcast clojure/lang/IFn
    //   725: getstatic clojure/core/match/SwitchNode.const__20 : Lclojure/lang/Var;
    //   728: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   731: checkcast clojure/lang/IFn
    //   734: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   737: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   740: checkcast clojure/lang/IFn
    //   743: getstatic clojure/core/match/SwitchNode.const__49 : Lclojure/lang/AFn;
    //   746: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   751: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   754: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   757: checkcast clojure/lang/IFn
    //   760: getstatic clojure/core/match/SwitchNode.const__33 : Lclojure/lang/Var;
    //   763: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   766: checkcast clojure/lang/IFn
    //   769: getstatic clojure/core/match/SwitchNode.const__20 : Lclojure/lang/Var;
    //   772: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   775: checkcast clojure/lang/IFn
    //   778: getstatic clojure/core/match/SwitchNode.const__19 : Lclojure/lang/Var;
    //   781: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   784: checkcast clojure/lang/IFn
    //   787: getstatic clojure/core/match/SwitchNode.const__20 : Lclojure/lang/Var;
    //   790: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   793: checkcast clojure/lang/IFn
    //   796: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   799: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   802: checkcast clojure/lang/IFn
    //   805: getstatic clojure/core/match/SwitchNode.const__50 : Lclojure/lang/AFn;
    //   808: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   813: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   816: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   819: checkcast clojure/lang/IFn
    //   822: getstatic clojure/core/match/SwitchNode.const__36 : Lclojure/lang/Var;
    //   825: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   828: checkcast clojure/lang/IFn
    //   831: getstatic clojure/core/match/SwitchNode.const__48 : Lclojure/lang/Var;
    //   834: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   837: getstatic clojure/core/match/SwitchNode.const__19 : Lclojure/lang/Var;
    //   840: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   843: checkcast clojure/lang/IFn
    //   846: getstatic clojure/core/match/SwitchNode.const__20 : Lclojure/lang/Var;
    //   849: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   852: checkcast clojure/lang/IFn
    //   855: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   858: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   861: checkcast clojure/lang/IFn
    //   864: aload_0
    //   865: getfield occurrence : Ljava/lang/Object;
    //   868: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   873: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   876: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   879: checkcast clojure/lang/IFn
    //   882: aload_2
    //   883: aconst_null
    //   884: astore_2
    //   885: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   890: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   895: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   900: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   905: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   910: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   915: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   920: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   923: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   926: checkcast clojure/lang/IFn
    //   929: aload_3
    //   930: aconst_null
    //   931: astore_3
    //   932: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   937: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   942: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   947: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   952: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   955: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   958: checkcast clojure/lang/IFn
    //   961: getstatic clojure/core/match/SwitchNode.const__51 : Lclojure/lang/Var;
    //   964: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   967: checkcast clojure/lang/IFn
    //   970: aload_0
    //   971: getfield default : Ljava/lang/Object;
    //   974: dup
    //   975: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   978: getstatic clojure/core/match/SwitchNode.__cached_class__1 : Ljava/lang/Class;
    //   981: if_acmpeq -> 998
    //   984: dup
    //   985: instanceof clojure/core/match/protocols/INodeCompile
    //   988: ifne -> 1013
    //   991: dup
    //   992: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   995: putstatic clojure/core/match/SwitchNode.__cached_class__1 : Ljava/lang/Class;
    //   998: getstatic clojure/core/match/SwitchNode.const__44 : Lclojure/lang/Var;
    //   1001: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1004: swap
    //   1005: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1010: goto -> 1021
    //   1013: checkcast clojure/core/match/protocols/INodeCompile
    //   1016: invokeinterface n_to_clj : ()Ljava/lang/Object;
    //   1021: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1026: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1031: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1036: aconst_null
    //   1037: astore_0
    //   1038: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1043: goto -> 1190
    //   1046: pop
    //   1047: getstatic clojure/core/match/SwitchNode.const__19 : Lclojure/lang/Var;
    //   1050: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1053: checkcast clojure/lang/IFn
    //   1056: getstatic clojure/core/match/SwitchNode.const__20 : Lclojure/lang/Var;
    //   1059: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1062: checkcast clojure/lang/IFn
    //   1065: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   1068: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1071: checkcast clojure/lang/IFn
    //   1074: getstatic clojure/core/match/SwitchNode.const__52 : Lclojure/lang/AFn;
    //   1077: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1082: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   1085: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1088: checkcast clojure/lang/IFn
    //   1091: aload_3
    //   1092: aconst_null
    //   1093: astore_3
    //   1094: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1099: getstatic clojure/core/match/SwitchNode.const__41 : Lclojure/lang/Var;
    //   1102: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1105: checkcast clojure/lang/IFn
    //   1108: getstatic clojure/core/match/SwitchNode.const__51 : Lclojure/lang/Var;
    //   1111: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1114: checkcast clojure/lang/IFn
    //   1117: aload_0
    //   1118: getfield default : Ljava/lang/Object;
    //   1121: dup
    //   1122: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1125: getstatic clojure/core/match/SwitchNode.__cached_class__2 : Ljava/lang/Class;
    //   1128: if_acmpeq -> 1145
    //   1131: dup
    //   1132: instanceof clojure/core/match/protocols/INodeCompile
    //   1135: ifne -> 1160
    //   1138: dup
    //   1139: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1142: putstatic clojure/core/match/SwitchNode.__cached_class__2 : Ljava/lang/Class;
    //   1145: getstatic clojure/core/match/SwitchNode.const__44 : Lclojure/lang/Var;
    //   1148: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1151: swap
    //   1152: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1157: goto -> 1168
    //   1160: checkcast clojure/core/match/protocols/INodeCompile
    //   1163: invokeinterface n_to_clj : ()Ljava/lang/Object;
    //   1168: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1173: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1178: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1183: aconst_null
    //   1184: astore_0
    //   1185: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1190: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #440	-> 0
    //   #443	-> 6
    //   #444	-> 15
    //   #444	-> 24
    //   #444	-> 43
    //   #444	-> 52
    //   #443	-> 57
    //   #446	-> 63
    //   #446	-> 73
    //   #446	-> 80
    //   #446	-> 85
    //   #448	-> 122
    //   #449	-> 144
    //   #450	-> 153
    //   #450	-> 162
    //   #450	-> 171
    //   #450	-> 180
    //   #450	-> 186
    //   #450	-> 194
    //   #450	-> 199
    //   #450	-> 210
    //   #450	-> 219
    //   #450	-> 228
    //   #450	-> 234
    //   #450	-> 245
    //   #452	-> 248
    //   #452	-> 283
    //   #450	-> 299
    //   #450	-> 304
    //   #450	-> 309
    //   #450	-> 314
    //   #449	-> 319
    //   #453	-> 334
    //   #454	-> 343
    //   #454	-> 352
    //   #454	-> 361
    //   #454	-> 370
    //   #454	-> 376
    //   #454	-> 384
    //   #454	-> 389
    //   #454	-> 400
    //   #454	-> 409
    //   #454	-> 418
    //   #454	-> 424
    //   #454	-> 435
    //   #457	-> 444
    //   #457	-> 447
    //   #454	-> 452
    //   #454	-> 457
    //   #454	-> 462
    //   #454	-> 467
    //   #453	-> 472
    //   #458	-> 478
    //   #459	-> 494
    //   #460	-> 511
    //   #461	-> 520
    //   #461	-> 529
    //   #461	-> 538
    //   #461	-> 547
    //   #461	-> 553
    //   #461	-> 564
    //   #461	-> 573
    //   #461	-> 588
    //   #461	-> 597
    //   #461	-> 606
    //   #461	-> 613
    //   #461	-> 624
    //   #461	-> 630
    //   #461	-> 635
    //   #461	-> 640
    //   #461	-> 645
    //   #461	-> 650
    //   #461	-> 655
    //   #461	-> 660
    //   #463	-> 671
    //   #463	-> 677
    //   #461	-> 682
    //   #460	-> 687
    //   #465	-> 705
    //   #465	-> 722
    //   #465	-> 731
    //   #465	-> 740
    //   #465	-> 746
    //   #465	-> 757
    //   #467	-> 766
    //   #468	-> 775
    //   #468	-> 784
    //   #468	-> 793
    //   #468	-> 802
    //   #468	-> 808
    //   #468	-> 819
    //   #468	-> 828
    //   #468	-> 843
    //   #468	-> 852
    //   #468	-> 861
    //   #468	-> 868
    //   #468	-> 879
    //   #468	-> 885
    //   #468	-> 890
    //   #468	-> 895
    //   #468	-> 900
    //   #468	-> 905
    //   #468	-> 910
    //   #468	-> 915
    //   #470	-> 926
    //   #470	-> 932
    //   #468	-> 937
    //   #467	-> 942
    //   #465	-> 947
    //   #465	-> 958
    //   #471	-> 967
    //   #471	-> 970
    //   #471	-> 1005
    //   #471	-> 1021
    //   #465	-> 1026
    //   #465	-> 1031
    //   #465	-> 1036
    //   #465	-> 1053
    //   #465	-> 1062
    //   #465	-> 1071
    //   #465	-> 1077
    //   #465	-> 1088
    //   #465	-> 1094
    //   #465	-> 1105
    //   #474	-> 1114
    //   #474	-> 1117
    //   #474	-> 1152
    //   #474	-> 1168
    //   #465	-> 1173
    //   #465	-> 1178
    //   #465	-> 1183
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   63	1127	1	clauses	Ljava/lang/Object;
    //   122	1068	2	bind_expr	Ljava/lang/Object;
    //   478	712	3	cond_expr	Ljava/lang/Object;
    //   0	1190	0	this	Lclojure/core/match/SwitchNode; }
  
  public int hasheq() {
    int hq__7768__auto__36028 = this.__hasheq, h__7769__auto__36027 = RT.intCast(0x1E4C87AAL ^ APersistentMap.mapHasheq((IPersistentMap)this));
    this.__hasheq = h__7769__auto__36027;
    return (hq__7768__auto__36028 == 0L) ? h__7769__auto__36027 : hq__7768__auto__36028;
  }
  
  public int hashCode() {
    int hash__7771__auto__36030 = this.__hash, h__7772__auto__36029 = APersistentMap.mapHash((IPersistentMap)this);
    this.__hash = h__7772__auto__36029;
    return (hash__7771__auto__36030 == 0L) ? h__7772__auto__36029 : hash__7771__auto__36030;
  }
  
  public boolean equals(Object G__36014) { G__36014 = null;
    return APersistentMap.mapEquals((IPersistentMap)this, G__36014); }
  
  public IPersistentMap meta() { return (IPersistentMap)this.__meta; }
  
  public IObj withMeta(IPersistentMap G__36014) { G__36014 = null;
    return (IObj)new SwitchNode(this.occurrence, this.cases, this.default, G__36014, this.__extmap, this.__hash, this.__hasheq); }
  
  public Object valAt(Object k__7777__auto__) { k__7777__auto__ = null;
    return ((ILookup)this).valAt(k__7777__auto__, null); }
  
  public Object valAt(Object k__7779__auto__, Object else__7780__auto__) {
    Object G__36025 = k__7779__auto__;
    switch (Util.hash(G__36025) >> 1 & 0x3) {
      case 0:
        if (G__36025 == const__8);
        break;
      case 1:
        if (G__36025 == const__9);
        break;
      case 2:
        if (G__36025 == const__10);
        break;
    } 
    k__7779__auto__ = null;
    else__7780__auto__ = null;
    this = null;
    return RT.get(this.__extmap, k__7779__auto__, else__7780__auto__);
  }
  
  public ILookupThunk getLookupThunk(Keyword k__7782__auto__) {
    Object gclass = ((IFn)const__22.getRawRoot()).invoke(this), G__36018 = k__7782__auto__ = null;
    switch (Util.hash(G__36018) >> 1 & 0x3) {
      case 0:
        if (G__36018 == const__8)
          gclass = null; 
        break;
      case 1:
        if (G__36018 == const__9)
          gclass = null; 
        break;
      case 2:
        if (G__36018 == const__10)
          gclass = null; 
        break;
    } 
    return (ILookupThunk)null;
  }
  
  public int count() { return RT.intCast(Numbers.add(3L, RT.count(this.__extmap))); }
  
  public IPersistentCollection empty() { throw (Throwable)new UnsupportedOperationException((String)((IFn)const__24.getRawRoot()).invoke("Can't create empty: ", "clojure.core.match.SwitchNode")); }
  
  public IPersistentCollection cons(Object e__7786__auto__) { e__7786__auto__ = null;
    this = null;
    return (IPersistentCollection)((IFn)const__23).invoke(this, e__7786__auto__); }
  
  public boolean equiv(Object G__36014) {
    boolean or__5516__auto__36034 = Util.identical(this, G__36014);
    Object G__36014 = G__36014 = null;
    boolean and__5514__auto__36033 = Util.equiv(this.occurrence, ((SwitchNode)G__36014).occurrence), and__5514__auto__36032 = Util.equiv(this.cases, ((SwitchNode)G__36014).cases), and__5514__auto__36031 = Util.equiv(this.default, ((SwitchNode)G__36014).default);
    G__36014 = null;
    return RT.booleanCast(or__5516__auto__36034 ? (or__5516__auto__36034 ? Boolean.TRUE : Boolean.FALSE) : (Util.identical(((IFn)const__22.getRawRoot()).invoke(this), ((IFn)const__22.getRawRoot()).invoke(G__36014)) ? (and__5514__auto__36033 ? (and__5514__auto__36032 ? (and__5514__auto__36031 ? (Util.equiv(this.__extmap, ((SwitchNode)G__36014).__extmap) ? Boolean.TRUE : Boolean.FALSE) : (and__5514__auto__36031 ? Boolean.TRUE : Boolean.FALSE)) : (and__5514__auto__36032 ? Boolean.TRUE : Boolean.FALSE)) : (and__5514__auto__36033 ? Boolean.TRUE : Boolean.FALSE)) : null));
  }
  
  public boolean containsKey(Object k__7789__auto__) { k__7789__auto__ = null;
    this = null;
    return ((Boolean)((IFn)const__21.getRawRoot()).invoke(Util.identical(this, ((ILookup)this).valAt(k__7789__auto__, this)) ? Boolean.TRUE : Boolean.FALSE)).booleanValue(); }
  
  public IMapEntry entryAt(Object k__7791__auto__) {
    Object v__7792__auto__36035 = ((ILookup)this).valAt(k__7791__auto__, this);
    k__7791__auto__ = null;
    v__7792__auto__36035 = null;
    this = null;
    return (IMapEntry)(Util.identical(this, v__7792__auto__36035) ? null : MapEntry.create(k__7791__auto__, v__7792__auto__36035));
  }
  
  public ISeq seq() { this = null;
    return (ISeq)((IFn)const__19.getRawRoot()).invoke(((IFn)const__20.getRawRoot()).invoke(Tuple.create(MapEntry.create(const__10, this.occurrence), MapEntry.create(const__9, this.cases), MapEntry.create(const__8, this.default)), this.__extmap)); }
  
  public Iterator iterator() { return (Iterator)new RecordIterator((ILookup)this, (IPersistentVector)const__18, (Iterator)RT.iter(this.__extmap)); }
  
  public IPersistentMap assoc(Object k__7796__auto__, Object G__36014) {
    Object pred__36016 = const__16.getRawRoot(), expr__36017 = k__7796__auto__;
    if (((IFn)pred__36016).invoke(const__10, expr__36017) != null) {
      if (((IFn)pred__36016).invoke(const__10, expr__36017) != Boolean.FALSE)
        G__36014 = null; 
    } else {
      ((IFn)pred__36016).invoke(const__10, expr__36017);
    } 
    if (((IFn)pred__36016).invoke(const__9, expr__36017) != null) {
      if (((IFn)pred__36016).invoke(const__9, expr__36017) != Boolean.FALSE)
        G__36014 = null; 
    } else {
      ((IFn)pred__36016).invoke(const__9, expr__36017);
    } 
    pred__36016 = null;
    expr__36017 = null;
    if (((IFn)pred__36016).invoke(const__8, expr__36017) != null) {
      if (((IFn)pred__36016).invoke(const__8, expr__36017) != Boolean.FALSE)
        G__36014 = null; 
    } else {
      ((IFn)pred__36016).invoke(const__8, expr__36017);
    } 
    k__7796__auto__ = null;
    G__36014 = null;
    return (IPersistentMap)new SwitchNode(this.occurrence, this.cases, this.default, this.__meta, ((IFn)const__17.getRawRoot()).invoke(this.__extmap, k__7796__auto__, G__36014));
  }
  
  public IPersistentMap without(Object k__7798__auto__) { if (((IFn)const__7.getRawRoot()).invoke(const__11, k__7798__auto__) != null) {
      if (((IFn)const__7.getRawRoot()).invoke(const__11, k__7798__auto__) != Boolean.FALSE) {
        k__7798__auto__ = null;
        this = null;
      } 
    } else {
      ((IFn)const__7.getRawRoot()).invoke(const__11, k__7798__auto__);
    } 
    k__7798__auto__ = null;
    return (IPersistentMap)new SwitchNode(this.occurrence, this.cases, this.default, this.__meta, ((IFn)const__15.getRawRoot()).invoke(((IFn)const__12.getRawRoot()).invoke(this.__extmap, k__7798__auto__))); }
  
  public int size() { this = null;
    return ((Counted)this).count(); }
  
  public boolean isEmpty() { return Util.equiv(0L, ((Counted)this).count()); }
  
  public boolean containsValue(Object v__7802__auto__) { v__7802__auto__ = null;
    return RT.booleanCast(((IFn)const__4.getRawRoot()).invoke(RT.set(new Object[] { v__7802__auto__ }, ), ((IFn)const__1.getRawRoot()).invoke(this))); }
  
  public Object get(Object k__7804__auto__) { k__7804__auto__ = null;
    return ((ILookup)this).valAt(k__7804__auto__); }
  
  public Object put(Object k__7806__auto__, Object v__7807__auto__) { throw (Throwable)new UnsupportedOperationException(); }
  
  public Object remove(Object k__7809__auto__) { throw (Throwable)new UnsupportedOperationException(); }
  
  public void putAll(Map m__7811__auto__) { throw (Throwable)new UnsupportedOperationException(); }
  
  public void clear() { throw (Throwable)new UnsupportedOperationException(); }
  
  public Set keySet() { this = null;
    return (Set)((IFn)const__0.getRawRoot()).invoke(((IFn)const__2.getRawRoot()).invoke(this)); }
  
  public Collection values() { this = null;
    return (Collection)((IFn)const__1.getRawRoot()).invoke(this); }
  
  public Set entrySet() { this = null;
    return (Set)((IFn)const__0.getRawRoot()).invoke(this); }
}
