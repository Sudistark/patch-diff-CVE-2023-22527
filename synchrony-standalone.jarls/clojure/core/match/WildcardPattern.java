package clojure.core.match;

import clojure.lang.ILookup;
import clojure.lang.ILookupThunk;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.Keyword;
import clojure.lang.KeywordLookupSite;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Util;
import clojure.lang.Var;

public final class WildcardPattern implements ILookup, IObj, IType {
  public final Object sym;
  
  public final Object named;
  
  public final Object _meta;
  
  public static final Keyword const__3 = (Keyword)RT.keyword(null, "sym");
  
  public static final Var const__4 = (Var)RT.var("clojure.core", "not");
  
  public static final Keyword const__5 = (Keyword)RT.keyword(null, "named");
  
  static final KeywordLookupSite __site__0__;
  
  static ILookupThunk __thunk__0__ = __site__0__ = new KeywordLookupSite(RT.keyword(null, "sym"));
  
  static final KeywordLookupSite __site__1__;
  
  static ILookupThunk __thunk__1__ = __site__1__ = new KeywordLookupSite(RT.keyword(null, "named"));
  
  public WildcardPattern(Object paramObject1, Object paramObject2, Object paramObject3) { this.sym = paramObject1;
    this.named = paramObject2;
    this._meta = paramObject3; }
  
  public static IPersistentVector getBasis() { return Tuple.create(Symbol.intern(null, "sym"), Symbol.intern(null, "named"), Symbol.intern(null, "_meta")); }
  
  public Object valAt(Object k, Object not_found) {
    Object G__36231 = k = null;
    switch (Util.hash(G__36231) >> 0 & true) {
      case 0:
        if (G__36231 == const__3);
        break;
      case 1:
        if (G__36231 == const__5);
        break;
    } 
    return null;
  }
  
  public Object valAt(Object k) { k = null;
    return ((ILookup)this).valAt(k, null); }
  
  public IPersistentMap meta() { return (IPersistentMap)this._meta; }
  
  public IObj withMeta(IPersistentMap new_meta) { new_meta = null;
    return (IObj)new WildcardPattern(this.sym, this.named, new_meta); }
  
  public boolean equals(Object other) { // Byte code:
    //   0: aload_1
    //   1: instanceof clojure/core/match/WildcardPattern
    //   4: istore_2
    //   5: iload_2
    //   6: ifeq -> 154
    //   9: aload_0
    //   10: getfield named : Ljava/lang/Object;
    //   13: dup
    //   14: ifnull -> 90
    //   17: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   20: if_acmpeq -> 91
    //   23: aload_0
    //   24: getfield sym : Ljava/lang/Object;
    //   27: getstatic clojure/core/match/WildcardPattern.__thunk__0__ : Lclojure/lang/ILookupThunk;
    //   30: dup
    //   31: aload_1
    //   32: aconst_null
    //   33: astore_1
    //   34: dup_x2
    //   35: invokeinterface get : (Ljava/lang/Object;)Ljava/lang/Object;
    //   40: dup_x2
    //   41: if_acmpeq -> 48
    //   44: pop
    //   45: goto -> 70
    //   48: swap
    //   49: pop
    //   50: dup
    //   51: getstatic clojure/core/match/WildcardPattern.__site__0__ : Lclojure/lang/KeywordLookupSite;
    //   54: swap
    //   55: invokeinterface fault : (Ljava/lang/Object;)Lclojure/lang/ILookupThunk;
    //   60: dup
    //   61: putstatic clojure/core/match/WildcardPattern.__thunk__0__ : Lclojure/lang/ILookupThunk;
    //   64: swap
    //   65: invokeinterface get : (Ljava/lang/Object;)Ljava/lang/Object;
    //   70: aconst_null
    //   71: astore_0
    //   72: invokestatic equiv : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   75: ifeq -> 84
    //   78: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   81: goto -> 87
    //   84: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   87: goto -> 150
    //   90: pop
    //   91: getstatic clojure/core/match/WildcardPattern.const__4 : Lclojure/lang/Var;
    //   94: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   97: checkcast clojure/lang/IFn
    //   100: getstatic clojure/core/match/WildcardPattern.__thunk__1__ : Lclojure/lang/ILookupThunk;
    //   103: dup
    //   104: aload_1
    //   105: aconst_null
    //   106: astore_1
    //   107: dup_x2
    //   108: invokeinterface get : (Ljava/lang/Object;)Ljava/lang/Object;
    //   113: dup_x2
    //   114: if_acmpeq -> 121
    //   117: pop
    //   118: goto -> 143
    //   121: swap
    //   122: pop
    //   123: dup
    //   124: getstatic clojure/core/match/WildcardPattern.__site__1__ : Lclojure/lang/KeywordLookupSite;
    //   127: swap
    //   128: invokeinterface fault : (Ljava/lang/Object;)Lclojure/lang/ILookupThunk;
    //   133: dup
    //   134: putstatic clojure/core/match/WildcardPattern.__thunk__1__ : Lclojure/lang/ILookupThunk;
    //   137: swap
    //   138: invokeinterface get : (Ljava/lang/Object;)Ljava/lang/Object;
    //   143: aconst_null
    //   144: astore_0
    //   145: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   150: goto -> 167
    //   153: athrow
    //   154: iload_2
    //   155: ifeq -> 164
    //   158: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   161: goto -> 167
    //   164: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   167: checkcast java/lang/Boolean
    //   170: invokevirtual booleanValue : ()Z
    //   173: ireturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #847	-> 0
    //   #850	-> 5
    //   #851	-> 9
    //   #852	-> 27
    //   #852	-> 34
    //   #852	-> 70
    //   #853	-> 97
    //   #853	-> 100
    //   #853	-> 107
    //   #853	-> 143
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   5	162	2	and__5514__auto__36233	Z
    //   0	173	0	this	Lclojure/core/match/WildcardPattern;
    //   0	173	1	other	Ljava/lang/Object; }
}
