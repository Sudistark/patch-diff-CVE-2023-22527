package clojure.core;

import clojure.core;
import clojure.lang.AFn;
import clojure.lang.APersistentVector;
import clojure.lang.Associative;
import clojure.lang.Counted;
import clojure.lang.IFn;
import clojure.lang.IHashEq;
import clojure.lang.ILookup;
import clojure.lang.IMapEntry;
import clojure.lang.IMeta;
import clojure.lang.IObj;
import clojure.lang.IPersistentCollection;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentStack;
import clojure.lang.IPersistentVector;
import clojure.lang.ISeq;
import clojure.lang.IType;
import clojure.lang.Indexed;
import clojure.lang.Keyword;
import clojure.lang.MapEntry;
import clojure.lang.Murmur3;
import clojure.lang.Numbers;
import clojure.lang.RT;
import clojure.lang.Reversible;
import clojure.lang.Seqable;
import clojure.lang.Sequential;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Util;
import clojure.lang.Var;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.concurrent.atomic.AtomicInteger;

public final class Vec implements Associative, Collection, ILookup, Comparable, IPersistentCollection, IHashEq, IVecImpl, IObj, Reversible, IFn, IMeta, Counted, Sequential, IPersistentVector, Seqable, IPersistentStack, List, Iterable, Indexed, IType {
  public final Object am;
  
  public final int cnt;
  
  public final int shift;
  
  public final Object root;
  
  public final Object tail;
  
  public final Object _meta;
  
  public static final Object const__1 = Long.valueOf(0L);
  
  public static final Object const__6 = RT.classForName("clojure.lang.IPersistentVector");
  
  public static final Keyword const__12 = (Keyword)RT.keyword(null, "else");
  
  public static final Object const__17 = Long.valueOf(1L);
  
  public static final Object const__26 = RT.classForName("java.lang.Object");
  
  public static final Object const__32 = Long.valueOf(-1L);
  
  public static final Object const__35 = Long.valueOf(32L);
  
  public static final Var const__42 = (Var)RT.var("clojure.core", "EMPTY-NODE");
  
  public static final AFn const__53 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(432), RT.keyword(null, "column"), Integer.valueOf(7) }), const__56 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(387), RT.keyword(null, "column"), Integer.valueOf(7) });
  
  public Vec(Object paramObject1, int paramInt1, int paramInt2, Object paramObject2, Object paramObject3, Object paramObject4) { this.am = paramObject1;
    this.cnt = paramInt1;
    this.shift = paramInt2;
    this.root = paramObject2;
    this.tail = paramObject3;
    this._meta = paramObject4; }
  
  public static IPersistentVector getBasis() { return Tuple.create(((IObj)Symbol.intern(null, "am")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.core.ArrayManager") })), ((IObj)Symbol.intern(null, "cnt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "int") })), ((IObj)Symbol.intern(null, "shift")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "int") })), ((IObj)Symbol.intern(null, "root")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.core.VecNode") })), Symbol.intern(null, "tail"), Symbol.intern(null, "_meta")); }
  
  public Object nth(int i, Object not_found) {
    int z = RT.intCast(0L);
    boolean and__5514__auto__8272 = Numbers.gte(i, z);
    not_found = null;
    return (and__5514__auto__8272 ? Numbers.lt(i, ((Counted)this).count()) : and__5514__auto__8272) ? ((Indexed)this).nth(i) : not_found;
  }
  
  public Object nth(int i) {
    Object a = ((IVecImpl)this).arrayFor(i);
    a = null;
    return ((ArrayManager)this.am).aget(a, RT.intCast(i & RT.intCast(31L)));
  }
  
  public Iterator iterator() {
    Object i = new AtomicInteger(RT.intCast(0L));
    i = null;
    return (Iterator)((IObj)new reify__8269(null, this.cnt, this, i)).withMeta((IPersistentMap)const__56);
  }
  
  public Object set(int i, Object e) { throw (Throwable)new UnsupportedOperationException(); }
  
  public Object remove(int i) { throw (Throwable)new UnsupportedOperationException(); }
  
  public boolean addAll(int i, Collection c) { throw (Throwable)new UnsupportedOperationException(); }
  
  public void add(int i, Object o) { throw (Throwable)new UnsupportedOperationException(); }
  
  public List subList(int a, int z) { this = null;
    return (List)core.subvec.invokeStatic(this, Integer.valueOf(a), Integer.valueOf(z)); }
  
  public ListIterator listIterator(int i) {
    Object i = new AtomicInteger(i);
    i = null;
    return (ListIterator)((IObj)new reify__8267(null, this, i, this.cnt)).withMeta((IPersistentMap)const__53);
  }
  
  public ListIterator listIterator() { return (ListIterator)((List)this).listIterator(RT.intCast(0L)); }
  
  public int lastIndexOf(Object o) { // Byte code:
    //   0: aload_0
    //   1: getfield cnt : I
    //   4: i2l
    //   5: invokestatic dec : (J)J
    //   8: lstore_2
    //   9: lload_2
    //   10: lconst_0
    //   11: lcmp
    //   12: ifge -> 22
    //   15: getstatic clojure/core/Vec.const__32 : Ljava/lang/Object;
    //   18: goto -> 76
    //   21: athrow
    //   22: aload_1
    //   23: aload_0
    //   24: checkcast clojure/lang/Indexed
    //   27: lload_2
    //   28: invokestatic intCast : (J)I
    //   31: invokeinterface nth : (I)Ljava/lang/Object;
    //   36: invokestatic equiv : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   39: ifeq -> 50
    //   42: lload_2
    //   43: invokestatic num : (J)Ljava/lang/Number;
    //   46: goto -> 76
    //   49: athrow
    //   50: getstatic clojure/core/Vec.const__12 : Lclojure/lang/Keyword;
    //   53: dup
    //   54: ifnull -> 74
    //   57: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   60: if_acmpeq -> 75
    //   63: lload_2
    //   64: invokestatic dec : (J)J
    //   67: lstore_2
    //   68: goto -> 9
    //   71: nop
    //   72: nop
    //   73: athrow
    //   74: pop
    //   75: aconst_null
    //   76: checkcast java/lang/Number
    //   79: invokevirtual intValue : ()I
    //   82: ireturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #131	-> 0
    //   #424	-> 5
    //   #425	-> 9
    //   #426	-> 9
    //   #425	-> 22
    //   #427	-> 31
    //   #427	-> 36
    //   #425	-> 50
    //   #428	-> 64
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   9	67	2	i	J
    //   0	82	0	this	Lclojure/core/Vec;
    //   0	82	1	o	Ljava/lang/Object; }
  
  public int indexOf(Object o) { // Byte code:
    //   0: lconst_0
    //   1: invokestatic intCast : (J)I
    //   4: i2l
    //   5: lstore_2
    //   6: lload_2
    //   7: aload_0
    //   8: getfield cnt : I
    //   11: i2l
    //   12: lcmp
    //   13: ifne -> 23
    //   16: getstatic clojure/core/Vec.const__32 : Ljava/lang/Object;
    //   19: goto -> 77
    //   22: athrow
    //   23: aload_1
    //   24: aload_0
    //   25: checkcast clojure/lang/Indexed
    //   28: lload_2
    //   29: invokestatic intCast : (J)I
    //   32: invokeinterface nth : (I)Ljava/lang/Object;
    //   37: invokestatic equiv : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   40: ifeq -> 51
    //   43: lload_2
    //   44: invokestatic num : (J)Ljava/lang/Number;
    //   47: goto -> 77
    //   50: athrow
    //   51: getstatic clojure/core/Vec.const__12 : Lclojure/lang/Keyword;
    //   54: dup
    //   55: ifnull -> 75
    //   58: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   61: if_acmpeq -> 76
    //   64: lload_2
    //   65: invokestatic inc : (J)J
    //   68: lstore_2
    //   69: goto -> 6
    //   72: nop
    //   73: nop
    //   74: athrow
    //   75: pop
    //   76: aconst_null
    //   77: checkcast java/lang/Number
    //   80: invokevirtual intValue : ()I
    //   83: ireturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #131	-> 0
    //   #418	-> 1
    //   #0	-> 4
    //   #419	-> 6
    //   #420	-> 6
    //   #419	-> 23
    //   #421	-> 32
    //   #421	-> 37
    //   #419	-> 51
    //   #422	-> 65
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   6	71	2	i	J
    //   0	83	0	this	Lclojure/core/Vec;
    //   0	83	1	o	Ljava/lang/Object; }
  
  public Object get(int i) {
    return ((Indexed)this).nth(i);
  }
  
  public IPersistentStack pop() { // Byte code:
    //   0: aload_0
    //   1: getfield cnt : I
    //   4: i2l
    //   5: lconst_0
    //   6: lcmp
    //   7: ifne -> 31
    //   10: new java/lang/IllegalStateException
    //   13: dup
    //   14: ldc_w 'Can't pop empty vector'
    //   17: checkcast java/lang/String
    //   20: invokespecial <init> : (Ljava/lang/String;)V
    //   23: checkcast java/lang/Throwable
    //   26: athrow
    //   27: nop
    //   28: nop
    //   29: athrow
    //   30: athrow
    //   31: lconst_1
    //   32: aload_0
    //   33: getfield cnt : I
    //   36: i2l
    //   37: lcmp
    //   38: ifne -> 92
    //   41: new clojure/core/Vec
    //   44: dup
    //   45: aload_0
    //   46: getfield am : Ljava/lang/Object;
    //   49: lconst_0
    //   50: invokestatic intCast : (J)I
    //   53: ldc2_w 5
    //   56: invokestatic intCast : (J)I
    //   59: getstatic clojure/core/Vec.const__42 : Lclojure/lang/Var;
    //   62: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   65: aload_0
    //   66: getfield am : Ljava/lang/Object;
    //   69: checkcast clojure/core/ArrayManager
    //   72: lconst_0
    //   73: invokestatic intCast : (J)I
    //   76: invokeinterface array : (I)Ljava/lang/Object;
    //   81: aload_0
    //   82: invokestatic invokeStatic : (Ljava/lang/Object;)Ljava/lang/Object;
    //   85: invokespecial <init> : (Ljava/lang/Object;IILjava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V
    //   88: goto -> 497
    //   91: athrow
    //   92: aload_0
    //   93: getfield cnt : I
    //   96: i2l
    //   97: aload_0
    //   98: checkcast clojure/core/IVecImpl
    //   101: invokeinterface tailoff : ()I
    //   106: i2l
    //   107: invokestatic minus : (JJ)J
    //   110: lconst_1
    //   111: lcmp
    //   112: ifle -> 221
    //   115: aload_0
    //   116: getfield am : Ljava/lang/Object;
    //   119: checkcast clojure/core/ArrayManager
    //   122: aload_0
    //   123: getfield am : Ljava/lang/Object;
    //   126: checkcast clojure/core/ArrayManager
    //   129: aload_0
    //   130: getfield tail : Ljava/lang/Object;
    //   133: invokeinterface alength : (Ljava/lang/Object;)I
    //   138: i2l
    //   139: invokestatic dec : (J)J
    //   142: invokestatic intCast : (J)I
    //   145: invokeinterface array : (I)Ljava/lang/Object;
    //   150: astore_1
    //   151: aload_0
    //   152: getfield tail : Ljava/lang/Object;
    //   155: lconst_0
    //   156: invokestatic intCast : (J)I
    //   159: aload_1
    //   160: lconst_0
    //   161: invokestatic intCast : (J)I
    //   164: aload_0
    //   165: getfield am : Ljava/lang/Object;
    //   168: checkcast clojure/core/ArrayManager
    //   171: aload_1
    //   172: invokeinterface alength : (Ljava/lang/Object;)I
    //   177: invokestatic arraycopy : (Ljava/lang/Object;ILjava/lang/Object;II)V
    //   180: new clojure/core/Vec
    //   183: dup
    //   184: aload_0
    //   185: getfield am : Ljava/lang/Object;
    //   188: aload_0
    //   189: getfield cnt : I
    //   192: i2l
    //   193: invokestatic dec : (J)J
    //   196: invokestatic intCast : (J)I
    //   199: aload_0
    //   200: getfield shift : I
    //   203: aload_0
    //   204: getfield root : Ljava/lang/Object;
    //   207: aload_1
    //   208: aconst_null
    //   209: astore_1
    //   210: aload_0
    //   211: invokestatic invokeStatic : (Ljava/lang/Object;)Ljava/lang/Object;
    //   214: invokespecial <init> : (Ljava/lang/Object;IILjava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V
    //   217: goto -> 497
    //   220: athrow
    //   221: getstatic clojure/core/Vec.const__12 : Lclojure/lang/Keyword;
    //   224: dup
    //   225: ifnull -> 495
    //   228: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   231: if_acmpeq -> 496
    //   234: aload_0
    //   235: checkcast clojure/core/IVecImpl
    //   238: aload_0
    //   239: getfield cnt : I
    //   242: i2l
    //   243: ldc2_w 2
    //   246: invokestatic minus : (JJ)J
    //   249: invokestatic intCast : (J)I
    //   252: invokeinterface arrayFor : (I)Ljava/lang/Object;
    //   257: astore_1
    //   258: aload_0
    //   259: checkcast clojure/core/IVecImpl
    //   262: aload_0
    //   263: getfield shift : I
    //   266: aload_0
    //   267: getfield root : Ljava/lang/Object;
    //   270: invokeinterface popTail : (ILjava/lang/Object;)Ljava/lang/Object;
    //   275: astore_2
    //   276: aload_2
    //   277: aconst_null
    //   278: invokestatic identical : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   281: ifeq -> 327
    //   284: new clojure/core/Vec
    //   287: dup
    //   288: aload_0
    //   289: getfield am : Ljava/lang/Object;
    //   292: aload_0
    //   293: getfield cnt : I
    //   296: i2l
    //   297: invokestatic dec : (J)J
    //   300: invokestatic intCast : (J)I
    //   303: aload_0
    //   304: getfield shift : I
    //   307: getstatic clojure/core/Vec.const__42 : Lclojure/lang/Var;
    //   310: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   313: aload_1
    //   314: aconst_null
    //   315: astore_1
    //   316: aload_0
    //   317: invokestatic invokeStatic : (Ljava/lang/Object;)Ljava/lang/Object;
    //   320: invokespecial <init> : (Ljava/lang/Object;IILjava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V
    //   323: goto -> 492
    //   326: athrow
    //   327: aload_0
    //   328: getfield shift : I
    //   331: i2l
    //   332: ldc2_w 5
    //   335: invokestatic gt : (JJ)Z
    //   338: istore_3
    //   339: iload_3
    //   340: ifeq -> 368
    //   343: aload_2
    //   344: checkcast clojure/core/VecNode
    //   347: getfield arr : Ljava/lang/Object;
    //   350: checkcast [Ljava/lang/Object;
    //   353: lconst_1
    //   354: invokestatic intCast : (J)I
    //   357: invokestatic aget : ([Ljava/lang/Object;I)Ljava/lang/Object;
    //   360: aconst_null
    //   361: invokestatic identical : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   364: goto -> 369
    //   367: athrow
    //   368: iload_3
    //   369: ifeq -> 438
    //   372: new clojure/core/Vec
    //   375: dup
    //   376: aload_0
    //   377: getfield am : Ljava/lang/Object;
    //   380: aload_0
    //   381: getfield cnt : I
    //   384: i2l
    //   385: invokestatic dec : (J)J
    //   388: invokestatic intCast : (J)I
    //   391: aload_0
    //   392: getfield shift : I
    //   395: i2l
    //   396: ldc2_w 5
    //   399: invokestatic minus : (JJ)J
    //   402: invokestatic intCast : (J)I
    //   405: aload_2
    //   406: aconst_null
    //   407: astore_2
    //   408: checkcast clojure/core/VecNode
    //   411: getfield arr : Ljava/lang/Object;
    //   414: checkcast [Ljava/lang/Object;
    //   417: lconst_0
    //   418: invokestatic intCast : (J)I
    //   421: invokestatic aget : ([Ljava/lang/Object;I)Ljava/lang/Object;
    //   424: aload_1
    //   425: aconst_null
    //   426: astore_1
    //   427: aload_0
    //   428: invokestatic invokeStatic : (Ljava/lang/Object;)Ljava/lang/Object;
    //   431: invokespecial <init> : (Ljava/lang/Object;IILjava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V
    //   434: goto -> 492
    //   437: athrow
    //   438: getstatic clojure/core/Vec.const__12 : Lclojure/lang/Keyword;
    //   441: dup
    //   442: ifnull -> 490
    //   445: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   448: if_acmpeq -> 491
    //   451: new clojure/core/Vec
    //   454: dup
    //   455: aload_0
    //   456: getfield am : Ljava/lang/Object;
    //   459: aload_0
    //   460: getfield cnt : I
    //   463: i2l
    //   464: invokestatic dec : (J)J
    //   467: invokestatic intCast : (J)I
    //   470: aload_0
    //   471: getfield shift : I
    //   474: aload_2
    //   475: aconst_null
    //   476: astore_2
    //   477: aload_1
    //   478: aconst_null
    //   479: astore_1
    //   480: aload_0
    //   481: invokestatic invokeStatic : (Ljava/lang/Object;)Ljava/lang/Object;
    //   484: invokespecial <init> : (Ljava/lang/Object;IILjava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V
    //   487: goto -> 492
    //   490: pop
    //   491: aconst_null
    //   492: goto -> 497
    //   495: pop
    //   496: aconst_null
    //   497: checkcast clojure/lang/IPersistentStack
    //   500: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #131	-> 0
    //   #220	-> 0
    //   #221	-> 0
    //   #220	-> 31
    //   #223	-> 31
    //   #224	-> 76
    //   #220	-> 92
    //   #225	-> 92
    //   #225	-> 101
    //   #225	-> 107
    //   #226	-> 133
    //   #226	-> 139
    //   #226	-> 145
    //   #227	-> 172
    //   #227	-> 177
    //   #228	-> 193
    //   #220	-> 221
    //   #230	-> 246
    //   #230	-> 252
    //   #231	-> 270
    //   #232	-> 276
    //   #233	-> 278
    //   #234	-> 297
    //   #232	-> 327
    //   #235	-> 335
    //   #235	-> 339
    //   #235	-> 344
    //   #235	-> 354
    //   #235	-> 357
    //   #235	-> 361
    //   #236	-> 385
    //   #236	-> 399
    //   #236	-> 408
    //   #236	-> 418
    //   #236	-> 421
    //   #232	-> 438
    //   #238	-> 464
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   151	66	1	new_tail	Ljava/lang/Object;
    //   339	30	3	and__5514__auto__8273	Z
    //   258	234	1	new_tail	Ljava/lang/Object;
    //   276	216	2	new_root	Ljava/lang/Object;
    //   0	500	0	this	Lclojure/core/Vec; }
  
  public Object peek() {
    return (this.cnt > RT.intCast(0L)) ? ((Indexed)this).nth(RT.intCast(Numbers.dec(this.cnt))) : null;
  }
  
  public ISeq seq() {
    return (ISeq)((this.cnt == 0L) ? null : new VecSeq(this.am, this, ((IVecImpl)this).arrayFor(RT.intCast(0L)), RT.intCast(0L), RT.intCast(0L)));
  }
  
  public int length() { return this.cnt; }
  
  public IPersistentVector assocN(int i, Object val) {
    boolean and__5514__auto__8274 = Numbers.lte(RT.intCast(0L), i);
    Object new_tail = ((ArrayManager)this.am).array(((ArrayManager)this.am).alength(this.tail));
    System.arraycopy(this.tail, RT.intCast(0L), new_tail, RT.intCast(0L), ((ArrayManager)this.am).alength(this.tail));
    val = null;
    ((ArrayManager)this.am).aset(new_tail, RT.intCast(i & RT.intCast(31L)), val);
    new_tail = null;
    val = null;
    if (i == this.cnt) {
      val = null;
    } else if (const__12 != null) {
      if (const__12 != Boolean.FALSE)
        throw (Throwable)new IndexOutOfBoundsException(); 
    } else {
      const__12;
    } 
    return (IPersistentVector)((and__5514__auto__8274 ? Numbers.lt(i, this.cnt) : and__5514__auto__8274) ? ((i >= ((IVecImpl)this).tailoff()) ? new Vec(this.am, this.cnt, this.shift, this.root, new_tail, core.meta__5418.invokeStatic(this)) : new Vec(this.am, this.cnt, this.shift, ((IVecImpl)this).doAssoc(this.shift, this.root, i, val), this.tail, core.meta__5418.invokeStatic(this))) : null);
  }
  
  public int count() { return this.cnt; }
  
  public IPersistentMap meta() { return (IPersistentMap)this._meta; }
  
  public Object invoke(Object k) { // Byte code:
    //   0: aload_1
    //   1: invokestatic isInteger : (Ljava/lang/Object;)Z
    //   4: ifeq -> 72
    //   7: aload_1
    //   8: aconst_null
    //   9: astore_1
    //   10: invokestatic intCast : (Ljava/lang/Object;)I
    //   13: istore_2
    //   14: iload_2
    //   15: i2l
    //   16: lconst_0
    //   17: invokestatic gte : (JJ)Z
    //   20: istore_3
    //   21: iload_3
    //   22: ifeq -> 39
    //   25: iload_2
    //   26: i2l
    //   27: aload_0
    //   28: getfield cnt : I
    //   31: i2l
    //   32: invokestatic lt : (JJ)Z
    //   35: goto -> 40
    //   38: athrow
    //   39: iload_3
    //   40: ifeq -> 57
    //   43: aload_0
    //   44: checkcast clojure/lang/Indexed
    //   47: iload_2
    //   48: invokeinterface nth : (I)Ljava/lang/Object;
    //   53: goto -> 68
    //   56: athrow
    //   57: new java/lang/IndexOutOfBoundsException
    //   60: dup
    //   61: invokespecial <init> : ()V
    //   64: checkcast java/lang/Throwable
    //   67: athrow
    //   68: goto -> 89
    //   71: athrow
    //   72: new java/lang/IllegalArgumentException
    //   75: dup
    //   76: ldc_w 'Key must be integer'
    //   79: checkcast java/lang/String
    //   82: invokespecial <init> : (Ljava/lang/String;)V
    //   85: checkcast java/lang/Throwable
    //   88: athrow
    //   89: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #131	-> 0
    //   #287	-> 0
    //   #287	-> 1
    //   #288	-> 10
    //   #289	-> 14
    //   #289	-> 17
    //   #289	-> 21
    //   #289	-> 32
    //   #290	-> 48
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   21	19	3	and__5514__auto__8275	Z
    //   14	54	2	i	I
    //   0	89	0	this	Lclojure/core/Vec;
    //   0	89	1	k	Ljava/lang/Object; }
  
  public ISeq rseq() {
    return (ISeq)((((Counted)this).count() > 0L) ? new APersistentVector.RSeq((IPersistentVector)this, RT.intCast(Numbers.dec(((Counted)this).count()))) : null);
  }
  
  public IObj withMeta(IPersistentMap m) { m = null;
    return (IObj)new Vec(this.am, this.cnt, this.shift, this.root, this.tail, m); }
  
  public Object doAssoc(int level, Object node, int i, Object val) {
    Object node = node = null;
    Object arr = ((ArrayManager)this.am).aclone(((VecNode)node).arr);
    val = null;
    ((ArrayManager)this.am).aset(arr, RT.intCast(i & RT.intCast(31L)), val);
    node = null;
    arr = null;
    Object[] arrayOfObject = RT.aclone((Object[])((VecNode)node).arr);
    long subidx = i >> (int)level & RT.intCast(31L);
    val = null;
    RT.aset((Object[])arrayOfObject, RT.intCast(subidx), ((IVecImpl)this).doAssoc(RT.intCast(Numbers.minus(level, RT.intCast(5L))), RT.aget((Object[])arrayOfObject, RT.intCast(subidx)), i, val));
    node = null;
    arrayOfObject = null;
    return (level == 0L) ? new VecNode(((VecNode)node).edit, arr) : new VecNode(((VecNode)node).edit, arrayOfObject);
  }
  
  public Object newPath(Object edit, int level, Object node) {
    node = null;
    Object ret = new VecNode(edit, RT.object_array(const__35));
    edit = null;
    node = null;
    RT.aset((Object[])((VecNode)ret).arr, RT.intCast(0L), ((IVecImpl)this).newPath(edit, RT.intCast(Numbers.minus(level, RT.intCast(5L))), node));
    ret = null;
    return (level == 0L) ? node : ret;
  }
  
  public Object popTail(int level, Object node) {
    Object node = node = null;
    long subidx = Numbers.minus(this.cnt, RT.intCast(2L)) >> (int)level & RT.intCast(31L);
    Object new_child = ((IVecImpl)this).popTail(RT.intCast(Numbers.minus(level, 5L)), RT.aget((Object[])((VecNode)node).arr, RT.intCast(subidx)));
    boolean and__5514__auto__8276 = Util.identical(new_child, null);
    node = null;
    Object[] arrayOfObject = RT.aclone((Object[])((VecNode)node).arr);
    new_child = null;
    RT.aset((Object[])arrayOfObject, RT.intCast(subidx), new_child);
    arrayOfObject = null;
    if (const__12 != null) {
      if (const__12 != Boolean.FALSE) {
        node = null;
        Object[] arrayOfObject1 = RT.aclone((Object[])((VecNode)node).arr);
        RT.aset((Object[])arrayOfObject1, RT.intCast(subidx), null);
        arrayOfObject1 = null;
      } 
    } else {
      const__12;
    } 
    return (level > 5L) ? ((and__5514__auto__8276 ? Numbers.isZero(subidx) : and__5514__auto__8276) ? null : new VecNode(((VecNode)this.root).edit, arrayOfObject)) : ((subidx == 0L) ? null : null);
  }
  
  public Object pushTail(int level, VecNode parent, VecNode tailnode) {
    long subidx = Numbers.dec(this.cnt) >> (int)level & RT.intCast(31L);
    Object parent = parent = null;
    ret = new VecNode(((VecNode)parent).edit, RT.aclone((Object[])((VecNode)parent).arr));
    tailnode = null;
    parent = null;
    Object child = RT.aget((Object[])((VecNode)parent).arr, RT.intCast(subidx));
    if (child != null) {
      if (child != Boolean.FALSE) {
        child = null;
        tailnode = null;
      } 
    } else {
      child;
    } 
    tailnode = null;
    Object node_to_insert = (level == RT.intCast(5L)) ? tailnode : ((IVecImpl)this).newPath(((VecNode)this.root).edit, RT.intCast(Numbers.minus(level, RT.intCast(5L))), tailnode);
    node_to_insert = null;
    RT.aset((Object[])((VecNode)ret).arr, RT.intCast(subidx), node_to_insert);
    return null;
  }
  
  public Object arrayFor(int i) { // Byte code:
    //   0: lconst_0
    //   1: invokestatic intCast : (J)I
    //   4: i2l
    //   5: iload_1
    //   6: i2l
    //   7: invokestatic lte : (JJ)Z
    //   10: istore_2
    //   11: iload_2
    //   12: ifeq -> 29
    //   15: iload_1
    //   16: i2l
    //   17: aload_0
    //   18: getfield cnt : I
    //   21: i2l
    //   22: invokestatic lt : (JJ)Z
    //   25: goto -> 30
    //   28: athrow
    //   29: iload_2
    //   30: ifeq -> 138
    //   33: iload_1
    //   34: i2l
    //   35: aload_0
    //   36: checkcast clojure/core/IVecImpl
    //   39: invokeinterface tailoff : ()I
    //   44: i2l
    //   45: lcmp
    //   46: iflt -> 57
    //   49: aload_0
    //   50: getfield tail : Ljava/lang/Object;
    //   53: goto -> 134
    //   56: athrow
    //   57: aload_0
    //   58: getfield root : Ljava/lang/Object;
    //   61: astore_2
    //   62: aload_0
    //   63: getfield shift : I
    //   66: i2l
    //   67: lstore_3
    //   68: lload_3
    //   69: lconst_0
    //   70: lcmp
    //   71: ifne -> 87
    //   74: aload_2
    //   75: aconst_null
    //   76: astore_2
    //   77: checkcast clojure/core/VecNode
    //   80: getfield arr : Ljava/lang/Object;
    //   83: goto -> 134
    //   86: athrow
    //   87: aload_2
    //   88: aconst_null
    //   89: astore_2
    //   90: checkcast clojure/core/VecNode
    //   93: getfield arr : Ljava/lang/Object;
    //   96: checkcast [Ljava/lang/Object;
    //   99: iload_1
    //   100: i2l
    //   101: lload_3
    //   102: l2i
    //   103: lshr
    //   104: ldc2_w 31
    //   107: invokestatic intCast : (J)I
    //   110: i2l
    //   111: land
    //   112: invokestatic intCast : (J)I
    //   115: invokestatic aget : ([Ljava/lang/Object;I)Ljava/lang/Object;
    //   118: lload_3
    //   119: ldc2_w 5
    //   122: invokestatic intCast : (J)I
    //   125: i2l
    //   126: invokestatic minus : (JJ)J
    //   129: lstore_3
    //   130: astore_2
    //   131: goto -> 68
    //   134: goto -> 149
    //   137: athrow
    //   138: new java/lang/IndexOutOfBoundsException
    //   141: dup
    //   142: invokespecial <init> : ()V
    //   145: checkcast java/lang/Throwable
    //   148: athrow
    //   149: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #131	-> 0
    //   #308	-> 0
    //   #308	-> 1
    //   #308	-> 7
    //   #308	-> 11
    //   #308	-> 22
    //   #309	-> 33
    //   #309	-> 33
    //   #309	-> 39
    //   #0	-> 66
    //   #312	-> 68
    //   #312	-> 68
    //   #313	-> 77
    //   #314	-> 90
    //   #314	-> 102
    //   #314	-> 107
    //   #314	-> 111
    //   #314	-> 112
    //   #314	-> 115
    //   #315	-> 122
    //   #315	-> 126
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   11	19	2	and__5514__auto__8277	Z
    //   62	72	2	node	Ljava/lang/Object;
    //   68	66	3	level	J
    //   0	149	0	this	Lclojure/core/Vec;
    //   0	149	1	i	I }
  
  public int tailoff() {
    return RT.intCast(Numbers.minus(this.cnt, ((ArrayManager)this.am).alength(this.tail)));
  }
  
  public int hasheq() {
    return Murmur3.hashOrdered((Iterable)this);
  }
  
  public boolean equiv(Object o) { // Byte code:
    //   0: aload_1
    //   1: instanceof clojure/lang/IPersistentVector
    //   4: istore_2
    //   5: iload_2
    //   6: ifeq -> 14
    //   9: iload_2
    //   10: goto -> 18
    //   13: athrow
    //   14: aload_1
    //   15: instanceof java/util/RandomAccess
    //   18: ifeq -> 143
    //   21: aload_0
    //   22: getfield cnt : I
    //   25: i2l
    //   26: aload_1
    //   27: invokestatic count : (Ljava/lang/Object;)I
    //   30: i2l
    //   31: invokestatic equiv : (JJ)Z
    //   34: istore_2
    //   35: iload_2
    //   36: ifeq -> 126
    //   39: lconst_0
    //   40: invokestatic intCast : (J)I
    //   43: i2l
    //   44: lstore_3
    //   45: lload_3
    //   46: aload_0
    //   47: getfield cnt : I
    //   50: i2l
    //   51: lcmp
    //   52: ifne -> 62
    //   55: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   58: goto -> 122
    //   61: athrow
    //   62: aload_0
    //   63: checkcast clojure/lang/Indexed
    //   66: lload_3
    //   67: invokestatic intCast : (J)I
    //   70: invokeinterface nth : (I)Ljava/lang/Object;
    //   75: aload_1
    //   76: lload_3
    //   77: invokestatic intCast : (J)I
    //   80: invokestatic nth : (Ljava/lang/Object;I)Ljava/lang/Object;
    //   83: invokestatic equiv : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   86: ifeq -> 101
    //   89: lload_3
    //   90: invokestatic inc : (J)J
    //   93: lstore_3
    //   94: goto -> 45
    //   97: nop
    //   98: nop
    //   99: athrow
    //   100: athrow
    //   101: getstatic clojure/core/Vec.const__12 : Lclojure/lang/Keyword;
    //   104: dup
    //   105: ifnull -> 120
    //   108: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   111: if_acmpeq -> 121
    //   114: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   117: goto -> 122
    //   120: pop
    //   121: aconst_null
    //   122: goto -> 139
    //   125: athrow
    //   126: iload_2
    //   127: ifeq -> 136
    //   130: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   133: goto -> 139
    //   136: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   139: goto -> 216
    //   142: athrow
    //   143: aload_1
    //   144: instanceof clojure/lang/Sequential
    //   147: istore_2
    //   148: iload_2
    //   149: ifeq -> 157
    //   152: iload_2
    //   153: goto -> 161
    //   156: athrow
    //   157: aload_1
    //   158: instanceof java/util/List
    //   161: ifeq -> 195
    //   164: aload_0
    //   165: invokestatic invokeStatic : (Ljava/lang/Object;)Ljava/lang/Object;
    //   168: aload_1
    //   169: aconst_null
    //   170: astore_1
    //   171: invokestatic invokeStatic : (Ljava/lang/Object;)Ljava/lang/Object;
    //   174: aconst_null
    //   175: astore_0
    //   176: invokestatic equiv : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   179: ifeq -> 188
    //   182: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   185: goto -> 191
    //   188: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   191: goto -> 216
    //   194: athrow
    //   195: getstatic clojure/core/Vec.const__12 : Lclojure/lang/Keyword;
    //   198: dup
    //   199: ifnull -> 214
    //   202: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   205: if_acmpeq -> 215
    //   208: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   211: goto -> 216
    //   214: pop
    //   215: aconst_null
    //   216: checkcast java/lang/Boolean
    //   219: invokevirtual booleanValue : ()Z
    //   222: ireturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #131	-> 0
    //   #202	-> 0
    //   #203	-> 5
    //   #204	-> 27
    //   #204	-> 31
    //   #204	-> 35
    //   #205	-> 40
    //   #0	-> 43
    //   #206	-> 45
    //   #207	-> 45
    //   #206	-> 62
    //   #208	-> 70
    //   #208	-> 80
    //   #208	-> 83
    //   #208	-> 90
    //   #206	-> 101
    //   #202	-> 143
    //   #210	-> 148
    //   #211	-> 174
    //   #202	-> 195
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   5	13	2	or__5516__auto__8278	Z
    //   45	77	3	i	J
    //   35	104	2	and__5514__auto__8279	Z
    //   148	13	2	or__5516__auto__8280	Z
    //   0	222	0	this	Lclojure/core/Vec;
    //   0	222	1	o	Ljava/lang/Object; }
  
  public IPersistentCollection empty() {
    return (IPersistentCollection)new Vec(this.am, RT.intCast(0L), RT.intCast(5L), const__42.getRawRoot(), ((ArrayManager)this.am).array(RT.intCast(0L)), null);
  }
  
  public IPersistentVector cons(Object val) {
    Object new_tail = ((ArrayManager)this.am).array(RT.intCast(Numbers.inc(((ArrayManager)this.am).alength(this.tail))));
    System.arraycopy(this.tail, RT.intCast(0L), new_tail, RT.intCast(0L), ((ArrayManager)this.am).alength(this.tail));
    val = null;
    ((ArrayManager)this.am).aset(new_tail, ((ArrayManager)this.am).alength(this.tail), val);
    new_tail = null;
    Object tail_node = new VecNode(((VecNode)this.root).edit, this.tail);
    Object new_root = new VecNode(((VecNode)this.root).edit, RT.object_array(const__35));
    Object G__8266 = ((VecNode)new_root).arr;
    RT.aset((Object[])G__8266, RT.intCast(0L), this.root);
    tail_node = null;
    RT.aset((Object[])G__8266, RT.intCast(1L), ((IVecImpl)this).newPath(((VecNode)this.root).edit, this.shift, tail_node));
    new_root = null;
    Object tl = ((ArrayManager)this.am).array(RT.intCast(1L));
    val = null;
    ((ArrayManager)this.am).aset(tl, RT.intCast(0L), val);
    tl = null;
    tail_node = null;
    Object tl = ((ArrayManager)this.am).array(RT.intCast(1L));
    val = null;
    ((ArrayManager)this.am).aset(tl, RT.intCast(0L), val);
    tl = null;
    return (IPersistentVector)((Numbers.minus(this.cnt, ((IVecImpl)this).tailoff()) < RT.intCast(32L)) ? new Vec(this.am, RT.intCast(Numbers.inc(this.cnt)), this.shift, this.root, new_tail, core.meta__5418.invokeStatic(this)) : ((this.cnt >> (int)RT.intCast(5L) > RT.intCast(1L) << (int)this.shift) ? new Vec(this.am, RT.intCast(Numbers.inc(this.cnt)), RT.intCast(Numbers.add(this.shift, RT.intCast(5L))), new_root, tl, core.meta__5418.invokeStatic(this)) : new Vec(this.am, RT.intCast(Numbers.inc(this.cnt)), this.shift, ((IVecImpl)this).pushTail(this.shift, (VecNode)this.root, (VecNode)tail_node), tl, core.meta__5418.invokeStatic(this))));
  }
  
  public int compareTo(Object o) { // Byte code:
    //   0: aload_0
    //   1: aload_1
    //   2: invokestatic identical : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   5: ifeq -> 15
    //   8: getstatic clojure/core/Vec.const__1 : Ljava/lang/Object;
    //   11: goto -> 174
    //   14: athrow
    //   15: getstatic clojure/core/Vec.const__6 : Ljava/lang/Object;
    //   18: aload_1
    //   19: aconst_null
    //   20: astore_1
    //   21: invokestatic invokeStatic : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   24: astore_2
    //   25: aload_2
    //   26: checkcast clojure/lang/Counted
    //   29: invokeinterface count : ()I
    //   34: istore_3
    //   35: aload_0
    //   36: getfield cnt : I
    //   39: i2l
    //   40: iload_3
    //   41: i2l
    //   42: lcmp
    //   43: ifge -> 53
    //   46: getstatic clojure/core/Vec.const__32 : Ljava/lang/Object;
    //   49: goto -> 174
    //   52: athrow
    //   53: aload_0
    //   54: getfield cnt : I
    //   57: i2l
    //   58: iload_3
    //   59: i2l
    //   60: lcmp
    //   61: ifle -> 71
    //   64: getstatic clojure/core/Vec.const__17 : Ljava/lang/Object;
    //   67: goto -> 174
    //   70: athrow
    //   71: getstatic clojure/core/Vec.const__12 : Lclojure/lang/Keyword;
    //   74: dup
    //   75: ifnull -> 172
    //   78: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   81: if_acmpeq -> 173
    //   84: lconst_0
    //   85: invokestatic intCast : (J)I
    //   88: i2l
    //   89: lstore #4
    //   91: lload #4
    //   93: aload_0
    //   94: getfield cnt : I
    //   97: i2l
    //   98: lcmp
    //   99: ifne -> 109
    //   102: getstatic clojure/core/Vec.const__1 : Ljava/lang/Object;
    //   105: goto -> 169
    //   108: athrow
    //   109: aload_0
    //   110: checkcast clojure/lang/Indexed
    //   113: lload #4
    //   115: invokestatic intCast : (J)I
    //   118: invokeinterface nth : (I)Ljava/lang/Object;
    //   123: aload_2
    //   124: checkcast clojure/lang/Indexed
    //   127: lload #4
    //   129: invokestatic intCast : (J)I
    //   132: invokeinterface nth : (I)Ljava/lang/Object;
    //   137: invokestatic compare : (Ljava/lang/Object;Ljava/lang/Object;)I
    //   140: istore #6
    //   142: lconst_0
    //   143: iload #6
    //   145: i2l
    //   146: lcmp
    //   147: ifne -> 164
    //   150: lload #4
    //   152: invokestatic inc : (J)J
    //   155: lstore #4
    //   157: goto -> 91
    //   160: nop
    //   161: nop
    //   162: athrow
    //   163: athrow
    //   164: iload #6
    //   166: invokestatic valueOf : (I)Ljava/lang/Integer;
    //   169: goto -> 174
    //   172: pop
    //   173: aconst_null
    //   174: checkcast java/lang/Number
    //   177: invokevirtual intValue : ()I
    //   180: ireturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #131	-> 0
    //   #368	-> 0
    //   #368	-> 2
    //   #371	-> 29
    //   #372	-> 35
    //   #373	-> 35
    //   #372	-> 53
    //   #374	-> 53
    //   #372	-> 71
    //   #376	-> 85
    //   #0	-> 88
    //   #377	-> 91
    //   #377	-> 91
    //   #379	-> 118
    //   #379	-> 132
    //   #379	-> 137
    //   #380	-> 142
    //   #380	-> 142
    //   #381	-> 152
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   142	27	6	comp	I
    //   91	78	4	i	J
    //   25	149	2	v	Ljava/lang/Object;
    //   35	139	3	vcnt	I
    //   0	180	0	this	Lclojure/core/Vec;
    //   0	180	1	o	Ljava/lang/Object; }
  
  public Object valAt(Object k) { k = null;
    return ((ILookup)this).valAt(k, null); }
  
  public Object valAt(Object k, Object not_found) {
    k = null;
    int i = RT.intCast(k);
    boolean and__5514__auto__8281 = Numbers.gte(i, 0L);
    not_found = null;
    not_found = null;
    return Util.isInteger(k) ? ((and__5514__auto__8281 ? Numbers.lt(i, this.cnt) : and__5514__auto__8281) ? ((Indexed)this).nth(i) : not_found) : not_found;
  }
  
  public boolean retainAll(Collection c) { throw (Throwable)new UnsupportedOperationException(); }
  
  public boolean removeAll(Collection c) { throw (Throwable)new UnsupportedOperationException(); }
  
  public boolean remove(Object o) { throw (Throwable)new UnsupportedOperationException(); }
  
  public void clear() { throw (Throwable)new UnsupportedOperationException(); }
  
  public boolean addAll(Collection c) { throw (Throwable)new UnsupportedOperationException(); }
  
  public boolean add(Object o) { throw (Throwable)new UnsupportedOperationException(); }
  
  public int size() { return this.cnt; }
  
  public Object[] toArray(Object[] arr) {
    long n__6021__auto__8282;
    long i;
    for (n__6021__auto__8282 = this.cnt, i = 0L; i < n__6021__auto__8282; i++)
      RT.aset((Object[])arr, RT.intCast(i), ((Indexed)this).nth(RT.intCast(i))); 
    null;
    arr = null;
    this = null;
    return (Object[])((RT.count(arr) >= this.cnt) ? arr : core.into_array.invokeStatic(const__26, this));
  }
  
  public Object[] toArray() { this = null;
    return (Object[])core.into_array.invokeStatic(const__26, this); }
  
  public boolean isEmpty() {
    return Numbers.isZero(this.cnt);
  }
  
  public boolean containsAll(Collection c) { c = null;
    this = null;
    return ((Boolean)core.every_QMARK_.invokeStatic(new fn__8264(this), c)).booleanValue(); }
  
  public boolean contains(Object o) { o = null;
    return RT.booleanCast(core.some.invokeStatic(new fn__8262(o), this)); }
  
  public int hashCode() { // Byte code:
    //   0: lconst_1
    //   1: invokestatic intCast : (J)I
    //   4: i2l
    //   5: lstore_1
    //   6: lconst_0
    //   7: invokestatic intCast : (J)I
    //   10: i2l
    //   11: lstore_3
    //   12: lload_3
    //   13: aload_0
    //   14: getfield cnt : I
    //   17: i2l
    //   18: lcmp
    //   19: ifne -> 27
    //   22: lload_1
    //   23: goto -> 72
    //   26: athrow
    //   27: aload_0
    //   28: checkcast clojure/lang/Indexed
    //   31: lload_3
    //   32: invokestatic intCast : (J)I
    //   35: invokeinterface nth : (I)Ljava/lang/Object;
    //   40: astore #5
    //   42: ldc2_w 31
    //   45: invokestatic intCast : (J)I
    //   48: lload_1
    //   49: invokestatic intCast : (J)I
    //   52: imul
    //   53: aload #5
    //   55: aconst_null
    //   56: astore #5
    //   58: invokestatic hash : (Ljava/lang/Object;)I
    //   61: iadd
    //   62: i2l
    //   63: lload_3
    //   64: invokestatic inc : (J)J
    //   67: lstore_3
    //   68: lstore_1
    //   69: goto -> 12
    //   72: invokestatic intCast : (J)I
    //   75: ireturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #131	-> 0
    //   #151	-> 1
    //   #0	-> 4
    //   #151	-> 7
    //   #0	-> 10
    //   #152	-> 12
    //   #152	-> 12
    //   #154	-> 35
    //   #155	-> 52
    //   #156	-> 58
    //   #155	-> 61
    //   #157	-> 64
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   42	30	5	val	Ljava/lang/Object;
    //   6	66	1	hash	J
    //   12	60	3	i	J
    //   0	75	0	this	Lclojure/core/Vec; }
  
  public boolean equals(Object o) { // Byte code:
    //   0: aload_0
    //   1: aload_1
    //   2: invokestatic identical : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   5: ifeq -> 15
    //   8: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   11: goto -> 279
    //   14: athrow
    //   15: aload_1
    //   16: instanceof clojure/lang/IPersistentVector
    //   19: istore_2
    //   20: iload_2
    //   21: ifeq -> 29
    //   24: iload_2
    //   25: goto -> 33
    //   28: athrow
    //   29: aload_1
    //   30: instanceof java/util/RandomAccess
    //   33: ifeq -> 158
    //   36: aload_0
    //   37: getfield cnt : I
    //   40: i2l
    //   41: aload_1
    //   42: invokestatic count : (Ljava/lang/Object;)I
    //   45: i2l
    //   46: invokestatic equiv : (JJ)Z
    //   49: istore_2
    //   50: iload_2
    //   51: ifeq -> 141
    //   54: lconst_0
    //   55: invokestatic intCast : (J)I
    //   58: i2l
    //   59: lstore_3
    //   60: lload_3
    //   61: aload_0
    //   62: getfield cnt : I
    //   65: i2l
    //   66: lcmp
    //   67: ifne -> 77
    //   70: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   73: goto -> 137
    //   76: athrow
    //   77: aload_0
    //   78: checkcast clojure/lang/Indexed
    //   81: lload_3
    //   82: invokestatic intCast : (J)I
    //   85: invokeinterface nth : (I)Ljava/lang/Object;
    //   90: aload_1
    //   91: lload_3
    //   92: invokestatic intCast : (J)I
    //   95: invokestatic nth : (Ljava/lang/Object;I)Ljava/lang/Object;
    //   98: invokevirtual equals : (Ljava/lang/Object;)Z
    //   101: ifeq -> 116
    //   104: lload_3
    //   105: invokestatic inc : (J)J
    //   108: lstore_3
    //   109: goto -> 60
    //   112: nop
    //   113: nop
    //   114: athrow
    //   115: athrow
    //   116: getstatic clojure/core/Vec.const__12 : Lclojure/lang/Keyword;
    //   119: dup
    //   120: ifnull -> 135
    //   123: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   126: if_acmpeq -> 136
    //   129: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   132: goto -> 137
    //   135: pop
    //   136: aconst_null
    //   137: goto -> 154
    //   140: athrow
    //   141: iload_2
    //   142: ifeq -> 151
    //   145: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   148: goto -> 154
    //   151: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   154: goto -> 279
    //   157: athrow
    //   158: aload_1
    //   159: instanceof clojure/lang/Sequential
    //   162: istore_2
    //   163: iload_2
    //   164: ifeq -> 172
    //   167: iload_2
    //   168: goto -> 176
    //   171: athrow
    //   172: aload_1
    //   173: instanceof java/util/List
    //   176: ifeq -> 258
    //   179: aload_0
    //   180: invokestatic invokeStatic : (Ljava/lang/Object;)Ljava/lang/Object;
    //   183: astore_2
    //   184: aload_2
    //   185: dup
    //   186: ifnull -> 229
    //   189: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   192: if_acmpeq -> 230
    //   195: aload_2
    //   196: aconst_null
    //   197: astore_2
    //   198: astore #5
    //   200: aload #5
    //   202: aconst_null
    //   203: astore #5
    //   205: aload_1
    //   206: aconst_null
    //   207: astore_1
    //   208: invokestatic invokeStatic : (Ljava/lang/Object;)Ljava/lang/Object;
    //   211: invokevirtual equals : (Ljava/lang/Object;)Z
    //   214: ifeq -> 223
    //   217: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   220: goto -> 226
    //   223: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   226: goto -> 254
    //   229: pop
    //   230: aload_1
    //   231: aconst_null
    //   232: astore_1
    //   233: invokestatic invokeStatic : (Ljava/lang/Object;)Ljava/lang/Object;
    //   236: aconst_null
    //   237: aconst_null
    //   238: astore_0
    //   239: invokestatic identical : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   242: ifeq -> 251
    //   245: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   248: goto -> 254
    //   251: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   254: goto -> 279
    //   257: athrow
    //   258: getstatic clojure/core/Vec.const__12 : Lclojure/lang/Keyword;
    //   261: dup
    //   262: ifnull -> 277
    //   265: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   268: if_acmpeq -> 278
    //   271: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   274: goto -> 279
    //   277: pop
    //   278: aconst_null
    //   279: checkcast java/lang/Boolean
    //   282: invokevirtual booleanValue : ()Z
    //   285: ireturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #131	-> 0
    //   #134	-> 0
    //   #135	-> 2
    //   #134	-> 15
    //   #136	-> 20
    //   #137	-> 42
    //   #137	-> 46
    //   #137	-> 50
    //   #138	-> 55
    //   #0	-> 58
    //   #139	-> 60
    //   #140	-> 60
    //   #139	-> 77
    //   #141	-> 85
    //   #141	-> 95
    //   #141	-> 98
    //   #141	-> 105
    //   #139	-> 116
    //   #134	-> 158
    //   #143	-> 163
    //   #144	-> 184
    //   #145	-> 211
    //   #146	-> 237
    //   #134	-> 258
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   20	13	2	or__5516__auto__8283	Z
    //   60	77	3	i	J
    //   50	104	2	and__5514__auto__8284	Z
    //   163	13	2	or__5516__auto__8285	Z
    //   200	26	5	st	Ljava/lang/Object;
    //   184	70	2	temp__5733__auto__8286	Ljava/lang/Object;
    //   0	285	0	this	Lclojure/core/Vec;
    //   0	285	1	o	Ljava/lang/Object; }
  
  public IMapEntry entryAt(Object k) {
    k = null;
    this = null;
    return (IMapEntry)(((Associative)this).containsKey(k) ? MapEntry.create(k, ((Indexed)this).nth(RT.intCast(k))) : null);
  }
  
  public boolean containsKey(Object k) {
    boolean and__5514__auto__8288 = Util.isInteger(k);
    boolean and__5514__auto__8287 = Numbers.lte(0L, RT.intCast(k));
    k = null;
    return and__5514__auto__8288 ? (and__5514__auto__8287 ? Numbers.lt(RT.intCast(k), this.cnt) : and__5514__auto__8287) : and__5514__auto__8288;
  }
  
  public Associative assoc(Object k, Object v) { // Byte code:
    //   0: aload_1
    //   1: invokestatic isInteger : (Ljava/lang/Object;)Z
    //   4: ifeq -> 32
    //   7: aload_0
    //   8: checkcast clojure/lang/IPersistentVector
    //   11: aload_1
    //   12: aconst_null
    //   13: astore_1
    //   14: checkcast java/lang/Number
    //   17: invokestatic intCast : (Ljava/lang/Object;)I
    //   20: aload_2
    //   21: aconst_null
    //   22: astore_2
    //   23: invokeinterface assocN : (ILjava/lang/Object;)Lclojure/lang/IPersistentVector;
    //   28: goto -> 49
    //   31: athrow
    //   32: new java/lang/IllegalArgumentException
    //   35: dup
    //   36: ldc_w 'Key must be integer'
    //   39: checkcast java/lang/String
    //   42: invokespecial <init> : (Ljava/lang/String;)V
    //   45: checkcast java/lang/Throwable
    //   48: athrow
    //   49: checkcast clojure/lang/Associative
    //   52: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #131	-> 0
    //   #262	-> 0
    //   #262	-> 1
    //   #263	-> 23
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   0	52	0	this	Lclojure/core/Vec;
    //   0	52	1	k	Ljava/lang/Object;
    //   0	52	2	v	Ljava/lang/Object; }
}
