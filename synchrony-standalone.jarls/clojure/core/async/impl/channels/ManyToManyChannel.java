package clojure.core.async.impl.channels;

import clojure.core.async.impl.protocols.Channel;
import clojure.core.async.impl.protocols.ReadPort;
import clojure.core.async.impl.protocols.WritePort;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;

public final class ManyToManyChannel implements MMC, WritePort, ReadPort, Channel, IType {
  public final Object takes;
  
  public final Object puts;
  
  public final Object buf;
  
  public final Object closed;
  
  public final Object mutex;
  
  public final Object add_BANG_;
  
  private static Class __cached_class__0;
  
  private static Class __cached_class__1;
  
  private static Class __cached_class__2;
  
  private static Class __cached_class__3;
  
  private static Class __cached_class__4;
  
  private static Class __cached_class__5;
  
  private static Class __cached_class__6;
  
  private static Class __cached_class__7;
  
  private static Class __cached_class__8;
  
  private static Class __cached_class__9;
  
  private static Class __cached_class__10;
  
  private static Class __cached_class__11;
  
  private static Class __cached_class__12;
  
  private static Class __cached_class__13;
  
  private static Class __cached_class__14;
  
  private static Class __cached_class__15;
  
  private static Class __cached_class__16;
  
  private static Class __cached_class__17;
  
  private static Class __cached_class__18;
  
  private static Class __cached_class__19;
  
  private static Class __cached_class__20;
  
  private static Class __cached_class__21;
  
  private static Class __cached_class__22;
  
  private static Class __cached_class__23;
  
  private static Class __cached_class__24;
  
  private static Class __cached_class__25;
  
  private static Class __cached_class__26;
  
  private static Class __cached_class__27;
  
  public static final Var const__0 = (Var)RT.var("clojure.core.async.impl.protocols", "active?");
  
  public static final Var const__3 = (Var)RT.var("clojure.core.async.impl.protocols", "commit");
  
  public static final Var const__4 = (Var)RT.var("clojure.core.async.impl.dispatch", "run");
  
  public static final Var const__5 = (Var)RT.var("clojure.core.async.impl.protocols", "close!");
  
  public static final Var const__7 = (Var)RT.var("clojure.core.async.impl.channels", "cleanup");
  
  public static final Var const__8 = (Var)RT.var("clojure.core", "deref");
  
  public static final Var const__9 = (Var)RT.var("clojure.core.async.impl.channels", "box");
  
  public static final Var const__10 = (Var)RT.var("clojure.core", "not");
  
  public static final Var const__11 = (Var)RT.var("clojure.core.async.impl.protocols", "full?");
  
  public static final Var const__15 = (Var)RT.var("clojure.core", "seq");
  
  public static final Var const__16 = (Var)RT.var("clojure.core.async.impl.channels", "abort");
  
  public static final Var const__19 = (Var)RT.var("clojure.core", "chunked-seq?");
  
  public static final Var const__20 = (Var)RT.var("clojure.core", "chunk-first");
  
  public static final Var const__21 = (Var)RT.var("clojure.core", "chunk-rest");
  
  public static final Var const__23 = (Var)RT.var("clojure.core", "first");
  
  public static final Var const__24 = (Var)RT.var("clojure.core", "next");
  
  public static final Var const__26 = (Var)RT.var("clojure.core.async.impl.protocols", "blockable?");
  
  public static final Object const__27 = Long.valueOf(1024L);
  
  public static final Var const__28 = (Var)RT.var("clojure.core", "str");
  
  public static final Var const__29 = (Var)RT.var("clojure.core", "pr-str");
  
  public static final Object const__30 = ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "<"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, ".size"), Symbol.intern(null, "puts") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(153), RT.keyword(null, "column"), Integer.valueOf(38) })), Symbol.intern("impl", "MAX-QUEUE-SIZE") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(153), RT.keyword(null, "column"), Integer.valueOf(35) }));
  
  public static final Var const__31 = (Var)RT.var("clojure.core.async.impl.protocols", "remove!");
  
  public static final Object const__33 = ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "<"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, ".size"), Symbol.intern(null, "takes") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(236), RT.keyword(null, "column"), Integer.valueOf(36) })), Symbol.intern("impl", "MAX-QUEUE-SIZE") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(236), RT.keyword(null, "column"), Integer.valueOf(33) }));
  
  public static final Var const__34 = (Var)RT.var("clojure.core", "reset!"), const__35 = (Var)RT.var("clojure.core.async.impl.protocols", "close-buf!");
  
  public ManyToManyChannel(Object paramObject1, Object paramObject2, Object paramObject3, Object paramObject4, Object paramObject5, Object paramObject6) { this.takes = paramObject1;
    this.puts = paramObject2;
    this.buf = paramObject3;
    this.closed = paramObject4;
    this.mutex = paramObject5;
    this.add_BANG_ = paramObject6; }
  
  public static IPersistentVector getBasis() { return Tuple.create(((IObj)Symbol.intern(null, "takes")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "LinkedList") })), ((IObj)Symbol.intern(null, "puts")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "LinkedList") })), ((IObj)Symbol.intern(null, "buf")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Queue") })), Symbol.intern(null, "closed"), ((IObj)Symbol.intern(null, "mutex")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Lock") })), Symbol.intern(null, "add!")); }
  
  public Object close_BANG_() { // Byte code:
    //   0: aload_0
    //   1: getfield mutex : Ljava/lang/Object;
    //   4: checkcast java/util/concurrent/locks/Lock
    //   7: invokeinterface lock : ()V
    //   12: aconst_null
    //   13: pop
    //   14: aload_0
    //   15: dup
    //   16: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   19: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__23 : Ljava/lang/Class;
    //   22: if_acmpeq -> 39
    //   25: dup
    //   26: instanceof clojure/core/async/impl/channels/MMC
    //   29: ifne -> 54
    //   32: dup
    //   33: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   36: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__23 : Ljava/lang/Class;
    //   39: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__7 : Lclojure/lang/Var;
    //   42: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   45: swap
    //   46: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   51: goto -> 62
    //   54: checkcast clojure/core/async/impl/channels/MMC
    //   57: invokeinterface cleanup : ()Ljava/lang/Object;
    //   62: pop
    //   63: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__8 : Lclojure/lang/Var;
    //   66: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   69: checkcast clojure/lang/IFn
    //   72: aload_0
    //   73: getfield closed : Ljava/lang/Object;
    //   76: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   81: dup
    //   82: ifnull -> 109
    //   85: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   88: if_acmpeq -> 110
    //   91: aload_0
    //   92: getfield mutex : Ljava/lang/Object;
    //   95: checkcast java/util/concurrent/locks/Lock
    //   98: invokeinterface unlock : ()V
    //   103: aconst_null
    //   104: pop
    //   105: aconst_null
    //   106: goto -> 683
    //   109: pop
    //   110: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__34 : Lclojure/lang/Var;
    //   113: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   116: checkcast clojure/lang/IFn
    //   119: aload_0
    //   120: getfield closed : Ljava/lang/Object;
    //   123: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   126: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   131: pop
    //   132: aload_0
    //   133: getfield buf : Ljava/lang/Object;
    //   136: astore_1
    //   137: aload_1
    //   138: dup
    //   139: ifnull -> 173
    //   142: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   145: if_acmpeq -> 174
    //   148: aload_0
    //   149: getfield puts : Ljava/lang/Object;
    //   152: checkcast java/util/AbstractCollection
    //   155: invokevirtual isEmpty : ()Z
    //   158: ifeq -> 167
    //   161: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   164: goto -> 170
    //   167: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   170: goto -> 177
    //   173: pop
    //   174: aload_1
    //   175: aconst_null
    //   176: astore_1
    //   177: dup
    //   178: ifnull -> 207
    //   181: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   184: if_acmpeq -> 208
    //   187: aload_0
    //   188: getfield add_BANG_ : Ljava/lang/Object;
    //   191: checkcast clojure/lang/IFn
    //   194: aload_0
    //   195: getfield buf : Ljava/lang/Object;
    //   198: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   203: pop
    //   204: goto -> 210
    //   207: pop
    //   208: aconst_null
    //   209: pop
    //   210: aload_0
    //   211: getfield takes : Ljava/lang/Object;
    //   214: checkcast java/util/AbstractSequentialList
    //   217: invokevirtual iterator : ()Ljava/util/Iterator;
    //   220: astore_1
    //   221: aload_1
    //   222: checkcast java/util/Iterator
    //   225: invokeinterface hasNext : ()Z
    //   230: ifeq -> 594
    //   233: aload_1
    //   234: checkcast java/util/Iterator
    //   237: invokeinterface next : ()Ljava/lang/Object;
    //   242: astore_2
    //   243: aload_2
    //   244: checkcast java/util/concurrent/locks/Lock
    //   247: invokeinterface lock : ()V
    //   252: aconst_null
    //   253: pop
    //   254: aload_2
    //   255: dup
    //   256: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   259: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__24 : Ljava/lang/Class;
    //   262: if_acmpeq -> 279
    //   265: dup
    //   266: instanceof clojure/core/async/impl/protocols/Handler
    //   269: ifne -> 294
    //   272: dup
    //   273: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   276: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__24 : Ljava/lang/Class;
    //   279: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__0 : Lclojure/lang/Var;
    //   282: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   285: swap
    //   286: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   291: goto -> 302
    //   294: checkcast clojure/core/async/impl/protocols/Handler
    //   297: invokeinterface active_QMARK_ : ()Ljava/lang/Object;
    //   302: astore_3
    //   303: aload_3
    //   304: dup
    //   305: ifnull -> 365
    //   308: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   311: if_acmpeq -> 366
    //   314: aload_2
    //   315: dup
    //   316: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   319: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__25 : Ljava/lang/Class;
    //   322: if_acmpeq -> 339
    //   325: dup
    //   326: instanceof clojure/core/async/impl/protocols/Handler
    //   329: ifne -> 354
    //   332: dup
    //   333: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   336: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__25 : Ljava/lang/Class;
    //   339: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__3 : Lclojure/lang/Var;
    //   342: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   345: swap
    //   346: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   351: goto -> 362
    //   354: checkcast clojure/core/async/impl/protocols/Handler
    //   357: invokeinterface commit : ()Ljava/lang/Object;
    //   362: goto -> 369
    //   365: pop
    //   366: aload_3
    //   367: aconst_null
    //   368: astore_3
    //   369: astore_3
    //   370: aload_2
    //   371: aconst_null
    //   372: astore_2
    //   373: checkcast java/util/concurrent/locks/Lock
    //   376: invokeinterface unlock : ()V
    //   381: aconst_null
    //   382: pop
    //   383: aload_3
    //   384: dup
    //   385: ifnull -> 545
    //   388: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   391: if_acmpeq -> 546
    //   394: aload_0
    //   395: getfield buf : Ljava/lang/Object;
    //   398: astore #4
    //   400: aload #4
    //   402: dup
    //   403: ifnull -> 438
    //   406: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   409: if_acmpeq -> 439
    //   412: aload_0
    //   413: getfield buf : Ljava/lang/Object;
    //   416: invokestatic count : (Ljava/lang/Object;)I
    //   419: i2l
    //   420: invokestatic isPos : (J)Z
    //   423: ifeq -> 432
    //   426: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   429: goto -> 435
    //   432: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   435: goto -> 444
    //   438: pop
    //   439: aload #4
    //   441: aconst_null
    //   442: astore #4
    //   444: dup
    //   445: ifnull -> 508
    //   448: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   451: if_acmpeq -> 509
    //   454: aload_0
    //   455: getfield buf : Ljava/lang/Object;
    //   458: dup
    //   459: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   462: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__26 : Ljava/lang/Class;
    //   465: if_acmpeq -> 482
    //   468: dup
    //   469: instanceof clojure/core/async/impl/protocols/Buffer
    //   472: ifne -> 497
    //   475: dup
    //   476: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   479: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__26 : Ljava/lang/Class;
    //   482: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__31 : Lclojure/lang/Var;
    //   485: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   488: swap
    //   489: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   494: goto -> 505
    //   497: checkcast clojure/core/async/impl/protocols/Buffer
    //   500: invokeinterface remove_BANG_ : ()Ljava/lang/Object;
    //   505: goto -> 510
    //   508: pop
    //   509: aconst_null
    //   510: astore #4
    //   512: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__4 : Lclojure/lang/Var;
    //   515: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   518: checkcast clojure/lang/IFn
    //   521: new clojure/core/async/impl/channels/ManyToManyChannel$fn__544
    //   524: dup
    //   525: aload #4
    //   527: aconst_null
    //   528: astore #4
    //   530: aload_3
    //   531: aconst_null
    //   532: astore_3
    //   533: invokespecial <init> : (Ljava/lang/Object;Ljava/lang/Object;)V
    //   536: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   541: pop
    //   542: goto -> 548
    //   545: pop
    //   546: aconst_null
    //   547: pop
    //   548: aload_1
    //   549: checkcast java/util/Iterator
    //   552: invokeinterface remove : ()V
    //   557: aconst_null
    //   558: pop
    //   559: aload_1
    //   560: checkcast java/util/Iterator
    //   563: invokeinterface hasNext : ()Z
    //   568: ifeq -> 588
    //   571: aload_1
    //   572: checkcast java/util/Iterator
    //   575: invokeinterface next : ()Ljava/lang/Object;
    //   580: astore_2
    //   581: goto -> 243
    //   584: nop
    //   585: nop
    //   586: athrow
    //   587: athrow
    //   588: aconst_null
    //   589: pop
    //   590: goto -> 596
    //   593: athrow
    //   594: aconst_null
    //   595: pop
    //   596: aload_0
    //   597: getfield buf : Ljava/lang/Object;
    //   600: dup
    //   601: ifnull -> 665
    //   604: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   607: if_acmpeq -> 666
    //   610: aload_0
    //   611: getfield buf : Ljava/lang/Object;
    //   614: dup
    //   615: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   618: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__27 : Ljava/lang/Class;
    //   621: if_acmpeq -> 638
    //   624: dup
    //   625: instanceof clojure/core/async/impl/protocols/Buffer
    //   628: ifne -> 653
    //   631: dup
    //   632: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   635: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__27 : Ljava/lang/Class;
    //   638: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__35 : Lclojure/lang/Var;
    //   641: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   644: swap
    //   645: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   650: goto -> 661
    //   653: checkcast clojure/core/async/impl/protocols/Buffer
    //   656: invokeinterface close_buf_BANG_ : ()Ljava/lang/Object;
    //   661: pop
    //   662: goto -> 668
    //   665: pop
    //   666: aconst_null
    //   667: pop
    //   668: aload_0
    //   669: getfield mutex : Ljava/lang/Object;
    //   672: checkcast java/util/concurrent/locks/Lock
    //   675: invokeinterface unlock : ()V
    //   680: aconst_null
    //   681: pop
    //   682: aconst_null
    //   683: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #32	-> 0
    //   #247	-> 7
    //   #248	-> 14
    //   #248	-> 46
    //   #249	-> 63
    //   #249	-> 69
    //   #249	-> 76
    //   #251	-> 98
    //   #254	-> 116
    //   #254	-> 126
    //   #255	-> 132
    //   #255	-> 137
    //   #255	-> 155
    //   #256	-> 191
    //   #256	-> 198
    //   #257	-> 217
    //   #258	-> 221
    //   #258	-> 225
    //   #259	-> 237
    //   #260	-> 247
    //   #261	-> 254
    //   #261	-> 286
    //   #261	-> 303
    //   #261	-> 314
    //   #261	-> 346
    //   #262	-> 376
    //   #263	-> 383
    //   #264	-> 394
    //   #264	-> 400
    //   #264	-> 416
    //   #264	-> 420
    //   #264	-> 454
    //   #264	-> 489
    //   #265	-> 518
    //   #265	-> 536
    //   #266	-> 552
    //   #267	-> 559
    //   #267	-> 563
    //   #268	-> 575
    //   #269	-> 596
    //   #269	-> 610
    //   #269	-> 645
    //   #270	-> 675
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   137	40	1	and__5514__auto__547	Ljava/lang/Object;
    //   303	66	3	and__5514__auto__548	Ljava/lang/Object;
    //   400	44	4	and__5514__auto__549	Ljava/lang/Object;
    //   512	30	4	val	Ljava/lang/Object;
    //   370	220	3	take_cb	Ljava/lang/Object;
    //   243	347	2	taker	Ljava/lang/Object;
    //   221	375	1	iter	Ljava/lang/Object;
    //   0	683	0	this	Lclojure/core/async/impl/channels/ManyToManyChannel; }
  
  public Object closed_QMARK_() { this = null;
    return ((IFn)const__8.getRawRoot()).invoke(this.closed); }
  
  public Object take_BANG_(Object handler) { // Byte code:
    //   0: aload_0
    //   1: getfield mutex : Ljava/lang/Object;
    //   4: checkcast java/util/concurrent/locks/Lock
    //   7: invokeinterface lock : ()V
    //   12: aconst_null
    //   13: pop
    //   14: aload_0
    //   15: dup
    //   16: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   19: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__18 : Ljava/lang/Class;
    //   22: if_acmpeq -> 39
    //   25: dup
    //   26: instanceof clojure/core/async/impl/channels/MMC
    //   29: ifne -> 54
    //   32: dup
    //   33: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   36: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__18 : Ljava/lang/Class;
    //   39: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__7 : Lclojure/lang/Var;
    //   42: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   45: swap
    //   46: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   51: goto -> 62
    //   54: checkcast clojure/core/async/impl/channels/MMC
    //   57: invokeinterface cleanup : ()Ljava/lang/Object;
    //   62: pop
    //   63: aload_1
    //   64: aconst_null
    //   65: astore_1
    //   66: astore_2
    //   67: new clojure/core/async/impl/channels/ManyToManyChannel$commit_handler__497
    //   70: dup
    //   71: aload_2
    //   72: invokespecial <init> : (Ljava/lang/Object;)V
    //   75: astore_3
    //   76: aload_0
    //   77: getfield buf : Ljava/lang/Object;
    //   80: astore #4
    //   82: aload #4
    //   84: dup
    //   85: ifnull -> 120
    //   88: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   91: if_acmpeq -> 121
    //   94: aload_0
    //   95: getfield buf : Ljava/lang/Object;
    //   98: invokestatic count : (Ljava/lang/Object;)I
    //   101: i2l
    //   102: invokestatic isPos : (J)Z
    //   105: ifeq -> 114
    //   108: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   111: goto -> 117
    //   114: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   117: goto -> 126
    //   120: pop
    //   121: aload #4
    //   123: aconst_null
    //   124: astore #4
    //   126: dup
    //   127: ifnull -> 824
    //   130: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   133: if_acmpeq -> 825
    //   136: aload_3
    //   137: aconst_null
    //   138: astore_3
    //   139: checkcast clojure/lang/IFn
    //   142: invokeinterface invoke : ()Ljava/lang/Object;
    //   147: astore #4
    //   149: aload #4
    //   151: dup
    //   152: ifnull -> 805
    //   155: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   158: if_acmpeq -> 806
    //   161: aload #4
    //   163: aconst_null
    //   164: astore #4
    //   166: pop
    //   167: aload_0
    //   168: getfield buf : Ljava/lang/Object;
    //   171: dup
    //   172: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   175: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__19 : Ljava/lang/Class;
    //   178: if_acmpeq -> 195
    //   181: dup
    //   182: instanceof clojure/core/async/impl/protocols/Buffer
    //   185: ifne -> 210
    //   188: dup
    //   189: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   192: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__19 : Ljava/lang/Class;
    //   195: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__31 : Lclojure/lang/Var;
    //   198: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   201: swap
    //   202: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   207: goto -> 218
    //   210: checkcast clojure/core/async/impl/protocols/Buffer
    //   213: invokeinterface remove_BANG_ : ()Ljava/lang/Object;
    //   218: astore #5
    //   220: aload_0
    //   221: getfield puts : Ljava/lang/Object;
    //   224: checkcast java/util/AbstractSequentialList
    //   227: invokevirtual iterator : ()Ljava/util/Iterator;
    //   230: astore #6
    //   232: aload #6
    //   234: checkcast java/util/Iterator
    //   237: invokeinterface hasNext : ()Z
    //   242: ifeq -> 333
    //   245: getstatic clojure/lang/PersistentVector.EMPTY : Lclojure/lang/PersistentVector;
    //   248: astore #7
    //   250: aload #6
    //   252: checkcast java/util/Iterator
    //   255: invokeinterface next : ()Ljava/lang/Object;
    //   260: astore #8
    //   262: aload #8
    //   264: astore #9
    //   266: aload #9
    //   268: lconst_0
    //   269: invokestatic intCast : (J)I
    //   272: aconst_null
    //   273: invokestatic nth : (Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;
    //   276: pop
    //   277: aload #9
    //   279: aconst_null
    //   280: astore #9
    //   282: lconst_1
    //   283: invokestatic intCast : (J)I
    //   286: aconst_null
    //   287: invokestatic nth : (Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;
    //   290: pop
    //   291: new clojure/core/async/impl/channels/ManyToManyChannel$fn__510
    //   294: dup
    //   295: aload_0
    //   296: getfield add_BANG_ : Ljava/lang/Object;
    //   299: aload #8
    //   301: aconst_null
    //   302: astore #8
    //   304: aload #6
    //   306: aconst_null
    //   307: astore #6
    //   309: aload_0
    //   310: getfield buf : Ljava/lang/Object;
    //   313: aload #7
    //   315: aconst_null
    //   316: astore #7
    //   318: invokespecial <init> : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V
    //   321: checkcast clojure/lang/IFn
    //   324: invokeinterface invoke : ()Ljava/lang/Object;
    //   329: goto -> 334
    //   332: athrow
    //   333: aconst_null
    //   334: astore #7
    //   336: aload #7
    //   338: lconst_0
    //   339: invokestatic intCast : (J)I
    //   342: aconst_null
    //   343: invokestatic nth : (Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;
    //   346: astore #8
    //   348: aload #7
    //   350: aconst_null
    //   351: astore #7
    //   353: lconst_1
    //   354: invokestatic intCast : (J)I
    //   357: aconst_null
    //   358: invokestatic nth : (Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;
    //   361: astore #9
    //   363: aload #8
    //   365: aconst_null
    //   366: astore #8
    //   368: dup
    //   369: ifnull -> 430
    //   372: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   375: if_acmpeq -> 431
    //   378: aload_0
    //   379: dup
    //   380: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   383: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__20 : Ljava/lang/Class;
    //   386: if_acmpeq -> 403
    //   389: dup
    //   390: instanceof clojure/core/async/impl/channels/MMC
    //   393: ifne -> 418
    //   396: dup
    //   397: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   400: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__20 : Ljava/lang/Class;
    //   403: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__16 : Lclojure/lang/Var;
    //   406: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   409: swap
    //   410: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   415: goto -> 426
    //   418: checkcast clojure/core/async/impl/channels/MMC
    //   421: invokeinterface abort : ()Ljava/lang/Object;
    //   426: pop
    //   427: goto -> 433
    //   430: pop
    //   431: aconst_null
    //   432: pop
    //   433: aload_0
    //   434: getfield mutex : Ljava/lang/Object;
    //   437: checkcast java/util/concurrent/locks/Lock
    //   440: invokeinterface unlock : ()V
    //   445: aconst_null
    //   446: pop
    //   447: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__15 : Lclojure/lang/Var;
    //   450: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   453: checkcast clojure/lang/IFn
    //   456: aload #9
    //   458: aconst_null
    //   459: astore #9
    //   461: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   466: astore #10
    //   468: aconst_null
    //   469: astore #11
    //   471: lconst_0
    //   472: lstore #12
    //   474: lconst_0
    //   475: lstore #14
    //   477: lload #14
    //   479: lload #12
    //   481: lcmp
    //   482: ifge -> 560
    //   485: aload #11
    //   487: checkcast clojure/lang/Indexed
    //   490: lload #14
    //   492: invokestatic intCast : (J)I
    //   495: invokeinterface nth : (I)Ljava/lang/Object;
    //   500: astore #16
    //   502: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__4 : Lclojure/lang/Var;
    //   505: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   508: checkcast clojure/lang/IFn
    //   511: new clojure/core/async/impl/channels/ManyToManyChannel$fn__522
    //   514: dup
    //   515: aload #16
    //   517: aconst_null
    //   518: astore #16
    //   520: invokespecial <init> : (Ljava/lang/Object;)V
    //   523: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   528: pop
    //   529: aload #10
    //   531: aconst_null
    //   532: astore #10
    //   534: aload #11
    //   536: aconst_null
    //   537: astore #11
    //   539: lload #12
    //   541: lload #14
    //   543: lconst_1
    //   544: ladd
    //   545: lstore #14
    //   547: lstore #12
    //   549: astore #11
    //   551: astore #10
    //   553: goto -> 477
    //   556: nop
    //   557: nop
    //   558: athrow
    //   559: athrow
    //   560: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__15 : Lclojure/lang/Var;
    //   563: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   566: checkcast clojure/lang/IFn
    //   569: aload #10
    //   571: aconst_null
    //   572: astore #10
    //   574: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   579: astore #16
    //   581: aload #16
    //   583: dup
    //   584: ifnull -> 778
    //   587: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   590: if_acmpeq -> 779
    //   593: aload #16
    //   595: aconst_null
    //   596: astore #16
    //   598: astore #17
    //   600: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__19 : Lclojure/lang/Var;
    //   603: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   606: checkcast clojure/lang/IFn
    //   609: aload #17
    //   611: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   616: dup
    //   617: ifnull -> 696
    //   620: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   623: if_acmpeq -> 697
    //   626: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__20 : Lclojure/lang/Var;
    //   629: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   632: checkcast clojure/lang/IFn
    //   635: aload #17
    //   637: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   642: astore #18
    //   644: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__21 : Lclojure/lang/Var;
    //   647: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   650: checkcast clojure/lang/IFn
    //   653: aload #17
    //   655: aconst_null
    //   656: astore #17
    //   658: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   663: aload #18
    //   665: aload #18
    //   667: aconst_null
    //   668: astore #18
    //   670: invokestatic count : (Ljava/lang/Object;)I
    //   673: invokestatic intCast : (I)I
    //   676: i2l
    //   677: lconst_0
    //   678: invokestatic intCast : (J)I
    //   681: i2l
    //   682: lstore #14
    //   684: lstore #12
    //   686: astore #11
    //   688: astore #10
    //   690: goto -> 477
    //   693: nop
    //   694: nop
    //   695: athrow
    //   696: pop
    //   697: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__23 : Lclojure/lang/Var;
    //   700: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   703: checkcast clojure/lang/IFn
    //   706: aload #17
    //   708: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   713: astore #18
    //   715: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__4 : Lclojure/lang/Var;
    //   718: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   721: checkcast clojure/lang/IFn
    //   724: new clojure/core/async/impl/channels/ManyToManyChannel$fn__524
    //   727: dup
    //   728: aload #18
    //   730: aconst_null
    //   731: astore #18
    //   733: invokespecial <init> : (Ljava/lang/Object;)V
    //   736: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   741: pop
    //   742: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__24 : Lclojure/lang/Var;
    //   745: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   748: checkcast clojure/lang/IFn
    //   751: aload #17
    //   753: aconst_null
    //   754: astore #17
    //   756: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   761: aconst_null
    //   762: lconst_0
    //   763: lconst_0
    //   764: lstore #14
    //   766: lstore #12
    //   768: astore #11
    //   770: astore #10
    //   772: goto -> 477
    //   775: nop
    //   776: nop
    //   777: athrow
    //   778: pop
    //   779: aconst_null
    //   780: pop
    //   781: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__9 : Lclojure/lang/Var;
    //   784: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   787: checkcast clojure/lang/IFn
    //   790: aload #5
    //   792: aconst_null
    //   793: astore #5
    //   795: aconst_null
    //   796: astore_0
    //   797: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   802: goto -> 821
    //   805: pop
    //   806: aload_0
    //   807: getfield mutex : Ljava/lang/Object;
    //   810: checkcast java/util/concurrent/locks/Lock
    //   813: invokeinterface unlock : ()V
    //   818: aconst_null
    //   819: pop
    //   820: aconst_null
    //   821: goto -> 1564
    //   824: pop
    //   825: aload_0
    //   826: getfield puts : Ljava/lang/Object;
    //   829: checkcast java/util/AbstractSequentialList
    //   832: invokevirtual iterator : ()Ljava/util/Iterator;
    //   835: astore #4
    //   837: aload #4
    //   839: checkcast java/util/Iterator
    //   842: invokeinterface hasNext : ()Z
    //   847: ifeq -> 921
    //   850: aload #4
    //   852: checkcast java/util/Iterator
    //   855: invokeinterface next : ()Ljava/lang/Object;
    //   860: astore #19
    //   862: aload #19
    //   864: astore #5
    //   866: aload #5
    //   868: lconst_0
    //   869: invokestatic intCast : (J)I
    //   872: aconst_null
    //   873: invokestatic nth : (Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;
    //   876: pop
    //   877: aload #5
    //   879: aconst_null
    //   880: astore #5
    //   882: lconst_1
    //   883: invokestatic intCast : (J)I
    //   886: aconst_null
    //   887: invokestatic nth : (Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;
    //   890: pop
    //   891: new clojure/core/async/impl/channels/ManyToManyChannel$fn__536
    //   894: dup
    //   895: aload #4
    //   897: aconst_null
    //   898: astore #4
    //   900: aload_2
    //   901: aload #19
    //   903: aconst_null
    //   904: astore #19
    //   906: invokespecial <init> : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V
    //   909: checkcast clojure/lang/IFn
    //   912: invokeinterface invoke : ()Ljava/lang/Object;
    //   917: goto -> 922
    //   920: athrow
    //   921: aconst_null
    //   922: astore #19
    //   924: aload #19
    //   926: lconst_0
    //   927: invokestatic intCast : (J)I
    //   930: aconst_null
    //   931: invokestatic nth : (Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;
    //   934: astore #5
    //   936: aload #19
    //   938: lconst_1
    //   939: invokestatic intCast : (J)I
    //   942: aconst_null
    //   943: invokestatic nth : (Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;
    //   946: astore #6
    //   948: aload #19
    //   950: aconst_null
    //   951: astore #19
    //   953: ldc2_w 2
    //   956: invokestatic intCast : (J)I
    //   959: aconst_null
    //   960: invokestatic nth : (Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;
    //   963: astore #7
    //   965: aload #6
    //   967: astore #8
    //   969: aload #8
    //   971: dup
    //   972: ifnull -> 989
    //   975: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   978: if_acmpeq -> 990
    //   981: aload #5
    //   983: aconst_null
    //   984: astore #5
    //   986: goto -> 995
    //   989: pop
    //   990: aload #8
    //   992: aconst_null
    //   993: astore #8
    //   995: dup
    //   996: ifnull -> 1070
    //   999: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   1002: if_acmpeq -> 1071
    //   1005: aload_0
    //   1006: getfield mutex : Ljava/lang/Object;
    //   1009: checkcast java/util/concurrent/locks/Lock
    //   1012: invokeinterface unlock : ()V
    //   1017: aconst_null
    //   1018: pop
    //   1019: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__4 : Lclojure/lang/Var;
    //   1022: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1025: checkcast clojure/lang/IFn
    //   1028: new clojure/core/async/impl/channels/ManyToManyChannel$fn__542
    //   1031: dup
    //   1032: aload #6
    //   1034: aconst_null
    //   1035: astore #6
    //   1037: invokespecial <init> : (Ljava/lang/Object;)V
    //   1040: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1045: pop
    //   1046: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__9 : Lclojure/lang/Var;
    //   1049: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1052: checkcast clojure/lang/IFn
    //   1055: aload #7
    //   1057: aconst_null
    //   1058: astore #7
    //   1060: aconst_null
    //   1061: astore_0
    //   1062: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1067: goto -> 1564
    //   1070: pop
    //   1071: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__8 : Lclojure/lang/Var;
    //   1074: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1077: checkcast clojure/lang/IFn
    //   1080: aload_0
    //   1081: getfield closed : Ljava/lang/Object;
    //   1084: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1089: dup
    //   1090: ifnull -> 1349
    //   1093: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   1096: if_acmpeq -> 1350
    //   1099: aload_0
    //   1100: getfield buf : Ljava/lang/Object;
    //   1103: dup
    //   1104: ifnull -> 1133
    //   1107: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   1110: if_acmpeq -> 1134
    //   1113: aload_0
    //   1114: getfield add_BANG_ : Ljava/lang/Object;
    //   1117: checkcast clojure/lang/IFn
    //   1120: aload_0
    //   1121: getfield buf : Ljava/lang/Object;
    //   1124: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1129: pop
    //   1130: goto -> 1136
    //   1133: pop
    //   1134: aconst_null
    //   1135: pop
    //   1136: aload_0
    //   1137: getfield buf : Ljava/lang/Object;
    //   1140: astore #8
    //   1142: aload #8
    //   1144: dup
    //   1145: ifnull -> 1180
    //   1148: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   1151: if_acmpeq -> 1181
    //   1154: aload_0
    //   1155: getfield buf : Ljava/lang/Object;
    //   1158: invokestatic count : (Ljava/lang/Object;)I
    //   1161: i2l
    //   1162: invokestatic isPos : (J)Z
    //   1165: ifeq -> 1174
    //   1168: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   1171: goto -> 1177
    //   1174: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   1177: goto -> 1186
    //   1180: pop
    //   1181: aload #8
    //   1183: aconst_null
    //   1184: astore #8
    //   1186: astore #8
    //   1188: aload_3
    //   1189: aconst_null
    //   1190: astore_3
    //   1191: checkcast clojure/lang/IFn
    //   1194: invokeinterface invoke : ()Ljava/lang/Object;
    //   1199: astore #9
    //   1201: aload #9
    //   1203: dup
    //   1204: ifnull -> 1330
    //   1207: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   1210: if_acmpeq -> 1331
    //   1213: aload #9
    //   1215: aconst_null
    //   1216: astore #9
    //   1218: pop
    //   1219: aload #8
    //   1221: aconst_null
    //   1222: astore #8
    //   1224: dup
    //   1225: ifnull -> 1288
    //   1228: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   1231: if_acmpeq -> 1289
    //   1234: aload_0
    //   1235: getfield buf : Ljava/lang/Object;
    //   1238: dup
    //   1239: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1242: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__21 : Ljava/lang/Class;
    //   1245: if_acmpeq -> 1262
    //   1248: dup
    //   1249: instanceof clojure/core/async/impl/protocols/Buffer
    //   1252: ifne -> 1277
    //   1255: dup
    //   1256: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1259: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__21 : Ljava/lang/Class;
    //   1262: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__31 : Lclojure/lang/Var;
    //   1265: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1268: swap
    //   1269: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1274: goto -> 1285
    //   1277: checkcast clojure/core/async/impl/protocols/Buffer
    //   1280: invokeinterface remove_BANG_ : ()Ljava/lang/Object;
    //   1285: goto -> 1290
    //   1288: pop
    //   1289: aconst_null
    //   1290: astore #11
    //   1292: aload_0
    //   1293: getfield mutex : Ljava/lang/Object;
    //   1296: checkcast java/util/concurrent/locks/Lock
    //   1299: invokeinterface unlock : ()V
    //   1304: aconst_null
    //   1305: pop
    //   1306: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__9 : Lclojure/lang/Var;
    //   1309: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1312: checkcast clojure/lang/IFn
    //   1315: aload #11
    //   1317: aconst_null
    //   1318: astore #11
    //   1320: aconst_null
    //   1321: astore_0
    //   1322: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1327: goto -> 1346
    //   1330: pop
    //   1331: aload_0
    //   1332: getfield mutex : Ljava/lang/Object;
    //   1335: checkcast java/util/concurrent/locks/Lock
    //   1338: invokeinterface unlock : ()V
    //   1343: aconst_null
    //   1344: pop
    //   1345: aconst_null
    //   1346: goto -> 1564
    //   1349: pop
    //   1350: aload_2
    //   1351: dup
    //   1352: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1355: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__22 : Ljava/lang/Class;
    //   1358: if_acmpeq -> 1375
    //   1361: dup
    //   1362: instanceof clojure/core/async/impl/protocols/Handler
    //   1365: ifne -> 1390
    //   1368: dup
    //   1369: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1372: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__22 : Ljava/lang/Class;
    //   1375: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__26 : Lclojure/lang/Var;
    //   1378: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1381: swap
    //   1382: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1387: goto -> 1398
    //   1390: checkcast clojure/core/async/impl/protocols/Handler
    //   1393: invokeinterface blockable_QMARK_ : ()Ljava/lang/Object;
    //   1398: dup
    //   1399: ifnull -> 1546
    //   1402: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   1405: if_acmpeq -> 1547
    //   1408: aload_0
    //   1409: getfield takes : Ljava/lang/Object;
    //   1412: checkcast java/util/LinkedList
    //   1415: invokevirtual size : ()I
    //   1418: i2l
    //   1419: ldc2_w 1024
    //   1422: lcmp
    //   1423: ifge -> 1432
    //   1426: aconst_null
    //   1427: pop
    //   1428: goto -> 1517
    //   1431: athrow
    //   1432: aload_0
    //   1433: getfield mutex : Ljava/lang/Object;
    //   1436: checkcast java/util/concurrent/locks/Lock
    //   1439: invokeinterface unlock : ()V
    //   1444: aconst_null
    //   1445: pop
    //   1446: new java/lang/AssertionError
    //   1449: dup
    //   1450: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__28 : Lclojure/lang/Var;
    //   1453: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1456: checkcast clojure/lang/IFn
    //   1459: ldc_w 'Assert failed: '
    //   1462: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__28 : Lclojure/lang/Var;
    //   1465: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1468: checkcast clojure/lang/IFn
    //   1471: ldc_w 'No more than '
    //   1474: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__27 : Ljava/lang/Object;
    //   1477: ldc_w ' pending takes are allowed on a single channel.'
    //   1480: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1485: ldc_w '\\n'
    //   1488: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__29 : Lclojure/lang/Var;
    //   1491: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1494: checkcast clojure/lang/IFn
    //   1497: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__33 : Ljava/lang/Object;
    //   1500: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1505: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1510: invokespecial <init> : (Ljava/lang/Object;)V
    //   1513: checkcast java/lang/Throwable
    //   1516: athrow
    //   1517: aload_0
    //   1518: getfield takes : Ljava/lang/Object;
    //   1521: checkcast java/util/LinkedList
    //   1524: aload_2
    //   1525: aconst_null
    //   1526: astore_2
    //   1527: invokevirtual add : (Ljava/lang/Object;)Z
    //   1530: ifeq -> 1539
    //   1533: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   1536: goto -> 1542
    //   1539: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   1542: pop
    //   1543: goto -> 1549
    //   1546: pop
    //   1547: aconst_null
    //   1548: pop
    //   1549: aload_0
    //   1550: getfield mutex : Ljava/lang/Object;
    //   1553: checkcast java/util/concurrent/locks/Lock
    //   1556: invokeinterface unlock : ()V
    //   1561: aconst_null
    //   1562: pop
    //   1563: aconst_null
    //   1564: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #32	-> 0
    //   #164	-> 7
    //   #165	-> 14
    //   #165	-> 46
    //   #172	-> 76
    //   #172	-> 82
    //   #172	-> 98
    //   #172	-> 102
    //   #174	-> 139
    //   #174	-> 142
    //   #174	-> 149
    //   #175	-> 167
    //   #175	-> 202
    //   #176	-> 227
    //   #178	-> 232
    //   #178	-> 237
    //   #180	-> 255
    //   #179	-> 273
    //   #179	-> 287
    //   #179	-> 321
    //   #179	-> 324
    //   #175	-> 343
    //   #175	-> 358
    //   #190	-> 363
    //   #191	-> 378
    //   #191	-> 410
    //   #192	-> 440
    //   #193	-> 453
    //   #193	-> 461
    //   #193	-> 477
    //   #193	-> 477
    //   #193	-> 495
    //   #194	-> 508
    //   #194	-> 523
    //   #193	-> 543
    //   #193	-> 566
    //   #193	-> 574
    //   #193	-> 581
    //   #193	-> 600
    //   #193	-> 606
    //   #193	-> 611
    //   #193	-> 632
    //   #193	-> 637
    //   #193	-> 650
    //   #193	-> 658
    //   #193	-> 670
    //   #193	-> 673
    //   #193	-> 678
    //   #193	-> 703
    //   #193	-> 708
    //   #194	-> 721
    //   #194	-> 736
    //   #193	-> 748
    //   #193	-> 756
    //   #195	-> 787
    //   #195	-> 795
    //   #196	-> 813
    //   #198	-> 832
    //   #200	-> 837
    //   #200	-> 842
    //   #201	-> 855
    //   #201	-> 873
    //   #201	-> 887
    //   #201	-> 909
    //   #201	-> 912
    //   #198	-> 931
    //   #198	-> 943
    //   #198	-> 960
    //   #217	-> 965
    //   #217	-> 969
    //   #219	-> 1012
    //   #220	-> 1025
    //   #220	-> 1040
    //   #221	-> 1052
    //   #221	-> 1060
    //   #222	-> 1071
    //   #222	-> 1077
    //   #222	-> 1084
    //   #224	-> 1099
    //   #224	-> 1117
    //   #224	-> 1124
    //   #225	-> 1142
    //   #225	-> 1158
    //   #225	-> 1162
    //   #226	-> 1191
    //   #226	-> 1194
    //   #226	-> 1201
    //   #227	-> 1219
    //   #227	-> 1234
    //   #227	-> 1269
    //   #228	-> 1299
    //   #229	-> 1312
    //   #229	-> 1320
    //   #231	-> 1338
    //   #234	-> 1350
    //   #234	-> 1350
    //   #234	-> 1382
    //   #235	-> 1408
    //   #236	-> 1408
    //   #236	-> 1415
    //   #235	-> 1439
    //   #235	-> 1456
    //   #237	-> 1468
    //   #237	-> 1480
    //   #235	-> 1494
    //   #235	-> 1500
    //   #235	-> 1505
    //   #239	-> 1527
    //   #240	-> 1556
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   82	44	4	and__5514__auto__550	Ljava/lang/Object;
    //   250	79	7	cbs	Ljava/lang/Object;
    //   262	67	8	G__506	Ljava/lang/Object;
    //   266	63	9	vec__507	Ljava/lang/Object;
    //   277	52	10	putter	Ljava/lang/Object;
    //   291	38	11	val	Ljava/lang/Object;
    //   502	54	16	cb	Ljava/lang/Object;
    //   644	49	18	c__5998__auto__551	Ljava/lang/Object;
    //   715	60	18	cb	Ljava/lang/Object;
    //   600	175	17	seq_518	Ljava/lang/Object;
    //   581	200	16	temp__5735__auto__552	Ljava/lang/Object;
    //   468	313	10	seq_518	Ljava/lang/Object;
    //   471	310	11	chunk_519	Ljava/lang/Object;
    //   474	307	12	count_520	J
    //   477	304	14	i_521	J
    //   220	582	5	val	Ljava/lang/Object;
    //   232	570	6	iter	Ljava/lang/Object;
    //   336	466	7	vec__500	Ljava/lang/Object;
    //   348	454	8	done_QMARK_	Ljava/lang/Object;
    //   363	439	9	cbs	Ljava/lang/Object;
    //   167	635	19	take_cb	Ljava/lang/Object;
    //   149	672	4	temp__5733__auto__553	Ljava/lang/Object;
    //   862	55	19	G__532	Ljava/lang/Object;
    //   866	51	5	vec__533	Ljava/lang/Object;
    //   877	40	6	putter	Ljava/lang/Object;
    //   891	26	7	val	Ljava/lang/Object;
    //   969	26	8	and__5514__auto__554	Ljava/lang/Object;
    //   1142	44	8	and__5514__auto__555	Ljava/lang/Object;
    //   1292	35	11	val	Ljava/lang/Object;
    //   1219	108	10	take_cb	Ljava/lang/Object;
    //   1201	145	9	temp__5733__auto__556	Ljava/lang/Object;
    //   1188	158	8	has_val	Ljava/lang/Object;
    //   837	727	4	iter	Ljava/lang/Object;
    //   924	640	19	vec__526	Ljava/lang/Object;
    //   936	628	5	take_cb	Ljava/lang/Object;
    //   948	616	6	put_cb	Ljava/lang/Object;
    //   965	599	7	val	Ljava/lang/Object;
    //   67	1497	2	handler	Ljava/lang/Object;
    //   76	1488	3	commit_handler	Ljava/lang/Object;
    //   0	1564	0	this	Lclojure/core/async/impl/channels/ManyToManyChannel;
    //   0	1564	1	handler	Ljava/lang/Object; }
  
  public Object put_BANG_(Object val, Object handler) { // Byte code:
    //   0: aload_1
    //   1: aconst_null
    //   2: invokestatic identical : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   5: ifeq -> 29
    //   8: new java/lang/IllegalArgumentException
    //   11: dup
    //   12: ldc_w 'Can't put nil on channel'
    //   15: checkcast java/lang/String
    //   18: invokespecial <init> : (Ljava/lang/String;)V
    //   21: checkcast java/lang/Throwable
    //   24: athrow
    //   25: nop
    //   26: nop
    //   27: athrow
    //   28: athrow
    //   29: aconst_null
    //   30: pop
    //   31: aload_0
    //   32: getfield mutex : Ljava/lang/Object;
    //   35: checkcast java/util/concurrent/locks/Lock
    //   38: invokeinterface lock : ()V
    //   43: aconst_null
    //   44: pop
    //   45: aload_0
    //   46: dup
    //   47: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   50: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__5 : Ljava/lang/Class;
    //   53: if_acmpeq -> 70
    //   56: dup
    //   57: instanceof clojure/core/async/impl/channels/MMC
    //   60: ifne -> 85
    //   63: dup
    //   64: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   67: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__5 : Ljava/lang/Class;
    //   70: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__7 : Lclojure/lang/Var;
    //   73: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   76: swap
    //   77: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   82: goto -> 93
    //   85: checkcast clojure/core/async/impl/channels/MMC
    //   88: invokeinterface cleanup : ()Ljava/lang/Object;
    //   93: pop
    //   94: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__8 : Lclojure/lang/Var;
    //   97: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   100: checkcast clojure/lang/IFn
    //   103: aload_0
    //   104: getfield closed : Ljava/lang/Object;
    //   107: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   112: dup
    //   113: ifnull -> 158
    //   116: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   119: if_acmpeq -> 159
    //   122: aload_0
    //   123: getfield mutex : Ljava/lang/Object;
    //   126: checkcast java/util/concurrent/locks/Lock
    //   129: invokeinterface unlock : ()V
    //   134: aconst_null
    //   135: pop
    //   136: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__9 : Lclojure/lang/Var;
    //   139: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   142: checkcast clojure/lang/IFn
    //   145: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   148: aconst_null
    //   149: astore_0
    //   150: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   155: goto -> 2060
    //   158: pop
    //   159: aload_2
    //   160: aconst_null
    //   161: astore_2
    //   162: astore_3
    //   163: aload_0
    //   164: getfield buf : Ljava/lang/Object;
    //   167: astore #4
    //   169: aload #4
    //   171: dup
    //   172: ifnull -> 308
    //   175: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   178: if_acmpeq -> 309
    //   181: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__10 : Lclojure/lang/Var;
    //   184: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   187: checkcast clojure/lang/IFn
    //   190: aload_0
    //   191: getfield buf : Ljava/lang/Object;
    //   194: dup
    //   195: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   198: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__6 : Ljava/lang/Class;
    //   201: if_acmpeq -> 218
    //   204: dup
    //   205: instanceof clojure/core/async/impl/protocols/Buffer
    //   208: ifne -> 233
    //   211: dup
    //   212: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   215: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__6 : Ljava/lang/Class;
    //   218: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__11 : Lclojure/lang/Var;
    //   221: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   224: swap
    //   225: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   230: goto -> 241
    //   233: checkcast clojure/core/async/impl/protocols/Buffer
    //   236: invokeinterface full_QMARK_ : ()Ljava/lang/Object;
    //   241: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   246: astore #5
    //   248: aload #5
    //   250: dup
    //   251: ifnull -> 299
    //   254: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   257: if_acmpeq -> 300
    //   260: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__10 : Lclojure/lang/Var;
    //   263: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   266: checkcast clojure/lang/IFn
    //   269: aload_0
    //   270: getfield takes : Ljava/lang/Object;
    //   273: checkcast java/util/AbstractCollection
    //   276: invokevirtual isEmpty : ()Z
    //   279: ifeq -> 288
    //   282: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   285: goto -> 291
    //   288: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   291: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   296: goto -> 305
    //   299: pop
    //   300: aload #5
    //   302: aconst_null
    //   303: astore #5
    //   305: goto -> 314
    //   308: pop
    //   309: aload #4
    //   311: aconst_null
    //   312: astore #4
    //   314: dup
    //   315: ifnull -> 1176
    //   318: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   321: if_acmpeq -> 1177
    //   324: aload_3
    //   325: checkcast java/util/concurrent/locks/Lock
    //   328: invokeinterface lock : ()V
    //   333: aconst_null
    //   334: pop
    //   335: aload_3
    //   336: dup
    //   337: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   340: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__7 : Ljava/lang/Class;
    //   343: if_acmpeq -> 360
    //   346: dup
    //   347: instanceof clojure/core/async/impl/protocols/Handler
    //   350: ifne -> 375
    //   353: dup
    //   354: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   357: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__7 : Ljava/lang/Class;
    //   360: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__0 : Lclojure/lang/Var;
    //   363: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   366: swap
    //   367: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   372: goto -> 383
    //   375: checkcast clojure/core/async/impl/protocols/Handler
    //   378: invokeinterface active_QMARK_ : ()Ljava/lang/Object;
    //   383: astore #4
    //   385: aload #4
    //   387: dup
    //   388: ifnull -> 448
    //   391: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   394: if_acmpeq -> 449
    //   397: aload_3
    //   398: dup
    //   399: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   402: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__8 : Ljava/lang/Class;
    //   405: if_acmpeq -> 422
    //   408: dup
    //   409: instanceof clojure/core/async/impl/protocols/Handler
    //   412: ifne -> 437
    //   415: dup
    //   416: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   419: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__8 : Ljava/lang/Class;
    //   422: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__3 : Lclojure/lang/Var;
    //   425: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   428: swap
    //   429: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   434: goto -> 445
    //   437: checkcast clojure/core/async/impl/protocols/Handler
    //   440: invokeinterface commit : ()Ljava/lang/Object;
    //   445: goto -> 454
    //   448: pop
    //   449: aload #4
    //   451: aconst_null
    //   452: astore #4
    //   454: astore #4
    //   456: aload_3
    //   457: aconst_null
    //   458: astore_3
    //   459: checkcast java/util/concurrent/locks/Lock
    //   462: invokeinterface unlock : ()V
    //   467: aconst_null
    //   468: pop
    //   469: aload #4
    //   471: aconst_null
    //   472: astore #4
    //   474: dup
    //   475: ifnull -> 1157
    //   478: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   481: if_acmpeq -> 1158
    //   484: aload_0
    //   485: getfield add_BANG_ : Ljava/lang/Object;
    //   488: checkcast clojure/lang/IFn
    //   491: aload_0
    //   492: getfield buf : Ljava/lang/Object;
    //   495: aload_1
    //   496: aconst_null
    //   497: astore_1
    //   498: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   503: invokestatic isReduced : (Ljava/lang/Object;)Z
    //   506: istore #5
    //   508: aload_0
    //   509: getfield buf : Ljava/lang/Object;
    //   512: invokestatic count : (Ljava/lang/Object;)I
    //   515: i2l
    //   516: lconst_0
    //   517: lcmp
    //   518: ifle -> 1061
    //   521: aload_0
    //   522: getfield takes : Ljava/lang/Object;
    //   525: checkcast java/util/AbstractSequentialList
    //   528: invokevirtual iterator : ()Ljava/util/Iterator;
    //   531: astore #6
    //   533: new clojure/core/async/impl/channels/ManyToManyChannel$fn__479
    //   536: dup
    //   537: aload #6
    //   539: aconst_null
    //   540: astore #6
    //   542: aload_0
    //   543: getfield buf : Ljava/lang/Object;
    //   546: invokespecial <init> : (Ljava/lang/Object;Ljava/lang/Object;)V
    //   549: checkcast clojure/lang/IFn
    //   552: invokeinterface invoke : ()Ljava/lang/Object;
    //   557: astore #7
    //   559: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__15 : Lclojure/lang/Var;
    //   562: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   565: checkcast clojure/lang/IFn
    //   568: aload #7
    //   570: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   575: dup
    //   576: ifnull -> 982
    //   579: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   582: if_acmpeq -> 983
    //   585: iload #5
    //   587: ifeq -> 643
    //   590: aload_0
    //   591: dup
    //   592: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   595: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__9 : Ljava/lang/Class;
    //   598: if_acmpeq -> 615
    //   601: dup
    //   602: instanceof clojure/core/async/impl/channels/MMC
    //   605: ifne -> 630
    //   608: dup
    //   609: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   612: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__9 : Ljava/lang/Class;
    //   615: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__16 : Lclojure/lang/Var;
    //   618: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   621: swap
    //   622: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   627: goto -> 638
    //   630: checkcast clojure/core/async/impl/channels/MMC
    //   633: invokeinterface abort : ()Ljava/lang/Object;
    //   638: pop
    //   639: goto -> 645
    //   642: athrow
    //   643: aconst_null
    //   644: pop
    //   645: aload_0
    //   646: getfield mutex : Ljava/lang/Object;
    //   649: checkcast java/util/concurrent/locks/Lock
    //   652: invokeinterface unlock : ()V
    //   657: aconst_null
    //   658: pop
    //   659: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__15 : Lclojure/lang/Var;
    //   662: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   665: checkcast clojure/lang/IFn
    //   668: aload #7
    //   670: aconst_null
    //   671: astore #7
    //   673: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   678: astore #8
    //   680: aconst_null
    //   681: astore #9
    //   683: lconst_0
    //   684: lstore #10
    //   686: lconst_0
    //   687: lstore #12
    //   689: lload #12
    //   691: lload #10
    //   693: lcmp
    //   694: ifge -> 765
    //   697: aload #9
    //   699: checkcast clojure/lang/Indexed
    //   702: lload #12
    //   704: invokestatic intCast : (J)I
    //   707: invokeinterface nth : (I)Ljava/lang/Object;
    //   712: astore #14
    //   714: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__4 : Lclojure/lang/Var;
    //   717: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   720: checkcast clojure/lang/IFn
    //   723: aload #14
    //   725: aconst_null
    //   726: astore #14
    //   728: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   733: pop
    //   734: aload #8
    //   736: aconst_null
    //   737: astore #8
    //   739: aload #9
    //   741: aconst_null
    //   742: astore #9
    //   744: lload #10
    //   746: lload #12
    //   748: lconst_1
    //   749: ladd
    //   750: lstore #12
    //   752: lstore #10
    //   754: astore #9
    //   756: astore #8
    //   758: goto -> 689
    //   761: nop
    //   762: nop
    //   763: athrow
    //   764: athrow
    //   765: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__15 : Lclojure/lang/Var;
    //   768: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   771: checkcast clojure/lang/IFn
    //   774: aload #8
    //   776: aconst_null
    //   777: astore #8
    //   779: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   784: astore #14
    //   786: aload #14
    //   788: dup
    //   789: ifnull -> 976
    //   792: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   795: if_acmpeq -> 977
    //   798: aload #14
    //   800: aconst_null
    //   801: astore #14
    //   803: astore #15
    //   805: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__19 : Lclojure/lang/Var;
    //   808: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   811: checkcast clojure/lang/IFn
    //   814: aload #15
    //   816: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   821: dup
    //   822: ifnull -> 901
    //   825: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   828: if_acmpeq -> 902
    //   831: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__20 : Lclojure/lang/Var;
    //   834: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   837: checkcast clojure/lang/IFn
    //   840: aload #15
    //   842: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   847: astore #16
    //   849: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__21 : Lclojure/lang/Var;
    //   852: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   855: checkcast clojure/lang/IFn
    //   858: aload #15
    //   860: aconst_null
    //   861: astore #15
    //   863: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   868: aload #16
    //   870: aload #16
    //   872: aconst_null
    //   873: astore #16
    //   875: invokestatic count : (Ljava/lang/Object;)I
    //   878: invokestatic intCast : (I)I
    //   881: i2l
    //   882: lconst_0
    //   883: invokestatic intCast : (J)I
    //   886: i2l
    //   887: lstore #12
    //   889: lstore #10
    //   891: astore #9
    //   893: astore #8
    //   895: goto -> 689
    //   898: nop
    //   899: nop
    //   900: athrow
    //   901: pop
    //   902: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__23 : Lclojure/lang/Var;
    //   905: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   908: checkcast clojure/lang/IFn
    //   911: aload #15
    //   913: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   918: astore #16
    //   920: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__4 : Lclojure/lang/Var;
    //   923: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   926: checkcast clojure/lang/IFn
    //   929: aload #16
    //   931: aconst_null
    //   932: astore #16
    //   934: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   939: pop
    //   940: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__24 : Lclojure/lang/Var;
    //   943: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   946: checkcast clojure/lang/IFn
    //   949: aload #15
    //   951: aconst_null
    //   952: astore #15
    //   954: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   959: aconst_null
    //   960: lconst_0
    //   961: lconst_0
    //   962: lstore #12
    //   964: lstore #10
    //   966: astore #9
    //   968: astore #8
    //   970: goto -> 689
    //   973: nop
    //   974: nop
    //   975: athrow
    //   976: pop
    //   977: aconst_null
    //   978: pop
    //   979: goto -> 1057
    //   982: pop
    //   983: iload #5
    //   985: ifeq -> 1041
    //   988: aload_0
    //   989: dup
    //   990: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   993: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__10 : Ljava/lang/Class;
    //   996: if_acmpeq -> 1013
    //   999: dup
    //   1000: instanceof clojure/core/async/impl/channels/MMC
    //   1003: ifne -> 1028
    //   1006: dup
    //   1007: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1010: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__10 : Ljava/lang/Class;
    //   1013: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__16 : Lclojure/lang/Var;
    //   1016: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1019: swap
    //   1020: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1025: goto -> 1036
    //   1028: checkcast clojure/core/async/impl/channels/MMC
    //   1031: invokeinterface abort : ()Ljava/lang/Object;
    //   1036: pop
    //   1037: goto -> 1043
    //   1040: athrow
    //   1041: aconst_null
    //   1042: pop
    //   1043: aload_0
    //   1044: getfield mutex : Ljava/lang/Object;
    //   1047: checkcast java/util/concurrent/locks/Lock
    //   1050: invokeinterface unlock : ()V
    //   1055: aconst_null
    //   1056: pop
    //   1057: goto -> 1135
    //   1060: athrow
    //   1061: iload #5
    //   1063: ifeq -> 1119
    //   1066: aload_0
    //   1067: dup
    //   1068: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1071: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__11 : Ljava/lang/Class;
    //   1074: if_acmpeq -> 1091
    //   1077: dup
    //   1078: instanceof clojure/core/async/impl/channels/MMC
    //   1081: ifne -> 1106
    //   1084: dup
    //   1085: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1088: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__11 : Ljava/lang/Class;
    //   1091: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__16 : Lclojure/lang/Var;
    //   1094: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1097: swap
    //   1098: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1103: goto -> 1114
    //   1106: checkcast clojure/core/async/impl/channels/MMC
    //   1109: invokeinterface abort : ()Ljava/lang/Object;
    //   1114: pop
    //   1115: goto -> 1121
    //   1118: athrow
    //   1119: aconst_null
    //   1120: pop
    //   1121: aload_0
    //   1122: getfield mutex : Ljava/lang/Object;
    //   1125: checkcast java/util/concurrent/locks/Lock
    //   1128: invokeinterface unlock : ()V
    //   1133: aconst_null
    //   1134: pop
    //   1135: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__9 : Lclojure/lang/Var;
    //   1138: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1141: checkcast clojure/lang/IFn
    //   1144: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   1147: aconst_null
    //   1148: astore_0
    //   1149: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1154: goto -> 1173
    //   1157: pop
    //   1158: aload_0
    //   1159: getfield mutex : Ljava/lang/Object;
    //   1162: checkcast java/util/concurrent/locks/Lock
    //   1165: invokeinterface unlock : ()V
    //   1170: aconst_null
    //   1171: pop
    //   1172: aconst_null
    //   1173: goto -> 2060
    //   1176: pop
    //   1177: aload_0
    //   1178: getfield takes : Ljava/lang/Object;
    //   1181: checkcast java/util/AbstractSequentialList
    //   1184: invokevirtual iterator : ()Ljava/util/Iterator;
    //   1187: astore #4
    //   1189: aload #4
    //   1191: checkcast java/util/Iterator
    //   1194: invokeinterface hasNext : ()Z
    //   1199: ifeq -> 1227
    //   1202: new clojure/core/async/impl/channels/ManyToManyChannel$fn__492
    //   1205: dup
    //   1206: aload_3
    //   1207: aload #4
    //   1209: aconst_null
    //   1210: astore #4
    //   1212: invokespecial <init> : (Ljava/lang/Object;Ljava/lang/Object;)V
    //   1215: checkcast clojure/lang/IFn
    //   1218: invokeinterface invoke : ()Ljava/lang/Object;
    //   1223: goto -> 1228
    //   1226: athrow
    //   1227: aconst_null
    //   1228: astore #5
    //   1230: aload #5
    //   1232: lconst_0
    //   1233: invokestatic intCast : (J)I
    //   1236: aconst_null
    //   1237: invokestatic nth : (Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;
    //   1240: astore #6
    //   1242: aload #5
    //   1244: aconst_null
    //   1245: astore #5
    //   1247: lconst_1
    //   1248: invokestatic intCast : (J)I
    //   1251: aconst_null
    //   1252: invokestatic nth : (Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;
    //   1255: astore #7
    //   1257: aload #6
    //   1259: aconst_null
    //   1260: astore #6
    //   1262: astore #8
    //   1264: aload #8
    //   1266: dup
    //   1267: ifnull -> 1281
    //   1270: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   1273: if_acmpeq -> 1282
    //   1276: aload #7
    //   1278: goto -> 1287
    //   1281: pop
    //   1282: aload #8
    //   1284: aconst_null
    //   1285: astore #8
    //   1287: dup
    //   1288: ifnull -> 1363
    //   1291: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   1294: if_acmpeq -> 1364
    //   1297: aload_0
    //   1298: getfield mutex : Ljava/lang/Object;
    //   1301: checkcast java/util/concurrent/locks/Lock
    //   1304: invokeinterface unlock : ()V
    //   1309: aconst_null
    //   1310: pop
    //   1311: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__4 : Lclojure/lang/Var;
    //   1314: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1317: checkcast clojure/lang/IFn
    //   1320: new clojure/core/async/impl/channels/ManyToManyChannel$fn__495
    //   1323: dup
    //   1324: aload #7
    //   1326: aconst_null
    //   1327: astore #7
    //   1329: aload_1
    //   1330: aconst_null
    //   1331: astore_1
    //   1332: invokespecial <init> : (Ljava/lang/Object;Ljava/lang/Object;)V
    //   1335: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1340: pop
    //   1341: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__9 : Lclojure/lang/Var;
    //   1344: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1347: checkcast clojure/lang/IFn
    //   1350: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   1353: aconst_null
    //   1354: astore_0
    //   1355: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1360: goto -> 2060
    //   1363: pop
    //   1364: aload_0
    //   1365: getfield buf : Ljava/lang/Object;
    //   1368: astore #8
    //   1370: aload #8
    //   1372: dup
    //   1373: ifnull -> 1450
    //   1376: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   1379: if_acmpeq -> 1451
    //   1382: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__10 : Lclojure/lang/Var;
    //   1385: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1388: checkcast clojure/lang/IFn
    //   1391: aload_0
    //   1392: getfield buf : Ljava/lang/Object;
    //   1395: dup
    //   1396: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1399: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__12 : Ljava/lang/Class;
    //   1402: if_acmpeq -> 1419
    //   1405: dup
    //   1406: instanceof clojure/core/async/impl/protocols/Buffer
    //   1409: ifne -> 1434
    //   1412: dup
    //   1413: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1416: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__12 : Ljava/lang/Class;
    //   1419: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__11 : Lclojure/lang/Var;
    //   1422: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1425: swap
    //   1426: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1431: goto -> 1442
    //   1434: checkcast clojure/core/async/impl/protocols/Buffer
    //   1437: invokeinterface full_QMARK_ : ()Ljava/lang/Object;
    //   1442: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1447: goto -> 1456
    //   1450: pop
    //   1451: aload #8
    //   1453: aconst_null
    //   1454: astore #8
    //   1456: dup
    //   1457: ifnull -> 1765
    //   1460: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   1463: if_acmpeq -> 1766
    //   1466: aload_3
    //   1467: checkcast java/util/concurrent/locks/Lock
    //   1470: invokeinterface lock : ()V
    //   1475: aconst_null
    //   1476: pop
    //   1477: aload_3
    //   1478: dup
    //   1479: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1482: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__13 : Ljava/lang/Class;
    //   1485: if_acmpeq -> 1502
    //   1488: dup
    //   1489: instanceof clojure/core/async/impl/protocols/Handler
    //   1492: ifne -> 1517
    //   1495: dup
    //   1496: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1499: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__13 : Ljava/lang/Class;
    //   1502: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__0 : Lclojure/lang/Var;
    //   1505: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1508: swap
    //   1509: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1514: goto -> 1525
    //   1517: checkcast clojure/core/async/impl/protocols/Handler
    //   1520: invokeinterface active_QMARK_ : ()Ljava/lang/Object;
    //   1525: astore #8
    //   1527: aload #8
    //   1529: dup
    //   1530: ifnull -> 1590
    //   1533: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   1536: if_acmpeq -> 1591
    //   1539: aload_3
    //   1540: dup
    //   1541: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1544: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__14 : Ljava/lang/Class;
    //   1547: if_acmpeq -> 1564
    //   1550: dup
    //   1551: instanceof clojure/core/async/impl/protocols/Handler
    //   1554: ifne -> 1579
    //   1557: dup
    //   1558: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1561: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__14 : Ljava/lang/Class;
    //   1564: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__3 : Lclojure/lang/Var;
    //   1567: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1570: swap
    //   1571: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1576: goto -> 1587
    //   1579: checkcast clojure/core/async/impl/protocols/Handler
    //   1582: invokeinterface commit : ()Ljava/lang/Object;
    //   1587: goto -> 1596
    //   1590: pop
    //   1591: aload #8
    //   1593: aconst_null
    //   1594: astore #8
    //   1596: astore #8
    //   1598: aload_3
    //   1599: aconst_null
    //   1600: astore_3
    //   1601: checkcast java/util/concurrent/locks/Lock
    //   1604: invokeinterface unlock : ()V
    //   1609: aconst_null
    //   1610: pop
    //   1611: aload #8
    //   1613: aconst_null
    //   1614: astore #8
    //   1616: dup
    //   1617: ifnull -> 1746
    //   1620: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   1623: if_acmpeq -> 1747
    //   1626: aload_0
    //   1627: getfield add_BANG_ : Ljava/lang/Object;
    //   1630: checkcast clojure/lang/IFn
    //   1633: aload_0
    //   1634: getfield buf : Ljava/lang/Object;
    //   1637: aload_1
    //   1638: aconst_null
    //   1639: astore_1
    //   1640: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1645: invokestatic isReduced : (Ljava/lang/Object;)Z
    //   1648: istore #9
    //   1650: iload #9
    //   1652: ifeq -> 1708
    //   1655: aload_0
    //   1656: dup
    //   1657: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1660: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__15 : Ljava/lang/Class;
    //   1663: if_acmpeq -> 1680
    //   1666: dup
    //   1667: instanceof clojure/core/async/impl/channels/MMC
    //   1670: ifne -> 1695
    //   1673: dup
    //   1674: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1677: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__15 : Ljava/lang/Class;
    //   1680: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__16 : Lclojure/lang/Var;
    //   1683: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1686: swap
    //   1687: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1692: goto -> 1703
    //   1695: checkcast clojure/core/async/impl/channels/MMC
    //   1698: invokeinterface abort : ()Ljava/lang/Object;
    //   1703: pop
    //   1704: goto -> 1710
    //   1707: athrow
    //   1708: aconst_null
    //   1709: pop
    //   1710: aload_0
    //   1711: getfield mutex : Ljava/lang/Object;
    //   1714: checkcast java/util/concurrent/locks/Lock
    //   1717: invokeinterface unlock : ()V
    //   1722: aconst_null
    //   1723: pop
    //   1724: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__9 : Lclojure/lang/Var;
    //   1727: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1730: checkcast clojure/lang/IFn
    //   1733: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   1736: aconst_null
    //   1737: astore_0
    //   1738: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1743: goto -> 1762
    //   1746: pop
    //   1747: aload_0
    //   1748: getfield mutex : Ljava/lang/Object;
    //   1751: checkcast java/util/concurrent/locks/Lock
    //   1754: invokeinterface unlock : ()V
    //   1759: aconst_null
    //   1760: pop
    //   1761: aconst_null
    //   1762: goto -> 2060
    //   1765: pop
    //   1766: aload_3
    //   1767: dup
    //   1768: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1771: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__16 : Ljava/lang/Class;
    //   1774: if_acmpeq -> 1791
    //   1777: dup
    //   1778: instanceof clojure/core/async/impl/protocols/Handler
    //   1781: ifne -> 1806
    //   1784: dup
    //   1785: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1788: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__16 : Ljava/lang/Class;
    //   1791: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__0 : Lclojure/lang/Var;
    //   1794: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1797: swap
    //   1798: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1803: goto -> 1814
    //   1806: checkcast clojure/core/async/impl/protocols/Handler
    //   1809: invokeinterface active_QMARK_ : ()Ljava/lang/Object;
    //   1814: astore #8
    //   1816: aload #8
    //   1818: dup
    //   1819: ifnull -> 1879
    //   1822: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   1825: if_acmpeq -> 1880
    //   1828: aload_3
    //   1829: dup
    //   1830: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1833: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__17 : Ljava/lang/Class;
    //   1836: if_acmpeq -> 1853
    //   1839: dup
    //   1840: instanceof clojure/core/async/impl/protocols/Handler
    //   1843: ifne -> 1868
    //   1846: dup
    //   1847: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   1850: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__17 : Ljava/lang/Class;
    //   1853: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__26 : Lclojure/lang/Var;
    //   1856: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1859: swap
    //   1860: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1865: goto -> 1876
    //   1868: checkcast clojure/core/async/impl/protocols/Handler
    //   1871: invokeinterface blockable_QMARK_ : ()Ljava/lang/Object;
    //   1876: goto -> 1885
    //   1879: pop
    //   1880: aload #8
    //   1882: aconst_null
    //   1883: astore #8
    //   1885: dup
    //   1886: ifnull -> 2042
    //   1889: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   1892: if_acmpeq -> 2043
    //   1895: aload_0
    //   1896: getfield puts : Ljava/lang/Object;
    //   1899: checkcast java/util/LinkedList
    //   1902: invokevirtual size : ()I
    //   1905: i2l
    //   1906: ldc2_w 1024
    //   1909: lcmp
    //   1910: ifge -> 1919
    //   1913: aconst_null
    //   1914: pop
    //   1915: goto -> 2007
    //   1918: athrow
    //   1919: aload_0
    //   1920: getfield mutex : Ljava/lang/Object;
    //   1923: checkcast java/util/concurrent/locks/Lock
    //   1926: invokeinterface unlock : ()V
    //   1931: aconst_null
    //   1932: pop
    //   1933: new java/lang/AssertionError
    //   1936: dup
    //   1937: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__28 : Lclojure/lang/Var;
    //   1940: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1943: checkcast clojure/lang/IFn
    //   1946: ldc_w 'Assert failed: '
    //   1949: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__28 : Lclojure/lang/Var;
    //   1952: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1955: checkcast clojure/lang/IFn
    //   1958: ldc_w 'No more than '
    //   1961: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__27 : Ljava/lang/Object;
    //   1964: ldc_w ' pending puts are allowed on a single channel.'
    //   1967: ldc_w ' Consider using a windowed buffer.'
    //   1970: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1975: ldc_w '\\n'
    //   1978: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__29 : Lclojure/lang/Var;
    //   1981: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1984: checkcast clojure/lang/IFn
    //   1987: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__30 : Ljava/lang/Object;
    //   1990: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1995: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   2000: invokespecial <init> : (Ljava/lang/Object;)V
    //   2003: checkcast java/lang/Throwable
    //   2006: athrow
    //   2007: aload_0
    //   2008: getfield puts : Ljava/lang/Object;
    //   2011: checkcast java/util/LinkedList
    //   2014: aload_3
    //   2015: aconst_null
    //   2016: astore_3
    //   2017: aload_1
    //   2018: aconst_null
    //   2019: astore_1
    //   2020: invokestatic create : (Ljava/lang/Object;Ljava/lang/Object;)Lclojure/lang/IPersistentVector;
    //   2023: invokevirtual add : (Ljava/lang/Object;)Z
    //   2026: ifeq -> 2035
    //   2029: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   2032: goto -> 2038
    //   2035: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   2038: pop
    //   2039: goto -> 2045
    //   2042: pop
    //   2043: aconst_null
    //   2044: pop
    //   2045: aload_0
    //   2046: getfield mutex : Ljava/lang/Object;
    //   2049: checkcast java/util/concurrent/locks/Lock
    //   2052: invokeinterface unlock : ()V
    //   2057: aconst_null
    //   2058: pop
    //   2059: aconst_null
    //   2060: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #32	-> 0
    //   #69	-> 0
    //   #69	-> 2
    //   #71	-> 38
    //   #72	-> 45
    //   #72	-> 77
    //   #73	-> 94
    //   #73	-> 100
    //   #73	-> 107
    //   #74	-> 129
    //   #75	-> 142
    //   #75	-> 148
    //   #77	-> 163
    //   #77	-> 169
    //   #77	-> 187
    //   #77	-> 190
    //   #77	-> 225
    //   #77	-> 241
    //   #77	-> 248
    //   #77	-> 266
    //   #77	-> 276
    //   #77	-> 291
    //   #79	-> 328
    //   #80	-> 335
    //   #80	-> 367
    //   #80	-> 385
    //   #80	-> 397
    //   #80	-> 429
    //   #81	-> 462
    //   #82	-> 469
    //   #83	-> 488
    //   #83	-> 498
    //   #83	-> 503
    //   #84	-> 508
    //   #84	-> 508
    //   #84	-> 512
    //   #85	-> 528
    //   #86	-> 549
    //   #86	-> 552
    //   #98	-> 559
    //   #98	-> 565
    //   #98	-> 570
    //   #100	-> 585
    //   #101	-> 590
    //   #101	-> 622
    //   #102	-> 652
    //   #103	-> 665
    //   #103	-> 673
    //   #103	-> 689
    //   #103	-> 689
    //   #103	-> 707
    //   #104	-> 720
    //   #104	-> 728
    //   #103	-> 748
    //   #103	-> 771
    //   #103	-> 779
    //   #103	-> 786
    //   #103	-> 805
    //   #103	-> 811
    //   #103	-> 816
    //   #103	-> 837
    //   #103	-> 842
    //   #103	-> 855
    //   #103	-> 863
    //   #103	-> 875
    //   #103	-> 878
    //   #103	-> 883
    //   #103	-> 908
    //   #103	-> 913
    //   #104	-> 926
    //   #104	-> 934
    //   #103	-> 946
    //   #103	-> 954
    //   #106	-> 983
    //   #107	-> 988
    //   #107	-> 1020
    //   #108	-> 1050
    //   #110	-> 1061
    //   #111	-> 1066
    //   #111	-> 1098
    //   #112	-> 1128
    //   #113	-> 1141
    //   #113	-> 1147
    //   #114	-> 1165
    //   #116	-> 1184
    //   #117	-> 1189
    //   #117	-> 1194
    //   #118	-> 1215
    //   #118	-> 1218
    //   #116	-> 1237
    //   #116	-> 1252
    //   #132	-> 1257
    //   #132	-> 1264
    //   #134	-> 1304
    //   #135	-> 1317
    //   #135	-> 1335
    //   #136	-> 1347
    //   #136	-> 1353
    //   #137	-> 1364
    //   #137	-> 1370
    //   #137	-> 1388
    //   #137	-> 1391
    //   #137	-> 1426
    //   #137	-> 1442
    //   #139	-> 1470
    //   #140	-> 1477
    //   #140	-> 1509
    //   #140	-> 1527
    //   #140	-> 1539
    //   #140	-> 1571
    //   #141	-> 1604
    //   #142	-> 1611
    //   #143	-> 1630
    //   #143	-> 1640
    //   #143	-> 1645
    //   #144	-> 1650
    //   #145	-> 1655
    //   #145	-> 1687
    //   #146	-> 1717
    //   #147	-> 1730
    //   #147	-> 1736
    //   #148	-> 1754
    //   #151	-> 1766
    //   #151	-> 1766
    //   #151	-> 1798
    //   #151	-> 1816
    //   #151	-> 1828
    //   #151	-> 1860
    //   #152	-> 1895
    //   #153	-> 1895
    //   #153	-> 1902
    //   #152	-> 1926
    //   #152	-> 1943
    //   #154	-> 1955
    //   #154	-> 1970
    //   #152	-> 1984
    //   #152	-> 1990
    //   #152	-> 1995
    //   #157	-> 2023
    //   #158	-> 2052
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   248	57	5	and__5514__auto__557	Ljava/lang/Object;
    //   169	145	4	and__5514__auto__558	Ljava/lang/Object;
    //   385	69	4	and__5514__auto__559	Ljava/lang/Object;
    //   714	47	14	f	Ljava/lang/Object;
    //   849	49	16	c__5998__auto__560	Ljava/lang/Object;
    //   920	53	16	f	Ljava/lang/Object;
    //   805	168	15	seq_485	Ljava/lang/Object;
    //   786	193	14	temp__5735__auto__561	Ljava/lang/Object;
    //   680	299	8	seq_485	Ljava/lang/Object;
    //   683	296	9	chunk_486	Ljava/lang/Object;
    //   686	293	10	count_487	J
    //   689	290	12	i_488	J
    //   533	524	6	iter	Ljava/lang/Object;
    //   559	498	7	take_cbs	Ljava/lang/Object;
    //   508	646	5	done_QMARK_	Z
    //   456	717	4	put_cb	Ljava/lang/Object;
    //   1264	23	8	and__5514__auto__562	Ljava/lang/Object;
    //   1370	86	8	and__5514__auto__563	Ljava/lang/Object;
    //   1527	69	8	and__5514__auto__564	Ljava/lang/Object;
    //   1650	93	9	done_QMARK_	Z
    //   1598	164	8	put_cb	Ljava/lang/Object;
    //   1816	69	8	and__5514__auto__565	Ljava/lang/Object;
    //   1189	871	4	iter	Ljava/lang/Object;
    //   1230	830	5	vec__489	Ljava/lang/Object;
    //   1242	818	6	put_cb	Ljava/lang/Object;
    //   1257	803	7	take_cb	Ljava/lang/Object;
    //   163	1897	3	handler	Ljava/lang/Object;
    //   0	2060	0	this	Lclojure/core/async/impl/channels/ManyToManyChannel;
    //   0	2060	1	val	Ljava/lang/Object;
    //   0	2060	2	handler	Ljava/lang/Object; }
  
  public Object abort() { // Byte code:
    //   0: aload_0
    //   1: getfield puts : Ljava/lang/Object;
    //   4: checkcast java/util/AbstractSequentialList
    //   7: invokevirtual iterator : ()Ljava/util/Iterator;
    //   10: astore_1
    //   11: aload_1
    //   12: checkcast java/util/Iterator
    //   15: invokeinterface hasNext : ()Z
    //   20: ifeq -> 305
    //   23: aload_1
    //   24: checkcast java/util/Iterator
    //   27: invokeinterface next : ()Ljava/lang/Object;
    //   32: astore_2
    //   33: aload_2
    //   34: astore_3
    //   35: aload_3
    //   36: aconst_null
    //   37: astore_3
    //   38: lconst_0
    //   39: invokestatic intCast : (J)I
    //   42: aconst_null
    //   43: invokestatic nth : (Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;
    //   46: pop
    //   47: aload_2
    //   48: aconst_null
    //   49: astore_2
    //   50: astore #4
    //   52: aload #4
    //   54: aconst_null
    //   55: astore #4
    //   57: astore #5
    //   59: aload #5
    //   61: aconst_null
    //   62: astore #5
    //   64: lconst_0
    //   65: invokestatic intCast : (J)I
    //   68: aconst_null
    //   69: invokestatic nth : (Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;
    //   72: astore #6
    //   74: aload #6
    //   76: checkcast java/util/concurrent/locks/Lock
    //   79: invokeinterface lock : ()V
    //   84: aconst_null
    //   85: pop
    //   86: aload #6
    //   88: dup
    //   89: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   92: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__2 : Ljava/lang/Class;
    //   95: if_acmpeq -> 112
    //   98: dup
    //   99: instanceof clojure/core/async/impl/protocols/Handler
    //   102: ifne -> 127
    //   105: dup
    //   106: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   109: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__2 : Ljava/lang/Class;
    //   112: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__0 : Lclojure/lang/Var;
    //   115: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   118: swap
    //   119: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   124: goto -> 135
    //   127: checkcast clojure/core/async/impl/protocols/Handler
    //   130: invokeinterface active_QMARK_ : ()Ljava/lang/Object;
    //   135: astore #7
    //   137: aload #7
    //   139: dup
    //   140: ifnull -> 201
    //   143: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   146: if_acmpeq -> 202
    //   149: aload #6
    //   151: dup
    //   152: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   155: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__3 : Ljava/lang/Class;
    //   158: if_acmpeq -> 175
    //   161: dup
    //   162: instanceof clojure/core/async/impl/protocols/Handler
    //   165: ifne -> 190
    //   168: dup
    //   169: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   172: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__3 : Ljava/lang/Class;
    //   175: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__3 : Lclojure/lang/Var;
    //   178: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   181: swap
    //   182: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   187: goto -> 198
    //   190: checkcast clojure/core/async/impl/protocols/Handler
    //   193: invokeinterface commit : ()Ljava/lang/Object;
    //   198: goto -> 207
    //   201: pop
    //   202: aload #7
    //   204: aconst_null
    //   205: astore #7
    //   207: astore #7
    //   209: aload #6
    //   211: aconst_null
    //   212: astore #6
    //   214: checkcast java/util/concurrent/locks/Lock
    //   217: invokeinterface unlock : ()V
    //   222: aconst_null
    //   223: pop
    //   224: aload #7
    //   226: dup
    //   227: ifnull -> 266
    //   230: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   233: if_acmpeq -> 267
    //   236: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__4 : Lclojure/lang/Var;
    //   239: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   242: checkcast clojure/lang/IFn
    //   245: new clojure/core/async/impl/channels/ManyToManyChannel$fn__477
    //   248: dup
    //   249: aload #7
    //   251: aconst_null
    //   252: astore #7
    //   254: invokespecial <init> : (Ljava/lang/Object;)V
    //   257: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   262: pop
    //   263: goto -> 269
    //   266: pop
    //   267: aconst_null
    //   268: pop
    //   269: aload_1
    //   270: checkcast java/util/Iterator
    //   273: invokeinterface hasNext : ()Z
    //   278: ifeq -> 299
    //   281: aload_1
    //   282: checkcast java/util/Iterator
    //   285: invokeinterface next : ()Ljava/lang/Object;
    //   290: astore #4
    //   292: goto -> 52
    //   295: nop
    //   296: nop
    //   297: athrow
    //   298: athrow
    //   299: aconst_null
    //   300: pop
    //   301: goto -> 307
    //   304: athrow
    //   305: aconst_null
    //   306: pop
    //   307: aload_0
    //   308: getfield puts : Ljava/lang/Object;
    //   311: checkcast java/util/LinkedList
    //   314: invokevirtual clear : ()V
    //   317: aconst_null
    //   318: pop
    //   319: aload_0
    //   320: dup
    //   321: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   324: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__4 : Ljava/lang/Class;
    //   327: if_acmpeq -> 344
    //   330: dup
    //   331: instanceof clojure/core/async/impl/protocols/Channel
    //   334: ifne -> 361
    //   337: dup
    //   338: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   341: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__4 : Ljava/lang/Class;
    //   344: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__5 : Lclojure/lang/Var;
    //   347: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   350: swap
    //   351: aconst_null
    //   352: astore_0
    //   353: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   358: goto -> 369
    //   361: checkcast clojure/core/async/impl/protocols/Channel
    //   364: invokeinterface close_BANG_ : ()Ljava/lang/Object;
    //   369: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #32	-> 0
    //   #53	-> 7
    //   #54	-> 11
    //   #54	-> 15
    //   #55	-> 27
    //   #55	-> 43
    //   #55	-> 69
    //   #56	-> 79
    //   #57	-> 86
    //   #57	-> 119
    //   #57	-> 137
    //   #57	-> 149
    //   #57	-> 182
    //   #58	-> 217
    //   #59	-> 224
    //   #60	-> 242
    //   #60	-> 257
    //   #61	-> 269
    //   #61	-> 273
    //   #62	-> 285
    //   #63	-> 314
    //   #64	-> 319
    //   #64	-> 351
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   137	70	7	and__5514__auto__566	Ljava/lang/Object;
    //   209	92	7	put_cb	Ljava/lang/Object;
    //   59	242	5	vec__474	Ljava/lang/Object;
    //   74	227	6	putter	Ljava/lang/Object;
    //   52	249	4	G__470	Ljava/lang/Object;
    //   33	268	2	G__470	Ljava/lang/Object;
    //   35	266	3	vec__471	Ljava/lang/Object;
    //   47	254	8	putter	Ljava/lang/Object;
    //   11	296	1	iter	Ljava/lang/Object;
    //   0	369	0	this	Lclojure/core/async/impl/channels/ManyToManyChannel; }
  
  public Object cleanup() { // Byte code:
    //   0: aload_0
    //   1: getfield takes : Ljava/lang/Object;
    //   4: checkcast java/util/AbstractCollection
    //   7: invokevirtual isEmpty : ()Z
    //   10: ifeq -> 19
    //   13: aconst_null
    //   14: pop
    //   15: goto -> 148
    //   18: athrow
    //   19: aload_0
    //   20: getfield takes : Ljava/lang/Object;
    //   23: checkcast java/util/AbstractSequentialList
    //   26: invokevirtual iterator : ()Ljava/util/Iterator;
    //   29: astore_1
    //   30: aload_1
    //   31: checkcast java/util/Iterator
    //   34: invokeinterface next : ()Ljava/lang/Object;
    //   39: astore_2
    //   40: aload_2
    //   41: aconst_null
    //   42: astore_2
    //   43: dup
    //   44: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   47: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__0 : Ljava/lang/Class;
    //   50: if_acmpeq -> 67
    //   53: dup
    //   54: instanceof clojure/core/async/impl/protocols/Handler
    //   57: ifne -> 82
    //   60: dup
    //   61: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   64: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__0 : Ljava/lang/Class;
    //   67: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__0 : Lclojure/lang/Var;
    //   70: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   73: swap
    //   74: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   79: goto -> 90
    //   82: checkcast clojure/core/async/impl/protocols/Handler
    //   85: invokeinterface active_QMARK_ : ()Ljava/lang/Object;
    //   90: dup
    //   91: ifnull -> 105
    //   94: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   97: if_acmpeq -> 106
    //   100: aconst_null
    //   101: pop
    //   102: goto -> 117
    //   105: pop
    //   106: aload_1
    //   107: checkcast java/util/Iterator
    //   110: invokeinterface remove : ()V
    //   115: aconst_null
    //   116: pop
    //   117: aload_1
    //   118: checkcast java/util/Iterator
    //   121: invokeinterface hasNext : ()Z
    //   126: ifeq -> 146
    //   129: aload_1
    //   130: checkcast java/util/Iterator
    //   133: invokeinterface next : ()Ljava/lang/Object;
    //   138: astore_2
    //   139: goto -> 40
    //   142: nop
    //   143: nop
    //   144: athrow
    //   145: athrow
    //   146: aconst_null
    //   147: pop
    //   148: aload_0
    //   149: getfield puts : Ljava/lang/Object;
    //   152: checkcast java/util/AbstractCollection
    //   155: invokevirtual isEmpty : ()Z
    //   158: ifeq -> 166
    //   161: aconst_null
    //   162: goto -> 338
    //   165: athrow
    //   166: aload_0
    //   167: getfield puts : Ljava/lang/Object;
    //   170: checkcast java/util/AbstractSequentialList
    //   173: invokevirtual iterator : ()Ljava/util/Iterator;
    //   176: astore_1
    //   177: aload_1
    //   178: checkcast java/util/Iterator
    //   181: invokeinterface next : ()Ljava/lang/Object;
    //   186: astore_2
    //   187: aload_2
    //   188: astore_3
    //   189: aload_3
    //   190: aconst_null
    //   191: astore_3
    //   192: lconst_0
    //   193: invokestatic intCast : (J)I
    //   196: aconst_null
    //   197: invokestatic nth : (Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;
    //   200: pop
    //   201: aload_2
    //   202: aconst_null
    //   203: astore_2
    //   204: astore #4
    //   206: aload #4
    //   208: aconst_null
    //   209: astore #4
    //   211: astore #5
    //   213: aload #5
    //   215: aconst_null
    //   216: astore #5
    //   218: lconst_0
    //   219: invokestatic intCast : (J)I
    //   222: aconst_null
    //   223: invokestatic nth : (Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;
    //   226: astore #6
    //   228: aload #6
    //   230: aconst_null
    //   231: astore #6
    //   233: dup
    //   234: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   237: getstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__1 : Ljava/lang/Class;
    //   240: if_acmpeq -> 257
    //   243: dup
    //   244: instanceof clojure/core/async/impl/protocols/Handler
    //   247: ifne -> 272
    //   250: dup
    //   251: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   254: putstatic clojure/core/async/impl/channels/ManyToManyChannel.__cached_class__1 : Ljava/lang/Class;
    //   257: getstatic clojure/core/async/impl/channels/ManyToManyChannel.const__0 : Lclojure/lang/Var;
    //   260: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   263: swap
    //   264: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   269: goto -> 280
    //   272: checkcast clojure/core/async/impl/protocols/Handler
    //   275: invokeinterface active_QMARK_ : ()Ljava/lang/Object;
    //   280: dup
    //   281: ifnull -> 295
    //   284: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   287: if_acmpeq -> 296
    //   290: aconst_null
    //   291: pop
    //   292: goto -> 307
    //   295: pop
    //   296: aload_1
    //   297: checkcast java/util/Iterator
    //   300: invokeinterface remove : ()V
    //   305: aconst_null
    //   306: pop
    //   307: aload_1
    //   308: checkcast java/util/Iterator
    //   311: invokeinterface hasNext : ()Z
    //   316: ifeq -> 337
    //   319: aload_1
    //   320: checkcast java/util/Iterator
    //   323: invokeinterface next : ()Ljava/lang/Object;
    //   328: astore #4
    //   330: goto -> 206
    //   333: nop
    //   334: nop
    //   335: athrow
    //   336: athrow
    //   337: aconst_null
    //   338: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #32	-> 0
    //   #36	-> 0
    //   #36	-> 7
    //   #37	-> 26
    //   #38	-> 34
    //   #39	-> 40
    //   #39	-> 40
    //   #39	-> 74
    //   #40	-> 110
    //   #41	-> 117
    //   #41	-> 121
    //   #42	-> 133
    //   #43	-> 148
    //   #43	-> 155
    //   #44	-> 173
    //   #45	-> 181
    //   #45	-> 197
    //   #45	-> 223
    //   #46	-> 228
    //   #46	-> 228
    //   #46	-> 264
    //   #47	-> 300
    //   #48	-> 307
    //   #48	-> 311
    //   #49	-> 323
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   40	108	2	taker	Ljava/lang/Object;
    //   30	118	1	iter	Ljava/lang/Object;
    //   213	125	5	vec__464	Ljava/lang/Object;
    //   228	110	6	putter	Ljava/lang/Object;
    //   206	132	4	G__460	Ljava/lang/Object;
    //   187	151	2	G__460	Ljava/lang/Object;
    //   189	149	3	vec__461	Ljava/lang/Object;
    //   201	137	7	putter	Ljava/lang/Object;
    //   177	161	1	iter	Ljava/lang/Object;
    //   0	338	0	this	Lclojure/core/async/impl/channels/ManyToManyChannel; }
}
