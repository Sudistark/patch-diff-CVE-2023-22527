package clojure.core.async.impl.timers;

import clojure.core.async.impl.protocols.Channel;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.Numbers;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Util;
import clojure.lang.Var;
import java.util.concurrent.Delayed;
import java.util.concurrent.TimeUnit;

public final class TimeoutQueueEntry implements Delayed, Channel, IType {
  public final Object channel;
  
  public final long timestamp;
  
  private static Class __cached_class__0;
  
  public static final Var const__6 = (Var)RT.var("clojure.core.async.impl.protocols", "close!");
  
  public TimeoutQueueEntry(Object paramObject, long paramLong) { this.channel = paramObject;
    this.timestamp = paramLong; }
  
  public static IPersistentVector getBasis() { return Tuple.create(Symbol.intern(null, "channel"), ((IObj)Symbol.intern(null, "timestamp")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") }))); }
  
  public Object close_BANG_() { if (Util.classOf(this.channel) != __cached_class__0)
      if (!(this.channel instanceof Channel)) {
        __cached_class__0 = Util.classOf(this.channel);
      } else {
        return ((Channel)this.channel).close_BANG_();
      }  
    this = null; }
  
  public int compareTo(Object other) {
    other = null;
    long ostamp = ((TimeoutQueueEntry)other).timestamp;
    return RT.intCast((this.timestamp < ostamp) ? -1L : ((this.timestamp == ostamp) ? 0L : 1L));
  }
  
  public long getDelay(TimeUnit time_unit) {
    time_unit = null;
    this = null;
    return ((TimeUnit)time_unit).convert(Numbers.minus(this.timestamp, System.currentTimeMillis()), (TimeUnit)TimeUnit.MILLISECONDS);
  }
}
