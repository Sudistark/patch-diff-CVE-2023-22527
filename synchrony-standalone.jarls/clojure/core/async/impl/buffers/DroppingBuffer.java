package clojure.core.async.impl.buffers;

import clojure.core.async.impl.protocols.Buffer;
import clojure.core.async.impl.protocols.UnblockingBuffer;
import clojure.lang.Counted;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import java.util.LinkedList;

public final class DroppingBuffer implements UnblockingBuffer, Buffer, Counted, IType {
  public final Object buf;
  
  public final long n;
  
  public DroppingBuffer(Object paramObject, long paramLong) { this.buf = paramObject;
    this.n = paramLong; }
  
  public static IPersistentVector getBasis() { return Tuple.create(((IObj)Symbol.intern(null, "buf")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "LinkedList") })), ((IObj)Symbol.intern(null, "n")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") }))); }
  
  public int count() { this = null;
    return ((LinkedList)this.buf).size(); }
  
  public Object close_buf_BANG_() { return null; }
  
  public Object add_BANG__STAR_(Object itm) {
    if (((LinkedList)this.buf).size() >= this.n) {
      null;
    } else {
      itm = null;
      ((LinkedList)this.buf).addFirst(itm);
      null;
    } 
    return this;
  }
  
  public Object remove_BANG_() { return ((LinkedList)this.buf).removeLast(); }
  
  public Object full_QMARK_() { return Boolean.FALSE; }
  
  static  {
  
  }
}
