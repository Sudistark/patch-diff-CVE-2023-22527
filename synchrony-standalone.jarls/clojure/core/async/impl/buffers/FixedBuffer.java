package clojure.core.async.impl.buffers;

import clojure.core.async.impl.protocols.Buffer;
import clojure.lang.Counted;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.Numbers;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import java.util.LinkedList;

public final class FixedBuffer implements Buffer, Counted, IType {
  public final Object buf;
  
  public final long n;
  
  public FixedBuffer(Object paramObject, long paramLong) { this.buf = paramObject;
    this.n = paramLong; }
  
  public static IPersistentVector getBasis() { return Tuple.create(((IObj)Symbol.intern(null, "buf")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "LinkedList") })), ((IObj)Symbol.intern(null, "n")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") }))); }
  
  public int count() { this = null;
    return ((LinkedList)this.buf).size(); }
  
  public Object close_buf_BANG_() { return null; }
  
  public Object add_BANG__STAR_(Object itm) {
    itm = null;
    ((LinkedList)this.buf).addFirst(itm);
    null;
    return this;
  }
  
  public Object remove_BANG_() { return ((LinkedList)this.buf).removeLast(); }
  
  public Object full_QMARK_() { this = null;
    return Numbers.gte(((LinkedList)this.buf).size(), this.n) ? Boolean.TRUE : Boolean.FALSE; }
  
  static  {
  
  }
}
