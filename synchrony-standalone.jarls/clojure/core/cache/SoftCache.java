package clojure.core.cache;

import clojure.lang.Associative;
import clojure.lang.Counted;
import clojure.lang.IFn;
import clojure.lang.ILookup;
import clojure.lang.IMapEntry;
import clojure.lang.IObj;
import clojure.lang.IPersistentCollection;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.ISeq;
import clojure.lang.IType;
import clojure.lang.Keyword;
import clojure.lang.RT;
import clojure.lang.Seqable;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Util;
import clojure.lang.Var;
import java.util.Iterator;
import java.util.Map;

public final class SoftCache implements Associative, CacheProtocol, ILookup, IPersistentCollection, Counted, IPersistentMap, Seqable, Iterable, IType {
  public final Object cache;
  
  public final Object rcache;
  
  public final Object rq;
  
  private static Class __cached_class__0;
  
  private static Class __cached_class__1;
  
  private static Class __cached_class__2;
  
  private static Class __cached_class__3;
  
  private static Class __cached_class__4;
  
  private static Class __cached_class__5;
  
  private static Class __cached_class__6;
  
  private static Class __cached_class__7;
  
  private static Class __cached_class__8;
  
  private static Class __cached_class__9;
  
  public static final Var const__0 = (Var)RT.var("clojure.core.cache", "has?");
  
  public static final Var const__1 = (Var)RT.var("clojure.core.cache", "lookup");
  
  public static final Var const__2 = (Var)RT.var("clojure.core", "str");
  
  public static final Var const__3 = (Var)RT.var("clojure.core.cache", "seed");
  
  public static final Var const__4 = (Var)RT.var("clojure.core", "conj");
  
  public static final Var const__5 = (Var)RT.var("clojure.core", "empty");
  
  public static final Keyword const__8 = (Keyword)RT.keyword("clojure.core.cache", "nil");
  
  public static final Var const__10 = (Var)RT.var("clojure.core", "not"), const__12 = (Var)RT.var("clojure.core.cache", "clear-soft-cache!"), const__13 = (Var)RT.var("clojure.core.cache", "make-reference"), const__16 = (Var)RT.var("clojure.core", "seq"), const__22 = (Var)RT.var("clojure.core", "chunked-seq?"), const__23 = (Var)RT.var("clojure.core", "chunk-first"), const__24 = (Var)RT.var("clojure.core", "chunk-rest"), const__27 = (Var)RT.var("clojure.core", "first"), const__28 = (Var)RT.var("clojure.core", "next"), const__29 = (Var)RT.var("clojure.core.cache", "miss"), const__30 = (Var)RT.var("clojure.core.cache", "evict");
  
  public SoftCache(Object paramObject1, Object paramObject2, Object paramObject3) { this.cache = paramObject1;
    this.rcache = paramObject2;
    this.rq = paramObject3; }
  
  public static IPersistentVector getBasis() { return Tuple.create(((IObj)Symbol.intern(null, "cache")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.Map") })), ((IObj)Symbol.intern(null, "rcache")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.Map") })), Symbol.intern(null, "rq")); }
  
  public Iterator iterator() { return (Iterator)((Iterable)this.cache).iterator(); }
  
  public ISeq seq() { this = null;
    return (ISeq)((IFn)const__16.getRawRoot()).invoke(this.cache); }
  
  public IPersistentMap without(Object k__1491__auto__) { if (Util.classOf(this) != __cached_class__9)
      if (!(this instanceof CacheProtocol)) {
        __cached_class__9 = Util.classOf(this);
      } else {
        k__1491__auto__ = null;
        return (IPersistentMap)((CacheProtocol)this).evict(k__1491__auto__);
      }  
    k__1491__auto__ = null;
    this = null; }
  
  public IPersistentMap assoc(Object k__1491__auto__, Object v__1492__auto__) { if (Util.classOf(this) != __cached_class__8)
      if (!(this instanceof CacheProtocol)) {
        __cached_class__8 = Util.classOf(this);
      } else {
        k__1491__auto__ = null;
        v__1492__auto__ = null;
        return (IPersistentMap)((CacheProtocol)this).miss(k__1491__auto__, v__1492__auto__);
      }  
    k__1491__auto__ = null;
    v__1492__auto__ = null;
    this = null; }
  
  public int count() { return RT.count(this.cache); }
  
  public Object seed(Object base) { // Byte code:
    //   0: aload_1
    //   1: instanceof clojure/core/cache/SoftCache
    //   4: istore_2
    //   5: new java/util/concurrent/ConcurrentHashMap
    //   8: dup
    //   9: invokespecial <init> : ()V
    //   12: astore_3
    //   13: new java/util/concurrent/ConcurrentHashMap
    //   16: dup
    //   17: invokespecial <init> : ()V
    //   20: astore #4
    //   22: new java/lang/ref/ReferenceQueue
    //   25: dup
    //   26: invokespecial <init> : ()V
    //   29: astore #5
    //   31: getstatic clojure/core/cache/SoftCache.const__16 : Lclojure/lang/Var;
    //   34: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   37: checkcast clojure/lang/IFn
    //   40: aload_1
    //   41: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   46: dup
    //   47: ifnull -> 635
    //   50: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   53: if_acmpeq -> 636
    //   56: getstatic clojure/core/cache/SoftCache.const__16 : Lclojure/lang/Var;
    //   59: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   62: checkcast clojure/lang/IFn
    //   65: aload_1
    //   66: aconst_null
    //   67: astore_1
    //   68: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   73: astore #6
    //   75: aconst_null
    //   76: astore #7
    //   78: lconst_0
    //   79: lstore #8
    //   81: lconst_0
    //   82: lstore #10
    //   84: lload #10
    //   86: lload #8
    //   88: lcmp
    //   89: ifge -> 289
    //   92: aload #7
    //   94: checkcast clojure/lang/Indexed
    //   97: lload #10
    //   99: invokestatic intCast : (J)I
    //   102: invokeinterface nth : (I)Ljava/lang/Object;
    //   107: astore #12
    //   109: aload #12
    //   111: lconst_0
    //   112: invokestatic intCast : (J)I
    //   115: aconst_null
    //   116: invokestatic nth : (Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;
    //   119: astore #13
    //   121: aload #12
    //   123: aconst_null
    //   124: astore #12
    //   126: lconst_1
    //   127: invokestatic intCast : (J)I
    //   130: aconst_null
    //   131: invokestatic nth : (Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;
    //   134: astore #14
    //   136: aload #13
    //   138: aconst_null
    //   139: astore #13
    //   141: astore #15
    //   143: aload #15
    //   145: dup
    //   146: ifnull -> 163
    //   149: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   152: if_acmpeq -> 164
    //   155: aload #15
    //   157: aconst_null
    //   158: astore #15
    //   160: goto -> 167
    //   163: pop
    //   164: getstatic clojure/core/cache/SoftCache.const__8 : Lclojure/lang/Keyword;
    //   167: astore #15
    //   169: iload_2
    //   170: ifeq -> 204
    //   173: getstatic clojure/core/cache/SoftCache.const__13 : Lclojure/lang/Var;
    //   176: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   179: checkcast clojure/lang/IFn
    //   182: aload #14
    //   184: aconst_null
    //   185: astore #14
    //   187: checkcast java/lang/ref/SoftReference
    //   190: invokevirtual get : ()Ljava/lang/Object;
    //   193: aload #5
    //   195: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   200: goto -> 225
    //   203: athrow
    //   204: getstatic clojure/core/cache/SoftCache.const__13 : Lclojure/lang/Var;
    //   207: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   210: checkcast clojure/lang/IFn
    //   213: aload #14
    //   215: aconst_null
    //   216: astore #14
    //   218: aload #5
    //   220: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   225: astore #16
    //   227: aload_3
    //   228: checkcast java/util/concurrent/ConcurrentHashMap
    //   231: aload #15
    //   233: aload #16
    //   235: invokevirtual put : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   238: pop
    //   239: aload #4
    //   241: checkcast java/util/concurrent/ConcurrentHashMap
    //   244: aload #16
    //   246: aconst_null
    //   247: astore #16
    //   249: aload #15
    //   251: aconst_null
    //   252: astore #15
    //   254: invokevirtual put : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   257: pop
    //   258: aload #6
    //   260: aconst_null
    //   261: astore #6
    //   263: aload #7
    //   265: aconst_null
    //   266: astore #7
    //   268: lload #8
    //   270: lload #10
    //   272: lconst_1
    //   273: ladd
    //   274: lstore #10
    //   276: lstore #8
    //   278: astore #7
    //   280: astore #6
    //   282: goto -> 84
    //   285: nop
    //   286: nop
    //   287: athrow
    //   288: athrow
    //   289: getstatic clojure/core/cache/SoftCache.const__16 : Lclojure/lang/Var;
    //   292: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   295: checkcast clojure/lang/IFn
    //   298: aload #6
    //   300: aconst_null
    //   301: astore #6
    //   303: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   308: astore #12
    //   310: aload #12
    //   312: dup
    //   313: ifnull -> 629
    //   316: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   319: if_acmpeq -> 630
    //   322: aload #12
    //   324: aconst_null
    //   325: astore #12
    //   327: astore #13
    //   329: getstatic clojure/core/cache/SoftCache.const__22 : Lclojure/lang/Var;
    //   332: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   335: checkcast clojure/lang/IFn
    //   338: aload #13
    //   340: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   345: dup
    //   346: ifnull -> 425
    //   349: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   352: if_acmpeq -> 426
    //   355: getstatic clojure/core/cache/SoftCache.const__23 : Lclojure/lang/Var;
    //   358: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   361: checkcast clojure/lang/IFn
    //   364: aload #13
    //   366: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   371: astore #14
    //   373: getstatic clojure/core/cache/SoftCache.const__24 : Lclojure/lang/Var;
    //   376: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   379: checkcast clojure/lang/IFn
    //   382: aload #13
    //   384: aconst_null
    //   385: astore #13
    //   387: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   392: aload #14
    //   394: aload #14
    //   396: aconst_null
    //   397: astore #14
    //   399: invokestatic count : (Ljava/lang/Object;)I
    //   402: invokestatic intCast : (I)I
    //   405: i2l
    //   406: lconst_0
    //   407: invokestatic intCast : (J)I
    //   410: i2l
    //   411: lstore #10
    //   413: lstore #8
    //   415: astore #7
    //   417: astore #6
    //   419: goto -> 84
    //   422: nop
    //   423: nop
    //   424: athrow
    //   425: pop
    //   426: getstatic clojure/core/cache/SoftCache.const__27 : Lclojure/lang/Var;
    //   429: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   432: checkcast clojure/lang/IFn
    //   435: aload #13
    //   437: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   442: astore #14
    //   444: aload #14
    //   446: lconst_0
    //   447: invokestatic intCast : (J)I
    //   450: aconst_null
    //   451: invokestatic nth : (Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;
    //   454: astore #15
    //   456: aload #14
    //   458: aconst_null
    //   459: astore #14
    //   461: lconst_1
    //   462: invokestatic intCast : (J)I
    //   465: aconst_null
    //   466: invokestatic nth : (Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;
    //   469: astore #16
    //   471: aload #15
    //   473: aconst_null
    //   474: astore #15
    //   476: astore #17
    //   478: aload #17
    //   480: dup
    //   481: ifnull -> 498
    //   484: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   487: if_acmpeq -> 499
    //   490: aload #17
    //   492: aconst_null
    //   493: astore #17
    //   495: goto -> 502
    //   498: pop
    //   499: getstatic clojure/core/cache/SoftCache.const__8 : Lclojure/lang/Keyword;
    //   502: astore #17
    //   504: iload_2
    //   505: ifeq -> 539
    //   508: getstatic clojure/core/cache/SoftCache.const__13 : Lclojure/lang/Var;
    //   511: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   514: checkcast clojure/lang/IFn
    //   517: aload #16
    //   519: aconst_null
    //   520: astore #16
    //   522: checkcast java/lang/ref/SoftReference
    //   525: invokevirtual get : ()Ljava/lang/Object;
    //   528: aload #5
    //   530: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   535: goto -> 560
    //   538: athrow
    //   539: getstatic clojure/core/cache/SoftCache.const__13 : Lclojure/lang/Var;
    //   542: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   545: checkcast clojure/lang/IFn
    //   548: aload #16
    //   550: aconst_null
    //   551: astore #16
    //   553: aload #5
    //   555: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   560: astore #18
    //   562: aload_3
    //   563: checkcast java/util/concurrent/ConcurrentHashMap
    //   566: aload #17
    //   568: aload #18
    //   570: invokevirtual put : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   573: pop
    //   574: aload #4
    //   576: checkcast java/util/concurrent/ConcurrentHashMap
    //   579: aload #18
    //   581: aconst_null
    //   582: astore #18
    //   584: aload #17
    //   586: aconst_null
    //   587: astore #17
    //   589: invokevirtual put : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   592: pop
    //   593: getstatic clojure/core/cache/SoftCache.const__28 : Lclojure/lang/Var;
    //   596: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   599: checkcast clojure/lang/IFn
    //   602: aload #13
    //   604: aconst_null
    //   605: astore #13
    //   607: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   612: aconst_null
    //   613: lconst_0
    //   614: lconst_0
    //   615: lstore #10
    //   617: lstore #8
    //   619: astore #7
    //   621: astore #6
    //   623: goto -> 84
    //   626: nop
    //   627: nop
    //   628: athrow
    //   629: pop
    //   630: aconst_null
    //   631: pop
    //   632: goto -> 638
    //   635: pop
    //   636: aconst_null
    //   637: pop
    //   638: new clojure/core/cache/SoftCache
    //   641: dup
    //   642: aload_3
    //   643: aconst_null
    //   644: astore_3
    //   645: aload #4
    //   647: aconst_null
    //   648: astore #4
    //   650: aload #5
    //   652: aconst_null
    //   653: astore #5
    //   655: invokespecial <init> : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V
    //   658: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #522	-> 0
    //   #567	-> 31
    //   #567	-> 37
    //   #567	-> 41
    //   #568	-> 62
    //   #568	-> 68
    //   #568	-> 84
    //   #568	-> 84
    //   #568	-> 102
    //   #568	-> 116
    //   #568	-> 131
    //   #569	-> 143
    //   #570	-> 169
    //   #571	-> 179
    //   #571	-> 190
    //   #571	-> 195
    //   #572	-> 210
    //   #572	-> 220
    //   #573	-> 235
    //   #574	-> 254
    //   #568	-> 272
    //   #568	-> 295
    //   #568	-> 303
    //   #568	-> 310
    //   #568	-> 329
    //   #568	-> 335
    //   #568	-> 340
    //   #568	-> 361
    //   #568	-> 366
    //   #568	-> 379
    //   #568	-> 387
    //   #568	-> 399
    //   #568	-> 402
    //   #568	-> 407
    //   #568	-> 432
    //   #568	-> 437
    //   #568	-> 451
    //   #568	-> 466
    //   #569	-> 478
    //   #570	-> 504
    //   #571	-> 514
    //   #571	-> 525
    //   #571	-> 530
    //   #572	-> 545
    //   #572	-> 555
    //   #573	-> 570
    //   #574	-> 589
    //   #568	-> 599
    //   #568	-> 607
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   143	24	15	or__5516__auto__1677	Ljava/lang/Object;
    //   169	89	15	k	Ljava/lang/Object;
    //   227	31	16	r	Ljava/lang/Object;
    //   109	176	12	vec__1670	Ljava/lang/Object;
    //   121	164	13	k	Ljava/lang/Object;
    //   136	149	14	v	Ljava/lang/Object;
    //   373	49	14	c__5998__auto__1678	Ljava/lang/Object;
    //   478	24	17	or__5516__auto__1679	Ljava/lang/Object;
    //   504	89	17	k	Ljava/lang/Object;
    //   562	31	18	r	Ljava/lang/Object;
    //   444	182	14	vec__1673	Ljava/lang/Object;
    //   456	170	15	k	Ljava/lang/Object;
    //   471	155	16	v	Ljava/lang/Object;
    //   329	297	13	seq_1666	Ljava/lang/Object;
    //   310	322	12	temp__5735__auto__1680	Ljava/lang/Object;
    //   75	557	6	seq_1666	Ljava/lang/Object;
    //   78	554	7	chunk_1667	Ljava/lang/Object;
    //   81	551	8	count_1668	J
    //   84	548	10	i_1669	J
    //   5	653	2	soft_cache_QMARK_	Z
    //   13	645	3	cache	Ljava/lang/Object;
    //   22	636	4	rcache	Ljava/lang/Object;
    //   31	627	5	rq	Ljava/lang/Object;
    //   0	658	0	this	Lclojure/core/cache/SoftCache;
    //   0	658	1	base	Ljava/lang/Object; }
  
  public Object evict(Object key) { // Byte code:
    //   0: aload_1
    //   1: aconst_null
    //   2: astore_1
    //   3: astore_2
    //   4: aload_2
    //   5: dup
    //   6: ifnull -> 21
    //   9: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   12: if_acmpeq -> 22
    //   15: aload_2
    //   16: aconst_null
    //   17: astore_2
    //   18: goto -> 25
    //   21: pop
    //   22: getstatic clojure/core/cache/SoftCache.const__8 : Lclojure/lang/Keyword;
    //   25: astore_2
    //   26: aload_0
    //   27: getfield cache : Ljava/lang/Object;
    //   30: aload_2
    //   31: invokestatic get : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   34: astore_3
    //   35: aload_3
    //   36: dup
    //   37: ifnull -> 81
    //   40: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   43: if_acmpeq -> 82
    //   46: aload_0
    //   47: getfield cache : Ljava/lang/Object;
    //   50: checkcast java/util/Map
    //   53: aload_2
    //   54: aconst_null
    //   55: astore_2
    //   56: invokeinterface remove : (Ljava/lang/Object;)Ljava/lang/Object;
    //   61: pop
    //   62: aload_0
    //   63: getfield rcache : Ljava/lang/Object;
    //   66: checkcast java/util/Map
    //   69: aload_3
    //   70: aconst_null
    //   71: astore_3
    //   72: invokeinterface remove : (Ljava/lang/Object;)Ljava/lang/Object;
    //   77: pop
    //   78: goto -> 84
    //   81: pop
    //   82: aconst_null
    //   83: pop
    //   84: getstatic clojure/core/cache/SoftCache.const__12 : Lclojure/lang/Var;
    //   87: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   90: checkcast clojure/lang/IFn
    //   93: aload_0
    //   94: getfield cache : Ljava/lang/Object;
    //   97: aload_0
    //   98: getfield rcache : Ljava/lang/Object;
    //   101: aload_0
    //   102: getfield rq : Ljava/lang/Object;
    //   105: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   110: pop
    //   111: aload_0
    //   112: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #522	-> 0
    //   #555	-> 4
    //   #556	-> 31
    //   #557	-> 35
    //   #558	-> 56
    //   #559	-> 72
    //   #560	-> 90
    //   #560	-> 105
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   4	21	2	or__5516__auto__1681	Ljava/lang/Object;
    //   26	86	2	key	Ljava/lang/Object;
    //   35	77	3	r	Ljava/lang/Object;
    //   0	112	0	this	Lclojure/core/cache/SoftCache;
    //   0	112	1	key	Ljava/lang/Object; }
  
  public Object miss(Object item, Object result) {
    Object or__5516__auto__1682 = item = null;
    if (or__5516__auto__1682 != null) {
      if (or__5516__auto__1682 != Boolean.FALSE)
        or__5516__auto__1682 = null; 
    } else {
      or__5516__auto__1682;
    } 
    Object item = const__8;
    result = null;
    Object r = ((IFn)const__13.getRawRoot()).invoke(result, this.rq);
    ((Map)this.cache)
      .put(item, r);
    r = null;
    item = null;
    ((Map)this.rcache)
      .put(r, item);
    ((IFn)const__12.getRawRoot())
      .invoke(this.cache, this.rcache, this.rq);
    return this;
  }
  
  public Object hit(Object item) { ((IFn)const__12.getRawRoot()).invoke(this.cache, this.rcache, this.rq);
    return this; }
  
  public Object has_QMARK_(Object item) { // Byte code:
    //   0: aload_1
    //   1: aconst_null
    //   2: astore_1
    //   3: astore_2
    //   4: aload_2
    //   5: dup
    //   6: ifnull -> 21
    //   9: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   12: if_acmpeq -> 22
    //   15: aload_2
    //   16: aconst_null
    //   17: astore_2
    //   18: goto -> 25
    //   21: pop
    //   22: getstatic clojure/core/cache/SoftCache.const__8 : Lclojure/lang/Keyword;
    //   25: astore_2
    //   26: aload_0
    //   27: getfield cache : Ljava/lang/Object;
    //   30: aload_2
    //   31: aconst_null
    //   32: astore_2
    //   33: invokestatic get : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   36: astore_3
    //   37: aload_3
    //   38: dup
    //   39: ifnull -> 90
    //   42: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   45: if_acmpeq -> 91
    //   48: getstatic clojure/core/cache/SoftCache.const__10 : Lclojure/lang/Var;
    //   51: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   54: checkcast clojure/lang/IFn
    //   57: aload_3
    //   58: aconst_null
    //   59: astore_3
    //   60: checkcast java/lang/ref/SoftReference
    //   63: invokevirtual get : ()Ljava/lang/Object;
    //   66: aconst_null
    //   67: invokestatic identical : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   70: ifeq -> 79
    //   73: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   76: goto -> 82
    //   79: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   82: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   87: goto -> 92
    //   90: pop
    //   91: aconst_null
    //   92: aconst_null
    //   93: astore_0
    //   94: invokestatic booleanCast : (Ljava/lang/Object;)Z
    //   97: ifeq -> 106
    //   100: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   103: goto -> 109
    //   106: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   109: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #522	-> 0
    //   #539	-> 4
    //   #540	-> 33
    //   #542	-> 37
    //   #543	-> 54
    //   #543	-> 63
    //   #543	-> 67
    //   #543	-> 82
    //   #541	-> 92
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   4	21	2	or__5516__auto__1683	Ljava/lang/Object;
    //   26	83	2	item	Ljava/lang/Object;
    //   37	72	3	cell	Ljava/lang/Object;
    //   0	109	0	this	Lclojure/core/cache/SoftCache;
    //   0	109	1	item	Ljava/lang/Object; }
  
  public Object lookup(Object item, Object not_found) { // Byte code:
    //   0: aload_0
    //   1: getfield cache : Ljava/lang/Object;
    //   4: aload_1
    //   5: aconst_null
    //   6: astore_1
    //   7: astore_3
    //   8: aload_3
    //   9: dup
    //   10: ifnull -> 25
    //   13: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   16: if_acmpeq -> 26
    //   19: aload_3
    //   20: aconst_null
    //   21: astore_3
    //   22: goto -> 29
    //   25: pop
    //   26: getstatic clojure/core/cache/SoftCache.const__8 : Lclojure/lang/Keyword;
    //   29: invokestatic get : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   32: astore_3
    //   33: aload_3
    //   34: dup
    //   35: ifnull -> 112
    //   38: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   41: if_acmpeq -> 113
    //   44: aload_3
    //   45: aconst_null
    //   46: astore_3
    //   47: astore #4
    //   49: aload #4
    //   51: aconst_null
    //   52: astore #4
    //   54: checkcast java/lang/ref/SoftReference
    //   57: invokevirtual get : ()Ljava/lang/Object;
    //   60: astore #5
    //   62: aload #5
    //   64: dup
    //   65: ifnull -> 105
    //   68: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   71: if_acmpeq -> 106
    //   74: aload #5
    //   76: aconst_null
    //   77: astore #5
    //   79: astore #6
    //   81: getstatic clojure/core/cache/SoftCache.const__8 : Lclojure/lang/Keyword;
    //   84: aload #6
    //   86: invokestatic equiv : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   89: ifeq -> 97
    //   92: aconst_null
    //   93: goto -> 102
    //   96: athrow
    //   97: aload #6
    //   99: aconst_null
    //   100: astore #6
    //   102: goto -> 109
    //   105: pop
    //   106: aload_2
    //   107: aconst_null
    //   108: astore_2
    //   109: goto -> 116
    //   112: pop
    //   113: aload_2
    //   114: aconst_null
    //   115: astore_2
    //   116: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #522	-> 0
    //   #531	-> 8
    //   #531	-> 29
    //   #531	-> 33
    //   #532	-> 57
    //   #532	-> 62
    //   #533	-> 81
    //   #533	-> 86
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   8	21	3	or__5516__auto__1684	Ljava/lang/Object;
    //   81	21	6	v	Ljava/lang/Object;
    //   62	47	5	temp__5733__auto__1685	Ljava/lang/Object;
    //   49	60	4	r	Ljava/lang/Object;
    //   33	83	3	temp__5733__auto__1686	Ljava/lang/Object;
    //   0	116	0	this	Lclojure/core/cache/SoftCache;
    //   0	116	1	item	Ljava/lang/Object;
    //   0	116	2	not_found	Ljava/lang/Object; }
  
  public Object lookup(Object item) { // Byte code:
    //   0: aload_0
    //   1: getfield cache : Ljava/lang/Object;
    //   4: aload_1
    //   5: aconst_null
    //   6: astore_1
    //   7: astore_2
    //   8: aload_2
    //   9: dup
    //   10: ifnull -> 25
    //   13: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   16: if_acmpeq -> 26
    //   19: aload_2
    //   20: aconst_null
    //   21: astore_2
    //   22: goto -> 29
    //   25: pop
    //   26: getstatic clojure/core/cache/SoftCache.const__8 : Lclojure/lang/Keyword;
    //   29: invokestatic get : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   32: astore_2
    //   33: aload_2
    //   34: dup
    //   35: ifnull -> 83
    //   38: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   41: if_acmpeq -> 84
    //   44: aload_2
    //   45: aconst_null
    //   46: astore_2
    //   47: astore_3
    //   48: aload_3
    //   49: aconst_null
    //   50: astore_3
    //   51: checkcast java/lang/ref/SoftReference
    //   54: invokevirtual get : ()Ljava/lang/Object;
    //   57: astore #4
    //   59: getstatic clojure/core/cache/SoftCache.const__8 : Lclojure/lang/Keyword;
    //   62: aload #4
    //   64: invokestatic equiv : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   67: ifeq -> 75
    //   70: aconst_null
    //   71: goto -> 80
    //   74: athrow
    //   75: aload #4
    //   77: aconst_null
    //   78: astore #4
    //   80: goto -> 85
    //   83: pop
    //   84: aconst_null
    //   85: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #522	-> 0
    //   #525	-> 8
    //   #525	-> 29
    //   #525	-> 33
    //   #526	-> 54
    //   #527	-> 59
    //   #527	-> 64
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   8	21	2	or__5516__auto__1687	Ljava/lang/Object;
    //   59	21	4	v	Ljava/lang/Object;
    //   48	32	3	r	Ljava/lang/Object;
    //   33	52	2	temp__5735__auto__1688	Ljava/lang/Object;
    //   0	85	0	this	Lclojure/core/cache/SoftCache;
    //   0	85	1	item	Ljava/lang/Object; }
  
  public boolean equiv(Object other__1494__auto__) { other__1494__auto__ = null;
    return Util.equiv(other__1494__auto__, this.cache); }
  
  public IPersistentCollection empty() { if (Util.classOf(this) != __cached_class__7)
      if (!(this instanceof CacheProtocol)) {
        __cached_class__7 = Util.classOf(this);
      } else {
        return (IPersistentCollection)((CacheProtocol)this).seed(((IFn)const__5.getRawRoot()).invoke(this.cache));
      }  
    this = null; }
  
  public IPersistentCollection cons(Object elem__1493__auto__) { if (Util.classOf(this) != __cached_class__6)
      if (!(this instanceof CacheProtocol)) {
        __cached_class__6 = Util.classOf(this);
      } else {
        elem__1493__auto__ = null;
        return (IPersistentCollection)((CacheProtocol)this).seed(((IFn)const__4.getRawRoot()).invoke(this.cache, elem__1493__auto__));
      }  
    elem__1493__auto__ = null;
    this = null; }
  
  public Object valAt(Object key__1488__auto__, Object not_found__1489__auto__) { // Byte code:
    //   0: aload_0
    //   1: dup
    //   2: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   5: getstatic clojure/core/cache/SoftCache.__cached_class__4 : Ljava/lang/Class;
    //   8: if_acmpeq -> 25
    //   11: dup
    //   12: instanceof clojure/core/cache/CacheProtocol
    //   15: ifne -> 41
    //   18: dup
    //   19: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   22: putstatic clojure/core/cache/SoftCache.__cached_class__4 : Ljava/lang/Class;
    //   25: getstatic clojure/core/cache/SoftCache.const__0 : Lclojure/lang/Var;
    //   28: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   31: swap
    //   32: aload_1
    //   33: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   38: goto -> 50
    //   41: checkcast clojure/core/cache/CacheProtocol
    //   44: aload_1
    //   45: invokeinterface has_QMARK_ : (Ljava/lang/Object;)Ljava/lang/Object;
    //   50: dup
    //   51: ifnull -> 119
    //   54: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   57: if_acmpeq -> 120
    //   60: aload_0
    //   61: dup
    //   62: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   65: getstatic clojure/core/cache/SoftCache.__cached_class__5 : Ljava/lang/Class;
    //   68: if_acmpeq -> 85
    //   71: dup
    //   72: instanceof clojure/core/cache/CacheProtocol
    //   75: ifne -> 105
    //   78: dup
    //   79: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   82: putstatic clojure/core/cache/SoftCache.__cached_class__5 : Ljava/lang/Class;
    //   85: getstatic clojure/core/cache/SoftCache.const__1 : Lclojure/lang/Var;
    //   88: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   91: swap
    //   92: aload_1
    //   93: aconst_null
    //   94: astore_1
    //   95: aconst_null
    //   96: astore_0
    //   97: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   102: goto -> 116
    //   105: checkcast clojure/core/cache/CacheProtocol
    //   108: aload_1
    //   109: aconst_null
    //   110: astore_1
    //   111: invokeinterface lookup : (Ljava/lang/Object;)Ljava/lang/Object;
    //   116: goto -> 123
    //   119: pop
    //   120: aload_2
    //   121: aconst_null
    //   122: astore_2
    //   123: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #522	-> 0
    //   #522	-> 0
    //   #522	-> 0
    //   #522	-> 33
    //   #522	-> 60
    //   #522	-> 95
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   0	123	0	this	Lclojure/core/cache/SoftCache;
    //   0	123	1	key__1488__auto__	Ljava/lang/Object;
    //   0	123	2	not_found__1489__auto__	Ljava/lang/Object; }
  
  public Object valAt(Object key__1488__auto__) { if (Util.classOf(this) != __cached_class__3)
      if (!(this instanceof CacheProtocol)) {
        __cached_class__3 = Util.classOf(this);
      } else {
        key__1488__auto__ = null;
        return ((CacheProtocol)this).lookup(key__1488__auto__);
      }  
    key__1488__auto__ = null;
    this = null; }
  
  public String toString() { this = null;
    return (String)((IFn)const__2.getRawRoot()).invoke(this.cache); }
  
  public IMapEntry entryAt(Object k__1491__auto__) { // Byte code:
    //   0: aload_0
    //   1: dup
    //   2: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   5: getstatic clojure/core/cache/SoftCache.__cached_class__1 : Ljava/lang/Class;
    //   8: if_acmpeq -> 25
    //   11: dup
    //   12: instanceof clojure/core/cache/CacheProtocol
    //   15: ifne -> 41
    //   18: dup
    //   19: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   22: putstatic clojure/core/cache/SoftCache.__cached_class__1 : Ljava/lang/Class;
    //   25: getstatic clojure/core/cache/SoftCache.const__0 : Lclojure/lang/Var;
    //   28: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   31: swap
    //   32: aload_1
    //   33: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   38: goto -> 50
    //   41: checkcast clojure/core/cache/CacheProtocol
    //   44: aload_1
    //   45: invokeinterface has_QMARK_ : (Ljava/lang/Object;)Ljava/lang/Object;
    //   50: dup
    //   51: ifnull -> 125
    //   54: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   57: if_acmpeq -> 126
    //   60: new clojure/lang/MapEntry
    //   63: dup
    //   64: aload_1
    //   65: aload_0
    //   66: dup
    //   67: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   70: getstatic clojure/core/cache/SoftCache.__cached_class__2 : Ljava/lang/Class;
    //   73: if_acmpeq -> 90
    //   76: dup
    //   77: instanceof clojure/core/cache/CacheProtocol
    //   80: ifne -> 108
    //   83: dup
    //   84: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   87: putstatic clojure/core/cache/SoftCache.__cached_class__2 : Ljava/lang/Class;
    //   90: getstatic clojure/core/cache/SoftCache.const__1 : Lclojure/lang/Var;
    //   93: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   96: swap
    //   97: aload_1
    //   98: aconst_null
    //   99: astore_1
    //   100: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   105: goto -> 119
    //   108: checkcast clojure/core/cache/CacheProtocol
    //   111: aload_1
    //   112: aconst_null
    //   113: astore_1
    //   114: invokeinterface lookup : (Ljava/lang/Object;)Ljava/lang/Object;
    //   119: invokespecial <init> : (Ljava/lang/Object;Ljava/lang/Object;)V
    //   122: goto -> 127
    //   125: pop
    //   126: aconst_null
    //   127: checkcast clojure/lang/IMapEntry
    //   130: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #522	-> 0
    //   #522	-> 0
    //   #522	-> 0
    //   #522	-> 33
    //   #522	-> 65
    //   #522	-> 100
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   0	130	0	this	Lclojure/core/cache/SoftCache;
    //   0	130	1	k__1491__auto__	Ljava/lang/Object; }
  
  public boolean containsKey(Object k__1491__auto__) { if (Util.classOf(this) != __cached_class__0)
      if (!(this instanceof CacheProtocol)) {
        __cached_class__0 = Util.classOf(this);
      } else {
        k__1491__auto__ = null;
        return ((Boolean)((CacheProtocol)this).has_QMARK_(k__1491__auto__)).booleanValue();
      }  
    k__1491__auto__ = null;
    this = null; }
}
