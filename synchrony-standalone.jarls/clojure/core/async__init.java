package clojure.core;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class async__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Keyword const__2;
  
  public static final AFn const__3;
  
  public static final AFn const__4;
  
  public static final Var const__5;
  
  public static final AFn const__6;
  
  public static final AFn const__7;
  
  public static final Var const__8;
  
  public static final Var const__9;
  
  public static final AFn const__17;
  
  public static final Var const__18;
  
  public static final AFn const__21;
  
  public static final Var const__22;
  
  public static final AFn const__25;
  
  public static final Var const__26;
  
  public static final AFn const__29;
  
  public static final Var const__30;
  
  public static final AFn const__33;
  
  public static final Var const__34;
  
  public static final AFn const__37;
  
  public static final Var const__38;
  
  public static final AFn const__41;
  
  public static final Var const__42;
  
  public static final AFn const__45;
  
  public static final Var const__46;
  
  public static final AFn const__49;
  
  public static final Var const__50;
  
  public static final AFn const__53;
  
  public static final Var const__54;
  
  public static final AFn const__57;
  
  public static final Var const__58;
  
  public static final AFn const__61;
  
  public static final Var const__62;
  
  public static final AFn const__65;
  
  public static final Var const__66;
  
  public static final AFn const__70;
  
  public static final Var const__71;
  
  public static final AFn const__73;
  
  public static final Var const__74;
  
  public static final AFn const__77;
  
  public static final Var const__78;
  
  public static final AFn const__81;
  
  public static final Var const__82;
  
  public static final AFn const__85;
  
  public static final Var const__86;
  
  public static final AFn const__89;
  
  public static final Var const__90;
  
  public static final AFn const__93;
  
  public static final Var const__94;
  
  public static final AFn const__97;
  
  public static final Var const__98;
  
  public static final AFn const__101;
  
  public static final Var const__102;
  
  public static final AFn const__105;
  
  public static final Var const__106;
  
  public static final AFn const__109;
  
  public static final Var const__110;
  
  public static final AFn const__113;
  
  public static final Var const__114;
  
  public static final AFn const__117;
  
  public static final Var const__118;
  
  public static final AFn const__121;
  
  public static final Var const__122;
  
  public static final AFn const__125;
  
  public static final Var const__126;
  
  public static final AFn const__129;
  
  public static final Var const__130;
  
  public static final AFn const__133;
  
  public static final Var const__134;
  
  public static final AFn const__137;
  
  public static final Var const__138;
  
  public static final AFn const__141;
  
  public static final Var const__142;
  
  public static final AFn const__145;
  
  public static final Var const__146;
  
  public static final AFn const__149;
  
  public static final Var const__150;
  
  public static final AFn const__153;
  
  public static final Var const__154;
  
  public static final AFn const__157;
  
  public static final Var const__158;
  
  public static final AFn const__161;
  
  public static final Var const__162;
  
  public static final AFn const__165;
  
  public static final Var const__166;
  
  public static final AFn const__169;
  
  public static final Var const__170;
  
  public static final AFn const__173;
  
  public static final Var const__174;
  
  public static final AFn const__177;
  
  public static final Var const__178;
  
  public static final AFn const__181;
  
  public static final Var const__182;
  
  public static final AFn const__185;
  
  public static final Var const__186;
  
  public static final AFn const__189;
  
  public static final Object const__190;
  
  public static final Var const__191;
  
  public static final Var const__192;
  
  public static final Var const__193;
  
  public static final Var const__194;
  
  public static final ISeq const__195;
  
  public static final Var const__196;
  
  public static final Var const__197;
  
  public static final AFn const__201;
  
  public static final Keyword const__202;
  
  public static final AFn const__203;
  
  public static final Keyword const__204;
  
  public static final Keyword const__205;
  
  public static final AFn const__207;
  
  public static final Keyword const__208;
  
  public static final Var const__209;
  
  public static final Var const__210;
  
  public static final Var const__211;
  
  public static final AFn const__212;
  
  public static final AFn const__213;
  
  public static final Keyword const__214;
  
  public static final Var const__215;
  
  public static final AFn const__216;
  
  public static final Object const__217;
  
  public static final Var const__218;
  
  public static final ISeq const__219;
  
  public static final AFn const__221;
  
  public static final AFn const__222;
  
  public static final AFn const__226;
  
  public static final AFn const__227;
  
  public static final AFn const__228;
  
  public static final AFn const__229;
  
  public static final AFn const__230;
  
  public static final AFn const__231;
  
  public static final AFn const__232;
  
  public static final AFn const__233;
  
  public static final Var const__234;
  
  public static final AFn const__237;
  
  public static final Var const__238;
  
  public static final AFn const__241;
  
  public static final Var const__242;
  
  public static final AFn const__245;
  
  public static final Var const__246;
  
  public static final AFn const__249;
  
  public static final Object const__250;
  
  public static final Var const__251;
  
  public static final ISeq const__252;
  
  public static final AFn const__254;
  
  public static final AFn const__255;
  
  public static final AFn const__261;
  
  public static final AFn const__262;
  
  public static final AFn const__263;
  
  public static final AFn const__264;
  
  public static final AFn const__265;
  
  public static final AFn const__266;
  
  public static final AFn const__267;
  
  public static final AFn const__268;
  
  public static final AFn const__269;
  
  public static final AFn const__270;
  
  public static final AFn const__271;
  
  public static final AFn const__272;
  
  public static final Var const__273;
  
  public static final AFn const__276;
  
  public static final Var const__277;
  
  public static final AFn const__280;
  
  public static final Var const__281;
  
  public static final AFn const__284;
  
  public static final Var const__285;
  
  public static final AFn const__288;
  
  public static final Var const__289;
  
  public static final AFn const__292;
  
  public static final Var const__293;
  
  public static final AFn const__296;
  
  public static final Object const__297;
  
  public static final Var const__298;
  
  public static final ISeq const__299;
  
  public static final AFn const__301;
  
  public static final AFn const__302;
  
  public static final AFn const__306;
  
  public static final AFn const__307;
  
  public static final AFn const__308;
  
  public static final AFn const__309;
  
  public static final AFn const__310;
  
  public static final AFn const__311;
  
  public static final AFn const__312;
  
  public static final AFn const__313;
  
  public static final Var const__314;
  
  public static final AFn const__317;
  
  public static final Var const__318;
  
  public static final AFn const__321;
  
  public static final Var const__322;
  
  public static final AFn const__325;
  
  public static final Var const__326;
  
  public static final AFn const__329;
  
  public static final Var const__330;
  
  public static final AFn const__333;
  
  public static final Var const__334;
  
  public static final AFn const__337;
  
  public static final Var const__338;
  
  public static final AFn const__341;
  
  public static final Var const__342;
  
  public static final AFn const__345;
  
  public static final Var const__346;
  
  public static final AFn const__350;
  
  public static final Var const__351;
  
  public static final AFn const__354;
  
  public static final Var const__355;
  
  public static final AFn const__358;
  
  public static final Var const__359;
  
  public static final AFn const__362;
  
  public static final Var const__363;
  
  public static final AFn const__366;
  
  public static final Var const__367;
  
  public static final AFn const__370;
  
  public static final Var const__371;
  
  public static final AFn const__374;
  
  public static final Var const__375;
  
  public static final AFn const__378;
  
  public static final Var const__379;
  
  public static final AFn const__382;
  
  public static final Var const__383;
  
  public static final AFn const__386;
  
  public static final Var const__387;
  
  public static final AFn const__390;
  
  public static final Var const__391;
  
  public static final AFn const__394;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new async.fn__5555());
    const__9.setMeta((IPersistentMap)const__17);
    const__9.bindRoot(new async.fn_handler());
    const__18.setMeta((IPersistentMap)const__21);
    const__18.bindRoot(new async.buffer());
    const__22.setMeta((IPersistentMap)const__25);
    const__22.bindRoot(new async.dropping_buffer());
    const__26.setMeta((IPersistentMap)const__29);
    const__26.bindRoot(new async.sliding_buffer());
    const__30.setMeta((IPersistentMap)const__33);
    const__30.bindRoot(new async.unblocking_buffer_QMARK_());
    const__34.setMeta((IPersistentMap)const__37);
    const__34.bindRoot(new async.chan());
    const__38.setMeta((IPersistentMap)const__41);
    const__38.bindRoot(new async.promise_chan());
    const__42.setMeta((IPersistentMap)const__45);
    const__42.bindRoot(new async.timeout());
    const__46.setMeta((IPersistentMap)const__49);
    const__46.bindRoot(new async._LT__BANG__BANG_());
    const__50.setMeta((IPersistentMap)const__53);
    const__50.bindRoot(new async._LT__BANG_());
    const__54.setMeta((IPersistentMap)const__57);
    const__54.bindRoot(new async.take_BANG_());
    const__58.setMeta((IPersistentMap)const__61);
    const__58.bindRoot(new async._GT__BANG__BANG_());
    const__62.setMeta((IPersistentMap)const__65);
    const__62.bindRoot(new async._GT__BANG_());
    const__66.setMeta((IPersistentMap)const__70);
    const__66.bindRoot(new async.nop());
    const__71.setMeta((IPersistentMap)const__73);
    const__71




























































































































      
      .bindRoot(((IFn)const__9.getRawRoot()).invoke(const__66.getRawRoot()));
    const__74.setMeta((IPersistentMap)const__77);
    const__74.bindRoot(new async.put_BANG_());
    const__78.setMeta((IPersistentMap)const__81);
    const__78.bindRoot(new async.close_BANG_());
    const__82.setMeta((IPersistentMap)const__85);
    const__82.bindRoot(new async.random_array());
    const__86.setMeta((IPersistentMap)const__89);
    const__86.bindRoot(new async.alt_flag());
    const__90.setMeta((IPersistentMap)const__93);
    const__90.bindRoot(new async.alt_handler());
    const__94.setMeta((IPersistentMap)const__97);
    const__94.bindRoot(new async.do_alts());
    const__98.setMeta((IPersistentMap)const__101);
    const__98.bindRoot(new async.alts_BANG__BANG_());
    const__102.setMeta((IPersistentMap)const__105);
    const__102.bindRoot(new async.alts_BANG_());
    const__106.setMeta((IPersistentMap)const__109);
    const__106.bindRoot(new async.do_alt());
    const__110.setMeta((IPersistentMap)const__113);
    const__110.bindRoot(new async.alt_BANG__BANG_());
    ((Var)const__110)





















































































































































      
      .setMacro();
    const__114.setMeta((IPersistentMap)const__117);
    const__114.bindRoot(new async.alt_BANG_());
    ((Var)const__114)





      
      .setMacro();
    const__118.setMeta((IPersistentMap)const__121);
    const__118.bindRoot(new async.ioc_alts_BANG_());
    const__122.setMeta((IPersistentMap)const__125);
    const__122.bindRoot(new async.offer_BANG_());
    const__126.setMeta((IPersistentMap)const__129);
    const__126.bindRoot(new async.poll_BANG_());
    const__130.setMeta((IPersistentMap)const__133);
    const__130.bindRoot(new async.go());
    ((Var)const__130)






















































      
      .setMacro();
    const__134.setMeta((IPersistentMap)const__137);
    const__134.bindRoot(new async.thread_call());
    const__138.setMeta((IPersistentMap)const__141);
    const__138.bindRoot(new async.thread());
    ((Var)const__138)



















      
      .setMacro();
    const__142.setMeta((IPersistentMap)const__145);
    const__142.bindRoot(new async.go_loop());
    ((Var)const__142)







      
      .setMacro();
    const__146.setMeta((IPersistentMap)const__149);
    const__146.bindRoot(new async.pipe());
    const__150.setMeta((IPersistentMap)const__153);
    const__150.bindRoot(new async.pipeline_STAR_());
    const__154.setMeta((IPersistentMap)const__157);
    const__154.bindRoot(new async.pipeline());
    const__158.setMeta((IPersistentMap)const__161);
    const__158.bindRoot(new async.pipeline_blocking());
    const__162.setMeta((IPersistentMap)const__165);
    const__162.bindRoot(new async.pipeline_async());
    const__166.setMeta((IPersistentMap)const__169);
    const__166.bindRoot(new async.split());
    const__170.setMeta((IPersistentMap)const__173);
    const__170.bindRoot(new async.reduce());
    const__174.setMeta((IPersistentMap)const__177);
    const__174.bindRoot(new async.transduce());
    const__178.setMeta((IPersistentMap)const__181);
    const__178.bindRoot(new async.bounded_count());
    const__182.setMeta((IPersistentMap)const__185);
    const__182.bindRoot(new async.onto_chan());
    const__186.setMeta((IPersistentMap)const__189);
    const__186.bindRoot(new async.to_chan());
    const__234.setMeta((IPersistentMap)const__237);
    const__234.bindRoot(new async.mult());
    const__238.setMeta((IPersistentMap)const__241);
    const__238.bindRoot(new async.tap());
    const__242.setMeta((IPersistentMap)const__245);
    const__242.bindRoot(new async.untap());
    const__246.setMeta((IPersistentMap)const__249);
    const__246.bindRoot(new async.untap_all());
    const__273.setMeta((IPersistentMap)const__276);
    const__273.bindRoot(new async.mix());
    const__277.setMeta((IPersistentMap)const__280);
    const__277.bindRoot(new async.admix());
    const__281.setMeta((IPersistentMap)const__284);
    const__281.bindRoot(new async.unmix());
    const__285.setMeta((IPersistentMap)const__288);
    const__285.bindRoot(new async.unmix_all());
    const__289.setMeta((IPersistentMap)const__292);
    const__289.bindRoot(new async.toggle());
    const__293.setMeta((IPersistentMap)const__296);
    const__293.bindRoot(new async.solo_mode());
    const__314.setMeta((IPersistentMap)const__317);
    const__314.bindRoot(new async.pub());
    const__318.setMeta((IPersistentMap)const__321);
    const__318.bindRoot(new async.sub());
    const__322.setMeta((IPersistentMap)const__325);
    const__322.bindRoot(new async.unsub());
    const__326.setMeta((IPersistentMap)const__329);
    const__326.bindRoot(new async.unsub_all());
    const__330.setMeta((IPersistentMap)const__333);
    const__330.bindRoot(new async.map());
    const__334.setMeta((IPersistentMap)const__337);
    const__334.bindRoot(new async.merge());
    const__338.setMeta((IPersistentMap)const__341);
    const__338.bindRoot(new async.into());
    const__342.setMeta((IPersistentMap)const__345);
    const__342.bindRoot(new async.take());
    const__346.setMeta((IPersistentMap)const__350);
    const__346.bindRoot(new async.map_LT_());
    const__351.setMeta((IPersistentMap)const__354);
    const__351.bindRoot(new async.map_GT_());
    const__355.setMeta((IPersistentMap)const__358);
    const__355.bindRoot(new async.filter_GT_());
    const__359.setMeta((IPersistentMap)const__362);
    const__359.bindRoot(new async.remove_GT_());
    const__363.setMeta((IPersistentMap)const__366);
    const__363.bindRoot(new async.filter_LT_());
    const__367.setMeta((IPersistentMap)const__370);
    const__367.bindRoot(new async.remove_LT_());
    const__371.setMeta((IPersistentMap)const__374);
    const__371.bindRoot(new async.mapcat_STAR_());
    const__375.setMeta((IPersistentMap)const__378);
    const__375.bindRoot(new async.mapcat_LT_());
    const__379.setMeta((IPersistentMap)const__382);
    const__379.bindRoot(new async.mapcat_GT_());
    const__383.setMeta((IPersistentMap)const__386);
    const__383.bindRoot(new async.unique());
    const__387.setMeta((IPersistentMap)const__390);
    const__387.bindRoot(new async.partition());
    const__391.setMeta((IPersistentMap)const__394);
    const__391.bindRoot(new async.partition_by());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.core.async")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Facilities for async programming and communication.\n\ngo blocks are dispatched over an internal thread pool, which\ndefaults to 8 threads. The size of this pool can be modified using\nthe Java system property `clojure.core.async.pool-size`." }));
    const__2 = (Keyword)RT.keyword(null, "doc");
    const__3 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Facilities for async programming and communication.\n\ngo blocks are dispatched over an internal thread pool, which\ndefaults to 8 threads. The size of this pool can be modified using\nthe Java system property `clojure.core.async.pool-size`." });
    const__4 = (AFn)Symbol.intern(null, "clojure.core");
    const__5 = (Var)RT.var("clojure.core", "alias");
    const__6 = (AFn)Symbol.intern(null, "core");
    const__7 = (AFn)Symbol.intern(null, "clojure.core");
    const__8 = (Var)RT.var("clojure.core", "*warn-on-reflection*");
    const__9 = (Var)RT.var("clojure.core.async", "fn-handler");
    const__17 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "blockable")) })), RT.keyword(null, "line"), Integer.valueOf(34), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__18 = (Var)RT.var("clojure.core.async", "buffer");
    const__21 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Returns a fixed buffer of size n. When full, puts will block/park.", RT.keyword(null, "line"), Integer.valueOf(49), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__22 = (Var)RT.var("clojure.core.async", "dropping-buffer");
    const__25 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Returns a buffer of size n. When full, puts will complete but\n  val will be dropped (no transfer).", RT.keyword(null, "line"), Integer.valueOf(54), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__26 = (Var)RT.var("clojure.core.async", "sliding-buffer");
    const__29 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Returns a buffer of size n. When full, puts will complete, and be\n  buffered, but oldest elements in buffer will be dropped (not\n  transferred).", RT.keyword(null, "line"), Integer.valueOf(60), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__30 = (Var)RT.var("clojure.core.async", "unblocking-buffer?");
    const__33 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "buff")) })), RT.keyword(null, "doc"), "Returns true if a channel created with buff will never block. That is to say,\n   puts into this buffer will never cause the buffer to be full. ", RT.keyword(null, "line"), Integer.valueOf(67), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__34 = (Var)RT.var("clojure.core.async", "chan");
    const__37 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "buf-or-n")), Tuple.create(Symbol.intern(null, "buf-or-n"), Symbol.intern(null, "xform")), Tuple.create(Symbol.intern(null, "buf-or-n"), Symbol.intern(null, "xform"), Symbol.intern(null, "ex-handler")) })), RT.keyword(null, "doc"), "Creates a channel with an optional buffer, an optional transducer\n  (like (map f), (filter p) etc or a composition thereof), and an\n  optional exception-handler.  If buf-or-n is a number, will create\n  and use a fixed buffer of that size. If a transducer is supplied a\n  buffer must be specified. ex-handler must be a fn of one argument -\n  if an exception occurs during transformation it will be called with\n  the Throwable as an argument, and any non-nil return value will be\n  placed in the channel.", RT.keyword(null, "line"), Integer.valueOf(73), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__38 = (Var)RT.var("clojure.core.async", "promise-chan");
    const__41 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "xform")), Tuple.create(Symbol.intern(null, "xform"), Symbol.intern(null, "ex-handler")) })), RT.keyword(null, "doc"), "Creates a promise channel with an optional transducer, and an optional\n  exception-handler. A promise channel can take exactly one value that consumers\n  will receive. Once full, puts complete but val is dropped (no transfer).\n  Consumers will block until either a value is placed in the channel or the\n  channel is closed, then return the value (or nil) forever. See chan for the\n  semantics of xform and ex-handler.", RT.keyword(null, "line"), Integer.valueOf(90), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__42 = (Var)RT.var("clojure.core.async", "timeout");
    const__45 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "msecs")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") }))) })), RT.keyword(null, "doc"), "Returns a channel that will close after msecs", RT.keyword(null, "line"), Integer.valueOf(102), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__46 = (Var)RT.var("clojure.core.async", "<!!");
    const__49 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "port")) })), RT.keyword(null, "doc"), "takes a val from port. Will return nil if closed. Will block\n  if nothing is available.", RT.keyword(null, "line"), Integer.valueOf(107), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__50 = (Var)RT.var("clojure.core.async", "<!");
    const__53 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "port")) })), RT.keyword(null, "doc"), "takes a val from port. Must be called inside a (go ...) block. Will\n  return nil if closed. Will park if nothing is available.", RT.keyword(null, "line"), Integer.valueOf(117), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__54 = (Var)RT.var("clojure.core.async", "take!");
    const__57 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "port"), Symbol.intern(null, "fn1")), Tuple.create(Symbol.intern(null, "port"), Symbol.intern(null, "fn1"), Symbol.intern(null, "on-caller?")) })), RT.keyword(null, "doc"), "Asynchronously takes a val from port, passing to fn1. Will pass nil\n   if closed. If on-caller? (default true) is true, and value is\n   immediately available, will call fn1 on calling thread.\n   Returns nil.", RT.keyword(null, "line"), Integer.valueOf(123), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__58 = (Var)RT.var("clojure.core.async", ">!!");
    const__61 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "port"), Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "puts a val into port. nil values are not allowed. Will block if no\n  buffer space is available. Returns true unless port is already closed.", RT.keyword(null, "line"), Integer.valueOf(138), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__62 = (Var)RT.var("clojure.core.async", ">!");
    const__65 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "port"), Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "puts a val into port. nil values are not allowed. Must be called\n  inside a (go ...) block. Will park if no buffer space is available.\n  Returns true unless port is already closed.", RT.keyword(null, "line"), Integer.valueOf(148), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__66 = (Var)RT.var("clojure.core.async", "nop");
    const__70 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })), RT.keyword(null, "line"), Integer.valueOf(155), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__71 = (Var)RT.var("clojure.core.async", "fhnop");
    const__73 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(156), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__74 = (Var)RT.var("clojure.core.async", "put!");
    const__77 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "port"), Symbol.intern(null, "val")), Tuple.create(Symbol.intern(null, "port"), Symbol.intern(null, "val"), Symbol.intern(null, "fn1")), Tuple.create(Symbol.intern(null, "port"), Symbol.intern(null, "val"), Symbol.intern(null, "fn1"), Symbol.intern(null, "on-caller?")) })), RT.keyword(null, "doc"), "Asynchronously puts a val into port, calling fn1 (if supplied) when\n   complete, passing false iff port is already closed. nil values are\n   not allowed. If on-caller? (default true) is true, and the put is\n   immediately accepted, will call fn1 on calling thread.  Returns\n   true unless port is already closed.", RT.keyword(null, "line"), Integer.valueOf(158), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__78 = (Var)RT.var("clojure.core.async", "close!");
    const__81 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "chan")) })), RT.keyword(null, "doc"), "Closes a channel. The channel will no longer accept any puts (they\n  will be ignored). Data in the channel remains available for taking, until\n  exhausted, after which takes will return nil. If there are any\n  pending takes, they will be dispatched with nil. Closing a closed\n  channel is a no-op. Returns nil.\n\n  Logically closing happens after all puts have been delivered. Therefore, any\n  blocked or parked puts will remain blocked/parked until a taker releases them.", RT.keyword(null, "line"), Integer.valueOf(178), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__82 = (Var)RT.var("clojure.core.async", "random-array");
    const__85 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "line"), Integer.valueOf(193), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__86 = (Var)RT.var("clojure.core.async", "alt-flag");
    const__89 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "line"), Integer.valueOf(206), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__90 = (Var)RT.var("clojure.core.async", "alt-handler");
    const__93 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "flag")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Lock") })), Symbol.intern(null, "cb")) })), RT.keyword(null, "line"), Integer.valueOf(223), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__94 = (Var)RT.var("clojure.core.async", "do-alts");
    const__97 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fret"), Symbol.intern(null, "ports"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "returns derefable [val port] if immediate, nil if enqueued", RT.keyword(null, "line"), Integer.valueOf(237), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__98 = (Var)RT.var("clojure.core.async", "alts!!");
  }
  
  public static void __init1() {
    const__101 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ports"), Symbol.intern(null, "&"), RT.map(new Object[] { RT.keyword(null, "as"), Symbol.intern(null, "opts") })) })), RT.keyword(null, "doc"), "Like alts!, except takes will be made as if by <!!, and puts will\n  be made as if by >!!, will block until completed, and not intended\n  for use in (go ...) blocks.", RT.keyword(null, "line"), Integer.valueOf(267), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__102 = (Var)RT.var("clojure.core.async", "alts!");
    const__105 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ports"), Symbol.intern(null, "&"), RT.map(new Object[] { RT.keyword(null, "as"), Symbol.intern(null, "opts") })) })), RT.keyword(null, "doc"), "Completes at most one of several channel operations. Must be called\n  inside a (go ...) block. ports is a vector of channel endpoints,\n  which can be either a channel to take from or a vector of\n  [channel-to-put-to val-to-put], in any combination. Takes will be\n  made as if by <!, and puts will be made as if by >!. Unless\n  the :priority option is true, if more than one port operation is\n  ready a non-deterministic choice will be made. If no operation is\n  ready and a :default value is supplied, [default-val :default] will\n  be returned, otherwise alts! will park until the first operation to\n  become ready completes. Returns [val port] of the completed\n  operation, where val is the value taken for takes, and a\n  boolean (true unless already closed, as per put!) for puts.\n\n  opts are passed as :key val ... Supported options:\n\n  :default val - the value to use if none of the operations are immediately ready\n  :priority true - (default nil) when true, the operations will be tried in order.\n\n  Note: there is no guarantee that the port exps or val exprs will be\n  used, nor in what order should they be, so they should not be\n  depended upon for side effects.", RT.keyword(null, "line"), Integer.valueOf(278), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__106 = (Var)RT.var("clojure.core.async", "do-alt");
    const__109 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "alts"), Symbol.intern(null, "clauses")) })), RT.keyword(null, "line"), Integer.valueOf(304), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__110 = (Var)RT.var("clojure.core.async", "alt!!");
    const__113 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "clauses")) })), RT.keyword(null, "doc"), "Like alt!, except as if by alts!!, will block until completed, and\n  not intended for use in (go ...) blocks.", RT.keyword(null, "line"), Integer.valueOf(342), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__114 = (Var)RT.var("clojure.core.async", "alt!");
    const__117 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "clauses")) })), RT.keyword(null, "doc"), "Makes a single choice between one of several channel operations,\n  as if by alts!, returning the value of the result expr corresponding\n  to the operation completed. Must be called inside a (go ...) block.\n\n  Each clause takes the form of:\n\n  channel-op[s] result-expr\n\n  where channel-ops is one of:\n\n  take-port - a single port to take\n  [take-port | [put-port put-val] ...] - a vector of ports as per alts!\n  :default | :priority - an option for alts!\n\n  and result-expr is either a list beginning with a vector, whereupon that\n  vector will be treated as a binding for the [val port] return of the\n  operation, else any other expression.\n\n  (alt!\n    [c t] ([val ch] (foo ch val))\n    x ([v] v)\n    [[out val]] :wrote\n    :default 42)\n\n  Each option may appear at most once. The choice and parking\n  characteristics are those of alts!.", RT.keyword(null, "line"), Integer.valueOf(349), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__118 = (Var)RT.var("clojure.core.async", "ioc-alts!");
    const__121 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "state"), Symbol.intern(null, "cont-block"), Symbol.intern(null, "ports"), Symbol.intern(null, "&"), RT.map(new Object[] { RT.keyword(null, "as"), Symbol.intern(null, "opts") })) })), RT.keyword(null, "line"), Integer.valueOf(380), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__122 = (Var)RT.var("clojure.core.async", "offer!");
    const__125 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "port"), Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "Puts a val into port if it's possible to do so immediately.\n   nil values are not allowed. Never blocks. Returns true if offer succeeds.", RT.keyword(null, "line"), Integer.valueOf(391), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__126 = (Var)RT.var("clojure.core.async", "poll!");
    const__129 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "port")) })), RT.keyword(null, "doc"), "Takes a val from port if it's possible to do so immediately.\n   Never blocks. Returns value if successful, nil otherwise.", RT.keyword(null, "line"), Integer.valueOf(398), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__130 = (Var)RT.var("clojure.core.async", "go");
    const__133 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Asynchronously executes the body, returning immediately to the\n  calling thread. Additionally, any visible calls to <!, >! and alt!/alts!\n  channel operations within the body will block (if necessary) by\n  'parking' the calling thread rather than tying up an OS thread (or\n  the only JS thread when in ClojureScript). Upon completion of the\n  operation, the body will be resumed.\n\n  Returns a channel which will receive the result of the body when\n  completed", RT.keyword(null, "line"), Integer.valueOf(405), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__134 = (Var)RT.var("clojure.core.async", "thread-call");
    const__137 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Executes f in another thread, returning immediately to the calling\n  thread. Returns a channel which will receive the result of calling\n  f when completed, then close.", RT.keyword(null, "line"), Integer.valueOf(432), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__138 = (Var)RT.var("clojure.core.async", "thread");
    const__141 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Executes the body in another thread, returning immediately to the\n  calling thread. Returns a channel which will receive the result of\n  the body when completed, then close.", RT.keyword(null, "line"), Integer.valueOf(450), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__142 = (Var)RT.var("clojure.core.async", "go-loop");
    const__145 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Like (go (loop ...))", RT.keyword(null, "line"), Integer.valueOf(459), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__146 = (Var)RT.var("clojure.core.async", "pipe");
    const__149 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "from"), Symbol.intern(null, "to")), Tuple.create(Symbol.intern(null, "from"), Symbol.intern(null, "to"), Symbol.intern(null, "close?")) })), RT.keyword(null, "doc"), "Takes elements from the from channel and supplies them to the to\n  channel. By default, the to channel will be closed when the from\n  channel closes, but can be determined by the close?  parameter. Will\n  stop consuming the from channel if the to channel closes", RT.keyword(null, "line"), Integer.valueOf(464), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__150 = (Var)RT.var("clojure.core.async", "pipeline*");
    const__153 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { RT.vector(new Object[] { Symbol.intern(null, "n"), Symbol.intern(null, "to"), Symbol.intern(null, "xf"), Symbol.intern(null, "from"), Symbol.intern(null, "close?"), Symbol.intern(null, "ex-handler"), Symbol.intern(null, "type") }) })), RT.keyword(null, "line"), Integer.valueOf(479), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__154 = (Var)RT.var("clojure.core.async", "pipeline");
    const__157 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "to"), Symbol.intern(null, "xf"), Symbol.intern(null, "from")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "to"), Symbol.intern(null, "xf"), Symbol.intern(null, "from"), Symbol.intern(null, "close?")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "to"), Symbol.intern(null, "xf"), Symbol.intern(null, "from"), Symbol.intern(null, "close?"), Symbol.intern(null, "ex-handler")) })), RT.keyword(null, "doc"), "Takes elements from the from channel and supplies them to the to\n  channel, subject to the transducer xf, with parallelism n. Because\n  it is parallel, the transducer will be applied independently to each\n  element, not across elements, and may produce zero or more outputs\n  per input.  Outputs will be returned in order relative to the\n  inputs. By default, the to channel will be closed when the from\n  channel closes, but can be determined by the close?  parameter. Will\n  stop consuming the from channel if the to channel closes. Note this\n  should be used for computational parallelism. If you have multiple\n  blocking operations to put in flight, use pipeline-blocking instead,\n  If you have multiple asynchronous operations to put in flight, use\n  pipeline-async instead.", RT.keyword(null, "line"), Integer.valueOf(538), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__158 = (Var)RT.var("clojure.core.async", "pipeline-blocking");
    const__161 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "to"), Symbol.intern(null, "xf"), Symbol.intern(null, "from")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "to"), Symbol.intern(null, "xf"), Symbol.intern(null, "from"), Symbol.intern(null, "close?")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "to"), Symbol.intern(null, "xf"), Symbol.intern(null, "from"), Symbol.intern(null, "close?"), Symbol.intern(null, "ex-handler")) })), RT.keyword(null, "doc"), "Like pipeline, for blocking operations.", RT.keyword(null, "line"), Integer.valueOf(555), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__162 = (Var)RT.var("clojure.core.async", "pipeline-async");
    const__165 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "to"), Symbol.intern(null, "af"), Symbol.intern(null, "from")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "to"), Symbol.intern(null, "af"), Symbol.intern(null, "from"), Symbol.intern(null, "close?")) })), RT.keyword(null, "doc"), "Takes elements from the from channel and supplies them to the to\n  channel, subject to the async function af, with parallelism n. af\n  must be a function of two arguments, the first an input value and\n  the second a channel on which to place the result(s). af must close!\n  the channel before returning.  The presumption is that af will\n  return immediately, having launched some asynchronous operation\n  (i.e. in another thread) whose completion/callback will manipulate\n  the result channel. Outputs will be returned in order relative to\n  the inputs. By default, the to channel will be closed when the from\n  channel closes, but can be determined by the close?  parameter. Will\n  stop consuming the from channel if the to channel closes. See also\n  pipeline, pipeline-blocking.", RT.keyword(null, "line"), Integer.valueOf(561), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__166 = (Var)RT.var("clojure.core.async", "split");
    const__169 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "ch")), Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "ch"), Symbol.intern(null, "t-buf-or-n"), Symbol.intern(null, "f-buf-or-n")) })), RT.keyword(null, "doc"), "Takes a predicate and a source channel and returns a vector of two\n  channels, the first of which will contain the values for which the\n  predicate returned true, the second those for which it returned\n  false.\n\n  The out channels will be unbuffered by default, or two buf-or-ns can\n  be supplied. The channels will close after the source channel has\n  closed.", RT.keyword(null, "line"), Integer.valueOf(577), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__170 = (Var)RT.var("clojure.core.async", "reduce");
    const__173 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "init"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), "f should be a function of 2 arguments. Returns a channel containing\n  the single result of applying f to init and the first item from the\n  channel, then applying f to that result and the 2nd item, etc. If\n  the channel closes without yielding items, returns init and f is not\n  called. ch must close before reduce produces a result.", RT.keyword(null, "line"), Integer.valueOf(598), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__174 = (Var)RT.var("clojure.core.async", "transduce");
    const__177 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xform"), Symbol.intern(null, "f"), Symbol.intern(null, "init"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), "async/reduces a channel with a transformation (xform f).\n  Returns a channel containing the result.  ch must close before\n  transduce produces a result.", RT.keyword(null, "line"), Integer.valueOf(614), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__178 = (Var)RT.var("clojure.core.async", "bounded-count");
    const__181 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Returns the smaller of n or the count of coll, without examining\n  more than n items if coll is not counted", RT.keyword(null, "line"), Integer.valueOf(624), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__182 = (Var)RT.var("clojure.core.async", "onto-chan");
    const__185 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ch"), Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "ch"), Symbol.intern(null, "coll"), Symbol.intern(null, "close?")) })), RT.keyword(null, "doc"), "Puts the contents of coll into the supplied channel.\n\n  By default the channel will be closed after the items are copied,\n  but can be determined by the close? parameter.\n\n  Returns a channel which will close after the items are copied.", RT.keyword(null, "line"), Integer.valueOf(635), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__186 = (Var)RT.var("clojure.core.async", "to-chan");
    const__189 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Creates and returns a channel which contains the contents of coll,\n  closing when exhausted.", RT.keyword(null, "line"), Integer.valueOf(650), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__190 = RT.classForName("clojure.core.async.Mux");
    const__191 = (Var)RT.var("clojure.core", "alter-meta!");
    const__192 = (Var)RT.var("clojure.core.async", "Mux");
    const__193 = (Var)RT.var("clojure.core", "assoc");
    const__194 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__195 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "muxch*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) })) }));
    const__196 = (Var)RT.var("clojure.core", "alter-var-root");
    const__197 = (Var)RT.var("clojure.core", "merge");
  }
  
  public static void __init2() {
    const__201 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.core.async.Mux"), RT.keyword(null, "on-interface"), RT.classForName("clojure.core.async.Mux") });
    const__202 = (Keyword)RT.keyword(null, "sigs");
    const__203 = (AFn)RT.map(new Object[] { RT.keyword(null, "muxch*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "muxch*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })), RT.keyword(null, "doc"), null }) });
    const__204 = (Keyword)RT.keyword(null, "var");
    const__205 = (Keyword)RT.keyword(null, "method-map");
    const__207 = (AFn)RT.map(new Object[] { RT.keyword(null, "muxch*"), RT.keyword(null, "muxch*") });
    const__208 = (Keyword)RT.keyword(null, "method-builders");
    const__209 = (Var)RT.var("clojure.core", "intern");
    const__210 = (Var)RT.var("clojure.core", "*ns*");
    const__211 = (Var)RT.var("clojure.core", "with-meta");
    const__212 = (AFn)((IObj)Symbol.intern(null, "muxch*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) }));
    const__213 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "muxch*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })), RT.keyword(null, "doc"), null });
    const__214 = (Keyword)RT.keyword(null, "protocol");
    const__215 = (Var)RT.var("clojure.core", "-reset-methods");
    const__216 = (AFn)Symbol.intern(null, "Mux");
    const__217 = RT.classForName("clojure.core.async.Mult");
    const__218 = (Var)RT.var("clojure.core.async", "Mult");
    const__219 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "tap*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch"), Symbol.intern(null, "close?")) })) })), ((IObj)Symbol.intern(null, "untap*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch")) })) })), ((IObj)Symbol.intern(null, "untap-all*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })) })) }));
    const__221 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.core.async.Mult"), RT.keyword(null, "on-interface"), RT.classForName("clojure.core.async.Mult") });
    const__222 = (AFn)RT.map(new Object[] { RT.keyword(null, "tap*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "tap*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch"), Symbol.intern(null, "close?")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch"), Symbol.intern(null, "close?")) })), RT.keyword(null, "doc"), null }), RT.keyword(null, "untap*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "untap*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), null }), RT.keyword(null, "untap-all*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "untap-all*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), null }) });
    const__226 = (AFn)RT.map(new Object[] { RT.keyword(null, "untap*"), RT.keyword(null, "untap*"), RT.keyword(null, "untap-all*"), RT.keyword(null, "untap-all*"), RT.keyword(null, "tap*"), RT.keyword(null, "tap*") });
    const__227 = (AFn)((IObj)Symbol.intern(null, "untap-all*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })) }));
    const__228 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "untap-all*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), null });
    const__229 = (AFn)((IObj)Symbol.intern(null, "untap*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch")) })) }));
    const__230 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "untap*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), null });
    const__231 = (AFn)((IObj)Symbol.intern(null, "tap*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch"), Symbol.intern(null, "close?")) })) }));
    const__232 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "tap*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch"), Symbol.intern(null, "close?")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch"), Symbol.intern(null, "close?")) })), RT.keyword(null, "doc"), null });
    const__233 = (AFn)Symbol.intern(null, "Mult");
    const__234 = (Var)RT.var("clojure.core.async", "mult");
    const__237 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), "Creates and returns a mult(iple) of the supplied channel. Channels\n  containing copies of the channel can be created with 'tap', and\n  detached with 'untap'.\n\n  Each item is distributed to all taps in parallel and synchronously,\n  i.e. each tap must accept before the next item is distributed. Use\n  buffering/windowing to prevent slow taps from holding up the mult.\n\n  Items received when there are no taps get dropped.\n\n  If a tap puts to a closed channel, it will be removed from the mult.", RT.keyword(null, "line"), Integer.valueOf(671), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__238 = (Var)RT.var("clojure.core.async", "tap");
    const__241 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "mult"), Symbol.intern(null, "ch")), Tuple.create(Symbol.intern(null, "mult"), Symbol.intern(null, "ch"), Symbol.intern(null, "close?")) })), RT.keyword(null, "doc"), "Copies the mult source onto the supplied channel.\n\n  By default the channel will be closed when the source closes,\n  but can be determined by the close? parameter.", RT.keyword(null, "line"), Integer.valueOf(714), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__242 = (Var)RT.var("clojure.core.async", "untap");
    const__245 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "mult"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), "Disconnects a target channel from a mult", RT.keyword(null, "line"), Integer.valueOf(722), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__246 = (Var)RT.var("clojure.core.async", "untap-all");
    const__249 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "mult")) })), RT.keyword(null, "doc"), "Disconnects all target channels from a mult", RT.keyword(null, "line"), Integer.valueOf(727), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__250 = RT.classForName("clojure.core.async.Mix");
    const__251 = (Var)RT.var("clojure.core.async", "Mix");
    const__252 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "admix*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch")) })) })), ((IObj)Symbol.intern(null, "unmix*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch")) })) })), ((IObj)Symbol.intern(null, "unmix-all*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })) })), ((IObj)Symbol.intern(null, "toggle*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "state-map")) })) })), ((IObj)Symbol.intern(null, "solo-mode*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "mode")) })) })) }));
    const__254 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.core.async.Mix"), RT.keyword(null, "on-interface"), RT.classForName("clojure.core.async.Mix") });
    const__255 = (AFn)RT.map(new Object[] { RT.keyword(null, "admix*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "admix*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), null }), RT.keyword(null, "unmix*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "unmix*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), null }), RT.keyword(null, "unmix-all*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "unmix-all*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), null }), RT.keyword(null, "toggle*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "toggle*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "state-map")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "state-map")) })), RT.keyword(null, "doc"), null }), RT.keyword(null, "solo-mode*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "solo-mode*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "mode")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "mode")) })), RT.keyword(null, "doc"), null }) });
    const__261 = (AFn)RT.map(new Object[] { RT.keyword(null, "solo-mode*"), RT.keyword(null, "solo-mode*"), RT.keyword(null, "unmix-all*"), RT.keyword(null, "unmix-all*"), RT.keyword(null, "toggle*"), RT.keyword(null, "toggle*"), RT.keyword(null, "admix*"), RT.keyword(null, "admix*"), RT.keyword(null, "unmix*"), RT.keyword(null, "unmix*") });
    const__262 = (AFn)((IObj)Symbol.intern(null, "unmix*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch")) })) }));
    const__263 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "unmix*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), null });
    const__264 = (AFn)((IObj)Symbol.intern(null, "solo-mode*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "mode")) })) }));
    const__265 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "solo-mode*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "mode")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "mode")) })), RT.keyword(null, "doc"), null });
    const__266 = (AFn)((IObj)Symbol.intern(null, "admix*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch")) })) }));
    const__267 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "admix*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), null });
    const__268 = (AFn)((IObj)Symbol.intern(null, "unmix-all*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })) }));
    const__269 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "unmix-all*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), null });
    const__270 = (AFn)((IObj)Symbol.intern(null, "toggle*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "state-map")) })) }));
    const__271 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "toggle*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "state-map")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "state-map")) })), RT.keyword(null, "doc"), null });
    const__272 = (AFn)Symbol.intern(null, "Mix");
    const__273 = (Var)RT.var("clojure.core.async", "mix");
    const__276 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "out")) })), RT.keyword(null, "doc"), "Creates and returns a mix of one or more input channels which will\n  be put on the supplied out channel. Input sources can be added to\n  the mix with 'admix', and removed with 'unmix'. A mix supports\n  soloing, muting and pausing multiple inputs atomically using\n  'toggle', and can solo using either muting or pausing as determined\n  by 'solo-mode'.\n\n  Each channel can have zero or more boolean modes set via 'toggle':\n\n  :solo - when true, only this (ond other soloed) channel(s) will appear\n          in the mix output channel. :mute and :pause states of soloed\n          channels are ignored. If solo-mode is :mute, non-soloed\n          channels are muted, if :pause, non-soloed channels are\n          paused.\n\n  :mute - muted channels will have their contents consumed but not included in the mix\n  :pause - paused channels will not have their contents consumed (and thus also not included in the mix)\n", RT.keyword(null, "line"), Integer.valueOf(738), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__277 = (Var)RT.var("clojure.core.async", "admix");
    const__280 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "mix"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), "Adds ch as an input to the mix", RT.keyword(null, "line"), Integer.valueOf(808), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__281 = (Var)RT.var("clojure.core.async", "unmix");
    const__284 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "mix"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), "Removes ch as an input to the mix", RT.keyword(null, "line"), Integer.valueOf(813), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__285 = (Var)RT.var("clojure.core.async", "unmix-all");
    const__288 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "mix")) })), RT.keyword(null, "doc"), "removes all inputs from the mix", RT.keyword(null, "line"), Integer.valueOf(818), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__289 = (Var)RT.var("clojure.core.async", "toggle");
    const__292 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "mix"), Symbol.intern(null, "state-map")) })), RT.keyword(null, "doc"), "Atomically sets the state(s) of one or more channels in a mix. The\n  state map is a map of channels -> channel-state-map. A\n  channel-state-map is a map of attrs -> boolean, where attr is one or\n  more of :mute, :pause or :solo. Any states supplied are merged with\n  the current state.\n\n  Note that channels can be added to a mix via toggle, which can be\n  used to add channels in a particular (e.g. paused) state.", RT.keyword(null, "line"), Integer.valueOf(823), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__293 = (Var)RT.var("clojure.core.async", "solo-mode");
    const__296 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "mix"), Symbol.intern(null, "mode")) })), RT.keyword(null, "doc"), "Sets the solo mode of the mix. mode must be one of :mute or :pause", RT.keyword(null, "line"), Integer.valueOf(835), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__297 = RT.classForName("clojure.core.async.Pub");
    const__298 = (Var)RT.var("clojure.core.async", "Pub");
    const__299 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "sub*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "v"), Symbol.intern(null, "ch"), Symbol.intern(null, "close?")) })) })), ((IObj)Symbol.intern(null, "unsub*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "v"), Symbol.intern(null, "ch")) })) })), ((IObj)Symbol.intern(null, "unsub-all*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p")), Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "v")) })) })) }));
  }
  
  public static void __init3() {
    const__301 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.core.async.Pub"), RT.keyword(null, "on-interface"), RT.classForName("clojure.core.async.Pub") });
    const__302 = (AFn)RT.map(new Object[] { RT.keyword(null, "sub*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "sub*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "v"), Symbol.intern(null, "ch"), Symbol.intern(null, "close?")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "v"), Symbol.intern(null, "ch"), Symbol.intern(null, "close?")) })), RT.keyword(null, "doc"), null }), RT.keyword(null, "unsub*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "unsub*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "v"), Symbol.intern(null, "ch")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "v"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), null }), RT.keyword(null, "unsub-all*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "unsub-all*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p")), Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "v")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p")), Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "v")) })), RT.keyword(null, "doc"), null }) });
    const__306 = (AFn)RT.map(new Object[] { RT.keyword(null, "sub*"), RT.keyword(null, "sub*"), RT.keyword(null, "unsub*"), RT.keyword(null, "unsub*"), RT.keyword(null, "unsub-all*"), RT.keyword(null, "unsub-all*") });
    const__307 = (AFn)((IObj)Symbol.intern(null, "unsub*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "v"), Symbol.intern(null, "ch")) })) }));
    const__308 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "unsub*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "v"), Symbol.intern(null, "ch")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "v"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), null });
    const__309 = (AFn)((IObj)Symbol.intern(null, "unsub-all*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p")), Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "v")) })) }));
    const__310 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "unsub-all*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p")), Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "v")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p")), Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "v")) })), RT.keyword(null, "doc"), null });
    const__311 = (AFn)((IObj)Symbol.intern(null, "sub*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "v"), Symbol.intern(null, "ch"), Symbol.intern(null, "close?")) })) }));
    const__312 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "sub*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "v"), Symbol.intern(null, "ch"), Symbol.intern(null, "close?")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "v"), Symbol.intern(null, "ch"), Symbol.intern(null, "close?")) })), RT.keyword(null, "doc"), null });
    const__313 = (AFn)Symbol.intern(null, "Pub");
    const__314 = (Var)RT.var("clojure.core.async", "pub");
    const__317 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ch"), Symbol.intern(null, "topic-fn")), Tuple.create(Symbol.intern(null, "ch"), Symbol.intern(null, "topic-fn"), Symbol.intern(null, "buf-fn")) })), RT.keyword(null, "doc"), "Creates and returns a pub(lication) of the supplied channel,\n  partitioned into topics by the topic-fn. topic-fn will be applied to\n  each value on the channel and the result will determine the 'topic'\n  on which that value will be put. Channels can be subscribed to\n  receive copies of topics using 'sub', and unsubscribed using\n  'unsub'. Each topic will be handled by an internal mult on a\n  dedicated channel. By default these internal channels are\n  unbuffered, but a buf-fn can be supplied which, given a topic,\n  creates a buffer with desired properties.\n\n  Each item is distributed to all subs in parallel and synchronously,\n  i.e. each sub must accept before the next item is distributed. Use\n  buffering/windowing to prevent slow subs from holding up the pub.\n\n  Items received when there are no matching subs get dropped.\n\n  Note that if buf-fns are used then each topic is handled\n  asynchronously, i.e. if a channel is subscribed to more than one\n  topic it should not expect them to be interleaved identically with\n  the source.", RT.keyword(null, "line"), Integer.valueOf(845), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__318 = (Var)RT.var("clojure.core.async", "sub");
    const__321 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "topic"), Symbol.intern(null, "ch")), Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "topic"), Symbol.intern(null, "ch"), Symbol.intern(null, "close?")) })), RT.keyword(null, "doc"), "Subscribes a channel to a topic of a pub.\n\n  By default the channel will be closed when the source closes,\n  but can be determined by the close? parameter.", RT.keyword(null, "line"), Integer.valueOf(900), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__322 = (Var)RT.var("clojure.core.async", "unsub");
    const__325 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "topic"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), "Unsubscribes a channel from a topic of a pub", RT.keyword(null, "line"), Integer.valueOf(908), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__326 = (Var)RT.var("clojure.core.async", "unsub-all");
    const__329 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p")), Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "topic")) })), RT.keyword(null, "doc"), "Unsubscribes all channels from a pub, or a topic of a pub", RT.keyword(null, "line"), Integer.valueOf(913), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__330 = (Var)RT.var("clojure.core.async", "map");
    const__333 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "chs")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "chs"), Symbol.intern(null, "buf-or-n")) })), RT.keyword(null, "doc"), "Takes a function and a collection of source channels, and returns a\n  channel which contains the values produced by applying f to the set\n  of first items taken from each source channel, followed by applying\n  f to the set of second items from each channel, until any one of the\n  channels is closed, at which point the output channel will be\n  closed. The returned channel will be unbuffered by default, or a\n  buf-or-n can be supplied", RT.keyword(null, "line"), Integer.valueOf(920), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__334 = (Var)RT.var("clojure.core.async", "merge");
    const__337 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "chs")), Tuple.create(Symbol.intern(null, "chs"), Symbol.intern(null, "buf-or-n")) })), RT.keyword(null, "doc"), "Takes a collection of source channels and returns a channel which\n  contains all values taken from them. The returned channel will be\n  unbuffered by default, or a buf-or-n can be supplied. The channel\n  will close after all the source channels have closed.", RT.keyword(null, "line"), Integer.valueOf(956), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__338 = (Var)RT.var("clojure.core.async", "into");
    const__341 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), "Returns a channel containing the single (collection) result of the\n  items taken from the channel conjoined to the supplied\n  collection. ch must close before into produces a result.", RT.keyword(null, "line"), Integer.valueOf(974), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__342 = (Var)RT.var("clojure.core.async", "take");
    const__345 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "ch")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "ch"), Symbol.intern(null, "buf-or-n")) })), RT.keyword(null, "doc"), "Returns a channel that will return, at most, n items from ch. After n items\n   have been returned, or ch has been closed, the return channel will close.\n\n  The output channel is unbuffered by default, unless buf-or-n is given.", RT.keyword(null, "line"), Integer.valueOf(982), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__346 = (Var)RT.var("clojure.core.async", "map<");
    const__350 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), "Deprecated - this function will be removed. Use transducer instead", RT.keyword(null, "deprecated"), "0.1.319.0-6b1aca-alpha", RT.keyword(null, "line"), Integer.valueOf(1001), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__351 = (Var)RT.var("clojure.core.async", "map>");
    const__354 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), "Deprecated - this function will be removed. Use transducer instead", RT.keyword(null, "deprecated"), "0.1.319.0-6b1aca-alpha", RT.keyword(null, "line"), Integer.valueOf(1033), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__355 = (Var)RT.var("clojure.core.async", "filter>");
    const__358 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), "Deprecated - this function will be removed. Use transducer instead", RT.keyword(null, "deprecated"), "0.1.319.0-6b1aca-alpha", RT.keyword(null, "line"), Integer.valueOf(1049), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__359 = (Var)RT.var("clojure.core.async", "remove>");
    const__362 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), "Deprecated - this function will be removed. Use transducer instead", RT.keyword(null, "deprecated"), "0.1.319.0-6b1aca-alpha", RT.keyword(null, "line"), Integer.valueOf(1067), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__363 = (Var)RT.var("clojure.core.async", "filter<");
    const__366 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "ch")), Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "ch"), Symbol.intern(null, "buf-or-n")) })), RT.keyword(null, "doc"), "Deprecated - this function will be removed. Use transducer instead", RT.keyword(null, "deprecated"), "0.1.319.0-6b1aca-alpha", RT.keyword(null, "line"), Integer.valueOf(1073), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__367 = (Var)RT.var("clojure.core.async", "remove<");
    const__370 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "ch")), Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "ch"), Symbol.intern(null, "buf-or-n")) })), RT.keyword(null, "doc"), "Deprecated - this function will be removed. Use transducer instead", RT.keyword(null, "deprecated"), "0.1.319.0-6b1aca-alpha", RT.keyword(null, "line"), Integer.valueOf(1088), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__371 = (Var)RT.var("clojure.core.async", "mapcat*");
    const__374 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "in"), Symbol.intern(null, "out")) })), RT.keyword(null, "line"), Integer.valueOf(1094), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__375 = (Var)RT.var("clojure.core.async", "mapcat<");
    const__378 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "in")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "in"), Symbol.intern(null, "buf-or-n")) })), RT.keyword(null, "doc"), "Deprecated - this function will be removed. Use transducer instead", RT.keyword(null, "deprecated"), "0.1.319.0-6b1aca-alpha", RT.keyword(null, "line"), Integer.valueOf(1104), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__379 = (Var)RT.var("clojure.core.async", "mapcat>");
    const__382 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "out")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "out"), Symbol.intern(null, "buf-or-n")) })), RT.keyword(null, "doc"), "Deprecated - this function will be removed. Use transducer instead", RT.keyword(null, "deprecated"), "0.1.319.0-6b1aca-alpha", RT.keyword(null, "line"), Integer.valueOf(1113), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__383 = (Var)RT.var("clojure.core.async", "unique");
    const__386 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ch")), Tuple.create(Symbol.intern(null, "ch"), Symbol.intern(null, "buf-or-n")) })), RT.keyword(null, "doc"), "Deprecated - this function will be removed. Use transducer instead", RT.keyword(null, "deprecated"), "0.1.319.0-6b1aca-alpha", RT.keyword(null, "line"), Integer.valueOf(1122), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__387 = (Var)RT.var("clojure.core.async", "partition");
    const__390 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "ch")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "ch"), Symbol.intern(null, "buf-or-n")) })), RT.keyword(null, "doc"), "Deprecated - this function will be removed. Use transducer instead", RT.keyword(null, "deprecated"), "0.1.319.0-6b1aca-alpha", RT.keyword(null, "line"), Integer.valueOf(1140), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/async.clj" });
    const__391 = (Var)RT.var("clojure.core.async", "partition-by");
    const__394 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "ch")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "ch"), Symbol.intern(null, "buf-or-n")) })), RT.keyword(null, "doc"), "Deprecated - this function will be removed. Use transducer instead", RT.keyword(null, "deprecated"), "0.1.319.0-6b1aca-alpha", RT.keyword(null, "line"), Integer.valueOf(1165), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/async.clj" });
  }
  
  static  {
    __init0();
    __init1();
    __init2();
    __init3();
    Compiler.pushNSandLoader(RT.classForName("clojure.core.async__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
