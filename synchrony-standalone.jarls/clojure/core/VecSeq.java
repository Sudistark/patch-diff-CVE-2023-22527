package clojure.core;

import clojure.core;
import clojure.core.protocols.InternalReduce;
import clojure.lang.Cons;
import clojure.lang.IChunk;
import clojure.lang.IChunkedSeq;
import clojure.lang.IObj;
import clojure.lang.IPersistentCollection;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.ISeq;
import clojure.lang.IType;
import clojure.lang.Keyword;
import clojure.lang.Numbers;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Seqable;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Util;

public final class VecSeq implements ISeq, IChunkedSeq, InternalReduce, Seqable, IType {
  public final Object am;
  
  public final Object vec;
  
  public final Object anode;
  
  public final int i;
  
  public final int offset;
  
  public static final Keyword const__19 = (Keyword)RT.keyword(null, "else");
  
  public VecSeq(Object paramObject1, Object paramObject2, Object paramObject3, int paramInt1, int paramInt2) { this.am = paramObject1;
    this.vec = paramObject2;
    this.anode = paramObject3;
    this.i = paramInt1;
    this.offset = paramInt2; }
  
  public static IPersistentVector getBasis() { return Tuple.create(((IObj)Symbol.intern(null, "am")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.core.ArrayManager") })), ((IObj)Symbol.intern(null, "vec")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.core.IVecImpl") })), Symbol.intern(null, "anode"), ((IObj)Symbol.intern(null, "i")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "int") })), ((IObj)Symbol.intern(null, "offset")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "int") }))); }
  
  public ISeq chunkedMore() {
    Object s = ((IChunkedSeq)this).chunkedNext(), or__5516__auto__8250 = s = null;
    if (or__5516__auto__8250 != null) {
      if (or__5516__auto__8250 != Boolean.FALSE)
        or__5516__auto__8250 = null; 
    } else {
      or__5516__auto__8250;
    } 
    return (ISeq)PersistentList.EMPTY;
  }
  
  public ISeq chunkedNext() {
    long nexti = Numbers.add(this.i, ((ArrayManager)this.am).alength(this.anode));
    return (ISeq)((nexti < RT.count(this.vec)) ? new VecSeq(this.am, this.vec, ((IVecImpl)this.vec).arrayFor(RT.intCast(nexti)), RT.intCast(nexti), RT.intCast(0L)) : null);
  }
  
  public IChunk chunkedFirst() { return (IChunk)new ArrayChunk(this.am, this.anode, this.offset, ((ArrayManager)this.am).alength(this.anode)); }
  
  public ISeq seq() { return (ISeq)this; }
  
  public IPersistentCollection empty() { return (IPersistentCollection)PersistentList.EMPTY; }
  
  public boolean equiv(Object o) {
    if (Util.identical(this, o)) {
    
    } else {
      boolean or__5516__auto__8251 = o instanceof clojure.lang.Sequential;
      if (or__5516__auto__8251 ? or__5516__auto__8251 : (o instanceof java.util.List)) {
        boolean and__5514__auto__8252;
        Object me = this;
        o = null;
        Object you = core.seq__5402.invokeStatic(o);
        while (true) {
          if (Util.identical(me, null)) {
            you = null;
            this = null;
          } else {
            and__5514__auto__8252 = Util.equiv(core.first__5384.invokeStatic(me), core.first__5384.invokeStatic(you));
            if (and__5514__auto__8252) {
              me = null;
              you = null;
              you = core.next__5386.invokeStatic(you);
              me = core.next__5386.invokeStatic(me);
              continue;
            } 
            break;
          } 
        } 
      } else if (const__19 != null) {
        if (const__19 != Boolean.FALSE);
      } else {
        const__19;
      } 
    } 
    return ((Boolean)null).booleanValue();
  }
  
  public int count() { // Byte code:
    //   0: lconst_1
    //   1: lstore_1
    //   2: aload_0
    //   3: invokestatic invokeStatic : (Ljava/lang/Object;)Ljava/lang/Object;
    //   6: astore_3
    //   7: aload_3
    //   8: dup
    //   9: ifnull -> 63
    //   12: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   15: if_acmpeq -> 64
    //   18: aload_3
    //   19: instanceof clojure/lang/Counted
    //   22: ifeq -> 45
    //   25: lload_1
    //   26: aload_3
    //   27: aconst_null
    //   28: astore_3
    //   29: checkcast clojure/lang/IPersistentCollection
    //   32: invokeinterface count : ()I
    //   37: i2l
    //   38: invokestatic add : (JJ)J
    //   41: goto -> 60
    //   44: athrow
    //   45: lload_1
    //   46: invokestatic inc : (J)J
    //   49: aload_3
    //   50: aconst_null
    //   51: astore_3
    //   52: invokestatic invokeStatic : (Ljava/lang/Object;)Ljava/lang/Object;
    //   55: astore_3
    //   56: lstore_1
    //   57: goto -> 7
    //   60: goto -> 65
    //   63: pop
    //   64: lload_1
    //   65: invokestatic intCast : (J)I
    //   68: ireturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #58	-> 0
    //   #95	-> 7
    //   #96	-> 18
    //   #97	-> 32
    //   #97	-> 38
    //   #98	-> 46
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   2	63	1	i	J
    //   7	58	3	s	Ljava/lang/Object;
    //   0	68	0	this	Lclojure/core/VecSeq; }
  
  public ISeq cons(Object o) { o = null;
    return (ISeq)new Cons(o, (ISeq)this); }
  
  public ISeq more() {
    Object s = ((ISeq)this).next(), or__5516__auto__8253 = s = null;
    if (or__5516__auto__8253 != null) {
      if (or__5516__auto__8253 != Boolean.FALSE)
        or__5516__auto__8253 = null; 
    } else {
      or__5516__auto__8253;
    } 
    return (ISeq)PersistentList.EMPTY;
  }
  
  public ISeq next() {
    return (ISeq)((Numbers.inc(this.offset) < ((ArrayManager)this.am).alength(this.anode)) ? new VecSeq(this.am, this.vec, this.anode, this.i, RT.intCast(Numbers.inc(this.offset))) : ((IChunkedSeq)this).chunkedNext());
  }
  
  public Object first() {
    return ((ArrayManager)this.am).aget(this.anode, this.offset);
  }
  
  public Object internal_reduce(Object f, Object val) { // Byte code:
    //   0: aload_2
    //   1: aconst_null
    //   2: astore_2
    //   3: astore_3
    //   4: aload_0
    //   5: getfield i : I
    //   8: i2l
    //   9: aload_0
    //   10: getfield offset : I
    //   13: i2l
    //   14: invokestatic add : (JJ)J
    //   17: lstore #4
    //   19: lload #4
    //   21: aload_0
    //   22: getfield vec : Ljava/lang/Object;
    //   25: invokestatic count : (Ljava/lang/Object;)I
    //   28: i2l
    //   29: lcmp
    //   30: ifge -> 133
    //   33: aload_0
    //   34: getfield vec : Ljava/lang/Object;
    //   37: checkcast clojure/core/IVecImpl
    //   40: lload #4
    //   42: invokestatic intCast : (J)I
    //   45: invokeinterface arrayFor : (I)Ljava/lang/Object;
    //   50: astore #6
    //   52: new clojure/core/VecSeq$fn__8247
    //   55: dup
    //   56: aload_3
    //   57: aconst_null
    //   58: astore_3
    //   59: lload #4
    //   61: aload_0
    //   62: getfield am : Ljava/lang/Object;
    //   65: aload_1
    //   66: aload #6
    //   68: aconst_null
    //   69: astore #6
    //   71: invokespecial <init> : (Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V
    //   74: checkcast clojure/lang/IFn
    //   77: invokeinterface invoke : ()Ljava/lang/Object;
    //   82: astore #7
    //   84: aload #7
    //   86: invokestatic isReduced : (Ljava/lang/Object;)Z
    //   89: ifeq -> 106
    //   92: aload #7
    //   94: aconst_null
    //   95: astore #7
    //   97: aconst_null
    //   98: astore_0
    //   99: invokestatic invokeStatic : (Ljava/lang/Object;)Ljava/lang/Object;
    //   102: goto -> 129
    //   105: athrow
    //   106: aload #7
    //   108: aconst_null
    //   109: astore #7
    //   111: ldc2_w 65504
    //   114: lload #4
    //   116: ldc2_w 32
    //   119: invokestatic add : (JJ)J
    //   122: land
    //   123: lstore #4
    //   125: astore_3
    //   126: goto -> 19
    //   129: goto -> 136
    //   132: athrow
    //   133: aload_3
    //   134: aconst_null
    //   135: astore_3
    //   136: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #58	-> 0
    //   #65	-> 14
    //   #66	-> 19
    //   #66	-> 19
    //   #66	-> 25
    //   #67	-> 45
    //   #68	-> 74
    //   #68	-> 77
    //   #76	-> 84
    //   #76	-> 86
    //   #78	-> 119
    //   #78	-> 122
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   52	77	6	node	Ljava/lang/Object;
    //   84	45	7	result	Ljava/lang/Object;
    //   4	132	3	result	Ljava/lang/Object;
    //   19	117	4	aidx	J
    //   0	136	0	this	Lclojure/core/VecSeq;
    //   0	136	1	f	Ljava/lang/Object;
    //   0	136	2	val	Ljava/lang/Object; }
}
