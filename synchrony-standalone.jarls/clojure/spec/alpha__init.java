package clojure.spec;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;

public class alpha__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__2;
  
  public static final Var const__3;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final Var const__7;
  
  public static final Var const__8;
  
  public static final Keyword const__15;
  
  public static final AFn const__16;
  
  public static final Object const__17;
  
  public static final Var const__18;
  
  public static final AFn const__20;
  
  public static final Object const__21;
  
  public static final Var const__22;
  
  public static final AFn const__24;
  
  public static final Object const__25;
  
  public static final Var const__26;
  
  public static final AFn const__28;
  
  public static final Object const__29;
  
  public static final Object const__30;
  
  public static final Var const__31;
  
  public static final Var const__32;
  
  public static final Var const__33;
  
  public static final Var const__34;
  
  public static final ISeq const__35;
  
  public static final Var const__36;
  
  public static final Var const__37;
  
  public static final AFn const__41;
  
  public static final Keyword const__42;
  
  public static final AFn const__43;
  
  public static final Keyword const__44;
  
  public static final Keyword const__45;
  
  public static final AFn const__52;
  
  public static final Keyword const__53;
  
  public static final Var const__54;
  
  public static final Var const__55;
  
  public static final Var const__56;
  
  public static final AFn const__57;
  
  public static final AFn const__58;
  
  public static final Keyword const__59;
  
  public static final AFn const__60;
  
  public static final AFn const__61;
  
  public static final AFn const__62;
  
  public static final AFn const__63;
  
  public static final AFn const__64;
  
  public static final AFn const__65;
  
  public static final AFn const__66;
  
  public static final AFn const__67;
  
  public static final AFn const__68;
  
  public static final AFn const__69;
  
  public static final Var const__70;
  
  public static final AFn const__71;
  
  public static final Var const__72;
  
  public static final AFn const__77;
  
  public static final Var const__78;
  
  public static final AFn const__81;
  
  public static final Var const__82;
  
  public static final AFn const__85;
  
  public static final Var const__86;
  
  public static final AFn const__89;
  
  public static final Var const__90;
  
  public static final AFn const__93;
  
  public static final Var const__94;
  
  public static final AFn const__97;
  
  public static final Var const__98;
  
  public static final AFn const__101;
  
  public static final Var const__102;
  
  public static final AFn const__105;
  
  public static final Var const__106;
  
  public static final AFn const__108;
  
  public static final Var const__109;
  
  public static final AFn const__112;
  
  public static final Var const__113;
  
  public static final AFn const__116;
  
  public static final Object const__117;
  
  public static final Var const__118;
  
  public static final ISeq const__119;
  
  public static final AFn const__121;
  
  public static final AFn const__122;
  
  public static final Keyword const__123;
  
  public static final AFn const__124;
  
  public static final AFn const__125;
  
  public static final AFn const__126;
  
  public static final AFn const__127;
  
  public static final Var const__128;
  
  public static final AFn const__131;
  
  public static final Var const__132;
  
  public static final Object const__133;
  
  public static final Object const__134;
  
  public static final Object const__135;
  
  public static final Object const__136;
  
  public static final Var const__137;
  
  public static final AFn const__140;
  
  public static final Var const__141;
  
  public static final AFn const__144;
  
  public static final Var const__145;
  
  public static final AFn const__148;
  
  public static final Var const__149;
  
  public static final AFn const__152;
  
  public static final Var const__153;
  
  public static final AFn const__156;
  
  public static final Var const__157;
  
  public static final AFn const__160;
  
  public static final Var const__161;
  
  public static final AFn const__164;
  
  public static final Var const__165;
  
  public static final AFn const__168;
  
  public static final Var const__169;
  
  public static final AFn const__172;
  
  public static final Var const__173;
  
  public static final AFn const__176;
  
  public static final Var const__177;
  
  public static final AFn const__180;
  
  public static final Var const__181;
  
  public static final AFn const__183;
  
  public static final Var const__184;
  
  public static final AFn const__187;
  
  public static final Var const__188;
  
  public static final AFn const__191;
  
  public static final Var const__192;
  
  public static final AFn const__195;
  
  public static final Var const__196;
  
  public static final AFn const__198;
  
  public static final Var const__199;
  
  public static final AFn const__202;
  
  public static final Var const__203;
  
  public static final AFn const__206;
  
  public static final Var const__207;
  
  public static final AFn const__210;
  
  public static final Var const__211;
  
  public static final AFn const__214;
  
  public static final Var const__215;
  
  public static final AFn const__218;
  
  public static final Var const__219;
  
  public static final AFn const__223;
  
  public static final Var const__224;
  
  public static final AFn const__227;
  
  public static final AFn const__230;
  
  public static final Var const__231;
  
  public static final AFn const__234;
  
  public static final Var const__235;
  
  public static final AFn const__238;
  
  public static final Var const__239;
  
  public static final AFn const__242;
  
  public static final Var const__243;
  
  public static final AFn const__246;
  
  public static final Var const__247;
  
  public static final AFn const__250;
  
  public static final Var const__251;
  
  public static final AFn const__254;
  
  public static final Var const__255;
  
  public static final AFn const__258;
  
  public static final Var const__259;
  
  public static final AFn const__262;
  
  public static final Var const__263;
  
  public static final AFn const__266;
  
  public static final Var const__267;
  
  public static final AFn const__270;
  
  public static final Var const__271;
  
  public static final AFn const__274;
  
  public static final Var const__275;
  
  public static final AFn const__278;
  
  public static final Var const__279;
  
  public static final AFn const__282;
  
  public static final Var const__283;
  
  public static final AFn const__286;
  
  public static final Var const__287;
  
  public static final AFn const__290;
  
  public static final Var const__291;
  
  public static final AFn const__294;
  
  public static final Var const__295;
  
  public static final AFn const__298;
  
  public static final Var const__299;
  
  public static final AFn const__302;
  
  public static final Var const__303;
  
  public static final AFn const__306;
  
  public static final Var const__307;
  
  public static final AFn const__310;
  
  public static final Var const__311;
  
  public static final AFn const__314;
  
  public static final Var const__315;
  
  public static final AFn const__318;
  
  public static final Var const__319;
  
  public static final AFn const__322;
  
  public static final Var const__323;
  
  public static final AFn const__326;
  
  public static final Var const__327;
  
  public static final AFn const__330;
  
  public static final Var const__331;
  
  public static final AFn const__334;
  
  public static final Var const__335;
  
  public static final AFn const__338;
  
  public static final AFn const__341;
  
  public static final Var const__342;
  
  public static final AFn const__345;
  
  public static final Var const__346;
  
  public static final AFn const__349;
  
  public static final Var const__350;
  
  public static final AFn const__352;
  
  public static final Var const__353;
  
  public static final AFn const__355;
  
  public static final Var const__356;
  
  public static final AFn const__359;
  
  public static final AFn const__362;
  
  public static final AFn const__365;
  
  public static final Var const__366;
  
  public static final AFn const__369;
  
  public static final AFn const__372;
  
  public static final Var const__373;
  
  public static final AFn const__376;
  
  public static final Var const__377;
  
  public static final AFn const__380;
  
  public static final Var const__381;
  
  public static final AFn const__384;
  
  public static final Var const__385;
  
  public static final AFn const__388;
  
  public static final Var const__389;
  
  public static final AFn const__392;
  
  public static final Var const__393;
  
  public static final AFn const__396;
  
  public static final Var const__397;
  
  public static final AFn const__400;
  
  public static final Var const__401;
  
  public static final AFn const__404;
  
  public static final Var const__405;
  
  public static final AFn const__408;
  
  public static final Var const__409;
  
  public static final AFn const__411;
  
  public static final AFn const__412;
  
  public static final AFn const__413;
  
  public static final AFn const__414;
  
  public static final AFn const__415;
  
  public static final Var const__416;
  
  public static final AFn const__419;
  
  public static final Var const__420;
  
  public static final AFn const__423;
  
  public static final Var const__424;
  
  public static final AFn const__427;
  
  public static final Var const__428;
  
  public static final AFn const__431;
  
  public static final Var const__432;
  
  public static final AFn const__435;
  
  public static final Var const__436;
  
  public static final AFn const__439;
  
  public static final Var const__440;
  
  public static final AFn const__443;
  
  public static final Var const__444;
  
  public static final AFn const__447;
  
  public static final Var const__448;
  
  public static final AFn const__451;
  
  public static final Var const__452;
  
  public static final AFn const__455;
  
  public static final Var const__456;
  
  public static final AFn const__459;
  
  public static final Var const__460;
  
  public static final AFn const__463;
  
  public static final Var const__464;
  
  public static final AFn const__467;
  
  public static final Var const__468;
  
  public static final AFn const__471;
  
  public static final Var const__472;
  
  public static final AFn const__475;
  
  public static final Var const__476;
  
  public static final AFn const__479;
  
  public static final Var const__480;
  
  public static final AFn const__483;
  
  public static final Var const__484;
  
  public static final AFn const__486;
  
  public static final Var const__487;
  
  public static final AFn const__490;
  
  public static final Var const__491;
  
  public static final AFn const__493;
  
  public static final AFn const__496;
  
  public static final Var const__497;
  
  public static final AFn const__500;
  
  public static final AFn const__503;
  
  public static final Var const__504;
  
  public static final AFn const__507;
  
  public static final Var const__508;
  
  public static final AFn const__511;
  
  public static final Var const__512;
  
  public static final AFn const__515;
  
  public static final Var const__516;
  
  public static final AFn const__519;
  
  public static final Var const__520;
  
  public static final AFn const__523;
  
  public static final Var const__524;
  
  public static final AFn const__527;
  
  public static final AFn const__530;
  
  public static final Var const__531;
  
  public static final AFn const__534;
  
  public static final Var const__535;
  
  public static final AFn const__538;
  
  public static final Var const__539;
  
  public static final AFn const__542;
  
  public static final Keyword const__543;
  
  public static final Object const__544;
  
  public static final Object const__545;
  
  public static final Var const__546;
  
  public static final AFn const__549;
  
  public static final Var const__550;
  
  public static final AFn const__553;
  
  public static final Var const__554;
  
  public static final AFn const__557;
  
  public static final Var const__558;
  
  public static final AFn const__561;
  
  public static final Var const__562;
  
  public static final AFn const__565;
  
  public static final Var const__566;
  
  public static final AFn const__569;
  
  public static final Var const__570;
  
  public static final AFn const__573;
  
  public static final Var const__574;
  
  public static final AFn const__577;
  
  public static final Var const__578;
  
  public static final AFn const__581;
  
  public static final Var const__582;
  
  public static final AFn const__585;
  
  public static final Var const__586;
  
  public static final AFn const__589;
  
  public static final Var const__590;
  
  public static final AFn const__593;
  
  public static final Var const__594;
  
  public static final AFn const__597;
  
  public static final Var const__598;
  
  public static final AFn const__601;
  
  public static final Var const__602;
  
  public static final AFn const__605;
  
  public static void load() { // Byte code:
    //   0: getstatic clojure/spec/alpha__init.const__0 : Lclojure/lang/Var;
    //   3: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   6: checkcast clojure/lang/IFn
    //   9: getstatic clojure/spec/alpha__init.const__1 : Lclojure/lang/AFn;
    //   12: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   17: new clojure/spec/alpha$loading__6434__auto____1653
    //   20: dup
    //   21: invokespecial <init> : ()V
    //   24: checkcast clojure/lang/IFn
    //   27: invokeinterface invoke : ()Ljava/lang/Object;
    //   32: getstatic clojure/spec/alpha__init.const__1 : Lclojure/lang/AFn;
    //   35: checkcast clojure/lang/Symbol
    //   38: getstatic clojure/spec/alpha__init.const__2 : Lclojure/lang/AFn;
    //   41: invokevirtual equals : (Ljava/lang/Object;)Z
    //   44: ifeq -> 52
    //   47: aconst_null
    //   48: goto -> 67
    //   51: pop
    //   52: new clojure/spec/alpha$fn__1655
    //   55: dup
    //   56: invokespecial <init> : ()V
    //   59: checkcast java/util/concurrent/Callable
    //   62: invokestatic runInTransaction : (Ljava/util/concurrent/Callable;)Ljava/lang/Object;
    //   65: pop
    //   66: aconst_null
    //   67: getstatic clojure/spec/alpha__init.const__3 : Lclojure/lang/Var;
    //   70: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   73: checkcast clojure/lang/IFn
    //   76: getstatic clojure/spec/alpha__init.const__4 : Lclojure/lang/AFn;
    //   79: getstatic clojure/spec/alpha__init.const__5 : Lclojure/lang/AFn;
    //   82: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   87: getstatic clojure/spec/alpha__init.const__6 : Lclojure/lang/Var;
    //   90: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   93: invokevirtual set : (Ljava/lang/Object;)Ljava/lang/Object;
    //   96: getstatic clojure/spec/alpha__init.const__8 : Lclojure/lang/Var;
    //   99: iconst_1
    //   100: invokevirtual setDynamic : (Z)Lclojure/lang/Var;
    //   103: dup
    //   104: getstatic clojure/spec/alpha__init.const__16 : Lclojure/lang/AFn;
    //   107: checkcast clojure/lang/IPersistentMap
    //   110: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   113: dup
    //   114: getstatic clojure/spec/alpha__init.const__17 : Ljava/lang/Object;
    //   117: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   120: getstatic clojure/spec/alpha__init.const__18 : Lclojure/lang/Var;
    //   123: iconst_1
    //   124: invokevirtual setDynamic : (Z)Lclojure/lang/Var;
    //   127: dup
    //   128: getstatic clojure/spec/alpha__init.const__20 : Lclojure/lang/AFn;
    //   131: checkcast clojure/lang/IPersistentMap
    //   134: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   137: dup
    //   138: getstatic clojure/spec/alpha__init.const__21 : Ljava/lang/Object;
    //   141: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   144: getstatic clojure/spec/alpha__init.const__22 : Lclojure/lang/Var;
    //   147: iconst_1
    //   148: invokevirtual setDynamic : (Z)Lclojure/lang/Var;
    //   151: dup
    //   152: getstatic clojure/spec/alpha__init.const__24 : Lclojure/lang/AFn;
    //   155: checkcast clojure/lang/IPersistentMap
    //   158: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   161: dup
    //   162: getstatic clojure/spec/alpha__init.const__25 : Ljava/lang/Object;
    //   165: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   168: getstatic clojure/spec/alpha__init.const__26 : Lclojure/lang/Var;
    //   171: iconst_1
    //   172: invokevirtual setDynamic : (Z)Lclojure/lang/Var;
    //   175: dup
    //   176: getstatic clojure/spec/alpha__init.const__28 : Lclojure/lang/AFn;
    //   179: checkcast clojure/lang/IPersistentMap
    //   182: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   185: dup
    //   186: getstatic clojure/spec/alpha__init.const__29 : Ljava/lang/Object;
    //   189: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   192: new clojure/spec/alpha$fn__1669
    //   195: dup
    //   196: invokespecial <init> : ()V
    //   199: checkcast clojure/lang/IFn
    //   202: invokeinterface invoke : ()Ljava/lang/Object;
    //   207: getstatic clojure/spec/alpha__init.const__30 : Ljava/lang/Object;
    //   210: getstatic clojure/spec/alpha__init.const__31 : Lclojure/lang/Var;
    //   213: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   216: checkcast clojure/lang/IFn
    //   219: getstatic clojure/spec/alpha__init.const__32 : Lclojure/lang/Var;
    //   222: getstatic clojure/spec/alpha__init.const__33 : Lclojure/lang/Var;
    //   225: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   228: getstatic clojure/spec/alpha__init.const__15 : Lclojure/lang/Keyword;
    //   231: aconst_null
    //   232: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   237: getstatic clojure/spec/alpha__init.const__34 : Lclojure/lang/Var;
    //   240: checkcast clojure/lang/IFn
    //   243: getstatic clojure/spec/alpha__init.const__32 : Lclojure/lang/Var;
    //   246: getstatic clojure/spec/alpha__init.const__35 : Lclojure/lang/ISeq;
    //   249: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   254: getstatic clojure/spec/alpha__init.const__36 : Lclojure/lang/Var;
    //   257: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   260: checkcast clojure/lang/IFn
    //   263: getstatic clojure/spec/alpha__init.const__32 : Lclojure/lang/Var;
    //   266: getstatic clojure/spec/alpha__init.const__37 : Lclojure/lang/Var;
    //   269: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   272: getstatic clojure/spec/alpha__init.const__33 : Lclojure/lang/Var;
    //   275: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   278: checkcast clojure/lang/IFn
    //   281: getstatic clojure/spec/alpha__init.const__41 : Lclojure/lang/AFn;
    //   284: getstatic clojure/spec/alpha__init.const__42 : Lclojure/lang/Keyword;
    //   287: getstatic clojure/spec/alpha__init.const__43 : Lclojure/lang/AFn;
    //   290: getstatic clojure/spec/alpha__init.const__44 : Lclojure/lang/Keyword;
    //   293: getstatic clojure/spec/alpha__init.const__32 : Lclojure/lang/Var;
    //   296: getstatic clojure/spec/alpha__init.const__45 : Lclojure/lang/Keyword;
    //   299: getstatic clojure/spec/alpha__init.const__52 : Lclojure/lang/AFn;
    //   302: getstatic clojure/spec/alpha__init.const__53 : Lclojure/lang/Keyword;
    //   305: bipush #12
    //   307: anewarray java/lang/Object
    //   310: dup
    //   311: iconst_0
    //   312: getstatic clojure/spec/alpha__init.const__54 : Lclojure/lang/Var;
    //   315: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   318: checkcast clojure/lang/IFn
    //   321: getstatic clojure/spec/alpha__init.const__55 : Lclojure/lang/Var;
    //   324: invokevirtual get : ()Ljava/lang/Object;
    //   327: getstatic clojure/spec/alpha__init.const__56 : Lclojure/lang/Var;
    //   330: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   333: checkcast clojure/lang/IFn
    //   336: getstatic clojure/spec/alpha__init.const__57 : Lclojure/lang/AFn;
    //   339: getstatic clojure/spec/alpha__init.const__37 : Lclojure/lang/Var;
    //   342: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   345: checkcast clojure/lang/IFn
    //   348: getstatic clojure/spec/alpha__init.const__58 : Lclojure/lang/AFn;
    //   351: iconst_2
    //   352: anewarray java/lang/Object
    //   355: dup
    //   356: iconst_0
    //   357: getstatic clojure/spec/alpha__init.const__59 : Lclojure/lang/Keyword;
    //   360: aastore
    //   361: dup
    //   362: iconst_1
    //   363: getstatic clojure/spec/alpha__init.const__32 : Lclojure/lang/Var;
    //   366: aastore
    //   367: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   370: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   375: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   380: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   385: aastore
    //   386: dup
    //   387: iconst_1
    //   388: new clojure/spec/alpha$fn__1672
    //   391: dup
    //   392: invokespecial <init> : ()V
    //   395: aastore
    //   396: dup
    //   397: iconst_2
    //   398: getstatic clojure/spec/alpha__init.const__54 : Lclojure/lang/Var;
    //   401: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   404: checkcast clojure/lang/IFn
    //   407: getstatic clojure/spec/alpha__init.const__55 : Lclojure/lang/Var;
    //   410: invokevirtual get : ()Ljava/lang/Object;
    //   413: getstatic clojure/spec/alpha__init.const__56 : Lclojure/lang/Var;
    //   416: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   419: checkcast clojure/lang/IFn
    //   422: getstatic clojure/spec/alpha__init.const__60 : Lclojure/lang/AFn;
    //   425: getstatic clojure/spec/alpha__init.const__37 : Lclojure/lang/Var;
    //   428: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   431: checkcast clojure/lang/IFn
    //   434: getstatic clojure/spec/alpha__init.const__61 : Lclojure/lang/AFn;
    //   437: iconst_2
    //   438: anewarray java/lang/Object
    //   441: dup
    //   442: iconst_0
    //   443: getstatic clojure/spec/alpha__init.const__59 : Lclojure/lang/Keyword;
    //   446: aastore
    //   447: dup
    //   448: iconst_1
    //   449: getstatic clojure/spec/alpha__init.const__32 : Lclojure/lang/Var;
    //   452: aastore
    //   453: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   456: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   461: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   466: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   471: aastore
    //   472: dup
    //   473: iconst_3
    //   474: new clojure/spec/alpha$fn__1685
    //   477: dup
    //   478: invokespecial <init> : ()V
    //   481: aastore
    //   482: dup
    //   483: iconst_4
    //   484: getstatic clojure/spec/alpha__init.const__54 : Lclojure/lang/Var;
    //   487: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   490: checkcast clojure/lang/IFn
    //   493: getstatic clojure/spec/alpha__init.const__55 : Lclojure/lang/Var;
    //   496: invokevirtual get : ()Ljava/lang/Object;
    //   499: getstatic clojure/spec/alpha__init.const__56 : Lclojure/lang/Var;
    //   502: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   505: checkcast clojure/lang/IFn
    //   508: getstatic clojure/spec/alpha__init.const__62 : Lclojure/lang/AFn;
    //   511: getstatic clojure/spec/alpha__init.const__37 : Lclojure/lang/Var;
    //   514: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   517: checkcast clojure/lang/IFn
    //   520: getstatic clojure/spec/alpha__init.const__63 : Lclojure/lang/AFn;
    //   523: iconst_2
    //   524: anewarray java/lang/Object
    //   527: dup
    //   528: iconst_0
    //   529: getstatic clojure/spec/alpha__init.const__59 : Lclojure/lang/Keyword;
    //   532: aastore
    //   533: dup
    //   534: iconst_1
    //   535: getstatic clojure/spec/alpha__init.const__32 : Lclojure/lang/Var;
    //   538: aastore
    //   539: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   542: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   547: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   552: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   557: aastore
    //   558: dup
    //   559: iconst_5
    //   560: new clojure/spec/alpha$fn__1696
    //   563: dup
    //   564: invokespecial <init> : ()V
    //   567: aastore
    //   568: dup
    //   569: bipush #6
    //   571: getstatic clojure/spec/alpha__init.const__54 : Lclojure/lang/Var;
    //   574: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   577: checkcast clojure/lang/IFn
    //   580: getstatic clojure/spec/alpha__init.const__55 : Lclojure/lang/Var;
    //   583: invokevirtual get : ()Ljava/lang/Object;
    //   586: getstatic clojure/spec/alpha__init.const__56 : Lclojure/lang/Var;
    //   589: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   592: checkcast clojure/lang/IFn
    //   595: getstatic clojure/spec/alpha__init.const__64 : Lclojure/lang/AFn;
    //   598: getstatic clojure/spec/alpha__init.const__37 : Lclojure/lang/Var;
    //   601: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   604: checkcast clojure/lang/IFn
    //   607: getstatic clojure/spec/alpha__init.const__65 : Lclojure/lang/AFn;
    //   610: iconst_2
    //   611: anewarray java/lang/Object
    //   614: dup
    //   615: iconst_0
    //   616: getstatic clojure/spec/alpha__init.const__59 : Lclojure/lang/Keyword;
    //   619: aastore
    //   620: dup
    //   621: iconst_1
    //   622: getstatic clojure/spec/alpha__init.const__32 : Lclojure/lang/Var;
    //   625: aastore
    //   626: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   629: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   634: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   639: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   644: aastore
    //   645: dup
    //   646: bipush #7
    //   648: new clojure/spec/alpha$fn__1715
    //   651: dup
    //   652: invokespecial <init> : ()V
    //   655: aastore
    //   656: dup
    //   657: bipush #8
    //   659: getstatic clojure/spec/alpha__init.const__54 : Lclojure/lang/Var;
    //   662: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   665: checkcast clojure/lang/IFn
    //   668: getstatic clojure/spec/alpha__init.const__55 : Lclojure/lang/Var;
    //   671: invokevirtual get : ()Ljava/lang/Object;
    //   674: getstatic clojure/spec/alpha__init.const__56 : Lclojure/lang/Var;
    //   677: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   680: checkcast clojure/lang/IFn
    //   683: getstatic clojure/spec/alpha__init.const__66 : Lclojure/lang/AFn;
    //   686: getstatic clojure/spec/alpha__init.const__37 : Lclojure/lang/Var;
    //   689: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   692: checkcast clojure/lang/IFn
    //   695: getstatic clojure/spec/alpha__init.const__67 : Lclojure/lang/AFn;
    //   698: iconst_2
    //   699: anewarray java/lang/Object
    //   702: dup
    //   703: iconst_0
    //   704: getstatic clojure/spec/alpha__init.const__59 : Lclojure/lang/Keyword;
    //   707: aastore
    //   708: dup
    //   709: iconst_1
    //   710: getstatic clojure/spec/alpha__init.const__32 : Lclojure/lang/Var;
    //   713: aastore
    //   714: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   717: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   722: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   727: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   732: aastore
    //   733: dup
    //   734: bipush #9
    //   736: new clojure/spec/alpha$fn__1732
    //   739: dup
    //   740: invokespecial <init> : ()V
    //   743: aastore
    //   744: dup
    //   745: bipush #10
    //   747: getstatic clojure/spec/alpha__init.const__54 : Lclojure/lang/Var;
    //   750: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   753: checkcast clojure/lang/IFn
    //   756: getstatic clojure/spec/alpha__init.const__55 : Lclojure/lang/Var;
    //   759: invokevirtual get : ()Ljava/lang/Object;
    //   762: getstatic clojure/spec/alpha__init.const__56 : Lclojure/lang/Var;
    //   765: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   768: checkcast clojure/lang/IFn
    //   771: getstatic clojure/spec/alpha__init.const__68 : Lclojure/lang/AFn;
    //   774: getstatic clojure/spec/alpha__init.const__37 : Lclojure/lang/Var;
    //   777: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   780: checkcast clojure/lang/IFn
    //   783: getstatic clojure/spec/alpha__init.const__69 : Lclojure/lang/AFn;
    //   786: iconst_2
    //   787: anewarray java/lang/Object
    //   790: dup
    //   791: iconst_0
    //   792: getstatic clojure/spec/alpha__init.const__59 : Lclojure/lang/Keyword;
    //   795: aastore
    //   796: dup
    //   797: iconst_1
    //   798: getstatic clojure/spec/alpha__init.const__32 : Lclojure/lang/Var;
    //   801: aastore
    //   802: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   805: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   810: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   815: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   820: aastore
    //   821: dup
    //   822: bipush #11
    //   824: new clojure/spec/alpha$fn__1745
    //   827: dup
    //   828: invokespecial <init> : ()V
    //   831: aastore
    //   832: invokestatic map : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   835: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   840: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   845: getstatic clojure/spec/alpha__init.const__70 : Lclojure/lang/Var;
    //   848: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   851: checkcast clojure/lang/IFn
    //   854: getstatic clojure/spec/alpha__init.const__32 : Lclojure/lang/Var;
    //   857: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   860: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   865: getstatic clojure/spec/alpha__init.const__71 : Lclojure/lang/AFn;
    //   868: new clojure/spec/alpha$fn__1758
    //   871: dup
    //   872: invokespecial <init> : ()V
    //   875: checkcast clojure/lang/IFn
    //   878: invokeinterface invoke : ()Ljava/lang/Object;
    //   883: getstatic clojure/spec/alpha__init.const__72 : Lclojure/lang/Var;
    //   886: dup
    //   887: getstatic clojure/spec/alpha__init.const__77 : Lclojure/lang/AFn;
    //   890: checkcast clojure/lang/IPersistentMap
    //   893: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   896: dup
    //   897: new clojure/spec/alpha$deep_resolve
    //   900: dup
    //   901: invokespecial <init> : ()V
    //   904: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   907: getstatic clojure/spec/alpha__init.const__78 : Lclojure/lang/Var;
    //   910: dup
    //   911: getstatic clojure/spec/alpha__init.const__81 : Lclojure/lang/AFn;
    //   914: checkcast clojure/lang/IPersistentMap
    //   917: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   920: dup
    //   921: new clojure/spec/alpha$reg_resolve
    //   924: dup
    //   925: invokespecial <init> : ()V
    //   928: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   931: getstatic clojure/spec/alpha__init.const__82 : Lclojure/lang/Var;
    //   934: dup
    //   935: getstatic clojure/spec/alpha__init.const__85 : Lclojure/lang/AFn;
    //   938: checkcast clojure/lang/IPersistentMap
    //   941: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   944: dup
    //   945: new clojure/spec/alpha$reg_resolve_BANG_
    //   948: dup
    //   949: invokespecial <init> : ()V
    //   952: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   955: getstatic clojure/spec/alpha__init.const__86 : Lclojure/lang/Var;
    //   958: dup
    //   959: getstatic clojure/spec/alpha__init.const__89 : Lclojure/lang/AFn;
    //   962: checkcast clojure/lang/IPersistentMap
    //   965: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   968: dup
    //   969: new clojure/spec/alpha$spec_QMARK_
    //   972: dup
    //   973: invokespecial <init> : ()V
    //   976: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   979: getstatic clojure/spec/alpha__init.const__90 : Lclojure/lang/Var;
    //   982: dup
    //   983: getstatic clojure/spec/alpha__init.const__93 : Lclojure/lang/AFn;
    //   986: checkcast clojure/lang/IPersistentMap
    //   989: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   992: dup
    //   993: new clojure/spec/alpha$regex_QMARK_
    //   996: dup
    //   997: invokespecial <init> : ()V
    //   1000: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1003: getstatic clojure/spec/alpha__init.const__94 : Lclojure/lang/Var;
    //   1006: dup
    //   1007: getstatic clojure/spec/alpha__init.const__97 : Lclojure/lang/AFn;
    //   1010: checkcast clojure/lang/IPersistentMap
    //   1013: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1016: dup
    //   1017: new clojure/spec/alpha$with_name
    //   1020: dup
    //   1021: invokespecial <init> : ()V
    //   1024: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1027: getstatic clojure/spec/alpha__init.const__98 : Lclojure/lang/Var;
    //   1030: dup
    //   1031: getstatic clojure/spec/alpha__init.const__101 : Lclojure/lang/AFn;
    //   1034: checkcast clojure/lang/IPersistentMap
    //   1037: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1040: dup
    //   1041: new clojure/spec/alpha$spec_name
    //   1044: dup
    //   1045: invokespecial <init> : ()V
    //   1048: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1051: getstatic clojure/spec/alpha__init.const__102 : Lclojure/lang/Var;
    //   1054: dup
    //   1055: getstatic clojure/spec/alpha__init.const__105 : Lclojure/lang/AFn;
    //   1058: checkcast clojure/lang/IPersistentMap
    //   1061: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1064: getstatic clojure/spec/alpha__init.const__106 : Lclojure/lang/Var;
    //   1067: dup
    //   1068: getstatic clojure/spec/alpha__init.const__108 : Lclojure/lang/AFn;
    //   1071: checkcast clojure/lang/IPersistentMap
    //   1074: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1077: getstatic clojure/spec/alpha__init.const__109 : Lclojure/lang/Var;
    //   1080: dup
    //   1081: getstatic clojure/spec/alpha__init.const__112 : Lclojure/lang/AFn;
    //   1084: checkcast clojure/lang/IPersistentMap
    //   1087: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1090: dup
    //   1091: new clojure/spec/alpha$maybe_spec
    //   1094: dup
    //   1095: invokespecial <init> : ()V
    //   1098: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1101: getstatic clojure/spec/alpha__init.const__113 : Lclojure/lang/Var;
    //   1104: dup
    //   1105: getstatic clojure/spec/alpha__init.const__116 : Lclojure/lang/AFn;
    //   1108: checkcast clojure/lang/IPersistentMap
    //   1111: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1114: dup
    //   1115: new clojure/spec/alpha$the_spec
    //   1118: dup
    //   1119: invokespecial <init> : ()V
    //   1122: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1125: new clojure/spec/alpha$fn__1779
    //   1128: dup
    //   1129: invokespecial <init> : ()V
    //   1132: checkcast clojure/lang/IFn
    //   1135: invokeinterface invoke : ()Ljava/lang/Object;
    //   1140: getstatic clojure/spec/alpha__init.const__117 : Ljava/lang/Object;
    //   1143: getstatic clojure/spec/alpha__init.const__31 : Lclojure/lang/Var;
    //   1146: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1149: checkcast clojure/lang/IFn
    //   1152: getstatic clojure/spec/alpha__init.const__118 : Lclojure/lang/Var;
    //   1155: getstatic clojure/spec/alpha__init.const__33 : Lclojure/lang/Var;
    //   1158: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1161: getstatic clojure/spec/alpha__init.const__15 : Lclojure/lang/Keyword;
    //   1164: aconst_null
    //   1165: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1170: getstatic clojure/spec/alpha__init.const__34 : Lclojure/lang/Var;
    //   1173: checkcast clojure/lang/IFn
    //   1176: getstatic clojure/spec/alpha__init.const__118 : Lclojure/lang/Var;
    //   1179: getstatic clojure/spec/alpha__init.const__119 : Lclojure/lang/ISeq;
    //   1182: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1187: getstatic clojure/spec/alpha__init.const__36 : Lclojure/lang/Var;
    //   1190: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1193: checkcast clojure/lang/IFn
    //   1196: getstatic clojure/spec/alpha__init.const__118 : Lclojure/lang/Var;
    //   1199: getstatic clojure/spec/alpha__init.const__37 : Lclojure/lang/Var;
    //   1202: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1205: getstatic clojure/spec/alpha__init.const__33 : Lclojure/lang/Var;
    //   1208: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1211: checkcast clojure/lang/IFn
    //   1214: getstatic clojure/spec/alpha__init.const__121 : Lclojure/lang/AFn;
    //   1217: getstatic clojure/spec/alpha__init.const__42 : Lclojure/lang/Keyword;
    //   1220: getstatic clojure/spec/alpha__init.const__122 : Lclojure/lang/AFn;
    //   1223: getstatic clojure/spec/alpha__init.const__44 : Lclojure/lang/Keyword;
    //   1226: getstatic clojure/spec/alpha__init.const__118 : Lclojure/lang/Var;
    //   1229: getstatic clojure/spec/alpha__init.const__45 : Lclojure/lang/Keyword;
    //   1232: getstatic clojure/spec/alpha__init.const__124 : Lclojure/lang/AFn;
    //   1235: getstatic clojure/spec/alpha__init.const__53 : Lclojure/lang/Keyword;
    //   1238: iconst_2
    //   1239: anewarray java/lang/Object
    //   1242: dup
    //   1243: iconst_0
    //   1244: getstatic clojure/spec/alpha__init.const__54 : Lclojure/lang/Var;
    //   1247: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1250: checkcast clojure/lang/IFn
    //   1253: getstatic clojure/spec/alpha__init.const__55 : Lclojure/lang/Var;
    //   1256: invokevirtual get : ()Ljava/lang/Object;
    //   1259: getstatic clojure/spec/alpha__init.const__56 : Lclojure/lang/Var;
    //   1262: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1265: checkcast clojure/lang/IFn
    //   1268: getstatic clojure/spec/alpha__init.const__125 : Lclojure/lang/AFn;
    //   1271: getstatic clojure/spec/alpha__init.const__37 : Lclojure/lang/Var;
    //   1274: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1277: checkcast clojure/lang/IFn
    //   1280: getstatic clojure/spec/alpha__init.const__126 : Lclojure/lang/AFn;
    //   1283: iconst_2
    //   1284: anewarray java/lang/Object
    //   1287: dup
    //   1288: iconst_0
    //   1289: getstatic clojure/spec/alpha__init.const__59 : Lclojure/lang/Keyword;
    //   1292: aastore
    //   1293: dup
    //   1294: iconst_1
    //   1295: getstatic clojure/spec/alpha__init.const__118 : Lclojure/lang/Var;
    //   1298: aastore
    //   1299: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   1302: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1307: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1312: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1317: aastore
    //   1318: dup
    //   1319: iconst_1
    //   1320: new clojure/spec/alpha$fn__1782
    //   1323: dup
    //   1324: invokespecial <init> : ()V
    //   1327: aastore
    //   1328: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   1331: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1336: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1341: getstatic clojure/spec/alpha__init.const__70 : Lclojure/lang/Var;
    //   1344: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1347: checkcast clojure/lang/IFn
    //   1350: getstatic clojure/spec/alpha__init.const__118 : Lclojure/lang/Var;
    //   1353: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1356: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1361: getstatic clojure/spec/alpha__init.const__127 : Lclojure/lang/AFn;
    //   1364: getstatic clojure/spec/alpha__init.const__128 : Lclojure/lang/Var;
    //   1367: dup
    //   1368: getstatic clojure/spec/alpha__init.const__131 : Lclojure/lang/AFn;
    //   1371: checkcast clojure/lang/IPersistentMap
    //   1374: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1377: dup
    //   1378: new clojure/spec/alpha$fn_sym
    //   1381: dup
    //   1382: invokespecial <init> : ()V
    //   1385: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1388: getstatic clojure/spec/alpha__init.const__132 : Lclojure/lang/Var;
    //   1391: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1394: checkcast clojure/lang/IFn
    //   1397: getstatic clojure/spec/alpha__init.const__133 : Ljava/lang/Object;
    //   1400: getstatic clojure/spec/alpha__init.const__118 : Lclojure/lang/Var;
    //   1403: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1406: iconst_2
    //   1407: anewarray java/lang/Object
    //   1410: dup
    //   1411: iconst_0
    //   1412: getstatic clojure/spec/alpha__init.const__123 : Lclojure/lang/Keyword;
    //   1415: aastore
    //   1416: dup
    //   1417: iconst_1
    //   1418: new clojure/spec/alpha$fn__1803
    //   1421: dup
    //   1422: invokespecial <init> : ()V
    //   1425: aastore
    //   1426: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   1429: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1434: getstatic clojure/spec/alpha__init.const__132 : Lclojure/lang/Var;
    //   1437: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1440: checkcast clojure/lang/IFn
    //   1443: getstatic clojure/spec/alpha__init.const__134 : Ljava/lang/Object;
    //   1446: getstatic clojure/spec/alpha__init.const__118 : Lclojure/lang/Var;
    //   1449: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1452: iconst_2
    //   1453: anewarray java/lang/Object
    //   1456: dup
    //   1457: iconst_0
    //   1458: getstatic clojure/spec/alpha__init.const__123 : Lclojure/lang/Keyword;
    //   1461: aastore
    //   1462: dup
    //   1463: iconst_1
    //   1464: new clojure/spec/alpha$fn__1805
    //   1467: dup
    //   1468: invokespecial <init> : ()V
    //   1471: aastore
    //   1472: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   1475: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1480: getstatic clojure/spec/alpha__init.const__132 : Lclojure/lang/Var;
    //   1483: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1486: checkcast clojure/lang/IFn
    //   1489: getstatic clojure/spec/alpha__init.const__135 : Ljava/lang/Object;
    //   1492: getstatic clojure/spec/alpha__init.const__118 : Lclojure/lang/Var;
    //   1495: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1498: iconst_2
    //   1499: anewarray java/lang/Object
    //   1502: dup
    //   1503: iconst_0
    //   1504: getstatic clojure/spec/alpha__init.const__123 : Lclojure/lang/Keyword;
    //   1507: aastore
    //   1508: dup
    //   1509: iconst_1
    //   1510: new clojure/spec/alpha$fn__1807
    //   1513: dup
    //   1514: invokespecial <init> : ()V
    //   1517: aastore
    //   1518: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   1521: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1526: getstatic clojure/spec/alpha__init.const__132 : Lclojure/lang/Var;
    //   1529: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1532: checkcast clojure/lang/IFn
    //   1535: getstatic clojure/spec/alpha__init.const__136 : Ljava/lang/Object;
    //   1538: getstatic clojure/spec/alpha__init.const__118 : Lclojure/lang/Var;
    //   1541: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1544: iconst_2
    //   1545: anewarray java/lang/Object
    //   1548: dup
    //   1549: iconst_0
    //   1550: getstatic clojure/spec/alpha__init.const__123 : Lclojure/lang/Keyword;
    //   1553: aastore
    //   1554: dup
    //   1555: iconst_1
    //   1556: new clojure/spec/alpha$fn__1809
    //   1559: dup
    //   1560: invokespecial <init> : ()V
    //   1563: aastore
    //   1564: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   1567: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1572: getstatic clojure/spec/alpha__init.const__137 : Lclojure/lang/Var;
    //   1575: dup
    //   1576: getstatic clojure/spec/alpha__init.const__140 : Lclojure/lang/AFn;
    //   1579: checkcast clojure/lang/IPersistentMap
    //   1582: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1585: dup
    //   1586: new clojure/spec/alpha$specize
    //   1589: dup
    //   1590: invokespecial <init> : ()V
    //   1593: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1596: getstatic clojure/spec/alpha__init.const__141 : Lclojure/lang/Var;
    //   1599: dup
    //   1600: getstatic clojure/spec/alpha__init.const__144 : Lclojure/lang/AFn;
    //   1603: checkcast clojure/lang/IPersistentMap
    //   1606: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1609: dup
    //   1610: new clojure/spec/alpha$invalid_QMARK_
    //   1613: dup
    //   1614: invokespecial <init> : ()V
    //   1617: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1620: getstatic clojure/spec/alpha__init.const__145 : Lclojure/lang/Var;
    //   1623: dup
    //   1624: getstatic clojure/spec/alpha__init.const__148 : Lclojure/lang/AFn;
    //   1627: checkcast clojure/lang/IPersistentMap
    //   1630: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1633: dup
    //   1634: new clojure/spec/alpha$conform
    //   1637: dup
    //   1638: invokespecial <init> : ()V
    //   1641: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1644: getstatic clojure/spec/alpha__init.const__149 : Lclojure/lang/Var;
    //   1647: dup
    //   1648: getstatic clojure/spec/alpha__init.const__152 : Lclojure/lang/AFn;
    //   1651: checkcast clojure/lang/IPersistentMap
    //   1654: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1657: dup
    //   1658: new clojure/spec/alpha$unform
    //   1661: dup
    //   1662: invokespecial <init> : ()V
    //   1665: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1668: getstatic clojure/spec/alpha__init.const__153 : Lclojure/lang/Var;
    //   1671: dup
    //   1672: getstatic clojure/spec/alpha__init.const__156 : Lclojure/lang/AFn;
    //   1675: checkcast clojure/lang/IPersistentMap
    //   1678: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1681: dup
    //   1682: new clojure/spec/alpha$form
    //   1685: dup
    //   1686: invokespecial <init> : ()V
    //   1689: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1692: getstatic clojure/spec/alpha__init.const__157 : Lclojure/lang/Var;
    //   1695: dup
    //   1696: getstatic clojure/spec/alpha__init.const__160 : Lclojure/lang/AFn;
    //   1699: checkcast clojure/lang/IPersistentMap
    //   1702: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1705: dup
    //   1706: new clojure/spec/alpha$abbrev
    //   1709: dup
    //   1710: invokespecial <init> : ()V
    //   1713: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1716: getstatic clojure/spec/alpha__init.const__161 : Lclojure/lang/Var;
    //   1719: dup
    //   1720: getstatic clojure/spec/alpha__init.const__164 : Lclojure/lang/AFn;
    //   1723: checkcast clojure/lang/IPersistentMap
    //   1726: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1729: dup
    //   1730: new clojure/spec/alpha$describe
    //   1733: dup
    //   1734: invokespecial <init> : ()V
    //   1737: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1740: getstatic clojure/spec/alpha__init.const__165 : Lclojure/lang/Var;
    //   1743: dup
    //   1744: getstatic clojure/spec/alpha__init.const__168 : Lclojure/lang/AFn;
    //   1747: checkcast clojure/lang/IPersistentMap
    //   1750: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1753: dup
    //   1754: new clojure/spec/alpha$with_gen
    //   1757: dup
    //   1758: invokespecial <init> : ()V
    //   1761: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1764: getstatic clojure/spec/alpha__init.const__169 : Lclojure/lang/Var;
    //   1767: dup
    //   1768: getstatic clojure/spec/alpha__init.const__172 : Lclojure/lang/AFn;
    //   1771: checkcast clojure/lang/IPersistentMap
    //   1774: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1777: dup
    //   1778: new clojure/spec/alpha$explain_data_STAR_
    //   1781: dup
    //   1782: invokespecial <init> : ()V
    //   1785: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1788: getstatic clojure/spec/alpha__init.const__173 : Lclojure/lang/Var;
    //   1791: dup
    //   1792: getstatic clojure/spec/alpha__init.const__176 : Lclojure/lang/AFn;
    //   1795: checkcast clojure/lang/IPersistentMap
    //   1798: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1801: dup
    //   1802: new clojure/spec/alpha$explain_data
    //   1805: dup
    //   1806: invokespecial <init> : ()V
    //   1809: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1812: getstatic clojure/spec/alpha__init.const__177 : Lclojure/lang/Var;
    //   1815: dup
    //   1816: getstatic clojure/spec/alpha__init.const__180 : Lclojure/lang/AFn;
    //   1819: checkcast clojure/lang/IPersistentMap
    //   1822: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1825: dup
    //   1826: new clojure/spec/alpha$explain_printer
    //   1829: dup
    //   1830: invokespecial <init> : ()V
    //   1833: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1836: getstatic clojure/spec/alpha__init.const__181 : Lclojure/lang/Var;
    //   1839: iconst_1
    //   1840: invokevirtual setDynamic : (Z)Lclojure/lang/Var;
    //   1843: dup
    //   1844: getstatic clojure/spec/alpha__init.const__183 : Lclojure/lang/AFn;
    //   1847: checkcast clojure/lang/IPersistentMap
    //   1850: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1853: dup
    //   1854: getstatic clojure/spec/alpha__init.const__177 : Lclojure/lang/Var;
    //   1857: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1860: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1863: getstatic clojure/spec/alpha__init.const__184 : Lclojure/lang/Var;
    //   1866: dup
    //   1867: getstatic clojure/spec/alpha__init.const__187 : Lclojure/lang/AFn;
    //   1870: checkcast clojure/lang/IPersistentMap
    //   1873: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1876: dup
    //   1877: new clojure/spec/alpha$explain_out
    //   1880: dup
    //   1881: invokespecial <init> : ()V
    //   1884: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1887: getstatic clojure/spec/alpha__init.const__188 : Lclojure/lang/Var;
    //   1890: dup
    //   1891: getstatic clojure/spec/alpha__init.const__191 : Lclojure/lang/AFn;
    //   1894: checkcast clojure/lang/IPersistentMap
    //   1897: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1900: dup
    //   1901: new clojure/spec/alpha$explain
    //   1904: dup
    //   1905: invokespecial <init> : ()V
    //   1908: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1911: getstatic clojure/spec/alpha__init.const__192 : Lclojure/lang/Var;
    //   1914: dup
    //   1915: getstatic clojure/spec/alpha__init.const__195 : Lclojure/lang/AFn;
    //   1918: checkcast clojure/lang/IPersistentMap
    //   1921: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1924: dup
    //   1925: new clojure/spec/alpha$explain_str
    //   1928: dup
    //   1929: invokespecial <init> : ()V
    //   1932: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1935: getstatic clojure/spec/alpha__init.const__196 : Lclojure/lang/Var;
    //   1938: dup
    //   1939: getstatic clojure/spec/alpha__init.const__198 : Lclojure/lang/AFn;
    //   1942: checkcast clojure/lang/IPersistentMap
    //   1945: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1948: getstatic clojure/spec/alpha__init.const__199 : Lclojure/lang/Var;
    //   1951: dup
    //   1952: getstatic clojure/spec/alpha__init.const__202 : Lclojure/lang/AFn;
    //   1955: checkcast clojure/lang/IPersistentMap
    //   1958: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1961: dup
    //   1962: new clojure/spec/alpha$gensub
    //   1965: dup
    //   1966: invokespecial <init> : ()V
    //   1969: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1972: getstatic clojure/spec/alpha__init.const__203 : Lclojure/lang/Var;
    //   1975: dup
    //   1976: getstatic clojure/spec/alpha__init.const__206 : Lclojure/lang/AFn;
    //   1979: checkcast clojure/lang/IPersistentMap
    //   1982: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1985: dup
    //   1986: new clojure/spec/alpha$gen
    //   1989: dup
    //   1990: invokespecial <init> : ()V
    //   1993: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1996: getstatic clojure/spec/alpha__init.const__207 : Lclojure/lang/Var;
    //   1999: dup
    //   2000: getstatic clojure/spec/alpha__init.const__210 : Lclojure/lang/AFn;
    //   2003: checkcast clojure/lang/IPersistentMap
    //   2006: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2009: dup
    //   2010: new clojure/spec/alpha$__GT_sym
    //   2013: dup
    //   2014: invokespecial <init> : ()V
    //   2017: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2020: getstatic clojure/spec/alpha__init.const__211 : Lclojure/lang/Var;
    //   2023: dup
    //   2024: getstatic clojure/spec/alpha__init.const__214 : Lclojure/lang/AFn;
    //   2027: checkcast clojure/lang/IPersistentMap
    //   2030: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2033: dup
    //   2034: new clojure/spec/alpha$unfn
    //   2037: dup
    //   2038: invokespecial <init> : ()V
    //   2041: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2044: getstatic clojure/spec/alpha__init.const__215 : Lclojure/lang/Var;
    //   2047: dup
    //   2048: getstatic clojure/spec/alpha__init.const__218 : Lclojure/lang/AFn;
    //   2051: checkcast clojure/lang/IPersistentMap
    //   2054: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2057: dup
    //   2058: new clojure/spec/alpha$res
    //   2061: dup
    //   2062: invokespecial <init> : ()V
    //   2065: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2068: getstatic clojure/spec/alpha__init.const__219 : Lclojure/lang/Var;
    //   2071: dup
    //   2072: getstatic clojure/spec/alpha__init.const__223 : Lclojure/lang/AFn;
    //   2075: checkcast clojure/lang/IPersistentMap
    //   2078: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2081: dup
    //   2082: new clojure/spec/alpha$def_impl
    //   2085: dup
    //   2086: invokespecial <init> : ()V
    //   2089: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2092: getstatic clojure/spec/alpha__init.const__224 : Lclojure/lang/Var;
    //   2095: dup
    //   2096: getstatic clojure/spec/alpha__init.const__227 : Lclojure/lang/AFn;
    //   2099: checkcast clojure/lang/IPersistentMap
    //   2102: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2105: dup
    //   2106: new clojure/spec/alpha$ns_qualify
    //   2109: dup
    //   2110: invokespecial <init> : ()V
    //   2113: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2116: getstatic clojure/spec/alpha__init.const__7 : Lclojure/lang/Var;
    //   2119: dup
    //   2120: getstatic clojure/spec/alpha__init.const__230 : Lclojure/lang/AFn;
    //   2123: checkcast clojure/lang/IPersistentMap
    //   2126: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2129: dup
    //   2130: new clojure/spec/alpha$def
    //   2133: dup
    //   2134: invokespecial <init> : ()V
    //   2137: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2140: getstatic clojure/spec/alpha__init.const__7 : Lclojure/lang/Var;
    //   2143: checkcast clojure/lang/Var
    //   2146: invokevirtual setMacro : ()V
    //   2149: aconst_null
    //   2150: getstatic clojure/spec/alpha__init.const__7 : Lclojure/lang/Var;
    //   2153: getstatic clojure/spec/alpha__init.const__231 : Lclojure/lang/Var;
    //   2156: dup
    //   2157: getstatic clojure/spec/alpha__init.const__234 : Lclojure/lang/AFn;
    //   2160: checkcast clojure/lang/IPersistentMap
    //   2163: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2166: dup
    //   2167: new clojure/spec/alpha$registry
    //   2170: dup
    //   2171: invokespecial <init> : ()V
    //   2174: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2177: getstatic clojure/spec/alpha__init.const__235 : Lclojure/lang/Var;
    //   2180: dup
    //   2181: getstatic clojure/spec/alpha__init.const__238 : Lclojure/lang/AFn;
    //   2184: checkcast clojure/lang/IPersistentMap
    //   2187: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2190: dup
    //   2191: new clojure/spec/alpha$get_spec
    //   2194: dup
    //   2195: invokespecial <init> : ()V
    //   2198: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2201: getstatic clojure/spec/alpha__init.const__239 : Lclojure/lang/Var;
    //   2204: dup
    //   2205: getstatic clojure/spec/alpha__init.const__242 : Lclojure/lang/AFn;
    //   2208: checkcast clojure/lang/IPersistentMap
    //   2211: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2214: dup
    //   2215: new clojure/spec/alpha$spec
    //   2218: dup
    //   2219: invokespecial <init> : ()V
    //   2222: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2225: getstatic clojure/spec/alpha__init.const__239 : Lclojure/lang/Var;
    //   2228: checkcast clojure/lang/Var
    //   2231: invokevirtual setMacro : ()V
    //   2234: aconst_null
    //   2235: getstatic clojure/spec/alpha__init.const__239 : Lclojure/lang/Var;
    //   2238: getstatic clojure/spec/alpha__init.const__243 : Lclojure/lang/Var;
    //   2241: dup
    //   2242: getstatic clojure/spec/alpha__init.const__246 : Lclojure/lang/AFn;
    //   2245: checkcast clojure/lang/IPersistentMap
    //   2248: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2251: dup
    //   2252: new clojure/spec/alpha$multi_spec
    //   2255: dup
    //   2256: invokespecial <init> : ()V
    //   2259: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2262: getstatic clojure/spec/alpha__init.const__243 : Lclojure/lang/Var;
    //   2265: checkcast clojure/lang/Var
    //   2268: invokevirtual setMacro : ()V
    //   2271: aconst_null
    //   2272: getstatic clojure/spec/alpha__init.const__243 : Lclojure/lang/Var;
    //   2275: getstatic clojure/spec/alpha__init.const__247 : Lclojure/lang/Var;
    //   2278: dup
    //   2279: getstatic clojure/spec/alpha__init.const__250 : Lclojure/lang/AFn;
    //   2282: checkcast clojure/lang/IPersistentMap
    //   2285: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2288: dup
    //   2289: new clojure/spec/alpha$keys
    //   2292: dup
    //   2293: invokespecial <init> : ()V
    //   2296: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2299: getstatic clojure/spec/alpha__init.const__247 : Lclojure/lang/Var;
    //   2302: checkcast clojure/lang/Var
    //   2305: invokevirtual setMacro : ()V
    //   2308: aconst_null
    //   2309: getstatic clojure/spec/alpha__init.const__247 : Lclojure/lang/Var;
    //   2312: getstatic clojure/spec/alpha__init.const__251 : Lclojure/lang/Var;
    //   2315: dup
    //   2316: getstatic clojure/spec/alpha__init.const__254 : Lclojure/lang/AFn;
    //   2319: checkcast clojure/lang/IPersistentMap
    //   2322: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2325: dup
    //   2326: new clojure/spec/alpha$or
    //   2329: dup
    //   2330: invokespecial <init> : ()V
    //   2333: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2336: getstatic clojure/spec/alpha__init.const__251 : Lclojure/lang/Var;
    //   2339: checkcast clojure/lang/Var
    //   2342: invokevirtual setMacro : ()V
    //   2345: aconst_null
    //   2346: getstatic clojure/spec/alpha__init.const__251 : Lclojure/lang/Var;
    //   2349: getstatic clojure/spec/alpha__init.const__255 : Lclojure/lang/Var;
    //   2352: dup
    //   2353: getstatic clojure/spec/alpha__init.const__258 : Lclojure/lang/AFn;
    //   2356: checkcast clojure/lang/IPersistentMap
    //   2359: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2362: dup
    //   2363: new clojure/spec/alpha$and
    //   2366: dup
    //   2367: invokespecial <init> : ()V
    //   2370: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2373: getstatic clojure/spec/alpha__init.const__255 : Lclojure/lang/Var;
    //   2376: checkcast clojure/lang/Var
    //   2379: invokevirtual setMacro : ()V
    //   2382: aconst_null
    //   2383: getstatic clojure/spec/alpha__init.const__255 : Lclojure/lang/Var;
    //   2386: getstatic clojure/spec/alpha__init.const__259 : Lclojure/lang/Var;
    //   2389: dup
    //   2390: getstatic clojure/spec/alpha__init.const__262 : Lclojure/lang/AFn;
    //   2393: checkcast clojure/lang/IPersistentMap
    //   2396: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2399: dup
    //   2400: new clojure/spec/alpha$merge
    //   2403: dup
    //   2404: invokespecial <init> : ()V
    //   2407: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2410: getstatic clojure/spec/alpha__init.const__259 : Lclojure/lang/Var;
    //   2413: checkcast clojure/lang/Var
    //   2416: invokevirtual setMacro : ()V
    //   2419: aconst_null
    //   2420: getstatic clojure/spec/alpha__init.const__259 : Lclojure/lang/Var;
    //   2423: getstatic clojure/spec/alpha__init.const__263 : Lclojure/lang/Var;
    //   2426: dup
    //   2427: getstatic clojure/spec/alpha__init.const__266 : Lclojure/lang/AFn;
    //   2430: checkcast clojure/lang/IPersistentMap
    //   2433: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2436: dup
    //   2437: new clojure/spec/alpha$res_kind
    //   2440: dup
    //   2441: invokespecial <init> : ()V
    //   2444: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2447: getstatic clojure/spec/alpha__init.const__267 : Lclojure/lang/Var;
    //   2450: dup
    //   2451: getstatic clojure/spec/alpha__init.const__270 : Lclojure/lang/AFn;
    //   2454: checkcast clojure/lang/IPersistentMap
    //   2457: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2460: dup
    //   2461: new clojure/spec/alpha$every
    //   2464: dup
    //   2465: invokespecial <init> : ()V
    //   2468: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2471: getstatic clojure/spec/alpha__init.const__267 : Lclojure/lang/Var;
    //   2474: checkcast clojure/lang/Var
    //   2477: invokevirtual setMacro : ()V
    //   2480: aconst_null
    //   2481: getstatic clojure/spec/alpha__init.const__267 : Lclojure/lang/Var;
    //   2484: getstatic clojure/spec/alpha__init.const__271 : Lclojure/lang/Var;
    //   2487: dup
    //   2488: getstatic clojure/spec/alpha__init.const__274 : Lclojure/lang/AFn;
    //   2491: checkcast clojure/lang/IPersistentMap
    //   2494: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2497: dup
    //   2498: new clojure/spec/alpha$every_kv
    //   2501: dup
    //   2502: invokespecial <init> : ()V
    //   2505: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2508: getstatic clojure/spec/alpha__init.const__271 : Lclojure/lang/Var;
    //   2511: checkcast clojure/lang/Var
    //   2514: invokevirtual setMacro : ()V
    //   2517: aconst_null
    //   2518: getstatic clojure/spec/alpha__init.const__271 : Lclojure/lang/Var;
    //   2521: getstatic clojure/spec/alpha__init.const__275 : Lclojure/lang/Var;
    //   2524: dup
    //   2525: getstatic clojure/spec/alpha__init.const__278 : Lclojure/lang/AFn;
    //   2528: checkcast clojure/lang/IPersistentMap
    //   2531: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2534: dup
    //   2535: new clojure/spec/alpha$coll_of
    //   2538: dup
    //   2539: invokespecial <init> : ()V
    //   2542: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2545: getstatic clojure/spec/alpha__init.const__275 : Lclojure/lang/Var;
    //   2548: checkcast clojure/lang/Var
    //   2551: invokevirtual setMacro : ()V
    //   2554: aconst_null
    //   2555: getstatic clojure/spec/alpha__init.const__275 : Lclojure/lang/Var;
    //   2558: getstatic clojure/spec/alpha__init.const__279 : Lclojure/lang/Var;
    //   2561: dup
    //   2562: getstatic clojure/spec/alpha__init.const__282 : Lclojure/lang/AFn;
    //   2565: checkcast clojure/lang/IPersistentMap
    //   2568: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2571: dup
    //   2572: new clojure/spec/alpha$map_of
    //   2575: dup
    //   2576: invokespecial <init> : ()V
    //   2579: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2582: getstatic clojure/spec/alpha__init.const__279 : Lclojure/lang/Var;
    //   2585: checkcast clojure/lang/Var
    //   2588: invokevirtual setMacro : ()V
    //   2591: aconst_null
    //   2592: getstatic clojure/spec/alpha__init.const__279 : Lclojure/lang/Var;
    //   2595: getstatic clojure/spec/alpha__init.const__283 : Lclojure/lang/Var;
    //   2598: dup
    //   2599: getstatic clojure/spec/alpha__init.const__286 : Lclojure/lang/AFn;
    //   2602: checkcast clojure/lang/IPersistentMap
    //   2605: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2608: dup
    //   2609: new clojure/spec/alpha$_STAR_
    //   2612: dup
    //   2613: invokespecial <init> : ()V
    //   2616: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2619: getstatic clojure/spec/alpha__init.const__283 : Lclojure/lang/Var;
    //   2622: checkcast clojure/lang/Var
    //   2625: invokevirtual setMacro : ()V
    //   2628: aconst_null
    //   2629: getstatic clojure/spec/alpha__init.const__283 : Lclojure/lang/Var;
    //   2632: getstatic clojure/spec/alpha__init.const__287 : Lclojure/lang/Var;
    //   2635: dup
    //   2636: getstatic clojure/spec/alpha__init.const__290 : Lclojure/lang/AFn;
    //   2639: checkcast clojure/lang/IPersistentMap
    //   2642: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2645: dup
    //   2646: new clojure/spec/alpha$_PLUS_
    //   2649: dup
    //   2650: invokespecial <init> : ()V
    //   2653: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2656: getstatic clojure/spec/alpha__init.const__287 : Lclojure/lang/Var;
    //   2659: checkcast clojure/lang/Var
    //   2662: invokevirtual setMacro : ()V
    //   2665: aconst_null
    //   2666: getstatic clojure/spec/alpha__init.const__287 : Lclojure/lang/Var;
    //   2669: getstatic clojure/spec/alpha__init.const__291 : Lclojure/lang/Var;
    //   2672: dup
    //   2673: getstatic clojure/spec/alpha__init.const__294 : Lclojure/lang/AFn;
    //   2676: checkcast clojure/lang/IPersistentMap
    //   2679: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2682: dup
    //   2683: new clojure/spec/alpha$_QMARK_
    //   2686: dup
    //   2687: invokespecial <init> : ()V
    //   2690: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2693: getstatic clojure/spec/alpha__init.const__291 : Lclojure/lang/Var;
    //   2696: checkcast clojure/lang/Var
    //   2699: invokevirtual setMacro : ()V
    //   2702: aconst_null
    //   2703: getstatic clojure/spec/alpha__init.const__291 : Lclojure/lang/Var;
    //   2706: getstatic clojure/spec/alpha__init.const__295 : Lclojure/lang/Var;
    //   2709: dup
    //   2710: getstatic clojure/spec/alpha__init.const__298 : Lclojure/lang/AFn;
    //   2713: checkcast clojure/lang/IPersistentMap
    //   2716: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2719: dup
    //   2720: new clojure/spec/alpha$alt
    //   2723: dup
    //   2724: invokespecial <init> : ()V
    //   2727: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2730: getstatic clojure/spec/alpha__init.const__295 : Lclojure/lang/Var;
    //   2733: checkcast clojure/lang/Var
    //   2736: invokevirtual setMacro : ()V
    //   2739: aconst_null
    //   2740: getstatic clojure/spec/alpha__init.const__295 : Lclojure/lang/Var;
    //   2743: getstatic clojure/spec/alpha__init.const__299 : Lclojure/lang/Var;
    //   2746: dup
    //   2747: getstatic clojure/spec/alpha__init.const__302 : Lclojure/lang/AFn;
    //   2750: checkcast clojure/lang/IPersistentMap
    //   2753: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2756: dup
    //   2757: new clojure/spec/alpha$cat
    //   2760: dup
    //   2761: invokespecial <init> : ()V
    //   2764: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2767: getstatic clojure/spec/alpha__init.const__299 : Lclojure/lang/Var;
    //   2770: checkcast clojure/lang/Var
    //   2773: invokevirtual setMacro : ()V
    //   2776: aconst_null
    //   2777: getstatic clojure/spec/alpha__init.const__299 : Lclojure/lang/Var;
    //   2780: getstatic clojure/spec/alpha__init.const__303 : Lclojure/lang/Var;
    //   2783: dup
    //   2784: getstatic clojure/spec/alpha__init.const__306 : Lclojure/lang/AFn;
    //   2787: checkcast clojure/lang/IPersistentMap
    //   2790: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2793: dup
    //   2794: new clojure/spec/alpha$_AMPERSAND_
    //   2797: dup
    //   2798: invokespecial <init> : ()V
    //   2801: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2804: getstatic clojure/spec/alpha__init.const__303 : Lclojure/lang/Var;
    //   2807: checkcast clojure/lang/Var
    //   2810: invokevirtual setMacro : ()V
    //   2813: aconst_null
    //   2814: getstatic clojure/spec/alpha__init.const__303 : Lclojure/lang/Var;
    //   2817: getstatic clojure/spec/alpha__init.const__307 : Lclojure/lang/Var;
    //   2820: dup
    //   2821: getstatic clojure/spec/alpha__init.const__310 : Lclojure/lang/AFn;
    //   2824: checkcast clojure/lang/IPersistentMap
    //   2827: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2830: dup
    //   2831: new clojure/spec/alpha$conformer
    //   2834: dup
    //   2835: invokespecial <init> : ()V
    //   2838: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2841: getstatic clojure/spec/alpha__init.const__307 : Lclojure/lang/Var;
    //   2844: checkcast clojure/lang/Var
    //   2847: invokevirtual setMacro : ()V
    //   2850: aconst_null
    //   2851: getstatic clojure/spec/alpha__init.const__307 : Lclojure/lang/Var;
    //   2854: getstatic clojure/spec/alpha__init.const__311 : Lclojure/lang/Var;
    //   2857: dup
    //   2858: getstatic clojure/spec/alpha__init.const__314 : Lclojure/lang/AFn;
    //   2861: checkcast clojure/lang/IPersistentMap
    //   2864: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2867: dup
    //   2868: new clojure/spec/alpha$fspec
    //   2871: dup
    //   2872: invokespecial <init> : ()V
    //   2875: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2878: getstatic clojure/spec/alpha__init.const__311 : Lclojure/lang/Var;
    //   2881: checkcast clojure/lang/Var
    //   2884: invokevirtual setMacro : ()V
    //   2887: aconst_null
    //   2888: getstatic clojure/spec/alpha__init.const__311 : Lclojure/lang/Var;
    //   2891: getstatic clojure/spec/alpha__init.const__315 : Lclojure/lang/Var;
    //   2894: dup
    //   2895: getstatic clojure/spec/alpha__init.const__318 : Lclojure/lang/AFn;
    //   2898: checkcast clojure/lang/IPersistentMap
    //   2901: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2904: dup
    //   2905: new clojure/spec/alpha$tuple
    //   2908: dup
    //   2909: invokespecial <init> : ()V
    //   2912: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2915: getstatic clojure/spec/alpha__init.const__315 : Lclojure/lang/Var;
    //   2918: checkcast clojure/lang/Var
    //   2921: invokevirtual setMacro : ()V
    //   2924: aconst_null
    //   2925: getstatic clojure/spec/alpha__init.const__315 : Lclojure/lang/Var;
    //   2928: getstatic clojure/spec/alpha__init.const__319 : Lclojure/lang/Var;
    //   2931: dup
    //   2932: getstatic clojure/spec/alpha__init.const__322 : Lclojure/lang/AFn;
    //   2935: checkcast clojure/lang/IPersistentMap
    //   2938: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2941: dup
    //   2942: new clojure/spec/alpha$macroexpand_check
    //   2945: dup
    //   2946: invokespecial <init> : ()V
    //   2949: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2952: getstatic clojure/spec/alpha__init.const__323 : Lclojure/lang/Var;
    //   2955: dup
    //   2956: getstatic clojure/spec/alpha__init.const__326 : Lclojure/lang/AFn;
    //   2959: checkcast clojure/lang/IPersistentMap
    //   2962: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2965: dup
    //   2966: new clojure/spec/alpha$fdef
    //   2969: dup
    //   2970: invokespecial <init> : ()V
    //   2973: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2976: getstatic clojure/spec/alpha__init.const__323 : Lclojure/lang/Var;
    //   2979: checkcast clojure/lang/Var
    //   2982: invokevirtual setMacro : ()V
    //   2985: aconst_null
    //   2986: getstatic clojure/spec/alpha__init.const__323 : Lclojure/lang/Var;
    //   2989: getstatic clojure/spec/alpha__init.const__327 : Lclojure/lang/Var;
    //   2992: dup
    //   2993: getstatic clojure/spec/alpha__init.const__330 : Lclojure/lang/AFn;
    //   2996: checkcast clojure/lang/IPersistentMap
    //   2999: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3002: dup
    //   3003: new clojure/spec/alpha$recur_limit_QMARK_
    //   3006: dup
    //   3007: invokespecial <init> : ()V
    //   3010: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3013: getstatic clojure/spec/alpha__init.const__331 : Lclojure/lang/Var;
    //   3016: dup
    //   3017: getstatic clojure/spec/alpha__init.const__334 : Lclojure/lang/AFn;
    //   3020: checkcast clojure/lang/IPersistentMap
    //   3023: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3026: dup
    //   3027: new clojure/spec/alpha$inck
    //   3030: dup
    //   3031: invokespecial <init> : ()V
    //   3034: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3037: getstatic clojure/spec/alpha__init.const__335 : Lclojure/lang/Var;
    //   3040: dup
    //   3041: getstatic clojure/spec/alpha__init.const__338 : Lclojure/lang/AFn;
    //   3044: checkcast clojure/lang/IPersistentMap
    //   3047: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3050: dup
    //   3051: new clojure/spec/alpha$dt
    //   3054: dup
    //   3055: invokespecial <init> : ()V
    //   3058: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3061: getstatic clojure/spec/alpha__init.const__196 : Lclojure/lang/Var;
    //   3064: dup
    //   3065: getstatic clojure/spec/alpha__init.const__341 : Lclojure/lang/AFn;
    //   3068: checkcast clojure/lang/IPersistentMap
    //   3071: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3074: dup
    //   3075: new clojure/spec/alpha$valid_QMARK_
    //   3078: dup
    //   3079: invokespecial <init> : ()V
    //   3082: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3085: getstatic clojure/spec/alpha__init.const__342 : Lclojure/lang/Var;
    //   3088: dup
    //   3089: getstatic clojure/spec/alpha__init.const__345 : Lclojure/lang/AFn;
    //   3092: checkcast clojure/lang/IPersistentMap
    //   3095: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3098: dup
    //   3099: new clojure/spec/alpha$pvalid_QMARK_
    //   3102: dup
    //   3103: invokespecial <init> : ()V
    //   3106: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3109: getstatic clojure/spec/alpha__init.const__346 : Lclojure/lang/Var;
    //   3112: dup
    //   3113: getstatic clojure/spec/alpha__init.const__349 : Lclojure/lang/AFn;
    //   3116: checkcast clojure/lang/IPersistentMap
    //   3119: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3122: dup
    //   3123: new clojure/spec/alpha$explain_1
    //   3126: dup
    //   3127: invokespecial <init> : ()V
    //   3130: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3133: getstatic clojure/spec/alpha__init.const__350 : Lclojure/lang/Var;
    //   3136: dup
    //   3137: getstatic clojure/spec/alpha__init.const__352 : Lclojure/lang/AFn;
    //   3140: checkcast clojure/lang/IPersistentMap
    //   3143: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3146: getstatic clojure/spec/alpha__init.const__353 : Lclojure/lang/Var;
    //   3149: dup
    //   3150: getstatic clojure/spec/alpha__init.const__355 : Lclojure/lang/AFn;
    //   3153: checkcast clojure/lang/IPersistentMap
    //   3156: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3159: getstatic clojure/spec/alpha__init.const__356 : Lclojure/lang/Var;
    //   3162: dup
    //   3163: getstatic clojure/spec/alpha__init.const__359 : Lclojure/lang/AFn;
    //   3166: checkcast clojure/lang/IPersistentMap
    //   3169: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3172: dup
    //   3173: new clojure/spec/alpha$k_gen
    //   3176: dup
    //   3177: invokespecial <init> : ()V
    //   3180: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3183: getstatic clojure/spec/alpha__init.const__350 : Lclojure/lang/Var;
    //   3186: dup
    //   3187: getstatic clojure/spec/alpha__init.const__362 : Lclojure/lang/AFn;
    //   3190: checkcast clojure/lang/IPersistentMap
    //   3193: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3196: dup
    //   3197: new clojure/spec/alpha$or_k_gen
    //   3200: dup
    //   3201: invokespecial <init> : ()V
    //   3204: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3207: getstatic clojure/spec/alpha__init.const__353 : Lclojure/lang/Var;
    //   3210: dup
    //   3211: getstatic clojure/spec/alpha__init.const__365 : Lclojure/lang/AFn;
    //   3214: checkcast clojure/lang/IPersistentMap
    //   3217: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3220: dup
    //   3221: new clojure/spec/alpha$and_k_gen
    //   3224: dup
    //   3225: invokespecial <init> : ()V
    //   3228: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3231: getstatic clojure/spec/alpha__init.const__366 : Lclojure/lang/Var;
    //   3234: dup
    //   3235: getstatic clojure/spec/alpha__init.const__369 : Lclojure/lang/AFn;
    //   3238: checkcast clojure/lang/IPersistentMap
    //   3241: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3244: dup
    //   3245: new clojure/spec/alpha$map_spec_impl
    //   3248: dup
    //   3249: invokespecial <init> : ()V
    //   3252: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3255: getstatic clojure/spec/alpha__init.const__102 : Lclojure/lang/Var;
    //   3258: dup
    //   3259: getstatic clojure/spec/alpha__init.const__372 : Lclojure/lang/AFn;
    //   3262: checkcast clojure/lang/IPersistentMap
    //   3265: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3268: dup
    //   3269: new clojure/spec/alpha$spec_impl
    //   3272: dup
    //   3273: invokespecial <init> : ()V
    //   3276: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3279: getstatic clojure/spec/alpha__init.const__373 : Lclojure/lang/Var;
    //   3282: dup
    //   3283: getstatic clojure/spec/alpha__init.const__376 : Lclojure/lang/AFn;
    //   3286: checkcast clojure/lang/IPersistentMap
    //   3289: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3292: dup
    //   3293: new clojure/spec/alpha$multi_spec_impl
    //   3296: dup
    //   3297: invokespecial <init> : ()V
    //   3300: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3303: getstatic clojure/spec/alpha__init.const__377 : Lclojure/lang/Var;
    //   3306: dup
    //   3307: getstatic clojure/spec/alpha__init.const__380 : Lclojure/lang/AFn;
    //   3310: checkcast clojure/lang/IPersistentMap
    //   3313: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3316: dup
    //   3317: new clojure/spec/alpha$tuple_impl
    //   3320: dup
    //   3321: invokespecial <init> : ()V
    //   3324: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3327: getstatic clojure/spec/alpha__init.const__381 : Lclojure/lang/Var;
    //   3330: dup
    //   3331: getstatic clojure/spec/alpha__init.const__384 : Lclojure/lang/AFn;
    //   3334: checkcast clojure/lang/IPersistentMap
    //   3337: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3340: dup
    //   3341: new clojure/spec/alpha$tagged_ret
    //   3344: dup
    //   3345: invokespecial <init> : ()V
    //   3348: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3351: getstatic clojure/spec/alpha__init.const__385 : Lclojure/lang/Var;
    //   3354: dup
    //   3355: getstatic clojure/spec/alpha__init.const__388 : Lclojure/lang/AFn;
    //   3358: checkcast clojure/lang/IPersistentMap
    //   3361: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3364: dup
    //   3365: new clojure/spec/alpha$or_spec_impl
    //   3368: dup
    //   3369: invokespecial <init> : ()V
    //   3372: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3375: getstatic clojure/spec/alpha__init.const__389 : Lclojure/lang/Var;
    //   3378: dup
    //   3379: getstatic clojure/spec/alpha__init.const__392 : Lclojure/lang/AFn;
    //   3382: checkcast clojure/lang/IPersistentMap
    //   3385: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3388: dup
    //   3389: new clojure/spec/alpha$and_preds
    //   3392: dup
    //   3393: invokespecial <init> : ()V
    //   3396: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3399: getstatic clojure/spec/alpha__init.const__393 : Lclojure/lang/Var;
    //   3402: dup
    //   3403: getstatic clojure/spec/alpha__init.const__396 : Lclojure/lang/AFn;
    //   3406: checkcast clojure/lang/IPersistentMap
    //   3409: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3412: dup
    //   3413: new clojure/spec/alpha$explain_pred_list
    //   3416: dup
    //   3417: invokespecial <init> : ()V
    //   3420: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3423: getstatic clojure/spec/alpha__init.const__397 : Lclojure/lang/Var;
    //   3426: dup
    //   3427: getstatic clojure/spec/alpha__init.const__400 : Lclojure/lang/AFn;
    //   3430: checkcast clojure/lang/IPersistentMap
    //   3433: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3436: dup
    //   3437: new clojure/spec/alpha$and_spec_impl
    //   3440: dup
    //   3441: invokespecial <init> : ()V
    //   3444: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3447: getstatic clojure/spec/alpha__init.const__401 : Lclojure/lang/Var;
    //   3450: dup
    //   3451: getstatic clojure/spec/alpha__init.const__404 : Lclojure/lang/AFn;
    //   3454: checkcast clojure/lang/IPersistentMap
    //   3457: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3460: dup
    //   3461: new clojure/spec/alpha$merge_spec_impl
    //   3464: dup
    //   3465: invokespecial <init> : ()V
    //   3468: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3471: getstatic clojure/spec/alpha__init.const__405 : Lclojure/lang/Var;
    //   3474: dup
    //   3475: getstatic clojure/spec/alpha__init.const__408 : Lclojure/lang/AFn;
    //   3478: checkcast clojure/lang/IPersistentMap
    //   3481: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3484: dup
    //   3485: new clojure/spec/alpha$coll_prob
    //   3488: dup
    //   3489: invokespecial <init> : ()V
    //   3492: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3495: getstatic clojure/spec/alpha__init.const__409 : Lclojure/lang/Var;
    //   3498: dup
    //   3499: getstatic clojure/spec/alpha__init.const__411 : Lclojure/lang/AFn;
    //   3502: checkcast clojure/lang/IPersistentMap
    //   3505: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3508: dup
    //   3509: bipush #8
    //   3511: anewarray java/lang/Object
    //   3514: dup
    //   3515: iconst_0
    //   3516: getstatic clojure/spec/alpha__init.const__412 : Lclojure/lang/AFn;
    //   3519: aastore
    //   3520: dup
    //   3521: iconst_1
    //   3522: getstatic clojure/lang/PersistentVector.EMPTY : Lclojure/lang/PersistentVector;
    //   3525: aastore
    //   3526: dup
    //   3527: iconst_2
    //   3528: getstatic clojure/spec/alpha__init.const__413 : Lclojure/lang/AFn;
    //   3531: aastore
    //   3532: dup
    //   3533: iconst_3
    //   3534: getstatic clojure/lang/PersistentHashSet.EMPTY : Lclojure/lang/PersistentHashSet;
    //   3537: aastore
    //   3538: dup
    //   3539: iconst_4
    //   3540: getstatic clojure/spec/alpha__init.const__414 : Lclojure/lang/AFn;
    //   3543: aastore
    //   3544: dup
    //   3545: iconst_5
    //   3546: getstatic clojure/lang/PersistentList.EMPTY : Lclojure/lang/PersistentList$EmptyList;
    //   3549: aastore
    //   3550: dup
    //   3551: bipush #6
    //   3553: getstatic clojure/spec/alpha__init.const__415 : Lclojure/lang/AFn;
    //   3556: aastore
    //   3557: dup
    //   3558: bipush #7
    //   3560: getstatic clojure/lang/PersistentArrayMap.EMPTY : Lclojure/lang/PersistentArrayMap;
    //   3563: aastore
    //   3564: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   3567: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3570: getstatic clojure/spec/alpha__init.const__416 : Lclojure/lang/Var;
    //   3573: dup
    //   3574: getstatic clojure/spec/alpha__init.const__419 : Lclojure/lang/AFn;
    //   3577: checkcast clojure/lang/IPersistentMap
    //   3580: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3583: dup
    //   3584: new clojure/spec/alpha$every_impl
    //   3587: dup
    //   3588: invokespecial <init> : ()V
    //   3591: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3594: getstatic clojure/spec/alpha__init.const__420 : Lclojure/lang/Var;
    //   3597: dup
    //   3598: getstatic clojure/spec/alpha__init.const__423 : Lclojure/lang/AFn;
    //   3601: checkcast clojure/lang/IPersistentMap
    //   3604: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3607: dup
    //   3608: new clojure/spec/alpha$accept
    //   3611: dup
    //   3612: invokespecial <init> : ()V
    //   3615: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3618: getstatic clojure/spec/alpha__init.const__424 : Lclojure/lang/Var;
    //   3621: dup
    //   3622: getstatic clojure/spec/alpha__init.const__427 : Lclojure/lang/AFn;
    //   3625: checkcast clojure/lang/IPersistentMap
    //   3628: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3631: dup
    //   3632: new clojure/spec/alpha$accept_QMARK_
    //   3635: dup
    //   3636: invokespecial <init> : ()V
    //   3639: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3642: getstatic clojure/spec/alpha__init.const__428 : Lclojure/lang/Var;
    //   3645: dup
    //   3646: getstatic clojure/spec/alpha__init.const__431 : Lclojure/lang/AFn;
    //   3649: checkcast clojure/lang/IPersistentMap
    //   3652: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3655: dup
    //   3656: new clojure/spec/alpha$pcat_STAR_
    //   3659: dup
    //   3660: invokespecial <init> : ()V
    //   3663: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3666: getstatic clojure/spec/alpha__init.const__432 : Lclojure/lang/Var;
    //   3669: dup
    //   3670: getstatic clojure/spec/alpha__init.const__435 : Lclojure/lang/AFn;
    //   3673: checkcast clojure/lang/IPersistentMap
    //   3676: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3679: dup
    //   3680: new clojure/spec/alpha$pcat
    //   3683: dup
    //   3684: invokespecial <init> : ()V
    //   3687: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3690: getstatic clojure/spec/alpha__init.const__436 : Lclojure/lang/Var;
    //   3693: dup
    //   3694: getstatic clojure/spec/alpha__init.const__439 : Lclojure/lang/AFn;
    //   3697: checkcast clojure/lang/IPersistentMap
    //   3700: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3703: dup
    //   3704: new clojure/spec/alpha$cat_impl
    //   3707: dup
    //   3708: invokespecial <init> : ()V
    //   3711: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3714: getstatic clojure/spec/alpha__init.const__440 : Lclojure/lang/Var;
    //   3717: dup
    //   3718: getstatic clojure/spec/alpha__init.const__443 : Lclojure/lang/AFn;
    //   3721: checkcast clojure/lang/IPersistentMap
    //   3724: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3727: dup
    //   3728: new clojure/spec/alpha$rep_STAR_
    //   3731: dup
    //   3732: invokespecial <init> : ()V
    //   3735: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3738: getstatic clojure/spec/alpha__init.const__444 : Lclojure/lang/Var;
    //   3741: dup
    //   3742: getstatic clojure/spec/alpha__init.const__447 : Lclojure/lang/AFn;
    //   3745: checkcast clojure/lang/IPersistentMap
    //   3748: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3751: dup
    //   3752: new clojure/spec/alpha$rep_impl
    //   3755: dup
    //   3756: invokespecial <init> : ()V
    //   3759: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3762: getstatic clojure/spec/alpha__init.const__448 : Lclojure/lang/Var;
    //   3765: dup
    //   3766: getstatic clojure/spec/alpha__init.const__451 : Lclojure/lang/AFn;
    //   3769: checkcast clojure/lang/IPersistentMap
    //   3772: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3775: dup
    //   3776: new clojure/spec/alpha$rep_PLUS_impl
    //   3779: dup
    //   3780: invokespecial <init> : ()V
    //   3783: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3786: getstatic clojure/spec/alpha__init.const__452 : Lclojure/lang/Var;
    //   3789: dup
    //   3790: getstatic clojure/spec/alpha__init.const__455 : Lclojure/lang/AFn;
    //   3793: checkcast clojure/lang/IPersistentMap
    //   3796: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3799: dup
    //   3800: new clojure/spec/alpha$amp_impl
    //   3803: dup
    //   3804: invokespecial <init> : ()V
    //   3807: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3810: getstatic clojure/spec/alpha__init.const__456 : Lclojure/lang/Var;
    //   3813: dup
    //   3814: getstatic clojure/spec/alpha__init.const__459 : Lclojure/lang/AFn;
    //   3817: checkcast clojure/lang/IPersistentMap
    //   3820: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3823: dup
    //   3824: new clojure/spec/alpha$filter_alt
    //   3827: dup
    //   3828: invokespecial <init> : ()V
    //   3831: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3834: getstatic clojure/spec/alpha__init.const__460 : Lclojure/lang/Var;
    //   3837: dup
    //   3838: getstatic clojure/spec/alpha__init.const__463 : Lclojure/lang/AFn;
    //   3841: checkcast clojure/lang/IPersistentMap
    //   3844: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3847: dup
    //   3848: new clojure/spec/alpha$alt_STAR_
    //   3851: dup
    //   3852: invokespecial <init> : ()V
    //   3855: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3858: getstatic clojure/spec/alpha__init.const__464 : Lclojure/lang/Var;
    //   3861: dup
    //   3862: getstatic clojure/spec/alpha__init.const__467 : Lclojure/lang/AFn;
    //   3865: checkcast clojure/lang/IPersistentMap
    //   3868: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3871: dup
    //   3872: new clojure/spec/alpha$alts
    //   3875: dup
    //   3876: invokespecial <init> : ()V
    //   3879: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3882: getstatic clojure/spec/alpha__init.const__468 : Lclojure/lang/Var;
    //   3885: dup
    //   3886: getstatic clojure/spec/alpha__init.const__471 : Lclojure/lang/AFn;
    //   3889: checkcast clojure/lang/IPersistentMap
    //   3892: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3895: dup
    //   3896: new clojure/spec/alpha$alt2
    //   3899: dup
    //   3900: invokespecial <init> : ()V
    //   3903: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3906: getstatic clojure/spec/alpha__init.const__472 : Lclojure/lang/Var;
    //   3909: dup
    //   3910: getstatic clojure/spec/alpha__init.const__475 : Lclojure/lang/AFn;
    //   3913: checkcast clojure/lang/IPersistentMap
    //   3916: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3919: dup
    //   3920: new clojure/spec/alpha$alt_impl
    //   3923: dup
    //   3924: invokespecial <init> : ()V
    //   3927: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3930: getstatic clojure/spec/alpha__init.const__476 : Lclojure/lang/Var;
    //   3933: dup
    //   3934: getstatic clojure/spec/alpha__init.const__479 : Lclojure/lang/AFn;
    //   3937: checkcast clojure/lang/IPersistentMap
    //   3940: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3943: dup
    //   3944: new clojure/spec/alpha$maybe_impl
    //   3947: dup
    //   3948: invokespecial <init> : ()V
    //   3951: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3954: getstatic clojure/spec/alpha__init.const__480 : Lclojure/lang/Var;
    //   3957: dup
    //   3958: getstatic clojure/spec/alpha__init.const__483 : Lclojure/lang/AFn;
    //   3961: checkcast clojure/lang/IPersistentMap
    //   3964: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3967: dup
    //   3968: new clojure/spec/alpha$noret_QMARK_
    //   3971: dup
    //   3972: invokespecial <init> : ()V
    //   3975: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3978: getstatic clojure/spec/alpha__init.const__484 : Lclojure/lang/Var;
    //   3981: dup
    //   3982: getstatic clojure/spec/alpha__init.const__486 : Lclojure/lang/AFn;
    //   3985: checkcast clojure/lang/IPersistentMap
    //   3988: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3991: getstatic clojure/spec/alpha__init.const__487 : Lclojure/lang/Var;
    //   3994: dup
    //   3995: getstatic clojure/spec/alpha__init.const__490 : Lclojure/lang/AFn;
    //   3998: checkcast clojure/lang/IPersistentMap
    //   4001: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4004: dup
    //   4005: new clojure/spec/alpha$accept_nil_QMARK_
    //   4008: dup
    //   4009: invokespecial <init> : ()V
    //   4012: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4015: getstatic clojure/spec/alpha__init.const__491 : Lclojure/lang/Var;
    //   4018: dup
    //   4019: getstatic clojure/spec/alpha__init.const__493 : Lclojure/lang/AFn;
    //   4022: checkcast clojure/lang/IPersistentMap
    //   4025: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4028: getstatic clojure/spec/alpha__init.const__484 : Lclojure/lang/Var;
    //   4031: dup
    //   4032: getstatic clojure/spec/alpha__init.const__496 : Lclojure/lang/AFn;
    //   4035: checkcast clojure/lang/IPersistentMap
    //   4038: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4041: dup
    //   4042: new clojure/spec/alpha$preturn
    //   4045: dup
    //   4046: invokespecial <init> : ()V
    //   4049: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4052: getstatic clojure/spec/alpha__init.const__497 : Lclojure/lang/Var;
    //   4055: dup
    //   4056: getstatic clojure/spec/alpha__init.const__500 : Lclojure/lang/AFn;
    //   4059: checkcast clojure/lang/IPersistentMap
    //   4062: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4065: dup
    //   4066: new clojure/spec/alpha$op_unform
    //   4069: dup
    //   4070: invokespecial <init> : ()V
    //   4073: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4076: getstatic clojure/spec/alpha__init.const__491 : Lclojure/lang/Var;
    //   4079: dup
    //   4080: getstatic clojure/spec/alpha__init.const__503 : Lclojure/lang/AFn;
    //   4083: checkcast clojure/lang/IPersistentMap
    //   4086: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4089: dup
    //   4090: new clojure/spec/alpha$add_ret
    //   4093: dup
    //   4094: invokespecial <init> : ()V
    //   4097: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4100: getstatic clojure/spec/alpha__init.const__504 : Lclojure/lang/Var;
    //   4103: dup
    //   4104: getstatic clojure/spec/alpha__init.const__507 : Lclojure/lang/AFn;
    //   4107: checkcast clojure/lang/IPersistentMap
    //   4110: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4113: dup
    //   4114: new clojure/spec/alpha$deriv
    //   4117: dup
    //   4118: invokespecial <init> : ()V
    //   4121: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4124: getstatic clojure/spec/alpha__init.const__508 : Lclojure/lang/Var;
    //   4127: dup
    //   4128: getstatic clojure/spec/alpha__init.const__511 : Lclojure/lang/AFn;
    //   4131: checkcast clojure/lang/IPersistentMap
    //   4134: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4137: dup
    //   4138: new clojure/spec/alpha$op_describe
    //   4141: dup
    //   4142: invokespecial <init> : ()V
    //   4145: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4148: getstatic clojure/spec/alpha__init.const__512 : Lclojure/lang/Var;
    //   4151: dup
    //   4152: getstatic clojure/spec/alpha__init.const__515 : Lclojure/lang/AFn;
    //   4155: checkcast clojure/lang/IPersistentMap
    //   4158: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4161: dup
    //   4162: new clojure/spec/alpha$op_explain
    //   4165: dup
    //   4166: invokespecial <init> : ()V
    //   4169: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4172: getstatic clojure/spec/alpha__init.const__516 : Lclojure/lang/Var;
    //   4175: dup
    //   4176: getstatic clojure/spec/alpha__init.const__519 : Lclojure/lang/AFn;
    //   4179: checkcast clojure/lang/IPersistentMap
    //   4182: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4185: dup
    //   4186: new clojure/spec/alpha$re_gen
    //   4189: dup
    //   4190: invokespecial <init> : ()V
    //   4193: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4196: getstatic clojure/spec/alpha__init.const__520 : Lclojure/lang/Var;
    //   4199: dup
    //   4200: getstatic clojure/spec/alpha__init.const__523 : Lclojure/lang/AFn;
    //   4203: checkcast clojure/lang/IPersistentMap
    //   4206: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4209: dup
    //   4210: new clojure/spec/alpha$re_conform
    //   4213: dup
    //   4214: invokespecial <init> : ()V
    //   4217: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4220: getstatic clojure/spec/alpha__init.const__524 : Lclojure/lang/Var;
    //   4223: dup
    //   4224: getstatic clojure/spec/alpha__init.const__527 : Lclojure/lang/AFn;
    //   4227: checkcast clojure/lang/IPersistentMap
    //   4230: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4233: dup
    //   4234: new clojure/spec/alpha$re_explain
    //   4237: dup
    //   4238: invokespecial <init> : ()V
    //   4241: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4244: getstatic clojure/spec/alpha__init.const__106 : Lclojure/lang/Var;
    //   4247: dup
    //   4248: getstatic clojure/spec/alpha__init.const__530 : Lclojure/lang/AFn;
    //   4251: checkcast clojure/lang/IPersistentMap
    //   4254: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4257: dup
    //   4258: new clojure/spec/alpha$regex_spec_impl
    //   4261: dup
    //   4262: invokespecial <init> : ()V
    //   4265: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4268: getstatic clojure/spec/alpha__init.const__531 : Lclojure/lang/Var;
    //   4271: dup
    //   4272: getstatic clojure/spec/alpha__init.const__534 : Lclojure/lang/AFn;
    //   4275: checkcast clojure/lang/IPersistentMap
    //   4278: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4281: dup
    //   4282: new clojure/spec/alpha$call_valid_QMARK_
    //   4285: dup
    //   4286: invokespecial <init> : ()V
    //   4289: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4292: getstatic clojure/spec/alpha__init.const__535 : Lclojure/lang/Var;
    //   4295: dup
    //   4296: getstatic clojure/spec/alpha__init.const__538 : Lclojure/lang/AFn;
    //   4299: checkcast clojure/lang/IPersistentMap
    //   4302: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4305: dup
    //   4306: new clojure/spec/alpha$validate_fn
    //   4309: dup
    //   4310: invokespecial <init> : ()V
    //   4313: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4316: getstatic clojure/spec/alpha__init.const__539 : Lclojure/lang/Var;
    //   4319: dup
    //   4320: getstatic clojure/spec/alpha__init.const__542 : Lclojure/lang/AFn;
    //   4323: checkcast clojure/lang/IPersistentMap
    //   4326: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4329: dup
    //   4330: new clojure/spec/alpha$fspec_impl
    //   4333: dup
    //   4334: invokespecial <init> : ()V
    //   4337: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4340: getstatic clojure/spec/alpha__init.const__219 : Lclojure/lang/Var;
    //   4343: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   4346: checkcast clojure/lang/IFn
    //   4349: getstatic clojure/spec/alpha__init.const__543 : Lclojure/lang/Keyword;
    //   4352: getstatic clojure/spec/alpha__init.const__544 : Ljava/lang/Object;
    //   4355: getstatic clojure/spec/alpha__init.const__102 : Lclojure/lang/Var;
    //   4358: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   4361: checkcast clojure/lang/IFn
    //   4364: getstatic clojure/spec/alpha__init.const__545 : Ljava/lang/Object;
    //   4367: new clojure/spec/alpha$fn__2536
    //   4370: dup
    //   4371: invokespecial <init> : ()V
    //   4374: aconst_null
    //   4375: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   4378: new clojure/spec/alpha$fn__2538
    //   4381: dup
    //   4382: invokespecial <init> : ()V
    //   4385: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   4390: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   4395: getstatic clojure/spec/alpha__init.const__546 : Lclojure/lang/Var;
    //   4398: dup
    //   4399: getstatic clojure/spec/alpha__init.const__549 : Lclojure/lang/AFn;
    //   4402: checkcast clojure/lang/IPersistentMap
    //   4405: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4408: dup
    //   4409: new clojure/spec/alpha$keys_STAR_
    //   4412: dup
    //   4413: invokespecial <init> : ()V
    //   4416: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4419: getstatic clojure/spec/alpha__init.const__546 : Lclojure/lang/Var;
    //   4422: checkcast clojure/lang/Var
    //   4425: invokevirtual setMacro : ()V
    //   4428: aconst_null
    //   4429: getstatic clojure/spec/alpha__init.const__546 : Lclojure/lang/Var;
    //   4432: getstatic clojure/spec/alpha__init.const__550 : Lclojure/lang/Var;
    //   4435: dup
    //   4436: getstatic clojure/spec/alpha__init.const__553 : Lclojure/lang/AFn;
    //   4439: checkcast clojure/lang/IPersistentMap
    //   4442: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4445: dup
    //   4446: new clojure/spec/alpha$nonconforming
    //   4449: dup
    //   4450: invokespecial <init> : ()V
    //   4453: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4456: getstatic clojure/spec/alpha__init.const__554 : Lclojure/lang/Var;
    //   4459: dup
    //   4460: getstatic clojure/spec/alpha__init.const__557 : Lclojure/lang/AFn;
    //   4463: checkcast clojure/lang/IPersistentMap
    //   4466: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4469: dup
    //   4470: new clojure/spec/alpha$nilable_impl
    //   4473: dup
    //   4474: invokespecial <init> : ()V
    //   4477: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4480: getstatic clojure/spec/alpha__init.const__558 : Lclojure/lang/Var;
    //   4483: dup
    //   4484: getstatic clojure/spec/alpha__init.const__561 : Lclojure/lang/AFn;
    //   4487: checkcast clojure/lang/IPersistentMap
    //   4490: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4493: dup
    //   4494: new clojure/spec/alpha$nilable
    //   4497: dup
    //   4498: invokespecial <init> : ()V
    //   4501: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4504: getstatic clojure/spec/alpha__init.const__558 : Lclojure/lang/Var;
    //   4507: checkcast clojure/lang/Var
    //   4510: invokevirtual setMacro : ()V
    //   4513: aconst_null
    //   4514: getstatic clojure/spec/alpha__init.const__558 : Lclojure/lang/Var;
    //   4517: getstatic clojure/spec/alpha__init.const__562 : Lclojure/lang/Var;
    //   4520: dup
    //   4521: getstatic clojure/spec/alpha__init.const__565 : Lclojure/lang/AFn;
    //   4524: checkcast clojure/lang/IPersistentMap
    //   4527: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4530: dup
    //   4531: new clojure/spec/alpha$exercise
    //   4534: dup
    //   4535: invokespecial <init> : ()V
    //   4538: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4541: getstatic clojure/spec/alpha__init.const__566 : Lclojure/lang/Var;
    //   4544: dup
    //   4545: getstatic clojure/spec/alpha__init.const__569 : Lclojure/lang/AFn;
    //   4548: checkcast clojure/lang/IPersistentMap
    //   4551: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4554: dup
    //   4555: new clojure/spec/alpha$exercise_fn
    //   4558: dup
    //   4559: invokespecial <init> : ()V
    //   4562: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4565: getstatic clojure/spec/alpha__init.const__570 : Lclojure/lang/Var;
    //   4568: dup
    //   4569: getstatic clojure/spec/alpha__init.const__573 : Lclojure/lang/AFn;
    //   4572: checkcast clojure/lang/IPersistentMap
    //   4575: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4578: dup
    //   4579: new clojure/spec/alpha$inst_in_range_QMARK_
    //   4582: dup
    //   4583: invokespecial <init> : ()V
    //   4586: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4589: getstatic clojure/spec/alpha__init.const__574 : Lclojure/lang/Var;
    //   4592: dup
    //   4593: getstatic clojure/spec/alpha__init.const__577 : Lclojure/lang/AFn;
    //   4596: checkcast clojure/lang/IPersistentMap
    //   4599: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4602: dup
    //   4603: new clojure/spec/alpha$inst_in
    //   4606: dup
    //   4607: invokespecial <init> : ()V
    //   4610: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4613: getstatic clojure/spec/alpha__init.const__574 : Lclojure/lang/Var;
    //   4616: checkcast clojure/lang/Var
    //   4619: invokevirtual setMacro : ()V
    //   4622: aconst_null
    //   4623: getstatic clojure/spec/alpha__init.const__574 : Lclojure/lang/Var;
    //   4626: getstatic clojure/spec/alpha__init.const__578 : Lclojure/lang/Var;
    //   4629: dup
    //   4630: getstatic clojure/spec/alpha__init.const__581 : Lclojure/lang/AFn;
    //   4633: checkcast clojure/lang/IPersistentMap
    //   4636: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4639: dup
    //   4640: new clojure/spec/alpha$int_in_range_QMARK_
    //   4643: dup
    //   4644: invokespecial <init> : ()V
    //   4647: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4650: getstatic clojure/spec/alpha__init.const__582 : Lclojure/lang/Var;
    //   4653: dup
    //   4654: getstatic clojure/spec/alpha__init.const__585 : Lclojure/lang/AFn;
    //   4657: checkcast clojure/lang/IPersistentMap
    //   4660: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4663: dup
    //   4664: new clojure/spec/alpha$int_in
    //   4667: dup
    //   4668: invokespecial <init> : ()V
    //   4671: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4674: getstatic clojure/spec/alpha__init.const__582 : Lclojure/lang/Var;
    //   4677: checkcast clojure/lang/Var
    //   4680: invokevirtual setMacro : ()V
    //   4683: aconst_null
    //   4684: getstatic clojure/spec/alpha__init.const__582 : Lclojure/lang/Var;
    //   4687: getstatic clojure/spec/alpha__init.const__586 : Lclojure/lang/Var;
    //   4690: dup
    //   4691: getstatic clojure/spec/alpha__init.const__589 : Lclojure/lang/AFn;
    //   4694: checkcast clojure/lang/IPersistentMap
    //   4697: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4700: dup
    //   4701: new clojure/spec/alpha$double_in
    //   4704: dup
    //   4705: invokespecial <init> : ()V
    //   4708: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4711: getstatic clojure/spec/alpha__init.const__586 : Lclojure/lang/Var;
    //   4714: checkcast clojure/lang/Var
    //   4717: invokevirtual setMacro : ()V
    //   4720: aconst_null
    //   4721: getstatic clojure/spec/alpha__init.const__586 : Lclojure/lang/Var;
    //   4724: new clojure/spec/alpha$fn__2611
    //   4727: dup
    //   4728: invokespecial <init> : ()V
    //   4731: checkcast clojure/lang/IFn
    //   4734: invokeinterface invoke : ()Ljava/lang/Object;
    //   4739: getstatic clojure/spec/alpha__init.const__590 : Lclojure/lang/Var;
    //   4742: dup
    //   4743: getstatic clojure/spec/alpha__init.const__593 : Lclojure/lang/AFn;
    //   4746: checkcast clojure/lang/IPersistentMap
    //   4749: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4752: dup
    //   4753: new clojure/spec/alpha$check_asserts_QMARK_
    //   4756: dup
    //   4757: invokespecial <init> : ()V
    //   4760: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4763: getstatic clojure/spec/alpha__init.const__594 : Lclojure/lang/Var;
    //   4766: dup
    //   4767: getstatic clojure/spec/alpha__init.const__597 : Lclojure/lang/AFn;
    //   4770: checkcast clojure/lang/IPersistentMap
    //   4773: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4776: dup
    //   4777: new clojure/spec/alpha$check_asserts
    //   4780: dup
    //   4781: invokespecial <init> : ()V
    //   4784: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4787: getstatic clojure/spec/alpha__init.const__598 : Lclojure/lang/Var;
    //   4790: dup
    //   4791: getstatic clojure/spec/alpha__init.const__601 : Lclojure/lang/AFn;
    //   4794: checkcast clojure/lang/IPersistentMap
    //   4797: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4800: dup
    //   4801: new clojure/spec/alpha$assert_STAR_
    //   4804: dup
    //   4805: invokespecial <init> : ()V
    //   4808: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4811: getstatic clojure/spec/alpha__init.const__602 : Lclojure/lang/Var;
    //   4814: dup
    //   4815: getstatic clojure/spec/alpha__init.const__605 : Lclojure/lang/AFn;
    //   4818: checkcast clojure/lang/IPersistentMap
    //   4821: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4824: dup
    //   4825: new clojure/spec/alpha$assert
    //   4828: dup
    //   4829: invokespecial <init> : ()V
    //   4832: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4835: getstatic clojure/spec/alpha__init.const__602 : Lclojure/lang/Var;
    //   4838: checkcast clojure/lang/Var
    //   4841: invokevirtual setMacro : ()V
    //   4844: aconst_null
    //   4845: getstatic clojure/spec/alpha__init.const__602 : Lclojure/lang/Var;
    //   4848: return
    // Line number table:
    //   Java source line number -> byte code offset
    //   #9	-> 6
    //   #9	-> 12
    //   #9	-> 24
    //   #9	-> 27
    //   #9	-> 32
    //   #9	-> 41
    //   #9	-> 62
    //   #15	-> 73
    //   #15	-> 82
    //   #37	-> 199
    //   #37	-> 202
    //   #37	-> 216
    //   #37	-> 232
    //   #37	-> 240
    //   #37	-> 249
    //   #37	-> 260
    //   #37	-> 278
    //   #37	-> 318
    //   #37	-> 333
    //   #37	-> 345
    //   #37	-> 370
    //   #37	-> 375
    //   #37	-> 380
    //   #37	-> 404
    //   #37	-> 419
    //   #37	-> 431
    //   #37	-> 456
    //   #37	-> 461
    //   #37	-> 466
    //   #37	-> 490
    //   #37	-> 505
    //   #37	-> 517
    //   #37	-> 542
    //   #37	-> 547
    //   #37	-> 552
    //   #37	-> 577
    //   #37	-> 592
    //   #37	-> 604
    //   #37	-> 629
    //   #37	-> 634
    //   #37	-> 639
    //   #37	-> 665
    //   #37	-> 680
    //   #37	-> 692
    //   #37	-> 717
    //   #37	-> 722
    //   #37	-> 727
    //   #37	-> 753
    //   #37	-> 768
    //   #37	-> 780
    //   #37	-> 805
    //   #37	-> 810
    //   #37	-> 815
    //   #37	-> 835
    //   #37	-> 840
    //   #37	-> 851
    //   #37	-> 860
    //   #45	-> 875
    //   #45	-> 878
    //   #121	-> 1132
    //   #121	-> 1135
    //   #121	-> 1149
    //   #121	-> 1165
    //   #121	-> 1173
    //   #121	-> 1182
    //   #121	-> 1193
    //   #121	-> 1211
    //   #121	-> 1250
    //   #121	-> 1265
    //   #121	-> 1277
    //   #121	-> 1302
    //   #121	-> 1307
    //   #121	-> 1312
    //   #121	-> 1331
    //   #121	-> 1336
    //   #121	-> 1347
    //   #121	-> 1356
    //   #130	-> 1394
    //   #130	-> 1429
    //   #130	-> 1440
    //   #130	-> 1475
    //   #130	-> 1486
    //   #130	-> 1521
    //   #130	-> 1532
    //   #130	-> 1567
    //   #342	-> 2146
    //   #361	-> 2231
    //   #380	-> 2268
    //   #409	-> 2305
    //   #471	-> 2342
    //   #488	-> 2379
    //   #498	-> 2416
    //   #515	-> 2477
    //   #563	-> 2514
    //   #574	-> 2551
    //   #587	-> 2588
    //   #602	-> 2625
    //   #608	-> 2662
    //   #614	-> 2699
    //   #620	-> 2736
    //   #637	-> 2773
    //   #653	-> 2810
    //   #661	-> 2847
    //   #669	-> 2884
    //   #689	-> 2921
    //   #709	-> 2982
    //   #1787	-> 4346
    //   #1787	-> 4361
    //   #1787	-> 4385
    //   #1787	-> 4390
    //   #1789	-> 4425
    //   #1855	-> 4510
    //   #1891	-> 4619
    //   #1909	-> 4680
    //   #1916	-> 4717
    //   #1934	-> 4731
    //   #1934	-> 4734
    //   #1970	-> 4841 }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "clojure.spec.alpha");
    const__2 = (AFn)Symbol.intern(null, "clojure.core");
    const__3 = (Var)RT.var("clojure.core", "alias");
    const__4 = (AFn)Symbol.intern(null, "c");
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.core", "*warn-on-reflection*");
    const__7 = (Var)RT.var("clojure.spec.alpha", "def");
    const__8 = (Var)RT.var("clojure.spec.alpha", "*recursion-limit*");
    const__15 = (Keyword)RT.keyword(null, "doc");
    const__16 = (AFn)RT.map(new Object[] { RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(19), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj", RT.keyword(null, "doc"), "A soft limit on how many times a branching spec (or/alt/*/opt-keys/multi-spec)\n  can be recursed through during generation. After this a\n  non-recursive branch will be chosen." });
    const__17 = Long.valueOf(4L);
    const__18 = (Var)RT.var("clojure.spec.alpha", "*fspec-iterations*");
    const__20 = (AFn)RT.map(new Object[] { RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(25), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj", RT.keyword(null, "doc"), "The number of times an anonymous fn specified by fspec will be (generatively) tested during conform" });
    const__21 = Long.valueOf(21L);
    const__22 = (Var)RT.var("clojure.spec.alpha", "*coll-check-limit*");
    const__24 = (AFn)RT.map(new Object[] { RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(29), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj", RT.keyword(null, "doc"), "The number of elements validated in a collection spec'ed with 'every'" });
    const__25 = Long.valueOf(101L);
    const__26 = (Var)RT.var("clojure.spec.alpha", "*coll-error-limit*");
    const__28 = (AFn)RT.map(new Object[] { RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(33), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj", RT.keyword(null, "doc"), "The number of errors reported by explain in a collection spec'ed with 'every'" });
    const__29 = Long.valueOf(20L);
    const__30 = RT.classForName("clojure.spec.alpha.Spec");
    const__31 = (Var)RT.var("clojure.core", "alter-meta!");
    const__32 = (Var)RT.var("clojure.spec.alpha", "Spec");
    const__33 = (Var)RT.var("clojure.core", "assoc");
    const__34 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__35 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "conform*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "x")) })) })), ((IObj)Symbol.intern(null, "unform*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "y")) })) })), ((IObj)Symbol.intern(null, "explain*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "path"), Symbol.intern(null, "via"), Symbol.intern(null, "in"), Symbol.intern(null, "x")) })) })), ((IObj)Symbol.intern(null, "gen*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "overrides"), Symbol.intern(null, "path"), Symbol.intern(null, "rmap")) })) })), ((IObj)Symbol.intern(null, "with-gen*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "gfn")) })) })), ((IObj)Symbol.intern(null, "describe*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec")) })) })) }));
    const__36 = (Var)RT.var("clojure.core", "alter-var-root");
    const__37 = (Var)RT.var("clojure.core", "merge");
    const__41 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.spec.alpha.Spec"), RT.keyword(null, "on-interface"), RT.classForName("clojure.spec.alpha.Spec") });
    const__42 = (Keyword)RT.keyword(null, "sigs");
    const__43 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "conform*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "conform*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "x")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), null }), RT.keyword(null, "unform*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "unform*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "y")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "y")) })), RT.keyword(null, "doc"), null }), RT.keyword(null, "explain*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "explain*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "path"), Symbol.intern(null, "via"), Symbol.intern(null, "in"), Symbol.intern(null, "x")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "path"), Symbol.intern(null, "via"), Symbol.intern(null, "in"), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), null }), RT.keyword(null, "gen*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "gen*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "overrides"), Symbol.intern(null, "path"), Symbol.intern(null, "rmap")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "overrides"), Symbol.intern(null, "path"), Symbol.intern(null, "rmap")) })), RT.keyword(null, "doc"), null }), RT.keyword(null, "with-gen*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "with-gen*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "gfn")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "gfn")) })), RT.keyword(null, "doc"), null }), 
          RT.keyword(null, "describe*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "describe*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec")) })), RT.keyword(null, "doc"), null }) });
    const__44 = (Keyword)RT.keyword(null, "var");
    const__45 = (Keyword)RT.keyword(null, "method-map");
    const__52 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "with-gen*"), RT.keyword(null, "with-gen*"), RT.keyword(null, "unform*"), RT.keyword(null, "unform*"), RT.keyword(null, "gen*"), RT.keyword(null, "gen*"), RT.keyword(null, "conform*"), RT.keyword(null, "conform*"), RT.keyword(null, "explain*"), RT.keyword(null, "explain*"), 
          RT.keyword(null, "describe*"), RT.keyword(null, "describe*") });
    const__53 = (Keyword)RT.keyword(null, "method-builders");
    const__54 = (Var)RT.var("clojure.core", "intern");
    const__55 = (Var)RT.var("clojure.core", "*ns*");
    const__56 = (Var)RT.var("clojure.core", "with-meta");
    const__57 = (AFn)((IObj)Symbol.intern(null, "with-gen*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "gfn")) })) }));
    const__58 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "with-gen*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "gfn")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "gfn")) })), RT.keyword(null, "doc"), null });
    const__59 = (Keyword)RT.keyword(null, "protocol");
    const__60 = (AFn)((IObj)Symbol.intern(null, "describe*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec")) })) }));
    const__61 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "describe*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec")) })), RT.keyword(null, "doc"), null });
    const__62 = (AFn)((IObj)Symbol.intern(null, "explain*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "path"), Symbol.intern(null, "via"), Symbol.intern(null, "in"), Symbol.intern(null, "x")) })) }));
    const__63 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "explain*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "path"), Symbol.intern(null, "via"), Symbol.intern(null, "in"), Symbol.intern(null, "x")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "path"), Symbol.intern(null, "via"), Symbol.intern(null, "in"), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), null });
    const__64 = (AFn)((IObj)Symbol.intern(null, "gen*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "overrides"), Symbol.intern(null, "path"), Symbol.intern(null, "rmap")) })) }));
    const__65 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "gen*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "overrides"), Symbol.intern(null, "path"), Symbol.intern(null, "rmap")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "overrides"), Symbol.intern(null, "path"), Symbol.intern(null, "rmap")) })), RT.keyword(null, "doc"), null });
    const__66 = (AFn)((IObj)Symbol.intern(null, "unform*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "y")) })) }));
    const__67 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "unform*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "y")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "y")) })), RT.keyword(null, "doc"), null });
    const__68 = (AFn)((IObj)Symbol.intern(null, "conform*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "x")) })) }));
    const__69 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "conform*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "x")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), null });
    const__70 = (Var)RT.var("clojure.core", "-reset-methods");
    const__71 = (AFn)Symbol.intern(null, "Spec");
    const__72 = (Var)RT.var("clojure.spec.alpha", "deep-resolve");
    const__77 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reg"), Symbol.intern(null, "k")) })), RT.keyword(null, "line"), Integer.valueOf(47), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__78 = (Var)RT.var("clojure.spec.alpha", "reg-resolve");
    const__81 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "k")) })), RT.keyword(null, "doc"), "returns the spec/regex at end of alias chain starting with k, nil if not found, k if k not ident", RT.keyword(null, "line"), Integer.valueOf(53), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__82 = (Var)RT.var("clojure.spec.alpha", "reg-resolve!");
    const__85 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "k")) })), RT.keyword(null, "doc"), "returns the spec/regex at end of alias chain starting with k, throws if not found, k if k not ident", RT.keyword(null, "line"), Integer.valueOf(64), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__86 = (Var)RT.var("clojure.spec.alpha", "spec?");
    const__89 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "returns x if x is a spec object, else logical false", RT.keyword(null, "line"), Integer.valueOf(72), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__90 = (Var)RT.var("clojure.spec.alpha", "regex?");
    const__93 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "returns x if x is a (clojure.spec) regex op, else logical false", RT.keyword(null, "line"), Integer.valueOf(78), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__94 = (Var)RT.var("clojure.spec.alpha", "with-name");
    const__97 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "name")) })), RT.keyword(null, "line"), Integer.valueOf(83), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__98 = (Var)RT.var("clojure.spec.alpha", "spec-name");
  }
  
  public static void __init1() {
    const__101 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec")) })), RT.keyword(null, "line"), Integer.valueOf(91), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__102 = (Var)RT.var("clojure.spec.alpha", "spec-impl");
    const__105 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(100), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__106 = (Var)RT.var("clojure.spec.alpha", "regex-spec-impl");
    const__108 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(101), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__109 = (Var)RT.var("clojure.spec.alpha", "maybe-spec");
    const__112 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec-or-k")) })), RT.keyword(null, "doc"), "spec-or-k must be a spec, regex or resolvable kw/sym, else returns nil.", RT.keyword(null, "line"), Integer.valueOf(103), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__113 = (Var)RT.var("clojure.spec.alpha", "the-spec");
    const__116 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec-or-k")) })), RT.keyword(null, "doc"), "spec-or-k must be a spec, regex or kw/sym, else returns nil. Throws if unresolvable kw/sym", RT.keyword(null, "line"), Integer.valueOf(114), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__117 = RT.classForName("clojure.spec.alpha.Specize");
    const__118 = (Var)RT.var("clojure.spec.alpha", "Specize");
    const__119 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "specize*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")), Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "form")) })) })) }));
    const__121 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.spec.alpha.Specize"), RT.keyword(null, "on-interface"), RT.classForName("clojure.spec.alpha.Specize") });
    const__122 = (AFn)RT.map(new Object[] { RT.keyword(null, "specize*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "specize*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")), Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "form")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")), Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), null }) });
    const__123 = (Keyword)RT.keyword(null, "specize*");
    const__124 = (AFn)RT.map(new Object[] { RT.keyword(null, "specize*"), RT.keyword(null, "specize*") });
    const__125 = (AFn)((IObj)Symbol.intern(null, "specize*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")), Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "form")) })) }));
    const__126 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "specize*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")), Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "form")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")), Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), null });
    const__127 = (AFn)Symbol.intern(null, "Specize");
    const__128 = (Var)RT.var("clojure.spec.alpha", "fn-sym");
    const__131 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "f")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Object") }))) })), RT.keyword(null, "line"), Integer.valueOf(124), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__132 = (Var)RT.var("clojure.core", "extend");
    const__133 = RT.classForName("clojure.lang.Keyword");
    const__134 = RT.classForName("clojure.lang.Symbol");
    const__135 = RT.classForName("clojure.lang.IPersistentSet");
    const__136 = RT.classForName("java.lang.Object");
    const__137 = (Var)RT.var("clojure.spec.alpha", "specize");
    const__140 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")), Tuple.create(Symbol.intern(null, "s"), Symbol.intern(null, "form")) })), RT.keyword(null, "line"), Integer.valueOf(151), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__141 = (Var)RT.var("clojure.spec.alpha", "invalid?");
    const__144 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ret")) })), RT.keyword(null, "doc"), "tests the validity of a conform return value", RT.keyword(null, "line"), Integer.valueOf(155), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__145 = (Var)RT.var("clojure.spec.alpha", "conform");
    const__148 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Given a spec and a value, returns :clojure.spec.alpha/invalid \n\tif value does not match spec, else the (possibly destructured) value.", RT.keyword(null, "line"), Integer.valueOf(160), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__149 = (Var)RT.var("clojure.spec.alpha", "unform");
    const__152 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Given a spec and a value created by or compliant with a call to\n  'conform' with the same spec, returns a value with all conform\n  destructuring undone.", RT.keyword(null, "line"), Integer.valueOf(166), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__153 = (Var)RT.var("clojure.spec.alpha", "form");
    const__156 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec")) })), RT.keyword(null, "doc"), "returns the spec as data", RT.keyword(null, "line"), Integer.valueOf(173), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__157 = (Var)RT.var("clojure.spec.alpha", "abbrev");
    const__160 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")) })), RT.keyword(null, "line"), Integer.valueOf(179), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__161 = (Var)RT.var("clojure.spec.alpha", "describe");
    const__164 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec")) })), RT.keyword(null, "doc"), "returns an abbreviated description of the spec as data", RT.keyword(null, "line"), Integer.valueOf(198), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__165 = (Var)RT.var("clojure.spec.alpha", "with-gen");
    const__168 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "gen-fn")) })), RT.keyword(null, "doc"), "Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator", RT.keyword(null, "line"), Integer.valueOf(203), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__169 = (Var)RT.var("clojure.spec.alpha", "explain-data*");
    const__172 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "path"), Symbol.intern(null, "via"), Symbol.intern(null, "in"), Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(211), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__173 = (Var)RT.var("clojure.spec.alpha", "explain-data");
    const__176 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Given a spec and a value x which ought to conform, returns nil if x\n  conforms, else a map with at least the key ::problems whose value is\n  a collection of problem-maps, where problem-map has at least :path :pred and :val\n  keys describing the predicate and the value that failed at that\n  path.", RT.keyword(null, "line"), Integer.valueOf(218), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__177 = (Var)RT.var("clojure.spec.alpha", "explain-printer");
    const__180 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ed")) })), RT.keyword(null, "doc"), "Default printer for explain-data. nil indicates a successful validation.", RT.keyword(null, "line"), Integer.valueOf(227), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__181 = (Var)RT.var("clojure.spec.alpha", "*explain-out*");
    const__183 = (AFn)RT.map(new Object[] { RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(252), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__184 = (Var)RT.var("clojure.spec.alpha", "explain-out");
    const__187 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ed")) })), RT.keyword(null, "doc"), "Prints explanation data (per 'explain-data') to *out* using the printer in *explain-out*,\n   by default explain-printer.", RT.keyword(null, "line"), Integer.valueOf(254), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__188 = (Var)RT.var("clojure.spec.alpha", "explain");
    const__191 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Given a spec and a value that fails to conform, prints an explanation to *out*.", RT.keyword(null, "line"), Integer.valueOf(260), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__192 = (Var)RT.var("clojure.spec.alpha", "explain-str");
    const__195 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Given a spec and a value that fails to conform, returns an explanation as a string.", RT.keyword(null, "line"), Integer.valueOf(265), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__196 = (Var)RT.var("clojure.spec.alpha", "valid?");
    const__198 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(270), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__199 = (Var)RT.var("clojure.spec.alpha", "gensub");
  }
  
  public static void __init2() {
    const__202 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "overrides"), Symbol.intern(null, "path"), Symbol.intern(null, "rmap"), Symbol.intern(null, "form")) })), RT.keyword(null, "line"), Integer.valueOf(272), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__203 = (Var)RT.var("clojure.spec.alpha", "gen");
    const__206 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec")), Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "overrides")) })), RT.keyword(null, "doc"), "Given a spec, returns the generator for it, or throws if none can\n  be constructed. Optionally an overrides map can be provided which\n  should map spec names or paths (vectors of keywords) to no-arg\n  generator-creating fns. These will be used instead of the generators at those\n  names/paths. Note that parent generator (in the spec or overrides\n  map) will supersede those of any subtrees. A generator for a regex\n  op must always return a sequential collection (i.e. a generator for\n  s/? should return either an empty sequence/vector or a\n  sequence/vector with one item in it)", RT.keyword(null, "line"), Integer.valueOf(285), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__207 = (Var)RT.var("clojure.spec.alpha", "->sym");
    const__210 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns a symbol from a symbol or var", RT.keyword(null, "line"), Integer.valueOf(298), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__211 = (Var)RT.var("clojure.spec.alpha", "unfn");
    const__214 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "expr")) })), RT.keyword(null, "line"), Integer.valueOf(307), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__215 = (Var)RT.var("clojure.spec.alpha", "res");
    const__218 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")) })), RT.keyword(null, "line"), Integer.valueOf(315), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__219 = (Var)RT.var("clojure.spec.alpha", "def-impl");
    const__223 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "skip-wiki"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "k"), Symbol.intern(null, "form"), Symbol.intern(null, "spec")) })), RT.keyword(null, "doc"), "Do not call this directly, use 'def'", RT.keyword(null, "line"), Integer.valueOf(322), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__224 = (Var)RT.var("clojure.spec.alpha", "ns-qualify");
    const__227 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Qualify symbol s by resolving it or using the current *ns*.", RT.keyword(null, "line"), Integer.valueOf(334), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__230 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "k"), Symbol.intern(null, "spec-form")) })), RT.keyword(null, "doc"), "Given a namespace-qualified keyword or resolvable symbol k, and a\n  spec, spec-name, predicate or regex-op makes an entry in the\n  registry mapping k to the spec. Use nil to remove an entry in\n  the registry for k.", RT.keyword(null, "line"), Integer.valueOf(342), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__231 = (Var)RT.var("clojure.spec.alpha", "registry");
    const__234 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "returns the registry map, prefer 'get-spec' to lookup a spec by name", RT.keyword(null, "line"), Integer.valueOf(351), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__235 = (Var)RT.var("clojure.spec.alpha", "get-spec");
    const__238 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "k")) })), RT.keyword(null, "doc"), "Returns spec registered for keyword/symbol/var k, or nil.", RT.keyword(null, "line"), Integer.valueOf(356), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__239 = (Var)RT.var("clojure.spec.alpha", "spec");
    const__242 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "&"), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "gen")) })) })), RT.keyword(null, "doc"), "Takes a single predicate form, e.g. can be the name of a predicate,\n  like even?, or a fn literal like #(< % 42). Note that it is not\n  generally necessary to wrap predicates in spec when using the rest\n  of the spec macros, only to attach a unique generator\n\n  Can also be passed the result of one of the regex ops -\n  cat, alt, *, +, ?, in which case it will return a regex-conforming\n  spec, useful when nesting an independent regex.\n  ---\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.\n\n  Returns a spec.", RT.keyword(null, "line"), Integer.valueOf(361), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__243 = (Var)RT.var("clojure.spec.alpha", "multi-spec");
    const__246 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "mm"), Symbol.intern(null, "retag")) })), RT.keyword(null, "doc"), "Takes the name of a spec/predicate-returning multimethod and a\n  tag-restoring keyword or fn (retag).  Returns a spec that when\n  conforming or explaining data will pass it to the multimethod to get\n  an appropriate spec. You can e.g. use multi-spec to dynamically and\n  extensibly associate specs with 'tagged' data (i.e. data where one\n  of the fields indicates the shape of the rest of the structure).\n\n  (defmulti mspec :tag)\n\n  The methods should ignore their argument and return a predicate/spec:\n  (defmethod mspec :int [_] (s/keys :req-un [::tag ::i]))\n\n  retag is used during generation to retag generated values with\n  matching tags. retag can either be a keyword, at which key the\n  dispatch-tag will be assoc'ed, or a fn of generated value and\n  dispatch-tag that should return an appropriately retagged value.\n\n  Note that because the tags themselves comprise an open set,\n  the tag key spec cannot enumerate the values, but can e.g.\n  test for keyword?.\n\n  Note also that the dispatch values of the multimethod will be\n  included in the path, i.e. in reporting and gen overrides, even\n  though those values are not evident in the spec.\n", RT.keyword(null, "line"), Integer.valueOf(380), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__247 = (Var)RT.var("clojure.spec.alpha", "keys");
    const__250 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "req"), Symbol.intern(null, "req-un"), Symbol.intern(null, "opt"), Symbol.intern(null, "opt-un"), Symbol.intern(null, "gen")) })) })), RT.keyword(null, "doc"), "Creates and returns a map validating spec. :req and :opt are both\n  vectors of namespaced-qualified keywords. The validator will ensure\n  the :req keys are present. The :opt keys serve as documentation and\n  may be used by the generator.\n\n  The :req key vector supports 'and' and 'or' for key groups:\n\n  (s/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])\n\n  There are also -un versions of :req and :opt. These allow\n  you to connect unqualified keys to specs.  In each case, fully\n  qualfied keywords are passed, which name the specs, but unqualified\n  keys (with the same name component) are expected and checked at\n  conform-time, and generated during gen:\n\n  (s/keys :req-un [:my.ns/x :my.ns/y])\n\n  The above says keys :x and :y are required, and will be validated\n  and generated by specs (if they exist) named :my.ns/x :my.ns/y \n  respectively.\n\n  In addition, the values of *all* namespace-qualified keys will be validated\n  (and possibly destructured) by any registered specs. Note: there is\n  no support for inline value specification, by design.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.", RT.keyword(null, "line"), Integer.valueOf(409), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__251 = (Var)RT.var("clojure.spec.alpha", "or");
    const__254 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "key-pred-forms")) })), RT.keyword(null, "doc"), "Takes key+pred pairs, e.g.\n\n  (s/or :even even? :small #(< % 42))\n\n  Returns a destructuring spec that returns a map entry containing the\n  key of the first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.", RT.keyword(null, "line"), Integer.valueOf(471), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__255 = (Var)RT.var("clojure.spec.alpha", "and");
    const__258 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "pred-forms")) })), RT.keyword(null, "doc"), "Takes predicate/spec-forms, e.g.\n\n  (s/and even? #(< % 42))\n\n  Returns a spec that returns the conformed value. Successive\n  conformed values propagate through rest of predicates.", RT.keyword(null, "line"), Integer.valueOf(488), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__259 = (Var)RT.var("clojure.spec.alpha", "merge");
    const__262 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "pred-forms")) })), RT.keyword(null, "doc"), "Takes map-validating specs (e.g. 'keys' specs) and\n  returns a spec that returns a conformed map satisfying all of the\n  specs.  Unlike 'and', merge can generate maps satisfying the\n  union of the predicates.", RT.keyword(null, "line"), Integer.valueOf(498), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__263 = (Var)RT.var("clojure.spec.alpha", "res-kind");
    const__266 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "opts")) })), RT.keyword(null, "line"), Integer.valueOf(506), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__267 = (Var)RT.var("clojure.spec.alpha", "every");
    const__270 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "&"), RT.map(new Object[] { RT.keyword(null, "keys"), RT.vector(new Object[] { Symbol.intern(null, "into"), Symbol.intern(null, "kind"), Symbol.intern(null, "count"), Symbol.intern(null, "max-count"), Symbol.intern(null, "min-count"), Symbol.intern(null, "distinct"), Symbol.intern(null, "gen-max"), Symbol.intern(null, "gen") }), RT.keyword(null, "as"), Symbol.intern(null, "opts") })) })), RT.keyword(null, "doc"), "takes a pred and validates collection elements against that pred.\n\n  Note that 'every' does not do exhaustive checking, rather it samples\n  *coll-check-limit* elements. Nor (as a result) does it do any\n  conforming of elements. 'explain' will report at most *coll-error-limit*\n  problems.  Thus 'every' should be suitable for potentially large\n  collections.\n\n  Takes several kwargs options that further constrain the collection:\n\n  :kind - a pred that the collection type must satisfy, e.g. vector?\n        (default nil) Note that if :kind is specified and :into is\n        not, this pred must generate in order for every to generate.\n  :count - specifies coll has exactly this count (default nil)\n  :min-count, :max-count - coll has count (<= min-count count max-count) (defaults nil)\n  :distinct - all the elements are distinct (default nil)\n\n  And additional args that control gen\n\n  :gen-max - the maximum coll size to generate (default 20)\n  :into - one of [], (), {}, #{} - the default collection to generate into\n      (default: empty coll as generated by :kind pred if supplied, else [])\n  \n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator\n\n  See also - coll-of, every-kv\n", RT.keyword(null, "line"), Integer.valueOf(515), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__271 = (Var)RT.var("clojure.spec.alpha", "every-kv");
    const__274 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "kpred"), Symbol.intern(null, "vpred"), Symbol.intern(null, "&"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "like 'every' but takes separate key and val preds and works on associative collections.\n\n  Same options as 'every', :into defaults to {}\n\n  See also - map-of", RT.keyword(null, "line"), Integer.valueOf(563), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__275 = (Var)RT.var("clojure.spec.alpha", "coll-of");
    const__278 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "&"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Returns a spec for a collection of items satisfying pred. Unlike\n  'every', coll-of will exhaustively conform every value.\n\n  Same options as 'every'. conform will produce a collection\n  corresponding to :into if supplied, else will match the input collection,\n  avoiding rebuilding when possible.\n\n  See also - every, map-of", RT.keyword(null, "line"), Integer.valueOf(574), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__279 = (Var)RT.var("clojure.spec.alpha", "map-of");
    const__282 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "kpred"), Symbol.intern(null, "vpred"), Symbol.intern(null, "&"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Returns a spec for a map whose keys satisfy kpred and vals satisfy\n  vpred. Unlike 'every-kv', map-of will exhaustively conform every\n  value.\n\n  Same options as 'every', :kind defaults to map?, with the addition of:\n\n  :conform-keys - conform keys as well as values (default false)\n\n  See also - every-kv", RT.keyword(null, "line"), Integer.valueOf(587), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__283 = (Var)RT.var("clojure.spec.alpha", "*");
    const__286 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred-form")) })), RT.keyword(null, "doc"), "Returns a regex op that matches zero or more values matching\n  pred. Produces a vector of matches iff there is at least one match", RT.keyword(null, "line"), Integer.valueOf(602), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__287 = (Var)RT.var("clojure.spec.alpha", "+");
    const__290 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred-form")) })), RT.keyword(null, "doc"), "Returns a regex op that matches one or more values matching\n  pred. Produces a vector of matches", RT.keyword(null, "line"), Integer.valueOf(608), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__291 = (Var)RT.var("clojure.spec.alpha", "?");
    const__294 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred-form")) })), RT.keyword(null, "doc"), "Returns a regex op that matches zero or one value matching\n  pred. Produces a single value (not a collection) if matched.", RT.keyword(null, "line"), Integer.valueOf(614), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__295 = (Var)RT.var("clojure.spec.alpha", "alt");
    const__298 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "key-pred-forms")) })), RT.keyword(null, "doc"), "Takes key+pred pairs, e.g.\n\n  (s/alt :even even? :small #(< % 42))\n\n  Returns a regex op that returns a map entry containing the key of the\n  first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return", RT.keyword(null, "line"), Integer.valueOf(620), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__299 = (Var)RT.var("clojure.spec.alpha", "cat");
  }
  
  public static void __init3() {
    const__302 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "key-pred-forms")) })), RT.keyword(null, "doc"), "Takes key+pred pairs, e.g.\n\n  (s/cat :e even? :o odd?)\n\n  Returns a regex op that matches (all) values in sequence, returning a map\n  containing the keys of each pred and the corresponding value.", RT.keyword(null, "line"), Integer.valueOf(637), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__303 = (Var)RT.var("clojure.spec.alpha", "&");
    const__306 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "re"), Symbol.intern(null, "&"), Symbol.intern(null, "preds")) })), RT.keyword(null, "doc"), "takes a regex op re, and predicates. Returns a regex-op that consumes\n  input as per re but subjects the resulting value to the\n  conjunction of the predicates, and any conforming they might perform.", RT.keyword(null, "line"), Integer.valueOf(653), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__307 = (Var)RT.var("clojure.spec.alpha", "conformer");
    const__310 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "unf")) })), RT.keyword(null, "doc"), "takes a predicate function with the semantics of conform i.e. it should return either a\n  (possibly converted) value or :clojure.spec.alpha/invalid, and returns a\n  spec that uses it as a predicate/conformer. Optionally takes a\n  second fn that does unform of result of first", RT.keyword(null, "line"), Integer.valueOf(661), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__311 = (Var)RT.var("clojure.spec.alpha", "fspec");
    const__314 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "args"), Symbol.intern(null, "ret"), Symbol.intern(null, "fn"), Symbol.intern(null, "gen")), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "ret"), PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "quote"), Symbol.intern("clojure.core", "any?") })) }) })) })), RT.keyword(null, "doc"), "takes :args :ret and (optional) :fn kwargs whose values are preds\n  and returns a spec whose conform/explain take a fn and validates it\n  using generative testing. The conformed value is always the fn itself.\n\n  See 'fdef' for a single operation that creates an fspec and\n  registers it, as well as a full description of :args, :ret and :fn\n\n  fspecs can generate functions that validate the arguments and\n  fabricate a return value compliant with the :ret spec, ignoring\n  the :fn spec if present.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args\n  that returns a test.check generator.", RT.keyword(null, "line"), Integer.valueOf(669), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__315 = (Var)RT.var("clojure.spec.alpha", "tuple");
    const__318 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "preds")) })), RT.keyword(null, "doc"), "takes one or more preds and returns a spec for a tuple, a vector\n  where each element conforms to the corresponding pred. Each element\n  will be referred to in paths using its ordinal.", RT.keyword(null, "line"), Integer.valueOf(689), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__319 = (Var)RT.var("clojure.spec.alpha", "macroexpand-check");
    const__322 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "v"), Symbol.intern(null, "args")) })), RT.keyword(null, "line"), Integer.valueOf(697), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__323 = (Var)RT.var("clojure.spec.alpha", "fdef");
    const__326 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fn-sym"), Symbol.intern(null, "&"), Symbol.intern(null, "specs")) })), RT.keyword(null, "doc"), "Takes a symbol naming a function, and one or more of the following:\n\n  :args A regex spec for the function arguments as they were a list to be\n    passed to apply - in this way, a single spec can handle functions with\n    multiple arities\n  :ret A spec for the function's return value\n  :fn A spec of the relationship between args and ret - the\n    value passed is {:args conformed-args :ret conformed-ret} and is\n    expected to contain predicates that relate those values\n\n  Qualifies fn-sym with resolve, or using *ns* if no resolution found.\n  Registers an fspec in the global registry, where it can be retrieved\n  by calling get-spec with the var or fully-qualified symbol.\n\n  Once registered, function specs are included in doc, checked by\n  instrument, tested by the runner clojure.spec.test.alpha/check, and (if\n  a macro) used to explain errors during macroexpansion.\n\n  Note that :fn specs require the presence of :args and :ret specs to\n  conform values, and so :fn specs will be ignored if :args or :ret\n  are missing.\n\n  Returns the qualified fn-sym.\n\n  For example, to register function specs for the symbol function:\n\n  (s/fdef clojure.core/symbol\n    :args (s/alt :separate (s/cat :ns string? :n string?)\n                 :str string?\n                 :sym symbol?)\n    :ret symbol?)", RT.keyword(null, "line"), Integer.valueOf(709), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__327 = (Var)RT.var("clojure.spec.alpha", "recur-limit?");
    const__330 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rmap"), Symbol.intern(null, "id"), Symbol.intern(null, "path"), Symbol.intern(null, "k")) })), RT.keyword(null, "line"), Integer.valueOf(745), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__331 = (Var)RT.var("clojure.spec.alpha", "inck");
    const__334 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "k")) })), RT.keyword(null, "line"), Integer.valueOf(749), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__335 = (Var)RT.var("clojure.spec.alpha", "dt");
    const__338 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "x"), Symbol.intern(null, "form")), Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "x"), Symbol.intern(null, "form"), Symbol.intern(null, "cpred?")) })), RT.keyword(null, "line"), Integer.valueOf(752), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__341 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "x"), Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Helper function that returns true when x is valid for spec.", RT.keyword(null, "line"), Integer.valueOf(765), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__342 = (Var)RT.var("clojure.spec.alpha", "pvalid?");
    const__345 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "x")), Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "x"), Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "internal helper function that returns true when x is valid for spec.", RT.keyword(null, "line"), Integer.valueOf(774), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__346 = (Var)RT.var("clojure.spec.alpha", "explain-1");
    const__349 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "pred"), Symbol.intern(null, "path"), Symbol.intern(null, "via"), Symbol.intern(null, "in"), Symbol.intern(null, "v")) })), RT.keyword(null, "line"), Integer.valueOf(781), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__350 = (Var)RT.var("clojure.spec.alpha", "or-k-gen");
    const__352 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(788), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__353 = (Var)RT.var("clojure.spec.alpha", "and-k-gen");
    const__355 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(788), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__356 = (Var)RT.var("clojure.spec.alpha", "k-gen");
    const__359 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "returns a generator for form f, which can be a keyword or a list\n  starting with 'or or 'and.", RT.keyword(null, "line"), Integer.valueOf(790), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__362 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")), Tuple.create(Symbol.intern(null, "min-count"), Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "returns a tuple generator made up of generators for a random subset\n  of min-count (default 0) to all elements in s.", RT.keyword(null, "line"), Integer.valueOf(799), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__365 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "returns a tuple generator made up of generators for every element\n  in s.", RT.keyword(null, "line"), Integer.valueOf(810), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__366 = (Var)RT.var("clojure.spec.alpha", "map-spec-impl");
    const__369 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "skip-wiki"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), RT.vector(new Object[] { 
                          Symbol.intern(null, "req-un"), Symbol.intern(null, "opt-un"), Symbol.intern(null, "keys-pred"), Symbol.intern(null, "pred-exprs"), Symbol.intern(null, "opt-keys"), Symbol.intern(null, "req-specs"), Symbol.intern(null, "req"), Symbol.intern(null, "req-keys"), Symbol.intern(null, "opt-specs"), Symbol.intern(null, "pred-forms"), 
                          Symbol.intern(null, "opt"), Symbol.intern(null, "gfn") }), RT.keyword(null, "as"), Symbol.intern(null, "argm") })) })), RT.keyword(null, "doc"), "Do not call this directly, use 'spec' with a map argument", RT.keyword(null, "line"), Integer.valueOf(817), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__372 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "skip-wiki"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "pred"), Symbol.intern(null, "gfn"), Symbol.intern(null, "cpred?")), Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "pred"), Symbol.intern(null, "gfn"), Symbol.intern(null, "cpred?"), Symbol.intern(null, "unc")) })), RT.keyword(null, "doc"), "Do not call this directly, use 'spec'", RT.keyword(null, "line"), Integer.valueOf(908), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__373 = (Var)RT.var("clojure.spec.alpha", "multi-spec-impl");
    const__376 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "skip-wiki"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "mmvar"), Symbol.intern(null, "retag")), Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "mmvar"), Symbol.intern(null, "retag"), Symbol.intern(null, "gfn")) })), RT.keyword(null, "doc"), "Do not call this directly, use 'multi-spec'", RT.keyword(null, "line"), Integer.valueOf(941), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__377 = (Var)RT.var("clojure.spec.alpha", "tuple-impl");
    const__380 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "skip-wiki"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "forms"), Symbol.intern(null, "preds")), Tuple.create(Symbol.intern(null, "forms"), Symbol.intern(null, "preds"), Symbol.intern(null, "gfn")) })), RT.keyword(null, "doc"), "Do not call this directly, use 'tuple'", RT.keyword(null, "line"), Integer.valueOf(991), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__381 = (Var)RT.var("clojure.spec.alpha", "tagged-ret");
    const__384 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "tag"), Symbol.intern(null, "ret")) })), RT.keyword(null, "line"), Integer.valueOf(1053), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__385 = (Var)RT.var("clojure.spec.alpha", "or-spec-impl");
    const__388 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "skip-wiki"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "keys"), Symbol.intern(null, "forms"), Symbol.intern(null, "preds"), Symbol.intern(null, "gfn")) })), RT.keyword(null, "doc"), "Do not call this directly, use 'or'", RT.keyword(null, "line"), Integer.valueOf(1056), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__389 = (Var)RT.var("clojure.spec.alpha", "and-preds");
    const__392 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "preds"), Symbol.intern(null, "forms")) })), RT.keyword(null, "line"), Integer.valueOf(1123), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__393 = (Var)RT.var("clojure.spec.alpha", "explain-pred-list");
    const__396 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "forms"), Symbol.intern(null, "preds"), Symbol.intern(null, "path"), Symbol.intern(null, "via"), Symbol.intern(null, "in"), Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(1135), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__397 = (Var)RT.var("clojure.spec.alpha", "and-spec-impl");
  }
  
  public static void __init4() {
    const__400 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "skip-wiki"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "forms"), Symbol.intern(null, "preds"), Symbol.intern(null, "gfn")) })), RT.keyword(null, "doc"), "Do not call this directly, use 'and'", RT.keyword(null, "line"), Integer.valueOf(1146), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__401 = (Var)RT.var("clojure.spec.alpha", "merge-spec-impl");
    const__404 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "skip-wiki"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "forms"), Symbol.intern(null, "preds"), Symbol.intern(null, "gfn")) })), RT.keyword(null, "doc"), "Do not call this directly, use 'merge'", RT.keyword(null, "line"), Integer.valueOf(1190), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__405 = (Var)RT.var("clojure.spec.alpha", "coll-prob");
    const__408 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { RT.vector(new Object[] { Symbol.intern(null, "x"), Symbol.intern(null, "kfn"), Symbol.intern(null, "kform"), Symbol.intern(null, "distinct"), Symbol.intern(null, "count"), Symbol.intern(null, "min-count"), Symbol.intern(null, "max-count"), Symbol.intern(null, "path"), Symbol.intern(null, "via"), Symbol.intern(null, "in") }) })), RT.keyword(null, "line"), Integer.valueOf(1218), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__409 = (Var)RT.var("clojure.spec.alpha", "empty-coll");
    const__411 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1238), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__412 = (AFn)Symbol.intern("clojure.core", "vector?");
    const__413 = (AFn)Symbol.intern("clojure.core", "set?");
    const__414 = (AFn)Symbol.intern("clojure.core", "list?");
    const__415 = (AFn)Symbol.intern("clojure.core", "map?");
    const__416 = (Var)RT.var("clojure.spec.alpha", "every-impl");
    const__419 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "skip-wiki"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "pred"), Symbol.intern(null, "opts")), Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "pred"), RT.map(new Object[] { Symbol.intern(null, "conform-into"), RT.keyword(null, "into"), Symbol.intern(null, "describe-form"), RT.keyword("clojure.spec.alpha", "describe"), RT.keyword(null, "keys"), RT.vector(new Object[] { 
                          Symbol.intern(null, "kind"), RT.keyword("clojure.spec.alpha", "kind-form"), Symbol.intern(null, "count"), Symbol.intern(null, "max-count"), Symbol.intern(null, "min-count"), Symbol.intern(null, "distinct"), Symbol.intern(null, "gen-max"), RT.keyword("clojure.spec.alpha", "kfn"), RT.keyword("clojure.spec.alpha", "cpred"), Symbol.intern(null, "conform-keys"), 
                          RT.keyword("clojure.spec.alpha", "conform-all") }), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "gen-max"), Long.valueOf(20L) }), RT.keyword(null, "as"), Symbol.intern(null, "opts") }), Symbol.intern(null, "gfn")) })), RT.keyword(null, "doc"), "Do not call this directly, use 'every', 'every-kv', 'coll-of' or 'map-of'", RT.keyword(null, "line"), Integer.valueOf(1240), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__420 = (Var)RT.var("clojure.spec.alpha", "accept");
    const__423 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(1375), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__424 = (Var)RT.var("clojure.spec.alpha", "accept?");
    const__427 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(RT.keyword("clojure.spec.alpha", "op")) })) })), RT.keyword(null, "line"), Integer.valueOf(1377), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__428 = (Var)RT.var("clojure.spec.alpha", "pcat*");
    const__431 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.map(new Object[] { Tuple.create(Symbol.intern(null, "p1"), Symbol.intern(null, "&"), Symbol.intern(null, "pr"), RT.keyword(null, "as"), Symbol.intern(null, "ps")), RT.keyword(null, "ps"), Tuple.create(Symbol.intern(null, "k1"), Symbol.intern(null, "&"), Symbol.intern(null, "kr"), RT.keyword(null, "as"), Symbol.intern(null, "ks")), RT.keyword(null, "ks"), Tuple.create(Symbol.intern(null, "f1"), Symbol.intern(null, "&"), Symbol.intern(null, "fr"), RT.keyword(null, "as"), Symbol.intern(null, "forms")), RT.keyword(null, "forms"), Symbol.intern(null, "ret"), RT.keyword(null, "ret"), Symbol.intern(null, "rep+"), RT.keyword(null, "rep+") })) })), RT.keyword(null, "line"), Integer.valueOf(1380), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__432 = (Var)RT.var("clojure.spec.alpha", "pcat");
    const__435 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "ps")) })), RT.keyword(null, "line"), Integer.valueOf(1390), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__436 = (Var)RT.var("clojure.spec.alpha", "cat-impl");
    const__439 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "skip-wiki"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ks"), Symbol.intern(null, "ps"), Symbol.intern(null, "forms")) })), RT.keyword(null, "doc"), "Do not call this directly, use 'cat'", RT.keyword(null, "line"), Integer.valueOf(1392), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__440 = (Var)RT.var("clojure.spec.alpha", "rep*");
    const__443 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p1"), Symbol.intern(null, "p2"), Symbol.intern(null, "ret"), Symbol.intern(null, "splice"), Symbol.intern(null, "form")) })), RT.keyword(null, "line"), Integer.valueOf(1397), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__444 = (Var)RT.var("clojure.spec.alpha", "rep-impl");
    const__447 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "skip-wiki"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "p")) })), RT.keyword(null, "doc"), "Do not call this directly, use '*'", RT.keyword(null, "line"), Integer.valueOf(1404), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__448 = (Var)RT.var("clojure.spec.alpha", "rep+impl");
    const__451 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "skip-wiki"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "p")) })), RT.keyword(null, "doc"), "Do not call this directly, use '+'", RT.keyword(null, "line"), Integer.valueOf(1408), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__452 = (Var)RT.var("clojure.spec.alpha", "amp-impl");
    const__455 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "skip-wiki"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "re"), Symbol.intern(null, "re-form"), Symbol.intern(null, "preds"), Symbol.intern(null, "pred-forms")) })), RT.keyword(null, "doc"), "Do not call this directly, use '&'", RT.keyword(null, "line"), Integer.valueOf(1413), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__456 = (Var)RT.var("clojure.spec.alpha", "filter-alt");
    const__459 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ps"), Symbol.intern(null, "ks"), Symbol.intern(null, "forms"), Symbol.intern(null, "f")) })), RT.keyword(null, "line"), Integer.valueOf(1418), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__460 = (Var)RT.var("clojure.spec.alpha", "alt*");
    const__463 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ps"), Symbol.intern(null, "ks"), Symbol.intern(null, "forms")) })), RT.keyword(null, "line"), Integer.valueOf(1427), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__464 = (Var)RT.var("clojure.spec.alpha", "alts");
    const__467 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "ps")) })), RT.keyword(null, "line"), Integer.valueOf(1439), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__468 = (Var)RT.var("clojure.spec.alpha", "alt2");
    const__471 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p1"), Symbol.intern(null, "p2")) })), RT.keyword(null, "line"), Integer.valueOf(1440), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__472 = (Var)RT.var("clojure.spec.alpha", "alt-impl");
    const__475 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "skip-wiki"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ks"), Symbol.intern(null, "ps"), Symbol.intern(null, "forms")) })), RT.keyword(null, "doc"), "Do not call this directly, use 'alt'", RT.keyword(null, "line"), Integer.valueOf(1442), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__476 = (Var)RT.var("clojure.spec.alpha", "maybe-impl");
    const__479 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "skip-wiki"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Do not call this directly, use '?'", RT.keyword(null, "line"), Integer.valueOf(1446), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__480 = (Var)RT.var("clojure.spec.alpha", "noret?");
    const__483 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p1"), Symbol.intern(null, "pret")) })), RT.keyword(null, "line"), Integer.valueOf(1450), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__484 = (Var)RT.var("clojure.spec.alpha", "preturn");
    const__486 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1456), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__487 = (Var)RT.var("clojure.spec.alpha", "accept-nil?");
    const__490 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p")) })), RT.keyword(null, "line"), Integer.valueOf(1458), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__491 = (Var)RT.var("clojure.spec.alpha", "add-ret");
    const__493 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(1470), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__496 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p")) })), RT.keyword(null, "line"), Integer.valueOf(1472), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__497 = (Var)RT.var("clojure.spec.alpha", "op-unform");
  }
  
  public static void __init5() {
    const__500 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(1487), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__503 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "r"), Symbol.intern(null, "k")) })), RT.keyword(null, "line"), Integer.valueOf(1508), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__504 = (Var)RT.var("clojure.spec.alpha", "deriv");
    const__507 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(1521), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__508 = (Var)RT.var("clojure.spec.alpha", "op-describe");
    const__511 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p")) })), RT.keyword(null, "line"), Integer.valueOf(1541), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__512 = (Var)RT.var("clojure.spec.alpha", "op-explain");
    const__515 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "p"), Symbol.intern(null, "path"), Symbol.intern(null, "via"), Symbol.intern(null, "in"), Symbol.intern(null, "input")) })), RT.keyword(null, "line"), Integer.valueOf(1557), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__516 = (Var)RT.var("clojure.spec.alpha", "re-gen");
    const__519 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "overrides"), Symbol.intern(null, "path"), Symbol.intern(null, "rmap"), Symbol.intern(null, "f")) })), RT.keyword(null, "line"), Integer.valueOf(1612), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__520 = (Var)RT.var("clojure.spec.alpha", "re-conform");
    const__523 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "&"), Symbol.intern(null, "xs"), RT.keyword(null, "as"), Symbol.intern(null, "data"))) })), RT.keyword(null, "line"), Integer.valueOf(1653), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__524 = (Var)RT.var("clojure.spec.alpha", "re-explain");
    const__527 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "path"), Symbol.intern(null, "via"), Symbol.intern(null, "in"), Symbol.intern(null, "re"), Symbol.intern(null, "input")) })), RT.keyword(null, "line"), Integer.valueOf(1666), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__530 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "skip-wiki"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "re"), Symbol.intern(null, "gfn")) })), RT.keyword(null, "doc"), "Do not call this directly, use 'spec' with a regex op argument", RT.keyword(null, "line"), Integer.valueOf(1692), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__531 = (Var)RT.var("clojure.spec.alpha", "call-valid?");
    const__534 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "specs"), Symbol.intern(null, "args")) })), RT.keyword(null, "line"), Integer.valueOf(1719), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__535 = (Var)RT.var("clojure.spec.alpha", "validate-fn");
    const__538 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "specs"), Symbol.intern(null, "iters")) })), RT.keyword(null, "doc"), "returns f if valid, else smallest", RT.keyword(null, "line"), Integer.valueOf(1730), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__539 = (Var)RT.var("clojure.spec.alpha", "fspec-impl");
    const__542 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "skip-wiki"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { RT.vector(new Object[] { Symbol.intern(null, "argspec"), Symbol.intern(null, "aform"), Symbol.intern(null, "retspec"), Symbol.intern(null, "rform"), Symbol.intern(null, "fnspec"), Symbol.intern(null, "fform"), Symbol.intern(null, "gfn") }) })), RT.keyword(null, "doc"), "Do not call this directly, use 'fspec'", RT.keyword(null, "line"), Integer.valueOf(1740), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__543 = (Keyword)RT.keyword("clojure.spec.alpha", "kvs->map");
    const__544 = PersistentList.create(Arrays.asList(new Object[] { Symbol.intern("clojure.spec.alpha", "conformer"), PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "fn*"), Tuple.create(Symbol.intern(null, "p1__2534#")), PersistentList.create(Arrays.asList(new Object[] { Symbol.intern("clojure.core", "zipmap"), PersistentList.create(Arrays.asList(new Object[] { Symbol.intern("clojure.core", "map"), RT.keyword("clojure.spec.alpha", "k"), Symbol.intern(null, "p1__2534#") })), PersistentList.create(Arrays.asList(new Object[] { Symbol.intern("clojure.core", "map"), RT.keyword("clojure.spec.alpha", "v"), Symbol.intern(null, "p1__2534#") })) })) })), PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "fn*"), Tuple.create(Symbol.intern(null, "p1__2535#")), PersistentList.create(Arrays.asList(new Object[] { Symbol.intern("clojure.core", "map"), PersistentList.create(Arrays.asList(new Object[] { Symbol.intern("clojure.core", "fn"), Tuple.create(Tuple.create(Symbol.intern(null, "k"), Symbol.intern(null, "v"))), RT.map(new Object[] { RT.keyword("clojure.spec.alpha", "k"), Symbol.intern(null, "k"), RT.keyword("clojure.spec.alpha", "v"), Symbol.intern(null, "v") }) })), Symbol.intern(null, "p1__2535#") })) })) }));
    const__545 = PersistentList.create(Arrays.asList(new Object[] { Symbol.intern("clojure.spec.alpha", "conformer"), PersistentList.create(Arrays.asList(new Object[] { Symbol.intern("clojure.core", "fn"), Tuple.create(Symbol.intern(null, "%")), PersistentList.create(Arrays.asList(new Object[] { Symbol.intern("clojure.core", "zipmap"), PersistentList.create(Arrays.asList(new Object[] { Symbol.intern("clojure.core", "map"), RT.keyword("clojure.spec.alpha", "k"), Symbol.intern(null, "%") })), PersistentList.create(Arrays.asList(new Object[] { Symbol.intern("clojure.core", "map"), RT.keyword("clojure.spec.alpha", "v"), Symbol.intern(null, "%") })) })) })), PersistentList.create(Arrays.asList(new Object[] { Symbol.intern("clojure.core", "fn"), Tuple.create(Symbol.intern(null, "%")), PersistentList.create(Arrays.asList(new Object[] { Symbol.intern("clojure.core", "map"), PersistentList.create(Arrays.asList(new Object[] { Symbol.intern("clojure.core", "fn"), Tuple.create(Tuple.create(Symbol.intern(null, "k"), Symbol.intern(null, "v"))), RT.map(new Object[] { RT.keyword("clojure.spec.alpha", "k"), Symbol.intern(null, "k"), RT.keyword("clojure.spec.alpha", "v"), Symbol.intern(null, "v") }) })), Symbol.intern(null, "%") })) })) }));
    const__546 = (Var)RT.var("clojure.spec.alpha", "keys*");
    const__549 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "kspecs")) })), RT.keyword(null, "doc"), "takes the same arguments as spec/keys and returns a regex op that matches sequences of key/values,\n  converts them into a map, and conforms that map with a corresponding\n  spec/keys call:\n\n  user=> (s/conform (s/keys :req-un [::a ::c]) {:a 1 :c 2})\n  {:a 1, :c 2}\n  user=> (s/conform (s/keys* :req-un [::a ::c]) [:a 1 :c 2])\n  {:a 1, :c 2}\n\n  the resulting regex op can be composed into a larger regex:\n\n  user=> (s/conform (s/cat :i1 integer? :m (s/keys* :req-un [::a ::c]) :i2 integer?) [42 :a 1 :c 2 :d 4 99])\n  {:i1 42, :m {:a 1, :c 2, :d 4}, :i2 99}", RT.keyword(null, "line"), Integer.valueOf(1789), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__550 = (Var)RT.var("clojure.spec.alpha", "nonconforming");
    const__553 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "skip-wiki"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec")) })), RT.keyword(null, "doc"), "takes a spec and returns a spec that has the same properties except\n  'conform' returns the original (not the conformed) value. Note, will specize regex ops.", RT.keyword(null, "line"), Integer.valueOf(1808), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__554 = (Var)RT.var("clojure.spec.alpha", "nilable-impl");
    const__557 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "skip-wiki"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "pred"), Symbol.intern(null, "gfn")) })), RT.keyword(null, "doc"), "Do not call this directly, use 'nilable'", RT.keyword(null, "line"), Integer.valueOf(1829), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__558 = (Var)RT.var("clojure.spec.alpha", "nilable");
    const__561 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred")) })), RT.keyword(null, "doc"), "returns a spec that accepts nil and values satisfying pred", RT.keyword(null, "line"), Integer.valueOf(1855), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__562 = (Var)RT.var("clojure.spec.alpha", "exercise");
    const__565 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec")), Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "n")), Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "n"), Symbol.intern(null, "overrides")) })), RT.keyword(null, "doc"), "generates a number (default 10) of values compatible with spec and maps conform over them,\n  returning a sequence of [val conformed-val] tuples. Optionally takes\n  a generator overrides map as per gen", RT.keyword(null, "line"), Integer.valueOf(1861), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__566 = (Var)RT.var("clojure.spec.alpha", "exercise-fn");
    const__569 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sym")), Tuple.create(Symbol.intern(null, "sym"), Symbol.intern(null, "n")), Tuple.create(Symbol.intern(null, "sym-or-f"), Symbol.intern(null, "n"), Symbol.intern(null, "fspec")) })), RT.keyword(null, "doc"), "exercises the fn named by sym (a symbol) by applying it to\n  n (default 10) generated samples of its args spec. When fspec is\n  supplied its arg spec is used, and sym-or-f can be a fn.  Returns a\n  sequence of tuples of [args ret]. ", RT.keyword(null, "line"), Integer.valueOf(1870), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__570 = (Var)RT.var("clojure.spec.alpha", "inst-in-range?");
    const__573 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "start"), Symbol.intern(null, "end"), Symbol.intern(null, "inst")) })), RT.keyword(null, "doc"), "Return true if inst at or after start and before end", RT.keyword(null, "line"), Integer.valueOf(1884), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__574 = (Var)RT.var("clojure.spec.alpha", "inst-in");
    const__577 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "start"), Symbol.intern(null, "end")) })), RT.keyword(null, "doc"), "Returns a spec that validates insts in the range from start\n(inclusive) to end (exclusive).", RT.keyword(null, "line"), Integer.valueOf(1891), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__578 = (Var)RT.var("clojure.spec.alpha", "int-in-range?");
    const__581 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "start"), Symbol.intern(null, "end"), Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "Return true if start <= val, val < end and val is a fixed\n  precision integer.", RT.keyword(null, "line"), Integer.valueOf(1903), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__582 = (Var)RT.var("clojure.spec.alpha", "int-in");
    const__585 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "start"), Symbol.intern(null, "end")) })), RT.keyword(null, "doc"), "Returns a spec that validates fixed precision integers in the\n  range from start (inclusive) to end (exclusive).", RT.keyword(null, "line"), Integer.valueOf(1909), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__586 = (Var)RT.var("clojure.spec.alpha", "double-in");
    const__589 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "infinite?"), Symbol.intern(null, "NaN?"), Symbol.intern(null, "min"), Symbol.intern(null, "max")), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "infinite?"), Boolean.TRUE, Symbol.intern(null, "NaN?"), Boolean.TRUE }), RT.keyword(null, "as"), Symbol.intern(null, "m") })) })), RT.keyword(null, "doc"), "Specs a 64-bit floating point number. Options:\n\n    :infinite? - whether +/- infinity allowed (default true)\n    :NaN?      - whether NaN allowed (default true)\n    :min       - minimum value (inclusive, default none)\n    :max       - maximum value (inclusive, default none)", RT.keyword(null, "line"), Integer.valueOf(1916), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__590 = (Var)RT.var("clojure.spec.alpha", "check-asserts?");
    const__593 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Returns the value set by check-asserts.", RT.keyword(null, "line"), Integer.valueOf(1945), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__594 = (Var)RT.var("clojure.spec.alpha", "check-asserts");
    const__597 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "flag")) })), RT.keyword(null, "doc"), "Enable or disable spec asserts that have been compiled\nwith '*compile-asserts*' true.  See 'assert'.\n\nInitially set to boolean value of clojure.spec.check-asserts\nsystem property. Defaults to false.", RT.keyword(null, "line"), Integer.valueOf(1950), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__598 = (Var)RT.var("clojure.spec.alpha", "assert*");
  }
  
  public static void __init6() {
    const__601 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Do not call this directly, use 'assert'.", RT.keyword(null, "line"), Integer.valueOf(1959), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
    const__602 = (Var)RT.var("clojure.spec.alpha", "assert");
    const__605 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "spec-checking assert expression. Returns x if x is valid? according\nto spec, else throws an ex-info with explain-data plus ::failure of\n:assertion-failed.\n\nCan be disabled at either compile time or runtime:\n\nIf *compile-asserts* is false at compile time, compiles to x. Defaults\nto value of 'clojure.spec.compile-asserts' system property, or true if\nnot set.\n\nIf (check-asserts?) is false at runtime, always returns x. Defaults to\nvalue of 'clojure.spec.check-asserts' system property, or false if not\nset. You can toggle check-asserts? with (check-asserts bool).", RT.keyword(null, "line"), Integer.valueOf(1970), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/alpha.clj" });
  }
  
  static  {
    __init0();
    __init1();
    __init2();
    __init3();
    __init4();
    __init5();
    __init6();
    Compiler.pushNSandLoader(RT.classForName("clojure.spec.alpha__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
