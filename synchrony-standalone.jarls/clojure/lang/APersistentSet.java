package clojure.lang;

import java.io.Serializable;
import java.util.Collection;
import java.util.Iterator;
import java.util.Set;

public abstract class APersistentSet extends AFn implements IPersistentSet, Collection, Set, Serializable, IHashEq {
  int _hash;
  
  int _hasheq;
  
  final IPersistentMap impl;
  
  protected APersistentSet(IPersistentMap impl) { this.impl = impl; }
  
  public String toString() { return RT.printString(this); }
  
  public boolean contains(Object key) { return this.impl.containsKey(key); }
  
  public Object get(Object key) { return this.impl.valAt(key); }
  
  public int count() { return this.impl.count(); }
  
  public ISeq seq() { return RT.keys(this.impl); }
  
  public Object invoke(Object arg1) { return get(arg1); }
  
  public boolean equals(Object obj) { return setEquals(this, obj); }
  
  public static boolean setEquals(IPersistentSet s1, Object obj) {
    if (s1 == obj)
      return true; 
    if (!(obj instanceof Set))
      return false; 
    Set m = (Set)obj;
    if (m.size() != s1.count())
      return false; 
    for (Object aM : m) {
      if (!s1.contains(aM))
        return false; 
    } 
    return true;
  }
  
  public boolean equiv(Object obj) {
    if (!(obj instanceof Set))
      return false; 
    Set m = (Set)obj;
    if (m.size() != size())
      return false; 
    for (Object aM : m) {
      if (!contains(aM))
        return false; 
    } 
    return true;
  }
  
  public int hashCode() {
    int hash = this._hash;
    if (hash == 0) {
      for (ISeq s = seq(); s != null; s = s.next()) {
        Object e = s.first();
        hash += Util.hash(e);
      } 
      this._hash = hash;
    } 
    return hash;
  }
  
  public int hasheq() {
    int cached = this._hasheq;
    if (cached == 0)
      this._hasheq = cached = Murmur3.hashUnordered(this); 
    return cached;
  }
  
  public Object[] toArray() { return RT.seqToArray(seq()); }
  
  public boolean add(Object o) { throw new UnsupportedOperationException(); }
  
  public boolean remove(Object o) { throw new UnsupportedOperationException(); }
  
  public boolean addAll(Collection c) { throw new UnsupportedOperationException(); }
  
  public void clear() { throw new UnsupportedOperationException(); }
  
  public boolean retainAll(Collection c) { throw new UnsupportedOperationException(); }
  
  public boolean removeAll(Collection c) { throw new UnsupportedOperationException(); }
  
  public boolean containsAll(Collection c) {
    for (Object o : c) {
      if (!contains(o))
        return false; 
    } 
    return true;
  }
  
  public Object[] toArray(Object[] a) { return RT.seqToPassedArray(seq(), a); }
  
  public int size() { return count(); }
  
  public boolean isEmpty() { return (count() == 0); }
  
  public Iterator iterator() {
    if (this.impl instanceof IMapIterable)
      return ((IMapIterable)this.impl).keyIterator(); 
    return new Object(this);
  }
}
