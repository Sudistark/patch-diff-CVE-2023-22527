package clojure.lang;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

public final class LazySeq extends Obj implements ISeq, Sequential, List, IPending, IHashEq {
  private IFn fn;
  
  private Object sv;
  
  private ISeq s;
  
  public LazySeq(IFn fn) { this.fn = fn; }
  
  private LazySeq(IPersistentMap meta, ISeq s) {
    super(meta);
    this.fn = null;
    this.s = s;
  }
  
  public Obj withMeta(IPersistentMap meta) {
    if (meta() == meta)
      return this; 
    return new LazySeq(meta, seq());
  }
  
  final Object sval() {
    if (this.fn != null) {
      this.sv = this.fn.invoke();
      this.fn = null;
    } 
    if (this.sv != null)
      return this.sv; 
    return this.s;
  }
  
  public final ISeq seq() {
    sval();
    if (this.sv != null) {
      Object ls = this.sv;
      this.sv = null;
      while (ls instanceof LazySeq)
        ls = ((LazySeq)ls).sval(); 
      this.s = RT.seq(ls);
    } 
    return this.s;
  }
  
  public int count() {
    int c = 0;
    for (ISeq s = seq(); s != null; s = s.next())
      c++; 
    return c;
  }
  
  public Object first() {
    seq();
    if (this.s == null)
      return null; 
    return this.s.first();
  }
  
  public ISeq next() {
    seq();
    if (this.s == null)
      return null; 
    return this.s.next();
  }
  
  public ISeq more() {
    seq();
    if (this.s == null)
      return PersistentList.EMPTY; 
    return this.s.more();
  }
  
  public ISeq cons(Object o) { return RT.cons(o, seq()); }
  
  public IPersistentCollection empty() { return PersistentList.EMPTY; }
  
  public boolean equiv(Object o) {
    ISeq s = seq();
    if (s != null)
      return s.equiv(o); 
    return ((o instanceof Sequential || o instanceof List) && RT.seq(o) == null);
  }
  
  public int hashCode() {
    ISeq s = seq();
    if (s == null)
      return 1; 
    return Util.hash(s);
  }
  
  public int hasheq() { return Murmur3.hashOrdered(this); }
  
  public boolean equals(Object o) {
    ISeq s = seq();
    if (s != null)
      return s.equals(o); 
    return ((o instanceof Sequential || o instanceof List) && RT.seq(o) == null);
  }
  
  public Object[] toArray() { return RT.seqToArray(seq()); }
  
  public boolean add(Object o) { throw new UnsupportedOperationException(); }
  
  public boolean remove(Object o) { throw new UnsupportedOperationException(); }
  
  public boolean addAll(Collection c) { throw new UnsupportedOperationException(); }
  
  public void clear() { throw new UnsupportedOperationException(); }
  
  public boolean retainAll(Collection c) { throw new UnsupportedOperationException(); }
  
  public boolean removeAll(Collection c) { throw new UnsupportedOperationException(); }
  
  public boolean containsAll(Collection c) {
    for (Object o : c) {
      if (!contains(o))
        return false; 
    } 
    return true;
  }
  
  public Object[] toArray(Object[] a) { return RT.seqToPassedArray(seq(), a); }
  
  public int size() { return count(); }
  
  public boolean isEmpty() { return (seq() == null); }
  
  public boolean contains(Object o) {
    for (ISeq s = seq(); s != null; s = s.next()) {
      if (Util.equiv(s.first(), o))
        return true; 
    } 
    return false;
  }
  
  public Iterator iterator() { return new SeqIterator(this); }
  
  private List reify() { return new ArrayList(this); }
  
  public List subList(int fromIndex, int toIndex) { return reify().subList(fromIndex, toIndex); }
  
  public Object set(int index, Object element) { throw new UnsupportedOperationException(); }
  
  public Object remove(int index) { throw new UnsupportedOperationException(); }
  
  public int indexOf(Object o) {
    ISeq s = seq();
    for (int i = 0; s != null; s = s.next(), i++) {
      if (Util.equiv(s.first(), o))
        return i; 
    } 
    return -1;
  }
  
  public int lastIndexOf(Object o) { return reify().lastIndexOf(o); }
  
  public ListIterator listIterator() { return reify().listIterator(); }
  
  public ListIterator listIterator(int index) { return reify().listIterator(index); }
  
  public Object get(int index) { return RT.nth(this, index); }
  
  public void add(int index, Object element) { throw new UnsupportedOperationException(); }
  
  public boolean addAll(int index, Collection c) { throw new UnsupportedOperationException(); }
  
  public boolean isRealized() { return (this.fn == null); }
}
