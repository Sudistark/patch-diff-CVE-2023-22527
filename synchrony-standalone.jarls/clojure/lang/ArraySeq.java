package clojure.lang;

import java.lang.reflect.Array;

public class ArraySeq extends ASeq implements IndexedSeq, IReduce {
  public final Object[] array;
  
  final int i;
  
  public static ArraySeq create() { return null; }
  
  public static ArraySeq create(Object... array) {
    if (array == null || array.length == 0)
      return null; 
    return new ArraySeq(array, 0);
  }
  
  static ISeq createFromObject(Object array) {
    if (array == null || Array.getLength(array) == 0)
      return null; 
    Class aclass = array.getClass();
    if (aclass == int[].class)
      return new ArraySeq_int(null, (int[])array, 0); 
    if (aclass == float[].class)
      return new ArraySeq_float(null, (float[])array, 0); 
    if (aclass == double[].class)
      return new ArraySeq_double(null, (double[])array, 0); 
    if (aclass == long[].class)
      return new ArraySeq_long(null, (long[])array, 0); 
    if (aclass == byte[].class)
      return new ArraySeq_byte(null, (byte[])array, 0); 
    if (aclass == char[].class)
      return new ArraySeq_char(null, (char[])array, 0); 
    if (aclass == short[].class)
      return new ArraySeq_short(null, (short[])array, 0); 
    if (aclass == boolean[].class)
      return new ArraySeq_boolean(null, (boolean[])array, 0); 
    return new ArraySeq(array, 0);
  }
  
  ArraySeq(Object array, int i) {
    this.i = i;
    this.array = (Object[])array;
  }
  
  ArraySeq(IPersistentMap meta, Object array, int i) {
    super(meta);
    this.i = i;
    this.array = (Object[])array;
  }
  
  public Object first() {
    if (this.array != null)
      return this.array[this.i]; 
    return null;
  }
  
  public ISeq next() {
    if (this.array != null && this.i + 1 < this.array.length)
      return new ArraySeq(this.array, this.i + 1); 
    return null;
  }
  
  public int count() {
    if (this.array != null)
      return this.array.length - this.i; 
    return 0;
  }
  
  public int index() { return this.i; }
  
  public ArraySeq withMeta(IPersistentMap meta) {
    if (meta() == meta)
      return this; 
    return new ArraySeq(meta, this.array, this.i);
  }
  
  public Object reduce(IFn f) {
    if (this.array != null) {
      Object ret = this.array[this.i];
      for (int x = this.i + 1; x < this.array.length; x++) {
        ret = f.invoke(ret, this.array[x]);
        if (RT.isReduced(ret))
          return ((IDeref)ret).deref(); 
      } 
      return ret;
    } 
    return null;
  }
  
  public Object reduce(IFn f, Object start) {
    if (this.array != null) {
      Object ret = f.invoke(start, this.array[this.i]);
      for (int x = this.i + 1; x < this.array.length; x++) {
        if (RT.isReduced(ret))
          return ((IDeref)ret).deref(); 
        ret = f.invoke(ret, this.array[x]);
      } 
      if (RT.isReduced(ret))
        return ((IDeref)ret).deref(); 
      return ret;
    } 
    return null;
  }
  
  public int indexOf(Object o) {
    if (this.array != null)
      for (int j = this.i; j < this.array.length; j++) {
        if (Util.equals(o, this.array[j]))
          return j - this.i; 
      }  
    return -1;
  }
  
  public int lastIndexOf(Object o) {
    if (this.array != null)
      if (o == null) {
        for (int j = this.array.length - 1; j >= this.i; j--) {
          if (this.array[j] == null)
            return j - this.i; 
        } 
      } else {
        for (int j = this.array.length - 1; j >= this.i; j--) {
          if (o.equals(this.array[j]))
            return j - this.i; 
        } 
      }  
    return -1;
  }
}
