package clojure.lang;

import java.util.concurrent.atomic.AtomicReference;

public final class Atom extends ARef implements IAtom2 {
  final AtomicReference state;
  
  public Atom(Object state) { this.state = new AtomicReference(state); }
  
  public Atom(Object state, IPersistentMap meta) {
    super(meta);
    this.state = new AtomicReference(state);
  }
  
  public Object deref() { return this.state.get(); }
  
  public Object swap(IFn f) {
    Object newv, v;
    do {
      v = deref();
      newv = f.invoke(v);
      validate(newv);
    } while (!this.state.compareAndSet(v, newv));
    notifyWatches(v, newv);
    return newv;
  }
  
  public Object swap(IFn f, Object arg) {
    Object newv, v;
    do {
      v = deref();
      newv = f.invoke(v, arg);
      validate(newv);
    } while (!this.state.compareAndSet(v, newv));
    notifyWatches(v, newv);
    return newv;
  }
  
  public Object swap(IFn f, Object arg1, Object arg2) {
    Object newv, v;
    do {
      v = deref();
      newv = f.invoke(v, arg1, arg2);
      validate(newv);
    } while (!this.state.compareAndSet(v, newv));
    notifyWatches(v, newv);
    return newv;
  }
  
  public Object swap(IFn f, Object x, Object y, ISeq args) {
    Object newv, v;
    do {
      v = deref();
      newv = f.applyTo(RT.listStar(v, x, y, args));
      validate(newv);
    } while (!this.state.compareAndSet(v, newv));
    notifyWatches(v, newv);
    return newv;
  }
  
  public IPersistentVector swapVals(IFn f) {
    Object newv, oldv;
    do {
      oldv = deref();
      newv = f.invoke(oldv);
      validate(newv);
    } while (!this.state.compareAndSet(oldv, newv));
    notifyWatches(oldv, newv);
    return LazilyPersistentVector.createOwning(new Object[] { oldv, newv });
  }
  
  public IPersistentVector swapVals(IFn f, Object arg) {
    Object newv, oldv;
    do {
      oldv = deref();
      newv = f.invoke(oldv, arg);
      validate(newv);
    } while (!this.state.compareAndSet(oldv, newv));
    notifyWatches(oldv, newv);
    return LazilyPersistentVector.createOwning(new Object[] { oldv, newv });
  }
  
  public IPersistentVector swapVals(IFn f, Object arg1, Object arg2) {
    Object newv, oldv;
    do {
      oldv = deref();
      newv = f.invoke(oldv, arg1, arg2);
      validate(newv);
    } while (!this.state.compareAndSet(oldv, newv));
    notifyWatches(oldv, newv);
    return LazilyPersistentVector.createOwning(new Object[] { oldv, newv });
  }
  
  public IPersistentVector swapVals(IFn f, Object x, Object y, ISeq args) {
    Object newv, oldv;
    do {
      oldv = deref();
      newv = f.applyTo(RT.listStar(oldv, x, y, args));
      validate(newv);
    } while (!this.state.compareAndSet(oldv, newv));
    notifyWatches(oldv, newv);
    return LazilyPersistentVector.createOwning(new Object[] { oldv, newv });
  }
  
  public boolean compareAndSet(Object oldv, Object newv) {
    validate(newv);
    boolean ret = this.state.compareAndSet(oldv, newv);
    if (ret)
      notifyWatches(oldv, newv); 
    return ret;
  }
  
  public Object reset(Object newval) {
    Object oldval = this.state.get();
    validate(newval);
    this.state.set(newval);
    notifyWatches(oldval, newval);
    return newval;
  }
  
  public IPersistentVector resetVals(Object newv) {
    Object oldv;
    validate(newv);
    do {
      oldv = deref();
    } while (!this.state.compareAndSet(oldv, newv));
    notifyWatches(oldv, newv);
    return LazilyPersistentVector.createOwning(new Object[] { oldv, newv });
  }
}
