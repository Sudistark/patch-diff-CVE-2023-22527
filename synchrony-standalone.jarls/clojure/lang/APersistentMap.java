package clojure.lang;

import java.io.Serializable;
import java.util.Collection;
import java.util.Map;
import java.util.Set;

public abstract class APersistentMap extends AFn implements IPersistentMap, Map, Iterable, Serializable, MapEquivalence, IHashEq {
  int _hash;
  
  int _hasheq;
  
  public String toString() { return RT.printString(this); }
  
  public IPersistentCollection cons(Object o) {
    if (o instanceof Map.Entry) {
      Map.Entry e = (Map.Entry)o;
      return assoc(e.getKey(), e.getValue());
    } 
    if (o instanceof IPersistentVector) {
      IPersistentVector v = (IPersistentVector)o;
      if (v.count() != 2)
        throw new IllegalArgumentException("Vector arg to map conj must be a pair"); 
      return assoc(v.nth(0), v.nth(1));
    } 
    IPersistentMap iPersistentMap = this;
    for (ISeq es = RT.seq(o); es != null; es = es.next()) {
      Map.Entry e = (Map.Entry)es.first();
      iPersistentMap = iPersistentMap.assoc(e.getKey(), e.getValue());
    } 
    return iPersistentMap;
  }
  
  public boolean equals(Object obj) { return mapEquals(this, obj); }
  
  public static boolean mapEquals(IPersistentMap m1, Object obj) {
    if (m1 == obj)
      return true; 
    if (!(obj instanceof Map))
      return false; 
    Map m = (Map)obj;
    if (m.size() != m1.count())
      return false; 
    for (ISeq s = m1.seq(); s != null; s = s.next()) {
      Map.Entry e = (Map.Entry)s.first();
      boolean found = m.containsKey(e.getKey());
      if (!found || !Util.equals(e.getValue(), m.get(e.getKey())))
        return false; 
    } 
    return true;
  }
  
  public boolean equiv(Object obj) {
    if (!(obj instanceof Map))
      return false; 
    if (obj instanceof IPersistentMap && !(obj instanceof MapEquivalence))
      return false; 
    Map m = (Map)obj;
    if (m.size() != size())
      return false; 
    for (ISeq s = seq(); s != null; s = s.next()) {
      Map.Entry e = (Map.Entry)s.first();
      boolean found = m.containsKey(e.getKey());
      if (!found || !Util.equiv(e.getValue(), m.get(e.getKey())))
        return false; 
    } 
    return true;
  }
  
  public int hashCode() {
    int cached = this._hash;
    if (cached == 0)
      this._hash = cached = mapHash(this); 
    return cached;
  }
  
  public static int mapHash(IPersistentMap m) {
    int hash = 0;
    for (ISeq s = m.seq(); s != null; s = s.next()) {
      Map.Entry e = (Map.Entry)s.first();
      hash += (((e.getKey() == null) ? 0 : e.getKey().hashCode()) ^ (
        (e.getValue() == null) ? 0 : e.getValue().hashCode()));
    } 
    return hash;
  }
  
  public int hasheq() {
    int cached = this._hasheq;
    if (cached == 0)
      this._hasheq = cached = Murmur3.hashUnordered(this); 
    return cached;
  }
  
  public static int mapHasheq(IPersistentMap m) { return Murmur3.hashUnordered(m); }
  
  static final IFn MAKE_ENTRY = new Object();
  
  static final IFn MAKE_KEY = new Object();
  
  static final IFn MAKE_VAL = new Object();
  
  public Object invoke(Object arg1) { return valAt(arg1); }
  
  public Object invoke(Object arg1, Object notFound) { return valAt(arg1, notFound); }
  
  public void clear() { throw new UnsupportedOperationException(); }
  
  public boolean containsValue(Object value) { return values().contains(value); }
  
  public Set entrySet() { return new Object(this); }
  
  public Object get(Object key) { return valAt(key); }
  
  public boolean isEmpty() { return (count() == 0); }
  
  public Set keySet() { return new Object(this); }
  
  public Object put(Object key, Object value) { throw new UnsupportedOperationException(); }
  
  public void putAll(Map t) { throw new UnsupportedOperationException(); }
  
  public Object remove(Object key) { throw new UnsupportedOperationException(); }
  
  public int size() { return count(); }
  
  public Collection values() { return new Object(this); }
}
