package clojure.lang;

import java.util.Comparator;
import java.util.Iterator;
import java.util.Map;

public class PersistentTreeMap extends APersistentMap implements IObj, Reversible, Sorted, IKVReduce {
  public final Comparator comp;
  
  public final Node tree;
  
  public final int _count;
  
  final IPersistentMap _meta;
  
  public static final PersistentTreeMap EMPTY = new PersistentTreeMap();
  
  public static IPersistentMap create(Map other) {
    IPersistentMap iPersistentMap = EMPTY;
    for (Object o : other.entrySet()) {
      Map.Entry e = (Map.Entry)o;
      iPersistentMap = iPersistentMap.assoc(e.getKey(), e.getValue());
    } 
    return iPersistentMap;
  }
  
  public PersistentTreeMap() { this(RT.DEFAULT_COMPARATOR); }
  
  public PersistentTreeMap withMeta(IPersistentMap meta) {
    if (this._meta == meta)
      return this; 
    return new PersistentTreeMap(meta, this.comp, this.tree, this._count);
  }
  
  private PersistentTreeMap(Comparator comp) { this(null, comp); }
  
  public PersistentTreeMap(IPersistentMap meta, Comparator comp) {
    this.comp = comp;
    this._meta = meta;
    this.tree = null;
    this._count = 0;
  }
  
  PersistentTreeMap(IPersistentMap meta, Comparator comp, Node tree, int _count) {
    this._meta = meta;
    this.comp = comp;
    this.tree = tree;
    this._count = _count;
  }
  
  public static PersistentTreeMap create(ISeq items) {
    IPersistentMap iPersistentMap = EMPTY;
    for (; items != null; items = items.next().next()) {
      if (items.next() == null)
        throw new IllegalArgumentException(String.format("No value supplied for key: %s", new Object[] { items.first() })); 
      iPersistentMap = iPersistentMap.assoc(items.first(), RT.second(items));
    } 
    return (PersistentTreeMap)iPersistentMap;
  }
  
  public static PersistentTreeMap create(Comparator comp, ISeq items) {
    IPersistentMap iPersistentMap = new PersistentTreeMap(comp);
    for (; items != null; items = items.next().next()) {
      if (items.next() == null)
        throw new IllegalArgumentException(String.format("No value supplied for key: %s", new Object[] { items.first() })); 
      iPersistentMap = iPersistentMap.assoc(items.first(), RT.second(items));
    } 
    return (PersistentTreeMap)iPersistentMap;
  }
  
  public boolean containsKey(Object key) { return (entryAt(key) != null); }
  
  public boolean equals(Object obj) {
    try {
      return super.equals(obj);
    } catch (ClassCastException e) {
      return false;
    } 
  }
  
  public boolean equiv(Object obj) {
    try {
      return super.equiv(obj);
    } catch (ClassCastException e) {
      return false;
    } 
  }
  
  public PersistentTreeMap assocEx(Object key, Object val) {
    Box found = new Box(null);
    Node t = add(this.tree, key, val, found);
    if (t == null)
      throw Util.runtimeException("Key already present"); 
    return new PersistentTreeMap(this.comp, t.blacken(), this._count + 1, meta());
  }
  
  public PersistentTreeMap assoc(Object key, Object val) {
    Box found = new Box(null);
    Node t = add(this.tree, key, val, found);
    if (t == null) {
      Node foundNode = (Node)found.val;
      if (foundNode.val() == val)
        return this; 
      return new PersistentTreeMap(this.comp, replace(this.tree, key, val), this._count, meta());
    } 
    return new PersistentTreeMap(this.comp, t.blacken(), this._count + 1, meta());
  }
  
  public PersistentTreeMap without(Object key) {
    Box found = new Box(null);
    Node t = remove(this.tree, key, found);
    if (t == null) {
      if (found.val == null)
        return this; 
      return new PersistentTreeMap(meta(), this.comp);
    } 
    return new PersistentTreeMap(this.comp, t.blacken(), this._count - 1, meta());
  }
  
  public ISeq seq() {
    if (this._count > 0)
      return Seq.create(this.tree, true, this._count); 
    return null;
  }
  
  public IPersistentCollection empty() { return new PersistentTreeMap(meta(), this.comp); }
  
  public ISeq rseq() {
    if (this._count > 0)
      return Seq.create(this.tree, false, this._count); 
    return null;
  }
  
  public Comparator comparator() { return this.comp; }
  
  public Object entryKey(Object entry) { return ((IMapEntry)entry).key(); }
  
  public ISeq seq(boolean ascending) {
    if (this._count > 0)
      return Seq.create(this.tree, ascending, this._count); 
    return null;
  }
  
  public ISeq seqFrom(Object key, boolean ascending) {
    if (this._count > 0) {
      ISeq stack = null;
      Node t = this.tree;
      while (t != null) {
        int c = doCompare(key, t.key);
        if (c == 0) {
          stack = RT.cons(t, stack);
          return new Seq(stack, ascending);
        } 
        if (ascending) {
          if (c < 0) {
            stack = RT.cons(t, stack);
            t = t.left();
            continue;
          } 
          t = t.right();
          continue;
        } 
        if (c > 0) {
          stack = RT.cons(t, stack);
          t = t.right();
          continue;
        } 
        t = t.left();
      } 
      if (stack != null)
        return new Seq(stack, ascending); 
    } 
    return null;
  }
  
  public NodeIterator iterator() { return new NodeIterator(this.tree, true); }
  
  public Object kvreduce(IFn f, Object init) {
    if (this.tree != null)
      init = this.tree.kvreduce(f, init); 
    if (RT.isReduced(init))
      init = ((IDeref)init).deref(); 
    return init;
  }
  
  public NodeIterator reverseIterator() { return new NodeIterator(this.tree, false); }
  
  public Iterator keys() { return keys(iterator()); }
  
  public Iterator vals() { return vals(iterator()); }
  
  public Iterator keys(NodeIterator it) { return new KeyIterator(it); }
  
  public Iterator vals(NodeIterator it) { return new ValIterator(it); }
  
  public Object minKey() {
    Node t = min();
    return (t != null) ? t.key : null;
  }
  
  public Node min() {
    Node t = this.tree;
    if (t != null)
      while (t.left() != null)
        t = t.left();  
    return t;
  }
  
  public Object maxKey() {
    Node t = max();
    return (t != null) ? t.key : null;
  }
  
  public Node max() {
    Node t = this.tree;
    if (t != null)
      while (t.right() != null)
        t = t.right();  
    return t;
  }
  
  public int depth() { return depth(this.tree); }
  
  int depth(Node t) {
    if (t == null)
      return 0; 
    return 1 + Math.max(depth(t.left()), depth(t.right()));
  }
  
  public Object valAt(Object key, Object notFound) {
    Node n = entryAt(key);
    return (n != null) ? n.val() : notFound;
  }
  
  public Object valAt(Object key) { return valAt(key, null); }
  
  public int capacity() { return this._count; }
  
  public int count() { return this._count; }
  
  public Node entryAt(Object key) {
    Node t = this.tree;
    while (t != null) {
      int c = doCompare(key, t.key);
      if (c == 0)
        return t; 
      if (c < 0) {
        t = t.left();
        continue;
      } 
      t = t.right();
    } 
    return t;
  }
  
  public int doCompare(Object k1, Object k2) { return this.comp.compare(k1, k2); }
  
  Node add(Node t, Object key, Object val, Box found) {
    if (t == null) {
      if (this.comp == RT.DEFAULT_COMPARATOR && key != null && !(key instanceof Number) && !(key instanceof Comparable))
        throw new ClassCastException("Default comparator requires nil, Number, or Comparable: " + key); 
      if (val == null)
        return new Red(key); 
      return new RedVal(key, val);
    } 
    int c = doCompare(key, t.key);
    if (c == 0) {
      found.val = t;
      return null;
    } 
    Node ins = (c < 0) ? add(t.left(), key, val, found) : add(t.right(), key, val, found);
    if (ins == null)
      return null; 
    if (c < 0)
      return t.addLeft(ins); 
    return t.addRight(ins);
  }
  
  Node remove(Node t, Object key, Box found) {
    if (t == null)
      return null; 
    int c = doCompare(key, t.key);
    if (c == 0) {
      found.val = t;
      return append(t.left(), t.right());
    } 
    Node del = (c < 0) ? remove(t.left(), key, found) : remove(t.right(), key, found);
    if (del == null && found.val == null)
      return null; 
    if (c < 0) {
      if (t.left() instanceof Black)
        return balanceLeftDel(t.key, t.val(), del, t.right()); 
      return red(t.key, t.val(), del, t.right());
    } 
    if (t.right() instanceof Black)
      return balanceRightDel(t.key, t.val(), t.left(), del); 
    return red(t.key, t.val(), t.left(), del);
  }
  
  static Node append(Node left, Node right) {
    if (left == null)
      return right; 
    if (right == null)
      return left; 
    if (left instanceof Red) {
      if (right instanceof Red) {
        Node app = append(left.right(), right.left());
        if (app instanceof Red)
          return red(app.key, app.val(), 
              red(left.key, left.val(), left.left(), app.left()), 
              red(right.key, right.val(), app.right(), right.right())); 
        return red(left.key, left.val(), left.left(), red(right.key, right.val(), app, right.right()));
      } 
      return red(left.key, left.val(), left.left(), append(left.right(), right));
    } 
    if (right instanceof Red)
      return red(right.key, right.val(), append(left, right.left()), right.right()); 
    Node app = append(left.right(), right.left());
    if (app instanceof Red)
      return red(app.key, app.val(), 
          black(left.key, left.val(), left.left(), app.left()), 
          black(right.key, right.val(), app.right(), right.right())); 
    return balanceLeftDel(left.key, left.val(), left.left(), black(right.key, right.val(), app, right.right()));
  }
  
  static Node balanceLeftDel(Object key, Object val, Node del, Node right) {
    if (del instanceof Red)
      return red(key, val, del.blacken(), right); 
    if (right instanceof Black)
      return rightBalance(key, val, del, right.redden()); 
    if (right instanceof Red && right.left() instanceof Black)
      return red((right.left()).key, right.left().val(), 
          black(key, val, del, right.left().left()), 
          rightBalance(right.key, right.val(), right.left().right(), right.right().redden())); 
    throw new UnsupportedOperationException("Invariant violation");
  }
  
  static Node balanceRightDel(Object key, Object val, Node left, Node del) {
    if (del instanceof Red)
      return red(key, val, left, del.blacken()); 
    if (left instanceof Black)
      return leftBalance(key, val, left.redden(), del); 
    if (left instanceof Red && left.right() instanceof Black)
      return red((left.right()).key, left.right().val(), 
          leftBalance(left.key, left.val(), left.left().redden(), left.right().left()), 
          black(key, val, left.right().right(), del)); 
    throw new UnsupportedOperationException("Invariant violation");
  }
  
  static Node leftBalance(Object key, Object val, Node ins, Node right) {
    if (ins instanceof Red && ins.left() instanceof Red)
      return red(ins.key, ins.val(), ins.left().blacken(), black(key, val, ins.right(), right)); 
    if (ins instanceof Red && ins.right() instanceof Red)
      return red((ins.right()).key, ins.right().val(), 
          black(ins.key, ins.val(), ins.left(), ins.right().left()), 
          black(key, val, ins.right().right(), right)); 
    return black(key, val, ins, right);
  }
  
  static Node rightBalance(Object key, Object val, Node left, Node ins) {
    if (ins instanceof Red && ins.right() instanceof Red)
      return red(ins.key, ins.val(), black(key, val, left, ins.left()), ins.right().blacken()); 
    if (ins instanceof Red && ins.left() instanceof Red)
      return red((ins.left()).key, ins.left().val(), 
          black(key, val, left, ins.left().left()), 
          black(ins.key, ins.val(), ins.left().right(), ins.right())); 
    return black(key, val, left, ins);
  }
  
  Node replace(Node t, Object key, Object val) {
    int c = doCompare(key, t.key);
    return t.replace(t.key, (c == 0) ? val : t
        .val(), (c < 0) ? 
        replace(t.left(), key, val) : t.left(), (c > 0) ? 
        replace(t.right(), key, val) : t.right());
  }
  
  PersistentTreeMap(Comparator comp, Node tree, int count, IPersistentMap meta) {
    this._meta = meta;
    this.comp = comp;
    this.tree = tree;
    this._count = count;
  }
  
  static Red red(Object key, Object val, Node left, Node right) {
    if (left == null && right == null) {
      if (val == null)
        return new Red(key); 
      return new RedVal(key, val);
    } 
    if (val == null)
      return new RedBranch(key, left, right); 
    return new RedBranchVal(key, val, left, right);
  }
  
  static Black black(Object key, Object val, Node left, Node right) {
    if (left == null && right == null) {
      if (val == null)
        return new Black(key); 
      return new BlackVal(key, val);
    } 
    if (val == null)
      return new BlackBranch(key, left, right); 
    return new BlackBranchVal(key, val, left, right);
  }
  
  public IPersistentMap meta() { return this._meta; }
}
