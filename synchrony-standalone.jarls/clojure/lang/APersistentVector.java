package clojure.lang;

import java.io.Serializable;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.RandomAccess;

public abstract class APersistentVector extends AFn implements IPersistentVector, Iterable, List, RandomAccess, Comparable, Serializable, IHashEq {
  int _hash;
  
  int _hasheq;
  
  public String toString() { return RT.printString(this); }
  
  public ISeq seq() {
    if (count() > 0)
      return new Seq(this, 0); 
    return null;
  }
  
  public ISeq rseq() {
    if (count() > 0)
      return new RSeq(this, count() - 1); 
    return null;
  }
  
  static boolean doEquals(IPersistentVector v, Object obj) {
    if (obj instanceof IPersistentVector) {
      IPersistentVector ov = (IPersistentVector)obj;
      if (ov.count() != v.count())
        return false; 
      for (int i = 0; i < v.count(); i++) {
        if (!Util.equals(v.nth(i), ov.nth(i)))
          return false; 
      } 
      return true;
    } 
    if (obj instanceof List) {
      Collection ma = (Collection)obj;
      if (ma.size() != v.count() || ma.hashCode() != v.hashCode())
        return false; 
      Iterator i1 = ((List)v).iterator(), i2 = ma.iterator();
      while (i1.hasNext()) {
        if (!Util.equals(i1.next(), i2.next()))
          return false; 
      } 
      return true;
    } 
    if (!(obj instanceof Sequential))
      return false; 
    ISeq ms = RT.seq(obj);
    for (int i = 0; i < v.count(); i++, ms = ms.next()) {
      if (ms == null || !Util.equals(v.nth(i), ms.first()))
        return false; 
    } 
    if (ms != null)
      return false; 
    return true;
  }
  
  static boolean doEquiv(IPersistentVector v, Object obj) {
    if (obj instanceof IPersistentVector) {
      IPersistentVector ov = (IPersistentVector)obj;
      if (ov.count() != v.count())
        return false; 
      for (int i = 0; i < v.count(); i++) {
        if (!Util.equiv(v.nth(i), ov.nth(i)))
          return false; 
      } 
      return true;
    } 
    if (obj instanceof List) {
      Collection ma = (Collection)obj;
      if (ma.size() != v.count())
        return false; 
      Iterator i1 = ((List)v).iterator(), i2 = ma.iterator();
      while (i1.hasNext()) {
        if (!Util.equiv(i1.next(), i2.next()))
          return false; 
      } 
      return true;
    } 
    if (!(obj instanceof Sequential))
      return false; 
    ISeq ms = RT.seq(obj);
    for (int i = 0; i < v.count(); i++, ms = ms.next()) {
      if (ms == null || !Util.equiv(v.nth(i), ms.first()))
        return false; 
    } 
    if (ms != null)
      return false; 
    return true;
  }
  
  public boolean equals(Object obj) {
    if (obj == this)
      return true; 
    return doEquals(this, obj);
  }
  
  public boolean equiv(Object obj) {
    if (obj == this)
      return true; 
    return doEquiv(this, obj);
  }
  
  public int hashCode() {
    int hash = this._hash;
    if (hash == 0) {
      hash = 1;
      for (int i = 0; i < count(); i++) {
        Object obj = nth(i);
        hash = 31 * hash + ((obj == null) ? 0 : obj.hashCode());
      } 
      this._hash = hash;
    } 
    return hash;
  }
  
  public int hasheq() {
    int hash = this._hasheq;
    if (hash == 0) {
      hash = 1;
      int n;
      for (n = 0; n < count(); n++)
        hash = 31 * hash + Util.hasheq(nth(n)); 
      this._hasheq = hash = Murmur3.mixCollHash(hash, n);
    } 
    return hash;
  }
  
  public Object get(int index) { return nth(index); }
  
  public Object nth(int i, Object notFound) {
    if (i >= 0 && i < count())
      return nth(i); 
    return notFound;
  }
  
  public Object remove(int i) { throw new UnsupportedOperationException(); }
  
  public int indexOf(Object o) {
    for (int i = 0; i < count(); i++) {
      if (Util.equiv(nth(i), o))
        return i; 
    } 
    return -1;
  }
  
  public int lastIndexOf(Object o) {
    for (int i = count() - 1; i >= 0; i--) {
      if (Util.equiv(nth(i), o))
        return i; 
    } 
    return -1;
  }
  
  public ListIterator listIterator() { return listIterator(0); }
  
  public ListIterator listIterator(int index) { return new Object(this, index); }
  
  Iterator rangedIterator(int start, int end) { return new Object(this, start, end); }
  
  public List subList(int fromIndex, int toIndex) { return (List)RT.subvec(this, fromIndex, toIndex); }
  
  public Object set(int i, Object o) { throw new UnsupportedOperationException(); }
  
  public void add(int i, Object o) { throw new UnsupportedOperationException(); }
  
  public boolean addAll(int i, Collection c) { throw new UnsupportedOperationException(); }
  
  public Object invoke(Object arg1) {
    if (Util.isInteger(arg1))
      return nth(((Number)arg1).intValue()); 
    throw new IllegalArgumentException("Key must be integer");
  }
  
  public Iterator iterator() { return new Object(this); }
  
  public Object peek() {
    if (count() > 0)
      return nth(count() - 1); 
    return null;
  }
  
  public boolean containsKey(Object key) {
    if (!Util.isInteger(key))
      return false; 
    int i = ((Number)key).intValue();
    return (i >= 0 && i < count());
  }
  
  public IMapEntry entryAt(Object key) {
    if (Util.isInteger(key)) {
      int i = ((Number)key).intValue();
      if (i >= 0 && i < count())
        return MapEntry.create(key, nth(i)); 
    } 
    return null;
  }
  
  public IPersistentVector assoc(Object key, Object val) {
    if (Util.isInteger(key)) {
      int i = ((Number)key).intValue();
      return assocN(i, val);
    } 
    throw new IllegalArgumentException("Key must be integer");
  }
  
  public Object valAt(Object key, Object notFound) {
    if (Util.isInteger(key)) {
      int i = ((Number)key).intValue();
      if (i >= 0 && i < count())
        return nth(i); 
    } 
    return notFound;
  }
  
  public Object valAt(Object key) { return valAt(key, null); }
  
  public Object[] toArray() {
    Object[] ret = new Object[count()];
    for (int i = 0; i < count(); i++)
      ret[i] = nth(i); 
    return ret;
  }
  
  public boolean add(Object o) { throw new UnsupportedOperationException(); }
  
  public boolean remove(Object o) { throw new UnsupportedOperationException(); }
  
  public boolean addAll(Collection c) { throw new UnsupportedOperationException(); }
  
  public void clear() { throw new UnsupportedOperationException(); }
  
  public boolean retainAll(Collection c) { throw new UnsupportedOperationException(); }
  
  public boolean removeAll(Collection c) { throw new UnsupportedOperationException(); }
  
  public boolean containsAll(Collection c) {
    for (Object o : c) {
      if (!contains(o))
        return false; 
    } 
    return true;
  }
  
  public Object[] toArray(Object[] a) { return RT.seqToPassedArray(seq(), a); }
  
  public int size() { return count(); }
  
  public boolean isEmpty() { return (count() == 0); }
  
  public boolean contains(Object o) {
    for (ISeq s = seq(); s != null; s = s.next()) {
      if (Util.equiv(s.first(), o))
        return true; 
    } 
    return false;
  }
  
  public int length() { return count(); }
  
  public int compareTo(Object o) {
    IPersistentVector v = (IPersistentVector)o;
    if (count() < v.count())
      return -1; 
    if (count() > v.count())
      return 1; 
    for (int i = 0; i < count(); i++) {
      int c = Util.compare(nth(i), v.nth(i));
      if (c != 0)
        return c; 
    } 
    return 0;
  }
}
