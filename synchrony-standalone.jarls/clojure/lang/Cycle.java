package clojure.lang;

public class Cycle extends ASeq implements IReduce, IPending {
  private final ISeq all;
  
  private final ISeq prev;
  
  private Cycle(ISeq all, ISeq prev, ISeq current) {
    this.all = all;
    this.prev = prev;
    this._current = current;
  }
  
  private Cycle(IPersistentMap meta, ISeq all, ISeq prev, ISeq current, ISeq next) {
    super(meta);
    this.all = all;
    this.prev = prev;
    this._current = current;
    this._next = next;
  }
  
  public static ISeq create(ISeq vals) {
    if (vals == null)
      return PersistentList.EMPTY; 
    return new Cycle(vals, null, vals);
  }
  
  private ISeq current() {
    if (this._current == null) {
      ISeq current = this.prev.next();
      this._current = (current == null) ? this.all : current;
    } 
    return this._current;
  }
  
  public boolean isRealized() { return (this._current != null); }
  
  public Object first() { return current().first(); }
  
  public ISeq next() {
    if (this._next == null)
      this._next = new Cycle(this.all, current(), null); 
    return this._next;
  }
  
  public Cycle withMeta(IPersistentMap meta) {
    if (meta() == meta)
      return this; 
    return new Cycle(meta, this.all, this.prev, this._current, this._next);
  }
  
  public Object reduce(IFn f) {
    ISeq s = current();
    Object ret = s.first();
    do {
      s = s.next();
      if (s == null)
        s = this.all; 
      ret = f.invoke(ret, s.first());
    } while (!RT.isReduced(ret));
    return ((IDeref)ret).deref();
  }
  
  public Object reduce(IFn f, Object start) {
    Object ret = start;
    ISeq s = current();
    while (true) {
      ret = f.invoke(ret, s.first());
      if (RT.isReduced(ret))
        return ((IDeref)ret).deref(); 
      s = s.next();
      if (s == null)
        s = this.all; 
    } 
  }
}
