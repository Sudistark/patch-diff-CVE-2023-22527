package clojure.pprint;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IPersistentMap;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import clojure.pprint;
import java.util.Arrays;

public class utilities__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Var const__2;
  
  public static final AFn const__11;
  
  public static final Var const__12;
  
  public static final AFn const__15;
  
  public static final Var const__16;
  
  public static final AFn const__19;
  
  public static final Var const__20;
  
  public static final AFn const__24;
  
  public static final Var const__25;
  
  public static final AFn const__28;
  
  public static final Var const__29;
  
  public static final AFn const__32;
  
  public static final Var const__33;
  
  public static final AFn const__36;
  
  public static final Var const__37;
  
  public static final AFn const__40;
  
  public static final Var const__41;
  
  public static final AFn const__44;
  
  public static final Var const__45;
  
  public static final AFn const__48;
  
  public static void load() {
    const__2.setMeta((IPersistentMap)const__11);
    const__2.bindRoot(new pprint.map_passing_context());
    const__12.setMeta((IPersistentMap)const__15);
    const__12.bindRoot(new pprint.consume());
    const__16.setMeta((IPersistentMap)const__19);
    const__16.bindRoot(new pprint.consume_while());
    const__20.setMeta((IPersistentMap)const__24);
    const__20.bindRoot(new pprint.unzip_map());
    const__25.setMeta((IPersistentMap)const__28);
    const__25.bindRoot(new pprint.tuple_map());
    const__29.setMeta((IPersistentMap)const__32);
    const__29.bindRoot(new pprint.rtrim());
    const__33.setMeta((IPersistentMap)const__36);
    const__33.bindRoot(new pprint.ltrim());
    const__37.setMeta((IPersistentMap)const__40);
    const__37.bindRoot(new pprint.prefix_count());
    const__41.setMeta((IPersistentMap)const__44);
    const__41.bindRoot(new pprint.prerr());
    const__45.setMeta((IPersistentMap)const__48);
    const__45.bindRoot(new pprint.prlabel());
    ((Var)const__45)






















































































      
      .setMacro();
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "clojure.pprint");
    const__2 = (Var)RT.var("clojure.pprint", "map-passing-context");
    const__11 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "func"), Symbol.intern(null, "initial-context"), Symbol.intern(null, "lis")) })), RT.keyword(null, "line"), Integer.valueOf(26), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/pprint/utilities.clj" });
    const__12 = (Var)RT.var("clojure.pprint", "consume");
    const__15 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "func"), Symbol.intern(null, "initial-context")) })), RT.keyword(null, "line"), Integer.valueOf(37), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/pprint/utilities.clj" });
    const__16 = (Var)RT.var("clojure.pprint", "consume-while");
    const__19 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "func"), Symbol.intern(null, "initial-context")) })), RT.keyword(null, "line"), Integer.valueOf(45), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/pprint/utilities.clj" });
    const__20 = (Var)RT.var("clojure.pprint", "unzip-map");
    const__24 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), "Take a map that has pairs in the value slots and produce a pair of\n  maps, the first having all the first elements of the pairs and the\n  second all the second elements of the pairs", RT.keyword(null, "line"), Integer.valueOf(53), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/utilities.clj" });
    const__25 = (Var)RT.var("clojure.pprint", "tuple-map");
    const__28 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "v1")) })), RT.keyword(null, "doc"), "For all the values, v, in the map, replace them with [v v1]", RT.keyword(null, "line"), Integer.valueOf(61), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/utilities.clj" });
    const__29 = (Var)RT.var("clojure.pprint", "rtrim");
    const__32 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s"), Symbol.intern(null, "c")) })), RT.keyword(null, "doc"), "Trim all instances of c from the end of sequence s", RT.keyword(null, "line"), Integer.valueOf(66), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/utilities.clj" });
    const__33 = (Var)RT.var("clojure.pprint", "ltrim");
    const__36 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s"), Symbol.intern(null, "c")) })), RT.keyword(null, "doc"), "Trim all instances of c from the beginning of sequence s", RT.keyword(null, "line"), Integer.valueOf(78), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/utilities.clj" });
    const__37 = (Var)RT.var("clojure.pprint", "prefix-count");
    const__40 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "aseq"), Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "Return the number of times that val occurs at the start of sequence aseq,\n  if val is a seq itself, count the number of times any element of val\n  occurs at the beginning of aseq", RT.keyword(null, "line"), Integer.valueOf(89), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/utilities.clj" });
    const__41 = (Var)RT.var("clojure.pprint", "prerr");
    const__44 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Println to *err*", RT.keyword(null, "line"), Integer.valueOf(100), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/utilities.clj" });
    const__45 = (Var)RT.var("clojure.pprint", "prlabel");
    const__48 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "prefix"), Symbol.intern(null, "arg"), Symbol.intern(null, "&"), Symbol.intern(null, "more-args")) })), RT.keyword(null, "doc"), "Print args to *err* in name = value format", RT.keyword(null, "line"), Integer.valueOf(106), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/utilities.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("clojure.pprint.utilities__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
