package clojure;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;

public class genclass__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Var const__2;
  
  public static final AFn const__11;
  
  public static final Var const__12;
  
  public static final AFn const__15;
  
  public static final Var const__16;
  
  public static final AFn const__19;
  
  public static final Var const__20;
  
  public static final AFn const__23;
  
  public static final Var const__24;
  
  public static final AFn const__27;
  
  public static final Var const__28;
  
  public static final AFn const__31;
  
  public static final Var const__32;
  
  public static final AFn const__37;
  
  public static final Var const__38;
  
  public static final AFn const__40;
  
  public static final AFn const__41;
  
  public static final AFn const__42;
  
  public static final AFn const__43;
  
  public static final AFn const__44;
  
  public static final AFn const__45;
  
  public static final AFn const__46;
  
  public static final AFn const__47;
  
  public static final AFn const__48;
  
  public static final AFn const__49;
  
  public static final AFn const__50;
  
  public static final AFn const__51;
  
  public static final AFn const__52;
  
  public static final AFn const__53;
  
  public static final AFn const__54;
  
  public static final AFn const__55;
  
  public static final AFn const__56;
  
  public static final AFn const__57;
  
  public static final Var const__58;
  
  public static final AFn const__62;
  
  public static final Var const__63;
  
  public static final AFn const__66;
  
  public static final Var const__67;
  
  public static final AFn const__70;
  
  public static final Var const__71;
  
  public static final AFn const__74;
  
  public static final Var const__75;
  
  public static final AFn const__80;
  
  public static final Var const__81;
  
  public static final AFn const__85;
  
  public static final Var const__86;
  
  public static final AFn const__89;
  
  public static final Var const__90;
  
  public static final AFn const__93;
  
  public static void load() {
    const__2.setMeta((IPersistentMap)const__11);
    const__2.bindRoot(new core.filter_methods());
    const__12.setMeta((IPersistentMap)const__15);
    const__12.bindRoot(new core.non_private_methods());
    const__16.setMeta((IPersistentMap)const__19);
    const__16.bindRoot(new core.protected_final_methods());
    const__20.setMeta((IPersistentMap)const__23);
    const__20.bindRoot(new core.ctor_sigs());
    const__24.setMeta((IPersistentMap)const__27);
    const__24.bindRoot(new core.escape_class_name());
    const__28.setMeta((IPersistentMap)const__31);
    const__28.bindRoot(new core.overload_name());
    const__32.setMeta((IPersistentMap)const__37);
    const__32.bindRoot(new core.find_field());
    const__38.setMeta((IPersistentMap)const__40);
    const__38












































































      
      .bindRoot(RT.mapUniqueKeys(new Object[] { 
            const__41, int.class, const__42, byte.class, const__43, Class.forName((String)"[F"), const__44, char.class, const__45, 









            
            Class.forName((String)"[C"), 
            const__46, boolean.class, const__47, void.class, const__48, Class.forName((String)"[J"), const__49, Class.forName((String)"[D"), const__50, float.class, 
            const__51, Class.forName((String)"[Z"), const__52, Class.forName((String)"[S"), const__53, Class.forName((String)"[B"), const__54, double.class, const__55, short.class, 
            const__56, long.class, const__57, Class.forName((String)"[I") }));
    const__58.setMeta((IPersistentMap)const__62);
    const__58.bindRoot(new core.the_class());
    const__63.setMeta((IPersistentMap)const__66);
    const__63.bindRoot(new core.valid_java_method_name());
    const__67.setMeta((IPersistentMap)const__70);
    const__67.bindRoot(new core.validate_generate_class_options());
    const__71.setMeta((IPersistentMap)const__74);
    const__71.bindRoot(new core.generate_class());
    const__75.setMeta((IPersistentMap)const__80);
    const__75.bindRoot(new core.gen_class());
    ((Var)const__75).setMacro();
    const__81.setMeta((IPersistentMap)const__85);
    const__81.bindRoot(new core.asm_type());
    const__86.setMeta((IPersistentMap)const__89);
    const__86.bindRoot(new core.generate_interface());
    const__90.setMeta((IPersistentMap)const__93);
    const__90.bindRoot(new core.gen_interface());
    ((Var)const__90)



















































































































































































      
      .setMacro();
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "clojure.core");
    const__2 = (Var)RT.var("clojure.core", "filter-methods");
    const__11 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") })), Symbol.intern(null, "invalid-method?")) })), RT.keyword(null, "line"), Integer.valueOf(19), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/genclass.clj" });
    const__12 = (Var)RT.var("clojure.core", "non-private-methods");
    const__15 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") }))) })), RT.keyword(null, "line"), Integer.valueOf(42), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/genclass.clj" });
    const__16 = (Var)RT.var("clojure.core", "protected-final-methods");
    const__19 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") }))) })), RT.keyword(null, "line"), Integer.valueOf(51), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/genclass.clj" });
    const__20 = (Var)RT.var("clojure.core", "ctor-sigs");
    const__23 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "super")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") }))) })), RT.keyword(null, "line"), Integer.valueOf(59), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/genclass.clj" });
    const__24 = (Var)RT.var("clojure.core", "escape-class-name");
    const__27 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") }))) })), RT.keyword(null, "line"), Integer.valueOf(64), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/genclass.clj" });
    const__28 = (Var)RT.var("clojure.core", "overload-name");
    const__31 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "mname"), Symbol.intern(null, "pclasses")) })), RT.keyword(null, "line"), Integer.valueOf(68), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/genclass.clj" });
    const__32 = (Var)RT.var("clojure.core", "find-field");
    const__37 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.reflect.Field"), RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") })), Symbol.intern(null, "f")) })), RT.keyword(null, "line"), Integer.valueOf(74), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/genclass.clj" });
    const__38 = (Var)RT.var("clojure.core", "prim->class");
    const__40 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(85), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/genclass.clj" });
    const__41 = (AFn)Symbol.intern(null, "int");
    const__42 = (AFn)Symbol.intern(null, "byte");
    const__43 = (AFn)Symbol.intern(null, "floats");
    const__44 = (AFn)Symbol.intern(null, "char");
    const__45 = (AFn)Symbol.intern(null, "chars");
    const__46 = (AFn)Symbol.intern(null, "boolean");
    const__47 = (AFn)Symbol.intern(null, "void");
    const__48 = (AFn)Symbol.intern(null, "longs");
    const__49 = (AFn)Symbol.intern(null, "doubles");
    const__50 = (AFn)Symbol.intern(null, "float");
    const__51 = (AFn)Symbol.intern(null, "booleans");
    const__52 = (AFn)Symbol.intern(null, "shorts");
    const__53 = (AFn)Symbol.intern(null, "bytes");
    const__54 = (AFn)Symbol.intern(null, "double");
    const__55 = (AFn)Symbol.intern(null, "short");
    const__56 = (AFn)Symbol.intern(null, "long");
    const__57 = (AFn)Symbol.intern(null, "ints");
    const__58 = (Var)RT.var("clojure.core", "the-class");
    const__62 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.Class"), RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(104), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/genclass.clj" });
    const__63 = (Var)RT.var("clojure.core", "valid-java-method-name");
    const__66 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))) })), RT.keyword(null, "line"), Integer.valueOf(115), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/genclass.clj" });
    const__67 = (Var)RT.var("clojure.core", "validate-generate-class-options");
    const__70 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "methods")) })) })), RT.keyword(null, "line"), Integer.valueOf(119), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/genclass.clj" });
    const__71 = (Var)RT.var("clojure.core", "generate-class");
    const__74 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "options-map")) })), RT.keyword(null, "line"), Integer.valueOf(124), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/genclass.clj" });
    const__75 = (Var)RT.var("clojure.core", "gen-class");
    const__80 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "options")) })), RT.keyword(null, "doc"), "When compiling, generates compiled bytecode for a class with the\n  given package-qualified :name (which, as all names in these\n  parameters, can be a string or symbol), and writes the .class file\n  to the *compile-path* directory.  When not compiling, does\n  nothing. The gen-class construct contains no implementation, as the\n  implementation will be dynamically sought by the generated class in\n  functions in an implementing Clojure namespace. Given a generated\n  class org.mydomain.MyClass with a method named mymethod, gen-class\n  will generate an implementation that looks for a function named by \n  (str prefix mymethod) (default prefix: \"-\") in a\n  Clojure namespace specified by :impl-ns\n  (defaults to the current namespace). All inherited methods,\n  generated methods, and init and main functions (see :methods, :init,\n  and :main below) will be found similarly prefixed. By default, the\n  static initializer for the generated class will attempt to load the\n  Clojure support code for the class as a resource from the classpath,\n  e.g. in the example case, ``org/mydomain/MyClass__init.class``. This\n  behavior can be controlled by :load-impl-ns\n\n  Note that methods with a maximum of 18 parameters are supported.\n\n  In all subsequent sections taking types, the primitive types can be\n  referred to by their Java names (int, float etc), and classes in the\n  java.lang package can be used without a package qualifier. All other\n  classes must be fully qualified.\n\n  Options should be a set of key/value pairs, all except for :name are optional:\n\n  :name aname\n\n  The package-qualified name of the class to be generated\n\n  :extends aclass\n\n  Specifies the superclass, the non-private methods of which will be\n  overridden by the class. If not provided, defaults to Object.\n\n  :implements [interface ...]\n\n  One or more interfaces, the methods of which will be implemented by the class.\n\n  :init name\n\n  If supplied, names a function that will be called with the arguments\n  to the constructor. Must return [ [superclass-constructor-args] state] \n  If not supplied, the constructor args are passed directly to\n  the superclass constructor and the state will be nil\n\n  :constructors {[param-types] [super-param-types], ...}\n\n  By default, constructors are created for the generated class which\n  match the signature(s) of the constructors for the superclass. This\n  parameter may be used to explicitly specify constructors, each entry\n  providing a mapping from a constructor signature to a superclass\n  constructor signature. When you supply this, you must supply an :init\n  specifier. \n\n  :post-init name\n\n  If supplied, names a function that will be called with the object as\n  the first argument, followed by the arguments to the constructor.\n  It will be called every time an object of this class is created,\n  immediately after all the inherited constructors have completed.\n  Its return value is ignored.\n\n  :methods [ [name [param-types] return-type], ...]\n\n  The generated class automatically defines all of the non-private\n  methods of its superclasses/interfaces. This parameter can be used\n  to specify the signatures of additional methods of the generated\n  class. Static methods can be specified with ^{:static true} in the\n  signature's metadata. Do not repeat superclass/interface signatures\n  here.\n\n  :main boolean\n\n  If supplied and true, a static public main function will be generated. It will\n  pass each string of the String[] argument as a separate argument to\n  a function called (str prefix main).\n\n  :factory name\n\n  If supplied, a (set of) public static factory function(s) will be\n  created with the given name, and the same signature(s) as the\n  constructor(s).\n  \n  :state name\n\n  If supplied, a public final instance field with the given name will be\n  created. You must supply an :init function in order to provide a\n  value for the state. Note that, though final, the state can be a ref\n  or agent, supporting the creation of Java objects with transactional\n  or asynchronous mutation semantics.\n\n  :exposes {protected-field-name {:get name :set name}, ...}\n\n  Since the implementations of the methods of the generated class\n  occur in Clojure functions, they have no access to the inherited\n  protected fields of the superclass. This parameter can be used to\n  generate public getter/setter methods exposing the protected field(s)\n  for use in the implementation.\n\n  :exposes-methods {super-method-name exposed-name, ...}\n\n  It is sometimes necessary to call the superclass' implementation of an\n  overridden method.  Those methods may be exposed and referred in \n  the new method implementation by a local name.\n\n  :prefix string\n\n  Default: \"-\" Methods called e.g. Foo will be looked up in vars called\n  prefixFoo in the implementing ns.\n\n  :impl-ns name\n\n  Default: the name of the current ns. Implementations of methods will be \n  looked up in this namespace.\n\n  :load-impl-ns boolean\n\n  Default: true. Causes the static initializer for the generated class\n  to reference the load code for the implementing namespace. Should be\n  true when implementing-ns is the default, false if you intend to\n  load the code via some other method.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(507), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/genclass.clj" });
    const__81 = (Var)RT.var("clojure.core", "asm-type");
    const__85 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("clojure.asm.Type"), RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "c")) })), RT.keyword(null, "doc"), "Returns an asm Type object for c, which may be a primitive class\n  (such as Integer/TYPE), any other class (such as Double), or a\n  fully-qualified class name given as a string or symbol\n  (such as 'java.lang.String)", RT.keyword(null, "line"), Integer.valueOf(643), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/genclass.clj" });
    const__86 = (Var)RT.var("clojure.core", "generate-interface");
    const__89 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "extends"), Symbol.intern(null, "methods")) })) })), RT.keyword(null, "line"), Integer.valueOf(658), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/genclass.clj" });
    const__90 = (Var)RT.var("clojure.core", "gen-interface");
    const__93 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "options")) })), RT.keyword(null, "doc"), "When compiling, generates compiled bytecode for an interface with\n  the given package-qualified :name (which, as all names in these\n  parameters, can be a string or symbol), and writes the .class file\n  to the *compile-path* directory.  When not compiling, does nothing.\n \n  In all subsequent sections taking types, the primitive types can be\n  referred to by their Java names (int, float etc), and classes in the\n  java.lang package can be used without a package qualifier. All other\n  classes must be fully qualified.\n \n  Options should be a set of key/value pairs, all except for :name are\n  optional:\n\n  :name aname\n\n  The package-qualified name of the class to be generated\n\n  :extends [interface ...]\n\n  One or more interfaces, which will be extended by this interface.\n\n  :methods [ [name [param-types] return-type], ...]\n\n  This parameter is used to specify the signatures of the methods of\n  the generated interface.  Do not repeat superinterface signatures\n  here.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(688), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/genclass.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("clojure.genclass__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
