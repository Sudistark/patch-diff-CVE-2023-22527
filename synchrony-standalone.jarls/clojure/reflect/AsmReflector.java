package clojure.reflect;

import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.Keyword;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Util;
import clojure.lang.Var;

public final class AsmReflector implements Reflector, IType {
  public final Object class_resolver;
  
  private static Class __cached_class__0;
  
  public static final Var const__0 = (Var)RT.var("clojure.reflect", "resolve-class");
  
  public static final Keyword const__3 = (Keyword)RT.keyword(null, "bases"), const__4 = (Keyword)RT.keyword(null, "flags"), const__5 = (Keyword)RT.keyword(null, "members");
  
  public AsmReflector(Object paramObject) { this.class_resolver = paramObject; }
  
  public static IPersistentVector getBasis() { return Tuple.create(Symbol.intern(null, "class-resolver")); }
  
  public Object do_reflect(Object typeref) { if (Util.classOf(this.class_resolver) != __cached_class__0)
      if (!(this.class_resolver instanceof ClassResolver)) {
        __cached_class__0 = Util.classOf(this.class_resolver);
      } else {
        Object is = ((ClassResolver)this.class_resolver).resolve_class(typeref);
      }   }
}
