package clojure.reflect;

import clojure.core;
import clojure.lang.ArraySeq;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.Keyword;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import clojure.reflect;
import clojure.set;

public final class JavaReflector implements Reflector, IType {
  public final Object classloader;
  
  public static final Keyword const__1 = (Keyword)RT.keyword(null, "bases");
  
  public static final Var const__5 = (Var)RT.var("clojure.reflect", "typesym");
  
  public static final Keyword const__7 = (Keyword)RT.keyword(null, "flags"), const__9 = (Keyword)RT.keyword(null, "class"), const__10 = (Keyword)RT.keyword(null, "members");
  
  public JavaReflector(Object paramObject) { this.classloader = paramObject; }
  
  public static IPersistentVector getBasis() { return Tuple.create(Symbol.intern(null, "classloader")); }
  
  public Object do_reflect(Object typeref) {
    typeref = null;
    Object cls = reflect.typeref__GT_class.invokeStatic(typeref, this.classloader);
    new Object[6][0] = const__1;
    new Object[6][1] = core.not_empty.invokeStatic(core.set.invokeStatic(core.map.invokeStatic(const__5.getRawRoot(), core.bases.invokeStatic(cls))));
    new Object[6][2] = const__7;
    new Object[6][3] = 



      
      reflect.parse_flags.invokeStatic(Integer.valueOf(((Class)cls).getModifiers()), const__9);
    new Object[6][4] = const__10;
    cls = null;
    return RT.mapUniqueKeys(new Object[] { null, null, null, null, null, set.union.invokeStatic(reflect.declared_fields.invokeStatic(cls), reflect.declared_methods.invokeStatic(cls), ArraySeq.create(new Object[] { reflect.declared_constructors.invokeStatic(cls) })) });
  }
}
