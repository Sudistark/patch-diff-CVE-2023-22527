package org.bouncycastle.crypto.digests;

import org.bouncycastle.crypto.Digest;

public abstract class HarakaBase implements Digest {
  protected static final int DIGEST_SIZE = 32;
  
  private static final byte[][] S = { 
      { 
        99, 124, 119, 123, -14, 107, 111, -59, 48, 1, 
        103, 43, -2, -41, -85, 118 }, { 
        -54, -126, -55, 125, -6, 89, 71, -16, -83, -44, 
        -94, -81, -100, -92, 114, -64 }, { 
        -73, -3, -109, 38, 54, 63, -9, -52, 52, -91, 
        -27, -15, 113, -40, 49, 21 }, { 
        4, -57, 35, -61, 24, -106, 5, -102, 7, 18, 
        Byte.MIN_VALUE, -30, -21, 39, -78, 117 }, { 
        9, -125, 44, 26, 27, 110, 90, -96, 82, 59, 
        -42, -77, 41, -29, 47, -124 }, { 
        83, -47, 0, -19, 32, -4, -79, 91, 106, -53, 
        -66, 57, 74, 76, 88, -49 }, { 
        -48, -17, -86, -5, 67, 77, 51, -123, 69, -7, 
        2, Byte.MAX_VALUE, 80, 60, -97, -88 }, { 
        81, -93, 64, -113, -110, -99, 56, -11, -68, -74, 
        -38, 33, 16, -1, -13, -46 }, { 
        -51, 12, 19, -20, 95, -105, 68, 23, -60, -89, 
        126, 61, 100, 93, 25, 115 }, { 
        96, -127, 79, -36, 34, 42, -112, -120, 70, -18, 
        -72, 20, -34, 94, 11, -37 }, 
      { 
        -32, 50, 58, 10, 73, 6, 36, 92, -62, -45, 
        -84, 98, -111, -107, -28, 121 }, { 
        -25, -56, 55, 109, -115, -43, 78, -87, 108, 86, 
        -12, -22, 101, 122, -82, 8 }, { 
        -70, 120, 37, 46, 28, -90, -76, -58, -24, -35, 
        116, 31, 75, -67, -117, -118 }, { 
        112, 62, -75, 102, 72, 3, -10, 14, 97, 53, 
        87, -71, -122, -63, 29, -98 }, { 
        -31, -8, -104, 17, 105, -39, -114, -108, -101, 30, 
        -121, -23, -50, 85, 40, -33 }, { 
        -116, -95, -119, 13, -65, -26, 66, 104, 65, -103, 
        45, 15, -80, 84, -69, 22 } };
  
  static byte sBox(byte paramByte) { return S[(paramByte & 0xFF) >>> 4][paramByte & 0xF]; }
  
  static byte[] subBytes(byte[] paramArrayOfByte) {
    byte[] arrayOfByte = new byte[paramArrayOfByte.length];
    arrayOfByte[0] = sBox(paramArrayOfByte[0]);
    arrayOfByte[1] = sBox(paramArrayOfByte[1]);
    arrayOfByte[2] = sBox(paramArrayOfByte[2]);
    arrayOfByte[3] = sBox(paramArrayOfByte[3]);
    arrayOfByte[4] = sBox(paramArrayOfByte[4]);
    arrayOfByte[5] = sBox(paramArrayOfByte[5]);
    arrayOfByte[6] = sBox(paramArrayOfByte[6]);
    arrayOfByte[7] = sBox(paramArrayOfByte[7]);
    arrayOfByte[8] = sBox(paramArrayOfByte[8]);
    arrayOfByte[9] = sBox(paramArrayOfByte[9]);
    arrayOfByte[10] = sBox(paramArrayOfByte[10]);
    arrayOfByte[11] = sBox(paramArrayOfByte[11]);
    arrayOfByte[12] = sBox(paramArrayOfByte[12]);
    arrayOfByte[13] = sBox(paramArrayOfByte[13]);
    arrayOfByte[14] = sBox(paramArrayOfByte[14]);
    arrayOfByte[15] = sBox(paramArrayOfByte[15]);
    return arrayOfByte;
  }
  
  static byte[] shiftRows(byte[] paramArrayOfByte) { return new byte[] { 
        paramArrayOfByte[0], paramArrayOfByte[5], paramArrayOfByte[10], paramArrayOfByte[15], paramArrayOfByte[4], paramArrayOfByte[9], paramArrayOfByte[14], paramArrayOfByte[3], paramArrayOfByte[8], paramArrayOfByte[13], 
        paramArrayOfByte[2], paramArrayOfByte[7], paramArrayOfByte[12], paramArrayOfByte[1], paramArrayOfByte[6], paramArrayOfByte[11] }; }
  
  static byte[] aesEnc(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2) {
    paramArrayOfByte1 = subBytes(paramArrayOfByte1);
    paramArrayOfByte1 = shiftRows(paramArrayOfByte1);
    paramArrayOfByte1 = mixColumns(paramArrayOfByte1);
    xorReverse(paramArrayOfByte1, paramArrayOfByte2);
    return paramArrayOfByte1;
  }
  
  static byte xTime(byte paramByte) { return (paramByte >>> 7 > 0) ? (byte)((paramByte << 1 ^ 0x1B) & 0xFF) : (byte)(paramByte << 1 & 0xFF); }
  
  static void xorReverse(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2) {
    paramArrayOfByte1[0] = (byte)(paramArrayOfByte1[0] ^ paramArrayOfByte2[15]);
    paramArrayOfByte1[1] = (byte)(paramArrayOfByte1[1] ^ paramArrayOfByte2[14]);
    paramArrayOfByte1[2] = (byte)(paramArrayOfByte1[2] ^ paramArrayOfByte2[13]);
    paramArrayOfByte1[3] = (byte)(paramArrayOfByte1[3] ^ paramArrayOfByte2[12]);
    paramArrayOfByte1[4] = (byte)(paramArrayOfByte1[4] ^ paramArrayOfByte2[11]);
    paramArrayOfByte1[5] = (byte)(paramArrayOfByte1[5] ^ paramArrayOfByte2[10]);
    paramArrayOfByte1[6] = (byte)(paramArrayOfByte1[6] ^ paramArrayOfByte2[9]);
    paramArrayOfByte1[7] = (byte)(paramArrayOfByte1[7] ^ paramArrayOfByte2[8]);
    paramArrayOfByte1[8] = (byte)(paramArrayOfByte1[8] ^ paramArrayOfByte2[7]);
    paramArrayOfByte1[9] = (byte)(paramArrayOfByte1[9] ^ paramArrayOfByte2[6]);
    paramArrayOfByte1[10] = (byte)(paramArrayOfByte1[10] ^ paramArrayOfByte2[5]);
    paramArrayOfByte1[11] = (byte)(paramArrayOfByte1[11] ^ paramArrayOfByte2[4]);
    paramArrayOfByte1[12] = (byte)(paramArrayOfByte1[12] ^ paramArrayOfByte2[3]);
    paramArrayOfByte1[13] = (byte)(paramArrayOfByte1[13] ^ paramArrayOfByte2[2]);
    paramArrayOfByte1[14] = (byte)(paramArrayOfByte1[14] ^ paramArrayOfByte2[1]);
    paramArrayOfByte1[15] = (byte)(paramArrayOfByte1[15] ^ paramArrayOfByte2[0]);
  }
  
  static byte[] xor(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt) {
    byte[] arrayOfByte = new byte[16];
    for (byte b = 0; b < arrayOfByte.length; b++)
      arrayOfByte[b] = (byte)(paramArrayOfByte1[b] ^ paramArrayOfByte2[paramInt++]); 
    return arrayOfByte;
  }
  
  private static byte[] mixColumns(byte[] paramArrayOfByte) {
    byte[] arrayOfByte = new byte[paramArrayOfByte.length];
    byte b1 = 0;
    for (byte b2 = 0; b2 < 4; b2++) {
      arrayOfByte[b1++] = (byte)(xTime(paramArrayOfByte[4 * b2]) ^ xTime(paramArrayOfByte[4 * b2 + 1]) ^ paramArrayOfByte[4 * b2 + 1] ^ paramArrayOfByte[4 * b2 + 2] ^ paramArrayOfByte[4 * b2 + 3]);
      arrayOfByte[b1++] = (byte)(paramArrayOfByte[4 * b2] ^ xTime(paramArrayOfByte[4 * b2 + 1]) ^ xTime(paramArrayOfByte[4 * b2 + 2]) ^ paramArrayOfByte[4 * b2 + 2] ^ paramArrayOfByte[4 * b2 + 3]);
      arrayOfByte[b1++] = (byte)(paramArrayOfByte[4 * b2] ^ paramArrayOfByte[4 * b2 + 1] ^ xTime(paramArrayOfByte[4 * b2 + 2]) ^ xTime(paramArrayOfByte[4 * b2 + 3]) ^ paramArrayOfByte[4 * b2 + 3]);
      arrayOfByte[b1++] = (byte)(xTime(paramArrayOfByte[4 * b2]) ^ paramArrayOfByte[4 * b2] ^ paramArrayOfByte[4 * b2 + 1] ^ paramArrayOfByte[4 * b2 + 2] ^ xTime(paramArrayOfByte[4 * b2 + 3]));
    } 
    return arrayOfByte;
  }
  
  public int getDigestSize() { return 32; }
}
