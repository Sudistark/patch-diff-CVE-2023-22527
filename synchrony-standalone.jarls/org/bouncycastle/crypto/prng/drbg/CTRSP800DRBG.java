package org.bouncycastle.crypto.prng.drbg;

import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.prng.EntropySource;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.encoders.Hex;

public class CTRSP800DRBG implements SP80090DRBG {
  private static final long TDEA_RESEED_MAX = 2147483648L;
  
  private static final long AES_RESEED_MAX = 140737488355328L;
  
  private static final int TDEA_MAX_BITS_REQUEST = 4096;
  
  private static final int AES_MAX_BITS_REQUEST = 262144;
  
  private EntropySource _entropySource;
  
  private BlockCipher _engine;
  
  private int _keySizeInBits;
  
  private int _seedLength;
  
  private int _securityStrength;
  
  private byte[] _Key;
  
  private byte[] _V;
  
  private long _reseedCounter = 0L;
  
  private boolean _isTDEA = false;
  
  private static final byte[] K_BITS = Hex.decodeStrict("000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F");
  
  public CTRSP800DRBG(BlockCipher paramBlockCipher, int paramInt1, int paramInt2, EntropySource paramEntropySource, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2) {
    this._entropySource = paramEntropySource;
    this._engine = paramBlockCipher;
    this._keySizeInBits = paramInt1;
    this._securityStrength = paramInt2;
    this._seedLength = paramInt1 + paramBlockCipher.getBlockSize() * 8;
    this._isTDEA = isTDEA(paramBlockCipher);
    if (paramInt2 > 256)
      throw new IllegalArgumentException("Requested security strength is not supported by the derivation function"); 
    if (getMaxSecurityStrength(paramBlockCipher, paramInt1) < paramInt2)
      throw new IllegalArgumentException("Requested security strength is not supported by block cipher and key size"); 
    if (paramEntropySource.entropySize() < paramInt2)
      throw new IllegalArgumentException("Not enough entropy for security strength required"); 
    byte[] arrayOfByte = getEntropy();
    CTR_DRBG_Instantiate_algorithm(arrayOfByte, paramArrayOfByte2, paramArrayOfByte1);
  }
  
  private void CTR_DRBG_Instantiate_algorithm(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, byte[] paramArrayOfByte3) {
    byte[] arrayOfByte1 = Arrays.concatenate(paramArrayOfByte1, paramArrayOfByte2, paramArrayOfByte3);
    byte[] arrayOfByte2 = Block_Cipher_df(arrayOfByte1, this._seedLength);
    int i = this._engine.getBlockSize();
    this._Key = new byte[(this._keySizeInBits + 7) / 8];
    this._V = new byte[i];
    CTR_DRBG_Update(arrayOfByte2, this._Key, this._V);
    this._reseedCounter = 1L;
  }
  
  private void CTR_DRBG_Update(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, byte[] paramArrayOfByte3) {
    byte[] arrayOfByte1 = new byte[paramArrayOfByte1.length];
    byte[] arrayOfByte2 = new byte[this._engine.getBlockSize()];
    int i = 0;
    int j = this._engine.getBlockSize();
    this._engine.init(true, new KeyParameter(expandKey(paramArrayOfByte2)));
    while (i * j < paramArrayOfByte1.length) {
      addOneTo(paramArrayOfByte3);
      this._engine.processBlock(paramArrayOfByte3, 0, arrayOfByte2, 0);
      int k = (arrayOfByte1.length - i * j > j) ? j : (arrayOfByte1.length - i * j);
      System.arraycopy(arrayOfByte2, 0, arrayOfByte1, i * j, k);
      i++;
    } 
    XOR(arrayOfByte1, paramArrayOfByte1, arrayOfByte1, 0);
    System.arraycopy(arrayOfByte1, 0, paramArrayOfByte2, 0, paramArrayOfByte2.length);
    System.arraycopy(arrayOfByte1, paramArrayOfByte2.length, paramArrayOfByte3, 0, paramArrayOfByte3.length);
  }
  
  private void CTR_DRBG_Reseed_algorithm(byte[] paramArrayOfByte) {
    byte[] arrayOfByte = Arrays.concatenate(getEntropy(), paramArrayOfByte);
    arrayOfByte = Block_Cipher_df(arrayOfByte, this._seedLength);
    CTR_DRBG_Update(arrayOfByte, this._Key, this._V);
    this._reseedCounter = 1L;
  }
  
  private void XOR(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, byte[] paramArrayOfByte3, int paramInt) {
    for (int i = 0; i < paramArrayOfByte1.length; i++)
      paramArrayOfByte1[i] = (byte)(paramArrayOfByte2[i] ^ paramArrayOfByte3[i + paramInt]); 
  }
  
  private void addOneTo(byte[] paramArrayOfByte) {
    byte b = 1;
    for (int i = 1; i <= paramArrayOfByte.length; i++) {
      byte b1 = (paramArrayOfByte[paramArrayOfByte.length - i] & 0xFF) + b;
      b = (b1 > 255) ? 1 : 0;
      paramArrayOfByte[paramArrayOfByte.length - i] = (byte)b1;
    } 
  }
  
  private byte[] getEntropy() {
    byte[] arrayOfByte = this._entropySource.getEntropy();
    if (arrayOfByte.length < (this._securityStrength + 7) / 8)
      throw new IllegalStateException("Insufficient entropy provided by entropy source"); 
    return arrayOfByte;
  }
  
  private byte[] Block_Cipher_df(byte[] paramArrayOfByte, int paramInt) {
    int i = this._engine.getBlockSize();
    int j = paramArrayOfByte.length;
    int k = paramInt / 8;
    int m = 8 + j + 1;
    int n = (m + i - 1) / i * i;
    byte[] arrayOfByte1 = new byte[n];
    copyIntToByteArray(arrayOfByte1, j, 0);
    copyIntToByteArray(arrayOfByte1, k, 4);
    System.arraycopy(paramArrayOfByte, 0, arrayOfByte1, 8, j);
    arrayOfByte1[8 + j] = Byte.MIN_VALUE;
    byte[] arrayOfByte2 = new byte[this._keySizeInBits / 8 + i];
    byte[] arrayOfByte3 = new byte[i];
    byte[] arrayOfByte4 = new byte[i];
    int i1 = 0;
    byte[] arrayOfByte5 = new byte[this._keySizeInBits / 8];
    System.arraycopy(K_BITS, 0, arrayOfByte5, 0, arrayOfByte5.length);
    while (i1 * i * 8 < this._keySizeInBits + i * 8) {
      copyIntToByteArray(arrayOfByte4, i1, 0);
      BCC(arrayOfByte3, arrayOfByte5, arrayOfByte4, arrayOfByte1);
      int i2 = (arrayOfByte2.length - i1 * i > i) ? i : (arrayOfByte2.length - i1 * i);
      System.arraycopy(arrayOfByte3, 0, arrayOfByte2, i1 * i, i2);
      i1++;
    } 
    byte[] arrayOfByte6 = new byte[i];
    System.arraycopy(arrayOfByte2, 0, arrayOfByte5, 0, arrayOfByte5.length);
    System.arraycopy(arrayOfByte2, arrayOfByte5.length, arrayOfByte6, 0, arrayOfByte6.length);
    arrayOfByte2 = new byte[paramInt / 8];
    i1 = 0;
    this._engine.init(true, new KeyParameter(expandKey(arrayOfByte5)));
    while (i1 * i < arrayOfByte2.length) {
      this._engine.processBlock(arrayOfByte6, 0, arrayOfByte6, 0);
      int i2 = (arrayOfByte2.length - i1 * i > i) ? i : (arrayOfByte2.length - i1 * i);
      System.arraycopy(arrayOfByte6, 0, arrayOfByte2, i1 * i, i2);
      i1++;
    } 
    return arrayOfByte2;
  }
  
  private void BCC(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, byte[] paramArrayOfByte3, byte[] paramArrayOfByte4) {
    int i = this._engine.getBlockSize();
    byte[] arrayOfByte1 = new byte[i];
    int j = paramArrayOfByte4.length / i;
    byte[] arrayOfByte2 = new byte[i];
    this._engine.init(true, new KeyParameter(expandKey(paramArrayOfByte2)));
    this._engine.processBlock(paramArrayOfByte3, 0, arrayOfByte1, 0);
    for (int k = 0; k < j; k++) {
      XOR(arrayOfByte2, arrayOfByte1, paramArrayOfByte4, k * i);
      this._engine.processBlock(arrayOfByte2, 0, arrayOfByte1, 0);
    } 
    System.arraycopy(arrayOfByte1, 0, paramArrayOfByte1, 0, paramArrayOfByte1.length);
  }
  
  private void copyIntToByteArray(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    paramArrayOfByte[paramInt2 + 0] = (byte)(paramInt1 >> 24);
    paramArrayOfByte[paramInt2 + 1] = (byte)(paramInt1 >> 16);
    paramArrayOfByte[paramInt2 + 2] = (byte)(paramInt1 >> 8);
    paramArrayOfByte[paramInt2 + 3] = (byte)paramInt1;
  }
  
  public int getBlockSize() { return this._V.length * 8; }
  
  public int generate(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, boolean paramBoolean) {
    if (this._isTDEA) {
      if (this._reseedCounter > 2147483648L)
        return -1; 
      if (Utils.isTooLarge(paramArrayOfByte1, 512))
        throw new IllegalArgumentException("Number of bits per request limited to 4096"); 
    } else {
      if (this._reseedCounter > 140737488355328L)
        return -1; 
      if (Utils.isTooLarge(paramArrayOfByte1, 32768))
        throw new IllegalArgumentException("Number of bits per request limited to 262144"); 
    } 
    if (paramBoolean) {
      CTR_DRBG_Reseed_algorithm(paramArrayOfByte2);
      paramArrayOfByte2 = null;
    } 
    if (paramArrayOfByte2 != null) {
      paramArrayOfByte2 = Block_Cipher_df(paramArrayOfByte2, this._seedLength);
      CTR_DRBG_Update(paramArrayOfByte2, this._Key, this._V);
    } else {
      paramArrayOfByte2 = new byte[this._seedLength / 8];
    } 
    byte[] arrayOfByte = new byte[this._V.length];
    this._engine.init(true, new KeyParameter(expandKey(this._Key)));
    for (int i = 0; i <= paramArrayOfByte1.length / arrayOfByte.length; i++) {
      int j = (paramArrayOfByte1.length - i * arrayOfByte.length > arrayOfByte.length) ? arrayOfByte.length : (paramArrayOfByte1.length - i * this._V.length);
      if (j != 0) {
        addOneTo(this._V);
        this._engine.processBlock(this._V, 0, arrayOfByte, 0);
        System.arraycopy(arrayOfByte, 0, paramArrayOfByte1, i * arrayOfByte.length, j);
      } 
    } 
    CTR_DRBG_Update(paramArrayOfByte2, this._Key, this._V);
    this._reseedCounter++;
    return paramArrayOfByte1.length * 8;
  }
  
  public void reseed(byte[] paramArrayOfByte) { CTR_DRBG_Reseed_algorithm(paramArrayOfByte); }
  
  private boolean isTDEA(BlockCipher paramBlockCipher) { return (paramBlockCipher.getAlgorithmName().equals("DESede") || paramBlockCipher.getAlgorithmName().equals("TDEA")); }
  
  private int getMaxSecurityStrength(BlockCipher paramBlockCipher, int paramInt) { return (isTDEA(paramBlockCipher) && paramInt == 168) ? 112 : (paramBlockCipher.getAlgorithmName().equals("AES") ? paramInt : -1); }
  
  byte[] expandKey(byte[] paramArrayOfByte) {
    if (this._isTDEA) {
      byte[] arrayOfByte = new byte[24];
      padKey(paramArrayOfByte, 0, arrayOfByte, 0);
      padKey(paramArrayOfByte, 7, arrayOfByte, 8);
      padKey(paramArrayOfByte, 14, arrayOfByte, 16);
      return arrayOfByte;
    } 
    return paramArrayOfByte;
  }
  
  private void padKey(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2) {
    paramArrayOfByte2[paramInt2 + 0] = (byte)(paramArrayOfByte1[paramInt1 + 0] & 0xFE);
    paramArrayOfByte2[paramInt2 + 1] = (byte)(paramArrayOfByte1[paramInt1 + 0] << 7 | (paramArrayOfByte1[paramInt1 + 1] & 0xFC) >>> 1);
    paramArrayOfByte2[paramInt2 + 2] = (byte)(paramArrayOfByte1[paramInt1 + 1] << 6 | (paramArrayOfByte1[paramInt1 + 2] & 0xF8) >>> 2);
    paramArrayOfByte2[paramInt2 + 3] = (byte)(paramArrayOfByte1[paramInt1 + 2] << 5 | (paramArrayOfByte1[paramInt1 + 3] & 0xF0) >>> 3);
    paramArrayOfByte2[paramInt2 + 4] = (byte)(paramArrayOfByte1[paramInt1 + 3] << 4 | (paramArrayOfByte1[paramInt1 + 4] & 0xE0) >>> 4);
    paramArrayOfByte2[paramInt2 + 5] = (byte)(paramArrayOfByte1[paramInt1 + 4] << 3 | (paramArrayOfByte1[paramInt1 + 5] & 0xC0) >>> 5);
    paramArrayOfByte2[paramInt2 + 6] = (byte)(paramArrayOfByte1[paramInt1 + 5] << 2 | (paramArrayOfByte1[paramInt1 + 6] & 0x80) >>> 6);
    paramArrayOfByte2[paramInt2 + 7] = (byte)(paramArrayOfByte1[paramInt1 + 6] << 1);
    for (int i = paramInt2; i <= paramInt2 + 7; i++) {
      byte b = paramArrayOfByte2[i];
      paramArrayOfByte2[i] = (byte)(b & 0xFE | (b >> 1 ^ b >> 2 ^ b >> 3 ^ b >> 4 ^ b >> 5 ^ b >> 6 ^ b >> 7 ^ true) & true);
    } 
  }
}
