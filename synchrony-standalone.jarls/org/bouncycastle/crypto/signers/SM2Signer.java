package org.bouncycastle.crypto.signers;

import java.math.BigInteger;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.CryptoException;
import org.bouncycastle.crypto.CryptoServicesRegistrar;
import org.bouncycastle.crypto.Digest;
import org.bouncycastle.crypto.Signer;
import org.bouncycastle.crypto.digests.SM3Digest;
import org.bouncycastle.crypto.params.ECDomainParameters;
import org.bouncycastle.crypto.params.ECKeyParameters;
import org.bouncycastle.crypto.params.ECPrivateKeyParameters;
import org.bouncycastle.crypto.params.ECPublicKeyParameters;
import org.bouncycastle.crypto.params.ParametersWithID;
import org.bouncycastle.crypto.params.ParametersWithRandom;
import org.bouncycastle.math.ec.ECAlgorithms;
import org.bouncycastle.math.ec.ECConstants;
import org.bouncycastle.math.ec.ECFieldElement;
import org.bouncycastle.math.ec.ECMultiplier;
import org.bouncycastle.math.ec.ECPoint;
import org.bouncycastle.math.ec.FixedPointCombMultiplier;
import org.bouncycastle.util.BigIntegers;
import org.bouncycastle.util.encoders.Hex;

public class SM2Signer implements Signer, ECConstants {
  private final DSAKCalculator kCalculator = new RandomDSAKCalculator();
  
  private final Digest digest;
  
  private final DSAEncoding encoding;
  
  private ECDomainParameters ecParams;
  
  private ECPoint pubPoint;
  
  private ECKeyParameters ecKey;
  
  private byte[] z;
  
  public SM2Signer() { this(StandardDSAEncoding.INSTANCE, new SM3Digest()); }
  
  public SM2Signer(Digest paramDigest) { this(StandardDSAEncoding.INSTANCE, paramDigest); }
  
  public SM2Signer(DSAEncoding paramDSAEncoding) {
    this.encoding = paramDSAEncoding;
    this.digest = new SM3Digest();
  }
  
  public SM2Signer(DSAEncoding paramDSAEncoding, Digest paramDigest) {
    this.encoding = paramDSAEncoding;
    this.digest = paramDigest;
  }
  
  public void init(boolean paramBoolean, CipherParameters paramCipherParameters) {
    byte[] arrayOfByte;
    CipherParameters cipherParameters;
    if (paramCipherParameters instanceof ParametersWithID) {
      cipherParameters = ((ParametersWithID)paramCipherParameters).getParameters();
      arrayOfByte = ((ParametersWithID)paramCipherParameters).getID();
      if (arrayOfByte.length >= 8192)
        throw new IllegalArgumentException("SM2 user ID must be less than 2^16 bits long"); 
    } else {
      cipherParameters = paramCipherParameters;
      arrayOfByte = Hex.decodeStrict("31323334353637383132333435363738");
    } 
    if (paramBoolean) {
      if (cipherParameters instanceof ParametersWithRandom) {
        ParametersWithRandom parametersWithRandom = (ParametersWithRandom)cipherParameters;
        this.ecKey = (ECKeyParameters)parametersWithRandom.getParameters();
        this.ecParams = this.ecKey.getParameters();
        this.kCalculator.init(this.ecParams.getN(), parametersWithRandom.getRandom());
      } else {
        this.ecKey = (ECKeyParameters)cipherParameters;
        this.ecParams = this.ecKey.getParameters();
        this.kCalculator.init(this.ecParams.getN(), CryptoServicesRegistrar.getSecureRandom());
      } 
      this.pubPoint = createBasePointMultiplier().multiply(this.ecParams.getG(), ((ECPrivateKeyParameters)this.ecKey).getD()).normalize();
    } else {
      this.ecKey = (ECKeyParameters)cipherParameters;
      this.ecParams = this.ecKey.getParameters();
      this.pubPoint = ((ECPublicKeyParameters)this.ecKey).getQ();
    } 
    this.z = getZ(arrayOfByte);
    this.digest.update(this.z, 0, this.z.length);
  }
  
  public void update(byte paramByte) { this.digest.update(paramByte); }
  
  public void update(byte[] paramArrayOfByte, int paramInt1, int paramInt2) { this.digest.update(paramArrayOfByte, paramInt1, paramInt2); }
  
  public boolean verifySignature(byte[] paramArrayOfByte) {
    try {
      BigInteger[] arrayOfBigInteger = this.encoding.decode(this.ecParams.getN(), paramArrayOfByte);
      return verifySignature(arrayOfBigInteger[0], arrayOfBigInteger[1]);
    } catch (Exception exception) {
      return false;
    } 
  }
  
  public void reset() {
    this.digest.reset();
    if (this.z != null)
      this.digest.update(this.z, 0, this.z.length); 
  }
  
  public byte[] generateSignature() throws CryptoException {
    BigInteger bigInteger5;
    BigInteger bigInteger4;
    byte[] arrayOfByte = digestDoFinal();
    BigInteger bigInteger1 = this.ecParams.getN();
    BigInteger bigInteger2 = calculateE(bigInteger1, arrayOfByte);
    BigInteger bigInteger3 = ((ECPrivateKeyParameters)this.ecKey).getD();
    ECMultiplier eCMultiplier = createBasePointMultiplier();
    while (true) {
      BigInteger bigInteger = this.kCalculator.nextK();
      ECPoint eCPoint = eCMultiplier.multiply(this.ecParams.getG(), bigInteger).normalize();
      bigInteger4 = bigInteger2.add(eCPoint.getAffineXCoord().toBigInteger()).mod(bigInteger1);
      if (!bigInteger4.equals(ZERO) && !bigInteger4.add(bigInteger).equals(bigInteger1)) {
        BigInteger bigInteger6 = BigIntegers.modOddInverse(bigInteger1, bigInteger3.add(ONE));
        bigInteger5 = bigInteger.subtract(bigInteger4.multiply(bigInteger3)).mod(bigInteger1);
        bigInteger5 = bigInteger6.multiply(bigInteger5).mod(bigInteger1);
        if (!bigInteger5.equals(ZERO))
          break; 
      } 
    } 
    try {
      return this.encoding.encode(this.ecParams.getN(), bigInteger4, bigInteger5);
    } catch (Exception exception) {
      throw new CryptoException("unable to encode signature: " + exception.getMessage(), exception);
    } 
  }
  
  private boolean verifySignature(BigInteger paramBigInteger1, BigInteger paramBigInteger2) {
    BigInteger bigInteger1 = this.ecParams.getN();
    if (paramBigInteger1.compareTo(ONE) < 0 || paramBigInteger1.compareTo(bigInteger1) >= 0)
      return false; 
    if (paramBigInteger2.compareTo(ONE) < 0 || paramBigInteger2.compareTo(bigInteger1) >= 0)
      return false; 
    byte[] arrayOfByte = digestDoFinal();
    BigInteger bigInteger2 = calculateE(bigInteger1, arrayOfByte);
    BigInteger bigInteger3 = paramBigInteger1.add(paramBigInteger2).mod(bigInteger1);
    if (bigInteger3.equals(ZERO))
      return false; 
    ECPoint eCPoint1 = ((ECPublicKeyParameters)this.ecKey).getQ();
    ECPoint eCPoint2 = ECAlgorithms.sumOfTwoMultiplies(this.ecParams.getG(), paramBigInteger2, eCPoint1, bigInteger3).normalize();
    if (eCPoint2.isInfinity())
      return false; 
    BigInteger bigInteger4 = bigInteger2.add(eCPoint2.getAffineXCoord().toBigInteger()).mod(bigInteger1);
    return bigInteger4.equals(paramBigInteger1);
  }
  
  private byte[] digestDoFinal() throws CryptoException {
    byte[] arrayOfByte = new byte[this.digest.getDigestSize()];
    this.digest.doFinal(arrayOfByte, 0);
    reset();
    return arrayOfByte;
  }
  
  private byte[] getZ(byte[] paramArrayOfByte) {
    this.digest.reset();
    addUserID(this.digest, paramArrayOfByte);
    addFieldElement(this.digest, this.ecParams.getCurve().getA());
    addFieldElement(this.digest, this.ecParams.getCurve().getB());
    addFieldElement(this.digest, this.ecParams.getG().getAffineXCoord());
    addFieldElement(this.digest, this.ecParams.getG().getAffineYCoord());
    addFieldElement(this.digest, this.pubPoint.getAffineXCoord());
    addFieldElement(this.digest, this.pubPoint.getAffineYCoord());
    byte[] arrayOfByte = new byte[this.digest.getDigestSize()];
    this.digest.doFinal(arrayOfByte, 0);
    return arrayOfByte;
  }
  
  private void addUserID(Digest paramDigest, byte[] paramArrayOfByte) {
    int i = paramArrayOfByte.length * 8;
    paramDigest.update((byte)(i >> 8 & 0xFF));
    paramDigest.update((byte)(i & 0xFF));
    paramDigest.update(paramArrayOfByte, 0, paramArrayOfByte.length);
  }
  
  private void addFieldElement(Digest paramDigest, ECFieldElement paramECFieldElement) {
    byte[] arrayOfByte = paramECFieldElement.getEncoded();
    paramDigest.update(arrayOfByte, 0, arrayOfByte.length);
  }
  
  protected ECMultiplier createBasePointMultiplier() { return new FixedPointCombMultiplier(); }
  
  protected BigInteger calculateE(BigInteger paramBigInteger, byte[] paramArrayOfByte) { return new BigInteger(1, paramArrayOfByte); }
}
