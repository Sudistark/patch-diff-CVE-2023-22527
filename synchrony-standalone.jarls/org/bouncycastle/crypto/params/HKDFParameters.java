package org.bouncycastle.crypto.params;

import org.bouncycastle.crypto.DerivationParameters;
import org.bouncycastle.util.Arrays;

public class HKDFParameters implements DerivationParameters {
  private final byte[] ikm;
  
  private final boolean skipExpand;
  
  private final byte[] salt;
  
  private final byte[] info;
  
  private HKDFParameters(byte[] paramArrayOfByte1, boolean paramBoolean, byte[] paramArrayOfByte2, byte[] paramArrayOfByte3) {
    if (paramArrayOfByte1 == null)
      throw new IllegalArgumentException("IKM (input keying material) should not be null"); 
    this.ikm = Arrays.clone(paramArrayOfByte1);
    this.skipExpand = paramBoolean;
    if (paramArrayOfByte2 == null || paramArrayOfByte2.length == 0) {
      this.salt = null;
    } else {
      this.salt = Arrays.clone(paramArrayOfByte2);
    } 
    if (paramArrayOfByte3 == null) {
      this.info = new byte[0];
    } else {
      this.info = Arrays.clone(paramArrayOfByte3);
    } 
  }
  
  public HKDFParameters(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, byte[] paramArrayOfByte3) { this(paramArrayOfByte1, false, paramArrayOfByte2, paramArrayOfByte3); }
  
  public static HKDFParameters skipExtractParameters(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2) { return new HKDFParameters(paramArrayOfByte1, true, null, paramArrayOfByte2); }
  
  public static HKDFParameters defaultParameters(byte[] paramArrayOfByte) { return new HKDFParameters(paramArrayOfByte, false, null, null); }
  
  public byte[] getIKM() { return Arrays.clone(this.ikm); }
  
  public boolean skipExtract() { return this.skipExpand; }
  
  public byte[] getSalt() { return Arrays.clone(this.salt); }
  
  public byte[] getInfo() { return Arrays.clone(this.info); }
}
