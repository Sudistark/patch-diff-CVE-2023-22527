package org.bouncycastle.crypto.util;

import java.util.HashMap;
import java.util.Map;
import org.bouncycastle.crypto.AlphabetMapper;

public class BasicAlphabetMapper implements AlphabetMapper {
  private Map<Character, Integer> indexMap = new HashMap();
  
  private Map<Integer, Character> charMap = new HashMap();
  
  public BasicAlphabetMapper(String paramString) { this(paramString.toCharArray()); }
  
  public BasicAlphabetMapper(char[] paramArrayOfChar) {
    for (byte b = 0; b != paramArrayOfChar.length; b++) {
      if (this.indexMap.containsKey(Character.valueOf(paramArrayOfChar[b])))
        throw new IllegalArgumentException("duplicate key detected in alphabet: " + paramArrayOfChar[b]); 
      this.indexMap.put(Character.valueOf(paramArrayOfChar[b]), Integer.valueOf(b));
      this.charMap.put(Integer.valueOf(b), Character.valueOf(paramArrayOfChar[b]));
    } 
  }
  
  public int getRadix() { return this.indexMap.size(); }
  
  public byte[] convertToIndexes(char[] paramArrayOfChar) {
    byte[] arrayOfByte;
    if (this.indexMap.size() <= 256) {
      arrayOfByte = new byte[paramArrayOfChar.length];
      for (byte b = 0; b != paramArrayOfChar.length; b++)
        arrayOfByte[b] = ((Integer)this.indexMap.get(Character.valueOf(paramArrayOfChar[b]))).byteValue(); 
    } else {
      arrayOfByte = new byte[paramArrayOfChar.length * 2];
      for (byte b = 0; b != paramArrayOfChar.length; b++) {
        int i = ((Integer)this.indexMap.get(Character.valueOf(paramArrayOfChar[b]))).intValue();
        arrayOfByte[b * 2] = (byte)(i >> 8 & 0xFF);
        arrayOfByte[b * 2 + 1] = (byte)(i & 0xFF);
      } 
    } 
    return arrayOfByte;
  }
  
  public char[] convertToChars(byte[] paramArrayOfByte) {
    char[] arrayOfChar;
    if (this.charMap.size() <= 256) {
      arrayOfChar = new char[paramArrayOfByte.length];
      for (byte b = 0; b != paramArrayOfByte.length; b++)
        arrayOfChar[b] = ((Character)this.charMap.get(Integer.valueOf(paramArrayOfByte[b] & 0xFF))).charValue(); 
    } else {
      if ((paramArrayOfByte.length & true) != 0)
        throw new IllegalArgumentException("two byte radix and input string odd length"); 
      arrayOfChar = new char[paramArrayOfByte.length / 2];
      for (boolean bool = false; bool != paramArrayOfByte.length; bool += true)
        arrayOfChar[bool / 2] = ((Character)this.charMap.get(Integer.valueOf(paramArrayOfByte[bool] << 8 & 0xFF00 | paramArrayOfByte[bool + true] & 0xFF))).charValue(); 
    } 
    return arrayOfChar;
  }
}
