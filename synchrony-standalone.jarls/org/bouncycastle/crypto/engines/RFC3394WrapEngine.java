package org.bouncycastle.crypto.engines;

import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.crypto.Wrapper;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.ParametersWithIV;
import org.bouncycastle.crypto.params.ParametersWithRandom;
import org.bouncycastle.util.Arrays;

public class RFC3394WrapEngine implements Wrapper {
  private BlockCipher engine;
  
  private boolean wrapCipherMode;
  
  private KeyParameter param;
  
  private boolean forWrapping;
  
  private byte[] iv = { -90, -90, -90, -90, -90, -90, -90, -90 };
  
  public RFC3394WrapEngine(BlockCipher paramBlockCipher) { this(paramBlockCipher, false); }
  
  public RFC3394WrapEngine(BlockCipher paramBlockCipher, boolean paramBoolean) {
    this.engine = paramBlockCipher;
    this.wrapCipherMode = !paramBoolean;
  }
  
  public void init(boolean paramBoolean, CipherParameters paramCipherParameters) {
    this.forWrapping = paramBoolean;
    if (paramCipherParameters instanceof ParametersWithRandom)
      paramCipherParameters = ((ParametersWithRandom)paramCipherParameters).getParameters(); 
    if (paramCipherParameters instanceof KeyParameter) {
      this.param = (KeyParameter)paramCipherParameters;
    } else if (paramCipherParameters instanceof ParametersWithIV) {
      this.iv = ((ParametersWithIV)paramCipherParameters).getIV();
      this.param = (KeyParameter)((ParametersWithIV)paramCipherParameters).getParameters();
      if (this.iv.length != 8)
        throw new IllegalArgumentException("IV not equal to 8"); 
    } 
  }
  
  public String getAlgorithmName() { return this.engine.getAlgorithmName(); }
  
  public byte[] wrap(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    if (!this.forWrapping)
      throw new IllegalStateException("not set for wrapping"); 
    int i = paramInt2 / 8;
    if (i * 8 != paramInt2)
      throw new DataLengthException("wrap data must be a multiple of 8 bytes"); 
    byte[] arrayOfByte1 = new byte[paramInt2 + this.iv.length];
    byte[] arrayOfByte2 = new byte[8 + this.iv.length];
    System.arraycopy(this.iv, 0, arrayOfByte1, 0, this.iv.length);
    System.arraycopy(paramArrayOfByte, paramInt1, arrayOfByte1, this.iv.length, paramInt2);
    this.engine.init(this.wrapCipherMode, this.param);
    for (int j = 0; j != 6; j++) {
      for (int k = 1; k <= i; k++) {
        System.arraycopy(arrayOfByte1, 0, arrayOfByte2, 0, this.iv.length);
        System.arraycopy(arrayOfByte1, 8 * k, arrayOfByte2, this.iv.length, 8);
        this.engine.processBlock(arrayOfByte2, 0, arrayOfByte2, 0);
        int m = i * j + k;
        for (int n = 1; m != 0; n++) {
          byte b = (byte)m;
          arrayOfByte2[this.iv.length - n] = (byte)(arrayOfByte2[this.iv.length - n] ^ b);
          m >>>= 8;
        } 
        System.arraycopy(arrayOfByte2, 0, arrayOfByte1, 0, 8);
        System.arraycopy(arrayOfByte2, 8, arrayOfByte1, 8 * k, 8);
      } 
    } 
    return arrayOfByte1;
  }
  
  public byte[] unwrap(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    if (this.forWrapping)
      throw new IllegalStateException("not set for unwrapping"); 
    int i = paramInt2 / 8;
    if (i * 8 != paramInt2)
      throw new InvalidCipherTextException("unwrap data must be a multiple of 8 bytes"); 
    byte[] arrayOfByte1 = new byte[paramInt2 - this.iv.length];
    byte[] arrayOfByte2 = new byte[this.iv.length];
    byte[] arrayOfByte3 = new byte[8 + this.iv.length];
    System.arraycopy(paramArrayOfByte, paramInt1, arrayOfByte2, 0, this.iv.length);
    System.arraycopy(paramArrayOfByte, paramInt1 + this.iv.length, arrayOfByte1, 0, paramInt2 - this.iv.length);
    this.engine.init(!this.wrapCipherMode, this.param);
    i--;
    for (int j = 5; j >= 0; j--) {
      for (int k = i; k >= 1; k--) {
        System.arraycopy(arrayOfByte2, 0, arrayOfByte3, 0, this.iv.length);
        System.arraycopy(arrayOfByte1, 8 * (k - 1), arrayOfByte3, this.iv.length, 8);
        int m = i * j + k;
        for (int n = 1; m != 0; n++) {
          byte b = (byte)m;
          arrayOfByte3[this.iv.length - n] = (byte)(arrayOfByte3[this.iv.length - n] ^ b);
          m >>>= 8;
        } 
        this.engine.processBlock(arrayOfByte3, 0, arrayOfByte3, 0);
        System.arraycopy(arrayOfByte3, 0, arrayOfByte2, 0, 8);
        System.arraycopy(arrayOfByte3, 8, arrayOfByte1, 8 * (k - 1), 8);
      } 
    } 
    if (!Arrays.constantTimeAreEqual(arrayOfByte2, this.iv))
      throw new InvalidCipherTextException("checksum failed"); 
    return arrayOfByte1;
  }
}
