package org.bouncycastle.crypto.engines;

import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.OutputLengthException;
import org.bouncycastle.crypto.StreamCipher;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.util.Pack;

public class ISAACEngine implements StreamCipher {
  private final int sizeL = 8;
  
  private final int stateArraySize = 256;
  
  private int[] engineState = null;
  
  private int[] results = null;
  
  private int a = 0;
  
  private int b = 0;
  
  private int c = 0;
  
  private int index = 0;
  
  private byte[] keyStream = new byte[1024];
  
  private byte[] workingKey = null;
  
  private boolean initialised = false;
  
  public void init(boolean paramBoolean, CipherParameters paramCipherParameters) {
    if (!(paramCipherParameters instanceof KeyParameter))
      throw new IllegalArgumentException("invalid parameter passed to ISAAC init - " + paramCipherParameters.getClass().getName()); 
    KeyParameter keyParameter = (KeyParameter)paramCipherParameters;
    setKey(keyParameter.getKey());
  }
  
  public byte returnByte(byte paramByte) {
    if (this.index == 0) {
      isaac();
      this.keyStream = Pack.intToBigEndian(this.results);
    } 
    byte b1 = (byte)(this.keyStream[this.index] ^ paramByte);
    this.index = this.index + 1 & 0x3FF;
    return b1;
  }
  
  public int processBytes(byte[] paramArrayOfByte1, int paramInt1, int paramInt2, byte[] paramArrayOfByte2, int paramInt3) {
    if (!this.initialised)
      throw new IllegalStateException(getAlgorithmName() + " not initialised"); 
    if (paramInt1 + paramInt2 > paramArrayOfByte1.length)
      throw new DataLengthException("input buffer too short"); 
    if (paramInt3 + paramInt2 > paramArrayOfByte2.length)
      throw new OutputLengthException("output buffer too short"); 
    for (int i = 0; i < paramInt2; i++) {
      if (this.index == 0) {
        isaac();
        this.keyStream = Pack.intToBigEndian(this.results);
      } 
      paramArrayOfByte2[i + paramInt3] = (byte)(this.keyStream[this.index] ^ paramArrayOfByte1[i + paramInt1]);
      this.index = this.index + 1 & 0x3FF;
    } 
    return paramInt2;
  }
  
  public String getAlgorithmName() { return "ISAAC"; }
  
  public void reset() { setKey(this.workingKey); }
  
  private void setKey(byte[] paramArrayOfByte) {
    this.workingKey = paramArrayOfByte;
    if (this.engineState == null)
      this.engineState = new int[256]; 
    if (this.results == null)
      this.results = new int[256]; 
    byte b1;
    for (b1 = 0; b1 < 'Ā'; b1++) {
      this.results[b1] = 0;
      this.engineState[b1] = 0;
    } 
    this.a = this.b = this.c = 0;
    this.index = 0;
    byte[] arrayOfByte = new byte[paramArrayOfByte.length + (paramArrayOfByte.length & 0x3)];
    System.arraycopy(paramArrayOfByte, 0, arrayOfByte, 0, paramArrayOfByte.length);
    for (b1 = 0; b1 < arrayOfByte.length; b1 += 4)
      this.results[b1 >>> 2] = Pack.littleEndianToInt(arrayOfByte, b1); 
    int[] arrayOfInt = new int[8];
    for (b1 = 0; b1 < 8; b1++)
      arrayOfInt[b1] = -1640531527; 
    for (b1 = 0; b1 < 4; b1++)
      mix(arrayOfInt); 
    for (b1 = 0; b1 < 2; b1++) {
      for (byte b2 = 0; b2 < 'Ā'; b2 += 8) {
        byte b3;
        for (b3 = 0; b3 < 8; b3++)
          arrayOfInt[b3] = arrayOfInt[b3] + ((b1 < 1) ? this.results[b2 + b3] : this.engineState[b2 + b3]); 
        mix(arrayOfInt);
        for (b3 = 0; b3 < 8; b3++)
          this.engineState[b2 + b3] = arrayOfInt[b3]; 
      } 
    } 
    isaac();
    this.initialised = true;
  }
  
  private void isaac() {
    this.b += ++this.c;
    for (byte b1 = 0; b1 < 'Ā'; b1++) {
      int i = this.engineState[b1];
      switch (b1 & 0x3) {
        case 0:
          this.a ^= this.a << 13;
          break;
        case 1:
          this.a ^= this.a >>> 6;
          break;
        case 2:
          this.a ^= this.a << 2;
          break;
        case 3:
          this.a ^= this.a >>> 16;
          break;
      } 
      this.a += this.engineState[b1 + '' & 0xFF];
      int j = this.engineState[i >>> 2 & 0xFF] + this.a + this.b;
      this.engineState[b1] = j;
      this.results[b1] = this.b = this.engineState[j >>> 10 & 0xFF] + i;
    } 
  }
  
  private void mix(int[] paramArrayOfInt) {
    paramArrayOfInt[0] = paramArrayOfInt[0] ^ paramArrayOfInt[1] << 11;
    paramArrayOfInt[3] = paramArrayOfInt[3] + paramArrayOfInt[0];
    paramArrayOfInt[1] = paramArrayOfInt[1] + paramArrayOfInt[2];
    paramArrayOfInt[1] = paramArrayOfInt[1] ^ paramArrayOfInt[2] >>> 2;
    paramArrayOfInt[4] = paramArrayOfInt[4] + paramArrayOfInt[1];
    paramArrayOfInt[2] = paramArrayOfInt[2] + paramArrayOfInt[3];
    paramArrayOfInt[2] = paramArrayOfInt[2] ^ paramArrayOfInt[3] << 8;
    paramArrayOfInt[5] = paramArrayOfInt[5] + paramArrayOfInt[2];
    paramArrayOfInt[3] = paramArrayOfInt[3] + paramArrayOfInt[4];
    paramArrayOfInt[3] = paramArrayOfInt[3] ^ paramArrayOfInt[4] >>> 16;
    paramArrayOfInt[6] = paramArrayOfInt[6] + paramArrayOfInt[3];
    paramArrayOfInt[4] = paramArrayOfInt[4] + paramArrayOfInt[5];
    paramArrayOfInt[4] = paramArrayOfInt[4] ^ paramArrayOfInt[5] << 10;
    paramArrayOfInt[7] = paramArrayOfInt[7] + paramArrayOfInt[4];
    paramArrayOfInt[5] = paramArrayOfInt[5] + paramArrayOfInt[6];
    paramArrayOfInt[5] = paramArrayOfInt[5] ^ paramArrayOfInt[6] >>> 4;
    paramArrayOfInt[0] = paramArrayOfInt[0] + paramArrayOfInt[5];
    paramArrayOfInt[6] = paramArrayOfInt[6] + paramArrayOfInt[7];
    paramArrayOfInt[6] = paramArrayOfInt[6] ^ paramArrayOfInt[7] << 8;
    paramArrayOfInt[1] = paramArrayOfInt[1] + paramArrayOfInt[6];
    paramArrayOfInt[7] = paramArrayOfInt[7] + paramArrayOfInt[0];
    paramArrayOfInt[7] = paramArrayOfInt[7] ^ paramArrayOfInt[0] >>> 9;
    paramArrayOfInt[2] = paramArrayOfInt[2] + paramArrayOfInt[7];
    paramArrayOfInt[0] = paramArrayOfInt[0] + paramArrayOfInt[1];
  }
}
