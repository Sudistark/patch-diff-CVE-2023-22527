package org.bouncycastle.crypto.engines;

import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.OutputLengthException;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.util.Integers;
import org.bouncycastle.util.Pack;

public class NoekeonEngine implements BlockCipher {
  private static final int SIZE = 16;
  
  private static final byte[] roundConstants = { 
      Byte.MIN_VALUE, 27, 54, 108, -40, -85, 77, -102, 47, 94, 
      -68, 99, -58, -105, 53, 106, -44 };
  
  private final int[] k = new int[4];
  
  private boolean _initialised = false;
  
  private boolean _forEncryption;
  
  public String getAlgorithmName() { return "Noekeon"; }
  
  public int getBlockSize() { return 16; }
  
  public void init(boolean paramBoolean, CipherParameters paramCipherParameters) {
    if (!(paramCipherParameters instanceof KeyParameter))
      throw new IllegalArgumentException("invalid parameter passed to Noekeon init - " + paramCipherParameters.getClass().getName()); 
    KeyParameter keyParameter = (KeyParameter)paramCipherParameters;
    byte[] arrayOfByte = keyParameter.getKey();
    if (arrayOfByte.length != 16)
      throw new IllegalArgumentException("Key length not 128 bits."); 
    Pack.bigEndianToInt(arrayOfByte, 0, this.k, 0, 4);
    if (!paramBoolean) {
      int i = this.k[0];
      int j = this.k[1];
      int m = this.k[2];
      int n = this.k[3];
      int i1 = i ^ m;
      i1 ^= Integers.rotateLeft(i1, 8) ^ Integers.rotateLeft(i1, 24);
      int i2 = j ^ n;
      i2 ^= Integers.rotateLeft(i2, 8) ^ Integers.rotateLeft(i2, 24);
      i ^= i2;
      j ^= i1;
      m ^= i2;
      n ^= i1;
      this.k[0] = i;
      this.k[1] = j;
      this.k[2] = m;
      this.k[3] = n;
    } 
    this._forEncryption = paramBoolean;
    this._initialised = true;
  }
  
  public int processBlock(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2) {
    if (!this._initialised)
      throw new IllegalStateException(getAlgorithmName() + " not initialised"); 
    if (paramInt1 > paramArrayOfByte1.length - 16)
      throw new DataLengthException("input buffer too short"); 
    if (paramInt2 > paramArrayOfByte2.length - 16)
      throw new OutputLengthException("output buffer too short"); 
    return this._forEncryption ? encryptBlock(paramArrayOfByte1, paramInt1, paramArrayOfByte2, paramInt2) : decryptBlock(paramArrayOfByte1, paramInt1, paramArrayOfByte2, paramInt2);
  }
  
  public void reset() {}
  
  private int encryptBlock(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2) {
    int i = Pack.bigEndianToInt(paramArrayOfByte1, paramInt1);
    int j = Pack.bigEndianToInt(paramArrayOfByte1, paramInt1 + 4);
    int m = Pack.bigEndianToInt(paramArrayOfByte1, paramInt1 + 8);
    int n = Pack.bigEndianToInt(paramArrayOfByte1, paramInt1 + 12);
    int i1 = this.k[0];
    int i2 = this.k[1];
    int i3 = this.k[2];
    int i4 = this.k[3];
    byte b = 0;
    while (true) {
      i ^= roundConstants[b] & 0xFF;
      int i5 = i ^ m;
      i5 ^= Integers.rotateLeft(i5, 8) ^ Integers.rotateLeft(i5, 24);
      i ^= i1;
      j ^= i2;
      m ^= i3;
      n ^= i4;
      int i6 = j ^ n;
      i6 ^= Integers.rotateLeft(i6, 8) ^ Integers.rotateLeft(i6, 24);
      i ^= i6;
      j ^= i5;
      m ^= i6;
      n ^= i5;
      if (++b > 16)
        break; 
      j = Integers.rotateLeft(j, 1);
      m = Integers.rotateLeft(m, 5);
      n = Integers.rotateLeft(n, 2);
      i5 = n;
      j ^= (n | m);
      n = i ^ m & (j ^ 0xFFFFFFFF);
      m = i5 ^ j ^ 0xFFFFFFFF ^ m ^ n;
      j ^= (n | m);
      i = i5 ^ m & j;
      j = Integers.rotateLeft(j, 31);
      m = Integers.rotateLeft(m, 27);
      n = Integers.rotateLeft(n, 30);
    } 
    Pack.intToBigEndian(i, paramArrayOfByte2, paramInt2);
    Pack.intToBigEndian(j, paramArrayOfByte2, paramInt2 + 4);
    Pack.intToBigEndian(m, paramArrayOfByte2, paramInt2 + 8);
    Pack.intToBigEndian(n, paramArrayOfByte2, paramInt2 + 12);
    return 16;
  }
  
  private int decryptBlock(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2) {
    int i = Pack.bigEndianToInt(paramArrayOfByte1, paramInt1);
    int j = Pack.bigEndianToInt(paramArrayOfByte1, paramInt1 + 4);
    int m = Pack.bigEndianToInt(paramArrayOfByte1, paramInt1 + 8);
    int n = Pack.bigEndianToInt(paramArrayOfByte1, paramInt1 + 12);
    int i1 = this.k[0];
    int i2 = this.k[1];
    int i3 = this.k[2];
    int i4 = this.k[3];
    byte b = 16;
    while (true) {
      int i5 = i ^ m;
      i5 ^= Integers.rotateLeft(i5, 8) ^ Integers.rotateLeft(i5, 24);
      i ^= i1;
      j ^= i2;
      m ^= i3;
      n ^= i4;
      int i6 = j ^ n;
      i6 ^= Integers.rotateLeft(i6, 8) ^ Integers.rotateLeft(i6, 24);
      i ^= i6;
      j ^= i5;
      m ^= i6;
      n ^= i5;
      i ^= roundConstants[b] & 0xFF;
      if (--b < 0)
        break; 
      j = Integers.rotateLeft(j, 1);
      m = Integers.rotateLeft(m, 5);
      n = Integers.rotateLeft(n, 2);
      i5 = n;
      j ^= (n | m);
      n = i ^ m & (j ^ 0xFFFFFFFF);
      m = i5 ^ j ^ 0xFFFFFFFF ^ m ^ n;
      j ^= (n | m);
      i = i5 ^ m & j;
      j = Integers.rotateLeft(j, 31);
      m = Integers.rotateLeft(m, 27);
      n = Integers.rotateLeft(n, 30);
    } 
    Pack.intToBigEndian(i, paramArrayOfByte2, paramInt2);
    Pack.intToBigEndian(j, paramArrayOfByte2, paramInt2 + 4);
    Pack.intToBigEndian(m, paramArrayOfByte2, paramInt2 + 8);
    Pack.intToBigEndian(n, paramArrayOfByte2, paramInt2 + 12);
    return 16;
  }
}
