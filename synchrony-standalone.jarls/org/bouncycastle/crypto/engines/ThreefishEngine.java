package org.bouncycastle.crypto.engines;

import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.OutputLengthException;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.TweakableBlockCipherParameters;

public class ThreefishEngine implements BlockCipher {
  public static final int BLOCKSIZE_256 = 256;
  
  public static final int BLOCKSIZE_512 = 512;
  
  public static final int BLOCKSIZE_1024 = 1024;
  
  private static final int TWEAK_SIZE_BYTES = 16;
  
  private static final int TWEAK_SIZE_WORDS = 2;
  
  private static final int ROUNDS_256 = 72;
  
  private static final int ROUNDS_512 = 72;
  
  private static final int ROUNDS_1024 = 80;
  
  private static final int MAX_ROUNDS = 80;
  
  private static final long C_240 = 2004413935125273122L;
  
  private static int[] MOD9 = new int[80];
  
  private static int[] MOD17 = new int[MOD9.length];
  
  private static int[] MOD5 = new int[MOD9.length];
  
  private static int[] MOD3 = new int[MOD9.length];
  
  private int blocksizeBytes;
  
  private int blocksizeWords;
  
  private long[] currentBlock;
  
  private long[] t = new long[5];
  
  private long[] kw;
  
  private ThreefishCipher cipher;
  
  private boolean forEncryption;
  
  public ThreefishEngine(int paramInt) {
    this.blocksizeBytes = paramInt / 8;
    this.blocksizeWords = this.blocksizeBytes / 8;
    this.currentBlock = new long[this.blocksizeWords];
    this.kw = new long[2 * this.blocksizeWords + 1];
    switch (paramInt) {
      case 256:
        this.cipher = new Threefish256Cipher(this.kw, this.t);
        return;
      case 512:
        this.cipher = new Threefish512Cipher(this.kw, this.t);
        return;
      case 1024:
        this.cipher = new Threefish1024Cipher(this.kw, this.t);
        return;
    } 
    throw new IllegalArgumentException("Invalid blocksize - Threefish is defined with block size of 256, 512, or 1024 bits");
  }
  
  public void init(boolean paramBoolean, CipherParameters paramCipherParameters) throws IllegalArgumentException {
    byte[] arrayOfByte2;
    byte[] arrayOfByte1;
    if (paramCipherParameters instanceof TweakableBlockCipherParameters) {
      TweakableBlockCipherParameters tweakableBlockCipherParameters = (TweakableBlockCipherParameters)paramCipherParameters;
      arrayOfByte1 = tweakableBlockCipherParameters.getKey().getKey();
      arrayOfByte2 = tweakableBlockCipherParameters.getTweak();
    } else if (paramCipherParameters instanceof KeyParameter) {
      arrayOfByte1 = ((KeyParameter)paramCipherParameters).getKey();
      arrayOfByte2 = null;
    } else {
      throw new IllegalArgumentException("Invalid parameter passed to Threefish init - " + paramCipherParameters.getClass().getName());
    } 
    long[] arrayOfLong1 = null;
    long[] arrayOfLong2 = null;
    if (arrayOfByte1 != null) {
      if (arrayOfByte1.length != this.blocksizeBytes)
        throw new IllegalArgumentException("Threefish key must be same size as block (" + this.blocksizeBytes + " bytes)"); 
      arrayOfLong1 = new long[this.blocksizeWords];
      for (byte b = 0; b < arrayOfLong1.length; b++)
        arrayOfLong1[b] = bytesToWord(arrayOfByte1, b * 8); 
    } 
    if (arrayOfByte2 != null) {
      if (arrayOfByte2.length != 16)
        throw new IllegalArgumentException("Threefish tweak must be 16 bytes"); 
      arrayOfLong2 = new long[] { bytesToWord(arrayOfByte2, 0), bytesToWord(arrayOfByte2, 8) };
    } 
    init(paramBoolean, arrayOfLong1, arrayOfLong2);
  }
  
  public void init(boolean paramBoolean, long[] paramArrayOfLong1, long[] paramArrayOfLong2) {
    this.forEncryption = paramBoolean;
    if (paramArrayOfLong1 != null)
      setKey(paramArrayOfLong1); 
    if (paramArrayOfLong2 != null)
      setTweak(paramArrayOfLong2); 
  }
  
  private void setKey(long[] paramArrayOfLong) {
    if (paramArrayOfLong.length != this.blocksizeWords)
      throw new IllegalArgumentException("Threefish key must be same size as block (" + this.blocksizeWords + " words)"); 
    long l = 2004413935125273122L;
    for (byte b = 0; b < this.blocksizeWords; b++) {
      this.kw[b] = paramArrayOfLong[b];
      l ^= this.kw[b];
    } 
    this.kw[this.blocksizeWords] = l;
    System.arraycopy(this.kw, 0, this.kw, this.blocksizeWords + 1, this.blocksizeWords);
  }
  
  private void setTweak(long[] paramArrayOfLong) {
    if (paramArrayOfLong.length != 2)
      throw new IllegalArgumentException("Tweak must be 2 words."); 
    this.t[0] = paramArrayOfLong[0];
    this.t[1] = paramArrayOfLong[1];
    this.t[2] = this.t[0] ^ this.t[1];
    this.t[3] = this.t[0];
    this.t[4] = this.t[1];
  }
  
  public String getAlgorithmName() { return "Threefish-" + (this.blocksizeBytes * 8); }
  
  public int getBlockSize() { return this.blocksizeBytes; }
  
  public void reset() {}
  
  public int processBlock(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2) throws DataLengthException, IllegalStateException {
    if (paramInt1 + this.blocksizeBytes > paramArrayOfByte1.length)
      throw new DataLengthException("Input buffer too short"); 
    if (paramInt2 + this.blocksizeBytes > paramArrayOfByte2.length)
      throw new OutputLengthException("Output buffer too short"); 
    int i;
    for (i = 0; i < this.blocksizeBytes; i += 8)
      this.currentBlock[i >> 3] = bytesToWord(paramArrayOfByte1, paramInt1 + i); 
    processBlock(this.currentBlock, this.currentBlock);
    for (i = 0; i < this.blocksizeBytes; i += 8)
      wordToBytes(this.currentBlock[i >> 3], paramArrayOfByte2, paramInt2 + i); 
    return this.blocksizeBytes;
  }
  
  public int processBlock(long[] paramArrayOfLong1, long[] paramArrayOfLong2) throws DataLengthException, IllegalStateException {
    if (this.kw[this.blocksizeWords] == 0L)
      throw new IllegalStateException("Threefish engine not initialised"); 
    if (paramArrayOfLong1.length != this.blocksizeWords)
      throw new DataLengthException("Input buffer too short"); 
    if (paramArrayOfLong2.length != this.blocksizeWords)
      throw new OutputLengthException("Output buffer too short"); 
    if (this.forEncryption) {
      this.cipher.encryptBlock(paramArrayOfLong1, paramArrayOfLong2);
    } else {
      this.cipher.decryptBlock(paramArrayOfLong1, paramArrayOfLong2);
    } 
    return this.blocksizeWords;
  }
  
  public static long bytesToWord(byte[] paramArrayOfByte, int paramInt) {
    if (paramInt + 8 > paramArrayOfByte.length)
      throw new IllegalArgumentException(); 
    null = 0L;
    int i = paramInt;
    null = paramArrayOfByte[i++] & 0xFFL;
    null |= (paramArrayOfByte[i++] & 0xFFL) << 8;
    null |= (paramArrayOfByte[i++] & 0xFFL) << 16;
    null |= (paramArrayOfByte[i++] & 0xFFL) << 24;
    null |= (paramArrayOfByte[i++] & 0xFFL) << 32;
    null |= (paramArrayOfByte[i++] & 0xFFL) << 40;
    null |= (paramArrayOfByte[i++] & 0xFFL) << 48;
    return (paramArrayOfByte[i++] & 0xFFL) << 56;
  }
  
  public static void wordToBytes(long paramLong, byte[] paramArrayOfByte, int paramInt) {
    if (paramInt + 8 > paramArrayOfByte.length)
      throw new IllegalArgumentException(); 
    int i = paramInt;
    paramArrayOfByte[i++] = (byte)(int)paramLong;
    paramArrayOfByte[i++] = (byte)(int)(paramLong >> 8);
    paramArrayOfByte[i++] = (byte)(int)(paramLong >> 16);
    paramArrayOfByte[i++] = (byte)(int)(paramLong >> 24);
    paramArrayOfByte[i++] = (byte)(int)(paramLong >> 32);
    paramArrayOfByte[i++] = (byte)(int)(paramLong >> 40);
    paramArrayOfByte[i++] = (byte)(int)(paramLong >> 48);
    paramArrayOfByte[i++] = (byte)(int)(paramLong >> 56);
  }
  
  static long rotlXor(long paramLong1, int paramInt, long paramLong2) { return (paramLong1 << paramInt | paramLong1 >>> -paramInt) ^ paramLong2; }
  
  static long xorRotr(long paramLong1, int paramInt, long paramLong2) {
    long l = paramLong1 ^ paramLong2;
    return l >>> paramInt | l << -paramInt;
  }
  
  static  {
    for (byte b = 0; b < MOD9.length; b++) {
      MOD17[b] = b % 17;
      MOD9[b] = b % 9;
      MOD5[b] = b % 5;
      MOD3[b] = b % 3;
    } 
  }
}
