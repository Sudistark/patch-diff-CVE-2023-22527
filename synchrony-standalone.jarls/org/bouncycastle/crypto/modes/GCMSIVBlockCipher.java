package org.bouncycastle.crypto.modes;

import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.crypto.OutputLengthException;
import org.bouncycastle.crypto.engines.AESEngine;
import org.bouncycastle.crypto.modes.gcm.GCMMultiplier;
import org.bouncycastle.crypto.modes.gcm.Tables4kGCMMultiplier;
import org.bouncycastle.crypto.params.AEADParameters;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.ParametersWithIV;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Pack;

public class GCMSIVBlockCipher implements AEADBlockCipher {
  private static final int BUFLEN = 16;
  
  private static final int HALFBUFLEN = 8;
  
  private static final int NONCELEN = 12;
  
  private static final int MAX_DATALEN = 2147483623;
  
  private static final byte MASK = -128;
  
  private static final byte ADD = -31;
  
  private static final int INIT = 1;
  
  private static final int AEAD_COMPLETE = 2;
  
  private final BlockCipher theCipher;
  
  private final GCMMultiplier theMultiplier;
  
  private final byte[] theGHash = new byte[16];
  
  private final byte[] theReverse = new byte[16];
  
  private final GCMSIVHasher theAEADHasher;
  
  private final GCMSIVHasher theDataHasher;
  
  private GCMSIVCache thePlain;
  
  private GCMSIVCache theEncData;
  
  private boolean forEncryption;
  
  private byte[] theInitialAEAD;
  
  private byte[] theNonce;
  
  private int theFlags;
  
  private byte[] macBlock = new byte[16];
  
  public GCMSIVBlockCipher() { this(new AESEngine()); }
  
  public GCMSIVBlockCipher(BlockCipher paramBlockCipher) { this(paramBlockCipher, new Tables4kGCMMultiplier()); }
  
  public GCMSIVBlockCipher(BlockCipher paramBlockCipher, GCMMultiplier paramGCMMultiplier) {
    if (paramBlockCipher.getBlockSize() != 16)
      throw new IllegalArgumentException("Cipher required with a block size of 16."); 
    this.theCipher = paramBlockCipher;
    this.theMultiplier = paramGCMMultiplier;
    this.theAEADHasher = new GCMSIVHasher(this, null);
    this.theDataHasher = new GCMSIVHasher(this, null);
  }
  
  public BlockCipher getUnderlyingCipher() { return this.theCipher; }
  
  public void init(boolean paramBoolean, CipherParameters paramCipherParameters) throws IllegalArgumentException {
    byte[] arrayOfByte1 = null;
    byte[] arrayOfByte2 = null;
    KeyParameter keyParameter = null;
    if (paramCipherParameters instanceof AEADParameters) {
      AEADParameters aEADParameters = (AEADParameters)paramCipherParameters;
      arrayOfByte1 = aEADParameters.getAssociatedText();
      arrayOfByte2 = aEADParameters.getNonce();
      keyParameter = aEADParameters.getKey();
    } else if (paramCipherParameters instanceof ParametersWithIV) {
      ParametersWithIV parametersWithIV = (ParametersWithIV)paramCipherParameters;
      arrayOfByte2 = parametersWithIV.getIV();
      keyParameter = (KeyParameter)parametersWithIV.getParameters();
    } else {
      throw new IllegalArgumentException("invalid parameters passed to GCM-SIV");
    } 
    if (arrayOfByte2 == null || arrayOfByte2.length != 12)
      throw new IllegalArgumentException("Invalid nonce"); 
    if (keyParameter == null || (keyParameter.getKey().length != 16 && keyParameter.getKey().length != 32))
      throw new IllegalArgumentException("Invalid key"); 
    this.forEncryption = paramBoolean;
    this.theInitialAEAD = arrayOfByte1;
    this.theNonce = arrayOfByte2;
    deriveKeys(keyParameter);
    resetStreams();
  }
  
  public String getAlgorithmName() { return this.theCipher.getAlgorithmName() + "-GCM-SIV"; }
  
  private void checkAEADStatus(int paramInt) {
    if ((this.theFlags & true) == 0)
      throw new IllegalStateException("Cipher is not initialised"); 
    if ((this.theFlags & 0x2) != 0)
      throw new IllegalStateException("AEAD data cannot be processed after ordinary data"); 
    if (this.theAEADHasher.getBytesProcessed() + Float.MIN_VALUE > (2147483623 - paramInt) + Float.MIN_VALUE)
      throw new IllegalStateException("AEAD byte count exceeded"); 
  }
  
  private void checkStatus(int paramInt) {
    if ((this.theFlags & true) == 0)
      throw new IllegalStateException("Cipher is not initialised"); 
    if ((this.theFlags & 0x2) == 0) {
      this.theAEADHasher.completeHash();
      this.theFlags |= 0x2;
    } 
    long l1 = 2147483623L;
    long l2 = this.thePlain.size();
    if (!this.forEncryption) {
      l1 += 16L;
      l2 = this.theEncData.size();
    } 
    if (l2 + Float.MIN_VALUE > l1 - paramInt + Float.MIN_VALUE)
      throw new IllegalStateException("byte count exceeded"); 
  }
  
  public void processAADByte(byte paramByte) {
    checkAEADStatus(1);
    this.theAEADHasher.updateHash(paramByte);
  }
  
  public void processAADBytes(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    checkAEADStatus(paramInt2);
    checkBuffer(paramArrayOfByte, paramInt1, paramInt2, false);
    this.theAEADHasher.updateHash(paramArrayOfByte, paramInt1, paramInt2);
  }
  
  public int processByte(byte paramByte, byte[] paramArrayOfByte, int paramInt) throws DataLengthException {
    checkStatus(1);
    if (this.forEncryption) {
      this.thePlain.write(paramByte);
      this.theDataHasher.updateHash(paramByte);
    } else {
      this.theEncData.write(paramByte);
    } 
    return 0;
  }
  
  public int processBytes(byte[] paramArrayOfByte1, int paramInt1, int paramInt2, byte[] paramArrayOfByte2, int paramInt3) throws DataLengthException {
    checkStatus(paramInt2);
    checkBuffer(paramArrayOfByte1, paramInt1, paramInt2, false);
    if (this.forEncryption) {
      this.thePlain.write(paramArrayOfByte1, paramInt1, paramInt2);
      this.theDataHasher.updateHash(paramArrayOfByte1, paramInt1, paramInt2);
    } else {
      this.theEncData.write(paramArrayOfByte1, paramInt1, paramInt2);
    } 
    return 0;
  }
  
  public int doFinal(byte[] paramArrayOfByte, int paramInt) throws IllegalStateException, InvalidCipherTextException {
    checkStatus(0);
    checkBuffer(paramArrayOfByte, paramInt, getOutputSize(0), true);
    if (this.forEncryption) {
      byte[] arrayOfByte1 = calculateTag();
      int j = 16 + encryptPlain(arrayOfByte1, paramArrayOfByte, paramInt);
      System.arraycopy(arrayOfByte1, 0, paramArrayOfByte, paramInt + this.thePlain.size(), 16);
      System.arraycopy(arrayOfByte1, 0, this.macBlock, 0, this.macBlock.length);
      resetStreams();
      return j;
    } 
    decryptPlain();
    int i = this.thePlain.size();
    byte[] arrayOfByte = this.thePlain.getBuffer();
    System.arraycopy(arrayOfByte, 0, paramArrayOfByte, paramInt, i);
    resetStreams();
    return i;
  }
  
  public byte[] getMac() { return Arrays.clone(this.macBlock); }
  
  public int getUpdateOutputSize(int paramInt) { return 0; }
  
  public int getOutputSize(int paramInt) {
    if (this.forEncryption)
      return paramInt + this.thePlain.size() + 16; 
    int i = paramInt + this.theEncData.size();
    return (i > 16) ? (i - 16) : 0;
  }
  
  public void reset() { resetStreams(); }
  
  private void resetStreams() {
    if (this.thePlain != null)
      this.thePlain.clearBuffer(); 
    this.theAEADHasher.reset();
    this.theDataHasher.reset();
    this.thePlain = new GCMSIVCache();
    this.theEncData = this.forEncryption ? null : new GCMSIVCache();
    this.theFlags &= 0xFFFFFFFD;
    Arrays.fill(this.theGHash, (byte)0);
    if (this.theInitialAEAD != null)
      this.theAEADHasher.updateHash(this.theInitialAEAD, 0, this.theInitialAEAD.length); 
  }
  
  private static int bufLength(byte[] paramArrayOfByte) { return (paramArrayOfByte == null) ? 0 : paramArrayOfByte.length; }
  
  private static void checkBuffer(byte[] paramArrayOfByte, int paramInt1, int paramInt2, boolean paramBoolean) {
    int i = bufLength(paramArrayOfByte);
    int j = paramInt1 + paramInt2;
    boolean bool = (paramInt2 < 0 || paramInt1 < 0 || j < 0) ? 1 : 0;
    if (bool || j > i)
      throw paramBoolean ? new OutputLengthException("Output buffer too short.") : new DataLengthException("Input buffer too short."); 
  }
  
  private int encryptPlain(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt) {
    byte[] arrayOfByte1 = this.thePlain.getBuffer();
    byte[] arrayOfByte2 = Arrays.clone(paramArrayOfByte1);
    arrayOfByte2[15] = (byte)(arrayOfByte2[15] | 0xFFFFFF80);
    byte[] arrayOfByte3 = new byte[16];
    int i = this.thePlain.size();
    int j = 0;
    while (i > 0) {
      this.theCipher.processBlock(arrayOfByte2, 0, arrayOfByte3, 0);
      int k = Math.min(16, i);
      xorBlock(arrayOfByte3, arrayOfByte1, j, k);
      System.arraycopy(arrayOfByte3, 0, paramArrayOfByte2, paramInt + j, k);
      i -= k;
      j += k;
      incrementCounter(arrayOfByte2);
    } 
    return this.thePlain.size();
  }
  
  private void decryptPlain() {
    byte[] arrayOfByte1 = this.theEncData.getBuffer();
    int i = this.theEncData.size() - 16;
    if (i < 0)
      throw new InvalidCipherTextException("Data too short"); 
    byte[] arrayOfByte2 = Arrays.copyOfRange(arrayOfByte1, i, i + 16);
    byte[] arrayOfByte3 = Arrays.clone(arrayOfByte2);
    arrayOfByte3[15] = (byte)(arrayOfByte3[15] | 0xFFFFFF80);
    byte[] arrayOfByte4 = new byte[16];
    int j = 0;
    while (i > 0) {
      this.theCipher.processBlock(arrayOfByte3, 0, arrayOfByte4, 0);
      int k = Math.min(16, i);
      xorBlock(arrayOfByte4, arrayOfByte1, j, k);
      this.thePlain.write(arrayOfByte4, 0, k);
      this.theDataHasher.updateHash(arrayOfByte4, 0, k);
      i -= k;
      j += k;
      incrementCounter(arrayOfByte3);
    } 
    byte[] arrayOfByte5 = calculateTag();
    if (!Arrays.constantTimeAreEqual(arrayOfByte5, arrayOfByte2)) {
      reset();
      throw new InvalidCipherTextException("mac check failed");
    } 
    System.arraycopy(arrayOfByte5, 0, this.macBlock, 0, this.macBlock.length);
  }
  
  private byte[] calculateTag() {
    this.theDataHasher.completeHash();
    byte[] arrayOfByte1 = completePolyVal();
    byte[] arrayOfByte2 = new byte[16];
    for (byte b = 0; b < 12; b++)
      arrayOfByte1[b] = (byte)(arrayOfByte1[b] ^ this.theNonce[b]); 
    arrayOfByte1[15] = (byte)(arrayOfByte1[15] & 0xFFFFFF7F);
    this.theCipher.processBlock(arrayOfByte1, 0, arrayOfByte2, 0);
    return arrayOfByte2;
  }
  
  private byte[] completePolyVal() {
    byte[] arrayOfByte = new byte[16];
    gHashLengths();
    fillReverse(this.theGHash, 0, 16, arrayOfByte);
    return arrayOfByte;
  }
  
  private void gHashLengths() {
    byte[] arrayOfByte = new byte[16];
    Pack.longToBigEndian(8L * this.theDataHasher.getBytesProcessed(), arrayOfByte, 0);
    Pack.longToBigEndian(8L * this.theAEADHasher.getBytesProcessed(), arrayOfByte, 8);
    gHASH(arrayOfByte);
  }
  
  private void gHASH(byte[] paramArrayOfByte) {
    xorBlock(this.theGHash, paramArrayOfByte);
    this.theMultiplier.multiplyH(this.theGHash);
  }
  
  private static void fillReverse(byte[] paramArrayOfByte1, int paramInt1, int paramInt2, byte[] paramArrayOfByte2) {
    int i = 0;
    for (byte b = 15; i < paramInt2; b--) {
      paramArrayOfByte2[b] = paramArrayOfByte1[paramInt1 + i];
      i++;
    } 
  }
  
  private static void xorBlock(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2) {
    for (byte b = 0; b < 16; b++)
      paramArrayOfByte1[b] = (byte)(paramArrayOfByte1[b] ^ paramArrayOfByte2[b]); 
  }
  
  private static void xorBlock(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt1, int paramInt2) {
    for (int i = 0; i < paramInt2; i++)
      paramArrayOfByte1[i] = (byte)(paramArrayOfByte1[i] ^ paramArrayOfByte2[i + paramInt1]); 
  }
  
  private static void incrementCounter(byte[] paramArrayOfByte) {
    byte b = 0;
    paramArrayOfByte[b] = (byte)(paramArrayOfByte[b] + 1);
    while (b < 4 && (byte)(paramArrayOfByte[b] + 1) == 0)
      b++; 
  }
  
  private static void mulX(byte[] paramArrayOfByte) {
    byte b = 0;
    for (byte b1 = 0; b1 < 16; b1++) {
      byte b2 = paramArrayOfByte[b1];
      paramArrayOfByte[b1] = (byte)(b2 >> 1 & 0x7F | b);
      b = ((b2 & true) == 0) ? 0 : -128;
    } 
    if (b != 0)
      paramArrayOfByte[0] = (byte)(paramArrayOfByte[0] ^ 0xFFFFFFE1); 
  }
  
  private void deriveKeys(KeyParameter paramKeyParameter) {
    byte[] arrayOfByte1 = new byte[16];
    byte[] arrayOfByte2 = new byte[16];
    byte[] arrayOfByte3 = new byte[16];
    byte[] arrayOfByte4 = new byte[paramKeyParameter.getKey().length];
    System.arraycopy(this.theNonce, 0, arrayOfByte1, 4, 12);
    this.theCipher.init(true, paramKeyParameter);
    byte b = 0;
    this.theCipher.processBlock(arrayOfByte1, 0, arrayOfByte2, 0);
    System.arraycopy(arrayOfByte2, 0, arrayOfByte3, b, 8);
    arrayOfByte1[0] = (byte)(arrayOfByte1[0] + 1);
    b += 8;
    this.theCipher.processBlock(arrayOfByte1, 0, arrayOfByte2, 0);
    System.arraycopy(arrayOfByte2, 0, arrayOfByte3, b, 8);
    arrayOfByte1[0] = (byte)(arrayOfByte1[0] + 1);
    b = 0;
    this.theCipher.processBlock(arrayOfByte1, 0, arrayOfByte2, 0);
    System.arraycopy(arrayOfByte2, 0, arrayOfByte4, b, 8);
    arrayOfByte1[0] = (byte)(arrayOfByte1[0] + 1);
    b += 8;
    this.theCipher.processBlock(arrayOfByte1, 0, arrayOfByte2, 0);
    System.arraycopy(arrayOfByte2, 0, arrayOfByte4, b, 8);
    if (arrayOfByte4.length == 32) {
      arrayOfByte1[0] = (byte)(arrayOfByte1[0] + 1);
      b += 8;
      this.theCipher.processBlock(arrayOfByte1, 0, arrayOfByte2, 0);
      System.arraycopy(arrayOfByte2, 0, arrayOfByte4, b, 8);
      arrayOfByte1[0] = (byte)(arrayOfByte1[0] + 1);
      b += 8;
      this.theCipher.processBlock(arrayOfByte1, 0, arrayOfByte2, 0);
      System.arraycopy(arrayOfByte2, 0, arrayOfByte4, b, 8);
    } 
    this.theCipher.init(true, new KeyParameter(arrayOfByte4));
    fillReverse(arrayOfByte3, 0, 16, arrayOfByte2);
    mulX(arrayOfByte2);
    this.theMultiplier.init(arrayOfByte2);
    this.theFlags |= 0x1;
  }
}
