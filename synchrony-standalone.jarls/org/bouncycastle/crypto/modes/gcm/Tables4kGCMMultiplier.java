package org.bouncycastle.crypto.modes.gcm;

import org.bouncycastle.util.Pack;

public class Tables4kGCMMultiplier implements GCMMultiplier {
  private byte[] H;
  
  private long[][] T;
  
  public void init(byte[] paramArrayOfByte) {
    if (this.T == null) {
      this.T = new long[256][2];
    } else if (0 != GCMUtil.areEqual(this.H, paramArrayOfByte)) {
      return;
    } 
    this.H = new byte[16];
    GCMUtil.copy(paramArrayOfByte, this.H);
    GCMUtil.asLongs(this.H, this.T[1]);
    GCMUtil.multiplyP7(this.T[1], this.T[1]);
    for (byte b = 2; b < 'Ä€'; b += 2) {
      GCMUtil.divideP(this.T[b >> 1], this.T[b]);
      GCMUtil.xor(this.T[b], this.T[1], this.T[b + 1]);
    } 
  }
  
  public void multiplyH(byte[] paramArrayOfByte) {
    long[] arrayOfLong = this.T[paramArrayOfByte[15] & 0xFF];
    long l1 = arrayOfLong[0];
    long l2 = arrayOfLong[1];
    for (byte b = 14; b >= 0; b--) {
      arrayOfLong = this.T[paramArrayOfByte[b] & 0xFF];
      long l = l2 << 56;
      l2 = arrayOfLong[1] ^ (l2 >>> 8 | l1 << 56);
      l1 = arrayOfLong[0] ^ l1 >>> 8 ^ l ^ l >>> true ^ l >>> 2 ^ l >>> 7;
    } 
    Pack.longToBigEndian(l1, paramArrayOfByte, 0);
    Pack.longToBigEndian(l2, paramArrayOfByte, 8);
  }
}
