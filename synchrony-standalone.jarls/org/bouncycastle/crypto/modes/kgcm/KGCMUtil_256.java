package org.bouncycastle.crypto.modes.kgcm;

import org.bouncycastle.math.raw.Interleave;

public class KGCMUtil_256 {
  public static final int SIZE = 4;
  
  public static void add(long[] paramArrayOfLong1, long[] paramArrayOfLong2, long[] paramArrayOfLong3) {
    paramArrayOfLong3[0] = paramArrayOfLong1[0] ^ paramArrayOfLong2[0];
    paramArrayOfLong3[1] = paramArrayOfLong1[1] ^ paramArrayOfLong2[1];
    paramArrayOfLong3[2] = paramArrayOfLong1[2] ^ paramArrayOfLong2[2];
    paramArrayOfLong3[3] = paramArrayOfLong1[3] ^ paramArrayOfLong2[3];
  }
  
  public static void copy(long[] paramArrayOfLong1, long[] paramArrayOfLong2) {
    paramArrayOfLong2[0] = paramArrayOfLong1[0];
    paramArrayOfLong2[1] = paramArrayOfLong1[1];
    paramArrayOfLong2[2] = paramArrayOfLong1[2];
    paramArrayOfLong2[3] = paramArrayOfLong1[3];
  }
  
  public static boolean equal(long[] paramArrayOfLong1, long[] paramArrayOfLong2) {
    long l = 0L;
    l |= paramArrayOfLong1[0] ^ paramArrayOfLong2[0];
    l |= paramArrayOfLong1[1] ^ paramArrayOfLong2[1];
    l |= paramArrayOfLong1[2] ^ paramArrayOfLong2[2];
    l |= paramArrayOfLong1[3] ^ paramArrayOfLong2[3];
    return (l == 0L);
  }
  
  public static void multiply(long[] paramArrayOfLong1, long[] paramArrayOfLong2, long[] paramArrayOfLong3) {
    long l1 = paramArrayOfLong1[0];
    long l2 = paramArrayOfLong1[1];
    long l3 = paramArrayOfLong1[2];
    long l4 = paramArrayOfLong1[3];
    long l5 = paramArrayOfLong2[0];
    long l6 = paramArrayOfLong2[1];
    long l7 = paramArrayOfLong2[2];
    long l8 = paramArrayOfLong2[3];
    long l9 = 0L;
    long l10 = 0L;
    long l11 = 0L;
    long l12 = 0L;
    long l13 = 0L;
    for (byte b1 = 0; b1 < 64; b1++) {
      long l15 = -(l1 & 0x1L);
      l1 >>>= true;
      l9 ^= l5 & l15;
      l10 ^= l6 & l15;
      l11 ^= l7 & l15;
      l12 ^= l8 & l15;
      long l16 = -(l2 & 0x1L);
      l2 >>>= true;
      l10 ^= l5 & l16;
      l11 ^= l6 & l16;
      l12 ^= l7 & l16;
      l13 ^= l8 & l16;
      long l17 = l8 >> 63;
      l8 = l8 << true | l7 >>> 63;
      l7 = l7 << true | l6 >>> 63;
      l6 = l6 << true | l5 >>> 63;
      l5 = l5 << true ^ l17 & 0x425L;
    } 
    long l14 = l8;
    l8 = l7;
    l7 = l6;
    l6 = l5 ^ l14 >>> 62 ^ l14 >>> 59 ^ l14 >>> 54;
    l5 = l14 ^ l14 << 2 ^ l14 << 5 ^ l14 << 10;
    for (byte b2 = 0; b2 < 64; b2++) {
      long l15 = -(l3 & 0x1L);
      l3 >>>= true;
      l9 ^= l5 & l15;
      l10 ^= l6 & l15;
      l11 ^= l7 & l15;
      l12 ^= l8 & l15;
      long l16 = -(l4 & 0x1L);
      l4 >>>= true;
      l10 ^= l5 & l16;
      l11 ^= l6 & l16;
      l12 ^= l7 & l16;
      l13 ^= l8 & l16;
      long l17 = l8 >> 63;
      l8 = l8 << true | l7 >>> 63;
      l7 = l7 << true | l6 >>> 63;
      l6 = l6 << true | l5 >>> 63;
      l5 = l5 << true ^ l17 & 0x425L;
    } 
    l9 ^= l13 ^ l13 << 2 ^ l13 << 5 ^ l13 << 10;
    l10 ^= l13 >>> 62 ^ l13 >>> 59 ^ l13 >>> 54;
    paramArrayOfLong3[0] = l9;
    paramArrayOfLong3[1] = l10;
    paramArrayOfLong3[2] = l11;
    paramArrayOfLong3[3] = l12;
  }
  
  public static void multiplyX(long[] paramArrayOfLong1, long[] paramArrayOfLong2) {
    long l1 = paramArrayOfLong1[0];
    long l2 = paramArrayOfLong1[1];
    long l3 = paramArrayOfLong1[2];
    long l4 = paramArrayOfLong1[3];
    long l5 = l4 >> 63;
    paramArrayOfLong2[0] = l1 << true ^ l5 & 0x425L;
    paramArrayOfLong2[1] = l2 << true | l1 >>> 63;
    paramArrayOfLong2[2] = l3 << true | l2 >>> 63;
    paramArrayOfLong2[3] = l4 << true | l3 >>> 63;
  }
  
  public static void multiplyX8(long[] paramArrayOfLong1, long[] paramArrayOfLong2) {
    long l1 = paramArrayOfLong1[0];
    long l2 = paramArrayOfLong1[1];
    long l3 = paramArrayOfLong1[2];
    long l4 = paramArrayOfLong1[3];
    long l5 = l4 >>> 56;
    paramArrayOfLong2[0] = l1 << 8 ^ l5 ^ l5 << 2 ^ l5 << 5 ^ l5 << 10;
    paramArrayOfLong2[1] = l2 << 8 | l1 >>> 56;
    paramArrayOfLong2[2] = l3 << 8 | l2 >>> 56;
    paramArrayOfLong2[3] = l4 << 8 | l3 >>> 56;
  }
  
  public static void one(long[] paramArrayOfLong) {
    paramArrayOfLong[0] = 1L;
    paramArrayOfLong[1] = 0L;
    paramArrayOfLong[2] = 0L;
    paramArrayOfLong[3] = 0L;
  }
  
  public static void square(long[] paramArrayOfLong1, long[] paramArrayOfLong2) {
    long[] arrayOfLong = new long[8];
    byte b;
    for (b = 0; b < 4; b++)
      Interleave.expand64To128(paramArrayOfLong1[b], arrayOfLong, b << true); 
    b = 8;
    while (--b >= 4) {
      long l = arrayOfLong[b];
      arrayOfLong[b - 4] = arrayOfLong[b - 4] ^ l ^ l << 2 ^ l << 5 ^ l << 10;
      arrayOfLong[b - 4 + 1] = arrayOfLong[b - 4 + 1] ^ l >>> 62 ^ l >>> 59 ^ l >>> 54;
    } 
    copy(arrayOfLong, paramArrayOfLong2);
  }
  
  public static void x(long[] paramArrayOfLong) {
    paramArrayOfLong[0] = 2L;
    paramArrayOfLong[1] = 0L;
    paramArrayOfLong[2] = 0L;
    paramArrayOfLong[3] = 0L;
  }
  
  public static void zero(long[] paramArrayOfLong) {
    paramArrayOfLong[0] = 0L;
    paramArrayOfLong[1] = 0L;
    paramArrayOfLong[2] = 0L;
    paramArrayOfLong[3] = 0L;
  }
}
