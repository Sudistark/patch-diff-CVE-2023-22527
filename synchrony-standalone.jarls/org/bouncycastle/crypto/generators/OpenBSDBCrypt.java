package org.bouncycastle.crypto.generators;

import java.io.ByteArrayOutputStream;
import java.util.HashSet;
import java.util.Set;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Strings;

public class OpenBSDBCrypt {
  private static final byte[] encodingTable = { 
      46, 47, 65, 66, 67, 68, 69, 70, 71, 72, 
      73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 
      83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 
      99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 
      109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 
      119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 
      54, 55, 56, 57 };
  
  private static final byte[] decodingTable = new byte[128];
  
  private static final String defaultVersion = "2y";
  
  private static final Set<String> allowedVersions = new HashSet();
  
  public static String generate(char[] paramArrayOfChar, byte[] paramArrayOfByte, int paramInt) { return generate("2y", paramArrayOfChar, paramArrayOfByte, paramInt); }
  
  public static String generate(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt) { return generate("2y", paramArrayOfByte1, paramArrayOfByte2, paramInt); }
  
  public static String generate(String paramString, char[] paramArrayOfChar, byte[] paramArrayOfByte, int paramInt) {
    if (paramArrayOfChar == null)
      throw new IllegalArgumentException("Password required."); 
    return doGenerate(paramString, Strings.toUTF8ByteArray(paramArrayOfChar), paramArrayOfByte, paramInt);
  }
  
  public static String generate(String paramString, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt) {
    if (paramArrayOfByte1 == null)
      throw new IllegalArgumentException("Password required."); 
    return doGenerate(paramString, Arrays.clone(paramArrayOfByte1), paramArrayOfByte2, paramInt);
  }
  
  private static String doGenerate(String paramString, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt) {
    if (!allowedVersions.contains(paramString))
      throw new IllegalArgumentException("Version " + paramString + " is not accepted by this implementation."); 
    if (paramArrayOfByte2 == null)
      throw new IllegalArgumentException("Salt required."); 
    if (paramArrayOfByte2.length != 16)
      throw new DataLengthException("16 byte salt required: " + paramArrayOfByte2.length); 
    if (paramInt < 4 || paramInt > 31)
      throw new IllegalArgumentException("Invalid cost factor."); 
    byte[] arrayOfByte = new byte[(paramArrayOfByte1.length >= 72) ? 72 : (paramArrayOfByte1.length + 1)];
    if (arrayOfByte.length > paramArrayOfByte1.length) {
      System.arraycopy(paramArrayOfByte1, 0, arrayOfByte, 0, paramArrayOfByte1.length);
    } else {
      System.arraycopy(paramArrayOfByte1, 0, arrayOfByte, 0, arrayOfByte.length);
    } 
    Arrays.fill(paramArrayOfByte1, (byte)0);
    String str = createBcryptString(paramString, arrayOfByte, paramArrayOfByte2, paramInt);
    Arrays.fill(arrayOfByte, (byte)0);
    return str;
  }
  
  public static boolean checkPassword(String paramString, char[] paramArrayOfChar) {
    if (paramArrayOfChar == null)
      throw new IllegalArgumentException("Missing password."); 
    return doCheckPassword(paramString, Strings.toUTF8ByteArray(paramArrayOfChar));
  }
  
  public static boolean checkPassword(String paramString, byte[] paramArrayOfByte) {
    if (paramArrayOfByte == null)
      throw new IllegalArgumentException("Missing password."); 
    return doCheckPassword(paramString, Arrays.clone(paramArrayOfByte));
  }
  
  private static boolean doCheckPassword(String paramString, byte[] paramArrayOfByte) {
    byte b;
    String str1;
    if (paramString == null)
      throw new IllegalArgumentException("Missing bcryptString."); 
    if (paramString.charAt(1) != '2')
      throw new IllegalArgumentException("not a Bcrypt string"); 
    int i = paramString.length();
    if (i != 60 && (i != 59 || paramString.charAt(2) != '$'))
      throw new DataLengthException("Bcrypt String length: " + i + ", 60 required."); 
    if (paramString.charAt(2) == '$') {
      if (paramString.charAt(0) != '$' || paramString.charAt(5) != '$')
        throw new IllegalArgumentException("Invalid Bcrypt String format."); 
    } else if (paramString.charAt(0) != '$' || paramString.charAt(3) != '$' || paramString.charAt(6) != '$') {
      throw new IllegalArgumentException("Invalid Bcrypt String format.");
    } 
    if (paramString.charAt(2) == '$') {
      str1 = paramString.substring(1, 2);
      b = 3;
    } else {
      str1 = paramString.substring(1, 3);
      b = 4;
    } 
    if (!allowedVersions.contains(str1))
      throw new IllegalArgumentException("Bcrypt version '" + str1 + "' is not supported by this implementation"); 
    int j = 0;
    String str2 = paramString.substring(b, b + 2);
    try {
      j = Integer.parseInt(str2);
    } catch (NumberFormatException numberFormatException) {
      throw new IllegalArgumentException("Invalid cost factor: " + str2);
    } 
    if (j < 4 || j > 31)
      throw new IllegalArgumentException("Invalid cost factor: " + j + ", 4 < cost < 31 expected."); 
    byte[] arrayOfByte = decodeSaltString(paramString.substring(paramString.lastIndexOf('$') + 1, i - 31));
    String str3 = doGenerate(str1, paramArrayOfByte, arrayOfByte, j);
    return Strings.constantTimeAreEqual(paramString, str3);
  }
  
  private static String createBcryptString(String paramString, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt) {
    if (!allowedVersions.contains(paramString))
      throw new IllegalArgumentException("Version " + paramString + " is not accepted by this implementation."); 
    StringBuilder stringBuilder = new StringBuilder(60);
    stringBuilder.append('$');
    stringBuilder.append(paramString);
    stringBuilder.append('$');
    stringBuilder.append((paramInt < 10) ? ("0" + paramInt) : Integer.toString(paramInt));
    stringBuilder.append('$');
    encodeData(stringBuilder, paramArrayOfByte2);
    byte[] arrayOfByte = BCrypt.generate(paramArrayOfByte1, paramArrayOfByte2, paramInt);
    encodeData(stringBuilder, arrayOfByte);
    return stringBuilder.toString();
  }
  
  private static void encodeData(StringBuilder paramStringBuilder, byte[] paramArrayOfByte) {
    if (paramArrayOfByte.length != 24 && paramArrayOfByte.length != 16)
      throw new DataLengthException("Invalid length: " + paramArrayOfByte.length + ", 24 for key or 16 for salt expected"); 
    boolean bool1 = false;
    if (paramArrayOfByte.length == 16) {
      bool1 = true;
      byte[] arrayOfByte = new byte[18];
      System.arraycopy(paramArrayOfByte, 0, arrayOfByte, 0, paramArrayOfByte.length);
      paramArrayOfByte = arrayOfByte;
    } else {
      paramArrayOfByte[paramArrayOfByte.length - 1] = 0;
    } 
    int i = paramArrayOfByte.length;
    for (boolean bool2 = false; bool2 < i; bool2 += true) {
      byte b1 = paramArrayOfByte[bool2] & 0xFF;
      byte b2 = paramArrayOfByte[bool2 + true] & 0xFF;
      byte b3 = paramArrayOfByte[bool2 + 2] & 0xFF;
      paramStringBuilder.append((char)encodingTable[b1 >>> 2 & 0x3F]);
      paramStringBuilder.append((char)encodingTable[(b1 << 4 | b2 >>> 4) & 0x3F]);
      paramStringBuilder.append((char)encodingTable[(b2 << 2 | b3 >>> 6) & 0x3F]);
      paramStringBuilder.append((char)encodingTable[b3 & 0x3F]);
    } 
    if (bool1 == true) {
      paramStringBuilder.setLength(paramStringBuilder.length() - 2);
    } else {
      paramStringBuilder.setLength(paramStringBuilder.length() - 1);
    } 
  }
  
  private static byte[] decodeSaltString(String paramString) {
    char[] arrayOfChar1 = paramString.toCharArray();
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(16);
    if (arrayOfChar1.length != 22)
      throw new DataLengthException("Invalid base64 salt length: " + arrayOfChar1.length + " , 22 required."); 
    for (byte b = 0; b < arrayOfChar1.length; b++) {
      char c = arrayOfChar1[b];
      if (c > 'z' || c < '.' || (c > '9' && c < 'A'))
        throw new IllegalArgumentException("Salt string contains invalid character: " + c); 
    } 
    char[] arrayOfChar2 = new char[24];
    System.arraycopy(arrayOfChar1, 0, arrayOfChar2, 0, arrayOfChar1.length);
    arrayOfChar1 = arrayOfChar2;
    int i = arrayOfChar1.length;
    for (boolean bool = false; bool < i; bool += true) {
      byte b1 = decodingTable[arrayOfChar1[bool]];
      byte b2 = decodingTable[arrayOfChar1[bool + true]];
      byte b3 = decodingTable[arrayOfChar1[bool + 2]];
      byte b4 = decodingTable[arrayOfChar1[bool + 3]];
      byteArrayOutputStream.write(b1 << 2 | b2 >> 4);
      byteArrayOutputStream.write(b2 << 4 | b3 >> 2);
      byteArrayOutputStream.write(b3 << 6 | b4);
    } 
    null = byteArrayOutputStream.toByteArray();
    byte[] arrayOfByte = new byte[16];
    System.arraycopy(null, 0, arrayOfByte, 0, arrayOfByte.length);
    return arrayOfByte;
  }
  
  static  {
    allowedVersions.add("2");
    allowedVersions.add("2x");
    allowedVersions.add("2a");
    allowedVersions.add("2y");
    allowedVersions.add("2b");
    byte b;
    for (b = 0; b < decodingTable.length; b++)
      decodingTable[b] = -1; 
    for (b = 0; b < encodingTable.length; b++)
      decodingTable[encodingTable[b]] = (byte)b; 
  }
}
