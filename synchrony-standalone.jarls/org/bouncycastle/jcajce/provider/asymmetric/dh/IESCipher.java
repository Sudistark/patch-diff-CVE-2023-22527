package org.bouncycastle.jcajce.provider.asymmetric.dh;

import java.io.ByteArrayOutputStream;
import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.CipherSpi;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.interfaces.DHKey;
import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.crypto.engines.IESEngine;
import org.bouncycastle.crypto.generators.DHKeyPairGenerator;
import org.bouncycastle.crypto.generators.EphemeralKeyPairGenerator;
import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
import org.bouncycastle.crypto.params.DHKeyGenerationParameters;
import org.bouncycastle.crypto.params.DHKeyParameters;
import org.bouncycastle.crypto.params.DHParameters;
import org.bouncycastle.crypto.params.IESWithCipherParameters;
import org.bouncycastle.crypto.params.ParametersWithIV;
import org.bouncycastle.crypto.parsers.DHIESPublicKeyParser;
import org.bouncycastle.jcajce.provider.asymmetric.util.DHUtil;
import org.bouncycastle.jcajce.provider.asymmetric.util.IESUtil;
import org.bouncycastle.jcajce.provider.util.BadBlockException;
import org.bouncycastle.jcajce.util.BCJcaJceHelper;
import org.bouncycastle.jcajce.util.JcaJceHelper;
import org.bouncycastle.jce.interfaces.IESKey;
import org.bouncycastle.jce.spec.IESParameterSpec;
import org.bouncycastle.util.Strings;

public class IESCipher extends CipherSpi {
  private final JcaJceHelper helper = new BCJcaJceHelper();
  
  private final int ivLength;
  
  private IESEngine engine;
  
  private int state = -1;
  
  private ByteArrayOutputStream buffer = new ByteArrayOutputStream();
  
  private AlgorithmParameters engineParam = null;
  
  private IESParameterSpec engineSpec = null;
  
  private AsymmetricKeyParameter key;
  
  private SecureRandom random;
  
  private boolean dhaesMode = false;
  
  private AsymmetricKeyParameter otherKeyParameter = null;
  
  public IESCipher(IESEngine paramIESEngine) {
    this.engine = paramIESEngine;
    this.ivLength = 0;
  }
  
  public IESCipher(IESEngine paramIESEngine, int paramInt) {
    this.engine = paramIESEngine;
    this.ivLength = paramInt;
  }
  
  public int engineGetBlockSize() { return (this.engine.getCipher() != null) ? this.engine.getCipher().getBlockSize() : 0; }
  
  public int engineGetKeySize(Key paramKey) {
    if (paramKey instanceof DHKey)
      return ((DHKey)paramKey).getParams().getP().bitLength(); 
    throw new IllegalArgumentException("not a DH key");
  }
  
  public byte[] engineGetIV() { return (this.engineSpec != null) ? this.engineSpec.getNonce() : null; }
  
  public AlgorithmParameters engineGetParameters() {
    if (this.engineParam == null && this.engineSpec != null)
      try {
        this.engineParam = this.helper.createAlgorithmParameters("IES");
        this.engineParam.init(this.engineSpec);
      } catch (Exception exception) {
        throw new RuntimeException(exception.toString());
      }  
    return this.engineParam;
  }
  
  public void engineSetMode(String paramString) throws NoSuchAlgorithmException {
    String str = Strings.toUpperCase(paramString);
    if (str.equals("NONE")) {
      this.dhaesMode = false;
    } else if (str.equals("DHAES")) {
      this.dhaesMode = true;
    } else {
      throw new IllegalArgumentException("can't support mode " + paramString);
    } 
  }
  
  public int engineGetOutputSize(int paramInt) {
    int k;
    int j;
    if (this.key == null)
      throw new IllegalStateException("cipher not initialised"); 
    int i = this.engine.getMac().getMacSize();
    if (this.otherKeyParameter == null) {
      j = 1 + 2 * (((DHKeyParameters)this.key).getParameters().getP().bitLength() + 7) / 8;
    } else {
      j = 0;
    } 
    if (this.engine.getCipher() == null) {
      k = paramInt;
    } else if (this.state == 1 || this.state == 3) {
      k = this.engine.getCipher().getOutputSize(paramInt);
    } else if (this.state == 2 || this.state == 4) {
      k = this.engine.getCipher().getOutputSize(paramInt - i - j);
    } else {
      throw new IllegalStateException("cipher not initialised");
    } 
    if (this.state == 1 || this.state == 3)
      return this.buffer.size() + i + j + k; 
    if (this.state == 2 || this.state == 4)
      return this.buffer.size() - i - j + k; 
    throw new IllegalStateException("IESCipher not initialised");
  }
  
  public void engineSetPadding(String paramString) throws NoSuchAlgorithmException {
    String str = Strings.toUpperCase(paramString);
    if (str.equals("NOPADDING") || str.equals("PKCS5PADDING") || str.equals("PKCS7PADDING"))
      return; 
    throw new NoSuchPaddingException("padding not available with IESCipher");
  }
  
  public void engineInit(int paramInt, Key paramKey, AlgorithmParameters paramAlgorithmParameters, SecureRandom paramSecureRandom) throws InvalidKeyException, InvalidAlgorithmParameterException {
    AlgorithmParameterSpec algorithmParameterSpec = null;
    if (paramAlgorithmParameters != null)
      try {
        algorithmParameterSpec = paramAlgorithmParameters.getParameterSpec(IESParameterSpec.class);
      } catch (Exception exception) {
        throw new InvalidAlgorithmParameterException("cannot recognise parameters: " + exception.toString());
      }  
    this.engineParam = paramAlgorithmParameters;
    engineInit(paramInt, paramKey, algorithmParameterSpec, paramSecureRandom);
  }
  
  public void engineInit(int paramInt, Key paramKey, AlgorithmParameterSpec paramAlgorithmParameterSpec, SecureRandom paramSecureRandom) throws InvalidAlgorithmParameterException, InvalidKeyException {
    if (paramAlgorithmParameterSpec == null) {
      byte[] arrayOfByte1 = null;
      if (this.ivLength != 0 && paramInt == 1) {
        arrayOfByte1 = new byte[this.ivLength];
        paramSecureRandom.nextBytes(arrayOfByte1);
      } 
      this.engineSpec = IESUtil.guessParameterSpec(this.engine.getCipher(), arrayOfByte1);
    } else if (paramAlgorithmParameterSpec instanceof IESParameterSpec) {
      this.engineSpec = (IESParameterSpec)paramAlgorithmParameterSpec;
    } else {
      throw new InvalidAlgorithmParameterException("must be passed IES parameters");
    } 
    byte[] arrayOfByte = this.engineSpec.getNonce();
    if (this.ivLength != 0 && (arrayOfByte == null || arrayOfByte.length != this.ivLength))
      throw new InvalidAlgorithmParameterException("NONCE in IES Parameters needs to be " + this.ivLength + " bytes long"); 
    if (paramInt == 1 || paramInt == 3) {
      if (paramKey instanceof javax.crypto.interfaces.DHPublicKey) {
        this.key = DHUtil.generatePublicKeyParameter((PublicKey)paramKey);
      } else if (paramKey instanceof IESKey) {
        IESKey iESKey = (IESKey)paramKey;
        this.key = DHUtil.generatePublicKeyParameter(iESKey.getPublic());
        this.otherKeyParameter = DHUtil.generatePrivateKeyParameter(iESKey.getPrivate());
      } else {
        throw new InvalidKeyException("must be passed recipient's public DH key for encryption");
      } 
    } else if (paramInt == 2 || paramInt == 4) {
      if (paramKey instanceof javax.crypto.interfaces.DHPrivateKey) {
        this.key = DHUtil.generatePrivateKeyParameter((PrivateKey)paramKey);
      } else if (paramKey instanceof IESKey) {
        IESKey iESKey = (IESKey)paramKey;
        this.otherKeyParameter = DHUtil.generatePublicKeyParameter(iESKey.getPublic());
        this.key = DHUtil.generatePrivateKeyParameter(iESKey.getPrivate());
      } else {
        throw new InvalidKeyException("must be passed recipient's private DH key for decryption");
      } 
    } else {
      throw new InvalidKeyException("must be passed EC key");
    } 
    this.random = paramSecureRandom;
    this.state = paramInt;
    this.buffer.reset();
  }
  
  public void engineInit(int paramInt, Key paramKey, SecureRandom paramSecureRandom) throws InvalidKeyException {
    try {
      engineInit(paramInt, paramKey, (AlgorithmParameterSpec)null, paramSecureRandom);
    } catch (InvalidAlgorithmParameterException invalidAlgorithmParameterException) {
      throw new IllegalArgumentException("cannot handle supplied parameter spec: " + invalidAlgorithmParameterException.getMessage());
    } 
  }
  
  public byte[] engineUpdate(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    this.buffer.write(paramArrayOfByte, paramInt1, paramInt2);
    return null;
  }
  
  public int engineUpdate(byte[] paramArrayOfByte1, int paramInt1, int paramInt2, byte[] paramArrayOfByte2, int paramInt3) {
    this.buffer.write(paramArrayOfByte1, paramInt1, paramInt2);
    return 0;
  }
  
  public byte[] engineDoFinal(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    if (paramInt2 != 0)
      this.buffer.write(paramArrayOfByte, paramInt1, paramInt2); 
    byte[] arrayOfByte = this.buffer.toByteArray();
    this.buffer.reset();
    ParametersWithIV parametersWithIV = new IESWithCipherParameters(this.engineSpec.getDerivationV(), this.engineSpec.getEncodingV(), this.engineSpec.getMacKeySize(), this.engineSpec.getCipherKeySize());
    if (this.engineSpec.getNonce() != null)
      parametersWithIV = new ParametersWithIV(parametersWithIV, this.engineSpec.getNonce()); 
    DHParameters dHParameters = ((DHKeyParameters)this.key).getParameters();
    if (this.otherKeyParameter != null)
      try {
        if (this.state == 1 || this.state == 3) {
          this.engine.init(true, this.otherKeyParameter, this.key, parametersWithIV);
        } else {
          this.engine.init(false, this.key, this.otherKeyParameter, parametersWithIV);
        } 
        return this.engine.processBlock(arrayOfByte, 0, arrayOfByte.length);
      } catch (Exception exception) {
        throw new BadBlockException("unable to process block", exception);
      }  
    if (this.state == 1 || this.state == 3) {
      DHKeyPairGenerator dHKeyPairGenerator = new DHKeyPairGenerator();
      dHKeyPairGenerator.init(new DHKeyGenerationParameters(this.random, dHParameters));
      EphemeralKeyPairGenerator ephemeralKeyPairGenerator = new EphemeralKeyPairGenerator(dHKeyPairGenerator, new Object(this));
      try {
        this.engine.init(this.key, parametersWithIV, ephemeralKeyPairGenerator);
        return this.engine.processBlock(arrayOfByte, 0, arrayOfByte.length);
      } catch (Exception exception) {
        throw new BadBlockException("unable to process block", exception);
      } 
    } 
    if (this.state == 2 || this.state == 4)
      try {
        this.engine.init(this.key, parametersWithIV, new DHIESPublicKeyParser(((DHKeyParameters)this.key).getParameters()));
        return this.engine.processBlock(arrayOfByte, 0, arrayOfByte.length);
      } catch (InvalidCipherTextException invalidCipherTextException) {
        throw new BadBlockException("unable to process block", invalidCipherTextException);
      }  
    throw new IllegalStateException("IESCipher not initialised");
  }
  
  public int engineDoFinal(byte[] paramArrayOfByte1, int paramInt1, int paramInt2, byte[] paramArrayOfByte2, int paramInt3) {
    byte[] arrayOfByte = engineDoFinal(paramArrayOfByte1, paramInt1, paramInt2);
    System.arraycopy(arrayOfByte, 0, paramArrayOfByte2, paramInt3, arrayOfByte.length);
    return arrayOfByte.length;
  }
}
