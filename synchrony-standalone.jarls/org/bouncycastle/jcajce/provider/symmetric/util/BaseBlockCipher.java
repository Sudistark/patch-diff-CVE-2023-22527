package org.bouncycastle.jcajce.provider.symmetric.util;

import java.nio.ByteBuffer;
import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.InvalidParameterException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.ShortBufferException;
import javax.crypto.interfaces.PBEKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEParameterSpec;
import javax.crypto.spec.RC2ParameterSpec;
import javax.crypto.spec.RC5ParameterSpec;
import org.bouncycastle.asn1.DEROctetString;
import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.BufferedBlockCipher;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.CryptoServicesRegistrar;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.OutputLengthException;
import org.bouncycastle.crypto.fpe.FPEFF1Engine;
import org.bouncycastle.crypto.fpe.FPEFF3_1Engine;
import org.bouncycastle.crypto.modes.AEADBlockCipher;
import org.bouncycastle.crypto.modes.AEADCipher;
import org.bouncycastle.crypto.modes.CBCBlockCipher;
import org.bouncycastle.crypto.modes.CCMBlockCipher;
import org.bouncycastle.crypto.modes.CFBBlockCipher;
import org.bouncycastle.crypto.modes.CTSBlockCipher;
import org.bouncycastle.crypto.modes.EAXBlockCipher;
import org.bouncycastle.crypto.modes.GCFBBlockCipher;
import org.bouncycastle.crypto.modes.GCMBlockCipher;
import org.bouncycastle.crypto.modes.GCMSIVBlockCipher;
import org.bouncycastle.crypto.modes.GOFBBlockCipher;
import org.bouncycastle.crypto.modes.KCCMBlockCipher;
import org.bouncycastle.crypto.modes.KCTRBlockCipher;
import org.bouncycastle.crypto.modes.KGCMBlockCipher;
import org.bouncycastle.crypto.modes.OCBBlockCipher;
import org.bouncycastle.crypto.modes.OFBBlockCipher;
import org.bouncycastle.crypto.modes.OpenPGPCFBBlockCipher;
import org.bouncycastle.crypto.modes.PGPCFBBlockCipher;
import org.bouncycastle.crypto.modes.SICBlockCipher;
import org.bouncycastle.crypto.paddings.ISO10126d2Padding;
import org.bouncycastle.crypto.paddings.ISO7816d4Padding;
import org.bouncycastle.crypto.paddings.TBCPadding;
import org.bouncycastle.crypto.paddings.X923Padding;
import org.bouncycastle.crypto.paddings.ZeroBytePadding;
import org.bouncycastle.crypto.params.AEADParameters;
import org.bouncycastle.crypto.params.FPEParameters;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.ParametersWithIV;
import org.bouncycastle.crypto.params.ParametersWithRandom;
import org.bouncycastle.crypto.params.ParametersWithSBox;
import org.bouncycastle.crypto.params.RC2Parameters;
import org.bouncycastle.crypto.params.RC5Parameters;
import org.bouncycastle.internal.asn1.cms.GCMParameters;
import org.bouncycastle.jcajce.PBKDF1Key;
import org.bouncycastle.jcajce.PBKDF1KeyWithParameters;
import org.bouncycastle.jcajce.spec.AEADParameterSpec;
import org.bouncycastle.jcajce.spec.FPEParameterSpec;
import org.bouncycastle.jcajce.spec.GOST28147ParameterSpec;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Strings;

public class BaseBlockCipher extends BaseWrapCipher implements PBE {
  private static final int BUF_SIZE = 512;
  
  private static final Class gcmSpecClass = ClassUtil.loadClass(BaseBlockCipher.class, "javax.crypto.spec.GCMParameterSpec");
  
  private Class[] availableSpecs = { RC2ParameterSpec.class, RC5ParameterSpec.class, gcmSpecClass, GOST28147ParameterSpec.class, IvParameterSpec.class, PBEParameterSpec.class };
  
  private BlockCipher baseEngine;
  
  private BlockCipherProvider engineProvider;
  
  private GenericBlockCipher cipher;
  
  private ParametersWithIV ivParam;
  
  private AEADParameters aeadParams;
  
  private int keySizeInBits;
  
  private int scheme = -1;
  
  private int digest;
  
  private int ivLength = 0;
  
  private boolean padded;
  
  private boolean fixedIv = true;
  
  private PBEParameterSpec pbeSpec = null;
  
  private String pbeAlgorithm = null;
  
  private String modeName = null;
  
  protected BaseBlockCipher(BlockCipher paramBlockCipher) {
    this.baseEngine = paramBlockCipher;
    this.cipher = new BufferedGenericBlockCipher(paramBlockCipher);
  }
  
  protected BaseBlockCipher(BlockCipher paramBlockCipher, int paramInt1, int paramInt2, int paramInt3, int paramInt4) {
    this.baseEngine = paramBlockCipher;
    this.scheme = paramInt1;
    this.digest = paramInt2;
    this.keySizeInBits = paramInt3;
    this.ivLength = paramInt4;
    this.cipher = new BufferedGenericBlockCipher(paramBlockCipher);
  }
  
  protected BaseBlockCipher(BlockCipherProvider paramBlockCipherProvider) {
    this.baseEngine = paramBlockCipherProvider.get();
    this.engineProvider = paramBlockCipherProvider;
    this.cipher = new BufferedGenericBlockCipher(paramBlockCipherProvider.get());
  }
  
  protected BaseBlockCipher(AEADBlockCipher paramAEADBlockCipher) {
    this.baseEngine = paramAEADBlockCipher.getUnderlyingCipher();
    if (paramAEADBlockCipher.getAlgorithmName().indexOf("GCM") >= 0) {
      this.ivLength = 12;
    } else {
      this.ivLength = this.baseEngine.getBlockSize();
    } 
    this.cipher = new AEADGenericBlockCipher(paramAEADBlockCipher);
  }
  
  protected BaseBlockCipher(AEADCipher paramAEADCipher, boolean paramBoolean, int paramInt) {
    this.baseEngine = null;
    this.fixedIv = paramBoolean;
    this.ivLength = paramInt;
    this.cipher = new AEADGenericBlockCipher(paramAEADCipher);
  }
  
  protected BaseBlockCipher(AEADBlockCipher paramAEADBlockCipher, boolean paramBoolean, int paramInt) {
    this.baseEngine = paramAEADBlockCipher.getUnderlyingCipher();
    this.fixedIv = paramBoolean;
    this.ivLength = paramInt;
    this.cipher = new AEADGenericBlockCipher(paramAEADBlockCipher);
  }
  
  protected BaseBlockCipher(BlockCipher paramBlockCipher, int paramInt) { this(paramBlockCipher, true, paramInt); }
  
  protected BaseBlockCipher(BlockCipher paramBlockCipher, boolean paramBoolean, int paramInt) {
    this.baseEngine = paramBlockCipher;
    this.fixedIv = paramBoolean;
    this.cipher = new BufferedGenericBlockCipher(paramBlockCipher);
    this.ivLength = paramInt / 8;
  }
  
  protected BaseBlockCipher(BufferedBlockCipher paramBufferedBlockCipher, int paramInt) { this(paramBufferedBlockCipher, true, paramInt); }
  
  protected BaseBlockCipher(BufferedBlockCipher paramBufferedBlockCipher, boolean paramBoolean, int paramInt) {
    this.baseEngine = paramBufferedBlockCipher.getUnderlyingCipher();
    this.cipher = new BufferedGenericBlockCipher(paramBufferedBlockCipher);
    this.fixedIv = paramBoolean;
    this.ivLength = paramInt / 8;
  }
  
  protected int engineGetBlockSize() { return (this.baseEngine == null) ? -1 : this.baseEngine.getBlockSize(); }
  
  protected byte[] engineGetIV() { return (this.aeadParams != null) ? this.aeadParams.getNonce() : ((this.ivParam != null) ? this.ivParam.getIV() : null); }
  
  protected int engineGetKeySize(Key paramKey) { return paramKey.getEncoded().length * 8; }
  
  protected int engineGetOutputSize(int paramInt) { return this.cipher.getOutputSize(paramInt); }
  
  protected AlgorithmParameters engineGetParameters() {
    if (this.engineParams == null)
      if (this.pbeSpec != null) {
        try {
          this.engineParams = createParametersInstance(this.pbeAlgorithm);
          this.engineParams.init(this.pbeSpec);
        } catch (Exception exception) {
          return null;
        } 
      } else if (this.aeadParams != null) {
        if (this.baseEngine == null) {
          try {
            this.engineParams = createParametersInstance(PKCSObjectIdentifiers.id_alg_AEADChaCha20Poly1305.getId());
            this.engineParams.init((new DEROctetString(this.aeadParams.getNonce())).getEncoded());
          } catch (Exception exception) {
            throw new RuntimeException(exception.toString());
          } 
        } else {
          try {
            this.engineParams = createParametersInstance("GCM");
            this.engineParams.init((new GCMParameters(this.aeadParams.getNonce(), this.aeadParams.getMacSize() / 8)).getEncoded());
          } catch (Exception exception) {
            throw new RuntimeException(exception.toString());
          } 
        } 
      } else if (this.ivParam != null) {
        String str = this.cipher.getUnderlyingCipher().getAlgorithmName();
        if (str.indexOf('/') >= 0)
          str = str.substring(0, str.indexOf('/')); 
        try {
          this.engineParams = createParametersInstance(str);
          this.engineParams.init(new IvParameterSpec(this.ivParam.getIV()));
        } catch (Exception exception) {
          throw new RuntimeException(exception.toString());
        } 
      }  
    return this.engineParams;
  }
  
  protected void engineSetMode(String paramString) throws NoSuchAlgorithmException {
    if (this.baseEngine == null)
      throw new NoSuchAlgorithmException("no mode supported for this algorithm"); 
    this.modeName = Strings.toUpperCase(paramString);
    if (this.modeName.equals("ECB")) {
      this.ivLength = 0;
      this.cipher = new BufferedGenericBlockCipher(this.baseEngine);
    } else if (this.modeName.equals("CBC")) {
      this.ivLength = this.baseEngine.getBlockSize();
      this.cipher = new BufferedGenericBlockCipher(new CBCBlockCipher(this.baseEngine));
    } else if (this.modeName.startsWith("OFB")) {
      this.ivLength = this.baseEngine.getBlockSize();
      if (this.modeName.length() != 3) {
        int i = Integer.parseInt(this.modeName.substring(3));
        this.cipher = new BufferedGenericBlockCipher(new OFBBlockCipher(this.baseEngine, i));
      } else {
        this.cipher = new BufferedGenericBlockCipher(new OFBBlockCipher(this.baseEngine, 8 * this.baseEngine.getBlockSize()));
      } 
    } else if (this.modeName.startsWith("CFB")) {
      this.ivLength = this.baseEngine.getBlockSize();
      if (this.modeName.length() != 3) {
        int i = Integer.parseInt(this.modeName.substring(3));
        this.cipher = new BufferedGenericBlockCipher(new CFBBlockCipher(this.baseEngine, i));
      } else {
        this.cipher = new BufferedGenericBlockCipher(new CFBBlockCipher(this.baseEngine, 8 * this.baseEngine.getBlockSize()));
      } 
    } else if (this.modeName.startsWith("PGPCFB")) {
      boolean bool = this.modeName.equals("PGPCFBWITHIV");
      if (!bool && this.modeName.length() != 6)
        throw new NoSuchAlgorithmException("no mode support for " + this.modeName); 
      this.ivLength = this.baseEngine.getBlockSize();
      this.cipher = new BufferedGenericBlockCipher(new PGPCFBBlockCipher(this.baseEngine, bool));
    } else if (this.modeName.equals("OPENPGPCFB")) {
      this.ivLength = 0;
      this.cipher = new BufferedGenericBlockCipher(new OpenPGPCFBBlockCipher(this.baseEngine));
    } else if (this.modeName.equals("FF1")) {
      this.ivLength = 0;
      this.cipher = new BufferedFPEBlockCipher(new FPEFF1Engine(this.baseEngine));
    } else if (this.modeName.equals("FF3-1")) {
      this.ivLength = 0;
      this.cipher = new BufferedFPEBlockCipher(new FPEFF3_1Engine(this.baseEngine));
    } else if (this.modeName.equals("SIC")) {
      this.ivLength = this.baseEngine.getBlockSize();
      if (this.ivLength < 16)
        throw new IllegalArgumentException("Warning: SIC-Mode can become a twotime-pad if the blocksize of the cipher is too small. Use a cipher with a block size of at least 128 bits (e.g. AES)"); 
      this.fixedIv = false;
      this.cipher = new BufferedGenericBlockCipher(new BufferedBlockCipher(new SICBlockCipher(this.baseEngine)));
    } else if (this.modeName.equals("CTR")) {
      this.ivLength = this.baseEngine.getBlockSize();
      this.fixedIv = false;
      if (this.baseEngine instanceof org.bouncycastle.crypto.engines.DSTU7624Engine) {
        this.cipher = new BufferedGenericBlockCipher(new BufferedBlockCipher(new KCTRBlockCipher(this.baseEngine)));
      } else {
        this.cipher = new BufferedGenericBlockCipher(new BufferedBlockCipher(new SICBlockCipher(this.baseEngine)));
      } 
    } else if (this.modeName.equals("GOFB")) {
      this.ivLength = this.baseEngine.getBlockSize();
      this.cipher = new BufferedGenericBlockCipher(new BufferedBlockCipher(new GOFBBlockCipher(this.baseEngine)));
    } else if (this.modeName.equals("GCFB")) {
      this.ivLength = this.baseEngine.getBlockSize();
      this.cipher = new BufferedGenericBlockCipher(new BufferedBlockCipher(new GCFBBlockCipher(this.baseEngine)));
    } else if (this.modeName.equals("CTS")) {
      this.ivLength = this.baseEngine.getBlockSize();
      this.cipher = new BufferedGenericBlockCipher(new CTSBlockCipher(new CBCBlockCipher(this.baseEngine)));
    } else if (this.modeName.equals("CCM")) {
      this.ivLength = 12;
      if (this.baseEngine instanceof org.bouncycastle.crypto.engines.DSTU7624Engine) {
        this.cipher = new AEADGenericBlockCipher(new KCCMBlockCipher(this.baseEngine));
      } else {
        this.cipher = new AEADGenericBlockCipher(new CCMBlockCipher(this.baseEngine));
      } 
    } else if (this.modeName.equals("OCB")) {
      if (this.engineProvider != null) {
        this.ivLength = 15;
        this.cipher = new AEADGenericBlockCipher(new OCBBlockCipher(this.baseEngine, this.engineProvider.get()));
      } else {
        throw new NoSuchAlgorithmException("can't support mode " + paramString);
      } 
    } else if (this.modeName.equals("EAX")) {
      this.ivLength = this.baseEngine.getBlockSize();
      this.cipher = new AEADGenericBlockCipher(new EAXBlockCipher(this.baseEngine));
    } else if (this.modeName.equals("GCM-SIV")) {
      this.ivLength = 12;
      this.cipher = new AEADGenericBlockCipher(new GCMSIVBlockCipher(this.baseEngine));
    } else if (this.modeName.equals("GCM")) {
      if (this.baseEngine instanceof org.bouncycastle.crypto.engines.DSTU7624Engine) {
        this.ivLength = this.baseEngine.getBlockSize();
        this.cipher = new AEADGenericBlockCipher(new KGCMBlockCipher(this.baseEngine));
      } else {
        this.ivLength = 12;
        this.cipher = new AEADGenericBlockCipher(new GCMBlockCipher(this.baseEngine));
      } 
    } else {
      throw new NoSuchAlgorithmException("can't support mode " + paramString);
    } 
  }
  
  protected void engineSetPadding(String paramString) throws NoSuchAlgorithmException {
    if (this.baseEngine == null)
      throw new NoSuchPaddingException("no padding supported for this algorithm"); 
    String str = Strings.toUpperCase(paramString);
    if (str.equals("NOPADDING")) {
      if (this.cipher.wrapOnNoPadding())
        this.cipher = new BufferedGenericBlockCipher(new BufferedBlockCipher(this.cipher.getUnderlyingCipher())); 
    } else if (str.equals("WITHCTS") || str.equals("CTSPADDING") || str.equals("CS3PADDING")) {
      this.cipher = new BufferedGenericBlockCipher(new CTSBlockCipher(this.cipher.getUnderlyingCipher()));
    } else {
      this.padded = true;
      if (isAEADModeName(this.modeName))
        throw new NoSuchPaddingException("Only NoPadding can be used with AEAD modes."); 
      if (str.equals("PKCS5PADDING") || str.equals("PKCS7PADDING")) {
        this.cipher = new BufferedGenericBlockCipher(this.cipher.getUnderlyingCipher());
      } else if (str.equals("ZEROBYTEPADDING")) {
        this.cipher = new BufferedGenericBlockCipher(this.cipher.getUnderlyingCipher(), new ZeroBytePadding());
      } else if (str.equals("ISO10126PADDING") || str.equals("ISO10126-2PADDING")) {
        this.cipher = new BufferedGenericBlockCipher(this.cipher.getUnderlyingCipher(), new ISO10126d2Padding());
      } else if (str.equals("X9.23PADDING") || str.equals("X923PADDING")) {
        this.cipher = new BufferedGenericBlockCipher(this.cipher.getUnderlyingCipher(), new X923Padding());
      } else if (str.equals("ISO7816-4PADDING") || str.equals("ISO9797-1PADDING")) {
        this.cipher = new BufferedGenericBlockCipher(this.cipher.getUnderlyingCipher(), new ISO7816d4Padding());
      } else if (str.equals("TBCPADDING")) {
        this.cipher = new BufferedGenericBlockCipher(this.cipher.getUnderlyingCipher(), new TBCPadding());
      } else {
        throw new NoSuchPaddingException("Padding " + paramString + " unknown.");
      } 
    } 
  }
  
  protected void engineInit(int paramInt, Key paramKey, AlgorithmParameterSpec paramAlgorithmParameterSpec, SecureRandom paramSecureRandom) throws InvalidKeyException, InvalidAlgorithmParameterException {
    ParametersWithRandom parametersWithRandom;
    this.pbeSpec = null;
    this.pbeAlgorithm = null;
    this.engineParams = null;
    this.aeadParams = null;
    if (!(paramKey instanceof SecretKey))
      throw new InvalidKeyException("Key for algorithm " + ((paramKey != null) ? paramKey.getAlgorithm() : null) + " not suitable for symmetric enryption."); 
    if (paramAlgorithmParameterSpec == null && this.baseEngine != null && this.baseEngine.getAlgorithmName().startsWith("RC5-64"))
      throw new InvalidAlgorithmParameterException("RC5 requires an RC5ParametersSpec to be passed in."); 
    if (this.scheme == 2 || paramKey instanceof org.bouncycastle.jcajce.PKCS12Key) {
      SecretKey secretKey;
      try {
        secretKey = (SecretKey)paramKey;
      } catch (Exception exception) {
        throw new InvalidKeyException("PKCS12 requires a SecretKey/PBEKey");
      } 
      if (paramAlgorithmParameterSpec instanceof PBEParameterSpec)
        this.pbeSpec = (PBEParameterSpec)paramAlgorithmParameterSpec; 
      if (secretKey instanceof PBEKey && this.pbeSpec == null) {
        PBEKey pBEKey = (PBEKey)secretKey;
        if (pBEKey.getSalt() == null)
          throw new InvalidAlgorithmParameterException("PBEKey requires parameters to specify salt"); 
        this.pbeSpec = new PBEParameterSpec(pBEKey.getSalt(), pBEKey.getIterationCount());
      } 
      if (this.pbeSpec == null && !(secretKey instanceof PBEKey))
        throw new InvalidKeyException("Algorithm requires a PBE key"); 
      if (paramKey instanceof BCPBEKey) {
        CipherParameters cipherParameters = ((BCPBEKey)paramKey).getParam();
        if (cipherParameters instanceof ParametersWithIV) {
          parametersWithRandom = cipherParameters;
        } else if (cipherParameters == null) {
          parametersWithRandom = PBE.Util.makePBEParameters(secretKey.getEncoded(), 2, this.digest, this.keySizeInBits, this.ivLength * 8, this.pbeSpec, this.cipher.getAlgorithmName());
        } else {
          throw new InvalidKeyException("Algorithm requires a PBE key suitable for PKCS12");
        } 
      } else {
        parametersWithRandom = PBE.Util.makePBEParameters(secretKey.getEncoded(), 2, this.digest, this.keySizeInBits, this.ivLength * 8, this.pbeSpec, this.cipher.getAlgorithmName());
      } 
      if (parametersWithRandom instanceof ParametersWithIV)
        this.ivParam = (ParametersWithIV)parametersWithRandom; 
    } else if (paramKey instanceof PBKDF1Key) {
      PBKDF1Key pBKDF1Key = (PBKDF1Key)paramKey;
      if (paramAlgorithmParameterSpec instanceof PBEParameterSpec)
        this.pbeSpec = (PBEParameterSpec)paramAlgorithmParameterSpec; 
      if (pBKDF1Key instanceof PBKDF1KeyWithParameters && this.pbeSpec == null)
        this.pbeSpec = new PBEParameterSpec(((PBKDF1KeyWithParameters)pBKDF1Key).getSalt(), ((PBKDF1KeyWithParameters)pBKDF1Key).getIterationCount()); 
      parametersWithRandom = PBE.Util.makePBEParameters(pBKDF1Key.getEncoded(), 0, this.digest, this.keySizeInBits, this.ivLength * 8, this.pbeSpec, this.cipher.getAlgorithmName());
      if (parametersWithRandom instanceof ParametersWithIV)
        this.ivParam = (ParametersWithIV)parametersWithRandom; 
    } else if (paramKey instanceof BCPBEKey) {
      BCPBEKey bCPBEKey = (BCPBEKey)paramKey;
      if (bCPBEKey.getOID() != null) {
        this.pbeAlgorithm = bCPBEKey.getOID().getId();
      } else {
        this.pbeAlgorithm = bCPBEKey.getAlgorithm();
      } 
      if (bCPBEKey.getParam() != null) {
        parametersWithRandom = adjustParameters(paramAlgorithmParameterSpec, bCPBEKey.getParam());
      } else if (paramAlgorithmParameterSpec instanceof PBEParameterSpec) {
        this.pbeSpec = (PBEParameterSpec)paramAlgorithmParameterSpec;
        parametersWithRandom = PBE.Util.makePBEParameters(bCPBEKey, paramAlgorithmParameterSpec, this.cipher.getUnderlyingCipher().getAlgorithmName());
      } else {
        throw new InvalidAlgorithmParameterException("PBE requires PBE parameters to be set.");
      } 
      if (parametersWithRandom instanceof ParametersWithIV)
        this.ivParam = (ParametersWithIV)parametersWithRandom; 
    } else if (paramKey instanceof PBEKey) {
      PBEKey pBEKey = (PBEKey)paramKey;
      this.pbeSpec = (PBEParameterSpec)paramAlgorithmParameterSpec;
      if (pBEKey instanceof org.bouncycastle.jcajce.PKCS12KeyWithParameters && this.pbeSpec == null)
        this.pbeSpec = new PBEParameterSpec(pBEKey.getSalt(), pBEKey.getIterationCount()); 
      parametersWithRandom = PBE.Util.makePBEParameters(pBEKey.getEncoded(), this.scheme, this.digest, this.keySizeInBits, this.ivLength * 8, this.pbeSpec, this.cipher.getAlgorithmName());
      if (parametersWithRandom instanceof ParametersWithIV)
        this.ivParam = (ParametersWithIV)parametersWithRandom; 
    } else if (!(paramKey instanceof org.bouncycastle.jcajce.spec.RepeatedSecretKeySpec)) {
      if (this.scheme == 0 || this.scheme == 4 || this.scheme == 1 || this.scheme == 5)
        throw new InvalidKeyException("Algorithm requires a PBE key"); 
      parametersWithRandom = new KeyParameter(paramKey.getEncoded());
    } else {
      parametersWithRandom = null;
    } 
    if (paramAlgorithmParameterSpec instanceof AEADParameterSpec) {
      KeyParameter keyParameter;
      if (!isAEADModeName(this.modeName) && !(this.cipher instanceof AEADGenericBlockCipher))
        throw new InvalidAlgorithmParameterException("AEADParameterSpec can only be used with AEAD modes."); 
      AEADParameterSpec aEADParameterSpec = (AEADParameterSpec)paramAlgorithmParameterSpec;
      if (parametersWithRandom instanceof ParametersWithIV) {
        keyParameter = (KeyParameter)((ParametersWithIV)parametersWithRandom).getParameters();
      } else {
        keyParameter = (KeyParameter)parametersWithRandom;
      } 
      parametersWithRandom = this.aeadParams = new AEADParameters(keyParameter, aEADParameterSpec.getMacSizeInBits(), aEADParameterSpec.getNonce(), aEADParameterSpec.getAssociatedData());
    } else if (paramAlgorithmParameterSpec instanceof IvParameterSpec) {
      if (this.ivLength != 0) {
        ParametersWithIV parametersWithIV;
        IvParameterSpec ivParameterSpec = (IvParameterSpec)paramAlgorithmParameterSpec;
        if (ivParameterSpec.getIV().length != this.ivLength && !(this.cipher instanceof AEADGenericBlockCipher) && this.fixedIv)
          throw new InvalidAlgorithmParameterException("IV must be " + this.ivLength + " bytes long."); 
        if (parametersWithRandom instanceof ParametersWithIV) {
          parametersWithIV = new ParametersWithIV(((ParametersWithIV)parametersWithRandom).getParameters(), ivParameterSpec.getIV());
        } else {
          parametersWithIV = new ParametersWithIV(parametersWithIV, ivParameterSpec.getIV());
        } 
        this.ivParam = (ParametersWithIV)parametersWithIV;
      } else if (this.modeName != null && this.modeName.equals("ECB")) {
        throw new InvalidAlgorithmParameterException("ECB mode does not use an IV");
      } 
    } else if (paramAlgorithmParameterSpec instanceof GOST28147ParameterSpec) {
      GOST28147ParameterSpec gOST28147ParameterSpec = (GOST28147ParameterSpec)paramAlgorithmParameterSpec;
      ParametersWithSBox parametersWithSBox = new ParametersWithSBox(new KeyParameter(paramKey.getEncoded()), ((GOST28147ParameterSpec)paramAlgorithmParameterSpec).getSbox());
      if (gOST28147ParameterSpec.getIV() != null && this.ivLength != 0) {
        ParametersWithIV parametersWithIV;
        if (parametersWithSBox instanceof ParametersWithIV) {
          parametersWithIV = new ParametersWithIV(((ParametersWithIV)parametersWithSBox).getParameters(), gOST28147ParameterSpec.getIV());
        } else {
          parametersWithIV = new ParametersWithIV(parametersWithIV, gOST28147ParameterSpec.getIV());
        } 
        this.ivParam = (ParametersWithIV)parametersWithIV;
      } 
    } else if (paramAlgorithmParameterSpec instanceof RC2ParameterSpec) {
      RC2ParameterSpec rC2ParameterSpec = (RC2ParameterSpec)paramAlgorithmParameterSpec;
      RC2Parameters rC2Parameters = new RC2Parameters(paramKey.getEncoded(), ((RC2ParameterSpec)paramAlgorithmParameterSpec).getEffectiveKeyBits());
      if (rC2ParameterSpec.getIV() != null && this.ivLength != 0) {
        ParametersWithIV parametersWithIV;
        if (rC2Parameters instanceof ParametersWithIV) {
          parametersWithIV = new ParametersWithIV(((ParametersWithIV)rC2Parameters).getParameters(), rC2ParameterSpec.getIV());
        } else {
          parametersWithIV = new ParametersWithIV(parametersWithIV, rC2ParameterSpec.getIV());
        } 
        this.ivParam = (ParametersWithIV)parametersWithIV;
      } 
    } else {
      ParametersWithIV parametersWithIV;
      if (paramAlgorithmParameterSpec instanceof RC5ParameterSpec) {
        RC5ParameterSpec rC5ParameterSpec = (RC5ParameterSpec)paramAlgorithmParameterSpec;
        parametersWithIV = new RC5Parameters(paramKey.getEncoded(), ((RC5ParameterSpec)paramAlgorithmParameterSpec).getRounds());
        if (this.baseEngine.getAlgorithmName().startsWith("RC5")) {
          if (this.baseEngine.getAlgorithmName().equals("RC5-32")) {
            if (rC5ParameterSpec.getWordSize() != 32)
              throw new InvalidAlgorithmParameterException("RC5 already set up for a word size of 32 not " + rC5ParameterSpec.getWordSize() + "."); 
          } else if (this.baseEngine.getAlgorithmName().equals("RC5-64") && rC5ParameterSpec.getWordSize() != 64) {
            throw new InvalidAlgorithmParameterException("RC5 already set up for a word size of 64 not " + rC5ParameterSpec.getWordSize() + ".");
          } 
        } else {
          throw new InvalidAlgorithmParameterException("RC5 parameters passed to a cipher that is not RC5.");
        } 
        if (rC5ParameterSpec.getIV() != null && this.ivLength != 0) {
          if (parametersWithIV instanceof ParametersWithIV) {
            parametersWithIV = new ParametersWithIV(((ParametersWithIV)parametersWithIV).getParameters(), rC5ParameterSpec.getIV());
          } else {
            parametersWithIV = new ParametersWithIV(parametersWithIV, rC5ParameterSpec.getIV());
          } 
          this.ivParam = (ParametersWithIV)parametersWithIV;
        } 
      } else {
        FPEParameters fPEParameters;
        if (paramAlgorithmParameterSpec instanceof FPEParameterSpec) {
          FPEParameterSpec fPEParameterSpec = (FPEParameterSpec)paramAlgorithmParameterSpec;
          fPEParameters = new FPEParameters((KeyParameter)parametersWithIV, fPEParameterSpec.getRadix(), fPEParameterSpec.getTweak(), fPEParameterSpec.isUsingInverseFunction());
        } else if (gcmSpecClass != null && gcmSpecClass.isInstance(paramAlgorithmParameterSpec)) {
          KeyParameter keyParameter;
          if (!isAEADModeName(this.modeName) && !(this.cipher instanceof AEADGenericBlockCipher))
            throw new InvalidAlgorithmParameterException("GCMParameterSpec can only be used with AEAD modes."); 
          if (fPEParameters instanceof ParametersWithIV) {
            keyParameter = (KeyParameter)((ParametersWithIV)fPEParameters).getParameters();
          } else {
            keyParameter = (KeyParameter)fPEParameters;
          } 
          parametersWithRandom = this.aeadParams = GcmSpecUtil.extractAeadParameters(keyParameter, paramAlgorithmParameterSpec);
        } else if (paramAlgorithmParameterSpec != null && !(paramAlgorithmParameterSpec instanceof PBEParameterSpec)) {
          throw new InvalidAlgorithmParameterException("unknown parameter type.");
        } 
      } 
    } 
    if (this.ivLength != 0 && !(parametersWithRandom instanceof ParametersWithIV) && !(parametersWithRandom instanceof AEADParameters)) {
      SecureRandom secureRandom = paramSecureRandom;
      if (secureRandom == null)
        secureRandom = CryptoServicesRegistrar.getSecureRandom(); 
      if (paramInt == 1 || paramInt == 3) {
        byte[] arrayOfByte = new byte[this.ivLength];
        secureRandom.nextBytes(arrayOfByte);
        parametersWithRandom = new ParametersWithIV(parametersWithRandom, arrayOfByte);
        this.ivParam = (ParametersWithIV)parametersWithRandom;
      } else if (this.cipher.getUnderlyingCipher().getAlgorithmName().indexOf("PGPCFB") < 0) {
        throw new InvalidAlgorithmParameterException("no IV set when one expected");
      } 
    } 
    if (paramSecureRandom != null && this.padded)
      parametersWithRandom = new ParametersWithRandom(parametersWithRandom, paramSecureRandom); 
    try {
      switch (paramInt) {
        case 1:
        case 3:
          this.cipher.init(true, parametersWithRandom);
          break;
        case 2:
        case 4:
          this.cipher.init(false, parametersWithRandom);
          break;
        default:
          throw new InvalidParameterException("unknown opmode " + paramInt + " passed");
      } 
      if (this.cipher instanceof AEADGenericBlockCipher && this.aeadParams == null) {
        AEADCipher aEADCipher = AEADGenericBlockCipher.access$000((AEADGenericBlockCipher)this.cipher);
        this.aeadParams = new AEADParameters((KeyParameter)this.ivParam.getParameters(), aEADCipher.getMac().length * 8, this.ivParam.getIV());
      } 
    } catch (IllegalArgumentException illegalArgumentException) {
      throw new InvalidAlgorithmParameterException(illegalArgumentException.getMessage(), illegalArgumentException);
    } catch (Exception exception) {
      throw new BaseWrapCipher.InvalidKeyOrParametersException(exception.getMessage(), exception);
    } 
  }
  
  private CipherParameters adjustParameters(AlgorithmParameterSpec paramAlgorithmParameterSpec, CipherParameters paramCipherParameters) {
    ParametersWithIV parametersWithIV;
    if (paramCipherParameters instanceof ParametersWithIV) {
      CipherParameters cipherParameters = ((ParametersWithIV)paramCipherParameters).getParameters();
      if (paramAlgorithmParameterSpec instanceof IvParameterSpec) {
        IvParameterSpec ivParameterSpec = (IvParameterSpec)paramAlgorithmParameterSpec;
        this.ivParam = new ParametersWithIV(cipherParameters, ivParameterSpec.getIV());
        parametersWithIV = this.ivParam;
      } else if (paramAlgorithmParameterSpec instanceof GOST28147ParameterSpec) {
        GOST28147ParameterSpec gOST28147ParameterSpec = (GOST28147ParameterSpec)paramAlgorithmParameterSpec;
        ParametersWithSBox parametersWithSBox = new ParametersWithSBox(parametersWithIV, gOST28147ParameterSpec.getSbox());
        if (gOST28147ParameterSpec.getIV() != null && this.ivLength != 0) {
          this.ivParam = new ParametersWithIV(cipherParameters, gOST28147ParameterSpec.getIV());
          parametersWithIV = this.ivParam;
        } 
      } 
    } else if (paramAlgorithmParameterSpec instanceof IvParameterSpec) {
      IvParameterSpec ivParameterSpec = (IvParameterSpec)paramAlgorithmParameterSpec;
      this.ivParam = new ParametersWithIV(parametersWithIV, ivParameterSpec.getIV());
      parametersWithIV = this.ivParam;
    } else if (paramAlgorithmParameterSpec instanceof GOST28147ParameterSpec) {
      GOST28147ParameterSpec gOST28147ParameterSpec = (GOST28147ParameterSpec)paramAlgorithmParameterSpec;
      ParametersWithSBox parametersWithSBox = new ParametersWithSBox(parametersWithIV, gOST28147ParameterSpec.getSbox());
      if (gOST28147ParameterSpec.getIV() != null && this.ivLength != 0)
        parametersWithIV = new ParametersWithIV(parametersWithSBox, gOST28147ParameterSpec.getIV()); 
    } 
    return parametersWithIV;
  }
  
  protected void engineInit(int paramInt, Key paramKey, AlgorithmParameters paramAlgorithmParameters, SecureRandom paramSecureRandom) throws InvalidKeyException, InvalidAlgorithmParameterException {
    AlgorithmParameterSpec algorithmParameterSpec = null;
    if (paramAlgorithmParameters != null) {
      algorithmParameterSpec = SpecUtil.extractSpec(paramAlgorithmParameters, this.availableSpecs);
      if (algorithmParameterSpec == null)
        throw new InvalidAlgorithmParameterException("can't handle parameter " + paramAlgorithmParameters.toString()); 
    } 
    engineInit(paramInt, paramKey, algorithmParameterSpec, paramSecureRandom);
    this.engineParams = paramAlgorithmParameters;
  }
  
  protected void engineInit(int paramInt, Key paramKey, SecureRandom paramSecureRandom) throws InvalidKeyException {
    try {
      engineInit(paramInt, paramKey, (AlgorithmParameterSpec)null, paramSecureRandom);
    } catch (InvalidAlgorithmParameterException invalidAlgorithmParameterException) {
      throw new InvalidKeyException(invalidAlgorithmParameterException.getMessage());
    } 
  }
  
  protected void engineUpdateAAD(byte[] paramArrayOfByte, int paramInt1, int paramInt2) { this.cipher.updateAAD(paramArrayOfByte, paramInt1, paramInt2); }
  
  protected void engineUpdateAAD(ByteBuffer paramByteBuffer) {
    int i = paramByteBuffer.remaining();
    if (i >= 1)
      if (paramByteBuffer.hasArray()) {
        engineUpdateAAD(paramByteBuffer.array(), paramByteBuffer.arrayOffset() + paramByteBuffer.position(), i);
        paramByteBuffer.position(paramByteBuffer.limit());
      } else if (i <= 512) {
        byte[] arrayOfByte = new byte[i];
        paramByteBuffer.get(arrayOfByte);
        engineUpdateAAD(arrayOfByte, 0, arrayOfByte.length);
        Arrays.fill(arrayOfByte, (byte)0);
      } else {
        byte[] arrayOfByte = new byte[512];
        do {
          int j = Math.min(arrayOfByte.length, i);
          paramByteBuffer.get(arrayOfByte, 0, j);
          engineUpdateAAD(arrayOfByte, 0, j);
          i -= j;
        } while (i > 0);
        Arrays.fill(arrayOfByte, (byte)0);
      }  
  }
  
  protected byte[] engineUpdate(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    int i = this.cipher.getUpdateOutputSize(paramInt2);
    if (i > 0) {
      byte[] arrayOfByte = new byte[i];
      int j = this.cipher.processBytes(paramArrayOfByte, paramInt1, paramInt2, arrayOfByte, 0);
      if (j == 0)
        return null; 
      if (j != arrayOfByte.length) {
        byte[] arrayOfByte1 = new byte[j];
        System.arraycopy(arrayOfByte, 0, arrayOfByte1, 0, j);
        return arrayOfByte1;
      } 
      return arrayOfByte;
    } 
    this.cipher.processBytes(paramArrayOfByte, paramInt1, paramInt2, null, 0);
    return null;
  }
  
  protected int engineUpdate(byte[] paramArrayOfByte1, int paramInt1, int paramInt2, byte[] paramArrayOfByte2, int paramInt3) throws ShortBufferException {
    if (paramInt3 + this.cipher.getUpdateOutputSize(paramInt2) > paramArrayOfByte2.length)
      throw new ShortBufferException("output buffer too short for input."); 
    try {
      return this.cipher.processBytes(paramArrayOfByte1, paramInt1, paramInt2, paramArrayOfByte2, paramInt3);
    } catch (DataLengthException dataLengthException) {
      throw new IllegalStateException(dataLengthException.toString());
    } 
  }
  
  protected byte[] engineDoFinal(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    int i = 0;
    byte[] arrayOfByte1 = new byte[engineGetOutputSize(paramInt2)];
    if (paramInt2 != 0)
      i = this.cipher.processBytes(paramArrayOfByte, paramInt1, paramInt2, arrayOfByte1, 0); 
    try {
      i += this.cipher.doFinal(arrayOfByte1, i);
    } catch (DataLengthException dataLengthException) {
      throw new IllegalBlockSizeException(dataLengthException.getMessage());
    } 
    if (i == arrayOfByte1.length)
      return arrayOfByte1; 
    if (i > arrayOfByte1.length)
      throw new IllegalBlockSizeException("internal buffer overflow"); 
    byte[] arrayOfByte2 = new byte[i];
    System.arraycopy(arrayOfByte1, 0, arrayOfByte2, 0, i);
    return arrayOfByte2;
  }
  
  protected int engineDoFinal(byte[] paramArrayOfByte1, int paramInt1, int paramInt2, byte[] paramArrayOfByte2, int paramInt3) throws ShortBufferException {
    int i = 0;
    if (paramInt3 + engineGetOutputSize(paramInt2) > paramArrayOfByte2.length)
      throw new ShortBufferException("output buffer too short for input."); 
    try {
      if (paramInt2 != 0)
        i = this.cipher.processBytes(paramArrayOfByte1, paramInt1, paramInt2, paramArrayOfByte2, paramInt3); 
      return i + this.cipher.doFinal(paramArrayOfByte2, paramInt3 + i);
    } catch (OutputLengthException outputLengthException) {
      throw new IllegalBlockSizeException(outputLengthException.getMessage());
    } catch (DataLengthException dataLengthException) {
      throw new IllegalBlockSizeException(dataLengthException.getMessage());
    } 
  }
  
  private boolean isAEADModeName(String paramString) { return ("CCM".equals(paramString) || "EAX".equals(paramString) || "GCM".equals(paramString) || "GCM-SIV".equals(paramString) || "OCB".equals(paramString)); }
}
