package org.bouncycastle.tsp.ers;

import java.io.IOException;
import java.util.Collection;
import java.util.Date;
import org.bouncycastle.asn1.tsp.ArchiveTimeStamp;
import org.bouncycastle.asn1.tsp.PartialHashtree;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.cert.X509CertificateHolder;
import org.bouncycastle.cms.SignerInformationVerifier;
import org.bouncycastle.operator.DigestCalculator;
import org.bouncycastle.operator.DigestCalculatorProvider;
import org.bouncycastle.operator.OperatorCreationException;
import org.bouncycastle.tsp.TSPException;
import org.bouncycastle.tsp.TimeStampToken;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Store;

public class ERSArchiveTimeStamp {
  private final ArchiveTimeStamp archiveTimeStamp;
  
  private final DigestCalculator digCalc;
  
  private final TimeStampToken timeStampToken;
  
  private ERSRootNodeCalculator rootNodeCalculator = new BinaryTreeRootCalculator();
  
  public ERSArchiveTimeStamp(byte[] paramArrayOfByte, DigestCalculatorProvider paramDigestCalculatorProvider) throws TSPException, ERSException { this(ArchiveTimeStamp.getInstance(paramArrayOfByte), paramDigestCalculatorProvider); }
  
  public ERSArchiveTimeStamp(ArchiveTimeStamp paramArchiveTimeStamp, DigestCalculatorProvider paramDigestCalculatorProvider) throws TSPException, ERSException {
    try {
      this.archiveTimeStamp = paramArchiveTimeStamp;
      this.timeStampToken = new TimeStampToken(paramArchiveTimeStamp.getTimeStamp());
      this.digCalc = paramDigestCalculatorProvider.get(paramArchiveTimeStamp.getDigestAlgorithmIdentifier());
    } catch (IOException iOException) {
      throw new ERSException(iOException.getMessage(), iOException);
    } catch (OperatorCreationException operatorCreationException) {
      throw new ERSException(operatorCreationException.getMessage(), operatorCreationException);
    } 
  }
  
  ERSArchiveTimeStamp(ArchiveTimeStamp paramArchiveTimeStamp, DigestCalculator paramDigestCalculator, ERSRootNodeCalculator paramERSRootNodeCalculator) throws TSPException, ERSException {
    try {
      this.archiveTimeStamp = paramArchiveTimeStamp;
      this.timeStampToken = new TimeStampToken(paramArchiveTimeStamp.getTimeStamp());
      this.digCalc = paramDigestCalculator;
      this.rootNodeCalculator = paramERSRootNodeCalculator;
    } catch (IOException iOException) {
      throw new ERSException(iOException.getMessage(), iOException);
    } 
  }
  
  public AlgorithmIdentifier getDigestAlgorithmIdentifier() { return this.archiveTimeStamp.getDigestAlgorithmIdentifier(); }
  
  public void validatePresent(ERSData paramERSData, Date paramDate) throws ERSException, OperatorCreationException { validatePresent(paramERSData.getHash(this.digCalc), paramDate); }
  
  public void validatePresent(byte[] paramArrayOfByte, Date paramDate) throws ERSException, OperatorCreationException {
    byte[] arrayOfByte;
    if (this.timeStampToken.getTimeStampInfo().getGenTime().after(paramDate))
      throw new ArchiveTimeStampValidationException("timestamp generation time is in the future"); 
    checkContainsHashValue(paramArrayOfByte, this.digCalc);
    PartialHashtree[] arrayOfPartialHashtree = this.archiveTimeStamp.getReducedHashTree();
    if (arrayOfPartialHashtree != null) {
      arrayOfByte = this.rootNodeCalculator.computeRootHash(this.digCalc, this.archiveTimeStamp.getReducedHashTree());
    } else {
      arrayOfByte = paramArrayOfByte;
    } 
    checkTimeStampValid(this.timeStampToken, arrayOfByte);
  }
  
  public TimeStampToken getTimeStampToken() { return this.timeStampToken; }
  
  public X509CertificateHolder getSigningCertificate() {
    Store store = this.timeStampToken.getCertificates();
    if (store != null) {
      Collection collection = store.getMatches(this.timeStampToken.getSID());
      if (!collection.isEmpty())
        return (X509CertificateHolder)collection.iterator().next(); 
    } 
    return null;
  }
  
  public void validate(SignerInformationVerifier paramSignerInformationVerifier) throws TSPException { this.timeStampToken.validate(paramSignerInformationVerifier); }
  
  void checkContainsHashValue(byte[] paramArrayOfByte, DigestCalculator paramDigestCalculator) throws ArchiveTimeStampValidationException {
    PartialHashtree[] arrayOfPartialHashtree = this.archiveTimeStamp.getReducedHashTree();
    if (arrayOfPartialHashtree != null) {
      for (byte b = 0; b != arrayOfPartialHashtree.length; b++) {
        PartialHashtree partialHashtree = arrayOfPartialHashtree[b];
        if (partialHashtree.containsHash(paramArrayOfByte))
          return; 
        if (partialHashtree.getValueCount() > 1 && Arrays.areEqual(paramArrayOfByte, ERSUtil.calculateBranchHash(paramDigestCalculator, partialHashtree.getValues())))
          return; 
      } 
      throw new ArchiveTimeStampValidationException("object hash not found");
    } 
    if (!Arrays.areEqual(paramArrayOfByte, this.timeStampToken.getTimeStampInfo().getMessageImprintDigest()))
      throw new ArchiveTimeStampValidationException("object hash not found in wrapped timestamp"); 
  }
  
  void checkTimeStampValid(TimeStampToken paramTimeStampToken, byte[] paramArrayOfByte) throws ArchiveTimeStampValidationException {
    if (paramArrayOfByte != null && !Arrays.areEqual(paramArrayOfByte, paramTimeStampToken.getTimeStampInfo().getMessageImprintDigest()))
      throw new ArchiveTimeStampValidationException("timestamp hash does not match root"); 
  }
  
  public Date getGenTime() { return this.timeStampToken.getTimeStampInfo().getGenTime(); }
  
  public Date getExpiryTime() {
    X509CertificateHolder x509CertificateHolder = getSigningCertificate();
    return (x509CertificateHolder != null) ? x509CertificateHolder.getNotAfter() : null;
  }
  
  public ArchiveTimeStamp toASN1Structure() { return this.archiveTimeStamp; }
  
  public byte[] getEncoded() throws IOException { return this.archiveTimeStamp.getEncoded(); }
}
