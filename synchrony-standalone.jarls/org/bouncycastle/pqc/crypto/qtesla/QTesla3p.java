package org.bouncycastle.pqc.crypto.qtesla;

import java.security.SecureRandom;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Pack;

class QTesla3p {
  private static final int PARAM_N = 2048;
  
  private static final int PARAM_Q = 856145921;
  
  private static final int PARAM_Q_LOG = 30;
  
  private static final long PARAM_QINV = 587710463L;
  
  private static final long PARAM_BARR_MULT = 5L;
  
  private static final int PARAM_BARR_DIV = 32;
  
  private static final int PARAM_B = 2097151;
  
  private static final int PARAM_B_BITS = 21;
  
  private static final int PARAM_K = 5;
  
  private static final int PARAM_H = 40;
  
  private static final int PARAM_D = 24;
  
  private static final int PARAM_GEN_A = 180;
  
  private static final int PARAM_KEYGEN_BOUND_E = 901;
  
  private static final int PARAM_E = 901;
  
  private static final int PARAM_KEYGEN_BOUND_S = 901;
  
  private static final int PARAM_S = 901;
  
  private static final int PARAM_R2_INVN = 513161157;
  
  private static final int CRYPTO_RANDOMBYTES = 32;
  
  private static final int CRYPTO_SEEDBYTES = 32;
  
  private static final int CRYPTO_C_BYTES = 32;
  
  private static final int HM_BYTES = 40;
  
  private static final int RADIX32 = 32;
  
  static final int CRYPTO_BYTES = 5664;
  
  static final int CRYPTO_SECRETKEYBYTES = 12392;
  
  static final int CRYPTO_PUBLICKEYBYTES = 38432;
  
  private static final int maskb1 = 4194303;
  
  private static int NBLOCKS_SHAKE = 56;
  
  private static int BPLUS1BYTES = 3;
  
  static int generateKeyPair(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, SecureRandom paramSecureRandom) {
    byte b1 = 0;
    byte[] arrayOfByte1 = new byte[32];
    byte[] arrayOfByte2 = new byte[256];
    long[] arrayOfLong1 = new long[2048];
    long[] arrayOfLong2 = new long[10240];
    long[] arrayOfLong3 = new long[10240];
    long[] arrayOfLong4 = new long[10240];
    long[] arrayOfLong5 = new long[2048];
    paramSecureRandom.nextBytes(arrayOfByte1);
    HashUtils.secureHashAlgorithmKECCAK256(arrayOfByte2, 0, 256, arrayOfByte1, 0, 32);
    byte b2;
    for (b2 = 0; b2 < 5; b2++) {
      do {
        Gaussian.sample_gauss_poly(++b1, arrayOfByte2, b2 * 32, arrayOfLong2, b2 * 'ࠀ');
      } while (checkPolynomial(arrayOfLong2, b2 * 'ࠀ', 901));
    } 
    do {
      Gaussian.sample_gauss_poly(++b1, arrayOfByte2, 160, arrayOfLong1, 0);
    } while (checkPolynomial(arrayOfLong1, 0, 901));
    QTesla3PPolynomial.poly_uniform(arrayOfLong3, arrayOfByte2, 192);
    QTesla3PPolynomial.poly_ntt(arrayOfLong5, arrayOfLong1);
    for (b2 = 0; b2 < 5; b2++) {
      QTesla3PPolynomial.poly_mul(arrayOfLong4, b2 * 'ࠀ', arrayOfLong3, b2 * 'ࠀ', arrayOfLong5);
      QTesla3PPolynomial.poly_add_correct(arrayOfLong4, b2 * 'ࠀ', arrayOfLong4, b2 * 'ࠀ', arrayOfLong2, b2 * 'ࠀ');
    } 
    encodePublicKey(paramArrayOfByte1, arrayOfLong4, arrayOfByte2, 192);
    encodePrivateKey(paramArrayOfByte2, arrayOfLong1, arrayOfLong2, arrayOfByte2, 192, paramArrayOfByte1);
    return 0;
  }
  
  static int generateSignature(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt1, int paramInt2, byte[] paramArrayOfByte3, SecureRandom paramSecureRandom) {
    byte[] arrayOfByte1 = new byte[32];
    byte[] arrayOfByte2 = new byte[32];
    byte[] arrayOfByte3 = new byte[144];
    int[] arrayOfInt = new int[40];
    short[] arrayOfShort = new short[40];
    long[] arrayOfLong1 = new long[2048];
    long[] arrayOfLong2 = new long[2048];
    long[] arrayOfLong3 = new long[2048];
    long[] arrayOfLong4 = new long[2048];
    long[] arrayOfLong5 = new long[10240];
    long[] arrayOfLong6 = new long[10240];
    long[] arrayOfLong7 = new long[10240];
    byte b = 0;
    boolean bool = false;
    System.arraycopy(paramArrayOfByte3, 12320, arrayOfByte3, 0, 32);
    byte[] arrayOfByte4 = new byte[32];
    paramSecureRandom.nextBytes(arrayOfByte4);
    System.arraycopy(arrayOfByte4, 0, arrayOfByte3, 32, 32);
    HashUtils.secureHashAlgorithmKECCAK256(arrayOfByte3, 64, 40, paramArrayOfByte2, 0, paramInt2);
    HashUtils.secureHashAlgorithmKECCAK256(arrayOfByte2, 0, 32, arrayOfByte3, 0, arrayOfByte3.length - 40);
    System.arraycopy(paramArrayOfByte3, 12352, arrayOfByte3, arrayOfByte3.length - 40, 40);
    QTesla3PPolynomial.poly_uniform(arrayOfLong7, paramArrayOfByte3, 12288);
    while (true) {
      sample_y(arrayOfLong1, arrayOfByte2, 0, ++b);
      QTesla3PPolynomial.poly_ntt(arrayOfLong2, arrayOfLong1);
      byte b1;
      for (b1 = 0; b1 < 5; b1++)
        QTesla3PPolynomial.poly_mul(arrayOfLong5, b1 * 'ࠀ', arrayOfLong7, b1 * 'ࠀ', arrayOfLong2); 
      hashFunction(arrayOfByte1, 0, arrayOfLong5, arrayOfByte3, 64);
      encodeC(arrayOfInt, arrayOfShort, arrayOfByte1, 0);
      QTesla3PPolynomial.sparse_mul8(arrayOfLong3, paramArrayOfByte3, arrayOfInt, arrayOfShort);
      QTesla3PPolynomial.poly_add(arrayOfLong4, arrayOfLong1, arrayOfLong3);
      if (testRejection(arrayOfLong4))
        continue; 
      for (b1 = 0; b1 < 5; b1++) {
        QTesla3PPolynomial.sparse_mul8(arrayOfLong6, b1 * 'ࠀ', paramArrayOfByte3, 'ࠀ' * (b1 + 1), arrayOfInt, arrayOfShort);
        QTesla3PPolynomial.poly_sub(arrayOfLong5, b1 * 'ࠀ', arrayOfLong5, b1 * 'ࠀ', arrayOfLong6, b1 * 'ࠀ');
        bool = test_correctness(arrayOfLong5, b1 * 'ࠀ');
        if (bool)
          break; 
      } 
      if (bool)
        continue; 
      break;
    } 
    encodeSignature(paramArrayOfByte1, 0, arrayOfByte1, 0, arrayOfLong4);
    return 0;
  }
  
  static int verifying(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt1, int paramInt2, byte[] paramArrayOfByte3) {
    byte[] arrayOfByte1 = new byte[32];
    byte[] arrayOfByte2 = new byte[32];
    byte[] arrayOfByte3 = new byte[32];
    byte[] arrayOfByte4 = new byte[80];
    int[] arrayOfInt1 = new int[40];
    short[] arrayOfShort = new short[40];
    int[] arrayOfInt2 = new int[10240];
    long[] arrayOfLong1 = new long[10240];
    long[] arrayOfLong2 = new long[10240];
    long[] arrayOfLong3 = new long[10240];
    long[] arrayOfLong4 = new long[2048];
    long[] arrayOfLong5 = new long[2048];
    byte b = 0;
    if (paramInt2 != 5664)
      return -1; 
    decodeSignature(arrayOfByte1, arrayOfLong4, paramArrayOfByte2, paramInt1);
    if (testZ(arrayOfLong4))
      return -2; 
    decodePublicKey(arrayOfInt2, arrayOfByte3, 0, paramArrayOfByte3);
    HashUtils.secureHashAlgorithmKECCAK256(arrayOfByte4, 0, 40, paramArrayOfByte1, 0, paramArrayOfByte1.length);
    HashUtils.secureHashAlgorithmKECCAK256(arrayOfByte4, 40, 40, paramArrayOfByte3, 0, 38400);
    QTesla3PPolynomial.poly_uniform(arrayOfLong2, arrayOfByte3, 0);
    encodeC(arrayOfInt1, arrayOfShort, arrayOfByte1, 0);
    QTesla3PPolynomial.poly_ntt(arrayOfLong5, arrayOfLong4);
    for (b = 0; b < 5; b++) {
      QTesla3PPolynomial.sparse_mul32(arrayOfLong3, b * 'ࠀ', arrayOfInt2, b * 'ࠀ', arrayOfInt1, arrayOfShort);
      QTesla3PPolynomial.poly_mul(arrayOfLong1, b * 'ࠀ', arrayOfLong2, b * 'ࠀ', arrayOfLong5);
      QTesla3PPolynomial.poly_sub(arrayOfLong1, b * 'ࠀ', arrayOfLong1, b * 'ࠀ', arrayOfLong3, b * 'ࠀ');
    } 
    hashFunction(arrayOfByte2, 0, arrayOfLong1, arrayOfByte4, 0);
    return !memoryEqual(arrayOfByte1, 0, arrayOfByte2, 0, 32) ? -3 : 0;
  }
  
  static void encodePrivateKey(byte[] paramArrayOfByte1, long[] paramArrayOfLong1, long[] paramArrayOfLong2, byte[] paramArrayOfByte2, int paramInt, byte[] paramArrayOfByte3) {
    byte b = 0;
    char c2 = Character.MIN_VALUE;
    char c1;
    for (c1 = Character.MIN_VALUE; c1 < 'ࠀ'; c1++)
      paramArrayOfByte1[c2 + c1] = (byte)(int)paramArrayOfLong1[c1]; 
    c2 += 2048;
    for (b = 0; b < 5; b++) {
      for (c1 = Character.MIN_VALUE; c1 < 'ࠀ'; c1++)
        paramArrayOfByte1[c2 + b * 'ࠀ' + c1] = (byte)(int)paramArrayOfLong2[b * 'ࠀ' + c1]; 
    } 
    c2 += '⠀';
    System.arraycopy(paramArrayOfByte2, paramInt, paramArrayOfByte1, c2, 64);
    c2 += '@';
    HashUtils.secureHashAlgorithmKECCAK256(paramArrayOfByte1, c2, 40, paramArrayOfByte3, 0, 38400);
    c2 += '(';
  }
  
  static void encodePublicKey(byte[] paramArrayOfByte1, long[] paramArrayOfLong, byte[] paramArrayOfByte2, int paramInt) {
    boolean bool = false;
    for (byte b = 0; b < '▀'; b += 15) {
      at(paramArrayOfByte1, b, 0, (int)(paramArrayOfLong[bool] | paramArrayOfLong[bool + true] << 30));
      at(paramArrayOfByte1, b, 1, (int)(paramArrayOfLong[bool + true] >> 2 | paramArrayOfLong[bool + 2] << 28));
      at(paramArrayOfByte1, b, 2, (int)(paramArrayOfLong[bool + 2] >> 4 | paramArrayOfLong[bool + 3] << 26));
      at(paramArrayOfByte1, b, 3, (int)(paramArrayOfLong[bool + 3] >> 6 | paramArrayOfLong[bool + 4] << 24));
      at(paramArrayOfByte1, b, 4, (int)(paramArrayOfLong[bool + 4] >> 8 | paramArrayOfLong[bool + 5] << 22));
      at(paramArrayOfByte1, b, 5, (int)(paramArrayOfLong[bool + 5] >> 10 | paramArrayOfLong[bool + 6] << 20));
      at(paramArrayOfByte1, b, 6, (int)(paramArrayOfLong[bool + 6] >> 12 | paramArrayOfLong[bool + 7] << 18));
      at(paramArrayOfByte1, b, 7, (int)(paramArrayOfLong[bool + 7] >> 14 | paramArrayOfLong[bool + 8] << 16));
      at(paramArrayOfByte1, b, 8, (int)(paramArrayOfLong[bool + 8] >> 16 | paramArrayOfLong[bool + 9] << 14));
      at(paramArrayOfByte1, b, 9, (int)(paramArrayOfLong[bool + 9] >> 18 | paramArrayOfLong[bool + 10] << 12));
      at(paramArrayOfByte1, b, 10, (int)(paramArrayOfLong[bool + 10] >> 20 | paramArrayOfLong[bool + 11] << 10));
      at(paramArrayOfByte1, b, 11, (int)(paramArrayOfLong[bool + 11] >> 22 | paramArrayOfLong[bool + 12] << 8));
      at(paramArrayOfByte1, b, 12, (int)(paramArrayOfLong[bool + 12] >> 24 | paramArrayOfLong[bool + 13] << 6));
      at(paramArrayOfByte1, b, 13, (int)(paramArrayOfLong[bool + 13] >> 26 | paramArrayOfLong[bool + 14] << 4));
      at(paramArrayOfByte1, b, 14, (int)(paramArrayOfLong[bool + 14] >> 28 | paramArrayOfLong[bool + 15] << 2));
      bool += true;
    } 
    System.arraycopy(paramArrayOfByte2, paramInt, paramArrayOfByte1, 38400, 32);
  }
  
  static void decodePublicKey(int[] paramArrayOfInt, byte[] paramArrayOfByte1, int paramInt, byte[] paramArrayOfByte2) {
    byte b = 0;
    byte[] arrayOfByte = paramArrayOfByte2;
    int i = 1073741823;
    for (boolean bool = false; bool < '⠀'; bool += true) {
      paramArrayOfInt[bool] = at(arrayOfByte, b, 0) & i;
      paramArrayOfInt[bool + true] = (at(arrayOfByte, b, 0) >>> 30 | at(arrayOfByte, b, 1) << 2) & i;
      paramArrayOfInt[bool + 2] = (at(arrayOfByte, b, 1) >>> 28 | at(arrayOfByte, b, 2) << 4) & i;
      paramArrayOfInt[bool + 3] = (at(arrayOfByte, b, 2) >>> 26 | at(arrayOfByte, b, 3) << 6) & i;
      paramArrayOfInt[bool + 4] = (at(arrayOfByte, b, 3) >>> 24 | at(arrayOfByte, b, 4) << 8) & i;
      paramArrayOfInt[bool + 5] = (at(arrayOfByte, b, 4) >>> 22 | at(arrayOfByte, b, 5) << 10) & i;
      paramArrayOfInt[bool + 6] = (at(arrayOfByte, b, 5) >>> 20 | at(arrayOfByte, b, 6) << 12) & i;
      paramArrayOfInt[bool + 7] = (at(arrayOfByte, b, 6) >>> 18 | at(arrayOfByte, b, 7) << 14) & i;
      paramArrayOfInt[bool + 8] = (at(arrayOfByte, b, 7) >>> 16 | at(arrayOfByte, b, 8) << 16) & i;
      paramArrayOfInt[bool + 9] = (at(arrayOfByte, b, 8) >>> 14 | at(arrayOfByte, b, 9) << 18) & i;
      paramArrayOfInt[bool + 10] = (at(arrayOfByte, b, 9) >>> 12 | at(arrayOfByte, b, 10) << 20) & i;
      paramArrayOfInt[bool + 11] = (at(arrayOfByte, b, 10) >>> 10 | at(arrayOfByte, b, 11) << 22) & i;
      paramArrayOfInt[bool + 12] = (at(arrayOfByte, b, 11) >>> 8 | at(arrayOfByte, b, 12) << 24) & i;
      paramArrayOfInt[bool + 13] = (at(arrayOfByte, b, 12) >>> 6 | at(arrayOfByte, b, 13) << 26) & i;
      paramArrayOfInt[bool + 14] = (at(arrayOfByte, b, 13) >>> 4 | at(arrayOfByte, b, 14) << 28) & i;
      paramArrayOfInt[bool + 15] = at(arrayOfByte, b, 14) >>> 2 & i;
      b += 15;
    } 
    System.arraycopy(paramArrayOfByte2, 38400, paramArrayOfByte1, paramInt, 32);
  }
  
  private static boolean testZ(long[] paramArrayOfLong) {
    for (byte b = 0; b < 'ࠀ'; b++) {
      if (paramArrayOfLong[b] < -2096250L || paramArrayOfLong[b] > 2096250L)
        return true; 
    } 
    return false;
  }
  
  static void encodeSignature(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, long[] paramArrayOfLong) {
    boolean bool = false;
    for (byte b = 0; b < 'ր'; b += 11) {
      at(paramArrayOfByte1, b, 0, (int)(paramArrayOfLong[bool + false] & 0x3FFFFFL | paramArrayOfLong[bool + true] << 22));
      at(paramArrayOfByte1, b, 1, (int)(paramArrayOfLong[bool + true] >>> 10 & 0xFFFL | paramArrayOfLong[bool + 2] << 12));
      at(paramArrayOfByte1, b, 2, (int)(paramArrayOfLong[bool + 2] >>> 20 & 0x3L | (paramArrayOfLong[bool + 3] & 0x3FFFFFL) << 2 | paramArrayOfLong[bool + 4] << 24));
      at(paramArrayOfByte1, b, 3, (int)(paramArrayOfLong[bool + 4] >>> 8 & 0x3FFFL | paramArrayOfLong[bool + 5] << 14));
      at(paramArrayOfByte1, b, 4, (int)(paramArrayOfLong[bool + 5] >>> 18 & 0xFL | (paramArrayOfLong[bool + 6] & 0x3FFFFFL) << 4 | paramArrayOfLong[bool + 7] << 26));
      at(paramArrayOfByte1, b, 5, (int)(paramArrayOfLong[bool + 7] >>> 6 & 0xFFFFL | paramArrayOfLong[bool + 8] << 16));
      at(paramArrayOfByte1, b, 6, (int)(paramArrayOfLong[bool + 8] >>> 16 & 0x3FL | (paramArrayOfLong[bool + 9] & 0x3FFFFFL) << 6 | paramArrayOfLong[bool + 10] << 28));
      at(paramArrayOfByte1, b, 7, (int)(paramArrayOfLong[bool + 10] >>> 4 & 0x3FFFFL | paramArrayOfLong[bool + 11] << 18));
      at(paramArrayOfByte1, b, 8, (int)(paramArrayOfLong[bool + 11] >>> 14 & 0xFFL | (paramArrayOfLong[bool + 12] & 0x3FFFFFL) << 8 | paramArrayOfLong[bool + 13] << 30));
      at(paramArrayOfByte1, b, 9, (int)(paramArrayOfLong[bool + 13] >>> 2 & 0xFFFFFL | paramArrayOfLong[bool + 14] << 20));
      at(paramArrayOfByte1, b, 10, (int)(paramArrayOfLong[bool + 14] >>> 12 & 0x3FFL | paramArrayOfLong[bool + 15] << 10));
      bool += true;
    } 
    System.arraycopy(paramArrayOfByte2, paramInt2, paramArrayOfByte1, paramInt1 + 5632, 32);
  }
  
  static void decodeSignature(byte[] paramArrayOfByte1, long[] paramArrayOfLong, byte[] paramArrayOfByte2, int paramInt) {
    byte b = 0;
    for (boolean bool = false; bool < 'ࠀ'; bool += true) {
      int i = at(paramArrayOfByte2, b, 0);
      int j = at(paramArrayOfByte2, b, 1);
      int k = at(paramArrayOfByte2, b, 2);
      int m = at(paramArrayOfByte2, b, 3);
      int n = at(paramArrayOfByte2, b, 4);
      int i1 = at(paramArrayOfByte2, b, 5);
      int i2 = at(paramArrayOfByte2, b, 6);
      int i3 = at(paramArrayOfByte2, b, 7);
      int i4 = at(paramArrayOfByte2, b, 8);
      int i5 = at(paramArrayOfByte2, b, 9);
      int i6 = at(paramArrayOfByte2, b, 10);
      paramArrayOfLong[bool] = (i << 10 >> 10);
      paramArrayOfLong[bool + true] = (i >>> 22 | j << 20 >> 10);
      paramArrayOfLong[bool + 2] = (j >>> 12 | k << 30 >> 10);
      paramArrayOfLong[bool + 3] = (k << 8 >> 10);
      paramArrayOfLong[bool + 4] = (k >>> 24 | m << 18 >> 10);
      paramArrayOfLong[bool + 5] = (m >>> 14 | n << 28 >> 10);
      paramArrayOfLong[bool + 6] = (n << 6 >> 10);
      paramArrayOfLong[bool + 7] = (n >>> 26 | i1 << 16 >> 10);
      paramArrayOfLong[bool + 8] = (i1 >>> 16 | i2 << 26 >> 10);
      paramArrayOfLong[bool + 9] = (i2 << 4 >> 10);
      paramArrayOfLong[bool + 10] = (i2 >>> 28 | i3 << 14 >> 10);
      paramArrayOfLong[bool + 11] = (i3 >>> 18 | i4 << 24 >> 10);
      paramArrayOfLong[bool + 12] = (i4 << 2 >> 10);
      paramArrayOfLong[bool + 13] = (i4 >>> 30 | i5 << 12 >> 10);
      paramArrayOfLong[bool + 14] = (i5 >>> 20 | i6 << 22 >> 10);
      paramArrayOfLong[bool + 15] = (i6 >> 10);
      b += 11;
    } 
    System.arraycopy(paramArrayOfByte2, paramInt + 5632, paramArrayOfByte1, 0, 32);
  }
  
  static void encodeC(int[] paramArrayOfInt, short[] paramArrayOfShort, byte[] paramArrayOfByte, int paramInt) {
    boolean bool = false;
    short s = 0;
    short[] arrayOfShort = new short[2048];
    byte[] arrayOfByte = new byte[168];
    s = (short)(s + true);
    HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(arrayOfByte, 0, 168, s, paramArrayOfByte, paramInt, 32);
    Arrays.fill(arrayOfShort, (short)0);
    byte b = 0;
    while (b < 40) {
      if (bool > '¥') {
        s = (short)(s + 1);
        HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(arrayOfByte, 0, 168, s, paramArrayOfByte, paramInt, 32);
        bool = false;
      } 
      byte b1 = arrayOfByte[bool] << 8 | arrayOfByte[bool + true] & 0xFF;
      b1 &= 0x7FF;
      if (arrayOfShort[b1] == 0) {
        if ((arrayOfByte[bool + 2] & true) == 1) {
          arrayOfShort[b1] = -1;
        } else {
          arrayOfShort[b1] = 1;
        } 
        paramArrayOfInt[b] = b1;
        paramArrayOfShort[b] = arrayOfShort[b1];
        b++;
      } 
      bool += true;
    } 
  }
  
  private static void hashFunction(byte[] paramArrayOfByte1, int paramInt1, long[] paramArrayOfLong, byte[] paramArrayOfByte2, int paramInt2) {
    byte[] arrayOfByte = new byte[10320];
    for (byte b = 0; b < 5; b++) {
      char c = b * 'ࠀ';
      for (byte b1 = 0; b1 < 'ࠀ'; b1++) {
        int k = (int)paramArrayOfLong[c];
        int i = 428072960 - k >> 31;
        k = k - 856145921 & i | k & (i ^ 0xFFFFFFFF);
        int j = k & 0xFFFFFF;
        i = 8388608 - j >> 31;
        j = j - 16777216 & i | j & (i ^ 0xFFFFFFFF);
        arrayOfByte[c++] = (byte)(k - j >> 24);
      } 
    } 
    System.arraycopy(paramArrayOfByte2, paramInt2, arrayOfByte, 10240, 80);
    HashUtils.secureHashAlgorithmKECCAK256(paramArrayOfByte1, paramInt1, 32, arrayOfByte, 0, arrayOfByte.length);
  }
  
  static int lE24BitToInt(byte[] paramArrayOfByte, int paramInt) {
    null = paramArrayOfByte[paramInt] & 0xFF;
    null |= (paramArrayOfByte[++paramInt] & 0xFF) << 8;
    return (paramArrayOfByte[++paramInt] & 0xFF) << 16;
  }
  
  static void sample_y(long[] paramArrayOfLong, byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    byte b = 0;
    int i = 0;
    int j = 2048;
    byte[] arrayOfByte = new byte[2048 * BPLUS1BYTES + 1];
    int k = BPLUS1BYTES;
    short s = (short)(paramInt2 << 8);
    s = (short)(s + 1);
    HashUtils.customizableSecureHashAlgorithmKECCAK256Simple(arrayOfByte, 0, 2048 * k, s, paramArrayOfByte, paramInt1, 32);
    while (b < 'ࠀ') {
      if (i >= j * k) {
        j = NBLOCKS_SHAKE;
        s = (short)(s + 1);
        HashUtils.customizableSecureHashAlgorithmKECCAK256Simple(arrayOfByte, 0, 2048 * k, s, paramArrayOfByte, paramInt1, 32);
        i = 0;
      } 
      paramArrayOfLong[b] = (lE24BitToInt(arrayOfByte, i) & 0x3FFFFF);
      paramArrayOfLong[b] = paramArrayOfLong[b] - 2097151L;
      if (paramArrayOfLong[b] != 2097152L)
        b++; 
      i += k;
    } 
  }
  
  private static void at(byte[] paramArrayOfByte, int paramInt1, int paramInt2, int paramInt3) { Pack.intToLittleEndian(paramInt3, paramArrayOfByte, paramInt1 * 4 + paramInt2 * 4); }
  
  private static int at(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    int i = paramInt1 * 4 + paramInt2 * 4;
    null = paramArrayOfByte[i] & 0xFF;
    null |= (paramArrayOfByte[++i] & 0xFF) << 8;
    null |= (paramArrayOfByte[++i] & 0xFF) << 16;
    return paramArrayOfByte[++i] << 24;
  }
  
  static boolean test_correctness(long[] paramArrayOfLong, int paramInt) {
    for (int i = 0; i < 2048; i++) {
      int j = (int)(428072960L - paramArrayOfLong[paramInt + i]) >> 31;
      int m = (int)(paramArrayOfLong[paramInt + i] - 856145921L & j | paramArrayOfLong[paramInt + i] & (j ^ 0xFFFFFFFF));
      int n = (absolute(m) - 428072059 ^ 0xFFFFFFFF) >>> 31;
      int k = m;
      m = m + 8388608 - 1 >> 24;
      m = k - (m << 24);
      int i1 = (absolute(m) - 8387707 ^ 0xFFFFFFFF) >>> 31;
      if ((n | i1) == 1)
        return true; 
    } 
    return false;
  }
  
  private static boolean testRejection(long[] paramArrayOfLong) {
    int i = 0;
    for (byte b = 0; b < 'ࠀ'; b++)
      i = (int)(i | 2096250L - absolute(paramArrayOfLong[b])); 
    return (i >>> 31 > 0);
  }
  
  private static int absolute(int paramInt) { return (paramInt >> 31 ^ paramInt) - (paramInt >> 31); }
  
  private static long absolute(long paramLong) { return (paramLong >> 63 ^ paramLong) - (paramLong >> 63); }
  
  private static boolean checkPolynomial(long[] paramArrayOfLong, int paramInt1, int paramInt2) {
    int j = 0;
    char c = 'ࠀ';
    long[] arrayOfLong = new long[2048];
    int i;
    for (i = 0; i < 2048; i++)
      arrayOfLong[i] = absolute((int)paramArrayOfLong[paramInt1 + i]); 
    for (i = 0; i < 40; i++) {
      for (byte b = 0; b < c - '\001'; b++) {
        long l2 = arrayOfLong[b + true] - arrayOfLong[b] >> 31;
        long l1 = arrayOfLong[b + true] & l2 | arrayOfLong[b] & (l2 ^ 0xFFFFFFFFFFFFFFFFL);
        arrayOfLong[b + true] = arrayOfLong[b] & l2 | arrayOfLong[b + true] & (l2 ^ 0xFFFFFFFFFFFFFFFFL);
        arrayOfLong[b] = l1;
      } 
      j += (int)arrayOfLong[c - '\001'];
      c--;
    } 
    return (j > paramInt2);
  }
  
  static boolean memoryEqual(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, int paramInt3) {
    if (paramInt1 + paramInt3 <= paramArrayOfByte1.length && paramInt2 + paramInt3 <= paramArrayOfByte2.length) {
      for (int i = 0; i < paramInt3; i++) {
        if (paramArrayOfByte1[paramInt1 + i] != paramArrayOfByte2[paramInt2 + i])
          return false; 
      } 
      return true;
    } 
    return false;
  }
}
