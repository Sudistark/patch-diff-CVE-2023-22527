package org.bouncycastle.pqc.crypto.newhope;

import org.bouncycastle.crypto.digests.SHAKEDigest;
import org.bouncycastle.util.Pack;

class Poly {
  static void add(short[] paramArrayOfShort1, short[] paramArrayOfShort2, short[] paramArrayOfShort3) {
    for (byte b = 0; b < 'Ѐ'; b++)
      paramArrayOfShort3[b] = Reduce.barrett((short)(paramArrayOfShort1[b] + paramArrayOfShort2[b])); 
  }
  
  static void fromBytes(short[] paramArrayOfShort, byte[] paramArrayOfByte) {
    for (byte b = 0; b < 'Ā'; b++) {
      byte b1 = 7 * b;
      byte b2 = paramArrayOfByte[b1 + 0] & 0xFF;
      byte b3 = paramArrayOfByte[b1 + 1] & 0xFF;
      byte b4 = paramArrayOfByte[b1 + 2] & 0xFF;
      byte b5 = paramArrayOfByte[b1 + 3] & 0xFF;
      byte b6 = paramArrayOfByte[b1 + 4] & 0xFF;
      byte b7 = paramArrayOfByte[b1 + 5] & 0xFF;
      byte b8 = paramArrayOfByte[b1 + 6] & 0xFF;
      byte b9 = 4 * b;
      paramArrayOfShort[b9 + 0] = (short)(b2 | (b3 & 0x3F) << 8);
      paramArrayOfShort[b9 + 1] = (short)(b3 >>> 6 | b4 << 2 | (b5 & 0xF) << 10);
      paramArrayOfShort[b9 + 2] = (short)(b5 >>> 4 | b6 << 4 | (b7 & 0x3) << 12);
      paramArrayOfShort[b9 + 3] = (short)(b7 >>> 2 | b8 << 6);
    } 
  }
  
  static void fromNTT(short[] paramArrayOfShort) {
    NTT.bitReverse(paramArrayOfShort);
    NTT.core(paramArrayOfShort, Precomp.OMEGAS_INV_MONTGOMERY);
    NTT.mulCoefficients(paramArrayOfShort, Precomp.PSIS_INV_MONTGOMERY);
  }
  
  static void getNoise(short[] paramArrayOfShort, byte[] paramArrayOfByte, byte paramByte) {
    byte[] arrayOfByte1 = new byte[8];
    arrayOfByte1[0] = paramByte;
    byte[] arrayOfByte2 = new byte[4096];
    ChaCha20.process(paramArrayOfByte, arrayOfByte1, arrayOfByte2, 0, arrayOfByte2.length);
    for (byte b = 0; b < 'Ѐ'; b++) {
      int i = Pack.bigEndianToInt(arrayOfByte2, b * 4);
      int j = 0;
      int k;
      for (k = 0; k < 8; k++)
        j += (i >> k & 0x1010101); 
      k = (j >>> 24) + (j >>> 0) & 0xFF;
      int m = (j >>> 16) + (j >>> 8) & 0xFF;
      paramArrayOfShort[b] = (short)(k + 12289 - m);
    } 
  }
  
  static void pointWise(short[] paramArrayOfShort1, short[] paramArrayOfShort2, short[] paramArrayOfShort3) {
    for (byte b = 0; b < 'Ѐ'; b++) {
      short s1 = paramArrayOfShort1[b] & 0xFFFF;
      short s2 = paramArrayOfShort2[b] & 0xFFFF;
      short s3 = Reduce.montgomery(3186 * s2);
      paramArrayOfShort3[b] = Reduce.montgomery(s1 * (s3 & 0xFFFF));
    } 
  }
  
  static void toBytes(byte[] paramArrayOfByte, short[] paramArrayOfShort) {
    for (byte b = 0; b < 'Ā'; b++) {
      byte b1 = 4 * b;
      short s1 = normalize(paramArrayOfShort[b1 + 0]);
      short s2 = normalize(paramArrayOfShort[b1 + 1]);
      short s3 = normalize(paramArrayOfShort[b1 + 2]);
      short s4 = normalize(paramArrayOfShort[b1 + 3]);
      byte b2 = 7 * b;
      paramArrayOfByte[b2 + 0] = (byte)s1;
      paramArrayOfByte[b2 + 1] = (byte)(s1 >> 8 | s2 << 6);
      paramArrayOfByte[b2 + 2] = (byte)(s2 >> 2);
      paramArrayOfByte[b2 + 3] = (byte)(s2 >> 10 | s3 << 4);
      paramArrayOfByte[b2 + 4] = (byte)(s3 >> 4);
      paramArrayOfByte[b2 + 5] = (byte)(s3 >> 12 | s4 << 2);
      paramArrayOfByte[b2 + 6] = (byte)(s4 >> 6);
    } 
  }
  
  static void toNTT(short[] paramArrayOfShort) {
    NTT.mulCoefficients(paramArrayOfShort, Precomp.PSIS_BITREV_MONTGOMERY);
    NTT.core(paramArrayOfShort, Precomp.OMEGAS_MONTGOMERY);
  }
  
  static void uniform(short[] paramArrayOfShort, byte[] paramArrayOfByte) {
    SHAKEDigest sHAKEDigest = new SHAKEDigest(128);
    sHAKEDigest.update(paramArrayOfByte, 0, paramArrayOfByte.length);
    byte b = 0;
    while (true) {
      byte[] arrayOfByte = new byte[256];
      sHAKEDigest.doOutput(arrayOfByte, 0, arrayOfByte.length);
      for (boolean bool = false; bool < arrayOfByte.length; bool += true) {
        byte b1 = arrayOfByte[bool] & 0xFF | (arrayOfByte[bool + true] & 0xFF) << 8;
        if (b1 < 61445) {
          paramArrayOfShort[b++] = (short)b1;
          if (b == 'Ѐ')
            return; 
        } 
      } 
    } 
  }
  
  private static short normalize(short paramShort) {
    short s1 = Reduce.barrett(paramShort);
    short s2 = s1 - 12289;
    short s3 = s2 >> 31;
    s1 = s2 ^ (s1 ^ s2) & s3;
    return (short)s1;
  }
}
