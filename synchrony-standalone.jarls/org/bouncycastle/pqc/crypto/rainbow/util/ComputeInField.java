package org.bouncycastle.pqc.crypto.rainbow.util;

public class ComputeInField {
  private short[][] A;
  
  short[] x;
  
  public short[] solveEquation(short[][] paramArrayOfShort, short[] paramArrayOfShort1) {
    if (paramArrayOfShort.length != paramArrayOfShort1.length)
      return null; 
    try {
      this.A = new short[paramArrayOfShort.length][paramArrayOfShort.length + 1];
      this.x = new short[paramArrayOfShort.length];
      byte b;
      for (b = 0; b < paramArrayOfShort.length; b++) {
        for (byte b1 = 0; b1 < paramArrayOfShort[0].length; b1++)
          this.A[b][b1] = paramArrayOfShort[b][b1]; 
      } 
      for (b = 0; b < paramArrayOfShort1.length; b++)
        this.A[b][paramArrayOfShort1.length] = GF2Field.addElem(paramArrayOfShort1[b], this.A[b][paramArrayOfShort1.length]); 
      computeZerosUnder(false);
      substitute();
      return this.x;
    } catch (RuntimeException runtimeException) {
      return null;
    } 
  }
  
  public short[][] inverse(short[][] paramArrayOfShort) {
    try {
      this.A = new short[paramArrayOfShort.length][2 * paramArrayOfShort.length];
      if (paramArrayOfShort.length != paramArrayOfShort[0].length)
        throw new RuntimeException("The matrix is not invertible. Please choose another one!"); 
      int i;
      for (i = 0; i < paramArrayOfShort.length; i++) {
        int j;
        for (j = 0; j < paramArrayOfShort.length; j++)
          this.A[i][j] = paramArrayOfShort[i][j]; 
        for (j = paramArrayOfShort.length; j < 2 * paramArrayOfShort.length; j++)
          this.A[i][j] = 0; 
        this.A[i][i + this.A.length] = 1;
      } 
      computeZerosUnder(true);
      for (i = 0; i < this.A.length; i++) {
        short s = GF2Field.invElem(this.A[i][i]);
        for (int j = i; j < 2 * this.A.length; j++)
          this.A[i][j] = GF2Field.multElem(this.A[i][j], s); 
      } 
      computeZerosAbove();
      short[][] arrayOfShort = new short[this.A.length][this.A.length];
      for (i = 0; i < this.A.length; i++) {
        for (int j = this.A.length; j < 2 * this.A.length; j++)
          arrayOfShort[i][j - this.A.length] = this.A[i][j]; 
      } 
      return arrayOfShort;
    } catch (RuntimeException runtimeException) {
      return (short[][])null;
    } 
  }
  
  private void computeZerosUnder(boolean paramBoolean) throws RuntimeException {
    int i;
    short s = 0;
    if (paramBoolean) {
      i = 2 * this.A.length;
    } else {
      i = this.A.length + 1;
    } 
    for (byte b = 0; b < this.A.length - 1; b++) {
      for (byte b1 = b + true; b1 < this.A.length; b1++) {
        short s1 = this.A[b1][b];
        short s2 = GF2Field.invElem(this.A[b][b]);
        if (s2 == 0)
          throw new IllegalStateException("Matrix not invertible! We have to choose another one!"); 
        for (byte b2 = b; b2 < i; b2++) {
          s = GF2Field.multElem(this.A[b][b2], s2);
          s = GF2Field.multElem(s1, s);
          this.A[b1][b2] = GF2Field.addElem(this.A[b1][b2], s);
        } 
      } 
    } 
  }
  
  private void computeZerosAbove() {
    short s = 0;
    for (int i = this.A.length - 1; i > 0; i--) {
      for (int j = i - 1; j >= 0; j--) {
        short s1 = this.A[j][i];
        short s2 = GF2Field.invElem(this.A[i][i]);
        if (s2 == 0)
          throw new RuntimeException("The matrix is not invertible"); 
        for (int k = i; k < 2 * this.A.length; k++) {
          s = GF2Field.multElem(this.A[i][k], s2);
          s = GF2Field.multElem(s1, s);
          this.A[j][k] = GF2Field.addElem(this.A[j][k], s);
        } 
      } 
    } 
  }
  
  private void substitute() {
    short s = GF2Field.invElem(this.A[this.A.length - 1][this.A.length - 1]);
    if (s == 0)
      throw new IllegalStateException("The equation system is not solvable"); 
    this.x[this.A.length - 1] = GF2Field.multElem(this.A[this.A.length - 1][this.A.length], s);
    for (int i = this.A.length - 2; i >= 0; i--) {
      short s1 = this.A[i][this.A.length];
      for (int j = this.A.length - 1; j > i; j--) {
        s = GF2Field.multElem(this.A[i][j], this.x[j]);
        s1 = GF2Field.addElem(s1, s);
      } 
      s = GF2Field.invElem(this.A[i][i]);
      if (s == 0)
        throw new IllegalStateException("Not solvable equation system"); 
      this.x[i] = GF2Field.multElem(s1, s);
    } 
  }
  
  public short[][] multiplyMatrix(short[][] paramArrayOfShort1, short[][] paramArrayOfShort2) throws RuntimeException {
    if (paramArrayOfShort1[0].length != paramArrayOfShort2.length)
      throw new RuntimeException("Multiplication is not possible!"); 
    short s = 0;
    this.A = new short[paramArrayOfShort1.length][paramArrayOfShort2[0].length];
    for (byte b = 0; b < paramArrayOfShort1.length; b++) {
      for (byte b1 = 0; b1 < paramArrayOfShort2.length; b1++) {
        for (byte b2 = 0; b2 < paramArrayOfShort2[0].length; b2++) {
          s = GF2Field.multElem(paramArrayOfShort1[b][b1], paramArrayOfShort2[b1][b2]);
          this.A[b][b2] = GF2Field.addElem(this.A[b][b2], s);
        } 
      } 
    } 
    return this.A;
  }
  
  public short[] multiplyMatrix(short[][] paramArrayOfShort, short[] paramArrayOfShort1) {
    if (paramArrayOfShort[0].length != paramArrayOfShort1.length)
      throw new RuntimeException("Multiplication is not possible!"); 
    short s = 0;
    short[] arrayOfShort = new short[paramArrayOfShort.length];
    for (byte b = 0; b < paramArrayOfShort.length; b++) {
      for (byte b1 = 0; b1 < paramArrayOfShort1.length; b1++) {
        s = GF2Field.multElem(paramArrayOfShort[b][b1], paramArrayOfShort1[b1]);
        arrayOfShort[b] = GF2Field.addElem(arrayOfShort[b], s);
      } 
    } 
    return arrayOfShort;
  }
  
  public short[] addVect(short[] paramArrayOfShort1, short[] paramArrayOfShort2) {
    if (paramArrayOfShort1.length != paramArrayOfShort2.length)
      throw new RuntimeException("Multiplication is not possible!"); 
    short[] arrayOfShort = new short[paramArrayOfShort1.length];
    for (byte b = 0; b < arrayOfShort.length; b++)
      arrayOfShort[b] = GF2Field.addElem(paramArrayOfShort1[b], paramArrayOfShort2[b]); 
    return arrayOfShort;
  }
  
  public short[][] multVects(short[] paramArrayOfShort1, short[] paramArrayOfShort2) {
    if (paramArrayOfShort1.length != paramArrayOfShort2.length)
      throw new RuntimeException("Multiplication is not possible!"); 
    short[][] arrayOfShort = new short[paramArrayOfShort1.length][paramArrayOfShort2.length];
    for (byte b = 0; b < paramArrayOfShort1.length; b++) {
      for (byte b1 = 0; b1 < paramArrayOfShort2.length; b1++)
        arrayOfShort[b][b1] = GF2Field.multElem(paramArrayOfShort1[b], paramArrayOfShort2[b1]); 
    } 
    return arrayOfShort;
  }
  
  public short[] multVect(short paramShort, short[] paramArrayOfShort) {
    short[] arrayOfShort = new short[paramArrayOfShort.length];
    for (byte b = 0; b < arrayOfShort.length; b++)
      arrayOfShort[b] = GF2Field.multElem(paramShort, paramArrayOfShort[b]); 
    return arrayOfShort;
  }
  
  public short[][] multMatrix(short paramShort, short[][] paramArrayOfShort) {
    short[][] arrayOfShort = new short[paramArrayOfShort.length][paramArrayOfShort[0].length];
    for (byte b = 0; b < paramArrayOfShort.length; b++) {
      for (byte b1 = 0; b1 < paramArrayOfShort[0].length; b1++)
        arrayOfShort[b][b1] = GF2Field.multElem(paramShort, paramArrayOfShort[b][b1]); 
    } 
    return arrayOfShort;
  }
  
  public short[][] addSquareMatrix(short[][] paramArrayOfShort1, short[][] paramArrayOfShort2) throws RuntimeException {
    if (paramArrayOfShort1.length != paramArrayOfShort2.length || paramArrayOfShort1[0].length != paramArrayOfShort2[0].length)
      throw new RuntimeException("Addition is not possible!"); 
    short[][] arrayOfShort = new short[paramArrayOfShort1.length][paramArrayOfShort1.length];
    for (byte b = 0; b < paramArrayOfShort1.length; b++) {
      for (byte b1 = 0; b1 < paramArrayOfShort2.length; b1++)
        arrayOfShort[b][b1] = GF2Field.addElem(paramArrayOfShort1[b][b1], paramArrayOfShort2[b][b1]); 
    } 
    return arrayOfShort;
  }
}
