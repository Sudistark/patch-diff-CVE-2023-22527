package org.bouncycastle.pqc.crypto.rainbow;

import java.security.SecureRandom;
import org.bouncycastle.crypto.AsymmetricCipherKeyPair;
import org.bouncycastle.crypto.AsymmetricCipherKeyPairGenerator;
import org.bouncycastle.crypto.CryptoServicesRegistrar;
import org.bouncycastle.crypto.KeyGenerationParameters;
import org.bouncycastle.pqc.crypto.rainbow.util.ComputeInField;
import org.bouncycastle.pqc.crypto.rainbow.util.GF2Field;

public class RainbowKeyPairGenerator implements AsymmetricCipherKeyPairGenerator {
  private boolean initialized = false;
  
  private SecureRandom sr;
  
  private RainbowKeyGenerationParameters rainbowParams;
  
  private short[][] A1;
  
  private short[][] A1inv;
  
  private short[] b1;
  
  private short[][] A2;
  
  private short[][] A2inv;
  
  private short[] b2;
  
  private int numOfLayers;
  
  private Layer[] layers;
  
  private int[] vi;
  
  private short[][] pub_quadratic;
  
  private short[][] pub_singular;
  
  private short[] pub_scalar;
  
  public AsymmetricCipherKeyPair genKeyPair() {
    if (!this.initialized)
      initializeDefault(); 
    keygen();
    RainbowPrivateKeyParameters rainbowPrivateKeyParameters = new RainbowPrivateKeyParameters(this.A1inv, this.b1, this.A2inv, this.b2, this.vi, this.layers);
    RainbowPublicKeyParameters rainbowPublicKeyParameters = new RainbowPublicKeyParameters(this.vi[this.vi.length - 1] - this.vi[0], this.pub_quadratic, this.pub_singular, this.pub_scalar);
    return new AsymmetricCipherKeyPair(rainbowPublicKeyParameters, rainbowPrivateKeyParameters);
  }
  
  public void initialize(KeyGenerationParameters paramKeyGenerationParameters) {
    this.rainbowParams = (RainbowKeyGenerationParameters)paramKeyGenerationParameters;
    this.sr = this.rainbowParams.getRandom();
    this.vi = this.rainbowParams.getParameters().getVi();
    this.numOfLayers = this.rainbowParams.getParameters().getNumOfLayers();
    this.initialized = true;
  }
  
  private void initializeDefault() {
    RainbowKeyGenerationParameters rainbowKeyGenerationParameters = new RainbowKeyGenerationParameters(CryptoServicesRegistrar.getSecureRandom(), new RainbowParameters());
    initialize(rainbowKeyGenerationParameters);
  }
  
  private void keygen() {
    generateL1();
    generateL2();
    generateF();
    computePublicKey();
  }
  
  private void generateL1() {
    int i = this.vi[this.vi.length - 1] - this.vi[0];
    this.A1 = new short[i][i];
    this.A1inv = (short[][])null;
    ComputeInField computeInField = new ComputeInField();
    while (this.A1inv == null) {
      for (byte b3 = 0; b3 < i; b3++) {
        for (byte b4 = 0; b4 < i; b4++)
          this.A1[b3][b4] = (short)(this.sr.nextInt() & 0xFF); 
      } 
      this.A1inv = computeInField.inverse(this.A1);
    } 
    this.b1 = new short[i];
    for (byte b = 0; b < i; b++)
      this.b1[b] = (short)(this.sr.nextInt() & 0xFF); 
  }
  
  private void generateL2() {
    int i = this.vi[this.vi.length - 1];
    this.A2 = new short[i][i];
    this.A2inv = (short[][])null;
    ComputeInField computeInField = new ComputeInField();
    while (this.A2inv == null) {
      for (byte b3 = 0; b3 < i; b3++) {
        for (byte b4 = 0; b4 < i; b4++)
          this.A2[b3][b4] = (short)(this.sr.nextInt() & 0xFF); 
      } 
      this.A2inv = computeInField.inverse(this.A2);
    } 
    this.b2 = new short[i];
    for (byte b = 0; b < i; b++)
      this.b2[b] = (short)(this.sr.nextInt() & 0xFF); 
  }
  
  private void generateF() {
    this.layers = new Layer[this.numOfLayers];
    for (byte b = 0; b < this.numOfLayers; b++)
      this.layers[b] = new Layer(this.vi[b], this.vi[b + true], this.sr); 
  }
  
  private void computePublicKey() {
    ComputeInField computeInField = new ComputeInField();
    int i = this.vi[this.vi.length - 1] - this.vi[0];
    int j = this.vi[this.vi.length - 1];
    short[][][] arrayOfShort1 = new short[i][j][j];
    this.pub_singular = new short[i][j];
    this.pub_scalar = new short[i];
    int k = 0;
    int m = 0;
    int n = 0;
    short[] arrayOfShort2 = new short[j];
    short s = 0;
    for (byte b3 = 0; b3 < this.layers.length; b3++) {
      short[][][] arrayOfShort5 = this.layers[b3].getCoeffAlpha();
      short[][][] arrayOfShort6 = this.layers[b3].getCoeffBeta();
      short[][] arrayOfShort7 = this.layers[b3].getCoeffGamma();
      short[] arrayOfShort8 = this.layers[b3].getCoeffEta();
      k = arrayOfShort5[0].length;
      m = arrayOfShort6[0].length;
      for (byte b = 0; b < k; b++) {
        int i1;
        for (i1 = 0; i1 < k; i1++) {
          for (byte b5 = 0; b5 < m; b5++) {
            arrayOfShort2 = computeInField.multVect(arrayOfShort5[b][i1][b5], this.A2[i1 + m]);
            arrayOfShort1[n + b] = computeInField.addSquareMatrix(arrayOfShort1[n + b], computeInField.multVects(arrayOfShort2, this.A2[b5]));
            arrayOfShort2 = computeInField.multVect(this.b2[b5], arrayOfShort2);
            this.pub_singular[n + b] = computeInField.addVect(arrayOfShort2, this.pub_singular[n + b]);
            arrayOfShort2 = computeInField.multVect(arrayOfShort5[b][i1][b5], this.A2[b5]);
            arrayOfShort2 = computeInField.multVect(this.b2[i1 + m], arrayOfShort2);
            this.pub_singular[n + b] = computeInField.addVect(arrayOfShort2, this.pub_singular[n + b]);
            s = GF2Field.multElem(arrayOfShort5[b][i1][b5], this.b2[i1 + m]);
            this.pub_scalar[n + b] = GF2Field.addElem(this.pub_scalar[n + b], GF2Field.multElem(s, this.b2[b5]));
          } 
        } 
        for (i1 = 0; i1 < m; i1++) {
          for (byte b5 = 0; b5 < m; b5++) {
            arrayOfShort2 = computeInField.multVect(arrayOfShort6[b][i1][b5], this.A2[i1]);
            arrayOfShort1[n + b] = computeInField.addSquareMatrix(arrayOfShort1[n + b], computeInField.multVects(arrayOfShort2, this.A2[b5]));
            arrayOfShort2 = computeInField.multVect(this.b2[b5], arrayOfShort2);
            this.pub_singular[n + b] = computeInField.addVect(arrayOfShort2, this.pub_singular[n + b]);
            arrayOfShort2 = computeInField.multVect(arrayOfShort6[b][i1][b5], this.A2[b5]);
            arrayOfShort2 = computeInField.multVect(this.b2[i1], arrayOfShort2);
            this.pub_singular[n + b] = computeInField.addVect(arrayOfShort2, this.pub_singular[n + b]);
            s = GF2Field.multElem(arrayOfShort6[b][i1][b5], this.b2[i1]);
            this.pub_scalar[n + b] = GF2Field.addElem(this.pub_scalar[n + b], GF2Field.multElem(s, this.b2[b5]));
          } 
        } 
        for (i1 = 0; i1 < m + k; i1++) {
          arrayOfShort2 = computeInField.multVect(arrayOfShort7[b][i1], this.A2[i1]);
          this.pub_singular[n + b] = computeInField.addVect(arrayOfShort2, this.pub_singular[n + b]);
          this.pub_scalar[n + b] = GF2Field.addElem(this.pub_scalar[n + b], GF2Field.multElem(arrayOfShort7[b][i1], this.b2[i1]));
        } 
        this.pub_scalar[n + b] = GF2Field.addElem(this.pub_scalar[n + b], arrayOfShort8[b]);
      } 
      n += k;
    } 
    short[][][] arrayOfShort3 = new short[i][j][j];
    short[][] arrayOfShort = new short[i][j];
    short[] arrayOfShort4 = new short[i];
    for (byte b4 = 0; b4 < i; b4++) {
      for (byte b = 0; b < this.A1.length; b++) {
        arrayOfShort3[b4] = computeInField.addSquareMatrix(arrayOfShort3[b4], computeInField.multMatrix(this.A1[b4][b], arrayOfShort1[b]));
        arrayOfShort[b4] = computeInField.addVect(arrayOfShort[b4], computeInField.multVect(this.A1[b4][b], this.pub_singular[b]));
        arrayOfShort4[b4] = GF2Field.addElem(arrayOfShort4[b4], GF2Field.multElem(this.A1[b4][b], this.pub_scalar[b]));
      } 
      arrayOfShort4[b4] = GF2Field.addElem(arrayOfShort4[b4], this.b1[b4]);
    } 
    arrayOfShort1 = arrayOfShort3;
    this.pub_singular = arrayOfShort;
    this.pub_scalar = arrayOfShort4;
    compactPublicKey(arrayOfShort1);
  }
  
  private void compactPublicKey(short[][][] paramArrayOfShort) {
    int i = paramArrayOfShort.length;
    int j = paramArrayOfShort[0].length;
    int k = j * (j + 1) / 2;
    this.pub_quadratic = new short[i][k];
    byte b3 = 0;
    for (byte b4 = 0; b4 < i; b4++) {
      b3 = 0;
      for (byte b = 0; b < j; b++) {
        for (byte b5 = b; b5 < j; b5++) {
          if (b5 == b) {
            this.pub_quadratic[b4][b3] = paramArrayOfShort[b4][b][b5];
          } else {
            this.pub_quadratic[b4][b3] = GF2Field.addElem(paramArrayOfShort[b4][b][b5], paramArrayOfShort[b4][b5][b]);
          } 
          b3++;
        } 
      } 
    } 
  }
  
  public void init(KeyGenerationParameters paramKeyGenerationParameters) { initialize(paramKeyGenerationParameters); }
  
  public AsymmetricCipherKeyPair generateKeyPair() { return genKeyPair(); }
}
