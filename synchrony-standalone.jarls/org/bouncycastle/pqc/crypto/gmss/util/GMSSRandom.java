package org.bouncycastle.pqc.crypto.gmss.util;

import org.bouncycastle.crypto.Digest;

public class GMSSRandom {
  private Digest messDigestTree;
  
  public GMSSRandom(Digest paramDigest) { this.messDigestTree = paramDigest; }
  
  public byte[] nextSeed(byte[] paramArrayOfByte) {
    byte[] arrayOfByte = new byte[paramArrayOfByte.length];
    this.messDigestTree.update(paramArrayOfByte, 0, paramArrayOfByte.length);
    arrayOfByte = new byte[this.messDigestTree.getDigestSize()];
    this.messDigestTree.doFinal(arrayOfByte, 0);
    addByteArrays(paramArrayOfByte, arrayOfByte);
    addOne(paramArrayOfByte);
    return arrayOfByte;
  }
  
  private void addByteArrays(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2) {
    short s = 0;
    for (byte b = 0; b < paramArrayOfByte1.length; b++) {
      char c = (0xFF & paramArrayOfByte1[b]) + (0xFF & paramArrayOfByte2[b]) + s;
      paramArrayOfByte1[b] = (byte)c;
      s = (byte)(c >> '\b');
    } 
  }
  
  private void addOne(byte[] paramArrayOfByte) {
    short s = 1;
    for (byte b = 0; b < paramArrayOfByte.length; b++) {
      char c = (0xFF & paramArrayOfByte[b]) + s;
      paramArrayOfByte[b] = (byte)c;
      s = (byte)(c >> '\b');
    } 
  }
}
