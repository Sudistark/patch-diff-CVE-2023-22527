package org.bouncycastle.pqc.crypto.sphincs;

class Wots {
  static final int WOTS_LOGW = 4;
  
  static final int WOTS_W = 16;
  
  static final int WOTS_L1 = 64;
  
  static final int WOTS_L = 67;
  
  static final int WOTS_LOG_L = 7;
  
  static final int WOTS_SIGBYTES = 2144;
  
  static void expand_seed(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2) {
    clear(paramArrayOfByte1, paramInt1, 2144);
    Seed.prg(paramArrayOfByte1, paramInt1, 2144L, paramArrayOfByte2, paramInt2);
  }
  
  private static void clear(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    for (int i = 0; i != paramInt2; i++)
      paramArrayOfByte[i + paramInt1] = 0; 
  }
  
  static void gen_chain(HashFunctions paramHashFunctions, byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, byte[] paramArrayOfByte3, int paramInt3, int paramInt4) {
    for (int i = 0; i < 32; i++)
      paramArrayOfByte1[i + paramInt1] = paramArrayOfByte2[i + paramInt2]; 
    for (byte b = 0; b < paramInt4 && b < 16; b++)
      paramHashFunctions.hash_n_n_mask(paramArrayOfByte1, paramInt1, paramArrayOfByte1, paramInt1, paramArrayOfByte3, paramInt3 + b * 32); 
  }
  
  void wots_pkgen(HashFunctions paramHashFunctions, byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, byte[] paramArrayOfByte3, int paramInt3) {
    expand_seed(paramArrayOfByte1, paramInt1, paramArrayOfByte2, paramInt2);
    for (byte b = 0; b < 67; b++)
      gen_chain(paramHashFunctions, paramArrayOfByte1, paramInt1 + b * 32, paramArrayOfByte1, paramInt1 + b * 32, paramArrayOfByte3, paramInt3, 15); 
  }
  
  void wots_sign(HashFunctions paramHashFunctions, byte[] paramArrayOfByte1, int paramInt, byte[] paramArrayOfByte2, byte[] paramArrayOfByte3, byte[] paramArrayOfByte4) {
    int[] arrayOfInt = new int[67];
    int i = 0;
    byte b;
    for (b = 0; b < 64; b += true) {
      arrayOfInt[b] = paramArrayOfByte2[b / 2] & 0xF;
      arrayOfInt[b + true] = (paramArrayOfByte2[b / 2] & 0xFF) >>> 4;
      i += 15 - arrayOfInt[b];
      i += 15 - arrayOfInt[b + true];
    } 
    while (b < 67) {
      arrayOfInt[b] = i & 0xF;
      i >>>= 4;
      b++;
    } 
    expand_seed(paramArrayOfByte1, paramInt, paramArrayOfByte3, 0);
    for (b = 0; b < 67; b++)
      gen_chain(paramHashFunctions, paramArrayOfByte1, paramInt + b * 32, paramArrayOfByte1, paramInt + b * 32, paramArrayOfByte4, 0, arrayOfInt[b]); 
  }
  
  void wots_verify(HashFunctions paramHashFunctions, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt, byte[] paramArrayOfByte3, byte[] paramArrayOfByte4) {
    int[] arrayOfInt = new int[67];
    int i = 0;
    byte b;
    for (b = 0; b < 64; b += true) {
      arrayOfInt[b] = paramArrayOfByte3[b / 2] & 0xF;
      arrayOfInt[b + true] = (paramArrayOfByte3[b / 2] & 0xFF) >>> 4;
      i += 15 - arrayOfInt[b];
      i += 15 - arrayOfInt[b + true];
    } 
    while (b < 67) {
      arrayOfInt[b] = i & 0xF;
      i >>>= 4;
      b++;
    } 
    for (b = 0; b < 67; b++)
      gen_chain(paramHashFunctions, paramArrayOfByte1, b * 32, paramArrayOfByte2, paramInt + b * 32, paramArrayOfByte4, arrayOfInt[b] * 32, 15 - arrayOfInt[b]); 
  }
}
