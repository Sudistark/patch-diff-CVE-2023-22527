package org.bouncycastle.pqc.crypto.sphincs;

class Horst {
  static final int HORST_LOGT = 16;
  
  static final int HORST_T = 65536;
  
  static final int HORST_K = 32;
  
  static final int HORST_SKBYTES = 32;
  
  static final int HORST_SIGBYTES = 13312;
  
  static final int N_MASKS = 32;
  
  static void expand_seed(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2) { Seed.prg(paramArrayOfByte1, 0, 2097152L, paramArrayOfByte2, 0); }
  
  static int horst_sign(HashFunctions paramHashFunctions, byte[] paramArrayOfByte1, int paramInt, byte[] paramArrayOfByte2, byte[] paramArrayOfByte3, byte[] paramArrayOfByte4, byte[] paramArrayOfByte5) {
    byte[] arrayOfByte1 = new byte[2097152];
    int i = paramInt;
    byte[] arrayOfByte2 = new byte[4194272];
    expand_seed(arrayOfByte1, paramArrayOfByte3);
    byte b;
    for (b = 0; b < 65536; b++)
      paramHashFunctions.hash_n_n(arrayOfByte2, ('￿' + b) * ' ', arrayOfByte1, b * 32); 
    for (b = 0; b < 16; b++) {
      long l1 = ((1 << 16 - b) - 1);
      long l2 = ((1 << 16 - b - 1) - 1);
      for (byte b1 = 0; b1 < 1 << 16 - b - 1; b1++)
        paramHashFunctions.hash_2n_n_mask(arrayOfByte2, (int)((l2 + b1) * 32L), arrayOfByte2, (int)((l1 + (2 * b1)) * 32L), paramArrayOfByte4, 2 * b * 32); 
    } 
    char c;
    for (c = 'ߠ'; c < '࿠'; c++)
      paramArrayOfByte1[i++] = arrayOfByte2[c]; 
    for (b = 0; b < 32; b++) {
      byte b1 = (paramArrayOfByte5[2 * b] & 0xFF) + ((paramArrayOfByte5[2 * b + 1] & 0xFF) << 8);
      byte b2;
      for (b2 = 0; b2 < 32; b2++)
        paramArrayOfByte1[i++] = arrayOfByte1[b1 * 32 + b2]; 
      b1 += 65535;
      for (c = Character.MIN_VALUE; c < '\n'; c++) {
        b1 = ((b1 & true) != 0) ? (b1 + 1) : (b1 - 1);
        for (b2 = 0; b2 < 32; b2++)
          paramArrayOfByte1[i++] = arrayOfByte2[b1 * 32 + b2]; 
        b1 = (b1 - 1) / 2;
      } 
    } 
    for (b = 0; b < 32; b++)
      paramArrayOfByte2[b] = arrayOfByte2[b]; 
    return 13312;
  }
  
  static int horst_verify(HashFunctions paramHashFunctions, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt, byte[] paramArrayOfByte3, byte[] paramArrayOfByte4) {
    byte[] arrayOfByte = new byte[1024];
    int i = paramInt + 2048;
    for (byte b1 = 0; b1 < 32; b1++) {
      byte b = (paramArrayOfByte4[2 * b1] & 0xFF) + ((paramArrayOfByte4[2 * b1 + 1] & 0xFF) << 8);
      if ((b & true) == 0) {
        paramHashFunctions.hash_n_n(arrayOfByte, 0, paramArrayOfByte2, i);
        for (int k = 0; k < 32; k++)
          arrayOfByte[32 + k] = paramArrayOfByte2[i + 32 + k]; 
      } else {
        paramHashFunctions.hash_n_n(arrayOfByte, 32, paramArrayOfByte2, i);
        for (int k = 0; k < 32; k++)
          arrayOfByte[k] = paramArrayOfByte2[i + 32 + k]; 
      } 
      i += 64;
      for (byte b3 = 1; b3 < 10; b3++) {
        b >>>= 1;
        if ((b & true) == 0) {
          paramHashFunctions.hash_2n_n_mask(arrayOfByte, 0, arrayOfByte, 0, paramArrayOfByte3, 2 * (b3 - true) * 32);
          for (int k = 0; k < 32; k++)
            arrayOfByte[32 + k] = paramArrayOfByte2[i + k]; 
        } else {
          paramHashFunctions.hash_2n_n_mask(arrayOfByte, 32, arrayOfByte, 0, paramArrayOfByte3, 2 * (b3 - true) * 32);
          for (int k = 0; k < 32; k++)
            arrayOfByte[k] = paramArrayOfByte2[i + k]; 
        } 
        i += 32;
      } 
      b >>>= 1;
      paramHashFunctions.hash_2n_n_mask(arrayOfByte, 0, arrayOfByte, 0, paramArrayOfByte3, 576);
      for (int j = 0; j < 32; j++) {
        if (paramArrayOfByte2[paramInt + b * 32 + j] != arrayOfByte[j]) {
          for (j = 0; j < 32; j++)
            paramArrayOfByte1[j] = 0; 
          return -1;
        } 
      } 
    } 
    byte b2;
    for (b2 = 0; b2 < 32; b2++)
      paramHashFunctions.hash_2n_n_mask(arrayOfByte, b2 * 32, paramArrayOfByte2, paramInt + 2 * b2 * 32, paramArrayOfByte3, 640); 
    for (b2 = 0; b2 < 16; b2++)
      paramHashFunctions.hash_2n_n_mask(arrayOfByte, b2 * 32, arrayOfByte, 2 * b2 * 32, paramArrayOfByte3, 704); 
    for (b2 = 0; b2 < 8; b2++)
      paramHashFunctions.hash_2n_n_mask(arrayOfByte, b2 * 32, arrayOfByte, 2 * b2 * 32, paramArrayOfByte3, 768); 
    for (b2 = 0; b2 < 4; b2++)
      paramHashFunctions.hash_2n_n_mask(arrayOfByte, b2 * 32, arrayOfByte, 2 * b2 * 32, paramArrayOfByte3, 832); 
    for (b2 = 0; b2 < 2; b2++)
      paramHashFunctions.hash_2n_n_mask(arrayOfByte, b2 * 32, arrayOfByte, 2 * b2 * 32, paramArrayOfByte3, 896); 
    paramHashFunctions.hash_2n_n_mask(paramArrayOfByte1, 0, arrayOfByte, 0, paramArrayOfByte3, 960);
    return 0;
  }
}
