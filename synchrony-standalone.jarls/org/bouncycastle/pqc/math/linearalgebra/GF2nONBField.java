package org.bouncycastle.pqc.math.linearalgebra;

import java.security.SecureRandom;
import java.util.Random;
import java.util.Vector;

public class GF2nONBField extends GF2nField {
  private static final int MAXLONG = 64;
  
  private int mLength;
  
  private int mBit;
  
  private int mType;
  
  int[][] mMult;
  
  public GF2nONBField(int paramInt, SecureRandom paramSecureRandom) throws RuntimeException {
    super(paramSecureRandom);
    if (paramInt < 3)
      throw new IllegalArgumentException("k must be at least 3"); 
    this.mDegree = paramInt;
    this.mLength = this.mDegree / 64;
    this.mBit = this.mDegree & 0x3F;
    if (this.mBit == 0) {
      this.mBit = 64;
    } else {
      this.mLength++;
    } 
    computeType();
    if (this.mType < 3) {
      this.mMult = new int[this.mDegree][2];
      for (byte b = 0; b < this.mDegree; b++) {
        this.mMult[b][0] = -1;
        this.mMult[b][1] = -1;
      } 
      computeMultMatrix();
    } else {
      throw new RuntimeException("\nThe type of this field is " + this.mType);
    } 
    computeFieldPolynomial();
    this.fields = new Vector();
    this.matrices = new Vector();
  }
  
  int getONBLength() { return this.mLength; }
  
  int getONBBit() { return this.mBit; }
  
  protected GF2nElement getRandomRoot(GF2Polynomial paramGF2Polynomial) {
    GF2nPolynomial gF2nPolynomial = new GF2nPolynomial(paramGF2Polynomial, this);
    int i;
    for (i = gF2nPolynomial.getDegree(); i > 1; i = gF2nPolynomial.getDegree()) {
      int j;
      GF2nPolynomial gF2nPolynomial1;
      do {
        GF2nONBElement gF2nONBElement;
        GF2nPolynomial gF2nPolynomial3 = new GF2nPolynomial(2, (gF2nONBElement = new GF2nONBElement(this, this.random)).ZERO(this));
        gF2nPolynomial3.set(1, gF2nONBElement);
        GF2nPolynomial gF2nPolynomial2 = new GF2nPolynomial(gF2nPolynomial3);
        for (byte b = 1; b <= this.mDegree - 1; b++) {
          gF2nPolynomial2 = gF2nPolynomial2.multiplyAndReduce(gF2nPolynomial2, gF2nPolynomial);
          gF2nPolynomial2 = gF2nPolynomial2.add(gF2nPolynomial3);
        } 
        gF2nPolynomial1 = gF2nPolynomial2.gcd(gF2nPolynomial);
        j = gF2nPolynomial1.getDegree();
        i = gF2nPolynomial.getDegree();
      } while (j == 0 || j == i);
      if (j << 1 > i) {
        gF2nPolynomial = gF2nPolynomial.quotient(gF2nPolynomial1);
      } else {
        gF2nPolynomial = new GF2nPolynomial(gF2nPolynomial1);
      } 
    } 
    return gF2nPolynomial.at(0);
  }
  
  protected void computeCOBMatrix(GF2nField paramGF2nField) {
    GF2nElement gF2nElement;
    if (this.mDegree != paramGF2nField.mDegree)
      throw new IllegalArgumentException("GF2nField.computeCOBMatrix: B1 has a different degree and thus cannot be coverted to!"); 
    GF2Polynomial[] arrayOfGF2Polynomial = new GF2Polynomial[this.mDegree];
    int i;
    for (i = 0; i < this.mDegree; i++)
      arrayOfGF2Polynomial[i] = new GF2Polynomial(this.mDegree); 
    do {
      gF2nElement = paramGF2nField.getRandomRoot(this.fieldPolynomial);
    } while (gF2nElement.isZero());
    GF2nPolynomialElement[] arrayOfGF2nPolynomialElement = new GF2nPolynomialElement[this.mDegree];
    arrayOfGF2nPolynomialElement[0] = (GF2nElement)gF2nElement.clone();
    for (i = 1; i < this.mDegree; i++)
      arrayOfGF2nPolynomialElement[i] = arrayOfGF2nPolynomialElement[i - 1].square(); 
    for (i = 0; i < this.mDegree; i++) {
      for (int j = 0; j < this.mDegree; j++) {
        if (arrayOfGF2nPolynomialElement[i].testBit(j))
          arrayOfGF2Polynomial[this.mDegree - j - 1].setBit(this.mDegree - i - 1); 
      } 
    } 
    this.fields.addElement(paramGF2nField);
    this.matrices.addElement(arrayOfGF2Polynomial);
    paramGF2nField.fields.addElement(this);
    paramGF2nField.matrices.addElement(invertMatrix(arrayOfGF2Polynomial));
  }
  
  protected void computeFieldPolynomial() {
    if (this.mType == 1) {
      this.fieldPolynomial = new GF2Polynomial(this.mDegree + 1, "ALL");
    } else if (this.mType == 2) {
      GF2Polynomial gF2Polynomial1 = new GF2Polynomial(this.mDegree + 1, "ONE");
      GF2Polynomial gF2Polynomial2 = new GF2Polynomial(this.mDegree + 1, "X");
      gF2Polynomial2.addToThis(gF2Polynomial1);
      for (byte b = 1; b < this.mDegree; b++) {
        GF2Polynomial gF2Polynomial = gF2Polynomial1;
        gF2Polynomial1 = gF2Polynomial2;
        gF2Polynomial2 = gF2Polynomial1.shiftLeft();
        gF2Polynomial2.addToThis(gF2Polynomial);
      } 
      this.fieldPolynomial = gF2Polynomial2;
    } 
  }
  
  int[][] invMatrix(int[][] paramArrayOfInt) {
    int[][] arrayOfInt1 = new int[this.mDegree][this.mDegree];
    arrayOfInt1 = paramArrayOfInt;
    int[][] arrayOfInt2 = new int[this.mDegree][this.mDegree];
    int i;
    for (i = 0; i < this.mDegree; i++)
      arrayOfInt2[i][i] = 1; 
    for (i = 0; i < this.mDegree; i++) {
      for (byte b = i; b < this.mDegree; b++)
        arrayOfInt1[this.mDegree - 1 - i][b] = arrayOfInt1[i][i]; 
    } 
    return (int[][])null;
  }
  
  private void computeType() {
    if ((this.mDegree & 0x7) == 0)
      throw new RuntimeException("The extension degree is divisible by 8!"); 
    int i = 0;
    int j = 0;
    this.mType = 1;
    int k = 0;
    while (k != 1) {
      i = this.mType * this.mDegree + 1;
      if (IntegerFunctions.isPrime(i)) {
        j = IntegerFunctions.order(2, i);
        k = IntegerFunctions.gcd(this.mType * this.mDegree / j, this.mDegree);
      } 
      this.mType++;
    } 
    this.mType--;
    if (this.mType == 1) {
      i = (this.mDegree << 1) + 1;
      if (IntegerFunctions.isPrime(i)) {
        j = IntegerFunctions.order(2, i);
        k = IntegerFunctions.gcd((this.mDegree << 1) / j, this.mDegree);
        if (k == 1)
          this.mType++; 
      } 
    } 
  }
  
  private void computeMultMatrix() {
    if ((this.mType & 0x7) != 0) {
      int j;
      int i = this.mType * this.mDegree + 1;
      int[] arrayOfInt = new int[i];
      if (this.mType == 1) {
        j = 1;
      } else if (this.mType == 2) {
        j = i - 1;
      } else {
        j = elementOfOrder(this.mType, i);
      } 
      int k = 1;
      int m;
      for (m = 0; m < this.mType; m++) {
        int n = k;
        for (byte b = 0; b < this.mDegree; b++) {
          arrayOfInt[n] = b;
          n = (n << true) % i;
          if (n < 0)
            n += i; 
        } 
        k = j * k % i;
        if (k < 0)
          k += i; 
      } 
      if (this.mType == 1) {
        for (m = 1; m < i - 1; m++) {
          if (this.mMult[arrayOfInt[m + 1]][0] == -1) {
            this.mMult[arrayOfInt[m + 1]][0] = arrayOfInt[i - m];
          } else {
            this.mMult[arrayOfInt[m + 1]][1] = arrayOfInt[i - m];
          } 
        } 
        m = this.mDegree >> 1;
        for (int n = 1; n <= m; n++) {
          if (this.mMult[n - true][0] == -1) {
            this.mMult[n - true][0] = m + n - 1;
          } else {
            this.mMult[n - 1][1] = m + n - 1;
          } 
          if (this.mMult[m + n - 1][0] == -1) {
            this.mMult[m + n - 1][0] = n - 1;
          } else {
            this.mMult[m + n - 1][1] = n - 1;
          } 
        } 
      } else if (this.mType == 2) {
        for (m = 1; m < i - 1; m++) {
          if (this.mMult[arrayOfInt[m + 1]][0] == -1) {
            this.mMult[arrayOfInt[m + 1]][0] = arrayOfInt[i - m];
          } else {
            this.mMult[arrayOfInt[m + 1]][1] = arrayOfInt[i - m];
          } 
        } 
      } else {
        throw new RuntimeException("only type 1 or type 2 implemented");
      } 
    } else {
      throw new RuntimeException("bisher nur fuer Gausssche Normalbasen implementiert");
    } 
  }
  
  private int elementOfOrder(int paramInt1, int paramInt2) {
    Random random = new Random();
    int i = 0;
    while (!i) {
      i = random.nextInt();
      i %= (paramInt2 - 1);
      if (i < 0)
        i += paramInt2 - 1; 
    } 
    int j;
    for (j = IntegerFunctions.order(i, paramInt2); j % paramInt1 != 0 || j == 0; j = IntegerFunctions.order(i, paramInt2)) {
      while (i == 0) {
        i = random.nextInt();
        i %= (paramInt2 - 1);
        if (i < 0)
          i += paramInt2 - 1; 
      } 
    } 
    int k = i;
    j = paramInt1 / j;
    for (byte b = 2; b <= j; b++)
      k *= i; 
    return k;
  }
}
