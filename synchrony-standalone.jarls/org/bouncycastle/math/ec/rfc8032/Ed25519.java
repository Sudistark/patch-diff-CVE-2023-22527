package org.bouncycastle.math.ec.rfc8032;

import java.security.SecureRandom;
import org.bouncycastle.crypto.Digest;
import org.bouncycastle.crypto.digests.SHA512Digest;
import org.bouncycastle.math.ec.rfc7748.X25519;
import org.bouncycastle.math.raw.Interleave;
import org.bouncycastle.math.raw.Nat;
import org.bouncycastle.math.raw.Nat256;
import org.bouncycastle.util.Arrays;

public abstract class Ed25519 {
  private static final long M08L = 255L;
  
  private static final long M28L = 268435455L;
  
  private static final long M32L = 4294967295L;
  
  private static final int COORD_INTS = 8;
  
  private static final int POINT_BYTES = 32;
  
  private static final int SCALAR_INTS = 8;
  
  private static final int SCALAR_BYTES = 32;
  
  public static final int PREHASH_SIZE = 64;
  
  public static final int PUBLIC_KEY_SIZE = 32;
  
  public static final int SECRET_KEY_SIZE = 32;
  
  public static final int SIGNATURE_SIZE = 64;
  
  private static final byte[] DOM2_PREFIX = { 
      83, 105, 103, 69, 100, 50, 53, 53, 49, 57, 
      32, 110, 111, 32, 69, 100, 50, 53, 53, 49, 
      57, 32, 99, 111, 108, 108, 105, 115, 105, 111, 
      110, 115 };
  
  private static final int[] P = { -19, -1, -1, -1, -1, -1, -1, Integer.MAX_VALUE };
  
  private static final int[] L = { 1559614445, 1477600026, -1560830762, 350157278, 0, 0, 0, 268435456 };
  
  private static final int L0 = -50998291;
  
  private static final int L1 = 19280294;
  
  private static final int L2 = 127719000;
  
  private static final int L3 = -6428113;
  
  private static final int L4 = 5343;
  
  private static final int[] B_x = { 52811034, 25909283, 8072341, 50637101, 13785486, 30858332, 20483199, 20966410, 43936626, 4379245 };
  
  private static final int[] B_y = { 40265304, 26843545, 6710886, 53687091, 13421772, 40265318, 26843545, 6710886, 53687091, 13421772 };
  
  private static final int[] C_d = { 56195235, 47411844, 25868126, 40503822, 57364, 58321048, 30416477, 31930572, 57760639, 10749657 };
  
  private static final int[] C_d2 = { 45281625, 27714825, 18181821, 13898781, 114729, 49533232, 60832955, 30306712, 48412415, 4722099 };
  
  private static final int[] C_d4 = { 23454386, 55429651, 2809210, 27797563, 229458, 31957600, 54557047, 27058993, 29715967, 9444199 };
  
  private static final int WNAF_WIDTH_BASE = 7;
  
  private static final int PRECOMP_BLOCKS = 8;
  
  private static final int PRECOMP_TEETH = 4;
  
  private static final int PRECOMP_SPACING = 8;
  
  private static final int PRECOMP_POINTS = 8;
  
  private static final int PRECOMP_MASK = 7;
  
  private static final Object precompLock = new Object();
  
  private static PointExt[] precompBaseTable = null;
  
  private static int[] precompBase = null;
  
  private static byte[] calculateS(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, byte[] paramArrayOfByte3) {
    int[] arrayOfInt1 = new int[16];
    decodeScalar(paramArrayOfByte1, 0, arrayOfInt1);
    int[] arrayOfInt2 = new int[8];
    decodeScalar(paramArrayOfByte2, 0, arrayOfInt2);
    int[] arrayOfInt3 = new int[8];
    decodeScalar(paramArrayOfByte3, 0, arrayOfInt3);
    Nat256.mulAddTo(arrayOfInt2, arrayOfInt3, arrayOfInt1);
    byte[] arrayOfByte = new byte[64];
    for (byte b = 0; b < arrayOfInt1.length; b++)
      encode32(arrayOfInt1[b], arrayOfByte, b * 4); 
    return reduceScalar(arrayOfByte);
  }
  
  private static boolean checkContextVar(byte[] paramArrayOfByte, byte paramByte) { return ((paramArrayOfByte == null && paramByte == 0) || (paramArrayOfByte != null && paramArrayOfByte.length < 256)); }
  
  private static int checkPoint(int[] paramArrayOfInt1, int[] paramArrayOfInt2) {
    int[] arrayOfInt1 = F.create();
    int[] arrayOfInt2 = F.create();
    int[] arrayOfInt3 = F.create();
    F.sqr(paramArrayOfInt1, arrayOfInt2);
    F.sqr(paramArrayOfInt2, arrayOfInt3);
    F.mul(arrayOfInt2, arrayOfInt3, arrayOfInt1);
    F.sub(arrayOfInt3, arrayOfInt2, arrayOfInt3);
    F.mul(arrayOfInt1, C_d, arrayOfInt1);
    F.addOne(arrayOfInt1);
    F.sub(arrayOfInt1, arrayOfInt3, arrayOfInt1);
    F.normalize(arrayOfInt1);
    return F.isZero(arrayOfInt1);
  }
  
  private static int checkPoint(int[] paramArrayOfInt1, int[] paramArrayOfInt2, int[] paramArrayOfInt3) {
    int[] arrayOfInt1 = F.create();
    int[] arrayOfInt2 = F.create();
    int[] arrayOfInt3 = F.create();
    int[] arrayOfInt4 = F.create();
    F.sqr(paramArrayOfInt1, arrayOfInt2);
    F.sqr(paramArrayOfInt2, arrayOfInt3);
    F.sqr(paramArrayOfInt3, arrayOfInt4);
    F.mul(arrayOfInt2, arrayOfInt3, arrayOfInt1);
    F.sub(arrayOfInt3, arrayOfInt2, arrayOfInt3);
    F.mul(arrayOfInt3, arrayOfInt4, arrayOfInt3);
    F.sqr(arrayOfInt4, arrayOfInt4);
    F.mul(arrayOfInt1, C_d, arrayOfInt1);
    F.add(arrayOfInt1, arrayOfInt4, arrayOfInt1);
    F.sub(arrayOfInt1, arrayOfInt3, arrayOfInt1);
    F.normalize(arrayOfInt1);
    return F.isZero(arrayOfInt1);
  }
  
  private static boolean checkPointVar(byte[] paramArrayOfByte) {
    int[] arrayOfInt = new int[8];
    decode32(paramArrayOfByte, 0, arrayOfInt, 0, 8);
    arrayOfInt[7] = arrayOfInt[7] & 0x7FFFFFFF;
    return !Nat256.gte(arrayOfInt, P);
  }
  
  private static boolean checkScalarVar(byte[] paramArrayOfByte, int[] paramArrayOfInt) {
    decodeScalar(paramArrayOfByte, 0, paramArrayOfInt);
    return !Nat256.gte(paramArrayOfInt, L);
  }
  
  private static byte[] copy(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    byte[] arrayOfByte = new byte[paramInt2];
    System.arraycopy(paramArrayOfByte, paramInt1, arrayOfByte, 0, paramInt2);
    return arrayOfByte;
  }
  
  private static Digest createDigest() { return new SHA512Digest(); }
  
  public static Digest createPrehash() { return createDigest(); }
  
  private static int decode24(byte[] paramArrayOfByte, int paramInt) {
    null = paramArrayOfByte[paramInt] & 0xFF;
    null |= (paramArrayOfByte[++paramInt] & 0xFF) << 8;
    return (paramArrayOfByte[++paramInt] & 0xFF) << 16;
  }
  
  private static int decode32(byte[] paramArrayOfByte, int paramInt) {
    null = paramArrayOfByte[paramInt] & 0xFF;
    null |= (paramArrayOfByte[++paramInt] & 0xFF) << 8;
    null |= (paramArrayOfByte[++paramInt] & 0xFF) << 16;
    return paramArrayOfByte[++paramInt] << 24;
  }
  
  private static void decode32(byte[] paramArrayOfByte, int paramInt1, int[] paramArrayOfInt, int paramInt2, int paramInt3) {
    for (int i = 0; i < paramInt3; i++)
      paramArrayOfInt[paramInt2 + i] = decode32(paramArrayOfByte, paramInt1 + i * 4); 
  }
  
  private static boolean decodePointVar(byte[] paramArrayOfByte, int paramInt, boolean paramBoolean, PointAffine paramPointAffine) {
    byte[] arrayOfByte = copy(paramArrayOfByte, paramInt, 32);
    if (!checkPointVar(arrayOfByte))
      return false; 
    byte b = (arrayOfByte[31] & 0x80) >>> 7;
    arrayOfByte[31] = (byte)(arrayOfByte[31] & 0x7F);
    F.decode(arrayOfByte, 0, paramPointAffine.y);
    int[] arrayOfInt1 = F.create();
    int[] arrayOfInt2 = F.create();
    F.sqr(paramPointAffine.y, arrayOfInt1);
    F.mul(C_d, arrayOfInt1, arrayOfInt2);
    F.subOne(arrayOfInt1);
    F.addOne(arrayOfInt2);
    if (!F.sqrtRatioVar(arrayOfInt1, arrayOfInt2, paramPointAffine.x))
      return false; 
    F.normalize(paramPointAffine.x);
    if (b == 1 && F.isZeroVar(paramPointAffine.x))
      return false; 
    if (paramBoolean ^ ((b != (paramPointAffine.x[0] & true)) ? 1 : 0))
      F.negate(paramPointAffine.x, paramPointAffine.x); 
    return true;
  }
  
  private static void decodeScalar(byte[] paramArrayOfByte, int paramInt, int[] paramArrayOfInt) { decode32(paramArrayOfByte, paramInt, paramArrayOfInt, 0, 8); }
  
  private static void dom2(Digest paramDigest, byte paramByte, byte[] paramArrayOfByte) {
    if (paramArrayOfByte != null) {
      int i = DOM2_PREFIX.length;
      byte[] arrayOfByte = new byte[i + 2 + paramArrayOfByte.length];
      System.arraycopy(DOM2_PREFIX, 0, arrayOfByte, 0, i);
      arrayOfByte[i] = paramByte;
      arrayOfByte[i + 1] = (byte)paramArrayOfByte.length;
      System.arraycopy(paramArrayOfByte, 0, arrayOfByte, i + 2, paramArrayOfByte.length);
      paramDigest.update(arrayOfByte, 0, arrayOfByte.length);
    } 
  }
  
  private static void encode24(int paramInt1, byte[] paramArrayOfByte, int paramInt2) {
    paramArrayOfByte[paramInt2] = (byte)paramInt1;
    paramArrayOfByte[++paramInt2] = (byte)(paramInt1 >>> 8);
    paramArrayOfByte[++paramInt2] = (byte)(paramInt1 >>> 16);
  }
  
  private static void encode32(int paramInt1, byte[] paramArrayOfByte, int paramInt2) {
    paramArrayOfByte[paramInt2] = (byte)paramInt1;
    paramArrayOfByte[++paramInt2] = (byte)(paramInt1 >>> 8);
    paramArrayOfByte[++paramInt2] = (byte)(paramInt1 >>> 16);
    paramArrayOfByte[++paramInt2] = (byte)(paramInt1 >>> 24);
  }
  
  private static void encode56(long paramLong, byte[] paramArrayOfByte, int paramInt) {
    encode32((int)paramLong, paramArrayOfByte, paramInt);
    encode24((int)(paramLong >>> 32), paramArrayOfByte, paramInt + 4);
  }
  
  private static int encodePoint(PointAccum paramPointAccum, byte[] paramArrayOfByte, int paramInt) {
    int[] arrayOfInt1 = F.create();
    int[] arrayOfInt2 = F.create();
    F.inv(paramPointAccum.z, arrayOfInt2);
    F.mul(paramPointAccum.x, arrayOfInt2, arrayOfInt1);
    F.mul(paramPointAccum.y, arrayOfInt2, arrayOfInt2);
    F.normalize(arrayOfInt1);
    F.normalize(arrayOfInt2);
    int i = checkPoint(arrayOfInt1, arrayOfInt2);
    F.encode(arrayOfInt2, paramArrayOfByte, paramInt);
    paramArrayOfByte[paramInt + 32 - 1] = (byte)(paramArrayOfByte[paramInt + 32 - 1] | (arrayOfInt1[0] & true) << 7);
    return i;
  }
  
  public static void generatePrivateKey(SecureRandom paramSecureRandom, byte[] paramArrayOfByte) { paramSecureRandom.nextBytes(paramArrayOfByte); }
  
  public static void generatePublicKey(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2) {
    Digest digest = createDigest();
    byte[] arrayOfByte1 = new byte[digest.getDigestSize()];
    digest.update(paramArrayOfByte1, paramInt1, 32);
    digest.doFinal(arrayOfByte1, 0);
    byte[] arrayOfByte2 = new byte[32];
    pruneScalar(arrayOfByte1, 0, arrayOfByte2);
    scalarMultBaseEncoded(arrayOfByte2, paramArrayOfByte2, paramInt2);
  }
  
  private static int getWindow4(int[] paramArrayOfInt, int paramInt) {
    int i = paramInt >>> 3;
    int j = (paramInt & 0x7) << 2;
    return paramArrayOfInt[i] >>> j & 0xF;
  }
  
  private static byte[] getWnafVar(int[] paramArrayOfInt, int paramInt) {
    int[] arrayOfInt = new int[16];
    int i = arrayOfInt.length;
    int j = 0;
    int k = 8;
    while (--k >= 0) {
      int n = paramArrayOfInt[k];
      arrayOfInt[--i] = n >>> 16 | j << 16;
      arrayOfInt[--i] = j = n;
    } 
    byte[] arrayOfByte = new byte[253];
    j = 32 - paramInt;
    k = 0;
    int m = 0;
    byte b = 0;
    while (b < arrayOfInt.length) {
      int n = arrayOfInt[b];
      while (k < 16) {
        int i1 = n >>> k;
        int i2 = i1 & true;
        if (i2 == m) {
          k++;
          continue;
        } 
        int i3 = (i1 | true) << j;
        m = i3 >>> 31;
        arrayOfByte[(b << 4) + k] = (byte)(i3 >> j);
        k += paramInt;
      } 
      b++;
      k -= 16;
    } 
    return arrayOfByte;
  }
  
  private static void implSign(Digest paramDigest, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, byte[] paramArrayOfByte3, int paramInt1, byte[] paramArrayOfByte4, byte paramByte, byte[] paramArrayOfByte5, int paramInt2, int paramInt3, byte[] paramArrayOfByte6, int paramInt4) {
    dom2(paramDigest, paramByte, paramArrayOfByte4);
    paramDigest.update(paramArrayOfByte1, 32, 32);
    paramDigest.update(paramArrayOfByte5, paramInt2, paramInt3);
    paramDigest.doFinal(paramArrayOfByte1, 0);
    byte[] arrayOfByte1 = reduceScalar(paramArrayOfByte1);
    byte[] arrayOfByte2 = new byte[32];
    scalarMultBaseEncoded(arrayOfByte1, arrayOfByte2, 0);
    dom2(paramDigest, paramByte, paramArrayOfByte4);
    paramDigest.update(arrayOfByte2, 0, 32);
    paramDigest.update(paramArrayOfByte3, paramInt1, 32);
    paramDigest.update(paramArrayOfByte5, paramInt2, paramInt3);
    paramDigest.doFinal(paramArrayOfByte1, 0);
    byte[] arrayOfByte3 = reduceScalar(paramArrayOfByte1);
    byte[] arrayOfByte4 = calculateS(arrayOfByte1, arrayOfByte3, paramArrayOfByte2);
    System.arraycopy(arrayOfByte2, 0, paramArrayOfByte6, paramInt4, 32);
    System.arraycopy(arrayOfByte4, 0, paramArrayOfByte6, paramInt4 + 32, 32);
  }
  
  private static void implSign(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, byte paramByte, byte[] paramArrayOfByte3, int paramInt2, int paramInt3, byte[] paramArrayOfByte4, int paramInt4) {
    if (!checkContextVar(paramArrayOfByte2, paramByte))
      throw new IllegalArgumentException("ctx"); 
    Digest digest = createDigest();
    byte[] arrayOfByte1 = new byte[digest.getDigestSize()];
    digest.update(paramArrayOfByte1, paramInt1, 32);
    digest.doFinal(arrayOfByte1, 0);
    byte[] arrayOfByte2 = new byte[32];
    pruneScalar(arrayOfByte1, 0, arrayOfByte2);
    byte[] arrayOfByte3 = new byte[32];
    scalarMultBaseEncoded(arrayOfByte2, arrayOfByte3, 0);
    implSign(digest, arrayOfByte1, arrayOfByte2, arrayOfByte3, 0, paramArrayOfByte2, paramByte, paramArrayOfByte3, paramInt2, paramInt3, paramArrayOfByte4, paramInt4);
  }
  
  private static void implSign(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, byte[] paramArrayOfByte3, byte paramByte, byte[] paramArrayOfByte4, int paramInt3, int paramInt4, byte[] paramArrayOfByte5, int paramInt5) {
    if (!checkContextVar(paramArrayOfByte3, paramByte))
      throw new IllegalArgumentException("ctx"); 
    Digest digest = createDigest();
    byte[] arrayOfByte1 = new byte[digest.getDigestSize()];
    digest.update(paramArrayOfByte1, paramInt1, 32);
    digest.doFinal(arrayOfByte1, 0);
    byte[] arrayOfByte2 = new byte[32];
    pruneScalar(arrayOfByte1, 0, arrayOfByte2);
    implSign(digest, arrayOfByte1, arrayOfByte2, paramArrayOfByte2, paramInt2, paramArrayOfByte3, paramByte, paramArrayOfByte4, paramInt3, paramInt4, paramArrayOfByte5, paramInt5);
  }
  
  private static boolean implVerify(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, byte[] paramArrayOfByte3, byte paramByte, byte[] paramArrayOfByte4, int paramInt3, int paramInt4) {
    if (!checkContextVar(paramArrayOfByte3, paramByte))
      throw new IllegalArgumentException("ctx"); 
    byte[] arrayOfByte1 = copy(paramArrayOfByte1, paramInt1, 32);
    byte[] arrayOfByte2 = copy(paramArrayOfByte1, paramInt1 + 32, 32);
    if (!checkPointVar(arrayOfByte1))
      return false; 
    int[] arrayOfInt1 = new int[8];
    if (!checkScalarVar(arrayOfByte2, arrayOfInt1))
      return false; 
    PointAffine pointAffine = new PointAffine(null);
    if (!decodePointVar(paramArrayOfByte2, paramInt2, true, pointAffine))
      return false; 
    Digest digest = createDigest();
    byte[] arrayOfByte3 = new byte[digest.getDigestSize()];
    dom2(digest, paramByte, paramArrayOfByte3);
    digest.update(arrayOfByte1, 0, 32);
    digest.update(paramArrayOfByte2, paramInt2, 32);
    digest.update(paramArrayOfByte4, paramInt3, paramInt4);
    digest.doFinal(arrayOfByte3, 0);
    byte[] arrayOfByte4 = reduceScalar(arrayOfByte3);
    int[] arrayOfInt2 = new int[8];
    decodeScalar(arrayOfByte4, 0, arrayOfInt2);
    PointAccum pointAccum = new PointAccum(null);
    scalarMultStrausVar(arrayOfInt1, arrayOfInt2, pointAffine, pointAccum);
    byte[] arrayOfByte5 = new byte[32];
    return (0 != encodePoint(pointAccum, arrayOfByte5, 0) && Arrays.areEqual(arrayOfByte5, arrayOfByte1));
  }
  
  private static boolean isNeutralElementVar(int[] paramArrayOfInt1, int[] paramArrayOfInt2) { return (F.isZeroVar(paramArrayOfInt1) && F.isOneVar(paramArrayOfInt2)); }
  
  private static boolean isNeutralElementVar(int[] paramArrayOfInt1, int[] paramArrayOfInt2, int[] paramArrayOfInt3) { return (F.isZeroVar(paramArrayOfInt1) && F.areEqualVar(paramArrayOfInt2, paramArrayOfInt3)); }
  
  private static void pointAdd(PointExt paramPointExt, PointAccum paramPointAccum) {
    int[] arrayOfInt1 = F.create();
    int[] arrayOfInt2 = F.create();
    int[] arrayOfInt3 = F.create();
    int[] arrayOfInt4 = F.create();
    int[] arrayOfInt5 = paramPointAccum.u;
    int[] arrayOfInt6 = F.create();
    int[] arrayOfInt7 = F.create();
    int[] arrayOfInt8 = paramPointAccum.v;
    F.apm(paramPointAccum.y, paramPointAccum.x, arrayOfInt2, arrayOfInt1);
    F.apm(paramPointExt.y, paramPointExt.x, arrayOfInt4, arrayOfInt3);
    F.mul(arrayOfInt1, arrayOfInt3, arrayOfInt1);
    F.mul(arrayOfInt2, arrayOfInt4, arrayOfInt2);
    F.mul(paramPointAccum.u, paramPointAccum.v, arrayOfInt3);
    F.mul(arrayOfInt3, paramPointExt.t, arrayOfInt3);
    F.mul(arrayOfInt3, C_d2, arrayOfInt3);
    F.mul(paramPointAccum.z, paramPointExt.z, arrayOfInt4);
    F.add(arrayOfInt4, arrayOfInt4, arrayOfInt4);
    F.apm(arrayOfInt2, arrayOfInt1, arrayOfInt8, arrayOfInt5);
    F.apm(arrayOfInt4, arrayOfInt3, arrayOfInt7, arrayOfInt6);
    F.carry(arrayOfInt7);
    F.mul(arrayOfInt5, arrayOfInt6, paramPointAccum.x);
    F.mul(arrayOfInt7, arrayOfInt8, paramPointAccum.y);
    F.mul(arrayOfInt6, arrayOfInt7, paramPointAccum.z);
  }
  
  private static void pointAdd(PointExt paramPointExt1, PointExt paramPointExt2) {
    int[] arrayOfInt1 = F.create();
    int[] arrayOfInt2 = F.create();
    int[] arrayOfInt3 = F.create();
    int[] arrayOfInt4 = F.create();
    int[] arrayOfInt5 = F.create();
    int[] arrayOfInt6 = F.create();
    int[] arrayOfInt7 = F.create();
    int[] arrayOfInt8 = F.create();
    F.apm(paramPointExt1.y, paramPointExt1.x, arrayOfInt2, arrayOfInt1);
    F.apm(paramPointExt2.y, paramPointExt2.x, arrayOfInt4, arrayOfInt3);
    F.mul(arrayOfInt1, arrayOfInt3, arrayOfInt1);
    F.mul(arrayOfInt2, arrayOfInt4, arrayOfInt2);
    F.mul(paramPointExt1.t, paramPointExt2.t, arrayOfInt3);
    F.mul(arrayOfInt3, C_d2, arrayOfInt3);
    F.mul(paramPointExt1.z, paramPointExt2.z, arrayOfInt4);
    F.add(arrayOfInt4, arrayOfInt4, arrayOfInt4);
    F.apm(arrayOfInt2, arrayOfInt1, arrayOfInt8, arrayOfInt5);
    F.apm(arrayOfInt4, arrayOfInt3, arrayOfInt7, arrayOfInt6);
    F.carry(arrayOfInt7);
    F.mul(arrayOfInt5, arrayOfInt6, paramPointExt2.x);
    F.mul(arrayOfInt7, arrayOfInt8, paramPointExt2.y);
    F.mul(arrayOfInt6, arrayOfInt7, paramPointExt2.z);
    F.mul(arrayOfInt5, arrayOfInt8, paramPointExt2.t);
  }
  
  private static void pointAddVar(boolean paramBoolean, PointExt paramPointExt, PointAccum paramPointAccum) {
    int[] arrayOfInt12;
    int[] arrayOfInt11;
    int[] arrayOfInt10;
    int[] arrayOfInt9;
    int[] arrayOfInt1 = F.create();
    int[] arrayOfInt2 = F.create();
    int[] arrayOfInt3 = F.create();
    int[] arrayOfInt4 = F.create();
    int[] arrayOfInt5 = paramPointAccum.u;
    int[] arrayOfInt6 = F.create();
    int[] arrayOfInt7 = F.create();
    int[] arrayOfInt8 = paramPointAccum.v;
    if (paramBoolean) {
      arrayOfInt9 = arrayOfInt4;
      arrayOfInt10 = arrayOfInt3;
      arrayOfInt11 = arrayOfInt7;
      arrayOfInt12 = arrayOfInt6;
    } else {
      arrayOfInt9 = arrayOfInt3;
      arrayOfInt10 = arrayOfInt4;
      arrayOfInt11 = arrayOfInt6;
      arrayOfInt12 = arrayOfInt7;
    } 
    F.apm(paramPointAccum.y, paramPointAccum.x, arrayOfInt2, arrayOfInt1);
    F.apm(paramPointExt.y, paramPointExt.x, arrayOfInt10, arrayOfInt9);
    F.mul(arrayOfInt1, arrayOfInt3, arrayOfInt1);
    F.mul(arrayOfInt2, arrayOfInt4, arrayOfInt2);
    F.mul(paramPointAccum.u, paramPointAccum.v, arrayOfInt3);
    F.mul(arrayOfInt3, paramPointExt.t, arrayOfInt3);
    F.mul(arrayOfInt3, C_d2, arrayOfInt3);
    F.mul(paramPointAccum.z, paramPointExt.z, arrayOfInt4);
    F.add(arrayOfInt4, arrayOfInt4, arrayOfInt4);
    F.apm(arrayOfInt2, arrayOfInt1, arrayOfInt8, arrayOfInt5);
    F.apm(arrayOfInt4, arrayOfInt3, arrayOfInt12, arrayOfInt11);
    F.carry(arrayOfInt12);
    F.mul(arrayOfInt5, arrayOfInt6, paramPointAccum.x);
    F.mul(arrayOfInt7, arrayOfInt8, paramPointAccum.y);
    F.mul(arrayOfInt6, arrayOfInt7, paramPointAccum.z);
  }
  
  private static void pointAddVar(boolean paramBoolean, PointExt paramPointExt1, PointExt paramPointExt2, PointExt paramPointExt3) {
    int[] arrayOfInt12;
    int[] arrayOfInt11;
    int[] arrayOfInt10;
    int[] arrayOfInt9;
    int[] arrayOfInt1 = F.create();
    int[] arrayOfInt2 = F.create();
    int[] arrayOfInt3 = F.create();
    int[] arrayOfInt4 = F.create();
    int[] arrayOfInt5 = F.create();
    int[] arrayOfInt6 = F.create();
    int[] arrayOfInt7 = F.create();
    int[] arrayOfInt8 = F.create();
    if (paramBoolean) {
      arrayOfInt9 = arrayOfInt4;
      arrayOfInt10 = arrayOfInt3;
      arrayOfInt11 = arrayOfInt7;
      arrayOfInt12 = arrayOfInt6;
    } else {
      arrayOfInt9 = arrayOfInt3;
      arrayOfInt10 = arrayOfInt4;
      arrayOfInt11 = arrayOfInt6;
      arrayOfInt12 = arrayOfInt7;
    } 
    F.apm(paramPointExt1.y, paramPointExt1.x, arrayOfInt2, arrayOfInt1);
    F.apm(paramPointExt2.y, paramPointExt2.x, arrayOfInt10, arrayOfInt9);
    F.mul(arrayOfInt1, arrayOfInt3, arrayOfInt1);
    F.mul(arrayOfInt2, arrayOfInt4, arrayOfInt2);
    F.mul(paramPointExt1.t, paramPointExt2.t, arrayOfInt3);
    F.mul(arrayOfInt3, C_d2, arrayOfInt3);
    F.mul(paramPointExt1.z, paramPointExt2.z, arrayOfInt4);
    F.add(arrayOfInt4, arrayOfInt4, arrayOfInt4);
    F.apm(arrayOfInt2, arrayOfInt1, arrayOfInt8, arrayOfInt5);
    F.apm(arrayOfInt4, arrayOfInt3, arrayOfInt12, arrayOfInt11);
    F.carry(arrayOfInt12);
    F.mul(arrayOfInt5, arrayOfInt6, paramPointExt3.x);
    F.mul(arrayOfInt7, arrayOfInt8, paramPointExt3.y);
    F.mul(arrayOfInt6, arrayOfInt7, paramPointExt3.z);
    F.mul(arrayOfInt5, arrayOfInt8, paramPointExt3.t);
  }
  
  private static void pointAddPrecomp(PointPrecomp paramPointPrecomp, PointAccum paramPointAccum) {
    int[] arrayOfInt1 = F.create();
    int[] arrayOfInt2 = F.create();
    int[] arrayOfInt3 = F.create();
    int[] arrayOfInt4 = paramPointAccum.u;
    int[] arrayOfInt5 = F.create();
    int[] arrayOfInt6 = F.create();
    int[] arrayOfInt7 = paramPointAccum.v;
    F.apm(paramPointAccum.y, paramPointAccum.x, arrayOfInt2, arrayOfInt1);
    F.mul(arrayOfInt1, paramPointPrecomp.ymx_h, arrayOfInt1);
    F.mul(arrayOfInt2, paramPointPrecomp.ypx_h, arrayOfInt2);
    F.mul(paramPointAccum.u, paramPointAccum.v, arrayOfInt3);
    F.mul(arrayOfInt3, paramPointPrecomp.xyd, arrayOfInt3);
    F.apm(arrayOfInt2, arrayOfInt1, arrayOfInt7, arrayOfInt4);
    F.apm(paramPointAccum.z, arrayOfInt3, arrayOfInt6, arrayOfInt5);
    F.carry(arrayOfInt6);
    F.mul(arrayOfInt4, arrayOfInt5, paramPointAccum.x);
    F.mul(arrayOfInt6, arrayOfInt7, paramPointAccum.y);
    F.mul(arrayOfInt5, arrayOfInt6, paramPointAccum.z);
  }
  
  private static PointExt pointCopy(PointAccum paramPointAccum) {
    PointExt pointExt = new PointExt(null);
    F.copy(paramPointAccum.x, 0, pointExt.x, 0);
    F.copy(paramPointAccum.y, 0, pointExt.y, 0);
    F.copy(paramPointAccum.z, 0, pointExt.z, 0);
    F.mul(paramPointAccum.u, paramPointAccum.v, pointExt.t);
    return pointExt;
  }
  
  private static PointExt pointCopy(PointAffine paramPointAffine) {
    PointExt pointExt = new PointExt(null);
    F.copy(paramPointAffine.x, 0, pointExt.x, 0);
    F.copy(paramPointAffine.y, 0, pointExt.y, 0);
    pointExtendXY(pointExt);
    return pointExt;
  }
  
  private static PointExt pointCopy(PointExt paramPointExt) {
    PointExt pointExt = new PointExt(null);
    pointCopy(paramPointExt, pointExt);
    return pointExt;
  }
  
  private static void pointCopy(PointAffine paramPointAffine, PointAccum paramPointAccum) {
    F.copy(paramPointAffine.x, 0, paramPointAccum.x, 0);
    F.copy(paramPointAffine.y, 0, paramPointAccum.y, 0);
    pointExtendXY(paramPointAccum);
  }
  
  private static void pointCopy(PointExt paramPointExt1, PointExt paramPointExt2) {
    F.copy(paramPointExt1.x, 0, paramPointExt2.x, 0);
    F.copy(paramPointExt1.y, 0, paramPointExt2.y, 0);
    F.copy(paramPointExt1.z, 0, paramPointExt2.z, 0);
    F.copy(paramPointExt1.t, 0, paramPointExt2.t, 0);
  }
  
  private static void pointDouble(PointAccum paramPointAccum) {
    int[] arrayOfInt1 = F.create();
    int[] arrayOfInt2 = F.create();
    int[] arrayOfInt3 = F.create();
    int[] arrayOfInt4 = paramPointAccum.u;
    int[] arrayOfInt5 = F.create();
    int[] arrayOfInt6 = F.create();
    int[] arrayOfInt7 = paramPointAccum.v;
    F.sqr(paramPointAccum.x, arrayOfInt1);
    F.sqr(paramPointAccum.y, arrayOfInt2);
    F.sqr(paramPointAccum.z, arrayOfInt3);
    F.add(arrayOfInt3, arrayOfInt3, arrayOfInt3);
    F.apm(arrayOfInt1, arrayOfInt2, arrayOfInt7, arrayOfInt6);
    F.add(paramPointAccum.x, paramPointAccum.y, arrayOfInt4);
    F.sqr(arrayOfInt4, arrayOfInt4);
    F.sub(arrayOfInt7, arrayOfInt4, arrayOfInt4);
    F.add(arrayOfInt3, arrayOfInt6, arrayOfInt5);
    F.carry(arrayOfInt5);
    F.mul(arrayOfInt4, arrayOfInt5, paramPointAccum.x);
    F.mul(arrayOfInt6, arrayOfInt7, paramPointAccum.y);
    F.mul(arrayOfInt5, arrayOfInt6, paramPointAccum.z);
  }
  
  private static void pointExtendXY(PointAccum paramPointAccum) {
    F.one(paramPointAccum.z);
    F.copy(paramPointAccum.x, 0, paramPointAccum.u, 0);
    F.copy(paramPointAccum.y, 0, paramPointAccum.v, 0);
  }
  
  private static void pointExtendXY(PointExt paramPointExt) {
    F.one(paramPointExt.z);
    F.mul(paramPointExt.x, paramPointExt.y, paramPointExt.t);
  }
  
  private static void pointLookup(int paramInt1, int paramInt2, PointPrecomp paramPointPrecomp) {
    int i = paramInt1 * 8 * 3 * 10;
    for (int j = 0; j < 8; j++) {
      int k = (j ^ paramInt2) - 1 >> 31;
      F.cmov(k, precompBase, i, paramPointPrecomp.ypx_h, 0);
      i += 10;
      F.cmov(k, precompBase, i, paramPointPrecomp.ymx_h, 0);
      i += 10;
      F.cmov(k, precompBase, i, paramPointPrecomp.xyd, 0);
      i += 10;
    } 
  }
  
  private static void pointLookup(int[] paramArrayOfInt1, int paramInt, int[] paramArrayOfInt2, PointExt paramPointExt) {
    int i = getWindow4(paramArrayOfInt1, paramInt);
    int j = i >>> 3 ^ true;
    int k = (i ^ -j) & 0x7;
    int m = 0;
    byte b = 0;
    while (m < 8) {
      int n = (m ^ k) - 1 >> 31;
      F.cmov(n, paramArrayOfInt2, b, paramPointExt.x, 0);
      b += 10;
      F.cmov(n, paramArrayOfInt2, b, paramPointExt.y, 0);
      b += 10;
      F.cmov(n, paramArrayOfInt2, b, paramPointExt.z, 0);
      b += 10;
      F.cmov(n, paramArrayOfInt2, b, paramPointExt.t, 0);
      b += 10;
      m++;
    } 
    F.cnegate(j, paramPointExt.x);
    F.cnegate(j, paramPointExt.t);
  }
  
  private static void pointLookup(int[] paramArrayOfInt, int paramInt, PointExt paramPointExt) {
    int i = 40 * paramInt;
    F.copy(paramArrayOfInt, i, paramPointExt.x, 0);
    i += 10;
    F.copy(paramArrayOfInt, i, paramPointExt.y, 0);
    i += 10;
    F.copy(paramArrayOfInt, i, paramPointExt.z, 0);
    i += 10;
    F.copy(paramArrayOfInt, i, paramPointExt.t, 0);
  }
  
  private static int[] pointPrecompute(PointAffine paramPointAffine, int paramInt) {
    PointExt pointExt1 = pointCopy(paramPointAffine);
    PointExt pointExt2 = pointCopy(pointExt1);
    pointAdd(pointExt1, pointExt2);
    int[] arrayOfInt = F.createTable(paramInt * 4);
    byte b1 = 0;
    byte b2 = 0;
    while (true) {
      F.copy(pointExt1.x, 0, arrayOfInt, b1);
      b1 += 10;
      F.copy(pointExt1.y, 0, arrayOfInt, b1);
      b1 += 10;
      F.copy(pointExt1.z, 0, arrayOfInt, b1);
      b1 += 10;
      F.copy(pointExt1.t, 0, arrayOfInt, b1);
      b1 += 10;
      if (++b2 == paramInt)
        break; 
      pointAdd(pointExt2, pointExt1);
    } 
    return arrayOfInt;
  }
  
  private static PointExt[] pointPrecomputeVar(PointExt paramPointExt, int paramInt) {
    PointExt pointExt = new PointExt(null);
    pointAddVar(false, paramPointExt, paramPointExt, pointExt);
    PointExt[] arrayOfPointExt = new PointExt[paramInt];
    arrayOfPointExt[0] = pointCopy(paramPointExt);
    for (byte b = 1; b < paramInt; b++)
      pointAddVar(false, arrayOfPointExt[b - true], pointExt, arrayOfPointExt[b] = new PointExt(null)); 
    return arrayOfPointExt;
  }
  
  private static void pointSetNeutral(PointAccum paramPointAccum) {
    F.zero(paramPointAccum.x);
    F.one(paramPointAccum.y);
    F.one(paramPointAccum.z);
    F.zero(paramPointAccum.u);
    F.one(paramPointAccum.v);
  }
  
  private static void pointSetNeutral(PointExt paramPointExt) {
    F.zero(paramPointExt.x);
    F.one(paramPointExt.y);
    F.one(paramPointExt.z);
    F.zero(paramPointExt.t);
  }
  
  public static void precompute() {
    synchronized (precompLock) {
      if (precompBase != null)
        return; 
      PointExt pointExt = new PointExt(null);
      F.copy(B_x, 0, pointExt.x, 0);
      F.copy(B_y, 0, pointExt.y, 0);
      pointExtendXY(pointExt);
      precompBaseTable = pointPrecomputeVar(pointExt, 32);
      PointAccum pointAccum = new PointAccum(null);
      F.copy(B_x, 0, pointAccum.x, 0);
      F.copy(B_y, 0, pointAccum.y, 0);
      pointExtendXY(pointAccum);
      precompBase = F.createTable(192);
      byte b1 = 0;
      for (byte b2 = 0; b2 < 8; b2++) {
        PointExt[] arrayOfPointExt1 = new PointExt[4];
        PointExt pointExt1 = new PointExt(null);
        pointSetNeutral(pointExt1);
        for (byte b3 = 0; b3 < 4; b3++) {
          PointExt pointExt2 = pointCopy(pointAccum);
          pointAddVar(true, pointExt1, pointExt2, pointExt1);
          pointDouble(pointAccum);
          arrayOfPointExt1[b3] = pointCopy(pointAccum);
          if (b2 + b3 != 10)
            for (byte b = 1; b < 8; b++)
              pointDouble(pointAccum);  
        } 
        PointExt[] arrayOfPointExt2 = new PointExt[8];
        byte b4 = 0;
        arrayOfPointExt2[b4++] = pointExt1;
        for (byte b5 = 0; b5 < 3; b5++) {
          byte b8 = true << b5;
          byte b9 = 0;
          while (b9 < b8) {
            pointAddVar(false, arrayOfPointExt2[b4 - b8], arrayOfPointExt1[b5], arrayOfPointExt2[b4] = new PointExt(null));
            b9++;
            b4++;
          } 
        } 
        int[] arrayOfInt1 = F.createTable(8);
        int[] arrayOfInt2 = F.create();
        F.copy((arrayOfPointExt2[0]).z, 0, arrayOfInt2, 0);
        F.copy(arrayOfInt2, 0, arrayOfInt1, 0);
        byte b7 = 0;
        while (++b7 < 8) {
          F.mul(arrayOfInt2, (arrayOfPointExt2[b7]).z, arrayOfInt2);
          F.copy(arrayOfInt2, 0, arrayOfInt1, b7 * 10);
        } 
        F.add(arrayOfInt2, arrayOfInt2, arrayOfInt2);
        F.invVar(arrayOfInt2, arrayOfInt2);
        b7--;
        int[] arrayOfInt3 = F.create();
        while (b7 > 0) {
          byte b = b7--;
          F.copy(arrayOfInt1, b7 * 10, arrayOfInt3, 0);
          F.mul(arrayOfInt3, arrayOfInt2, arrayOfInt3);
          F.copy(arrayOfInt3, 0, arrayOfInt1, b * 10);
          F.mul(arrayOfInt2, (arrayOfPointExt2[b]).z, arrayOfInt2);
        } 
        F.copy(arrayOfInt2, 0, arrayOfInt1, 0);
        for (byte b6 = 0; b6 < 8; b6++) {
          PointExt pointExt2 = arrayOfPointExt2[b6];
          arrayOfInt3 = F.create();
          int[] arrayOfInt = F.create();
          F.copy(arrayOfInt1, b6 * 10, arrayOfInt, 0);
          F.mul(pointExt2.x, arrayOfInt, arrayOfInt3);
          F.mul(pointExt2.y, arrayOfInt, arrayOfInt);
          PointPrecomp pointPrecomp = new PointPrecomp(null);
          F.apm(arrayOfInt, arrayOfInt3, pointPrecomp.ypx_h, pointPrecomp.ymx_h);
          F.mul(arrayOfInt3, arrayOfInt, pointPrecomp.xyd);
          F.mul(pointPrecomp.xyd, C_d4, pointPrecomp.xyd);
          F.normalize(pointPrecomp.ypx_h);
          F.normalize(pointPrecomp.ymx_h);
          F.copy(pointPrecomp.ypx_h, 0, precompBase, b1);
          b1 += 10;
          F.copy(pointPrecomp.ymx_h, 0, precompBase, b1);
          b1 += 10;
          F.copy(pointPrecomp.xyd, 0, precompBase, b1);
          b1 += 10;
        } 
      } 
    } 
  }
  
  private static void pruneScalar(byte[] paramArrayOfByte1, int paramInt, byte[] paramArrayOfByte2) {
    System.arraycopy(paramArrayOfByte1, paramInt, paramArrayOfByte2, 0, 32);
    paramArrayOfByte2[0] = (byte)(paramArrayOfByte2[0] & 0xF8);
    paramArrayOfByte2[31] = (byte)(paramArrayOfByte2[31] & 0x7F);
    paramArrayOfByte2[31] = (byte)(paramArrayOfByte2[31] | 0x40);
  }
  
  private static byte[] reduceScalar(byte[] paramArrayOfByte) {
    long l1 = decode32(paramArrayOfByte, 0) & 0xFFFFFFFFL;
    long l2 = (decode24(paramArrayOfByte, 4) << 4) & 0xFFFFFFFFL;
    long l3 = decode32(paramArrayOfByte, 7) & 0xFFFFFFFFL;
    long l4 = (decode24(paramArrayOfByte, 11) << 4) & 0xFFFFFFFFL;
    long l5 = decode32(paramArrayOfByte, 14) & 0xFFFFFFFFL;
    long l6 = (decode24(paramArrayOfByte, 18) << 4) & 0xFFFFFFFFL;
    long l7 = decode32(paramArrayOfByte, 21) & 0xFFFFFFFFL;
    long l8 = (decode24(paramArrayOfByte, 25) << 4) & 0xFFFFFFFFL;
    long l9 = decode32(paramArrayOfByte, 28) & 0xFFFFFFFFL;
    long l10 = (decode24(paramArrayOfByte, 32) << 4) & 0xFFFFFFFFL;
    long l11 = decode32(paramArrayOfByte, 35) & 0xFFFFFFFFL;
    long l12 = (decode24(paramArrayOfByte, 39) << 4) & 0xFFFFFFFFL;
    long l13 = decode32(paramArrayOfByte, 42) & 0xFFFFFFFFL;
    long l14 = (decode24(paramArrayOfByte, 46) << 4) & 0xFFFFFFFFL;
    long l15 = decode32(paramArrayOfByte, 49) & 0xFFFFFFFFL;
    long l16 = (decode24(paramArrayOfByte, 53) << 4) & 0xFFFFFFFFL;
    long l17 = decode32(paramArrayOfByte, 56) & 0xFFFFFFFFL;
    long l18 = (decode24(paramArrayOfByte, 60) << 4) & 0xFFFFFFFFL;
    long l19 = paramArrayOfByte[63] & 0xFFL;
    l10 -= l19 * -50998291L;
    l11 -= l19 * 19280294L;
    l12 -= l19 * 127719000L;
    l13 -= l19 * -6428113L;
    l14 -= l19 * 5343L;
    l18 += (l17 >> 28);
    l17 &= 0xFFFFFFFL;
    l9 -= l18 * -50998291L;
    l10 -= l18 * 19280294L;
    l11 -= l18 * 127719000L;
    l12 -= l18 * -6428113L;
    l13 -= l18 * 5343L;
    l8 -= l17 * -50998291L;
    l9 -= l17 * 19280294L;
    l10 -= l17 * 127719000L;
    l11 -= l17 * -6428113L;
    l12 -= l17 * 5343L;
    l16 += (l15 >> 28);
    l15 &= 0xFFFFFFFL;
    l7 -= l16 * -50998291L;
    l8 -= l16 * 19280294L;
    l9 -= l16 * 127719000L;
    l10 -= l16 * -6428113L;
    l11 -= l16 * 5343L;
    l6 -= l15 * -50998291L;
    l7 -= l15 * 19280294L;
    l8 -= l15 * 127719000L;
    l9 -= l15 * -6428113L;
    l10 -= l15 * 5343L;
    l14 += (l13 >> 28);
    l13 &= 0xFFFFFFFL;
    l5 -= l14 * -50998291L;
    l6 -= l14 * 19280294L;
    l7 -= l14 * 127719000L;
    l8 -= l14 * -6428113L;
    l9 -= l14 * 5343L;
    l13 += (l12 >> 28);
    l12 &= 0xFFFFFFFL;
    l4 -= l13 * -50998291L;
    l5 -= l13 * 19280294L;
    l6 -= l13 * 127719000L;
    l7 -= l13 * -6428113L;
    l8 -= l13 * 5343L;
    l12 += (l11 >> 28);
    l11 &= 0xFFFFFFFL;
    l3 -= l12 * -50998291L;
    l4 -= l12 * 19280294L;
    l5 -= l12 * 127719000L;
    l6 -= l12 * -6428113L;
    l7 -= l12 * 5343L;
    l11 += (l10 >> 28);
    l10 &= 0xFFFFFFFL;
    l2 -= l11 * -50998291L;
    l3 -= l11 * 19280294L;
    l4 -= l11 * 127719000L;
    l5 -= l11 * -6428113L;
    l6 -= l11 * 5343L;
    l9 += (l8 >> 28);
    l8 &= 0xFFFFFFFL;
    l10 += (l9 >> 28);
    l9 &= 0xFFFFFFFL;
    long l20 = l9 >>> 27;
    l10 += l20;
    l1 -= l10 * -50998291L;
    l2 -= l10 * 19280294L;
    l3 -= l10 * 127719000L;
    l4 -= l10 * -6428113L;
    l5 -= l10 * 5343L;
    l2 += (l1 >> 28);
    l1 &= 0xFFFFFFFL;
    l3 += (l2 >> 28);
    l2 &= 0xFFFFFFFL;
    l4 += (l3 >> 28);
    l3 &= 0xFFFFFFFL;
    l5 += (l4 >> 28);
    l4 &= 0xFFFFFFFL;
    l6 += (l5 >> 28);
    l5 &= 0xFFFFFFFL;
    l7 += (l6 >> 28);
    l6 &= 0xFFFFFFFL;
    l8 += (l7 >> 28);
    l7 &= 0xFFFFFFFL;
    l9 += (l8 >> 28);
    l8 &= 0xFFFFFFFL;
    l10 = l9 >> 28;
    l9 &= 0xFFFFFFFL;
    l10 -= l20;
    l1 += (l10 & 0xFFFFFFFFFCF5D3EDL);
    l2 += (l10 & 0x12631A6L);
    l3 += (l10 & 0x79CD658L);
    l4 += (l10 & 0xFFFFFFFFFF9DEA2FL);
    l5 += (l10 & 0x14DFL);
    l2 += (l1 >> 28);
    l1 &= 0xFFFFFFFL;
    l3 += (l2 >> 28);
    l2 &= 0xFFFFFFFL;
    l4 += (l3 >> 28);
    l3 &= 0xFFFFFFFL;
    l5 += (l4 >> 28);
    l4 &= 0xFFFFFFFL;
    l6 += (l5 >> 28);
    l5 &= 0xFFFFFFFL;
    l7 += (l6 >> 28);
    l6 &= 0xFFFFFFFL;
    l8 += (l7 >> 28);
    l7 &= 0xFFFFFFFL;
    l9 += (l8 >> 28);
    l8 &= 0xFFFFFFFL;
    byte[] arrayOfByte = new byte[32];
    encode56(l1 | l2 << 28, arrayOfByte, 0);
    encode56(l3 | l4 << 28, arrayOfByte, 7);
    encode56(l5 | l6 << 28, arrayOfByte, 14);
    encode56(l7 | l8 << 28, arrayOfByte, 21);
    encode32((int)l9, arrayOfByte, 28);
    return arrayOfByte;
  }
  
  private static void scalarMult(byte[] paramArrayOfByte, PointAffine paramPointAffine, PointAccum paramPointAccum) {
    int[] arrayOfInt1 = new int[8];
    decodeScalar(paramArrayOfByte, 0, arrayOfInt1);
    Nat.shiftDownBits(8, arrayOfInt1, 3, 1);
    Nat.cadd(8, (arrayOfInt1[0] ^ 0xFFFFFFFF) & true, arrayOfInt1, L, arrayOfInt1);
    Nat.shiftDownBit(8, arrayOfInt1, 0);
    int[] arrayOfInt2 = pointPrecompute(paramPointAffine, 8);
    PointExt pointExt = new PointExt(null);
    pointCopy(paramPointAffine, paramPointAccum);
    pointLookup(arrayOfInt2, 7, pointExt);
    pointAdd(pointExt, paramPointAccum);
    byte b = 62;
    while (true) {
      pointLookup(arrayOfInt1, b, arrayOfInt2, pointExt);
      pointAdd(pointExt, paramPointAccum);
      pointDouble(paramPointAccum);
      pointDouble(paramPointAccum);
      pointDouble(paramPointAccum);
      if (--b < 0)
        break; 
      pointDouble(paramPointAccum);
    } 
  }
  
  private static void scalarMultBase(byte[] paramArrayOfByte, PointAccum paramPointAccum) {
    precompute();
    int[] arrayOfInt = new int[8];
    decodeScalar(paramArrayOfByte, 0, arrayOfInt);
    Nat.cadd(8, (arrayOfInt[0] ^ 0xFFFFFFFF) & true, arrayOfInt, L, arrayOfInt);
    Nat.shiftDownBit(8, arrayOfInt, 1);
    for (byte b = 0; b < 8; b++)
      arrayOfInt[b] = Interleave.shuffle2(arrayOfInt[b]); 
    PointPrecomp pointPrecomp = new PointPrecomp(null);
    pointSetNeutral(paramPointAccum);
    int i = 28;
    while (true) {
      for (byte b1 = 0; b1 < 8; b1++) {
        int j = arrayOfInt[b1] >>> i;
        int k = j >>> 3 & true;
        int m = (j ^ -k) & 0x7;
        pointLookup(b1, m, pointPrecomp);
        F.cswap(k, pointPrecomp.ypx_h, pointPrecomp.ymx_h);
        F.cnegate(k, pointPrecomp.xyd);
        pointAddPrecomp(pointPrecomp, paramPointAccum);
      } 
      i -= 4;
      if (i < 0)
        break; 
      pointDouble(paramPointAccum);
    } 
  }
  
  private static void scalarMultBaseEncoded(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt) {
    PointAccum pointAccum = new PointAccum(null);
    scalarMultBase(paramArrayOfByte1, pointAccum);
    if (0 == encodePoint(pointAccum, paramArrayOfByte2, paramInt))
      throw new IllegalStateException(); 
  }
  
  public static void scalarMultBaseYZ(X25519.Friend paramFriend, byte[] paramArrayOfByte, int paramInt, int[] paramArrayOfInt1, int[] paramArrayOfInt2) {
    if (null == paramFriend)
      throw new NullPointerException("This method is only for use by X25519"); 
    byte[] arrayOfByte = new byte[32];
    pruneScalar(paramArrayOfByte, paramInt, arrayOfByte);
    PointAccum pointAccum = new PointAccum(null);
    scalarMultBase(arrayOfByte, pointAccum);
    if (0 == checkPoint(pointAccum.x, pointAccum.y, pointAccum.z))
      throw new IllegalStateException(); 
    F.copy(pointAccum.y, 0, paramArrayOfInt1, 0);
    F.copy(pointAccum.z, 0, paramArrayOfInt2, 0);
  }
  
  private static void scalarMultOrderVar(PointAffine paramPointAffine, PointAccum paramPointAccum) {
    byte[] arrayOfByte = getWnafVar(L, 5);
    PointExt[] arrayOfPointExt = pointPrecomputeVar(pointCopy(paramPointAffine), 8);
    pointSetNeutral(paramPointAccum);
    char c = 'ü';
    while (true) {
      byte b = arrayOfByte[c];
      if (b != 0) {
        byte b1 = b >> 31;
        byte b2 = (b ^ b1) >>> 1;
        pointAddVar((b1 != 0), arrayOfPointExt[b2], paramPointAccum);
      } 
      if (--c < '\000')
        break; 
      pointDouble(paramPointAccum);
    } 
  }
  
  private static void scalarMultStrausVar(int[] paramArrayOfInt1, int[] paramArrayOfInt2, PointAffine paramPointAffine, PointAccum paramPointAccum) {
    precompute();
    byte[] arrayOfByte1 = getWnafVar(paramArrayOfInt1, 7);
    byte[] arrayOfByte2 = getWnafVar(paramArrayOfInt2, 5);
    PointExt[] arrayOfPointExt = pointPrecomputeVar(pointCopy(paramPointAffine), 8);
    pointSetNeutral(paramPointAccum);
    char c = 'ü';
    while (true) {
      byte b1 = arrayOfByte1[c];
      if (b1 != 0) {
        byte b3 = b1 >> 31;
        byte b4 = (b1 ^ b3) >>> 1;
        pointAddVar((b3 != 0), precompBaseTable[b4], paramPointAccum);
      } 
      byte b2 = arrayOfByte2[c];
      if (b2 != 0) {
        byte b3 = b2 >> 31;
        byte b4 = (b2 ^ b3) >>> 1;
        pointAddVar((b3 != 0), arrayOfPointExt[b4], paramPointAccum);
      } 
      if (--c < '\000')
        break; 
      pointDouble(paramPointAccum);
    } 
  }
  
  public static void sign(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, int paramInt3, byte[] paramArrayOfByte3, int paramInt4) {
    byte[] arrayOfByte = null;
    byte b = 0;
    implSign(paramArrayOfByte1, paramInt1, arrayOfByte, b, paramArrayOfByte2, paramInt2, paramInt3, paramArrayOfByte3, paramInt4);
  }
  
  public static void sign(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, byte[] paramArrayOfByte3, int paramInt3, int paramInt4, byte[] paramArrayOfByte4, int paramInt5) {
    byte[] arrayOfByte = null;
    byte b = 0;
    implSign(paramArrayOfByte1, paramInt1, paramArrayOfByte2, paramInt2, arrayOfByte, b, paramArrayOfByte3, paramInt3, paramInt4, paramArrayOfByte4, paramInt5);
  }
  
  public static void sign(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, byte[] paramArrayOfByte3, int paramInt2, int paramInt3, byte[] paramArrayOfByte4, int paramInt4) {
    byte b = 0;
    implSign(paramArrayOfByte1, paramInt1, paramArrayOfByte2, b, paramArrayOfByte3, paramInt2, paramInt3, paramArrayOfByte4, paramInt4);
  }
  
  public static void sign(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, byte[] paramArrayOfByte3, byte[] paramArrayOfByte4, int paramInt3, int paramInt4, byte[] paramArrayOfByte5, int paramInt5) {
    byte b = 0;
    implSign(paramArrayOfByte1, paramInt1, paramArrayOfByte2, paramInt2, paramArrayOfByte3, b, paramArrayOfByte4, paramInt3, paramInt4, paramArrayOfByte5, paramInt5);
  }
  
  public static void signPrehash(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, byte[] paramArrayOfByte3, int paramInt2, byte[] paramArrayOfByte4, int paramInt3) {
    byte b = 1;
    implSign(paramArrayOfByte1, paramInt1, paramArrayOfByte2, b, paramArrayOfByte3, paramInt2, 64, paramArrayOfByte4, paramInt3);
  }
  
  public static void signPrehash(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, byte[] paramArrayOfByte3, byte[] paramArrayOfByte4, int paramInt3, byte[] paramArrayOfByte5, int paramInt4) {
    byte b = 1;
    implSign(paramArrayOfByte1, paramInt1, paramArrayOfByte2, paramInt2, paramArrayOfByte3, b, paramArrayOfByte4, paramInt3, 64, paramArrayOfByte5, paramInt4);
  }
  
  public static void signPrehash(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, Digest paramDigest, byte[] paramArrayOfByte3, int paramInt2) {
    byte[] arrayOfByte = new byte[64];
    if (64 != paramDigest.doFinal(arrayOfByte, 0))
      throw new IllegalArgumentException("ph"); 
    byte b = 1;
    implSign(paramArrayOfByte1, paramInt1, paramArrayOfByte2, b, arrayOfByte, 0, arrayOfByte.length, paramArrayOfByte3, paramInt2);
  }
  
  public static void signPrehash(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, byte[] paramArrayOfByte3, Digest paramDigest, byte[] paramArrayOfByte4, int paramInt3) {
    byte[] arrayOfByte = new byte[64];
    if (64 != paramDigest.doFinal(arrayOfByte, 0))
      throw new IllegalArgumentException("ph"); 
    byte b = 1;
    implSign(paramArrayOfByte1, paramInt1, paramArrayOfByte2, paramInt2, paramArrayOfByte3, b, arrayOfByte, 0, arrayOfByte.length, paramArrayOfByte4, paramInt3);
  }
  
  public static boolean validatePublicKeyFull(byte[] paramArrayOfByte, int paramInt) {
    PointAffine pointAffine = new PointAffine(null);
    if (!decodePointVar(paramArrayOfByte, paramInt, false, pointAffine))
      return false; 
    F.normalize(pointAffine.x);
    F.normalize(pointAffine.y);
    if (isNeutralElementVar(pointAffine.x, pointAffine.y))
      return false; 
    PointAccum pointAccum = new PointAccum(null);
    scalarMultOrderVar(pointAffine, pointAccum);
    F.normalize(pointAccum.x);
    F.normalize(pointAccum.y);
    F.normalize(pointAccum.z);
    return isNeutralElementVar(pointAccum.x, pointAccum.y, pointAccum.z);
  }
  
  public static boolean validatePublicKeyPartial(byte[] paramArrayOfByte, int paramInt) {
    PointAffine pointAffine = new PointAffine(null);
    return decodePointVar(paramArrayOfByte, paramInt, false, pointAffine);
  }
  
  public static boolean verify(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, byte[] paramArrayOfByte3, int paramInt3, int paramInt4) {
    byte[] arrayOfByte = null;
    byte b = 0;
    return implVerify(paramArrayOfByte1, paramInt1, paramArrayOfByte2, paramInt2, arrayOfByte, b, paramArrayOfByte3, paramInt3, paramInt4);
  }
  
  public static boolean verify(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, byte[] paramArrayOfByte3, byte[] paramArrayOfByte4, int paramInt3, int paramInt4) {
    byte b = 0;
    return implVerify(paramArrayOfByte1, paramInt1, paramArrayOfByte2, paramInt2, paramArrayOfByte3, b, paramArrayOfByte4, paramInt3, paramInt4);
  }
  
  public static boolean verifyPrehash(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, byte[] paramArrayOfByte3, byte[] paramArrayOfByte4, int paramInt3) {
    byte b = 1;
    return implVerify(paramArrayOfByte1, paramInt1, paramArrayOfByte2, paramInt2, paramArrayOfByte3, b, paramArrayOfByte4, paramInt3, 64);
  }
  
  public static boolean verifyPrehash(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, byte[] paramArrayOfByte3, Digest paramDigest) {
    byte[] arrayOfByte = new byte[64];
    if (64 != paramDigest.doFinal(arrayOfByte, 0))
      throw new IllegalArgumentException("ph"); 
    byte b = 1;
    return implVerify(paramArrayOfByte1, paramInt1, paramArrayOfByte2, paramInt2, paramArrayOfByte3, b, arrayOfByte, 0, arrayOfByte.length);
  }
}
