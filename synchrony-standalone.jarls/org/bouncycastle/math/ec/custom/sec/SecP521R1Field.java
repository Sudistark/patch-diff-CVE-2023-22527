package org.bouncycastle.math.ec.custom.sec;

import java.math.BigInteger;
import java.security.SecureRandom;
import org.bouncycastle.math.raw.Mod;
import org.bouncycastle.math.raw.Nat;
import org.bouncycastle.math.raw.Nat512;
import org.bouncycastle.util.Pack;

public class SecP521R1Field {
  static final int[] P = { 
      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
      -1, -1, -1, -1, -1, -1, 511 };
  
  private static final int P16 = 511;
  
  public static void add(int[] paramArrayOfInt1, int[] paramArrayOfInt2, int[] paramArrayOfInt3) {
    int i = Nat.add(16, paramArrayOfInt1, paramArrayOfInt2, paramArrayOfInt3) + paramArrayOfInt1[16] + paramArrayOfInt2[16];
    if (i > 511 || (i == 511 && Nat.eq(16, paramArrayOfInt3, P))) {
      i += Nat.inc(16, paramArrayOfInt3);
      i &= 0x1FF;
    } 
    paramArrayOfInt3[16] = i;
  }
  
  public static void addOne(int[] paramArrayOfInt1, int[] paramArrayOfInt2) {
    int i = Nat.inc(16, paramArrayOfInt1, paramArrayOfInt2) + paramArrayOfInt1[16];
    if (i > 511 || (i == 511 && Nat.eq(16, paramArrayOfInt2, P))) {
      i += Nat.inc(16, paramArrayOfInt2);
      i &= 0x1FF;
    } 
    paramArrayOfInt2[16] = i;
  }
  
  public static int[] fromBigInteger(BigInteger paramBigInteger) {
    int[] arrayOfInt = Nat.fromBigInteger(521, paramBigInteger);
    if (Nat.eq(17, arrayOfInt, P))
      Nat.zero(17, arrayOfInt); 
    return arrayOfInt;
  }
  
  public static void half(int[] paramArrayOfInt1, int[] paramArrayOfInt2) {
    int i = paramArrayOfInt1[16];
    int j = Nat.shiftDownBit(16, paramArrayOfInt1, i, paramArrayOfInt2);
    paramArrayOfInt2[16] = i >>> 1 | j >>> 23;
  }
  
  public static void inv(int[] paramArrayOfInt1, int[] paramArrayOfInt2) { Mod.checkedModOddInverse(P, paramArrayOfInt1, paramArrayOfInt2); }
  
  public static int isZero(int[] paramArrayOfInt) {
    int i = 0;
    for (byte b = 0; b < 17; b++)
      i |= paramArrayOfInt[b]; 
    i = i >>> 1 | i & true;
    return i - 1 >> 31;
  }
  
  public static void multiply(int[] paramArrayOfInt1, int[] paramArrayOfInt2, int[] paramArrayOfInt3) {
    int[] arrayOfInt = Nat.create(33);
    implMultiply(paramArrayOfInt1, paramArrayOfInt2, arrayOfInt);
    reduce(arrayOfInt, paramArrayOfInt3);
  }
  
  public static void negate(int[] paramArrayOfInt1, int[] paramArrayOfInt2) {
    if (0 != isZero(paramArrayOfInt1)) {
      Nat.sub(17, P, P, paramArrayOfInt2);
    } else {
      Nat.sub(17, P, paramArrayOfInt1, paramArrayOfInt2);
    } 
  }
  
  public static void random(SecureRandom paramSecureRandom, int[] paramArrayOfInt) {
    byte[] arrayOfByte = new byte[68];
    do {
      paramSecureRandom.nextBytes(arrayOfByte);
      Pack.littleEndianToInt(arrayOfByte, 0, paramArrayOfInt, 0, 17);
      paramArrayOfInt[16] = paramArrayOfInt[16] & 0x1FF;
    } while (0 == Nat.lessThan(17, paramArrayOfInt, P));
  }
  
  public static void randomMult(SecureRandom paramSecureRandom, int[] paramArrayOfInt) {
    do {
      random(paramSecureRandom, paramArrayOfInt);
    } while (0 != isZero(paramArrayOfInt));
  }
  
  public static void reduce(int[] paramArrayOfInt1, int[] paramArrayOfInt2) {
    int i = paramArrayOfInt1[32];
    int j = Nat.shiftDownBits(16, paramArrayOfInt1, 16, 9, i, paramArrayOfInt2, 0) >>> 23;
    j += (i >>> 9);
    j += Nat.addTo(16, paramArrayOfInt1, paramArrayOfInt2);
    if (j > 511 || (j == 511 && Nat.eq(16, paramArrayOfInt2, P))) {
      j += Nat.inc(16, paramArrayOfInt2);
      j &= 0x1FF;
    } 
    paramArrayOfInt2[16] = j;
  }
  
  public static void reduce23(int[] paramArrayOfInt) {
    int i = paramArrayOfInt[16];
    int j = Nat.addWordTo(16, i >>> 9, paramArrayOfInt) + (i & 0x1FF);
    if (j > 511 || (j == 511 && Nat.eq(16, paramArrayOfInt, P))) {
      j += Nat.inc(16, paramArrayOfInt);
      j &= 0x1FF;
    } 
    paramArrayOfInt[16] = j;
  }
  
  public static void square(int[] paramArrayOfInt1, int[] paramArrayOfInt2) {
    int[] arrayOfInt = Nat.create(33);
    implSquare(paramArrayOfInt1, arrayOfInt);
    reduce(arrayOfInt, paramArrayOfInt2);
  }
  
  public static void squareN(int[] paramArrayOfInt1, int paramInt, int[] paramArrayOfInt2) {
    int[] arrayOfInt = Nat.create(33);
    implSquare(paramArrayOfInt1, arrayOfInt);
    reduce(arrayOfInt, paramArrayOfInt2);
    while (--paramInt > 0) {
      implSquare(paramArrayOfInt2, arrayOfInt);
      reduce(arrayOfInt, paramArrayOfInt2);
    } 
  }
  
  public static void subtract(int[] paramArrayOfInt1, int[] paramArrayOfInt2, int[] paramArrayOfInt3) {
    int i = Nat.sub(16, paramArrayOfInt1, paramArrayOfInt2, paramArrayOfInt3) + paramArrayOfInt1[16] - paramArrayOfInt2[16];
    if (i < 0) {
      i += Nat.dec(16, paramArrayOfInt3);
      i &= 0x1FF;
    } 
    paramArrayOfInt3[16] = i;
  }
  
  public static void twice(int[] paramArrayOfInt1, int[] paramArrayOfInt2) {
    int i = paramArrayOfInt1[16];
    int j = Nat.shiftUpBit(16, paramArrayOfInt1, i << 23, paramArrayOfInt2) | i << 1;
    paramArrayOfInt2[16] = j & 0x1FF;
  }
  
  protected static void implMultiply(int[] paramArrayOfInt1, int[] paramArrayOfInt2, int[] paramArrayOfInt3) {
    Nat512.mul(paramArrayOfInt1, paramArrayOfInt2, paramArrayOfInt3);
    int i = paramArrayOfInt1[16];
    int j = paramArrayOfInt2[16];
    paramArrayOfInt3[32] = Nat.mul31BothAdd(16, i, paramArrayOfInt2, j, paramArrayOfInt1, paramArrayOfInt3, 16) + i * j;
  }
  
  protected static void implSquare(int[] paramArrayOfInt1, int[] paramArrayOfInt2) {
    Nat512.square(paramArrayOfInt1, paramArrayOfInt2);
    int i = paramArrayOfInt1[16];
    paramArrayOfInt2[32] = Nat.mulWordAddTo(16, i << 1, paramArrayOfInt1, 0, paramArrayOfInt2, 16) + i * i;
  }
}
