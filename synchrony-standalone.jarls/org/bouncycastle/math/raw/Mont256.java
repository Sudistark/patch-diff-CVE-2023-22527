package org.bouncycastle.math.raw;

public abstract class Mont256 {
  private static final long M = 4294967295L;
  
  public static int inverse32(int paramInt) {
    null = paramInt;
    null *= (2 - paramInt * null);
    null *= (2 - paramInt * null);
    null *= (2 - paramInt * null);
    return 2 - paramInt * null;
  }
  
  public static void multAdd(int[] paramArrayOfInt1, int[] paramArrayOfInt2, int[] paramArrayOfInt3, int[] paramArrayOfInt4, int paramInt) {
    int i = 0;
    long l = paramArrayOfInt2[0] & 0xFFFFFFFFL;
    for (byte b = 0; b < 8; b++) {
      long l1 = paramArrayOfInt3[0] & 0xFFFFFFFFL;
      long l2 = paramArrayOfInt1[b] & 0xFFFFFFFFL;
      long l3 = l2 * l;
      long l4 = (l3 & 0xFFFFFFFFL) + l1;
      long l5 = ((int)l4 * paramInt) & 0xFFFFFFFFL;
      long l6 = l5 * (paramArrayOfInt4[0] & 0xFFFFFFFFL);
      l4 += (l6 & 0xFFFFFFFFL);
      l4 = (l4 >>> 32) + (l3 >>> 32) + (l6 >>> 32);
      for (byte b1 = 1; b1 < 8; b1++) {
        l3 = l2 * (paramArrayOfInt2[b1] & 0xFFFFFFFFL);
        l6 = l5 * (paramArrayOfInt4[b1] & 0xFFFFFFFFL);
        l4 += (l3 & 0xFFFFFFFFL) + (l6 & 0xFFFFFFFFL) + (paramArrayOfInt3[b1] & 0xFFFFFFFFL);
        paramArrayOfInt3[b1 - true] = (int)l4;
        l4 = (l4 >>> 32) + (l3 >>> 32) + (l6 >>> 32);
      } 
      l4 += (i & 0xFFFFFFFFL);
      paramArrayOfInt3[7] = (int)l4;
      i = (int)(l4 >>> 32);
    } 
    if (i != 0 || Nat256.gte(paramArrayOfInt3, paramArrayOfInt4))
      Nat256.sub(paramArrayOfInt3, paramArrayOfInt4, paramArrayOfInt3); 
  }
  
  public static void multAddXF(int[] paramArrayOfInt1, int[] paramArrayOfInt2, int[] paramArrayOfInt3, int[] paramArrayOfInt4) {
    int i = 0;
    long l = paramArrayOfInt2[0] & 0xFFFFFFFFL;
    for (byte b = 0; b < 8; b++) {
      long l1 = paramArrayOfInt1[b] & 0xFFFFFFFFL;
      long l2 = l1 * l + (paramArrayOfInt3[0] & 0xFFFFFFFFL);
      long l3 = l2 & 0xFFFFFFFFL;
      l2 = (l2 >>> 32) + l3;
      for (byte b1 = 1; b1 < 8; b1++) {
        long l4 = l1 * (paramArrayOfInt2[b1] & 0xFFFFFFFFL);
        long l5 = l3 * (paramArrayOfInt4[b1] & 0xFFFFFFFFL);
        l2 += (l4 & 0xFFFFFFFFL) + (l5 & 0xFFFFFFFFL) + (paramArrayOfInt3[b1] & 0xFFFFFFFFL);
        paramArrayOfInt3[b1 - true] = (int)l2;
        l2 = (l2 >>> 32) + (l4 >>> 32) + (l5 >>> 32);
      } 
      l2 += (i & 0xFFFFFFFFL);
      paramArrayOfInt3[7] = (int)l2;
      i = (int)(l2 >>> 32);
    } 
    if (i != 0 || Nat256.gte(paramArrayOfInt3, paramArrayOfInt4))
      Nat256.sub(paramArrayOfInt3, paramArrayOfInt4, paramArrayOfInt3); 
  }
  
  public static void reduce(int[] paramArrayOfInt1, int[] paramArrayOfInt2, int paramInt) {
    for (byte b = 0; b < 8; b++) {
      int i = paramArrayOfInt1[0];
      long l1 = (i * paramInt) & 0xFFFFFFFFL;
      long l2 = l1 * (paramArrayOfInt2[0] & 0xFFFFFFFFL) + (i & 0xFFFFFFFFL);
      l2 >>>= 32;
      for (byte b1 = 1; b1 < 8; b1++) {
        l2 += l1 * (paramArrayOfInt2[b1] & 0xFFFFFFFFL) + (paramArrayOfInt1[b1] & 0xFFFFFFFFL);
        paramArrayOfInt1[b1 - true] = (int)l2;
        l2 >>>= 32;
      } 
      paramArrayOfInt1[7] = (int)l2;
    } 
    if (Nat256.gte(paramArrayOfInt1, paramArrayOfInt2))
      Nat256.sub(paramArrayOfInt1, paramArrayOfInt2, paramArrayOfInt1); 
  }
  
  public static void reduceXF(int[] paramArrayOfInt1, int[] paramArrayOfInt2) {
    for (byte b = 0; b < 8; b++) {
      int i = paramArrayOfInt1[0];
      long l1 = i & 0xFFFFFFFFL;
      long l2 = l1;
      for (byte b1 = 1; b1 < 8; b1++) {
        l2 += l1 * (paramArrayOfInt2[b1] & 0xFFFFFFFFL) + (paramArrayOfInt1[b1] & 0xFFFFFFFFL);
        paramArrayOfInt1[b1 - true] = (int)l2;
        l2 >>>= 32;
      } 
      paramArrayOfInt1[7] = (int)l2;
    } 
    if (Nat256.gte(paramArrayOfInt1, paramArrayOfInt2))
      Nat256.sub(paramArrayOfInt1, paramArrayOfInt2, paramArrayOfInt1); 
  }
}
