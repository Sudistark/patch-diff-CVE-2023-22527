package org.bouncycastle.pkix.jcajce;

import java.io.BufferedInputStream;
import java.io.InputStream;
import java.lang.ref.WeakReference;
import java.net.URL;
import java.security.GeneralSecurityException;
import java.security.PublicKey;
import java.security.cert.CRL;
import java.security.cert.CertPathValidatorException;
import java.security.cert.CertStore;
import java.security.cert.CertStoreException;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.PKIXCertPathChecker;
import java.security.cert.PKIXParameters;
import java.security.cert.TrustAnchor;
import java.security.cert.X509CRL;
import java.security.cert.X509Certificate;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;
import java.util.WeakHashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.security.auth.x500.X500Principal;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x509.CRLDistPoint;
import org.bouncycastle.asn1.x509.DistributionPoint;
import org.bouncycastle.asn1.x509.DistributionPointName;
import org.bouncycastle.asn1.x509.Extension;
import org.bouncycastle.asn1.x509.GeneralName;
import org.bouncycastle.asn1.x509.GeneralNames;
import org.bouncycastle.jcajce.PKIXCRLStore;
import org.bouncycastle.jcajce.PKIXExtendedParameters;
import org.bouncycastle.jcajce.util.DefaultJcaJceHelper;
import org.bouncycastle.jcajce.util.JcaJceHelper;
import org.bouncycastle.jcajce.util.NamedJcaJceHelper;
import org.bouncycastle.jcajce.util.ProviderJcaJceHelper;
import org.bouncycastle.util.CollectionStore;
import org.bouncycastle.util.Store;

public class X509RevocationChecker extends PKIXCertPathChecker {
  public static final int PKIX_VALIDITY_MODEL = 0;
  
  public static final int CHAIN_VALIDITY_MODEL = 1;
  
  private static Logger LOG = Logger.getLogger(X509RevocationChecker.class.getName());
  
  private static final Map<GeneralName, WeakReference<X509CRL>> crlCache = Collections.synchronizedMap(new WeakHashMap());
  
  private final Map<X500Principal, Long> failures = new HashMap();
  
  private final Set<TrustAnchor> trustAnchors;
  
  private final boolean isCheckEEOnly;
  
  private final int validityModel;
  
  private final List<Store<CRL>> crls;
  
  private final List<CertStore> crlCertStores;
  
  private final JcaJceHelper helper;
  
  private final boolean canSoftFail;
  
  private final long failLogMaxTime;
  
  private final long failHardMaxTime;
  
  private Date currentDate;
  
  private X500Principal workingIssuerName;
  
  private PublicKey workingPublicKey;
  
  private X509Certificate signingCert;
  
  protected static final String[] crlReasons = { 
      "unspecified", "keyCompromise", "cACompromise", "affiliationChanged", "superseded", "cessationOfOperation", "certificateHold", "unknown", "removeFromCRL", "privilegeWithdrawn", 
      "aACompromise" };
  
  private X509RevocationChecker(Builder paramBuilder) {
    this.crls = new ArrayList(Builder.access$100(paramBuilder));
    this.crlCertStores = new ArrayList(Builder.access$200(paramBuilder));
    this.isCheckEEOnly = Builder.access$300(paramBuilder);
    this.validityModel = Builder.access$400(paramBuilder);
    this.trustAnchors = Builder.access$500(paramBuilder);
    this.canSoftFail = Builder.access$600(paramBuilder);
    this.failLogMaxTime = Builder.access$700(paramBuilder);
    this.failHardMaxTime = Builder.access$800(paramBuilder);
    if (Builder.access$900(paramBuilder) != null) {
      this.helper = new ProviderJcaJceHelper(Builder.access$900(paramBuilder));
    } else if (Builder.access$1000(paramBuilder) != null) {
      this.helper = new NamedJcaJceHelper(Builder.access$1000(paramBuilder));
    } else {
      this.helper = new DefaultJcaJceHelper();
    } 
  }
  
  public void init(boolean paramBoolean) throws CertPathValidatorException {
    if (paramBoolean)
      throw new IllegalArgumentException("forward processing not supported"); 
    this.currentDate = new Date();
    this.workingIssuerName = null;
  }
  
  public boolean isForwardCheckingSupported() { return false; }
  
  public Set<String> getSupportedExtensions() { return null; }
  
  public void check(Certificate paramCertificate, Collection<String> paramCollection) throws CertPathValidatorException {
    PKIXExtendedParameters.Builder builder;
    X509Certificate x509Certificate = (X509Certificate)paramCertificate;
    if (this.isCheckEEOnly && x509Certificate.getBasicConstraints() != -1) {
      this.workingIssuerName = x509Certificate.getSubjectX500Principal();
      this.workingPublicKey = x509Certificate.getPublicKey();
      this.signingCert = x509Certificate;
      return;
    } 
    TrustAnchor trustAnchor = null;
    if (this.workingIssuerName == null) {
      this.workingIssuerName = x509Certificate.getIssuerX500Principal();
      for (TrustAnchor null : this.trustAnchors) {
        if (this.workingIssuerName.equals(builder.getCA()) || this.workingIssuerName.equals(builder.getTrustedCert().getSubjectX500Principal()))
          trustAnchor = builder; 
      } 
      if (trustAnchor == null)
        throw new CertPathValidatorException("no trust anchor found for " + this.workingIssuerName); 
      this.signingCert = trustAnchor.getTrustedCert();
      this.workingPublicKey = this.signingCert.getPublicKey();
    } 
    ArrayList arrayList = new ArrayList();
    try {
      PKIXParameters pKIXParameters = new PKIXParameters(this.trustAnchors);
      pKIXParameters.setRevocationEnabled(false);
      pKIXParameters.setDate(this.currentDate);
      for (byte b1 = 0; b1 != this.crlCertStores.size(); b1++) {
        if (LOG.isLoggable(Level.INFO))
          addIssuers(arrayList, (CertStore)this.crlCertStores.get(b1)); 
        pKIXParameters.addCertStore((CertStore)this.crlCertStores.get(b1));
      } 
      builder = new PKIXExtendedParameters.Builder(pKIXParameters);
      builder.setValidityModel(this.validityModel);
    } catch (GeneralSecurityException generalSecurityException) {
      throw new RuntimeException("error setting up baseParams: " + generalSecurityException.getMessage());
    } 
    byte b;
    for (b = 0; b != this.crls.size(); b++) {
      if (LOG.isLoggable(Level.INFO))
        addIssuers(arrayList, (Store)this.crls.get(b)); 
      builder.addCRLStore(new LocalCRLStore(this, (Store)this.crls.get(b)));
    } 
    if (arrayList.isEmpty()) {
      LOG.log(Level.INFO, "configured with 0 pre-loaded CRLs");
    } else if (LOG.isLoggable(Level.FINE)) {
      for (b = 0; b != arrayList.size(); b++)
        LOG.log(Level.FINE, "configuring with CRL for issuer \"" + arrayList.get(b) + "\""); 
    } else {
      LOG.log(Level.INFO, "configured with " + arrayList.size() + " pre-loaded CRLs");
    } 
    PKIXExtendedParameters pKIXExtendedParameters = builder.build();
    Date date = RevocationUtilities.getValidityDate(pKIXExtendedParameters, this.currentDate);
    try {
      checkCRLs(pKIXExtendedParameters, this.currentDate, date, x509Certificate, this.signingCert, this.workingPublicKey, new ArrayList(), this.helper);
    } catch (AnnotatedException annotatedException) {
      throw new CertPathValidatorException(annotatedException.getMessage(), annotatedException.getCause());
    } catch (CRLNotFoundException cRLNotFoundException) {
      CRL cRL;
      if (null == x509Certificate.getExtensionValue(Extension.cRLDistributionPoints.getId()))
        throw cRLNotFoundException; 
      try {
        cRL = downloadCRLs(x509Certificate.getIssuerX500Principal(), this.currentDate, RevocationUtilities.getExtensionValue(x509Certificate, Extension.cRLDistributionPoints), this.helper);
      } catch (AnnotatedException annotatedException) {
        throw new CertPathValidatorException(annotatedException.getMessage(), annotatedException.getCause());
      } 
      if (cRL != null) {
        try {
          builder.addCRLStore(new LocalCRLStore(this, new CollectionStore(Collections.singleton(cRL))));
          pKIXExtendedParameters = builder.build();
          date = RevocationUtilities.getValidityDate(pKIXExtendedParameters, this.currentDate);
          checkCRLs(pKIXExtendedParameters, this.currentDate, date, x509Certificate, this.signingCert, this.workingPublicKey, new ArrayList(), this.helper);
        } catch (AnnotatedException annotatedException) {
          throw new CertPathValidatorException(annotatedException.getMessage(), annotatedException.getCause());
        } 
      } else {
        if (!this.canSoftFail)
          throw cRLNotFoundException; 
        X500Principal x500Principal = x509Certificate.getIssuerX500Principal();
        Long long = (Long)this.failures.get(x500Principal);
        if (long != null) {
          long l = System.currentTimeMillis() - long.longValue();
          if (this.failHardMaxTime != -1L && this.failHardMaxTime < l)
            throw cRLNotFoundException; 
          if (l < this.failLogMaxTime) {
            LOG.log(Level.WARNING, "soft failing for issuer: \"" + x500Principal + "\"");
          } else {
            LOG.log(Level.SEVERE, "soft failing for issuer: \"" + x500Principal + "\"");
          } 
        } else {
          this.failures.put(x500Principal, Long.valueOf(System.currentTimeMillis()));
        } 
      } 
    } 
    this.signingCert = x509Certificate;
    this.workingPublicKey = x509Certificate.getPublicKey();
    this.workingIssuerName = x509Certificate.getSubjectX500Principal();
  }
  
  private void addIssuers(List<X500Principal> paramList, CertStore paramCertStore) throws CertStoreException { paramCertStore.getCRLs(new Object(this, paramList)); }
  
  private void addIssuers(List<X500Principal> paramList, Store<CRL> paramStore) { paramStore.getMatches(new Object(this, paramList)); }
  
  private CRL downloadCRLs(X500Principal paramX500Principal, Date paramDate, ASN1Primitive paramASN1Primitive, JcaJceHelper paramJcaJceHelper) {
    CRLDistPoint cRLDistPoint = CRLDistPoint.getInstance(paramASN1Primitive);
    DistributionPoint[] arrayOfDistributionPoint = cRLDistPoint.getDistributionPoints();
    for (byte b = 0; b != arrayOfDistributionPoint.length; b++) {
      DistributionPoint distributionPoint = arrayOfDistributionPoint[b];
      DistributionPointName distributionPointName = distributionPoint.getDistributionPoint();
      if (distributionPointName != null && distributionPointName.getType() == 0) {
        GeneralName[] arrayOfGeneralName = GeneralNames.getInstance(distributionPointName.getName()).getNames();
        for (byte b1 = 0; b1 != arrayOfGeneralName.length; b1++) {
          GeneralName generalName = arrayOfGeneralName[b1];
          if (generalName.getTagNo() == 6) {
            WeakReference weakReference = (WeakReference)crlCache.get(generalName);
            if (weakReference != null) {
              X509CRL x509CRL = (X509CRL)weakReference.get();
              if (x509CRL != null && !paramDate.before(x509CRL.getThisUpdate()) && !paramDate.after(x509CRL.getNextUpdate()))
                return x509CRL; 
              crlCache.remove(generalName);
            } 
            URL uRL = null;
            try {
              uRL = new URL(generalName.getName().toString());
              CertificateFactory certificateFactory = paramJcaJceHelper.createCertificateFactory("X.509");
              InputStream inputStream = uRL.openStream();
              X509CRL x509CRL = (X509CRL)certificateFactory.generateCRL(new BufferedInputStream(inputStream));
              inputStream.close();
              LOG.log(Level.INFO, "downloaded CRL from CrlDP " + uRL + " for issuer \"" + paramX500Principal + "\"");
              crlCache.put(generalName, new WeakReference(x509CRL));
              return x509CRL;
            } catch (Exception exception) {
              if (LOG.isLoggable(Level.FINE)) {
                LOG.log(Level.FINE, "CrlDP " + uRL + " ignored: " + exception.getMessage(), exception);
              } else {
                LOG.log(Level.INFO, "CrlDP " + uRL + " ignored: " + exception.getMessage());
              } 
            } 
          } 
        } 
      } 
    } 
    return null;
  }
  
  static List<PKIXCRLStore> getAdditionalStoresFromCRLDistributionPoint(CRLDistPoint paramCRLDistPoint, Map<GeneralName, PKIXCRLStore> paramMap) throws AnnotatedException {
    DistributionPoint[] arrayOfDistributionPoint;
    if (paramCRLDistPoint == null)
      return Collections.emptyList(); 
    try {
      arrayOfDistributionPoint = paramCRLDistPoint.getDistributionPoints();
    } catch (Exception exception) {
      throw new AnnotatedException("could not read distribution points could not be read", exception);
    } 
    ArrayList arrayList = new ArrayList();
    for (byte b = 0; b < arrayOfDistributionPoint.length; b++) {
      DistributionPointName distributionPointName = arrayOfDistributionPoint[b].getDistributionPoint();
      if (distributionPointName != null && distributionPointName.getType() == 0) {
        GeneralName[] arrayOfGeneralName = GeneralNames.getInstance(distributionPointName.getName()).getNames();
        for (byte b1 = 0; b1 < arrayOfGeneralName.length; b1++) {
          PKIXCRLStore pKIXCRLStore = (PKIXCRLStore)paramMap.get(arrayOfGeneralName[b1]);
          if (pKIXCRLStore != null)
            arrayList.add(pKIXCRLStore); 
        } 
      } 
    } 
    return arrayList;
  }
  
  protected void checkCRLs(PKIXExtendedParameters paramPKIXExtendedParameters, Date paramDate1, Date paramDate2, X509Certificate paramX509Certificate1, X509Certificate paramX509Certificate2, PublicKey paramPublicKey, List paramList, JcaJceHelper paramJcaJceHelper) throws AnnotatedException, CertPathValidatorException {
    CRLDistPoint cRLDistPoint;
    try {
      cRLDistPoint = CRLDistPoint.getInstance(RevocationUtilities.getExtensionValue(paramX509Certificate1, Extension.cRLDistributionPoints));
    } catch (Exception exception) {
      throw new AnnotatedException("cannot read CRL distribution point extension", exception);
    } 
    CertStatus certStatus = new CertStatus();
    ReasonsMask reasonsMask = new ReasonsMask();
    AnnotatedException annotatedException = null;
    boolean bool = false;
    if (cRLDistPoint != null) {
      DistributionPoint[] arrayOfDistributionPoint;
      try {
        arrayOfDistributionPoint = cRLDistPoint.getDistributionPoints();
      } catch (Exception exception) {
        throw new AnnotatedException("cannot read distribution points", exception);
      } 
      if (arrayOfDistributionPoint != null) {
        PKIXExtendedParameters.Builder builder = new PKIXExtendedParameters.Builder(paramPKIXExtendedParameters);
        try {
          List list = getAdditionalStoresFromCRLDistributionPoint(cRLDistPoint, paramPKIXExtendedParameters.getNamedCRLStoreMap());
          Iterator iterator = list.iterator();
          while (iterator.hasNext())
            builder.addCRLStore((PKIXCRLStore)iterator.next()); 
        } catch (AnnotatedException annotatedException1) {
          throw new AnnotatedException("no additional CRL locations could be decoded from CRL distribution point extension", annotatedException1);
        } 
        PKIXExtendedParameters pKIXExtendedParameters = builder.build();
        Date date = RevocationUtilities.getValidityDate(pKIXExtendedParameters, paramDate1);
        for (byte b = 0; b < arrayOfDistributionPoint.length && certStatus.getCertStatus() == 11 && !reasonsMask.isAllReasons(); b++) {
          try {
            RFC3280CertPathUtilities.checkCRL(arrayOfDistributionPoint[b], pKIXExtendedParameters, paramDate1, date, paramX509Certificate1, paramX509Certificate2, paramPublicKey, certStatus, reasonsMask, paramList, paramJcaJceHelper);
            bool = true;
          } catch (AnnotatedException annotatedException1) {
            annotatedException = annotatedException1;
          } 
        } 
      } 
    } 
    if (certStatus.getCertStatus() == 11 && !reasonsMask.isAllReasons())
      try {
        X500Principal x500Principal = paramX509Certificate1.getIssuerX500Principal();
        DistributionPoint distributionPoint = new DistributionPoint(new DistributionPointName(0, new GeneralNames(new GeneralName(4, X500Name.getInstance(x500Principal.getEncoded())))), null, null);
        PKIXExtendedParameters pKIXExtendedParameters = (PKIXExtendedParameters)paramPKIXExtendedParameters.clone();
        RFC3280CertPathUtilities.checkCRL(distributionPoint, pKIXExtendedParameters, paramDate1, paramDate2, paramX509Certificate1, paramX509Certificate2, paramPublicKey, certStatus, reasonsMask, paramList, paramJcaJceHelper);
        bool = true;
      } catch (AnnotatedException annotatedException1) {
        annotatedException = annotatedException1;
      }  
    if (!bool) {
      if (annotatedException instanceof AnnotatedException)
        throw new CRLNotFoundException("no valid CRL found", annotatedException); 
      throw new CRLNotFoundException("no valid CRL found");
    } 
    if (certStatus.getCertStatus() != 11) {
      SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
      simpleDateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
      String str = "certificate [issuer=\"" + paramX509Certificate1.getIssuerX500Principal() + "\",serialNumber=" + paramX509Certificate1.getSerialNumber() + ",subject=\"" + paramX509Certificate1.getSubjectX500Principal() + "\"] revoked after " + simpleDateFormat.format(certStatus.getRevocationDate());
      str = str + ", reason: " + crlReasons[certStatus.getCertStatus()];
      throw new AnnotatedException(str);
    } 
    if (!reasonsMask.isAllReasons() && certStatus.getCertStatus() == 11)
      certStatus.setCertStatus(12); 
    if (certStatus.getCertStatus() == 12)
      throw new AnnotatedException("certificate status could not be determined"); 
  }
  
  public Object clone() { return this; }
}
