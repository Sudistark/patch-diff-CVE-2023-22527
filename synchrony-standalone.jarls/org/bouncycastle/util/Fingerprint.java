package org.bouncycastle.util;

import org.bouncycastle.crypto.digests.SHA512tDigest;
import org.bouncycastle.crypto.digests.SHAKEDigest;

public class Fingerprint {
  private static char[] encodingTable = { 
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
      'a', 'b', 'c', 'd', 'e', 'f' };
  
  private final byte[] fingerprint;
  
  public Fingerprint(byte[] paramArrayOfByte) { this(paramArrayOfByte, 160); }
  
  public Fingerprint(byte[] paramArrayOfByte, int paramInt) { this.fingerprint = calculateFingerprint(paramArrayOfByte, paramInt); }
  
  public Fingerprint(byte[] paramArrayOfByte, boolean paramBoolean) {
    if (paramBoolean) {
      this.fingerprint = calculateFingerprintSHA512_160(paramArrayOfByte);
    } else {
      this.fingerprint = calculateFingerprint(paramArrayOfByte);
    } 
  }
  
  public byte[] getFingerprint() { return Arrays.clone(this.fingerprint); }
  
  public String toString() {
    StringBuffer stringBuffer = new StringBuffer();
    for (byte b = 0; b != this.fingerprint.length; b++) {
      if (b)
        stringBuffer.append(":"); 
      stringBuffer.append(encodingTable[this.fingerprint[b] >>> 4 & 0xF]);
      stringBuffer.append(encodingTable[this.fingerprint[b] & 0xF]);
    } 
    return stringBuffer.toString();
  }
  
  public boolean equals(Object paramObject) { return (paramObject == this) ? true : ((paramObject instanceof Fingerprint) ? Arrays.areEqual(((Fingerprint)paramObject).fingerprint, this.fingerprint) : 0); }
  
  public int hashCode() { return Arrays.hashCode(this.fingerprint); }
  
  public static byte[] calculateFingerprint(byte[] paramArrayOfByte) { return calculateFingerprint(paramArrayOfByte, 160); }
  
  public static byte[] calculateFingerprint(byte[] paramArrayOfByte, int paramInt) {
    if (paramInt % 8 != 0)
      throw new IllegalArgumentException("bitLength must be a multiple of 8"); 
    SHAKEDigest sHAKEDigest = new SHAKEDigest(256);
    sHAKEDigest.update(paramArrayOfByte, 0, paramArrayOfByte.length);
    byte[] arrayOfByte = new byte[paramInt / 8];
    sHAKEDigest.doFinal(arrayOfByte, 0, paramInt / 8);
    return arrayOfByte;
  }
  
  public static byte[] calculateFingerprintSHA512_160(byte[] paramArrayOfByte) {
    SHA512tDigest sHA512tDigest = new SHA512tDigest(160);
    sHA512tDigest.update(paramArrayOfByte, 0, paramArrayOfByte.length);
    byte[] arrayOfByte = new byte[sHA512tDigest.getDigestSize()];
    sHA512tDigest.doFinal(arrayOfByte, 0);
    return arrayOfByte;
  }
}
