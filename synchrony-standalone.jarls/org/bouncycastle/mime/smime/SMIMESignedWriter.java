package org.bouncycastle.mime.smime;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import org.bouncycastle.cms.CMSAlgorithm;
import org.bouncycastle.cms.CMSSignedDataStreamGenerator;
import org.bouncycastle.mime.Headers;
import org.bouncycastle.mime.MimeWriter;
import org.bouncycastle.mime.encoding.Base64OutputStream;
import org.bouncycastle.util.Strings;

public class SMIMESignedWriter extends MimeWriter {
  public static final Map RFC3851_MICALGS;
  
  public static final Map RFC5751_MICALGS;
  
  public static final Map STANDARD_MICALGS;
  
  private final CMSSignedDataStreamGenerator sigGen;
  
  private final String boundary;
  
  private final OutputStream mimeOut;
  
  private final String contentTransferEncoding;
  
  private SMIMESignedWriter(Builder paramBuilder, Map<String, String> paramMap, String paramString, OutputStream paramOutputStream) {
    super(new Headers(mapToLines(paramMap), paramBuilder.contentTransferEncoding));
    this.sigGen = Builder.access$100(paramBuilder);
    this.contentTransferEncoding = paramBuilder.contentTransferEncoding;
    this.boundary = paramString;
    this.mimeOut = paramOutputStream;
  }
  
  public OutputStream getContentStream() throws IOException {
    this.headers.dumpHeaders(this.mimeOut);
    this.mimeOut.write(Strings.toByteArray("\r\n"));
    if (this.boundary == null)
      return null; 
    this.mimeOut.write(Strings.toByteArray("This is an S/MIME signed message\r\n"));
    this.mimeOut.write(Strings.toByteArray("\r\n--"));
    this.mimeOut.write(Strings.toByteArray(this.boundary));
    this.mimeOut.write(Strings.toByteArray("\r\n"));
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
    Base64OutputStream base64OutputStream = new Base64OutputStream(byteArrayOutputStream);
    return new ContentOutputStream(this, this.sigGen.open(base64OutputStream, false, SMimeUtils.createUnclosable(this.mimeOut)), this.mimeOut, byteArrayOutputStream, base64OutputStream);
  }
  
  static  {
    HashMap hashMap1 = new HashMap();
    hashMap1.put(CMSAlgorithm.MD5, "md5");
    hashMap1.put(CMSAlgorithm.SHA1, "sha-1");
    hashMap1.put(CMSAlgorithm.SHA224, "sha-224");
    hashMap1.put(CMSAlgorithm.SHA256, "sha-256");
    hashMap1.put(CMSAlgorithm.SHA384, "sha-384");
    hashMap1.put(CMSAlgorithm.SHA512, "sha-512");
    hashMap1.put(CMSAlgorithm.GOST3411, "gostr3411-94");
    hashMap1.put(CMSAlgorithm.GOST3411_2012_256, "gostr3411-2012-256");
    hashMap1.put(CMSAlgorithm.GOST3411_2012_512, "gostr3411-2012-512");
    RFC5751_MICALGS = Collections.unmodifiableMap(hashMap1);
    HashMap hashMap2 = new HashMap();
    hashMap2.put(CMSAlgorithm.MD5, "md5");
    hashMap2.put(CMSAlgorithm.SHA1, "sha1");
    hashMap2.put(CMSAlgorithm.SHA224, "sha224");
    hashMap2.put(CMSAlgorithm.SHA256, "sha256");
    hashMap2.put(CMSAlgorithm.SHA384, "sha384");
    hashMap2.put(CMSAlgorithm.SHA512, "sha512");
    hashMap2.put(CMSAlgorithm.GOST3411, "gostr3411-94");
    hashMap2.put(CMSAlgorithm.GOST3411_2012_256, "gostr3411-2012-256");
    hashMap2.put(CMSAlgorithm.GOST3411_2012_512, "gostr3411-2012-512");
    RFC3851_MICALGS = Collections.unmodifiableMap(hashMap2);
    STANDARD_MICALGS = RFC5751_MICALGS;
  }
}
