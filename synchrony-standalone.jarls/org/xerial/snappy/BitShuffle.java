package org.xerial.snappy;

import java.io.IOException;
import java.nio.ByteBuffer;

public class BitShuffle {
  private static BitShuffleNative impl;
  
  static  {
    try {
      impl = SnappyLoader.loadBitShuffleApi();
    } catch (Exception exception) {
      throw new ExceptionInInitializerError(exception);
    } 
  }
  
  public static int shuffle(ByteBuffer paramByteBuffer1, BitShuffleType paramBitShuffleType, ByteBuffer paramByteBuffer2) throws IOException {
    if (!paramByteBuffer1.isDirect())
      throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, "input is not a direct buffer"); 
    if (!paramByteBuffer2.isDirect())
      throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, "destination is not a direct buffer"); 
    int i = paramByteBuffer1.position();
    int j = paramByteBuffer1.remaining();
    int k = paramBitShuffleType.getTypeSize();
    if (j % k != 0)
      throw new IllegalArgumentException("input length must be a multiple of the given type size: " + k); 
    if (paramByteBuffer2.remaining() < j)
      throw new IllegalArgumentException("not enough space for output"); 
    int m = impl.shuffleDirectBuffer(paramByteBuffer1, i, k, j, paramByteBuffer2, paramByteBuffer2.position());
    assert m == j;
    paramByteBuffer2.limit(paramByteBuffer2.position() + m);
    return m;
  }
  
  public static byte[] shuffle(short[] paramArrayOfShort) throws IOException {
    byte[] arrayOfByte = new byte[paramArrayOfShort.length * 2];
    int i = impl.shuffle(paramArrayOfShort, 0, 2, paramArrayOfShort.length * 2, arrayOfByte, 0);
    assert i == paramArrayOfShort.length * 2;
    return arrayOfByte;
  }
  
  public static byte[] shuffle(int[] paramArrayOfInt) throws IOException {
    byte[] arrayOfByte = new byte[paramArrayOfInt.length * 4];
    int i = impl.shuffle(paramArrayOfInt, 0, 4, paramArrayOfInt.length * 4, arrayOfByte, 0);
    assert i == paramArrayOfInt.length * 4;
    return arrayOfByte;
  }
  
  public static byte[] shuffle(long[] paramArrayOfLong) throws IOException {
    byte[] arrayOfByte = new byte[paramArrayOfLong.length * 8];
    int i = impl.shuffle(paramArrayOfLong, 0, 8, paramArrayOfLong.length * 8, arrayOfByte, 0);
    assert i == paramArrayOfLong.length * 8;
    return arrayOfByte;
  }
  
  public static byte[] shuffle(float[] paramArrayOfFloat) throws IOException {
    byte[] arrayOfByte = new byte[paramArrayOfFloat.length * 4];
    int i = impl.shuffle(paramArrayOfFloat, 0, 4, paramArrayOfFloat.length * 4, arrayOfByte, 0);
    assert i == paramArrayOfFloat.length * 4;
    return arrayOfByte;
  }
  
  public static byte[] shuffle(double[] paramArrayOfDouble) throws IOException {
    byte[] arrayOfByte = new byte[paramArrayOfDouble.length * 8];
    int i = impl.shuffle(paramArrayOfDouble, 0, 8, paramArrayOfDouble.length * 8, arrayOfByte, 0);
    assert i == paramArrayOfDouble.length * 8;
    return arrayOfByte;
  }
  
  public static int unshuffle(ByteBuffer paramByteBuffer1, BitShuffleType paramBitShuffleType, ByteBuffer paramByteBuffer2) throws IOException {
    if (!paramByteBuffer1.isDirect())
      throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, "input is not a direct buffer"); 
    if (!paramByteBuffer2.isDirect())
      throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, "destination is not a direct buffer"); 
    int i = paramByteBuffer1.position();
    int j = paramByteBuffer1.remaining();
    int k = paramBitShuffleType.getTypeSize();
    if (j % k != 0)
      throw new IllegalArgumentException("length of input shuffled data must be a multiple of the given type size: " + k); 
    if (paramByteBuffer2.remaining() < j)
      throw new IllegalArgumentException("not enough space for output"); 
    int m = impl.unshuffleDirectBuffer(paramByteBuffer1, i, k, j, paramByteBuffer2, paramByteBuffer1.position());
    assert m == j;
    paramByteBuffer1.limit(paramByteBuffer1.position() + m);
    return m;
  }
  
  public static short[] unshuffleShortArray(byte[] paramArrayOfByte) throws IOException {
    short[] arrayOfShort = new short[paramArrayOfByte.length / 2];
    int i = impl.unshuffle(paramArrayOfByte, 0, 2, paramArrayOfByte.length, arrayOfShort, 0);
    assert i == paramArrayOfByte.length;
    return arrayOfShort;
  }
  
  public static int[] unshuffleIntArray(byte[] paramArrayOfByte) throws IOException {
    int[] arrayOfInt = new int[paramArrayOfByte.length / 4];
    int i = impl.unshuffle(paramArrayOfByte, 0, 4, paramArrayOfByte.length, arrayOfInt, 0);
    assert i == paramArrayOfByte.length;
    return arrayOfInt;
  }
  
  public static long[] unshuffleLongArray(byte[] paramArrayOfByte) throws IOException {
    long[] arrayOfLong = new long[paramArrayOfByte.length / 8];
    int i = impl.unshuffle(paramArrayOfByte, 0, 8, paramArrayOfByte.length, arrayOfLong, 0);
    assert i == paramArrayOfByte.length;
    return arrayOfLong;
  }
  
  public static float[] unshuffleFloatArray(byte[] paramArrayOfByte) throws IOException {
    float[] arrayOfFloat = new float[paramArrayOfByte.length / 4];
    int i = impl.unshuffle(paramArrayOfByte, 0, 4, paramArrayOfByte.length, arrayOfFloat, 0);
    assert i == paramArrayOfByte.length;
    return arrayOfFloat;
  }
  
  public static double[] unshuffleDoubleArray(byte[] paramArrayOfByte) throws IOException {
    double[] arrayOfDouble = new double[paramArrayOfByte.length / 8];
    int i = impl.unshuffle(paramArrayOfByte, 0, 8, paramArrayOfByte.length, arrayOfDouble, 0);
    assert i == paramArrayOfByte.length;
    return arrayOfDouble;
  }
}
