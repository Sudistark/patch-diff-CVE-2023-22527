package org.xerial.snappy;

import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.util.Properties;

public class Snappy {
  private static SnappyApi impl;
  
  static  {
    init();
  }
  
  public static void cleanUp() {
    SnappyLoader.cleanUpExtractedNativeLib();
    SnappyLoader.setSnappyApi(null);
  }
  
  static void init() {
    try {
      impl = SnappyLoader.loadSnappyApi();
    } catch (Exception exception) {
      throw new ExceptionInInitializerError(exception);
    } 
  }
  
  public static void arrayCopy(Object paramObject1, int paramInt1, int paramInt2, Object paramObject2, int paramInt3) throws IOException { impl.arrayCopy(paramObject1, paramInt1, paramInt2, paramObject2, paramInt3); }
  
  public static byte[] compress(byte[] paramArrayOfByte) throws IOException { return rawCompress(paramArrayOfByte, paramArrayOfByte.length); }
  
  public static int compress(byte[] paramArrayOfByte1, int paramInt1, int paramInt2, byte[] paramArrayOfByte2, int paramInt3) throws IOException { return rawCompress(paramArrayOfByte1, paramInt1, paramInt2, paramArrayOfByte2, paramInt3); }
  
  public static int compress(ByteBuffer paramByteBuffer1, ByteBuffer paramByteBuffer2) throws IOException {
    if (!paramByteBuffer1.isDirect())
      throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, "input is not a direct buffer"); 
    if (!paramByteBuffer2.isDirect())
      throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, "destination is not a direct buffer"); 
    int i = paramByteBuffer1.position();
    int j = paramByteBuffer1.remaining();
    int k = impl.rawCompress(paramByteBuffer1, i, j, paramByteBuffer2, paramByteBuffer2
        .position());
    paramByteBuffer2.limit(paramByteBuffer2.position() + k);
    return k;
  }
  
  public static byte[] compress(char[] paramArrayOfChar) throws IOException { return rawCompress(paramArrayOfChar, paramArrayOfChar.length * 2); }
  
  public static byte[] compress(double[] paramArrayOfDouble) throws IOException { return rawCompress(paramArrayOfDouble, paramArrayOfDouble.length * 8); }
  
  public static byte[] compress(float[] paramArrayOfFloat) throws IOException { return rawCompress(paramArrayOfFloat, paramArrayOfFloat.length * 4); }
  
  public static byte[] compress(int[] paramArrayOfInt) throws IOException { return rawCompress(paramArrayOfInt, paramArrayOfInt.length * 4); }
  
  public static byte[] compress(long[] paramArrayOfLong) throws IOException { return rawCompress(paramArrayOfLong, paramArrayOfLong.length * 8); }
  
  public static byte[] compress(short[] paramArrayOfShort) throws IOException { return rawCompress(paramArrayOfShort, paramArrayOfShort.length * 2); }
  
  public static byte[] compress(String paramString) throws IOException {
    try {
      return compress(paramString, "UTF-8");
    } catch (UnsupportedEncodingException unsupportedEncodingException) {
      throw new IllegalStateException("UTF-8 encoder is not found");
    } 
  }
  
  public static byte[] compress(String paramString1, String paramString2) throws UnsupportedEncodingException, IOException {
    byte[] arrayOfByte = paramString1.getBytes(paramString2);
    return compress(arrayOfByte);
  }
  
  public static byte[] compress(String paramString, Charset paramCharset) throws IOException {
    byte[] arrayOfByte = paramString.getBytes(paramCharset);
    return compress(arrayOfByte);
  }
  
  public static String getNativeLibraryVersion() {
    URL uRL = SnappyLoader.class.getResource("/org/xerial/snappy/VERSION");
    String str = "unknown";
    try {
      if (uRL != null) {
        inputStream = null;
        try {
          Properties properties = new Properties();
          inputStream = uRL.openStream();
          properties.load(inputStream);
          str = properties.getProperty("version", str);
          if (str.equals("unknown"))
            str = properties.getProperty("SNAPPY_VERSION", str); 
          str = str.trim().replaceAll("[^0-9\\.]", "");
        } finally {
          if (inputStream != null)
            inputStream.close(); 
        } 
      } 
    } catch (IOException iOException) {
      iOException.printStackTrace();
    } 
    return str;
  }
  
  public static boolean isValidCompressedBuffer(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException {
    if (paramArrayOfByte == null)
      throw new NullPointerException("input is null"); 
    return impl.isValidCompressedBuffer(paramArrayOfByte, paramInt1, paramInt2);
  }
  
  public static boolean isValidCompressedBuffer(byte[] paramArrayOfByte) throws IOException { return isValidCompressedBuffer(paramArrayOfByte, 0, paramArrayOfByte.length); }
  
  public static boolean isValidCompressedBuffer(ByteBuffer paramByteBuffer) throws IOException {
    return impl.isValidCompressedBuffer(paramByteBuffer, paramByteBuffer.position(), paramByteBuffer
        .remaining());
  }
  
  public static boolean isValidCompressedBuffer(long paramLong1, long paramLong2, long paramLong3) throws IOException { return impl.isValidCompressedBuffer(paramLong1, paramLong2, paramLong3); }
  
  public static int maxCompressedLength(int paramInt) { return impl.maxCompressedLength(paramInt); }
  
  public static long rawCompress(long paramLong1, long paramLong2, long paramLong3) throws IOException { return impl.rawCompress(paramLong1, paramLong2, paramLong3); }
  
  public static long rawUncompress(long paramLong1, long paramLong2, long paramLong3) throws IOException { return impl.rawUncompress(paramLong1, paramLong2, paramLong3); }
  
  public static byte[] rawCompress(Object paramObject, int paramInt) throws IOException {
    byte[] arrayOfByte1 = new byte[maxCompressedLength(paramInt)];
    int i = impl.rawCompress(paramObject, 0, paramInt, arrayOfByte1, 0);
    byte[] arrayOfByte2 = new byte[i];
    System.arraycopy(arrayOfByte1, 0, arrayOfByte2, 0, i);
    return arrayOfByte2;
  }
  
  public static int rawCompress(Object paramObject, int paramInt1, int paramInt2, byte[] paramArrayOfByte, int paramInt3) throws IOException {
    if (paramObject == null || paramArrayOfByte == null)
      throw new NullPointerException("input or output is null"); 
    return impl.rawCompress(paramObject, paramInt1, paramInt2, paramArrayOfByte, paramInt3);
  }
  
  public static int rawUncompress(byte[] paramArrayOfByte, int paramInt1, int paramInt2, Object paramObject, int paramInt3) throws IOException {
    if (paramArrayOfByte == null || paramObject == null)
      throw new NullPointerException("input or output is null"); 
    return impl.rawUncompress(paramArrayOfByte, paramInt1, paramInt2, paramObject, paramInt3);
  }
  
  public static byte[] uncompress(byte[] paramArrayOfByte) throws IOException {
    byte[] arrayOfByte = new byte[uncompressedLength(paramArrayOfByte)];
    uncompress(paramArrayOfByte, 0, paramArrayOfByte.length, arrayOfByte, 0);
    return arrayOfByte;
  }
  
  public static int uncompress(byte[] paramArrayOfByte1, int paramInt1, int paramInt2, byte[] paramArrayOfByte2, int paramInt3) throws IOException { return rawUncompress(paramArrayOfByte1, paramInt1, paramInt2, paramArrayOfByte2, paramInt3); }
  
  public static int uncompress(ByteBuffer paramByteBuffer1, ByteBuffer paramByteBuffer2) throws IOException {
    if (!paramByteBuffer1.isDirect())
      throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, "input is not a direct buffer"); 
    if (!paramByteBuffer2.isDirect())
      throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, "destination is not a direct buffer"); 
    int i = paramByteBuffer1.position();
    int j = paramByteBuffer1.remaining();
    int k = impl.rawUncompress(paramByteBuffer1, i, j, paramByteBuffer2, paramByteBuffer2
        .position());
    paramByteBuffer2.limit(paramByteBuffer2.position() + k);
    return k;
  }
  
  public static char[] uncompressCharArray(byte[] paramArrayOfByte) throws IOException { return uncompressCharArray(paramArrayOfByte, 0, paramArrayOfByte.length); }
  
  public static char[] uncompressCharArray(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException {
    int i = uncompressedLength(paramArrayOfByte, paramInt1, paramInt2);
    char[] arrayOfChar = new char[i / 2];
    impl.rawUncompress(paramArrayOfByte, paramInt1, paramInt2, arrayOfChar, 0);
    return arrayOfChar;
  }
  
  public static double[] uncompressDoubleArray(byte[] paramArrayOfByte) throws IOException {
    int i = uncompressedLength(paramArrayOfByte, 0, paramArrayOfByte.length);
    double[] arrayOfDouble = new double[i / 8];
    impl.rawUncompress(paramArrayOfByte, 0, paramArrayOfByte.length, arrayOfDouble, 0);
    return arrayOfDouble;
  }
  
  public static int uncompressedLength(byte[] paramArrayOfByte) throws IOException { return impl.uncompressedLength(paramArrayOfByte, 0, paramArrayOfByte.length); }
  
  public static int uncompressedLength(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException {
    if (paramArrayOfByte == null)
      throw new NullPointerException("input is null"); 
    return impl.uncompressedLength(paramArrayOfByte, paramInt1, paramInt2);
  }
  
  public static int uncompressedLength(ByteBuffer paramByteBuffer) throws IOException {
    if (!paramByteBuffer.isDirect())
      throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, "input is not a direct buffer"); 
    return impl.uncompressedLength(paramByteBuffer, paramByteBuffer.position(), paramByteBuffer.remaining());
  }
  
  public static long uncompressedLength(long paramLong1, long paramLong2) throws IOException { return impl.uncompressedLength(paramLong1, paramLong2); }
  
  public static float[] uncompressFloatArray(byte[] paramArrayOfByte) throws IOException { return uncompressFloatArray(paramArrayOfByte, 0, paramArrayOfByte.length); }
  
  public static float[] uncompressFloatArray(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException {
    int i = uncompressedLength(paramArrayOfByte, paramInt1, paramInt2);
    float[] arrayOfFloat = new float[i / 4];
    impl.rawUncompress(paramArrayOfByte, paramInt1, paramInt2, arrayOfFloat, 0);
    return arrayOfFloat;
  }
  
  public static int[] uncompressIntArray(byte[] paramArrayOfByte) throws IOException { return uncompressIntArray(paramArrayOfByte, 0, paramArrayOfByte.length); }
  
  public static int[] uncompressIntArray(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException {
    int i = uncompressedLength(paramArrayOfByte, paramInt1, paramInt2);
    int[] arrayOfInt = new int[i / 4];
    impl.rawUncompress(paramArrayOfByte, paramInt1, paramInt2, arrayOfInt, 0);
    return arrayOfInt;
  }
  
  public static long[] uncompressLongArray(byte[] paramArrayOfByte) throws IOException { return uncompressLongArray(paramArrayOfByte, 0, paramArrayOfByte.length); }
  
  public static long[] uncompressLongArray(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException {
    int i = uncompressedLength(paramArrayOfByte, paramInt1, paramInt2);
    long[] arrayOfLong = new long[i / 8];
    impl.rawUncompress(paramArrayOfByte, paramInt1, paramInt2, arrayOfLong, 0);
    return arrayOfLong;
  }
  
  public static short[] uncompressShortArray(byte[] paramArrayOfByte) throws IOException { return uncompressShortArray(paramArrayOfByte, 0, paramArrayOfByte.length); }
  
  public static short[] uncompressShortArray(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException {
    int i = uncompressedLength(paramArrayOfByte, paramInt1, paramInt2);
    short[] arrayOfShort = new short[i / 2];
    impl.rawUncompress(paramArrayOfByte, paramInt1, paramInt2, arrayOfShort, 0);
    return arrayOfShort;
  }
  
  public static String uncompressString(byte[] paramArrayOfByte) throws IOException {
    try {
      return uncompressString(paramArrayOfByte, "UTF-8");
    } catch (UnsupportedEncodingException unsupportedEncodingException) {
      throw new IllegalStateException("UTF-8 decoder is not found");
    } 
  }
  
  public static String uncompressString(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException {
    try {
      return uncompressString(paramArrayOfByte, paramInt1, paramInt2, "UTF-8");
    } catch (UnsupportedEncodingException unsupportedEncodingException) {
      throw new IllegalStateException("UTF-8 decoder is not found");
    } 
  }
  
  public static String uncompressString(byte[] paramArrayOfByte, int paramInt1, int paramInt2, String paramString) throws IOException, UnsupportedEncodingException {
    byte[] arrayOfByte = new byte[uncompressedLength(paramArrayOfByte, paramInt1, paramInt2)];
    uncompress(paramArrayOfByte, paramInt1, paramInt2, arrayOfByte, 0);
    return new String(arrayOfByte, paramString);
  }
  
  public static String uncompressString(byte[] paramArrayOfByte, int paramInt1, int paramInt2, Charset paramCharset) throws IOException, UnsupportedEncodingException {
    byte[] arrayOfByte = new byte[uncompressedLength(paramArrayOfByte, paramInt1, paramInt2)];
    uncompress(paramArrayOfByte, paramInt1, paramInt2, arrayOfByte, 0);
    return new String(arrayOfByte, paramCharset);
  }
  
  public static String uncompressString(byte[] paramArrayOfByte, String paramString) throws IOException, UnsupportedEncodingException {
    byte[] arrayOfByte = uncompress(paramArrayOfByte);
    return new String(arrayOfByte, paramString);
  }
  
  public static String uncompressString(byte[] paramArrayOfByte, Charset paramCharset) throws IOException, UnsupportedEncodingException {
    byte[] arrayOfByte = uncompress(paramArrayOfByte);
    return new String(arrayOfByte, paramCharset);
  }
}
