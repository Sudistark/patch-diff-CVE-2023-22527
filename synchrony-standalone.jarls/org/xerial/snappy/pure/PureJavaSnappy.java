package org.xerial.snappy.pure;

import java.io.IOException;
import java.lang.ref.SoftReference;
import java.nio.ByteBuffer;
import java.util.concurrent.ConcurrentLinkedDeque;
import org.xerial.snappy.SnappyApi;
import sun.misc.Unsafe;

public class PureJavaSnappy implements SnappyApi {
  private static final ConcurrentLinkedDeque<SoftReference<short[]>> CACHED_TABLES = new ConcurrentLinkedDeque();
  
  private static final int MAX_OUTPUT_LENGTH = 2147483647;
  
  public long rawCompress(long paramLong1, long paramLong2, long paramLong3) throws IOException {
    arrayOfShort = getTable();
    try {
      return SnappyRawCompressor.compress(null, paramLong1, paramLong2, null, paramLong3, 2147483647L, arrayOfShort);
    } finally {
      returnTable(arrayOfShort);
    } 
  }
  
  public long rawUncompress(long paramLong1, long paramLong2, long paramLong3) throws IOException { return SnappyRawDecompressor.decompress(null, paramLong1, paramLong2, null, paramLong3, 2147483647L); }
  
  public int rawCompress(ByteBuffer paramByteBuffer1, int paramInt1, int paramInt2, ByteBuffer paramByteBuffer2, int paramInt3) throws IOException {
    long l4;
    long l3;
    byte[] arrayOfByte2;
    long l2;
    long l1;
    byte[] arrayOfByte1;
    if (paramByteBuffer1.isDirect()) {
      arrayOfByte1 = null;
      long l = UnsafeUtil.getAddress(paramByteBuffer1);
      l1 = l + paramByteBuffer1.position();
      l2 = l + paramByteBuffer1.limit();
    } else if (paramByteBuffer1.hasArray()) {
      arrayOfByte1 = paramByteBuffer1.array();
      l1 = (Unsafe.ARRAY_BYTE_BASE_OFFSET + paramByteBuffer1.arrayOffset() + paramByteBuffer1.position());
      l2 = (Unsafe.ARRAY_BYTE_BASE_OFFSET + paramByteBuffer1.arrayOffset() + paramByteBuffer1.limit());
    } else {
      throw new IllegalArgumentException("Unsupported input ByteBuffer implementation " + paramByteBuffer1.getClass().getName());
    } 
    if (paramByteBuffer2.isDirect()) {
      arrayOfByte2 = null;
      long l = UnsafeUtil.getAddress(paramByteBuffer2);
      l3 = l + paramByteBuffer2.position();
      l4 = l + paramByteBuffer2.limit();
    } else if (paramByteBuffer2.hasArray()) {
      arrayOfByte2 = paramByteBuffer2.array();
      l3 = (Unsafe.ARRAY_BYTE_BASE_OFFSET + paramByteBuffer2.arrayOffset() + paramByteBuffer2.position());
      l4 = (Unsafe.ARRAY_BYTE_BASE_OFFSET + paramByteBuffer2.arrayOffset() + paramByteBuffer2.limit());
    } else {
      throw new IllegalArgumentException("Unsupported output ByteBuffer implementation " + paramByteBuffer2.getClass().getName());
    } 
    synchronized (paramByteBuffer1) {
      synchronized (paramByteBuffer2) {
        arrayOfShort = getTable();
        try {
          int i = SnappyRawCompressor.compress(arrayOfByte1, l1, l2, arrayOfByte2, l3, l4, arrayOfShort);
          paramByteBuffer2.position(paramByteBuffer2.position() + i);
          return i;
        } finally {
          returnTable(arrayOfShort);
        } 
      } 
    } 
  }
  
  public int rawCompress(Object paramObject1, int paramInt1, int paramInt2, Object paramObject2, int paramInt3) throws IOException {
    long l1 = (Unsafe.ARRAY_BYTE_BASE_OFFSET + paramInt1);
    long l2 = l1 + paramInt2;
    long l3 = (Unsafe.ARRAY_BYTE_BASE_OFFSET + paramInt3);
    long l4 = l3 + 2147483647L;
    arrayOfShort = getTable();
    try {
      return SnappyRawCompressor.compress(paramObject1, l1, l2, paramObject2, l3, l4, arrayOfShort);
    } finally {
      returnTable(arrayOfShort);
    } 
  }
  
  public int rawUncompress(ByteBuffer paramByteBuffer1, int paramInt1, int paramInt2, ByteBuffer paramByteBuffer2, int paramInt3) throws IOException {
    long l4;
    long l3;
    byte[] arrayOfByte2;
    long l2;
    long l1;
    byte[] arrayOfByte1;
    if (paramByteBuffer1.isDirect()) {
      arrayOfByte1 = null;
      long l = UnsafeUtil.getAddress(paramByteBuffer1);
      l1 = l + paramByteBuffer1.position();
      l2 = l + paramByteBuffer1.limit();
    } else if (paramByteBuffer1.hasArray()) {
      arrayOfByte1 = paramByteBuffer1.array();
      l1 = (Unsafe.ARRAY_BYTE_BASE_OFFSET + paramByteBuffer1.arrayOffset() + paramByteBuffer1.position());
      l2 = (Unsafe.ARRAY_BYTE_BASE_OFFSET + paramByteBuffer1.arrayOffset() + paramByteBuffer1.limit());
    } else {
      throw new IllegalArgumentException("Unsupported input ByteBuffer implementation " + paramByteBuffer1.getClass().getName());
    } 
    if (paramByteBuffer2.isDirect()) {
      arrayOfByte2 = null;
      long l = UnsafeUtil.getAddress(paramByteBuffer2);
      l3 = l + paramByteBuffer2.position();
      l4 = l + paramByteBuffer2.limit();
    } else if (paramByteBuffer2.hasArray()) {
      arrayOfByte2 = paramByteBuffer2.array();
      l3 = (Unsafe.ARRAY_BYTE_BASE_OFFSET + paramByteBuffer2.arrayOffset() + paramByteBuffer2.position());
      l4 = (Unsafe.ARRAY_BYTE_BASE_OFFSET + paramByteBuffer2.arrayOffset() + paramByteBuffer2.limit());
    } else {
      throw new IllegalArgumentException("Unsupported output ByteBuffer implementation " + paramByteBuffer2.getClass().getName());
    } 
    synchronized (paramByteBuffer1) {
      synchronized (paramByteBuffer2) {
        int i = SnappyRawDecompressor.decompress(arrayOfByte1, l1, l2, arrayOfByte2, l3, l4);
        paramByteBuffer2.position(paramByteBuffer2.position() + i);
        return i;
      } 
    } 
  }
  
  public int rawUncompress(Object paramObject1, int paramInt1, int paramInt2, Object paramObject2, int paramInt3) throws IOException {
    long l1 = (Unsafe.ARRAY_BYTE_BASE_OFFSET + paramInt1);
    long l2 = l1 + paramInt2;
    long l3 = (Unsafe.ARRAY_BYTE_BASE_OFFSET + paramInt3);
    long l4 = l3 + 2147483647L;
    return SnappyRawDecompressor.decompress(paramObject1, l1, l2, paramObject2, l3, l4);
  }
  
  public int maxCompressedLength(int paramInt) { return SnappyRawCompressor.maxCompressedLength(paramInt); }
  
  public int uncompressedLength(ByteBuffer paramByteBuffer, int paramInt1, int paramInt2) throws IOException {
    long l2;
    long l1;
    byte[] arrayOfByte;
    if (paramByteBuffer.isDirect()) {
      arrayOfByte = null;
      long l = UnsafeUtil.getAddress(paramByteBuffer);
      l1 = l + paramByteBuffer.position();
      l2 = l + paramByteBuffer.limit();
    } else if (paramByteBuffer.hasArray()) {
      arrayOfByte = paramByteBuffer.array();
      l1 = (Unsafe.ARRAY_BYTE_BASE_OFFSET + paramInt1);
      l2 = (Unsafe.ARRAY_BYTE_BASE_OFFSET + paramInt2);
    } else {
      throw new IllegalArgumentException("Unsupported input ByteBuffer implementation: " + paramByteBuffer.getClass().getName());
    } 
    return SnappyRawDecompressor.getUncompressedLength(arrayOfByte, l1, l2);
  }
  
  public int uncompressedLength(Object paramObject, int paramInt1, int paramInt2) throws IOException {
    long l1 = (Unsafe.ARRAY_BYTE_BASE_OFFSET + paramInt1);
    long l2 = (Unsafe.ARRAY_BYTE_BASE_OFFSET + paramInt2);
    return SnappyRawDecompressor.getUncompressedLength(paramObject, l1, l2);
  }
  
  public long uncompressedLength(long paramLong1, long paramLong2) throws IOException { return SnappyRawDecompressor.getUncompressedLength(null, paramLong1, paramLong1 + paramLong2); }
  
  public boolean isValidCompressedBuffer(ByteBuffer paramByteBuffer, int paramInt1, int paramInt2) throws IOException { throw new UnsupportedOperationException("isValidCompressedBuffer is not supported in pure-java mode"); }
  
  public boolean isValidCompressedBuffer(Object paramObject, int paramInt1, int paramInt2) throws IOException { throw new UnsupportedOperationException("isValidCompressedBuffer is not supported in pure-java mode"); }
  
  public boolean isValidCompressedBuffer(long paramLong1, long paramLong2, long paramLong3) throws IOException { throw new UnsupportedOperationException("isValidCompressedBuffer is not supported in pure-java mode"); }
  
  public void arrayCopy(Object paramObject1, int paramInt1, int paramInt2, Object paramObject2, int paramInt3) throws IOException { System.arraycopy(paramObject1, paramInt1, paramObject2, paramInt3, paramInt2); }
  
  private static short[] getTable() {
    SoftReference softReference;
    while ((softReference = (SoftReference)CACHED_TABLES.poll()) != null) {
      short[] arrayOfShort = (short[])softReference.get();
      if (arrayOfShort != null) {
        boolean bool = true;
        SoftReference softReference1;
        while (bool && (softReference1 = (SoftReference)CACHED_TABLES.peekLast()) != null) {
          if (softReference1.get() == null) {
            CACHED_TABLES.removeLastOccurrence(softReference1);
            continue;
          } 
          bool = false;
        } 
        return arrayOfShort;
      } 
    } 
    return new short[16384];
  }
  
  private static void returnTable(short[] paramArrayOfShort) { CACHED_TABLES.addFirst(new SoftReference(paramArrayOfShort)); }
}
