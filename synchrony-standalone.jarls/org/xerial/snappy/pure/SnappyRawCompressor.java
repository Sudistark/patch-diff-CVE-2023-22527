package org.xerial.snappy.pure;

import java.nio.ByteOrder;
import java.util.Arrays;

public final class SnappyRawCompressor {
  private static final int BLOCK_LOG = 16;
  
  private static final int BLOCK_SIZE = 65536;
  
  private static final int INPUT_MARGIN_BYTES = 15;
  
  private static final int MAX_HASH_TABLE_BITS = 14;
  
  public static final int MAX_HASH_TABLE_SIZE = 16384;
  
  private static final ByteOrder byteOrder = ByteOrder.nativeOrder();
  
  private static final int HIGH_BIT_MASK = 128;
  
  private static int littleEndian(int paramInt) { return (byteOrder == ByteOrder.LITTLE_ENDIAN) ? paramInt : Integer.reverseBytes(paramInt); }
  
  private static long littleEndian(long paramLong) { return (byteOrder == ByteOrder.LITTLE_ENDIAN) ? paramLong : Long.reverseBytes(paramLong); }
  
  private static short littleEndian(short paramShort) { return (byteOrder == ByteOrder.LITTLE_ENDIAN) ? paramShort : Short.reverseBytes(paramShort); }
  
  public static int maxCompressedLength(int paramInt) { return 32 + paramInt + paramInt / 6; }
  
  public static int compress(Object paramObject1, long paramLong1, long paramLong2, Object paramObject2, long paramLong3, long paramLong4, short[] paramArrayOfShort) {
    int i = maxCompressedLength((int)(paramLong2 - paramLong1));
    if (paramLong4 - paramLong3 < i)
      throw new IllegalArgumentException("Output buffer must be at least " + i + " bytes"); 
    long l1 = writeUncompressedLength(paramObject2, paramLong3, (int)(paramLong2 - paramLong1));
    long l2;
    for (l2 = paramLong1; l2 < paramLong2; l2 += 65536L) {
      long l3 = Math.min(paramLong2, l2 + 65536L);
      long l4 = l2;
      assert l3 - l2 <= 65536L;
      int j = getHashTableSize((int)(l3 - l2));
      Arrays.fill(paramArrayOfShort, 0, j, (short)0);
      int k = 32 - log2Floor(j);
      assert (j & j - 1) == 0 : "table must be power of two";
      assert -1 >>> k == j - 1;
      long l5 = l4;
      long l6 = l3 - 15L;
      while (l4 <= l6) {
        int n;
        assert l5 <= l4;
        byte b = 32;
        long l = 0L;
        l4++;
        for (; l4 + (b >>> 5) <= l6; l4 += (b++ >>> 5)) {
          int i1 = littleEndian(UnsafeUtil.UNSAFE.getInt(paramObject1, l4));
          n = hashBytes(i1, k);
          l = l2 + (paramArrayOfShort[n] & 0xFFFF);
          assert l >= 0L;
          assert l < l4;
          paramArrayOfShort[n] = (short)(int)(l4 - l2);
          if (i1 == littleEndian(UnsafeUtil.UNSAFE.getInt(paramObject1, l)))
            break; 
        } 
        if (l4 + (b >>> 5) > l6)
          break; 
        assert l5 + 16L <= l3;
        int m = (int)(l4 - l5);
        l1 = emitLiteralLength(paramObject2, l1, m);
        l1 = fastCopy(paramObject1, l5, paramObject2, l1, m);
        do {
          assert l3 >= l4 + 4L;
          int i1 = count(paramObject1, l4 + 4L, l + 4L, l3);
          i1 += 4;
          l1 = emitCopy(paramObject2, l1, l4, l, i1);
          l4 += i1;
          if (l4 >= l6)
            break; 
          long l7 = littleEndian(UnsafeUtil.UNSAFE.getLong(paramObject1, l4 - 1L));
          int i2 = (int)l7;
          n = (int)(l7 >>> 8);
          int i3 = hashBytes(i2, k);
          paramArrayOfShort[i3] = (short)(int)(l4 - l2 - 1L);
          int i4 = hashBytes(n, k);
          l = l2 + (paramArrayOfShort[i4] & 0xFFFF);
          paramArrayOfShort[i4] = (short)(int)(l4 - l2);
        } while (n == littleEndian(UnsafeUtil.UNSAFE.getInt(paramObject1, l)));
        l5 = l4;
      } 
      if (l5 < l3) {
        int m = (int)(l3 - l5);
        l1 = emitLiteralLength(paramObject2, l1, m);
        UnsafeUtil.UNSAFE.copyMemory(paramObject1, l5, paramObject2, l1, m);
        l1 += m;
      } 
    } 
    return (int)(l1 - paramLong3);
  }
  
  private static int count(Object paramObject, long paramLong1, long paramLong2, long paramLong3) {
    long l = paramLong1;
    while (l < paramLong3 - 7L) {
      long l1 = littleEndian(UnsafeUtil.UNSAFE.getLong(paramObject, paramLong2)) ^ littleEndian(UnsafeUtil.UNSAFE.getLong(paramObject, l));
      if (l1 != 0L) {
        l += (Long.numberOfTrailingZeros(l1) >> 3);
        return (int)(l - paramLong1);
      } 
      l += 8L;
      paramLong2 += 8L;
    } 
    if (l < paramLong3 - 3L && littleEndian(UnsafeUtil.UNSAFE.getInt(paramObject, paramLong2)) == littleEndian(UnsafeUtil.UNSAFE.getInt(paramObject, l))) {
      l += 4L;
      paramLong2 += 4L;
    } 
    if (l < paramLong3 - 1L && littleEndian(UnsafeUtil.UNSAFE.getShort(paramObject, paramLong2)) == littleEndian(UnsafeUtil.UNSAFE.getShort(paramObject, l))) {
      l += 2L;
      paramLong2 += 2L;
    } 
    if (l < paramLong3 && UnsafeUtil.UNSAFE.getByte(paramObject, paramLong2) == UnsafeUtil.UNSAFE.getByte(paramObject, l))
      l++; 
    return (int)(l - paramLong1);
  }
  
  private static long emitLiteralLength(Object paramObject, long paramLong, int paramInt) {
    int i = paramInt - 1;
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)(i << 2));
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)-16);
    byte b = 1;
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)-12);
    b = 2;
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)-8);
    b = 3;
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)-4);
    b = 4;
    UnsafeUtil.UNSAFE.putInt(paramObject, paramLong, littleEndian(i));
    return b;
  }
  
  private static long fastCopy(Object paramObject1, long paramLong1, Object paramObject2, long paramLong2, int paramInt) {
    long l = paramLong2 + paramInt;
    do {
      UnsafeUtil.UNSAFE.putLong(paramObject2, paramLong2, UnsafeUtil.UNSAFE.getLong(paramObject1, paramLong1));
      paramLong1 += 8L;
      paramLong2 += 8L;
    } while (paramLong2 < l);
    return l;
  }
  
  private static long emitCopy(Object paramObject, long paramLong1, long paramLong2, long paramLong3, int paramInt) { // Byte code:
    //   0: lload_3
    //   1: lload #5
    //   3: lsub
    //   4: lstore #8
    //   6: iload #7
    //   8: bipush #68
    //   10: if_icmplt -> 54
    //   13: getstatic org/xerial/snappy/pure/UnsafeUtil.UNSAFE : Lsun/misc/Unsafe;
    //   16: aload_0
    //   17: lload_1
    //   18: dup2
    //   19: lconst_1
    //   20: ladd
    //   21: lstore_1
    //   22: bipush #-2
    //   24: invokevirtual putByte : (Ljava/lang/Object;JB)V
    //   27: getstatic org/xerial/snappy/pure/UnsafeUtil.UNSAFE : Lsun/misc/Unsafe;
    //   30: aload_0
    //   31: lload_1
    //   32: lload #8
    //   34: l2i
    //   35: i2s
    //   36: invokestatic littleEndian : (S)S
    //   39: invokevirtual putShort : (Ljava/lang/Object;JS)V
    //   42: lload_1
    //   43: ldc2_w 2
    //   46: ladd
    //   47: lstore_1
    //   48: iinc #7, -64
    //   51: goto -> 6
    //   54: iload #7
    //   56: bipush #64
    //   58: if_icmple -> 99
    //   61: getstatic org/xerial/snappy/pure/UnsafeUtil.UNSAFE : Lsun/misc/Unsafe;
    //   64: aload_0
    //   65: lload_1
    //   66: dup2
    //   67: lconst_1
    //   68: ladd
    //   69: lstore_1
    //   70: bipush #-18
    //   72: invokevirtual putByte : (Ljava/lang/Object;JB)V
    //   75: getstatic org/xerial/snappy/pure/UnsafeUtil.UNSAFE : Lsun/misc/Unsafe;
    //   78: aload_0
    //   79: lload_1
    //   80: lload #8
    //   82: l2i
    //   83: i2s
    //   84: invokestatic littleEndian : (S)S
    //   87: invokevirtual putShort : (Ljava/lang/Object;JS)V
    //   90: lload_1
    //   91: ldc2_w 2
    //   94: ladd
    //   95: lstore_1
    //   96: iinc #7, -60
    //   99: iload #7
    //   101: bipush #12
    //   103: if_icmpge -> 169
    //   106: lload #8
    //   108: ldc2_w 2048
    //   111: lcmp
    //   112: ifge -> 169
    //   115: iload #7
    //   117: iconst_4
    //   118: isub
    //   119: istore #10
    //   121: getstatic org/xerial/snappy/pure/UnsafeUtil.UNSAFE : Lsun/misc/Unsafe;
    //   124: aload_0
    //   125: lload_1
    //   126: dup2
    //   127: lconst_1
    //   128: ladd
    //   129: lstore_1
    //   130: iconst_1
    //   131: iload #10
    //   133: iconst_2
    //   134: ishl
    //   135: iadd
    //   136: i2l
    //   137: lload #8
    //   139: bipush #8
    //   141: lushr
    //   142: iconst_5
    //   143: lshl
    //   144: ladd
    //   145: l2i
    //   146: i2b
    //   147: invokevirtual putByte : (Ljava/lang/Object;JB)V
    //   150: getstatic org/xerial/snappy/pure/UnsafeUtil.UNSAFE : Lsun/misc/Unsafe;
    //   153: aload_0
    //   154: lload_1
    //   155: dup2
    //   156: lconst_1
    //   157: ladd
    //   158: lstore_1
    //   159: lload #8
    //   161: l2i
    //   162: i2b
    //   163: invokevirtual putByte : (Ljava/lang/Object;JB)V
    //   166: goto -> 211
    //   169: getstatic org/xerial/snappy/pure/UnsafeUtil.UNSAFE : Lsun/misc/Unsafe;
    //   172: aload_0
    //   173: lload_1
    //   174: dup2
    //   175: lconst_1
    //   176: ladd
    //   177: lstore_1
    //   178: iconst_2
    //   179: iload #7
    //   181: iconst_1
    //   182: isub
    //   183: iconst_2
    //   184: ishl
    //   185: iadd
    //   186: i2b
    //   187: invokevirtual putByte : (Ljava/lang/Object;JB)V
    //   190: getstatic org/xerial/snappy/pure/UnsafeUtil.UNSAFE : Lsun/misc/Unsafe;
    //   193: aload_0
    //   194: lload_1
    //   195: lload #8
    //   197: l2i
    //   198: i2s
    //   199: invokestatic littleEndian : (S)S
    //   202: invokevirtual putShort : (Ljava/lang/Object;JS)V
    //   205: lload_1
    //   206: ldc2_w 2
    //   209: ladd
    //   210: lstore_1
    //   211: lload_1
    //   212: lreturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #334	-> 0
    //   #337	-> 6
    //   #338	-> 13
    //   #339	-> 27
    //   #340	-> 42
    //   #341	-> 48
    //   #346	-> 54
    //   #347	-> 61
    //   #348	-> 75
    //   #349	-> 90
    //   #350	-> 96
    //   #354	-> 99
    //   #355	-> 115
    //   #356	-> 121
    //   #357	-> 150
    //   #358	-> 166
    //   #360	-> 169
    //   #361	-> 190
    //   #362	-> 205
    //   #364	-> 211 }
  
  private static int getHashTableSize(int paramInt) {
    int i = Integer.highestOneBit(paramInt - 1) << 1;
    return Math.max(Math.min(i, 16384), 256);
  }
  
  private static int hashBytes(int paramInt1, int paramInt2) { return paramInt1 * 506832829 >>> paramInt2; }
  
  private static int log2Floor(int paramInt) { return (paramInt == 0) ? -1 : (0x1F ^ Integer.numberOfLeadingZeros(paramInt)); }
  
  private static long writeUncompressedLength(Object paramObject, long paramLong, int paramInt) {
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)paramInt);
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)(paramInt | 0x80));
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)(paramInt >>> 7));
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)(paramInt | 0x80));
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)(paramInt >>> 7 | 0x80));
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)(paramInt >>> 14));
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)(paramInt | 0x80));
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)(paramInt >>> 7 | 0x80));
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)(paramInt >>> 14 | 0x80));
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)(paramInt >>> 21));
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)(paramInt | 0x80));
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)(paramInt >>> 7 | 0x80));
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)(paramInt >>> 14 | 0x80));
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)(paramInt >>> 21 | 0x80));
    UnsafeUtil.UNSAFE.putByte(paramObject, paramLong++, (byte)(paramInt >>> 28));
    return paramLong;
  }
}
