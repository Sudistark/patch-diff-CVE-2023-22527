package org.xerial.snappy;

import java.io.IOException;
import java.io.OutputStream;
import org.xerial.snappy.buffer.BufferAllocator;
import org.xerial.snappy.buffer.BufferAllocatorFactory;
import org.xerial.snappy.buffer.CachedBufferAllocator;

public class SnappyOutputStream extends OutputStream {
  static final int MIN_BLOCK_SIZE = 1024;
  
  static final int DEFAULT_BLOCK_SIZE = 32768;
  
  protected final OutputStream out;
  
  private final int blockSize;
  
  private final BufferAllocator inputBufferAllocator;
  
  private final BufferAllocator outputBufferAllocator;
  
  protected byte[] inputBuffer;
  
  protected byte[] outputBuffer;
  
  private int inputCursor;
  
  private int outputCursor;
  
  private boolean headerWritten;
  
  private boolean closed;
  
  public SnappyOutputStream(OutputStream paramOutputStream) { this(paramOutputStream, 32768); }
  
  public SnappyOutputStream(OutputStream paramOutputStream, int paramInt) { this(paramOutputStream, paramInt, CachedBufferAllocator.getBufferAllocatorFactory()); }
  
  public SnappyOutputStream(OutputStream paramOutputStream, int paramInt, BufferAllocatorFactory paramBufferAllocatorFactory) {
    this.inputCursor = 0;
    this.outputCursor = 0;
    this.out = paramOutputStream;
    this.blockSize = Math.max(1024, paramInt);
    int i = paramInt;
    int j = SnappyCodec.HEADER_SIZE + 4 + Snappy.maxCompressedLength(paramInt);
    this.inputBufferAllocator = paramBufferAllocatorFactory.getBufferAllocator(i);
    this.outputBufferAllocator = paramBufferAllocatorFactory.getBufferAllocator(j);
    this.inputBuffer = this.inputBufferAllocator.allocate(i);
    this.outputBuffer = this.outputBufferAllocator.allocate(j);
  }
  
  public void write(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException {
    if (this.closed)
      throw new IOException("Stream is closed"); 
    int i = 0;
    while (i < paramInt2) {
      int j = Math.min(paramInt2 - i, this.blockSize - this.inputCursor);
      if (j > 0) {
        System.arraycopy(paramArrayOfByte, paramInt1 + i, this.inputBuffer, this.inputCursor, j);
        this.inputCursor += j;
      } 
      if (this.inputCursor < this.blockSize)
        return; 
      compressInput();
      i += j;
    } 
  }
  
  public void write(long[] paramArrayOfLong, int paramInt1, int paramInt2) throws IOException { rawWrite(paramArrayOfLong, paramInt1 * 8, paramInt2 * 8); }
  
  public void write(double[] paramArrayOfDouble, int paramInt1, int paramInt2) throws IOException { rawWrite(paramArrayOfDouble, paramInt1 * 8, paramInt2 * 8); }
  
  public void write(float[] paramArrayOfFloat, int paramInt1, int paramInt2) throws IOException { rawWrite(paramArrayOfFloat, paramInt1 * 4, paramInt2 * 4); }
  
  public void write(int[] paramArrayOfInt, int paramInt1, int paramInt2) throws IOException { rawWrite(paramArrayOfInt, paramInt1 * 4, paramInt2 * 4); }
  
  public void write(short[] paramArrayOfShort, int paramInt1, int paramInt2) throws IOException { rawWrite(paramArrayOfShort, paramInt1 * 2, paramInt2 * 2); }
  
  public void write(long[] paramArrayOfLong) throws IOException { write(paramArrayOfLong, 0, paramArrayOfLong.length); }
  
  public void write(double[] paramArrayOfDouble) throws IOException { write(paramArrayOfDouble, 0, paramArrayOfDouble.length); }
  
  public void write(float[] paramArrayOfFloat) throws IOException { write(paramArrayOfFloat, 0, paramArrayOfFloat.length); }
  
  public void write(int[] paramArrayOfInt) throws IOException { write(paramArrayOfInt, 0, paramArrayOfInt.length); }
  
  public void write(short[] paramArrayOfShort) throws IOException { write(paramArrayOfShort, 0, paramArrayOfShort.length); }
  
  private boolean hasSufficientOutputBufferFor(int paramInt) {
    int i = Snappy.maxCompressedLength(paramInt);
    return (i < this.outputBuffer.length - this.outputCursor - 4);
  }
  
  public void rawWrite(Object paramObject, int paramInt1, int paramInt2) throws IOException {
    if (this.closed)
      throw new IOException("Stream is closed"); 
    int i = 0;
    while (i < paramInt2) {
      int j = Math.min(paramInt2 - i, this.blockSize - this.inputCursor);
      if (j > 0) {
        Snappy.arrayCopy(paramObject, paramInt1 + i, j, this.inputBuffer, this.inputCursor);
        this.inputCursor += j;
      } 
      if (this.inputCursor < this.blockSize)
        return; 
      compressInput();
      i += j;
    } 
  }
  
  public void write(int paramInt) throws IOException {
    if (this.closed)
      throw new IOException("Stream is closed"); 
    if (this.inputCursor >= this.inputBuffer.length)
      compressInput(); 
    this.inputBuffer[this.inputCursor++] = (byte)paramInt;
  }
  
  public void flush() throws IOException {
    if (this.closed)
      throw new IOException("Stream is closed"); 
    compressInput();
    dumpOutput();
    this.out.flush();
  }
  
  static void writeInt(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException {
    paramArrayOfByte[paramInt1] = (byte)(paramInt2 >> 24 & 0xFF);
    paramArrayOfByte[paramInt1 + 1] = (byte)(paramInt2 >> 16 & 0xFF);
    paramArrayOfByte[paramInt1 + 2] = (byte)(paramInt2 >> 8 & 0xFF);
    paramArrayOfByte[paramInt1 + 3] = (byte)(paramInt2 >> 0 & 0xFF);
  }
  
  static int readInt(byte[] paramArrayOfByte, int paramInt) {
    byte b1 = (paramArrayOfByte[paramInt] & 0xFF) << 24;
    byte b2 = (paramArrayOfByte[paramInt + 1] & 0xFF) << 16;
    byte b3 = (paramArrayOfByte[paramInt + 2] & 0xFF) << 8;
    byte b4 = paramArrayOfByte[paramInt + 3] & 0xFF;
    return b1 | b2 | b3 | b4;
  }
  
  protected void dumpOutput() throws IOException {
    if (this.outputCursor > 0) {
      this.out.write(this.outputBuffer, 0, this.outputCursor);
      this.outputCursor = 0;
    } 
  }
  
  protected void compressInput() throws IOException {
    if (!this.headerWritten) {
      this.outputCursor = writeHeader();
      this.headerWritten = true;
    } 
    if (this.inputCursor <= 0)
      return; 
    if (!hasSufficientOutputBufferFor(this.inputCursor))
      dumpOutput(); 
    writeBlockPreemble();
    int i = Snappy.compress(this.inputBuffer, 0, this.inputCursor, this.outputBuffer, this.outputCursor + 4);
    writeInt(this.outputBuffer, this.outputCursor, i);
    this.outputCursor += 4 + i;
    this.inputCursor = 0;
  }
  
  protected int writeHeader() { return SnappyCodec.currentHeader.writeHeader(this.outputBuffer, 0); }
  
  protected void writeBlockPreemble() throws IOException {}
  
  protected void writeCurrentDataSize() throws IOException {
    writeInt(this.outputBuffer, this.outputCursor, this.inputCursor);
    this.outputCursor += 4;
  }
  
  public void close() throws IOException {
    if (this.closed)
      return; 
    try {
      flush();
      this.out.close();
    } finally {
      this.closed = true;
      this.inputBufferAllocator.release(this.inputBuffer);
      this.outputBufferAllocator.release(this.outputBuffer);
      this.inputBuffer = null;
      this.outputBuffer = null;
    } 
  }
}
