package org.xerial.snappy;

import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.WritableByteChannel;
import java.util.Arrays;
import java.util.zip.Checksum;
import org.xerial.snappy.pool.BufferPool;
import org.xerial.snappy.pool.DefaultPoolFactory;

public final class SnappyFramedInputStream extends InputStream implements ReadableByteChannel {
  private final Checksum crc32 = SnappyFramed.getCRC32C();
  
  private final ReadableByteChannel rbc;
  
  private final ByteBuffer frameHeader;
  
  private final boolean verifyChecksums;
  
  private final BufferPool bufferPool;
  
  private ByteBuffer input;
  
  private ByteBuffer uncompressedDirect;
  
  private boolean closed;
  
  private boolean eof;
  
  private int valid;
  
  private int position;
  
  private byte[] buffer;
  
  public SnappyFramedInputStream(InputStream paramInputStream) throws IOException { this(paramInputStream, true, DefaultPoolFactory.getDefaultPool()); }
  
  public SnappyFramedInputStream(InputStream paramInputStream, BufferPool paramBufferPool) throws IOException { this(paramInputStream, true, paramBufferPool); }
  
  public SnappyFramedInputStream(InputStream paramInputStream, boolean paramBoolean) throws IOException { this(paramInputStream, paramBoolean, DefaultPoolFactory.getDefaultPool()); }
  
  public SnappyFramedInputStream(InputStream paramInputStream, boolean paramBoolean, BufferPool paramBufferPool) throws IOException { this(Channels.newChannel(paramInputStream), paramBoolean, paramBufferPool); }
  
  public SnappyFramedInputStream(ReadableByteChannel paramReadableByteChannel, BufferPool paramBufferPool) throws IOException { this(paramReadableByteChannel, true, paramBufferPool); }
  
  public SnappyFramedInputStream(ReadableByteChannel paramReadableByteChannel) throws IOException { this(paramReadableByteChannel, true); }
  
  public SnappyFramedInputStream(ReadableByteChannel paramReadableByteChannel, boolean paramBoolean) throws IOException { this(paramReadableByteChannel, paramBoolean, DefaultPoolFactory.getDefaultPool()); }
  
  public SnappyFramedInputStream(ReadableByteChannel paramReadableByteChannel, boolean paramBoolean, BufferPool paramBufferPool) throws IOException {
    if (paramReadableByteChannel == null)
      throw new NullPointerException("in is null"); 
    if (paramBufferPool == null)
      throw new NullPointerException("bufferPool is null"); 
    this.bufferPool = paramBufferPool;
    this.rbc = paramReadableByteChannel;
    this.verifyChecksums = paramBoolean;
    allocateBuffersBasedOnSize(65541);
    this.frameHeader = ByteBuffer.allocate(4);
    byte[] arrayOfByte1 = SnappyFramed.HEADER_BYTES;
    byte[] arrayOfByte2 = new byte[arrayOfByte1.length];
    ByteBuffer byteBuffer = ByteBuffer.wrap(arrayOfByte2);
    int i = SnappyFramed.readBytes(paramReadableByteChannel, byteBuffer);
    if (i < arrayOfByte1.length)
      throw new EOFException("encountered EOF while reading stream header"); 
    if (!Arrays.equals(arrayOfByte1, arrayOfByte2))
      throw new IOException("invalid stream header"); 
  }
  
  private void allocateBuffersBasedOnSize(int paramInt) {
    if (this.input != null)
      this.bufferPool.releaseDirect(this.input); 
    if (this.uncompressedDirect != null)
      this.bufferPool.releaseDirect(this.uncompressedDirect); 
    if (this.buffer != null)
      this.bufferPool.releaseArray(this.buffer); 
    this.input = this.bufferPool.allocateDirect(paramInt);
    int i = Snappy.maxCompressedLength(paramInt);
    this.uncompressedDirect = this.bufferPool.allocateDirect(i);
    this.buffer = this.bufferPool.allocateArray(i);
  }
  
  public int read() throws IOException {
    if (this.closed)
      return -1; 
    if (!ensureBuffer())
      return -1; 
    return this.buffer[this.position++] & 0xFF;
  }
  
  public int read(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException {
    if (paramArrayOfByte == null)
      throw new IllegalArgumentException("output is null"); 
    if (paramInt1 < 0 || paramInt2 < 0 || paramInt1 + paramInt2 > paramArrayOfByte.length)
      throw new IllegalArgumentException("invalid offset [" + paramInt1 + "] and length [" + paramInt2 + ']'); 
    if (this.closed)
      throw new ClosedChannelException(); 
    if (paramInt2 == 0)
      return 0; 
    if (!ensureBuffer())
      return -1; 
    int i = Math.min(paramInt2, available());
    System.arraycopy(this.buffer, this.position, paramArrayOfByte, paramInt1, i);
    this.position += i;
    return i;
  }
  
  public int available() throws IOException {
    if (this.closed)
      return 0; 
    return this.valid - this.position;
  }
  
  public boolean isOpen() { return !this.closed; }
  
  public int read(ByteBuffer paramByteBuffer) throws IOException {
    if (paramByteBuffer == null)
      throw new IllegalArgumentException("dst is null"); 
    if (this.closed)
      throw new ClosedChannelException(); 
    if (paramByteBuffer.remaining() == 0)
      return 0; 
    if (!ensureBuffer())
      return -1; 
    int i = Math.min(paramByteBuffer.remaining(), available());
    paramByteBuffer.put(this.buffer, this.position, i);
    this.position += i;
    return i;
  }
  
  public long transferTo(OutputStream paramOutputStream) throws IOException {
    if (paramOutputStream == null)
      throw new IllegalArgumentException("os is null"); 
    if (this.closed)
      throw new ClosedChannelException(); 
    long l = 0L;
    while (ensureBuffer()) {
      int i = available();
      paramOutputStream.write(this.buffer, this.position, i);
      this.position += i;
      l += i;
    } 
    return l;
  }
  
  public long transferTo(WritableByteChannel paramWritableByteChannel) throws IOException {
    if (paramWritableByteChannel == null)
      throw new IllegalArgumentException("wbc is null"); 
    if (this.closed)
      throw new ClosedChannelException(); 
    ByteBuffer byteBuffer = ByteBuffer.wrap(this.buffer);
    long l = 0L;
    while (ensureBuffer()) {
      byteBuffer.clear();
      byteBuffer.position(this.position);
      byteBuffer.limit(this.position + available());
      paramWritableByteChannel.write(byteBuffer);
      int i = byteBuffer.position() - this.position;
      this.position += i;
      l += i;
    } 
    return l;
  }
  
  public void close() throws IOException {
    try {
      this.rbc.close();
    } finally {
      if (!this.closed) {
        this.closed = true;
        if (this.input != null) {
          this.bufferPool.releaseDirect(this.input);
          this.input = null;
        } 
        if (this.uncompressedDirect != null) {
          this.bufferPool.releaseDirect(this.uncompressedDirect);
          this.uncompressedDirect = null;
        } 
        if (this.buffer != null) {
          this.bufferPool.releaseArray(this.buffer);
          this.buffer = null;
        } 
      } 
    } 
  }
  
  private boolean ensureBuffer() {
    if (available() > 0)
      return true; 
    if (this.eof)
      return false; 
    if (!readBlockHeader()) {
      this.eof = true;
      return false;
    } 
    FrameMetaData frameMetaData = getFrameMetaData(this.frameHeader);
    if (FrameAction.SKIP == frameMetaData.frameAction) {
      SnappyFramed.skip(this.rbc, frameMetaData.length, 
          ByteBuffer.wrap(this.buffer));
      return ensureBuffer();
    } 
    if (frameMetaData.length > this.input.capacity())
      allocateBuffersBasedOnSize(frameMetaData.length); 
    this.input.clear();
    this.input.limit(frameMetaData.length);
    int i = SnappyFramed.readBytes(this.rbc, this.input);
    if (i != frameMetaData.length)
      throw new EOFException("unexpectd EOF when reading frame"); 
    this.input.flip();
    FrameData frameData = getFrameData(this.input);
    if (FrameAction.UNCOMPRESS == frameMetaData.frameAction) {
      this.input.position(frameData.offset);
      int j = Snappy.uncompressedLength(this.input);
      if (j > this.uncompressedDirect.capacity()) {
        this.bufferPool.releaseDirect(this.uncompressedDirect);
        this.bufferPool.releaseArray(this.buffer);
        this.uncompressedDirect = this.bufferPool.allocateDirect(j);
        this.buffer = this.bufferPool.allocateArray(j);
      } 
      this.uncompressedDirect.clear();
      this.valid = Snappy.uncompress(this.input, this.uncompressedDirect);
      this.uncompressedDirect.get(this.buffer, 0, this.valid);
      this.position = 0;
    } else {
      this.input.position(frameData.offset);
      this.position = 0;
      this.valid = this.input.remaining();
      this.input.get(this.buffer, 0, this.input.remaining());
    } 
    if (this.verifyChecksums) {
      int j = SnappyFramed.maskedCrc32c(this.crc32, this.buffer, this.position, this.valid - this.position);
      if (frameData.checkSum != j)
        throw new IOException("Corrupt input: invalid checksum"); 
    } 
    return true;
  }
  
  private boolean readBlockHeader() {
    this.frameHeader.clear();
    int i = SnappyFramed.readBytes(this.rbc, this.frameHeader);
    if (i == -1)
      return false; 
    if (i < this.frameHeader.capacity())
      throw new EOFException("encountered EOF while reading block header"); 
    this.frameHeader.flip();
    return true;
  }
  
  private FrameMetaData getFrameMetaData(ByteBuffer paramByteBuffer) throws IOException {
    FrameAction frameAction;
    assert paramByteBuffer.hasArray();
    byte[] arrayOfByte = paramByteBuffer.array();
    byte b1 = arrayOfByte[1] & 0xFF;
    b1 |= (arrayOfByte[2] & 0xFF) << 8;
    b1 |= (arrayOfByte[3] & 0xFF) << 16;
    byte b = 0;
    byte b2 = arrayOfByte[0] & 0xFF;
    switch (b2) {
      case 0:
        frameAction = FrameAction.UNCOMPRESS;
        b = 5;
        break;
      case 1:
        frameAction = FrameAction.RAW;
        b = 5;
        break;
      case 255:
        if (b1 != 6)
          throw new IOException("stream identifier chunk with invalid length: " + b1); 
        frameAction = FrameAction.SKIP;
        b = 6;
        break;
      default:
        if (b2 <= Byte.MAX_VALUE)
          throw new IOException("unsupported unskippable chunk: " + 
              Integer.toHexString(b2)); 
        frameAction = FrameAction.SKIP;
        b = 0;
        break;
    } 
    if (b1 < b)
      throw new IOException("invalid length: " + b1 + " for chunk flag: " + 
          Integer.toHexString(b2)); 
    return new FrameMetaData(frameAction, b1);
  }
  
  private FrameData getFrameData(ByteBuffer paramByteBuffer) throws IOException { return new FrameData(getCrc32c(paramByteBuffer), 4); }
  
  private int getCrc32c(ByteBuffer paramByteBuffer) throws IOException {
    int i = paramByteBuffer.position();
    return (paramByteBuffer.get(i + 3) & 0xFF) << 24 | (paramByteBuffer
      .get(i + 2) & 0xFF) << 16 | (paramByteBuffer
      .get(i + 1) & 0xFF) << 8 | paramByteBuffer
      .get(i) & 0xFF;
  }
}
