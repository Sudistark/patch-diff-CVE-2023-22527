package org.xerial.snappy.pool;

import java.lang.ref.SoftReference;
import java.nio.ByteBuffer;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.concurrent.ConcurrentMap;

public final class CachingBufferPool implements BufferPool {
  private static final IntFunction<byte[]> ARRAY_FUNCTION = new Object();
  
  private static final IntFunction<ByteBuffer> DBB_FUNCTION = new Object();
  
  private static final CachingBufferPool INSTANCE = new CachingBufferPool();
  
  private final ConcurrentMap<Integer, ConcurrentLinkedDeque<SoftReference<byte[]>>> bytes = new ConcurrentHashMap();
  
  private final ConcurrentMap<Integer, ConcurrentLinkedDeque<SoftReference<ByteBuffer>>> buffers = new ConcurrentHashMap();
  
  public static BufferPool getInstance() { return INSTANCE; }
  
  public byte[] allocateArray(int paramInt) {
    if (paramInt <= 0)
      throw new IllegalArgumentException("size is invalid: " + paramInt); 
    return (byte[])getOrCreate(paramInt, this.bytes, ARRAY_FUNCTION);
  }
  
  public void releaseArray(byte[] paramArrayOfByte) {
    if (paramArrayOfByte == null)
      throw new IllegalArgumentException("buffer is null"); 
    returnValue(paramArrayOfByte, Integer.valueOf(paramArrayOfByte.length), this.bytes);
  }
  
  public ByteBuffer allocateDirect(int paramInt) {
    if (paramInt <= 0)
      throw new IllegalArgumentException("size is invalid: " + paramInt); 
    return (ByteBuffer)getOrCreate(paramInt, this.buffers, DBB_FUNCTION);
  }
  
  public void releaseDirect(ByteBuffer paramByteBuffer) {
    if (paramByteBuffer == null)
      throw new IllegalArgumentException("buffer is null"); 
    paramByteBuffer.clear();
    returnValue(paramByteBuffer, Integer.valueOf(paramByteBuffer.capacity()), this.buffers);
  }
  
  private static <E> E getOrCreate(int paramInt, ConcurrentMap<Integer, ConcurrentLinkedDeque<SoftReference<E>>> paramConcurrentMap, IntFunction<E> paramIntFunction) {
    assert paramInt > 0;
    int i = adjustSize(paramInt);
    ConcurrentLinkedDeque concurrentLinkedDeque = optimisticGetEntry(Integer.valueOf(i), paramConcurrentMap);
    SoftReference softReference;
    while ((softReference = (SoftReference)concurrentLinkedDeque.pollFirst()) != null) {
      Object object = softReference.get();
      if (object != null)
        return (E)object; 
    } 
    return (E)paramIntFunction.create(i);
  }
  
  static int adjustSize(int paramInt) {
    assert paramInt > 0;
    switch (Integer.numberOfLeadingZeros(paramInt)) {
      case 1:
      case 2:
        return (paramInt <= 1610612736) ? roundToPowers(paramInt, 27) : Integer.MAX_VALUE;
      case 3:
      case 4:
        return roundToPowers(paramInt, 24);
      case 5:
      case 6:
      case 7:
        return roundToPowers(paramInt, 22);
      case 8:
      case 9:
      case 10:
        return roundToPowers(paramInt, 19);
      case 11:
      case 12:
        return roundToPowers(paramInt, 17);
      case 13:
      case 14:
      case 15:
      case 16:
        return roundToPowers(paramInt, 14);
      case 17:
      case 18:
      case 19:
        return roundToPowers(paramInt, 11);
    } 
    return 4096;
  }
  
  private static int roundToPowers(int paramInt1, int paramInt2) {
    int i = Integer.MAX_VALUE >> paramInt2 << paramInt2;
    int j = paramInt1 & i;
    return (j == paramInt1) ? paramInt1 : (j + (1 << paramInt2));
  }
  
  private static <E> ConcurrentLinkedDeque<SoftReference<E>> optimisticGetEntry(Integer paramInteger, ConcurrentMap<Integer, ConcurrentLinkedDeque<SoftReference<E>>> paramConcurrentMap) {
    ConcurrentLinkedDeque concurrentLinkedDeque = (ConcurrentLinkedDeque)paramConcurrentMap.get(paramInteger);
    if (concurrentLinkedDeque == null) {
      paramConcurrentMap.putIfAbsent(paramInteger, new ConcurrentLinkedDeque());
      concurrentLinkedDeque = (ConcurrentLinkedDeque)paramConcurrentMap.get(paramInteger);
    } 
    return concurrentLinkedDeque;
  }
  
  private static <E> void returnValue(E paramE, Integer paramInteger, ConcurrentMap<Integer, ConcurrentLinkedDeque<SoftReference<E>>> paramConcurrentMap) {
    ConcurrentLinkedDeque concurrentLinkedDeque = (ConcurrentLinkedDeque)paramConcurrentMap.get(paramInteger);
    if (concurrentLinkedDeque != null) {
      concurrentLinkedDeque.addFirst(new SoftReference(paramE));
      boolean bool = true;
      SoftReference softReference;
      while (bool && (softReference = (SoftReference)concurrentLinkedDeque.peekLast()) != null) {
        if (softReference.get() == null) {
          concurrentLinkedDeque.removeLastOccurrence(softReference);
          continue;
        } 
        bool = false;
      } 
    } 
  }
  
  public String toString() { return "CachingBufferPool [bytes=" + this.bytes + ", buffers=" + this.buffers + "]"; }
}
