package org.jsoup.helper;

import java.io.IOException;
import java.io.InputStream;
import java.net.CookieManager;
import java.net.CookieStore;
import java.net.MalformedURLException;
import java.net.Proxy;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.Collection;
import java.util.Map;
import javax.annotation.Nullable;
import javax.net.ssl.SSLSocketFactory;
import org.jsoup.Connection;
import org.jsoup.nodes.Document;
import org.jsoup.parser.Parser;

public class HttpConnection implements Connection {
  public static final String CONTENT_ENCODING = "Content-Encoding";
  
  public static final String DEFAULT_UA = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36";
  
  private static final String USER_AGENT = "User-Agent";
  
  public static final String CONTENT_TYPE = "Content-Type";
  
  public static final String MULTIPART_FORM_DATA = "multipart/form-data";
  
  public static final String FORM_URL_ENCODED = "application/x-www-form-urlencoded";
  
  private static final int HTTP_TEMP_REDIR = 307;
  
  private static final String DefaultUploadType = "application/octet-stream";
  
  private static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
  
  private Request req;
  
  @Nullable
  private Connection.Response res;
  
  public static Connection connect(String url) {
    HttpConnection httpConnection = new HttpConnection();
    httpConnection.url(url);
    return httpConnection;
  }
  
  public static Connection connect(URL url) {
    HttpConnection httpConnection = new HttpConnection();
    httpConnection.url(url);
    return httpConnection;
  }
  
  public HttpConnection() { this.req = new Request(); }
  
  HttpConnection(Request copy) { this.req = new Request(copy); }
  
  private static String encodeMimeName(String val) { return val.replace("\"", "%22"); }
  
  public Connection newRequest() { return new HttpConnection(this.req); }
  
  private HttpConnection(Request req, Response res) {
    this.req = req;
    this.res = res;
  }
  
  public Connection url(URL url) {
    this.req.url(url);
    return this;
  }
  
  public Connection url(String url) {
    Validate.notEmptyParam(url, "url");
    try {
      this.req.url(new URL(url));
    } catch (MalformedURLException e) {
      throw new IllegalArgumentException(String.format("The supplied URL, '%s', is malformed. Make sure it is an absolute URL, and starts with 'http://' or 'https://'. See https://jsoup.org/cookbook/extracting-data/working-with-urls", new Object[] { url }), e);
    } 
    return this;
  }
  
  public Connection proxy(@Nullable Proxy proxy) {
    this.req.proxy(proxy);
    return this;
  }
  
  public Connection proxy(String host, int port) {
    this.req.proxy(host, port);
    return this;
  }
  
  public Connection userAgent(String userAgent) {
    Validate.notNullParam(userAgent, "userAgent");
    this.req.header("User-Agent", userAgent);
    return this;
  }
  
  public Connection timeout(int millis) {
    this.req.timeout(millis);
    return this;
  }
  
  public Connection maxBodySize(int bytes) {
    this.req.maxBodySize(bytes);
    return this;
  }
  
  public Connection followRedirects(boolean followRedirects) {
    this.req.followRedirects(followRedirects);
    return this;
  }
  
  public Connection referrer(String referrer) {
    Validate.notNullParam(referrer, "referrer");
    this.req.header("Referer", referrer);
    return this;
  }
  
  public Connection method(Connection.Method method) {
    this.req.method(method);
    return this;
  }
  
  public Connection ignoreHttpErrors(boolean ignoreHttpErrors) {
    this.req.ignoreHttpErrors(ignoreHttpErrors);
    return this;
  }
  
  public Connection ignoreContentType(boolean ignoreContentType) {
    this.req.ignoreContentType(ignoreContentType);
    return this;
  }
  
  public Connection data(String key, String value) {
    this.req.data(KeyVal.create(key, value));
    return this;
  }
  
  public Connection sslSocketFactory(SSLSocketFactory sslSocketFactory) {
    this.req.sslSocketFactory(sslSocketFactory);
    return this;
  }
  
  public Connection data(String key, String filename, InputStream inputStream) {
    this.req.data(KeyVal.create(key, filename, inputStream));
    return this;
  }
  
  public Connection data(String key, String filename, InputStream inputStream, String contentType) {
    this.req.data(KeyVal.create(key, filename, inputStream).contentType(contentType));
    return this;
  }
  
  public Connection data(Map<String, String> data) {
    Validate.notNullParam(data, "data");
    for (Map.Entry<String, String> entry : data.entrySet())
      this.req.data(KeyVal.create((String)entry.getKey(), (String)entry.getValue())); 
    return this;
  }
  
  public Connection data(String... keyvals) {
    Validate.notNullParam(keyvals, "keyvals");
    Validate.isTrue((keyvals.length % 2 == 0), "Must supply an even number of key value pairs");
    for (int i = 0; i < keyvals.length; i += 2) {
      String key = keyvals[i];
      String value = keyvals[i + 1];
      Validate.notEmpty(key, "Data key must not be empty");
      Validate.notNull(value, "Data value must not be null");
      this.req.data(KeyVal.create(key, value));
    } 
    return this;
  }
  
  public Connection data(Collection<Connection.KeyVal> data) {
    Validate.notNullParam(data, "data");
    for (Connection.KeyVal entry : data)
      this.req.data(entry); 
    return this;
  }
  
  public Connection.KeyVal data(String key) {
    Validate.notEmptyParam(key, "key");
    for (Connection.KeyVal keyVal : request().data()) {
      if (keyVal.key().equals(key))
        return keyVal; 
    } 
    return null;
  }
  
  public Connection requestBody(String body) {
    this.req.requestBody(body);
    return this;
  }
  
  public Connection header(String name, String value) {
    this.req.header(name, value);
    return this;
  }
  
  public Connection headers(Map<String, String> headers) {
    Validate.notNullParam(headers, "headers");
    for (Map.Entry<String, String> entry : headers.entrySet())
      this.req.header((String)entry.getKey(), (String)entry.getValue()); 
    return this;
  }
  
  public Connection cookie(String name, String value) {
    this.req.cookie(name, value);
    return this;
  }
  
  public Connection cookies(Map<String, String> cookies) {
    Validate.notNullParam(cookies, "cookies");
    for (Map.Entry<String, String> entry : cookies.entrySet())
      this.req.cookie((String)entry.getKey(), (String)entry.getValue()); 
    return this;
  }
  
  public Connection cookieStore(CookieStore cookieStore) {
    Request.access$002(this.req, new CookieManager(cookieStore, null));
    return this;
  }
  
  public CookieStore cookieStore() { return Request.access$000(this.req).getCookieStore(); }
  
  public Connection parser(Parser parser) {
    this.req.parser(parser);
    return this;
  }
  
  public Document get() throws IOException {
    this.req.method(Connection.Method.GET);
    execute();
    Validate.notNull(this.res);
    return this.res.parse();
  }
  
  public Document post() throws IOException {
    this.req.method(Connection.Method.POST);
    execute();
    Validate.notNull(this.res);
    return this.res.parse();
  }
  
  public Connection.Response execute() throws IOException {
    this.res = Response.execute(this.req);
    return this.res;
  }
  
  public Connection.Request request() { return this.req; }
  
  public Connection request(Connection.Request request) {
    this.req = (Request)request;
    return this;
  }
  
  public Connection.Response response() throws IOException {
    if (this.res == null)
      throw new IllegalArgumentException("You must execute the request before getting a response."); 
    return this.res;
  }
  
  public Connection response(Connection.Response response) {
    this.res = response;
    return this;
  }
  
  public Connection postDataCharset(String charset) {
    this.req.postDataCharset(charset);
    return this;
  }
  
  private static boolean needsMultipart(Connection.Request req) {
    for (Connection.KeyVal keyVal : req.data()) {
      if (keyVal.hasInputStream())
        return true; 
    } 
    return false;
  }
}
