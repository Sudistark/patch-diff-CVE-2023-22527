package org.jsoup.internal;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.Stack;
import java.util.regex.Pattern;
import org.jsoup.helper.Validate;

public final class StringUtil {
  static final String[] padding = { 
      "", " ", "  ", "   ", "    ", "     ", "      ", "       ", "        ", "         ", 
      "          ", "           ", "            ", "             ", "              ", "               ", "                ", "                 ", "                  ", "                   ", 
      "                    " };
  
  public static String join(Collection<?> strings, String sep) { return join(strings.iterator(), sep); }
  
  public static String join(Iterator<?> strings, String sep) {
    if (!strings.hasNext())
      return ""; 
    String start = strings.next().toString();
    if (!strings.hasNext())
      return start; 
    StringJoiner j = new StringJoiner(sep);
    j.add(start);
    while (strings.hasNext())
      j.add(strings.next()); 
    return j.complete();
  }
  
  public static String join(String[] strings, String sep) { return join(Arrays.asList(strings), sep); }
  
  public static String padding(int width) { return padding(width, 30); }
  
  public static String padding(int width, int maxPaddingWidth) {
    Validate.isTrue((width >= 0), "width must be >= 0");
    Validate.isTrue((maxPaddingWidth >= -1));
    if (maxPaddingWidth != -1)
      width = Math.min(width, maxPaddingWidth); 
    if (width < padding.length)
      return padding[width]; 
    char[] out = new char[width];
    for (int i = 0; i < width; i++)
      out[i] = ' '; 
    return String.valueOf(out);
  }
  
  public static boolean isBlank(String string) {
    if (string == null || string.length() == 0)
      return true; 
    int l = string.length();
    for (int i = 0; i < l; i++) {
      if (!isWhitespace(string.codePointAt(i)))
        return false; 
    } 
    return true;
  }
  
  public static boolean startsWithNewline(String string) {
    if (string == null || string.length() == 0)
      return false; 
    return (string.charAt(0) == '\n');
  }
  
  public static boolean isNumeric(String string) {
    if (string == null || string.length() == 0)
      return false; 
    int l = string.length();
    for (int i = 0; i < l; i++) {
      if (!Character.isDigit(string.codePointAt(i)))
        return false; 
    } 
    return true;
  }
  
  public static boolean isWhitespace(int c) { return (c == 32 || c == 9 || c == 10 || c == 12 || c == 13); }
  
  public static boolean isActuallyWhitespace(int c) { return (c == 32 || c == 9 || c == 10 || c == 12 || c == 13 || c == 160); }
  
  public static boolean isInvisibleChar(int c) { return (c == 8203 || c == 173); }
  
  public static String normaliseWhitespace(String string) {
    StringBuilder sb = borrowBuilder();
    appendNormalisedWhitespace(sb, string, false);
    return releaseBuilder(sb);
  }
  
  public static void appendNormalisedWhitespace(StringBuilder accum, String string, boolean stripLeading) {
    boolean lastWasWhite = false;
    boolean reachedNonWhite = false;
    int len = string.length();
    int i;
    for (i = 0; i < len; i += Character.charCount(c)) {
      int c = string.codePointAt(i);
      if (isActuallyWhitespace(c)) {
        if ((!stripLeading || reachedNonWhite) && !lastWasWhite) {
          accum.append(' ');
          lastWasWhite = true;
        } 
      } else if (!isInvisibleChar(c)) {
        accum.appendCodePoint(c);
        lastWasWhite = false;
        reachedNonWhite = true;
      } 
    } 
  }
  
  public static boolean in(String needle, String... haystack) {
    int len = haystack.length;
    for (int i = 0; i < len; i++) {
      if (haystack[i].equals(needle))
        return true; 
    } 
    return false;
  }
  
  public static boolean inSorted(String needle, String[] haystack) { return (Arrays.binarySearch(haystack, needle) >= 0); }
  
  public static boolean isAscii(String string) {
    Validate.notNull(string);
    for (int i = 0; i < string.length(); i++) {
      int c = string.charAt(i);
      if (c > 127)
        return false; 
    } 
    return true;
  }
  
  private static final Pattern extraDotSegmentsPattern = Pattern.compile("^/((\\.{1,2}/)+)");
  
  public static URL resolve(URL base, String relUrl) throws MalformedURLException {
    relUrl = stripControlChars(relUrl);
    if (relUrl.startsWith("?"))
      relUrl = base.getPath() + relUrl; 
    URL url = new URL(base, relUrl);
    String fixedFile = extraDotSegmentsPattern.matcher(url.getFile()).replaceFirst("/");
    if (url.getRef() != null)
      fixedFile = fixedFile + "#" + url.getRef(); 
    return new URL(url.getProtocol(), url.getHost(), url.getPort(), fixedFile);
  }
  
  public static String resolve(String baseUrl, String relUrl) {
    baseUrl = stripControlChars(baseUrl);
    relUrl = stripControlChars(relUrl);
    try {
      URL base;
      try {
        base = new URL(baseUrl);
      } catch (MalformedURLException e) {
        URL abs = new URL(relUrl);
        return abs.toExternalForm();
      } 
      return resolve(base, relUrl).toExternalForm();
    } catch (MalformedURLException e) {
      URL base;
      return validUriScheme.matcher(relUrl).find() ? relUrl : "";
    } 
  }
  
  private static final Pattern validUriScheme = Pattern.compile("^[a-zA-Z][a-zA-Z0-9+-.]*:");
  
  private static final Pattern controlChars = Pattern.compile("[\\x00-\\x1f]*");
  
  private static String stripControlChars(String input) { return controlChars.matcher(input).replaceAll(""); }
  
  private static final ThreadLocal<Stack<StringBuilder>> threadLocalBuilders = new Object();
  
  private static final int MaxCachedBuilderSize = 8192;
  
  private static final int MaxIdleBuilders = 8;
  
  public static StringBuilder borrowBuilder() {
    builders = (Stack)threadLocalBuilders.get();
    return builders.empty() ? 
      new StringBuilder(8192) : 
      (StringBuilder)builders.pop();
  }
  
  public static String releaseBuilder(StringBuilder sb) {
    Validate.notNull(sb);
    String string = sb.toString();
    if (sb.length() > 8192) {
      sb = new StringBuilder(8192);
    } else {
      sb.delete(0, sb.length());
    } 
    Stack<StringBuilder> builders = (Stack)threadLocalBuilders.get();
    builders.push(sb);
    while (builders.size() > 8)
      builders.pop(); 
    return string;
  }
}
