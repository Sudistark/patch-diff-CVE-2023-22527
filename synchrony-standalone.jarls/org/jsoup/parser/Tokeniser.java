package org.jsoup.parser;

import java.util.Arrays;
import javax.annotation.Nullable;
import org.jsoup.helper.Validate;
import org.jsoup.internal.StringUtil;
import org.jsoup.nodes.Entities;

final class Tokeniser {
  static final char replacementChar = 'ï¿½';
  
  private static final char[] notCharRefCharsSorted = { '\t', '\n', '\r', '\f', ' ', '<', '&' };
  
  static final int win1252ExtensionsStart = 128;
  
  static final int[] win1252Extensions = { 
      8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 
      352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 
      8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 
      382, 376 };
  
  private final CharacterReader reader;
  
  private final ParseErrorList errors;
  
  private TokeniserState state;
  
  @Nullable
  private Token emitPending;
  
  private boolean isEmitPending;
  
  @Nullable
  private String charsString;
  
  private final StringBuilder charsBuilder;
  
  StringBuilder dataBuffer;
  
  Token.StartTag startPending;
  
  Token.EndTag endPending;
  
  Token.Tag tagPending;
  
  Token.Character charPending;
  
  Token.Doctype doctypePending;
  
  Token.Comment commentPending;
  
  @Nullable
  private String lastStartTag;
  
  @Nullable
  private String lastStartCloseSeq;
  
  private static final int Unset = -1;
  
  private int markupStartPos;
  
  private int charStartPos;
  
  private final int[] codepointHolder;
  
  private final int[] multipointHolder;
  
  static  {
    Arrays.sort(notCharRefCharsSorted);
  }
  
  Tokeniser(CharacterReader reader, ParseErrorList errors) {
    this.state = TokeniserState.Data;
    this.emitPending = null;
    this.isEmitPending = false;
    this.charsString = null;
    this.charsBuilder = new StringBuilder(1024);
    this.dataBuffer = new StringBuilder(1024);
    this.startPending = new Token.StartTag();
    this.endPending = new Token.EndTag();
    this.tagPending = this.startPending;
    this.charPending = new Token.Character();
    this.doctypePending = new Token.Doctype();
    this.commentPending = new Token.Comment();
    this.charStartPos = -1;
    this.codepointHolder = new int[1];
    this.multipointHolder = new int[2];
    this.reader = reader;
    this.errors = errors;
  }
  
  Token read() {
    while (!this.isEmitPending)
      this.state.read(this, this.reader); 
    StringBuilder cb = this.charsBuilder;
    if (cb.length() != 0) {
      String str = cb.toString();
      cb.delete(0, cb.length());
      Token.Character character = this.charPending.data(str);
      this.charsString = null;
      return character;
    } 
    if (this.charsString != null) {
      Token.Character character = this.charPending.data(this.charsString);
      this.charsString = null;
      return character;
    } 
    this.isEmitPending = false;
    assert this.emitPending != null;
    return this.emitPending;
  }
  
  void emit(Token token) {
    Validate.isFalse(this.isEmitPending);
    this.emitPending = token;
    this.isEmitPending = true;
    token.startPos(this.markupStartPos);
    token.endPos(this.reader.pos());
    this.charStartPos = -1;
    if (token.type == Token.TokenType.StartTag) {
      Token.StartTag startTag = (Token.StartTag)token;
      this.lastStartTag = startTag.tagName;
      this.lastStartCloseSeq = null;
    } else if (token.type == Token.TokenType.EndTag) {
      Token.EndTag endTag = (Token.EndTag)token;
      if (endTag.hasAttributes())
        error("Attributes incorrectly present on end tag [/%s]", new Object[] { endTag.normalName() }); 
    } 
  }
  
  void emit(String str) {
    if (this.charsString == null) {
      this.charsString = str;
    } else {
      if (this.charsBuilder.length() == 0)
        this.charsBuilder.append(this.charsString); 
      this.charsBuilder.append(str);
    } 
    this.charPending.startPos(this.charStartPos);
    this.charPending.endPos(this.reader.pos());
  }
  
  void emit(StringBuilder str) {
    if (this.charsString == null) {
      this.charsString = str.toString();
    } else {
      if (this.charsBuilder.length() == 0)
        this.charsBuilder.append(this.charsString); 
      this.charsBuilder.append(str);
    } 
    this.charPending.startPos(this.charStartPos);
    this.charPending.endPos(this.reader.pos());
  }
  
  void emit(char c) {
    if (this.charsString == null) {
      this.charsString = String.valueOf(c);
    } else {
      if (this.charsBuilder.length() == 0)
        this.charsBuilder.append(this.charsString); 
      this.charsBuilder.append(c);
    } 
    this.charPending.startPos(this.charStartPos);
    this.charPending.endPos(this.reader.pos());
  }
  
  void emit(char[] chars) { emit(String.valueOf(chars)); }
  
  void emit(int[] codepoints) { emit(new String(codepoints, 0, codepoints.length)); }
  
  TokeniserState getState() { return this.state; }
  
  void transition(TokeniserState newState) {
    switch (null.$SwitchMap$org$jsoup$parser$TokeniserState[newState.ordinal()]) {
      case 1:
        this.markupStartPos = this.reader.pos();
        break;
      case 2:
        if (this.charStartPos == -1)
          this.charStartPos = this.reader.pos(); 
        break;
    } 
    this.state = newState;
  }
  
  void advanceTransition(TokeniserState newState) {
    transition(newState);
    this.reader.advance();
  }
  
  @Nullable
  int[] consumeCharacterReference(@Nullable Character additionalAllowedCharacter, boolean inAttribute) {
    if (this.reader.isEmpty())
      return null; 
    if (additionalAllowedCharacter != null && additionalAllowedCharacter.charValue() == this.reader.current())
      return null; 
    if (this.reader.matchesAnySorted(notCharRefCharsSorted))
      return null; 
    int[] codeRef = this.codepointHolder;
    this.reader.mark();
    if (this.reader.matchConsume("#")) {
      boolean isHexMode = this.reader.matchConsumeIgnoreCase("X");
      String numRef = isHexMode ? this.reader.consumeHexSequence() : this.reader.consumeDigitSequence();
      if (numRef.length() == 0) {
        characterReferenceError("numeric reference with no numerals", new Object[0]);
        this.reader.rewindToMark();
        return null;
      } 
      this.reader.unmark();
      if (!this.reader.matchConsume(";"))
        characterReferenceError("missing semicolon on [&#%s]", new Object[] { numRef }); 
      int charval = -1;
      try {
        int base = isHexMode ? 16 : 10;
        charval = Integer.valueOf(numRef, base).intValue();
      } catch (NumberFormatException numberFormatException) {}
      if (charval == -1 || (charval >= 55296 && charval <= 57343) || charval > 1114111) {
        characterReferenceError("character [%s] outside of valid range", new Object[] { Integer.valueOf(charval) });
        codeRef[0] = 65533;
      } else {
        if (charval >= 128 && charval < 128 + win1252Extensions.length) {
          characterReferenceError("character [%s] is not a valid unicode code point", new Object[] { Integer.valueOf(charval) });
          charval = win1252Extensions[charval - 128];
        } 
        codeRef[0] = charval;
      } 
      return codeRef;
    } 
    String nameRef = this.reader.consumeLetterThenDigitSequence();
    boolean looksLegit = this.reader.matches(';');
    boolean found = (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) && looksLegit));
    if (!found) {
      this.reader.rewindToMark();
      if (looksLegit)
        characterReferenceError("invalid named reference [%s]", new Object[] { nameRef }); 
      return null;
    } 
    if (inAttribute && (this.reader.matchesLetter() || this.reader.matchesDigit() || this.reader.matchesAny(new char[] { '=', '-', '_' }))) {
      this.reader.rewindToMark();
      return null;
    } 
    this.reader.unmark();
    if (!this.reader.matchConsume(";"))
      characterReferenceError("missing semicolon on [&%s]", new Object[] { nameRef }); 
    int numChars = Entities.codepointsForName(nameRef, this.multipointHolder);
    if (numChars == 1) {
      codeRef[0] = this.multipointHolder[0];
      return codeRef;
    } 
    if (numChars == 2)
      return this.multipointHolder; 
    Validate.fail("Unexpected characters returned for " + nameRef);
    return this.multipointHolder;
  }
  
  Token.Tag createTagPending(boolean start) {
    this.tagPending = start ? this.startPending.reset() : this.endPending.reset();
    return this.tagPending;
  }
  
  void emitTagPending() {
    this.tagPending.finaliseTag();
    emit(this.tagPending);
  }
  
  void createCommentPending() { this.commentPending.reset(); }
  
  void emitCommentPending() { emit(this.commentPending); }
  
  void createBogusCommentPending() {
    this.commentPending.reset();
    this.commentPending.bogus = true;
  }
  
  void createDoctypePending() { this.doctypePending.reset(); }
  
  void emitDoctypePending() { emit(this.doctypePending); }
  
  void createTempBuffer() { Token.reset(this.dataBuffer); }
  
  boolean isAppropriateEndTagToken() { return (this.lastStartTag != null && this.tagPending.name().equalsIgnoreCase(this.lastStartTag)); }
  
  @Nullable
  String appropriateEndTagName() { return this.lastStartTag; }
  
  String appropriateEndTagSeq() {
    if (this.lastStartCloseSeq == null)
      this.lastStartCloseSeq = "</" + this.lastStartTag; 
    return this.lastStartCloseSeq;
  }
  
  void error(TokeniserState state) {
    if (this.errors.canAddError())
      this.errors.add(new ParseError(this.reader, "Unexpected character '%s' in input state [%s]", new Object[] { Character.valueOf(this.reader.current()), state })); 
  }
  
  void eofError(TokeniserState state) {
    if (this.errors.canAddError())
      this.errors.add(new ParseError(this.reader, "Unexpectedly reached end of file (EOF) in input state [%s]", new Object[] { state })); 
  }
  
  private void characterReferenceError(String message, Object... args) {
    if (this.errors.canAddError())
      this.errors.add(new ParseError(this.reader, String.format("Invalid character reference: " + message, args))); 
  }
  
  void error(String errorMsg) {
    if (this.errors.canAddError())
      this.errors.add(new ParseError(this.reader, errorMsg)); 
  }
  
  void error(String errorMsg, Object... args) {
    if (this.errors.canAddError())
      this.errors.add(new ParseError(this.reader, errorMsg, args)); 
  }
  
  boolean currentNodeInHtmlNS() { return true; }
  
  String unescapeEntities(boolean inAttribute) {
    StringBuilder builder = StringUtil.borrowBuilder();
    while (!this.reader.isEmpty()) {
      builder.append(this.reader.consumeTo('&'));
      if (this.reader.matches('&')) {
        this.reader.consume();
        int[] c = consumeCharacterReference(null, inAttribute);
        if (c == null || c.length == 0) {
          builder.append('&');
          continue;
        } 
        builder.appendCodePoint(c[0]);
        if (c.length == 2)
          builder.appendCodePoint(c[1]); 
      } 
    } 
    return StringUtil.releaseBuilder(builder);
  }
}
