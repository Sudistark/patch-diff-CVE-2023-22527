package org.jsoup.nodes;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;
import org.jsoup.SerializationException;
import org.jsoup.helper.Validate;
import org.jsoup.internal.Normalizer;
import org.jsoup.internal.StringUtil;
import org.jsoup.parser.ParseSettings;

public class Attributes extends Object implements Iterable<Attribute>, Cloneable {
  protected static final String dataPrefix = "data-";
  
  static final char InternalPrefix = '/';
  
  private static final int InitialCapacity = 3;
  
  private static final int GrowthFactor = 2;
  
  static final int NotFound = -1;
  
  private static final String EmptyString = "";
  
  private int size = 0;
  
  String[] keys = new String[3];
  
  Object[] vals = new Object[3];
  
  private void checkCapacity(int minNewSize) {
    Validate.isTrue((minNewSize >= this.size));
    int curCap = this.keys.length;
    if (curCap >= minNewSize)
      return; 
    int newCap = (curCap >= 3) ? (this.size * 2) : 3;
    if (minNewSize > newCap)
      newCap = minNewSize; 
    this.keys = (String[])Arrays.copyOf(this.keys, newCap);
    this.vals = Arrays.copyOf(this.vals, newCap);
  }
  
  int indexOfKey(String key) {
    Validate.notNull(key);
    for (int i = 0; i < this.size; i++) {
      if (key.equals(this.keys[i]))
        return i; 
    } 
    return -1;
  }
  
  private int indexOfKeyIgnoreCase(String key) {
    Validate.notNull(key);
    for (int i = 0; i < this.size; i++) {
      if (key.equalsIgnoreCase(this.keys[i]))
        return i; 
    } 
    return -1;
  }
  
  static String checkNotNull(@Nullable Object val) { return (val == null) ? "" : (String)val; }
  
  public String get(String key) {
    int i = indexOfKey(key);
    return (i == -1) ? "" : checkNotNull(this.vals[i]);
  }
  
  public String getIgnoreCase(String key) {
    int i = indexOfKeyIgnoreCase(key);
    return (i == -1) ? "" : checkNotNull(this.vals[i]);
  }
  
  @Nullable
  Object getUserData(String key) {
    Validate.notNull(key);
    if (!isInternalKey(key))
      key = internalKey(key); 
    int i = indexOfKeyIgnoreCase(key);
    return (i == -1) ? null : this.vals[i];
  }
  
  public Attributes add(String key, @Nullable String value) {
    addObject(key, value);
    return this;
  }
  
  private void addObject(String key, @Nullable Object value) {
    checkCapacity(this.size + 1);
    this.keys[this.size] = key;
    this.vals[this.size] = value;
    this.size++;
  }
  
  public Attributes put(String key, @Nullable String value) {
    Validate.notNull(key);
    int i = indexOfKey(key);
    if (i != -1) {
      this.vals[i] = value;
    } else {
      add(key, value);
    } 
    return this;
  }
  
  Attributes putUserData(String key, Object value) {
    Validate.notNull(key);
    if (!isInternalKey(key))
      key = internalKey(key); 
    Validate.notNull(value);
    int i = indexOfKey(key);
    if (i != -1) {
      this.vals[i] = value;
    } else {
      addObject(key, value);
    } 
    return this;
  }
  
  void putIgnoreCase(String key, @Nullable String value) {
    int i = indexOfKeyIgnoreCase(key);
    if (i != -1) {
      this.vals[i] = value;
      if (!this.keys[i].equals(key))
        this.keys[i] = key; 
    } else {
      add(key, value);
    } 
  }
  
  public Attributes put(String key, boolean value) {
    if (value) {
      putIgnoreCase(key, null);
    } else {
      remove(key);
    } 
    return this;
  }
  
  public Attributes put(Attribute attribute) {
    Validate.notNull(attribute);
    put(attribute.getKey(), attribute.getValue());
    attribute.parent = this;
    return this;
  }
  
  private void remove(int index) {
    Validate.isFalse((index >= this.size));
    int shifted = this.size - index - 1;
    if (shifted > 0) {
      System.arraycopy(this.keys, index + 1, this.keys, index, shifted);
      System.arraycopy(this.vals, index + 1, this.vals, index, shifted);
    } 
    this.size--;
    this.keys[this.size] = null;
    this.vals[this.size] = null;
  }
  
  public void remove(String key) {
    int i = indexOfKey(key);
    if (i != -1)
      remove(i); 
  }
  
  public void removeIgnoreCase(String key) {
    int i = indexOfKeyIgnoreCase(key);
    if (i != -1)
      remove(i); 
  }
  
  public boolean hasKey(String key) { return (indexOfKey(key) != -1); }
  
  public boolean hasKeyIgnoreCase(String key) { return (indexOfKeyIgnoreCase(key) != -1); }
  
  public boolean hasDeclaredValueForKey(String key) {
    int i = indexOfKey(key);
    return (i != -1 && this.vals[i] != null);
  }
  
  public boolean hasDeclaredValueForKeyIgnoreCase(String key) {
    int i = indexOfKeyIgnoreCase(key);
    return (i != -1 && this.vals[i] != null);
  }
  
  public int size() { return this.size; }
  
  public boolean isEmpty() { return (this.size == 0); }
  
  public void addAll(Attributes incoming) {
    if (incoming.size() == 0)
      return; 
    checkCapacity(this.size + incoming.size);
    boolean needsPut = (this.size != 0);
    for (Attribute attr : incoming) {
      if (needsPut) {
        put(attr);
        continue;
      } 
      add(attr.getKey(), attr.getValue());
    } 
  }
  
  public Iterator<Attribute> iterator() { return new Object(this); }
  
  public List<Attribute> asList() {
    ArrayList<Attribute> list = new ArrayList<Attribute>(this.size);
    for (int i = 0; i < this.size; i++) {
      if (!isInternalKey(this.keys[i])) {
        Attribute attr = new Attribute(this.keys[i], (String)this.vals[i], this);
        list.add(attr);
      } 
    } 
    return Collections.unmodifiableList(list);
  }
  
  public Map<String, String> dataset() { return new Dataset(this, null); }
  
  public String html() {
    StringBuilder sb = StringUtil.borrowBuilder();
    try {
      html(sb, (new Document("")).outputSettings());
    } catch (IOException e) {
      throw new SerializationException(e);
    } 
    return StringUtil.releaseBuilder(sb);
  }
  
  final void html(Appendable accum, Document.OutputSettings out) throws IOException {
    int sz = this.size;
    for (int i = 0; i < sz; i++) {
      if (!isInternalKey(this.keys[i])) {
        String key = Attribute.getValidKey(this.keys[i], out.syntax());
        if (key != null)
          Attribute.htmlNoValidate(key, (String)this.vals[i], accum.append(' '), out); 
      } 
    } 
  }
  
  public String toString() { return html(); }
  
  public boolean equals(@Nullable Object o) {
    if (this == o)
      return true; 
    if (o == null || getClass() != o.getClass())
      return false; 
    Attributes that = (Attributes)o;
    if (this.size != that.size)
      return false; 
    for (int i = 0; i < this.size; i++) {
      String key = this.keys[i];
      int thatI = that.indexOfKey(key);
      if (thatI == -1)
        return false; 
      Object val = this.vals[i];
      Object thatVal = that.vals[thatI];
      if (val == null) {
        if (thatVal != null)
          return false; 
      } else if (!val.equals(thatVal)) {
        return false;
      } 
    } 
    return true;
  }
  
  public int hashCode() {
    result = this.size;
    result = 31 * result + Arrays.hashCode(this.keys);
    return 31 * result + Arrays.hashCode(this.vals);
  }
  
  public Attributes clone() {
    Attributes clone;
    try {
      clone = (Attributes)super.clone();
    } catch (CloneNotSupportedException e) {
      throw new RuntimeException(e);
    } 
    clone.size = this.size;
    clone.keys = (String[])Arrays.copyOf(this.keys, this.size);
    clone.vals = Arrays.copyOf(this.vals, this.size);
    return clone;
  }
  
  public void normalize() {
    for (int i = 0; i < this.size; i++)
      this.keys[i] = Normalizer.lowerCase(this.keys[i]); 
  }
  
  public int deduplicate(ParseSettings settings) {
    if (isEmpty())
      return 0; 
    boolean preserve = settings.preserveAttributeCase();
    int dupes = 0;
    for (int i = 0; i < this.keys.length; i++) {
      for (int j = i + 1; j < this.keys.length && 
        this.keys[j] != null; j++) {
        if ((preserve && this.keys[i].equals(this.keys[j])) || (!preserve && this.keys[i].equalsIgnoreCase(this.keys[j]))) {
          dupes++;
          remove(j);
          j--;
        } 
      } 
    } 
    return dupes;
  }
  
  private static String dataKey(String key) { return "data-" + key; }
  
  static String internalKey(String key) { return '/' + key; }
  
  private boolean isInternalKey(String key) { return (key != null && key.length() > 1 && key.charAt(0) == '/'); }
}
