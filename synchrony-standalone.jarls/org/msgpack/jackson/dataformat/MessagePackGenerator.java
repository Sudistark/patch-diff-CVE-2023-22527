package org.msgpack.jackson.dataformat;

import com.fasterxml.jackson.core.Base64Variant;
import com.fasterxml.jackson.core.JsonGenerationException;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.ObjectCodec;
import com.fasterxml.jackson.core.SerializableString;
import com.fasterxml.jackson.core.base.GeneratorBase;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.util.LinkedList;
import java.util.List;
import org.msgpack.core.MessagePack;
import org.msgpack.core.MessagePacker;
import org.msgpack.core.buffer.OutputStreamBufferOutput;

public class MessagePackGenerator extends GeneratorBase {
  private static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8");
  
  private final MessagePacker messagePacker;
  
  private static ThreadLocal<OutputStreamBufferOutput> messageBufferOutputHolder = new ThreadLocal();
  
  private final OutputStream output;
  
  private final MessagePack.PackerConfig packerConfig;
  
  private LinkedList<StackItem> stack;
  
  private StackItem rootStackItem;
  
  public MessagePackGenerator(int paramInt, ObjectCodec paramObjectCodec, OutputStream paramOutputStream, MessagePack.PackerConfig paramPackerConfig, boolean paramBoolean) throws IOException {
    super(paramInt, paramObjectCodec);
    this.output = paramOutputStream;
    if (paramBoolean) {
      outputStreamBufferOutput = (OutputStreamBufferOutput)messageBufferOutputHolder.get();
      if (outputStreamBufferOutput == null) {
        outputStreamBufferOutput = new OutputStreamBufferOutput(paramOutputStream);
        messageBufferOutputHolder.set(outputStreamBufferOutput);
      } else {
        outputStreamBufferOutput.reset(paramOutputStream);
      } 
    } else {
      outputStreamBufferOutput = new OutputStreamBufferOutput(paramOutputStream);
    } 
    this.messagePacker = paramPackerConfig.newPacker(outputStreamBufferOutput);
    this.packerConfig = paramPackerConfig;
    this.stack = new LinkedList();
  }
  
  public void writeStartArray() throws IOException, JsonGenerationException {
    this._writeContext = this._writeContext.createChildArrayContext();
    this.stack.push(new StackItemForArray(null));
  }
  
  public void writeEndArray() throws IOException, JsonGenerationException {
    if (!this._writeContext.inArray())
      _reportError("Current context not an array but " + this._writeContext.getTypeDesc()); 
    getStackTopForArray();
    this._writeContext = this._writeContext.getParent();
    popStackAndStoreTheItemAsValue();
  }
  
  public void writeStartObject() throws IOException, JsonGenerationException {
    this._writeContext = this._writeContext.createChildObjectContext();
    this.stack.push(new StackItemForObject(null));
  }
  
  public void writeEndObject() throws IOException, JsonGenerationException {
    if (!this._writeContext.inObject())
      _reportError("Current context not an object but " + this._writeContext.getTypeDesc()); 
    StackItemForObject stackItemForObject = getStackTopForObject();
    if (stackItemForObject.getKeys().size() != stackItemForObject.getValues().size())
      throw new IllegalStateException(
          String.format("objectKeys.size() and objectValues.size() is not same: depth=%d, key=%d, value=%d", new Object[] { Integer.valueOf(this.stack.size()), Integer.valueOf(stackItemForObject.getKeys().size()), Integer.valueOf(stackItemForObject.getValues().size()) })); 
    this._writeContext = this._writeContext.getParent();
    popStackAndStoreTheItemAsValue();
  }
  
  private void pack(Object paramObject) throws IOException {
    MessagePacker messagePacker1 = getMessagePacker();
    if (paramObject == null) {
      messagePacker1.packNil();
    } else if (paramObject instanceof Integer) {
      messagePacker1.packInt(((Integer)paramObject).intValue());
    } else if (paramObject instanceof ByteBuffer) {
      ByteBuffer byteBuffer = (ByteBuffer)paramObject;
      int i = byteBuffer.remaining();
      if (byteBuffer.hasArray()) {
        messagePacker1.packBinaryHeader(i);
        messagePacker1.writePayload(byteBuffer.array(), byteBuffer.arrayOffset(), i);
      } else {
        byte[] arrayOfByte = new byte[i];
        byteBuffer.get(arrayOfByte);
        messagePacker1.packBinaryHeader(i);
        messagePacker1.addPayload(arrayOfByte);
      } 
    } else if (paramObject instanceof String) {
      messagePacker1.packString((String)paramObject);
    } else if (paramObject instanceof Float) {
      messagePacker1.packFloat(((Float)paramObject).floatValue());
    } else if (paramObject instanceof Long) {
      messagePacker1.packLong(((Long)paramObject).longValue());
    } else if (paramObject instanceof StackItemForObject) {
      packObject((StackItemForObject)paramObject);
    } else if (paramObject instanceof StackItemForArray) {
      packArray((StackItemForArray)paramObject);
    } else if (paramObject instanceof Double) {
      messagePacker1.packDouble(((Double)paramObject).doubleValue());
    } else if (paramObject instanceof BigInteger) {
      messagePacker1.packBigInteger((BigInteger)paramObject);
    } else if (paramObject instanceof BigDecimal) {
      packBigDecimal((BigDecimal)paramObject);
    } else if (paramObject instanceof Boolean) {
      messagePacker1.packBoolean(((Boolean)paramObject).booleanValue());
    } else if (paramObject instanceof MessagePackExtensionType) {
      MessagePackExtensionType messagePackExtensionType = (MessagePackExtensionType)paramObject;
      byte[] arrayOfByte = messagePackExtensionType.getData();
      messagePacker1.packExtensionTypeHeader(messagePackExtensionType.getType(), arrayOfByte.length);
      messagePacker1.writePayload(arrayOfByte);
    } else {
      messagePacker1.flush();
      ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
      MessagePackGenerator messagePackGenerator = new MessagePackGenerator(getFeatureMask(), getCodec(), byteArrayOutputStream, this.packerConfig, false);
      getCodec().writeValue(messagePackGenerator, paramObject);
      this.output.write(byteArrayOutputStream.toByteArray());
    } 
  }
  
  private void packBigDecimal(BigDecimal paramBigDecimal) throws IOException {
    MessagePacker messagePacker1 = getMessagePacker();
    boolean bool = false;
    try {
      BigInteger bigInteger = paramBigDecimal.toBigIntegerExact();
      messagePacker1.packBigInteger(bigInteger);
    } catch (ArithmeticException arithmeticException) {
      bool = true;
    } catch (IllegalArgumentException illegalArgumentException) {
      bool = true;
    } 
    if (bool) {
      double d = paramBigDecimal.doubleValue();
      if (!paramBigDecimal.stripTrailingZeros().toEngineeringString().equals(
          BigDecimal.valueOf(d).stripTrailingZeros().toEngineeringString()))
        throw new IllegalArgumentException("MessagePack cannot serialize a BigDecimal that can't be represented as double. " + paramBigDecimal); 
      messagePacker1.packDouble(d);
    } 
  }
  
  private void packObject(StackItemForObject paramStackItemForObject) throws IOException {
    List list1 = paramStackItemForObject.getKeys();
    List list2 = paramStackItemForObject.getValues();
    MessagePacker messagePacker1 = getMessagePacker();
    messagePacker1.packMapHeader(list1.size());
    for (byte b = 0; b < list1.size(); b++) {
      pack(list1.get(b));
      pack(list2.get(b));
    } 
  }
  
  private void packArray(StackItemForArray paramStackItemForArray) throws IOException {
    List list = paramStackItemForArray.getValues();
    MessagePacker messagePacker1 = getMessagePacker();
    messagePacker1.packArrayHeader(list.size());
    for (byte b = 0; b < list.size(); b++) {
      Object object = list.get(b);
      pack(object);
    } 
  }
  
  public void writeFieldName(String paramString) throws IOException, JsonGenerationException { addKeyToStackTop(paramString); }
  
  public void writeFieldName(SerializableString paramSerializableString) throws IOException {
    if (paramSerializableString instanceof MessagePackSerializedString) {
      addKeyToStackTop(((MessagePackSerializedString)paramSerializableString).getRawValue());
    } else if (paramSerializableString instanceof com.fasterxml.jackson.core.io.SerializedString) {
      addKeyToStackTop(paramSerializableString.getValue());
    } else {
      System.out.println(paramSerializableString.getClass());
      throw new IllegalArgumentException("Unsupported key: " + paramSerializableString);
    } 
  }
  
  public void writeString(String paramString) throws IOException, JsonGenerationException { addValueToStackTop(paramString); }
  
  public void writeString(char[] paramArrayOfChar, int paramInt1, int paramInt2) throws IOException, JsonGenerationException { addValueToStackTop(new String(paramArrayOfChar, paramInt1, paramInt2)); }
  
  public void writeRawUTF8String(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException, JsonGenerationException { addValueToStackTop(new String(paramArrayOfByte, paramInt1, paramInt2, DEFAULT_CHARSET)); }
  
  public void writeUTF8String(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException, JsonGenerationException { addValueToStackTop(new String(paramArrayOfByte, paramInt1, paramInt2, DEFAULT_CHARSET)); }
  
  public void writeRaw(String paramString) throws IOException, JsonGenerationException { addValueToStackTop(paramString); }
  
  public void writeRaw(String paramString, int paramInt1, int paramInt2) throws IOException, JsonGenerationException { addValueToStackTop(paramString.substring(0, paramInt2)); }
  
  public void writeRaw(char[] paramArrayOfChar, int paramInt1, int paramInt2) throws IOException, JsonGenerationException { addValueToStackTop(new String(paramArrayOfChar, paramInt1, paramInt2)); }
  
  public void writeRaw(char paramChar) throws IOException, JsonGenerationException { addValueToStackTop(String.valueOf(paramChar)); }
  
  public void writeBinary(Base64Variant paramBase64Variant, byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException, JsonGenerationException { addValueToStackTop(ByteBuffer.wrap(paramArrayOfByte, paramInt1, paramInt2)); }
  
  public void writeNumber(int paramInt) throws IOException, JsonGenerationException { addValueToStackTop(Integer.valueOf(paramInt)); }
  
  public void writeNumber(long paramLong) throws IOException, JsonGenerationException { addValueToStackTop(Long.valueOf(paramLong)); }
  
  public void writeNumber(BigInteger paramBigInteger) throws IOException, JsonGenerationException { addValueToStackTop(paramBigInteger); }
  
  public void writeNumber(double paramDouble) throws IOException, JsonGenerationException { addValueToStackTop(Double.valueOf(paramDouble)); }
  
  public void writeNumber(float paramFloat) throws IOException, JsonGenerationException { addValueToStackTop(Float.valueOf(paramFloat)); }
  
  public void writeNumber(BigDecimal paramBigDecimal) throws IOException { addValueToStackTop(paramBigDecimal); }
  
  public void writeNumber(String paramString) throws IOException, JsonGenerationException {
    try {
      long l = Long.parseLong(paramString);
      addValueToStackTop(Long.valueOf(l));
      return;
    } catch (NumberFormatException numberFormatException) {
      try {
        double d = Double.parseDouble(paramString);
        addValueToStackTop(Double.valueOf(d));
        return;
      } catch (NumberFormatException numberFormatException) {
        try {
          BigInteger bigInteger = new BigInteger(paramString);
          addValueToStackTop(bigInteger);
          return;
        } catch (NumberFormatException numberFormatException) {
          try {
            BigDecimal bigDecimal = new BigDecimal(paramString);
            addValueToStackTop(bigDecimal);
            return;
          } catch (NumberFormatException numberFormatException) {
            throw new NumberFormatException(paramString);
          } 
        } 
      } 
    } 
  }
  
  public void writeBoolean(boolean paramBoolean) throws IOException, JsonGenerationException { addValueToStackTop(Boolean.valueOf(paramBoolean)); }
  
  public void writeNull() throws IOException, JsonGenerationException { addValueToStackTop(null); }
  
  public void writeExtensionType(MessagePackExtensionType paramMessagePackExtensionType) throws IOException { addValueToStackTop(paramMessagePackExtensionType); }
  
  public void close() throws IOException, JsonGenerationException {
    try {
      flush();
    } finally {
      if (isEnabled(JsonGenerator.Feature.AUTO_CLOSE_TARGET)) {
        MessagePacker messagePacker1 = getMessagePacker();
        messagePacker1.close();
      } 
    } 
  }
  
  public void flush() throws IOException, JsonGenerationException {
    if (this.rootStackItem != null) {
      if (this.rootStackItem instanceof StackItemForObject) {
        packObject((StackItemForObject)this.rootStackItem);
      } else if (this.rootStackItem instanceof StackItemForArray) {
        packArray((StackItemForArray)this.rootStackItem);
      } else {
        throw new IllegalStateException("Unexpected rootStackItem: " + this.rootStackItem);
      } 
      this.rootStackItem = null;
      flushMessagePacker();
    } 
  }
  
  private void flushMessagePacker() throws IOException, JsonGenerationException {
    MessagePacker messagePacker1 = getMessagePacker();
    messagePacker1.flush();
  }
  
  protected void _releaseBuffers() throws IOException, JsonGenerationException {}
  
  protected void _verifyValueWrite(String paramString) throws IOException, JsonGenerationException {
    int i = this._writeContext.writeValue();
    if (i == 5)
      _reportError("Can not " + paramString + ", expecting field name"); 
  }
  
  private StackItem getStackTop() {
    if (this.stack.isEmpty())
      throw new IllegalStateException("The stack is empty"); 
    return (StackItem)this.stack.getFirst();
  }
  
  private StackItemForObject getStackTopForObject() {
    StackItem stackItem = getStackTop();
    if (!(stackItem instanceof StackItemForObject))
      throw new IllegalStateException("The stack top should be Object: " + stackItem); 
    return (StackItemForObject)stackItem;
  }
  
  private StackItemForArray getStackTopForArray() {
    StackItem stackItem = getStackTop();
    if (!(stackItem instanceof StackItemForArray))
      throw new IllegalStateException("The stack top should be Array: " + stackItem); 
    return (StackItemForArray)stackItem;
  }
  
  private void addKeyToStackTop(Object paramObject) throws IOException { getStackTop().addKey(paramObject); }
  
  private void addValueToStackTop(Object paramObject) throws IOException {
    if (this.stack.isEmpty()) {
      pack(paramObject);
      flushMessagePacker();
    } else {
      getStackTop().addValue(paramObject);
    } 
  }
  
  private void popStackAndStoreTheItemAsValue() throws IOException, JsonGenerationException {
    StackItem stackItem = (StackItem)this.stack.pop();
    if (this.stack.size() > 0) {
      addValueToStackTop(stackItem);
    } else {
      if (this.rootStackItem != null)
        throw new IllegalStateException("rootStackItem is not null"); 
      this.rootStackItem = stackItem;
    } 
  }
  
  private MessagePacker getMessagePacker() { return this.messagePacker; }
}
