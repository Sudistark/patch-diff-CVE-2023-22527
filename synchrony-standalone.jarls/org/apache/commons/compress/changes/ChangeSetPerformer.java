package org.apache.commons.compress.changes;

import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Set;
import org.apache.commons.compress.archivers.ArchiveEntry;
import org.apache.commons.compress.archivers.ArchiveInputStream;
import org.apache.commons.compress.archivers.ArchiveOutputStream;
import org.apache.commons.compress.archivers.zip.ZipFile;
import org.apache.commons.compress.utils.IOUtils;

public class ChangeSetPerformer {
  private final Set<Change> changes;
  
  public ChangeSetPerformer(ChangeSet changeSet) { this.changes = changeSet.getChanges(); }
  
  private void copyStream(InputStream in, ArchiveOutputStream out, ArchiveEntry entry) throws IOException {
    out.putArchiveEntry(entry);
    IOUtils.copy(in, out);
    out.closeArchiveEntry();
  }
  
  private boolean isDeletedLater(Set<Change> workingSet, ArchiveEntry entry) {
    String source = entry.getName();
    if (!workingSet.isEmpty())
      for (Change change : workingSet) {
        int type = change.type();
        String target = change.targetFile();
        if (type == 1 && source.equals(target))
          return true; 
        if (type == 4 && source.startsWith(target + "/"))
          return true; 
      }  
    return false;
  }
  
  private ChangeSetResults perform(ArchiveEntryIterator entryIterator, ArchiveOutputStream out) throws IOException {
    ChangeSetResults results = new ChangeSetResults();
    Set<Change> workingSet = new LinkedHashSet<Change>(this.changes);
    for (Iterator<Change> it = workingSet.iterator(); it.hasNext(); ) {
      Change change = (Change)it.next();
      if (change.type() == 2 && change.isReplaceMode()) {
        copyStream(change.getInput(), out, change.getEntry());
        it.remove();
        results.addedFromChangeSet(change.getEntry().getName());
      } 
    } 
    while (entryIterator.hasNext()) {
      ArchiveEntry entry = entryIterator.next();
      boolean copy = true;
      for (Iterator<Change> it = workingSet.iterator(); it.hasNext(); ) {
        Change change = (Change)it.next();
        int type = change.type();
        String name = entry.getName();
        if (type == 1 && name != null) {
          if (name.equals(change.targetFile())) {
            copy = false;
            it.remove();
            results.deleted(name);
            break;
          } 
          continue;
        } 
        if (type == 4 && name != null)
          if (name.startsWith(change.targetFile() + "/")) {
            copy = false;
            results.deleted(name);
            break;
          }  
      } 
      if (copy && 
        !isDeletedLater(workingSet, entry) && 
        !results.hasBeenAdded(entry.getName())) {
        copyStream(entryIterator.getInputStream(), out, entry);
        results.addedFromStream(entry.getName());
      } 
    } 
    for (Iterator<Change> it = workingSet.iterator(); it.hasNext(); ) {
      Change change = (Change)it.next();
      if (change.type() == 2 && 
        !change.isReplaceMode() && 
        !results.hasBeenAdded(change.getEntry().getName())) {
        copyStream(change.getInput(), out, change.getEntry());
        it.remove();
        results.addedFromChangeSet(change.getEntry().getName());
      } 
    } 
    out.finish();
    return results;
  }
  
  public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException { return perform(new ArchiveInputStreamIterator(in), out); }
  
  public ChangeSetResults perform(ZipFile in, ArchiveOutputStream out) throws IOException { return perform(new ZipFileIterator(in), out); }
}
