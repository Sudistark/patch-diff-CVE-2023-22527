package org.apache.commons.compress.compressors.lz4;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import org.apache.commons.compress.compressors.CompressorOutputStream;
import org.apache.commons.compress.utils.ByteUtils;

public class FramedLZ4CompressorOutputStream extends CompressorOutputStream {
  private static final byte[] END_MARK = new byte[4];
  
  private final byte[] oneByte;
  
  private final byte[] blockData;
  
  private final OutputStream out;
  
  private final Parameters params;
  
  private boolean finished;
  
  private int currentIndex;
  
  private final XXHash32 contentHash;
  
  private final XXHash32 blockHash;
  
  private final byte[] blockDependencyBuffer;
  
  private int collectedBlockDependencyBytes;
  
  public FramedLZ4CompressorOutputStream(OutputStream out) throws IOException { this(out, Parameters.DEFAULT); }
  
  public FramedLZ4CompressorOutputStream(OutputStream out, Parameters params) throws IOException {
    this.oneByte = new byte[1];
    this.contentHash = new XXHash32();
    this.params = params;
    this.blockData = new byte[Parameters.access$000(params).getSize()];
    this.out = out;
    this.blockHash = Parameters.access$100(params) ? new XXHash32() : null;
    out.write(FramedLZ4CompressorInputStream.LZ4_SIGNATURE);
    writeFrameDescriptor();
    this
      
      .blockDependencyBuffer = Parameters.access$200(params) ? new byte[65536] : null;
  }
  
  private void appendToBlockDependencyBuffer(byte[] b, int off, int len) {
    len = Math.min(len, this.blockDependencyBuffer.length);
    if (len > 0) {
      int keep = this.blockDependencyBuffer.length - len;
      if (keep > 0)
        System.arraycopy(this.blockDependencyBuffer, len, this.blockDependencyBuffer, 0, keep); 
      System.arraycopy(b, off, this.blockDependencyBuffer, keep, len);
      this.collectedBlockDependencyBytes = Math.min(this.collectedBlockDependencyBytes + len, this.blockDependencyBuffer.length);
    } 
  }
  
  public void close() throws IOException {
    try {
      finish();
    } finally {
      this.out.close();
    } 
  }
  
  public void finish() throws IOException {
    if (!this.finished) {
      if (this.currentIndex > 0)
        flushBlock(); 
      writeTrailer();
      this.finished = true;
    } 
  }
  
  private void flushBlock() throws IOException {
    boolean withBlockDependency = Parameters.access$200(this.params);
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    BlockLZ4CompressorOutputStream o = new BlockLZ4CompressorOutputStream(baos, Parameters.access$300(this.params));
    try {
      if (withBlockDependency)
        o.prefill(this.blockDependencyBuffer, this.blockDependencyBuffer.length - this.collectedBlockDependencyBytes, this.collectedBlockDependencyBytes); 
      o.write(this.blockData, 0, this.currentIndex);
      o.close();
    } catch (Throwable throwable) {
      try {
        o.close();
      } catch (Throwable throwable1) {
        throwable.addSuppressed(throwable1);
      } 
      throw throwable;
    } 
    if (withBlockDependency)
      appendToBlockDependencyBuffer(this.blockData, 0, this.currentIndex); 
    byte[] b = baos.toByteArray();
    if (b.length > this.currentIndex) {
      ByteUtils.toLittleEndian(this.out, (this.currentIndex | 0x80000000), 4);
      this.out.write(this.blockData, 0, this.currentIndex);
      if (Parameters.access$100(this.params))
        this.blockHash.update(this.blockData, 0, this.currentIndex); 
    } else {
      ByteUtils.toLittleEndian(this.out, b.length, 4);
      this.out.write(b);
      if (Parameters.access$100(this.params))
        this.blockHash.update(b, 0, b.length); 
    } 
    if (Parameters.access$100(this.params)) {
      ByteUtils.toLittleEndian(this.out, this.blockHash.getValue(), 4);
      this.blockHash.reset();
    } 
    this.currentIndex = 0;
  }
  
  public void write(byte[] data, int off, int len) {
    if (Parameters.access$400(this.params))
      this.contentHash.update(data, off, len); 
    int blockDataLength = this.blockData.length;
    if (this.currentIndex + len > blockDataLength) {
      flushBlock();
      while (len > blockDataLength) {
        System.arraycopy(data, off, this.blockData, 0, blockDataLength);
        off += blockDataLength;
        len -= blockDataLength;
        this.currentIndex = blockDataLength;
        flushBlock();
      } 
    } 
    System.arraycopy(data, off, this.blockData, this.currentIndex, len);
    this.currentIndex += len;
  }
  
  public void write(int b) throws IOException {
    this.oneByte[0] = (byte)(b & 0xFF);
    write(this.oneByte);
  }
  
  private void writeFrameDescriptor() throws IOException {
    int flags = 64;
    if (!Parameters.access$200(this.params))
      flags |= 0x20; 
    if (Parameters.access$400(this.params))
      flags |= 0x4; 
    if (Parameters.access$100(this.params))
      flags |= 0x10; 
    this.out.write(flags);
    this.contentHash.update(flags);
    int bd = Parameters.access$000(this.params).getIndex() << 4 & 0x70;
    this.out.write(bd);
    this.contentHash.update(bd);
    this.out.write((int)(this.contentHash.getValue() >> 8 & 0xFFL));
    this.contentHash.reset();
  }
  
  private void writeTrailer() throws IOException {
    this.out.write(END_MARK);
    if (Parameters.access$400(this.params))
      ByteUtils.toLittleEndian(this.out, this.contentHash.getValue(), 4); 
  }
}
