package org.apache.commons.compress.compressors.z;

import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteOrder;
import org.apache.commons.compress.compressors.lzw.LZWInputStream;

public class ZCompressorInputStream extends LZWInputStream {
  private static final int MAGIC_1 = 31;
  
  private static final int MAGIC_2 = 157;
  
  private static final int BLOCK_MODE_MASK = 128;
  
  private static final int MAX_CODE_SIZE_MASK = 31;
  
  private final boolean blockMode;
  
  private final int maxCodeSize;
  
  private long totalCodesRead;
  
  public static boolean matches(byte[] signature, int length) { return (length > 3 && signature[0] == 31 && signature[1] == -99); }
  
  public ZCompressorInputStream(InputStream inputStream) throws IOException { this(inputStream, -1); }
  
  public ZCompressorInputStream(InputStream inputStream, int memoryLimitInKb) throws IOException {
    super(inputStream, ByteOrder.LITTLE_ENDIAN);
    int firstByte = (int)this.in.readBits(8);
    int secondByte = (int)this.in.readBits(8);
    int thirdByte = (int)this.in.readBits(8);
    if (firstByte != 31 || secondByte != 157 || thirdByte < 0)
      throw new IOException("Input is not in .Z format"); 
    this.blockMode = ((thirdByte & 0x80) != 0);
    this.maxCodeSize = thirdByte & 0x1F;
    if (this.blockMode)
      setClearCode(9); 
    initializeTables(this.maxCodeSize, memoryLimitInKb);
    clearEntries();
  }
  
  protected int addEntry(int previousCode, byte character) throws IOException {
    int maxTableSize = 1 << getCodeSize();
    int r = addEntry(previousCode, character, maxTableSize);
    if (getTableSize() == maxTableSize && getCodeSize() < this.maxCodeSize) {
      reAlignReading();
      incrementCodeSize();
    } 
    return r;
  }
  
  private void clearEntries() { setTableSize('Ä€' + (this.blockMode ? 1 : Character.MIN_VALUE)); }
  
  protected int decompressNextSymbol() throws IOException {
    int code = readNextCode();
    if (code < 0)
      return -1; 
    if (this.blockMode && code == getClearCode()) {
      clearEntries();
      reAlignReading();
      resetCodeSize();
      resetPreviousCode();
      return 0;
    } 
    boolean addedUnfinishedEntry = false;
    if (code == getTableSize()) {
      addRepeatOfPreviousCode();
      addedUnfinishedEntry = true;
    } else if (code > getTableSize()) {
      throw new IOException(String.format("Invalid %d bit code 0x%x", new Object[] { Integer.valueOf(getCodeSize()), Integer.valueOf(code) }));
    } 
    return expandCodeToOutputStack(code, addedUnfinishedEntry);
  }
  
  protected int readNextCode() throws IOException {
    int code = super.readNextCode();
    if (code >= 0)
      this.totalCodesRead++; 
    return code;
  }
  
  private void reAlignReading() {
    long codeReadsToThrowAway = 8L - this.totalCodesRead % 8L;
    if (codeReadsToThrowAway == 8L)
      codeReadsToThrowAway = 0L; 
    for (long i = 0L; i < codeReadsToThrowAway; i++)
      readNextCode(); 
    this.in.clearBitCache();
  }
}
