package org.apache.commons.compress.harmony.pack200;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.StringReader;
import java.io.UncheckedIOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import org.objectweb.asm.Label;

public class NewAttributeBands extends BandSet {
  protected List<AttributeLayoutElement> attributeLayoutElements;
  
  private int[] backwardsCallCounts;
  
  private final CpBands cpBands;
  
  private final AttributeDefinitionBands.AttributeDefinition def;
  
  private boolean usedAtLeastOnce;
  
  private Integral lastPIntegral;
  
  public NewAttributeBands(int effort, CpBands cpBands, SegmentHeader header, AttributeDefinitionBands.AttributeDefinition def) throws IOException {
    super(effort, header);
    this.def = def;
    this.cpBands = cpBands;
    parseLayout();
  }
  
  public void addAttribute(NewAttribute attribute) {
    this.usedAtLeastOnce = true;
    InputStream stream = new ByteArrayInputStream(attribute.getBytes());
    for (AttributeLayoutElement attributeLayoutElement : this.attributeLayoutElements)
      attributeLayoutElement.addAttributeToBand(attribute, stream); 
  }
  
  public String getAttributeName() { return this.def.name.getUnderlyingString(); }
  
  private BHSDCodec getCodec(String layoutElement) {
    if (layoutElement.indexOf('O') >= 0)
      return Codec.BRANCH5; 
    if (layoutElement.indexOf('P') >= 0)
      return Codec.BCI5; 
    if (layoutElement.indexOf('S') >= 0 && layoutElement.indexOf("KS") < 0 && layoutElement
      .indexOf("RS") < 0)
      return Codec.SIGNED5; 
    if (layoutElement.indexOf('B') >= 0)
      return Codec.BYTE1; 
    return Codec.UNSIGNED5;
  }
  
  public int getFlagIndex() { return this.def.index; }
  
  private StringReader getStreamUpToMatchingBracket(StringReader reader) throws IOException {
    StringBuilder sb = new StringBuilder();
    int foundBracket = -1;
    while (foundBracket != 0) {
      int read = reader.read();
      if (read == -1)
        break; 
      char c = (char)read;
      if (c == ']')
        foundBracket++; 
      if (c == '[')
        foundBracket--; 
      if (foundBracket != 0)
        sb.append(c); 
    } 
    return new StringReader(sb.toString());
  }
  
  public boolean isUsedAtLeastOnce() { return this.usedAtLeastOnce; }
  
  public int[] numBackwardsCalls() { return this.backwardsCallCounts; }
  
  public void pack(OutputStream outputStream) throws IOException, Pack200Exception {
    for (AttributeLayoutElement attributeLayoutElement : this.attributeLayoutElements)
      attributeLayoutElement.pack(outputStream); 
  }
  
  private void parseLayout() throws IOException {
    String layout = this.def.layout.getUnderlyingString();
    if (this.attributeLayoutElements == null) {
      this.attributeLayoutElements = new ArrayList();
      StringReader reader = new StringReader(layout);
      AttributeLayoutElement e;
      while ((e = readNextAttributeElement(reader)) != null)
        this.attributeLayoutElements.add(e); 
      resolveCalls();
    } 
  }
  
  private List<LayoutElement> readBody(StringReader reader) throws IOException {
    List<LayoutElement> layoutElements = new ArrayList<LayoutElement>();
    LayoutElement e;
    while ((e = readNextLayoutElement(reader)) != null)
      layoutElements.add(e); 
    return layoutElements;
  }
  
  private int readInteger(int i, InputStream inputStream) {
    int result = 0;
    for (int j = 0; j < i; j++) {
      try {
        result = result << 8 | inputStream.read();
      } catch (IOException e) {
        throw new UncheckedIOException("Error reading unknown attribute", e);
      } 
    } 
    if (i == 1)
      result = (byte)result; 
    if (i == 2)
      result = (short)result; 
    return result;
  }
  
  private AttributeLayoutElement readNextAttributeElement(StringReader reader) throws IOException {
    reader.mark(1);
    int next = reader.read();
    if (next == -1)
      return null; 
    if (next == 91)
      return new Callable(this, readBody(getStreamUpToMatchingBracket(reader))); 
    reader.reset();
    return readNextLayoutElement(reader);
  }
  
  private LayoutElement readNextLayoutElement(StringReader reader) throws IOException {
    char nxt;
    StringBuilder string;
    int number;
    char next;
    List<LayoutElement> body;
    UnionCase c;
    List<UnionCase> unionCases;
    String int_type, str;
    char uint_type;
    int nextChar = reader.read();
    if (nextChar == -1)
      return null; 
    switch (nextChar) {
      case 66:
      case 72:
      case 73:
      case 86:
        return new Integral(this, new String(new char[] { (char)nextChar }));
      case 70:
      case 83:
        return new Integral(this, new String(new char[] { (char)nextChar, (char)reader.read() }));
      case 80:
        reader.mark(1);
        if (reader.read() != 79) {
          reader.reset();
          this.lastPIntegral = new Integral(this, "P" + (char)reader.read());
          return this.lastPIntegral;
        } 
        this.lastPIntegral = new Integral(this, "PO" + (char)reader.read(), this.lastPIntegral);
        return this.lastPIntegral;
      case 79:
        reader.mark(1);
        if (reader.read() != 83) {
          reader.reset();
          return new Integral(this, "O" + (char)reader.read(), this.lastPIntegral);
        } 
        return new Integral(this, "OS" + (char)reader.read(), this.lastPIntegral);
      case 78:
        uint_type = (char)reader.read();
        reader.read();
        str = readUpToMatchingBracket(reader);
        return new Replication(this, "" + uint_type, str);
      case 84:
        int_type = String.valueOf((char)reader.read());
        if (int_type.equals("S"))
          int_type = int_type + (char)reader.read(); 
        unionCases = new ArrayList<UnionCase>();
        while ((c = readNextUnionCase(reader)) != null)
          unionCases.add(c); 
        reader.read();
        reader.read();
        reader.read();
        body = null;
        reader.mark(1);
        next = (char)reader.read();
        if (next != ']') {
          reader.reset();
          body = readBody(getStreamUpToMatchingBracket(reader));
        } 
        return new Union(this, int_type, unionCases, body);
      case 40:
        number = readNumber(reader).intValue();
        reader.read();
        return new Call(this, number);
      case 75:
      case 82:
        string = (new StringBuilder("")).append((char)nextChar).append((char)reader.read());
        nxt = (char)reader.read();
        string.append(nxt);
        if (nxt == 'N')
          string.append((char)reader.read()); 
        return new Reference(this, string.toString());
    } 
    return null;
  }
  
  private UnionCase readNextUnionCase(StringReader reader) throws IOException {
    Integer nextTag;
    reader.mark(2);
    reader.read();
    int next = reader.read();
    char ch = (char)next;
    if (ch == ')' || next == -1) {
      reader.reset();
      return null;
    } 
    reader.reset();
    reader.read();
    List<Integer> tags = new ArrayList<Integer>();
    do {
      nextTag = readNumber(reader);
      if (nextTag == null)
        continue; 
      tags.add(nextTag);
      reader.read();
    } while (nextTag != null);
    reader.read();
    reader.mark(1);
    ch = (char)reader.read();
    if (ch == ']')
      return new UnionCase(this, tags); 
    reader.reset();
    return new UnionCase(this, tags, readBody(getStreamUpToMatchingBracket(reader)));
  }
  
  private Integer readNumber(StringReader stream) throws IOException {
    stream.mark(1);
    char first = (char)stream.read();
    boolean negative = (first == '-');
    if (!negative)
      stream.reset(); 
    stream.mark(100);
    int length = 0;
    int i;
    while ((i = stream.read()) != -1 && Character.isDigit((char)i))
      length++; 
    stream.reset();
    if (length == 0)
      return null; 
    char[] digits = new char[length];
    int read = stream.read(digits);
    if (read != digits.length)
      throw new IOException("Error reading from the input stream"); 
    return Integer.valueOf(Integer.parseInt((negative ? "-" : "") + new String(digits)));
  }
  
  private String readUpToMatchingBracket(StringReader reader) throws IOException {
    StringBuilder sb = new StringBuilder();
    int foundBracket = -1;
    while (foundBracket != 0) {
      int read = reader.read();
      if (read == -1)
        break; 
      char c = (char)read;
      if (c == ']')
        foundBracket++; 
      if (c == '[')
        foundBracket--; 
      if (foundBracket != 0)
        sb.append(c); 
    } 
    return sb.toString();
  }
  
  public void renumberBci(IntList bciRenumbering, Map<Label, Integer> labelsToOffsets) {
    for (AttributeLayoutElement attributeLayoutElement : this.attributeLayoutElements)
      attributeLayoutElement.renumberBci(bciRenumbering, labelsToOffsets); 
  }
  
  private void resolveCalls() throws IOException {
    for (int i = 0; i < this.attributeLayoutElements.size(); i++) {
      AttributeLayoutElement element = (AttributeLayoutElement)this.attributeLayoutElements.get(i);
      if (element instanceof Callable) {
        Callable callable = (Callable)element;
        List<LayoutElement> body = Callable.access$500(callable);
        for (LayoutElement layoutElement : body)
          resolveCallsForElement(i, callable, layoutElement); 
      } 
    } 
    int backwardsCallableIndex = 0;
    for (AttributeLayoutElement attributeLayoutElement : this.attributeLayoutElements) {
      if (attributeLayoutElement instanceof Callable) {
        Callable callable = (Callable)attributeLayoutElement;
        if (Callable.access$600(callable)) {
          callable.setBackwardsCallableIndex(backwardsCallableIndex);
          backwardsCallableIndex++;
        } 
      } 
    } 
    this.backwardsCallCounts = new int[backwardsCallableIndex];
  }
  
  private void resolveCallsForElement(int i, Callable currentCallable, LayoutElement layoutElement) {
    if (layoutElement instanceof Call) {
      Call call = (Call)layoutElement;
      int index = Call.access$700(call);
      if (index == 0) {
        call.setCallable(currentCallable);
      } else if (index > 0) {
        for (int k = i + 1; k < this.attributeLayoutElements.size(); k++) {
          AttributeLayoutElement el = (AttributeLayoutElement)this.attributeLayoutElements.get(k);
          index--;
          if (el instanceof Callable && index == 0) {
            call.setCallable((Callable)el);
            break;
          } 
        } 
      } else {
        for (int k = i - 1; k >= 0; k--) {
          AttributeLayoutElement el = (AttributeLayoutElement)this.attributeLayoutElements.get(k);
          index++;
          if (el instanceof Callable && index == 0) {
            call.setCallable((Callable)el);
            break;
          } 
        } 
      } 
    } else if (layoutElement instanceof Replication) {
      List<LayoutElement> children = Replication.access$800((Replication)layoutElement);
      for (LayoutElement child : children)
        resolveCallsForElement(i, currentCallable, child); 
    } 
  }
}
