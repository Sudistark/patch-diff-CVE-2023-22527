package org.apache.commons.compress.harmony.unpack200;

import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;
import org.apache.commons.compress.harmony.pack200.BHSDCodec;
import org.apache.commons.compress.harmony.pack200.Codec;
import org.apache.commons.compress.harmony.pack200.Pack200Exception;
import org.apache.commons.compress.harmony.unpack200.bytecode.Attribute;
import org.apache.commons.compress.harmony.unpack200.bytecode.NewAttribute;

public class NewAttributeBands extends BandSet {
  private final AttributeLayout attributeLayout;
  
  private int backwardsCallCount;
  
  protected List<AttributeLayoutElement> attributeLayoutElements;
  
  public NewAttributeBands(Segment segment, AttributeLayout attributeLayout) throws IOException {
    super(segment);
    this.attributeLayout = attributeLayout;
    parseLayout();
    attributeLayout.setBackwardsCallCount(this.backwardsCallCount);
  }
  
  public int getBackwardsCallCount() { return this.backwardsCallCount; }
  
  public BHSDCodec getCodec(String layoutElement) {
    if (layoutElement.indexOf('O') >= 0)
      return Codec.BRANCH5; 
    if (layoutElement.indexOf('P') >= 0)
      return Codec.BCI5; 
    if (layoutElement.indexOf('S') >= 0 && layoutElement.indexOf("KS") < 0 && layoutElement
      .indexOf("RS") < 0)
      return Codec.SIGNED5; 
    if (layoutElement.indexOf('B') >= 0)
      return Codec.BYTE1; 
    return Codec.UNSIGNED5;
  }
  
  private Attribute getOneAttribute(int index, List<AttributeLayoutElement> elements) {
    NewAttribute attribute = new NewAttribute(this.segment.getCpBands().cpUTF8Value(this.attributeLayout.getName()), this.attributeLayout.getIndex());
    for (AttributeLayoutElement element : elements)
      element.addToAttribute(index, attribute); 
    return attribute;
  }
  
  private StringReader getStreamUpToMatchingBracket(StringReader stream) throws IOException {
    StringBuilder sb = new StringBuilder();
    int foundBracket = -1;
    while (foundBracket != 0) {
      int read = stream.read();
      if (read == -1)
        break; 
      char c = (char)read;
      if (c == ']')
        foundBracket++; 
      if (c == '[')
        foundBracket--; 
      if (foundBracket != 0)
        sb.append(c); 
    } 
    return new StringReader(sb.toString());
  }
  
  public List<Attribute> parseAttributes(InputStream in, int occurrenceCount) throws IOException, Pack200Exception {
    for (AttributeLayoutElement element : this.attributeLayoutElements)
      element.readBands(in, occurrenceCount); 
    List<Attribute> attributes = new ArrayList<Attribute>(occurrenceCount);
    for (int i = 0; i < occurrenceCount; i++)
      attributes.add(getOneAttribute(i, this.attributeLayoutElements)); 
    return attributes;
  }
  
  private void parseLayout() throws IOException {
    if (this.attributeLayoutElements == null) {
      this.attributeLayoutElements = new ArrayList();
      StringReader stream = new StringReader(this.attributeLayout.getLayout());
      AttributeLayoutElement e;
      while ((e = readNextAttributeElement(stream)) != null)
        this.attributeLayoutElements.add(e); 
      resolveCalls();
    } 
  }
  
  public void read(InputStream in) throws IOException, Pack200Exception {}
  
  private List<LayoutElement> readBody(StringReader stream) throws IOException {
    List<LayoutElement> layoutElements = new ArrayList<LayoutElement>();
    LayoutElement e;
    while ((e = readNextLayoutElement(stream)) != null)
      layoutElements.add(e); 
    return layoutElements;
  }
  
  private AttributeLayoutElement readNextAttributeElement(StringReader stream) throws IOException {
    stream.mark(1);
    int next = stream.read();
    if (next == -1)
      return null; 
    if (next == 91)
      return new Callable(readBody(getStreamUpToMatchingBracket(stream))); 
    stream.reset();
    return readNextLayoutElement(stream);
  }
  
  private LayoutElement readNextLayoutElement(StringReader stream) throws IOException {
    char nxt;
    StringBuilder string;
    int number;
    char next;
    List<LayoutElement> body;
    UnionCase c;
    List<UnionCase> unionCases;
    String intType, str;
    char uintType;
    int nextChar = stream.read();
    if (nextChar == -1)
      return null; 
    switch (nextChar) {
      case 66:
      case 72:
      case 73:
      case 86:
        return new Integral(this, new String(new char[] { (char)nextChar }));
      case 70:
      case 83:
        return new Integral(this, new String(new char[] { (char)nextChar, (char)stream.read() }));
      case 80:
        stream.mark(1);
        if (stream.read() != 79) {
          stream.reset();
          return new Integral(this, "P" + (char)stream.read());
        } 
        return new Integral(this, "PO" + (char)stream.read());
      case 79:
        stream.mark(1);
        if (stream.read() != 83) {
          stream.reset();
          return new Integral(this, "O" + (char)stream.read());
        } 
        return new Integral(this, "OS" + (char)stream.read());
      case 78:
        uintType = (char)stream.read();
        stream.read();
        str = readUpToMatchingBracket(stream);
        return new Replication(this, "" + uintType, str);
      case 84:
        intType = "" + (char)stream.read();
        if (intType.equals("S"))
          intType = intType + (char)stream.read(); 
        unionCases = new ArrayList<UnionCase>();
        while ((c = readNextUnionCase(stream)) != null)
          unionCases.add(c); 
        stream.read();
        stream.read();
        stream.read();
        body = null;
        stream.mark(1);
        next = (char)stream.read();
        if (next != ']') {
          stream.reset();
          body = readBody(getStreamUpToMatchingBracket(stream));
        } 
        return new Union(this, intType, unionCases, body);
      case 40:
        number = readNumber(stream).intValue();
        stream.read();
        return new Call(this, number);
      case 75:
      case 82:
        string = (new StringBuilder("")).append((char)nextChar).append((char)stream.read());
        nxt = (char)stream.read();
        string.append(nxt);
        if (nxt == 'N')
          string.append((char)stream.read()); 
        return new Reference(this, string.toString());
    } 
    return null;
  }
  
  private UnionCase readNextUnionCase(StringReader stream) throws IOException {
    Integer nextTag;
    stream.mark(2);
    stream.read();
    int next = stream.read();
    char ch = (char)next;
    if (ch == ')' || next == -1) {
      stream.reset();
      return null;
    } 
    stream.reset();
    stream.read();
    List<Integer> tags = new ArrayList<Integer>();
    do {
      nextTag = readNumber(stream);
      if (nextTag == null)
        continue; 
      tags.add(nextTag);
      stream.read();
    } while (nextTag != null);
    stream.read();
    stream.mark(1);
    ch = (char)stream.read();
    if (ch == ']')
      return new UnionCase(this, tags); 
    stream.reset();
    return new UnionCase(this, tags, readBody(getStreamUpToMatchingBracket(stream)));
  }
  
  private Integer readNumber(StringReader stream) throws IOException {
    stream.mark(1);
    char first = (char)stream.read();
    boolean negative = (first == '-');
    if (!negative)
      stream.reset(); 
    stream.mark(100);
    int length = 0;
    int i;
    while ((i = stream.read()) != -1 && Character.isDigit((char)i))
      length++; 
    stream.reset();
    if (length == 0)
      return null; 
    char[] digits = new char[length];
    int read = stream.read(digits);
    if (read != digits.length)
      throw new IOException("Error reading from the input stream"); 
    return Integer.valueOf(Integer.parseInt((negative ? "-" : "") + new String(digits)));
  }
  
  private String readUpToMatchingBracket(StringReader stream) throws IOException {
    StringBuilder sb = new StringBuilder();
    int foundBracket = -1;
    while (foundBracket != 0) {
      int read = stream.read();
      if (read == -1)
        break; 
      char c = (char)read;
      if (c == ']')
        foundBracket++; 
      if (c == '[')
        foundBracket--; 
      if (foundBracket != 0)
        sb.append(c); 
    } 
    return sb.toString();
  }
  
  private void resolveCalls() throws IOException {
    int backwardsCalls = 0;
    for (int i = 0; i < this.attributeLayoutElements.size(); i++) {
      AttributeLayoutElement element = (AttributeLayoutElement)this.attributeLayoutElements.get(i);
      if (element instanceof Callable) {
        Callable callable = (Callable)element;
        if (i == 0)
          callable.setFirstCallable(true); 
        for (LayoutElement layoutElement : Callable.access$400(callable))
          backwardsCalls += resolveCallsForElement(i, callable, layoutElement); 
      } 
    } 
    this.backwardsCallCount = backwardsCalls;
  }
  
  private int resolveCallsForElement(int i, Callable currentCallable, LayoutElement layoutElement) {
    int backwardsCalls = 0;
    if (layoutElement instanceof Call) {
      Call call = (Call)layoutElement;
      int index = Call.access$500(call);
      if (index == 0) {
        backwardsCalls++;
        call.setCallable(currentCallable);
      } else if (index > 0) {
        for (int k = i + 1; k < this.attributeLayoutElements.size(); k++) {
          AttributeLayoutElement el = (AttributeLayoutElement)this.attributeLayoutElements.get(k);
          index--;
          if (el instanceof Callable && index == 0) {
            call.setCallable((Callable)el);
            break;
          } 
        } 
      } else {
        backwardsCalls++;
        for (int k = i - 1; k >= 0; k--) {
          AttributeLayoutElement el = (AttributeLayoutElement)this.attributeLayoutElements.get(k);
          index++;
          if (el instanceof Callable && index == 0) {
            call.setCallable((Callable)el);
            break;
          } 
        } 
      } 
    } else if (layoutElement instanceof Replication) {
      List<LayoutElement> children = Replication.access$600((Replication)layoutElement);
      for (LayoutElement child : children)
        backwardsCalls += resolveCallsForElement(i, currentCallable, child); 
    } 
    return backwardsCalls;
  }
  
  public void setBackwardsCalls(int[] backwardsCalls) throws IOException {
    int index = 0;
    parseLayout();
    for (AttributeLayoutElement element : this.attributeLayoutElements) {
      if (element instanceof Callable && ((Callable)element).isBackwardsCallable()) {
        ((Callable)element).addCount(backwardsCalls[index]);
        index++;
      } 
    } 
  }
  
  public void unpack() throws IOException {}
}
