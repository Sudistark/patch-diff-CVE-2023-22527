package org.apache.commons.compress.archivers;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.AccessController;
import java.util.Collections;
import java.util.Locale;
import java.util.ServiceLoader;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;
import org.apache.commons.compress.archivers.ar.ArArchiveInputStream;
import org.apache.commons.compress.archivers.ar.ArArchiveOutputStream;
import org.apache.commons.compress.archivers.arj.ArjArchiveInputStream;
import org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;
import org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream;
import org.apache.commons.compress.archivers.dump.DumpArchiveInputStream;
import org.apache.commons.compress.archivers.jar.JarArchiveInputStream;
import org.apache.commons.compress.archivers.jar.JarArchiveOutputStream;
import org.apache.commons.compress.archivers.sevenz.SevenZFile;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;
import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;
import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;
import org.apache.commons.compress.utils.IOUtils;
import org.apache.commons.compress.utils.Sets;

public class ArchiveStreamFactory implements ArchiveStreamProvider {
  private static final int TAR_HEADER_SIZE = 512;
  
  private static final int DUMP_SIGNATURE_SIZE = 32;
  
  private static final int SIGNATURE_SIZE = 12;
  
  public static final ArchiveStreamFactory DEFAULT = new ArchiveStreamFactory();
  
  public static final String APK = "apk";
  
  public static final String XAPK = "xapk";
  
  public static final String APKS = "apks";
  
  public static final String APKM = "apkm";
  
  public static final String AR = "ar";
  
  public static final String ARJ = "arj";
  
  public static final String CPIO = "cpio";
  
  public static final String DUMP = "dump";
  
  public static final String JAR = "jar";
  
  public static final String TAR = "tar";
  
  public static final String ZIP = "zip";
  
  public static final String SEVEN_Z = "7z";
  
  private final String encoding;
  
  private SortedMap<String, ArchiveStreamProvider> archiveInputStreamProviders;
  
  private SortedMap<String, ArchiveStreamProvider> archiveOutputStreamProviders;
  
  private static Iterable<ArchiveStreamProvider> archiveStreamProviderIterable() { return ServiceLoader.load(ArchiveStreamProvider.class, ClassLoader.getSystemClassLoader()); }
  
  public static String detect(InputStream in) throws ArchiveException {
    if (in == null)
      throw new IllegalArgumentException("Stream must not be null."); 
    if (!in.markSupported())
      throw new IllegalArgumentException("Mark is not supported."); 
    byte[] signature = new byte[12];
    in.mark(signature.length);
    int signatureLength = -1;
    try {
      signatureLength = IOUtils.readFully(in, signature);
      in.reset();
    } catch (IOException e) {
      throw new ArchiveException("IOException while reading signature.", e);
    } 
    if (ZipArchiveInputStream.matches(signature, signatureLength))
      return "zip"; 
    if (JarArchiveInputStream.matches(signature, signatureLength))
      return "jar"; 
    if (ArArchiveInputStream.matches(signature, signatureLength))
      return "ar"; 
    if (CpioArchiveInputStream.matches(signature, signatureLength))
      return "cpio"; 
    if (ArjArchiveInputStream.matches(signature, signatureLength))
      return "arj"; 
    if (SevenZFile.matches(signature, signatureLength))
      return "7z"; 
    byte[] dumpsig = new byte[32];
    in.mark(dumpsig.length);
    try {
      signatureLength = IOUtils.readFully(in, dumpsig);
      in.reset();
    } catch (IOException e) {
      throw new ArchiveException("IOException while reading dump signature", e);
    } 
    if (DumpArchiveInputStream.matches(dumpsig, signatureLength))
      return "dump"; 
    byte[] tarHeader = new byte[512];
    in.mark(tarHeader.length);
    try {
      signatureLength = IOUtils.readFully(in, tarHeader);
      in.reset();
    } catch (IOException e) {
      throw new ArchiveException("IOException while reading tar signature", e);
    } 
    if (TarArchiveInputStream.matches(tarHeader, signatureLength))
      return "tar"; 
    if (signatureLength >= 512)
      try {
        TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarHeader));
        try {
          if (tais.getNextTarEntry().isCheckSumOK()) {
            String str = "tar";
            tais.close();
            return str;
          } 
          tais.close();
        } catch (Throwable throwable) {
          try {
            tais.close();
          } catch (Throwable throwable1) {
            throwable.addSuppressed(throwable1);
          } 
          throw throwable;
        } 
      } catch (Exception exception) {} 
    throw new ArchiveException("No Archiver found for the stream signature");
  }
  
  public static SortedMap<String, ArchiveStreamProvider> findAvailableArchiveInputStreamProviders() {
    return (SortedMap)AccessController.doPrivileged(() -> {
          map = new TreeMap();
          putAll(DEFAULT.getInputStreamArchiveNames(), DEFAULT, map);
          archiveStreamProviderIterable().forEach(());
          return map;
        });
  }
  
  public static SortedMap<String, ArchiveStreamProvider> findAvailableArchiveOutputStreamProviders() {
    return (SortedMap)AccessController.doPrivileged(() -> {
          map = new TreeMap();
          putAll(DEFAULT.getOutputStreamArchiveNames(), DEFAULT, map);
          archiveStreamProviderIterable().forEach(());
          return map;
        });
  }
  
  static void putAll(Set<String> names, ArchiveStreamProvider provider, TreeMap<String, ArchiveStreamProvider> map) { names.forEach(name -> map.put(toKey(name), provider)); }
  
  private static String toKey(String name) { return name.toUpperCase(Locale.ROOT); }
  
  public ArchiveStreamFactory() { this(null); }
  
  public ArchiveStreamFactory(String encoding) {
    this.encoding = encoding;
    this.entryEncoding = encoding;
  }
  
  public ArchiveInputStream createArchiveInputStream(InputStream in) throws ArchiveException { return createArchiveInputStream(detect(in), in); }
  
  public ArchiveInputStream createArchiveInputStream(String archiverName, InputStream in) throws ArchiveException { return createArchiveInputStream(archiverName, in, this.entryEncoding); }
  
  public ArchiveInputStream createArchiveInputStream(String archiverName, InputStream in, String actualEncoding) throws ArchiveException {
    if (archiverName == null)
      throw new IllegalArgumentException("Archivername must not be null."); 
    if (in == null)
      throw new IllegalArgumentException("InputStream must not be null."); 
    if ("ar".equalsIgnoreCase(archiverName))
      return new ArArchiveInputStream(in); 
    if ("arj".equalsIgnoreCase(archiverName)) {
      if (actualEncoding != null)
        return new ArjArchiveInputStream(in, actualEncoding); 
      return new ArjArchiveInputStream(in);
    } 
    if ("zip".equalsIgnoreCase(archiverName)) {
      if (actualEncoding != null)
        return new ZipArchiveInputStream(in, actualEncoding); 
      return new ZipArchiveInputStream(in);
    } 
    if ("tar".equalsIgnoreCase(archiverName)) {
      if (actualEncoding != null)
        return new TarArchiveInputStream(in, actualEncoding); 
      return new TarArchiveInputStream(in);
    } 
    if ("jar".equalsIgnoreCase(archiverName) || "apk".equalsIgnoreCase(archiverName)) {
      if (actualEncoding != null)
        return new JarArchiveInputStream(in, actualEncoding); 
      return new JarArchiveInputStream(in);
    } 
    if ("cpio".equalsIgnoreCase(archiverName)) {
      if (actualEncoding != null)
        return new CpioArchiveInputStream(in, actualEncoding); 
      return new CpioArchiveInputStream(in);
    } 
    if ("dump".equalsIgnoreCase(archiverName)) {
      if (actualEncoding != null)
        return new DumpArchiveInputStream(in, actualEncoding); 
      return new DumpArchiveInputStream(in);
    } 
    if ("7z".equalsIgnoreCase(archiverName))
      throw new StreamingNotSupportedException("7z"); 
    ArchiveStreamProvider archiveStreamProvider = (ArchiveStreamProvider)getArchiveInputStreamProviders().get(toKey(archiverName));
    if (archiveStreamProvider != null)
      return archiveStreamProvider.createArchiveInputStream(archiverName, in, actualEncoding); 
    throw new ArchiveException("Archiver: " + archiverName + " not found.");
  }
  
  public ArchiveOutputStream createArchiveOutputStream(String archiverName, OutputStream out) throws ArchiveException { return createArchiveOutputStream(archiverName, out, this.entryEncoding); }
  
  public ArchiveOutputStream createArchiveOutputStream(String archiverName, OutputStream out, String actualEncoding) throws ArchiveException {
    if (archiverName == null)
      throw new IllegalArgumentException("Archivername must not be null."); 
    if (out == null)
      throw new IllegalArgumentException("OutputStream must not be null."); 
    if ("ar".equalsIgnoreCase(archiverName))
      return new ArArchiveOutputStream(out); 
    if ("zip".equalsIgnoreCase(archiverName)) {
      ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);
      if (actualEncoding != null)
        zip.setEncoding(actualEncoding); 
      return zip;
    } 
    if ("tar".equalsIgnoreCase(archiverName)) {
      if (actualEncoding != null)
        return new TarArchiveOutputStream(out, actualEncoding); 
      return new TarArchiveOutputStream(out);
    } 
    if ("jar".equalsIgnoreCase(archiverName)) {
      if (actualEncoding != null)
        return new JarArchiveOutputStream(out, actualEncoding); 
      return new JarArchiveOutputStream(out);
    } 
    if ("cpio".equalsIgnoreCase(archiverName)) {
      if (actualEncoding != null)
        return new CpioArchiveOutputStream(out, actualEncoding); 
      return new CpioArchiveOutputStream(out);
    } 
    if ("7z".equalsIgnoreCase(archiverName))
      throw new StreamingNotSupportedException("7z"); 
    ArchiveStreamProvider archiveStreamProvider = (ArchiveStreamProvider)getArchiveOutputStreamProviders().get(toKey(archiverName));
    if (archiveStreamProvider != null)
      return archiveStreamProvider.createArchiveOutputStream(archiverName, out, actualEncoding); 
    throw new ArchiveException("Archiver: " + archiverName + " not found.");
  }
  
  public SortedMap<String, ArchiveStreamProvider> getArchiveInputStreamProviders() {
    if (this.archiveInputStreamProviders == null)
      this
        .archiveInputStreamProviders = Collections.unmodifiableSortedMap(findAvailableArchiveInputStreamProviders()); 
    return this.archiveInputStreamProviders;
  }
  
  public SortedMap<String, ArchiveStreamProvider> getArchiveOutputStreamProviders() {
    if (this.archiveOutputStreamProviders == null)
      this
        .archiveOutputStreamProviders = Collections.unmodifiableSortedMap(findAvailableArchiveOutputStreamProviders()); 
    return this.archiveOutputStreamProviders;
  }
  
  public String getEntryEncoding() { return this.entryEncoding; }
  
  public Set<String> getInputStreamArchiveNames() { return Sets.newHashSet(new String[] { "ar", "arj", "zip", "tar", "jar", "cpio", "dump", "7z" }); }
  
  public Set<String> getOutputStreamArchiveNames() { return Sets.newHashSet(new String[] { "ar", "zip", "tar", "jar", "cpio", "7z" }); }
  
  @Deprecated
  public void setEntryEncoding(String entryEncoding) {
    if (this.encoding != null)
      throw new IllegalStateException("Cannot overide encoding set by the constructor"); 
    this.entryEncoding = entryEncoding;
  }
}
