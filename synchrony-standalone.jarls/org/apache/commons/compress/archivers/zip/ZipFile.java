package org.apache.commons.compress.archivers.zip;

import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.Closeable;
import java.io.EOFException;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.SequenceInputStream;
import java.nio.ByteBuffer;
import java.nio.channels.SeekableByteChannel;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.zip.Inflater;
import java.util.zip.ZipException;
import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;
import org.apache.commons.compress.compressors.deflate64.Deflate64CompressorInputStream;
import org.apache.commons.compress.utils.BoundedArchiveInputStream;
import org.apache.commons.compress.utils.BoundedSeekableByteChannelInputStream;
import org.apache.commons.compress.utils.IOUtils;

public class ZipFile implements Closeable {
  private static final int HASH_SIZE = 509;
  
  static final int NIBLET_MASK = 15;
  
  static final int BYTE_SHIFT = 8;
  
  private static final int POS_0 = 0;
  
  private static final int POS_1 = 1;
  
  private static final int POS_2 = 2;
  
  private static final int POS_3 = 3;
  
  private static final byte[] ONE_ZERO_BYTE = new byte[1];
  
  private static final int CFH_LEN = 42;
  
  private static final long CFH_SIG = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG);
  
  static final int MIN_EOCD_SIZE = 22;
  
  private static final int MAX_EOCD_SIZE = 65557;
  
  private static final int CFD_LENGTH_OFFSET = 12;
  
  private static final int CFD_DISK_OFFSET = 6;
  
  private static final int CFD_LOCATOR_RELATIVE_OFFSET = 8;
  
  private static final int ZIP64_EOCDL_LENGTH = 20;
  
  private static final int ZIP64_EOCDL_LOCATOR_OFFSET = 8;
  
  private static final int ZIP64_EOCD_CFD_LOCATOR_OFFSET = 48;
  
  private static final int ZIP64_EOCD_CFD_DISK_OFFSET = 20;
  
  private static final int ZIP64_EOCD_CFD_LOCATOR_RELATIVE_OFFSET = 24;
  
  private static final long LFH_OFFSET_FOR_FILENAME_LENGTH = 26L;
  
  private static final Comparator<ZipArchiveEntry> offsetComparator = Comparator.comparingLong(ZipArchiveEntry::getDiskNumberStart)
    .thenComparingLong(ZipArchiveEntry::getLocalHeaderOffset);
  
  private final List<ZipArchiveEntry> entries;
  
  private final Map<String, LinkedList<ZipArchiveEntry>> nameMap;
  
  private final String encoding;
  
  private final ZipEncoding zipEncoding;
  
  private final String archiveName;
  
  private final SeekableByteChannel archive;
  
  private final boolean useUnicodeExtraFields;
  
  private final boolean isSplitZipArchive;
  
  private final byte[] dwordBuf;
  
  private final byte[] wordBuf;
  
  private final byte[] cfhBuf;
  
  private final byte[] shortBuf;
  
  private final ByteBuffer dwordBbuf;
  
  private final ByteBuffer wordBbuf;
  
  private final ByteBuffer cfhBbuf;
  
  private final ByteBuffer shortBbuf;
  
  private long centralDirectoryStartDiskNumber;
  
  private long centralDirectoryStartRelativeOffset;
  
  private long centralDirectoryStartOffset;
  
  private long firstLocalFileHeaderOffset;
  
  public static void closeQuietly(ZipFile zipFile) { IOUtils.closeQuietly(zipFile); }
  
  public ZipFile(File f) throws IOException { this(f, "UTF8"); }
  
  public ZipFile(File f, String encoding) throws IOException { this(f.toPath(), encoding, true); }
  
  public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { this(f.toPath(), encoding, useUnicodeExtraFields, false); }
  
  public ZipFile(File f, String encoding, boolean useUnicodeExtraFields, boolean ignoreLocalFileHeader) throws IOException {
    this(Files.newByteChannel(f.toPath(), EnumSet.of(StandardOpenOption.READ), new java.nio.file.attribute.FileAttribute[0]), f
        .getAbsolutePath(), encoding, useUnicodeExtraFields, true, ignoreLocalFileHeader);
  }
  
  public ZipFile(Path path) throws IOException { this(path, "UTF8"); }
  
  public ZipFile(Path path, String encoding) throws IOException { this(path, encoding, true); }
  
  public ZipFile(Path path, String encoding, boolean useUnicodeExtraFields) throws IOException { this(path, encoding, useUnicodeExtraFields, false); }
  
  public ZipFile(Path path, String encoding, boolean useUnicodeExtraFields, boolean ignoreLocalFileHeader) throws IOException {
    this(Files.newByteChannel(path, EnumSet.of(StandardOpenOption.READ), new java.nio.file.attribute.FileAttribute[0]), path
        .toAbsolutePath().toString(), encoding, useUnicodeExtraFields, true, ignoreLocalFileHeader);
  }
  
  public ZipFile(SeekableByteChannel channel) throws IOException { this(channel, "unknown archive", "UTF8", true); }
  
  public ZipFile(SeekableByteChannel channel, String encoding) throws IOException { this(channel, "unknown archive", encoding, true); }
  
  public ZipFile(SeekableByteChannel channel, String archiveName, String encoding, boolean useUnicodeExtraFields) throws IOException { this(channel, archiveName, encoding, useUnicodeExtraFields, false, false); }
  
  public ZipFile(SeekableByteChannel channel, String archiveName, String encoding, boolean useUnicodeExtraFields, boolean ignoreLocalFileHeader) throws IOException { this(channel, archiveName, encoding, useUnicodeExtraFields, false, ignoreLocalFileHeader); }
  
  private ZipFile(SeekableByteChannel channel, String archiveName, String encoding, boolean useUnicodeExtraFields, boolean closeOnError, boolean ignoreLocalFileHeader) throws IOException {
    this.entries = new LinkedList();
    this.nameMap = new HashMap(509);
    this.closed = true;
    this.dwordBuf = new byte[8];
    this.wordBuf = new byte[4];
    this.cfhBuf = new byte[42];
    this.shortBuf = new byte[2];
    this.dwordBbuf = ByteBuffer.wrap(this.dwordBuf);
    this.wordBbuf = ByteBuffer.wrap(this.wordBuf);
    this.cfhBbuf = ByteBuffer.wrap(this.cfhBuf);
    this.shortBbuf = ByteBuffer.wrap(this.shortBuf);
    this.isSplitZipArchive = channel instanceof ZipSplitReadOnlySeekableByteChannel;
    this.archiveName = archiveName;
    this.encoding = encoding;
    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);
    this.useUnicodeExtraFields = useUnicodeExtraFields;
    this.archive = channel;
    success = false;
    try {
      Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag = populateFromCentralDirectory();
      if (!ignoreLocalFileHeader)
        resolveLocalFileHeaderData(entriesWithoutUTF8Flag); 
      fillNameMap();
      success = true;
    } catch (IOException e) {
      throw new IOException("Error on ZipFile " + archiveName, e);
    } finally {
      this.closed = !success;
      if (!success && closeOnError)
        IOUtils.closeQuietly(this.archive); 
    } 
  }
  
  public ZipFile(String name) throws IOException { this((new File(name)).toPath(), "UTF8"); }
  
  public ZipFile(String name, String encoding) throws IOException { this((new File(name)).toPath(), encoding, true); }
  
  public boolean canReadEntryData(ZipArchiveEntry ze) { return ZipUtil.canHandleEntryData(ze); }
  
  public void close() throws IOException {
    this.closed = true;
    this.archive.close();
  }
  
  public void copyRawEntries(ZipArchiveOutputStream target, ZipArchiveEntryPredicate predicate) throws IOException {
    Enumeration<ZipArchiveEntry> src = getEntriesInPhysicalOrder();
    while (src.hasMoreElements()) {
      ZipArchiveEntry entry = (ZipArchiveEntry)src.nextElement();
      if (predicate.test(entry))
        target.addRawArchiveEntry(entry, getRawInputStream(entry)); 
    } 
  }
  
  private BoundedArchiveInputStream createBoundedInputStream(long start, long remaining) {
    if (start < 0L || remaining < 0L || start + remaining < start)
      throw new IllegalArgumentException("Corrupted archive, stream boundaries are out of range"); 
    return (this.archive instanceof java.nio.channels.FileChannel) ? 
      new BoundedFileChannelInputStream(this, start, remaining) : 
      new BoundedSeekableByteChannelInputStream(start, remaining, this.archive);
  }
  
  private void fillNameMap() throws IOException {
    this.entries.forEach(ze -> {
          String name = ze.getName();
          LinkedList<ZipArchiveEntry> entriesOfThatName = (LinkedList)this.nameMap.computeIfAbsent(name, ());
          entriesOfThatName.addLast(ze);
        });
  }
  
  protected void finalize() throws IOException {
    try {
      if (!this.closed)
        close(); 
    } finally {
      super.finalize();
    } 
  }
  
  public InputStream getContentBeforeFirstLocalFileHeader() {
    return (this.firstLocalFileHeaderOffset == 0L) ? 
      null : createBoundedInputStream(0L, this.firstLocalFileHeaderOffset);
  }
  
  private long getDataOffset(ZipArchiveEntry ze) throws IOException {
    long s = ze.getDataOffset();
    if (s == -1L) {
      setDataOffset(ze);
      return ze.getDataOffset();
    } 
    return s;
  }
  
  public String getEncoding() { return this.encoding; }
  
  public Enumeration<ZipArchiveEntry> getEntries() { return Collections.enumeration(this.entries); }
  
  public Iterable<ZipArchiveEntry> getEntries(String name) { return (Iterable)this.nameMap.getOrDefault(name, ZipArchiveEntry.EMPTY_LINKED_LIST); }
  
  public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder() {
    ZipArchiveEntry[] allEntries = (ZipArchiveEntry[])this.entries.toArray(ZipArchiveEntry.EMPTY_ARRAY);
    Arrays.sort(allEntries, offsetComparator);
    return Collections.enumeration(Arrays.asList(allEntries));
  }
  
  public Iterable<ZipArchiveEntry> getEntriesInPhysicalOrder(String name) {
    ZipArchiveEntry[] entriesOfThatName = ZipArchiveEntry.EMPTY_ARRAY;
    LinkedList<ZipArchiveEntry> linkedList = (LinkedList)this.nameMap.get(name);
    if (linkedList != null) {
      entriesOfThatName = (ZipArchiveEntry[])linkedList.toArray(entriesOfThatName);
      Arrays.sort(entriesOfThatName, offsetComparator);
    } 
    return Arrays.asList(entriesOfThatName);
  }
  
  public ZipArchiveEntry getEntry(String name) {
    LinkedList<ZipArchiveEntry> entriesOfThatName = (LinkedList)this.nameMap.get(name);
    return (entriesOfThatName != null) ? (ZipArchiveEntry)entriesOfThatName.getFirst() : null;
  }
  
  public long getFirstLocalFileHeaderOffset() { return this.firstLocalFileHeaderOffset; }
  
  public InputStream getInputStream(ZipArchiveEntry zipEntry) throws IOException {
    Inflater inflater;
    if (!(zipEntry instanceof Entry))
      return null; 
    ZipUtil.checkRequestedFeatures(zipEntry);
    InputStream is = new BufferedInputStream(getRawInputStream(zipEntry));
    switch (null.$SwitchMap$org$apache$commons$compress$archivers$zip$ZipMethod[ZipMethod.getMethodByCode(zipEntry.getMethod()).ordinal()]) {
      case 1:
        return new StoredStatisticsStream(is);
      case 2:
        return new UnshrinkingInputStream(is);
      case 3:
        try {
          return new ExplodingInputStream(zipEntry.getGeneralPurposeBit().getSlidingDictionarySize(), zipEntry
              .getGeneralPurposeBit().getNumberOfShannonFanoTrees(), is);
        } catch (IllegalArgumentException ex) {
          throw new IOException("bad IMPLODE data", ex);
        } 
      case 4:
        inflater = new Inflater(true);
        return new Object(this, new SequenceInputStream(is, new ByteArrayInputStream(ONE_ZERO_BYTE)), inflater, inflater);
      case 5:
        return new BZip2CompressorInputStream(is);
      case 6:
        return new Deflate64CompressorInputStream(is);
    } 
    throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(zipEntry.getMethod()), zipEntry);
  }
  
  public InputStream getRawInputStream(ZipArchiveEntry ze) throws IOException {
    if (!(ze instanceof Entry))
      return null; 
    long start = getDataOffset(ze);
    if (start == -1L)
      return null; 
    return createBoundedInputStream(start, ze.getCompressedSize());
  }
  
  public String getUnixSymlink(ZipArchiveEntry entry) throws IOException {
    if (entry != null && entry.isUnixSymlink()) {
      InputStream in = getInputStream(entry);
      try {
        String str = this.zipEncoding.decode(IOUtils.toByteArray(in));
        if (in != null)
          in.close(); 
        return str;
      } catch (Throwable throwable) {
        if (in != null)
          try {
            in.close();
          } catch (Throwable throwable1) {
            throwable.addSuppressed(throwable1);
          }  
        throw throwable;
      } 
    } 
    return null;
  }
  
  private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory() throws IOException {
    HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag = new HashMap<ZipArchiveEntry, NameAndComment>();
    positionAtCentralDirectory();
    this.centralDirectoryStartOffset = this.archive.position();
    this.wordBbuf.rewind();
    IOUtils.readFully(this.archive, this.wordBbuf);
    long sig = ZipLong.getValue(this.wordBuf);
    if (sig != CFH_SIG && startsWithLocalFileHeader())
      throw new IOException("Central directory is empty, can't expand corrupt archive."); 
    while (sig == CFH_SIG) {
      readCentralDirectoryEntry(noUTF8Flag);
      this.wordBbuf.rewind();
      IOUtils.readFully(this.archive, this.wordBbuf);
      sig = ZipLong.getValue(this.wordBuf);
    } 
    return noUTF8Flag;
  }
  
  private void positionAtCentralDirectory() throws IOException {
    positionAtEndOfCentralDirectoryRecord();
    boolean found = false;
    boolean searchedForZip64EOCD = (this.archive.position() > 20L);
    if (searchedForZip64EOCD) {
      this.archive.position(this.archive.position() - 20L);
      this.wordBbuf.rewind();
      IOUtils.readFully(this.archive, this.wordBbuf);
      found = Arrays.equals(ZipArchiveOutputStream.ZIP64_EOCD_LOC_SIG, this.wordBuf);
    } 
    if (!found) {
      if (searchedForZip64EOCD)
        skipBytes(16); 
      positionAtCentralDirectory32();
    } else {
      positionAtCentralDirectory64();
    } 
  }
  
  private void positionAtCentralDirectory32() throws IOException {
    long endOfCentralDirectoryRecordOffset = this.archive.position();
    if (this.isSplitZipArchive) {
      skipBytes(6);
      this.shortBbuf.rewind();
      IOUtils.readFully(this.archive, this.shortBbuf);
      this.centralDirectoryStartDiskNumber = ZipShort.getValue(this.shortBuf);
      skipBytes(8);
      this.wordBbuf.rewind();
      IOUtils.readFully(this.archive, this.wordBbuf);
      this.centralDirectoryStartRelativeOffset = ZipLong.getValue(this.wordBuf);
      ((ZipSplitReadOnlySeekableByteChannel)this.archive)
        .position(this.centralDirectoryStartDiskNumber, this.centralDirectoryStartRelativeOffset);
    } else {
      skipBytes(12);
      this.wordBbuf.rewind();
      IOUtils.readFully(this.archive, this.wordBbuf);
      long centralDirectoryLength = ZipLong.getValue(this.wordBuf);
      this.wordBbuf.rewind();
      IOUtils.readFully(this.archive, this.wordBbuf);
      this.centralDirectoryStartDiskNumber = 0L;
      this.centralDirectoryStartRelativeOffset = ZipLong.getValue(this.wordBuf);
      this.firstLocalFileHeaderOffset = Long.max(endOfCentralDirectoryRecordOffset - centralDirectoryLength - this.centralDirectoryStartRelativeOffset, 0L);
      this.archive.position(this.centralDirectoryStartRelativeOffset + this.firstLocalFileHeaderOffset);
    } 
  }
  
  private void positionAtCentralDirectory64() throws IOException {
    if (this.isSplitZipArchive) {
      this.wordBbuf.rewind();
      IOUtils.readFully(this.archive, this.wordBbuf);
      long diskNumberOfEOCD = ZipLong.getValue(this.wordBuf);
      this.dwordBbuf.rewind();
      IOUtils.readFully(this.archive, this.dwordBbuf);
      long relativeOffsetOfEOCD = ZipEightByteInteger.getLongValue(this.dwordBuf);
      ((ZipSplitReadOnlySeekableByteChannel)this.archive)
        .position(diskNumberOfEOCD, relativeOffsetOfEOCD);
    } else {
      skipBytes(4);
      this.dwordBbuf.rewind();
      IOUtils.readFully(this.archive, this.dwordBbuf);
      this.archive.position(ZipEightByteInteger.getLongValue(this.dwordBuf));
    } 
    this.wordBbuf.rewind();
    IOUtils.readFully(this.archive, this.wordBbuf);
    if (!Arrays.equals(this.wordBuf, ZipArchiveOutputStream.ZIP64_EOCD_SIG))
      throw new ZipException("Archive's ZIP64 end of central directory locator is corrupt."); 
    if (this.isSplitZipArchive) {
      skipBytes(16);
      this.wordBbuf.rewind();
      IOUtils.readFully(this.archive, this.wordBbuf);
      this.centralDirectoryStartDiskNumber = ZipLong.getValue(this.wordBuf);
      skipBytes(24);
      this.dwordBbuf.rewind();
      IOUtils.readFully(this.archive, this.dwordBbuf);
      this.centralDirectoryStartRelativeOffset = ZipEightByteInteger.getLongValue(this.dwordBuf);
      ((ZipSplitReadOnlySeekableByteChannel)this.archive)
        .position(this.centralDirectoryStartDiskNumber, this.centralDirectoryStartRelativeOffset);
    } else {
      skipBytes(44);
      this.dwordBbuf.rewind();
      IOUtils.readFully(this.archive, this.dwordBbuf);
      this.centralDirectoryStartDiskNumber = 0L;
      this.centralDirectoryStartRelativeOffset = ZipEightByteInteger.getLongValue(this.dwordBuf);
      this.archive.position(this.centralDirectoryStartRelativeOffset);
    } 
  }
  
  private void positionAtEndOfCentralDirectoryRecord() throws IOException {
    boolean found = tryToLocateSignature(22L, 65557L, ZipArchiveOutputStream.EOCD_SIG);
    if (!found)
      throw new ZipException("Archive is not a ZIP archive"); 
  }
  
  private void readCentralDirectoryEntry(Map<ZipArchiveEntry, NameAndComment> noUTF8Flag) throws IOException {
    this.cfhBbuf.rewind();
    IOUtils.readFully(this.archive, this.cfhBbuf);
    int off = 0;
    Entry ze = new Entry();
    int versionMadeBy = ZipShort.getValue(this.cfhBuf, off);
    off += 2;
    ze.setVersionMadeBy(versionMadeBy);
    ze.setPlatform(versionMadeBy >> 8 & 0xF);
    ze.setVersionRequired(ZipShort.getValue(this.cfhBuf, off));
    off += 2;
    GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(this.cfhBuf, off);
    boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();
    ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : this.zipEncoding;
    if (hasUTF8Flag)
      ze.setNameSource(ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG); 
    ze.setGeneralPurposeBit(gpFlag);
    ze.setRawFlag(ZipShort.getValue(this.cfhBuf, off));
    off += 2;
    ze.setMethod(ZipShort.getValue(this.cfhBuf, off));
    off += 2;
    long time = ZipUtil.dosToJavaTime(ZipLong.getValue(this.cfhBuf, off));
    ze.setTime(time);
    off += 4;
    ze.setCrc(ZipLong.getValue(this.cfhBuf, off));
    off += 4;
    long size = ZipLong.getValue(this.cfhBuf, off);
    if (size < 0L)
      throw new IOException("broken archive, entry with negative compressed size"); 
    ze.setCompressedSize(size);
    off += 4;
    size = ZipLong.getValue(this.cfhBuf, off);
    if (size < 0L)
      throw new IOException("broken archive, entry with negative size"); 
    ze.setSize(size);
    off += 4;
    int fileNameLen = ZipShort.getValue(this.cfhBuf, off);
    off += 2;
    if (fileNameLen < 0)
      throw new IOException("broken archive, entry with negative fileNameLen"); 
    int extraLen = ZipShort.getValue(this.cfhBuf, off);
    off += 2;
    if (extraLen < 0)
      throw new IOException("broken archive, entry with negative extraLen"); 
    int commentLen = ZipShort.getValue(this.cfhBuf, off);
    off += 2;
    if (commentLen < 0)
      throw new IOException("broken archive, entry with negative commentLen"); 
    ze.setDiskNumberStart(ZipShort.getValue(this.cfhBuf, off));
    off += 2;
    ze.setInternalAttributes(ZipShort.getValue(this.cfhBuf, off));
    off += 2;
    ze.setExternalAttributes(ZipLong.getValue(this.cfhBuf, off));
    off += 4;
    byte[] fileName = IOUtils.readRange(this.archive, fileNameLen);
    if (fileName.length < fileNameLen)
      throw new EOFException(); 
    ze.setName(entryEncoding.decode(fileName), fileName);
    ze.setLocalHeaderOffset(ZipLong.getValue(this.cfhBuf, off) + this.firstLocalFileHeaderOffset);
    this.entries.add(ze);
    byte[] cdExtraData = IOUtils.readRange(this.archive, extraLen);
    if (cdExtraData.length < extraLen)
      throw new EOFException(); 
    try {
      ze.setCentralDirectoryExtra(cdExtraData);
    } catch (RuntimeException ex) {
      ZipException z = new ZipException("Invalid extra data in entry " + ze.getName());
      z.initCause(ex);
      throw z;
    } 
    setSizesAndOffsetFromZip64Extra(ze);
    sanityCheckLFHOffset(ze);
    byte[] comment = IOUtils.readRange(this.archive, commentLen);
    if (comment.length < commentLen)
      throw new EOFException(); 
    ze.setComment(entryEncoding.decode(comment));
    if (!hasUTF8Flag && this.useUnicodeExtraFields)
      noUTF8Flag.put(ze, new NameAndComment(fileName, comment, null)); 
    ze.setStreamContiguous(true);
  }
  
  private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag) throws IOException {
    for (ZipArchiveEntry zipArchiveEntry : this.entries) {
      Entry ze = (Entry)zipArchiveEntry;
      int[] lens = setDataOffset(ze);
      int fileNameLen = lens[0];
      int extraFieldLen = lens[1];
      skipBytes(fileNameLen);
      byte[] localExtraData = IOUtils.readRange(this.archive, extraFieldLen);
      if (localExtraData.length < extraFieldLen)
        throw new EOFException(); 
      try {
        ze.setExtra(localExtraData);
      } catch (RuntimeException ex) {
        ZipException z = new ZipException("Invalid extra data in entry " + ze.getName());
        z.initCause(ex);
        throw z;
      } 
      if (entriesWithoutUTF8Flag.containsKey(ze)) {
        NameAndComment nc = (NameAndComment)entriesWithoutUTF8Flag.get(ze);
        ZipUtil.setNameAndCommentFromExtraFields(ze, NameAndComment.access$200(nc), 
            NameAndComment.access$300(nc));
      } 
    } 
  }
  
  private void sanityCheckLFHOffset(ZipArchiveEntry ze) throws IOException {
    if (ze.getDiskNumberStart() < 0L)
      throw new IOException("broken archive, entry with negative disk number"); 
    if (ze.getLocalHeaderOffset() < 0L)
      throw new IOException("broken archive, entry with negative local file header offset"); 
    if (this.isSplitZipArchive) {
      if (ze.getDiskNumberStart() > this.centralDirectoryStartDiskNumber)
        throw new IOException("local file header for " + ze.getName() + " starts on a later disk than central directory"); 
      if (ze.getDiskNumberStart() == this.centralDirectoryStartDiskNumber && ze
        .getLocalHeaderOffset() > this.centralDirectoryStartRelativeOffset)
        throw new IOException("local file header for " + ze.getName() + " starts after central directory"); 
    } else if (ze.getLocalHeaderOffset() > this.centralDirectoryStartOffset) {
      throw new IOException("local file header for " + ze.getName() + " starts after central directory");
    } 
  }
  
  private int[] setDataOffset(ZipArchiveEntry ze) throws IOException {
    long offset = ze.getLocalHeaderOffset();
    if (this.isSplitZipArchive) {
      ((ZipSplitReadOnlySeekableByteChannel)this.archive)
        .position(ze.getDiskNumberStart(), offset + 26L);
      offset = this.archive.position() - 26L;
    } else {
      this.archive.position(offset + 26L);
    } 
    this.wordBbuf.rewind();
    IOUtils.readFully(this.archive, this.wordBbuf);
    this.wordBbuf.flip();
    this.wordBbuf.get(this.shortBuf);
    int fileNameLen = ZipShort.getValue(this.shortBuf);
    this.wordBbuf.get(this.shortBuf);
    int extraFieldLen = ZipShort.getValue(this.shortBuf);
    ze.setDataOffset(offset + 26L + 2L + 2L + fileNameLen + extraFieldLen);
    if (ze.getDataOffset() + ze.getCompressedSize() > this.centralDirectoryStartOffset)
      throw new IOException("data for " + ze.getName() + " overlaps with central directory."); 
    return new int[] { fileNameLen, extraFieldLen };
  }
  
  private void setSizesAndOffsetFromZip64Extra(ZipArchiveEntry ze) throws IOException {
    ZipExtraField extra = ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);
    if (extra != null && !(extra instanceof Zip64ExtendedInformationExtraField))
      throw new ZipException("archive contains unparseable zip64 extra field"); 
    Zip64ExtendedInformationExtraField z64 = (Zip64ExtendedInformationExtraField)extra;
    if (z64 != null) {
      boolean hasUncompressedSize = (ze.getSize() == 4294967295L);
      boolean hasCompressedSize = (ze.getCompressedSize() == 4294967295L);
      boolean hasRelativeHeaderOffset = (ze.getLocalHeaderOffset() == 4294967295L);
      boolean hasDiskStart = (ze.getDiskNumberStart() == 65535L);
      z64.reparseCentralDirectoryData(hasUncompressedSize, hasCompressedSize, hasRelativeHeaderOffset, hasDiskStart);
      if (hasUncompressedSize) {
        long size = z64.getSize().getLongValue();
        if (size < 0L)
          throw new IOException("broken archive, entry with negative size"); 
        ze.setSize(size);
      } else if (hasCompressedSize) {
        z64.setSize(new ZipEightByteInteger(ze.getSize()));
      } 
      if (hasCompressedSize) {
        long size = z64.getCompressedSize().getLongValue();
        if (size < 0L)
          throw new IOException("broken archive, entry with negative compressed size"); 
        ze.setCompressedSize(size);
      } else if (hasUncompressedSize) {
        z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));
      } 
      if (hasRelativeHeaderOffset)
        ze.setLocalHeaderOffset(z64.getRelativeHeaderOffset().getLongValue()); 
      if (hasDiskStart)
        ze.setDiskNumberStart(z64.getDiskStartNumber().getValue()); 
    } 
  }
  
  private void skipBytes(int count) throws IOException {
    long currentPosition = this.archive.position();
    long newPosition = currentPosition + count;
    if (newPosition > this.archive.size())
      throw new EOFException(); 
    this.archive.position(newPosition);
  }
  
  private boolean startsWithLocalFileHeader() throws IOException {
    this.archive.position(this.firstLocalFileHeaderOffset);
    this.wordBbuf.rewind();
    IOUtils.readFully(this.archive, this.wordBbuf);
    return Arrays.equals(this.wordBuf, ZipArchiveOutputStream.LFH_SIG);
  }
  
  private boolean tryToLocateSignature(long minDistanceFromEnd, long maxDistanceFromEnd, byte[] sig) throws IOException {
    boolean found = false;
    long off = this.archive.size() - minDistanceFromEnd;
    long stopSearching = Math.max(0L, this.archive.size() - maxDistanceFromEnd);
    if (off >= 0L)
      for (; off >= stopSearching; off--) {
        this.archive.position(off);
        try {
          this.wordBbuf.rewind();
          IOUtils.readFully(this.archive, this.wordBbuf);
          this.wordBbuf.flip();
        } catch (EOFException ex) {
          break;
        } 
        int curr = this.wordBbuf.get();
        if (curr == sig[0]) {
          curr = this.wordBbuf.get();
          if (curr == sig[1]) {
            curr = this.wordBbuf.get();
            if (curr == sig[2]) {
              curr = this.wordBbuf.get();
              if (curr == sig[3]) {
                found = true;
                break;
              } 
            } 
          } 
        } 
      }  
    if (found)
      this.archive.position(off); 
    return found;
  }
}
