package org.apache.commons.compress.archivers.zip;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.zip.ZipException;

public class ExtraFieldUtils {
  private static final int WORD = 4;
  
  private static final Map<ZipShort, Class<?>> IMPLEMENTATIONS = new ConcurrentHashMap();
  
  static final ZipExtraField[] EMPTY_ZIP_EXTRA_FIELD_ARRAY;
  
  static  {
    register(AsiExtraField.class);
    register(X5455_ExtendedTimestamp.class);
    register(X7875_NewUnix.class);
    register(JarMarker.class);
    register(UnicodePathExtraField.class);
    register(UnicodeCommentExtraField.class);
    register(Zip64ExtendedInformationExtraField.class);
    register(X000A_NTFS.class);
    register(X0014_X509Certificates.class);
    register(X0015_CertificateIdForFile.class);
    register(X0016_CertificateIdForCentralDirectory.class);
    register(X0017_StrongEncryptionHeader.class);
    register(X0019_EncryptionRecipientCertificateList.class);
    register(ResourceAlignmentExtraField.class);
    EMPTY_ZIP_EXTRA_FIELD_ARRAY = new ZipExtraField[0];
  }
  
  public static ZipExtraField createExtraField(ZipShort headerId) throws InstantiationException, IllegalAccessException {
    ZipExtraField field = createExtraFieldNoDefault(headerId);
    if (field != null)
      return field; 
    UnrecognizedExtraField u = new UnrecognizedExtraField();
    u.setHeaderId(headerId);
    return u;
  }
  
  public static ZipExtraField createExtraFieldNoDefault(ZipShort headerId) throws InstantiationException, IllegalAccessException {
    Class<?> c = (Class)IMPLEMENTATIONS.get(headerId);
    if (c != null)
      return (ZipExtraField)c.newInstance(); 
    return null;
  }
  
  public static ZipExtraField fillExtraField(ZipExtraField ze, byte[] data, int off, int len, boolean local) throws ZipException {
    try {
      if (local) {
        ze.parseFromLocalFileData(data, off, len);
      } else {
        ze.parseFromCentralDirectoryData(data, off, len);
      } 
      return ze;
    } catch (ArrayIndexOutOfBoundsException aiobe) {
      throw (ZipException)(new ZipException("Failed to parse corrupt ZIP extra field of type " + 
          Integer.toHexString(ze.getHeaderId().getValue()))).initCause(aiobe);
    } 
  }
  
  public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) {
    int dataLength = data.length;
    boolean lastIsUnparseableHolder = (dataLength > 0 && data[dataLength - 1] instanceof UnparseableExtraFieldData);
    int regularExtraFieldCount = lastIsUnparseableHolder ? (dataLength - 1) : dataLength;
    int sum = 4 * regularExtraFieldCount;
    for (ZipExtraField element : data)
      sum += element.getCentralDirectoryLength().getValue(); 
    byte[] result = new byte[sum];
    int start = 0;
    for (int i = 0; i < regularExtraFieldCount; i++) {
      System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);
      System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);
      start += 4;
      byte[] central = data[i].getCentralDirectoryData();
      if (central != null) {
        System.arraycopy(central, 0, result, start, central.length);
        start += central.length;
      } 
    } 
    if (lastIsUnparseableHolder) {
      byte[] central = data[dataLength - 1].getCentralDirectoryData();
      if (central != null)
        System.arraycopy(central, 0, result, start, central.length); 
    } 
    return result;
  }
  
  public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {
    int dataLength = data.length;
    boolean lastIsUnparseableHolder = (dataLength > 0 && data[dataLength - 1] instanceof UnparseableExtraFieldData);
    int regularExtraFieldCount = lastIsUnparseableHolder ? (dataLength - 1) : dataLength;
    int sum = 4 * regularExtraFieldCount;
    for (ZipExtraField element : data)
      sum += element.getLocalFileDataLength().getValue(); 
    byte[] result = new byte[sum];
    int start = 0;
    for (int i = 0; i < regularExtraFieldCount; i++) {
      System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);
      System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);
      start += 4;
      byte[] local = data[i].getLocalFileDataData();
      if (local != null) {
        System.arraycopy(local, 0, result, start, local.length);
        start += local.length;
      } 
    } 
    if (lastIsUnparseableHolder) {
      byte[] local = data[dataLength - 1].getLocalFileDataData();
      if (local != null)
        System.arraycopy(local, 0, result, start, local.length); 
    } 
    return result;
  }
  
  public static ZipExtraField[] parse(byte[] data) throws ZipException { return parse(data, true, UnparseableExtraField.THROW); }
  
  public static ZipExtraField[] parse(byte[] data, boolean local) throws ZipException { return parse(data, local, UnparseableExtraField.THROW); }
  
  public static ZipExtraField[] parse(byte[] data, boolean local, ExtraFieldParsingBehavior parsingBehavior) throws ZipException {
    List<ZipExtraField> v = new ArrayList<ZipExtraField>();
    int start = 0;
    int dataLength = data.length;
    while (start <= dataLength - 4) {
      ZipShort headerId = new ZipShort(data, start);
      int length = (new ZipShort(data, start + 2)).getValue();
      if (start + 4 + length > dataLength) {
        ZipExtraField field = parsingBehavior.onUnparseableExtraField(data, start, dataLength - start, local, length);
        if (field != null)
          v.add(field); 
        break;
      } 
      try {
        ZipExtraField ze = (ZipExtraField)Objects.requireNonNull(parsingBehavior.createExtraField(headerId), "createExtraField must not return null");
        v.add((ZipExtraField)Objects.requireNonNull(parsingBehavior.fill(ze, data, start + 4, length, local), "fill must not return null"));
        start += length + 4;
      } catch (InstantiationException|IllegalAccessException ie) {
        throw (ZipException)(new ZipException(ie.getMessage())).initCause(ie);
      } 
    } 
    return (ZipExtraField[])v.toArray(EMPTY_ZIP_EXTRA_FIELD_ARRAY);
  }
  
  public static ZipExtraField[] parse(byte[] data, boolean local, UnparseableExtraField onUnparseableData) throws ZipException { return parse(data, local, new Object(onUnparseableData)); }
  
  public static void register(Class<?> c) {
    try {
      ZipExtraField ze = (ZipExtraField)c.newInstance();
      IMPLEMENTATIONS.put(ze.getHeaderId(), c);
    } catch (ClassCastException cc) {
      throw new IllegalArgumentException(c + " doesn't implement ZipExtraField");
    } catch (InstantiationException ie) {
      throw new IllegalArgumentException(c + " is not a concrete class");
    } catch (IllegalAccessException ie) {
      throw new IllegalArgumentException(c + "'s no-arg constructor is not public");
    } 
  }
}
