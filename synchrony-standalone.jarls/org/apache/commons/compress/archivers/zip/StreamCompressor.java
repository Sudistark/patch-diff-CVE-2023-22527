package org.apache.commons.compress.archivers.zip;

import java.io.Closeable;
import java.io.DataOutput;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.channels.SeekableByteChannel;
import java.util.zip.CRC32;
import java.util.zip.Deflater;
import org.apache.commons.compress.parallel.ScatterGatherBackingStore;

public abstract class StreamCompressor implements Closeable {
  private static final int DEFLATER_BLOCK_SIZE = 8192;
  
  private static final int BUFFER_SIZE = 4096;
  
  private final Deflater def;
  
  private final CRC32 crc;
  
  private long writtenToOutputStreamForLastEntry;
  
  private long sourcePayloadLength;
  
  private long totalWrittenToOutputStream;
  
  private final byte[] outputBuffer;
  
  private final byte[] readerBuf;
  
  static StreamCompressor create(DataOutput os, Deflater deflater) { return new DataOutputCompressor(deflater, os); }
  
  public static StreamCompressor create(int compressionLevel, ScatterGatherBackingStore bs) {
    Deflater deflater = new Deflater(compressionLevel, true);
    return new ScatterGatherBackingStoreCompressor(deflater, bs);
  }
  
  static StreamCompressor create(OutputStream os) { return create(os, new Deflater(-1, true)); }
  
  static StreamCompressor create(OutputStream os, Deflater deflater) { return new OutputStreamCompressor(deflater, os); }
  
  public static StreamCompressor create(ScatterGatherBackingStore bs) { return create(-1, bs); }
  
  static StreamCompressor create(SeekableByteChannel os, Deflater deflater) { return new SeekableByteChannelCompressor(deflater, os); }
  
  StreamCompressor(Deflater deflater) {
    this.crc = new CRC32();
    this.outputBuffer = new byte[4096];
    this.readerBuf = new byte[4096];
    this.def = deflater;
  }
  
  public void close() throws IOException { this.def.end(); }
  
  void deflate() throws IOException {
    int len = this.def.deflate(this.outputBuffer, 0, this.outputBuffer.length);
    if (len > 0)
      writeCounted(this.outputBuffer, 0, len); 
  }
  
  public void deflate(InputStream source, int method) throws IOException {
    reset();
    int length;
    while ((length = source.read(this.readerBuf, 0, this.readerBuf.length)) >= 0)
      write(this.readerBuf, 0, length, method); 
    if (method == 8)
      flushDeflater(); 
  }
  
  private void deflateUntilInputIsNeeded() throws IOException {
    while (!this.def.needsInput())
      deflate(); 
  }
  
  void flushDeflater() throws IOException {
    this.def.finish();
    while (!this.def.finished())
      deflate(); 
  }
  
  public long getBytesRead() { return this.sourcePayloadLength; }
  
  public long getBytesWrittenForLastEntry() { return this.writtenToOutputStreamForLastEntry; }
  
  public long getCrc32() { return this.crc.getValue(); }
  
  public long getTotalBytesWritten() { return this.totalWrittenToOutputStream; }
  
  void reset() throws IOException {
    this.crc.reset();
    this.def.reset();
    this.sourcePayloadLength = 0L;
    this.writtenToOutputStreamForLastEntry = 0L;
  }
  
  long write(byte[] b, int offset, int length, int method) throws IOException {
    long current = this.writtenToOutputStreamForLastEntry;
    this.crc.update(b, offset, length);
    if (method == 8) {
      writeDeflated(b, offset, length);
    } else {
      writeCounted(b, offset, length);
    } 
    this.sourcePayloadLength += length;
    return this.writtenToOutputStreamForLastEntry - current;
  }
  
  public void writeCounted(byte[] data) throws IOException { writeCounted(data, 0, data.length); }
  
  public void writeCounted(byte[] data, int offset, int length) throws IOException {
    writeOut(data, offset, length);
    this.writtenToOutputStreamForLastEntry += length;
    this.totalWrittenToOutputStream += length;
  }
  
  private void writeDeflated(byte[] b, int offset, int length) throws IOException {
    if (length > 0 && !this.def.finished())
      if (length <= 8192) {
        this.def.setInput(b, offset, length);
        deflateUntilInputIsNeeded();
      } else {
        int fullblocks = length / 8192;
        for (int i = 0; i < fullblocks; i++) {
          this.def.setInput(b, offset + i * 8192, 8192);
          deflateUntilInputIsNeeded();
        } 
        int done = fullblocks * 8192;
        if (done < length) {
          this.def.setInput(b, offset + done, length - done);
          deflateUntilInputIsNeeded();
        } 
      }  
  }
  
  protected abstract void writeOut(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException;
}
