package org.apache.commons.compress.archivers.zip;

import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.SeekableByteChannel;
import java.nio.file.Files;
import java.nio.file.OpenOption;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.function.Supplier;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.apache.commons.compress.utils.FileNameUtils;
import org.apache.commons.compress.utils.MultiReadOnlySeekableByteChannel;

public class ZipSplitReadOnlySeekableByteChannel extends MultiReadOnlySeekableByteChannel {
  private static final Path[] EMPTY_PATH_ARRAY = new Path[0];
  
  private static final int ZIP_SPLIT_SIGNATURE_LENGTH = 4;
  
  public static SeekableByteChannel buildFromLastSplitSegment(File lastSegmentFile) throws IOException { return buildFromLastSplitSegment(lastSegmentFile.toPath()); }
  
  public static SeekableByteChannel buildFromLastSplitSegment(Path lastSegmentPath) throws IOException {
    ArrayList<Path> splitZipSegments;
    String extension = FileNameUtils.getExtension(lastSegmentPath);
    if (!extension.equalsIgnoreCase("zip"))
      throw new IllegalArgumentException("The extension of last ZIP split segment should be .zip"); 
    Path parent = Objects.nonNull(lastSegmentPath.getParent()) ? lastSegmentPath.getParent() : lastSegmentPath.getFileSystem().getPath(".", new String[0]);
    String fileBaseName = FileNameUtils.getBaseName(lastSegmentPath);
    Pattern pattern = Pattern.compile(Pattern.quote(fileBaseName) + ".[zZ][0-9]+");
    Stream<Path> walk = Files.walk(parent, 1, new java.nio.file.FileVisitOption[0]);
    try {
      splitZipSegments = (ArrayList)walk.filter(x$0 -> Files.isRegularFile(x$0, new java.nio.file.LinkOption[0])).filter(path -> pattern.matcher(path.getFileName().toString()).matches()).sorted(new ZipSplitSegmentComparator(null)).collect(Collectors.toCollection(ArrayList::new));
      if (walk != null)
        walk.close(); 
    } catch (Throwable throwable) {
      if (walk != null)
        try {
          walk.close();
        } catch (Throwable throwable1) {
          throwable.addSuppressed(throwable1);
        }  
      throw throwable;
    } 
    return forPaths(lastSegmentPath, splitZipSegments);
  }
  
  public static SeekableByteChannel forFiles(File... files) throws IOException {
    List<Path> paths = new ArrayList<Path>();
    for (File f : (File[])Objects.requireNonNull(files, "files must not be null"))
      paths.add(f.toPath()); 
    return forPaths((Path[])paths.toArray(EMPTY_PATH_ARRAY));
  }
  
  public static SeekableByteChannel forFiles(File lastSegmentFile, Iterable<File> files) throws IOException {
    Objects.requireNonNull(files, "files");
    Objects.requireNonNull(lastSegmentFile, "lastSegmentFile");
    List<Path> filesList = new ArrayList<Path>();
    files.forEach(f -> filesList.add(f.toPath()));
    return forPaths(lastSegmentFile.toPath(), filesList);
  }
  
  public static SeekableByteChannel forOrderedSeekableByteChannels(SeekableByteChannel... channels) throws IOException {
    if ((SeekableByteChannel[])Objects.requireNonNull(channels, "channels must not be null").length == 1)
      return channels[0]; 
    return new ZipSplitReadOnlySeekableByteChannel(Arrays.asList(channels));
  }
  
  public static SeekableByteChannel forOrderedSeekableByteChannels(SeekableByteChannel lastSegmentChannel, Iterable<SeekableByteChannel> channels) throws IOException {
    Objects.requireNonNull(channels, "channels");
    Objects.requireNonNull(lastSegmentChannel, "lastSegmentChannel");
    List<SeekableByteChannel> channelsList = new ArrayList<SeekableByteChannel>();
    Objects.requireNonNull(channelsList);
    channels.forEach(channelsList::add);
    channelsList.add(lastSegmentChannel);
    return forOrderedSeekableByteChannels((SeekableByteChannel[])channelsList.toArray(new SeekableByteChannel[0]));
  }
  
  public static SeekableByteChannel forPaths(Path... paths) throws IOException {
    List<SeekableByteChannel> channels = new ArrayList<SeekableByteChannel>();
    for (Path path : (Path[])Objects.requireNonNull(paths, "paths must not be null")) {
      channels.add(Files.newByteChannel(path, new OpenOption[] { StandardOpenOption.READ }));
    } 
    if (channels.size() == 1)
      return (SeekableByteChannel)channels.get(0); 
    return new ZipSplitReadOnlySeekableByteChannel(channels);
  }
  
  public static SeekableByteChannel forPaths(Path lastSegmentPath, Iterable<Path> paths) throws IOException {
    Objects.requireNonNull(paths, "paths");
    Objects.requireNonNull(lastSegmentPath, "lastSegmentPath");
    List<Path> filesList = new ArrayList<Path>();
    Objects.requireNonNull(filesList);
    paths.forEach(filesList::add);
    filesList.add(lastSegmentPath);
    return forPaths((Path[])filesList.toArray(EMPTY_PATH_ARRAY));
  }
  
  private final ByteBuffer zipSplitSignatureByteBuffer = ByteBuffer.allocate(4);
  
  public ZipSplitReadOnlySeekableByteChannel(List<SeekableByteChannel> channels) throws IOException {
    super(channels);
    assertSplitSignature(channels);
  }
  
  private void assertSplitSignature(List<SeekableByteChannel> channels) throws IOException {
    SeekableByteChannel channel = (SeekableByteChannel)channels.get(0);
    channel.position(0L);
    this.zipSplitSignatureByteBuffer.rewind();
    channel.read(this.zipSplitSignatureByteBuffer);
    ZipLong signature = new ZipLong(this.zipSplitSignatureByteBuffer.array());
    if (!signature.equals(ZipLong.DD_SIG)) {
      channel.position(0L);
      throw new IOException("The first ZIP split segment does not begin with split ZIP file signature");
    } 
    channel.position(0L);
  }
}
