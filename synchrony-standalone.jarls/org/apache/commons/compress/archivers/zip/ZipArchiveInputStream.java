package org.apache.commons.compress.archivers.zip;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.io.PushbackInputStream;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.zip.DataFormatException;
import java.util.zip.Inflater;
import java.util.zip.ZipException;
import org.apache.commons.compress.archivers.ArchiveEntry;
import org.apache.commons.compress.archivers.ArchiveInputStream;
import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;
import org.apache.commons.compress.compressors.deflate64.Deflate64CompressorInputStream;
import org.apache.commons.compress.utils.ArchiveUtils;
import org.apache.commons.compress.utils.IOUtils;
import org.apache.commons.compress.utils.InputStreamStatistics;

public class ZipArchiveInputStream extends ArchiveInputStream implements InputStreamStatistics {
  private static final int LFH_LEN = 30;
  
  private static final int CFH_LEN = 46;
  
  private static final long TWO_EXP_32 = 4294967296L;
  
  private static final String USE_ZIPFILE_INSTEAD_OF_STREAM_DISCLAIMER = " while reading a stored entry using data descriptor. Either the archive is broken or it can not be read using ZipArchiveInputStream and you must use ZipFile. A common cause for this is a ZIP archive containing a ZIP archive. See http://commons.apache.org/proper/commons-compress/zip.html#ZipArchiveInputStream_vs_ZipFile";
  
  private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();
  
  private static final byte[] CFH = ZipLong.CFH_SIG.getBytes();
  
  private static final byte[] DD = ZipLong.DD_SIG.getBytes();
  
  private static final byte[] APK_SIGNING_BLOCK_MAGIC = { 
      65, 80, 75, 32, 83, 105, 103, 32, 66, 108, 
      111, 99, 107, 32, 52, 50 };
  
  private static final BigInteger LONG_MAX = BigInteger.valueOf(Float.MAX_VALUE);
  
  private final ZipEncoding zipEncoding;
  
  final String encoding;
  
  private final boolean useUnicodeExtraFields;
  
  private final InputStream inputStream;
  
  private final Inflater inf;
  
  private final ByteBuffer buf;
  
  private CurrentEntry current;
  
  private boolean closed;
  
  private boolean hitCentralDirectory;
  
  private ByteArrayInputStream lastStoredEntry;
  
  private final boolean allowStoredEntriesWithDataDescriptor;
  
  private long uncompressedCount;
  
  private final boolean skipSplitSig;
  
  private final byte[] lfhBuf;
  
  private final byte[] skipBuf;
  
  private final byte[] shortBuf;
  
  private final byte[] wordBuf;
  
  private final byte[] twoDwordBuf;
  
  private int entriesRead;
  
  private static boolean checksig(byte[] signature, byte[] expected) {
    for (int i = 0; i < expected.length; i++) {
      if (signature[i] != expected[i])
        return false; 
    } 
    return true;
  }
  
  public static boolean matches(byte[] signature, int length) {
    if (length < ZipArchiveOutputStream.LFH_SIG.length)
      return false; 
    return (checksig(signature, ZipArchiveOutputStream.LFH_SIG) || 
      checksig(signature, ZipArchiveOutputStream.EOCD_SIG) || 
      checksig(signature, ZipArchiveOutputStream.DD_SIG) || 
      checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes()));
  }
  
  public ZipArchiveInputStream(InputStream inputStream) { this(inputStream, "UTF8"); }
  
  public ZipArchiveInputStream(InputStream inputStream, String encoding) { this(inputStream, encoding, true); }
  
  public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) { this(inputStream, encoding, useUnicodeExtraFields, false); }
  
  public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) { this(inputStream, encoding, useUnicodeExtraFields, allowStoredEntriesWithDataDescriptor, false); }
  
  public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor, boolean skipSplitSig) {
    this.inf = new Inflater(true);
    this.buf = ByteBuffer.allocate(512);
    this.lfhBuf = new byte[30];
    this.skipBuf = new byte[1024];
    this.shortBuf = new byte[2];
    this.wordBuf = new byte[4];
    this.twoDwordBuf = new byte[16];
    this.encoding = encoding;
    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);
    this.useUnicodeExtraFields = useUnicodeExtraFields;
    this.inputStream = new PushbackInputStream(inputStream, this.buf.capacity());
    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;
    this.skipSplitSig = skipSplitSig;
    this.buf.limit(0);
  }
  
  private boolean bufferContainsSignature(ByteArrayOutputStream bos, int offset, int lastRead, int expectedDDLen) throws IOException {
    boolean done = false;
    for (int i = 0; !done && i < offset + lastRead - 4; i++) {
      if (this.buf.array()[i] == LFH[0] && this.buf.array()[i + 1] == LFH[1]) {
        int expectDDPos = i;
        if ((i >= expectedDDLen && this.buf
          .array()[i + 2] == LFH[2] && this.buf.array()[i + 3] == LFH[3]) || (this.buf
          .array()[i + 2] == CFH[2] && this.buf.array()[i + 3] == CFH[3])) {
          expectDDPos = i - expectedDDLen;
          done = true;
        } else if (this.buf.array()[i + 2] == DD[2] && this.buf.array()[i + 3] == DD[3]) {
          done = true;
        } 
        if (done) {
          pushback(this.buf.array(), expectDDPos, offset + lastRead - expectDDPos);
          bos.write(this.buf.array(), 0, expectDDPos);
          readDataDescriptor();
        } 
      } 
    } 
    return done;
  }
  
  private int cacheBytesRead(ByteArrayOutputStream bos, int offset, int lastRead, int expectedDDLen) {
    int cacheable = offset + lastRead - expectedDDLen - 3;
    if (cacheable > 0) {
      bos.write(this.buf.array(), 0, cacheable);
      System.arraycopy(this.buf.array(), cacheable, this.buf.array(), 0, expectedDDLen + 3);
      offset = expectedDDLen + 3;
    } else {
      offset += lastRead;
    } 
    return offset;
  }
  
  public boolean canReadEntryData(ArchiveEntry ae) {
    if (ae instanceof ZipArchiveEntry) {
      ZipArchiveEntry ze = (ZipArchiveEntry)ae;
      return (ZipUtil.canHandleEntryData(ze) && 
        supportsDataDescriptorFor(ze) && 
        supportsCompressedSizeFor(ze));
    } 
    return false;
  }
  
  public void close() throws IOException {
    if (!this.closed) {
      this.closed = true;
      try {
        this.inputStream.close();
      } finally {
        this.inf.end();
      } 
    } 
  }
  
  private void closeEntry() throws IOException {
    if (this.closed)
      throw new IOException("The stream is closed"); 
    if (this.current == null)
      return; 
    if (currentEntryHasOutstandingBytes()) {
      drainCurrentEntryData();
    } else {
      skip(Float.MAX_VALUE);
      long inB = (CurrentEntry.access$400(this.current).getMethod() == 8) ? getBytesInflated() : CurrentEntry.access$500(this.current);
      int diff = (int)(CurrentEntry.access$200(this.current) - inB);
      if (diff > 0) {
        pushback(this.buf.array(), this.buf.limit() - diff, diff);
        CurrentEntry.access$222(this.current, diff);
      } 
      if (currentEntryHasOutstandingBytes())
        drainCurrentEntryData(); 
    } 
    if (this.lastStoredEntry == null && CurrentEntry.access$600(this.current))
      readDataDescriptor(); 
    this.inf.reset();
    this.buf.clear().flip();
    this.current = null;
    this.lastStoredEntry = null;
  }
  
  private boolean currentEntryHasOutstandingBytes() {
    return (CurrentEntry.access$200(this.current) <= CurrentEntry.access$400(this.current).getCompressedSize() && 
      !CurrentEntry.access$600(this.current));
  }
  
  private void drainCurrentEntryData() throws IOException {
    long remaining = CurrentEntry.access$400(this.current).getCompressedSize() - CurrentEntry.access$200(this.current);
    while (remaining > 0L) {
      long n = this.inputStream.read(this.buf.array(), 0, (int)Math.min(this.buf.capacity(), remaining));
      if (n < 0L)
        throw new EOFException("Truncated ZIP entry: " + 
            ArchiveUtils.sanitize(CurrentEntry.access$400(this.current).getName())); 
      count(n);
      remaining -= n;
    } 
  }
  
  private int fill() throws IOException {
    if (this.closed)
      throw new IOException("The stream is closed"); 
    int length = this.inputStream.read(this.buf.array());
    if (length > 0) {
      this.buf.limit(length);
      count(this.buf.limit());
      this.inf.setInput(this.buf.array(), 0, this.buf.limit());
    } 
    return length;
  }
  
  private boolean findEocdRecord() {
    int currentByte = -1;
    boolean skipReadCall = false;
    while (skipReadCall || (currentByte = readOneByte()) > -1) {
      skipReadCall = false;
      if (!isFirstByteOfEocdSig(currentByte))
        continue; 
      currentByte = readOneByte();
      if (currentByte != ZipArchiveOutputStream.EOCD_SIG[1]) {
        if (currentByte == -1)
          break; 
        skipReadCall = isFirstByteOfEocdSig(currentByte);
        continue;
      } 
      currentByte = readOneByte();
      if (currentByte != ZipArchiveOutputStream.EOCD_SIG[2]) {
        if (currentByte == -1)
          break; 
        skipReadCall = isFirstByteOfEocdSig(currentByte);
        continue;
      } 
      currentByte = readOneByte();
      if (currentByte == -1)
        break; 
      if (currentByte == ZipArchiveOutputStream.EOCD_SIG[3])
        return true; 
      skipReadCall = isFirstByteOfEocdSig(currentByte);
    } 
    return false;
  }
  
  private long getBytesInflated() {
    long inB = this.inf.getBytesRead();
    if (CurrentEntry.access$200(this.current) >= 4294967296L)
      while (inB + 4294967296L <= CurrentEntry.access$200(this.current))
        inB += 4294967296L;  
    return inB;
  }
  
  public long getCompressedCount() {
    int method = CurrentEntry.access$400(this.current).getMethod();
    if (method == 0)
      return CurrentEntry.access$500(this.current); 
    if (method == 8)
      return getBytesInflated(); 
    if (method == ZipMethod.UNSHRINKING.getCode() || method == ZipMethod.IMPLODING
      .getCode() || method == ZipMethod.ENHANCED_DEFLATED
      .getCode() || method == ZipMethod.BZIP2
      .getCode())
      return ((InputStreamStatistics)CurrentEntry.access$700(this.current)).getCompressedCount(); 
    return -1L;
  }
  
  public ArchiveEntry getNextEntry() throws IOException { return getNextZipEntry(); }
  
  public ZipArchiveEntry getNextZipEntry() throws IOException {
    this.uncompressedCount = 0L;
    boolean firstEntry = true;
    if (this.closed || this.hitCentralDirectory)
      return null; 
    if (this.current != null) {
      closeEntry();
      firstEntry = false;
    } 
    long currentHeaderOffset = getBytesRead();
    try {
      if (firstEntry) {
        readFirstLocalFileHeader();
      } else {
        readFully(this.lfhBuf);
      } 
    } catch (EOFException e) {
      return null;
    } 
    ZipLong sig = new ZipLong(this.lfhBuf);
    if (!sig.equals(ZipLong.LFH_SIG)) {
      if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG) || isApkSigningBlock(this.lfhBuf)) {
        this.hitCentralDirectory = true;
        skipRemainderOfArchive();
        return null;
      } 
      throw new ZipException(String.format("Unexpected record signature: 0x%x", new Object[] { Long.valueOf(sig.getValue()) }));
    } 
    int off = 4;
    this.current = new CurrentEntry(null);
    int versionMadeBy = ZipShort.getValue(this.lfhBuf, off);
    off += 2;
    CurrentEntry.access$400(this.current).setPlatform(versionMadeBy >> 8 & 0xF);
    GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(this.lfhBuf, off);
    boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();
    ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : this.zipEncoding;
    CurrentEntry.access$602(this.current, gpFlag.usesDataDescriptor());
    CurrentEntry.access$400(this.current).setGeneralPurposeBit(gpFlag);
    off += 2;
    CurrentEntry.access$400(this.current).setMethod(ZipShort.getValue(this.lfhBuf, off));
    off += 2;
    long time = ZipUtil.dosToJavaTime(ZipLong.getValue(this.lfhBuf, off));
    CurrentEntry.access$400(this.current).setTime(time);
    off += 4;
    ZipLong size = null, cSize = null;
    if (!CurrentEntry.access$600(this.current)) {
      CurrentEntry.access$400(this.current).setCrc(ZipLong.getValue(this.lfhBuf, off));
      off += 4;
      cSize = new ZipLong(this.lfhBuf, off);
      off += 4;
      size = new ZipLong(this.lfhBuf, off);
      off += 4;
    } else {
      off += 12;
    } 
    int fileNameLen = ZipShort.getValue(this.lfhBuf, off);
    off += 2;
    int extraLen = ZipShort.getValue(this.lfhBuf, off);
    off += 2;
    byte[] fileName = readRange(fileNameLen);
    CurrentEntry.access$400(this.current).setName(entryEncoding.decode(fileName), fileName);
    if (hasUTF8Flag)
      CurrentEntry.access$400(this.current).setNameSource(ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG); 
    byte[] extraData = readRange(extraLen);
    try {
      CurrentEntry.access$400(this.current).setExtra(extraData);
    } catch (RuntimeException ex) {
      ZipException z = new ZipException("Invalid extra data in entry " + CurrentEntry.access$400(this.current).getName());
      z.initCause(ex);
      throw z;
    } 
    if (!hasUTF8Flag && this.useUnicodeExtraFields)
      ZipUtil.setNameAndCommentFromExtraFields(CurrentEntry.access$400(this.current), fileName, null); 
    processZip64Extra(size, cSize);
    CurrentEntry.access$400(this.current).setLocalHeaderOffset(currentHeaderOffset);
    CurrentEntry.access$400(this.current).setDataOffset(getBytesRead());
    CurrentEntry.access$400(this.current).setStreamContiguous(true);
    ZipMethod m = ZipMethod.getMethodByCode(CurrentEntry.access$400(this.current).getMethod());
    if (CurrentEntry.access$400(this.current).getCompressedSize() != -1L) {
      if (ZipUtil.canHandleEntryData(CurrentEntry.access$400(this.current)) && m != ZipMethod.STORED && m != ZipMethod.DEFLATED) {
        BoundedInputStream boundedInputStream = new BoundedInputStream(this, this.inputStream, CurrentEntry.access$400(this.current).getCompressedSize());
        switch (null.$SwitchMap$org$apache$commons$compress$archivers$zip$ZipMethod[m.ordinal()]) {
          case 1:
            CurrentEntry.access$902(this.current, new UnshrinkingInputStream(boundedInputStream));
            break;
          case 2:
            try {
              CurrentEntry.access$902(this.current, new ExplodingInputStream(
                    CurrentEntry.access$400(this.current).getGeneralPurposeBit().getSlidingDictionarySize(), 
                    CurrentEntry.access$400(this.current).getGeneralPurposeBit().getNumberOfShannonFanoTrees(), boundedInputStream));
            } catch (IllegalArgumentException ex) {
              throw new IOException("bad IMPLODE data", ex);
            } 
            break;
          case 3:
            CurrentEntry.access$902(this.current, new BZip2CompressorInputStream(boundedInputStream));
            break;
          case 4:
            CurrentEntry.access$902(this.current, new Deflate64CompressorInputStream(boundedInputStream));
            break;
        } 
      } 
    } else if (m == ZipMethod.ENHANCED_DEFLATED) {
      CurrentEntry.access$902(this.current, new Deflate64CompressorInputStream(this.inputStream));
    } 
    this.entriesRead++;
    return CurrentEntry.access$400(this.current);
  }
  
  public long getUncompressedCount() { return this.uncompressedCount; }
  
  private boolean isApkSigningBlock(byte[] suspectLocalFileHeader) throws IOException {
    BigInteger len = ZipEightByteInteger.getValue(suspectLocalFileHeader);
    BigInteger toSkip = len.add(BigInteger.valueOf((8 - suspectLocalFileHeader.length) - APK_SIGNING_BLOCK_MAGIC.length));
    byte[] magic = new byte[APK_SIGNING_BLOCK_MAGIC.length];
    try {
      if (toSkip.signum() < 0) {
        int off = suspectLocalFileHeader.length + toSkip.intValue();
        if (off < 8)
          return false; 
        int bytesInBuffer = Math.abs(toSkip.intValue());
        System.arraycopy(suspectLocalFileHeader, off, magic, 0, Math.min(bytesInBuffer, magic.length));
        if (bytesInBuffer < magic.length)
          readFully(magic, bytesInBuffer); 
      } else {
        while (toSkip.compareTo(LONG_MAX) > 0) {
          realSkip(Float.MAX_VALUE);
          toSkip = toSkip.add(LONG_MAX.negate());
        } 
        realSkip(toSkip.longValue());
        readFully(magic);
      } 
    } catch (EOFException ex) {
      return false;
    } 
    return Arrays.equals(magic, APK_SIGNING_BLOCK_MAGIC);
  }
  
  private boolean isFirstByteOfEocdSig(int b) { return (b == ZipArchiveOutputStream.EOCD_SIG[0]); }
  
  private void processZip64Extra(ZipLong size, ZipLong cSize) throws ZipException {
    ZipExtraField extra = CurrentEntry.access$400(this.current).getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);
    if (extra != null && !(extra instanceof Zip64ExtendedInformationExtraField))
      throw new ZipException("archive contains unparseable zip64 extra field"); 
    Zip64ExtendedInformationExtraField z64 = (Zip64ExtendedInformationExtraField)extra;
    CurrentEntry.access$1002(this.current, (z64 != null));
    if (!CurrentEntry.access$600(this.current))
      if (z64 != null && (ZipLong.ZIP64_MAGIC
        .equals(cSize) || ZipLong.ZIP64_MAGIC.equals(size))) {
        if (z64.getCompressedSize() == null || z64.getSize() == null)
          throw new ZipException("archive contains corrupted zip64 extra field"); 
        long s = z64.getCompressedSize().getLongValue();
        if (s < 0L)
          throw new ZipException("broken archive, entry with negative compressed size"); 
        CurrentEntry.access$400(this.current).setCompressedSize(s);
        s = z64.getSize().getLongValue();
        if (s < 0L)
          throw new ZipException("broken archive, entry with negative size"); 
        CurrentEntry.access$400(this.current).setSize(s);
      } else if (cSize != null && size != null) {
        if (cSize.getValue() < 0L)
          throw new ZipException("broken archive, entry with negative compressed size"); 
        CurrentEntry.access$400(this.current).setCompressedSize(cSize.getValue());
        if (size.getValue() < 0L)
          throw new ZipException("broken archive, entry with negative size"); 
        CurrentEntry.access$400(this.current).setSize(size.getValue());
      }  
  }
  
  private void pushback(byte[] buf, int offset, int length) throws IOException {
    ((PushbackInputStream)this.inputStream).unread(buf, offset, length);
    pushedBackBytes(length);
  }
  
  public int read(byte[] buffer, int offset, int length) throws IOException {
    int read;
    if (length == 0)
      return 0; 
    if (this.closed)
      throw new IOException("The stream is closed"); 
    if (this.current == null)
      return -1; 
    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length)
      throw new ArrayIndexOutOfBoundsException(); 
    ZipUtil.checkRequestedFeatures(CurrentEntry.access$400(this.current));
    if (!supportsDataDescriptorFor(CurrentEntry.access$400(this.current)))
      throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, 
          CurrentEntry.access$400(this.current)); 
    if (!supportsCompressedSizeFor(CurrentEntry.access$400(this.current)))
      throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE, 
          CurrentEntry.access$400(this.current)); 
    if (CurrentEntry.access$400(this.current).getMethod() == 0) {
      read = readStored(buffer, offset, length);
    } else if (CurrentEntry.access$400(this.current).getMethod() == 8) {
      read = readDeflated(buffer, offset, length);
    } else if (CurrentEntry.access$400(this.current).getMethod() == ZipMethod.UNSHRINKING.getCode() || 
      CurrentEntry.access$400(this.current).getMethod() == ZipMethod.IMPLODING.getCode() || 
      CurrentEntry.access$400(this.current).getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || 
      CurrentEntry.access$400(this.current).getMethod() == ZipMethod.BZIP2.getCode()) {
      read = CurrentEntry.access$900(this.current).read(buffer, offset, length);
    } else {
      throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(CurrentEntry.access$400(this.current).getMethod()), 
          CurrentEntry.access$400(this.current));
    } 
    if (read >= 0) {
      CurrentEntry.access$1100(this.current).update(buffer, offset, read);
      this.uncompressedCount += read;
    } 
    return read;
  }
  
  private void readDataDescriptor() throws IOException {
    readFully(this.wordBuf);
    ZipLong val = new ZipLong(this.wordBuf);
    if (ZipLong.DD_SIG.equals(val)) {
      readFully(this.wordBuf);
      val = new ZipLong(this.wordBuf);
    } 
    CurrentEntry.access$400(this.current).setCrc(val.getValue());
    readFully(this.twoDwordBuf);
    ZipLong potentialSig = new ZipLong(this.twoDwordBuf, 8);
    if (potentialSig.equals(ZipLong.CFH_SIG) || potentialSig.equals(ZipLong.LFH_SIG)) {
      pushback(this.twoDwordBuf, 8, 8);
      long size = ZipLong.getValue(this.twoDwordBuf);
      if (size < 0L)
        throw new ZipException("broken archive, entry with negative compressed size"); 
      CurrentEntry.access$400(this.current).setCompressedSize(size);
      size = ZipLong.getValue(this.twoDwordBuf, 4);
      if (size < 0L)
        throw new ZipException("broken archive, entry with negative size"); 
      CurrentEntry.access$400(this.current).setSize(size);
    } else {
      long size = ZipEightByteInteger.getLongValue(this.twoDwordBuf);
      if (size < 0L)
        throw new ZipException("broken archive, entry with negative compressed size"); 
      CurrentEntry.access$400(this.current).setCompressedSize(size);
      size = ZipEightByteInteger.getLongValue(this.twoDwordBuf, 8);
      if (size < 0L)
        throw new ZipException("broken archive, entry with negative size"); 
      CurrentEntry.access$400(this.current).setSize(size);
    } 
  }
  
  private int readDeflated(byte[] buffer, int offset, int length) throws IOException {
    int read = readFromInflater(buffer, offset, length);
    if (read <= 0) {
      if (this.inf.finished())
        return -1; 
      if (this.inf.needsDictionary())
        throw new ZipException("This archive needs a preset dictionary which is not supported by Commons Compress."); 
      if (read == -1)
        throw new IOException("Truncated ZIP file"); 
    } 
    return read;
  }
  
  private void readFirstLocalFileHeader() throws IOException {
    readFully(this.lfhBuf);
    ZipLong sig = new ZipLong(this.lfhBuf);
    if (!this.skipSplitSig && sig.equals(ZipLong.DD_SIG))
      throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING); 
    if (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER) || sig.equals(ZipLong.DD_SIG)) {
      byte[] missedLfhBytes = new byte[4];
      readFully(missedLfhBytes);
      System.arraycopy(this.lfhBuf, 4, this.lfhBuf, 0, 26);
      System.arraycopy(missedLfhBytes, 0, this.lfhBuf, 26, 4);
    } 
  }
  
  private int readFromInflater(byte[] buffer, int offset, int length) throws IOException {
    int read = 0;
    do {
      if (this.inf.needsInput()) {
        int l = fill();
        if (l > 0) {
          CurrentEntry.access$214(this.current, this.buf.limit());
        } else {
          if (l == -1)
            return -1; 
          break;
        } 
      } 
      try {
        read = this.inf.inflate(buffer, offset, length);
      } catch (DataFormatException e) {
        throw (IOException)(new ZipException(e.getMessage())).initCause(e);
      } 
    } while (read == 0 && this.inf.needsInput());
    return read;
  }
  
  private void readFully(byte[] b) throws IOException { readFully(b, 0); }
  
  private void readFully(byte[] b, int off) throws IOException {
    int len = b.length - off;
    int count = IOUtils.readFully(this.inputStream, b, off, len);
    count(count);
    if (count < len)
      throw new EOFException(); 
  }
  
  private int readOneByte() throws IOException {
    int b = this.inputStream.read();
    if (b != -1)
      count(1); 
    return b;
  }
  
  private byte[] readRange(int len) throws IOException {
    byte[] ret = IOUtils.readRange(this.inputStream, len);
    count(ret.length);
    if (ret.length < len)
      throw new EOFException(); 
    return ret;
  }
  
  private int readStored(byte[] buffer, int offset, int length) throws IOException {
    if (CurrentEntry.access$600(this.current)) {
      if (this.lastStoredEntry == null)
        readStoredEntry(); 
      return this.lastStoredEntry.read(buffer, offset, length);
    } 
    long csize = CurrentEntry.access$400(this.current).getSize();
    if (CurrentEntry.access$500(this.current) >= csize)
      return -1; 
    if (this.buf.position() >= this.buf.limit()) {
      this.buf.position(0);
      int l = this.inputStream.read(this.buf.array());
      if (l == -1) {
        this.buf.limit(0);
        throw new IOException("Truncated ZIP file");
      } 
      this.buf.limit(l);
      count(l);
      CurrentEntry.access$214(this.current, l);
    } 
    int toRead = Math.min(this.buf.remaining(), length);
    if (csize - CurrentEntry.access$500(this.current) < toRead)
      toRead = (int)(csize - CurrentEntry.access$500(this.current)); 
    this.buf.get(buffer, offset, toRead);
    CurrentEntry.access$514(this.current, toRead);
    return toRead;
  }
  
  private void readStoredEntry() throws IOException {
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    int off = 0;
    boolean done = false;
    int ddLen = CurrentEntry.access$1000(this.current) ? 20 : 12;
    while (!done) {
      int r = this.inputStream.read(this.buf.array(), off, 512 - off);
      if (r <= 0)
        throw new IOException("Truncated ZIP file"); 
      if (r + off < 4) {
        off += r;
        continue;
      } 
      done = bufferContainsSignature(bos, off, r, ddLen);
      if (!done)
        off = cacheBytesRead(bos, off, r, ddLen); 
    } 
    if (CurrentEntry.access$400(this.current).getCompressedSize() != CurrentEntry.access$400(this.current).getSize())
      throw new ZipException("compressed and uncompressed size don't match while reading a stored entry using data descriptor. Either the archive is broken or it can not be read using ZipArchiveInputStream and you must use ZipFile. A common cause for this is a ZIP archive containing a ZIP archive. See http://commons.apache.org/proper/commons-compress/zip.html#ZipArchiveInputStream_vs_ZipFile"); 
    byte[] b = bos.toByteArray();
    if (b.length != CurrentEntry.access$400(this.current).getSize())
      throw new ZipException("actual and claimed size don't match while reading a stored entry using data descriptor. Either the archive is broken or it can not be read using ZipArchiveInputStream and you must use ZipFile. A common cause for this is a ZIP archive containing a ZIP archive. See http://commons.apache.org/proper/commons-compress/zip.html#ZipArchiveInputStream_vs_ZipFile"); 
    this.lastStoredEntry = new ByteArrayInputStream(b);
  }
  
  private void realSkip(long value) throws IOException {
    if (value >= 0L) {
      long skipped = 0L;
      while (skipped < value) {
        long rem = value - skipped;
        int x = this.inputStream.read(this.skipBuf, 0, (int)((this.skipBuf.length > rem) ? rem : this.skipBuf.length));
        if (x == -1)
          return; 
        count(x);
        skipped += x;
      } 
      return;
    } 
    throw new IllegalArgumentException();
  }
  
  public long skip(long value) throws IOException {
    if (value >= 0L) {
      long skipped = 0L;
      while (skipped < value) {
        long rem = value - skipped;
        int x = read(this.skipBuf, 0, (int)((this.skipBuf.length > rem) ? rem : this.skipBuf.length));
        if (x == -1)
          return skipped; 
        skipped += x;
      } 
      return skipped;
    } 
    throw new IllegalArgumentException();
  }
  
  private void skipRemainderOfArchive() throws IOException {
    if (this.entriesRead > 0) {
      realSkip(this.entriesRead * 46L - 30L);
      boolean foundEocd = findEocdRecord();
      if (foundEocd) {
        realSkip(16L);
        readFully(this.shortBuf);
        int commentLen = ZipShort.getValue(this.shortBuf);
        if (commentLen >= 0) {
          realSkip(commentLen);
          return;
        } 
      } 
    } 
    throw new IOException("Truncated ZIP file");
  }
  
  private boolean supportsCompressedSizeFor(ZipArchiveEntry entry) {
    return (entry.getCompressedSize() != -1L || entry
      .getMethod() == 8 || entry
      .getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || (entry
      .getGeneralPurposeBit().usesDataDescriptor() && this.allowStoredEntriesWithDataDescriptor && entry
      
      .getMethod() == 0));
  }
  
  private boolean supportsDataDescriptorFor(ZipArchiveEntry entry) {
    return (!entry.getGeneralPurposeBit().usesDataDescriptor() || (this.allowStoredEntriesWithDataDescriptor && entry
      .getMethod() == 0) || entry
      .getMethod() == 8 || entry
      .getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode());
  }
}
