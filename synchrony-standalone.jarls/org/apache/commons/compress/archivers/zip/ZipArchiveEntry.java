package org.apache.commons.compress.archivers.zip;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.attribute.FileTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import org.apache.commons.compress.archivers.ArchiveEntry;
import org.apache.commons.compress.archivers.EntryStreamOffsets;
import org.apache.commons.compress.utils.ByteUtils;
import org.apache.commons.compress.utils.TimeUtils;

public class ZipArchiveEntry extends ZipEntry implements ArchiveEntry, EntryStreamOffsets {
  static final ZipArchiveEntry[] EMPTY_ARRAY = new ZipArchiveEntry[0];
  
  static LinkedList<ZipArchiveEntry> EMPTY_LINKED_LIST = new LinkedList();
  
  public static final int PLATFORM_UNIX = 3;
  
  public static final int PLATFORM_FAT = 0;
  
  public static final int CRC_UNKNOWN = -1;
  
  private static final int SHORT_MASK = 65535;
  
  private static final int SHORT_SHIFT = 16;
  
  private static boolean canConvertToInfoZipExtendedTimestamp(FileTime lastModifiedTime, FileTime lastAccessTime, FileTime creationTime) {
    return (TimeUtils.isUnixTime(lastModifiedTime) && 
      TimeUtils.isUnixTime(lastAccessTime) && 
      TimeUtils.isUnixTime(creationTime));
  }
  
  private int method = -1;
  
  private long size = -1L;
  
  private int internalAttributes;
  
  private int versionRequired;
  
  private int versionMadeBy;
  
  private int platform = 0;
  
  private int rawFlag;
  
  private long externalAttributes;
  
  private int alignment;
  
  private ZipExtraField[] extraFields;
  
  private UnparseableExtraFieldData unparseableExtra;
  
  private String name;
  
  private byte[] rawName;
  
  private GeneralPurposeBit gpb = new GeneralPurposeBit();
  
  private long localHeaderOffset = -1L;
  
  private long dataOffset = -1L;
  
  private boolean isStreamContiguous;
  
  private NameSource nameSource = NameSource.NAME;
  
  private CommentSource commentSource = CommentSource.COMMENT;
  
  private long diskNumberStart;
  
  private boolean lastModifiedDateSet = false;
  
  private long time = -1L;
  
  protected ZipArchiveEntry() { this(""); }
  
  public ZipArchiveEntry(File inputFile, String entryName) {
    this((inputFile.isDirectory() && !entryName.endsWith("/")) ? (
        entryName + "/") : entryName);
    try {
      setAttributes(inputFile.toPath(), new LinkOption[0]);
    } catch (IOException e) {
      if (inputFile.isFile())
        setSize(inputFile.length()); 
      setTime(inputFile.lastModified());
    } 
  }
  
  public ZipArchiveEntry(ZipEntry entry) throws ZipException {
    super(entry);
    setName(entry.getName());
    byte[] extra = entry.getExtra();
    if (extra != null) {
      setExtraFields(ExtraFieldUtils.parse(extra, true, ExtraFieldParsingMode.BEST_EFFORT));
    } else {
      setExtra();
    } 
    setMethod(entry.getMethod());
    this.size = entry.getSize();
  }
  
  public ZipArchiveEntry(Path inputPath, String entryName, LinkOption... options) throws IOException {
    this((Files.isDirectory(inputPath, options) && !entryName.endsWith("/")) ? (
        entryName + "/") : entryName);
    setAttributes(inputPath, options);
  }
  
  public ZipArchiveEntry(String name) {
    super(name);
    setName(name);
  }
  
  public ZipArchiveEntry(ZipArchiveEntry entry) throws ZipException {
    this(entry);
    setInternalAttributes(entry.getInternalAttributes());
    setExternalAttributes(entry.getExternalAttributes());
    setExtraFields(entry.getAllExtraFieldsNoCopy());
    setPlatform(entry.getPlatform());
    GeneralPurposeBit other = entry.getGeneralPurposeBit();
    setGeneralPurposeBit((other == null) ? null : 
        (GeneralPurposeBit)other.clone());
  }
  
  public void addAsFirstExtraField(ZipExtraField ze) {
    if (ze instanceof UnparseableExtraFieldData) {
      this.unparseableExtra = (UnparseableExtraFieldData)ze;
    } else {
      if (getExtraField(ze.getHeaderId()) != null)
        internalRemoveExtraField(ze.getHeaderId()); 
      ZipExtraField[] copy = this.extraFields;
      int newLen = (this.extraFields != null) ? (this.extraFields.length + 1) : 1;
      this.extraFields = new ZipExtraField[newLen];
      this.extraFields[0] = ze;
      if (copy != null)
        System.arraycopy(copy, 0, this.extraFields, 1, this.extraFields.length - 1); 
    } 
    setExtra();
  }
  
  public void addExtraField(ZipExtraField ze) {
    internalAddExtraField(ze);
    setExtra();
  }
  
  private void addInfoZipExtendedTimestamp(FileTime lastModifiedTime, FileTime lastAccessTime, FileTime creationTime) {
    X5455_ExtendedTimestamp infoZipTimestamp = new X5455_ExtendedTimestamp();
    if (lastModifiedTime != null)
      infoZipTimestamp.setModifyFileTime(lastModifiedTime); 
    if (lastAccessTime != null)
      infoZipTimestamp.setAccessFileTime(lastAccessTime); 
    if (creationTime != null)
      infoZipTimestamp.setCreateFileTime(creationTime); 
    internalAddExtraField(infoZipTimestamp);
  }
  
  private void addNTFSTimestamp(FileTime lastModifiedTime, FileTime lastAccessTime, FileTime creationTime) {
    X000A_NTFS ntfsTimestamp = new X000A_NTFS();
    if (lastModifiedTime != null)
      ntfsTimestamp.setModifyFileTime(lastModifiedTime); 
    if (lastAccessTime != null)
      ntfsTimestamp.setAccessFileTime(lastAccessTime); 
    if (creationTime != null)
      ntfsTimestamp.setCreateFileTime(creationTime); 
    internalAddExtraField(ntfsTimestamp);
  }
  
  public Object clone() {
    ZipArchiveEntry e = (ZipArchiveEntry)super.clone();
    e.setInternalAttributes(getInternalAttributes());
    e.setExternalAttributes(getExternalAttributes());
    e.setExtraFields(getAllExtraFieldsNoCopy());
    return e;
  }
  
  private ZipExtraField[] copyOf(ZipExtraField[] src, int length) { return (ZipExtraField[])Arrays.copyOf(src, length); }
  
  public boolean equals(Object obj) {
    if (this == obj)
      return true; 
    if (obj == null || getClass() != obj.getClass())
      return false; 
    ZipArchiveEntry other = (ZipArchiveEntry)obj;
    String myName = getName();
    String otherName = other.getName();
    if (!Objects.equals(myName, otherName))
      return false; 
    String myComment = getComment();
    String otherComment = other.getComment();
    if (myComment == null)
      myComment = ""; 
    if (otherComment == null)
      otherComment = ""; 
    return (Objects.equals(getLastModifiedTime(), other.getLastModifiedTime()) && 
      Objects.equals(getLastAccessTime(), other.getLastAccessTime()) && 
      Objects.equals(getCreationTime(), other.getCreationTime()) && myComment
      .equals(otherComment) && 
      getInternalAttributes() == other.getInternalAttributes() && 
      getPlatform() == other.getPlatform() && 
      getExternalAttributes() == other.getExternalAttributes() && 
      getMethod() == other.getMethod() && 
      getSize() == other.getSize() && 
      getCrc() == other.getCrc() && 
      getCompressedSize() == other.getCompressedSize() && 
      Arrays.equals(getCentralDirectoryExtra(), other
        .getCentralDirectoryExtra()) && 
      Arrays.equals(getLocalFileDataExtra(), other
        .getLocalFileDataExtra()) && this.localHeaderOffset == other.localHeaderOffset && this.dataOffset == other.dataOffset && this.gpb

      
      .equals(other.gpb));
  }
  
  private ZipExtraField findMatching(ZipShort headerId, List<ZipExtraField> fs) { return (ZipExtraField)fs.stream().filter(f -> headerId.equals(f.getHeaderId())).findFirst().orElse(null); }
  
  private ZipExtraField findUnparseable(List<ZipExtraField> fs) { Objects.requireNonNull(UnparseableExtraFieldData.class);
    return (ZipExtraField)fs.stream().filter(UnparseableExtraFieldData.class::isInstance).findFirst().orElse(null); }
  
  protected int getAlignment() { return this.alignment; }
  
  private ZipExtraField[] getAllExtraFields() {
    ZipExtraField[] allExtraFieldsNoCopy = getAllExtraFieldsNoCopy();
    return (allExtraFieldsNoCopy == this.extraFields) ? copyOf(allExtraFieldsNoCopy, allExtraFieldsNoCopy.length) : 
      allExtraFieldsNoCopy;
  }
  
  private ZipExtraField[] getAllExtraFieldsNoCopy() {
    if (this.extraFields == null)
      return getUnparseableOnly(); 
    return (this.unparseableExtra != null) ? getMergedFields() : this.extraFields;
  }
  
  public byte[] getCentralDirectoryExtra() { return ExtraFieldUtils.mergeCentralDirectoryData(getAllExtraFieldsNoCopy()); }
  
  public CommentSource getCommentSource() { return this.commentSource; }
  
  public long getDataOffset() { return this.dataOffset; }
  
  public long getDiskNumberStart() { return this.diskNumberStart; }
  
  public long getExternalAttributes() { return this.externalAttributes; }
  
  public ZipExtraField getExtraField(ZipShort type) {
    if (this.extraFields != null)
      for (ZipExtraField extraField : this.extraFields) {
        if (type.equals(extraField.getHeaderId()))
          return extraField; 
      }  
    return null;
  }
  
  public ZipExtraField[] getExtraFields() { return getParseableExtraFields(); }
  
  public ZipExtraField[] getExtraFields(boolean includeUnparseable) {
    return includeUnparseable ? 
      getAllExtraFields() : 
      getParseableExtraFields();
  }
  
  public ZipExtraField[] getExtraFields(ExtraFieldParsingBehavior parsingBehavior) throws ZipException {
    if (parsingBehavior == ExtraFieldParsingMode.BEST_EFFORT)
      return getExtraFields(true); 
    if (parsingBehavior == ExtraFieldParsingMode.ONLY_PARSEABLE_LENIENT)
      return getExtraFields(false); 
    byte[] local = getExtra();
    List<ZipExtraField> localFields = new ArrayList<ZipExtraField>(Arrays.asList(ExtraFieldUtils.parse(local, true, parsingBehavior)));
    byte[] central = getCentralDirectoryExtra();
    List<ZipExtraField> centralFields = new ArrayList<ZipExtraField>(Arrays.asList(ExtraFieldUtils.parse(central, false, parsingBehavior)));
    List<ZipExtraField> merged = new ArrayList<ZipExtraField>();
    for (ZipExtraField l : localFields) {
      ZipExtraField c;
      if (l instanceof UnparseableExtraFieldData) {
        c = findUnparseable(centralFields);
      } else {
        c = findMatching(l.getHeaderId(), centralFields);
      } 
      if (c != null) {
        byte[] cd = c.getCentralDirectoryData();
        if (cd != null && cd.length > 0)
          l.parseFromCentralDirectoryData(cd, 0, cd.length); 
        centralFields.remove(c);
      } 
      merged.add(l);
    } 
    merged.addAll(centralFields);
    return (ZipExtraField[])merged.toArray(ExtraFieldUtils.EMPTY_ZIP_EXTRA_FIELD_ARRAY);
  }
  
  public GeneralPurposeBit getGeneralPurposeBit() { return this.gpb; }
  
  public int getInternalAttributes() { return this.internalAttributes; }
  
  public Date getLastModifiedDate() { return new Date(getTime()); }
  
  public byte[] getLocalFileDataExtra() {
    byte[] extra = getExtra();
    return (extra != null) ? extra : ByteUtils.EMPTY_BYTE_ARRAY;
  }
  
  public long getLocalHeaderOffset() { return this.localHeaderOffset; }
  
  private ZipExtraField[] getMergedFields() {
    ZipExtraField[] zipExtraFields = copyOf(this.extraFields, this.extraFields.length + 1);
    zipExtraFields[this.extraFields.length] = this.unparseableExtra;
    return zipExtraFields;
  }
  
  public int getMethod() { return this.method; }
  
  public String getName() { return (this.name == null) ? super.getName() : this.name; }
  
  public NameSource getNameSource() { return this.nameSource; }
  
  private ZipExtraField[] getParseableExtraFields() {
    ZipExtraField[] parseableExtraFields = getParseableExtraFieldsNoCopy();
    return (parseableExtraFields == this.extraFields) ? copyOf(parseableExtraFields, parseableExtraFields.length) : 
      parseableExtraFields;
  }
  
  private ZipExtraField[] getParseableExtraFieldsNoCopy() {
    if (this.extraFields == null)
      return ExtraFieldUtils.EMPTY_ZIP_EXTRA_FIELD_ARRAY; 
    return this.extraFields;
  }
  
  public int getPlatform() { return this.platform; }
  
  public int getRawFlag() { return this.rawFlag; }
  
  public byte[] getRawName() {
    if (this.rawName != null)
      return Arrays.copyOf(this.rawName, this.rawName.length); 
    return null;
  }
  
  public long getSize() { return this.size; }
  
  public long getTime() {
    if (this.lastModifiedDateSet)
      return getLastModifiedTime().toMillis(); 
    return (this.time != -1L) ? this.time : super.getTime();
  }
  
  public int getUnixMode() {
    return (this.platform != 3) ? 0 : 
      (int)(getExternalAttributes() >> 16 & 0xFFFFL);
  }
  
  public UnparseableExtraFieldData getUnparseableExtraFieldData() { return this.unparseableExtra; }
  
  private ZipExtraField[] getUnparseableOnly() { new ZipExtraField[1][0] = this.unparseableExtra;
    return (this.unparseableExtra == null) ? ExtraFieldUtils.EMPTY_ZIP_EXTRA_FIELD_ARRAY : new ZipExtraField[1]; }
  
  public int getVersionMadeBy() { return this.versionMadeBy; }
  
  public int getVersionRequired() { return this.versionRequired; }
  
  public int hashCode() { return getName().hashCode(); }
  
  private void internalAddExtraField(ZipExtraField ze) {
    if (ze instanceof UnparseableExtraFieldData) {
      this.unparseableExtra = (UnparseableExtraFieldData)ze;
    } else if (this.extraFields == null) {
      this.extraFields = new ZipExtraField[] { ze };
    } else {
      if (getExtraField(ze.getHeaderId()) != null)
        internalRemoveExtraField(ze.getHeaderId()); 
      ZipExtraField[] zipExtraFields = copyOf(this.extraFields, this.extraFields.length + 1);
      zipExtraFields[zipExtraFields.length - 1] = ze;
      this.extraFields = zipExtraFields;
    } 
  }
  
  private void internalRemoveExtraField(ZipShort type) {
    if (this.extraFields == null)
      return; 
    List<ZipExtraField> newResult = new ArrayList<ZipExtraField>();
    for (ZipExtraField extraField : this.extraFields) {
      if (!type.equals(extraField.getHeaderId()))
        newResult.add(extraField); 
    } 
    if (this.extraFields.length == newResult.size())
      return; 
    this.extraFields = (ZipExtraField[])newResult.toArray(ExtraFieldUtils.EMPTY_ZIP_EXTRA_FIELD_ARRAY);
  }
  
  private void internalSetLastModifiedTime(FileTime time) {
    super.setLastModifiedTime(time);
    this.time = time.toMillis();
    this.lastModifiedDateSet = true;
  }
  
  public boolean isDirectory() { return getName().endsWith("/"); }
  
  public boolean isStreamContiguous() { return this.isStreamContiguous; }
  
  public boolean isUnixSymlink() { return ((getUnixMode() & 0xF000) == 40960); }
  
  private void mergeExtraFields(ZipExtraField[] f, boolean local) {
    if (this.extraFields == null) {
      setExtraFields(f);
    } else {
      for (ZipExtraField element : f) {
        ZipExtraField existing;
        if (element instanceof UnparseableExtraFieldData) {
          existing = this.unparseableExtra;
        } else {
          existing = getExtraField(element.getHeaderId());
        } 
        if (existing == null) {
          internalAddExtraField(element);
        } else {
          byte[] b = local ? element.getLocalFileDataData() : element.getCentralDirectoryData();
          try {
            if (local) {
              existing.parseFromLocalFileData(b, 0, b.length);
            } else {
              existing.parseFromCentralDirectoryData(b, 0, b.length);
            } 
          } catch (ZipException ex) {
            UnrecognizedExtraField u = new UnrecognizedExtraField();
            u.setHeaderId(existing.getHeaderId());
            if (local) {
              u.setLocalFileDataData(b);
              u.setCentralDirectoryData(existing.getCentralDirectoryData());
            } else {
              u.setLocalFileDataData(existing.getLocalFileDataData());
              u.setCentralDirectoryData(b);
            } 
            internalRemoveExtraField(existing.getHeaderId());
            internalAddExtraField(u);
          } 
        } 
      } 
      setExtra();
    } 
  }
  
  public void removeExtraField(ZipShort type) {
    if (getExtraField(type) == null)
      throw new NoSuchElementException(); 
    internalRemoveExtraField(type);
    setExtra();
  }
  
  public void removeUnparseableExtraFieldData() {
    if (this.unparseableExtra == null)
      throw new NoSuchElementException(); 
    this.unparseableExtra = null;
    setExtra();
  }
  
  private boolean requiresExtraTimeFields() {
    if (getLastAccessTime() != null || getCreationTime() != null)
      return true; 
    return this.lastModifiedDateSet;
  }
  
  public void setAlignment(int alignment) {
    if ((alignment & alignment - 1) != 0 || alignment > 65535)
      throw new IllegalArgumentException("Invalid value for alignment, must be power of two and no bigger than 65535 but is " + alignment); 
    this.alignment = alignment;
  }
  
  private void setAttributes(Path inputPath, LinkOption... options) throws IOException {
    BasicFileAttributes attributes = Files.readAttributes(inputPath, BasicFileAttributes.class, options);
    if (attributes.isRegularFile())
      setSize(attributes.size()); 
    super.setLastModifiedTime(attributes.lastModifiedTime());
    super.setCreationTime(attributes.creationTime());
    super.setLastAccessTime(attributes.lastAccessTime());
    setExtraTimeFields();
  }
  
  public void setCentralDirectoryExtra(byte[] b) {
    try {
      mergeExtraFields(ExtraFieldUtils.parse(b, false, ExtraFieldParsingMode.BEST_EFFORT), false);
    } catch (ZipException e) {
      throw new IllegalArgumentException(e.getMessage(), e);
    } 
  }
  
  public void setCommentSource(CommentSource commentSource) { this.commentSource = commentSource; }
  
  public ZipEntry setCreationTime(FileTime time) {
    super.setCreationTime(time);
    setExtraTimeFields();
    return this;
  }
  
  protected void setDataOffset(long dataOffset) { this.dataOffset = dataOffset; }
  
  public void setDiskNumberStart(long diskNumberStart) { this.diskNumberStart = diskNumberStart; }
  
  public void setExternalAttributes(long value) { this.externalAttributes = value; }
  
  protected void setExtra() {
    super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getAllExtraFieldsNoCopy()));
    updateTimeFieldsFromExtraFields();
  }
  
  public void setExtra(byte[] extra) {
    try {
      mergeExtraFields(ExtraFieldUtils.parse(extra, true, ExtraFieldParsingMode.BEST_EFFORT), true);
    } catch (ZipException e) {
      throw new IllegalArgumentException("Error parsing extra fields for entry: " + 
          getName() + " - " + e.getMessage(), e);
    } 
  }
  
  public void setExtraFields(ZipExtraField[] fields) {
    this.unparseableExtra = null;
    List<ZipExtraField> newFields = new ArrayList<ZipExtraField>();
    if (fields != null)
      for (ZipExtraField field : fields) {
        if (field instanceof UnparseableExtraFieldData) {
          this.unparseableExtra = (UnparseableExtraFieldData)field;
        } else {
          newFields.add(field);
        } 
      }  
    this.extraFields = (ZipExtraField[])newFields.toArray(ExtraFieldUtils.EMPTY_ZIP_EXTRA_FIELD_ARRAY);
    setExtra();
  }
  
  private void setExtraTimeFields() {
    if (getExtraField(X5455_ExtendedTimestamp.HEADER_ID) != null)
      internalRemoveExtraField(X5455_ExtendedTimestamp.HEADER_ID); 
    if (getExtraField(X000A_NTFS.HEADER_ID) != null)
      internalRemoveExtraField(X000A_NTFS.HEADER_ID); 
    if (requiresExtraTimeFields()) {
      FileTime lastModifiedTime = getLastModifiedTime();
      FileTime lastAccessTime = getLastAccessTime();
      FileTime creationTime = getCreationTime();
      if (canConvertToInfoZipExtendedTimestamp(lastModifiedTime, lastAccessTime, creationTime))
        addInfoZipExtendedTimestamp(lastModifiedTime, lastAccessTime, creationTime); 
      addNTFSTimestamp(lastModifiedTime, lastAccessTime, creationTime);
    } 
    setExtra();
  }
  
  public void setGeneralPurposeBit(GeneralPurposeBit b) { this.gpb = b; }
  
  public void setInternalAttributes(int value) { this.internalAttributes = value; }
  
  public ZipEntry setLastAccessTime(FileTime time) {
    super.setLastAccessTime(time);
    setExtraTimeFields();
    return this;
  }
  
  public ZipEntry setLastModifiedTime(FileTime time) {
    internalSetLastModifiedTime(time);
    setExtraTimeFields();
    return this;
  }
  
  protected void setLocalHeaderOffset(long localHeaderOffset) { this.localHeaderOffset = localHeaderOffset; }
  
  public void setMethod(int method) {
    if (method < 0)
      throw new IllegalArgumentException("ZIP compression method can not be negative: " + method); 
    this.method = method;
  }
  
  protected void setName(String name) {
    if (name != null && getPlatform() == 0 && 
      !name.contains("/"))
      name = name.replace('\\', '/'); 
    this.name = name;
  }
  
  protected void setName(String name, byte[] rawName) {
    setName(name);
    this.rawName = rawName;
  }
  
  public void setNameSource(NameSource nameSource) { this.nameSource = nameSource; }
  
  protected void setPlatform(int platform) { this.platform = platform; }
  
  public void setRawFlag(int rawFlag) { this.rawFlag = rawFlag; }
  
  public void setSize(long size) {
    if (size < 0L)
      throw new IllegalArgumentException("Invalid entry size"); 
    this.size = size;
  }
  
  protected void setStreamContiguous(boolean isStreamContiguous) { this.isStreamContiguous = isStreamContiguous; }
  
  public void setTime(FileTime fileTime) { setTime(fileTime.toMillis()); }
  
  public void setTime(long time) {
    if (ZipUtil.isDosTime(time)) {
      super.setTime(time);
      this.time = time;
      this.lastModifiedDateSet = false;
      setExtraTimeFields();
    } else {
      setLastModifiedTime(FileTime.fromMillis(time));
    } 
  }
  
  public void setUnixMode(int mode) {
    setExternalAttributes((mode << 16 | (
        
        ((mode & 0x80) == 0) ? 1 : 0) | (
        
        isDirectory() ? 16 : 0)));
    this.platform = 3;
  }
  
  public void setVersionMadeBy(int versionMadeBy) { this.versionMadeBy = versionMadeBy; }
  
  public void setVersionRequired(int versionRequired) { this.versionRequired = versionRequired; }
  
  private void updateTimeFieldsFromExtraFields() {
    updateTimeFromExtendedTimestampField();
    updateTimeFromNtfsField();
  }
  
  private void updateTimeFromExtendedTimestampField() {
    ZipExtraField extraField = getExtraField(X5455_ExtendedTimestamp.HEADER_ID);
    if (extraField instanceof X5455_ExtendedTimestamp) {
      X5455_ExtendedTimestamp extendedTimestamp = (X5455_ExtendedTimestamp)extraField;
      if (extendedTimestamp.isBit0_modifyTimePresent()) {
        FileTime modifyTime = extendedTimestamp.getModifyFileTime();
        if (modifyTime != null)
          internalSetLastModifiedTime(modifyTime); 
      } 
      if (extendedTimestamp.isBit1_accessTimePresent()) {
        FileTime accessTime = extendedTimestamp.getAccessFileTime();
        if (accessTime != null)
          super.setLastAccessTime(accessTime); 
      } 
      if (extendedTimestamp.isBit2_createTimePresent()) {
        FileTime creationTime = extendedTimestamp.getCreateFileTime();
        if (creationTime != null)
          super.setCreationTime(creationTime); 
      } 
    } 
  }
  
  private void updateTimeFromNtfsField() {
    ZipExtraField extraField = getExtraField(X000A_NTFS.HEADER_ID);
    if (extraField instanceof X000A_NTFS) {
      X000A_NTFS ntfsTimestamp = (X000A_NTFS)extraField;
      FileTime modifyTime = ntfsTimestamp.getModifyFileTime();
      if (modifyTime != null)
        internalSetLastModifiedTime(modifyTime); 
      FileTime accessTime = ntfsTimestamp.getAccessFileTime();
      if (accessTime != null)
        super.setLastAccessTime(accessTime); 
      FileTime creationTime = ntfsTimestamp.getCreateFileTime();
      if (creationTime != null)
        super.setCreationTime(creationTime); 
    } 
  }
}
