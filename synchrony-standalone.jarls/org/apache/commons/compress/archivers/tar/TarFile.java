package org.apache.commons.compress.archivers.tar;

import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.channels.SeekableByteChannel;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import org.apache.commons.compress.archivers.zip.ZipEncoding;
import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;
import org.apache.commons.compress.utils.ArchiveUtils;
import org.apache.commons.compress.utils.BoundedInputStream;
import org.apache.commons.compress.utils.BoundedSeekableByteChannelInputStream;
import org.apache.commons.compress.utils.SeekableInMemoryByteChannel;

public class TarFile implements Closeable {
  private static final int SMALL_BUFFER_SIZE = 256;
  
  private final byte[] smallBuf;
  
  private final SeekableByteChannel archive;
  
  private final ZipEncoding zipEncoding;
  
  private final LinkedList<TarArchiveEntry> entries;
  
  private final int blockSize;
  
  private final boolean lenient;
  
  private final int recordSize;
  
  private final ByteBuffer recordBuffer;
  
  private final List<TarArchiveStructSparse> globalSparseHeaders;
  
  private boolean hasHitEOF;
  
  private TarArchiveEntry currEntry;
  
  private Map<String, String> globalPaxHeaders;
  
  private final Map<String, List<InputStream>> sparseInputStreams;
  
  public TarFile(byte[] content) throws IOException { this(new SeekableInMemoryByteChannel(content)); }
  
  public TarFile(byte[] content, boolean lenient) throws IOException { this(new SeekableInMemoryByteChannel(content), 10240, 512, null, lenient); }
  
  public TarFile(byte[] content, String encoding) throws IOException { this(new SeekableInMemoryByteChannel(content), 10240, 512, encoding, false); }
  
  public TarFile(File archive) throws IOException { this(archive.toPath()); }
  
  public TarFile(File archive, boolean lenient) throws IOException { this(archive.toPath(), lenient); }
  
  public TarFile(File archive, String encoding) throws IOException { this(archive.toPath(), encoding); }
  
  public TarFile(Path archivePath) throws IOException { this(Files.newByteChannel(archivePath, new java.nio.file.OpenOption[0]), 10240, 512, null, false); }
  
  public TarFile(Path archivePath, boolean lenient) throws IOException { this(Files.newByteChannel(archivePath, new java.nio.file.OpenOption[0]), 10240, 512, null, lenient); }
  
  public TarFile(Path archivePath, String encoding) throws IOException { this(Files.newByteChannel(archivePath, new java.nio.file.OpenOption[0]), 10240, 512, encoding, false); }
  
  public TarFile(SeekableByteChannel content) throws IOException { this(content, 10240, 512, null, false); }
  
  public TarFile(SeekableByteChannel archive, int blockSize, int recordSize, String encoding, boolean lenient) throws IOException {
    this.smallBuf = new byte[256];
    this.entries = new LinkedList();
    this.globalSparseHeaders = new ArrayList();
    this.globalPaxHeaders = new HashMap();
    this.sparseInputStreams = new HashMap();
    this.archive = archive;
    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);
    this.recordSize = recordSize;
    this.recordBuffer = ByteBuffer.allocate(this.recordSize);
    this.blockSize = blockSize;
    this.lenient = lenient;
    TarArchiveEntry entry;
    while ((entry = getNextTarEntry()) != null)
      this.entries.add(entry); 
  }
  
  private void applyPaxHeadersToCurrentEntry(Map<String, String> headers, List<TarArchiveStructSparse> sparseHeaders) throws IOException {
    this.currEntry.updateEntryFromPaxHeaders(headers);
    this.currEntry.setSparseHeaders(sparseHeaders);
  }
  
  private void buildSparseInputStreams() throws IOException {
    List<InputStream> streams = new ArrayList<InputStream>();
    List<TarArchiveStructSparse> sparseHeaders = this.currEntry.getOrderedSparseHeaders();
    TarArchiveSparseZeroInputStream tarArchiveSparseZeroInputStream = new TarArchiveSparseZeroInputStream();
    long offset = 0L;
    long numberOfZeroBytesInSparseEntry = 0L;
    for (TarArchiveStructSparse sparseHeader : sparseHeaders) {
      long zeroBlockSize = sparseHeader.getOffset() - offset;
      if (zeroBlockSize < 0L)
        throw new IOException("Corrupted struct sparse detected"); 
      if (zeroBlockSize > 0L) {
        streams.add(new BoundedInputStream(tarArchiveSparseZeroInputStream, zeroBlockSize));
        numberOfZeroBytesInSparseEntry += zeroBlockSize;
      } 
      if (sparseHeader.getNumbytes() > 0L) {
        long start = this.currEntry.getDataOffset() + sparseHeader.getOffset() - numberOfZeroBytesInSparseEntry;
        if (start + sparseHeader.getNumbytes() < start)
          throw new IOException("Unreadable TAR archive, sparse block offset or length too big"); 
        streams.add(new BoundedSeekableByteChannelInputStream(start, sparseHeader.getNumbytes(), this.archive));
      } 
      offset = sparseHeader.getOffset() + sparseHeader.getNumbytes();
    } 
    this.sparseInputStreams.put(this.currEntry.getName(), streams);
  }
  
  public void close() throws IOException { this.archive.close(); }
  
  private void consumeRemainderOfLastBlock() throws IOException {
    long bytesReadOfLastBlock = this.archive.position() % this.blockSize;
    if (bytesReadOfLastBlock > 0L)
      repositionForwardBy(this.blockSize - bytesReadOfLastBlock); 
  }
  
  public List<TarArchiveEntry> getEntries() { return new ArrayList(this.entries); }
  
  public InputStream getInputStream(TarArchiveEntry entry) throws IOException {
    try {
      return new BoundedTarEntryInputStream(this, entry, this.archive);
    } catch (RuntimeException ex) {
      throw new IOException("Corrupted TAR archive. Can't read entry", ex);
    } 
  }
  
  private byte[] getLongNameData() throws IOException {
    ByteArrayOutputStream longName = new ByteArrayOutputStream();
    InputStream in = getInputStream(this.currEntry);
    try {
      int length;
      while ((length = in.read(this.smallBuf)) >= 0)
        longName.write(this.smallBuf, 0, length); 
      if (in != null)
        in.close(); 
    } catch (Throwable throwable) {
      if (in != null)
        try {
          in.close();
        } catch (Throwable throwable1) {
          throwable.addSuppressed(throwable1);
        }  
      throw throwable;
    } 
    getNextTarEntry();
    if (this.currEntry == null)
      return null; 
    byte[] longNameData = longName.toByteArray();
    int length = longNameData.length;
    while (length > 0 && longNameData[length - 1] == 0)
      length--; 
    if (length != longNameData.length)
      longNameData = Arrays.copyOf(longNameData, length); 
    return longNameData;
  }
  
  private TarArchiveEntry getNextTarEntry() throws IOException {
    if (isAtEOF())
      return null; 
    if (this.currEntry != null) {
      repositionForwardTo(this.currEntry.getDataOffset() + this.currEntry.getSize());
      throwExceptionIfPositionIsNotInArchive();
      skipRecordPadding();
    } 
    ByteBuffer headerBuf = getRecord();
    if (null == headerBuf) {
      this.currEntry = null;
      return null;
    } 
    try {
      long position = this.archive.position();
      this.currEntry = new TarArchiveEntry(this.globalPaxHeaders, headerBuf.array(), this.zipEncoding, this.lenient, position);
    } catch (IllegalArgumentException e) {
      throw new IOException("Error detected parsing the header", e);
    } 
    if (this.currEntry.isGNULongLinkEntry()) {
      byte[] longLinkData = getLongNameData();
      if (longLinkData == null)
        return null; 
      this.currEntry.setLinkName(this.zipEncoding.decode(longLinkData));
    } 
    if (this.currEntry.isGNULongNameEntry()) {
      byte[] longNameData = getLongNameData();
      if (longNameData == null)
        return null; 
      String name = this.zipEncoding.decode(longNameData);
      this.currEntry.setName(name);
      if (this.currEntry.isDirectory() && !name.endsWith("/"))
        this.currEntry.setName(name + "/"); 
    } 
    if (this.currEntry.isGlobalPaxHeader())
      readGlobalPaxHeaders(); 
    try {
      if (this.currEntry.isPaxHeader()) {
        paxHeaders();
      } else if (!this.globalPaxHeaders.isEmpty()) {
        applyPaxHeadersToCurrentEntry(this.globalPaxHeaders, this.globalSparseHeaders);
      } 
    } catch (NumberFormatException e) {
      throw new IOException("Error detected parsing the pax header", e);
    } 
    if (this.currEntry.isOldGNUSparse())
      readOldGNUSparse(); 
    return this.currEntry;
  }
  
  private ByteBuffer getRecord() throws IOException {
    ByteBuffer headerBuf = readRecord();
    setAtEOF(isEOFRecord(headerBuf));
    if (isAtEOF() && headerBuf != null) {
      tryToConsumeSecondEOFRecord();
      consumeRemainderOfLastBlock();
      headerBuf = null;
    } 
    return headerBuf;
  }
  
  protected final boolean isAtEOF() { return this.hasHitEOF; }
  
  private boolean isDirectory() { return (this.currEntry != null && this.currEntry.isDirectory()); }
  
  private boolean isEOFRecord(ByteBuffer headerBuf) { return (headerBuf == null || ArchiveUtils.isArrayZero(headerBuf.array(), this.recordSize)); }
  
  private void paxHeaders() throws IOException {
    Map<String, String> headers;
    List<TarArchiveStructSparse> sparseHeaders = new ArrayList<TarArchiveStructSparse>();
    InputStream input = getInputStream(this.currEntry);
    try {
      headers = TarUtils.parsePaxHeaders(input, sparseHeaders, this.globalPaxHeaders, this.currEntry.getSize());
      if (input != null)
        input.close(); 
    } catch (Throwable throwable) {
      if (input != null)
        try {
          input.close();
        } catch (Throwable throwable1) {
          throwable.addSuppressed(throwable1);
        }  
      throw throwable;
    } 
    if (headers.containsKey("GNU.sparse.map"))
      sparseHeaders = new ArrayList<TarArchiveStructSparse>(TarUtils.parseFromPAX01SparseHeaders((String)headers.get("GNU.sparse.map"))); 
    getNextTarEntry();
    if (this.currEntry == null)
      throw new IOException("premature end of tar archive. Didn't find any entry after PAX header."); 
    applyPaxHeadersToCurrentEntry(headers, sparseHeaders);
    if (this.currEntry.isPaxGNU1XSparse()) {
      InputStream input = getInputStream(this.currEntry);
      try {
        sparseHeaders = TarUtils.parsePAX1XSparseHeaders(input, this.recordSize);
        if (input != null)
          input.close(); 
      } catch (Throwable throwable) {
        if (input != null)
          try {
            input.close();
          } catch (Throwable throwable1) {
            throwable.addSuppressed(throwable1);
          }  
        throw throwable;
      } 
      this.currEntry.setSparseHeaders(sparseHeaders);
      this.currEntry.setDataOffset(this.currEntry.getDataOffset() + this.recordSize);
    } 
    buildSparseInputStreams();
  }
  
  private void readGlobalPaxHeaders() throws IOException {
    InputStream input = getInputStream(this.currEntry);
    try {
      this.globalPaxHeaders = TarUtils.parsePaxHeaders(input, this.globalSparseHeaders, this.globalPaxHeaders, this.currEntry
          .getSize());
      if (input != null)
        input.close(); 
    } catch (Throwable throwable) {
      if (input != null)
        try {
          input.close();
        } catch (Throwable throwable1) {
          throwable.addSuppressed(throwable1);
        }  
      throw throwable;
    } 
    getNextTarEntry();
    if (this.currEntry == null)
      throw new IOException("Error detected parsing the pax header"); 
  }
  
  private void readOldGNUSparse() throws IOException {
    if (this.currEntry.isExtended()) {
      TarArchiveSparseEntry entry;
      do {
        ByteBuffer headerBuf = getRecord();
        if (headerBuf == null)
          throw new IOException("premature end of tar archive. Didn't find extended_header after header with extended flag."); 
        entry = new TarArchiveSparseEntry(headerBuf.array());
        this.currEntry.getSparseHeaders().addAll(entry.getSparseHeaders());
        this.currEntry.setDataOffset(this.currEntry.getDataOffset() + this.recordSize);
      } while (entry.isExtended());
    } 
    buildSparseInputStreams();
  }
  
  private ByteBuffer readRecord() throws IOException {
    this.recordBuffer.rewind();
    int readNow = this.archive.read(this.recordBuffer);
    if (readNow != this.recordSize)
      return null; 
    return this.recordBuffer;
  }
  
  private void repositionForwardBy(long offset) throws IOException { repositionForwardTo(this.archive.position() + offset); }
  
  private void repositionForwardTo(long newPosition) throws IOException {
    long currPosition = this.archive.position();
    if (newPosition < currPosition)
      throw new IOException("trying to move backwards inside of the archive"); 
    this.archive.position(newPosition);
  }
  
  protected final void setAtEOF(boolean b) { this.hasHitEOF = b; }
  
  private void skipRecordPadding() throws IOException {
    if (!isDirectory() && this.currEntry.getSize() > 0L && this.currEntry.getSize() % this.recordSize != 0L) {
      long numRecords = this.currEntry.getSize() / this.recordSize + 1L;
      long padding = numRecords * this.recordSize - this.currEntry.getSize();
      repositionForwardBy(padding);
      throwExceptionIfPositionIsNotInArchive();
    } 
  }
  
  private void throwExceptionIfPositionIsNotInArchive() throws IOException {
    if (this.archive.size() < this.archive.position())
      throw new IOException("Truncated TAR archive"); 
  }
  
  private void tryToConsumeSecondEOFRecord() throws IOException {
    shouldReset = true;
    try {
      shouldReset = !isEOFRecord(readRecord());
    } finally {
      if (shouldReset)
        this.archive.position(this.archive.position() - this.recordSize); 
    } 
  }
}
