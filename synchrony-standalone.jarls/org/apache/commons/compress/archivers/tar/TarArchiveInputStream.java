package org.apache.commons.compress.archivers.tar;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.compress.archivers.ArchiveEntry;
import org.apache.commons.compress.archivers.ArchiveInputStream;
import org.apache.commons.compress.archivers.zip.ZipEncoding;
import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;
import org.apache.commons.compress.utils.ArchiveUtils;
import org.apache.commons.compress.utils.BoundedInputStream;
import org.apache.commons.compress.utils.IOUtils;

public class TarArchiveInputStream extends ArchiveInputStream {
  private static final int SMALL_BUFFER_SIZE = 256;
  
  private final byte[] smallBuf;
  
  private final int recordSize;
  
  private final byte[] recordBuffer;
  
  private final int blockSize;
  
  private boolean hasHitEOF;
  
  private long entrySize;
  
  private long entryOffset;
  
  private final InputStream inputStream;
  
  private List<InputStream> sparseInputStreams;
  
  private int currentSparseInputStreamIndex;
  
  private TarArchiveEntry currEntry;
  
  private final ZipEncoding zipEncoding;
  
  final String encoding;
  
  private Map<String, String> globalPaxHeaders;
  
  private final List<TarArchiveStructSparse> globalSparseHeaders;
  
  private final boolean lenient;
  
  public static boolean matches(byte[] signature, int length) {
    if (length < 265)
      return false; 
    if (ArchiveUtils.matchAsciiBuffer("ustar\000", signature, 257, 6) && 

      
      ArchiveUtils.matchAsciiBuffer("00", signature, 263, 2))
      return true; 
    if (ArchiveUtils.matchAsciiBuffer("ustar ", signature, 257, 6) && (


      
      ArchiveUtils.matchAsciiBuffer(" \000", signature, 263, 2) || 

      
      ArchiveUtils.matchAsciiBuffer("0\000", signature, 263, 2)))
      return true; 
    return (ArchiveUtils.matchAsciiBuffer("ustar\000", signature, 257, 6) && 

      
      ArchiveUtils.matchAsciiBuffer("\000\000", signature, 263, 2));
  }
  
  public TarArchiveInputStream(InputStream is) { this(is, 10240, 512); }
  
  public TarArchiveInputStream(InputStream is, boolean lenient) { this(is, 10240, 512, null, lenient); }
  
  public TarArchiveInputStream(InputStream is, int blockSize) { this(is, blockSize, 512); }
  
  public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) { this(is, blockSize, recordSize, null); }
  
  public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) { this(is, blockSize, recordSize, encoding, false); }
  
  public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding, boolean lenient) {
    this.smallBuf = new byte[256];
    this.globalPaxHeaders = new HashMap();
    this.globalSparseHeaders = new ArrayList();
    this.inputStream = is;
    this.hasHitEOF = false;
    this.encoding = encoding;
    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);
    this.recordSize = recordSize;
    this.recordBuffer = new byte[recordSize];
    this.blockSize = blockSize;
    this.lenient = lenient;
  }
  
  public TarArchiveInputStream(InputStream is, int blockSize, String encoding) { this(is, blockSize, 512, encoding); }
  
  public TarArchiveInputStream(InputStream is, String encoding) { this(is, 10240, 512, encoding); }
  
  private void applyPaxHeadersToCurrentEntry(Map<String, String> headers, List<TarArchiveStructSparse> sparseHeaders) throws IOException {
    this.currEntry.updateEntryFromPaxHeaders(headers);
    this.currEntry.setSparseHeaders(sparseHeaders);
  }
  
  public int available() throws IOException {
    if (isDirectory())
      return 0; 
    if (this.currEntry.getRealSize() - this.entryOffset > 2147483647L)
      return Integer.MAX_VALUE; 
    return (int)(this.currEntry.getRealSize() - this.entryOffset);
  }
  
  private void buildSparseInputStreams() throws IOException {
    this.currentSparseInputStreamIndex = -1;
    this.sparseInputStreams = new ArrayList();
    List<TarArchiveStructSparse> sparseHeaders = this.currEntry.getOrderedSparseHeaders();
    TarArchiveSparseZeroInputStream tarArchiveSparseZeroInputStream = new TarArchiveSparseZeroInputStream();
    long offset = 0L;
    for (TarArchiveStructSparse sparseHeader : sparseHeaders) {
      long zeroBlockSize = sparseHeader.getOffset() - offset;
      if (zeroBlockSize < 0L)
        throw new IOException("Corrupted struct sparse detected"); 
      if (zeroBlockSize > 0L)
        this.sparseInputStreams.add(new BoundedInputStream(tarArchiveSparseZeroInputStream, sparseHeader.getOffset() - offset)); 
      if (sparseHeader.getNumbytes() > 0L)
        this.sparseInputStreams.add(new BoundedInputStream(this.inputStream, sparseHeader.getNumbytes())); 
      offset = sparseHeader.getOffset() + sparseHeader.getNumbytes();
    } 
    if (!this.sparseInputStreams.isEmpty())
      this.currentSparseInputStreamIndex = 0; 
  }
  
  public boolean canReadEntryData(ArchiveEntry ae) { return ae instanceof TarArchiveEntry; }
  
  public void close() throws IOException {
    if (this.sparseInputStreams != null)
      for (InputStream inputStream : this.sparseInputStreams)
        inputStream.close();  
    this.inputStream.close();
  }
  
  private void consumeRemainderOfLastBlock() throws IOException {
    long bytesReadOfLastBlock = getBytesRead() % this.blockSize;
    if (bytesReadOfLastBlock > 0L) {
      long skipped = IOUtils.skip(this.inputStream, this.blockSize - bytesReadOfLastBlock);
      count(skipped);
    } 
  }
  
  private long getActuallySkipped(long available, long skipped, long expected) throws IOException {
    long actuallySkipped = skipped;
    if (this.inputStream instanceof java.io.FileInputStream)
      actuallySkipped = Math.min(skipped, available); 
    if (actuallySkipped != expected)
      throw new IOException("Truncated TAR archive"); 
    return actuallySkipped;
  }
  
  public TarArchiveEntry getCurrentEntry() { return this.currEntry; }
  
  protected byte[] getLongNameData() throws IOException {
    ByteArrayOutputStream longName = new ByteArrayOutputStream();
    int length = 0;
    while ((length = read(this.smallBuf)) >= 0)
      longName.write(this.smallBuf, 0, length); 
    getNextEntry();
    if (this.currEntry == null)
      return null; 
    byte[] longNameData = longName.toByteArray();
    length = longNameData.length;
    while (length > 0 && longNameData[length - 1] == 0)
      length--; 
    if (length != longNameData.length)
      longNameData = Arrays.copyOf(longNameData, length); 
    return longNameData;
  }
  
  public ArchiveEntry getNextEntry() throws IOException { return getNextTarEntry(); }
  
  public TarArchiveEntry getNextTarEntry() {
    if (isAtEOF())
      return null; 
    if (this.currEntry != null) {
      IOUtils.skip(this, Float.MAX_VALUE);
      skipRecordPadding();
    } 
    byte[] headerBuf = getRecord();
    if (headerBuf == null) {
      this.currEntry = null;
      return null;
    } 
    try {
      this.currEntry = new TarArchiveEntry(this.globalPaxHeaders, headerBuf, this.zipEncoding, this.lenient);
    } catch (IllegalArgumentException e) {
      throw new IOException("Error detected parsing the header", e);
    } 
    this.entryOffset = 0L;
    this.entrySize = this.currEntry.getSize();
    if (this.currEntry.isGNULongLinkEntry()) {
      byte[] longLinkData = getLongNameData();
      if (longLinkData == null)
        return null; 
      this.currEntry.setLinkName(this.zipEncoding.decode(longLinkData));
    } 
    if (this.currEntry.isGNULongNameEntry()) {
      byte[] longNameData = getLongNameData();
      if (longNameData == null)
        return null; 
      String name = this.zipEncoding.decode(longNameData);
      this.currEntry.setName(name);
      if (this.currEntry.isDirectory() && !name.endsWith("/"))
        this.currEntry.setName(name + "/"); 
    } 
    if (this.currEntry.isGlobalPaxHeader())
      readGlobalPaxHeaders(); 
    try {
      if (this.currEntry.isPaxHeader()) {
        paxHeaders();
      } else if (!this.globalPaxHeaders.isEmpty()) {
        applyPaxHeadersToCurrentEntry(this.globalPaxHeaders, this.globalSparseHeaders);
      } 
    } catch (NumberFormatException e) {
      throw new IOException("Error detected parsing the pax header", e);
    } 
    if (this.currEntry.isOldGNUSparse())
      readOldGNUSparse(); 
    this.entrySize = this.currEntry.getSize();
    return this.currEntry;
  }
  
  private byte[] getRecord() throws IOException {
    byte[] headerBuf = readRecord();
    setAtEOF(isEOFRecord(headerBuf));
    if (isAtEOF() && headerBuf != null) {
      tryToConsumeSecondEOFRecord();
      consumeRemainderOfLastBlock();
      headerBuf = null;
    } 
    return headerBuf;
  }
  
  public int getRecordSize() throws IOException { return this.recordSize; }
  
  protected final boolean isAtEOF() { return this.hasHitEOF; }
  
  private boolean isDirectory() { return (this.currEntry != null && this.currEntry.isDirectory()); }
  
  protected boolean isEOFRecord(byte[] record) { return (record == null || ArchiveUtils.isArrayZero(record, this.recordSize)); }
  
  public void mark(int markLimit) {}
  
  public boolean markSupported() { return false; }
  
  private void paxHeaders() throws IOException {
    List<TarArchiveStructSparse> sparseHeaders = new ArrayList<TarArchiveStructSparse>();
    Map<String, String> headers = TarUtils.parsePaxHeaders(this, sparseHeaders, this.globalPaxHeaders, this.entrySize);
    if (headers.containsKey("GNU.sparse.map"))
      sparseHeaders = new ArrayList<TarArchiveStructSparse>(TarUtils.parseFromPAX01SparseHeaders((String)headers.get("GNU.sparse.map"))); 
    getNextEntry();
    if (this.currEntry == null)
      throw new IOException("premature end of tar archive. Didn't find any entry after PAX header."); 
    applyPaxHeadersToCurrentEntry(headers, sparseHeaders);
    if (this.currEntry.isPaxGNU1XSparse()) {
      sparseHeaders = TarUtils.parsePAX1XSparseHeaders(this.inputStream, this.recordSize);
      this.currEntry.setSparseHeaders(sparseHeaders);
    } 
    buildSparseInputStreams();
  }
  
  public int read(byte[] buf, int offset, int numToRead) throws IOException {
    if (numToRead == 0)
      return 0; 
    int totalRead = 0;
    if (isAtEOF() || isDirectory())
      return -1; 
    if (this.currEntry == null)
      throw new IllegalStateException("No current tar entry"); 
    if (this.entryOffset >= this.currEntry.getRealSize())
      return -1; 
    numToRead = Math.min(numToRead, available());
    if (this.currEntry.isSparse()) {
      totalRead = readSparse(buf, offset, numToRead);
    } else {
      totalRead = this.inputStream.read(buf, offset, numToRead);
    } 
    if (totalRead == -1) {
      if (numToRead > 0)
        throw new IOException("Truncated TAR archive"); 
      setAtEOF(true);
    } else {
      count(totalRead);
      this.entryOffset += totalRead;
    } 
    return totalRead;
  }
  
  private void readGlobalPaxHeaders() throws IOException {
    this.globalPaxHeaders = TarUtils.parsePaxHeaders(this, this.globalSparseHeaders, this.globalPaxHeaders, this.entrySize);
    getNextEntry();
    if (this.currEntry == null)
      throw new IOException("Error detected parsing the pax header"); 
  }
  
  private void readOldGNUSparse() throws IOException {
    if (this.currEntry.isExtended()) {
      TarArchiveSparseEntry entry;
      do {
        byte[] headerBuf = getRecord();
        if (headerBuf == null)
          throw new IOException("premature end of tar archive. Didn't find extended_header after header with extended flag."); 
        entry = new TarArchiveSparseEntry(headerBuf);
        this.currEntry.getSparseHeaders().addAll(entry.getSparseHeaders());
      } while (entry.isExtended());
    } 
    buildSparseInputStreams();
  }
  
  protected byte[] readRecord() throws IOException {
    int readNow = IOUtils.readFully(this.inputStream, this.recordBuffer);
    count(readNow);
    if (readNow != this.recordSize)
      return null; 
    return this.recordBuffer;
  }
  
  private int readSparse(byte[] buf, int offset, int numToRead) throws IOException {
    if (this.sparseInputStreams == null || this.sparseInputStreams.isEmpty())
      return this.inputStream.read(buf, offset, numToRead); 
    if (this.currentSparseInputStreamIndex >= this.sparseInputStreams.size())
      return -1; 
    InputStream currentInputStream = (InputStream)this.sparseInputStreams.get(this.currentSparseInputStreamIndex);
    int readLen = currentInputStream.read(buf, offset, numToRead);
    if (this.currentSparseInputStreamIndex == this.sparseInputStreams.size() - 1)
      return readLen; 
    if (readLen == -1) {
      this.currentSparseInputStreamIndex++;
      return readSparse(buf, offset, numToRead);
    } 
    if (readLen < numToRead) {
      this.currentSparseInputStreamIndex++;
      int readLenOfNext = readSparse(buf, offset + readLen, numToRead - readLen);
      if (readLenOfNext == -1)
        return readLen; 
      return readLen + readLenOfNext;
    } 
    return readLen;
  }
  
  public void reset() throws IOException {}
  
  protected final void setAtEOF(boolean b) { this.hasHitEOF = b; }
  
  protected final void setCurrentEntry(TarArchiveEntry e) { this.currEntry = e; }
  
  public long skip(long n) throws IOException {
    long skipped;
    if (n <= 0L || isDirectory())
      return 0L; 
    long availableOfInputStream = this.inputStream.available();
    long available = this.currEntry.getRealSize() - this.entryOffset;
    long numToSkip = Math.min(n, available);
    if (!this.currEntry.isSparse()) {
      skipped = IOUtils.skip(this.inputStream, numToSkip);
      skipped = getActuallySkipped(availableOfInputStream, skipped, numToSkip);
    } else {
      skipped = skipSparse(numToSkip);
    } 
    count(skipped);
    this.entryOffset += skipped;
    return skipped;
  }
  
  private void skipRecordPadding() throws IOException {
    if (!isDirectory() && this.entrySize > 0L && this.entrySize % this.recordSize != 0L) {
      long available = this.inputStream.available();
      long numRecords = this.entrySize / this.recordSize + 1L;
      long padding = numRecords * this.recordSize - this.entrySize;
      long skipped = IOUtils.skip(this.inputStream, padding);
      skipped = getActuallySkipped(available, skipped, padding);
      count(skipped);
    } 
  }
  
  private long skipSparse(long n) throws IOException {
    if (this.sparseInputStreams == null || this.sparseInputStreams.isEmpty())
      return this.inputStream.skip(n); 
    long bytesSkipped = 0L;
    while (bytesSkipped < n && this.currentSparseInputStreamIndex < this.sparseInputStreams.size()) {
      InputStream currentInputStream = (InputStream)this.sparseInputStreams.get(this.currentSparseInputStreamIndex);
      bytesSkipped += currentInputStream.skip(n - bytesSkipped);
      if (bytesSkipped < n)
        this.currentSparseInputStreamIndex++; 
    } 
    return bytesSkipped;
  }
  
  private void tryToConsumeSecondEOFRecord() throws IOException {
    shouldReset = true;
    marked = this.inputStream.markSupported();
    if (marked)
      this.inputStream.mark(this.recordSize); 
    try {
      shouldReset = !isEOFRecord(readRecord());
    } finally {
      if (shouldReset && marked) {
        pushedBackBytes(this.recordSize);
        this.inputStream.reset();
      } 
    } 
  }
}
