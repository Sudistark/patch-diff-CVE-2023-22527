package org.apache.commons.fileupload.disk;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicInteger;
import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.FileItemHeaders;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.ParameterParser;
import org.apache.commons.fileupload.util.Streams;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.io.output.DeferredFileOutputStream;

public class DiskFileItem implements FileItem {
  public static final String DEFAULT_CHARSET = "ISO-8859-1";
  
  private static final String UID = UUID.randomUUID().toString().replace('-', '_');
  
  private static final AtomicInteger COUNTER = new AtomicInteger(0);
  
  private String fieldName;
  
  private final String contentType;
  
  private boolean isFormField;
  
  private final String fileName;
  
  private long size;
  
  private final int sizeThreshold;
  
  private final File repository;
  
  private byte[] cachedContent;
  
  private DeferredFileOutputStream dfos;
  
  private File tempFile;
  
  private FileItemHeaders headers;
  
  private String defaultCharset;
  
  public DiskFileItem(String fieldName, String contentType, boolean isFormField, String fileName, int sizeThreshold, File repository) {
    this.size = -1L;
    this.defaultCharset = "ISO-8859-1";
    this.fieldName = fieldName;
    this.contentType = contentType;
    this.isFormField = isFormField;
    this.fileName = fileName;
    this.sizeThreshold = sizeThreshold;
    this.repository = repository;
  }
  
  public InputStream getInputStream() throws IOException {
    if (!isInMemory())
      return new FileInputStream(this.dfos.getFile()); 
    if (this.cachedContent == null)
      this.cachedContent = this.dfos.getData(); 
    return new ByteArrayInputStream(this.cachedContent);
  }
  
  public String getContentType() { return this.contentType; }
  
  public String getCharSet() {
    ParameterParser parser = new ParameterParser();
    parser.setLowerCaseNames(true);
    Map<String, String> params = parser.parse(getContentType(), ';');
    return (String)params.get("charset");
  }
  
  public String getName() { return Streams.checkFileName(this.fileName); }
  
  public boolean isInMemory() {
    if (this.cachedContent != null)
      return true; 
    return this.dfos.isInMemory();
  }
  
  public long getSize() {
    if (this.size >= 0L)
      return this.size; 
    if (this.cachedContent != null)
      return this.cachedContent.length; 
    if (this.dfos.isInMemory())
      return this.dfos.getData().length; 
    return this.dfos.getFile().length();
  }
  
  public byte[] get() {
    if (isInMemory()) {
      if (this.cachedContent == null && this.dfos != null)
        this.cachedContent = this.dfos.getData(); 
      return this.cachedContent;
    } 
    byte[] fileData = new byte[(int)getSize()];
    fis = null;
    try {
      fis = new FileInputStream(this.dfos.getFile());
      IOUtils.readFully(fis, fileData);
    } catch (IOException e) {
      fileData = null;
    } finally {
      IOUtils.closeQuietly(fis);
    } 
    return fileData;
  }
  
  public String getString(String charset) throws UnsupportedEncodingException { return new String(get(), charset); }
  
  public String getString() {
    byte[] rawdata = get();
    String charset = getCharSet();
    if (charset == null)
      charset = this.defaultCharset; 
    try {
      return new String(rawdata, charset);
    } catch (UnsupportedEncodingException e) {
      return new String(rawdata);
    } 
  }
  
  public void write(File file) throws Exception {
    if (isInMemory()) {
      fout = null;
      try {
        fout = new FileOutputStream(file);
        fout.write(get());
        fout.close();
      } finally {
        IOUtils.closeQuietly(fout);
      } 
    } else {
      File outputFile = getStoreLocation();
      if (outputFile != null) {
        this.size = outputFile.length();
        if (file.exists())
          file.delete(); 
        FileUtils.moveFile(outputFile, file);
      } else {
        throw new FileUploadException("Cannot write uploaded file to disk!");
      } 
    } 
  }
  
  public void delete() {
    this.cachedContent = null;
    File outputFile = getStoreLocation();
    if (outputFile != null && !isInMemory() && outputFile.exists())
      outputFile.delete(); 
  }
  
  public String getFieldName() { return this.fieldName; }
  
  public void setFieldName(String fieldName) { this.fieldName = fieldName; }
  
  public boolean isFormField() { return this.isFormField; }
  
  public void setFormField(boolean state) { this.isFormField = state; }
  
  public OutputStream getOutputStream() throws IOException {
    if (this.dfos == null) {
      File outputFile = getTempFile();
      this.dfos = new DeferredFileOutputStream(this.sizeThreshold, outputFile);
    } 
    return this.dfos;
  }
  
  public File getStoreLocation() {
    if (this.dfos == null)
      return null; 
    if (isInMemory())
      return null; 
    return this.dfos.getFile();
  }
  
  protected void finalize() {
    if (this.dfos == null || this.dfos.isInMemory())
      return; 
    File outputFile = this.dfos.getFile();
    if (outputFile != null && outputFile.exists())
      outputFile.delete(); 
  }
  
  protected File getTempFile() {
    if (this.tempFile == null) {
      File tempDir = this.repository;
      if (tempDir == null)
        tempDir = new File(System.getProperty("java.io.tmpdir")); 
      String tempFileName = String.format("upload_%s_%s.tmp", new Object[] { UID, getUniqueId() });
      this.tempFile = new File(tempDir, tempFileName);
    } 
    return this.tempFile;
  }
  
  private static String getUniqueId() {
    limit = 100000000;
    int current = COUNTER.getAndIncrement();
    String id = Integer.toString(current);
    if (current < 100000000)
      id = ("00000000" + id).substring(id.length()); 
    return id;
  }
  
  public String toString() {
    return String.format("name=%s, StoreLocation=%s, size=%s bytes, isFormField=%s, FieldName=%s", new Object[] { getName(), getStoreLocation(), Long.valueOf(getSize()), 
          Boolean.valueOf(isFormField()), getFieldName() });
  }
  
  public FileItemHeaders getHeaders() { return this.headers; }
  
  public void setHeaders(FileItemHeaders pHeaders) { this.headers = pHeaders; }
  
  public String getDefaultCharset() { return this.defaultCharset; }
  
  public void setDefaultCharset(String charset) { this.defaultCharset = charset; }
}
