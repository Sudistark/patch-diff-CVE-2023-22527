package org.apache.commons.fileupload;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import javax.servlet.http.HttpServletRequest;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.apache.commons.fileupload.servlet.ServletRequestContext;
import org.apache.commons.fileupload.util.FileItemHeadersImpl;
import org.apache.commons.fileupload.util.Streams;

public abstract class FileUploadBase {
  public static final String CONTENT_TYPE = "Content-type";
  
  public static final String CONTENT_DISPOSITION = "Content-disposition";
  
  public static final String CONTENT_LENGTH = "Content-length";
  
  public static final String FORM_DATA = "form-data";
  
  public static final String ATTACHMENT = "attachment";
  
  public static final String MULTIPART = "multipart/";
  
  public static final String MULTIPART_FORM_DATA = "multipart/form-data";
  
  public static final String MULTIPART_MIXED = "multipart/mixed";
  
  @Deprecated
  public static final int MAX_HEADER_SIZE = 1024;
  
  public static final boolean isMultipartContent(RequestContext ctx) {
    String contentType = ctx.getContentType();
    if (contentType == null)
      return false; 
    if (contentType.toLowerCase(Locale.ENGLISH).startsWith("multipart/"))
      return true; 
    return false;
  }
  
  @Deprecated
  public static boolean isMultipartContent(HttpServletRequest req) { return ServletFileUpload.isMultipartContent(req); }
  
  private long sizeMax = -1L;
  
  private long fileSizeMax = -1L;
  
  private long fileCountMax = -1L;
  
  private String headerEncoding;
  
  private ProgressListener listener;
  
  public long getSizeMax() { return this.sizeMax; }
  
  public void setSizeMax(long sizeMax) { this.sizeMax = sizeMax; }
  
  public long getFileSizeMax() { return this.fileSizeMax; }
  
  public void setFileSizeMax(long fileSizeMax) { this.fileSizeMax = fileSizeMax; }
  
  public long getFileCountMax() { return this.fileCountMax; }
  
  public void setFileCountMax(long fileCountMax) { this.fileCountMax = fileCountMax; }
  
  public String getHeaderEncoding() { return this.headerEncoding; }
  
  public void setHeaderEncoding(String encoding) { this.headerEncoding = encoding; }
  
  @Deprecated
  public List<FileItem> parseRequest(HttpServletRequest req) throws FileUploadException { return parseRequest(new ServletRequestContext(req)); }
  
  public FileItemIterator getItemIterator(RequestContext ctx) throws FileUploadException, IOException {
    try {
      return new FileItemIteratorImpl(this, ctx);
    } catch (FileUploadIOException e) {
      throw (FileUploadException)e.getCause();
    } 
  }
  
  public List<FileItem> parseRequest(RequestContext ctx) throws FileUploadException {
    items = new ArrayList<FileItem>();
    successful = false;
    try {
      FileItemIterator iter = getItemIterator(ctx);
      FileItemFactory fac = getFileItemFactory();
      byte[] buffer = new byte[8192];
      if (fac == null)
        throw new NullPointerException("No FileItemFactory has been set."); 
      while (iter.hasNext()) {
        if (items.size() == this.fileCountMax)
          throw new FileCountLimitExceededException("attachment", getFileCountMax()); 
        FileItemStream item = iter.next();
        String fileName = FileItemIteratorImpl.FileItemStreamImpl.access$000((FileItemIteratorImpl.FileItemStreamImpl)item);
        FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(), item
            .isFormField(), fileName);
        items.add(fileItem);
        try {
          Streams.copy(item.openStream(), fileItem.getOutputStream(), true, buffer);
        } catch (FileUploadIOException e) {
          throw (FileUploadException)e.getCause();
        } catch (IOException e) {
          throw new IOFileUploadException(String.format("Processing of %s request failed. %s", new Object[] { "multipart/form-data", e
                  .getMessage() }), e);
        } 
        FileItemHeaders fih = item.getHeaders();
        fileItem.setHeaders(fih);
      } 
      successful = true;
      return items;
    } catch (FileUploadIOException e) {
      throw (FileUploadException)e.getCause();
    } catch (IOException e) {
      throw new FileUploadException(e.getMessage(), e);
    } finally {
      if (!successful)
        for (FileItem fileItem : items) {
          try {
            fileItem.delete();
          } catch (Exception exception) {}
        }  
    } 
  }
  
  public Map<String, List<FileItem>> parseParameterMap(RequestContext ctx) throws FileUploadException {
    List<FileItem> items = parseRequest(ctx);
    Map<String, List<FileItem>> itemsMap = new HashMap<String, List<FileItem>>(items.size());
    for (FileItem fileItem : items) {
      String fieldName = fileItem.getFieldName();
      List<FileItem> mappedItems = (List)itemsMap.get(fieldName);
      if (mappedItems == null) {
        mappedItems = new ArrayList<FileItem>();
        itemsMap.put(fieldName, mappedItems);
      } 
      mappedItems.add(fileItem);
    } 
    return itemsMap;
  }
  
  protected byte[] getBoundary(String contentType) {
    byte[] boundary;
    ParameterParser parser = new ParameterParser();
    parser.setLowerCaseNames(true);
    Map<String, String> params = parser.parse(contentType, new char[] { ';', ',' });
    String boundaryStr = (String)params.get("boundary");
    if (boundaryStr == null)
      return null; 
    try {
      boundary = boundaryStr.getBytes("ISO-8859-1");
    } catch (UnsupportedEncodingException e) {
      boundary = boundaryStr.getBytes();
    } 
    return boundary;
  }
  
  @Deprecated
  protected String getFileName(Map<String, String> headers) { return getFileName(getHeader(headers, "Content-disposition")); }
  
  protected String getFileName(FileItemHeaders headers) { return getFileName(headers.getHeader("Content-disposition")); }
  
  private String getFileName(String pContentDisposition) {
    String fileName = null;
    if (pContentDisposition != null) {
      String cdl = pContentDisposition.toLowerCase(Locale.ENGLISH);
      if (cdl.startsWith("form-data") || cdl.startsWith("attachment")) {
        ParameterParser parser = new ParameterParser();
        parser.setLowerCaseNames(true);
        Map<String, String> params = parser.parse(pContentDisposition, ';');
        if (params.containsKey("filename")) {
          fileName = (String)params.get("filename");
          if (fileName != null) {
            fileName = fileName.trim();
          } else {
            fileName = "";
          } 
        } 
      } 
    } 
    return fileName;
  }
  
  protected String getFieldName(FileItemHeaders headers) { return getFieldName(headers.getHeader("Content-disposition")); }
  
  private String getFieldName(String pContentDisposition) {
    String fieldName = null;
    if (pContentDisposition != null && pContentDisposition
      .toLowerCase(Locale.ENGLISH).startsWith("form-data")) {
      ParameterParser parser = new ParameterParser();
      parser.setLowerCaseNames(true);
      Map<String, String> params = parser.parse(pContentDisposition, ';');
      fieldName = (String)params.get("name");
      if (fieldName != null)
        fieldName = fieldName.trim(); 
    } 
    return fieldName;
  }
  
  @Deprecated
  protected String getFieldName(Map<String, String> headers) { return getFieldName(getHeader(headers, "Content-disposition")); }
  
  @Deprecated
  protected FileItem createItem(Map<String, String> headers, boolean isFormField) throws FileUploadException {
    return getFileItemFactory().createItem(getFieldName(headers), 
        getHeader(headers, "Content-type"), isFormField, 
        
        getFileName(headers));
  }
  
  protected FileItemHeaders getParsedHeaders(String headerPart) {
    int len = headerPart.length();
    FileItemHeadersImpl headers = newFileItemHeaders();
    int start = 0;
    while (true) {
      int end = parseEndOfLine(headerPart, start);
      if (start == end)
        break; 
      StringBuilder header = new StringBuilder(headerPart.substring(start, end));
      start = end + 2;
      while (start < len) {
        int nonWs = start;
        while (nonWs < len) {
          char c = headerPart.charAt(nonWs);
          if (c != ' ' && c != '\t')
            break; 
          nonWs++;
        } 
        if (nonWs == start)
          break; 
        end = parseEndOfLine(headerPart, nonWs);
        header.append(" ").append(headerPart.substring(nonWs, end));
        start = end + 2;
      } 
      parseHeaderLine(headers, header.toString());
    } 
    return headers;
  }
  
  protected FileItemHeadersImpl newFileItemHeaders() { return new FileItemHeadersImpl(); }
  
  @Deprecated
  protected Map<String, String> parseHeaders(String headerPart) {
    FileItemHeaders headers = getParsedHeaders(headerPart);
    Map<String, String> result = new HashMap<String, String>();
    for (Iterator<String> iter = headers.getHeaderNames(); iter.hasNext(); ) {
      String headerName = (String)iter.next();
      Iterator<String> iter2 = headers.getHeaders(headerName);
      StringBuilder headerValue = new StringBuilder((String)iter2.next());
      while (iter2.hasNext())
        headerValue.append(",").append((String)iter2.next()); 
      result.put(headerName, headerValue.toString());
    } 
    return result;
  }
  
  private int parseEndOfLine(String headerPart, int end) {
    int index = end;
    while (true) {
      int offset = headerPart.indexOf('\r', index);
      if (offset == -1 || offset + 1 >= headerPart.length())
        throw new IllegalStateException("Expected headers to be terminated by an empty line."); 
      if (headerPart.charAt(offset + 1) == '\n')
        return offset; 
      index = offset + 1;
    } 
  }
  
  private void parseHeaderLine(FileItemHeadersImpl headers, String header) {
    int colonOffset = header.indexOf(':');
    if (colonOffset == -1)
      return; 
    String headerName = header.substring(0, colonOffset).trim();
    String headerValue = header.substring(header.indexOf(':') + 1).trim();
    headers.addHeader(headerName, headerValue);
  }
  
  @Deprecated
  protected final String getHeader(Map<String, String> headers, String name) { return (String)headers.get(name.toLowerCase(Locale.ENGLISH)); }
  
  public ProgressListener getProgressListener() { return this.listener; }
  
  public void setProgressListener(ProgressListener pListener) { this.listener = pListener; }
  
  public abstract FileItemFactory getFileItemFactory();
  
  public abstract void setFileItemFactory(FileItemFactory paramFileItemFactory);
}
