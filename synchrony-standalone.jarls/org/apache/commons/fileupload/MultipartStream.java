package org.apache.commons.fileupload;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import org.apache.commons.fileupload.util.Streams;

public class MultipartStream {
  public static final byte CR = 13;
  
  public static final byte LF = 10;
  
  public static final byte DASH = 45;
  
  public static final int HEADER_PART_SIZE_MAX = 10240;
  
  protected static final int DEFAULT_BUFSIZE = 4096;
  
  protected static final byte[] HEADER_SEPARATOR = { 13, 10, 13, 10 };
  
  protected static final byte[] FIELD_SEPARATOR = { 13, 10 };
  
  protected static final byte[] STREAM_TERMINATOR = { 45, 45 };
  
  protected static final byte[] BOUNDARY_PREFIX = { 13, 10, 45, 45 };
  
  private final InputStream input;
  
  private int boundaryLength;
  
  private final int keepRegion;
  
  private final byte[] boundary;
  
  private final int[] boundaryTable;
  
  private final int bufSize;
  
  private final byte[] buffer;
  
  private int head;
  
  private int tail;
  
  private String headerEncoding;
  
  private final ProgressNotifier notifier;
  
  @Deprecated
  public MultipartStream() { this(null, null, null); }
  
  @Deprecated
  public MultipartStream(InputStream input, byte[] boundary, int bufSize) { this(input, boundary, bufSize, null); }
  
  public MultipartStream(InputStream input, byte[] boundary, int bufSize, ProgressNotifier pNotifier) {
    if (boundary == null)
      throw new IllegalArgumentException("boundary may not be null"); 
    this.boundaryLength = boundary.length + BOUNDARY_PREFIX.length;
    if (bufSize < this.boundaryLength + 1)
      throw new IllegalArgumentException("The buffer size specified for the MultipartStream is too small"); 
    this.input = input;
    this.bufSize = Math.max(bufSize, this.boundaryLength * 2);
    this.buffer = new byte[this.bufSize];
    this.notifier = pNotifier;
    this.boundary = new byte[this.boundaryLength];
    this.boundaryTable = new int[this.boundaryLength + 1];
    this.keepRegion = this.boundary.length;
    System.arraycopy(BOUNDARY_PREFIX, 0, this.boundary, 0, BOUNDARY_PREFIX.length);
    System.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length, boundary.length);
    computeBoundaryTable();
    this.head = 0;
    this.tail = 0;
  }
  
  MultipartStream(InputStream input, byte[] boundary, ProgressNotifier pNotifier) { this(input, boundary, 4096, pNotifier); }
  
  @Deprecated
  public MultipartStream(InputStream input, byte[] boundary) { this(input, boundary, 4096, null); }
  
  public String getHeaderEncoding() { return this.headerEncoding; }
  
  public void setHeaderEncoding(String encoding) { this.headerEncoding = encoding; }
  
  public byte readByte() throws IOException {
    if (this.head == this.tail) {
      this.head = 0;
      this.tail = this.input.read(this.buffer, this.head, this.bufSize);
      if (this.tail == -1)
        throw new IOException("No more data is available"); 
      if (this.notifier != null)
        this.notifier.noteBytesRead(this.tail); 
    } 
    return this.buffer[this.head++];
  }
  
  public boolean readBoundary() throws FileUploadBase.FileUploadIOException, MalformedStreamException {
    byte[] marker = new byte[2];
    boolean nextChunk = false;
    this.head += this.boundaryLength;
    try {
      marker[0] = readByte();
      if (marker[0] == 10)
        return true; 
      marker[1] = readByte();
      if (arrayequals(marker, STREAM_TERMINATOR, 2)) {
        nextChunk = false;
      } else if (arrayequals(marker, FIELD_SEPARATOR, 2)) {
        nextChunk = true;
      } else {
        throw new MalformedStreamException("Unexpected characters follow a boundary");
      } 
    } catch (FileUploadIOException e) {
      throw e;
    } catch (IOException e) {
      throw new MalformedStreamException("Stream ended unexpectedly");
    } 
    return nextChunk;
  }
  
  public void setBoundary(byte[] boundary) throws IllegalBoundaryException {
    if (boundary.length != this.boundaryLength - BOUNDARY_PREFIX.length)
      throw new IllegalBoundaryException("The length of a boundary token cannot be changed"); 
    System.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length, boundary.length);
    computeBoundaryTable();
  }
  
  private void computeBoundaryTable() {
    int position = 2;
    int candidate = 0;
    this.boundaryTable[0] = -1;
    this.boundaryTable[1] = 0;
    while (position <= this.boundaryLength) {
      if (this.boundary[position - 1] == this.boundary[candidate]) {
        this.boundaryTable[position] = candidate + 1;
        candidate++;
        position++;
        continue;
      } 
      if (candidate > 0) {
        candidate = this.boundaryTable[candidate];
        continue;
      } 
      this.boundaryTable[position] = 0;
      position++;
    } 
  }
  
  public String readHeaders() {
    int i = 0;
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    int size = 0;
    while (i < HEADER_SEPARATOR.length) {
      byte b;
      try {
        b = readByte();
      } catch (FileUploadIOException e) {
        throw e;
      } catch (IOException e) {
        throw new MalformedStreamException("Stream ended unexpectedly");
      } 
      if (++size > 10240)
        throw new MalformedStreamException(
            String.format("Header section has more than %s bytes (maybe it is not properly terminated)", new Object[] { Integer.valueOf(10240) })); 
      if (b == HEADER_SEPARATOR[i]) {
        i++;
      } else {
        i = 0;
      } 
      baos.write(b);
    } 
    String headers = null;
    if (this.headerEncoding != null) {
      try {
        headers = baos.toString(this.headerEncoding);
      } catch (UnsupportedEncodingException e) {
        headers = baos.toString();
      } 
    } else {
      headers = baos.toString();
    } 
    return headers;
  }
  
  public int readBodyData(OutputStream output) throws MalformedStreamException, IOException { return (int)Streams.copy(newInputStream(), output, false); }
  
  ItemInputStream newInputStream() { return new ItemInputStream(this); }
  
  public int discardBodyData() throws MalformedStreamException, IOException { return readBodyData(null); }
  
  public boolean skipPreamble() throws FileUploadBase.FileUploadIOException, MalformedStreamException {
    System.arraycopy(this.boundary, 2, this.boundary, 0, this.boundary.length - 2);
    this.boundaryLength = this.boundary.length - 2;
    computeBoundaryTable();
    try {
      discardBodyData();
      return readBoundary();
    } catch (MalformedStreamException e) {
      return false;
    } finally {
      System.arraycopy(this.boundary, 0, this.boundary, 2, this.boundary.length - 2);
      this.boundaryLength = this.boundary.length;
      this.boundary[0] = 13;
      this.boundary[1] = 10;
      computeBoundaryTable();
    } 
  }
  
  public static boolean arrayequals(byte[] a, byte[] b, int count) {
    for (int i = 0; i < count; i++) {
      if (a[i] != b[i])
        return false; 
    } 
    return true;
  }
  
  protected int findByte(byte value, int pos) {
    for (int i = pos; i < this.tail; i++) {
      if (this.buffer[i] == value)
        return i; 
    } 
    return -1;
  }
  
  protected int findSeparator() throws MalformedStreamException, IOException {
    int bufferPos = this.head;
    int tablePos = 0;
    while (bufferPos < this.tail) {
      while (tablePos >= 0 && this.buffer[bufferPos] != this.boundary[tablePos])
        tablePos = this.boundaryTable[tablePos]; 
      bufferPos++;
      tablePos++;
      if (tablePos == this.boundaryLength)
        return bufferPos - this.boundaryLength; 
    } 
    return -1;
  }
}
