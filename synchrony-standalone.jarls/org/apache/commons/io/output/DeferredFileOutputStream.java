package org.apache.commons.io.output;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Objects;
import java.util.function.Supplier;
import org.apache.commons.io.file.PathUtils;

public class DeferredFileOutputStream extends ThresholdingOutputStream {
  private ByteArrayOutputStream memoryOutputStream;
  
  private OutputStream currentOutputStream;
  
  private Path outputPath;
  
  private final String prefix;
  
  private final String suffix;
  
  private final Path directory;
  
  private boolean closed;
  
  public static Builder builder() { return new Builder(); }
  
  private static int checkBufferSize(int initialBufferSize) {
    if (initialBufferSize < 0)
      throw new IllegalArgumentException("Initial buffer size must be at least 0."); 
    return initialBufferSize;
  }
  
  private static Path toPath(File file, Supplier<Path> defaultPathSupplier) { return (file != null) ? file.toPath() : ((defaultPathSupplier == null) ? null : (Path)defaultPathSupplier.get()); }
  
  private static Path toPath(Path file, Supplier<Path> defaultPathSupplier) { return (file != null) ? file : ((defaultPathSupplier == null) ? null : (Path)defaultPathSupplier.get()); }
  
  @Deprecated
  public DeferredFileOutputStream(int threshold, File outputFile) { this(threshold, outputFile, null, null, null, 1024); }
  
  private DeferredFileOutputStream(int threshold, File outputFile, String prefix, String suffix, File directory, int initialBufferSize) {
    super(threshold);
    this.outputPath = toPath(outputFile, null);
    this.prefix = prefix;
    this.suffix = suffix;
    this.directory = toPath(directory, PathUtils::getTempDirectory);
    this.memoryOutputStream = new ByteArrayOutputStream(checkBufferSize(initialBufferSize));
    this.currentOutputStream = this.memoryOutputStream;
  }
  
  private DeferredFileOutputStream(int threshold, Path outputFile, String prefix, String suffix, Path directory, int initialBufferSize) {
    super(threshold);
    this.outputPath = toPath(outputFile, null);
    this.prefix = prefix;
    this.suffix = suffix;
    this.directory = toPath(directory, PathUtils::getTempDirectory);
    this.memoryOutputStream = new ByteArrayOutputStream(checkBufferSize(initialBufferSize));
    this.currentOutputStream = this.memoryOutputStream;
  }
  
  @Deprecated
  public DeferredFileOutputStream(int threshold, int initialBufferSize, File outputFile) { this(threshold, outputFile, null, null, null, initialBufferSize); }
  
  @Deprecated
  public DeferredFileOutputStream(int threshold, int initialBufferSize, String prefix, String suffix, File directory) { this(threshold, null, (String)Objects.requireNonNull(prefix, "prefix"), suffix, directory, initialBufferSize); }
  
  @Deprecated
  public DeferredFileOutputStream(int threshold, String prefix, String suffix, File directory) { this(threshold, null, (String)Objects.requireNonNull(prefix, "prefix"), suffix, directory, 1024); }
  
  public void close() throws IOException {
    super.close();
    this.closed = true;
  }
  
  public byte[] getData() { return (this.memoryOutputStream != null) ? this.memoryOutputStream.toByteArray() : null; }
  
  public File getFile() { return (this.outputPath != null) ? this.outputPath.toFile() : null; }
  
  public Path getPath() { return this.outputPath; }
  
  protected OutputStream getStream() throws IOException { return this.currentOutputStream; }
  
  public boolean isInMemory() { return !isThresholdExceeded(); }
  
  protected void thresholdReached() throws IOException {
    if (this.prefix != null)
      this.outputPath = Files.createTempFile(this.directory, this.prefix, this.suffix, new java.nio.file.attribute.FileAttribute[0]); 
    PathUtils.createParentDirectories(this.outputPath, null, PathUtils.EMPTY_FILE_ATTRIBUTE_ARRAY);
    OutputStream fos = Files.newOutputStream(this.outputPath, new java.nio.file.OpenOption[0]);
    try {
      this.memoryOutputStream.writeTo(fos);
    } catch (IOException e) {
      fos.close();
      throw e;
    } 
    this.currentOutputStream = fos;
    this.memoryOutputStream = null;
  }
  
  public InputStream toInputStream() throws IOException {
    if (!this.closed)
      throw new IOException("Stream not closed"); 
    if (isInMemory())
      return this.memoryOutputStream.toInputStream(); 
    return Files.newInputStream(this.outputPath, new java.nio.file.OpenOption[0]);
  }
  
  public void writeTo(OutputStream outputStream) throws IOException {
    if (!this.closed)
      throw new IOException("Stream not closed"); 
    if (isInMemory()) {
      this.memoryOutputStream.writeTo(outputStream);
    } else {
      Files.copy(this.outputPath, outputStream);
    } 
  }
}
