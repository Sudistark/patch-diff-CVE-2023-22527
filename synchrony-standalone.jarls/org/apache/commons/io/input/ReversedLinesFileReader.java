package org.apache.commons.io.input;

import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.nio.channels.SeekableByteChannel;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.OpenOption;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.apache.commons.io.Charsets;
import org.apache.commons.io.FileSystem;
import org.apache.commons.io.StandardLineSeparator;

public class ReversedLinesFileReader implements Closeable {
  private static final String EMPTY_STRING = "";
  
  private static final int DEFAULT_BLOCK_SIZE = FileSystem.getCurrent().getBlockSize();
  
  private final int blockSize;
  
  private final Charset charset;
  
  private final SeekableByteChannel channel;
  
  private final long totalByteLength;
  
  private final long totalBlockCount;
  
  private final byte[][] newLineSequences;
  
  private final int avoidNewlineSplitBufferSize;
  
  private final int byteDecrement;
  
  private FilePart currentFilePart;
  
  private boolean trailingNewlineOfFileSkipped;
  
  public static Builder builder() { return new Builder(); }
  
  @Deprecated
  public ReversedLinesFileReader(File file) throws IOException { this(file, DEFAULT_BLOCK_SIZE, Charset.defaultCharset()); }
  
  @Deprecated
  public ReversedLinesFileReader(File file, Charset charset) throws IOException { this(file.toPath(), charset); }
  
  @Deprecated
  public ReversedLinesFileReader(File file, int blockSize, Charset charset) throws IOException { this(file.toPath(), blockSize, charset); }
  
  @Deprecated
  public ReversedLinesFileReader(File file, int blockSize, String charsetName) throws IOException { this(file.toPath(), blockSize, charsetName); }
  
  @Deprecated
  public ReversedLinesFileReader(Path file, Charset charset) throws IOException { this(file, DEFAULT_BLOCK_SIZE, charset); }
  
  @Deprecated
  public ReversedLinesFileReader(Path file, int blockSize, Charset charset) throws IOException {
    this.blockSize = blockSize;
    this.charset = Charsets.toCharset(charset);
    CharsetEncoder charsetEncoder = this.charset.newEncoder();
    float maxBytesPerChar = charsetEncoder.maxBytesPerChar();
    if (maxBytesPerChar == 1.0F || this.charset == StandardCharsets.UTF_8) {
      this.byteDecrement = 1;
    } else if (this.charset == Charset.forName("Shift_JIS") || this.charset == 
      
      Charset.forName("windows-31j") || this.charset == 
      Charset.forName("x-windows-949") || this.charset == 
      Charset.forName("gbk") || this.charset == 
      Charset.forName("x-windows-950")) {
      this.byteDecrement = 1;
    } else if (this.charset == StandardCharsets.UTF_16BE || this.charset == StandardCharsets.UTF_16LE) {
      this.byteDecrement = 2;
    } else {
      if (this.charset == StandardCharsets.UTF_16)
        throw new UnsupportedEncodingException("For UTF-16, you need to specify the byte order (use UTF-16BE or UTF-16LE)"); 
      throw new UnsupportedEncodingException("Encoding " + charset + " is not supported yet (feel free to submit a patch)");
    } 
    this

      
      .newLineSequences = new byte[][] { StandardLineSeparator.CRLF.getBytes(this.charset), StandardLineSeparator.LF.getBytes(this.charset), StandardLineSeparator.CR.getBytes(this.charset) };
    this.avoidNewlineSplitBufferSize = this.newLineSequences[0].length;
    this.channel = Files.newByteChannel(file, new OpenOption[] { StandardOpenOption.READ });
    this.totalByteLength = this.channel.size();
    int lastBlockLength = (int)(this.totalByteLength % blockSize);
    if (lastBlockLength > 0) {
      this.totalBlockCount = this.totalByteLength / blockSize + 1L;
    } else {
      this.totalBlockCount = this.totalByteLength / blockSize;
      if (this.totalByteLength > 0L)
        lastBlockLength = blockSize; 
    } 
    this.currentFilePart = new FilePart(this, this.totalBlockCount, lastBlockLength, null, null);
  }
  
  @Deprecated
  public ReversedLinesFileReader(Path file, int blockSize, String charsetName) throws IOException { this(file, blockSize, Charsets.toCharset(charsetName)); }
  
  public void close() throws IOException { this.channel.close(); }
  
  public String readLine() throws IOException {
    String line = FilePart.access$800(this.currentFilePart);
    while (line == null) {
      this.currentFilePart = FilePart.access$900(this.currentFilePart);
      if (this.currentFilePart == null)
        break; 
      line = FilePart.access$800(this.currentFilePart);
    } 
    if ("".equals(line) && !this.trailingNewlineOfFileSkipped) {
      this.trailingNewlineOfFileSkipped = true;
      line = readLine();
    } 
    return line;
  }
  
  public List<String> readLines(int lineCount) throws IOException {
    if (lineCount < 0)
      throw new IllegalArgumentException("lineCount < 0"); 
    ArrayList<String> arrayList = new ArrayList<String>(lineCount);
    for (int i = 0; i < lineCount; i++) {
      String line = readLine();
      if (line == null)
        return arrayList; 
      arrayList.add(line);
    } 
    return arrayList;
  }
  
  public String toString(int lineCount) throws IOException {
    List<String> lines = readLines(lineCount);
    Collections.reverse(lines);
    return lines.isEmpty() ? "" : (String.join(System.lineSeparator(), lines) + System.lineSeparator());
  }
}
