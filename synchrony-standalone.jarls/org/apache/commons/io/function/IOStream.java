package org.apache.commons.io.function;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Spliterators;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiFunction;
import java.util.function.IntFunction;
import java.util.function.ToDoubleFunction;
import java.util.function.ToIntFunction;
import java.util.function.ToLongFunction;
import java.util.stream.Collector;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import org.apache.commons.io.IOExceptionList;

public interface IOStream<T> extends IOBaseStream<T, IOStream<T>, Stream<T>> {
  static <T> IOStream<T> adapt(Stream<T> stream) { return IOStreamAdapter.adapt(stream); }
  
  static <T> IOStream<T> empty() { return IOStreamAdapter.adapt(Stream.empty()); }
  
  static <T> IOStream<T> iterate(T seed, IOUnaryOperator<T> f) {
    Objects.requireNonNull(f);
    Object object = new Object(seed, f);
    return adapt(StreamSupport.stream(Spliterators.spliteratorUnknownSize(object, 1040), false));
  }
  
  static <T> IOStream<T> of(Iterable<T> values) { return (values == null) ? empty() : adapt(StreamSupport.stream(values.spliterator(), false)); }
  
  @SafeVarargs
  static <T> IOStream<T> of(T... values) { return (values == null || values.length == 0) ? empty() : adapt(Arrays.stream(values)); }
  
  static <T> IOStream<T> of(T t) { return adapt(Stream.of(t)); }
  
  default boolean allMatch(IOPredicate<? super T> predicate) throws IOException { return ((Stream)unwrap()).allMatch(t -> Erase.test(predicate, t)); }
  
  default boolean anyMatch(IOPredicate<? super T> predicate) throws IOException { return ((Stream)unwrap()).anyMatch(t -> Erase.test(predicate, t)); }
  
  default <R, A> R collect(Collector<? super T, A, R> collector) { return (R)((Stream)unwrap()).collect(collector); }
  
  default <R> R collect(IOSupplier<R> supplier, IOBiConsumer<R, ? super T> accumulator, IOBiConsumer<R, R> combiner) throws IOException { return (R)((Stream)unwrap()).collect(() -> Erase.get(supplier), (t, u) -> Erase.accept(accumulator, t, u), (t, u) -> Erase.accept(combiner, t, u)); }
  
  default long count() { return ((Stream)unwrap()).count(); }
  
  default IOStream<T> distinct() { return adapt(((Stream)unwrap()).distinct()); }
  
  default IOStream<T> filter(IOPredicate<? super T> predicate) throws IOException { return adapt(((Stream)unwrap()).filter(t -> Erase.test(predicate, t))); }
  
  default Optional<T> findAny() { return ((Stream)unwrap()).findAny(); }
  
  default Optional<T> findFirst() { return ((Stream)unwrap()).findFirst(); }
  
  default <R> IOStream<R> flatMap(IOFunction<? super T, ? extends IOStream<? extends R>> mapper) throws IOException { return adapt(((Stream)unwrap()).flatMap(t -> (Stream)((IOStream)Erase.apply(mapper, t)).unwrap())); }
  
  default DoubleStream flatMapToDouble(IOFunction<? super T, ? extends DoubleStream> mapper) throws IOException { return ((Stream)unwrap()).flatMapToDouble(t -> (DoubleStream)Erase.apply(mapper, t)); }
  
  default IntStream flatMapToInt(IOFunction<? super T, ? extends IntStream> mapper) throws IOException { return ((Stream)unwrap()).flatMapToInt(t -> (IntStream)Erase.apply(mapper, t)); }
  
  default LongStream flatMapToLong(IOFunction<? super T, ? extends LongStream> mapper) throws IOException { return ((Stream)unwrap()).flatMapToLong(t -> (LongStream)Erase.apply(mapper, t)); }
  
  default void forAll(IOConsumer<T> action) throws IOExceptionList { forAll(action, (i, e) -> e); }
  
  default void forAll(IOConsumer<T> action, BiFunction<Integer, IOException, IOException> exSupplier) throws IOExceptionList {
    AtomicReference<List<IOException>> causeList = new AtomicReference<List<IOException>>();
    AtomicInteger index = new AtomicInteger();
    IOConsumer<T> safeAction = IOStreams.toIOConsumer(action);
    ((Stream)unwrap()).forEach(e -> {
          try {
            safeAction.accept(e);
          } catch (IOException innerEx) {
            if (causeList.get() == null)
              causeList.set(new ArrayList()); 
            if (exSupplier != null)
              ((List)causeList.get()).add((IOException)exSupplier.apply(Integer.valueOf(index.get()), innerEx)); 
          } 
          index.incrementAndGet();
        });
    IOExceptionList.checkEmpty((List)causeList.get(), null);
  }
  
  default void forEach(IOConsumer<? super T> action) throws IOException { ((Stream)unwrap()).forEach(e -> Erase.accept(action, e)); }
  
  default void forEachOrdered(IOConsumer<? super T> action) throws IOException { ((Stream)unwrap()).forEachOrdered(e -> Erase.accept(action, e)); }
  
  default IOStream<T> limit(long maxSize) { return adapt(((Stream)unwrap()).limit(maxSize)); }
  
  default <R> IOStream<R> map(IOFunction<? super T, ? extends R> mapper) throws IOException { return adapt(((Stream)unwrap()).map(t -> Erase.apply(mapper, t))); }
  
  default DoubleStream mapToDouble(ToDoubleFunction<? super T> mapper) { return ((Stream)unwrap()).mapToDouble(mapper); }
  
  default IntStream mapToInt(ToIntFunction<? super T> mapper) { return ((Stream)unwrap()).mapToInt(mapper); }
  
  default LongStream mapToLong(ToLongFunction<? super T> mapper) { return ((Stream)unwrap()).mapToLong(mapper); }
  
  default Optional<T> max(IOComparator<? super T> comparator) throws IOException { return ((Stream)unwrap()).max((t, u) -> Erase.compare(comparator, t, u)); }
  
  default Optional<T> min(IOComparator<? super T> comparator) throws IOException { return ((Stream)unwrap()).min((t, u) -> Erase.compare(comparator, t, u)); }
  
  default boolean noneMatch(IOPredicate<? super T> predicate) throws IOException { return ((Stream)unwrap()).noneMatch(t -> Erase.test(predicate, t)); }
  
  default IOStream<T> peek(IOConsumer<? super T> action) throws IOException { return adapt(((Stream)unwrap()).peek(t -> Erase.accept(action, t))); }
  
  default Optional<T> reduce(IOBinaryOperator<T> accumulator) throws IOException { return ((Stream)unwrap()).reduce((t, u) -> Erase.apply(accumulator, t, u)); }
  
  default T reduce(T identity, IOBinaryOperator<T> accumulator) throws IOException { return (T)((Stream)unwrap()).reduce(identity, (t, u) -> Erase.apply(accumulator, t, u)); }
  
  default <U> U reduce(U identity, IOBiFunction<U, ? super T, U> accumulator, IOBinaryOperator<U> combiner) throws IOException { return (U)((Stream)unwrap()).reduce(identity, (t, u) -> Erase.apply(accumulator, t, u), (t, u) -> Erase.apply(combiner, t, u)); }
  
  default IOStream<T> skip(long n) { return adapt(((Stream)unwrap()).skip(n)); }
  
  default IOStream<T> sorted() { return adapt(((Stream)unwrap()).sorted()); }
  
  default IOStream<T> sorted(IOComparator<? super T> comparator) throws IOException { return adapt(((Stream)unwrap()).sorted((t, u) -> Erase.compare(comparator, t, u))); }
  
  default Object[] toArray() { return ((Stream)unwrap()).toArray(); }
  
  default <A> A[] toArray(IntFunction<A[]> generator) { return (A[])((Stream)unwrap()).toArray(generator); }
}
