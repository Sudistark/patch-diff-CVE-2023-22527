package org.apache.commons.io.serialization;

import java.io.IOException;
import java.io.InputStream;
import java.io.InvalidClassException;
import java.io.ObjectInputStream;
import java.io.ObjectStreamClass;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Stream;

public class ValidatingObjectInputStream extends ObjectInputStream {
  private final List<ClassNameMatcher> acceptMatchers = new ArrayList();
  
  private final List<ClassNameMatcher> rejectMatchers = new ArrayList();
  
  public ValidatingObjectInputStream(InputStream input) throws IOException { super(input); }
  
  public ValidatingObjectInputStream accept(Class... classes) {
    Objects.requireNonNull(this.acceptMatchers);
    Stream.of(classes).map(c -> new FullClassNameMatcher(new String[] { c.getName() })).forEach(this.acceptMatchers::add);
    return this;
  }
  
  public ValidatingObjectInputStream accept(ClassNameMatcher m) {
    this.acceptMatchers.add(m);
    return this;
  }
  
  public ValidatingObjectInputStream accept(Pattern pattern) {
    this.acceptMatchers.add(new RegexpClassNameMatcher(pattern));
    return this;
  }
  
  public ValidatingObjectInputStream accept(String... patterns) {
    Objects.requireNonNull(this.acceptMatchers);
    Stream.of(patterns).map(WildcardClassNameMatcher::new).forEach(this.acceptMatchers::add);
    return this;
  }
  
  protected void invalidClassNameFound(String className) throws InvalidClassException { throw new InvalidClassException("Class name not accepted: " + className); }
  
  public ValidatingObjectInputStream reject(Class... classes) {
    Objects.requireNonNull(this.rejectMatchers);
    Stream.of(classes).map(c -> new FullClassNameMatcher(new String[] { c.getName() })).forEach(this.rejectMatchers::add);
    return this;
  }
  
  public ValidatingObjectInputStream reject(ClassNameMatcher m) {
    this.rejectMatchers.add(m);
    return this;
  }
  
  public ValidatingObjectInputStream reject(Pattern pattern) {
    this.rejectMatchers.add(new RegexpClassNameMatcher(pattern));
    return this;
  }
  
  public ValidatingObjectInputStream reject(String... patterns) {
    Objects.requireNonNull(this.rejectMatchers);
    Stream.of(patterns).map(WildcardClassNameMatcher::new).forEach(this.rejectMatchers::add);
    return this;
  }
  
  protected Class<?> resolveClass(ObjectStreamClass osc) throws IOException, ClassNotFoundException {
    validateClassName(osc.getName());
    return super.resolveClass(osc);
  }
  
  private void validateClassName(String name) throws InvalidClassException {
    for (ClassNameMatcher m : this.rejectMatchers) {
      if (m.matches(name))
        invalidClassNameFound(name); 
    } 
    boolean ok = false;
    for (ClassNameMatcher m : this.acceptMatchers) {
      if (m.matches(name)) {
        ok = true;
        break;
      } 
    } 
    if (!ok)
      invalidClassNameFound(name); 
  }
}
