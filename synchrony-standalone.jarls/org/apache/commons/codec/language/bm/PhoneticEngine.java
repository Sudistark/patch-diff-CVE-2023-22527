package org.apache.commons.codec.language.bm;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.TreeMap;
import java.util.stream.Collectors;

public class PhoneticEngine {
  private static final int DEFAULT_MAX_PHONEMES = 20;
  
  private static final Map<NameType, Set<String>> NAME_PREFIXES = new EnumMap(NameType.class);
  
  private final Lang lang;
  
  private final NameType nameType;
  
  private final RuleType ruleType;
  
  private final boolean concat;
  
  private final int maxPhonemes;
  
  static  {
    NAME_PREFIXES.put(NameType.ASHKENAZI, 
        Collections.unmodifiableSet(new HashSet(
            Arrays.asList(new String[] { "bar", "ben", "da", "de", "van", "von" }))));
    NAME_PREFIXES.put(NameType.SEPHARDIC, 
        Collections.unmodifiableSet(new HashSet(
            Arrays.asList(new String[] { 
                "al", "el", "da", "dal", "de", "del", "dela", "de la", "della", "des", 
                "di", "do", "dos", "du", "van", "von" }))));
    NAME_PREFIXES.put(NameType.GENERIC, 
        Collections.unmodifiableSet(new HashSet(
            Arrays.asList(new String[] { 
                "da", "dal", "de", "del", "dela", "de la", "della", "des", "di", "do", 
                "dos", "du", "van", "von" }))));
  }
  
  private static String join(List<String> strings, String sep) { return (String)strings.stream().collect(Collectors.joining(sep)); }
  
  public PhoneticEngine(NameType nameType, RuleType ruleType, boolean concat) { this(nameType, ruleType, concat, 20); }
  
  public PhoneticEngine(NameType nameType, RuleType ruleType, boolean concat, int maxPhonemes) {
    if (ruleType == RuleType.RULES)
      throw new IllegalArgumentException("ruleType must not be " + RuleType.RULES); 
    this.nameType = nameType;
    this.ruleType = ruleType;
    this.concat = concat;
    this.lang = Lang.instance(nameType);
    this.maxPhonemes = maxPhonemes;
  }
  
  private PhonemeBuilder applyFinalRules(PhonemeBuilder phonemeBuilder, Map<String, List<Rule>> finalRules) {
    Objects.requireNonNull(finalRules, "finalRules");
    if (finalRules.isEmpty())
      return phonemeBuilder; 
    Map<Rule.Phoneme, Rule.Phoneme> phonemes = new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);
    phonemeBuilder.getPhonemes().forEach(phoneme -> {
          PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
          String phonemeText = phoneme.getPhonemeText().toString();
          int i;
          for (i = 0; i < phonemeText.length(); ) {
            RulesApplication rulesApplication = (new RulesApplication(finalRules, phonemeText, subBuilder, i, this.maxPhonemes)).invoke();
            boolean found = rulesApplication.isFound();
            subBuilder = rulesApplication.getPhonemeBuilder();
            if (!found)
              subBuilder.append(phonemeText.subSequence(i, i + 1)); 
            i = rulesApplication.getI();
          } 
          subBuilder.getPhonemes().forEach(());
        });
    return new PhonemeBuilder(phonemes.keySet(), null);
  }
  
  public String encode(String input) {
    Languages.LanguageSet languageSet = this.lang.guessLanguages(input);
    return encode(input, languageSet);
  }
  
  public String encode(String input, Languages.LanguageSet languageSet) {
    Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);
    Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, "common");
    Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);
    input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();
    if (this.nameType == NameType.GENERIC) {
      if (input.startsWith("d'")) {
        String remainder = input.substring(2);
        String combined = "d" + remainder;
        return "(" + encode(remainder) + ")-(" + encode(combined) + ")";
      } 
      for (String l : (Set)NAME_PREFIXES.get(this.nameType)) {
        if (input.startsWith(l + " ")) {
          String remainder = input.substring(l.length() + 1);
          String combined = l + remainder;
          return "(" + encode(remainder) + ")-(" + encode(combined) + ")";
        } 
      } 
    } 
    List<String> words = Arrays.asList(input.split("\\s+"));
    List<String> words2 = new ArrayList<String>();
    switch (null.$SwitchMap$org$apache$commons$codec$language$bm$NameType[this.nameType.ordinal()]) {
      case 1:
        words.forEach(aWord -> {
              String[] parts = aWord.split("'");
              words2.add(parts[parts.length - 1]);
            });
        words2.removeAll((Collection)NAME_PREFIXES.get(this.nameType));
        break;
      case 2:
        words2.addAll(words);
        words2.removeAll((Collection)NAME_PREFIXES.get(this.nameType));
        break;
      case 3:
        words2.addAll(words);
        break;
      default:
        throw new IllegalStateException("Unreachable case: " + this.nameType);
    } 
    if (this.concat) {
      input = join(words2, " ");
    } else if (words2.size() == 1) {
      input = (String)words.iterator().next();
    } else {
      StringBuilder result = new StringBuilder();
      words2.forEach(word -> result.append("-").append(encode(word)));
      return result.substring(1);
    } 
    PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);
    for (int i = 0; i < input.length(); ) {
      RulesApplication rulesApplication = (new RulesApplication(rules, input, phonemeBuilder, i, this.maxPhonemes)).invoke();
      i = rulesApplication.getI();
      phonemeBuilder = rulesApplication.getPhonemeBuilder();
    } 
    phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);
    phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);
    return phonemeBuilder.makeString();
  }
  
  public Lang getLang() { return this.lang; }
  
  public NameType getNameType() { return this.nameType; }
  
  public RuleType getRuleType() { return this.ruleType; }
  
  public boolean isConcat() { return this.concat; }
  
  public int getMaxPhonemes() { return this.maxPhonemes; }
}
