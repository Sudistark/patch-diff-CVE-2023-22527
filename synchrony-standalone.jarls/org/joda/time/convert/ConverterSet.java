package org.joda.time.convert;

class ConverterSet {
  private final Converter[] iConverters;
  
  private Entry[] iSelectEntries;
  
  ConverterSet(Converter[] paramArrayOfConverter) {
    this.iConverters = paramArrayOfConverter;
    this.iSelectEntries = new Entry[16];
  }
  
  Converter select(Class<?> paramClass) throws IllegalStateException {
    Entry[] arrayOfEntry1 = this.iSelectEntries;
    int i = arrayOfEntry1.length;
    byte b1 = (paramClass == null) ? 0 : (paramClass.hashCode() & i - 1);
    Entry entry;
    while ((entry = arrayOfEntry1[b1]) != null) {
      if (entry.iType == paramClass)
        return entry.iConverter; 
      if (++b1 >= i)
        b1 = 0; 
    } 
    Converter converter = selectSlow(this, paramClass);
    entry = new Entry(paramClass, converter);
    Entry[] arrayOfEntry = (Entry[])arrayOfEntry1.clone();
    arrayOfEntry[b1] = entry;
    int j;
    for (j = 0; j < i; j++) {
      if (arrayOfEntry[j] == null) {
        this.iSelectEntries = arrayOfEntry;
        return converter;
      } 
    } 
    j = i << 1;
    Entry[] arrayOfEntry2 = new Entry[j];
    for (byte b2 = 0; b2 < i; b2++) {
      entry = arrayOfEntry[b2];
      paramClass = entry.iType;
      b1 = (paramClass == null) ? 0 : (paramClass.hashCode() & j - 1);
      while (arrayOfEntry2[b1] != null) {
        if (++b1 >= j)
          b1 = 0; 
      } 
      arrayOfEntry2[b1] = entry;
    } 
    this.iSelectEntries = arrayOfEntry2;
    return converter;
  }
  
  int size() { return this.iConverters.length; }
  
  void copyInto(Converter[] paramArrayOfConverter) { System.arraycopy(this.iConverters, 0, paramArrayOfConverter, 0, this.iConverters.length); }
  
  ConverterSet add(Converter paramConverter, Converter[] paramArrayOfConverter) {
    Converter[] arrayOfConverter1 = this.iConverters;
    int i = arrayOfConverter1.length;
    for (byte b = 0; b < i; b++) {
      Converter converter = arrayOfConverter1[b];
      if (paramConverter.equals(converter)) {
        if (paramArrayOfConverter != null)
          paramArrayOfConverter[0] = null; 
        return this;
      } 
      if (paramConverter.getSupportedType() == converter.getSupportedType()) {
        Converter[] arrayOfConverter = new Converter[i];
        for (byte b1 = 0; b1 < i; b1++) {
          if (b1 != b) {
            arrayOfConverter[b1] = arrayOfConverter1[b1];
          } else {
            arrayOfConverter[b1] = paramConverter;
          } 
        } 
        if (paramArrayOfConverter != null)
          paramArrayOfConverter[0] = converter; 
        return new ConverterSet(arrayOfConverter);
      } 
    } 
    Converter[] arrayOfConverter2 = new Converter[i + 1];
    System.arraycopy(arrayOfConverter1, 0, arrayOfConverter2, 0, i);
    arrayOfConverter2[i] = paramConverter;
    if (paramArrayOfConverter != null)
      paramArrayOfConverter[0] = null; 
    return new ConverterSet(arrayOfConverter2);
  }
  
  ConverterSet remove(Converter paramConverter, Converter[] paramArrayOfConverter) {
    Converter[] arrayOfConverter = this.iConverters;
    int i = arrayOfConverter.length;
    for (byte b = 0; b < i; b++) {
      if (paramConverter.equals(arrayOfConverter[b]))
        return remove(b, paramArrayOfConverter); 
    } 
    if (paramArrayOfConverter != null)
      paramArrayOfConverter[0] = null; 
    return this;
  }
  
  ConverterSet remove(int paramInt, Converter[] paramArrayOfConverter) {
    Converter[] arrayOfConverter1 = this.iConverters;
    int i = arrayOfConverter1.length;
    if (paramInt >= i)
      throw new IndexOutOfBoundsException(); 
    if (paramArrayOfConverter != null)
      paramArrayOfConverter[0] = arrayOfConverter1[paramInt]; 
    Converter[] arrayOfConverter2 = new Converter[i - 1];
    byte b1 = 0;
    for (byte b2 = 0; b2 < i; b2++) {
      if (b2 != paramInt)
        arrayOfConverter2[b1++] = arrayOfConverter1[b2]; 
    } 
    return new ConverterSet(arrayOfConverter2);
  }
  
  private static Converter selectSlow(ConverterSet paramConverterSet, Class<?> paramClass) {
    Converter[] arrayOfConverter = paramConverterSet.iConverters;
    int i = arrayOfConverter.length;
    int j;
    for (j = i; --j >= 0; ) {
      Converter converter = arrayOfConverter[j];
      Class clazz = converter.getSupportedType();
      if (clazz == paramClass)
        return converter; 
      if (clazz == null || (paramClass != null && !clazz.isAssignableFrom(paramClass))) {
        paramConverterSet = paramConverterSet.remove(j, null);
        arrayOfConverter = paramConverterSet.iConverters;
        i = arrayOfConverter.length;
      } 
    } 
    if (paramClass == null || i == 0)
      return null; 
    if (i == 1)
      return arrayOfConverter[0]; 
    for (j = i; --j >= 0; ) {
      Converter converter = arrayOfConverter[j];
      Class clazz = converter.getSupportedType();
      for (int k = i; --k >= 0;) {
        if (k != j && arrayOfConverter[k].getSupportedType().isAssignableFrom(clazz)) {
          paramConverterSet = paramConverterSet.remove(k, null);
          arrayOfConverter = paramConverterSet.iConverters;
          i = arrayOfConverter.length;
          j = i - 1;
        } 
      } 
    } 
    if (i == 1)
      return arrayOfConverter[0]; 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("Unable to find best converter for type \"");
    stringBuilder.append(paramClass.getName());
    stringBuilder.append("\" from remaining set: ");
    for (byte b = 0; b < i; b++) {
      Converter converter = arrayOfConverter[b];
      Class clazz = converter.getSupportedType();
      stringBuilder.append(converter.getClass().getName());
      stringBuilder.append('[');
      stringBuilder.append((clazz == null) ? null : clazz.getName());
      stringBuilder.append("], ");
    } 
    throw new IllegalStateException(stringBuilder.toString());
  }
}
