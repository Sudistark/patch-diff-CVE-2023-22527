package org.joda.time.base;

import java.io.Serializable;
import org.joda.time.Chronology;
import org.joda.time.DateTimeUtils;
import org.joda.time.DurationField;
import org.joda.time.DurationFieldType;
import org.joda.time.MutablePeriod;
import org.joda.time.Period;
import org.joda.time.PeriodType;
import org.joda.time.ReadableInstant;
import org.joda.time.ReadablePartial;
import org.joda.time.ReadablePeriod;
import org.joda.time.chrono.ISOChronology;
import org.joda.time.field.FieldUtils;

public abstract class BaseSingleFieldPeriod extends Object implements ReadablePeriod, Comparable<BaseSingleFieldPeriod>, Serializable {
  private static final long serialVersionUID = 9386874258972L;
  
  private static final long START_1972 = 63072000000L;
  
  protected static int between(ReadableInstant paramReadableInstant1, ReadableInstant paramReadableInstant2, DurationFieldType paramDurationFieldType) {
    if (paramReadableInstant1 == null || paramReadableInstant2 == null)
      throw new IllegalArgumentException("ReadableInstant objects must not be null"); 
    Chronology chronology = DateTimeUtils.getInstantChronology(paramReadableInstant1);
    return paramDurationFieldType.getField(chronology).getDifference(paramReadableInstant2.getMillis(), paramReadableInstant1.getMillis());
  }
  
  protected static int between(ReadablePartial paramReadablePartial1, ReadablePartial paramReadablePartial2, ReadablePeriod paramReadablePeriod) {
    if (paramReadablePartial1 == null || paramReadablePartial2 == null)
      throw new IllegalArgumentException("ReadablePartial objects must not be null"); 
    if (paramReadablePartial1.size() != paramReadablePartial2.size())
      throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); 
    byte b;
    int i;
    for (b = 0, i = paramReadablePartial1.size(); b < i; b++) {
      if (paramReadablePartial1.getFieldType(b) != paramReadablePartial2.getFieldType(b))
        throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); 
    } 
    if (!DateTimeUtils.isContiguous(paramReadablePartial1))
      throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); 
    Chronology chronology = DateTimeUtils.getChronology(paramReadablePartial1.getChronology()).withUTC();
    int[] arrayOfInt = chronology.get(paramReadablePeriod, chronology.set(paramReadablePartial1, 63072000000L), chronology.set(paramReadablePartial2, 63072000000L));
    return arrayOfInt[0];
  }
  
  protected static int standardPeriodIn(ReadablePeriod paramReadablePeriod, long paramLong) {
    if (paramReadablePeriod == null)
      return 0; 
    ISOChronology iSOChronology = ISOChronology.getInstanceUTC();
    long l = 0L;
    for (byte b = 0; b < paramReadablePeriod.size(); b++) {
      int i = paramReadablePeriod.getValue(b);
      if (i != 0) {
        DurationField durationField = paramReadablePeriod.getFieldType(b).getField(iSOChronology);
        if (!durationField.isPrecise())
          throw new IllegalArgumentException("Cannot convert period to duration as " + durationField
              .getName() + " is not precise in the period " + paramReadablePeriod); 
        l = FieldUtils.safeAdd(l, FieldUtils.safeMultiply(durationField.getUnitMillis(), i));
      } 
    } 
    return FieldUtils.safeToInt(l / paramLong);
  }
  
  protected BaseSingleFieldPeriod(int paramInt) { this.iPeriod = paramInt; }
  
  protected int getValue() { return this.iPeriod; }
  
  protected void setValue(int paramInt) { this.iPeriod = paramInt; }
  
  public int size() { return 1; }
  
  public DurationFieldType getFieldType(int paramInt) {
    if (paramInt != 0)
      throw new IndexOutOfBoundsException(String.valueOf(paramInt)); 
    return getFieldType();
  }
  
  public int getValue(int paramInt) {
    if (paramInt != 0)
      throw new IndexOutOfBoundsException(String.valueOf(paramInt)); 
    return getValue();
  }
  
  public int get(DurationFieldType paramDurationFieldType) {
    if (paramDurationFieldType == getFieldType())
      return getValue(); 
    return 0;
  }
  
  public boolean isSupported(DurationFieldType paramDurationFieldType) { return (paramDurationFieldType == getFieldType()); }
  
  public Period toPeriod() { return Period.ZERO.withFields(this); }
  
  public MutablePeriod toMutablePeriod() {
    MutablePeriod mutablePeriod = new MutablePeriod();
    mutablePeriod.add(this);
    return mutablePeriod;
  }
  
  public boolean equals(Object paramObject) {
    if (this == paramObject)
      return true; 
    if (!(paramObject instanceof ReadablePeriod))
      return false; 
    ReadablePeriod readablePeriod = (ReadablePeriod)paramObject;
    return (readablePeriod.getPeriodType() == getPeriodType() && readablePeriod.getValue(0) == getValue());
  }
  
  public int hashCode() {
    null = 17;
    null = 27 * null + getValue();
    return 27 * null + getFieldType().hashCode();
  }
  
  public int compareTo(BaseSingleFieldPeriod paramBaseSingleFieldPeriod) {
    if (paramBaseSingleFieldPeriod.getClass() != getClass())
      throw new ClassCastException(getClass() + " cannot be compared to " + paramBaseSingleFieldPeriod.getClass()); 
    int i = paramBaseSingleFieldPeriod.getValue();
    int j = getValue();
    if (j > i)
      return 1; 
    if (j < i)
      return -1; 
    return 0;
  }
  
  public abstract DurationFieldType getFieldType();
  
  public abstract PeriodType getPeriodType();
}
