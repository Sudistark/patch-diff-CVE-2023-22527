package org.joda.time;

import java.io.File;
import java.io.ObjectStreamException;
import java.io.Serializable;
import java.util.Locale;
import java.util.Set;
import java.util.TimeZone;
import java.util.concurrent.atomic.AtomicReference;
import org.joda.convert.FromString;
import org.joda.convert.ToString;
import org.joda.time.field.FieldUtils;
import org.joda.time.format.FormatUtils;
import org.joda.time.tz.DefaultNameProvider;
import org.joda.time.tz.FixedDateTimeZone;
import org.joda.time.tz.NameProvider;
import org.joda.time.tz.Provider;
import org.joda.time.tz.UTCProvider;
import org.joda.time.tz.ZoneInfoProvider;

public abstract class DateTimeZone implements Serializable {
  private static final long serialVersionUID = 5546345482340108586L;
  
  public static final DateTimeZone UTC = UTCDateTimeZone.INSTANCE;
  
  private static final int MAX_MILLIS = 86399999;
  
  private static final AtomicReference<Provider> cProvider = new AtomicReference();
  
  private static final AtomicReference<NameProvider> cNameProvider = new AtomicReference();
  
  private static final AtomicReference<DateTimeZone> cDefault = new AtomicReference();
  
  public static final String DEFAULT_TZ_DATA_PATH = "org/joda/time/tz/data";
  
  private final String iID;
  
  public static DateTimeZone getDefault() {
    DateTimeZone dateTimeZone = (DateTimeZone)cDefault.get();
    if (dateTimeZone == null) {
      try {
        try {
          String str = System.getProperty("user.timezone");
          if (str != null)
            dateTimeZone = forID(str); 
        } catch (RuntimeException runtimeException) {}
        if (dateTimeZone == null)
          dateTimeZone = forTimeZone(TimeZone.getDefault()); 
      } catch (IllegalArgumentException illegalArgumentException) {}
      if (dateTimeZone == null)
        dateTimeZone = UTC; 
      if (!cDefault.compareAndSet(null, dateTimeZone))
        dateTimeZone = (DateTimeZone)cDefault.get(); 
    } 
    return dateTimeZone;
  }
  
  public static void setDefault(DateTimeZone paramDateTimeZone) throws SecurityException {
    SecurityManager securityManager = System.getSecurityManager();
    if (securityManager != null)
      securityManager.checkPermission(new JodaTimePermission("DateTimeZone.setDefault")); 
    if (paramDateTimeZone == null)
      throw new IllegalArgumentException("The datetime zone must not be null"); 
    cDefault.set(paramDateTimeZone);
  }
  
  @FromString
  public static DateTimeZone forID(String paramString) {
    if (paramString == null)
      return getDefault(); 
    if (paramString.equals("UTC"))
      return UTC; 
    DateTimeZone dateTimeZone = getProvider().getZone(paramString);
    if (dateTimeZone != null)
      return dateTimeZone; 
    if (paramString.startsWith("+") || paramString.startsWith("-")) {
      int i = parseOffset(paramString);
      if (i == 0L)
        return UTC; 
      paramString = printOffset(i);
      return fixedOffsetZone(paramString, i);
    } 
    throw new IllegalArgumentException("The datetime zone id '" + paramString + "' is not recognised");
  }
  
  public static DateTimeZone forOffsetHours(int paramInt) throws IllegalArgumentException { return forOffsetHoursMinutes(paramInt, 0); }
  
  public static DateTimeZone forOffsetHoursMinutes(int paramInt1, int paramInt2) throws IllegalArgumentException {
    if (paramInt1 == 0 && paramInt2 == 0)
      return UTC; 
    if (paramInt1 < -23 || paramInt1 > 23)
      throw new IllegalArgumentException("Hours out of range: " + paramInt1); 
    if (paramInt2 < -59 || paramInt2 > 59)
      throw new IllegalArgumentException("Minutes out of range: " + paramInt2); 
    if (paramInt1 > 0 && paramInt2 < 0)
      throw new IllegalArgumentException("Positive hours must not have negative minutes: " + paramInt2); 
    int i = 0;
    try {
      int j = paramInt1 * 60;
      if (j < 0) {
        paramInt2 = j - Math.abs(paramInt2);
      } else {
        paramInt2 = j + paramInt2;
      } 
      i = FieldUtils.safeMultiply(paramInt2, 60000);
    } catch (ArithmeticException arithmeticException) {
      throw new IllegalArgumentException("Offset is too large");
    } 
    return forOffsetMillis(i);
  }
  
  public static DateTimeZone forOffsetMillis(int paramInt) throws IllegalArgumentException {
    if (paramInt < -86399999 || paramInt > 86399999)
      throw new IllegalArgumentException("Millis out of range: " + paramInt); 
    String str = printOffset(paramInt);
    return fixedOffsetZone(str, paramInt);
  }
  
  public static DateTimeZone forTimeZone(TimeZone paramTimeZone) {
    if (paramTimeZone == null)
      return getDefault(); 
    String str1 = paramTimeZone.getID();
    if (str1 == null)
      throw new IllegalArgumentException("The TimeZone id must not be null"); 
    if (str1.equals("UTC"))
      return UTC; 
    DateTimeZone dateTimeZone = null;
    String str2 = getConvertedId(str1);
    Provider provider = getProvider();
    if (str2 != null)
      dateTimeZone = provider.getZone(str2); 
    if (dateTimeZone == null)
      dateTimeZone = provider.getZone(str1); 
    if (dateTimeZone != null)
      return dateTimeZone; 
    if (str2 == null) {
      str2 = str1;
      if (str2.startsWith("GMT+") || str2.startsWith("GMT-")) {
        str2 = str2.substring(3);
        if (str2.length() > 2) {
          char c = str2.charAt(1);
          if (c > '9' && Character.isDigit(c))
            str2 = convertToAsciiNumber(str2); 
        } 
        int i = parseOffset(str2);
        if (i == 0L)
          return UTC; 
        str2 = printOffset(i);
        return fixedOffsetZone(str2, i);
      } 
    } 
    throw new IllegalArgumentException("The datetime zone id '" + str1 + "' is not recognised");
  }
  
  private static String convertToAsciiNumber(String paramString) {
    StringBuilder stringBuilder = new StringBuilder(paramString);
    for (byte b = 0; b < stringBuilder.length(); b++) {
      char c = stringBuilder.charAt(b);
      int i = Character.digit(c, 10);
      if (i >= 0)
        stringBuilder.setCharAt(b, (char)(48 + i)); 
    } 
    return stringBuilder.toString();
  }
  
  private static DateTimeZone fixedOffsetZone(String paramString, int paramInt) {
    if (paramInt == 0)
      return UTC; 
    return new FixedDateTimeZone(paramString, null, paramInt, paramInt);
  }
  
  public static Set<String> getAvailableIDs() { return getProvider().getAvailableIDs(); }
  
  public static Provider getProvider() {
    Provider provider = (Provider)cProvider.get();
    if (provider == null) {
      provider = getDefaultProvider();
      if (!cProvider.compareAndSet(null, provider))
        provider = (Provider)cProvider.get(); 
    } 
    return provider;
  }
  
  public static void setProvider(Provider paramProvider) throws SecurityException {
    SecurityManager securityManager = System.getSecurityManager();
    if (securityManager != null)
      securityManager.checkPermission(new JodaTimePermission("DateTimeZone.setProvider")); 
    if (paramProvider == null) {
      paramProvider = getDefaultProvider();
    } else {
      validateProvider(paramProvider);
    } 
    cProvider.set(paramProvider);
  }
  
  private static Provider validateProvider(Provider paramProvider) {
    Set set = paramProvider.getAvailableIDs();
    if (set == null || set.size() == 0)
      throw new IllegalArgumentException("The provider doesn't have any available ids"); 
    if (!set.contains("UTC"))
      throw new IllegalArgumentException("The provider doesn't support UTC"); 
    if (!UTC.equals(paramProvider.getZone("UTC")))
      throw new IllegalArgumentException("Invalid UTC zone provided"); 
    return paramProvider;
  }
  
  private static Provider getDefaultProvider() {
    try {
      String str = System.getProperty("org.joda.time.DateTimeZone.Provider");
      if (str != null)
        try {
          Class clazz = Class.forName(str, false, DateTimeZone.class.getClassLoader());
          if (!Provider.class.isAssignableFrom(clazz))
            throw new IllegalArgumentException("System property referred to class that does not implement " + Provider.class); 
          Provider provider = (Provider)clazz.asSubclass(Provider.class).getConstructor(new Class[0]).newInstance(new Object[0]);
          return validateProvider(provider);
        } catch (Exception exception) {
          throw new RuntimeException(exception);
        }  
    } catch (SecurityException securityException) {}
    try {
      String str = System.getProperty("org.joda.time.DateTimeZone.Folder");
      if (str != null)
        try {
          ZoneInfoProvider zoneInfoProvider = new ZoneInfoProvider(new File(str));
          return validateProvider(zoneInfoProvider);
        } catch (Exception exception) {
          throw new RuntimeException(exception);
        }  
    } catch (SecurityException securityException) {}
    try {
      ZoneInfoProvider zoneInfoProvider = new ZoneInfoProvider("org/joda/time/tz/data");
      return validateProvider(zoneInfoProvider);
    } catch (Exception exception) {
      exception.printStackTrace();
      return new UTCProvider();
    } 
  }
  
  public static NameProvider getNameProvider() {
    NameProvider nameProvider = (NameProvider)cNameProvider.get();
    if (nameProvider == null) {
      nameProvider = getDefaultNameProvider();
      if (!cNameProvider.compareAndSet(null, nameProvider))
        nameProvider = (NameProvider)cNameProvider.get(); 
    } 
    return nameProvider;
  }
  
  public static void setNameProvider(NameProvider paramNameProvider) throws SecurityException {
    SecurityManager securityManager = System.getSecurityManager();
    if (securityManager != null)
      securityManager.checkPermission(new JodaTimePermission("DateTimeZone.setNameProvider")); 
    if (paramNameProvider == null)
      paramNameProvider = getDefaultNameProvider(); 
    cNameProvider.set(paramNameProvider);
  }
  
  private static NameProvider getDefaultNameProvider() {
    DefaultNameProvider defaultNameProvider = null;
    try {
      String str = System.getProperty("org.joda.time.DateTimeZone.NameProvider");
      if (str != null)
        try {
          Class clazz = Class.forName(str, false, DateTimeZone.class.getClassLoader());
          if (!NameProvider.class.isAssignableFrom(clazz))
            throw new IllegalArgumentException("System property referred to class that does not implement " + NameProvider.class); 
          defaultNameProvider = (NameProvider)clazz.asSubclass(NameProvider.class).getConstructor(new Class[0]).newInstance(new Object[0]);
        } catch (Exception exception) {
          throw new RuntimeException(exception);
        }  
    } catch (SecurityException securityException) {}
    if (defaultNameProvider == null)
      defaultNameProvider = new DefaultNameProvider(); 
    return defaultNameProvider;
  }
  
  private static String getConvertedId(String paramString) { return (String)LazyInit.CONVERSION_MAP.get(paramString); }
  
  private static int parseOffset(String paramString) { return -((int)LazyInit.OFFSET_FORMATTER.parseMillis(paramString)); }
  
  private static String printOffset(int paramInt) {
    StringBuffer stringBuffer = new StringBuffer();
    if (paramInt >= 0) {
      stringBuffer.append('+');
    } else {
      stringBuffer.append('-');
      paramInt = -paramInt;
    } 
    int i = paramInt / 3600000;
    FormatUtils.appendPaddedInteger(stringBuffer, i, 2);
    paramInt -= i * 3600000;
    int j = paramInt / 60000;
    stringBuffer.append(':');
    FormatUtils.appendPaddedInteger(stringBuffer, j, 2);
    paramInt -= j * 60000;
    if (paramInt == 0)
      return stringBuffer.toString(); 
    int k = paramInt / 1000;
    stringBuffer.append(':');
    FormatUtils.appendPaddedInteger(stringBuffer, k, 2);
    paramInt -= k * 1000;
    if (paramInt == 0)
      return stringBuffer.toString(); 
    stringBuffer.append('.');
    FormatUtils.appendPaddedInteger(stringBuffer, paramInt, 3);
    return stringBuffer.toString();
  }
  
  protected DateTimeZone(String paramString) {
    if (paramString == null)
      throw new IllegalArgumentException("Id must not be null"); 
    this.iID = paramString;
  }
  
  @ToString
  public final String getID() { return this.iID; }
  
  public abstract String getNameKey(long paramLong);
  
  public final String getShortName(long paramLong) { return getShortName(paramLong, null); }
  
  public String getShortName(long paramLong, Locale paramLocale) {
    String str2;
    if (paramLocale == null)
      paramLocale = Locale.getDefault(); 
    String str1 = getNameKey(paramLong);
    if (str1 == null)
      return this.iID; 
    NameProvider nameProvider = getNameProvider();
    if (nameProvider instanceof DefaultNameProvider) {
      str2 = ((DefaultNameProvider)nameProvider).getShortName(paramLocale, this.iID, str1, isStandardOffset(paramLong));
    } else {
      str2 = nameProvider.getShortName(paramLocale, this.iID, str1);
    } 
    if (str2 != null)
      return str2; 
    return printOffset(getOffset(paramLong));
  }
  
  public final String getName(long paramLong) { return getName(paramLong, null); }
  
  public String getName(long paramLong, Locale paramLocale) {
    String str2;
    if (paramLocale == null)
      paramLocale = Locale.getDefault(); 
    String str1 = getNameKey(paramLong);
    if (str1 == null)
      return this.iID; 
    NameProvider nameProvider = getNameProvider();
    if (nameProvider instanceof DefaultNameProvider) {
      str2 = ((DefaultNameProvider)nameProvider).getName(paramLocale, this.iID, str1, isStandardOffset(paramLong));
    } else {
      str2 = nameProvider.getName(paramLocale, this.iID, str1);
    } 
    if (str2 != null)
      return str2; 
    return printOffset(getOffset(paramLong));
  }
  
  public abstract int getOffset(long paramLong);
  
  public final int getOffset(ReadableInstant paramReadableInstant) {
    if (paramReadableInstant == null)
      return getOffset(DateTimeUtils.currentTimeMillis()); 
    return getOffset(paramReadableInstant.getMillis());
  }
  
  public abstract int getStandardOffset(long paramLong);
  
  public boolean isStandardOffset(long paramLong) { return (getOffset(paramLong) == getStandardOffset(paramLong)); }
  
  public int getOffsetFromLocal(long paramLong) {
    int i = getOffset(paramLong);
    long l = paramLong - i;
    int j = getOffset(l);
    if (i != j) {
      if (i - j < 0) {
        long l1 = nextTransition(l);
        if (l1 == paramLong - i)
          l1 = Float.MAX_VALUE; 
        long l2 = nextTransition(paramLong - j);
        if (l2 == paramLong - j)
          l2 = Float.MAX_VALUE; 
        if (l1 != l2)
          return i; 
      } 
    } else if (i >= 0) {
      long l1 = previousTransition(l);
      if (l1 < l) {
        int k = getOffset(l1);
        int m = k - i;
        if (l - l1 <= m)
          return k; 
      } 
    } 
    return j;
  }
  
  public long convertUTCToLocal(long paramLong) {
    int i = getOffset(paramLong);
    long l = paramLong + i;
    if ((paramLong ^ l) < 0L && (paramLong ^ i) >= 0L)
      throw new ArithmeticException("Adding time zone offset caused overflow"); 
    return l;
  }
  
  public long convertLocalToUTC(long paramLong1, boolean paramBoolean, long paramLong2) {
    int i = getOffset(paramLong2);
    long l = paramLong1 - i;
    int j = getOffset(l);
    if (j == i)
      return l; 
    return convertLocalToUTC(paramLong1, paramBoolean);
  }
  
  public long convertLocalToUTC(long paramLong, boolean paramBoolean) {
    int i = getOffset(paramLong);
    int j = getOffset(paramLong - i);
    if (i != j)
      if (paramBoolean || i < 0) {
        long l1 = nextTransition(paramLong - i);
        if (l1 == paramLong - i)
          l1 = Float.MAX_VALUE; 
        long l2 = nextTransition(paramLong - j);
        if (l2 == paramLong - j)
          l2 = Float.MAX_VALUE; 
        if (l1 != l2) {
          if (paramBoolean)
            throw new IllegalInstantException(paramLong, getID()); 
          j = i;
        } 
      }  
    long l = paramLong - j;
    if ((paramLong ^ l) < 0L && (paramLong ^ j) < 0L)
      throw new ArithmeticException("Subtracting time zone offset caused overflow"); 
    return l;
  }
  
  public long getMillisKeepLocal(DateTimeZone paramDateTimeZone, long paramLong) {
    if (paramDateTimeZone == null)
      paramDateTimeZone = getDefault(); 
    if (paramDateTimeZone == this)
      return paramLong; 
    long l = convertUTCToLocal(paramLong);
    return paramDateTimeZone.convertLocalToUTC(l, false, paramLong);
  }
  
  public boolean isLocalDateTimeGap(LocalDateTime paramLocalDateTime) {
    if (isFixed())
      return false; 
    try {
      paramLocalDateTime.toDateTime(this);
      return false;
    } catch (IllegalInstantException illegalInstantException) {
      return true;
    } 
  }
  
  public long adjustOffset(long paramLong, boolean paramBoolean) {
    long l1 = paramLong - 10800000L;
    long l2 = paramLong + 10800000L;
    long l3 = getOffset(l1);
    long l4 = getOffset(l2);
    if (l3 <= l4)
      return paramLong; 
    long l5 = l3 - l4;
    long l6 = nextTransition(l1);
    long l7 = l6 - l5;
    long l8 = l6 + l5;
    if (paramLong < l7 || paramLong >= l8)
      return paramLong; 
    long l9 = paramLong - l7;
    if (l9 >= l5)
      return paramBoolean ? paramLong : (paramLong - l5); 
    return paramBoolean ? (paramLong + l5) : paramLong;
  }
  
  public abstract boolean isFixed();
  
  public abstract long nextTransition(long paramLong);
  
  public abstract long previousTransition(long paramLong);
  
  public TimeZone toTimeZone() { return TimeZone.getTimeZone(this.iID); }
  
  public abstract boolean equals(Object paramObject);
  
  public int hashCode() { return 57 + getID().hashCode(); }
  
  public String toString() { return getID(); }
  
  protected Object writeReplace() throws ObjectStreamException { return new Stub(this.iID); }
}
