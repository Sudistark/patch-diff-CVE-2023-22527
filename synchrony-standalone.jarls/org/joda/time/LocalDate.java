package org.joda.time;

import java.io.Serializable;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashSet;
import java.util.Locale;
import java.util.Set;
import java.util.TimeZone;
import org.joda.convert.FromString;
import org.joda.convert.ToString;
import org.joda.time.base.BaseLocal;
import org.joda.time.chrono.ISOChronology;
import org.joda.time.convert.ConverterManager;
import org.joda.time.convert.PartialConverter;
import org.joda.time.field.FieldUtils;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.ISODateTimeFormat;

public final class LocalDate extends BaseLocal implements ReadablePartial, Serializable {
  private static final long serialVersionUID = -8775358157899L;
  
  private static final int YEAR = 0;
  
  private static final int MONTH_OF_YEAR = 1;
  
  private static final int DAY_OF_MONTH = 2;
  
  private static final Set<DurationFieldType> DATE_DURATION_TYPES = new HashSet();
  
  private final long iLocalMillis;
  
  private final Chronology iChronology;
  
  private int iHash;
  
  static  {
    DATE_DURATION_TYPES.add(DurationFieldType.days());
    DATE_DURATION_TYPES.add(DurationFieldType.weeks());
    DATE_DURATION_TYPES.add(DurationFieldType.months());
    DATE_DURATION_TYPES.add(DurationFieldType.weekyears());
    DATE_DURATION_TYPES.add(DurationFieldType.years());
    DATE_DURATION_TYPES.add(DurationFieldType.centuries());
    DATE_DURATION_TYPES.add(DurationFieldType.eras());
  }
  
  public static LocalDate now() { return new LocalDate(); }
  
  public static LocalDate now(DateTimeZone paramDateTimeZone) {
    if (paramDateTimeZone == null)
      throw new NullPointerException("Zone must not be null"); 
    return new LocalDate(paramDateTimeZone);
  }
  
  public static LocalDate now(Chronology paramChronology) {
    if (paramChronology == null)
      throw new NullPointerException("Chronology must not be null"); 
    return new LocalDate(paramChronology);
  }
  
  @FromString
  public static LocalDate parse(String paramString) { return parse(paramString, ISODateTimeFormat.localDateParser()); }
  
  public static LocalDate parse(String paramString, DateTimeFormatter paramDateTimeFormatter) { return paramDateTimeFormatter.parseLocalDate(paramString); }
  
  public static LocalDate fromCalendarFields(Calendar paramCalendar) {
    if (paramCalendar == null)
      throw new IllegalArgumentException("The calendar must not be null"); 
    int i = paramCalendar.get(0);
    int j = paramCalendar.get(1);
    return new LocalDate((i == 1) ? j : (1 - j), paramCalendar
        
        .get(2) + 1, paramCalendar
        .get(5));
  }
  
  public static LocalDate fromDateFields(Date paramDate) {
    if (paramDate == null)
      throw new IllegalArgumentException("The date must not be null"); 
    if (paramDate.getTime() < 0L) {
      GregorianCalendar gregorianCalendar = new GregorianCalendar();
      gregorianCalendar.setTime(paramDate);
      return fromCalendarFields(gregorianCalendar);
    } 
    return new LocalDate(paramDate
        .getYear() + 1900, paramDate
        .getMonth() + 1, paramDate
        .getDate());
  }
  
  public LocalDate() { this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance()); }
  
  public LocalDate(DateTimeZone paramDateTimeZone) { this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(paramDateTimeZone)); }
  
  public LocalDate(Chronology paramChronology) { this(DateTimeUtils.currentTimeMillis(), paramChronology); }
  
  public LocalDate(long paramLong) { this(paramLong, ISOChronology.getInstance()); }
  
  public LocalDate(long paramLong, DateTimeZone paramDateTimeZone) { this(paramLong, ISOChronology.getInstance(paramDateTimeZone)); }
  
  public LocalDate(long paramLong, Chronology paramChronology) {
    paramChronology = DateTimeUtils.getChronology(paramChronology);
    long l = paramChronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, paramLong);
    paramChronology = paramChronology.withUTC();
    this.iLocalMillis = paramChronology.dayOfMonth().roundFloor(l);
    this.iChronology = paramChronology;
  }
  
  public LocalDate(Object paramObject) { this(paramObject, (Chronology)null); }
  
  public LocalDate(Object paramObject, DateTimeZone paramDateTimeZone) {
    PartialConverter partialConverter = ConverterManager.getInstance().getPartialConverter(paramObject);
    Chronology chronology = partialConverter.getChronology(paramObject, paramDateTimeZone);
    chronology = DateTimeUtils.getChronology(chronology);
    this.iChronology = chronology.withUTC();
    int[] arrayOfInt = partialConverter.getPartialValues(this, paramObject, chronology, ISODateTimeFormat.localDateParser());
    this.iLocalMillis = this.iChronology.getDateTimeMillis(arrayOfInt[0], arrayOfInt[1], arrayOfInt[2], 0);
  }
  
  public LocalDate(Object paramObject, Chronology paramChronology) {
    PartialConverter partialConverter = ConverterManager.getInstance().getPartialConverter(paramObject);
    paramChronology = partialConverter.getChronology(paramObject, paramChronology);
    paramChronology = DateTimeUtils.getChronology(paramChronology);
    this.iChronology = paramChronology.withUTC();
    int[] arrayOfInt = partialConverter.getPartialValues(this, paramObject, paramChronology, ISODateTimeFormat.localDateParser());
    this.iLocalMillis = this.iChronology.getDateTimeMillis(arrayOfInt[0], arrayOfInt[1], arrayOfInt[2], 0);
  }
  
  public LocalDate(int paramInt1, int paramInt2, int paramInt3) { this(paramInt1, paramInt2, paramInt3, ISOChronology.getInstanceUTC()); }
  
  public LocalDate(int paramInt1, int paramInt2, int paramInt3, Chronology paramChronology) {
    paramChronology = DateTimeUtils.getChronology(paramChronology).withUTC();
    long l = paramChronology.getDateTimeMillis(paramInt1, paramInt2, paramInt3, 0);
    this.iChronology = paramChronology;
    this.iLocalMillis = l;
  }
  
  private Object readResolve() {
    if (this.iChronology == null)
      return new LocalDate(this.iLocalMillis, ISOChronology.getInstanceUTC()); 
    if (!DateTimeZone.UTC.equals(this.iChronology.getZone()))
      return new LocalDate(this.iLocalMillis, this.iChronology.withUTC()); 
    return this;
  }
  
  public int size() { return 3; }
  
  protected DateTimeField getField(int paramInt, Chronology paramChronology) {
    switch (paramInt) {
      case 0:
        return paramChronology.year();
      case 1:
        return paramChronology.monthOfYear();
      case 2:
        return paramChronology.dayOfMonth();
    } 
    throw new IndexOutOfBoundsException("Invalid index: " + paramInt);
  }
  
  public int getValue(int paramInt) {
    switch (paramInt) {
      case 0:
        return getChronology().year().get(getLocalMillis());
      case 1:
        return getChronology().monthOfYear().get(getLocalMillis());
      case 2:
        return getChronology().dayOfMonth().get(getLocalMillis());
    } 
    throw new IndexOutOfBoundsException("Invalid index: " + paramInt);
  }
  
  public int get(DateTimeFieldType paramDateTimeFieldType) {
    if (paramDateTimeFieldType == null)
      throw new IllegalArgumentException("The DateTimeFieldType must not be null"); 
    if (!isSupported(paramDateTimeFieldType))
      throw new IllegalArgumentException("Field '" + paramDateTimeFieldType + "' is not supported"); 
    return paramDateTimeFieldType.getField(getChronology()).get(getLocalMillis());
  }
  
  public boolean isSupported(DateTimeFieldType paramDateTimeFieldType) {
    if (paramDateTimeFieldType == null)
      return false; 
    DurationFieldType durationFieldType = paramDateTimeFieldType.getDurationType();
    if (DATE_DURATION_TYPES.contains(durationFieldType) || durationFieldType
      .getField(getChronology()).getUnitMillis() >= 
      getChronology().days().getUnitMillis())
      return paramDateTimeFieldType.getField(getChronology()).isSupported(); 
    return false;
  }
  
  public boolean isSupported(DurationFieldType paramDurationFieldType) {
    if (paramDurationFieldType == null)
      return false; 
    DurationField durationField = paramDurationFieldType.getField(getChronology());
    if (DATE_DURATION_TYPES.contains(paramDurationFieldType) || durationField
      .getUnitMillis() >= getChronology().days().getUnitMillis())
      return durationField.isSupported(); 
    return false;
  }
  
  protected long getLocalMillis() { return this.iLocalMillis; }
  
  public Chronology getChronology() { return this.iChronology; }
  
  public boolean equals(Object paramObject) {
    if (this == paramObject)
      return true; 
    if (paramObject instanceof LocalDate) {
      LocalDate localDate = (LocalDate)paramObject;
      if (this.iChronology.equals(localDate.iChronology))
        return (this.iLocalMillis == localDate.iLocalMillis); 
    } 
    return super.equals(paramObject);
  }
  
  public int hashCode() {
    int i = this.iHash;
    if (i == 0)
      i = this.iHash = super.hashCode(); 
    return i;
  }
  
  public int compareTo(ReadablePartial paramReadablePartial) {
    if (this == paramReadablePartial)
      return 0; 
    if (paramReadablePartial instanceof LocalDate) {
      LocalDate localDate = (LocalDate)paramReadablePartial;
      if (this.iChronology.equals(localDate.iChronology))
        return (this.iLocalMillis < localDate.iLocalMillis) ? -1 : ((this.iLocalMillis == localDate.iLocalMillis) ? 0 : 1); 
    } 
    return super.compareTo(paramReadablePartial);
  }
  
  public DateTime toDateTimeAtStartOfDay() { return toDateTimeAtStartOfDay(null); }
  
  public DateTime toDateTimeAtStartOfDay(DateTimeZone paramDateTimeZone) {
    paramDateTimeZone = DateTimeUtils.getZone(paramDateTimeZone);
    Chronology chronology = getChronology().withZone(paramDateTimeZone);
    long l1 = getLocalMillis() + 21600000L;
    long l2 = paramDateTimeZone.convertLocalToUTC(l1, false);
    l2 = chronology.dayOfMonth().roundFloor(l2);
    return new DateTime(l2, chronology);
  }
  
  @Deprecated
  public DateTime toDateTimeAtMidnight() { return toDateTimeAtMidnight(null); }
  
  @Deprecated
  public DateTime toDateTimeAtMidnight(DateTimeZone paramDateTimeZone) {
    paramDateTimeZone = DateTimeUtils.getZone(paramDateTimeZone);
    Chronology chronology = getChronology().withZone(paramDateTimeZone);
    return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chronology);
  }
  
  public DateTime toDateTimeAtCurrentTime() { return toDateTimeAtCurrentTime(null); }
  
  public DateTime toDateTimeAtCurrentTime(DateTimeZone paramDateTimeZone) {
    paramDateTimeZone = DateTimeUtils.getZone(paramDateTimeZone);
    Chronology chronology = getChronology().withZone(paramDateTimeZone);
    long l1 = DateTimeUtils.currentTimeMillis();
    long l2 = chronology.set(this, l1);
    return new DateTime(l2, chronology);
  }
  
  @Deprecated
  public DateMidnight toDateMidnight() { return toDateMidnight(null); }
  
  @Deprecated
  public DateMidnight toDateMidnight(DateTimeZone paramDateTimeZone) {
    paramDateTimeZone = DateTimeUtils.getZone(paramDateTimeZone);
    Chronology chronology = getChronology().withZone(paramDateTimeZone);
    return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chronology);
  }
  
  public LocalDateTime toLocalDateTime(LocalTime paramLocalTime) {
    if (paramLocalTime == null)
      throw new IllegalArgumentException("The time must not be null"); 
    if (getChronology() != paramLocalTime.getChronology())
      throw new IllegalArgumentException("The chronology of the time does not match"); 
    long l = getLocalMillis() + paramLocalTime.getLocalMillis();
    return new LocalDateTime(l, getChronology());
  }
  
  public DateTime toDateTime(LocalTime paramLocalTime) { return toDateTime(paramLocalTime, null); }
  
  public DateTime toDateTime(LocalTime paramLocalTime, DateTimeZone paramDateTimeZone) {
    if (paramLocalTime == null)
      return toDateTimeAtCurrentTime(paramDateTimeZone); 
    if (getChronology() != paramLocalTime.getChronology())
      throw new IllegalArgumentException("The chronology of the time does not match"); 
    Chronology chronology = getChronology().withZone(paramDateTimeZone);
    return new DateTime(
        getYear(), getMonthOfYear(), getDayOfMonth(), paramLocalTime
        .getHourOfDay(), paramLocalTime.getMinuteOfHour(), paramLocalTime
        .getSecondOfMinute(), paramLocalTime.getMillisOfSecond(), chronology);
  }
  
  public Interval toInterval() { return toInterval(null); }
  
  public Interval toInterval(DateTimeZone paramDateTimeZone) {
    paramDateTimeZone = DateTimeUtils.getZone(paramDateTimeZone);
    DateTime dateTime1 = toDateTimeAtStartOfDay(paramDateTimeZone);
    DateTime dateTime2 = plusDays(1).toDateTimeAtStartOfDay(paramDateTimeZone);
    return new Interval(dateTime1, dateTime2);
  }
  
  public Date toDate() {
    int i = getDayOfMonth();
    Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, i);
    LocalDate localDate = fromDateFields(date);
    if (localDate.isBefore(this)) {
      while (!localDate.equals(this)) {
        date.setTime(date.getTime() + 3600000L);
        localDate = fromDateFields(date);
      } 
      while (date.getDate() == i)
        date.setTime(date.getTime() - 1000L); 
      date.setTime(date.getTime() + 1000L);
    } else if (localDate.equals(this)) {
      Date date1 = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());
      if (date1.getDate() == i)
        date = date1; 
    } 
    return date;
  }
  
  LocalDate withLocalMillis(long paramLong) {
    paramLong = this.iChronology.dayOfMonth().roundFloor(paramLong);
    return (paramLong == getLocalMillis()) ? this : new LocalDate(paramLong, getChronology());
  }
  
  public LocalDate withFields(ReadablePartial paramReadablePartial) {
    if (paramReadablePartial == null)
      return this; 
    return withLocalMillis(getChronology().set(paramReadablePartial, getLocalMillis()));
  }
  
  public LocalDate withField(DateTimeFieldType paramDateTimeFieldType, int paramInt) {
    if (paramDateTimeFieldType == null)
      throw new IllegalArgumentException("Field must not be null"); 
    if (!isSupported(paramDateTimeFieldType))
      throw new IllegalArgumentException("Field '" + paramDateTimeFieldType + "' is not supported"); 
    long l = paramDateTimeFieldType.getField(getChronology()).set(getLocalMillis(), paramInt);
    return withLocalMillis(l);
  }
  
  public LocalDate withFieldAdded(DurationFieldType paramDurationFieldType, int paramInt) {
    if (paramDurationFieldType == null)
      throw new IllegalArgumentException("Field must not be null"); 
    if (!isSupported(paramDurationFieldType))
      throw new IllegalArgumentException("Field '" + paramDurationFieldType + "' is not supported"); 
    if (paramInt == 0)
      return this; 
    long l = paramDurationFieldType.getField(getChronology()).add(getLocalMillis(), paramInt);
    return withLocalMillis(l);
  }
  
  public LocalDate withPeriodAdded(ReadablePeriod paramReadablePeriod, int paramInt) {
    if (paramReadablePeriod == null || paramInt == 0)
      return this; 
    long l = getLocalMillis();
    Chronology chronology = getChronology();
    for (byte b = 0; b < paramReadablePeriod.size(); b++) {
      long l1 = FieldUtils.safeMultiply(paramReadablePeriod.getValue(b), paramInt);
      DurationFieldType durationFieldType = paramReadablePeriod.getFieldType(b);
      if (isSupported(durationFieldType))
        l = durationFieldType.getField(chronology).add(l, l1); 
    } 
    return withLocalMillis(l);
  }
  
  public LocalDate plus(ReadablePeriod paramReadablePeriod) { return withPeriodAdded(paramReadablePeriod, 1); }
  
  public LocalDate plusYears(int paramInt) {
    if (paramInt == 0)
      return this; 
    long l = getChronology().years().add(getLocalMillis(), paramInt);
    return withLocalMillis(l);
  }
  
  public LocalDate plusMonths(int paramInt) {
    if (paramInt == 0)
      return this; 
    long l = getChronology().months().add(getLocalMillis(), paramInt);
    return withLocalMillis(l);
  }
  
  public LocalDate plusWeeks(int paramInt) {
    if (paramInt == 0)
      return this; 
    long l = getChronology().weeks().add(getLocalMillis(), paramInt);
    return withLocalMillis(l);
  }
  
  public LocalDate plusDays(int paramInt) {
    if (paramInt == 0)
      return this; 
    long l = getChronology().days().add(getLocalMillis(), paramInt);
    return withLocalMillis(l);
  }
  
  public LocalDate minus(ReadablePeriod paramReadablePeriod) { return withPeriodAdded(paramReadablePeriod, -1); }
  
  public LocalDate minusYears(int paramInt) {
    if (paramInt == 0)
      return this; 
    long l = getChronology().years().subtract(getLocalMillis(), paramInt);
    return withLocalMillis(l);
  }
  
  public LocalDate minusMonths(int paramInt) {
    if (paramInt == 0)
      return this; 
    long l = getChronology().months().subtract(getLocalMillis(), paramInt);
    return withLocalMillis(l);
  }
  
  public LocalDate minusWeeks(int paramInt) {
    if (paramInt == 0)
      return this; 
    long l = getChronology().weeks().subtract(getLocalMillis(), paramInt);
    return withLocalMillis(l);
  }
  
  public LocalDate minusDays(int paramInt) {
    if (paramInt == 0)
      return this; 
    long l = getChronology().days().subtract(getLocalMillis(), paramInt);
    return withLocalMillis(l);
  }
  
  public Property property(DateTimeFieldType paramDateTimeFieldType) {
    if (paramDateTimeFieldType == null)
      throw new IllegalArgumentException("The DateTimeFieldType must not be null"); 
    if (!isSupported(paramDateTimeFieldType))
      throw new IllegalArgumentException("Field '" + paramDateTimeFieldType + "' is not supported"); 
    return new Property(this, paramDateTimeFieldType.getField(getChronology()));
  }
  
  public int getEra() { return getChronology().era().get(getLocalMillis()); }
  
  public int getCenturyOfEra() { return getChronology().centuryOfEra().get(getLocalMillis()); }
  
  public int getYearOfEra() { return getChronology().yearOfEra().get(getLocalMillis()); }
  
  public int getYearOfCentury() { return getChronology().yearOfCentury().get(getLocalMillis()); }
  
  public int getYear() { return getChronology().year().get(getLocalMillis()); }
  
  public int getWeekyear() { return getChronology().weekyear().get(getLocalMillis()); }
  
  public int getMonthOfYear() { return getChronology().monthOfYear().get(getLocalMillis()); }
  
  public int getWeekOfWeekyear() { return getChronology().weekOfWeekyear().get(getLocalMillis()); }
  
  public int getDayOfYear() { return getChronology().dayOfYear().get(getLocalMillis()); }
  
  public int getDayOfMonth() { return getChronology().dayOfMonth().get(getLocalMillis()); }
  
  public int getDayOfWeek() { return getChronology().dayOfWeek().get(getLocalMillis()); }
  
  public LocalDate withEra(int paramInt) { return withLocalMillis(getChronology().era().set(getLocalMillis(), paramInt)); }
  
  public LocalDate withCenturyOfEra(int paramInt) { return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), paramInt)); }
  
  public LocalDate withYearOfEra(int paramInt) { return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), paramInt)); }
  
  public LocalDate withYearOfCentury(int paramInt) { return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), paramInt)); }
  
  public LocalDate withYear(int paramInt) { return withLocalMillis(getChronology().year().set(getLocalMillis(), paramInt)); }
  
  public LocalDate withWeekyear(int paramInt) { return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), paramInt)); }
  
  public LocalDate withMonthOfYear(int paramInt) { return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), paramInt)); }
  
  public LocalDate withWeekOfWeekyear(int paramInt) { return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), paramInt)); }
  
  public LocalDate withDayOfYear(int paramInt) { return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), paramInt)); }
  
  public LocalDate withDayOfMonth(int paramInt) { return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), paramInt)); }
  
  public LocalDate withDayOfWeek(int paramInt) { return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), paramInt)); }
  
  public Property era() { return new Property(this, getChronology().era()); }
  
  public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); }
  
  public Property yearOfCentury() { return new Property(this, getChronology().yearOfCentury()); }
  
  public Property yearOfEra() { return new Property(this, getChronology().yearOfEra()); }
  
  public Property year() { return new Property(this, getChronology().year()); }
  
  public Property weekyear() { return new Property(this, getChronology().weekyear()); }
  
  public Property monthOfYear() { return new Property(this, getChronology().monthOfYear()); }
  
  public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); }
  
  public Property dayOfYear() { return new Property(this, getChronology().dayOfYear()); }
  
  public Property dayOfMonth() { return new Property(this, getChronology().dayOfMonth()); }
  
  public Property dayOfWeek() { return new Property(this, getChronology().dayOfWeek()); }
  
  @ToString
  public String toString() { return ISODateTimeFormat.date().print(this); }
  
  public String toString(String paramString) {
    if (paramString == null)
      return toString(); 
    return DateTimeFormat.forPattern(paramString).print(this);
  }
  
  public String toString(String paramString, Locale paramLocale) throws IllegalArgumentException {
    if (paramString == null)
      return toString(); 
    return DateTimeFormat.forPattern(paramString).withLocale(paramLocale).print(this);
  }
}
