package org.joda.time.chrono;

import java.util.HashMap;
import org.joda.time.Chronology;
import org.joda.time.DateTime;
import org.joda.time.DateTimeField;
import org.joda.time.DateTimeZone;
import org.joda.time.DurationField;
import org.joda.time.MutableDateTime;
import org.joda.time.ReadableDateTime;
import org.joda.time.field.FieldUtils;

public final class LimitChronology extends AssembledChronology {
  private static final long serialVersionUID = 7670866536893052522L;
  
  final DateTime iLowerLimit;
  
  final DateTime iUpperLimit;
  
  private LimitChronology iWithUTC;
  
  public static LimitChronology getInstance(Chronology paramChronology, ReadableDateTime paramReadableDateTime1, ReadableDateTime paramReadableDateTime2) {
    if (paramChronology == null)
      throw new IllegalArgumentException("Must supply a chronology"); 
    DateTime dateTime1 = (paramReadableDateTime1 == null) ? null : paramReadableDateTime1.toDateTime();
    DateTime dateTime2 = (paramReadableDateTime2 == null) ? null : paramReadableDateTime2.toDateTime();
    if (dateTime1 != null && dateTime2 != null && !dateTime1.isBefore(dateTime2))
      throw new IllegalArgumentException("The lower limit must be come before than the upper limit"); 
    return new LimitChronology(paramChronology, (DateTime)dateTime1, (DateTime)dateTime2);
  }
  
  private LimitChronology(Chronology paramChronology, DateTime paramDateTime1, DateTime paramDateTime2) {
    super(paramChronology, null);
    this.iLowerLimit = paramDateTime1;
    this.iUpperLimit = paramDateTime2;
  }
  
  public DateTime getLowerLimit() { return this.iLowerLimit; }
  
  public DateTime getUpperLimit() { return this.iUpperLimit; }
  
  public Chronology withUTC() { return withZone(DateTimeZone.UTC); }
  
  public Chronology withZone(DateTimeZone paramDateTimeZone) {
    if (paramDateTimeZone == null)
      paramDateTimeZone = DateTimeZone.getDefault(); 
    if (paramDateTimeZone == getZone())
      return this; 
    if (paramDateTimeZone == DateTimeZone.UTC && this.iWithUTC != null)
      return this.iWithUTC; 
    DateTime dateTime1 = this.iLowerLimit;
    if (dateTime1 != null) {
      MutableDateTime mutableDateTime = dateTime1.toMutableDateTime();
      mutableDateTime.setZoneRetainFields(paramDateTimeZone);
      dateTime1 = mutableDateTime.toDateTime();
    } 
    DateTime dateTime2 = this.iUpperLimit;
    if (dateTime2 != null) {
      MutableDateTime mutableDateTime = dateTime2.toMutableDateTime();
      mutableDateTime.setZoneRetainFields(paramDateTimeZone);
      dateTime2 = mutableDateTime.toDateTime();
    } 
    LimitChronology limitChronology = getInstance(getBase().withZone(paramDateTimeZone), dateTime1, dateTime2);
    if (paramDateTimeZone == DateTimeZone.UTC)
      this.iWithUTC = limitChronology; 
    return limitChronology;
  }
  
  public long getDateTimeMillis(int paramInt1, int paramInt2, int paramInt3, int paramInt4) throws IllegalArgumentException {
    long l = getBase().getDateTimeMillis(paramInt1, paramInt2, paramInt3, paramInt4);
    checkLimits(l, "resulting");
    return l;
  }
  
  public long getDateTimeMillis(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7) throws IllegalArgumentException {
    long l = getBase().getDateTimeMillis(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7);
    checkLimits(l, "resulting");
    return l;
  }
  
  public long getDateTimeMillis(long paramLong, int paramInt1, int paramInt2, int paramInt3, int paramInt4) throws IllegalArgumentException {
    checkLimits(paramLong, null);
    paramLong = getBase().getDateTimeMillis(paramLong, paramInt1, paramInt2, paramInt3, paramInt4);
    checkLimits(paramLong, "resulting");
    return paramLong;
  }
  
  protected void assemble(AssembledChronology.Fields paramFields) {
    HashMap hashMap = new HashMap();
    paramFields.eras = convertField(paramFields.eras, hashMap);
    paramFields.centuries = convertField(paramFields.centuries, hashMap);
    paramFields.years = convertField(paramFields.years, hashMap);
    paramFields.months = convertField(paramFields.months, hashMap);
    paramFields.weekyears = convertField(paramFields.weekyears, hashMap);
    paramFields.weeks = convertField(paramFields.weeks, hashMap);
    paramFields.days = convertField(paramFields.days, hashMap);
    paramFields.halfdays = convertField(paramFields.halfdays, hashMap);
    paramFields.hours = convertField(paramFields.hours, hashMap);
    paramFields.minutes = convertField(paramFields.minutes, hashMap);
    paramFields.seconds = convertField(paramFields.seconds, hashMap);
    paramFields.millis = convertField(paramFields.millis, hashMap);
    paramFields.year = convertField(paramFields.year, hashMap);
    paramFields.yearOfEra = convertField(paramFields.yearOfEra, hashMap);
    paramFields.yearOfCentury = convertField(paramFields.yearOfCentury, hashMap);
    paramFields.centuryOfEra = convertField(paramFields.centuryOfEra, hashMap);
    paramFields.era = convertField(paramFields.era, hashMap);
    paramFields.dayOfWeek = convertField(paramFields.dayOfWeek, hashMap);
    paramFields.dayOfMonth = convertField(paramFields.dayOfMonth, hashMap);
    paramFields.dayOfYear = convertField(paramFields.dayOfYear, hashMap);
    paramFields.monthOfYear = convertField(paramFields.monthOfYear, hashMap);
    paramFields.weekOfWeekyear = convertField(paramFields.weekOfWeekyear, hashMap);
    paramFields.weekyear = convertField(paramFields.weekyear, hashMap);
    paramFields.weekyearOfCentury = convertField(paramFields.weekyearOfCentury, hashMap);
    paramFields.millisOfSecond = convertField(paramFields.millisOfSecond, hashMap);
    paramFields.millisOfDay = convertField(paramFields.millisOfDay, hashMap);
    paramFields.secondOfMinute = convertField(paramFields.secondOfMinute, hashMap);
    paramFields.secondOfDay = convertField(paramFields.secondOfDay, hashMap);
    paramFields.minuteOfHour = convertField(paramFields.minuteOfHour, hashMap);
    paramFields.minuteOfDay = convertField(paramFields.minuteOfDay, hashMap);
    paramFields.hourOfDay = convertField(paramFields.hourOfDay, hashMap);
    paramFields.hourOfHalfday = convertField(paramFields.hourOfHalfday, hashMap);
    paramFields.clockhourOfDay = convertField(paramFields.clockhourOfDay, hashMap);
    paramFields.clockhourOfHalfday = convertField(paramFields.clockhourOfHalfday, hashMap);
    paramFields.halfdayOfDay = convertField(paramFields.halfdayOfDay, hashMap);
  }
  
  private DurationField convertField(DurationField paramDurationField, HashMap<Object, Object> paramHashMap) {
    if (paramDurationField == null || !paramDurationField.isSupported())
      return paramDurationField; 
    if (paramHashMap.containsKey(paramDurationField))
      return (DurationField)paramHashMap.get(paramDurationField); 
    LimitDurationField limitDurationField = new LimitDurationField(this, paramDurationField);
    paramHashMap.put(paramDurationField, limitDurationField);
    return limitDurationField;
  }
  
  private DateTimeField convertField(DateTimeField paramDateTimeField, HashMap<Object, Object> paramHashMap) {
    if (paramDateTimeField == null || !paramDateTimeField.isSupported())
      return paramDateTimeField; 
    if (paramHashMap.containsKey(paramDateTimeField))
      return (DateTimeField)paramHashMap.get(paramDateTimeField); 
    LimitDateTimeField limitDateTimeField = new LimitDateTimeField(this, paramDateTimeField, convertField(paramDateTimeField.getDurationField(), paramHashMap), convertField(paramDateTimeField.getRangeDurationField(), paramHashMap), convertField(paramDateTimeField.getLeapDurationField(), paramHashMap));
    paramHashMap.put(paramDateTimeField, limitDateTimeField);
    return limitDateTimeField;
  }
  
  void checkLimits(long paramLong, String paramString) {
    DateTime dateTime;
    if ((dateTime = this.iLowerLimit) != null && paramLong < dateTime.getMillis())
      throw new LimitException(this, paramString, true); 
    if ((dateTime = this.iUpperLimit) != null && paramLong >= dateTime.getMillis())
      throw new LimitException(this, paramString, false); 
  }
  
  public boolean equals(Object paramObject) {
    if (this == paramObject)
      return true; 
    if (!(paramObject instanceof LimitChronology))
      return false; 
    LimitChronology limitChronology = (LimitChronology)paramObject;
    return (
      getBase().equals(limitChronology.getBase()) && 
      FieldUtils.equals(getLowerLimit(), limitChronology.getLowerLimit()) && 
      FieldUtils.equals(getUpperLimit(), limitChronology.getUpperLimit()));
  }
  
  public int hashCode() {
    null = 317351877;
    null += ((getLowerLimit() != null) ? getLowerLimit().hashCode() : 0);
    null += ((getUpperLimit() != null) ? getUpperLimit().hashCode() : 0);
    return getBase().hashCode() * 7;
  }
  
  public String toString() {
    return "LimitChronology[" + getBase().toString() + ", " + (
      (getLowerLimit() == null) ? "NoLimit" : getLowerLimit().toString()) + ", " + (
      (getUpperLimit() == null) ? "NoLimit" : getUpperLimit().toString()) + ']';
  }
}
