package org.joda.time.chrono;

import java.util.concurrent.ConcurrentHashMap;
import org.joda.time.Chronology;
import org.joda.time.DateTime;
import org.joda.time.DateTimeField;
import org.joda.time.DateTimeFieldType;
import org.joda.time.DateTimeZone;
import org.joda.time.DurationFieldType;
import org.joda.time.field.DelegatedDateTimeField;
import org.joda.time.field.DividedDateTimeField;
import org.joda.time.field.OffsetDateTimeField;
import org.joda.time.field.RemainderDateTimeField;
import org.joda.time.field.SkipUndoDateTimeField;
import org.joda.time.field.UnsupportedDurationField;

public final class BuddhistChronology extends AssembledChronology {
  private static final long serialVersionUID = -3474595157769370126L;
  
  public static final int BE = 1;
  
  private static final DateTimeField ERA_FIELD = new BasicSingleEraDateTimeField("BE");
  
  private static final int BUDDHIST_OFFSET = 543;
  
  private static final ConcurrentHashMap<DateTimeZone, BuddhistChronology> cCache = new ConcurrentHashMap();
  
  private static final BuddhistChronology INSTANCE_UTC = getInstance(DateTimeZone.UTC);
  
  public static BuddhistChronology getInstanceUTC() { return INSTANCE_UTC; }
  
  public static BuddhistChronology getInstance() { return getInstance(DateTimeZone.getDefault()); }
  
  public static BuddhistChronology getInstance(DateTimeZone paramDateTimeZone) {
    if (paramDateTimeZone == null)
      paramDateTimeZone = DateTimeZone.getDefault(); 
    BuddhistChronology buddhistChronology = (BuddhistChronology)cCache.get(paramDateTimeZone);
    if (buddhistChronology == null) {
      buddhistChronology = new BuddhistChronology(GJChronology.getInstance(paramDateTimeZone, null), null);
      DateTime dateTime = new DateTime(1, 1, 1, 0, 0, 0, 0, buddhistChronology);
      buddhistChronology = new BuddhistChronology(LimitChronology.getInstance(buddhistChronology, dateTime, null), "");
      BuddhistChronology buddhistChronology1 = (BuddhistChronology)cCache.putIfAbsent(paramDateTimeZone, buddhistChronology);
      if (buddhistChronology1 != null)
        buddhistChronology = buddhistChronology1; 
    } 
    return buddhistChronology;
  }
  
  private BuddhistChronology(Chronology paramChronology, Object paramObject) { super(paramChronology, paramObject); }
  
  private Object readResolve() {
    Chronology chronology = getBase();
    return (chronology == null) ? getInstanceUTC() : getInstance(chronology.getZone());
  }
  
  public Chronology withUTC() { return INSTANCE_UTC; }
  
  public Chronology withZone(DateTimeZone paramDateTimeZone) {
    if (paramDateTimeZone == null)
      paramDateTimeZone = DateTimeZone.getDefault(); 
    if (paramDateTimeZone == getZone())
      return this; 
    return getInstance(paramDateTimeZone);
  }
  
  public boolean equals(Object paramObject) {
    if (this == paramObject)
      return true; 
    if (paramObject instanceof BuddhistChronology) {
      BuddhistChronology buddhistChronology = (BuddhistChronology)paramObject;
      return getZone().equals(buddhistChronology.getZone());
    } 
    return false;
  }
  
  public int hashCode() { return "Buddhist".hashCode() * 11 + getZone().hashCode(); }
  
  public String toString() {
    String str = "BuddhistChronology";
    DateTimeZone dateTimeZone = getZone();
    if (dateTimeZone != null)
      str = str + '[' + dateTimeZone.getID() + ']'; 
    return str;
  }
  
  protected void assemble(AssembledChronology.Fields paramFields) {
    if (getParam() == null) {
      paramFields.eras = UnsupportedDurationField.getInstance(DurationFieldType.eras());
      DateTimeField dateTimeField = paramFields.year;
      paramFields.year = new OffsetDateTimeField(new SkipUndoDateTimeField(this, dateTimeField), 543);
      dateTimeField = paramFields.yearOfEra;
      paramFields
        .yearOfEra = new DelegatedDateTimeField(paramFields.year, paramFields.eras, DateTimeFieldType.yearOfEra());
      dateTimeField = paramFields.weekyear;
      paramFields.weekyear = new OffsetDateTimeField(new SkipUndoDateTimeField(this, dateTimeField), 543);
      OffsetDateTimeField offsetDateTimeField = new OffsetDateTimeField(paramFields.yearOfEra, 99);
      paramFields
        .centuryOfEra = new DividedDateTimeField(offsetDateTimeField, paramFields.eras, DateTimeFieldType.centuryOfEra(), 100);
      paramFields.centuries = paramFields.centuryOfEra.getDurationField();
      RemainderDateTimeField remainderDateTimeField = new RemainderDateTimeField((DividedDateTimeField)paramFields.centuryOfEra);
      paramFields
        .yearOfCentury = new OffsetDateTimeField(remainderDateTimeField, DateTimeFieldType.yearOfCentury(), 1);
      remainderDateTimeField = new RemainderDateTimeField(paramFields.weekyear, paramFields.centuries, DateTimeFieldType.weekyearOfCentury(), 100);
      paramFields
        .weekyearOfCentury = new OffsetDateTimeField(remainderDateTimeField, DateTimeFieldType.weekyearOfCentury(), 1);
      paramFields.era = ERA_FIELD;
    } 
  }
}
