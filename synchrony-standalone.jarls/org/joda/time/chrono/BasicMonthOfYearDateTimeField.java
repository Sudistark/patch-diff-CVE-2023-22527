package org.joda.time.chrono;

import org.joda.time.DateTimeFieldType;
import org.joda.time.DateTimeUtils;
import org.joda.time.DurationField;
import org.joda.time.ReadablePartial;
import org.joda.time.field.FieldUtils;
import org.joda.time.field.ImpreciseDateTimeField;

class BasicMonthOfYearDateTimeField extends ImpreciseDateTimeField {
  private static final long serialVersionUID = -8258715387168736L;
  
  private static final int MIN = 1;
  
  private final BasicChronology iChronology;
  
  private final int iMax;
  
  private final int iLeapMonth;
  
  BasicMonthOfYearDateTimeField(BasicChronology paramBasicChronology, int paramInt) {
    super(DateTimeFieldType.monthOfYear(), paramBasicChronology.getAverageMillisPerMonth());
    this.iChronology = paramBasicChronology;
    this.iMax = this.iChronology.getMaxMonth();
    this.iLeapMonth = paramInt;
  }
  
  public boolean isLenient() { return false; }
  
  public int get(long paramLong) { return this.iChronology.getMonthOfYear(paramLong); }
  
  public long add(long paramLong, int paramInt) {
    if (paramInt == 0)
      return paramLong; 
    long l1 = this.iChronology.getMillisOfDay(paramLong);
    int i = this.iChronology.getYear(paramLong);
    int j = this.iChronology.getMonthOfYear(paramLong, i);
    int k = i;
    int m = j - 1 + paramInt;
    if (j > 0 && m < 0) {
      if (Math.signum((paramInt + this.iMax)) == Math.signum(paramInt)) {
        k--;
        paramInt += this.iMax;
      } else {
        k++;
        paramInt -= this.iMax;
      } 
      m = j - 1 + paramInt;
    } 
    if (m >= 0) {
      k += m / this.iMax;
      m = m % this.iMax + 1;
    } else {
      k = k + m / this.iMax - 1;
      m = Math.abs(m);
      int i2 = m % this.iMax;
      if (i2 == 0)
        i2 = this.iMax; 
      m = this.iMax - i2 + 1;
      if (m == 1)
        k++; 
    } 
    int n = this.iChronology.getDayOfMonth(paramLong, i, j);
    int i1 = this.iChronology.getDaysInYearMonth(k, m);
    if (n > i1)
      n = i1; 
    long l2 = this.iChronology.getYearMonthDayMillis(k, m, n);
    return l2 + l1;
  }
  
  public long add(long paramLong1, long paramLong2) {
    long l2;
    int i = (int)paramLong2;
    if (i == paramLong2)
      return add(paramLong1, i); 
    long l1 = this.iChronology.getMillisOfDay(paramLong1);
    int j = this.iChronology.getYear(paramLong1);
    int k = this.iChronology.getMonthOfYear(paramLong1, j);
    long l3 = (k - 1) + paramLong2;
    if (l3 >= 0L) {
      l2 = j + l3 / this.iMax;
      l3 = l3 % this.iMax + 1L;
    } else {
      l2 = j + l3 / this.iMax - 1L;
      l3 = Math.abs(l3);
      int i3 = (int)(l3 % this.iMax);
      if (i3 == 0)
        i3 = this.iMax; 
      l3 = (this.iMax - i3 + 1);
      if (l3 == 1L)
        l2++; 
    } 
    if (l2 < this.iChronology.getMinYear() || l2 > this.iChronology
      .getMaxYear())
      throw new IllegalArgumentException("Magnitude of add amount is too large: " + paramLong2); 
    int m = (int)l2;
    int n = (int)l3;
    int i1 = this.iChronology.getDayOfMonth(paramLong1, j, k);
    int i2 = this.iChronology.getDaysInYearMonth(m, n);
    if (i1 > i2)
      i1 = i2; 
    long l4 = this.iChronology.getYearMonthDayMillis(m, n, i1);
    return l4 + l1;
  }
  
  public int[] add(ReadablePartial paramReadablePartial, int paramInt1, int[] paramArrayOfInt, int paramInt2) {
    if (paramInt2 == 0)
      return paramArrayOfInt; 
    if (paramReadablePartial.size() > 0 && paramReadablePartial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && paramInt1 == 0) {
      int i = paramArrayOfInt[0] - 1;
      int j = (i + paramInt2 % 12 + 12) % 12 + 1;
      return set(paramReadablePartial, 0, paramArrayOfInt, j);
    } 
    if (DateTimeUtils.isContiguous(paramReadablePartial)) {
      long l = 0L;
      byte b;
      int i;
      for (b = 0, i = paramReadablePartial.size(); b < i; b++)
        l = paramReadablePartial.getFieldType(b).getField(this.iChronology).set(l, paramArrayOfInt[b]); 
      l = add(l, paramInt2);
      return this.iChronology.get(paramReadablePartial, l);
    } 
    return super.add(paramReadablePartial, paramInt1, paramArrayOfInt, paramInt2);
  }
  
  public long addWrapField(long paramLong, int paramInt) { return set(paramLong, FieldUtils.getWrappedValue(get(paramLong), paramInt, 1, this.iMax)); }
  
  public long getDifferenceAsLong(long paramLong1, long paramLong2) {
    if (paramLong1 < paramLong2)
      return -getDifference(paramLong2, paramLong1); 
    int i = this.iChronology.getYear(paramLong1);
    int j = this.iChronology.getMonthOfYear(paramLong1, i);
    int k = this.iChronology.getYear(paramLong2);
    int m = this.iChronology.getMonthOfYear(paramLong2, k);
    long l1 = (i - k) * this.iMax + j - m;
    int n = this.iChronology.getDayOfMonth(paramLong1, i, j);
    if (n == this.iChronology.getDaysInYearMonth(i, j)) {
      int i1 = this.iChronology.getDayOfMonth(paramLong2, k, m);
      if (i1 > n)
        paramLong2 = this.iChronology.dayOfMonth().set(paramLong2, n); 
    } 
    long l2 = paramLong1 - this.iChronology.getYearMonthMillis(i, j);
    long l3 = paramLong2 - this.iChronology.getYearMonthMillis(k, m);
    if (l2 < l3)
      l1--; 
    return l1;
  }
  
  public long set(long paramLong, int paramInt) {
    FieldUtils.verifyValueBounds(this, paramInt, 1, this.iMax);
    int i = this.iChronology.getYear(paramLong);
    int j = this.iChronology.getDayOfMonth(paramLong, i);
    int k = this.iChronology.getDaysInYearMonth(i, paramInt);
    if (j > k)
      j = k; 
    return this.iChronology.getYearMonthDayMillis(i, paramInt, j) + this.iChronology
      .getMillisOfDay(paramLong);
  }
  
  public DurationField getRangeDurationField() { return this.iChronology.years(); }
  
  public boolean isLeap(long paramLong) {
    int i = this.iChronology.getYear(paramLong);
    if (this.iChronology.isLeapYear(i))
      return (this.iChronology.getMonthOfYear(paramLong, i) == this.iLeapMonth); 
    return false;
  }
  
  public int getLeapAmount(long paramLong) { return isLeap(paramLong) ? 1 : 0; }
  
  public DurationField getLeapDurationField() { return this.iChronology.days(); }
  
  public int getMinimumValue() { return 1; }
  
  public int getMaximumValue() { return this.iMax; }
  
  public long roundFloor(long paramLong) {
    int i = this.iChronology.getYear(paramLong);
    int j = this.iChronology.getMonthOfYear(paramLong, i);
    return this.iChronology.getYearMonthMillis(i, j);
  }
  
  public long remainder(long paramLong) { return paramLong - roundFloor(paramLong); }
  
  private Object readResolve() { return this.iChronology.monthOfYear(); }
}
