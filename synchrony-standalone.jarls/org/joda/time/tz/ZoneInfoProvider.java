package org.joda.time.tz;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.ref.SoftReference;
import java.security.AccessController;
import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import org.joda.time.DateTimeZone;

public class ZoneInfoProvider implements Provider {
  private final File iFileDir;
  
  private final String iResourcePath;
  
  private final ClassLoader iLoader;
  
  private final Map<String, Object> iZoneInfoMap;
  
  private final Set<String> iZoneInfoKeys;
  
  public ZoneInfoProvider() throws IOException { this("org/joda/time/tz/data"); }
  
  public ZoneInfoProvider(File paramFile) throws IOException {
    if (paramFile == null)
      throw new IllegalArgumentException("No file directory provided"); 
    if (!paramFile.exists())
      throw new IOException("File directory doesn't exist: " + paramFile); 
    if (!paramFile.isDirectory())
      throw new IOException("File doesn't refer to a directory: " + paramFile); 
    this.iFileDir = paramFile;
    this.iResourcePath = null;
    this.iLoader = null;
    this.iZoneInfoMap = loadZoneInfoMap(openResource("ZoneInfoMap"));
    this.iZoneInfoKeys = Collections.unmodifiableSortedSet(new TreeSet(this.iZoneInfoMap.keySet()));
  }
  
  public ZoneInfoProvider(String paramString) throws IOException { this(paramString, null, false); }
  
  public ZoneInfoProvider(String paramString, ClassLoader paramClassLoader) throws IOException { this(paramString, paramClassLoader, true); }
  
  private ZoneInfoProvider(String paramString, ClassLoader paramClassLoader, boolean paramBoolean) throws IOException {
    if (paramString == null)
      throw new IllegalArgumentException("No resource path provided"); 
    if (!paramString.endsWith("/"))
      paramString = paramString + '/'; 
    this.iFileDir = null;
    this.iResourcePath = paramString;
    if (paramClassLoader == null && !paramBoolean)
      paramClassLoader = getClass().getClassLoader(); 
    this.iLoader = paramClassLoader;
    this.iZoneInfoMap = loadZoneInfoMap(openResource("ZoneInfoMap"));
    this.iZoneInfoKeys = Collections.unmodifiableSortedSet(new TreeSet(this.iZoneInfoMap.keySet()));
  }
  
  public DateTimeZone getZone(String paramString) {
    if (paramString == null)
      return null; 
    Object object = this.iZoneInfoMap.get(paramString);
    if (object == null)
      return null; 
    if (object instanceof SoftReference) {
      SoftReference softReference = (SoftReference)object;
      DateTimeZone dateTimeZone = (DateTimeZone)softReference.get();
      if (dateTimeZone != null)
        return dateTimeZone; 
      return loadZoneData(paramString);
    } 
    if (paramString.equals(object))
      return loadZoneData(paramString); 
    return getZone((String)object);
  }
  
  public Set<String> getAvailableIDs() { return this.iZoneInfoKeys; }
  
  protected void uncaughtException(Exception paramException) { paramException.printStackTrace(); }
  
  private InputStream openResource(String paramString) throws IOException {
    InputStream inputStream;
    if (this.iFileDir != null) {
      inputStream = new FileInputStream(new File(this.iFileDir, paramString));
    } else {
      String str = this.iResourcePath.concat(paramString);
      inputStream = (InputStream)AccessController.doPrivileged(new Object(this, str));
      if (inputStream == null) {
        StringBuilder stringBuilder = (new StringBuilder(40)).append("Resource not found: \"").append(str).append("\" ClassLoader: ").append((this.iLoader != null) ? this.iLoader.toString() : "system");
        throw new IOException(stringBuilder.toString());
      } 
    } 
    return inputStream;
  }
  
  private DateTimeZone loadZoneData(String paramString) {
    inputStream = null;
    try {
      inputStream = openResource(paramString);
      DateTimeZone dateTimeZone = DateTimeZoneBuilder.readFrom(inputStream, paramString);
      this.iZoneInfoMap.put(paramString, new SoftReference(dateTimeZone));
      return dateTimeZone;
    } catch (IOException iOException) {
      uncaughtException(iOException);
      this.iZoneInfoMap.remove(paramString);
      return null;
    } finally {
      try {
        if (inputStream != null)
          inputStream.close(); 
      } catch (IOException iOException) {}
    } 
  }
  
  private static Map<String, Object> loadZoneInfoMap(InputStream paramInputStream) throws IOException {
    ConcurrentHashMap concurrentHashMap = new ConcurrentHashMap();
    dataInputStream = new DataInputStream(paramInputStream);
    try {
      readZoneInfoMap(dataInputStream, concurrentHashMap);
    } finally {
      try {
        dataInputStream.close();
      } catch (IOException iOException) {}
    } 
    concurrentHashMap.put("UTC", new SoftReference(DateTimeZone.UTC));
    return concurrentHashMap;
  }
  
  private static void readZoneInfoMap(DataInputStream paramDataInputStream, Map<String, Object> paramMap) throws IOException {
    int i = paramDataInputStream.readUnsignedShort();
    String[] arrayOfString = new String[i];
    byte b;
    for (b = 0; b < i; b++)
      arrayOfString[b] = paramDataInputStream.readUTF().intern(); 
    i = paramDataInputStream.readUnsignedShort();
    for (b = 0; b < i; b++) {
      try {
        paramMap.put(arrayOfString[paramDataInputStream.readUnsignedShort()], arrayOfString[paramDataInputStream.readUnsignedShort()]);
      } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {
        throw new IOException("Corrupt zone info map");
      } 
    } 
  }
}
