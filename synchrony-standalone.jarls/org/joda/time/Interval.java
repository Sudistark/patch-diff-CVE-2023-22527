package org.joda.time;

import java.io.Serializable;
import org.joda.time.base.BaseInterval;
import org.joda.time.chrono.ISOChronology;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.ISODateTimeFormat;
import org.joda.time.format.ISOPeriodFormat;
import org.joda.time.format.PeriodFormatter;

public final class Interval extends BaseInterval implements ReadableInterval, Serializable {
  private static final long serialVersionUID = 4922451897541386752L;
  
  public static Interval parse(String paramString) { return new Interval(paramString); }
  
  public static Interval parseWithOffset(String paramString) {
    int i = paramString.indexOf('/');
    if (i < 0)
      throw new IllegalArgumentException("Format requires a '/' separator: " + paramString); 
    String str1 = paramString.substring(0, i);
    if (str1.length() <= 0)
      throw new IllegalArgumentException("Format invalid: " + paramString); 
    String str2 = paramString.substring(i + 1);
    if (str2.length() <= 0)
      throw new IllegalArgumentException("Format invalid: " + paramString); 
    DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.dateTimeParser().withOffsetParsed();
    PeriodFormatter periodFormatter = ISOPeriodFormat.standard();
    DateTime dateTime1 = null;
    Period period = null;
    char c = str1.charAt(0);
    if (c == 'P' || c == 'p') {
      period = periodFormatter.withParseType(PeriodType.standard()).parsePeriod(str1);
    } else {
      dateTime1 = dateTimeFormatter.parseDateTime(str1);
    } 
    c = str2.charAt(0);
    if (c == 'P' || c == 'p') {
      if (period != null)
        throw new IllegalArgumentException("Interval composed of two durations: " + paramString); 
      period = periodFormatter.withParseType(PeriodType.standard()).parsePeriod(str2);
      return new Interval(dateTime1, period);
    } 
    DateTime dateTime2 = dateTimeFormatter.parseDateTime(str2);
    if (period != null)
      return new Interval(period, dateTime2); 
    return new Interval(dateTime1, dateTime2);
  }
  
  public Interval(long paramLong1, long paramLong2) { super(paramLong1, paramLong2, null); }
  
  public Interval(long paramLong1, long paramLong2, DateTimeZone paramDateTimeZone) { super(paramLong1, paramLong2, ISOChronology.getInstance(paramDateTimeZone)); }
  
  public Interval(long paramLong1, long paramLong2, Chronology paramChronology) { super(paramLong1, paramLong2, paramChronology); }
  
  public Interval(ReadableInstant paramReadableInstant1, ReadableInstant paramReadableInstant2) { super(paramReadableInstant1, paramReadableInstant2); }
  
  public Interval(ReadableInstant paramReadableInstant, ReadableDuration paramReadableDuration) { super(paramReadableInstant, paramReadableDuration); }
  
  public Interval(ReadableDuration paramReadableDuration, ReadableInstant paramReadableInstant) { super(paramReadableDuration, paramReadableInstant); }
  
  public Interval(ReadableInstant paramReadableInstant, ReadablePeriod paramReadablePeriod) { super(paramReadableInstant, paramReadablePeriod); }
  
  public Interval(ReadablePeriod paramReadablePeriod, ReadableInstant paramReadableInstant) { super(paramReadablePeriod, paramReadableInstant); }
  
  public Interval(Object paramObject) { super(paramObject, null); }
  
  public Interval(Object paramObject, Chronology paramChronology) { super(paramObject, paramChronology); }
  
  public Interval toInterval() { return this; }
  
  public Interval overlap(ReadableInterval paramReadableInterval) {
    paramReadableInterval = DateTimeUtils.getReadableInterval(paramReadableInterval);
    if (!overlaps(paramReadableInterval))
      return null; 
    long l1 = Math.max(getStartMillis(), paramReadableInterval.getStartMillis());
    long l2 = Math.min(getEndMillis(), paramReadableInterval.getEndMillis());
    return new Interval(l1, l2, getChronology());
  }
  
  public Interval gap(ReadableInterval paramReadableInterval) {
    paramReadableInterval = DateTimeUtils.getReadableInterval(paramReadableInterval);
    long l1 = paramReadableInterval.getStartMillis();
    long l2 = paramReadableInterval.getEndMillis();
    long l3 = getStartMillis();
    long l4 = getEndMillis();
    if (l3 > l2)
      return new Interval(l2, l3, getChronology()); 
    if (l1 > l4)
      return new Interval(l4, l1, getChronology()); 
    return null;
  }
  
  public boolean abuts(ReadableInterval paramReadableInterval) {
    if (paramReadableInterval == null) {
      long l = DateTimeUtils.currentTimeMillis();
      return (getStartMillis() == l || getEndMillis() == l);
    } 
    return (paramReadableInterval.getEndMillis() == getStartMillis() || 
      getEndMillis() == paramReadableInterval.getStartMillis());
  }
  
  public Interval withChronology(Chronology paramChronology) {
    if (getChronology() == paramChronology)
      return this; 
    return new Interval(getStartMillis(), getEndMillis(), paramChronology);
  }
  
  public Interval withStartMillis(long paramLong) {
    if (paramLong == getStartMillis())
      return this; 
    return new Interval(paramLong, getEndMillis(), getChronology());
  }
  
  public Interval withStart(ReadableInstant paramReadableInstant) {
    long l = DateTimeUtils.getInstantMillis(paramReadableInstant);
    return withStartMillis(l);
  }
  
  public Interval withEndMillis(long paramLong) {
    if (paramLong == getEndMillis())
      return this; 
    return new Interval(getStartMillis(), paramLong, getChronology());
  }
  
  public Interval withEnd(ReadableInstant paramReadableInstant) {
    long l = DateTimeUtils.getInstantMillis(paramReadableInstant);
    return withEndMillis(l);
  }
  
  public Interval withDurationAfterStart(ReadableDuration paramReadableDuration) {
    long l1 = DateTimeUtils.getDurationMillis(paramReadableDuration);
    if (l1 == toDurationMillis())
      return this; 
    Chronology chronology = getChronology();
    long l2 = getStartMillis();
    long l3 = chronology.add(l2, l1, 1);
    return new Interval(l2, l3, chronology);
  }
  
  public Interval withDurationBeforeEnd(ReadableDuration paramReadableDuration) {
    long l1 = DateTimeUtils.getDurationMillis(paramReadableDuration);
    if (l1 == toDurationMillis())
      return this; 
    Chronology chronology = getChronology();
    long l2 = getEndMillis();
    long l3 = chronology.add(l2, l1, -1);
    return new Interval(l3, l2, chronology);
  }
  
  public Interval withPeriodAfterStart(ReadablePeriod paramReadablePeriod) {
    if (paramReadablePeriod == null)
      return withDurationAfterStart(null); 
    Chronology chronology = getChronology();
    long l1 = getStartMillis();
    long l2 = chronology.add(paramReadablePeriod, l1, 1);
    return new Interval(l1, l2, chronology);
  }
  
  public Interval withPeriodBeforeEnd(ReadablePeriod paramReadablePeriod) {
    if (paramReadablePeriod == null)
      return withDurationBeforeEnd(null); 
    Chronology chronology = getChronology();
    long l1 = getEndMillis();
    long l2 = chronology.add(paramReadablePeriod, l1, -1);
    return new Interval(l2, l1, chronology);
  }
}
