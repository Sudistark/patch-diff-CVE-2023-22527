package org.joda.time;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Locale;
import org.joda.time.base.AbstractPartial;
import org.joda.time.field.FieldUtils;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.ISODateTimeFormat;

public final class Partial extends AbstractPartial implements ReadablePartial, Serializable {
  private static final long serialVersionUID = 12324121189002L;
  
  private final Chronology iChronology;
  
  private final DateTimeFieldType[] iTypes;
  
  private final int[] iValues;
  
  private DateTimeFormatter[] iFormatter;
  
  public Partial() { this((Chronology)null); }
  
  public Partial(Chronology paramChronology) {
    this.iChronology = DateTimeUtils.getChronology(paramChronology).withUTC();
    this.iTypes = new DateTimeFieldType[0];
    this.iValues = new int[0];
  }
  
  public Partial(DateTimeFieldType paramDateTimeFieldType, int paramInt) { this(paramDateTimeFieldType, paramInt, null); }
  
  public Partial(DateTimeFieldType paramDateTimeFieldType, int paramInt, Chronology paramChronology) {
    paramChronology = DateTimeUtils.getChronology(paramChronology).withUTC();
    this.iChronology = paramChronology;
    if (paramDateTimeFieldType == null)
      throw new IllegalArgumentException("The field type must not be null"); 
    this.iTypes = new DateTimeFieldType[] { paramDateTimeFieldType };
    this.iValues = new int[] { paramInt };
    paramChronology.validate(this, this.iValues);
  }
  
  public Partial(DateTimeFieldType[] paramArrayOfDateTimeFieldType, int[] paramArrayOfInt) { this(paramArrayOfDateTimeFieldType, paramArrayOfInt, null); }
  
  public Partial(DateTimeFieldType[] paramArrayOfDateTimeFieldType, int[] paramArrayOfInt, Chronology paramChronology) {
    paramChronology = DateTimeUtils.getChronology(paramChronology).withUTC();
    this.iChronology = paramChronology;
    if (paramArrayOfDateTimeFieldType == null)
      throw new IllegalArgumentException("Types array must not be null"); 
    if (paramArrayOfInt == null)
      throw new IllegalArgumentException("Values array must not be null"); 
    if (paramArrayOfInt.length != paramArrayOfDateTimeFieldType.length)
      throw new IllegalArgumentException("Values array must be the same length as the types array"); 
    if (paramArrayOfDateTimeFieldType.length == 0) {
      this.iTypes = paramArrayOfDateTimeFieldType;
      this.iValues = paramArrayOfInt;
      return;
    } 
    for (byte b1 = 0; b1 < paramArrayOfDateTimeFieldType.length; b1++) {
      if (paramArrayOfDateTimeFieldType[b1] == null)
        throw new IllegalArgumentException("Types array must not contain null: index " + b1); 
    } 
    DurationField durationField = null;
    for (byte b2 = 0; b2 < paramArrayOfDateTimeFieldType.length; b2++) {
      DateTimeFieldType dateTimeFieldType = paramArrayOfDateTimeFieldType[b2];
      DurationField durationField1 = dateTimeFieldType.getDurationType().getField(this.iChronology);
      if (b2) {
        if (!durationField1.isSupported()) {
          if (durationField.isSupported())
            throw new IllegalArgumentException("Types array must be in order largest-smallest: " + paramArrayOfDateTimeFieldType[b2 - true]
                .getName() + " < " + dateTimeFieldType.getName()); 
          throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + paramArrayOfDateTimeFieldType[b2 - true]
              .getName() + " and " + dateTimeFieldType.getName());
        } 
        int i = durationField.compareTo(durationField1);
        if (i < 0)
          throw new IllegalArgumentException("Types array must be in order largest-smallest: " + paramArrayOfDateTimeFieldType[b2 - true]
              .getName() + " < " + dateTimeFieldType.getName()); 
        if (i == 0)
          if (durationField.equals(durationField1)) {
            DurationFieldType durationFieldType1 = paramArrayOfDateTimeFieldType[b2 - true].getRangeDurationType();
            DurationFieldType durationFieldType2 = dateTimeFieldType.getRangeDurationType();
            if (durationFieldType1 == null) {
              if (durationFieldType2 == null)
                throw new IllegalArgumentException("Types array must not contain duplicate: " + paramArrayOfDateTimeFieldType[b2 - true]
                    .getName() + " and " + dateTimeFieldType.getName()); 
            } else {
              if (durationFieldType2 == null)
                throw new IllegalArgumentException("Types array must be in order largest-smallest: " + paramArrayOfDateTimeFieldType[b2 - true]
                    .getName() + " < " + dateTimeFieldType.getName()); 
              DurationField durationField2 = durationFieldType1.getField(this.iChronology);
              DurationField durationField3 = durationFieldType2.getField(this.iChronology);
              if (durationField2.compareTo(durationField3) < 0)
                throw new IllegalArgumentException("Types array must be in order largest-smallest: " + paramArrayOfDateTimeFieldType[b2 - true]
                    .getName() + " < " + dateTimeFieldType.getName()); 
              if (durationField2.compareTo(durationField3) == 0)
                throw new IllegalArgumentException("Types array must not contain duplicate: " + paramArrayOfDateTimeFieldType[b2 - true]
                    .getName() + " and " + dateTimeFieldType.getName()); 
            } 
          } else if (durationField.isSupported() && durationField.getType() != DurationFieldType.YEARS_TYPE) {
            throw new IllegalArgumentException("Types array must be in order largest-smallest, for year-based fields, years is defined as being largest: " + paramArrayOfDateTimeFieldType[b2 - true]
                
                .getName() + " < " + dateTimeFieldType.getName());
          }  
      } 
      durationField = durationField1;
    } 
    this.iTypes = (DateTimeFieldType[])paramArrayOfDateTimeFieldType.clone();
    paramChronology.validate(this, paramArrayOfInt);
    this.iValues = (int[])paramArrayOfInt.clone();
  }
  
  public Partial(ReadablePartial paramReadablePartial) {
    if (paramReadablePartial == null)
      throw new IllegalArgumentException("The partial must not be null"); 
    this.iChronology = DateTimeUtils.getChronology(paramReadablePartial.getChronology()).withUTC();
    this.iTypes = new DateTimeFieldType[paramReadablePartial.size()];
    this.iValues = new int[paramReadablePartial.size()];
    for (byte b = 0; b < paramReadablePartial.size(); b++) {
      this.iTypes[b] = paramReadablePartial.getFieldType(b);
      this.iValues[b] = paramReadablePartial.getValue(b);
    } 
  }
  
  Partial(Partial paramPartial, int[] paramArrayOfInt) {
    this.iChronology = paramPartial.iChronology;
    this.iTypes = paramPartial.iTypes;
    this.iValues = paramArrayOfInt;
  }
  
  Partial(Chronology paramChronology, DateTimeFieldType[] paramArrayOfDateTimeFieldType, int[] paramArrayOfInt) {
    this.iChronology = paramChronology;
    this.iTypes = paramArrayOfDateTimeFieldType;
    this.iValues = paramArrayOfInt;
  }
  
  public int size() { return this.iTypes.length; }
  
  public Chronology getChronology() { return this.iChronology; }
  
  protected DateTimeField getField(int paramInt, Chronology paramChronology) { return this.iTypes[paramInt].getField(paramChronology); }
  
  public DateTimeFieldType getFieldType(int paramInt) { return this.iTypes[paramInt]; }
  
  public DateTimeFieldType[] getFieldTypes() { return (DateTimeFieldType[])this.iTypes.clone(); }
  
  public int getValue(int paramInt) { return this.iValues[paramInt]; }
  
  public int[] getValues() { return (int[])this.iValues.clone(); }
  
  public Partial withChronologyRetainFields(Chronology paramChronology) {
    paramChronology = DateTimeUtils.getChronology(paramChronology);
    paramChronology = paramChronology.withUTC();
    if (paramChronology == getChronology())
      return this; 
    Partial partial = new Partial(paramChronology, this.iTypes, this.iValues);
    paramChronology.validate(partial, this.iValues);
    return partial;
  }
  
  public Partial with(DateTimeFieldType paramDateTimeFieldType, int paramInt) {
    if (paramDateTimeFieldType == null)
      throw new IllegalArgumentException("The field type must not be null"); 
    int i = indexOf(paramDateTimeFieldType);
    if (i == -1) {
      DateTimeFieldType[] arrayOfDateTimeFieldType = new DateTimeFieldType[this.iTypes.length + 1];
      int[] arrayOfInt1 = new int[arrayOfDateTimeFieldType.length];
      int j = 0;
      DurationField durationField = paramDateTimeFieldType.getDurationType().getField(this.iChronology);
      if (durationField.isSupported())
        for (; j < this.iTypes.length; j++) {
          DateTimeFieldType dateTimeFieldType = this.iTypes[j];
          DurationField durationField1 = dateTimeFieldType.getDurationType().getField(this.iChronology);
          if (durationField1.isSupported()) {
            int k = durationField.compareTo(durationField1);
            if (k > 0)
              break; 
            if (k == 0) {
              if (paramDateTimeFieldType.getRangeDurationType() == null)
                break; 
              if (dateTimeFieldType.getRangeDurationType() != null) {
                DurationField durationField2 = paramDateTimeFieldType.getRangeDurationType().getField(this.iChronology);
                DurationField durationField3 = dateTimeFieldType.getRangeDurationType().getField(this.iChronology);
                if (durationField2.compareTo(durationField3) > 0)
                  break; 
              } 
            } 
          } 
        }  
      System.arraycopy(this.iTypes, 0, arrayOfDateTimeFieldType, 0, j);
      System.arraycopy(this.iValues, 0, arrayOfInt1, 0, j);
      arrayOfDateTimeFieldType[j] = paramDateTimeFieldType;
      arrayOfInt1[j] = paramInt;
      System.arraycopy(this.iTypes, j, arrayOfDateTimeFieldType, j + 1, arrayOfDateTimeFieldType.length - j - 1);
      System.arraycopy(this.iValues, j, arrayOfInt1, j + 1, arrayOfInt1.length - j - 1);
      Partial partial = new Partial(arrayOfDateTimeFieldType, arrayOfInt1, this.iChronology);
      this.iChronology.validate(partial, arrayOfInt1);
      return partial;
    } 
    if (paramInt == getValue(i))
      return this; 
    int[] arrayOfInt = getValues();
    arrayOfInt = getField(i).set(this, i, arrayOfInt, paramInt);
    return new Partial(this, arrayOfInt);
  }
  
  public Partial without(DateTimeFieldType paramDateTimeFieldType) {
    int i = indexOf(paramDateTimeFieldType);
    if (i != -1) {
      DateTimeFieldType[] arrayOfDateTimeFieldType = new DateTimeFieldType[size() - 1];
      int[] arrayOfInt = new int[size() - 1];
      System.arraycopy(this.iTypes, 0, arrayOfDateTimeFieldType, 0, i);
      System.arraycopy(this.iTypes, i + 1, arrayOfDateTimeFieldType, i, arrayOfDateTimeFieldType.length - i);
      System.arraycopy(this.iValues, 0, arrayOfInt, 0, i);
      System.arraycopy(this.iValues, i + 1, arrayOfInt, i, arrayOfInt.length - i);
      Partial partial = new Partial(this.iChronology, arrayOfDateTimeFieldType, arrayOfInt);
      this.iChronology.validate(partial, arrayOfInt);
      return partial;
    } 
    return this;
  }
  
  public Partial withField(DateTimeFieldType paramDateTimeFieldType, int paramInt) {
    int i = indexOfSupported(paramDateTimeFieldType);
    if (paramInt == getValue(i))
      return this; 
    int[] arrayOfInt = getValues();
    arrayOfInt = getField(i).set(this, i, arrayOfInt, paramInt);
    return new Partial(this, arrayOfInt);
  }
  
  public Partial withFieldAdded(DurationFieldType paramDurationFieldType, int paramInt) {
    int i = indexOfSupported(paramDurationFieldType);
    if (paramInt == 0)
      return this; 
    int[] arrayOfInt = getValues();
    arrayOfInt = getField(i).add(this, i, arrayOfInt, paramInt);
    return new Partial(this, arrayOfInt);
  }
  
  public Partial withFieldAddWrapped(DurationFieldType paramDurationFieldType, int paramInt) {
    int i = indexOfSupported(paramDurationFieldType);
    if (paramInt == 0)
      return this; 
    int[] arrayOfInt = getValues();
    arrayOfInt = getField(i).addWrapPartial(this, i, arrayOfInt, paramInt);
    return new Partial(this, arrayOfInt);
  }
  
  public Partial withPeriodAdded(ReadablePeriod paramReadablePeriod, int paramInt) {
    if (paramReadablePeriod == null || paramInt == 0)
      return this; 
    int[] arrayOfInt = getValues();
    for (byte b = 0; b < paramReadablePeriod.size(); b++) {
      DurationFieldType durationFieldType = paramReadablePeriod.getFieldType(b);
      int i = indexOf(durationFieldType);
      if (i >= 0)
        arrayOfInt = getField(i).add(this, i, arrayOfInt, 
            FieldUtils.safeMultiply(paramReadablePeriod.getValue(b), paramInt)); 
    } 
    return new Partial(this, arrayOfInt);
  }
  
  public Partial plus(ReadablePeriod paramReadablePeriod) { return withPeriodAdded(paramReadablePeriod, 1); }
  
  public Partial minus(ReadablePeriod paramReadablePeriod) { return withPeriodAdded(paramReadablePeriod, -1); }
  
  public Property property(DateTimeFieldType paramDateTimeFieldType) { return new Property(this, indexOfSupported(paramDateTimeFieldType)); }
  
  public boolean isMatch(ReadableInstant paramReadableInstant) {
    long l = DateTimeUtils.getInstantMillis(paramReadableInstant);
    Chronology chronology = DateTimeUtils.getInstantChronology(paramReadableInstant);
    for (byte b = 0; b < this.iTypes.length; b++) {
      int i = this.iTypes[b].getField(chronology).get(l);
      if (i != this.iValues[b])
        return false; 
    } 
    return true;
  }
  
  public boolean isMatch(ReadablePartial paramReadablePartial) {
    if (paramReadablePartial == null)
      throw new IllegalArgumentException("The partial must not be null"); 
    for (byte b = 0; b < this.iTypes.length; b++) {
      int i = paramReadablePartial.get(this.iTypes[b]);
      if (i != this.iValues[b])
        return false; 
    } 
    return true;
  }
  
  public DateTimeFormatter getFormatter() {
    DateTimeFormatter[] arrayOfDateTimeFormatter = this.iFormatter;
    if (arrayOfDateTimeFormatter == null) {
      if (size() == 0)
        return null; 
      arrayOfDateTimeFormatter = new DateTimeFormatter[2];
      try {
        ArrayList arrayList = new ArrayList(Arrays.asList(this.iTypes));
        arrayOfDateTimeFormatter[0] = ISODateTimeFormat.forFields(arrayList, true, false);
        if (arrayList.size() == 0)
          arrayOfDateTimeFormatter[1] = arrayOfDateTimeFormatter[0]; 
      } catch (IllegalArgumentException illegalArgumentException) {}
      this.iFormatter = arrayOfDateTimeFormatter;
    } 
    return arrayOfDateTimeFormatter[0];
  }
  
  public String toString() {
    DateTimeFormatter[] arrayOfDateTimeFormatter = this.iFormatter;
    if (arrayOfDateTimeFormatter == null) {
      getFormatter();
      arrayOfDateTimeFormatter = this.iFormatter;
      if (arrayOfDateTimeFormatter == null)
        return toStringList(); 
    } 
    DateTimeFormatter dateTimeFormatter = arrayOfDateTimeFormatter[1];
    if (dateTimeFormatter == null)
      return toStringList(); 
    return dateTimeFormatter.print(this);
  }
  
  public String toStringList() {
    int i = size();
    StringBuilder stringBuilder = new StringBuilder(20 * i);
    stringBuilder.append('[');
    for (byte b = 0; b < i; b++) {
      if (b)
        stringBuilder.append(',').append(' '); 
      stringBuilder.append(this.iTypes[b].getName());
      stringBuilder.append('=');
      stringBuilder.append(this.iValues[b]);
    } 
    stringBuilder.append(']');
    return stringBuilder.toString();
  }
  
  public String toString(String paramString) {
    if (paramString == null)
      return toString(); 
    return DateTimeFormat.forPattern(paramString).print(this);
  }
  
  public String toString(String paramString, Locale paramLocale) {
    if (paramString == null)
      return toString(); 
    return DateTimeFormat.forPattern(paramString).withLocale(paramLocale).print(this);
  }
}
