package cheshire;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class core__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__3;
  
  public static final AFn const__4;
  
  public static final Var const__5;
  
  public static final AFn const__13;
  
  public static final Var const__14;
  
  public static final AFn const__17;
  
  public static final Var const__18;
  
  public static final AFn const__21;
  
  public static final Var const__22;
  
  public static final AFn const__25;
  
  public static final Var const__26;
  
  public static final AFn const__31;
  
  public static final Var const__32;
  
  public static final AFn const__34;
  
  public static final Var const__35;
  
  public static final AFn const__38;
  
  public static final Var const__39;
  
  public static final AFn const__42;
  
  public static final Var const__43;
  
  public static final AFn const__46;
  
  public static final Var const__47;
  
  public static final AFn const__50;
  
  public static final Var const__51;
  
  public static final AFn const__54;
  
  public static final Var const__55;
  
  public static final AFn const__58;
  
  public static final Var const__59;
  
  public static final AFn const__62;
  
  public static final Var const__63;
  
  public static final AFn const__66;
  
  public static final Var const__67;
  
  public static final AFn const__70;
  
  public static final Var const__71;
  
  public static final AFn const__73;
  
  public static final Var const__74;
  
  public static final AFn const__78;
  
  public static final Var const__79;
  
  public static final AFn const__82;
  
  public static final Var const__83;
  
  public static final AFn const__86;
  
  public static final Var const__87;
  
  public static final AFn const__90;
  
  public static final Var const__91;
  
  public static final AFn const__93;
  
  public static final Var const__94;
  
  public static final Var const__95;
  
  public static final Var const__96;
  
  public static final Var const__97;
  
  public static final AFn const__98;
  
  public static final Var const__99;
  
  public static final AFn const__101;
  
  public static final AFn const__102;
  
  public static final Var const__103;
  
  public static final AFn const__105;
  
  public static final AFn const__106;
  
  public static final Var const__107;
  
  public static final AFn const__109;
  
  public static final AFn const__110;
  
  public static final Var const__111;
  
  public static final AFn const__113;
  
  public static final AFn const__114;
  
  public static final Var const__115;
  
  public static final AFn const__117;
  
  public static final AFn const__118;
  
  public static final Var const__119;
  
  public static final AFn const__121;
  
  public static final AFn const__122;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new core.fn__29369());
    const__5.setMeta((IPersistentMap)const__13);
    const__5.bindRoot(new core.create_pretty_printer());
    const__14.setMeta((IPersistentMap)const__17);
    const__14.bindRoot(new core.generate_string());
    const__18.setMeta((IPersistentMap)const__21);
    const__18.bindRoot(new core.generate_stream());
    const__22.setMeta((IPersistentMap)const__25);
    const__22.bindRoot(new core.create_generator());
    const__26.setDynamic(true).setMeta((IPersistentMap)const__31);
    const__32.setDynamic(true).setMeta((IPersistentMap)const__34);
    const__35.setMeta((IPersistentMap)const__38);
    const__35.bindRoot(new core.with_writer());
    ((Var)const__35)









































































































      
      .setMacro();
    const__39.setMeta((IPersistentMap)const__42);
    const__39.bindRoot(new core.write());
    const__43.setMeta((IPersistentMap)const__46);
    const__43.bindRoot(new core.generate_smile());
    const__47.setMeta((IPersistentMap)const__50);
    const__47.bindRoot(new core.generate_cbor());
    const__51.setMeta((IPersistentMap)const__54);
    const__51.bindRoot(new core.parse_string());
    const__55.setMeta((IPersistentMap)const__58);
    const__55.bindRoot(new core.parse_string_strict());
    const__59.setMeta((IPersistentMap)const__62);
    const__59.bindRoot(new core.parse_stream());
    const__63.setMeta((IPersistentMap)const__66);
    const__63.bindRoot(new core.parse_smile());
    const__67.setMeta((IPersistentMap)const__70);
    const__67.bindRoot(new core.parse_cbor());
    const__71.setMeta((IPersistentMap)const__73);
    const__71.bindRoot(new Object());
    const__74.setMeta((IPersistentMap)const__78);
    const__74.bindRoot(new core.parsed_seq_STAR_());
    const__79.setMeta((IPersistentMap)const__82);
    const__79.bindRoot(new core.parsed_seq());
    const__83.setMeta((IPersistentMap)const__86);
    const__83.bindRoot(new core.parsed_smile_seq());
    const__87.setMeta((IPersistentMap)const__90);
    const__87.bindRoot(new core.copy_arglists());
    ((Var)const__87)

















































































































































































































      
      .setMacro();
    const__91.setMeta((IPersistentMap)const__93);
    const__91.bindRoot(const__14.getRawRoot());
    const__99.setMeta((IPersistentMap)const__101);
    const__99.bindRoot(const__18.getRawRoot());
    const__103.setMeta((IPersistentMap)const__105);
    const__103.bindRoot(const__43.getRawRoot());
    const__107.setMeta((IPersistentMap)const__109);
    const__107.bindRoot(const__51.getRawRoot());
    const__111.setMeta((IPersistentMap)const__113);
    const__111.bindRoot(const__55.getRawRoot());
    const__115.setMeta((IPersistentMap)const__117);
    const__115.bindRoot(const__59.getRawRoot());
    const__119.setMeta((IPersistentMap)const__121);
    const__119.bindRoot(const__63.getRawRoot());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "cheshire.core")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Main encoding and decoding namespace." }));
    const__3 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Main encoding and decoding namespace." });
    const__4 = (AFn)Symbol.intern(null, "clojure.core");
    const__5 = (Var)RT.var("cheshire.core", "create-pretty-printer");
    const__13 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "options")) })), RT.keyword(null, "doc"), "Returns an instance of CustomPrettyPrinter based on the configuration\n  provided as argument", RT.keyword(null, "line"), Integer.valueOf(25), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj" });
    const__14 = (Var)RT.var("cheshire.core", "generate-string");
    const__17 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "obj"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.lang.String") })), ((IObj)Tuple.create(Symbol.intern(null, "obj"), Symbol.intern(null, "opt-map"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.lang.String") })) })), RT.keyword(null, "doc"), "Returns a JSON-encoding String for the given Clojure object. Takes an\n  optional date format string that Date objects will be encoded with.\n\n  The default date format (in UTC) is: yyyy-MM-dd'T'HH:mm:ss'Z'", RT.keyword(null, "line"), Integer.valueOf(49), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj" });
    const__18 = (Var)RT.var("cheshire.core", "generate-stream");
    const__21 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "obj"), ((IObj)Symbol.intern(null, "writer")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "BufferedWriter") })))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.io.BufferedWriter") })), ((IObj)Tuple.create(Symbol.intern(null, "obj"), ((IObj)Symbol.intern(null, "writer")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "BufferedWriter") })), Symbol.intern(null, "opt-map"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.io.BufferedWriter") })) })), RT.keyword(null, "doc"), "Returns a BufferedWriter for the given Clojure object with the JSON-encoded\n  data written to the writer. Takes an optional date format string that Date\n  objects will be encoded with.\n\n  The default date format (in UTC) is: yyyy-MM-dd'T'HH:mm:ss'Z'", RT.keyword(null, "line"), Integer.valueOf(81), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj" });
    const__22 = (Var)RT.var("cheshire.core", "create-generator");
    const__25 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "writer")) })), RT.keyword(null, "line"), Integer.valueOf(113), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj" });
    const__26 = (Var)RT.var("cheshire.core", "*generator*");
    const__31 = (AFn)RT.map(new Object[] { RT.keyword(null, "tag"), RT.classForName("com.fasterxml.jackson.core.JsonGenerator"), RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(120), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj" });
    const__32 = (Var)RT.var("cheshire.core", "*opt-map*");
    const__34 = (AFn)RT.map(new Object[] { RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(121), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj" });
    const__35 = (Var)RT.var("cheshire.core", "with-writer");
    const__38 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "writer"), Symbol.intern(null, "opt-map")), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "line"), Integer.valueOf(123), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj" });
    const__39 = (Var)RT.var("cheshire.core", "write");
    const__42 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "obj")), Tuple.create(Symbol.intern(null, "obj"), Symbol.intern(null, "wholeness")) })), RT.keyword(null, "doc"), "Write given Clojure object as a piece of data within with-writer.\n  List of wholeness acceptable values:\n  - no value - the same as :all\n  - :all - write object in a regular way with start and end borders\n  - :start - write object with start border only\n  - :start-inner - write object and its inner object with start border only\n  - :end - write object with end border only.", RT.keyword(null, "line"), Integer.valueOf(135), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj" });
    const__43 = (Var)RT.var("cheshire.core", "generate-smile");
    const__46 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "obj"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "bytes") })), ((IObj)Tuple.create(Symbol.intern(null, "obj"), Symbol.intern(null, "opt-map"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "bytes") })) })), RT.keyword(null, "doc"), "Returns a SMILE-encoded byte-array for the given Clojure object.\n  Takes an optional date format string that Date objects will be encoded with.\n\n  The default date format (in UTC) is: yyyy-MM-dd'T'HH:mm:ss'Z'", RT.keyword(null, "line"), Integer.valueOf(151), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj" });
    const__47 = (Var)RT.var("cheshire.core", "generate-cbor");
    const__50 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "obj"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "bytes") })), ((IObj)Tuple.create(Symbol.intern(null, "obj"), Symbol.intern(null, "opt-map"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "bytes") })) })), RT.keyword(null, "doc"), "Returns a CBOR-encoded byte-array for the given Clojure object.\n  Takes an optional date format string that Date objects will be encoded with.\n\n  The default date format (in UTC) is: yyyy-MM-dd'T'HH:mm:ss'Z'", RT.keyword(null, "line"), Integer.valueOf(171), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj" });
    const__51 = (Var)RT.var("cheshire.core", "parse-string");
    const__54 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "string")), Tuple.create(Symbol.intern(null, "string"), Symbol.intern(null, "key-fn")), Tuple.create(((IObj)Symbol.intern(null, "string")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })), Symbol.intern(null, "key-fn"), Symbol.intern(null, "array-coerce-fn")) })), RT.keyword(null, "doc"), "Returns the Clojure object corresponding to the given JSON-encoded string.\n  An optional key-fn argument can be either true (to coerce keys to keywords),\n  false to leave them as strings, or a function to provide custom coercion.\n\n  The array-coerce-fn is an optional function taking the name of an array field,\n  and returning the collection to be used for array values.\n\n  If the top-level object is an array, it will be parsed lazily (use\n  `parse-strict' if strict parsing is required for top-level arrays.", RT.keyword(null, "line"), Integer.valueOf(192), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj" });
    const__55 = (Var)RT.var("cheshire.core", "parse-string-strict");
    const__58 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "string")), Tuple.create(Symbol.intern(null, "string"), Symbol.intern(null, "key-fn")), Tuple.create(((IObj)Symbol.intern(null, "string")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })), Symbol.intern(null, "key-fn"), Symbol.intern(null, "array-coerce-fn")) })), RT.keyword(null, "doc"), "Returns the Clojure object corresponding to the given JSON-encoded string.\n  An optional key-fn argument can be either true (to coerce keys to keywords),\n  false to leave them as strings, or a function to provide custom coercion.\n\n  The array-coerce-fn is an optional function taking the name of an array field,\n  and returning the collection to be used for array values.\n\n  Does not lazily parse top-level arrays.", RT.keyword(null, "line"), Integer.valueOf(213), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj" });
    const__59 = (Var)RT.var("cheshire.core", "parse-stream");
    const__62 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr")), Tuple.create(Symbol.intern(null, "rdr"), Symbol.intern(null, "key-fn")), Tuple.create(((IObj)Symbol.intern(null, "rdr")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "BufferedReader") })), Symbol.intern(null, "key-fn"), Symbol.intern(null, "array-coerce-fn")) })), RT.keyword(null, "doc"), "Returns the Clojure object corresponding to the given reader, reader must\n  implement BufferedReader. An optional key-fn argument can be either true (to\n  coerce keys to keywords),false to leave them as strings, or a function to\n  provide custom coercion.\n\n  The array-coerce-fn is an optional function taking the name of an array field,\n  and returning the collection to be used for array values.\n\n  If the top-level object is an array, it will be parsed lazily (use\n  `parse-strict' if strict parsing is required for top-level arrays.\n\n  If multiple objects (enclosed in a top-level `{}' need to be parsed lazily,\n  see parsed-seq.", RT.keyword(null, "line"), Integer.valueOf(232), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj" });
    const__63 = (Var)RT.var("cheshire.core", "parse-smile");
    const__66 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bytes")), Tuple.create(Symbol.intern(null, "bytes"), Symbol.intern(null, "key-fn")), Tuple.create(((IObj)Symbol.intern(null, "bytes")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "bytes") })), Symbol.intern(null, "key-fn"), Symbol.intern(null, "array-coerce-fn")) })), RT.keyword(null, "doc"), "Returns the Clojure object corresponding to the given SMILE-encoded bytes.\n  An optional key-fn argument can be either true (to coerce keys to keywords),\n  false to leave them as strings, or a function to provide custom coercion.\n\n  The array-coerce-fn is an optional function taking the name of an array field,\n  and returning the collection to be used for array values.", RT.keyword(null, "line"), Integer.valueOf(256), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj" });
    const__67 = (Var)RT.var("cheshire.core", "parse-cbor");
    const__70 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bytes")), Tuple.create(Symbol.intern(null, "bytes"), Symbol.intern(null, "key-fn")), Tuple.create(((IObj)Symbol.intern(null, "bytes")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "bytes") })), Symbol.intern(null, "key-fn"), Symbol.intern(null, "array-coerce-fn")) })), RT.keyword(null, "doc"), "Returns the Clojure object corresponding to the given CBOR-encoded bytes.\n  An optional key-fn argument can be either true (to coerce keys to keywords),\n  false to leave them as strings, or a function to provide custom coercion.\n\n  The array-coerce-fn is an optional function taking the name of an array field,\n  and returning the collection to be used for array values.", RT.keyword(null, "line"), Integer.valueOf(272), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj" });
    const__71 = (Var)RT.var("cheshire.core", "eof");
    const__73 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Object used to determine end of lazy parsing attempt.", RT.keyword(null, "line"), Integer.valueOf(288), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj" });
    const__74 = (Var)RT.var("cheshire.core", "parsed-seq*");
    const__78 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "parser")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "JsonParser") })), Symbol.intern(null, "key-fn"), Symbol.intern(null, "array-coerce-fn")) })), RT.keyword(null, "doc"), "Internal lazy-seq parser", RT.keyword(null, "line"), Integer.valueOf(292), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "cheshire/core.clj" });
    const__79 = (Var)RT.var("cheshire.core", "parsed-seq");
    const__82 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")), Tuple.create(Symbol.intern(null, "reader"), Symbol.intern(null, "key-fn")), Tuple.create(((IObj)Symbol.intern(null, "reader")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "BufferedReader") })), Symbol.intern(null, "key-fn"), Symbol.intern(null, "array-coerce-fn")) })), RT.keyword(null, "doc"), "Returns a lazy seq of Clojure objects corresponding to the JSON read from\n  the given reader. The seq continues until the end of the reader is reached.\n\n  The array-coerce-fn is an optional function taking the name of an array field,\n  and returning the collection to be used for array values.\n  If non-laziness is needed, see parse-stream.", RT.keyword(null, "line"), Integer.valueOf(300), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj" });
    const__83 = (Var)RT.var("cheshire.core", "parsed-smile-seq");
    const__86 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")), Tuple.create(Symbol.intern(null, "reader"), Symbol.intern(null, "key-fn")), Tuple.create(((IObj)Symbol.intern(null, "reader")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "BufferedReader") })), Symbol.intern(null, "key-fn"), Symbol.intern(null, "array-coerce-fn")) })), RT.keyword(null, "doc"), "Returns a lazy seq of Clojure objects corresponding to the SMILE read from\n  the given reader. The seq continues until the end of the reader is reached.\n\n  The array-coerce-fn is an optional function taking the name of an array field,\n  and returning the collection to be used for array values.", RT.keyword(null, "line"), Integer.valueOf(317), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj" });
    const__87 = (Var)RT.var("cheshire.core", "copy-arglists");
    const__90 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "dst"), Symbol.intern(null, "src")) })), RT.keyword(null, "line"), Integer.valueOf(334), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj" });
    const__91 = (Var)RT.var("cheshire.core", "encode");
    const__93 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(337), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj", RT.keyword(null, "doc"), "Alias to generate-string for clojure-json users" });
    const__94 = (Var)RT.var("clojure.core", "alter-meta!");
    const__95 = (Var)RT.var("clojure.core", "merge");
    const__96 = (Var)RT.var("clojure.core", "select-keys");
    const__97 = (Var)RT.var("clojure.core", "meta");
    const__98 = (AFn)Tuple.create(RT.keyword(null, "arglists"));
    const__99 = (Var)RT.var("cheshire.core", "encode-stream");
  }
  
  public static void __init1() {
    const__101 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(339), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj", RT.keyword(null, "doc"), "Alias to generate-stream for clojure-json users" });
    const__102 = (AFn)Tuple.create(RT.keyword(null, "arglists"));
    const__103 = (Var)RT.var("cheshire.core", "encode-smile");
    const__105 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(341), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj", RT.keyword(null, "doc"), "Alias to generate-smile for clojure-json users" });
    const__106 = (AFn)Tuple.create(RT.keyword(null, "arglists"));
    const__107 = (Var)RT.var("cheshire.core", "decode");
    const__109 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(343), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj", RT.keyword(null, "doc"), "Alias to parse-string for clojure-json users" });
    const__110 = (AFn)Tuple.create(RT.keyword(null, "arglists"));
    const__111 = (Var)RT.var("cheshire.core", "decode-strict");
    const__113 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(345), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj", RT.keyword(null, "doc"), "Alias to parse-string-strict for clojure-json users" });
    const__114 = (AFn)Tuple.create(RT.keyword(null, "arglists"));
    const__115 = (Var)RT.var("cheshire.core", "decode-stream");
    const__117 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(347), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj", RT.keyword(null, "doc"), "Alias to parse-stream for clojure-json users" });
    const__118 = (AFn)Tuple.create(RT.keyword(null, "arglists"));
    const__119 = (Var)RT.var("cheshire.core", "decode-smile");
    const__121 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(349), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "cheshire/core.clj", RT.keyword(null, "doc"), "Alias to parse-smile for clojure-json users" });
    const__122 = (AFn)Tuple.create(RT.keyword(null, "arglists"));
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("cheshire.core__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
