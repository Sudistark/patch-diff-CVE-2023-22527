package aleph;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IPersistentMap;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class tcp__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__2;
  
  public static final Var const__4;
  
  public static final Object const__42;
  
  public static final Var const__43;
  
  public static final Var const__44;
  
  public static final Keyword const__45;
  
  public static final Var const__46;
  
  public static final AFn const__56;
  
  public static final Var const__57;
  
  public static final AFn const__61;
  
  public static final Var const__62;
  
  public static final AFn const__65;
  
  public static final Var const__66;
  
  public static final AFn const__69;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new tcp.fn__40732());
    const__46.setMeta((IPersistentMap)const__56);
    const__46.bindRoot(new tcp.server_channel_handler());
    const__57.setMeta((IPersistentMap)const__61);
    const__57.bindRoot(new tcp.start_server());
    const__62.setMeta((IPersistentMap)const__65);
    const__62.bindRoot(new tcp.client_channel_handler());
    const__66.setMeta((IPersistentMap)const__69);
    const__66.bindRoot(new tcp.client());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "aleph.tcp");
    const__2 = (AFn)Symbol.intern(null, "clojure.core");
    const__4 = (Var)RT.var("clojure.core", "assoc");
    const__42 = RT.classForName("aleph.tcp.TcpConnection");
    const__43 = (Var)RT.var("clojure.core", "alter-meta!");
    const__44 = (Var)RT.var("aleph.tcp", "->TcpConnection");
    const__45 = (Keyword)RT.keyword(null, "private");
    const__46 = (Var)RT.var("aleph.tcp", "server-channel-handler");
    const__56 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("io.netty.channel.ChannelHandler"), RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "handler"), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "raw-stream?")), RT.keyword(null, "as"), Symbol.intern(null, "options") })) })), RT.keyword(null, "line"), Integer.valueOf(26), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "aleph/tcp.clj" });
    const__57 = (Var)RT.var("aleph.tcp", "start-server");
    const__61 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "handler"), RT.map(new Object[] { RT.keyword(null, "keys"), RT.vector(new Object[] { Symbol.intern(null, "port"), Symbol.intern(null, "socket-address"), Symbol.intern(null, "ssl-context"), Symbol.intern(null, "bootstrap-transform"), Symbol.intern(null, "pipeline-transform"), Symbol.intern(null, "epoll?"), Symbol.intern(null, "shutdown-timeout"), Symbol.intern(null, "transport") }), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "bootstrap-transform"), Symbol.intern(null, "identity"), Symbol.intern(null, "pipeline-transform"), Symbol.intern(null, "identity"), Symbol.intern(null, "epoll?"), Boolean.FALSE, Symbol.intern(null, "shutdown-timeout"), Symbol.intern("netty", "default-shutdown-timeout") }), RT.keyword(null, "as"), Symbol.intern(null, "options") })) })), RT.keyword(null, "doc"), "Takes a two-arg handler function which for each connection will be called with a duplex\n   stream and a map containing information about the client.  Returns a server object that can\n   be shutdown via `java.io.Closeable.close()`, and whose port can be discovered via `aleph.netty.port`.\n\n   Param key               | Description\n   | ---                   | ---\n   | `port`                | the port the server will bind to.  If `0`, the server will bind to a random port.\n   | `socket-address`      | a `java.net.SocketAddress` specifying both the port and interface to bind to.\n   | `ssl-context`         | an `io.netty.handler.ssl.SslContext` object or a map of SSL context options (see `aleph.netty/ssl-server-context` for more details). If given, the server will only accept SSL connections and call the handler once the SSL session has been successfully established. If a self-signed certificate is all that's required, `(aleph.netty/self-signed-ssl-context)` will suffice.\n   | `bootstrap-transform` | a function that takes an `io.netty.bootstrap.ServerBootstrap` object, which represents the server, and modifies it.\n   | `pipeline-transform`  | a function that takes an `io.netty.channel.ChannelPipeline` object, which represents a connection, and modifies it.\n   | `raw-stream?`         | if true, messages from the stream will be `io.netty.buffer.ByteBuf` objects rather than byte-arrays.  This will minimize copying, but means that care must be taken with Netty's buffer reference counting.  Only recommended for advanced users.\n   | `shutdown-timeout`    | interval in seconds within which in-flight requests must be processed, defaults to 15 seconds. A value of 0 bypasses waiting entirely.\n   | `transport`           | the transport to use, one of `:nio`, `:epoll`, `:kqueue` or `:io-uring` (defaults to `:nio`)", RT.keyword(null, "line"), Integer.valueOf(68), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "aleph/tcp.clj" });
    const__62 = (Var)RT.var("aleph.tcp", "client-channel-handler");
    const__65 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("io.netty.channel.ChannelHandler"), RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "raw-stream?")) })) })), RT.keyword(null, "line"), Integer.valueOf(105), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "aleph/tcp.clj" });
    const__66 = (Var)RT.var("aleph.tcp", "client");
    const__69 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), RT.vector(new Object[] { 
                          Symbol.intern(null, "host"), Symbol.intern(null, "port"), Symbol.intern(null, "remote-address"), Symbol.intern(null, "local-address"), Symbol.intern(null, "ssl-context"), Symbol.intern(null, "ssl?"), Symbol.intern(null, "insecure?"), Symbol.intern(null, "pipeline-transform"), Symbol.intern(null, "bootstrap-transform"), Symbol.intern(null, "epoll?"), 
                          Symbol.intern(null, "transport") }), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "bootstrap-transform"), Symbol.intern(null, "identity"), Symbol.intern(null, "epoll?"), Boolean.FALSE }), RT.keyword(null, "as"), Symbol.intern(null, "options") })) })), RT.keyword(null, "doc"), "Given a host and port, returns a deferred which yields a duplex stream that can be used\n   to communicate with the server.\n\n   Param key               | Description\n   | ---                   | ---\n   | `host`                | the hostname of the server.\n   | `port`                | the port of the server.\n   | `remote-address`      | a `java.net.SocketAddress` specifying the server's address.\n   | `local-address`       | a `java.net.SocketAddress` specifying the local network interface to use.\n   | `ssl-context`         | an explicit `io.netty.handler.ssl.SslHandler` or a map of SSL context options (see `aleph.netty/ssl-client-context` for more details) to use. Defers to `ssl?` and `insecure?` configuration if omitted.\n   | `ssl?`                | if true, the client attempts to establish a secure connection with the server.\n   | `insecure?`           | if true, the client will ignore the server's certificate.\n   | `bootstrap-transform` | a function that takes an `io.netty.bootstrap.Bootstrap` object, which represents the client, and modifies it.\n   | `pipeline-transform`  | a function that takes an `io.netty.channel.ChannelPipeline` object, which represents a connection, and modifies it.\n   | `raw-stream?`         | if true, messages from the stream will be `io.netty.buffer.ByteBuf` objects rather than byte-arrays.  This will minimize copying, but means that care must be taken with Netty's buffer reference counting.  Only recommended for advanced users.\n   | `transport`               | the transport to use, one of `:nio`, `:epoll`, `:kqueue` or `:io-uring` (defaults to `:nio`)", RT.keyword(null, "line"), Integer.valueOf(151), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "aleph/tcp.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("aleph.tcp__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
