package schema;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class coerce__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__3;
  
  public static final AFn const__4;
  
  public static final Var const__5;
  
  public static final AFn const__11;
  
  public static final Var const__12;
  
  public static final Var const__13;
  
  public static final Var const__14;
  
  public static final Keyword const__15;
  
  public static final AFn const__16;
  
  public static final Keyword const__17;
  
  public static final Var const__18;
  
  public static final AFn const__20;
  
  public static final Var const__21;
  
  public static final Var const__22;
  
  public static final Var const__23;
  
  public static final Var const__24;
  
  public static final AFn const__25;
  
  public static final AFn const__26;
  
  public static final Var const__27;
  
  public static final AFn const__31;
  
  public static final Var const__32;
  
  public static final AFn const__35;
  
  public static final Var const__36;
  
  public static final AFn const__39;
  
  public static final Var const__40;
  
  public static final AFn const__43;
  
  public static final Var const__44;
  
  public static final AFn const__47;
  
  public static final Var const__48;
  
  public static final AFn const__51;
  
  public static final Var const__52;
  
  public static final AFn const__54;
  
  public static final Var const__55;
  
  public static final AFn const__58;
  
  public static final Var const__59;
  
  public static final Var const__60;
  
  public static final Var const__61;
  
  public static final Var const__62;
  
  public static final Object const__63;
  
  public static final Var const__64;
  
  public static final Object const__65;
  
  public static final Object const__66;
  
  public static final Var const__67;
  
  public static final Object const__68;
  
  public static final Var const__69;
  
  public static final Object const__70;
  
  public static final Var const__71;
  
  public static final AFn const__74;
  
  public static final Var const__75;
  
  public static final AFn const__77;
  
  public static final Var const__78;
  
  public static final Var const__79;
  
  public static final AFn const__81;
  
  public static final Var const__82;
  
  public static final Var const__83;
  
  public static final AFn const__86;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new coerce.fn__60765());
    const__5.setMeta((IPersistentMap)const__11);
    const__5















      
      .bindRoot(((IFn)const__12.getRawRoot()).invoke(((IFn)const__13.getRawRoot()).invoke(const__14.getRawRoot()), RT.mapUniqueKeys(new Object[] { const__15, const__16, const__17, new coerce.fn__60767() })));
    const__18.setMeta((IPersistentMap)const__20);
    const__18




      
      .bindRoot(((IFn)const__21.getRawRoot()).invoke(((IFn)const__22.getRawRoot()).invoke(((IFn)const__21.getRawRoot()).invoke(const__23.getRawRoot(), Tuple.create(Tuple.create(((IFn)const__24.getRawRoot()).invoke(const__23.getRawRoot(), const__25))))), Tuple.create(Tuple.create(((IFn)const__24.getRawRoot()).invoke(const__5.getRawRoot(), const__26)))));
    const__27.setMeta((IPersistentMap)const__31);
    const__27.bindRoot(new coerce.string__GT_keyword());
    const__32.setMeta((IPersistentMap)const__35);
    const__32.bindRoot(new coerce.string__GT_boolean());
    const__36.setMeta((IPersistentMap)const__39);
    const__36.bindRoot(new coerce.keyword_enum_matcher());
    const__40.setMeta((IPersistentMap)const__43);
    const__40.bindRoot(new coerce.set_matcher());
    const__44.setMeta((IPersistentMap)const__47);
    const__44.bindRoot(new coerce.safe());
    const__48.setMeta((IPersistentMap)const__51);
    const__48

































      
      .bindRoot(((IFn)const__44.getRawRoot()).invoke(new coerce.fn__60867()));
    const__52.setMeta((IPersistentMap)const__54);
    const__52










      
      .bindRoot(((IFn)const__44.getRawRoot()).invoke(new coerce.fn__60870()));
    const__55.setMeta((IPersistentMap)const__58);
    const__55




      
      .bindRoot(((IFn)const__59.getRawRoot()).invoke(RT.map(new Object[] { const__60.getRawRoot(), const__27.getRawRoot(), const__61.getRawRoot(), const__32.getRawRoot(), const__62.getRawRoot(), const__52.getRawRoot() }, ), RT.map(new Object[] { 
              const__63, const__27.getRawRoot(), const__64.getRawRoot(), const__48.getRawRoot(), const__65, const__48.getRawRoot(), const__66, ((IFn)const__44.getRawRoot()).invoke(const__67.getRawRoot()), const__68, ((IFn)const__44.getRawRoot()).invoke(const__69.getRawRoot()), 
              const__70, const__32.getRawRoot() })));
    const__71.setMeta((IPersistentMap)const__74);
    const__71.bindRoot(new coerce.json_coercion_matcher());
    const__75.setMeta((IPersistentMap)const__77);
    const__75.bindRoot(const__78.getRawRoot());
    const__79.setMeta((IPersistentMap)const__81);
    const__79.bindRoot(((IFn)const__59.getRawRoot()).invoke(const__55.getRawRoot(), 

          
          RT.map(new Object[] { const__82.getRawRoot(), ((IFn)const__44.getRawRoot()).invoke(const__75.getRawRoot()), const__64.getRawRoot(), ((IFn)const__44.getRawRoot()).invoke(const__75.getRawRoot()) }, ), RT.map(new Object[] { const__64.getRawRoot(), ((IFn)const__44.getRawRoot()).invoke(new coerce.fn__60878()), const__65, ((IFn)const__44.getRawRoot()).invoke(new coerce.fn__60880()), const__66, ((IFn)const__44.getRawRoot()).invoke(new coerce.fn__60882()) })));
    const__83.setMeta((IPersistentMap)const__86);
    const__83.bindRoot(new coerce.string_coercion_matcher());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "schema.coerce")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Extension of schema for input coercion (coercing an input to match a schema)" }));
    const__3 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Extension of schema for input coercion (coercing an input to match a schema)" });
    const__4 = (AFn)Symbol.intern(null, "clojure.core");
    const__5 = (Var)RT.var("schema.coerce", "Schema");
    const__11 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(16), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/coerce.clj", RT.keyword(null, "doc"), "A Schema for Schemas" });
    const__12 = (Var)RT.var("clojure.core", "with-meta");
    const__13 = (Var)RT.var("schema.core", "->Protocol");
    const__14 = (Var)RT.var("schema.core", "Schema");
    const__15 = (Keyword)RT.keyword(null, "proto-sym");
    const__16 = (AFn)Symbol.intern("s", "Schema");
    const__17 = (Keyword)RT.keyword(null, "proto-pred");
    const__18 = (Var)RT.var("schema.coerce", "CoercionMatcher");
    const__20 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(20), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/coerce.clj", RT.keyword(null, "doc"), "A function from schema to coercion function, or nil if no special coercion is needed.\n   The returned function is applied to the corresponding data before validation (or walking/\n   coercion of its sub-schemas, if applicable)" });
    const__21 = (Var)RT.var("schema.core", "make-fn-schema");
    const__22 = (Var)RT.var("schema.core", "maybe");
    const__23 = (Var)RT.var("schema.core", "Any");
    const__24 = (Var)RT.var("schema.core", "one");
    const__25 = (AFn)Symbol.intern(null, "arg0");
    const__26 = (AFn)Symbol.intern(null, "arg0");
    const__27 = (Var)RT.var("schema.coerce", "string->keyword");
    const__31 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "line"), Integer.valueOf(64), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/coerce.clj" });
    const__32 = (Var)RT.var("schema.coerce", "string->boolean");
    const__35 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "returns true for strings that are equal, ignoring case, to the string 'true'\n   (following java.lang.Boolean/parseBoolean semantics)", RT.keyword(null, "line"), Integer.valueOf(67), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/coerce.clj" });
    const__36 = (Var)RT.var("schema.coerce", "keyword-enum-matcher");
    const__39 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "schema")) })), RT.keyword(null, "line"), Integer.valueOf(73), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/coerce.clj" });
    const__40 = (Var)RT.var("schema.coerce", "set-matcher");
    const__43 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "schema")) })), RT.keyword(null, "line"), Integer.valueOf(80), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/coerce.clj" });
    const__44 = (Var)RT.var("schema.coerce", "safe");
    const__47 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Take a single-arg function f, and return a single-arg function that acts as identity\n   if f throws an exception, and like f otherwise.  Useful because coercers are not explicitly\n   guarded for exceptions, and failing to coerce will generally produce a more useful error\n   in this case.", RT.keyword(null, "line"), Integer.valueOf(84), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/coerce.clj" });
    const__48 = (Var)RT.var("schema.coerce", "safe-long-cast");
    const__51 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(92), RT.keyword(null, "column"), Integer.valueOf(7), RT.keyword(null, "file"), "schema/coerce.clj", RT.keyword(null, "doc"), "Coerce x to a long if this can be done without losing precision, otherwise return x." });
    const__52 = (Var)RT.var("schema.coerce", "string->uuid");
    const__54 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(101), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/coerce.clj", RT.keyword(null, "doc"), "Returns instance of UUID if input is a string.\n   Note: in CLJS, this does not guarantee a specific UUID string representation,\n         similar to #uuid reader" });
    const__55 = (Var)RT.var("schema.coerce", "+json-coercions+");
    const__58 = (AFn)RT.map(new Object[] { RT.keyword(null, "no-doc"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(111), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/coerce.clj" });
    const__59 = (Var)RT.var("clojure.core", "merge");
    const__60 = (Var)RT.var("schema.core", "Keyword");
    const__61 = (Var)RT.var("schema.core", "Bool");
    const__62 = (Var)RT.var("schema.core", "Uuid");
    const__63 = RT.classForName("clojure.lang.Keyword");
    const__64 = (Var)RT.var("schema.core", "Int");
    const__65 = RT.classForName("java.lang.Long");
    const__66 = RT.classForName("java.lang.Double");
    const__67 = (Var)RT.var("clojure.core", "double");
    const__68 = RT.classForName("java.lang.Float");
    const__69 = (Var)RT.var("clojure.core", "float");
    const__70 = RT.classForName("java.lang.Boolean");
    const__71 = (Var)RT.var("schema.coerce", "json-coercion-matcher");
    const__74 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "schema")) })), RT.keyword(null, "doc"), "A matcher that coerces keywords and keyword eq/enums from strings, and longs and doubles\n     from numbers on the JVM (without losing precision)", RT.keyword(null, "line"), Integer.valueOf(123), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/coerce.clj" });
    const__75 = (Var)RT.var("schema.coerce", "edn-read-string");
    const__77 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(131), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/coerce.clj", RT.keyword(null, "doc"), "Reads one object from a string. Returns nil when string is nil or empty" });
    const__78 = (Var)RT.var("clojure.edn", "read-string");
    const__79 = (Var)RT.var("schema.coerce", "+string-coercions+");
    const__81 = (AFn)RT.map(new Object[] { RT.keyword(null, "no-doc"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(135), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/coerce.clj" });
    const__82 = (Var)RT.var("schema.core", "Num");
    const__83 = (Var)RT.var("schema.coerce", "string-coercion-matcher");
    const__86 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "schema")) })), RT.keyword(null, "doc"), "A matcher that coerces keywords, keyword eq/enums, s/Num and s/Int,\n     and long and doubles (JVM only) from strings.", RT.keyword(null, "line"), Integer.valueOf(144), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/coerce.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("schema.coerce__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
