package schema;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;

public class core__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Keyword const__2;
  
  public static final AFn const__3;
  
  public static final AFn const__4;
  
  public static final Var const__5;
  
  public static final AFn const__11;
  
  public static final Object const__12;
  
  public static final Var const__13;
  
  public static final Var const__14;
  
  public static final Var const__15;
  
  public static final Var const__16;
  
  public static final ISeq const__17;
  
  public static final Var const__18;
  
  public static final Var const__19;
  
  public static final AFn const__23;
  
  public static final Keyword const__24;
  
  public static final AFn const__25;
  
  public static final Keyword const__26;
  
  public static final Keyword const__27;
  
  public static final AFn const__29;
  
  public static final Keyword const__30;
  
  public static final Var const__31;
  
  public static final Var const__32;
  
  public static final Var const__33;
  
  public static final AFn const__34;
  
  public static final AFn const__35;
  
  public static final Keyword const__36;
  
  public static final Var const__37;
  
  public static final AFn const__38;
  
  public static final Var const__39;
  
  public static final Var const__40;
  
  public static final AFn const__41;
  
  public static final Keyword const__42;
  
  public static final AFn const__43;
  
  public static final Var const__44;
  
  public static final Object const__45;
  
  public static final Var const__46;
  
  public static final ISeq const__47;
  
  public static final AFn const__49;
  
  public static final AFn const__50;
  
  public static final Keyword const__51;
  
  public static final Keyword const__52;
  
  public static final AFn const__53;
  
  public static final AFn const__54;
  
  public static final AFn const__55;
  
  public static final AFn const__56;
  
  public static final AFn const__57;
  
  public static final AFn const__58;
  
  public static final Var const__59;
  
  public static final Var const__60;
  
  public static final Var const__61;
  
  public static final AFn const__66;
  
  public static final Var const__67;
  
  public static final AFn const__70;
  
  public static final Var const__71;
  
  public static final AFn const__74;
  
  public static final Var const__75;
  
  public static final AFn const__78;
  
  public static final Var const__79;
  
  public static final AFn const__82;
  
  public static final Object const__83;
  
  public static final Var const__84;
  
  public static final AFn const__88;
  
  public static final Var const__89;
  
  public static final Var const__90;
  
  public static final Var const__91;
  
  public static final AFn const__92;
  
  public static final AFn const__93;
  
  public static final AFn const__94;
  
  public static final AFn const__95;
  
  public static final AFn const__96;
  
  public static final AFn const__97;
  
  public static final AFn const__98;
  
  public static final AFn const__99;
  
  public static final AFn const__100;
  
  public static final AFn const__101;
  
  public static final AFn const__102;
  
  public static final AFn const__103;
  
  public static final AFn const__104;
  
  public static final AFn const__105;
  
  public static final AFn const__106;
  
  public static final AFn const__107;
  
  public static final Var const__108;
  
  public static final AFn const__110;
  
  public static final Var const__111;
  
  public static final AFn const__114;
  
  public static final Var const__115;
  
  public static final AFn const__118;
  
  public static final Var const__119;
  
  public static final AFn const__122;
  
  public static final Var const__123;
  
  public static final AFn const__126;
  
  public static final Var const__127;
  
  public static final AFn const__130;
  
  public static final Var const__131;
  
  public static final AFn const__134;
  
  public static final Object const__135;
  
  public static final Var const__136;
  
  public static final AFn const__138;
  
  public static final Object const__139;
  
  public static final Var const__140;
  
  public static final AFn const__142;
  
  public static final Object const__143;
  
  public static final Var const__144;
  
  public static final AFn const__146;
  
  public static final Object const__147;
  
  public static final Var const__148;
  
  public static final AFn const__150;
  
  public static final Var const__151;
  
  public static final Var const__152;
  
  public static final AFn const__154;
  
  public static final Var const__155;
  
  public static final Var const__156;
  
  public static final AFn const__158;
  
  public static final Var const__159;
  
  public static final Var const__160;
  
  public static final AFn const__162;
  
  public static final Var const__163;
  
  public static final AFn const__165;
  
  public static final Object const__166;
  
  public static final Var const__167;
  
  public static final AFn const__169;
  
  public static final Object const__170;
  
  public static final Var const__171;
  
  public static final AFn const__174;
  
  public static final Var const__175;
  
  public static final AFn const__178;
  
  public static final Var const__179;
  
  public static final AFn const__183;
  
  public static final Var const__184;
  
  public static final AFn const__187;
  
  public static final Object const__188;
  
  public static final Var const__189;
  
  public static final ISeq const__190;
  
  public static final AFn const__192;
  
  public static final AFn const__193;
  
  public static final Keyword const__194;
  
  public static final AFn const__195;
  
  public static final AFn const__196;
  
  public static final AFn const__197;
  
  public static final AFn const__198;
  
  public static final Object const__199;
  
  public static final Object const__200;
  
  public static final Object const__201;
  
  public static final Var const__202;
  
  public static final AFn const__205;
  
  public static final Var const__206;
  
  public static final AFn const__209;
  
  public static final Var const__210;
  
  public static final AFn const__213;
  
  public static final Var const__214;
  
  public static final AFn const__217;
  
  public static final Var const__218;
  
  public static final AFn const__221;
  
  public static final Var const__222;
  
  public static final AFn const__225;
  
  public static final Var const__226;
  
  public static final AFn const__230;
  
  public static final Var const__231;
  
  public static final AFn const__234;
  
  public static final Var const__235;
  
  public static final AFn const__238;
  
  public static final Var const__239;
  
  public static final AFn const__242;
  
  public static final Var const__243;
  
  public static final AFn const__246;
  
  public static final Var const__247;
  
  public static final AFn const__250;
  
  public static final Var const__251;
  
  public static final AFn const__254;
  
  public static final Var const__255;
  
  public static final AFn const__258;
  
  public static final Var const__259;
  
  public static final AFn const__262;
  
  public static final Var const__263;
  
  public static final AFn const__266;
  
  public static final Var const__267;
  
  public static final AFn const__270;
  
  public static final Var const__271;
  
  public static final AFn const__274;
  
  public static final Var const__275;
  
  public static final AFn const__278;
  
  public static final Var const__279;
  
  public static final AFn const__282;
  
  public static final Var const__283;
  
  public static final AFn const__286;
  
  public static final Var const__287;
  
  public static final AFn const__290;
  
  public static final Object const__291;
  
  public static final Object const__292;
  
  public static final Var const__293;
  
  public static final AFn const__296;
  
  public static final Var const__297;
  
  public static final AFn const__300;
  
  public static final Var const__301;
  
  public static final AFn const__304;
  
  public static final Var const__305;
  
  public static final AFn const__308;
  
  public static final Var const__309;
  
  public static final AFn const__312;
  
  public static final Var const__313;
  
  public static final AFn const__316;
  
  public static final Object const__317;
  
  public static final Var const__318;
  
  public static final AFn const__321;
  
  public static final Var const__322;
  
  public static final AFn const__325;
  
  public static final Var const__326;
  
  public static final AFn const__329;
  
  public static final Var const__330;
  
  public static final AFn const__333;
  
  public static final Var const__334;
  
  public static final AFn const__337;
  
  public static final Var const__338;
  
  public static final AFn const__341;
  
  public static final Var const__342;
  
  public static final AFn const__345;
  
  public static final Var const__346;
  
  public static final AFn const__349;
  
  public static final Var const__350;
  
  public static final AFn const__353;
  
  public static final Var const__354;
  
  public static final AFn const__357;
  
  public static final Var const__358;
  
  public static final AFn const__361;
  
  public static final Var const__362;
  
  public static final AFn const__365;
  
  public static final Var const__366;
  
  public static final AFn const__369;
  
  public static final Var const__370;
  
  public static final AFn const__373;
  
  public static final Var const__374;
  
  public static final AFn const__377;
  
  public static final Var const__378;
  
  public static final AFn const__381;
  
  public static final Var const__382;
  
  public static final AFn const__385;
  
  public static final Var const__386;
  
  public static final AFn const__389;
  
  public static final Var const__390;
  
  public static final AFn const__393;
  
  public static final Var const__394;
  
  public static final AFn const__396;
  
  public static final Var const__397;
  
  public static final AFn const__400;
  
  public static final Var const__401;
  
  public static final AFn const__406;
  
  public static final Var const__407;
  
  public static final AFn const__408;
  
  public static final Var const__409;
  
  public static final AFn const__412;
  
  public static final Var const__413;
  
  public static final AFn const__416;
  
  public static final Var const__417;
  
  public static final AFn const__420;
  
  public static final Var const__421;
  
  public static final AFn const__424;
  
  public static final Var const__425;
  
  public static final AFn const__428;
  
  public static final Var const__429;
  
  public static final AFn const__432;
  
  public static void load() { // Byte code:
    //   0: getstatic schema/core__init.const__0 : Lclojure/lang/Var;
    //   3: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   6: checkcast clojure/lang/IFn
    //   9: getstatic schema/core__init.const__1 : Lclojure/lang/AFn;
    //   12: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   17: getstatic schema/core__init.const__1 : Lclojure/lang/AFn;
    //   20: checkcast clojure/lang/Symbol
    //   23: invokestatic find : (Lclojure/lang/Symbol;)Lclojure/lang/Namespace;
    //   26: checkcast clojure/lang/AReference
    //   29: getstatic schema/core__init.const__3 : Lclojure/lang/AFn;
    //   32: checkcast clojure/lang/IPersistentMap
    //   35: invokevirtual resetMeta : (Lclojure/lang/IPersistentMap;)Lclojure/lang/IPersistentMap;
    //   38: new schema/core$loading__6721__auto____21544
    //   41: dup
    //   42: invokespecial <init> : ()V
    //   45: checkcast clojure/lang/IFn
    //   48: invokeinterface invoke : ()Ljava/lang/Object;
    //   53: getstatic schema/core__init.const__1 : Lclojure/lang/AFn;
    //   56: checkcast clojure/lang/Symbol
    //   59: getstatic schema/core__init.const__4 : Lclojure/lang/AFn;
    //   62: invokevirtual equals : (Ljava/lang/Object;)Z
    //   65: ifeq -> 73
    //   68: aconst_null
    //   69: goto -> 88
    //   72: athrow
    //   73: new schema/core$fn__21774
    //   76: dup
    //   77: invokespecial <init> : ()V
    //   80: checkcast java/util/concurrent/Callable
    //   83: invokestatic runInTransaction : (Ljava/util/concurrent/Callable;)Ljava/lang/Object;
    //   86: pop
    //   87: aconst_null
    //   88: getstatic schema/core__init.const__5 : Lclojure/lang/Var;
    //   91: dup
    //   92: getstatic schema/core__init.const__11 : Lclojure/lang/AFn;
    //   95: checkcast clojure/lang/IPersistentMap
    //   98: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   101: dup
    //   102: new schema/core$fn__21778
    //   105: dup
    //   106: invokespecial <init> : ()V
    //   109: checkcast clojure/lang/IFn
    //   112: invokeinterface invoke : ()Ljava/lang/Object;
    //   117: pop
    //   118: getstatic schema/core__init.const__12 : Ljava/lang/Object;
    //   121: pop
    //   122: getstatic schema/core__init.const__13 : Lclojure/lang/Var;
    //   125: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   128: checkcast clojure/lang/IFn
    //   131: getstatic schema/core__init.const__14 : Lclojure/lang/Var;
    //   134: getstatic schema/core__init.const__15 : Lclojure/lang/Var;
    //   137: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   140: getstatic schema/core__init.const__2 : Lclojure/lang/Keyword;
    //   143: aconst_null
    //   144: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   149: pop
    //   150: getstatic schema/core__init.const__16 : Lclojure/lang/Var;
    //   153: checkcast clojure/lang/IFn
    //   156: getstatic schema/core__init.const__14 : Lclojure/lang/Var;
    //   159: getstatic schema/core__init.const__17 : Lclojure/lang/ISeq;
    //   162: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   167: pop
    //   168: getstatic schema/core__init.const__18 : Lclojure/lang/Var;
    //   171: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   174: checkcast clojure/lang/IFn
    //   177: getstatic schema/core__init.const__14 : Lclojure/lang/Var;
    //   180: getstatic schema/core__init.const__19 : Lclojure/lang/Var;
    //   183: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   186: getstatic schema/core__init.const__15 : Lclojure/lang/Var;
    //   189: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   192: checkcast clojure/lang/IFn
    //   195: getstatic schema/core__init.const__23 : Lclojure/lang/AFn;
    //   198: getstatic schema/core__init.const__24 : Lclojure/lang/Keyword;
    //   201: getstatic schema/core__init.const__25 : Lclojure/lang/AFn;
    //   204: getstatic schema/core__init.const__26 : Lclojure/lang/Keyword;
    //   207: getstatic schema/core__init.const__14 : Lclojure/lang/Var;
    //   210: getstatic schema/core__init.const__27 : Lclojure/lang/Keyword;
    //   213: getstatic schema/core__init.const__29 : Lclojure/lang/AFn;
    //   216: getstatic schema/core__init.const__30 : Lclojure/lang/Keyword;
    //   219: iconst_2
    //   220: anewarray java/lang/Object
    //   223: dup
    //   224: iconst_0
    //   225: getstatic schema/core__init.const__31 : Lclojure/lang/Var;
    //   228: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   231: checkcast clojure/lang/IFn
    //   234: getstatic schema/core__init.const__32 : Lclojure/lang/Var;
    //   237: invokevirtual get : ()Ljava/lang/Object;
    //   240: getstatic schema/core__init.const__33 : Lclojure/lang/Var;
    //   243: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   246: checkcast clojure/lang/IFn
    //   249: getstatic schema/core__init.const__34 : Lclojure/lang/AFn;
    //   252: getstatic schema/core__init.const__19 : Lclojure/lang/Var;
    //   255: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   258: checkcast clojure/lang/IFn
    //   261: getstatic schema/core__init.const__35 : Lclojure/lang/AFn;
    //   264: iconst_2
    //   265: anewarray java/lang/Object
    //   268: dup
    //   269: iconst_0
    //   270: getstatic schema/core__init.const__36 : Lclojure/lang/Keyword;
    //   273: aastore
    //   274: dup
    //   275: iconst_1
    //   276: getstatic schema/core__init.const__14 : Lclojure/lang/Var;
    //   279: aastore
    //   280: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   283: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   288: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   293: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   298: aastore
    //   299: dup
    //   300: iconst_1
    //   301: new schema/core$fn__21781
    //   304: dup
    //   305: invokespecial <init> : ()V
    //   308: aastore
    //   309: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   312: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   317: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   322: pop
    //   323: getstatic schema/core__init.const__37 : Lclojure/lang/Var;
    //   326: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   329: checkcast clojure/lang/IFn
    //   332: getstatic schema/core__init.const__14 : Lclojure/lang/Var;
    //   335: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   338: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   343: pop
    //   344: getstatic schema/core__init.const__38 : Lclojure/lang/AFn;
    //   347: pop
    //   348: new schema/core$fn__21792
    //   351: dup
    //   352: invokespecial <init> : ()V
    //   355: checkcast clojure/lang/IFn
    //   358: invokeinterface invoke : ()Ljava/lang/Object;
    //   363: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   366: getstatic schema/core__init.const__5 : Lclojure/lang/Var;
    //   369: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   372: dup
    //   373: ifnull -> 386
    //   376: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   379: if_acmpeq -> 387
    //   382: aconst_null
    //   383: goto -> 410
    //   386: pop
    //   387: getstatic schema/core__init.const__40 : Lclojure/lang/Var;
    //   390: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   393: checkcast clojure/lang/IFn
    //   396: getstatic schema/core__init.const__41 : Lclojure/lang/AFn;
    //   399: getstatic schema/core__init.const__42 : Lclojure/lang/Keyword;
    //   402: getstatic schema/core__init.const__43 : Lclojure/lang/AFn;
    //   405: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   410: getstatic schema/core__init.const__44 : Lclojure/lang/Var;
    //   413: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   416: invokevirtual set : (Ljava/lang/Object;)Ljava/lang/Object;
    //   419: new schema/core$fn__21802
    //   422: dup
    //   423: invokespecial <init> : ()V
    //   426: checkcast clojure/lang/IFn
    //   429: invokeinterface invoke : ()Ljava/lang/Object;
    //   434: getstatic schema/core__init.const__45 : Ljava/lang/Object;
    //   437: getstatic schema/core__init.const__13 : Lclojure/lang/Var;
    //   440: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   443: checkcast clojure/lang/IFn
    //   446: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   449: getstatic schema/core__init.const__15 : Lclojure/lang/Var;
    //   452: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   455: getstatic schema/core__init.const__2 : Lclojure/lang/Keyword;
    //   458: aconst_null
    //   459: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   464: getstatic schema/core__init.const__16 : Lclojure/lang/Var;
    //   467: checkcast clojure/lang/IFn
    //   470: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   473: getstatic schema/core__init.const__47 : Lclojure/lang/ISeq;
    //   476: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   481: getstatic schema/core__init.const__18 : Lclojure/lang/Var;
    //   484: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   487: checkcast clojure/lang/IFn
    //   490: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   493: getstatic schema/core__init.const__19 : Lclojure/lang/Var;
    //   496: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   499: getstatic schema/core__init.const__15 : Lclojure/lang/Var;
    //   502: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   505: checkcast clojure/lang/IFn
    //   508: getstatic schema/core__init.const__49 : Lclojure/lang/AFn;
    //   511: getstatic schema/core__init.const__24 : Lclojure/lang/Keyword;
    //   514: getstatic schema/core__init.const__50 : Lclojure/lang/AFn;
    //   517: getstatic schema/core__init.const__26 : Lclojure/lang/Keyword;
    //   520: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   523: getstatic schema/core__init.const__27 : Lclojure/lang/Keyword;
    //   526: getstatic schema/core__init.const__53 : Lclojure/lang/AFn;
    //   529: getstatic schema/core__init.const__30 : Lclojure/lang/Keyword;
    //   532: iconst_4
    //   533: anewarray java/lang/Object
    //   536: dup
    //   537: iconst_0
    //   538: getstatic schema/core__init.const__31 : Lclojure/lang/Var;
    //   541: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   544: checkcast clojure/lang/IFn
    //   547: getstatic schema/core__init.const__32 : Lclojure/lang/Var;
    //   550: invokevirtual get : ()Ljava/lang/Object;
    //   553: getstatic schema/core__init.const__33 : Lclojure/lang/Var;
    //   556: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   559: checkcast clojure/lang/IFn
    //   562: getstatic schema/core__init.const__54 : Lclojure/lang/AFn;
    //   565: getstatic schema/core__init.const__19 : Lclojure/lang/Var;
    //   568: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   571: checkcast clojure/lang/IFn
    //   574: getstatic schema/core__init.const__55 : Lclojure/lang/AFn;
    //   577: iconst_2
    //   578: anewarray java/lang/Object
    //   581: dup
    //   582: iconst_0
    //   583: getstatic schema/core__init.const__36 : Lclojure/lang/Keyword;
    //   586: aastore
    //   587: dup
    //   588: iconst_1
    //   589: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   592: aastore
    //   593: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   596: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   601: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   606: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   611: aastore
    //   612: dup
    //   613: iconst_1
    //   614: new schema/core$fn__21805
    //   617: dup
    //   618: invokespecial <init> : ()V
    //   621: aastore
    //   622: dup
    //   623: iconst_2
    //   624: getstatic schema/core__init.const__31 : Lclojure/lang/Var;
    //   627: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   630: checkcast clojure/lang/IFn
    //   633: getstatic schema/core__init.const__32 : Lclojure/lang/Var;
    //   636: invokevirtual get : ()Ljava/lang/Object;
    //   639: getstatic schema/core__init.const__33 : Lclojure/lang/Var;
    //   642: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   645: checkcast clojure/lang/IFn
    //   648: getstatic schema/core__init.const__56 : Lclojure/lang/AFn;
    //   651: getstatic schema/core__init.const__19 : Lclojure/lang/Var;
    //   654: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   657: checkcast clojure/lang/IFn
    //   660: getstatic schema/core__init.const__57 : Lclojure/lang/AFn;
    //   663: iconst_2
    //   664: anewarray java/lang/Object
    //   667: dup
    //   668: iconst_0
    //   669: getstatic schema/core__init.const__36 : Lclojure/lang/Keyword;
    //   672: aastore
    //   673: dup
    //   674: iconst_1
    //   675: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   678: aastore
    //   679: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   682: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   687: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   692: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   697: aastore
    //   698: dup
    //   699: iconst_3
    //   700: new schema/core$fn__21816
    //   703: dup
    //   704: invokespecial <init> : ()V
    //   707: aastore
    //   708: invokestatic map : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   711: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   716: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   721: getstatic schema/core__init.const__37 : Lclojure/lang/Var;
    //   724: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   727: checkcast clojure/lang/IFn
    //   730: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   733: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   736: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   741: getstatic schema/core__init.const__58 : Lclojure/lang/AFn;
    //   744: getstatic schema/core__init.const__59 : Lclojure/lang/Var;
    //   747: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   750: checkcast clojure/lang/MultiFn
    //   753: getstatic schema/core__init.const__45 : Ljava/lang/Object;
    //   756: new schema/core$fn__21827
    //   759: dup
    //   760: invokespecial <init> : ()V
    //   763: checkcast clojure/lang/IFn
    //   766: invokevirtual addMethod : (Ljava/lang/Object;Lclojure/lang/IFn;)Lclojure/lang/MultiFn;
    //   769: getstatic schema/core__init.const__60 : Lclojure/lang/Var;
    //   772: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   775: checkcast clojure/lang/MultiFn
    //   778: getstatic schema/core__init.const__45 : Ljava/lang/Object;
    //   781: new schema/core$fn__21829
    //   784: dup
    //   785: invokespecial <init> : ()V
    //   788: checkcast clojure/lang/IFn
    //   791: invokevirtual addMethod : (Ljava/lang/Object;Lclojure/lang/IFn;)Lclojure/lang/MultiFn;
    //   794: new schema/core$fn__21835
    //   797: dup
    //   798: invokespecial <init> : ()V
    //   801: checkcast clojure/lang/IFn
    //   804: invokeinterface invoke : ()Ljava/lang/Object;
    //   809: getstatic schema/core__init.const__61 : Lclojure/lang/Var;
    //   812: dup
    //   813: getstatic schema/core__init.const__66 : Lclojure/lang/AFn;
    //   816: checkcast clojure/lang/IPersistentMap
    //   819: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   822: dup
    //   823: new schema/core$checker
    //   826: dup
    //   827: invokespecial <init> : ()V
    //   830: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   833: getstatic schema/core__init.const__67 : Lclojure/lang/Var;
    //   836: dup
    //   837: getstatic schema/core__init.const__70 : Lclojure/lang/AFn;
    //   840: checkcast clojure/lang/IPersistentMap
    //   843: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   846: dup
    //   847: new schema/core$check
    //   850: dup
    //   851: invokespecial <init> : ()V
    //   854: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   857: getstatic schema/core__init.const__71 : Lclojure/lang/Var;
    //   860: dup
    //   861: getstatic schema/core__init.const__74 : Lclojure/lang/AFn;
    //   864: checkcast clojure/lang/IPersistentMap
    //   867: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   870: dup
    //   871: new schema/core$validator
    //   874: dup
    //   875: invokespecial <init> : ()V
    //   878: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   881: getstatic schema/core__init.const__75 : Lclojure/lang/Var;
    //   884: dup
    //   885: getstatic schema/core__init.const__78 : Lclojure/lang/AFn;
    //   888: checkcast clojure/lang/IPersistentMap
    //   891: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   894: dup
    //   895: new schema/core$validate
    //   898: dup
    //   899: invokespecial <init> : ()V
    //   902: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   905: getstatic schema/core__init.const__79 : Lclojure/lang/Var;
    //   908: dup
    //   909: getstatic schema/core__init.const__82 : Lclojure/lang/AFn;
    //   912: checkcast clojure/lang/IPersistentMap
    //   915: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   918: dup
    //   919: new schema/core$instance_precondition
    //   922: dup
    //   923: invokespecial <init> : ()V
    //   926: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   929: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   932: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   935: checkcast clojure/lang/IFn
    //   938: getstatic schema/core__init.const__83 : Ljava/lang/Object;
    //   941: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   944: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   947: iconst_4
    //   948: anewarray java/lang/Object
    //   951: dup
    //   952: iconst_0
    //   953: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   956: aastore
    //   957: dup
    //   958: iconst_1
    //   959: new schema/core$fn__21855
    //   962: dup
    //   963: invokespecial <init> : ()V
    //   966: aastore
    //   967: dup
    //   968: iconst_2
    //   969: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   972: aastore
    //   973: dup
    //   974: iconst_3
    //   975: new schema/core$fn__21858
    //   978: dup
    //   979: invokespecial <init> : ()V
    //   982: aastore
    //   983: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   986: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   991: getstatic schema/core__init.const__84 : Lclojure/lang/Var;
    //   994: dup
    //   995: getstatic schema/core__init.const__88 : Lclojure/lang/AFn;
    //   998: checkcast clojure/lang/IPersistentMap
    //   1001: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1004: dup
    //   1005: new schema/core$extend_primitive
    //   1008: dup
    //   1009: invokespecial <init> : ()V
    //   1012: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1015: getstatic schema/core__init.const__84 : Lclojure/lang/Var;
    //   1018: checkcast clojure/lang/Var
    //   1021: invokevirtual setMacro : ()V
    //   1024: aconst_null
    //   1025: getstatic schema/core__init.const__84 : Lclojure/lang/Var;
    //   1028: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   1031: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1034: checkcast clojure/lang/IFn
    //   1037: getstatic schema/core__init.const__89 : Lclojure/lang/Var;
    //   1040: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1043: checkcast clojure/lang/IFn
    //   1046: getstatic schema/core__init.const__90 : Lclojure/lang/Var;
    //   1049: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1052: checkcast clojure/lang/IFn
    //   1055: getstatic schema/core__init.const__91 : Lclojure/lang/Var;
    //   1058: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1061: checkcast clojure/lang/IFn
    //   1064: getstatic schema/core__init.const__92 : Lclojure/lang/AFn;
    //   1067: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1072: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1077: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1082: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   1085: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1088: iconst_4
    //   1089: anewarray java/lang/Object
    //   1092: dup
    //   1093: iconst_0
    //   1094: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   1097: aastore
    //   1098: dup
    //   1099: iconst_1
    //   1100: new schema/core$fn__21865
    //   1103: dup
    //   1104: invokespecial <init> : ()V
    //   1107: aastore
    //   1108: dup
    //   1109: iconst_2
    //   1110: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   1113: aastore
    //   1114: dup
    //   1115: iconst_3
    //   1116: new schema/core$fn__21867
    //   1119: dup
    //   1120: invokespecial <init> : ()V
    //   1123: aastore
    //   1124: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   1127: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1132: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   1135: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1138: checkcast clojure/lang/IFn
    //   1141: getstatic schema/core__init.const__89 : Lclojure/lang/Var;
    //   1144: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1147: checkcast clojure/lang/IFn
    //   1150: getstatic schema/core__init.const__90 : Lclojure/lang/Var;
    //   1153: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1156: checkcast clojure/lang/IFn
    //   1159: getstatic schema/core__init.const__91 : Lclojure/lang/Var;
    //   1162: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1165: checkcast clojure/lang/IFn
    //   1168: getstatic schema/core__init.const__93 : Lclojure/lang/AFn;
    //   1171: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1176: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1181: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1186: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   1189: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1192: iconst_4
    //   1193: anewarray java/lang/Object
    //   1196: dup
    //   1197: iconst_0
    //   1198: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   1201: aastore
    //   1202: dup
    //   1203: iconst_1
    //   1204: new schema/core$fn__21869
    //   1207: dup
    //   1208: invokespecial <init> : ()V
    //   1211: aastore
    //   1212: dup
    //   1213: iconst_2
    //   1214: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   1217: aastore
    //   1218: dup
    //   1219: iconst_3
    //   1220: new schema/core$fn__21871
    //   1223: dup
    //   1224: invokespecial <init> : ()V
    //   1227: aastore
    //   1228: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   1231: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1236: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   1239: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1242: checkcast clojure/lang/IFn
    //   1245: getstatic schema/core__init.const__89 : Lclojure/lang/Var;
    //   1248: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1251: checkcast clojure/lang/IFn
    //   1254: getstatic schema/core__init.const__90 : Lclojure/lang/Var;
    //   1257: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1260: checkcast clojure/lang/IFn
    //   1263: getstatic schema/core__init.const__91 : Lclojure/lang/Var;
    //   1266: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1269: checkcast clojure/lang/IFn
    //   1272: getstatic schema/core__init.const__94 : Lclojure/lang/AFn;
    //   1275: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1280: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1285: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1290: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   1293: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1296: iconst_4
    //   1297: anewarray java/lang/Object
    //   1300: dup
    //   1301: iconst_0
    //   1302: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   1305: aastore
    //   1306: dup
    //   1307: iconst_1
    //   1308: new schema/core$fn__21873
    //   1311: dup
    //   1312: invokespecial <init> : ()V
    //   1315: aastore
    //   1316: dup
    //   1317: iconst_2
    //   1318: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   1321: aastore
    //   1322: dup
    //   1323: iconst_3
    //   1324: new schema/core$fn__21875
    //   1327: dup
    //   1328: invokespecial <init> : ()V
    //   1331: aastore
    //   1332: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   1335: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1340: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   1343: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1346: checkcast clojure/lang/IFn
    //   1349: getstatic schema/core__init.const__89 : Lclojure/lang/Var;
    //   1352: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1355: checkcast clojure/lang/IFn
    //   1358: getstatic schema/core__init.const__90 : Lclojure/lang/Var;
    //   1361: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1364: checkcast clojure/lang/IFn
    //   1367: getstatic schema/core__init.const__91 : Lclojure/lang/Var;
    //   1370: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1373: checkcast clojure/lang/IFn
    //   1376: getstatic schema/core__init.const__95 : Lclojure/lang/AFn;
    //   1379: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1384: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1389: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1394: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   1397: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1400: iconst_4
    //   1401: anewarray java/lang/Object
    //   1404: dup
    //   1405: iconst_0
    //   1406: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   1409: aastore
    //   1410: dup
    //   1411: iconst_1
    //   1412: new schema/core$fn__21877
    //   1415: dup
    //   1416: invokespecial <init> : ()V
    //   1419: aastore
    //   1420: dup
    //   1421: iconst_2
    //   1422: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   1425: aastore
    //   1426: dup
    //   1427: iconst_3
    //   1428: new schema/core$fn__21879
    //   1431: dup
    //   1432: invokespecial <init> : ()V
    //   1435: aastore
    //   1436: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   1439: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1444: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   1447: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1450: checkcast clojure/lang/IFn
    //   1453: getstatic schema/core__init.const__89 : Lclojure/lang/Var;
    //   1456: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1459: checkcast clojure/lang/IFn
    //   1462: getstatic schema/core__init.const__90 : Lclojure/lang/Var;
    //   1465: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1468: checkcast clojure/lang/IFn
    //   1471: getstatic schema/core__init.const__91 : Lclojure/lang/Var;
    //   1474: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1477: checkcast clojure/lang/IFn
    //   1480: getstatic schema/core__init.const__96 : Lclojure/lang/AFn;
    //   1483: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1488: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1493: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1498: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   1501: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1504: iconst_4
    //   1505: anewarray java/lang/Object
    //   1508: dup
    //   1509: iconst_0
    //   1510: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   1513: aastore
    //   1514: dup
    //   1515: iconst_1
    //   1516: new schema/core$fn__21881
    //   1519: dup
    //   1520: invokespecial <init> : ()V
    //   1523: aastore
    //   1524: dup
    //   1525: iconst_2
    //   1526: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   1529: aastore
    //   1530: dup
    //   1531: iconst_3
    //   1532: new schema/core$fn__21883
    //   1535: dup
    //   1536: invokespecial <init> : ()V
    //   1539: aastore
    //   1540: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   1543: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1548: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   1551: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1554: checkcast clojure/lang/IFn
    //   1557: getstatic schema/core__init.const__89 : Lclojure/lang/Var;
    //   1560: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1563: checkcast clojure/lang/IFn
    //   1566: getstatic schema/core__init.const__90 : Lclojure/lang/Var;
    //   1569: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1572: checkcast clojure/lang/IFn
    //   1575: getstatic schema/core__init.const__91 : Lclojure/lang/Var;
    //   1578: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1581: checkcast clojure/lang/IFn
    //   1584: getstatic schema/core__init.const__97 : Lclojure/lang/AFn;
    //   1587: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1592: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1597: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1602: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   1605: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1608: iconst_4
    //   1609: anewarray java/lang/Object
    //   1612: dup
    //   1613: iconst_0
    //   1614: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   1617: aastore
    //   1618: dup
    //   1619: iconst_1
    //   1620: new schema/core$fn__21885
    //   1623: dup
    //   1624: invokespecial <init> : ()V
    //   1627: aastore
    //   1628: dup
    //   1629: iconst_2
    //   1630: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   1633: aastore
    //   1634: dup
    //   1635: iconst_3
    //   1636: new schema/core$fn__21887
    //   1639: dup
    //   1640: invokespecial <init> : ()V
    //   1643: aastore
    //   1644: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   1647: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1652: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   1655: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1658: checkcast clojure/lang/IFn
    //   1661: getstatic schema/core__init.const__89 : Lclojure/lang/Var;
    //   1664: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1667: checkcast clojure/lang/IFn
    //   1670: getstatic schema/core__init.const__90 : Lclojure/lang/Var;
    //   1673: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1676: checkcast clojure/lang/IFn
    //   1679: getstatic schema/core__init.const__91 : Lclojure/lang/Var;
    //   1682: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1685: checkcast clojure/lang/IFn
    //   1688: getstatic schema/core__init.const__98 : Lclojure/lang/AFn;
    //   1691: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1696: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1701: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1706: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   1709: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1712: iconst_4
    //   1713: anewarray java/lang/Object
    //   1716: dup
    //   1717: iconst_0
    //   1718: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   1721: aastore
    //   1722: dup
    //   1723: iconst_1
    //   1724: new schema/core$fn__21889
    //   1727: dup
    //   1728: invokespecial <init> : ()V
    //   1731: aastore
    //   1732: dup
    //   1733: iconst_2
    //   1734: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   1737: aastore
    //   1738: dup
    //   1739: iconst_3
    //   1740: new schema/core$fn__21891
    //   1743: dup
    //   1744: invokespecial <init> : ()V
    //   1747: aastore
    //   1748: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   1751: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1756: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   1759: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1762: checkcast clojure/lang/IFn
    //   1765: getstatic schema/core__init.const__89 : Lclojure/lang/Var;
    //   1768: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1771: checkcast clojure/lang/IFn
    //   1774: getstatic schema/core__init.const__90 : Lclojure/lang/Var;
    //   1777: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1780: checkcast clojure/lang/IFn
    //   1783: getstatic schema/core__init.const__91 : Lclojure/lang/Var;
    //   1786: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1789: checkcast clojure/lang/IFn
    //   1792: getstatic schema/core__init.const__99 : Lclojure/lang/AFn;
    //   1795: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1800: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1805: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1810: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   1813: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1816: iconst_4
    //   1817: anewarray java/lang/Object
    //   1820: dup
    //   1821: iconst_0
    //   1822: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   1825: aastore
    //   1826: dup
    //   1827: iconst_1
    //   1828: new schema/core$fn__21893
    //   1831: dup
    //   1832: invokespecial <init> : ()V
    //   1835: aastore
    //   1836: dup
    //   1837: iconst_2
    //   1838: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   1841: aastore
    //   1842: dup
    //   1843: iconst_3
    //   1844: new schema/core$fn__21895
    //   1847: dup
    //   1848: invokespecial <init> : ()V
    //   1851: aastore
    //   1852: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   1855: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1860: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   1863: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1866: checkcast clojure/lang/IFn
    //   1869: getstatic schema/core__init.const__89 : Lclojure/lang/Var;
    //   1872: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1875: checkcast clojure/lang/IFn
    //   1878: getstatic schema/core__init.const__90 : Lclojure/lang/Var;
    //   1881: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1884: checkcast clojure/lang/IFn
    //   1887: getstatic schema/core__init.const__91 : Lclojure/lang/Var;
    //   1890: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1893: checkcast clojure/lang/IFn
    //   1896: getstatic schema/core__init.const__100 : Lclojure/lang/AFn;
    //   1899: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1904: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1909: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   1914: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   1917: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1920: iconst_4
    //   1921: anewarray java/lang/Object
    //   1924: dup
    //   1925: iconst_0
    //   1926: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   1929: aastore
    //   1930: dup
    //   1931: iconst_1
    //   1932: new schema/core$fn__21897
    //   1935: dup
    //   1936: invokespecial <init> : ()V
    //   1939: aastore
    //   1940: dup
    //   1941: iconst_2
    //   1942: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   1945: aastore
    //   1946: dup
    //   1947: iconst_3
    //   1948: new schema/core$fn__21899
    //   1951: dup
    //   1952: invokespecial <init> : ()V
    //   1955: aastore
    //   1956: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   1959: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   1964: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   1967: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1970: checkcast clojure/lang/IFn
    //   1973: getstatic schema/core__init.const__89 : Lclojure/lang/Var;
    //   1976: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1979: checkcast clojure/lang/IFn
    //   1982: getstatic schema/core__init.const__90 : Lclojure/lang/Var;
    //   1985: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1988: checkcast clojure/lang/IFn
    //   1991: getstatic schema/core__init.const__91 : Lclojure/lang/Var;
    //   1994: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   1997: checkcast clojure/lang/IFn
    //   2000: getstatic schema/core__init.const__101 : Lclojure/lang/AFn;
    //   2003: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2008: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2013: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2018: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   2021: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2024: iconst_4
    //   2025: anewarray java/lang/Object
    //   2028: dup
    //   2029: iconst_0
    //   2030: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   2033: aastore
    //   2034: dup
    //   2035: iconst_1
    //   2036: new schema/core$fn__21901
    //   2039: dup
    //   2040: invokespecial <init> : ()V
    //   2043: aastore
    //   2044: dup
    //   2045: iconst_2
    //   2046: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   2049: aastore
    //   2050: dup
    //   2051: iconst_3
    //   2052: new schema/core$fn__21903
    //   2055: dup
    //   2056: invokespecial <init> : ()V
    //   2059: aastore
    //   2060: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   2063: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   2068: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   2071: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2074: checkcast clojure/lang/IFn
    //   2077: getstatic schema/core__init.const__89 : Lclojure/lang/Var;
    //   2080: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2083: checkcast clojure/lang/IFn
    //   2086: getstatic schema/core__init.const__90 : Lclojure/lang/Var;
    //   2089: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2092: checkcast clojure/lang/IFn
    //   2095: getstatic schema/core__init.const__91 : Lclojure/lang/Var;
    //   2098: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2101: checkcast clojure/lang/IFn
    //   2104: getstatic schema/core__init.const__102 : Lclojure/lang/AFn;
    //   2107: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2112: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2117: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2122: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   2125: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2128: iconst_4
    //   2129: anewarray java/lang/Object
    //   2132: dup
    //   2133: iconst_0
    //   2134: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   2137: aastore
    //   2138: dup
    //   2139: iconst_1
    //   2140: new schema/core$fn__21905
    //   2143: dup
    //   2144: invokespecial <init> : ()V
    //   2147: aastore
    //   2148: dup
    //   2149: iconst_2
    //   2150: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   2153: aastore
    //   2154: dup
    //   2155: iconst_3
    //   2156: new schema/core$fn__21907
    //   2159: dup
    //   2160: invokespecial <init> : ()V
    //   2163: aastore
    //   2164: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   2167: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   2172: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   2175: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2178: checkcast clojure/lang/IFn
    //   2181: getstatic schema/core__init.const__89 : Lclojure/lang/Var;
    //   2184: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2187: checkcast clojure/lang/IFn
    //   2190: getstatic schema/core__init.const__90 : Lclojure/lang/Var;
    //   2193: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2196: checkcast clojure/lang/IFn
    //   2199: getstatic schema/core__init.const__91 : Lclojure/lang/Var;
    //   2202: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2205: checkcast clojure/lang/IFn
    //   2208: getstatic schema/core__init.const__103 : Lclojure/lang/AFn;
    //   2211: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2216: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2221: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2226: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   2229: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2232: iconst_4
    //   2233: anewarray java/lang/Object
    //   2236: dup
    //   2237: iconst_0
    //   2238: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   2241: aastore
    //   2242: dup
    //   2243: iconst_1
    //   2244: new schema/core$fn__21909
    //   2247: dup
    //   2248: invokespecial <init> : ()V
    //   2251: aastore
    //   2252: dup
    //   2253: iconst_2
    //   2254: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   2257: aastore
    //   2258: dup
    //   2259: iconst_3
    //   2260: new schema/core$fn__21911
    //   2263: dup
    //   2264: invokespecial <init> : ()V
    //   2267: aastore
    //   2268: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   2271: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   2276: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   2279: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2282: checkcast clojure/lang/IFn
    //   2285: getstatic schema/core__init.const__89 : Lclojure/lang/Var;
    //   2288: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2291: checkcast clojure/lang/IFn
    //   2294: getstatic schema/core__init.const__90 : Lclojure/lang/Var;
    //   2297: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2300: checkcast clojure/lang/IFn
    //   2303: getstatic schema/core__init.const__91 : Lclojure/lang/Var;
    //   2306: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2309: checkcast clojure/lang/IFn
    //   2312: getstatic schema/core__init.const__104 : Lclojure/lang/AFn;
    //   2315: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2320: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2325: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2330: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   2333: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2336: iconst_4
    //   2337: anewarray java/lang/Object
    //   2340: dup
    //   2341: iconst_0
    //   2342: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   2345: aastore
    //   2346: dup
    //   2347: iconst_1
    //   2348: new schema/core$fn__21913
    //   2351: dup
    //   2352: invokespecial <init> : ()V
    //   2355: aastore
    //   2356: dup
    //   2357: iconst_2
    //   2358: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   2361: aastore
    //   2362: dup
    //   2363: iconst_3
    //   2364: new schema/core$fn__21915
    //   2367: dup
    //   2368: invokespecial <init> : ()V
    //   2371: aastore
    //   2372: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   2375: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   2380: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   2383: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2386: checkcast clojure/lang/IFn
    //   2389: getstatic schema/core__init.const__89 : Lclojure/lang/Var;
    //   2392: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2395: checkcast clojure/lang/IFn
    //   2398: getstatic schema/core__init.const__90 : Lclojure/lang/Var;
    //   2401: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2404: checkcast clojure/lang/IFn
    //   2407: getstatic schema/core__init.const__91 : Lclojure/lang/Var;
    //   2410: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2413: checkcast clojure/lang/IFn
    //   2416: getstatic schema/core__init.const__105 : Lclojure/lang/AFn;
    //   2419: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2424: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2429: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2434: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   2437: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2440: iconst_4
    //   2441: anewarray java/lang/Object
    //   2444: dup
    //   2445: iconst_0
    //   2446: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   2449: aastore
    //   2450: dup
    //   2451: iconst_1
    //   2452: new schema/core$fn__21917
    //   2455: dup
    //   2456: invokespecial <init> : ()V
    //   2459: aastore
    //   2460: dup
    //   2461: iconst_2
    //   2462: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   2465: aastore
    //   2466: dup
    //   2467: iconst_3
    //   2468: new schema/core$fn__21919
    //   2471: dup
    //   2472: invokespecial <init> : ()V
    //   2475: aastore
    //   2476: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   2479: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   2484: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   2487: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2490: checkcast clojure/lang/IFn
    //   2493: getstatic schema/core__init.const__89 : Lclojure/lang/Var;
    //   2496: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2499: checkcast clojure/lang/IFn
    //   2502: getstatic schema/core__init.const__90 : Lclojure/lang/Var;
    //   2505: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2508: checkcast clojure/lang/IFn
    //   2511: getstatic schema/core__init.const__91 : Lclojure/lang/Var;
    //   2514: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2517: checkcast clojure/lang/IFn
    //   2520: getstatic schema/core__init.const__106 : Lclojure/lang/AFn;
    //   2523: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2528: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2533: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2538: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   2541: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2544: iconst_4
    //   2545: anewarray java/lang/Object
    //   2548: dup
    //   2549: iconst_0
    //   2550: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   2553: aastore
    //   2554: dup
    //   2555: iconst_1
    //   2556: new schema/core$fn__21921
    //   2559: dup
    //   2560: invokespecial <init> : ()V
    //   2563: aastore
    //   2564: dup
    //   2565: iconst_2
    //   2566: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   2569: aastore
    //   2570: dup
    //   2571: iconst_3
    //   2572: new schema/core$fn__21923
    //   2575: dup
    //   2576: invokespecial <init> : ()V
    //   2579: aastore
    //   2580: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   2583: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   2588: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   2591: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2594: checkcast clojure/lang/IFn
    //   2597: getstatic schema/core__init.const__89 : Lclojure/lang/Var;
    //   2600: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2603: checkcast clojure/lang/IFn
    //   2606: getstatic schema/core__init.const__90 : Lclojure/lang/Var;
    //   2609: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2612: checkcast clojure/lang/IFn
    //   2615: getstatic schema/core__init.const__91 : Lclojure/lang/Var;
    //   2618: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2621: checkcast clojure/lang/IFn
    //   2624: getstatic schema/core__init.const__107 : Lclojure/lang/AFn;
    //   2627: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2632: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2637: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   2642: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   2645: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2648: iconst_4
    //   2649: anewarray java/lang/Object
    //   2652: dup
    //   2653: iconst_0
    //   2654: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   2657: aastore
    //   2658: dup
    //   2659: iconst_1
    //   2660: new schema/core$fn__21925
    //   2663: dup
    //   2664: invokespecial <init> : ()V
    //   2667: aastore
    //   2668: dup
    //   2669: iconst_2
    //   2670: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   2673: aastore
    //   2674: dup
    //   2675: iconst_3
    //   2676: new schema/core$fn__21927
    //   2679: dup
    //   2680: invokespecial <init> : ()V
    //   2683: aastore
    //   2684: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   2687: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   2692: new schema/core$fn__21930
    //   2695: dup
    //   2696: invokespecial <init> : ()V
    //   2699: checkcast clojure/lang/IFn
    //   2702: invokeinterface invoke : ()Ljava/lang/Object;
    //   2707: getstatic schema/core__init.const__108 : Lclojure/lang/Var;
    //   2710: dup
    //   2711: getstatic schema/core__init.const__110 : Lclojure/lang/AFn;
    //   2714: checkcast clojure/lang/IPersistentMap
    //   2717: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2720: dup
    //   2721: new schema/core/AnythingSchema
    //   2724: dup
    //   2725: aconst_null
    //   2726: invokespecial <init> : (Ljava/lang/Object;)V
    //   2729: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2732: new schema/core$fn__21953
    //   2735: dup
    //   2736: invokespecial <init> : ()V
    //   2739: checkcast clojure/lang/IFn
    //   2742: invokeinterface invoke : ()Ljava/lang/Object;
    //   2747: getstatic schema/core__init.const__111 : Lclojure/lang/Var;
    //   2750: dup
    //   2751: getstatic schema/core__init.const__114 : Lclojure/lang/AFn;
    //   2754: checkcast clojure/lang/IPersistentMap
    //   2757: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2760: dup
    //   2761: new schema/core$eq
    //   2764: dup
    //   2765: invokespecial <init> : ()V
    //   2768: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2771: new schema/core$fn__21981
    //   2774: dup
    //   2775: invokespecial <init> : ()V
    //   2778: checkcast clojure/lang/IFn
    //   2781: invokeinterface invoke : ()Ljava/lang/Object;
    //   2786: getstatic schema/core__init.const__115 : Lclojure/lang/Var;
    //   2789: dup
    //   2790: getstatic schema/core__init.const__118 : Lclojure/lang/AFn;
    //   2793: checkcast clojure/lang/IPersistentMap
    //   2796: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2799: dup
    //   2800: new schema/core$isa
    //   2803: dup
    //   2804: invokespecial <init> : ()V
    //   2807: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2810: new schema/core$fn__22012
    //   2813: dup
    //   2814: invokespecial <init> : ()V
    //   2817: checkcast clojure/lang/IFn
    //   2820: invokeinterface invoke : ()Ljava/lang/Object;
    //   2825: getstatic schema/core__init.const__119 : Lclojure/lang/Var;
    //   2828: dup
    //   2829: getstatic schema/core__init.const__122 : Lclojure/lang/AFn;
    //   2832: checkcast clojure/lang/IPersistentMap
    //   2835: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2838: dup
    //   2839: new schema/core$enum
    //   2842: dup
    //   2843: invokespecial <init> : ()V
    //   2846: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2849: new schema/core$fn__22039
    //   2852: dup
    //   2853: invokespecial <init> : ()V
    //   2856: checkcast clojure/lang/IFn
    //   2859: invokeinterface invoke : ()Ljava/lang/Object;
    //   2864: getstatic schema/core__init.const__123 : Lclojure/lang/Var;
    //   2867: dup
    //   2868: getstatic schema/core__init.const__126 : Lclojure/lang/AFn;
    //   2871: checkcast clojure/lang/IPersistentMap
    //   2874: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2877: dup
    //   2878: new schema/core$pred
    //   2881: dup
    //   2882: invokespecial <init> : ()V
    //   2885: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2888: getstatic schema/core__init.const__127 : Lclojure/lang/Var;
    //   2891: dup
    //   2892: getstatic schema/core__init.const__130 : Lclojure/lang/AFn;
    //   2895: checkcast clojure/lang/IPersistentMap
    //   2898: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2901: dup
    //   2902: new schema/core$protocol_name
    //   2905: dup
    //   2906: invokespecial <init> : ()V
    //   2909: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2912: new schema/core$fn__22069
    //   2915: dup
    //   2916: invokespecial <init> : ()V
    //   2919: checkcast clojure/lang/IFn
    //   2922: invokeinterface invoke : ()Ljava/lang/Object;
    //   2927: getstatic schema/core__init.const__131 : Lclojure/lang/Var;
    //   2930: dup
    //   2931: getstatic schema/core__init.const__134 : Lclojure/lang/AFn;
    //   2934: checkcast clojure/lang/IPersistentMap
    //   2937: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   2940: dup
    //   2941: new schema/core$protocol
    //   2944: dup
    //   2945: invokespecial <init> : ()V
    //   2948: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   2951: getstatic schema/core__init.const__131 : Lclojure/lang/Var;
    //   2954: checkcast clojure/lang/Var
    //   2957: invokevirtual setMacro : ()V
    //   2960: aconst_null
    //   2961: getstatic schema/core__init.const__131 : Lclojure/lang/Var;
    //   2964: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   2967: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2970: checkcast clojure/lang/IFn
    //   2973: getstatic schema/core__init.const__135 : Ljava/lang/Object;
    //   2976: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   2979: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   2982: iconst_4
    //   2983: anewarray java/lang/Object
    //   2986: dup
    //   2987: iconst_0
    //   2988: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   2991: aastore
    //   2992: dup
    //   2993: iconst_1
    //   2994: new schema/core$fn__22098
    //   2997: dup
    //   2998: invokespecial <init> : ()V
    //   3001: aastore
    //   3002: dup
    //   3003: iconst_2
    //   3004: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   3007: aastore
    //   3008: dup
    //   3009: iconst_3
    //   3010: new schema/core$fn__22106
    //   3013: dup
    //   3014: invokespecial <init> : ()V
    //   3017: aastore
    //   3018: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   3021: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   3026: getstatic schema/core__init.const__136 : Lclojure/lang/Var;
    //   3029: dup
    //   3030: getstatic schema/core__init.const__138 : Lclojure/lang/AFn;
    //   3033: checkcast clojure/lang/IPersistentMap
    //   3036: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3039: dup
    //   3040: getstatic schema/core__init.const__139 : Ljava/lang/Object;
    //   3043: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3046: getstatic schema/core__init.const__140 : Lclojure/lang/Var;
    //   3049: dup
    //   3050: getstatic schema/core__init.const__142 : Lclojure/lang/AFn;
    //   3053: checkcast clojure/lang/IPersistentMap
    //   3056: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3059: dup
    //   3060: getstatic schema/core__init.const__143 : Ljava/lang/Object;
    //   3063: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3066: getstatic schema/core__init.const__144 : Lclojure/lang/Var;
    //   3069: dup
    //   3070: getstatic schema/core__init.const__146 : Lclojure/lang/AFn;
    //   3073: checkcast clojure/lang/IPersistentMap
    //   3076: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3079: dup
    //   3080: getstatic schema/core__init.const__147 : Ljava/lang/Object;
    //   3083: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3086: getstatic schema/core__init.const__148 : Lclojure/lang/Var;
    //   3089: dup
    //   3090: getstatic schema/core__init.const__150 : Lclojure/lang/AFn;
    //   3093: checkcast clojure/lang/IPersistentMap
    //   3096: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3099: dup
    //   3100: getstatic schema/core__init.const__123 : Lclojure/lang/Var;
    //   3103: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3106: checkcast clojure/lang/IFn
    //   3109: getstatic schema/core__init.const__151 : Lclojure/lang/Var;
    //   3112: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3115: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   3120: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3123: getstatic schema/core__init.const__152 : Lclojure/lang/Var;
    //   3126: dup
    //   3127: getstatic schema/core__init.const__154 : Lclojure/lang/AFn;
    //   3130: checkcast clojure/lang/IPersistentMap
    //   3133: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3136: dup
    //   3137: getstatic schema/core__init.const__123 : Lclojure/lang/Var;
    //   3140: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3143: checkcast clojure/lang/IFn
    //   3146: getstatic schema/core__init.const__155 : Lclojure/lang/Var;
    //   3149: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3152: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   3157: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3160: getstatic schema/core__init.const__156 : Lclojure/lang/Var;
    //   3163: dup
    //   3164: getstatic schema/core__init.const__158 : Lclojure/lang/AFn;
    //   3167: checkcast clojure/lang/IPersistentMap
    //   3170: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3173: dup
    //   3174: getstatic schema/core__init.const__123 : Lclojure/lang/Var;
    //   3177: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3180: checkcast clojure/lang/IFn
    //   3183: getstatic schema/core__init.const__159 : Lclojure/lang/Var;
    //   3186: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3189: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   3194: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3197: getstatic schema/core__init.const__160 : Lclojure/lang/Var;
    //   3200: dup
    //   3201: getstatic schema/core__init.const__162 : Lclojure/lang/AFn;
    //   3204: checkcast clojure/lang/IPersistentMap
    //   3207: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3210: dup
    //   3211: getstatic schema/core__init.const__135 : Ljava/lang/Object;
    //   3214: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3217: getstatic schema/core__init.const__163 : Lclojure/lang/Var;
    //   3220: dup
    //   3221: getstatic schema/core__init.const__165 : Lclojure/lang/AFn;
    //   3224: checkcast clojure/lang/IPersistentMap
    //   3227: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3230: dup
    //   3231: getstatic schema/core__init.const__166 : Ljava/lang/Object;
    //   3234: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3237: getstatic schema/core__init.const__167 : Lclojure/lang/Var;
    //   3240: dup
    //   3241: getstatic schema/core__init.const__169 : Lclojure/lang/AFn;
    //   3244: checkcast clojure/lang/IPersistentMap
    //   3247: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3250: dup
    //   3251: getstatic schema/core__init.const__170 : Ljava/lang/Object;
    //   3254: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3257: new schema/core$fn__22109
    //   3260: dup
    //   3261: invokespecial <init> : ()V
    //   3264: checkcast clojure/lang/IFn
    //   3267: invokeinterface invoke : ()Ljava/lang/Object;
    //   3272: getstatic schema/core__init.const__171 : Lclojure/lang/Var;
    //   3275: dup
    //   3276: getstatic schema/core__init.const__174 : Lclojure/lang/AFn;
    //   3279: checkcast clojure/lang/IPersistentMap
    //   3282: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3285: dup
    //   3286: new schema/core$maybe
    //   3289: dup
    //   3290: invokespecial <init> : ()V
    //   3293: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3296: new schema/core$fn__22132
    //   3299: dup
    //   3300: invokespecial <init> : ()V
    //   3303: checkcast clojure/lang/IFn
    //   3306: invokeinterface invoke : ()Ljava/lang/Object;
    //   3311: getstatic schema/core__init.const__175 : Lclojure/lang/Var;
    //   3314: dup
    //   3315: getstatic schema/core__init.const__178 : Lclojure/lang/AFn;
    //   3318: checkcast clojure/lang/IPersistentMap
    //   3321: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3324: dup
    //   3325: new schema/core$named
    //   3328: dup
    //   3329: invokespecial <init> : ()V
    //   3332: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3335: new schema/core$fn__22160
    //   3338: dup
    //   3339: invokespecial <init> : ()V
    //   3342: checkcast clojure/lang/IFn
    //   3345: invokeinterface invoke : ()Ljava/lang/Object;
    //   3350: getstatic schema/core__init.const__179 : Lclojure/lang/Var;
    //   3353: dup
    //   3354: getstatic schema/core__init.const__183 : Lclojure/lang/AFn;
    //   3357: checkcast clojure/lang/IPersistentMap
    //   3360: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3363: dup
    //   3364: new schema/core$either
    //   3367: dup
    //   3368: invokespecial <init> : ()V
    //   3371: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3374: new schema/core$fn__22199
    //   3377: dup
    //   3378: invokespecial <init> : ()V
    //   3381: checkcast clojure/lang/IFn
    //   3384: invokeinterface invoke : ()Ljava/lang/Object;
    //   3389: getstatic schema/core__init.const__184 : Lclojure/lang/Var;
    //   3392: dup
    //   3393: getstatic schema/core__init.const__187 : Lclojure/lang/AFn;
    //   3396: checkcast clojure/lang/IPersistentMap
    //   3399: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3402: dup
    //   3403: new schema/core$conditional
    //   3406: dup
    //   3407: invokespecial <init> : ()V
    //   3410: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3413: new schema/core$fn__22276
    //   3416: dup
    //   3417: invokespecial <init> : ()V
    //   3420: checkcast clojure/lang/IFn
    //   3423: invokeinterface invoke : ()Ljava/lang/Object;
    //   3428: getstatic schema/core__init.const__188 : Ljava/lang/Object;
    //   3431: getstatic schema/core__init.const__13 : Lclojure/lang/Var;
    //   3434: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3437: checkcast clojure/lang/IFn
    //   3440: getstatic schema/core__init.const__189 : Lclojure/lang/Var;
    //   3443: getstatic schema/core__init.const__15 : Lclojure/lang/Var;
    //   3446: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3449: getstatic schema/core__init.const__2 : Lclojure/lang/Keyword;
    //   3452: aconst_null
    //   3453: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   3458: getstatic schema/core__init.const__16 : Lclojure/lang/Var;
    //   3461: checkcast clojure/lang/IFn
    //   3464: getstatic schema/core__init.const__189 : Lclojure/lang/Var;
    //   3467: getstatic schema/core__init.const__190 : Lclojure/lang/ISeq;
    //   3470: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   3475: getstatic schema/core__init.const__18 : Lclojure/lang/Var;
    //   3478: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3481: checkcast clojure/lang/IFn
    //   3484: getstatic schema/core__init.const__189 : Lclojure/lang/Var;
    //   3487: getstatic schema/core__init.const__19 : Lclojure/lang/Var;
    //   3490: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3493: getstatic schema/core__init.const__15 : Lclojure/lang/Var;
    //   3496: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3499: checkcast clojure/lang/IFn
    //   3502: getstatic schema/core__init.const__192 : Lclojure/lang/AFn;
    //   3505: getstatic schema/core__init.const__24 : Lclojure/lang/Keyword;
    //   3508: getstatic schema/core__init.const__193 : Lclojure/lang/AFn;
    //   3511: getstatic schema/core__init.const__26 : Lclojure/lang/Keyword;
    //   3514: getstatic schema/core__init.const__189 : Lclojure/lang/Var;
    //   3517: getstatic schema/core__init.const__27 : Lclojure/lang/Keyword;
    //   3520: getstatic schema/core__init.const__195 : Lclojure/lang/AFn;
    //   3523: getstatic schema/core__init.const__30 : Lclojure/lang/Keyword;
    //   3526: iconst_2
    //   3527: anewarray java/lang/Object
    //   3530: dup
    //   3531: iconst_0
    //   3532: getstatic schema/core__init.const__31 : Lclojure/lang/Var;
    //   3535: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3538: checkcast clojure/lang/IFn
    //   3541: getstatic schema/core__init.const__32 : Lclojure/lang/Var;
    //   3544: invokevirtual get : ()Ljava/lang/Object;
    //   3547: getstatic schema/core__init.const__33 : Lclojure/lang/Var;
    //   3550: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3553: checkcast clojure/lang/IFn
    //   3556: getstatic schema/core__init.const__196 : Lclojure/lang/AFn;
    //   3559: getstatic schema/core__init.const__19 : Lclojure/lang/Var;
    //   3562: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3565: checkcast clojure/lang/IFn
    //   3568: getstatic schema/core__init.const__197 : Lclojure/lang/AFn;
    //   3571: iconst_2
    //   3572: anewarray java/lang/Object
    //   3575: dup
    //   3576: iconst_0
    //   3577: getstatic schema/core__init.const__36 : Lclojure/lang/Keyword;
    //   3580: aastore
    //   3581: dup
    //   3582: iconst_1
    //   3583: getstatic schema/core__init.const__189 : Lclojure/lang/Var;
    //   3586: aastore
    //   3587: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   3590: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   3595: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   3600: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   3605: aastore
    //   3606: dup
    //   3607: iconst_1
    //   3608: new schema/core$fn__22279
    //   3611: dup
    //   3612: invokespecial <init> : ()V
    //   3615: aastore
    //   3616: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   3619: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   3624: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   3629: getstatic schema/core__init.const__37 : Lclojure/lang/Var;
    //   3632: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3635: checkcast clojure/lang/IFn
    //   3638: getstatic schema/core__init.const__189 : Lclojure/lang/Var;
    //   3641: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3644: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   3649: getstatic schema/core__init.const__198 : Lclojure/lang/AFn;
    //   3652: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   3655: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3658: checkcast clojure/lang/IFn
    //   3661: getstatic schema/core__init.const__199 : Ljava/lang/Object;
    //   3664: getstatic schema/core__init.const__189 : Lclojure/lang/Var;
    //   3667: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3670: iconst_2
    //   3671: anewarray java/lang/Object
    //   3674: dup
    //   3675: iconst_0
    //   3676: getstatic schema/core__init.const__194 : Lclojure/lang/Keyword;
    //   3679: aastore
    //   3680: dup
    //   3681: iconst_1
    //   3682: new schema/core$fn__22290
    //   3685: dup
    //   3686: invokespecial <init> : ()V
    //   3689: aastore
    //   3690: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   3693: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   3698: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   3701: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3704: checkcast clojure/lang/IFn
    //   3707: getstatic schema/core__init.const__200 : Ljava/lang/Object;
    //   3710: getstatic schema/core__init.const__189 : Lclojure/lang/Var;
    //   3713: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3716: iconst_2
    //   3717: anewarray java/lang/Object
    //   3720: dup
    //   3721: iconst_0
    //   3722: getstatic schema/core__init.const__194 : Lclojure/lang/Keyword;
    //   3725: aastore
    //   3726: dup
    //   3727: iconst_1
    //   3728: new schema/core$fn__22292
    //   3731: dup
    //   3732: invokespecial <init> : ()V
    //   3735: aastore
    //   3736: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   3739: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   3744: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   3747: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3750: checkcast clojure/lang/IFn
    //   3753: getstatic schema/core__init.const__201 : Ljava/lang/Object;
    //   3756: getstatic schema/core__init.const__189 : Lclojure/lang/Var;
    //   3759: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   3762: iconst_2
    //   3763: anewarray java/lang/Object
    //   3766: dup
    //   3767: iconst_0
    //   3768: getstatic schema/core__init.const__194 : Lclojure/lang/Keyword;
    //   3771: aastore
    //   3772: dup
    //   3773: iconst_1
    //   3774: new schema/core$fn__22310
    //   3777: dup
    //   3778: invokespecial <init> : ()V
    //   3781: aastore
    //   3782: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   3785: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   3790: new schema/core$fn__22314
    //   3793: dup
    //   3794: invokespecial <init> : ()V
    //   3797: checkcast clojure/lang/IFn
    //   3800: invokeinterface invoke : ()Ljava/lang/Object;
    //   3805: getstatic schema/core__init.const__202 : Lclojure/lang/Var;
    //   3808: dup
    //   3809: getstatic schema/core__init.const__205 : Lclojure/lang/AFn;
    //   3812: checkcast clojure/lang/IPersistentMap
    //   3815: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3818: dup
    //   3819: new schema/core$cond_pre
    //   3822: dup
    //   3823: invokespecial <init> : ()V
    //   3826: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3829: new schema/core$fn__22353
    //   3832: dup
    //   3833: invokespecial <init> : ()V
    //   3836: checkcast clojure/lang/IFn
    //   3839: invokeinterface invoke : ()Ljava/lang/Object;
    //   3844: getstatic schema/core__init.const__206 : Lclojure/lang/Var;
    //   3847: dup
    //   3848: getstatic schema/core__init.const__209 : Lclojure/lang/AFn;
    //   3851: checkcast clojure/lang/IPersistentMap
    //   3854: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3857: dup
    //   3858: new schema/core$constrained
    //   3861: dup
    //   3862: invokespecial <init> : ()V
    //   3865: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3868: new schema/core$fn__22384
    //   3871: dup
    //   3872: invokespecial <init> : ()V
    //   3875: checkcast clojure/lang/IFn
    //   3878: invokeinterface invoke : ()Ljava/lang/Object;
    //   3883: getstatic schema/core__init.const__210 : Lclojure/lang/Var;
    //   3886: dup
    //   3887: getstatic schema/core__init.const__213 : Lclojure/lang/AFn;
    //   3890: checkcast clojure/lang/IPersistentMap
    //   3893: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3896: dup
    //   3897: new schema/core$both
    //   3900: dup
    //   3901: invokespecial <init> : ()V
    //   3904: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3907: getstatic schema/core__init.const__214 : Lclojure/lang/Var;
    //   3910: dup
    //   3911: getstatic schema/core__init.const__217 : Lclojure/lang/AFn;
    //   3914: checkcast clojure/lang/IPersistentMap
    //   3917: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3920: dup
    //   3921: new schema/core$if
    //   3924: dup
    //   3925: invokespecial <init> : ()V
    //   3928: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3931: getstatic schema/core__init.const__218 : Lclojure/lang/Var;
    //   3934: dup
    //   3935: getstatic schema/core__init.const__221 : Lclojure/lang/AFn;
    //   3938: checkcast clojure/lang/IPersistentMap
    //   3941: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3944: dup
    //   3945: new schema/core$var_name
    //   3948: dup
    //   3949: invokespecial <init> : ()V
    //   3952: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3955: new schema/core$fn__22416
    //   3958: dup
    //   3959: invokespecial <init> : ()V
    //   3962: checkcast clojure/lang/IFn
    //   3965: invokeinterface invoke : ()Ljava/lang/Object;
    //   3970: getstatic schema/core__init.const__222 : Lclojure/lang/Var;
    //   3973: dup
    //   3974: getstatic schema/core__init.const__225 : Lclojure/lang/AFn;
    //   3977: checkcast clojure/lang/IPersistentMap
    //   3980: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   3983: dup
    //   3984: new schema/core$recursive
    //   3987: dup
    //   3988: invokespecial <init> : ()V
    //   3991: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   3994: getstatic schema/core__init.const__226 : Lclojure/lang/Var;
    //   3997: dup
    //   3998: getstatic schema/core__init.const__230 : Lclojure/lang/AFn;
    //   4001: checkcast clojure/lang/IPersistentMap
    //   4004: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4007: dup
    //   4008: new schema/core$atom_QMARK_
    //   4011: dup
    //   4012: invokespecial <init> : ()V
    //   4015: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4018: new schema/core$fn__22439
    //   4021: dup
    //   4022: invokespecial <init> : ()V
    //   4025: checkcast clojure/lang/IFn
    //   4028: invokeinterface invoke : ()Ljava/lang/Object;
    //   4033: getstatic schema/core__init.const__231 : Lclojure/lang/Var;
    //   4036: dup
    //   4037: getstatic schema/core__init.const__234 : Lclojure/lang/AFn;
    //   4040: checkcast clojure/lang/IPersistentMap
    //   4043: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4046: dup
    //   4047: new schema/core$atom
    //   4050: dup
    //   4051: invokespecial <init> : ()V
    //   4054: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4057: new schema/core$fn__22467
    //   4060: dup
    //   4061: invokespecial <init> : ()V
    //   4064: checkcast clojure/lang/IFn
    //   4067: invokeinterface invoke : ()Ljava/lang/Object;
    //   4072: getstatic schema/core__init.const__235 : Lclojure/lang/Var;
    //   4075: dup
    //   4076: getstatic schema/core__init.const__238 : Lclojure/lang/AFn;
    //   4079: checkcast clojure/lang/IPersistentMap
    //   4082: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4085: dup
    //   4086: new schema/core$required_key
    //   4089: dup
    //   4090: invokespecial <init> : ()V
    //   4093: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4096: getstatic schema/core__init.const__239 : Lclojure/lang/Var;
    //   4099: dup
    //   4100: getstatic schema/core__init.const__242 : Lclojure/lang/AFn;
    //   4103: checkcast clojure/lang/IPersistentMap
    //   4106: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4109: dup
    //   4110: new schema/core$required_key_QMARK_
    //   4113: dup
    //   4114: invokespecial <init> : ()V
    //   4117: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4120: new schema/core$fn__22491
    //   4123: dup
    //   4124: invokespecial <init> : ()V
    //   4127: checkcast clojure/lang/IFn
    //   4130: invokeinterface invoke : ()Ljava/lang/Object;
    //   4135: getstatic schema/core__init.const__243 : Lclojure/lang/Var;
    //   4138: dup
    //   4139: getstatic schema/core__init.const__246 : Lclojure/lang/AFn;
    //   4142: checkcast clojure/lang/IPersistentMap
    //   4145: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4148: dup
    //   4149: new schema/core$optional_key
    //   4152: dup
    //   4153: invokespecial <init> : ()V
    //   4156: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4159: getstatic schema/core__init.const__247 : Lclojure/lang/Var;
    //   4162: dup
    //   4163: getstatic schema/core__init.const__250 : Lclojure/lang/AFn;
    //   4166: checkcast clojure/lang/IPersistentMap
    //   4169: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4172: dup
    //   4173: new schema/core$optional_key_QMARK_
    //   4176: dup
    //   4177: invokespecial <init> : ()V
    //   4180: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4183: getstatic schema/core__init.const__251 : Lclojure/lang/Var;
    //   4186: dup
    //   4187: getstatic schema/core__init.const__254 : Lclojure/lang/AFn;
    //   4190: checkcast clojure/lang/IPersistentMap
    //   4193: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4196: dup
    //   4197: new schema/core$explicit_schema_key
    //   4200: dup
    //   4201: invokespecial <init> : ()V
    //   4204: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4207: getstatic schema/core__init.const__255 : Lclojure/lang/Var;
    //   4210: dup
    //   4211: getstatic schema/core__init.const__258 : Lclojure/lang/AFn;
    //   4214: checkcast clojure/lang/IPersistentMap
    //   4217: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4220: dup
    //   4221: new schema/core$specific_key_QMARK_
    //   4224: dup
    //   4225: invokespecial <init> : ()V
    //   4228: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4231: getstatic schema/core__init.const__259 : Lclojure/lang/Var;
    //   4234: dup
    //   4235: getstatic schema/core__init.const__262 : Lclojure/lang/AFn;
    //   4238: checkcast clojure/lang/IPersistentMap
    //   4241: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4244: dup
    //   4245: new schema/core$map_entry_ctor
    //   4248: dup
    //   4249: invokespecial <init> : ()V
    //   4252: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4255: new schema/core$fn__22522
    //   4258: dup
    //   4259: invokespecial <init> : ()V
    //   4262: checkcast clojure/lang/IFn
    //   4265: invokeinterface invoke : ()Ljava/lang/Object;
    //   4270: getstatic schema/core__init.const__263 : Lclojure/lang/Var;
    //   4273: dup
    //   4274: getstatic schema/core__init.const__266 : Lclojure/lang/AFn;
    //   4277: checkcast clojure/lang/IPersistentMap
    //   4280: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4283: dup
    //   4284: new schema/core$map_entry
    //   4287: dup
    //   4288: invokespecial <init> : ()V
    //   4291: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4294: getstatic schema/core__init.const__267 : Lclojure/lang/Var;
    //   4297: dup
    //   4298: getstatic schema/core__init.const__270 : Lclojure/lang/AFn;
    //   4301: checkcast clojure/lang/IPersistentMap
    //   4304: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4307: dup
    //   4308: new schema/core$find_extra_keys_schema
    //   4311: dup
    //   4312: invokespecial <init> : ()V
    //   4315: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4318: getstatic schema/core__init.const__271 : Lclojure/lang/Var;
    //   4321: dup
    //   4322: getstatic schema/core__init.const__274 : Lclojure/lang/AFn;
    //   4325: checkcast clojure/lang/IPersistentMap
    //   4328: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4331: dup
    //   4332: new schema/core$explain_kspec
    //   4335: dup
    //   4336: invokespecial <init> : ()V
    //   4339: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4342: getstatic schema/core__init.const__275 : Lclojure/lang/Var;
    //   4345: dup
    //   4346: getstatic schema/core__init.const__278 : Lclojure/lang/AFn;
    //   4349: checkcast clojure/lang/IPersistentMap
    //   4352: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4355: dup
    //   4356: new schema/core$map_elements
    //   4359: dup
    //   4360: invokespecial <init> : ()V
    //   4363: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4366: getstatic schema/core__init.const__279 : Lclojure/lang/Var;
    //   4369: dup
    //   4370: getstatic schema/core__init.const__282 : Lclojure/lang/AFn;
    //   4373: checkcast clojure/lang/IPersistentMap
    //   4376: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4379: dup
    //   4380: new schema/core$map_error
    //   4383: dup
    //   4384: invokespecial <init> : ()V
    //   4387: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4390: getstatic schema/core__init.const__283 : Lclojure/lang/Var;
    //   4393: dup
    //   4394: getstatic schema/core__init.const__286 : Lclojure/lang/AFn;
    //   4397: checkcast clojure/lang/IPersistentMap
    //   4400: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4403: dup
    //   4404: new schema/core$map_spec
    //   4407: dup
    //   4408: invokespecial <init> : ()V
    //   4411: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4414: getstatic schema/core__init.const__287 : Lclojure/lang/Var;
    //   4417: dup
    //   4418: getstatic schema/core__init.const__290 : Lclojure/lang/AFn;
    //   4421: checkcast clojure/lang/IPersistentMap
    //   4424: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4427: dup
    //   4428: new schema/core$map_explain
    //   4431: dup
    //   4432: invokespecial <init> : ()V
    //   4435: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4438: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   4441: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   4444: checkcast clojure/lang/IFn
    //   4447: getstatic schema/core__init.const__291 : Ljava/lang/Object;
    //   4450: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   4453: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   4456: iconst_4
    //   4457: anewarray java/lang/Object
    //   4460: dup
    //   4461: iconst_0
    //   4462: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   4465: aastore
    //   4466: dup
    //   4467: iconst_1
    //   4468: new schema/core$fn__22647
    //   4471: dup
    //   4472: invokespecial <init> : ()V
    //   4475: aastore
    //   4476: dup
    //   4477: iconst_2
    //   4478: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   4481: aastore
    //   4482: dup
    //   4483: iconst_3
    //   4484: new schema/core$fn__22649
    //   4487: dup
    //   4488: invokespecial <init> : ()V
    //   4491: aastore
    //   4492: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   4495: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   4500: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   4503: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   4506: checkcast clojure/lang/IFn
    //   4509: getstatic schema/core__init.const__292 : Ljava/lang/Object;
    //   4512: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   4515: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   4518: iconst_4
    //   4519: anewarray java/lang/Object
    //   4522: dup
    //   4523: iconst_0
    //   4524: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   4527: aastore
    //   4528: dup
    //   4529: iconst_1
    //   4530: new schema/core$fn__22651
    //   4533: dup
    //   4534: invokespecial <init> : ()V
    //   4537: aastore
    //   4538: dup
    //   4539: iconst_2
    //   4540: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   4543: aastore
    //   4544: dup
    //   4545: iconst_3
    //   4546: new schema/core$fn__22657
    //   4549: dup
    //   4550: invokespecial <init> : ()V
    //   4553: aastore
    //   4554: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   4557: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   4562: getstatic schema/core__init.const__293 : Lclojure/lang/Var;
    //   4565: dup
    //   4566: getstatic schema/core__init.const__296 : Lclojure/lang/AFn;
    //   4569: checkcast clojure/lang/IPersistentMap
    //   4572: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4575: dup
    //   4576: new schema/core$queue_QMARK_
    //   4579: dup
    //   4580: invokespecial <init> : ()V
    //   4583: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4586: getstatic schema/core__init.const__297 : Lclojure/lang/Var;
    //   4589: dup
    //   4590: getstatic schema/core__init.const__300 : Lclojure/lang/AFn;
    //   4593: checkcast clojure/lang/IPersistentMap
    //   4596: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4599: dup
    //   4600: new schema/core$as_queue
    //   4603: dup
    //   4604: invokespecial <init> : ()V
    //   4607: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4610: new schema/core$fn__22662
    //   4613: dup
    //   4614: invokespecial <init> : ()V
    //   4617: checkcast clojure/lang/IFn
    //   4620: invokeinterface invoke : ()Ljava/lang/Object;
    //   4625: getstatic schema/core__init.const__301 : Lclojure/lang/Var;
    //   4628: dup
    //   4629: getstatic schema/core__init.const__304 : Lclojure/lang/AFn;
    //   4632: checkcast clojure/lang/IPersistentMap
    //   4635: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4638: dup
    //   4639: new schema/core$queue
    //   4642: dup
    //   4643: invokespecial <init> : ()V
    //   4646: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4649: new schema/core$fn__22688
    //   4652: dup
    //   4653: invokespecial <init> : ()V
    //   4656: checkcast clojure/lang/IFn
    //   4659: invokeinterface invoke : ()Ljava/lang/Object;
    //   4664: getstatic schema/core__init.const__305 : Lclojure/lang/Var;
    //   4667: dup
    //   4668: getstatic schema/core__init.const__308 : Lclojure/lang/AFn;
    //   4671: checkcast clojure/lang/IPersistentMap
    //   4674: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4677: dup
    //   4678: new schema/core$one
    //   4681: dup
    //   4682: invokespecial <init> : ()V
    //   4685: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4688: getstatic schema/core__init.const__309 : Lclojure/lang/Var;
    //   4691: dup
    //   4692: getstatic schema/core__init.const__312 : Lclojure/lang/AFn;
    //   4695: checkcast clojure/lang/IPersistentMap
    //   4698: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4701: dup
    //   4702: new schema/core$optional
    //   4705: dup
    //   4706: invokespecial <init> : ()V
    //   4709: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4712: getstatic schema/core__init.const__313 : Lclojure/lang/Var;
    //   4715: dup
    //   4716: getstatic schema/core__init.const__316 : Lclojure/lang/AFn;
    //   4719: checkcast clojure/lang/IPersistentMap
    //   4722: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4725: dup
    //   4726: new schema/core$parse_sequence_schema
    //   4729: dup
    //   4730: invokespecial <init> : ()V
    //   4733: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4736: getstatic schema/core__init.const__39 : Lclojure/lang/Var;
    //   4739: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   4742: checkcast clojure/lang/IFn
    //   4745: getstatic schema/core__init.const__317 : Ljava/lang/Object;
    //   4748: getstatic schema/core__init.const__46 : Lclojure/lang/Var;
    //   4751: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   4754: iconst_4
    //   4755: anewarray java/lang/Object
    //   4758: dup
    //   4759: iconst_0
    //   4760: getstatic schema/core__init.const__52 : Lclojure/lang/Keyword;
    //   4763: aastore
    //   4764: dup
    //   4765: iconst_1
    //   4766: new schema/core$fn__22736
    //   4769: dup
    //   4770: invokespecial <init> : ()V
    //   4773: aastore
    //   4774: dup
    //   4775: iconst_2
    //   4776: getstatic schema/core__init.const__51 : Lclojure/lang/Keyword;
    //   4779: aastore
    //   4780: dup
    //   4781: iconst_3
    //   4782: new schema/core$fn__22761
    //   4785: dup
    //   4786: invokespecial <init> : ()V
    //   4789: aastore
    //   4790: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   4793: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   4798: getstatic schema/core__init.const__318 : Lclojure/lang/Var;
    //   4801: dup
    //   4802: getstatic schema/core__init.const__321 : Lclojure/lang/AFn;
    //   4805: checkcast clojure/lang/IPersistentMap
    //   4808: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4811: dup
    //   4812: new schema/core$pair
    //   4815: dup
    //   4816: invokespecial <init> : ()V
    //   4819: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4822: new schema/core$fn__22785
    //   4825: dup
    //   4826: invokespecial <init> : ()V
    //   4829: checkcast clojure/lang/IFn
    //   4832: invokeinterface invoke : ()Ljava/lang/Object;
    //   4837: getstatic schema/core__init.const__322 : Lclojure/lang/Var;
    //   4840: dup
    //   4841: getstatic schema/core__init.const__325 : Lclojure/lang/AFn;
    //   4844: checkcast clojure/lang/IPersistentMap
    //   4847: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4850: dup
    //   4851: new schema/core$record_STAR_
    //   4854: dup
    //   4855: invokespecial <init> : ()V
    //   4858: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4861: getstatic schema/core__init.const__326 : Lclojure/lang/Var;
    //   4864: dup
    //   4865: getstatic schema/core__init.const__329 : Lclojure/lang/AFn;
    //   4868: checkcast clojure/lang/IPersistentMap
    //   4871: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4874: dup
    //   4875: new schema/core$record
    //   4878: dup
    //   4879: invokespecial <init> : ()V
    //   4882: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4885: getstatic schema/core__init.const__326 : Lclojure/lang/Var;
    //   4888: checkcast clojure/lang/Var
    //   4891: invokevirtual setMacro : ()V
    //   4894: aconst_null
    //   4895: getstatic schema/core__init.const__326 : Lclojure/lang/Var;
    //   4898: getstatic schema/core__init.const__330 : Lclojure/lang/Var;
    //   4901: dup
    //   4902: getstatic schema/core__init.const__333 : Lclojure/lang/AFn;
    //   4905: checkcast clojure/lang/IPersistentMap
    //   4908: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4911: dup
    //   4912: new schema/core$explain_input_schema
    //   4915: dup
    //   4916: invokespecial <init> : ()V
    //   4919: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4922: new schema/core$fn__22832
    //   4925: dup
    //   4926: invokespecial <init> : ()V
    //   4929: checkcast clojure/lang/IFn
    //   4932: invokeinterface invoke : ()Ljava/lang/Object;
    //   4937: getstatic schema/core__init.const__334 : Lclojure/lang/Var;
    //   4940: dup
    //   4941: getstatic schema/core__init.const__337 : Lclojure/lang/AFn;
    //   4944: checkcast clojure/lang/IPersistentMap
    //   4947: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4950: dup
    //   4951: new schema/core$arity
    //   4954: dup
    //   4955: invokespecial <init> : ()V
    //   4958: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4961: getstatic schema/core__init.const__338 : Lclojure/lang/Var;
    //   4964: dup
    //   4965: getstatic schema/core__init.const__341 : Lclojure/lang/AFn;
    //   4968: checkcast clojure/lang/IPersistentMap
    //   4971: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4974: dup
    //   4975: new schema/core$make_fn_schema
    //   4978: dup
    //   4979: invokespecial <init> : ()V
    //   4982: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   4985: getstatic schema/core__init.const__342 : Lclojure/lang/Var;
    //   4988: dup
    //   4989: getstatic schema/core__init.const__345 : Lclojure/lang/AFn;
    //   4992: checkcast clojure/lang/IPersistentMap
    //   4995: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   4998: dup
    //   4999: new schema/core$_EQ__GT__STAR_
    //   5002: dup
    //   5003: invokespecial <init> : ()V
    //   5006: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5009: getstatic schema/core__init.const__342 : Lclojure/lang/Var;
    //   5012: checkcast clojure/lang/Var
    //   5015: invokevirtual setMacro : ()V
    //   5018: aconst_null
    //   5019: getstatic schema/core__init.const__342 : Lclojure/lang/Var;
    //   5022: getstatic schema/core__init.const__346 : Lclojure/lang/Var;
    //   5025: dup
    //   5026: getstatic schema/core__init.const__349 : Lclojure/lang/AFn;
    //   5029: checkcast clojure/lang/IPersistentMap
    //   5032: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5035: dup
    //   5036: new schema/core$_EQ__GT_
    //   5039: dup
    //   5040: invokespecial <init> : ()V
    //   5043: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5046: getstatic schema/core__init.const__346 : Lclojure/lang/Var;
    //   5049: checkcast clojure/lang/Var
    //   5052: invokevirtual setMacro : ()V
    //   5055: aconst_null
    //   5056: getstatic schema/core__init.const__346 : Lclojure/lang/Var;
    //   5059: getstatic schema/core__init.const__350 : Lclojure/lang/Var;
    //   5062: dup
    //   5063: getstatic schema/core__init.const__353 : Lclojure/lang/AFn;
    //   5066: checkcast clojure/lang/IPersistentMap
    //   5069: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5072: dup
    //   5073: new schema/core$schema_with_name
    //   5076: dup
    //   5077: invokespecial <init> : ()V
    //   5080: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5083: getstatic schema/core__init.const__354 : Lclojure/lang/Var;
    //   5086: dup
    //   5087: getstatic schema/core__init.const__357 : Lclojure/lang/AFn;
    //   5090: checkcast clojure/lang/IPersistentMap
    //   5093: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5096: dup
    //   5097: new schema/core$schema_name
    //   5100: dup
    //   5101: invokespecial <init> : ()V
    //   5104: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5107: getstatic schema/core__init.const__358 : Lclojure/lang/Var;
    //   5110: dup
    //   5111: getstatic schema/core__init.const__361 : Lclojure/lang/AFn;
    //   5114: checkcast clojure/lang/IPersistentMap
    //   5117: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5120: dup
    //   5121: new schema/core$schema_ns
    //   5124: dup
    //   5125: invokespecial <init> : ()V
    //   5128: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5131: getstatic schema/core__init.const__362 : Lclojure/lang/Var;
    //   5134: dup
    //   5135: getstatic schema/core__init.const__365 : Lclojure/lang/AFn;
    //   5138: checkcast clojure/lang/IPersistentMap
    //   5141: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5144: dup
    //   5145: new schema/core$defschema
    //   5148: dup
    //   5149: invokespecial <init> : ()V
    //   5152: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5155: getstatic schema/core__init.const__362 : Lclojure/lang/Var;
    //   5158: checkcast clojure/lang/Var
    //   5161: invokevirtual setMacro : ()V
    //   5164: aconst_null
    //   5165: getstatic schema/core__init.const__362 : Lclojure/lang/Var;
    //   5168: getstatic schema/core__init.const__366 : Lclojure/lang/Var;
    //   5171: dup
    //   5172: getstatic schema/core__init.const__369 : Lclojure/lang/AFn;
    //   5175: checkcast clojure/lang/IPersistentMap
    //   5178: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5181: dup
    //   5182: new schema/core$defrecord
    //   5185: dup
    //   5186: invokespecial <init> : ()V
    //   5189: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5192: getstatic schema/core__init.const__366 : Lclojure/lang/Var;
    //   5195: checkcast clojure/lang/Var
    //   5198: invokevirtual setMacro : ()V
    //   5201: aconst_null
    //   5202: getstatic schema/core__init.const__366 : Lclojure/lang/Var;
    //   5205: getstatic schema/core__init.const__370 : Lclojure/lang/Var;
    //   5208: dup
    //   5209: getstatic schema/core__init.const__373 : Lclojure/lang/AFn;
    //   5212: checkcast clojure/lang/IPersistentMap
    //   5215: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5218: dup
    //   5219: new schema/core$defrecord_PLUS_
    //   5222: dup
    //   5223: invokespecial <init> : ()V
    //   5226: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5229: getstatic schema/core__init.const__370 : Lclojure/lang/Var;
    //   5232: checkcast clojure/lang/Var
    //   5235: invokevirtual setMacro : ()V
    //   5238: aconst_null
    //   5239: getstatic schema/core__init.const__370 : Lclojure/lang/Var;
    //   5242: getstatic schema/core__init.const__374 : Lclojure/lang/Var;
    //   5245: dup
    //   5246: getstatic schema/core__init.const__377 : Lclojure/lang/AFn;
    //   5249: checkcast clojure/lang/IPersistentMap
    //   5252: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5255: dup
    //   5256: new schema/core$set_compile_fn_validation_BANG_
    //   5259: dup
    //   5260: invokespecial <init> : ()V
    //   5263: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5266: getstatic schema/core__init.const__374 : Lclojure/lang/Var;
    //   5269: checkcast clojure/lang/Var
    //   5272: invokevirtual setMacro : ()V
    //   5275: aconst_null
    //   5276: getstatic schema/core__init.const__374 : Lclojure/lang/Var;
    //   5279: getstatic schema/core__init.const__378 : Lclojure/lang/Var;
    //   5282: dup
    //   5283: getstatic schema/core__init.const__381 : Lclojure/lang/AFn;
    //   5286: checkcast clojure/lang/IPersistentMap
    //   5289: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5292: dup
    //   5293: new schema/core$fn_validation_QMARK_
    //   5296: dup
    //   5297: invokespecial <init> : ()V
    //   5300: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5303: getstatic schema/core__init.const__382 : Lclojure/lang/Var;
    //   5306: dup
    //   5307: getstatic schema/core__init.const__385 : Lclojure/lang/AFn;
    //   5310: checkcast clojure/lang/IPersistentMap
    //   5313: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5316: dup
    //   5317: new schema/core$set_fn_validation_BANG_
    //   5320: dup
    //   5321: invokespecial <init> : ()V
    //   5324: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5327: getstatic schema/core__init.const__386 : Lclojure/lang/Var;
    //   5330: dup
    //   5331: getstatic schema/core__init.const__389 : Lclojure/lang/AFn;
    //   5334: checkcast clojure/lang/IPersistentMap
    //   5337: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5340: dup
    //   5341: new schema/core$with_fn_validation
    //   5344: dup
    //   5345: invokespecial <init> : ()V
    //   5348: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5351: getstatic schema/core__init.const__386 : Lclojure/lang/Var;
    //   5354: checkcast clojure/lang/Var
    //   5357: invokevirtual setMacro : ()V
    //   5360: aconst_null
    //   5361: getstatic schema/core__init.const__386 : Lclojure/lang/Var;
    //   5364: getstatic schema/core__init.const__390 : Lclojure/lang/Var;
    //   5367: dup
    //   5368: getstatic schema/core__init.const__393 : Lclojure/lang/AFn;
    //   5371: checkcast clojure/lang/IPersistentMap
    //   5374: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5377: dup
    //   5378: new schema/core$without_fn_validation
    //   5381: dup
    //   5382: invokespecial <init> : ()V
    //   5385: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5388: getstatic schema/core__init.const__390 : Lclojure/lang/Var;
    //   5391: checkcast clojure/lang/Var
    //   5394: invokevirtual setMacro : ()V
    //   5397: aconst_null
    //   5398: getstatic schema/core__init.const__390 : Lclojure/lang/Var;
    //   5401: getstatic schema/core__init.const__394 : Lclojure/lang/Var;
    //   5404: dup
    //   5405: getstatic schema/core__init.const__396 : Lclojure/lang/AFn;
    //   5408: checkcast clojure/lang/IPersistentMap
    //   5411: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5414: dup
    //   5415: aconst_null
    //   5416: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5419: getstatic schema/core__init.const__397 : Lclojure/lang/Var;
    //   5422: dup
    //   5423: getstatic schema/core__init.const__400 : Lclojure/lang/AFn;
    //   5426: checkcast clojure/lang/IPersistentMap
    //   5429: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5432: dup
    //   5433: new schema/core$schematize_fn
    //   5436: dup
    //   5437: invokespecial <init> : ()V
    //   5440: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5443: getstatic schema/core__init.const__401 : Lclojure/lang/Var;
    //   5446: dup
    //   5447: getstatic schema/core__init.const__406 : Lclojure/lang/AFn;
    //   5450: checkcast clojure/lang/IPersistentMap
    //   5453: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5456: dup
    //   5457: new schema/core$fn_schema
    //   5460: dup
    //   5461: invokespecial <init> : ()V
    //   5464: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5467: getstatic schema/core__init.const__5 : Lclojure/lang/Var;
    //   5470: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   5473: dup
    //   5474: ifnull -> 5487
    //   5477: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   5480: if_acmpeq -> 5488
    //   5483: aconst_null
    //   5484: goto -> 5511
    //   5487: pop
    //   5488: getstatic schema/core__init.const__407 : Lclojure/lang/Var;
    //   5491: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   5494: checkcast clojure/lang/IFn
    //   5497: getstatic schema/core__init.const__32 : Lclojure/lang/Var;
    //   5500: invokevirtual get : ()Ljava/lang/Object;
    //   5503: getstatic schema/core__init.const__408 : Lclojure/lang/AFn;
    //   5506: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   5511: getstatic schema/core__init.const__409 : Lclojure/lang/Var;
    //   5514: dup
    //   5515: getstatic schema/core__init.const__412 : Lclojure/lang/AFn;
    //   5518: checkcast clojure/lang/IPersistentMap
    //   5521: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5524: dup
    //   5525: new schema/core$fn
    //   5528: dup
    //   5529: invokespecial <init> : ()V
    //   5532: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5535: getstatic schema/core__init.const__409 : Lclojure/lang/Var;
    //   5538: checkcast clojure/lang/Var
    //   5541: invokevirtual setMacro : ()V
    //   5544: aconst_null
    //   5545: getstatic schema/core__init.const__409 : Lclojure/lang/Var;
    //   5548: getstatic schema/core__init.const__413 : Lclojure/lang/Var;
    //   5551: dup
    //   5552: getstatic schema/core__init.const__416 : Lclojure/lang/AFn;
    //   5555: checkcast clojure/lang/IPersistentMap
    //   5558: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5561: dup
    //   5562: new schema/core$defn
    //   5565: dup
    //   5566: invokespecial <init> : ()V
    //   5569: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5572: getstatic schema/core__init.const__413 : Lclojure/lang/Var;
    //   5575: checkcast clojure/lang/Var
    //   5578: invokevirtual setMacro : ()V
    //   5581: aconst_null
    //   5582: getstatic schema/core__init.const__413 : Lclojure/lang/Var;
    //   5585: getstatic schema/core__init.const__417 : Lclojure/lang/Var;
    //   5588: dup
    //   5589: getstatic schema/core__init.const__420 : Lclojure/lang/AFn;
    //   5592: checkcast clojure/lang/IPersistentMap
    //   5595: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5598: dup
    //   5599: new schema/core$defmethod
    //   5602: dup
    //   5603: invokespecial <init> : ()V
    //   5606: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5609: getstatic schema/core__init.const__417 : Lclojure/lang/Var;
    //   5612: checkcast clojure/lang/Var
    //   5615: invokevirtual setMacro : ()V
    //   5618: aconst_null
    //   5619: getstatic schema/core__init.const__417 : Lclojure/lang/Var;
    //   5622: getstatic schema/core__init.const__421 : Lclojure/lang/Var;
    //   5625: dup
    //   5626: getstatic schema/core__init.const__424 : Lclojure/lang/AFn;
    //   5629: checkcast clojure/lang/IPersistentMap
    //   5632: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5635: dup
    //   5636: new schema/core$letfn
    //   5639: dup
    //   5640: invokespecial <init> : ()V
    //   5643: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5646: getstatic schema/core__init.const__421 : Lclojure/lang/Var;
    //   5649: checkcast clojure/lang/Var
    //   5652: invokevirtual setMacro : ()V
    //   5655: aconst_null
    //   5656: getstatic schema/core__init.const__421 : Lclojure/lang/Var;
    //   5659: getstatic schema/core__init.const__425 : Lclojure/lang/Var;
    //   5662: dup
    //   5663: getstatic schema/core__init.const__428 : Lclojure/lang/AFn;
    //   5666: checkcast clojure/lang/IPersistentMap
    //   5669: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5672: dup
    //   5673: new schema/core$def
    //   5676: dup
    //   5677: invokespecial <init> : ()V
    //   5680: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5683: getstatic schema/core__init.const__425 : Lclojure/lang/Var;
    //   5686: checkcast clojure/lang/Var
    //   5689: invokevirtual setMacro : ()V
    //   5692: aconst_null
    //   5693: getstatic schema/core__init.const__425 : Lclojure/lang/Var;
    //   5696: getstatic schema/core__init.const__44 : Lclojure/lang/Var;
    //   5699: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   5702: invokevirtual set : (Ljava/lang/Object;)Ljava/lang/Object;
    //   5705: getstatic schema/core__init.const__429 : Lclojure/lang/Var;
    //   5708: dup
    //   5709: getstatic schema/core__init.const__432 : Lclojure/lang/AFn;
    //   5712: checkcast clojure/lang/IPersistentMap
    //   5715: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   5718: dup
    //   5719: new schema/core$set_max_value_length_BANG_
    //   5722: dup
    //   5723: invokespecial <init> : ()V
    //   5726: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   5729: return
    // Line number table:
    //   Java source line number -> byte code offset
    //   #1	-> 6
    //   #1	-> 12
    //   #1	-> 23
    //   #1	-> 35
    //   #1	-> 45
    //   #1	-> 48
    //   #1	-> 53
    //   #1	-> 62
    //   #1	-> 83
    //   #92	-> 109
    //   #92	-> 112
    //   #92	-> 128
    //   #92	-> 144
    //   #92	-> 153
    //   #92	-> 162
    //   #92	-> 174
    //   #92	-> 192
    //   #92	-> 231
    //   #92	-> 246
    //   #92	-> 258
    //   #92	-> 283
    //   #92	-> 288
    //   #92	-> 293
    //   #92	-> 312
    //   #92	-> 317
    //   #92	-> 329
    //   #92	-> 338
    //   #94	-> 355
    //   #94	-> 358
    //   #101	-> 366
    //   #103	-> 393
    //   #103	-> 405
    //   #110	-> 426
    //   #110	-> 429
    //   #110	-> 443
    //   #110	-> 459
    //   #110	-> 467
    //   #110	-> 476
    //   #110	-> 487
    //   #110	-> 505
    //   #110	-> 544
    //   #110	-> 559
    //   #110	-> 571
    //   #110	-> 596
    //   #110	-> 601
    //   #110	-> 606
    //   #110	-> 630
    //   #110	-> 645
    //   #110	-> 657
    //   #110	-> 682
    //   #110	-> 687
    //   #110	-> 692
    //   #110	-> 711
    //   #110	-> 716
    //   #110	-> 727
    //   #110	-> 736
    //   #123	-> 766
    //   #125	-> 791
    //   #127	-> 801
    //   #127	-> 804
    //   #181	-> 935
    //   #181	-> 986
    //   #207	-> 1021
    //   #216	-> 1034
    //   #216	-> 1043
    //   #216	-> 1052
    //   #216	-> 1061
    //   #216	-> 1067
    //   #216	-> 1072
    //   #216	-> 1077
    //   #216	-> 1127
    //   #217	-> 1138
    //   #217	-> 1147
    //   #217	-> 1156
    //   #217	-> 1165
    //   #217	-> 1171
    //   #217	-> 1176
    //   #217	-> 1181
    //   #217	-> 1231
    //   #218	-> 1242
    //   #218	-> 1251
    //   #218	-> 1260
    //   #218	-> 1269
    //   #218	-> 1275
    //   #218	-> 1280
    //   #218	-> 1285
    //   #218	-> 1335
    //   #219	-> 1346
    //   #219	-> 1355
    //   #219	-> 1364
    //   #219	-> 1373
    //   #219	-> 1379
    //   #219	-> 1384
    //   #219	-> 1389
    //   #219	-> 1439
    //   #220	-> 1450
    //   #220	-> 1459
    //   #220	-> 1468
    //   #220	-> 1477
    //   #220	-> 1483
    //   #220	-> 1488
    //   #220	-> 1493
    //   #220	-> 1543
    //   #221	-> 1554
    //   #221	-> 1563
    //   #221	-> 1572
    //   #221	-> 1581
    //   #221	-> 1587
    //   #221	-> 1592
    //   #221	-> 1597
    //   #221	-> 1647
    //   #222	-> 1658
    //   #222	-> 1667
    //   #222	-> 1676
    //   #222	-> 1685
    //   #222	-> 1691
    //   #222	-> 1696
    //   #222	-> 1701
    //   #222	-> 1751
    //   #223	-> 1762
    //   #223	-> 1771
    //   #223	-> 1780
    //   #223	-> 1789
    //   #223	-> 1795
    //   #223	-> 1800
    //   #223	-> 1805
    //   #223	-> 1855
    //   #225	-> 1866
    //   #225	-> 1875
    //   #225	-> 1884
    //   #225	-> 1893
    //   #225	-> 1899
    //   #225	-> 1904
    //   #225	-> 1909
    //   #225	-> 1959
    //   #226	-> 1970
    //   #226	-> 1979
    //   #226	-> 1988
    //   #226	-> 1997
    //   #226	-> 2003
    //   #226	-> 2008
    //   #226	-> 2013
    //   #226	-> 2063
    //   #227	-> 2074
    //   #227	-> 2083
    //   #227	-> 2092
    //   #227	-> 2101
    //   #227	-> 2107
    //   #227	-> 2112
    //   #227	-> 2117
    //   #227	-> 2167
    //   #228	-> 2178
    //   #228	-> 2187
    //   #228	-> 2196
    //   #228	-> 2205
    //   #228	-> 2211
    //   #228	-> 2216
    //   #228	-> 2221
    //   #228	-> 2271
    //   #229	-> 2282
    //   #229	-> 2291
    //   #229	-> 2300
    //   #229	-> 2309
    //   #229	-> 2315
    //   #229	-> 2320
    //   #229	-> 2325
    //   #229	-> 2375
    //   #230	-> 2386
    //   #230	-> 2395
    //   #230	-> 2404
    //   #230	-> 2413
    //   #230	-> 2419
    //   #230	-> 2424
    //   #230	-> 2429
    //   #230	-> 2479
    //   #231	-> 2490
    //   #231	-> 2499
    //   #231	-> 2508
    //   #231	-> 2517
    //   #231	-> 2523
    //   #231	-> 2528
    //   #231	-> 2533
    //   #231	-> 2583
    //   #232	-> 2594
    //   #232	-> 2603
    //   #232	-> 2612
    //   #232	-> 2621
    //   #232	-> 2627
    //   #232	-> 2632
    //   #232	-> 2637
    //   #232	-> 2687
    //   #239	-> 2699
    //   #239	-> 2702
    //   #254	-> 2739
    //   #254	-> 2742
    //   #267	-> 2778
    //   #267	-> 2781
    //   #286	-> 2817
    //   #286	-> 2820
    //   #299	-> 2856
    //   #299	-> 2859
    //   #326	-> 2919
    //   #326	-> 2922
    //   #337	-> 2957
    //   #353	-> 2970
    //   #353	-> 3021
    //   #383	-> 3106
    //   #383	-> 3115
    //   #387	-> 3143
    //   #387	-> 3152
    //   #391	-> 3180
    //   #391	-> 3189
    //   #417	-> 3264
    //   #417	-> 3267
    //   #434	-> 3303
    //   #434	-> 3306
    //   #450	-> 3342
    //   #450	-> 3345
    //   #477	-> 3381
    //   #477	-> 3384
    //   #523	-> 3420
    //   #523	-> 3423
    //   #523	-> 3437
    //   #523	-> 3453
    //   #523	-> 3461
    //   #523	-> 3470
    //   #523	-> 3481
    //   #523	-> 3499
    //   #523	-> 3538
    //   #523	-> 3553
    //   #523	-> 3565
    //   #523	-> 3590
    //   #523	-> 3595
    //   #523	-> 3600
    //   #523	-> 3619
    //   #523	-> 3624
    //   #523	-> 3635
    //   #523	-> 3644
    //   #529	-> 3658
    //   #529	-> 3693
    //   #529	-> 3704
    //   #529	-> 3739
    //   #529	-> 3750
    //   #529	-> 3785
    //   #548	-> 3797
    //   #548	-> 3800
    //   #583	-> 3836
    //   #583	-> 3839
    //   #607	-> 3875
    //   #607	-> 3878
    //   #651	-> 3962
    //   #651	-> 3965
    //   #681	-> 4025
    //   #681	-> 4028
    //   #720	-> 4064
    //   #720	-> 4067
    //   #733	-> 4127
    //   #733	-> 4130
    //   #759	-> 4262
    //   #759	-> 4265
    //   #842	-> 4444
    //   #842	-> 4495
    //   #857	-> 4506
    //   #857	-> 4557
    //   #888	-> 4617
    //   #888	-> 4620
    //   #913	-> 4656
    //   #913	-> 4659
    //   #940	-> 4742
    //   #940	-> 4793
    //   #1004	-> 4829
    //   #1004	-> 4832
    //   #1023	-> 4891
    //   #1054	-> 4929
    //   #1054	-> 4932
    //   #1081	-> 5015
    //   #1091	-> 5052
    //   #1116	-> 5161
    //   #1131	-> 5198
    //   #1170	-> 5235
    //   #1178	-> 5272
    //   #1195	-> 5357
    //   #1208	-> 5394
    //   #1250	-> 5467
    //   #1250	-> 5494
    //   #1250	-> 5506
    //   #1252	-> 5541
    //   #1277	-> 5578
    //   #1353	-> 5615
    //   #1378	-> 5652
    //   #1386	-> 5689 }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "schema.core")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "A library for data shape definition and validation. A Schema is just Clojure data,\n   which can be used to document and validate Clojure functions and data.\n\n   For example,\n\n   (def FooBar {:foo Keyword :bar [Number]}) ;; a schema\n\n   (check FooBar {:foo :k :bar [1.0 2.0 3.0]})\n   ==> nil\n\n   representing successful validation, but the following all return helpful errors\n   describing how the provided data fails to measure up to schema FooBar's standards.\n\n   (check FooBar {:bar [1.0 2.0 3.0]})\n   ==> {:foo missing-required-key}\n\n   (check FooBar {:foo 1 :bar [1.0 2.0 3.0]})\n   ==> {:foo (not (keyword? 1))}\n\n   (check FooBar {:foo :k :bar [1.0 2.0 3.0] :baz 1})\n   ==> {:baz disallowed-key}\n\n   Schema lets you describe your leaf values using the Any, Keyword, Symbol, Number,\n   String, and Int definitions below, or (in Clojure) you can use arbitrary Java\n   classes or primitive casts to describe simple values.\n\n   From there, you can build up schemas for complex types using Clojure syntax\n   (map literals for maps, set literals for sets, vector literals for sequences,\n   with details described below), plus helpers below that provide optional values,\n   enumerations, arbitrary predicates, and more.\n\n   Assuming you (:require [schema.core :as s :include-macros true]),\n   Schema also provides macros for defining records with schematized elements\n   (s/defrecord), and named or anonymous functions (s/fn and s/defn) with\n   schematized inputs and return values.  In addition to producing better-documented\n   records and functions, these macros allow you to retrieve the schema associated\n   with the defined record or function.  Moreover, functions include optional\n   *validation*, which will throw an error if the inputs or outputs do not\n   match the provided schemas:\n\n   (s/defrecord FooBar\n    [foo :- Int\n     bar :- String])\n\n   (s/defn quux :- Int\n    [foobar :- Foobar\n     mogrifier :- Number]\n    (* mogrifier (+ (:foo foobar) (Long/parseLong (:bar foobar)))))\n\n   (quux (FooBar. 10 \"5\") 2)\n   ==> 30\n\n   (fn-schema quux)\n   ==> (=> Int (record user.FooBar {:foo Int, :bar java.lang.String}) java.lang.Number)\n\n   (s/with-fn-validation (quux (FooBar. 10.2 \"5\") 2))\n   ==> Input to quux does not match schema: [(named {:foo (not (integer? 10.2))} foobar) nil]\n\n   As you can see, the preferred syntax for providing type hints to schema's defrecord,\n   fn, and defn macros is to follow each element, argument, or function name with a\n   :- schema.  Symbols without schemas default to a schema of Any.  In Clojure,\n   class (e.g., clojure.lang.String) and primitive schemas (long, double) are also\n   propagated to tag metadata to ensure you get the type hinting and primitive\n   behavior you ask for.\n\n   If you don't like this style, standard Clojure-style typehints are also supported:\n\n   (fn-schema (s/fn [^String x]))\n   ==> (=> Any java.lang.String)\n\n   You can directly type hint a symbol as a class, primitive, or simple\n   schema.\n\n   See the docstrings of defrecord, fn, and defn for more details about how\n   to use these macros." }));
    const__2 = (Keyword)RT.keyword(null, "doc");
    const__3 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "A library for data shape definition and validation. A Schema is just Clojure data,\n   which can be used to document and validate Clojure functions and data.\n\n   For example,\n\n   (def FooBar {:foo Keyword :bar [Number]}) ;; a schema\n\n   (check FooBar {:foo :k :bar [1.0 2.0 3.0]})\n   ==> nil\n\n   representing successful validation, but the following all return helpful errors\n   describing how the provided data fails to measure up to schema FooBar's standards.\n\n   (check FooBar {:bar [1.0 2.0 3.0]})\n   ==> {:foo missing-required-key}\n\n   (check FooBar {:foo 1 :bar [1.0 2.0 3.0]})\n   ==> {:foo (not (keyword? 1))}\n\n   (check FooBar {:foo :k :bar [1.0 2.0 3.0] :baz 1})\n   ==> {:baz disallowed-key}\n\n   Schema lets you describe your leaf values using the Any, Keyword, Symbol, Number,\n   String, and Int definitions below, or (in Clojure) you can use arbitrary Java\n   classes or primitive casts to describe simple values.\n\n   From there, you can build up schemas for complex types using Clojure syntax\n   (map literals for maps, set literals for sets, vector literals for sequences,\n   with details described below), plus helpers below that provide optional values,\n   enumerations, arbitrary predicates, and more.\n\n   Assuming you (:require [schema.core :as s :include-macros true]),\n   Schema also provides macros for defining records with schematized elements\n   (s/defrecord), and named or anonymous functions (s/fn and s/defn) with\n   schematized inputs and return values.  In addition to producing better-documented\n   records and functions, these macros allow you to retrieve the schema associated\n   with the defined record or function.  Moreover, functions include optional\n   *validation*, which will throw an error if the inputs or outputs do not\n   match the provided schemas:\n\n   (s/defrecord FooBar\n    [foo :- Int\n     bar :- String])\n\n   (s/defn quux :- Int\n    [foobar :- Foobar\n     mogrifier :- Number]\n    (* mogrifier (+ (:foo foobar) (Long/parseLong (:bar foobar)))))\n\n   (quux (FooBar. 10 \"5\") 2)\n   ==> 30\n\n   (fn-schema quux)\n   ==> (=> Int (record user.FooBar {:foo Int, :bar java.lang.String}) java.lang.Number)\n\n   (s/with-fn-validation (quux (FooBar. 10.2 \"5\") 2))\n   ==> Input to quux does not match schema: [(named {:foo (not (integer? 10.2))} foobar) nil]\n\n   As you can see, the preferred syntax for providing type hints to schema's defrecord,\n   fn, and defn macros is to follow each element, argument, or function name with a\n   :- schema.  Symbols without schemas default to a schema of Any.  In Clojure,\n   class (e.g., clojure.lang.String) and primitive schemas (long, double) are also\n   propagated to tag metadata to ensure you get the type hinting and primitive\n   behavior you ask for.\n\n   If you don't like this style, standard Clojure-style typehints are also supported:\n\n   (fn-schema (s/fn [^String x]))\n   ==> (=> Any java.lang.String)\n\n   You can directly type hint a symbol as a class, primitive, or simple\n   schema.\n\n   See the docstrings of defrecord, fn, and defn for more details about how\n   to use these macros." });
    const__4 = (AFn)Symbol.intern(null, "clojure.core");
    const__5 = (Var)RT.var("schema.core", "clj-1195-fixed?");
    const__11 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(91), RT.keyword(null, "column"), Integer.valueOf(7), RT.keyword(null, "file"), "schema/core.clj" });
    const__12 = RT.classForName("schema.core.CLJ1195Check");
    const__13 = (Var)RT.var("clojure.core", "alter-meta!");
    const__14 = (Var)RT.var("schema.core", "CLJ1195Check");
    const__15 = (Var)RT.var("clojure.core", "assoc");
    const__16 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__17 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "dummy-method")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })) }));
    const__18 = (Var)RT.var("clojure.core", "alter-var-root");
    const__19 = (Var)RT.var("clojure.core", "merge");
    const__23 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "schema.core.CLJ1195Check"), RT.keyword(null, "on-interface"), RT.classForName("schema.core.CLJ1195Check") });
    const__24 = (Keyword)RT.keyword(null, "sigs");
    const__25 = (AFn)RT.map(new Object[] { RT.keyword(null, "dummy-method"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "dummy-method")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), null }) });
    const__26 = (Keyword)RT.keyword(null, "var");
    const__27 = (Keyword)RT.keyword(null, "method-map");
    const__29 = (AFn)RT.map(new Object[] { RT.keyword(null, "dummy-method"), RT.keyword(null, "dummy-method") });
    const__30 = (Keyword)RT.keyword(null, "method-builders");
    const__31 = (Var)RT.var("clojure.core", "intern");
    const__32 = (Var)RT.var("clojure.core", "*ns*");
    const__33 = (Var)RT.var("clojure.core", "with-meta");
    const__34 = (AFn)((IObj)Symbol.intern(null, "dummy-method")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__35 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "dummy-method")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), null });
    const__36 = (Keyword)RT.keyword(null, "protocol");
    const__37 = (Var)RT.var("clojure.core", "-reset-methods");
    const__38 = (AFn)Symbol.intern(null, "CLJ1195Check");
    const__39 = (Var)RT.var("clojure.core", "extend");
    const__40 = (Var)RT.var("clojure.core", "refer");
    const__41 = (AFn)Symbol.intern(null, "clojure.core");
    const__42 = (Keyword)RT.keyword(null, "exclude");
    const__43 = (AFn)RT.vector(new Object[] { Symbol.intern(null, "Keyword"), Symbol.intern(null, "Symbol"), Symbol.intern(null, "Inst"), Symbol.intern(null, "atom"), Symbol.intern(null, "defrecord"), Symbol.intern(null, "defn"), Symbol.intern(null, "letfn"), Symbol.intern(null, "defmethod") });
    const__44 = (Var)RT.var("clojure.core", "*warn-on-reflection*");
    const__45 = RT.classForName("schema.core.Schema");
    const__46 = (Var)RT.var("schema.core", "Schema");
    const__47 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "spec")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "A spec is a record of some type that expresses the structure of this schema\n     in a declarative and/or imperative way.  See schema.spec.* for examples.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "explain")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Expand this schema to a human-readable format suitable for pprinting,\n     also expanding class schematas at the leaves.  Example:\n\n     user> (s/explain {:a s/Keyword :b [s/Int]} )\n     {:a Keyword, :b [Int]}", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })) }));
    const__49 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "schema.core.Schema"), RT.keyword(null, "on-interface"), RT.classForName("schema.core.Schema") });
    const__50 = (AFn)RT.map(new Object[] { RT.keyword(null, "spec"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "spec")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "A spec is a record of some type that expresses the structure of this schema\n     in a declarative and/or imperative way.  See schema.spec.* for examples.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "A spec is a record of some type that expresses the structure of this schema\n     in a declarative and/or imperative way.  See schema.spec.* for examples." }), RT.keyword(null, "explain"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "explain")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Expand this schema to a human-readable format suitable for pprinting,\n     also expanding class schematas at the leaves.  Example:\n\n     user> (s/explain {:a s/Keyword :b [s/Int]} )\n     {:a Keyword, :b [Int]}", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Expand this schema to a human-readable format suitable for pprinting,\n     also expanding class schematas at the leaves.  Example:\n\n     user> (s/explain {:a s/Keyword :b [s/Int]} )\n     {:a Keyword, :b [Int]}" }) });
    const__51 = (Keyword)RT.keyword(null, "explain");
    const__52 = (Keyword)RT.keyword(null, "spec");
    const__53 = (AFn)RT.map(new Object[] { RT.keyword(null, "explain"), RT.keyword(null, "explain"), RT.keyword(null, "spec"), RT.keyword(null, "spec") });
    const__54 = (AFn)((IObj)Symbol.intern(null, "explain")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Expand this schema to a human-readable format suitable for pprinting,\n     also expanding class schematas at the leaves.  Example:\n\n     user> (s/explain {:a s/Keyword :b [s/Int]} )\n     {:a Keyword, :b [Int]}", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__55 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "explain")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Expand this schema to a human-readable format suitable for pprinting,\n     also expanding class schematas at the leaves.  Example:\n\n     user> (s/explain {:a s/Keyword :b [s/Int]} )\n     {:a Keyword, :b [Int]}", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Expand this schema to a human-readable format suitable for pprinting,\n     also expanding class schematas at the leaves.  Example:\n\n     user> (s/explain {:a s/Keyword :b [s/Int]} )\n     {:a Keyword, :b [Int]}" });
    const__56 = (AFn)((IObj)Symbol.intern(null, "spec")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "A spec is a record of some type that expresses the structure of this schema\n     in a declarative and/or imperative way.  See schema.spec.* for examples.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__57 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "spec")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "A spec is a record of some type that expresses the structure of this schema\n     in a declarative and/or imperative way.  See schema.spec.* for examples.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "A spec is a record of some type that expresses the structure of this schema\n     in a declarative and/or imperative way.  See schema.spec.* for examples." });
    const__58 = (AFn)Symbol.intern(null, "Schema");
    const__59 = (Var)RT.var("clojure.core", "print-method");
    const__60 = (Var)RT.var("clojure.pprint", "simple-dispatch");
    const__61 = (Var)RT.var("schema.core", "checker");
    const__66 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "schema")) })), RT.keyword(null, "doc"), "Compile an efficient checker for schema, which returns nil for valid values and\n   error descriptions otherwise.", RT.keyword(null, "line"), Integer.valueOf(132), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__67 = (Var)RT.var("schema.core", "check");
    const__70 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "schema"), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return nil if x matches schema; otherwise, returns a value that looks like the\n   'bad' parts of x with ValidationErrors at the leaves describing the failures.\n\n   If you will be checking many datums, it is much more efficient to create\n   a 'checker' once and call it on each of them.", RT.keyword(null, "line"), Integer.valueOf(140), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__71 = (Var)RT.var("schema.core", "validator");
    const__74 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "schema")) })), RT.keyword(null, "doc"), "Compile an efficient validator for schema.", RT.keyword(null, "line"), Integer.valueOf(149), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__75 = (Var)RT.var("schema.core", "validate");
    const__78 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "schema"), Symbol.intern(null, "value")) })), RT.keyword(null, "doc"), "Throw an exception if value does not satisfy schema; otherwise, return value.\n   If you will be validating many datums, it is much more efficient to create\n   a 'validator' once and call it on each of them.", RT.keyword(null, "line"), Integer.valueOf(159), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__79 = (Var)RT.var("schema.core", "instance-precondition");
    const__82 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s"), Symbol.intern(null, "klass")) })), RT.keyword(null, "line"), Integer.valueOf(172), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__83 = RT.classForName("java.lang.Class");
    const__84 = (Var)RT.var("schema.core", "extend-primitive");
    const__88 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cast-sym"), Symbol.intern(null, "class-sym")) })), RT.keyword(null, "line"), Integer.valueOf(207), RT.keyword(null, "column"), Integer.valueOf(3), RT.keyword(null, "file"), "schema/core.clj" });
    const__89 = (Var)RT.var("clojure.core", "class");
    const__90 = (Var)RT.var("clojure.core", "deref");
    const__91 = (Var)RT.var("clojure.core", "resolve");
    const__92 = (AFn)Symbol.intern(null, "double");
    const__93 = (AFn)Symbol.intern(null, "float");
    const__94 = (AFn)Symbol.intern(null, "long");
    const__95 = (AFn)Symbol.intern(null, "int");
    const__96 = (AFn)Symbol.intern(null, "short");
    const__97 = (AFn)Symbol.intern(null, "char");
    const__98 = (AFn)Symbol.intern(null, "byte");
    const__99 = (AFn)Symbol.intern(null, "boolean");
  }
  
  public static void __init1() {
    const__100 = (AFn)Symbol.intern(null, "doubles");
    const__101 = (AFn)Symbol.intern(null, "floats");
    const__102 = (AFn)Symbol.intern(null, "longs");
    const__103 = (AFn)Symbol.intern(null, "ints");
    const__104 = (AFn)Symbol.intern(null, "shorts");
    const__105 = (AFn)Symbol.intern(null, "chars");
    const__106 = (AFn)Symbol.intern(null, "bytes");
    const__107 = (AFn)Symbol.intern(null, "booleans");
    const__108 = (Var)RT.var("schema.core", "Any");
    const__110 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(247), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj", RT.keyword(null, "doc"), "Any value, including nil." });
    const__111 = (Var)RT.var("schema.core", "eq");
    const__114 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "v")) })), RT.keyword(null, "doc"), "A value that must be (= v).", RT.keyword(null, "line"), Integer.valueOf(259), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__115 = (Var)RT.var("schema.core", "isa");
    const__118 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "parent")), Tuple.create(Symbol.intern(null, "h"), Symbol.intern(null, "parent")) })), RT.keyword(null, "doc"), "A value that must be a child of parent.", RT.keyword(null, "line"), Integer.valueOf(276), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__119 = (Var)RT.var("schema.core", "enum");
    const__122 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "vs")) })), RT.keyword(null, "doc"), "A value that must be = to some element of vs.", RT.keyword(null, "line"), Integer.valueOf(291), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__123 = (Var)RT.var("schema.core", "pred");
    const__126 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p?")), Tuple.create(Symbol.intern(null, "p?"), Symbol.intern(null, "pred-name")) })), RT.keyword(null, "doc"), "A value for which p? returns true (and does not throw).\n   Optional pred-name can be passed for nicer validation errors.", RT.keyword(null, "line"), Integer.valueOf(309), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__127 = (Var)RT.var("schema.core", "protocol-name");
    const__130 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "protocol")) })), RT.keyword(null, "line"), Integer.valueOf(321), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__131 = (Var)RT.var("schema.core", "protocol");
    const__134 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p")) })), RT.keyword(null, "doc"), "A value that must satsify? protocol p.\n\n   Internaly, we must make sure not to capture the value of the protocol at\n   schema creation time, since that's impossible in cljs and breaks later\n   extends in Clojure.\n\n   A macro for cljs sake, since `satisfies?` is a macro in cljs.", RT.keyword(null, "line"), Integer.valueOf(337), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__135 = RT.classForName("java.util.regex.Pattern");
    const__136 = (Var)RT.var("schema.core", "Str");
    const__138 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(368), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj", RT.keyword(null, "doc"), "Satisfied only by String.\n   Is (pred string?) and not js/String in cljs because of keywords." });
    const__139 = RT.classForName("java.lang.String");
    const__140 = (Var)RT.var("schema.core", "Bool");
    const__142 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(373), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj", RT.keyword(null, "doc"), "Boolean true or false" });
    const__143 = RT.classForName("java.lang.Boolean");
    const__144 = (Var)RT.var("schema.core", "Num");
    const__146 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(377), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj", RT.keyword(null, "doc"), "Any number" });
    const__147 = RT.classForName("java.lang.Number");
    const__148 = (Var)RT.var("schema.core", "Int");
    const__150 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(381), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj", RT.keyword(null, "doc"), "Any integral number" });
    const__151 = (Var)RT.var("clojure.core", "integer?");
    const__152 = (Var)RT.var("schema.core", "Keyword");
    const__154 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(385), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj", RT.keyword(null, "doc"), "A keyword" });
    const__155 = (Var)RT.var("clojure.core", "keyword?");
    const__156 = (Var)RT.var("schema.core", "Symbol");
    const__158 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(389), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj", RT.keyword(null, "doc"), "A symbol" });
    const__159 = (Var)RT.var("clojure.core", "symbol?");
    const__160 = (Var)RT.var("schema.core", "Regex");
    const__162 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(393), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj", RT.keyword(null, "doc"), "A regular expression" });
    const__163 = (Var)RT.var("schema.core", "Inst");
    const__165 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(402), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj", RT.keyword(null, "doc"), "The local representation of #inst ..." });
    const__166 = RT.classForName("java.util.Date");
    const__167 = (Var)RT.var("schema.core", "Uuid");
    const__169 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(406), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj", RT.keyword(null, "doc"), "The local representation of #uuid ..." });
    const__170 = RT.classForName("java.util.UUID");
    const__171 = (Var)RT.var("schema.core", "maybe");
    const__174 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "schema")) })), RT.keyword(null, "doc"), "A value that must either be nil or satisfy schema", RT.keyword(null, "line"), Integer.valueOf(426), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__175 = (Var)RT.var("schema.core", "named");
    const__178 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "schema"), Symbol.intern(null, "name")) })), RT.keyword(null, "doc"), "A value that must satisfy schema, and has a name for documentation purposes.", RT.keyword(null, "line"), Integer.valueOf(442), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__179 = (Var)RT.var("schema.core", "either");
    const__183 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "deprecated"), "1.0.0", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "schemas")) })), RT.keyword(null, "doc"), "A value that must satisfy at least one schema in schemas.\n   Note that `either` does not work properly with coercion\n\n   DEPRECATED: prefer `conditional` or `cond-pre`\n\n   WARNING: either does not work with coercion.  It is also slow and gives\n   bad error messages.  Please consider using `conditional` and friends\n   instead; they are more efficient, provide better error messages,\n   and work with coercion.", RT.keyword(null, "line"), Integer.valueOf(461), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "schema/core.clj" });
    const__184 = (Var)RT.var("schema.core", "conditional");
    const__187 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "preds-and-schemas")) })), RT.keyword(null, "doc"), "Define a conditional schema.  Takes args like cond,\n   (conditional pred1 schema1 pred2 schema2 ...),\n   and checks the first schemaX where predX (an ordinary Clojure function\n   that returns true or false) returns true on the value.\n   Unlike cond, throws if the value does not match any condition.\n   :else may be used as a final condition in the place of (constantly true).\n   More efficient than either, since only one schema must be checked.\n   An optional final argument can be passed, a symbol to appear in\n   error messages when none of the conditions match.", RT.keyword(null, "line"), Integer.valueOf(496), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__188 = RT.classForName("schema.core.HasPrecondition");
    const__189 = (Var)RT.var("schema.core", "HasPrecondition");
    const__190 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "precondition")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a predicate representing the Precondition for this schema:\n     the predicate returns true if the precondition is satisfied.\n     (See spec.core for more details)", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })) }));
    const__192 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "schema.core.HasPrecondition"), RT.keyword(null, "on-interface"), RT.classForName("schema.core.HasPrecondition") });
    const__193 = (AFn)RT.map(new Object[] { RT.keyword(null, "precondition"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "precondition")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a predicate representing the Precondition for this schema:\n     the predicate returns true if the precondition is satisfied.\n     (See spec.core for more details)", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return a predicate representing the Precondition for this schema:\n     the predicate returns true if the precondition is satisfied.\n     (See spec.core for more details)" }) });
    const__194 = (Keyword)RT.keyword(null, "precondition");
    const__195 = (AFn)RT.map(new Object[] { RT.keyword(null, "precondition"), RT.keyword(null, "precondition") });
    const__196 = (AFn)((IObj)Symbol.intern(null, "precondition")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a predicate representing the Precondition for this schema:\n     the predicate returns true if the precondition is satisfied.\n     (See spec.core for more details)", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__197 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "precondition")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a predicate representing the Precondition for this schema:\n     the predicate returns true if the precondition is satisfied.\n     (See spec.core for more details)", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return a predicate representing the Precondition for this schema:\n     the predicate returns true if the precondition is satisfied.\n     (See spec.core for more details)" });
    const__198 = (AFn)Symbol.intern(null, "HasPrecondition");
    const__199 = RT.classForName("schema.spec.leaf.LeafSpec");
  }
  
  public static void __init2() {
    const__200 = RT.classForName("schema.spec.variant.VariantSpec");
    const__201 = RT.classForName("schema.spec.collection.CollectionSpec");
    const__202 = (Var)RT.var("schema.core", "cond-pre");
    const__205 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "schemas")) })), RT.keyword(null, "doc"), "A replacement for `either` that constructs a conditional schema\n   based on the schema spec preconditions of the component schemas.\n\n   Given a datum, the preconditions for each schema (which typically\n   check just the outermost class) are tested against the datum in turn.\n   The first schema whose precondition matches is greedily selected,\n   and the datum is validated against that schema.  Unlike `either`,\n   a validation failure is final (and there is no backtracking to try\n   other schemas that might match).\n\n   Thus, `cond-pre` is only suitable for schemas with mutually exclusive\n   preconditions (e.g., s/Int and s/Str).  If this doesn't hold\n   (e.g. {:a s/Int} and {:b s/Str}), you must use `conditional` instead\n   and provide an explicit condition for distinguishing the cases.\n\n   EXPERIMENTAL", RT.keyword(null, "line"), Integer.valueOf(561), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__206 = (Var)RT.var("schema.core", "constrained");
    const__209 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s"), Symbol.intern(null, "p?")), Tuple.create(Symbol.intern(null, "s"), Symbol.intern(null, "p?"), Symbol.intern(null, "pred-name")) })), RT.keyword(null, "doc"), "A schema with an additional post-condition.  Differs from `conditional`\n   with a single schema, in that the predicate checked *after* the main\n   schema.  This can lead to better error messages, and is often better\n   suited for coercion.", RT.keyword(null, "line"), Integer.valueOf(594), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__210 = (Var)RT.var("schema.core", "both");
    const__213 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "deprecated"), "1.0.0", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "schemas")) })), RT.keyword(null, "doc"), "A value that must satisfy every schema in schemas.\n\n   DEPRECATED: prefer 'conditional' with a single condition\n   instead, or `constrained`.\n\n   When used with coercion, coerces each schema in sequence.", RT.keyword(null, "line"), Integer.valueOf(626), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "schema/core.clj" });
    const__214 = (Var)RT.var("schema.core", "if");
    const__217 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "if-schema"), Symbol.intern(null, "else-schema")) })), RT.keyword(null, "doc"), "if the predicate returns truthy, use the if-schema, otherwise use the else-schema", RT.keyword(null, "line"), Integer.valueOf(637), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__218 = (Var)RT.var("schema.core", "var-name");
    const__221 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "v")) })), RT.keyword(null, "line"), Integer.valueOf(647), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__222 = (Var)RT.var("schema.core", "recursive");
    const__225 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "schema")) })), RT.keyword(null, "doc"), "Support for (mutually) recursive schemas by passing a var that points to a schema,\n   e.g (recursive #'ExampleRecursiveSchema).", RT.keyword(null, "line"), Integer.valueOf(665), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__226 = (Var)RT.var("schema.core", "atom?");
    const__230 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(677), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__231 = (Var)RT.var("schema.core", "atom");
    const__234 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "schema")) })), RT.keyword(null, "doc"), "An atom containing a value matching 'schema'.", RT.keyword(null, "line"), Integer.valueOf(691), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__235 = (Var)RT.var("schema.core", "required-key");
    const__238 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "k")) })), RT.keyword(null, "doc"), "A required key in a map", RT.keyword(null, "line"), Integer.valueOf(722), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__239 = (Var)RT.var("schema.core", "required-key?");
    const__242 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ks")) })), RT.keyword(null, "line"), Integer.valueOf(729), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__243 = (Var)RT.var("schema.core", "optional-key");
    const__246 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "k")) })), RT.keyword(null, "doc"), "An optional key in a map", RT.keyword(null, "line"), Integer.valueOf(735), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__247 = (Var)RT.var("schema.core", "optional-key?");
    const__250 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ks")) })), RT.keyword(null, "line"), Integer.valueOf(740), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__251 = (Var)RT.var("schema.core", "explicit-schema-key");
    const__254 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ks")) })), RT.keyword(null, "line"), Integer.valueOf(744), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__255 = (Var)RT.var("schema.core", "specific-key?");
    const__258 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ks")) })), RT.keyword(null, "line"), Integer.valueOf(750), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__259 = (Var)RT.var("schema.core", "map-entry-ctor");
    const__262 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "k"), Symbol.intern(null, "v"), RT.keyword(null, "as"), Symbol.intern(null, "coll"))) })), RT.keyword(null, "line"), Integer.valueOf(754), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__263 = (Var)RT.var("schema.core", "map-entry");
    const__266 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "key-schema"), Symbol.intern(null, "val-schema")) })), RT.keyword(null, "line"), Integer.valueOf(777), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__267 = (Var)RT.var("schema.core", "find-extra-keys-schema");
    const__270 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "map-schema")) })), RT.keyword(null, "line"), Integer.valueOf(780), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__271 = (Var)RT.var("schema.core", "explain-kspec");
    const__274 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "kspec")) })), RT.keyword(null, "line"), Integer.valueOf(787), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__275 = (Var)RT.var("schema.core", "map-elements");
    const__278 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "line"), Integer.valueOf(796), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__279 = (Var)RT.var("schema.core", "map-error");
    const__282 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "line"), Integer.valueOf(828), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__283 = (Var)RT.var("schema.core", "map-spec");
    const__286 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "line"), Integer.valueOf(832), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__287 = (Var)RT.var("schema.core", "map-explain");
    const__290 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "line"), Integer.valueOf(839), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__291 = RT.classForName("clojure.lang.APersistentMap");
    const__292 = RT.classForName("clojure.lang.APersistentSet");
    const__293 = (Var)RT.var("schema.core", "queue?");
    const__296 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(875), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__297 = (Var)RT.var("schema.core", "as-queue");
  }
  
  public static void __init3() {
    const__300 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "col")) })), RT.keyword(null, "line"), Integer.valueOf(881), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__301 = (Var)RT.var("schema.core", "queue");
    const__304 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Defines a schema satisfied by instances of clojure.lang.PersistentQueue\n  (clj.core/PersistentQueue in ClojureScript) whose values satisfy x.", RT.keyword(null, "line"), Integer.valueOf(898), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__305 = (Var)RT.var("schema.core", "one");
    const__308 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "schema"), Symbol.intern(null, "name")) })), RT.keyword(null, "doc"), "A single required element of a sequence (not repeated, the implicit default)", RT.keyword(null, "line"), Integer.valueOf(915), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__309 = (Var)RT.var("schema.core", "optional");
    const__312 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "schema"), Symbol.intern(null, "name")) })), RT.keyword(null, "doc"), "A single optional element of a sequence (not repeated, the implicit default)", RT.keyword(null, "line"), Integer.valueOf(920), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__313 = (Var)RT.var("schema.core", "parse-sequence-schema");
    const__316 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "line"), Integer.valueOf(925), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__317 = RT.classForName("clojure.lang.APersistentVector");
    const__318 = (Var)RT.var("schema.core", "pair");
    const__321 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "first-schema"), Symbol.intern(null, "first-name"), Symbol.intern(null, "second-schema"), Symbol.intern(null, "second-name")) })), RT.keyword(null, "doc"), "A schema for a pair of schemas and their names", RT.keyword(null, "line"), Integer.valueOf(991), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__322 = (Var)RT.var("schema.core", "record*");
    const__325 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "klass"), Symbol.intern(null, "schema"), Symbol.intern(null, "map-constructor")) })), RT.keyword(null, "line"), Integer.valueOf(1018), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__326 = (Var)RT.var("schema.core", "record");
    const__329 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "klass"), Symbol.intern(null, "schema")), Tuple.create(Symbol.intern(null, "klass"), Symbol.intern(null, "schema"), Symbol.intern(null, "map-constructor")) })), RT.keyword(null, "doc"), "A Record instance of type klass, whose elements match map schema 'schema'.\n\n   The final argument is the map constructor of the record type; if you do\n   not pass one, an attempt is made to find the corresponding function\n   (but this may fail in exotic circumstances).", RT.keyword(null, "line"), Integer.valueOf(1023), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__330 = (Var)RT.var("schema.core", "explain-input-schema");
    const__333 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "input-schema")) })), RT.keyword(null, "line"), Integer.valueOf(1048), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__334 = (Var)RT.var("schema.core", "arity");
    const__337 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "input-schema")) })), RT.keyword(null, "line"), Integer.valueOf(1062), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__338 = (Var)RT.var("schema.core", "make-fn-schema");
    const__341 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "output-schema"), Symbol.intern(null, "input-schemas")) })), RT.keyword(null, "doc"), "A function outputting a value in output schema, whose argument vector must match one of\n   input-schemas, each of which should be a sequence schema.\n   Currently function schemas are purely descriptive; they validate against any function,\n   regardless of actual input and output types.", RT.keyword(null, "line"), Integer.valueOf(1069), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__342 = (Var)RT.var("schema.core", "=>*");
    const__345 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "output-schema"), Symbol.intern(null, "&"), Symbol.intern(null, "arity-schema-specs")) })), RT.keyword(null, "doc"), "Produce a function schema from an output schema and a list of arity input schema specs,\n   each of which is a vector of argument schemas, ending with an optional '& more-schema'\n   specification where more-schema must be a sequence schema.\n\n   Currently function schemas are purely descriptive; there is no validation except for\n   functions defined directly by s/fn or s/defn", RT.keyword(null, "line"), Integer.valueOf(1081), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__346 = (Var)RT.var("schema.core", "=>");
    const__349 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "output-schema"), Symbol.intern(null, "&"), Symbol.intern(null, "arg-schemas")) })), RT.keyword(null, "doc"), "Convenience macro for defining function schemas with a single arity; like =>*, but\n   there is no vector around the argument schemas for this arity.", RT.keyword(null, "line"), Integer.valueOf(1091), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__350 = (Var)RT.var("schema.core", "schema-with-name");
    const__353 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "schema"), Symbol.intern(null, "name")) })), RT.keyword(null, "doc"), "Records name in schema's metadata.", RT.keyword(null, "line"), Integer.valueOf(1101), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__354 = (Var)RT.var("schema.core", "schema-name");
    const__357 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "schema")) })), RT.keyword(null, "doc"), "Returns the name of a schema attached via schema-with-name (or defschema).", RT.keyword(null, "line"), Integer.valueOf(1106), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__358 = (Var)RT.var("schema.core", "schema-ns");
    const__361 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "schema")) })), RT.keyword(null, "doc"), "Returns the namespace of a schema attached via defschema.", RT.keyword(null, "line"), Integer.valueOf(1111), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__362 = (Var)RT.var("schema.core", "defschema");
    const__365 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "form")), Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "docstring"), Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Convenience macro to make it clear to reader that body is meant to be used as a schema.\n   The name of the schema is recorded in the metadata.", RT.keyword(null, "line"), Integer.valueOf(1116), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__366 = (Var)RT.var("schema.core", "defrecord");
    const__369 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "field-schema"), Symbol.intern(null, "extra-key-schema?"), Symbol.intern(null, "extra-validator-fn?"), Symbol.intern(null, "&"), Symbol.intern(null, "opts+specs")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(1165), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Define a record with a schema.\n\n   In addition to the ordinary behavior of defrecord, this macro produces a schema\n   for the Record, which will automatically be used when validating instances of\n   the Record class:\n\n   (m/defrecord FooBar\n    [foo :- Int\n     bar :- String])\n\n   (schema.utils/class-schema FooBar)\n   ==> (record user.FooBar {:foo Int, :bar java.lang.String})\n\n   (s/check FooBar (FooBar. 1.2 :not-a-string))\n   ==> {:foo (not (integer? 1.2)), :bar (not (instance? java.lang.String :not-a-string))}\n\n   See (doc schema.core) for details of the :- syntax for record elements.\n\n   Moreover, optional arguments extra-key-schema? and extra-validator-fn? can be\n   passed to augment the record schema.\n    - extra-key-schema is a map schema that defines validation for additional\n      key-value pairs not in the record base (the default is to not allow extra\n       mappings).\n    - extra-validator-fn? is an additional predicate that will be used as part\n      of validating the record value.\n\n   The remaining opts+specs (i.e., protocol and interface implementations) are\n   passed through directly to defrecord.\n\n   Finally, this macro replaces Clojure's map->name constructor with one that is\n   more than an order of magnitude faster (as of Clojure 1.5), and provides a\n   new strict-map->name constructor that throws or drops extra keys not in the\n   record base.", RT.keyword(null, "line"), Integer.valueOf(1131), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__370 = (Var)RT.var("schema.core", "defrecord+");
    const__373 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "field-schema"), Symbol.intern(null, "extra-key-schema?"), Symbol.intern(null, "extra-validator-fn?"), Symbol.intern(null, "&"), Symbol.intern(null, "opts+specs")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(1174), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "DEPRECATED -- canonical version moved to schema.potemkin\n   Like defrecord, but emits a record using potemkin/defrecord+.  You must provide\n   your own dependency on potemkin to use this.", RT.keyword(null, "line"), Integer.valueOf(1170), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__374 = (Var)RT.var("schema.core", "set-compile-fn-validation!");
    const__377 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "on?")) })), RT.keyword(null, "line"), Integer.valueOf(1178), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__378 = (Var)RT.var("schema.core", "fn-validation?");
    const__381 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Get the current global schema validation setting.", RT.keyword(null, "line"), Integer.valueOf(1183), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__382 = (Var)RT.var("schema.core", "set-fn-validation!");
    const__385 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "on?")) })), RT.keyword(null, "doc"), "Globally turn on (or off) schema validation for all s/fn and s/defn instances.", RT.keyword(null, "line"), Integer.valueOf(1189), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__386 = (Var)RT.var("schema.core", "with-fn-validation");
    const__389 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Execute body with input and output schema validation turned on for\n   all s/defn and s/fn instances globally (across all threads). After\n   all forms have been executed, resets function validation to its\n   previously set value. Not concurrency-safe.", RT.keyword(null, "line"), Integer.valueOf(1195), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__390 = (Var)RT.var("schema.core", "without-fn-validation");
    const__393 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Execute body with input and output schema validation turned off for\n   all s/defn and s/fn instances globally (across all threads). After\n   all forms have been executed, resets function validation to its\n   previously set value. Not concurrency-safe.", RT.keyword(null, "line"), Integer.valueOf(1208), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__394 = (Var)RT.var("schema.core", "fn-validator");
    const__396 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(1221), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj", RT.keyword(null, "doc"), "A var that can be rebound to a function to customize the behavior\n  of fn validation. When fn validation is on and `fn-validator` is\n  bound to a function, normal argument and return value checks will\n  be substituted with a call to this function with five arguments:\n\n    direction   - :input or :output\n    fn-name     - a symbol, the function's name\n    schema      - the schema for the arglist or the return value\n    checker     - a precompiled checker to check a value against\n                  the schema\n    value       - the actual arglist or return value\n\n  The function's return value will be ignored." });
    const__397 = (Var)RT.var("schema.core", "schematize-fn");
  }
  
  public static void __init4() {
    const__400 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "schema")) })), RT.keyword(null, "doc"), "Attach the schema to fn f at runtime, extractable by fn-schema.", RT.keyword(null, "line"), Integer.valueOf(1237), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__401 = (Var)RT.var("schema.core", "fn-schema");
    const__406 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("schema.core.FnSchema"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Produce the schema for a function defined with s/fn or s/defn.", RT.keyword(null, "line"), Integer.valueOf(1242), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "schema/core.clj" });
    const__407 = (Var)RT.var("clojure.core", "ns-unmap");
    const__408 = (AFn)Symbol.intern(null, "fn");
    const__409 = (Var)RT.var("schema.core", "fn");
    const__412 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "fn-args")) })), RT.keyword(null, "doc"), "s/fn : s/defn :: clojure.core/fn : clojure.core/defn\n\n   See (doc s/defn) for details.\n\n   Additional gotchas and limitations:\n    - Like s/defn, the output schema must go on the fn name. If you\n      don't supply a name, schema will gensym one for you and attach\n      the schema.\n    - Unlike s/defn, the function schema is stored in metadata on the\n      fn.  Clojure's implementation for metadata on fns currently\n      produces a wrapper fn, which will decrease performance and\n      negate the benefits of primitive type hints compared to\n      clojure.core/fn.", RT.keyword(null, "line"), Integer.valueOf(1252), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__413 = (Var)RT.var("schema.core", "defn");
    const__416 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "defn-args")) })), RT.keyword(null, "doc"), "Like clojure.core/defn, except that schema-style typehints can be given on\n   the argument symbols and on the function name (for the return value).\n\n   You can call s/fn-schema on the defined function to get its schema back, or\n   use with-fn-validation to enable runtime checking of function inputs and\n   outputs.\n\n   (s/defn foo :- s/Num\n    [x :- s/Int\n     y :- s/Num]\n    (* x y))\n\n   (s/fn-schema foo)\n   ==> (=> java.lang.Number Int java.lang.Number)\n\n   (s/with-fn-validation (foo 1 2))\n   ==> 2\n\n   (s/with-fn-validation (foo 1.5 2))\n   ==> Input to foo does not match schema: [(named (not (integer? 1.5)) x) nil]\n\n   See (doc schema.core) for details of the :- syntax for arguments and return\n   schemas.\n\n   The overhead for checking if run-time validation should be used is very\n   small -- about 5% of a very small fn call.  On top of that, actual\n   validation costs what it costs.\n\n   You can also turn on validation unconditionally for this fn only by\n   putting ^:always-validate metadata on the fn name.\n\n   Gotchas and limitations:\n    - The output schema always goes on the fn name, not the arg vector. This\n      means that all arities must share the same output schema. Schema will\n      automatically propagate primitive hints to the arg vector and class hints\n      to the fn name, so that you get the behavior you expect from Clojure.\n    - All primitive schemas will be passed through as type hints to Clojure,\n      despite their legality in a particular position.  E.g.,\n        (s/defn foo [x :- int])\n      will fail because Clojure does not allow primitive ints as fn arguments;\n      in such cases, use the boxed Classes instead (e.g., Integer).\n    - Schema metadata is only processed on top-level arguments.  I.e., you can\n      use destructuring, but you must put schema metadata on the top-level\n      arguments, not the destructured variables.\n\n      Bad:  (s/defn foo [{:keys [x :- s/Int]}])\n      Good: (s/defn foo [{:keys [x]} :- {:x s/Int}])\n    - Only a specific subset of rest-arg destructuring is supported:\n      - & rest works as expected\n      - & [a b] works, with schemas for individual elements parsed out of the binding,\n        or an overall schema on the vector\n      - & {} is not supported.\n    - Unlike clojure.core/defn, a final attr-map on multi-arity functions\n      is not supported.", RT.keyword(null, "line"), Integer.valueOf(1277), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__417 = (Var)RT.var("schema.core", "defmethod");
    const__420 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "multifn"), Symbol.intern(null, "dispatch-val"), Symbol.intern(null, "&"), Symbol.intern(null, "fn-tail")) })), RT.keyword(null, "doc"), "Like clojure.core/defmethod, except that schema-style typehints can be given on\n   the argument symbols and after the dispatch-val (for the return value).\n\n   See (doc s/defn) for details.\n\n   Examples:\n\n     (s/defmethod mymultifun :a-dispatch-value :- s/Num [x :- s/Int y :- s/Num] (* x y))\n\n     ;; You can also use meta tags like ^:always-validate by placing them\n     ;; before the multifunction name:\n\n     (s/defmethod ^:always-validate mymultifun :a-dispatch-value [x y] (* x y))", RT.keyword(null, "line"), Integer.valueOf(1353), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__421 = (Var)RT.var("schema.core", "letfn");
    const__424 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fnspecs"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "s/letfn : s/fn :: clojure.core/letfn : clojure.core/fn", RT.keyword(null, "line"), Integer.valueOf(1378), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__425 = (Var)RT.var("schema.core", "def");
    const__428 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "def-args")) })), RT.keyword(null, "doc"), "Like def, but takes a schema on the var name (with the same format\n   as the output schema of s/defn), requires an initial value, and\n   asserts that the initial value matches the schema on the var name\n   (regardless of the status of with-fn-validation).  Due to\n   limitations of add-watch!, cannot enforce validation of subsequent\n   rebindings of var.  Throws at compile-time for clj, and client-side\n   load-time for cljs.\n\n   Example:\n\n   (s/def foo :- long \"a long\" 2)", RT.keyword(null, "line"), Integer.valueOf(1386), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
    const__429 = (Var)RT.var("schema.core", "set-max-value-length!");
    const__432 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "max-length")) })), RT.keyword(null, "doc"), "Sets the maximum length of value to be output before it is contracted to a prettier name.", RT.keyword(null, "line"), Integer.valueOf(1413), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "schema/core.clj" });
  }
  
  static  {
    __init0();
    __init1();
    __init2();
    __init3();
    __init4();
    Compiler.pushNSandLoader(RT.classForName("schema.core__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
