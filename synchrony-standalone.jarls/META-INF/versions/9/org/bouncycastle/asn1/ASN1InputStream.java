package META-INF.versions.9.org.bouncycastle.asn1;

import java.io.ByteArrayInputStream;
import java.io.EOFException;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import org.bouncycastle.asn1.ASN1BitString;
import org.bouncycastle.asn1.ASN1Boolean;
import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1EncodableVector;
import org.bouncycastle.asn1.ASN1Enumerated;
import org.bouncycastle.asn1.ASN1Exception;
import org.bouncycastle.asn1.ASN1GeneralizedTime;
import org.bouncycastle.asn1.ASN1InputStream;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.ASN1OctetString;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.ASN1StreamParser;
import org.bouncycastle.asn1.ASN1UTCTime;
import org.bouncycastle.asn1.BERApplicationSpecificParser;
import org.bouncycastle.asn1.BEROctetString;
import org.bouncycastle.asn1.BEROctetStringParser;
import org.bouncycastle.asn1.BERPrivateParser;
import org.bouncycastle.asn1.BERSequenceParser;
import org.bouncycastle.asn1.BERSetParser;
import org.bouncycastle.asn1.BERTaggedObjectParser;
import org.bouncycastle.asn1.BERTags;
import org.bouncycastle.asn1.DERBMPString;
import org.bouncycastle.asn1.DERExternalParser;
import org.bouncycastle.asn1.DERGeneralString;
import org.bouncycastle.asn1.DERGraphicString;
import org.bouncycastle.asn1.DERIA5String;
import org.bouncycastle.asn1.DERNull;
import org.bouncycastle.asn1.DERNumericString;
import org.bouncycastle.asn1.DEROctetString;
import org.bouncycastle.asn1.DERPrintableString;
import org.bouncycastle.asn1.DERT61String;
import org.bouncycastle.asn1.DERUTF8String;
import org.bouncycastle.asn1.DERUniversalString;
import org.bouncycastle.asn1.DERVideotexString;
import org.bouncycastle.asn1.DERVisibleString;
import org.bouncycastle.asn1.DLApplicationSpecific;
import org.bouncycastle.asn1.DLExternal;
import org.bouncycastle.asn1.DLFactory;
import org.bouncycastle.asn1.DLPrivate;
import org.bouncycastle.asn1.DefiniteLengthInputStream;
import org.bouncycastle.asn1.IndefiniteLengthInputStream;
import org.bouncycastle.asn1.LazyEncodedSequence;
import org.bouncycastle.asn1.StreamUtil;
import org.bouncycastle.util.io.Streams;

public class ASN1InputStream extends FilterInputStream implements BERTags {
  private final int limit;
  
  private final boolean lazyEvaluate;
  
  private final byte[][] tmpBuffers;
  
  public ASN1InputStream(InputStream paramInputStream) { this(paramInputStream, StreamUtil.findLimit(paramInputStream)); }
  
  public ASN1InputStream(byte[] paramArrayOfByte) { this(new ByteArrayInputStream(paramArrayOfByte), paramArrayOfByte.length); }
  
  public ASN1InputStream(byte[] paramArrayOfByte, boolean paramBoolean) { this(new ByteArrayInputStream(paramArrayOfByte), paramArrayOfByte.length, paramBoolean); }
  
  public ASN1InputStream(InputStream paramInputStream, int paramInt) { this(paramInputStream, paramInt, false); }
  
  public ASN1InputStream(InputStream paramInputStream, boolean paramBoolean) { this(paramInputStream, StreamUtil.findLimit(paramInputStream), paramBoolean); }
  
  public ASN1InputStream(InputStream paramInputStream, int paramInt, boolean paramBoolean) {
    super(paramInputStream);
    this.limit = paramInt;
    this.lazyEvaluate = paramBoolean;
    this.tmpBuffers = new byte[11][];
  }
  
  int getLimit() { return this.limit; }
  
  protected int readLength() { return readLength(this, this.limit, false); }
  
  protected void readFully(byte[] paramArrayOfByte) {
    if (Streams.readFully(this, paramArrayOfByte) != paramArrayOfByte.length)
      throw new EOFException("EOF encountered in middle of object"); 
  }
  
  protected ASN1Primitive buildObject(int paramInt1, int paramInt2, int paramInt3) throws IOException {
    boolean bool = ((paramInt1 & 0x20) != 0);
    DefiniteLengthInputStream definiteLengthInputStream = new DefiniteLengthInputStream(this, paramInt3, this.limit);
    if ((paramInt1 & 0xC0) == 192)
      return new DLPrivate(bool, paramInt2, definiteLengthInputStream.toByteArray()); 
    if ((paramInt1 & 0x40) != 0)
      return new DLApplicationSpecific(bool, paramInt2, definiteLengthInputStream.toByteArray()); 
    if ((paramInt1 & 0x80) != 0)
      return (new ASN1StreamParser(definiteLengthInputStream)).readTaggedObject(bool, paramInt2); 
    if (bool) {
      byte b;
      ASN1OctetString[] arrayOfASN1OctetString;
      ASN1EncodableVector aSN1EncodableVector;
      switch (paramInt2) {
        case 4:
          aSN1EncodableVector = readVector(definiteLengthInputStream);
          arrayOfASN1OctetString = new ASN1OctetString[aSN1EncodableVector.size()];
          for (b = 0; b != arrayOfASN1OctetString.length; b++) {
            ASN1Encodable aSN1Encodable = aSN1EncodableVector.get(b);
            if (aSN1Encodable instanceof ASN1OctetString) {
              arrayOfASN1OctetString[b] = (ASN1OctetString)aSN1Encodable;
            } else {
              throw new ASN1Exception("unknown object encountered in constructed OCTET STRING: " + aSN1Encodable.getClass());
            } 
          } 
          return new BEROctetString(arrayOfASN1OctetString);
        case 16:
          if (this.lazyEvaluate)
            return new LazyEncodedSequence(definiteLengthInputStream.toByteArray()); 
          return DLFactory.createSequence(readVector(definiteLengthInputStream));
        case 17:
          return DLFactory.createSet(readVector(definiteLengthInputStream));
        case 8:
          return new DLExternal(readVector(definiteLengthInputStream));
      } 
      throw new IOException("unknown tag " + paramInt2 + " encountered");
    } 
    return createPrimitiveDERObject(paramInt2, definiteLengthInputStream, this.tmpBuffers);
  }
  
  ASN1EncodableVector readVector(DefiniteLengthInputStream paramDefiniteLengthInputStream) throws IOException {
    if (paramDefiniteLengthInputStream.getRemaining() < 1)
      return new ASN1EncodableVector(0); 
    ASN1InputStream aSN1InputStream = new ASN1InputStream(paramDefiniteLengthInputStream);
    ASN1EncodableVector aSN1EncodableVector = new ASN1EncodableVector();
    ASN1Primitive aSN1Primitive;
    while ((aSN1Primitive = aSN1InputStream.readObject()) != null)
      aSN1EncodableVector.add(aSN1Primitive); 
    return aSN1EncodableVector;
  }
  
  public ASN1Primitive readObject() throws IOException {
    int i = read();
    if (i <= 0) {
      if (i == 0)
        throw new IOException("unexpected end-of-contents marker"); 
      return null;
    } 
    int j = readTagNumber(this, i);
    boolean bool = ((i & 0x20) != 0) ? 1 : 0;
    int k = readLength();
    if (k < 0) {
      if (!bool)
        throw new IOException("indefinite-length primitive encoding encountered"); 
      IndefiniteLengthInputStream indefiniteLengthInputStream = new IndefiniteLengthInputStream(this, this.limit);
      ASN1StreamParser aSN1StreamParser = new ASN1StreamParser(indefiniteLengthInputStream, this.limit);
      if ((i & 0xC0) == 192)
        return (new BERPrivateParser(j, aSN1StreamParser)).getLoadedObject(); 
      if ((i & 0x40) != 0)
        return (new BERApplicationSpecificParser(j, aSN1StreamParser)).getLoadedObject(); 
      if ((i & 0x80) != 0)
        return (new BERTaggedObjectParser(true, j, aSN1StreamParser)).getLoadedObject(); 
      switch (j) {
        case 4:
          return (new BEROctetStringParser(aSN1StreamParser)).getLoadedObject();
        case 16:
          return (new BERSequenceParser(aSN1StreamParser)).getLoadedObject();
        case 17:
          return (new BERSetParser(aSN1StreamParser)).getLoadedObject();
        case 8:
          return (new DERExternalParser(aSN1StreamParser)).getLoadedObject();
      } 
      throw new IOException("unknown BER object encountered");
    } 
    try {
      return buildObject(i, j, k);
    } catch (IllegalArgumentException illegalArgumentException) {
      throw new ASN1Exception("corrupted stream detected", illegalArgumentException);
    } 
  }
  
  static int readTagNumber(InputStream paramInputStream, int paramInt) throws IOException {
    int i = paramInt & 0x1F;
    if (i == 31) {
      i = 0;
      int j = paramInputStream.read();
      if ((j & 0x7F) == 0)
        throw new IOException("corrupted stream - invalid high tag number found"); 
      while (j >= 0 && (j & 0x80) != 0) {
        i |= j & 0x7F;
        i <<= 7;
        j = paramInputStream.read();
      } 
      if (j < 0)
        throw new EOFException("EOF found inside tag value."); 
      i |= j & 0x7F;
    } 
    return i;
  }
  
  static int readLength(InputStream paramInputStream, int paramInt, boolean paramBoolean) throws IOException {
    int i = paramInputStream.read();
    if (i < 0)
      throw new EOFException("EOF found when length expected"); 
    if (i == 128)
      return -1; 
    if (i > 127) {
      int j = i & 0x7F;
      if (j > 4)
        throw new IOException("DER length more than 4 bytes: " + j); 
      i = 0;
      for (byte b = 0; b < j; b++) {
        int k = paramInputStream.read();
        if (k < 0)
          throw new EOFException("EOF found reading length"); 
        i = (i << 8) + k;
      } 
      if (i < 0)
        throw new IOException("corrupted stream - negative length found"); 
      if (i >= paramInt && !paramBoolean)
        throw new IOException("corrupted stream - out of bounds length found: " + i + " >= " + paramInt); 
    } 
    return i;
  }
  
  private static byte[] getBuffer(DefiniteLengthInputStream paramDefiniteLengthInputStream, byte[][] paramArrayOfByte) throws IOException {
    int i = paramDefiniteLengthInputStream.getRemaining();
    if (i >= paramArrayOfByte.length)
      return paramDefiniteLengthInputStream.toByteArray(); 
    byte[] arrayOfByte = paramArrayOfByte[i];
    if (arrayOfByte == null)
      arrayOfByte = paramArrayOfByte[i] = new byte[i]; 
    paramDefiniteLengthInputStream.readAllIntoByteArray(arrayOfByte);
    return arrayOfByte;
  }
  
  private static char[] getBMPCharBuffer(DefiniteLengthInputStream paramDefiniteLengthInputStream) throws IOException {
    int i = paramDefiniteLengthInputStream.getRemaining();
    if (0 != (i & true))
      throw new IOException("malformed BMPString encoding encountered"); 
    char[] arrayOfChar = new char[i / 2];
    byte b = 0;
    byte[] arrayOfByte = new byte[8];
    while (i >= 8) {
      if (Streams.readFully(paramDefiniteLengthInputStream, arrayOfByte, 0, 8) != 8)
        throw new EOFException("EOF encountered in middle of BMPString"); 
      arrayOfChar[b] = (char)(arrayOfByte[0] << 8 | arrayOfByte[1] & 0xFF);
      arrayOfChar[b + true] = (char)(arrayOfByte[2] << 8 | arrayOfByte[3] & 0xFF);
      arrayOfChar[b + 2] = (char)(arrayOfByte[4] << 8 | arrayOfByte[5] & 0xFF);
      arrayOfChar[b + 3] = (char)(arrayOfByte[6] << 8 | arrayOfByte[7] & 0xFF);
      b += true;
      i -= 8;
    } 
    if (i > 0) {
      if (Streams.readFully(paramDefiniteLengthInputStream, arrayOfByte, 0, i) != i)
        throw new EOFException("EOF encountered in middle of BMPString"); 
      byte b1 = 0;
      do {
        byte b2 = arrayOfByte[b1++] << 8;
        byte b3 = arrayOfByte[b1++] & 0xFF;
        arrayOfChar[b++] = (char)(b2 | b3);
      } while (b1 < i);
    } 
    if (0 != paramDefiniteLengthInputStream.getRemaining() || arrayOfChar.length != b)
      throw new IllegalStateException(); 
    return arrayOfChar;
  }
  
  static ASN1Primitive createPrimitiveDERObject(int paramInt, DefiniteLengthInputStream paramDefiniteLengthInputStream, byte[][] paramArrayOfByte) throws IOException {
    switch (paramInt) {
      case 3:
        return ASN1BitString.fromInputStream(paramDefiniteLengthInputStream.getRemaining(), paramDefiniteLengthInputStream);
      case 30:
        return new DERBMPString(getBMPCharBuffer(paramDefiniteLengthInputStream));
      case 1:
        return ASN1Boolean.fromOctetString(getBuffer(paramDefiniteLengthInputStream, paramArrayOfByte));
      case 10:
        return ASN1Enumerated.fromOctetString(getBuffer(paramDefiniteLengthInputStream, paramArrayOfByte));
      case 24:
        return new ASN1GeneralizedTime(paramDefiniteLengthInputStream.toByteArray());
      case 27:
        return new DERGeneralString(paramDefiniteLengthInputStream.toByteArray());
      case 22:
        return new DERIA5String(paramDefiniteLengthInputStream.toByteArray());
      case 2:
        return new ASN1Integer(paramDefiniteLengthInputStream.toByteArray(), false);
      case 5:
        return DERNull.INSTANCE;
      case 18:
        return new DERNumericString(paramDefiniteLengthInputStream.toByteArray());
      case 6:
        return ASN1ObjectIdentifier.fromOctetString(getBuffer(paramDefiniteLengthInputStream, paramArrayOfByte));
      case 4:
        return new DEROctetString(paramDefiniteLengthInputStream.toByteArray());
      case 19:
        return new DERPrintableString(paramDefiniteLengthInputStream.toByteArray());
      case 20:
        return new DERT61String(paramDefiniteLengthInputStream.toByteArray());
      case 28:
        return new DERUniversalString(paramDefiniteLengthInputStream.toByteArray());
      case 23:
        return new ASN1UTCTime(paramDefiniteLengthInputStream.toByteArray());
      case 12:
        return new DERUTF8String(paramDefiniteLengthInputStream.toByteArray());
      case 26:
        return new DERVisibleString(paramDefiniteLengthInputStream.toByteArray());
      case 25:
        return new DERGraphicString(paramDefiniteLengthInputStream.toByteArray());
      case 21:
        return new DERVideotexString(paramDefiniteLengthInputStream.toByteArray());
    } 
    throw new IOException("unknown tag " + paramInt + " encountered");
  }
}
