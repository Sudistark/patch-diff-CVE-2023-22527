package META-INF.versions.9.org.bouncycastle.asn1;

import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import org.bouncycastle.asn1.ASN1BitString;
import org.bouncycastle.asn1.ASN1OutputStream;
import org.bouncycastle.asn1.ASN1ParsingException;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.ASN1String;
import org.bouncycastle.asn1.DERBitString;
import org.bouncycastle.asn1.DLBitString;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.io.Streams;

public abstract class ASN1BitString extends ASN1Primitive implements ASN1String {
  private static final char[] table = { 
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
      'A', 'B', 'C', 'D', 'E', 'F' };
  
  protected final byte[] data;
  
  protected final int padBits;
  
  protected static int getPadBits(int paramInt) {
    int i = 0;
    byte b;
    for (b = 3; b >= 0; b--) {
      if (b != 0) {
        if (paramInt >> b * 8 != 0) {
          i = paramInt >> b * 8 & 0xFF;
          break;
        } 
      } else if (paramInt != 0) {
        i = paramInt & 0xFF;
        break;
      } 
    } 
    if (i == 0)
      return 0; 
    b = 1;
    while ((i <<= 1 & 0xFF) != 0)
      b++; 
    return 8 - b;
  }
  
  protected static byte[] getBytes(int paramInt) {
    if (paramInt == 0)
      return new byte[0]; 
    byte b1 = 4;
    for (byte b2 = 3; b2 >= 1; b2--) {
      if ((paramInt & 'Ã¿' << b2 * 8) != 0)
        break; 
      b1--;
    } 
    byte[] arrayOfByte = new byte[b1];
    for (byte b3 = 0; b3 < b1; b3++)
      arrayOfByte[b3] = (byte)(paramInt >> b3 * 8 & 0xFF); 
    return arrayOfByte;
  }
  
  protected ASN1BitString(byte paramByte, int paramInt) {
    if (paramInt > 7 || paramInt < 0)
      throw new IllegalArgumentException("pad bits cannot be greater than 7 or less than 0"); 
    this.data = new byte[] { paramByte };
    this.padBits = paramInt;
  }
  
  public ASN1BitString(byte[] paramArrayOfByte, int paramInt) {
    if (paramArrayOfByte == null)
      throw new NullPointerException("'data' cannot be null"); 
    if (paramArrayOfByte.length == 0 && paramInt != 0)
      throw new IllegalArgumentException("zero length data with non-zero pad bits"); 
    if (paramInt > 7 || paramInt < 0)
      throw new IllegalArgumentException("pad bits cannot be greater than 7 or less than 0"); 
    this.data = Arrays.clone(paramArrayOfByte);
    this.padBits = paramInt;
  }
  
  public String getString() {
    byte[] arrayOfByte;
    StringBuffer stringBuffer = new StringBuffer("#");
    try {
      arrayOfByte = getEncoded();
    } catch (IOException iOException) {
      throw new ASN1ParsingException("Internal error encoding BitString: " + iOException.getMessage(), iOException);
    } 
    for (byte b = 0; b != arrayOfByte.length; b++) {
      stringBuffer.append(table[arrayOfByte[b] >>> 4 & 0xF]);
      stringBuffer.append(table[arrayOfByte[b] & 0xF]);
    } 
    return stringBuffer.toString();
  }
  
  public int intValue() {
    int i = 0;
    int j = Math.min(4, this.data.length - 1);
    byte b;
    for (b = 0; b < j; b++)
      i |= (this.data[b] & 0xFF) << 8 * b; 
    if (0 <= j && j < 4) {
      b = (byte)(this.data[j] & 255 << this.padBits);
      i |= (b & 0xFF) << 8 * j;
    } 
    return i;
  }
  
  public byte[] getOctets() {
    if (this.padBits != 0)
      throw new IllegalStateException("attempt to get non-octet aligned data from BIT STRING"); 
    return Arrays.clone(this.data);
  }
  
  public byte[] getBytes() {
    if (0 == this.data.length)
      return this.data; 
    byte[] arrayOfByte = Arrays.clone(this.data);
    arrayOfByte[this.data.length - 1] = (byte)(arrayOfByte[this.data.length - 1] & 255 << this.padBits);
    return arrayOfByte;
  }
  
  public int getPadBits() { return this.padBits; }
  
  public String toString() { return getString(); }
  
  public int hashCode() {
    int i = this.data.length;
    if (--i < 0)
      return 1; 
    byte b = (byte)(this.data[i] & 255 << this.padBits);
    int j = Arrays.hashCode(this.data, 0, i);
    j *= 257;
    j ^= b;
    return j ^ this.padBits;
  }
  
  boolean asn1Equals(ASN1Primitive paramASN1Primitive) {
    if (!(paramASN1Primitive instanceof ASN1BitString))
      return false; 
    ASN1BitString aSN1BitString = (ASN1BitString)paramASN1Primitive;
    if (this.padBits != aSN1BitString.padBits)
      return false; 
    byte[] arrayOfByte1 = this.data, arrayOfByte2 = aSN1BitString.data;
    int i = arrayOfByte1.length;
    if (i != arrayOfByte2.length)
      return false; 
    if (--i < 0)
      return true; 
    byte b;
    for (b = 0; b < i; b++) {
      if (arrayOfByte1[b] != arrayOfByte2[b])
        return false; 
    } 
    b = (byte)(arrayOfByte1[i] & 255 << this.padBits);
    byte b1 = (byte)(arrayOfByte2[i] & 255 << this.padBits);
    return (b == b1);
  }
  
  static ASN1BitString fromInputStream(int paramInt, InputStream paramInputStream) throws IOException {
    if (paramInt < 1)
      throw new IllegalArgumentException("truncated BIT STRING detected"); 
    int i = paramInputStream.read();
    byte[] arrayOfByte = new byte[paramInt - 1];
    if (arrayOfByte.length != 0) {
      if (Streams.readFully(paramInputStream, arrayOfByte) != arrayOfByte.length)
        throw new EOFException("EOF encountered in middle of BIT STRING"); 
      if (i > 0 && i < 8)
        if (arrayOfByte[arrayOfByte.length - 1] != (byte)(arrayOfByte[arrayOfByte.length - 1] & 255 << i))
          return new DLBitString(arrayOfByte, i);  
    } 
    return new DERBitString(arrayOfByte, i);
  }
  
  public ASN1Primitive getLoadedObject() { return toASN1Primitive(); }
  
  ASN1Primitive toDERObject() { return new DERBitString(this.data, this.padBits); }
  
  ASN1Primitive toDLObject() { return new DLBitString(this.data, this.padBits); }
  
  abstract void encode(ASN1OutputStream paramASN1OutputStream, boolean paramBoolean) throws IOException;
}
