package META-INF.versions.9.org.bouncycastle.util;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.security.AccessController;
import java.util.Vector;
import org.bouncycastle.util.StringList;
import org.bouncycastle.util.Strings;
import org.bouncycastle.util.encoders.UTF8;

public final class Strings {
  private static String LINE_SEPARATOR;
  
  static  {
    try {
      LINE_SEPARATOR = (String)AccessController.doPrivileged(new Object());
    } catch (Exception exception) {
      try {
        LINE_SEPARATOR = String.format("%n", new Object[0]);
      } catch (Exception exception1) {
        LINE_SEPARATOR = "\n";
      } 
    } 
  }
  
  public static String fromUTF8ByteArray(byte[] paramArrayOfByte) {
    char[] arrayOfChar = new char[paramArrayOfByte.length];
    int i = UTF8.transcodeToUTF16(paramArrayOfByte, arrayOfChar);
    if (i < 0)
      throw new IllegalArgumentException("Invalid UTF-8 input"); 
    return new String(arrayOfChar, 0, i);
  }
  
  public static byte[] toUTF8ByteArray(String paramString) { return toUTF8ByteArray(paramString.toCharArray()); }
  
  public static byte[] toUTF8ByteArray(char[] paramArrayOfChar) {
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
    try {
      toUTF8ByteArray(paramArrayOfChar, byteArrayOutputStream);
    } catch (IOException iOException) {
      throw new IllegalStateException("cannot encode string to byte array!");
    } 
    return byteArrayOutputStream.toByteArray();
  }
  
  public static void toUTF8ByteArray(char[] paramArrayOfChar, OutputStream paramOutputStream) throws IOException {
    char[] arrayOfChar = paramArrayOfChar;
    byte b = 0;
    while (b < arrayOfChar.length) {
      char c = arrayOfChar[b];
      if (c < '') {
        paramOutputStream.write(c);
      } else if (c < 'ࠀ') {
        paramOutputStream.write(0xC0 | c >> '\006');
        paramOutputStream.write(0x80 | c & 0x3F);
      } else if (c >= '?' && c <= '?') {
        if (b + true >= arrayOfChar.length)
          throw new IllegalStateException("invalid UTF-16 codepoint"); 
        char c1 = c;
        c = arrayOfChar[++b];
        char c2 = c;
        if (c1 > '?')
          throw new IllegalStateException("invalid UTF-16 codepoint"); 
        int i = ((c1 & 0x3FF) << '\n' | c2 & 0x3FF) + 65536;
        paramOutputStream.write(0xF0 | i >> 18);
        paramOutputStream.write(0x80 | i >> 12 & 0x3F);
        paramOutputStream.write(0x80 | i >> 6 & 0x3F);
        paramOutputStream.write(0x80 | i & 0x3F);
      } else {
        paramOutputStream.write(0xE0 | c >> '\f');
        paramOutputStream.write(0x80 | c >> '\006' & 0x3F);
        paramOutputStream.write(0x80 | c & 0x3F);
      } 
      b++;
    } 
  }
  
  public static String toUpperCase(String paramString) {
    boolean bool = false;
    char[] arrayOfChar = paramString.toCharArray();
    for (byte b = 0; b != arrayOfChar.length; b++) {
      char c = arrayOfChar[b];
      if ('a' <= c && 'z' >= c) {
        bool = true;
        arrayOfChar[b] = (char)(c - 'a' + 'A');
      } 
    } 
    if (bool)
      return new String(arrayOfChar); 
    return paramString;
  }
  
  public static String toLowerCase(String paramString) {
    boolean bool = false;
    char[] arrayOfChar = paramString.toCharArray();
    for (byte b = 0; b != arrayOfChar.length; b++) {
      char c = arrayOfChar[b];
      if ('A' <= c && 'Z' >= c) {
        bool = true;
        arrayOfChar[b] = (char)(c - 'A' + 'a');
      } 
    } 
    if (bool)
      return new String(arrayOfChar); 
    return paramString;
  }
  
  public static byte[] toByteArray(char[] paramArrayOfChar) {
    byte[] arrayOfByte = new byte[paramArrayOfChar.length];
    for (byte b = 0; b != arrayOfByte.length; b++)
      arrayOfByte[b] = (byte)paramArrayOfChar[b]; 
    return arrayOfByte;
  }
  
  public static byte[] toByteArray(String paramString) {
    byte[] arrayOfByte = new byte[paramString.length()];
    for (byte b = 0; b != arrayOfByte.length; b++) {
      char c = paramString.charAt(b);
      arrayOfByte[b] = (byte)c;
    } 
    return arrayOfByte;
  }
  
  public static int toByteArray(String paramString, byte[] paramArrayOfByte, int paramInt) {
    int i = paramString.length();
    for (int j = 0; j < i; j++) {
      char c = paramString.charAt(j);
      paramArrayOfByte[paramInt + j] = (byte)c;
    } 
    return i;
  }
  
  public static boolean constantTimeAreEqual(String paramString1, String paramString2) {
    boolean bool = (paramString1.length() == paramString2.length());
    int i = paramString1.length();
    for (byte b = 0; b != i; b++)
      bool &= ((paramString1.charAt(b) == paramString2.charAt(b)) ? 1 : 0); 
    return bool;
  }
  
  public static String fromByteArray(byte[] paramArrayOfByte) { return new String(asCharArray(paramArrayOfByte)); }
  
  public static char[] asCharArray(byte[] paramArrayOfByte) {
    char[] arrayOfChar = new char[paramArrayOfByte.length];
    for (byte b = 0; b != arrayOfChar.length; b++)
      arrayOfChar[b] = (char)(paramArrayOfByte[b] & 0xFF); 
    return arrayOfChar;
  }
  
  public static String[] split(String paramString, char paramChar) {
    Vector vector = new Vector();
    boolean bool = true;
    while (bool) {
      int i = paramString.indexOf(paramChar);
      if (i > 0) {
        String str = paramString.substring(0, i);
        vector.addElement(str);
        paramString = paramString.substring(i + 1);
        continue;
      } 
      bool = false;
      vector.addElement(paramString);
    } 
    String[] arrayOfString = new String[vector.size()];
    for (byte b = 0; b != arrayOfString.length; b++)
      arrayOfString[b] = (String)vector.elementAt(b); 
    return arrayOfString;
  }
  
  public static StringList newList() { return new StringListImpl(null); }
  
  public static String lineSeparator() { return LINE_SEPARATOR; }
}
