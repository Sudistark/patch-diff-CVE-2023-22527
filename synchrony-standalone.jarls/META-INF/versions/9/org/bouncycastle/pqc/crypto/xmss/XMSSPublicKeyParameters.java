package META-INF.versions.9.org.bouncycastle.pqc.crypto.xmss;

import java.io.IOException;
import org.bouncycastle.pqc.crypto.xmss.XMSSKeyParameters;
import org.bouncycastle.pqc.crypto.xmss.XMSSParameters;
import org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters;
import org.bouncycastle.pqc.crypto.xmss.XMSSStoreableObjectInterface;
import org.bouncycastle.pqc.crypto.xmss.XMSSUtil;
import org.bouncycastle.util.Encodable;
import org.bouncycastle.util.Pack;

public final class XMSSPublicKeyParameters extends XMSSKeyParameters implements XMSSStoreableObjectInterface, Encodable {
  private final XMSSParameters params;
  
  private final int oid;
  
  private final byte[] root;
  
  private final byte[] publicSeed;
  
  private XMSSPublicKeyParameters(Builder paramBuilder) {
    super(false, Builder.access$000(paramBuilder).getTreeDigest());
    this.params = Builder.access$000(paramBuilder);
    if (this.params == null)
      throw new NullPointerException("params == null"); 
    int i = this.params.getTreeDigestSize();
    byte[] arrayOfByte = Builder.access$100(paramBuilder);
    if (arrayOfByte != null) {
      int j = 4;
      int k = i;
      int m = i;
      int n = 0;
      if (arrayOfByte.length == k + m) {
        this.oid = 0;
        this.root = XMSSUtil.extractBytesAtOffset(arrayOfByte, n, k);
        n += k;
        this.publicSeed = XMSSUtil.extractBytesAtOffset(arrayOfByte, n, m);
      } else if (arrayOfByte.length == j + k + m) {
        this.oid = Pack.bigEndianToInt(arrayOfByte, 0);
        n += j;
        this.root = XMSSUtil.extractBytesAtOffset(arrayOfByte, n, k);
        n += k;
        this.publicSeed = XMSSUtil.extractBytesAtOffset(arrayOfByte, n, m);
      } else {
        throw new IllegalArgumentException("public key has wrong size");
      } 
    } else {
      if (this.params.getOid() != null) {
        this.oid = this.params.getOid().getOid();
      } else {
        this.oid = 0;
      } 
      byte[] arrayOfByte1 = Builder.access$200(paramBuilder);
      if (arrayOfByte1 != null) {
        if (arrayOfByte1.length != i)
          throw new IllegalArgumentException("length of root must be equal to length of digest"); 
        this.root = arrayOfByte1;
      } else {
        this.root = new byte[i];
      } 
      byte[] arrayOfByte2 = Builder.access$300(paramBuilder);
      if (arrayOfByte2 != null) {
        if (arrayOfByte2.length != i)
          throw new IllegalArgumentException("length of publicSeed must be equal to length of digest"); 
        this.publicSeed = arrayOfByte2;
      } else {
        this.publicSeed = new byte[i];
      } 
    } 
  }
  
  public byte[] getEncoded() throws IOException { return toByteArray(); }
  
  public byte[] toByteArray() throws IOException {
    byte[] arrayOfByte;
    int i = this.params.getTreeDigestSize();
    int j = 4;
    int k = i;
    int m = i;
    int n = 0;
    if (this.oid != 0) {
      arrayOfByte = new byte[j + k + m];
      Pack.intToBigEndian(this.oid, arrayOfByte, n);
      n += j;
    } else {
      arrayOfByte = new byte[k + m];
    } 
    XMSSUtil.copyBytesAtOffset(arrayOfByte, this.root, n);
    n += k;
    XMSSUtil.copyBytesAtOffset(arrayOfByte, this.publicSeed, n);
    return arrayOfByte;
  }
  
  public byte[] getRoot() throws IOException { return XMSSUtil.cloneArray(this.root); }
  
  public byte[] getPublicSeed() throws IOException { return XMSSUtil.cloneArray(this.publicSeed); }
  
  public XMSSParameters getParameters() { return this.params; }
}
