package META-INF.versions.9.org.bouncycastle.pqc.math.linearalgebra;

import java.security.SecureRandom;
import org.bouncycastle.pqc.math.linearalgebra.GF2Matrix;
import org.bouncycastle.pqc.math.linearalgebra.GF2Vector;
import org.bouncycastle.pqc.math.linearalgebra.GF2mField;
import org.bouncycastle.pqc.math.linearalgebra.GoppaCode;
import org.bouncycastle.pqc.math.linearalgebra.Permutation;
import org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM;

public final class GoppaCode {
  public static GF2Matrix createCanonicalCheckMatrix(GF2mField paramGF2mField, PolynomialGF2mSmallM paramPolynomialGF2mSmallM) {
    int i = paramGF2mField.getDegree();
    int j = 1 << i;
    int k = paramPolynomialGF2mSmallM.getDegree();
    int[][] arrayOfInt1 = new int[k][j];
    int[][] arrayOfInt2 = new int[k][j];
    int m;
    for (m = 0; m < j; m++)
      arrayOfInt2[0][m] = paramGF2mField.inverse(paramPolynomialGF2mSmallM.evaluateAt(m)); 
    for (m = 1; m < k; m++) {
      for (byte b1 = 0; b1 < j; b1++)
        arrayOfInt2[m][b1] = paramGF2mField.mult(arrayOfInt2[m - 1][b1], b1); 
    } 
    for (m = 0; m < k; m++) {
      for (byte b1 = 0; b1 < j; b1++) {
        for (int n = 0; n <= m; n++)
          arrayOfInt1[m][b1] = paramGF2mField.add(arrayOfInt1[m][b1], paramGF2mField.mult(arrayOfInt2[n][b1], paramPolynomialGF2mSmallM
                .getCoefficient(k + n - m))); 
      } 
    } 
    int[][] arrayOfInt3 = new int[k * i][j + 31 >>> 5];
    for (byte b = 0; b < j; b++) {
      byte b1 = b >>> 5;
      int n = 1 << (b & 0x1F);
      for (byte b2 = 0; b2 < k; b2++) {
        int i1 = arrayOfInt1[b2][b];
        for (int i2 = 0; i2 < i; i2++) {
          int i3 = i1 >>> i2 & true;
          if (i3 != 0) {
            int i4 = (b2 + true) * i - i2 - 1;
            arrayOfInt3[i4][b1] = arrayOfInt3[i4][b1] ^ n;
          } 
        } 
      } 
    } 
    return new GF2Matrix(j, arrayOfInt3);
  }
  
  public static MaMaPe computeSystematicForm(GF2Matrix paramGF2Matrix, SecureRandom paramSecureRandom) {
    Permutation permutation;
    GF2Matrix gF2Matrix2, gF2Matrix1;
    int i = paramGF2Matrix.getNumColumns();
    GF2Matrix gF2Matrix3 = null;
    boolean bool = false;
    do {
      permutation = new Permutation(i, paramSecureRandom);
      gF2Matrix1 = (GF2Matrix)paramGF2Matrix.rightMultiply(permutation);
      gF2Matrix2 = gF2Matrix1.getLeftSubMatrix();
      try {
        bool = true;
        gF2Matrix3 = (GF2Matrix)gF2Matrix2.computeInverse();
      } catch (ArithmeticException arithmeticException) {
        bool = false;
      } 
    } while (!bool);
    GF2Matrix gF2Matrix4 = (GF2Matrix)gF2Matrix3.rightMultiply(gF2Matrix1);
    GF2Matrix gF2Matrix5 = gF2Matrix4.getRightSubMatrix();
    return new MaMaPe(gF2Matrix2, gF2Matrix5, permutation);
  }
  
  public static GF2Vector syndromeDecode(GF2Vector paramGF2Vector, GF2mField paramGF2mField, PolynomialGF2mSmallM paramPolynomialGF2mSmallM, PolynomialGF2mSmallM[] paramArrayOfPolynomialGF2mSmallM) {
    int i = 1 << paramGF2mField.getDegree();
    GF2Vector gF2Vector = new GF2Vector(i);
    if (!paramGF2Vector.isZero()) {
      PolynomialGF2mSmallM polynomialGF2mSmallM1 = new PolynomialGF2mSmallM(paramGF2Vector.toExtensionFieldVector(paramGF2mField));
      PolynomialGF2mSmallM polynomialGF2mSmallM2 = polynomialGF2mSmallM1.modInverse(paramPolynomialGF2mSmallM);
      PolynomialGF2mSmallM polynomialGF2mSmallM3 = polynomialGF2mSmallM2.addMonomial(1);
      polynomialGF2mSmallM3 = polynomialGF2mSmallM3.modSquareRootMatrix(paramArrayOfPolynomialGF2mSmallM);
      PolynomialGF2mSmallM[] arrayOfPolynomialGF2mSmallM = polynomialGF2mSmallM3.modPolynomialToFracton(paramPolynomialGF2mSmallM);
      PolynomialGF2mSmallM polynomialGF2mSmallM4 = arrayOfPolynomialGF2mSmallM[0].multiply(arrayOfPolynomialGF2mSmallM[0]);
      PolynomialGF2mSmallM polynomialGF2mSmallM5 = arrayOfPolynomialGF2mSmallM[1].multiply(arrayOfPolynomialGF2mSmallM[1]);
      PolynomialGF2mSmallM polynomialGF2mSmallM6 = polynomialGF2mSmallM5.multWithMonomial(1);
      PolynomialGF2mSmallM polynomialGF2mSmallM7 = polynomialGF2mSmallM4.add(polynomialGF2mSmallM6);
      int j = polynomialGF2mSmallM7.getHeadCoefficient();
      int k = paramGF2mField.inverse(j);
      PolynomialGF2mSmallM polynomialGF2mSmallM8 = polynomialGF2mSmallM7.multWithElement(k);
      for (byte b = 0; b < i; b++) {
        int m = polynomialGF2mSmallM8.evaluateAt(b);
        if (m == 0)
          gF2Vector.setBit(b); 
      } 
    } 
    return gF2Vector;
  }
}
