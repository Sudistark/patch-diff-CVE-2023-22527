package clj_commons.byte_streams.graph;

import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.Numbers;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Util;

public final class Conversion implements IType {
  public final Object f;
  
  public final double cost;
  
  public Conversion(Object paramObject, double paramDouble) { this.f = paramObject;
    this.cost = paramDouble; }
  
  public static IPersistentVector getBasis() { return Tuple.create(Symbol.intern(null, "f"), ((IObj)Symbol.intern(null, "cost")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "double") }))); }
  
  public int hashCode() { return RT.intCast(System.identityHashCode(this.f) ^ (int)this.cost); }
  
  public boolean equals(Object x) {
    boolean and__5514__auto__26562 = x instanceof Conversion;
    boolean and__5514__auto__26561 = Util.identical(this.f, ((Conversion)x).f);
    x = null;
    return and__5514__auto__26562 ? (and__5514__auto__26561 ? Numbers.equiv(this.cost, ((Conversion)x).cost) : and__5514__auto__26561) : and__5514__auto__26562;
  }
  
  static  {
  
  }
}
