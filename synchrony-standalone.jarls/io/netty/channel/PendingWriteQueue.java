package io.netty.channel;

import io.netty.util.ReferenceCountUtil;
import io.netty.util.concurrent.EventExecutor;
import io.netty.util.concurrent.PromiseCombiner;
import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.SystemPropertyUtil;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;

public final class PendingWriteQueue {
  private static final InternalLogger logger = InternalLoggerFactory.getInstance(PendingWriteQueue.class);
  
  private static final int PENDING_WRITE_OVERHEAD = SystemPropertyUtil.getInt("io.netty.transport.pendingWriteSizeOverhead", 64);
  
  private final ChannelOutboundInvoker invoker;
  
  private final EventExecutor executor;
  
  private final PendingBytesTracker tracker;
  
  private PendingWrite head;
  
  private PendingWrite tail;
  
  private int size;
  
  private long bytes;
  
  public PendingWriteQueue(ChannelHandlerContext ctx) {
    this.tracker = PendingBytesTracker.newTracker(ctx.channel());
    this.invoker = ctx;
    this.executor = ctx.executor();
  }
  
  public PendingWriteQueue(Channel channel) {
    this.tracker = PendingBytesTracker.newTracker(channel);
    this.invoker = channel;
    this.executor = channel.eventLoop();
  }
  
  public boolean isEmpty() {
    assert this.executor.inEventLoop();
    return (this.head == null);
  }
  
  public int size() {
    assert this.executor.inEventLoop();
    return this.size;
  }
  
  public long bytes() {
    assert this.executor.inEventLoop();
    return this.bytes;
  }
  
  private int size(Object msg) {
    int messageSize = this.tracker.size(msg);
    if (messageSize < 0)
      messageSize = 0; 
    return messageSize + PENDING_WRITE_OVERHEAD;
  }
  
  public void add(Object msg, ChannelPromise promise) {
    assert this.executor.inEventLoop();
    ObjectUtil.checkNotNull(msg, "msg");
    ObjectUtil.checkNotNull(promise, "promise");
    int messageSize = size(msg);
    PendingWrite write = PendingWrite.newInstance(msg, messageSize, promise);
    PendingWrite currentTail = this.tail;
    if (currentTail == null) {
      this.tail = this.head = write;
    } else {
      PendingWrite.access$002(currentTail, write);
      this.tail = write;
    } 
    this.size++;
    this.bytes += messageSize;
    this.tracker.incrementPendingOutboundBytes(PendingWrite.access$100(write));
  }
  
  public ChannelFuture removeAndWriteAll() {
    assert this.executor.inEventLoop();
    if (isEmpty())
      return null; 
    ChannelPromise p = this.invoker.newPromise();
    PromiseCombiner combiner = new PromiseCombiner(this.executor);
    try {
      for (PendingWrite write = this.head; write != null; write = this.head) {
        this.head = this.tail = null;
        this.size = 0;
        this.bytes = 0L;
        while (write != null) {
          PendingWrite next = PendingWrite.access$000(write);
          Object msg = PendingWrite.access$200(write);
          ChannelPromise promise = PendingWrite.access$300(write);
          recycle(write, false);
          if (!(promise instanceof VoidChannelPromise))
            combiner.add(promise); 
          this.invoker.write(msg, promise);
          write = next;
        } 
      } 
      combiner.finish(p);
    } catch (Throwable cause) {
      p.setFailure(cause);
    } 
    assertEmpty();
    return p;
  }
  
  public void removeAndFailAll(Throwable cause) {
    assert this.executor.inEventLoop();
    ObjectUtil.checkNotNull(cause, "cause");
    for (PendingWrite write = this.head; write != null; write = this.head) {
      this.head = this.tail = null;
      this.size = 0;
      this.bytes = 0L;
      while (write != null) {
        PendingWrite next = PendingWrite.access$000(write);
        ReferenceCountUtil.safeRelease(PendingWrite.access$200(write));
        ChannelPromise promise = PendingWrite.access$300(write);
        recycle(write, false);
        safeFail(promise, cause);
        write = next;
      } 
    } 
    assertEmpty();
  }
  
  public void removeAndFail(Throwable cause) {
    assert this.executor.inEventLoop();
    ObjectUtil.checkNotNull(cause, "cause");
    PendingWrite write = this.head;
    if (write == null)
      return; 
    ReferenceCountUtil.safeRelease(PendingWrite.access$200(write));
    ChannelPromise promise = PendingWrite.access$300(write);
    safeFail(promise, cause);
    recycle(write, true);
  }
  
  private void assertEmpty() { assert this.tail == null && this.head == null && this.size == 0; }
  
  public ChannelFuture removeAndWrite() {
    assert this.executor.inEventLoop();
    PendingWrite write = this.head;
    if (write == null)
      return null; 
    Object msg = PendingWrite.access$200(write);
    ChannelPromise promise = PendingWrite.access$300(write);
    recycle(write, true);
    return this.invoker.write(msg, promise);
  }
  
  public ChannelPromise remove() {
    assert this.executor.inEventLoop();
    PendingWrite write = this.head;
    if (write == null)
      return null; 
    ChannelPromise promise = PendingWrite.access$300(write);
    ReferenceCountUtil.safeRelease(PendingWrite.access$200(write));
    recycle(write, true);
    return promise;
  }
  
  public Object current() {
    assert this.executor.inEventLoop();
    PendingWrite write = this.head;
    if (write == null)
      return null; 
    return PendingWrite.access$200(write);
  }
  
  private void recycle(PendingWrite write, boolean update) {
    PendingWrite next = PendingWrite.access$000(write);
    long writeSize = PendingWrite.access$100(write);
    if (update)
      if (next == null) {
        this.head = this.tail = null;
        this.size = 0;
        this.bytes = 0L;
      } else {
        this.head = next;
        this.size--;
        this.bytes -= writeSize;
        assert this.size > 0 && this.bytes >= 0L;
      }  
    PendingWrite.access$400(write);
    this.tracker.decrementPendingOutboundBytes(writeSize);
  }
  
  private static void safeFail(ChannelPromise promise, Throwable cause) {
    if (!(promise instanceof VoidChannelPromise) && !promise.tryFailure(cause))
      logger.warn("Failed to mark a promise as failure because it's done already: {}", promise, cause); 
  }
}
