package io.netty.channel.oio;

import io.netty.channel.AbstractChannel;
import io.netty.channel.Channel;
import io.netty.channel.EventLoop;
import java.net.SocketAddress;

@Deprecated
public abstract class AbstractOioChannel extends AbstractChannel {
  protected static final int SO_TIMEOUT = 1000;
  
  boolean readPending;
  
  boolean readWhenInactive;
  
  final Runnable readTask = new Object(this);
  
  private final Runnable clearReadPendingRunnable = new Object(this);
  
  protected AbstractOioChannel(Channel parent) { super(parent); }
  
  protected AbstractChannel.AbstractUnsafe newUnsafe() { return new DefaultOioUnsafe(this, null); }
  
  protected boolean isCompatible(EventLoop loop) { return loop instanceof io.netty.channel.ThreadPerChannelEventLoop; }
  
  protected abstract void doConnect(SocketAddress paramSocketAddress1, SocketAddress paramSocketAddress2) throws Exception;
  
  protected void doBeginRead() throws Exception {
    if (this.readPending)
      return; 
    if (!isActive()) {
      this.readWhenInactive = true;
      return;
    } 
    this.readPending = true;
    eventLoop().execute(this.readTask);
  }
  
  protected abstract void doRead() throws Exception;
  
  @Deprecated
  protected boolean isReadPending() { return this.readPending; }
  
  @Deprecated
  protected void setReadPending(boolean readPending) {
    if (isRegistered()) {
      EventLoop eventLoop = eventLoop();
      if (eventLoop.inEventLoop()) {
        this.readPending = readPending;
      } else {
        eventLoop.execute(new Object(this, readPending));
      } 
    } else {
      this.readPending = readPending;
    } 
  }
  
  protected final void clearReadPending() throws Exception {
    if (isRegistered()) {
      EventLoop eventLoop = eventLoop();
      if (eventLoop.inEventLoop()) {
        this.readPending = false;
      } else {
        eventLoop.execute(this.clearReadPendingRunnable);
      } 
    } else {
      this.readPending = false;
    } 
  }
}
