package io.netty.channel;

import io.netty.buffer.ByteBufAllocator;
import io.netty.util.DefaultAttributeMap;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import java.io.IOException;
import java.net.SocketAddress;

public abstract class AbstractChannel extends DefaultAttributeMap implements Channel {
  private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractChannel.class);
  
  private final Channel parent;
  
  private final ChannelId id;
  
  private final Channel.Unsafe unsafe;
  
  private final DefaultChannelPipeline pipeline;
  
  private final VoidChannelPromise unsafeVoidPromise;
  
  private final CloseFuture closeFuture;
  
  private boolean closeInitiated;
  
  private Throwable initialCloseCause;
  
  private boolean strValActive;
  
  private String strVal;
  
  protected AbstractChannel(Channel parent) {
    this.unsafeVoidPromise = new VoidChannelPromise(this, false);
    this.closeFuture = new CloseFuture(this);
    this.parent = parent;
    this.id = newId();
    this.unsafe = newUnsafe();
    this.pipeline = newChannelPipeline();
  }
  
  protected AbstractChannel(Channel parent, ChannelId id) {
    this.unsafeVoidPromise = new VoidChannelPromise(this, false);
    this.closeFuture = new CloseFuture(this);
    this.parent = parent;
    this.id = id;
    this.unsafe = newUnsafe();
    this.pipeline = newChannelPipeline();
  }
  
  protected final int maxMessagesPerWrite() {
    ChannelConfig config = config();
    if (config instanceof DefaultChannelConfig)
      return ((DefaultChannelConfig)config).getMaxMessagesPerWrite(); 
    Integer value = (Integer)config.getOption(ChannelOption.MAX_MESSAGES_PER_WRITE);
    if (value == null)
      return Integer.MAX_VALUE; 
    return value.intValue();
  }
  
  public final ChannelId id() { return this.id; }
  
  protected ChannelId newId() { return DefaultChannelId.newInstance(); }
  
  protected DefaultChannelPipeline newChannelPipeline() { return new DefaultChannelPipeline(this); }
  
  public boolean isWritable() {
    ChannelOutboundBuffer buf = this.unsafe.outboundBuffer();
    return (buf != null && buf.isWritable());
  }
  
  public long bytesBeforeUnwritable() {
    ChannelOutboundBuffer buf = this.unsafe.outboundBuffer();
    return (buf != null) ? buf.bytesBeforeUnwritable() : 0L;
  }
  
  public long bytesBeforeWritable() {
    ChannelOutboundBuffer buf = this.unsafe.outboundBuffer();
    return (buf != null) ? buf.bytesBeforeWritable() : Float.MAX_VALUE;
  }
  
  public Channel parent() { return this.parent; }
  
  public ChannelPipeline pipeline() { return this.pipeline; }
  
  public ByteBufAllocator alloc() { return config().getAllocator(); }
  
  public EventLoop eventLoop() {
    EventLoop eventLoop = this.eventLoop;
    if (eventLoop == null)
      throw new IllegalStateException("channel not registered to an event loop"); 
    return eventLoop;
  }
  
  public SocketAddress localAddress() {
    SocketAddress localAddress = this.localAddress;
    if (localAddress == null)
      try {
        this.localAddress = localAddress = unsafe().localAddress();
      } catch (Error e) {
        throw e;
      } catch (Throwable t) {
        return null;
      }  
    return localAddress;
  }
  
  @Deprecated
  protected void invalidateLocalAddress() { this.localAddress = null; }
  
  public SocketAddress remoteAddress() {
    SocketAddress remoteAddress = this.remoteAddress;
    if (remoteAddress == null)
      try {
        this.remoteAddress = remoteAddress = unsafe().remoteAddress();
      } catch (Error e) {
        throw e;
      } catch (Throwable t) {
        return null;
      }  
    return remoteAddress;
  }
  
  @Deprecated
  protected void invalidateRemoteAddress() { this.remoteAddress = null; }
  
  public boolean isRegistered() { return this.registered; }
  
  public ChannelFuture bind(SocketAddress localAddress) { return this.pipeline.bind(localAddress); }
  
  public ChannelFuture connect(SocketAddress remoteAddress) { return this.pipeline.connect(remoteAddress); }
  
  public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress) { return this.pipeline.connect(remoteAddress, localAddress); }
  
  public ChannelFuture disconnect() { return this.pipeline.disconnect(); }
  
  public ChannelFuture close() { return this.pipeline.close(); }
  
  public ChannelFuture deregister() { return this.pipeline.deregister(); }
  
  public Channel flush() {
    this.pipeline.flush();
    return this;
  }
  
  public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) { return this.pipeline.bind(localAddress, promise); }
  
  public ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) { return this.pipeline.connect(remoteAddress, promise); }
  
  public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) { return this.pipeline.connect(remoteAddress, localAddress, promise); }
  
  public ChannelFuture disconnect(ChannelPromise promise) { return this.pipeline.disconnect(promise); }
  
  public ChannelFuture close(ChannelPromise promise) { return this.pipeline.close(promise); }
  
  public ChannelFuture deregister(ChannelPromise promise) { return this.pipeline.deregister(promise); }
  
  public Channel read() {
    this.pipeline.read();
    return this;
  }
  
  public ChannelFuture write(Object msg) { return this.pipeline.write(msg); }
  
  public ChannelFuture write(Object msg, ChannelPromise promise) { return this.pipeline.write(msg, promise); }
  
  public ChannelFuture writeAndFlush(Object msg) { return this.pipeline.writeAndFlush(msg); }
  
  public ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) { return this.pipeline.writeAndFlush(msg, promise); }
  
  public ChannelPromise newPromise() { return this.pipeline.newPromise(); }
  
  public ChannelProgressivePromise newProgressivePromise() { return this.pipeline.newProgressivePromise(); }
  
  public ChannelFuture newSucceededFuture() { return this.pipeline.newSucceededFuture(); }
  
  public ChannelFuture newFailedFuture(Throwable cause) { return this.pipeline.newFailedFuture(cause); }
  
  public ChannelFuture closeFuture() { return this.closeFuture; }
  
  public Channel.Unsafe unsafe() { return this.unsafe; }
  
  public final int hashCode() { return this.id.hashCode(); }
  
  public final boolean equals(Object o) { return (this == o); }
  
  public final int compareTo(Channel o) {
    if (this == o)
      return 0; 
    return id().compareTo(o.id());
  }
  
  public String toString() {
    boolean active = isActive();
    if (this.strValActive == active && this.strVal != null)
      return this.strVal; 
    SocketAddress remoteAddr = remoteAddress();
    SocketAddress localAddr = localAddress();
    if (remoteAddr != null) {
      StringBuilder buf = (new StringBuilder(96)).append("[id: 0x").append(this.id.asShortText()).append(", L:").append(localAddr).append(active ? " - " : " ! ").append("R:").append(remoteAddr).append(']');
      this.strVal = buf.toString();
    } else if (localAddr != null) {
      StringBuilder buf = (new StringBuilder(64)).append("[id: 0x").append(this.id.asShortText()).append(", L:").append(localAddr).append(']');
      this.strVal = buf.toString();
    } else {
      StringBuilder buf = (new StringBuilder(16)).append("[id: 0x").append(this.id.asShortText()).append(']');
      this.strVal = buf.toString();
    } 
    this.strValActive = active;
    return this.strVal;
  }
  
  public final ChannelPromise voidPromise() { return this.pipeline.voidPromise(); }
  
  protected void doRegister() {}
  
  protected void doShutdownOutput() { doClose(); }
  
  protected void doDeregister() {}
  
  protected Object filterOutboundMessage(Object msg) throws Exception { return msg; }
  
  protected void validateFileRegion(DefaultFileRegion region, long position) throws IOException { DefaultFileRegion.validate(region, position); }
  
  protected abstract AbstractUnsafe newUnsafe();
  
  protected abstract boolean isCompatible(EventLoop paramEventLoop);
  
  protected abstract SocketAddress localAddress0();
  
  protected abstract SocketAddress remoteAddress0();
  
  protected abstract void doBind(SocketAddress paramSocketAddress) throws Exception;
  
  protected abstract void doDisconnect();
  
  protected abstract void doClose();
  
  protected abstract void doBeginRead();
  
  protected abstract void doWrite(ChannelOutboundBuffer paramChannelOutboundBuffer) throws Exception;
}
