package io.netty.channel.embedded;

import io.netty.channel.AbstractChannel;
import io.netty.channel.Channel;
import io.netty.channel.ChannelConfig;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelId;
import io.netty.channel.ChannelMetadata;
import io.netty.channel.ChannelOutboundBuffer;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.ChannelPromise;
import io.netty.channel.DefaultChannelConfig;
import io.netty.channel.DefaultChannelPipeline;
import io.netty.channel.EventLoop;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.PlatformDependent;
import io.netty.util.internal.RecyclableArrayList;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import java.net.SocketAddress;
import java.nio.channels.ClosedChannelException;
import java.util.ArrayDeque;
import java.util.Queue;
import java.util.concurrent.TimeUnit;

public class EmbeddedChannel extends AbstractChannel {
  private static final SocketAddress LOCAL_ADDRESS = new EmbeddedSocketAddress();
  
  private static final SocketAddress REMOTE_ADDRESS = new EmbeddedSocketAddress();
  
  private static final ChannelHandler[] EMPTY_HANDLERS = new ChannelHandler[0];
  
  private static final InternalLogger logger = InternalLoggerFactory.getInstance(EmbeddedChannel.class);
  
  private static final ChannelMetadata METADATA_NO_DISCONNECT = new ChannelMetadata(false);
  
  private static final ChannelMetadata METADATA_DISCONNECT = new ChannelMetadata(true);
  
  private final EmbeddedEventLoop loop = new EmbeddedEventLoop();
  
  private final ChannelFutureListener recordExceptionListener = new Object(this);
  
  private final ChannelMetadata metadata;
  
  private final ChannelConfig config;
  
  private Queue<Object> inboundMessages;
  
  private Queue<Object> outboundMessages;
  
  private Throwable lastException;
  
  private State state;
  
  public EmbeddedChannel() { this(EMPTY_HANDLERS); }
  
  public EmbeddedChannel(ChannelId channelId) { this(channelId, EMPTY_HANDLERS); }
  
  public EmbeddedChannel(ChannelHandler... handlers) { this(EmbeddedChannelId.INSTANCE, handlers); }
  
  public EmbeddedChannel(boolean hasDisconnect, ChannelHandler... handlers) { this(EmbeddedChannelId.INSTANCE, hasDisconnect, handlers); }
  
  public EmbeddedChannel(boolean register, boolean hasDisconnect, ChannelHandler... handlers) { this(EmbeddedChannelId.INSTANCE, register, hasDisconnect, handlers); }
  
  public EmbeddedChannel(ChannelId channelId, ChannelHandler... handlers) { this(channelId, false, handlers); }
  
  public EmbeddedChannel(ChannelId channelId, boolean hasDisconnect, ChannelHandler... handlers) { this(channelId, true, hasDisconnect, handlers); }
  
  public EmbeddedChannel(ChannelId channelId, boolean register, boolean hasDisconnect, ChannelHandler... handlers) { this(null, channelId, register, hasDisconnect, handlers); }
  
  public EmbeddedChannel(Channel parent, ChannelId channelId, boolean register, boolean hasDisconnect, ChannelHandler... handlers) {
    super(parent, channelId);
    this.metadata = metadata(hasDisconnect);
    this.config = new DefaultChannelConfig(this);
    setup(register, handlers);
  }
  
  public EmbeddedChannel(ChannelId channelId, boolean hasDisconnect, ChannelConfig config, ChannelHandler... handlers) {
    super(null, channelId);
    this.metadata = metadata(hasDisconnect);
    this.config = (ChannelConfig)ObjectUtil.checkNotNull(config, "config");
    setup(true, handlers);
  }
  
  private static ChannelMetadata metadata(boolean hasDisconnect) { return hasDisconnect ? METADATA_DISCONNECT : METADATA_NO_DISCONNECT; }
  
  private void setup(boolean register, ChannelHandler... handlers) {
    ObjectUtil.checkNotNull(handlers, "handlers");
    ChannelPipeline p = pipeline();
    p.addLast(new ChannelHandler[] { new Object(this, handlers) });
    if (register) {
      ChannelFuture future = this.loop.register(this);
      assert future.isDone();
    } 
  }
  
  public void register() {
    ChannelFuture future = this.loop.register(this);
    assert future.isDone();
    Throwable cause = future.cause();
    if (cause != null)
      PlatformDependent.throwException(cause); 
  }
  
  protected final DefaultChannelPipeline newChannelPipeline() { return new EmbeddedChannelPipeline(this, this); }
  
  public ChannelMetadata metadata() { return this.metadata; }
  
  public ChannelConfig config() { return this.config; }
  
  public boolean isOpen() { return (this.state != State.CLOSED); }
  
  public boolean isActive() { return (this.state == State.ACTIVE); }
  
  public Queue<Object> inboundMessages() {
    if (this.inboundMessages == null)
      this.inboundMessages = new ArrayDeque(); 
    return this.inboundMessages;
  }
  
  @Deprecated
  public Queue<Object> lastInboundBuffer() { return inboundMessages(); }
  
  public Queue<Object> outboundMessages() {
    if (this.outboundMessages == null)
      this.outboundMessages = new ArrayDeque(); 
    return this.outboundMessages;
  }
  
  @Deprecated
  public Queue<Object> lastOutboundBuffer() { return outboundMessages(); }
  
  public <T> T readInbound() {
    T message = (T)poll(this.inboundMessages);
    if (message != null)
      ReferenceCountUtil.touch(message, "Caller of readInbound() will handle the message from this point"); 
    return message;
  }
  
  public <T> T readOutbound() {
    T message = (T)poll(this.outboundMessages);
    if (message != null)
      ReferenceCountUtil.touch(message, "Caller of readOutbound() will handle the message from this point."); 
    return message;
  }
  
  public boolean writeInbound(Object... msgs) {
    ensureOpen();
    if (msgs.length == 0)
      return isNotEmpty(this.inboundMessages); 
    ChannelPipeline p = pipeline();
    for (Object m : msgs)
      p.fireChannelRead(m); 
    flushInbound(false, voidPromise());
    return isNotEmpty(this.inboundMessages);
  }
  
  public ChannelFuture writeOneInbound(Object msg) { return writeOneInbound(msg, newPromise()); }
  
  public ChannelFuture writeOneInbound(Object msg, ChannelPromise promise) {
    if (checkOpen(true))
      pipeline().fireChannelRead(msg); 
    return checkException(promise);
  }
  
  public EmbeddedChannel flushInbound() {
    flushInbound(true, voidPromise());
    return this;
  }
  
  private ChannelFuture flushInbound(boolean recordException, ChannelPromise promise) {
    if (checkOpen(recordException)) {
      pipeline().fireChannelReadComplete();
      runPendingTasks();
    } 
    return checkException(promise);
  }
  
  public boolean writeOutbound(Object... msgs) {
    ensureOpen();
    if (msgs.length == 0)
      return isNotEmpty(this.outboundMessages); 
    futures = RecyclableArrayList.newInstance(msgs.length);
    try {
      for (Object m : msgs) {
        if (m == null)
          break; 
        futures.add(write(m));
      } 
      flushOutbound0();
      int size = futures.size();
      for (int i = 0; i < size; i++) {
        ChannelFuture future = (ChannelFuture)futures.get(i);
        if (future.isDone()) {
          recordException(future);
        } else {
          future.addListener(this.recordExceptionListener);
        } 
      } 
      checkException();
      return isNotEmpty(this.outboundMessages);
    } finally {
      futures.recycle();
    } 
  }
  
  public ChannelFuture writeOneOutbound(Object msg) { return writeOneOutbound(msg, newPromise()); }
  
  public ChannelFuture writeOneOutbound(Object msg, ChannelPromise promise) {
    if (checkOpen(true))
      return write(msg, promise); 
    return checkException(promise);
  }
  
  public EmbeddedChannel flushOutbound() {
    if (checkOpen(true))
      flushOutbound0(); 
    checkException(voidPromise());
    return this;
  }
  
  private void flushOutbound0() {
    runPendingTasks();
    flush();
  }
  
  public boolean finish() { return finish(false); }
  
  public boolean finishAndReleaseAll() { return finish(true); }
  
  private boolean finish(boolean releaseAll) {
    close();
    try {
      checkException();
      return (isNotEmpty(this.inboundMessages) || isNotEmpty(this.outboundMessages));
    } finally {
      if (releaseAll) {
        releaseAll(this.inboundMessages);
        releaseAll(this.outboundMessages);
      } 
    } 
  }
  
  public boolean releaseInbound() { return releaseAll(this.inboundMessages); }
  
  public boolean releaseOutbound() { return releaseAll(this.outboundMessages); }
  
  private static boolean releaseAll(Queue<Object> queue) {
    if (isNotEmpty(queue)) {
      while (true) {
        Object msg = queue.poll();
        if (msg == null)
          break; 
        ReferenceCountUtil.release(msg);
      } 
      return true;
    } 
    return false;
  }
  
  private void finishPendingTasks(boolean cancel) {
    runPendingTasks();
    if (cancel)
      embeddedEventLoop().cancelScheduledTasks(); 
  }
  
  public final ChannelFuture close() { return close(newPromise()); }
  
  public final ChannelFuture disconnect() { return disconnect(newPromise()); }
  
  public final ChannelFuture close(ChannelPromise promise) {
    runPendingTasks();
    ChannelFuture future = super.close(promise);
    finishPendingTasks(true);
    return future;
  }
  
  public final ChannelFuture disconnect(ChannelPromise promise) {
    ChannelFuture future = super.disconnect(promise);
    finishPendingTasks(!this.metadata.hasDisconnect());
    return future;
  }
  
  private static boolean isNotEmpty(Queue<Object> queue) { return (queue != null && !queue.isEmpty()); }
  
  private static Object poll(Queue<Object> queue) { return (queue != null) ? queue.poll() : null; }
  
  public void runPendingTasks() {
    try {
      embeddedEventLoop().runTasks();
    } catch (Exception e) {
      recordException(e);
    } 
    try {
      embeddedEventLoop().runScheduledTasks();
    } catch (Exception e) {
      recordException(e);
    } 
  }
  
  public boolean hasPendingTasks() {
    return (embeddedEventLoop().hasPendingNormalTasks() || 
      embeddedEventLoop().nextScheduledTask() == 0L);
  }
  
  public long runScheduledPendingTasks() {
    try {
      return embeddedEventLoop().runScheduledTasks();
    } catch (Exception e) {
      recordException(e);
      return embeddedEventLoop().nextScheduledTask();
    } 
  }
  
  private void recordException(ChannelFuture future) {
    if (!future.isSuccess())
      recordException(future.cause()); 
  }
  
  private void recordException(Throwable cause) {
    if (this.lastException == null) {
      this.lastException = cause;
    } else {
      logger.warn("More than one exception was raised. Will report only the first one and log others.", cause);
    } 
  }
  
  public void advanceTimeBy(long duration, TimeUnit unit) { embeddedEventLoop().advanceTimeBy(unit.toNanos(duration)); }
  
  public void freezeTime() { embeddedEventLoop().freezeTime(); }
  
  public void unfreezeTime() { embeddedEventLoop().unfreezeTime(); }
  
  private ChannelFuture checkException(ChannelPromise promise) {
    Throwable t = this.lastException;
    if (t != null) {
      this.lastException = null;
      if (promise.isVoid())
        PlatformDependent.throwException(t); 
      return promise.setFailure(t);
    } 
    return promise.setSuccess();
  }
  
  public void checkException() { checkException(voidPromise()); }
  
  private boolean checkOpen(boolean recordException) {
    if (!isOpen()) {
      if (recordException)
        recordException(new ClosedChannelException()); 
      return false;
    } 
    return true;
  }
  
  private EmbeddedEventLoop embeddedEventLoop() {
    if (isRegistered())
      return (EmbeddedEventLoop)eventLoop(); 
    return this.loop;
  }
  
  protected final void ensureOpen() {
    if (!checkOpen(true))
      checkException(); 
  }
  
  protected boolean isCompatible(EventLoop loop) { return loop instanceof EmbeddedEventLoop; }
  
  protected SocketAddress localAddress0() { return isActive() ? LOCAL_ADDRESS : null; }
  
  protected SocketAddress remoteAddress0() { return isActive() ? REMOTE_ADDRESS : null; }
  
  protected void doRegister() { this.state = State.ACTIVE; }
  
  protected void doBind(SocketAddress localAddress) throws Exception {}
  
  protected void doDisconnect() {
    if (!this.metadata.hasDisconnect())
      doClose(); 
  }
  
  protected void doClose() { this.state = State.CLOSED; }
  
  protected void doBeginRead() {}
  
  protected AbstractChannel.AbstractUnsafe newUnsafe() { return new EmbeddedUnsafe(this, null); }
  
  public Channel.Unsafe unsafe() { return ((EmbeddedUnsafe)super.unsafe()).wrapped; }
  
  protected void doWrite(ChannelOutboundBuffer in) throws Exception {
    while (true) {
      Object msg = in.current();
      if (msg == null)
        break; 
      ReferenceCountUtil.retain(msg);
      handleOutboundMessage(msg);
      in.remove();
    } 
  }
  
  protected void handleOutboundMessage(Object msg) { outboundMessages().add(msg); }
  
  protected void handleInboundMessage(Object msg) { inboundMessages().add(msg); }
}
