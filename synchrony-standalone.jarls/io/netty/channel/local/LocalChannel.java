package io.netty.channel.local;

import io.netty.buffer.ByteBuf;
import io.netty.channel.AbstractChannel;
import io.netty.channel.Channel;
import io.netty.channel.ChannelConfig;
import io.netty.channel.ChannelMetadata;
import io.netty.channel.ChannelOutboundBuffer;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.ChannelPromise;
import io.netty.channel.DefaultChannelConfig;
import io.netty.channel.EventLoop;
import io.netty.channel.PreferHeapByteBufAllocator;
import io.netty.channel.RecvByteBufAllocator;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.SingleThreadEventExecutor;
import io.netty.util.internal.InternalThreadLocalMap;
import io.netty.util.internal.PlatformDependent;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import java.net.SocketAddress;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.NotYetConnectedException;
import java.util.Queue;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

public class LocalChannel extends AbstractChannel {
  private static final InternalLogger logger = InternalLoggerFactory.getInstance(LocalChannel.class);
  
  private static final AtomicReferenceFieldUpdater<LocalChannel, Future> FINISH_READ_FUTURE_UPDATER = AtomicReferenceFieldUpdater.newUpdater(LocalChannel.class, Future.class, "finishReadFuture");
  
  private static final ChannelMetadata METADATA = new ChannelMetadata(false);
  
  private static final int MAX_READER_STACK_DEPTH = 8;
  
  private final ChannelConfig config = new DefaultChannelConfig(this);
  
  final Queue<Object> inboundBuffer = PlatformDependent.newSpscQueue();
  
  private final Runnable readTask = new Object(this);
  
  private final Runnable shutdownHook = new Object(this);
  
  public LocalChannel() {
    super(null);
    config().setAllocator(new PreferHeapByteBufAllocator(this.config.getAllocator()));
  }
  
  protected LocalChannel(LocalServerChannel parent, LocalChannel peer) {
    super(parent);
    config().setAllocator(new PreferHeapByteBufAllocator(this.config.getAllocator()));
    this.peer = peer;
    this.localAddress = parent.localAddress();
    this.remoteAddress = peer.localAddress();
  }
  
  public ChannelMetadata metadata() { return METADATA; }
  
  public ChannelConfig config() { return this.config; }
  
  public LocalServerChannel parent() { return (LocalServerChannel)super.parent(); }
  
  public LocalAddress localAddress() { return (LocalAddress)super.localAddress(); }
  
  public LocalAddress remoteAddress() { return (LocalAddress)super.remoteAddress(); }
  
  public boolean isOpen() { return (this.state != State.CLOSED); }
  
  public boolean isActive() { return (this.state == State.CONNECTED); }
  
  protected AbstractChannel.AbstractUnsafe newUnsafe() { return new LocalUnsafe(this, null); }
  
  protected boolean isCompatible(EventLoop loop) { return loop instanceof io.netty.channel.SingleThreadEventLoop; }
  
  protected SocketAddress localAddress0() { return this.localAddress; }
  
  protected SocketAddress remoteAddress0() { return this.remoteAddress; }
  
  protected void doRegister() {
    if (this.peer != null && parent() != null) {
      LocalChannel peer = this.peer;
      this.state = State.CONNECTED;
      peer.remoteAddress = (parent() == null) ? null : parent().localAddress();
      peer.state = State.CONNECTED;
      peer.eventLoop().execute(new Object(this, peer));
    } 
    ((SingleThreadEventExecutor)eventLoop()).addShutdownHook(this.shutdownHook);
  }
  
  protected void doBind(SocketAddress localAddress) throws Exception {
    this
      .localAddress = LocalChannelRegistry.register(this, this.localAddress, localAddress);
    this.state = State.BOUND;
  }
  
  protected void doDisconnect() { doClose(); }
  
  protected void doClose() {
    LocalChannel peer = this.peer;
    oldState = this.state;
    try {
      if (oldState != State.CLOSED) {
        if (this.localAddress != null) {
          if (parent() == null)
            LocalChannelRegistry.unregister(this.localAddress); 
          this.localAddress = null;
        } 
        this.state = State.CLOSED;
        if (this.writeInProgress && peer != null)
          finishPeerRead(peer); 
        ChannelPromise promise = this.connectPromise;
        if (promise != null) {
          promise.tryFailure(new ClosedChannelException());
          this.connectPromise = null;
        } 
      } 
      if (peer != null) {
        this.peer = null;
        EventLoop peerEventLoop = peer.eventLoop();
        boolean peerIsActive = peer.isActive();
        try {
          peerEventLoop.execute(new Object(this, peer, peerIsActive));
        } catch (Throwable cause) {
          logger.warn("Releasing Inbound Queues for channels {}-{} because exception occurred!", new Object[] { this, peer, cause });
          if (peerEventLoop.inEventLoop()) {
            peer.releaseInboundBuffers();
          } else {
            peer.close();
          } 
          PlatformDependent.throwException(cause);
        } 
      } 
    } finally {
      if (oldState != null && oldState != State.CLOSED)
        releaseInboundBuffers(); 
    } 
  }
  
  private void tryClose(boolean isActive) {
    if (isActive) {
      unsafe().close(unsafe().voidPromise());
    } else {
      releaseInboundBuffers();
    } 
  }
  
  protected void doDeregister() { ((SingleThreadEventExecutor)eventLoop()).removeShutdownHook(this.shutdownHook); }
  
  private void readInbound() {
    RecvByteBufAllocator.Handle handle = unsafe().recvBufAllocHandle();
    handle.reset(config());
    ChannelPipeline pipeline = pipeline();
    do {
      Object received = this.inboundBuffer.poll();
      if (received == null)
        break; 
      if (received instanceof ByteBuf && this.inboundBuffer.peek() instanceof ByteBuf) {
        ByteBuf msg = (ByteBuf)received;
        ByteBuf output = handle.allocate(alloc());
        if (msg.readableBytes() < output.writableBytes()) {
          output.writeBytes(msg, msg.readerIndex(), msg.readableBytes());
          msg.release();
          while (received = this.inboundBuffer.peek() instanceof ByteBuf && ((ByteBuf)received)
            .readableBytes() < output.writableBytes()) {
            this.inboundBuffer.poll();
            msg = (ByteBuf)received;
            output.writeBytes(msg, msg.readerIndex(), msg.readableBytes());
            msg.release();
          } 
          handle.lastBytesRead(output.readableBytes());
          received = output;
        } else {
          handle.lastBytesRead(output.capacity());
          output.release();
        } 
      } 
      handle.incMessagesRead(1);
      pipeline.fireChannelRead(received);
    } while (handle.continueReading());
    handle.readComplete();
    pipeline.fireChannelReadComplete();
  }
  
  protected void doBeginRead() {
    if (this.readInProgress)
      return; 
    Queue<Object> inboundBuffer = this.inboundBuffer;
    if (inboundBuffer.isEmpty()) {
      this.readInProgress = true;
      return;
    } 
    threadLocals = InternalThreadLocalMap.get();
    stackDepth = threadLocals.localChannelReaderStackDepth();
    if (stackDepth < 8) {
      threadLocals.setLocalChannelReaderStackDepth(stackDepth + 1);
      try {
        readInbound();
      } finally {
        threadLocals.setLocalChannelReaderStackDepth(stackDepth);
      } 
    } else {
      try {
        eventLoop().execute(this.readTask);
      } catch (Throwable cause) {
        logger.warn("Closing Local channels {}-{} because exception occurred!", new Object[] { this, this.peer, cause });
        close();
        this.peer.close();
        PlatformDependent.throwException(cause);
      } 
    } 
  }
  
  protected void doWrite(ChannelOutboundBuffer in) throws Exception {
    switch (null.$SwitchMap$io$netty$channel$local$LocalChannel$State[this.state.ordinal()]) {
      case 1:
      case 2:
        throw new NotYetConnectedException();
      case 3:
        throw new ClosedChannelException();
    } 
    LocalChannel peer = this.peer;
    this.writeInProgress = true;
    try {
      ClosedChannelException exception = null;
      while (true) {
        Object msg = in.current();
        if (msg == null)
          break; 
        try {
          if (peer.state == State.CONNECTED) {
            peer.inboundBuffer.add(ReferenceCountUtil.retain(msg));
            in.remove();
            continue;
          } 
          if (exception == null)
            exception = new ClosedChannelException(); 
          in.remove(exception);
        } catch (Throwable cause) {
          in.remove(cause);
        } 
      } 
    } finally {
      this.writeInProgress = false;
    } 
    finishPeerRead(peer);
  }
  
  private void finishPeerRead(LocalChannel peer) {
    if (peer.eventLoop() == eventLoop() && !peer.writeInProgress) {
      finishPeerRead0(peer);
    } else {
      runFinishPeerReadTask(peer);
    } 
  }
  
  private void runFinishPeerReadTask(LocalChannel peer) {
    Object object = new Object(this, peer);
    try {
      if (peer.writeInProgress) {
        peer.finishReadFuture = peer.eventLoop().submit(object);
      } else {
        peer.eventLoop().execute(object);
      } 
    } catch (Throwable cause) {
      logger.warn("Closing Local channels {}-{} because exception occurred!", new Object[] { this, peer, cause });
      close();
      peer.close();
      PlatformDependent.throwException(cause);
    } 
  }
  
  private void releaseInboundBuffers() {
    assert eventLoop() == null || eventLoop().inEventLoop();
    this.readInProgress = false;
    Queue<Object> inboundBuffer = this.inboundBuffer;
    Object msg;
    while ((msg = inboundBuffer.poll()) != null)
      ReferenceCountUtil.release(msg); 
  }
  
  private void finishPeerRead0(LocalChannel peer) {
    Future<?> peerFinishReadFuture = peer.finishReadFuture;
    if (peerFinishReadFuture != null) {
      if (!peerFinishReadFuture.isDone()) {
        runFinishPeerReadTask(peer);
        return;
      } 
      FINISH_READ_FUTURE_UPDATER.compareAndSet(peer, peerFinishReadFuture, null);
    } 
    if (peer.readInProgress && !peer.inboundBuffer.isEmpty()) {
      peer.readInProgress = false;
      peer.readInbound();
    } 
  }
}
