package io.netty.channel.group;

import io.netty.channel.Channel;

public final class ChannelMatchers {
  private static final ChannelMatcher ALL_MATCHER = new Object();
  
  private static final ChannelMatcher SERVER_CHANNEL_MATCHER = isInstanceOf(io.netty.channel.ServerChannel.class);
  
  private static final ChannelMatcher NON_SERVER_CHANNEL_MATCHER = isNotInstanceOf(io.netty.channel.ServerChannel.class);
  
  public static ChannelMatcher all() { return ALL_MATCHER; }
  
  public static ChannelMatcher isNot(Channel channel) { return invert(is(channel)); }
  
  public static ChannelMatcher is(Channel channel) { return new InstanceMatcher(channel); }
  
  public static ChannelMatcher isInstanceOf(Class<? extends Channel> clazz) { return new ClassMatcher(clazz); }
  
  public static ChannelMatcher isNotInstanceOf(Class<? extends Channel> clazz) { return invert(isInstanceOf(clazz)); }
  
  public static ChannelMatcher isServerChannel() { return SERVER_CHANNEL_MATCHER; }
  
  public static ChannelMatcher isNonServerChannel() { return NON_SERVER_CHANNEL_MATCHER; }
  
  public static ChannelMatcher invert(ChannelMatcher matcher) { return new InvertMatcher(matcher); }
  
  public static ChannelMatcher compose(ChannelMatcher... matchers) {
    if (matchers.length < 1)
      throw new IllegalArgumentException("matchers must at least contain one element"); 
    if (matchers.length == 1)
      return matchers[0]; 
    return new CompositeMatcher(matchers);
  }
}
