package io.netty.handler.timeout;

import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelOutboundHandlerAdapter;
import io.netty.channel.ChannelPromise;
import io.netty.util.internal.ObjectUtil;
import java.util.concurrent.TimeUnit;

public class WriteTimeoutHandler extends ChannelOutboundHandlerAdapter {
  private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1L);
  
  private final long timeoutNanos;
  
  private WriteTimeoutTask lastTask;
  
  private boolean closed;
  
  public WriteTimeoutHandler(int timeoutSeconds) { this(timeoutSeconds, TimeUnit.SECONDS); }
  
  public WriteTimeoutHandler(long timeout, TimeUnit unit) {
    ObjectUtil.checkNotNull(unit, "unit");
    if (timeout <= 0L) {
      this.timeoutNanos = 0L;
    } else {
      this.timeoutNanos = Math.max(unit.toNanos(timeout), MIN_TIMEOUT_NANOS);
    } 
  }
  
  public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
    if (this.timeoutNanos > 0L) {
      promise = promise.unvoid();
      scheduleTimeout(ctx, promise);
    } 
    ctx.write(msg, promise);
  }
  
  public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
    assert ctx.executor().inEventLoop();
    WriteTimeoutTask task = this.lastTask;
    this.lastTask = null;
    while (task != null) {
      assert WriteTimeoutTask.access$000(task).executor().inEventLoop();
      task.scheduledFuture.cancel(false);
      WriteTimeoutTask prev = task.prev;
      task.prev = null;
      task.next = null;
      task = prev;
    } 
  }
  
  private void scheduleTimeout(ChannelHandlerContext ctx, ChannelPromise promise) {
    WriteTimeoutTask task = new WriteTimeoutTask(this, ctx, promise);
    task.scheduledFuture = ctx.executor().schedule(task, this.timeoutNanos, TimeUnit.NANOSECONDS);
    if (!task.scheduledFuture.isDone()) {
      addWriteTimeoutTask(task);
      promise.addListener(task);
    } 
  }
  
  private void addWriteTimeoutTask(WriteTimeoutTask task) {
    assert WriteTimeoutTask.access$000(task).executor().inEventLoop();
    if (this.lastTask != null) {
      this.lastTask.next = task;
      task.prev = this.lastTask;
    } 
    this.lastTask = task;
  }
  
  private void removeWriteTimeoutTask(WriteTimeoutTask task) {
    assert WriteTimeoutTask.access$000(task).executor().inEventLoop();
    if (task == this.lastTask) {
      assert task.next == null;
      this.lastTask = this.lastTask.prev;
      if (this.lastTask != null)
        this.lastTask.next = null; 
    } else {
      if (task.prev == null && task.next == null)
        return; 
      if (task.prev == null) {
        task.next.prev = null;
      } else {
        task.prev.next = task.next;
        task.next.prev = task.prev;
      } 
    } 
    task.prev = null;
    task.next = null;
  }
  
  protected void writeTimedOut(ChannelHandlerContext ctx) throws Exception {
    if (!this.closed) {
      ctx.fireExceptionCaught(WriteTimeoutException.INSTANCE);
      ctx.close();
      this.closed = true;
    } 
  }
}
