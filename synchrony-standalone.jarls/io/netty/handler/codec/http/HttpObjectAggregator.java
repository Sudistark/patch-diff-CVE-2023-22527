package io.netty.handler.codec.http;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufHolder;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelPipeline;
import io.netty.handler.codec.MessageAggregator;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;

public class HttpObjectAggregator extends MessageAggregator<HttpObject, HttpMessage, HttpContent, FullHttpMessage> {
  private static final InternalLogger logger = InternalLoggerFactory.getInstance(HttpObjectAggregator.class);
  
  private static final FullHttpResponse CONTINUE = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE, Unpooled.EMPTY_BUFFER);
  
  private static final FullHttpResponse EXPECTATION_FAILED = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.EXPECTATION_FAILED, Unpooled.EMPTY_BUFFER);
  
  private static final FullHttpResponse TOO_LARGE_CLOSE = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE, Unpooled.EMPTY_BUFFER);
  
  private static final FullHttpResponse TOO_LARGE = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE, Unpooled.EMPTY_BUFFER);
  
  private final boolean closeOnExpectationFailed;
  
  static  {
    EXPECTATION_FAILED.headers().set(HttpHeaderNames.CONTENT_LENGTH, Integer.valueOf(0));
    TOO_LARGE.headers().set(HttpHeaderNames.CONTENT_LENGTH, Integer.valueOf(0));
    TOO_LARGE_CLOSE.headers().set(HttpHeaderNames.CONTENT_LENGTH, Integer.valueOf(0));
    TOO_LARGE_CLOSE.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);
  }
  
  public HttpObjectAggregator(int maxContentLength) { this(maxContentLength, false); }
  
  public HttpObjectAggregator(int maxContentLength, boolean closeOnExpectationFailed) {
    super(maxContentLength);
    this.closeOnExpectationFailed = closeOnExpectationFailed;
  }
  
  protected boolean isStartMessage(HttpObject msg) throws Exception { return msg instanceof HttpMessage; }
  
  protected boolean isContentMessage(HttpObject msg) throws Exception { return msg instanceof HttpContent; }
  
  protected boolean isLastContentMessage(HttpContent msg) throws Exception { return msg instanceof LastHttpContent; }
  
  protected boolean isAggregated(HttpObject msg) throws Exception { return msg instanceof FullHttpMessage; }
  
  protected boolean isContentLengthInvalid(HttpMessage start, int maxContentLength) {
    try {
      return (HttpUtil.getContentLength(start, -1L) > maxContentLength);
    } catch (NumberFormatException e) {
      return false;
    } 
  }
  
  private static Object continueResponse(HttpMessage start, int maxContentLength, ChannelPipeline pipeline) {
    if (HttpUtil.isUnsupportedExpectation(start)) {
      pipeline.fireUserEventTriggered(HttpExpectationFailedEvent.INSTANCE);
      return EXPECTATION_FAILED.retainedDuplicate();
    } 
    if (HttpUtil.is100ContinueExpected(start)) {
      if (HttpUtil.getContentLength(start, -1L) <= maxContentLength)
        return CONTINUE.retainedDuplicate(); 
      pipeline.fireUserEventTriggered(HttpExpectationFailedEvent.INSTANCE);
      return TOO_LARGE.retainedDuplicate();
    } 
    return null;
  }
  
  protected Object newContinueResponse(HttpMessage start, int maxContentLength, ChannelPipeline pipeline) {
    Object response = continueResponse(start, maxContentLength, pipeline);
    if (response != null)
      start.headers().remove(HttpHeaderNames.EXPECT); 
    return response;
  }
  
  protected boolean closeAfterContinueResponse(Object msg) { return (this.closeOnExpectationFailed && ignoreContentAfterContinueResponse(msg)); }
  
  protected boolean ignoreContentAfterContinueResponse(Object msg) {
    if (msg instanceof HttpResponse) {
      HttpResponse httpResponse = (HttpResponse)msg;
      return httpResponse.status().codeClass().equals(HttpStatusClass.CLIENT_ERROR);
    } 
    return false;
  }
  
  protected FullHttpMessage beginAggregation(HttpMessage start, ByteBuf content) throws Exception {
    AggregatedFullHttpResponse aggregatedFullHttpResponse;
    assert !(start instanceof FullHttpMessage);
    HttpUtil.setTransferEncodingChunked(start, false);
    if (start instanceof HttpRequest) {
      aggregatedFullHttpResponse = new AggregatedFullHttpRequest((HttpRequest)start, content, null);
    } else if (start instanceof HttpResponse) {
      aggregatedFullHttpResponse = new AggregatedFullHttpResponse((HttpResponse)start, content, null);
    } else {
      throw new Error();
    } 
    return aggregatedFullHttpResponse;
  }
  
  protected void aggregate(FullHttpMessage aggregated, HttpContent content) throws Exception {
    if (content instanceof LastHttpContent)
      ((AggregatedFullHttpMessage)aggregated).setTrailingHeaders(((LastHttpContent)content).trailingHeaders()); 
  }
  
  protected void finishAggregation(FullHttpMessage aggregated) throws Exception {
    if (!HttpUtil.isContentLengthSet(aggregated))
      aggregated.headers().set(HttpHeaderNames.CONTENT_LENGTH, 
          
          String.valueOf(aggregated.content().readableBytes())); 
  }
  
  protected void handleOversizedMessage(ChannelHandlerContext ctx, HttpMessage oversized) throws Exception {
    if (oversized instanceof HttpRequest) {
      if (oversized instanceof FullHttpMessage || (
        !HttpUtil.is100ContinueExpected(oversized) && !HttpUtil.isKeepAlive(oversized))) {
        ChannelFuture future = ctx.writeAndFlush(TOO_LARGE_CLOSE.retainedDuplicate());
        future.addListener(new Object(this, ctx));
      } else {
        ctx.writeAndFlush(TOO_LARGE.retainedDuplicate()).addListener(new Object(this, ctx));
      } 
    } else {
      if (oversized instanceof HttpResponse) {
        ctx.close();
        throw new TooLongHttpContentException("Response entity too large: " + oversized);
      } 
      throw new IllegalStateException();
    } 
  }
}
