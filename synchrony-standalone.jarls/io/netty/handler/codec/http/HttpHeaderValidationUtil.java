package io.netty.handler.codec.http;

import io.netty.util.AsciiString;

public final class HttpHeaderValidationUtil {
  private static final long TOKEN_CHARS_HIGH;
  
  private static final long TOKEN_CHARS_LOW;
  
  public static boolean isConnectionHeader(CharSequence name, boolean ignoreTeHeader) {
    int len = name.length();
    switch (len) {
      case 2:
        return ignoreTeHeader ? false : AsciiString.contentEqualsIgnoreCase(name, HttpHeaderNames.TE);
      case 7:
        return AsciiString.contentEqualsIgnoreCase(name, HttpHeaderNames.UPGRADE);
      case 10:
        return (AsciiString.contentEqualsIgnoreCase(name, HttpHeaderNames.CONNECTION) || 
          AsciiString.contentEqualsIgnoreCase(name, HttpHeaderNames.KEEP_ALIVE));
      case 16:
        return AsciiString.contentEqualsIgnoreCase(name, HttpHeaderNames.PROXY_CONNECTION);
      case 17:
        return AsciiString.contentEqualsIgnoreCase(name, HttpHeaderNames.TRANSFER_ENCODING);
    } 
    return false;
  }
  
  public static boolean isTeNotTrailers(CharSequence name, CharSequence value) {
    if (name.length() == 2)
      return (AsciiString.contentEqualsIgnoreCase(name, HttpHeaderNames.TE) && 
        !AsciiString.contentEqualsIgnoreCase(value, HttpHeaderValues.TRAILERS)); 
    return false;
  }
  
  public static int validateValidHeaderValue(CharSequence value) {
    int length = value.length();
    if (length == 0)
      return -1; 
    if (value instanceof AsciiString)
      return verifyValidHeaderValueAsciiString((AsciiString)value); 
    return verifyValidHeaderValueCharSequence(value);
  }
  
  private static int verifyValidHeaderValueAsciiString(AsciiString value) {
    byte[] array = value.array();
    int start = value.arrayOffset();
    int b = array[start] & 0xFF;
    if (b < 33 || b == 127)
      return 0; 
    int length = value.length();
    for (int i = start + 1; i < length; i++) {
      b = array[i] & 0xFF;
      if ((b < 32 && b != 9) || b == 127)
        return i - start; 
    } 
    return -1;
  }
  
  private static int verifyValidHeaderValueCharSequence(CharSequence value) {
    int b = value.charAt(0);
    if (b < 33 || b == 127)
      return 0; 
    int length = value.length();
    for (int i = 1; i < length; i++) {
      b = value.charAt(i);
      if ((b < 32 && b != 9) || b == 127)
        return i; 
    } 
    return -1;
  }
  
  public static int validateToken(CharSequence token) {
    if (token instanceof AsciiString)
      return validateAsciiStringToken((AsciiString)token); 
    return validateCharSequenceToken(token);
  }
  
  private static int validateAsciiStringToken(AsciiString token) {
    byte[] array = token.array();
    for (int i = token.arrayOffset(), len = token.arrayOffset() + token.length(); i < len; i++) {
      if (!BitSet128.contains(array[i], TOKEN_CHARS_HIGH, TOKEN_CHARS_LOW))
        return i - token.arrayOffset(); 
    } 
    return -1;
  }
  
  private static int validateCharSequenceToken(CharSequence token) {
    for (int i = 0, len = token.length(); i < len; i++) {
      byte value = (byte)token.charAt(i);
      if (!BitSet128.contains(value, TOKEN_CHARS_HIGH, TOKEN_CHARS_LOW))
        return i; 
    } 
    return -1;
  }
  
  static  {
    tokenChars = (new BitSet128(null)).range('0', '9').range('a', 'z').range('A', 'Z').bits(new char[] { '-', '.', '_', '~' }).bits(new char[] { 
          '!', '#', '$', '%', '&', '\'', '*', '+', '^', '`', 
          '|' });
    TOKEN_CHARS_HIGH = tokenChars.high();
    TOKEN_CHARS_LOW = tokenChars.low();
  }
}
