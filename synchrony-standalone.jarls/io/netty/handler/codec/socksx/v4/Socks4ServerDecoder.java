package io.netty.handler.codec.socksx.v4;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufUtil;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.DecoderException;
import io.netty.handler.codec.DecoderResult;
import io.netty.handler.codec.ReplayingDecoder;
import io.netty.handler.codec.socksx.SocksVersion;
import io.netty.util.CharsetUtil;
import io.netty.util.NetUtil;
import java.util.List;

public class Socks4ServerDecoder extends ReplayingDecoder<Socks4ServerDecoder.State> {
  private static final int MAX_FIELD_LENGTH = 255;
  
  private Socks4CommandType type;
  
  private String dstAddr;
  
  private int dstPort;
  
  private String userId;
  
  public Socks4ServerDecoder() {
    super(State.START);
    setSingleDecode(true);
  }
  
  protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
    try {
      int readableBytes;
      int version;
      switch (null.$SwitchMap$io$netty$handler$codec$socksx$v4$Socks4ServerDecoder$State[((State)state()).ordinal()]) {
        case 1:
          version = in.readUnsignedByte();
          if (version != SocksVersion.SOCKS4a.byteValue())
            throw new DecoderException("unsupported protocol version: " + version); 
          this.type = Socks4CommandType.valueOf(in.readByte());
          this.dstPort = ByteBufUtil.readUnsignedShortBE(in);
          this.dstAddr = NetUtil.intToIpAddress(ByteBufUtil.readIntBE(in));
          checkpoint(State.READ_USERID);
        case 2:
          this.userId = readString("userid", in);
          checkpoint(State.READ_DOMAIN);
        case 3:
          if (!"0.0.0.0".equals(this.dstAddr) && this.dstAddr.startsWith("0.0.0."))
            this.dstAddr = readString("dstAddr", in); 
          out.add(new DefaultSocks4CommandRequest(this.type, this.dstAddr, this.dstPort, this.userId));
          checkpoint(State.SUCCESS);
        case 4:
          readableBytes = actualReadableBytes();
          if (readableBytes > 0)
            out.add(in.readRetainedSlice(readableBytes)); 
          break;
        case 5:
          in.skipBytes(actualReadableBytes());
          break;
      } 
    } catch (Exception e) {
      fail(out, e);
    } 
  }
  
  private void fail(List<Object> out, Exception cause) {
    DecoderException decoderException;
    if (!(cause instanceof DecoderException))
      decoderException = new DecoderException(cause); 
    DefaultSocks4CommandRequest defaultSocks4CommandRequest = new DefaultSocks4CommandRequest((this.type != null) ? this.type : Socks4CommandType.CONNECT, (this.dstAddr != null) ? this.dstAddr : "", (this.dstPort != 0) ? this.dstPort : 65535, (this.userId != null) ? this.userId : "");
    defaultSocks4CommandRequest.setDecoderResult(DecoderResult.failure(decoderException));
    out.add(defaultSocks4CommandRequest);
    checkpoint(State.FAILURE);
  }
  
  private static String readString(String fieldName, ByteBuf in) {
    int length = in.bytesBefore(256, (byte)0);
    if (length < 0)
      throw new DecoderException("field '" + fieldName + "' longer than " + 'Ã¿' + " chars"); 
    String value = in.readSlice(length).toString(CharsetUtil.US_ASCII);
    in.skipBytes(1);
    return value;
  }
}
