package io.netty.handler.codec.socksx.v5;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufUtil;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.DecoderException;
import io.netty.handler.codec.DecoderResult;
import io.netty.handler.codec.ReplayingDecoder;
import io.netty.handler.codec.socksx.SocksVersion;
import io.netty.util.internal.ObjectUtil;
import java.util.List;

public class Socks5CommandRequestDecoder extends ReplayingDecoder<Socks5CommandRequestDecoder.State> {
  private final Socks5AddressDecoder addressDecoder;
  
  public Socks5CommandRequestDecoder() { this(Socks5AddressDecoder.DEFAULT); }
  
  public Socks5CommandRequestDecoder(Socks5AddressDecoder addressDecoder) {
    super(State.INIT);
    this.addressDecoder = (Socks5AddressDecoder)ObjectUtil.checkNotNull(addressDecoder, "addressDecoder");
  }
  
  protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
    try {
      int dstPort;
      String dstAddr;
      Socks5AddressType dstAddrType;
      Socks5CommandType type;
      byte version;
      int readableBytes;
      switch (null.$SwitchMap$io$netty$handler$codec$socksx$v5$Socks5CommandRequestDecoder$State[((State)state()).ordinal()]) {
        case 1:
          version = in.readByte();
          if (version != SocksVersion.SOCKS5.byteValue())
            throw new DecoderException("unsupported version: " + version + " (expected: " + SocksVersion.SOCKS5
                .byteValue() + ')'); 
          type = Socks5CommandType.valueOf(in.readByte());
          in.skipBytes(1);
          dstAddrType = Socks5AddressType.valueOf(in.readByte());
          dstAddr = this.addressDecoder.decodeAddress(dstAddrType, in);
          dstPort = ByteBufUtil.readUnsignedShortBE(in);
          out.add(new DefaultSocks5CommandRequest(type, dstAddrType, dstAddr, dstPort));
          checkpoint(State.SUCCESS);
        case 2:
          readableBytes = actualReadableBytes();
          if (readableBytes > 0)
            out.add(in.readRetainedSlice(readableBytes)); 
          break;
        case 3:
          in.skipBytes(actualReadableBytes());
          break;
      } 
    } catch (Exception e) {
      fail(out, e);
    } 
  }
  
  private void fail(List<Object> out, Exception cause) {
    DecoderException decoderException;
    if (!(cause instanceof DecoderException))
      decoderException = new DecoderException(cause); 
    checkpoint(State.FAILURE);
    DefaultSocks5CommandRequest defaultSocks5CommandRequest = new DefaultSocks5CommandRequest(Socks5CommandType.CONNECT, Socks5AddressType.IPv4, "0.0.0.0", 1);
    defaultSocks5CommandRequest.setDecoderResult(DecoderResult.failure(decoderException));
    out.add(defaultSocks5CommandRequest);
  }
}
