package io.netty.handler.ssl;

import io.netty.internal.tcnative.SSLSessionCache;
import io.netty.util.internal.SystemPropertyUtil;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

class OpenSslSessionCache implements SSLSessionCache {
  private static final OpenSslSession[] EMPTY_SESSIONS = new OpenSslSession[0];
  
  private static final int DEFAULT_CACHE_SIZE;
  
  private final OpenSslEngineMap engineMap;
  
  private final Map<OpenSslSessionId, NativeSslSession> sessions;
  
  private final AtomicInteger maximumCacheSize;
  
  private final AtomicInteger sessionTimeout;
  
  private int sessionCounter;
  
  static  {
    cacheSize = SystemPropertyUtil.getInt("javax.net.ssl.sessionCacheSize", 20480);
    if (cacheSize >= 0) {
      DEFAULT_CACHE_SIZE = cacheSize;
    } else {
      DEFAULT_CACHE_SIZE = 20480;
    } 
  }
  
  OpenSslSessionCache(OpenSslEngineMap engineMap) {
    this.sessions = new Object(this);
    this.maximumCacheSize = new AtomicInteger(DEFAULT_CACHE_SIZE);
    this.sessionTimeout = new AtomicInteger(300);
    this.engineMap = engineMap;
  }
  
  final void setSessionTimeout(int seconds) {
    int oldTimeout = this.sessionTimeout.getAndSet(seconds);
    if (oldTimeout > seconds)
      clear(); 
  }
  
  final int getSessionTimeout() { return this.sessionTimeout.get(); }
  
  protected boolean sessionCreated(NativeSslSession session) { return true; }
  
  protected void sessionRemoved(NativeSslSession session) {}
  
  final void setSessionCacheSize(int size) {
    long oldSize = this.maximumCacheSize.getAndSet(size);
    if (oldSize > size || size == 0)
      clear(); 
  }
  
  final int getSessionCacheSize() { return this.maximumCacheSize.get(); }
  
  private void expungeInvalidSessions() {
    if (this.sessions.isEmpty())
      return; 
    long now = System.currentTimeMillis();
    Iterator<Map.Entry<OpenSslSessionId, NativeSslSession>> iterator = this.sessions.entrySet().iterator();
    while (iterator.hasNext()) {
      NativeSslSession session = (NativeSslSession)((Map.Entry)iterator.next()).getValue();
      if (session.isValid(now))
        break; 
      iterator.remove();
      notifyRemovalAndFree(session);
    } 
  }
  
  public final boolean sessionCreated(long ssl, long sslSession) {
    ReferenceCountedOpenSslEngine engine = this.engineMap.get(ssl);
    if (engine == null)
      return false; 
    NativeSslSession session = new NativeSslSession(sslSession, engine.getPeerHost(), engine.getPeerPort(), getSessionTimeout() * 1000L);
    engine.setSessionId(session.sessionId());
    synchronized (this) {
      if (++this.sessionCounter == 255) {
        this.sessionCounter = 0;
        expungeInvalidSessions();
      } 
      if (!sessionCreated(session)) {
        session.close();
        return false;
      } 
      NativeSslSession old = (NativeSslSession)this.sessions.put(session.sessionId(), session);
      if (old != null)
        notifyRemovalAndFree(old); 
    } 
    return true;
  }
  
  public final long getSession(long ssl, byte[] sessionId) {
    NativeSslSession session;
    OpenSslSessionId id = new OpenSslSessionId(sessionId);
    synchronized (this) {
      session = (NativeSslSession)this.sessions.get(id);
      if (session == null)
        return -1L; 
      if (!session.isValid() || 



        
        !session.upRef()) {
        removeSessionWithId(session.sessionId());
        return -1L;
      } 
      if (session.shouldBeSingleUse())
        removeSessionWithId(session.sessionId()); 
    } 
    session.updateLastAccessedTime();
    return session.session();
  }
  
  void setSession(long ssl, String host, int port) {}
  
  final void removeSessionWithId(OpenSslSessionId id) {
    NativeSslSession sslSession = (NativeSslSession)this.sessions.remove(id);
    if (sslSession != null)
      notifyRemovalAndFree(sslSession); 
  }
  
  final boolean containsSessionWithId(OpenSslSessionId id) { return this.sessions.containsKey(id); }
  
  private void notifyRemovalAndFree(NativeSslSession session) {
    sessionRemoved(session);
    session.free();
  }
  
  final OpenSslSession getSession(OpenSslSessionId id) {
    NativeSslSession session = (NativeSslSession)this.sessions.get(id);
    if (session != null && !session.isValid()) {
      removeSessionWithId(session.sessionId());
      return null;
    } 
    return session;
  }
  
  final List<OpenSslSessionId> getIds() {
    OpenSslSession[] sessionsArray;
    synchronized (this) {
      sessionsArray = (OpenSslSession[])this.sessions.values().toArray(EMPTY_SESSIONS);
    } 
    List<OpenSslSessionId> ids = new ArrayList<OpenSslSessionId>(sessionsArray.length);
    for (OpenSslSession session : sessionsArray) {
      if (session.isValid())
        ids.add(session.sessionId()); 
    } 
    return ids;
  }
  
  void clear() {
    Iterator<Map.Entry<OpenSslSessionId, NativeSslSession>> iterator = this.sessions.entrySet().iterator();
    while (iterator.hasNext()) {
      NativeSslSession session = (NativeSslSession)((Map.Entry)iterator.next()).getValue();
      iterator.remove();
      notifyRemovalAndFree(session);
    } 
  }
}
