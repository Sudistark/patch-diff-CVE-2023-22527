package io.netty.handler.ssl;

import io.netty.internal.tcnative.SSLContext;
import java.util.concurrent.locks.Lock;

public final class OpenSslSessionStats {
  private final ReferenceCountedOpenSslContext context;
  
  OpenSslSessionStats(ReferenceCountedOpenSslContext context) { this.context = context; }
  
  public long number() {
    readerLock = this.context.ctxLock.readLock();
    readerLock.lock();
    try {
      return SSLContext.sessionNumber(this.context.ctx);
    } finally {
      readerLock.unlock();
    } 
  }
  
  public long connect() {
    readerLock = this.context.ctxLock.readLock();
    readerLock.lock();
    try {
      return SSLContext.sessionConnect(this.context.ctx);
    } finally {
      readerLock.unlock();
    } 
  }
  
  public long connectGood() {
    readerLock = this.context.ctxLock.readLock();
    readerLock.lock();
    try {
      return SSLContext.sessionConnectGood(this.context.ctx);
    } finally {
      readerLock.unlock();
    } 
  }
  
  public long connectRenegotiate() {
    readerLock = this.context.ctxLock.readLock();
    readerLock.lock();
    try {
      return SSLContext.sessionConnectRenegotiate(this.context.ctx);
    } finally {
      readerLock.unlock();
    } 
  }
  
  public long accept() {
    readerLock = this.context.ctxLock.readLock();
    readerLock.lock();
    try {
      return SSLContext.sessionAccept(this.context.ctx);
    } finally {
      readerLock.unlock();
    } 
  }
  
  public long acceptGood() {
    readerLock = this.context.ctxLock.readLock();
    readerLock.lock();
    try {
      return SSLContext.sessionAcceptGood(this.context.ctx);
    } finally {
      readerLock.unlock();
    } 
  }
  
  public long acceptRenegotiate() {
    readerLock = this.context.ctxLock.readLock();
    readerLock.lock();
    try {
      return SSLContext.sessionAcceptRenegotiate(this.context.ctx);
    } finally {
      readerLock.unlock();
    } 
  }
  
  public long hits() {
    readerLock = this.context.ctxLock.readLock();
    readerLock.lock();
    try {
      return SSLContext.sessionHits(this.context.ctx);
    } finally {
      readerLock.unlock();
    } 
  }
  
  public long cbHits() {
    readerLock = this.context.ctxLock.readLock();
    readerLock.lock();
    try {
      return SSLContext.sessionCbHits(this.context.ctx);
    } finally {
      readerLock.unlock();
    } 
  }
  
  public long misses() {
    readerLock = this.context.ctxLock.readLock();
    readerLock.lock();
    try {
      return SSLContext.sessionMisses(this.context.ctx);
    } finally {
      readerLock.unlock();
    } 
  }
  
  public long timeouts() {
    readerLock = this.context.ctxLock.readLock();
    readerLock.lock();
    try {
      return SSLContext.sessionTimeouts(this.context.ctx);
    } finally {
      readerLock.unlock();
    } 
  }
  
  public long cacheFull() {
    readerLock = this.context.ctxLock.readLock();
    readerLock.lock();
    try {
      return SSLContext.sessionCacheFull(this.context.ctx);
    } finally {
      readerLock.unlock();
    } 
  }
  
  public long ticketKeyFail() {
    readerLock = this.context.ctxLock.readLock();
    readerLock.lock();
    try {
      return SSLContext.sessionTicketKeyFail(this.context.ctx);
    } finally {
      readerLock.unlock();
    } 
  }
  
  public long ticketKeyNew() {
    readerLock = this.context.ctxLock.readLock();
    readerLock.lock();
    try {
      return SSLContext.sessionTicketKeyNew(this.context.ctx);
    } finally {
      readerLock.unlock();
    } 
  }
  
  public long ticketKeyRenew() {
    readerLock = this.context.ctxLock.readLock();
    readerLock.lock();
    try {
      return SSLContext.sessionTicketKeyRenew(this.context.ctx);
    } finally {
      readerLock.unlock();
    } 
  }
  
  public long ticketKeyResume() {
    readerLock = this.context.ctxLock.readLock();
    readerLock.lock();
    try {
      return SSLContext.sessionTicketKeyResume(this.context.ctx);
    } finally {
      readerLock.unlock();
    } 
  }
}
