package io.netty.handler.stream;

import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.Unpooled;
import io.netty.channel.Channel;
import io.netty.channel.ChannelDuplexHandler;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelPromise;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import java.nio.channels.ClosedChannelException;
import java.util.ArrayDeque;
import java.util.Queue;

public class ChunkedWriteHandler extends ChannelDuplexHandler {
  private static final InternalLogger logger = InternalLoggerFactory.getInstance(ChunkedWriteHandler.class);
  
  private final Queue<PendingWrite> queue = new ArrayDeque();
  
  @Deprecated
  public ChunkedWriteHandler(int maxPendingWrites) { ObjectUtil.checkPositive(maxPendingWrites, "maxPendingWrites"); }
  
  public void handlerAdded(ChannelHandlerContext ctx) throws Exception { this.ctx = ctx; }
  
  public void resumeTransfer() {
    ChannelHandlerContext ctx = this.ctx;
    if (ctx == null)
      return; 
    if (ctx.executor().inEventLoop()) {
      resumeTransfer0(ctx);
    } else {
      ctx.executor().execute(new Object(this, ctx));
    } 
  }
  
  private void resumeTransfer0(ChannelHandlerContext ctx) throws Exception {
    try {
      doFlush(ctx);
    } catch (Exception e) {
      logger.warn("Unexpected exception while sending chunks.", e);
    } 
  }
  
  public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception { this.queue.add(new PendingWrite(msg, promise)); }
  
  public void flush(ChannelHandlerContext ctx) throws Exception { doFlush(ctx); }
  
  public void channelInactive(ChannelHandlerContext ctx) throws Exception {
    doFlush(ctx);
    ctx.fireChannelInactive();
  }
  
  public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {
    if (ctx.channel().isWritable())
      doFlush(ctx); 
    ctx.fireChannelWritabilityChanged();
  }
  
  private void discard(Throwable cause) {
    while (true) {
      PendingWrite currentWrite = (PendingWrite)this.queue.poll();
      if (currentWrite == null)
        break; 
      Object message = currentWrite.msg;
      if (message instanceof ChunkedInput) {
        long inputLength;
        boolean endOfInput;
        ChunkedInput<?> in = (ChunkedInput)message;
        try {
          endOfInput = in.isEndOfInput();
          inputLength = in.length();
          closeInput(in);
        } catch (Exception e) {
          closeInput(in);
          currentWrite.fail(e);
          if (logger.isWarnEnabled())
            logger.warn(ChunkedInput.class.getSimpleName() + " failed", e); 
          continue;
        } 
        if (!endOfInput) {
          if (cause == null)
            cause = new ClosedChannelException(); 
          currentWrite.fail(cause);
          continue;
        } 
        currentWrite.success(inputLength);
        continue;
      } 
      if (cause == null)
        cause = new ClosedChannelException(); 
      currentWrite.fail(cause);
    } 
  }
  
  private void doFlush(ChannelHandlerContext ctx) throws Exception {
    Channel channel = ctx.channel();
    if (!channel.isActive()) {
      discard(null);
      return;
    } 
    boolean requiresFlush = true;
    ByteBufAllocator allocator = ctx.alloc();
    while (channel.isWritable()) {
      PendingWrite currentWrite = (PendingWrite)this.queue.peek();
      if (currentWrite == null)
        break; 
      if (currentWrite.promise.isDone()) {
        this.queue.remove();
        continue;
      } 
      Object pendingMessage = currentWrite.msg;
      if (pendingMessage instanceof ChunkedInput) {
        boolean suspend, endOfInput;
        ChunkedInput<?> chunks = (ChunkedInput)pendingMessage;
        Object message = null;
        try {
          message = chunks.readChunk(allocator);
          endOfInput = chunks.isEndOfInput();
          if (message == null) {
            suspend = !endOfInput;
          } else {
            suspend = false;
          } 
        } catch (Throwable t) {
          this.queue.remove();
          if (message != null)
            ReferenceCountUtil.release(message); 
          closeInput(chunks);
          currentWrite.fail(t);
          break;
        } 
        if (suspend)
          break; 
        if (message == null)
          message = Unpooled.EMPTY_BUFFER; 
        if (endOfInput)
          this.queue.remove(); 
        ChannelFuture f = ctx.writeAndFlush(message);
        if (endOfInput) {
          if (f.isDone()) {
            handleEndOfInputFuture(f, currentWrite);
          } else {
            f.addListener(new Object(this, currentWrite));
          } 
        } else {
          boolean resume = !channel.isWritable();
          if (f.isDone()) {
            handleFuture(f, currentWrite, resume);
          } else {
            f.addListener(new Object(this, currentWrite, resume));
          } 
        } 
        requiresFlush = false;
      } else {
        this.queue.remove();
        ctx.write(pendingMessage, currentWrite.promise);
        requiresFlush = true;
      } 
      if (!channel.isActive()) {
        discard(new ClosedChannelException());
        break;
      } 
    } 
    if (requiresFlush)
      ctx.flush(); 
  }
  
  private static void handleEndOfInputFuture(ChannelFuture future, PendingWrite currentWrite) {
    ChunkedInput<?> input = (ChunkedInput)currentWrite.msg;
    if (!future.isSuccess()) {
      closeInput(input);
      currentWrite.fail(future.cause());
    } else {
      long inputProgress = input.progress();
      long inputLength = input.length();
      closeInput(input);
      currentWrite.progress(inputProgress, inputLength);
      currentWrite.success(inputLength);
    } 
  }
  
  private void handleFuture(ChannelFuture future, PendingWrite currentWrite, boolean resume) {
    ChunkedInput<?> input = (ChunkedInput)currentWrite.msg;
    if (!future.isSuccess()) {
      closeInput(input);
      currentWrite.fail(future.cause());
    } else {
      currentWrite.progress(input.progress(), input.length());
      if (resume && future.channel().isWritable())
        resumeTransfer(); 
    } 
  }
  
  private static void closeInput(ChunkedInput<?> chunks) {
    try {
      chunks.close();
    } catch (Throwable t) {
      if (logger.isWarnEnabled())
        logger.warn("Failed to close a chunked input.", t); 
    } 
  }
  
  public ChunkedWriteHandler() {}
}
