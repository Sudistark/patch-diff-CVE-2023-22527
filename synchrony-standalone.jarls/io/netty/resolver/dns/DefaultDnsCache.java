package io.netty.resolver.dns;

import io.netty.channel.EventLoop;
import io.netty.handler.codec.dns.DnsRecord;
import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.StringUtil;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.InetAddress;
import java.util.Collections;
import java.util.List;

public class DefaultDnsCache implements DnsCache {
  private final Cache<DefaultDnsCacheEntry> resolveCache;
  
  private final int minTtl;
  
  private final int maxTtl;
  
  private final int negativeTtl;
  
  public DefaultDnsCache() { this(0, Cache.MAX_SUPPORTED_TTL_SECS, 0); }
  
  public DefaultDnsCache(int minTtl, int maxTtl, int negativeTtl) {
    this.resolveCache = new Object(this);
    this.minTtl = Math.min(Cache.MAX_SUPPORTED_TTL_SECS, ObjectUtil.checkPositiveOrZero(minTtl, "minTtl"));
    this.maxTtl = Math.min(Cache.MAX_SUPPORTED_TTL_SECS, ObjectUtil.checkPositiveOrZero(maxTtl, "maxTtl"));
    if (minTtl > maxTtl)
      throw new IllegalArgumentException("minTtl: " + minTtl + ", maxTtl: " + maxTtl + " (expected: 0 <= minTtl <= maxTtl)"); 
    this.negativeTtl = Math.min(Cache.MAX_SUPPORTED_TTL_SECS, ObjectUtil.checkPositiveOrZero(negativeTtl, "negativeTtl"));
  }
  
  public int minTtl() { return this.minTtl; }
  
  public int maxTtl() { return this.maxTtl; }
  
  public int negativeTtl() { return this.negativeTtl; }
  
  public void clear() { this.resolveCache.clear(); }
  
  public boolean clear(String hostname) {
    ObjectUtil.checkNotNull(hostname, "hostname");
    return this.resolveCache.clear(appendDot(hostname));
  }
  
  private static boolean emptyAdditionals(DnsRecord[] additionals) { return (additionals == null || additionals.length == 0); }
  
  public List<? extends DnsCacheEntry> get(String hostname, DnsRecord[] additionals) {
    ObjectUtil.checkNotNull(hostname, "hostname");
    if (!emptyAdditionals(additionals))
      return Collections.emptyList(); 
    List<? extends DnsCacheEntry> entries = this.resolveCache.get(appendDot(hostname));
    if (entries == null || entries.isEmpty())
      return entries; 
    return new DnsCacheEntryList(entries);
  }
  
  public DnsCacheEntry cache(String hostname, DnsRecord[] additionals, InetAddress address, long originalTtl, EventLoop loop) {
    ObjectUtil.checkNotNull(hostname, "hostname");
    ObjectUtil.checkNotNull(address, "address");
    ObjectUtil.checkNotNull(loop, "loop");
    DefaultDnsCacheEntry e = new DefaultDnsCacheEntry(hostname, address);
    if (this.maxTtl == 0 || !emptyAdditionals(additionals))
      return e; 
    this.resolveCache.cache(appendDot(hostname), e, Math.max(this.minTtl, (int)Math.min(this.maxTtl, originalTtl)), loop);
    return e;
  }
  
  public DnsCacheEntry cache(String hostname, DnsRecord[] additionals, Throwable cause, EventLoop loop) {
    ObjectUtil.checkNotNull(hostname, "hostname");
    ObjectUtil.checkNotNull(cause, "cause");
    ObjectUtil.checkNotNull(loop, "loop");
    DefaultDnsCacheEntry e = new DefaultDnsCacheEntry(hostname, cause);
    if (this.negativeTtl == 0 || !emptyAdditionals(additionals))
      return e; 
    this.resolveCache.cache(appendDot(hostname), e, this.negativeTtl, loop);
    return e;
  }
  
  public String toString() {
    return "DefaultDnsCache(minTtl=" + 
      this.minTtl + 
      ", maxTtl=" + this.maxTtl + 
      ", negativeTtl=" + this.negativeTtl + 
      ", cached resolved hostname=" + this.resolveCache
      .size() + ')';
  }
  
  private static String appendDot(String hostname) { return StringUtil.endsWith(hostname, '.') ? hostname : (hostname + '.'); }
  
  private static Throwable copyThrowable(Throwable error) {
    if (error.getClass() == java.net.UnknownHostException.class) {
      Object object = new Object(error.getMessage());
      object.initCause(error.getCause());
      object.setStackTrace(error.getStackTrace());
      return object;
    } 
    oos = null;
    ois = null;
    try {
      ByteArrayOutputStream baos = new ByteArrayOutputStream();
      oos = new ObjectOutputStream(baos);
      oos.writeObject(error);
      ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
      ois = new ObjectInputStream(bais);
      return (Throwable)ois.readObject();
    } catch (IOException e) {
      throw new IllegalStateException(e);
    } catch (ClassNotFoundException e) {
      throw new IllegalStateException(e);
    } finally {
      if (oos != null)
        try {
          oos.close();
        } catch (IOException iOException) {} 
      if (ois != null)
        try {
          ois.close();
        } catch (IOException iOException) {} 
    } 
  }
}
