package io.netty.incubator.channel.uring;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.ByteBufHolder;
import io.netty.buffer.ByteBufUtil;
import io.netty.buffer.Unpooled;
import io.netty.channel.AbstractChannel;
import io.netty.channel.Channel;
import io.netty.channel.ChannelConfig;
import io.netty.channel.ChannelMetadata;
import io.netty.channel.ChannelOutboundBuffer;
import io.netty.channel.ChannelPromise;
import io.netty.channel.EventLoop;
import io.netty.channel.socket.SocketChannelConfig;
import io.netty.channel.unix.Buffer;
import io.netty.channel.unix.FileDescriptor;
import io.netty.channel.unix.UnixChannel;
import io.netty.channel.unix.UnixChannelUtil;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AlreadyConnectedException;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.UnresolvedAddressException;
import java.util.concurrent.ScheduledFuture;

abstract class AbstractIOUringChannel extends AbstractChannel implements UnixChannel {
  private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractIOUringChannel.class);
  
  private static final ChannelMetadata METADATA = new ChannelMetadata(false);
  
  final LinuxSocket socket;
  
  private static final int POLL_IN_SCHEDULED = 1;
  
  private static final int POLL_OUT_SCHEDULED = 4;
  
  private static final int POLL_RDHUP_SCHEDULED = 8;
  
  private static final int WRITE_SCHEDULED = 16;
  
  private static final int READ_SCHEDULED = 32;
  
  private static final int CONNECT_SCHEDULED = 64;
  
  private byte ioState;
  
  private short numOutstandingWrites;
  
  private short numOutstandingReads;
  
  private ChannelPromise delayedClose;
  
  private boolean inputClosedSeenErrorOnRead;
  
  private ChannelPromise connectPromise;
  
  private ScheduledFuture<?> connectTimeoutFuture;
  
  private SocketAddress requestedRemoteAddress;
  
  private ByteBuffer remoteAddressMemory;
  
  private IOUringSubmissionQueue submissionQueue;
  
  AbstractIOUringChannel(Channel parent, LinuxSocket socket) { this(parent, socket, true); }
  
  AbstractIOUringChannel(Channel parent, LinuxSocket socket, boolean active) {
    super(parent);
    this.socket = (LinuxSocket)ObjectUtil.checkNotNull(socket, "fd");
    if (active) {
      this.active = true;
      this.local = socket.localAddress();
      this.remote = socket.remoteAddress();
    } 
    if (parent != null) {
      logger.trace("Create Channel Socket: {}", Integer.valueOf(socket.intValue()));
    } else {
      logger.trace("Create Server Socket: {}", Integer.valueOf(socket.intValue()));
    } 
  }
  
  AbstractIOUringChannel(Channel parent, LinuxSocket fd, SocketAddress remote) {
    super(parent);
    this.socket = (LinuxSocket)ObjectUtil.checkNotNull(fd, "fd");
    this.active = true;
    this.remote = remote;
    this.local = fd.localAddress();
  }
  
  public boolean isOpen() { return this.socket.isOpen(); }
  
  public boolean isActive() { return this.active; }
  
  public ChannelMetadata metadata() { return METADATA; }
  
  public FileDescriptor fd() { return this.socket; }
  
  AbstractUringUnsafe ioUringUnsafe() { return (AbstractUringUnsafe)unsafe(); }
  
  protected boolean isCompatible(EventLoop loop) { return loop instanceof IOUringEventLoop; }
  
  protected final ByteBuf newDirectBuffer(ByteBuf buf) { return newDirectBuffer(buf, buf); }
  
  protected final ByteBuf newDirectBuffer(Object holder, ByteBuf buf) {
    int readableBytes = buf.readableBytes();
    if (readableBytes == 0) {
      ReferenceCountUtil.release(holder);
      return Unpooled.EMPTY_BUFFER;
    } 
    ByteBufAllocator alloc = alloc();
    if (alloc.isDirectBufferPooled())
      return newDirectBuffer0(holder, buf, alloc, readableBytes); 
    ByteBuf directBuf = ByteBufUtil.threadLocalDirectBuffer();
    if (directBuf == null)
      return newDirectBuffer0(holder, buf, alloc, readableBytes); 
    directBuf.writeBytes(buf, buf.readerIndex(), readableBytes);
    ReferenceCountUtil.safeRelease(holder);
    return directBuf;
  }
  
  private static ByteBuf newDirectBuffer0(Object holder, ByteBuf buf, ByteBufAllocator alloc, int capacity) {
    ByteBuf directBuf = alloc.directBuffer(capacity);
    directBuf.writeBytes(buf, buf.readerIndex(), capacity);
    ReferenceCountUtil.safeRelease(holder);
    return directBuf;
  }
  
  protected void doDisconnect() throws Exception {}
  
  IOUringSubmissionQueue submissionQueue() { return this.submissionQueue; }
  
  private void freeRemoteAddressMemory() throws Exception {
    if (this.remoteAddressMemory != null) {
      Buffer.free(this.remoteAddressMemory);
      this.remoteAddressMemory = null;
    } 
  }
  
  boolean ioScheduled() { return (this.ioState != 0); }
  
  protected void doClose() throws Exception {
    freeRemoteAddressMemory();
    this.active = false;
    try {
      ChannelPromise promise = this.connectPromise;
      if (promise != null) {
        promise.tryFailure(new ClosedChannelException());
        this.connectPromise = null;
      } 
      cancelConnectTimeoutFuture();
    } finally {
      if (this.submissionQueue != null) {
        if (this.socket.markClosed())
          this.submissionQueue.addClose(fd().intValue(), (short)0); 
      } else {
        this.socket.close();
      } 
    } 
  }
  
  protected void doBeginRead() throws Exception {
    if ((this.ioState & true) == 0)
      ioUringUnsafe().schedulePollIn(); 
  }
  
  protected void doWrite(ChannelOutboundBuffer in) {
    if ((this.ioState & 0x10) != 0)
      return; 
    if (scheduleWrite(in) > 0)
      this.ioState = (byte)(this.ioState | 0x10); 
  }
  
  private int scheduleWrite(ChannelOutboundBuffer in) {
    if (this.delayedClose != null || this.numOutstandingWrites == Short.MAX_VALUE)
      return 0; 
    if (in == null)
      return 0; 
    int msgCount = in.size();
    if (msgCount == 0)
      return 0; 
    Object msg = in.current();
    if (msgCount > 1) {
      this.numOutstandingWrites = (short)ioUringUnsafe().scheduleWriteMultiple(in);
    } else if ((msg instanceof ByteBuf && ((ByteBuf)msg).nioBufferCount() > 1) || (msg instanceof ByteBufHolder && ((ByteBufHolder)msg)
      .content().nioBufferCount() > 1)) {
      this.numOutstandingWrites = (short)ioUringUnsafe().scheduleWriteMultiple(in);
    } else {
      this.numOutstandingWrites = (short)ioUringUnsafe().scheduleWriteSingle(msg);
    } 
    assert this.numOutstandingWrites > 0;
    return this.numOutstandingWrites;
  }
  
  private void schedulePollOut() throws Exception {
    assert (this.ioState & 0x4) == 0;
    IOUringSubmissionQueue submissionQueue = submissionQueue();
    submissionQueue.addPollOut(this.socket.intValue());
    this.ioState = (byte)(this.ioState | 0x4);
  }
  
  final void schedulePollRdHup() throws Exception {
    assert (this.ioState & 0x8) == 0;
    IOUringSubmissionQueue submissionQueue = submissionQueue();
    submissionQueue.addPollRdHup(fd().intValue());
    this.ioState = (byte)(this.ioState | 0x8);
  }
  
  final void resetCachedAddresses() throws Exception {
    this.local = this.socket.localAddress();
    this.remote = this.socket.remoteAddress();
  }
  
  protected Object filterOutboundMessage(Object msg) {
    if (msg instanceof ByteBuf) {
      ByteBuf buf = (ByteBuf)msg;
      return UnixChannelUtil.isBufferCopyNeededForWrite(buf) ? newDirectBuffer(buf) : buf;
    } 
    throw new UnsupportedOperationException("unsupported message type");
  }
  
  protected void doRegister() throws Exception {
    IOUringEventLoop eventLoop = (IOUringEventLoop)eventLoop();
    eventLoop.add(this);
    this.submissionQueue = eventLoop.getRingBuffer().ioUringSubmissionQueue();
  }
  
  protected final void doDeregister() throws Exception {
    IOUringSubmissionQueue submissionQueue = submissionQueue();
    if (submissionQueue != null) {
      if ((this.ioState & 0xD) == 0) {
        ((IOUringEventLoop)eventLoop()).remove(this);
        return;
      } 
      if ((this.ioState & true) != 0)
        submissionQueue.addPollRemove(this.socket.intValue(), Native.POLLIN); 
      if ((this.ioState & 0x4) != 0)
        submissionQueue.addPollRemove(this.socket.intValue(), Native.POLLOUT); 
      if ((this.ioState & 0x8) != 0)
        submissionQueue.addPollRemove(this.socket.intValue(), Native.POLLRDHUP); 
    } 
  }
  
  protected void doBind(SocketAddress local) throws Exception {
    if (local instanceof InetSocketAddress)
      checkResolvable((InetSocketAddress)local); 
    this.socket.bind(local);
    this.local = this.socket.localAddress();
  }
  
  protected static void checkResolvable(InetSocketAddress addr) {
    if (addr.isUnresolved())
      throw new UnresolvedAddressException(); 
  }
  
  protected SocketAddress localAddress0() { return this.local; }
  
  protected SocketAddress remoteAddress0() { return this.remote; }
  
  private void doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception {
    if (localAddress instanceof InetSocketAddress)
      checkResolvable((InetSocketAddress)localAddress); 
    if (remoteAddress instanceof InetSocketAddress)
      checkResolvable((InetSocketAddress)remoteAddress); 
    if (this.remote != null)
      throw new AlreadyConnectedException(); 
    if (localAddress != null)
      this.socket.bind(localAddress); 
  }
  
  private static boolean isAllowHalfClosure(ChannelConfig config) {
    return (config instanceof SocketChannelConfig && ((SocketChannelConfig)config)
      .isAllowHalfClosure());
  }
  
  private void cancelConnectTimeoutFuture() throws Exception {
    if (this.connectTimeoutFuture != null) {
      this.connectTimeoutFuture.cancel(false);
      this.connectTimeoutFuture = null;
    } 
  }
  
  private void computeRemote() throws Exception {
    if (this.requestedRemoteAddress instanceof InetSocketAddress)
      this.remote = UnixChannelUtil.computeRemoteAddr((InetSocketAddress)this.requestedRemoteAddress, this.socket.remoteAddress()); 
  }
  
  private boolean shouldBreakIoUringInReady(ChannelConfig config) { return (this.socket.isInputShutdown() && (this.inputClosedSeenErrorOnRead || !isAllowHalfClosure(config))); }
  
  public void clearPollFlag(int pollMask) {
    if (pollMask == Native.POLLIN) {
      this.ioState = (byte)(this.ioState & 0xFFFFFFFE);
    } else if (pollMask == Native.POLLOUT) {
      this.ioState = (byte)(this.ioState & 0xFFFFFFFB);
    } else if (pollMask == Native.POLLRDHUP) {
      this.ioState = (byte)(this.ioState & 0xFFFFFFF7);
    } 
  }
  
  protected abstract AbstractUringUnsafe newUnsafe();
}
