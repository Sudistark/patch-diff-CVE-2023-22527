package io.netty.buffer;

import io.netty.util.Recycler;
import io.netty.util.internal.ObjectPool;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

abstract class AbstractPooledDerivedByteBuf extends AbstractReferenceCountedByteBuf {
  private final Recycler.EnhancedHandle<AbstractPooledDerivedByteBuf> recyclerHandle;
  
  private AbstractByteBuf rootParent;
  
  private ByteBuf parent;
  
  AbstractPooledDerivedByteBuf(ObjectPool.Handle<? extends AbstractPooledDerivedByteBuf> recyclerHandle) {
    super(0);
    this.recyclerHandle = (Recycler.EnhancedHandle)recyclerHandle;
  }
  
  final void parent(ByteBuf newParent) {
    assert newParent instanceof SimpleLeakAwareByteBuf;
    this.parent = newParent;
  }
  
  public final AbstractByteBuf unwrap() { return this.rootParent; }
  
  final <U extends AbstractPooledDerivedByteBuf> U init(AbstractByteBuf unwrapped, ByteBuf wrapped, int readerIndex, int writerIndex, int maxCapacity) {
    wrapped.retain();
    this.parent = wrapped;
    this.rootParent = unwrapped;
    try {
      maxCapacity(maxCapacity);
      setIndex0(readerIndex, writerIndex);
      resetRefCnt();
      U castThis = (U)this;
      wrapped = null;
      return castThis;
    } finally {
      if (wrapped != null) {
        this.parent = this.rootParent = null;
        wrapped.release();
      } 
    } 
  }
  
  protected final void deallocate() {
    ByteBuf parent = this.parent;
    this.recyclerHandle.unguardedRecycle(this);
    parent.release();
  }
  
  public final ByteBufAllocator alloc() { return unwrap().alloc(); }
  
  @Deprecated
  public final ByteOrder order() { return unwrap().order(); }
  
  public boolean isReadOnly() { return unwrap().isReadOnly(); }
  
  public final boolean isDirect() { return unwrap().isDirect(); }
  
  public boolean hasArray() { return unwrap().hasArray(); }
  
  public byte[] array() { return unwrap().array(); }
  
  public boolean hasMemoryAddress() { return unwrap().hasMemoryAddress(); }
  
  public boolean isContiguous() { return unwrap().isContiguous(); }
  
  public final int nioBufferCount() { return unwrap().nioBufferCount(); }
  
  public final ByteBuffer internalNioBuffer(int index, int length) { return nioBuffer(index, length); }
  
  public final ByteBuf retainedSlice() {
    int index = readerIndex();
    return retainedSlice(index, writerIndex() - index);
  }
  
  public ByteBuf slice(int index, int length) {
    ensureAccessible();
    return new PooledNonRetainedSlicedByteBuf(this, unwrap(), index, length);
  }
  
  final ByteBuf duplicate0() {
    ensureAccessible();
    return new PooledNonRetainedDuplicateByteBuf(this, unwrap());
  }
}
