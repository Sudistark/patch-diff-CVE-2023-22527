package io.netty.util;

import io.netty.util.concurrent.ImmediateExecutor;
import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.PlatformDependent;
import io.netty.util.internal.StringUtil;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import java.util.Collections;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.atomic.AtomicLong;

public class HashedWheelTimer implements Timer {
  static final InternalLogger logger = InternalLoggerFactory.getInstance(HashedWheelTimer.class);
  
  private static final AtomicInteger INSTANCE_COUNTER = new AtomicInteger();
  
  private static final AtomicBoolean WARNED_TOO_MANY_INSTANCES = new AtomicBoolean();
  
  private static final int INSTANCE_COUNT_LIMIT = 64;
  
  private static final long MILLISECOND_NANOS = TimeUnit.MILLISECONDS.toNanos(1L);
  
  private static final ResourceLeakDetector<HashedWheelTimer> leakDetector = ResourceLeakDetectorFactory.instance()
    .newResourceLeakDetector(HashedWheelTimer.class, 1);
  
  private static final AtomicIntegerFieldUpdater<HashedWheelTimer> WORKER_STATE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimer.class, "workerState");
  
  private final ResourceLeakTracker<HashedWheelTimer> leak;
  
  private final Worker worker;
  
  private final Thread workerThread;
  
  public static final int WORKER_STATE_INIT = 0;
  
  public static final int WORKER_STATE_STARTED = 1;
  
  public static final int WORKER_STATE_SHUTDOWN = 2;
  
  private final long tickDuration;
  
  private final HashedWheelBucket[] wheel;
  
  private final int mask;
  
  private final CountDownLatch startTimeInitialized;
  
  private final Queue<HashedWheelTimeout> timeouts;
  
  private final Queue<HashedWheelTimeout> cancelledTimeouts;
  
  private final AtomicLong pendingTimeouts;
  
  private final long maxPendingTimeouts;
  
  private final Executor taskExecutor;
  
  public HashedWheelTimer() { this(Executors.defaultThreadFactory()); }
  
  public HashedWheelTimer(long tickDuration, TimeUnit unit) { this(Executors.defaultThreadFactory(), tickDuration, unit); }
  
  public HashedWheelTimer(long tickDuration, TimeUnit unit, int ticksPerWheel) { this(Executors.defaultThreadFactory(), tickDuration, unit, ticksPerWheel); }
  
  public HashedWheelTimer(ThreadFactory threadFactory) { this(threadFactory, 100L, TimeUnit.MILLISECONDS); }
  
  public HashedWheelTimer(ThreadFactory threadFactory, long tickDuration, TimeUnit unit) { this(threadFactory, tickDuration, unit, 512); }
  
  public HashedWheelTimer(ThreadFactory threadFactory, long tickDuration, TimeUnit unit, int ticksPerWheel) { this(threadFactory, tickDuration, unit, ticksPerWheel, true); }
  
  public HashedWheelTimer(ThreadFactory threadFactory, long tickDuration, TimeUnit unit, int ticksPerWheel, boolean leakDetection) { this(threadFactory, tickDuration, unit, ticksPerWheel, leakDetection, -1L); }
  
  public HashedWheelTimer(ThreadFactory threadFactory, long tickDuration, TimeUnit unit, int ticksPerWheel, boolean leakDetection, long maxPendingTimeouts) { this(threadFactory, tickDuration, unit, ticksPerWheel, leakDetection, maxPendingTimeouts, ImmediateExecutor.INSTANCE); }
  
  public HashedWheelTimer(ThreadFactory threadFactory, long tickDuration, TimeUnit unit, int ticksPerWheel, boolean leakDetection, long maxPendingTimeouts, Executor taskExecutor) {
    this.worker = new Worker(this, null);
    this.startTimeInitialized = new CountDownLatch(1);
    this.timeouts = PlatformDependent.newMpscQueue();
    this.cancelledTimeouts = PlatformDependent.newMpscQueue();
    this.pendingTimeouts = new AtomicLong(0L);
    ObjectUtil.checkNotNull(threadFactory, "threadFactory");
    ObjectUtil.checkNotNull(unit, "unit");
    ObjectUtil.checkPositive(tickDuration, "tickDuration");
    ObjectUtil.checkPositive(ticksPerWheel, "ticksPerWheel");
    this.taskExecutor = (Executor)ObjectUtil.checkNotNull(taskExecutor, "taskExecutor");
    this.wheel = createWheel(ticksPerWheel);
    this.mask = this.wheel.length - 1;
    long duration = unit.toNanos(tickDuration);
    if (duration >= Float.MAX_VALUE / this.wheel.length)
      throw new IllegalArgumentException(String.format("tickDuration: %d (expected: 0 < tickDuration in nanos < %d", new Object[] { Long.valueOf(tickDuration), Long.valueOf(Float.MAX_VALUE / this.wheel.length) })); 
    if (duration < MILLISECOND_NANOS) {
      logger.warn("Configured tickDuration {} smaller than {}, using 1ms.", 
          Long.valueOf(tickDuration), Long.valueOf(MILLISECOND_NANOS));
      this.tickDuration = MILLISECOND_NANOS;
    } else {
      this.tickDuration = duration;
    } 
    this.workerThread = threadFactory.newThread(this.worker);
    this.leak = (leakDetection || !this.workerThread.isDaemon()) ? leakDetector.track(this) : null;
    this.maxPendingTimeouts = maxPendingTimeouts;
    if (INSTANCE_COUNTER.incrementAndGet() > 64 && WARNED_TOO_MANY_INSTANCES
      .compareAndSet(false, true))
      reportTooManyInstances(); 
  }
  
  protected void finalize() {
    try {
      super.finalize();
    } finally {
      if (WORKER_STATE_UPDATER.getAndSet(this, 2) != 2)
        INSTANCE_COUNTER.decrementAndGet(); 
    } 
  }
  
  private static HashedWheelBucket[] createWheel(int ticksPerWheel) {
    ObjectUtil.checkInRange(ticksPerWheel, 1, 1073741824, "ticksPerWheel");
    ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);
    HashedWheelBucket[] arrayOfHashedWheelBucket = new HashedWheelBucket[ticksPerWheel];
    for (int i = 0; i < arrayOfHashedWheelBucket.length; i++)
      arrayOfHashedWheelBucket[i] = new HashedWheelBucket(null); 
    return arrayOfHashedWheelBucket;
  }
  
  private static int normalizeTicksPerWheel(int ticksPerWheel) {
    int normalizedTicksPerWheel = 1;
    while (normalizedTicksPerWheel < ticksPerWheel)
      normalizedTicksPerWheel <<= 1; 
    return normalizedTicksPerWheel;
  }
  
  public void start() {
    switch (WORKER_STATE_UPDATER.get(this)) {
      case 0:
        if (WORKER_STATE_UPDATER.compareAndSet(this, 0, 1))
          this.workerThread.start(); 
        break;
      case 1:
        break;
      case 2:
        throw new IllegalStateException("cannot be started once stopped");
      default:
        throw new Error("Invalid WorkerState");
    } 
    while (this.startTime == 0L) {
      try {
        this.startTimeInitialized.await();
      } catch (InterruptedException interruptedException) {}
    } 
  }
  
  public Set<Timeout> stop() {
    if (Thread.currentThread() == this.workerThread)
      throw new IllegalStateException(HashedWheelTimer.class
          .getSimpleName() + ".stop() cannot be called from " + TimerTask.class
          
          .getSimpleName()); 
    if (!WORKER_STATE_UPDATER.compareAndSet(this, 1, 2)) {
      if (WORKER_STATE_UPDATER.getAndSet(this, 2) != 2) {
        INSTANCE_COUNTER.decrementAndGet();
        if (this.leak != null) {
          boolean closed = this.leak.close(this);
          assert closed;
        } 
      } 
      return Collections.emptySet();
    } 
    try {
      boolean interrupted = false;
      while (this.workerThread.isAlive()) {
        this.workerThread.interrupt();
        try {
          this.workerThread.join(100L);
        } catch (InterruptedException ignored) {
          interrupted = true;
        } 
      } 
      if (interrupted)
        Thread.currentThread().interrupt(); 
    } finally {
      INSTANCE_COUNTER.decrementAndGet();
      if (this.leak != null) {
        boolean closed = this.leak.close(this);
        assert closed;
      } 
    } 
    return this.worker.unprocessedTimeouts();
  }
  
  public Timeout newTimeout(TimerTask task, long delay, TimeUnit unit) {
    ObjectUtil.checkNotNull(task, "task");
    ObjectUtil.checkNotNull(unit, "unit");
    long pendingTimeoutsCount = this.pendingTimeouts.incrementAndGet();
    if (this.maxPendingTimeouts > 0L && pendingTimeoutsCount > this.maxPendingTimeouts) {
      this.pendingTimeouts.decrementAndGet();
      throw new RejectedExecutionException("Number of pending timeouts (" + pendingTimeoutsCount + ") is greater than or equal to maximum allowed pending timeouts (" + this.maxPendingTimeouts + ")");
    } 
    start();
    long deadline = System.nanoTime() + unit.toNanos(delay) - this.startTime;
    if (delay > 0L && deadline < 0L)
      deadline = Float.MAX_VALUE; 
    HashedWheelTimeout timeout = new HashedWheelTimeout(this, task, deadline);
    this.timeouts.add(timeout);
    return timeout;
  }
  
  public long pendingTimeouts() { return this.pendingTimeouts.get(); }
  
  private static void reportTooManyInstances() {
    if (logger.isErrorEnabled()) {
      resourceType = StringUtil.simpleClassName(HashedWheelTimer.class);
      logger.error("You are creating too many " + resourceType + " instances. " + resourceType + " is a shared resource that must be reused across the JVM, so that only a few instances are created.");
    } 
  }
}
