package io.netty.util.internal;

import io.netty.util.concurrent.FastThreadLocalThread;
import java.lang.ref.ReferenceQueue;
import java.security.AccessController;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

public final class ObjectCleaner {
  private static final int REFERENCE_QUEUE_POLL_TIMEOUT_MS = Math.max(500, SystemPropertyUtil.getInt("io.netty.util.internal.ObjectCleaner.refQueuePollTimeout", 10000));
  
  static final String CLEANER_THREAD_NAME = ObjectCleaner.class.getSimpleName() + "Thread";
  
  private static final Set<AutomaticCleanerReference> LIVE_SET = new ConcurrentSet();
  
  private static final ReferenceQueue<Object> REFERENCE_QUEUE = new ReferenceQueue();
  
  private static final AtomicBoolean CLEANER_RUNNING = new AtomicBoolean(false);
  
  private static final Runnable CLEANER_TASK = new Object();
  
  public static void register(Object object, Runnable cleanupTask) {
    AutomaticCleanerReference reference = new AutomaticCleanerReference(object, (Runnable)ObjectUtil.checkNotNull(cleanupTask, "cleanupTask"));
    LIVE_SET.add(reference);
    if (CLEANER_RUNNING.compareAndSet(false, true)) {
      FastThreadLocalThread fastThreadLocalThread = new FastThreadLocalThread(CLEANER_TASK);
      fastThreadLocalThread.setPriority(1);
      AccessController.doPrivileged(new Object(fastThreadLocalThread));
      fastThreadLocalThread.setName(CLEANER_THREAD_NAME);
      fastThreadLocalThread.setDaemon(true);
      fastThreadLocalThread.start();
    } 
  }
  
  public static int getLiveSetCount() { return LIVE_SET.size(); }
}
