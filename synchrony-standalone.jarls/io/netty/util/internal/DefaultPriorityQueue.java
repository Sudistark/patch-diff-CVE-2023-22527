package io.netty.util.internal;

import java.util.AbstractQueue;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;

public final class DefaultPriorityQueue<T extends PriorityQueueNode> extends AbstractQueue<T> implements PriorityQueue<T> {
  private static final PriorityQueueNode[] EMPTY_ARRAY = new PriorityQueueNode[0];
  
  private final Comparator<T> comparator;
  
  private T[] queue;
  
  private int size;
  
  public DefaultPriorityQueue(Comparator<T> comparator, int initialSize) {
    this.comparator = (Comparator)ObjectUtil.checkNotNull(comparator, "comparator");
    this.queue = (PriorityQueueNode[])((initialSize != 0) ? new PriorityQueueNode[initialSize] : EMPTY_ARRAY);
  }
  
  public int size() { return this.size; }
  
  public boolean isEmpty() { return (this.size == 0); }
  
  public boolean contains(Object o) {
    if (!(o instanceof PriorityQueueNode))
      return false; 
    PriorityQueueNode node = (PriorityQueueNode)o;
    return contains(node, node.priorityQueueIndex(this));
  }
  
  public boolean containsTyped(T node) { return contains(node, node.priorityQueueIndex(this)); }
  
  public void clear() {
    for (int i = 0; i < this.size; i++) {
      T node = (T)this.queue[i];
      if (node != null) {
        node.priorityQueueIndex(this, -1);
        this.queue[i] = null;
      } 
    } 
    this.size = 0;
  }
  
  public void clearIgnoringIndexes() { this.size = 0; }
  
  public boolean offer(T e) {
    if (e.priorityQueueIndex(this) != -1)
      throw new IllegalArgumentException("e.priorityQueueIndex(): " + e.priorityQueueIndex(this) + " (expected: " + -1 + ") + e: " + e); 
    if (this.size >= this.queue.length)
      this.queue = (PriorityQueueNode[])Arrays.copyOf(this.queue, this.queue.length + ((this.queue.length < 64) ? (this.queue.length + 2) : (this.queue.length >>> 1))); 
    bubbleUp(this.size++, e);
    return true;
  }
  
  public T poll() {
    if (this.size == 0)
      return null; 
    T result = (T)this.queue[0];
    result.priorityQueueIndex(this, -1);
    T last = (T)this.queue[--this.size];
    this.queue[this.size] = null;
    if (this.size != 0)
      bubbleDown(0, last); 
    return result;
  }
  
  public T peek() { return (T)((this.size == 0) ? null : this.queue[0]); }
  
  public boolean remove(Object o) {
    T node;
    try {
      node = (T)(PriorityQueueNode)o;
    } catch (ClassCastException e) {
      return false;
    } 
    return removeTyped(node);
  }
  
  public boolean removeTyped(T node) {
    int i = node.priorityQueueIndex(this);
    if (!contains(node, i))
      return false; 
    node.priorityQueueIndex(this, -1);
    if (--this.size == 0 || this.size == i) {
      this.queue[i] = null;
      return true;
    } 
    this.queue[i] = this.queue[this.size];
    T moved = (T)this.queue[this.size];
    this.queue[this.size] = null;
    if (this.comparator.compare(node, moved) < 0) {
      bubbleDown(i, moved);
    } else {
      bubbleUp(i, moved);
    } 
    return true;
  }
  
  public void priorityChanged(T node) {
    int i = node.priorityQueueIndex(this);
    if (!contains(node, i))
      return; 
    if (i == 0) {
      bubbleDown(i, node);
    } else {
      int iParent = i - 1 >>> 1;
      T parent = (T)this.queue[iParent];
      if (this.comparator.compare(node, parent) < 0) {
        bubbleUp(i, node);
      } else {
        bubbleDown(i, node);
      } 
    } 
  }
  
  public Object[] toArray() { return Arrays.copyOf(this.queue, this.size); }
  
  public <X> X[] toArray(X[] a) {
    if (a.length < this.size)
      return (X[])(Object[])Arrays.copyOf(this.queue, this.size, a.getClass()); 
    System.arraycopy(this.queue, 0, a, 0, this.size);
    if (a.length > this.size)
      a[this.size] = null; 
    return a;
  }
  
  public Iterator<T> iterator() { return new PriorityQueueIterator(this, null); }
  
  private boolean contains(PriorityQueueNode node, int i) { return (i >= 0 && i < this.size && node.equals(this.queue[i])); }
  
  private void bubbleDown(int k, T node) {
    int half = this.size >>> 1;
    while (k < half) {
      int iChild = (k << 1) + 1;
      T child = (T)this.queue[iChild];
      int rightChild = iChild + 1;
      if (rightChild < this.size && this.comparator.compare(child, this.queue[rightChild]) > 0)
        child = (T)this.queue[iChild = rightChild]; 
      if (this.comparator.compare(node, child) <= 0)
        break; 
      this.queue[k] = child;
      child.priorityQueueIndex(this, k);
      k = iChild;
    } 
    this.queue[k] = node;
    node.priorityQueueIndex(this, k);
  }
  
  private void bubbleUp(int k, T node) {
    while (k > 0) {
      int iParent = k - 1 >>> 1;
      T parent = (T)this.queue[iParent];
      if (this.comparator.compare(node, parent) >= 0)
        break; 
      this.queue[k] = parent;
      parent.priorityQueueIndex(this, k);
      k = iParent;
    } 
    this.queue[k] = node;
    node.priorityQueueIndex(this, k);
  }
}
