package io.netty.util.concurrent;

import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.SystemPropertyUtil;
import io.netty.util.internal.ThreadExecutorMap;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import java.security.AccessController;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import org.jetbrains.annotations.Async.Schedule;

public final class GlobalEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor {
  private static final InternalLogger logger = InternalLoggerFactory.getInstance(GlobalEventExecutor.class);
  
  private static final long SCHEDULE_QUIET_PERIOD_INTERVAL;
  
  public static final GlobalEventExecutor INSTANCE;
  
  final BlockingQueue<Runnable> taskQueue;
  
  final ScheduledFutureTask<Void> quietPeriodTask;
  
  final ThreadFactory threadFactory;
  
  private final TaskRunner taskRunner;
  
  private final AtomicBoolean started;
  
  private final Future<?> terminationFuture;
  
  static  {
    quietPeriod = SystemPropertyUtil.getInt("io.netty.globalEventExecutor.quietPeriodSeconds", 1);
    if (quietPeriod <= 0)
      quietPeriod = 1; 
    logger.debug("-Dio.netty.globalEventExecutor.quietPeriodSeconds: {}", Integer.valueOf(quietPeriod));
    SCHEDULE_QUIET_PERIOD_INTERVAL = TimeUnit.SECONDS.toNanos(quietPeriod);
    INSTANCE = new GlobalEventExecutor();
  }
  
  private GlobalEventExecutor() {
    this.taskQueue = new LinkedBlockingQueue();
    this







      
      .quietPeriodTask = new ScheduledFutureTask(this, Executors.callable(new Object(this), null), deadlineNanos(getCurrentTimeNanos(), SCHEDULE_QUIET_PERIOD_INTERVAL), -SCHEDULE_QUIET_PERIOD_INTERVAL);
    this.taskRunner = new TaskRunner(this);
    this.started = new AtomicBoolean();
    this.terminationFuture = new FailedFuture(this, new UnsupportedOperationException());
    scheduledTaskQueue().add(this.quietPeriodTask);
    this.threadFactory = ThreadExecutorMap.apply(new DefaultThreadFactory(
          DefaultThreadFactory.toPoolName(getClass()), false, 5, null), this);
  }
  
  Runnable takeTask() {
    Runnable task;
    BlockingQueue<Runnable> taskQueue = this.taskQueue;
    do {
      ScheduledFutureTask<?> scheduledTask = peekScheduledTask();
      if (scheduledTask == null) {
        Runnable task = null;
        try {
          task = (Runnable)taskQueue.take();
        } catch (InterruptedException interruptedException) {}
        return task;
      } 
      long delayNanos = scheduledTask.delayNanos();
      task = null;
      if (delayNanos > 0L)
        try {
          task = (Runnable)taskQueue.poll(delayNanos, TimeUnit.NANOSECONDS);
        } catch (InterruptedException e) {
          return null;
        }  
      if (task != null)
        continue; 
      fetchFromScheduledTaskQueue();
      task = (Runnable)taskQueue.poll();
    } while (task == null);
    return task;
  }
  
  private void fetchFromScheduledTaskQueue() {
    long nanoTime = getCurrentTimeNanos();
    Runnable scheduledTask = pollScheduledTask(nanoTime);
    while (scheduledTask != null) {
      this.taskQueue.add(scheduledTask);
      scheduledTask = pollScheduledTask(nanoTime);
    } 
  }
  
  public int pendingTasks() { return this.taskQueue.size(); }
  
  private void addTask(Runnable task) { this.taskQueue.add(ObjectUtil.checkNotNull(task, "task")); }
  
  public boolean inEventLoop(Thread thread) { return (thread == this.thread); }
  
  public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) { return terminationFuture(); }
  
  public Future<?> terminationFuture() { return this.terminationFuture; }
  
  @Deprecated
  public void shutdown() { throw new UnsupportedOperationException(); }
  
  public boolean isShuttingDown() { return false; }
  
  public boolean isShutdown() { return false; }
  
  public boolean isTerminated() { return false; }
  
  public boolean awaitTermination(long timeout, TimeUnit unit) { return false; }
  
  public boolean awaitInactivity(long timeout, TimeUnit unit) {
    ObjectUtil.checkNotNull(unit, "unit");
    Thread thread = this.thread;
    if (thread == null)
      throw new IllegalStateException("thread was not started"); 
    thread.join(unit.toMillis(timeout));
    return !thread.isAlive();
  }
  
  public void execute(Runnable task) { execute0(task); }
  
  private void execute0(@Schedule Runnable task) {
    addTask((Runnable)ObjectUtil.checkNotNull(task, "task"));
    if (!inEventLoop())
      startThread(); 
  }
  
  private void startThread() {
    if (this.started.compareAndSet(false, true)) {
      Thread t = this.threadFactory.newThread(this.taskRunner);
      AccessController.doPrivileged(new Object(this, t));
      this.thread = t;
      t.start();
    } 
  }
}
