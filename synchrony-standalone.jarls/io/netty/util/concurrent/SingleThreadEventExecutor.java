package io.netty.util.concurrent;

import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.PlatformDependent;
import io.netty.util.internal.SystemPropertyUtil;
import io.netty.util.internal.ThreadExecutorMap;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import org.jetbrains.annotations.Async.Schedule;

public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor {
  static final int DEFAULT_MAX_PENDING_EXECUTOR_TASKS = Math.max(16, 
      SystemPropertyUtil.getInt("io.netty.eventexecutor.maxPendingTasks", 2147483647));
  
  private static final InternalLogger logger = InternalLoggerFactory.getInstance(SingleThreadEventExecutor.class);
  
  private static final int ST_NOT_STARTED = 1;
  
  private static final int ST_STARTED = 2;
  
  private static final int ST_SHUTTING_DOWN = 3;
  
  private static final int ST_SHUTDOWN = 4;
  
  private static final int ST_TERMINATED = 5;
  
  private static final Runnable NOOP_TASK = new Object();
  
  private static final AtomicIntegerFieldUpdater<SingleThreadEventExecutor> STATE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(SingleThreadEventExecutor.class, "state");
  
  private static final AtomicReferenceFieldUpdater<SingleThreadEventExecutor, ThreadProperties> PROPERTIES_UPDATER = AtomicReferenceFieldUpdater.newUpdater(SingleThreadEventExecutor.class, ThreadProperties.class, "threadProperties");
  
  private final Queue<Runnable> taskQueue;
  
  private final Executor executor;
  
  private final CountDownLatch threadLock = new CountDownLatch(1);
  
  private final Set<Runnable> shutdownHooks = new LinkedHashSet();
  
  private final boolean addTaskWakesUp;
  
  private final int maxPendingTasks;
  
  private final RejectedExecutionHandler rejectedExecutionHandler;
  
  private long lastExecutionTime;
  
  private long gracefulShutdownStartTime;
  
  private final Promise<?> terminationFuture = new DefaultPromise(GlobalEventExecutor.INSTANCE);
  
  protected SingleThreadEventExecutor(EventExecutorGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp) { this(parent, new ThreadPerTaskExecutor(threadFactory), addTaskWakesUp); }
  
  protected SingleThreadEventExecutor(EventExecutorGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp, int maxPendingTasks, RejectedExecutionHandler rejectedHandler) { this(parent, new ThreadPerTaskExecutor(threadFactory), addTaskWakesUp, maxPendingTasks, rejectedHandler); }
  
  protected SingleThreadEventExecutor(EventExecutorGroup parent, Executor executor, boolean addTaskWakesUp) { this(parent, executor, addTaskWakesUp, DEFAULT_MAX_PENDING_EXECUTOR_TASKS, RejectedExecutionHandlers.reject()); }
  
  protected SingleThreadEventExecutor(EventExecutorGroup parent, Executor executor, boolean addTaskWakesUp, int maxPendingTasks, RejectedExecutionHandler rejectedHandler) {
    super(parent);
    this.addTaskWakesUp = addTaskWakesUp;
    this.maxPendingTasks = Math.max(16, maxPendingTasks);
    this.executor = ThreadExecutorMap.apply(executor, this);
    this.taskQueue = newTaskQueue(this.maxPendingTasks);
    this.rejectedExecutionHandler = (RejectedExecutionHandler)ObjectUtil.checkNotNull(rejectedHandler, "rejectedHandler");
  }
  
  protected SingleThreadEventExecutor(EventExecutorGroup parent, Executor executor, boolean addTaskWakesUp, Queue<Runnable> taskQueue, RejectedExecutionHandler rejectedHandler) {
    super(parent);
    this.addTaskWakesUp = addTaskWakesUp;
    this.maxPendingTasks = DEFAULT_MAX_PENDING_EXECUTOR_TASKS;
    this.executor = ThreadExecutorMap.apply(executor, this);
    this.taskQueue = (Queue)ObjectUtil.checkNotNull(taskQueue, "taskQueue");
    this.rejectedExecutionHandler = (RejectedExecutionHandler)ObjectUtil.checkNotNull(rejectedHandler, "rejectedHandler");
  }
  
  @Deprecated
  protected Queue<Runnable> newTaskQueue() { return newTaskQueue(this.maxPendingTasks); }
  
  protected Queue<Runnable> newTaskQueue(int maxPendingTasks) { return new LinkedBlockingQueue(maxPendingTasks); }
  
  protected void interruptThread() {
    Thread currentThread = this.thread;
    if (currentThread == null) {
      this.interrupted = true;
    } else {
      currentThread.interrupt();
    } 
  }
  
  protected Runnable pollTask() {
    assert inEventLoop();
    return pollTaskFrom(this.taskQueue);
  }
  
  protected static Runnable pollTaskFrom(Queue<Runnable> taskQueue) {
    Runnable task;
    do {
      task = (Runnable)taskQueue.poll();
    } while (task == WAKEUP_TASK);
    return task;
  }
  
  protected Runnable takeTask() {
    Runnable task;
    assert inEventLoop();
    if (!(this.taskQueue instanceof BlockingQueue))
      throw new UnsupportedOperationException(); 
    BlockingQueue<Runnable> taskQueue = (BlockingQueue)this.taskQueue;
    do {
      ScheduledFutureTask<?> scheduledTask = peekScheduledTask();
      if (scheduledTask == null) {
        Runnable task = null;
        try {
          task = (Runnable)taskQueue.take();
          if (task == WAKEUP_TASK)
            task = null; 
        } catch (InterruptedException interruptedException) {}
        return task;
      } 
      long delayNanos = scheduledTask.delayNanos();
      task = null;
      if (delayNanos > 0L)
        try {
          task = (Runnable)taskQueue.poll(delayNanos, TimeUnit.NANOSECONDS);
        } catch (InterruptedException e) {
          return null;
        }  
      if (task != null)
        continue; 
      fetchFromScheduledTaskQueue();
      task = (Runnable)taskQueue.poll();
    } while (task == null);
    return task;
  }
  
  private boolean fetchFromScheduledTaskQueue() {
    Runnable scheduledTask;
    if (this.scheduledTaskQueue == null || this.scheduledTaskQueue.isEmpty())
      return true; 
    long nanoTime = getCurrentTimeNanos();
    do {
      scheduledTask = pollScheduledTask(nanoTime);
      if (scheduledTask == null)
        return true; 
    } while (this.taskQueue.offer(scheduledTask));
    this.scheduledTaskQueue.add((ScheduledFutureTask)scheduledTask);
    return false;
  }
  
  private boolean executeExpiredScheduledTasks() {
    if (this.scheduledTaskQueue == null || this.scheduledTaskQueue.isEmpty())
      return false; 
    long nanoTime = getCurrentTimeNanos();
    Runnable scheduledTask = pollScheduledTask(nanoTime);
    if (scheduledTask == null)
      return false; 
    do {
      safeExecute(scheduledTask);
    } while ((scheduledTask = pollScheduledTask(nanoTime)) != null);
    return true;
  }
  
  protected Runnable peekTask() {
    assert inEventLoop();
    return (Runnable)this.taskQueue.peek();
  }
  
  protected boolean hasTasks() {
    assert inEventLoop();
    return !this.taskQueue.isEmpty();
  }
  
  public int pendingTasks() { return this.taskQueue.size(); }
  
  protected void addTask(Runnable task) {
    ObjectUtil.checkNotNull(task, "task");
    if (!offerTask(task))
      reject(task); 
  }
  
  final boolean offerTask(Runnable task) {
    if (isShutdown())
      reject(); 
    return this.taskQueue.offer(task);
  }
  
  protected boolean removeTask(Runnable task) { return this.taskQueue.remove(ObjectUtil.checkNotNull(task, "task")); }
  
  protected boolean runAllTasks() {
    boolean fetchedAll;
    assert inEventLoop();
    boolean ranAtLeastOne = false;
    do {
      fetchedAll = fetchFromScheduledTaskQueue();
      if (!runAllTasksFrom(this.taskQueue))
        continue; 
      ranAtLeastOne = true;
    } while (!fetchedAll);
    if (ranAtLeastOne)
      this.lastExecutionTime = getCurrentTimeNanos(); 
    afterRunningAllTasks();
    return ranAtLeastOne;
  }
  
  protected final boolean runScheduledAndExecutorTasks(int maxDrainAttempts) {
    boolean ranAtLeastOneTask;
    assert inEventLoop();
    int drainAttempt = 0;
    do {
      ranAtLeastOneTask = runExistingTasksFrom(this.taskQueue) | executeExpiredScheduledTasks();
    } while (ranAtLeastOneTask && ++drainAttempt < maxDrainAttempts);
    if (drainAttempt > 0)
      this.lastExecutionTime = getCurrentTimeNanos(); 
    afterRunningAllTasks();
    return (drainAttempt > 0);
  }
  
  protected final boolean runAllTasksFrom(Queue<Runnable> taskQueue) {
    Runnable task = pollTaskFrom(taskQueue);
    if (task == null)
      return false; 
    do {
      safeExecute(task);
      task = pollTaskFrom(taskQueue);
    } while (task != null);
    return true;
  }
  
  private boolean runExistingTasksFrom(Queue<Runnable> taskQueue) {
    Runnable task = pollTaskFrom(taskQueue);
    if (task == null)
      return false; 
    int remaining = Math.min(this.maxPendingTasks, taskQueue.size());
    safeExecute(task);
    while (remaining-- > 0 && (task = (Runnable)taskQueue.poll()) != null)
      safeExecute(task); 
    return true;
  }
  
  protected boolean runAllTasks(long timeoutNanos) {
    long lastExecutionTime;
    fetchFromScheduledTaskQueue();
    Runnable task = pollTask();
    if (task == null) {
      afterRunningAllTasks();
      return false;
    } 
    long deadline = (timeoutNanos > 0L) ? (getCurrentTimeNanos() + timeoutNanos) : 0L;
    long runTasks = 0L;
    while (true) {
      safeExecute(task);
      runTasks++;
      if ((runTasks & 0x3FL) == 0L) {
        lastExecutionTime = getCurrentTimeNanos();
        if (lastExecutionTime >= deadline)
          break; 
      } 
      task = pollTask();
      if (task == null) {
        lastExecutionTime = getCurrentTimeNanos();
        break;
      } 
    } 
    afterRunningAllTasks();
    this.lastExecutionTime = lastExecutionTime;
    return true;
  }
  
  protected void afterRunningAllTasks() {}
  
  protected long delayNanos(long currentTimeNanos) {
    currentTimeNanos -= initialNanoTime();
    ScheduledFutureTask<?> scheduledTask = peekScheduledTask();
    if (scheduledTask == null)
      return SCHEDULE_PURGE_INTERVAL; 
    return scheduledTask.delayNanos(currentTimeNanos);
  }
  
  protected long deadlineNanos() {
    ScheduledFutureTask<?> scheduledTask = peekScheduledTask();
    if (scheduledTask == null)
      return getCurrentTimeNanos() + SCHEDULE_PURGE_INTERVAL; 
    return scheduledTask.deadlineNanos();
  }
  
  protected void updateLastExecutionTime() { this.lastExecutionTime = getCurrentTimeNanos(); }
  
  protected void cleanup() {}
  
  protected void wakeup(boolean inEventLoop) {
    if (!inEventLoop)
      this.taskQueue.offer(WAKEUP_TASK); 
  }
  
  public boolean inEventLoop(Thread thread) { return (thread == this.thread); }
  
  public void addShutdownHook(Runnable task) {
    if (inEventLoop()) {
      this.shutdownHooks.add(task);
    } else {
      execute(new Object(this, task));
    } 
  }
  
  public void removeShutdownHook(Runnable task) {
    if (inEventLoop()) {
      this.shutdownHooks.remove(task);
    } else {
      execute(new Object(this, task));
    } 
  }
  
  private boolean runShutdownHooks() {
    ran = false;
    while (!this.shutdownHooks.isEmpty()) {
      List<Runnable> copy = new ArrayList<Runnable>(this.shutdownHooks);
      this.shutdownHooks.clear();
      for (Runnable task : copy) {
        try {
          runTask(task);
        } catch (Throwable t) {
          logger.warn("Shutdown hook raised an exception.", t);
        } finally {
          ran = true;
        } 
      } 
    } 
    if (ran)
      this.lastExecutionTime = getCurrentTimeNanos(); 
    return ran;
  }
  
  public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {
    int newState, oldState;
    boolean wakeup;
    ObjectUtil.checkPositiveOrZero(quietPeriod, "quietPeriod");
    if (timeout < quietPeriod)
      throw new IllegalArgumentException("timeout: " + timeout + " (expected >= quietPeriod (" + quietPeriod + "))"); 
    ObjectUtil.checkNotNull(unit, "unit");
    if (isShuttingDown())
      return terminationFuture(); 
    boolean inEventLoop = inEventLoop();
    do {
      if (isShuttingDown())
        return terminationFuture(); 
      wakeup = true;
      oldState = this.state;
      if (inEventLoop) {
        newState = 3;
      } else {
        int newState;
        switch (oldState) {
          case 1:
          case 2:
            newState = 3;
            break;
          default:
            newState = oldState;
            wakeup = false;
            break;
        } 
      } 
    } while (!STATE_UPDATER.compareAndSet(this, oldState, newState));
    this.gracefulShutdownQuietPeriod = unit.toNanos(quietPeriod);
    this.gracefulShutdownTimeout = unit.toNanos(timeout);
    if (ensureThreadStarted(oldState))
      return this.terminationFuture; 
    if (wakeup) {
      this.taskQueue.offer(WAKEUP_TASK);
      if (!this.addTaskWakesUp)
        wakeup(inEventLoop); 
    } 
    return terminationFuture();
  }
  
  public Future<?> terminationFuture() { return this.terminationFuture; }
  
  @Deprecated
  public void shutdown() {
    int newState, oldState;
    boolean wakeup;
    if (isShutdown())
      return; 
    boolean inEventLoop = inEventLoop();
    do {
      if (isShuttingDown())
        return; 
      wakeup = true;
      oldState = this.state;
      if (inEventLoop) {
        newState = 4;
      } else {
        int newState;
        switch (oldState) {
          case 1:
          case 2:
          case 3:
            newState = 4;
            break;
          default:
            newState = oldState;
            wakeup = false;
            break;
        } 
      } 
    } while (!STATE_UPDATER.compareAndSet(this, oldState, newState));
    if (ensureThreadStarted(oldState))
      return; 
    if (wakeup) {
      this.taskQueue.offer(WAKEUP_TASK);
      if (!this.addTaskWakesUp)
        wakeup(inEventLoop); 
    } 
  }
  
  public boolean isShuttingDown() { return (this.state >= 3); }
  
  public boolean isShutdown() { return (this.state >= 4); }
  
  public boolean isTerminated() { return (this.state == 5); }
  
  protected boolean confirmShutdown() {
    if (!isShuttingDown())
      return false; 
    if (!inEventLoop())
      throw new IllegalStateException("must be invoked from an event loop"); 
    cancelScheduledTasks();
    if (this.gracefulShutdownStartTime == 0L)
      this.gracefulShutdownStartTime = getCurrentTimeNanos(); 
    if (runAllTasks() || runShutdownHooks()) {
      if (isShutdown())
        return true; 
      if (this.gracefulShutdownQuietPeriod == 0L)
        return true; 
      this.taskQueue.offer(WAKEUP_TASK);
      return false;
    } 
    long nanoTime = getCurrentTimeNanos();
    if (isShutdown() || nanoTime - this.gracefulShutdownStartTime > this.gracefulShutdownTimeout)
      return true; 
    if (nanoTime - this.lastExecutionTime <= this.gracefulShutdownQuietPeriod) {
      this.taskQueue.offer(WAKEUP_TASK);
      try {
        Thread.sleep(100L);
      } catch (InterruptedException interruptedException) {}
      return false;
    } 
    return true;
  }
  
  public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
    ObjectUtil.checkNotNull(unit, "unit");
    if (inEventLoop())
      throw new IllegalStateException("cannot await termination of the current thread"); 
    this.threadLock.await(timeout, unit);
    return isTerminated();
  }
  
  public void execute(Runnable task) { execute0(task); }
  
  public void lazyExecute(Runnable task) { lazyExecute0(task); }
  
  private void execute0(@Schedule Runnable task) {
    ObjectUtil.checkNotNull(task, "task");
    execute(task, wakesUpForTask(task));
  }
  
  private void lazyExecute0(@Schedule Runnable task) { execute((Runnable)ObjectUtil.checkNotNull(task, "task"), false); }
  
  private void execute(Runnable task, boolean immediate) {
    boolean inEventLoop = inEventLoop();
    addTask(task);
    if (!inEventLoop) {
      startThread();
      if (isShutdown()) {
        boolean reject = false;
        try {
          if (removeTask(task))
            reject = true; 
        } catch (UnsupportedOperationException unsupportedOperationException) {}
        if (reject)
          reject(); 
      } 
    } 
    if (!this.addTaskWakesUp && immediate)
      wakeup(inEventLoop); 
  }
  
  public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {
    throwIfInEventLoop("invokeAny");
    return (T)super.invokeAny(tasks);
  }
  
  public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
    throwIfInEventLoop("invokeAny");
    return (T)super.invokeAny(tasks, timeout, unit);
  }
  
  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
    throwIfInEventLoop("invokeAll");
    return super.invokeAll(tasks);
  }
  
  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {
    throwIfInEventLoop("invokeAll");
    return super.invokeAll(tasks, timeout, unit);
  }
  
  private void throwIfInEventLoop(String method) {
    if (inEventLoop())
      throw new RejectedExecutionException("Calling " + method + " from within the EventLoop is not allowed"); 
  }
  
  public final ThreadProperties threadProperties() {
    ThreadProperties threadProperties1 = this.threadProperties;
    if (threadProperties1 == null) {
      Thread thread = this.thread;
      if (thread == null) {
        assert !inEventLoop();
        submit(NOOP_TASK).syncUninterruptibly();
        thread = this.thread;
        assert thread != null;
      } 
      DefaultThreadProperties defaultThreadProperties = new DefaultThreadProperties(thread);
      if (!PROPERTIES_UPDATER.compareAndSet(this, null, defaultThreadProperties))
        threadProperties1 = this.threadProperties; 
    } 
    return threadProperties1;
  }
  
  protected boolean wakesUpForTask(Runnable task) { return true; }
  
  protected static void reject() { throw new RejectedExecutionException("event executor terminated"); }
  
  protected final void reject(Runnable task) { this.rejectedExecutionHandler.rejected(task, this); }
  
  private static final long SCHEDULE_PURGE_INTERVAL = TimeUnit.SECONDS.toNanos(1L);
  
  private void startThread() {
    if (this.state == 1 && 
      STATE_UPDATER.compareAndSet(this, 1, 2)) {
      success = false;
      try {
        doStartThread();
        success = true;
      } finally {
        if (!success)
          STATE_UPDATER.compareAndSet(this, 2, 1); 
      } 
    } 
  }
  
  private boolean ensureThreadStarted(int oldState) {
    if (oldState == 1)
      try {
        doStartThread();
      } catch (Throwable cause) {
        STATE_UPDATER.set(this, 5);
        this.terminationFuture.tryFailure(cause);
        if (!(cause instanceof Exception))
          PlatformDependent.throwException(cause); 
        return true;
      }  
    return false;
  }
  
  private void doStartThread() {
    assert this.thread == null;
    this.executor.execute(new Object(this));
  }
  
  final int drainTasks() {
    int numTasks = 0;
    while (true) {
      Runnable runnable = (Runnable)this.taskQueue.poll();
      if (runnable == null)
        break; 
      if (WAKEUP_TASK != runnable)
        numTasks++; 
    } 
    return numTasks;
  }
  
  protected abstract void run();
}
