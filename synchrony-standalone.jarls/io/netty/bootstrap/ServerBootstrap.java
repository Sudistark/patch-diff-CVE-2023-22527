package io.netty.bootstrap;

import io.netty.channel.Channel;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.util.AttributeKey;
import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class ServerBootstrap extends AbstractBootstrap<ServerBootstrap, ServerChannel> {
  private static final InternalLogger logger = InternalLoggerFactory.getInstance(ServerBootstrap.class);
  
  private final Map<ChannelOption<?>, Object> childOptions = new LinkedHashMap();
  
  private final Map<AttributeKey<?>, Object> childAttrs = new ConcurrentHashMap();
  
  private final ServerBootstrapConfig config = new ServerBootstrapConfig(this);
  
  private ServerBootstrap(ServerBootstrap bootstrap) {
    super(bootstrap);
    this.childGroup = bootstrap.childGroup;
    this.childHandler = bootstrap.childHandler;
    synchronized (bootstrap.childOptions) {
      this.childOptions.putAll(bootstrap.childOptions);
    } 
    this.childAttrs.putAll(bootstrap.childAttrs);
  }
  
  public ServerBootstrap group(EventLoopGroup group) { return group(group, group); }
  
  public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) {
    super.group(parentGroup);
    if (this.childGroup != null)
      throw new IllegalStateException("childGroup set already"); 
    this.childGroup = (EventLoopGroup)ObjectUtil.checkNotNull(childGroup, "childGroup");
    return this;
  }
  
  public <T> ServerBootstrap childOption(ChannelOption<T> childOption, T value) {
    ObjectUtil.checkNotNull(childOption, "childOption");
    synchronized (this.childOptions) {
      if (value == null) {
        this.childOptions.remove(childOption);
      } else {
        this.childOptions.put(childOption, value);
      } 
    } 
    return this;
  }
  
  public <T> ServerBootstrap childAttr(AttributeKey<T> childKey, T value) {
    ObjectUtil.checkNotNull(childKey, "childKey");
    if (value == null) {
      this.childAttrs.remove(childKey);
    } else {
      this.childAttrs.put(childKey, value);
    } 
    return this;
  }
  
  public ServerBootstrap childHandler(ChannelHandler childHandler) {
    this.childHandler = (ChannelHandler)ObjectUtil.checkNotNull(childHandler, "childHandler");
    return this;
  }
  
  void init(Channel channel) {
    setChannelOptions(channel, newOptionsArray(), logger);
    setAttributes(channel, newAttributesArray());
    ChannelPipeline p = channel.pipeline();
    EventLoopGroup currentChildGroup = this.childGroup;
    ChannelHandler currentChildHandler = this.childHandler;
    Map.Entry[] arrayOfEntry1 = newOptionsArray(this.childOptions);
    Map.Entry[] arrayOfEntry2 = newAttributesArray(this.childAttrs);
    p.addLast(new ChannelHandler[] { new Object(this, currentChildGroup, currentChildHandler, arrayOfEntry1, arrayOfEntry2) });
  }
  
  public ServerBootstrap validate() {
    super.validate();
    if (this.childHandler == null)
      throw new IllegalStateException("childHandler not set"); 
    if (this.childGroup == null) {
      logger.warn("childGroup is not set. Using parentGroup instead.");
      this.childGroup = this.config.group();
    } 
    return this;
  }
  
  public ServerBootstrap clone() { return new ServerBootstrap(this); }
  
  @Deprecated
  public EventLoopGroup childGroup() { return this.childGroup; }
  
  final ChannelHandler childHandler() { return this.childHandler; }
  
  final Map<ChannelOption<?>, Object> childOptions() {
    synchronized (this.childOptions) {
      return copiedMap(this.childOptions);
    } 
  }
  
  final Map<AttributeKey<?>, Object> childAttrs() { return copiedMap(this.childAttrs); }
  
  public final ServerBootstrapConfig config() { return this.config; }
  
  public ServerBootstrap() {}
}
