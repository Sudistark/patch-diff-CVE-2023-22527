package hickory;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class hiccup_utils__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__3;
  
  public static final AFn const__4;
  
  public static final Var const__5;
  
  public static final AFn const__14;
  
  public static final Var const__15;
  
  public static final AFn const__18;
  
  public static final Var const__19;
  
  public static final AFn const__22;
  
  public static final Var const__23;
  
  public static final AFn const__26;
  
  public static final Var const__27;
  
  public static final AFn const__30;
  
  public static final Var const__31;
  
  public static final AFn const__34;
  
  public static final Var const__35;
  
  public static final AFn const__38;
  
  public static final Var const__39;
  
  public static final AFn const__42;
  
  public static final Var const__43;
  
  public static final AFn const__46;
  
  public static final Var const__47;
  
  public static final AFn const__50;
  
  public static void load() { LockingTransaction.runInTransaction((Callable)new hiccup_utils.fn__59132());
    const__5.setMeta((IPersistentMap)const__14);
    const__5.bindRoot(new hiccup_utils.first_idx());
    const__15.setMeta((IPersistentMap)const__18);
    const__15.bindRoot(new hiccup_utils.index_of());
    const__19.setMeta((IPersistentMap)const__22);
    const__19.bindRoot(new hiccup_utils.split_keep_trailing_empty());
    const__23.setMeta((IPersistentMap)const__26);
    const__23.bindRoot(new hiccup_utils.tag_well_formed_QMARK_());
    const__27.setMeta((IPersistentMap)const__30);
    const__27.bindRoot(new hiccup_utils.tag_name());
    const__31.setMeta((IPersistentMap)const__34);
    const__31.bindRoot(new hiccup_utils.class_names());
    const__35.setMeta((IPersistentMap)const__38);
    const__35.bindRoot(new hiccup_utils.id());
    const__39.setMeta((IPersistentMap)const__42);
    const__39.bindRoot(new hiccup_utils.expand_content_seqs());
    const__43.setMeta((IPersistentMap)const__46);
    const__43.bindRoot(new hiccup_utils.normalize_element());
    const__47.setMeta((IPersistentMap)const__50);
    const__47.bindRoot(new hiccup_utils.normalize_form()); }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "hickory.hiccup-utils")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Utilities for working with hiccup forms." }));
    const__3 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Utilities for working with hiccup forms." });
    const__4 = (AFn)Symbol.intern(null, "clojure.core");
    const__5 = (Var)RT.var("hickory.hiccup-utils", "first-idx");
    const__14 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "a")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "b")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") }))) })), RT.keyword(null, "doc"), "Given two possible indexes, returns the lesser that is not -1. If both\n   are -1, then -1 is returned. Useful for searching strings for multiple\n   markers, as many routines will return -1 for not found.\n\n   Examples: (first-idx -1 -1) => -1\n             (first-idx -1 2) => 2\n             (first-idx 5 -1) => 5\n             (first-idx 5 3) => 3", RT.keyword(null, "line"), Integer.valueOf(5), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "hickory/hiccup_utils.cljc" });
    const__15 = (Var)RT.var("hickory.hiccup-utils", "index-of");
    const__18 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })), Symbol.intern(null, "c")), Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })), Symbol.intern(null, "c"), Symbol.intern(null, "idx")) })), RT.keyword(null, "line"), Integer.valueOf(22), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "hickory/hiccup_utils.cljc" });
    const__19 = (Var)RT.var("hickory.hiccup-utils", "split-keep-trailing-empty");
    const__22 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s"), Symbol.intern(null, "re")) })), RT.keyword(null, "doc"), "clojure.string/split is a wrapper on java.lang.String/split with the limit\n   parameter equal to 0, which keeps leading empty strings, but discards\n   trailing empty strings. This makes no sense, so we have to write our own\n   to keep the trailing empty strings.", RT.keyword(null, "line"), Integer.valueOf(30), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "hickory/hiccup_utils.cljc" });
    const__23 = (Var)RT.var("hickory.hiccup-utils", "tag-well-formed?");
    const__26 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "tag-elem")) })), RT.keyword(null, "doc"), "Given a hiccup tag element, returns true iff the tag is in 'valid' hiccup\n   format. Which in this function means:\n      1. Tag name is non-empty.\n      2. If there is an id, there is only one.\n      3. If there is an id, it is nonempty.\n      4. If there is an id, it comes before any classes.\n      5. Any class name is nonempty.", RT.keyword(null, "line"), Integer.valueOf(38), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "hickory/hiccup_utils.cljc" });
    const__27 = (Var)RT.var("hickory.hiccup-utils", "tag-name");
    const__30 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "tag-elem")) })), RT.keyword(null, "doc"), "Given a well-formed hiccup tag element, return just the tag name as\n  a string.", RT.keyword(null, "line"), Integer.valueOf(68), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "hickory/hiccup_utils.cljc" });
    const__31 = (Var)RT.var("hickory.hiccup-utils", "class-names");
    const__34 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "tag-elem")) })), RT.keyword(null, "doc"), "Given a well-formed hiccup tag element, return a vector containing\n   any class names included in the tag, as strings. Ignores the hiccup\n   requirement that any id on the tag must come\n   first. Example: :div.foo.bar => [\"foo\" \"bar\"].", RT.keyword(null, "line"), Integer.valueOf(83), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "hickory/hiccup_utils.cljc" });
    const__35 = (Var)RT.var("hickory.hiccup-utils", "id");
    const__38 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "tag-elem")) })), RT.keyword(null, "doc"), "Given a well-formed hiccup tag element, return a string containing\n   the id, or nil if there isn't one.", RT.keyword(null, "line"), Integer.valueOf(108), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "hickory/hiccup_utils.cljc" });
    const__39 = (Var)RT.var("hickory.hiccup-utils", "expand-content-seqs");
    const__42 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "content")) })), RT.keyword(null, "doc"), "Given a sequence of hiccup forms, presumably the content forms of another\n   hiccup element, return a new sequence with any sequence elements expanded\n   into the main sequence. This logic does not apply recursively, so sequences\n   inside sequences won't be expanded out. Also note that this really only\n   applies to sequences; things that seq? returns true on. So this excludes\n   vectors.\n     (expand-content-seqs [1 '(2 3) (for [x [1 2 3]] (* x 2)) [5]])\n     ==> (1 2 3 2 4 6 [5])", RT.keyword(null, "line"), Integer.valueOf(121), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "hickory/hiccup_utils.cljc" });
    const__43 = (Var)RT.var("hickory.hiccup-utils", "normalize-element");
    const__46 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "hiccup-form")) })), RT.keyword(null, "doc"), "Given a well-formed hiccup form, ensure that it is in the form\n     [tag attributes content1 ... contentN].\n   That is, an unadorned tag name (keyword, lowercase), all attributes in the\n   attribute map in the second element, and then any children. Note that this\n   does not happen recursively; content is not modified.", RT.keyword(null, "line"), Integer.valueOf(148), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "hickory/hiccup_utils.cljc" });
    const__47 = (Var)RT.var("hickory.hiccup-utils", "normalize-form");
    const__50 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Given a well-formed hiccup form, recursively normalizes it, so that it and\n   all children elements will also be normalized. A normalized form is in the\n   form\n     [tag attributes content1 ... contentN].\n   That is, an unadorned tag name (keyword, lowercase), all attributes in the\n   attribute map in the second element, and then any children. Any content\n   that is a sequence is also expanded out into the main sequence of content\n   items.", RT.keyword(null, "line"), Integer.valueOf(174), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "hickory/hiccup_utils.cljc" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("hickory.hiccup_utils__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
