package com.mchange.v2.csv;

import java.io.BufferedReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public final class FastCsvUtils {
  private static final int ESCAPE_BIT = 16777216;
  
  private static final int SHIFT_BIT = 33554432;
  
  private static final int SHIFT_OFFSET = 8;
  
  private static final int CR = 13;
  
  private static final int LF = 10;
  
  private static final int EOF = -1;
  
  private static final int CRLF_TOKEN = 999;
  
  private static final String CRLF = "\r\n";
  
  private static final int GUESSED_LINE_LEN = 512;
  
  public static String csvReadLine(BufferedReader paramBufferedReader) throws IOException, MalformedCsvException {
    String str2;
    int[] arrayOfInt = new int[1];
    String str1 = readLine(paramBufferedReader, arrayOfInt);
    if (str1 != null) {
      int i = countQuotes(str1);
      if (i % 2 != 0) {
        StringBuilder stringBuilder = new StringBuilder(str1);
        do {
          appendForToken(arrayOfInt[0], stringBuilder);
          str1 = readLine(paramBufferedReader, arrayOfInt);
          if (str1 != null) {
            stringBuilder.append(str1);
            i += countQuotes(str1);
          } else {
            throw new MalformedCsvException("Unterminated quote at EOF: '" + stringBuilder.toString() + "'");
          } 
        } while (i % 2 != 0);
        str2 = stringBuilder.toString();
      } else {
        str2 = str1;
      } 
    } else {
      str2 = null;
    } 
    return str2;
  }
  
  private static void appendForToken(int paramInt, StringBuilder paramStringBuilder) {
    switch (paramInt) {
      case 10:
      case 13:
        paramStringBuilder.append((char)paramInt);
      case 999:
        paramStringBuilder.append("\r\n");
      case -1:
        return;
    } 
    throw new InternalError("Unexpected token (should never happen): " + paramInt);
  }
  
  private static String readLine(BufferedReader paramBufferedReader, int[] paramArrayOfInt) throws IOException {
    StringBuilder stringBuilder = new StringBuilder(512);
    int i = paramBufferedReader.read();
    if (i < 0) {
      paramArrayOfInt[0] = -1;
      return null;
    } 
    while (notSepOrEOF(i)) {
      stringBuilder.append((char)i);
      i = paramBufferedReader.read();
    } 
    if (i == 13) {
      paramBufferedReader.mark(1);
      int j = paramBufferedReader.read();
      if (j == 10) {
        paramArrayOfInt[0] = 999;
      } else {
        paramBufferedReader.reset();
        paramArrayOfInt[0] = 13;
      } 
    } else {
      paramArrayOfInt[0] = i;
    } 
    return stringBuilder.toString();
  }
  
  private static boolean notSepOrEOF(int paramInt) { return (paramInt >= 0 && paramInt != 10 && paramInt != 13); }
  
  private static int countQuotes(String paramString) {
    char[] arrayOfChar = paramString.toCharArray();
    byte b1 = 0;
    byte b2;
    int i;
    for (b2 = 0, i = arrayOfChar.length; b2 < i; b2++) {
      if (arrayOfChar[b2] == '"')
        b1++; 
    } 
    return b1;
  }
  
  public static String[] splitRecord(String paramString) throws MalformedCsvException {
    int[] arrayOfInt = upshiftQuoteString(paramString);
    List list = splitShifted(arrayOfInt);
    int i = list.size();
    String[] arrayOfString = new String[i];
    for (byte b = 0; b < i; b++)
      arrayOfString[b] = downshift((int[])list.get(b)); 
    return arrayOfString;
  }
  
  private static void debugPrint(int[] paramArrayOfInt) {
    int i = paramArrayOfInt.length;
    char[] arrayOfChar = new char[i];
    for (byte b = 0; b < i; b++)
      arrayOfChar[b] = isShifted(paramArrayOfInt[b]) ? '_' : (char)paramArrayOfInt[b]; 
    System.err.println(new String(arrayOfChar));
  }
  
  private static List splitShifted(int[] paramArrayOfInt) {
    ArrayList arrayList = new ArrayList();
    byte b1 = 0;
    byte b2;
    int i;
    for (b2 = 0, i = paramArrayOfInt.length; b2 <= i; b2++) {
      if (b2 == i || paramArrayOfInt[b2] == 44) {
        boolean bool = b2 - b1;
        byte b4 = -1;
        byte b3;
        for (b3 = b1; b3 <= b2; b3++) {
          if (b3 == b2) {
            b4 = 0;
            break;
          } 
          if (paramArrayOfInt[b3] != 32 && paramArrayOfInt[b3] != 9)
            break; 
        } 
        if (b4 < 0)
          if (b3 == b2 - 1) {
            b4 = 1;
          } else {
            for (b4 = b2 - b3; b4 > 0; b4--) {
              byte b = b3 + b4 - 1;
              if (paramArrayOfInt[b] != 32 && paramArrayOfInt[b] != 9)
                break; 
            } 
          }  
        int[] arrayOfInt = new int[b4];
        if (b4 > 0)
          System.arraycopy(paramArrayOfInt, b3, arrayOfInt, 0, b4); 
        arrayList.add(arrayOfInt);
        b1 = b2 + 1;
      } 
    } 
    return arrayList;
  }
  
  private static String downshift(int[] paramArrayOfInt) {
    int i = paramArrayOfInt.length;
    char[] arrayOfChar = new char[i];
    for (byte b = 0; b < i; b++) {
      int j = paramArrayOfInt[b];
      arrayOfChar[b] = (char)(isShifted(j) ? (j >>> 8) : j);
    } 
    return new String(arrayOfChar);
  }
  
  private static boolean isShifted(int paramInt) { return ((paramInt & 0x2000000) != 0); }
  
  private static int[] upshiftQuoteString(String paramString) throws MalformedCsvException {
    char[] arrayOfChar = paramString.toCharArray();
    int[] arrayOfInt1 = new int[arrayOfChar.length];
    EscapedCharReader escapedCharReader = new EscapedCharReader(arrayOfChar);
    byte b = 0;
    boolean bool = false;
    int i;
    for (i = escapedCharReader.read(bool); i >= 0; i = escapedCharReader.read(bool)) {
      if (i == 34) {
        bool = !bool;
      } else {
        arrayOfInt1[b++] = findShiftyChar(i, bool);
      } 
    } 
    int[] arrayOfInt2 = new int[b];
    System.arraycopy(arrayOfInt1, 0, arrayOfInt2, 0, b);
    return arrayOfInt2;
  }
  
  private static int findShiftyChar(int paramInt, boolean paramBoolean) { return paramBoolean ? (paramInt << 8 | 0x2000000) : paramInt; }
  
  private static int escape(int paramInt) { return paramInt | 0x1000000; }
  
  private static boolean isEscaped(int paramInt) { return ((paramInt & 0x1000000) != 0); }
}
