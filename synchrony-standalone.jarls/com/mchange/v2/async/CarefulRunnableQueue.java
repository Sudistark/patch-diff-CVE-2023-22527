package com.mchange.v2.async;

import com.mchange.v2.log.MLevel;
import com.mchange.v2.log.MLog;
import com.mchange.v2.log.MLogger;
import com.mchange.v2.util.ResourceClosedException;
import java.util.LinkedList;
import java.util.List;

public class CarefulRunnableQueue implements RunnableQueue, Queuable, StrandedTaskReporting {
  private static final MLogger logger = MLog.getLogger(CarefulRunnableQueue.class);
  
  private List taskList;
  
  private TaskThread t;
  
  private boolean shutdown_on_interrupt;
  
  private boolean gentle_close_requested;
  
  private List strandedTasks;
  
  public CarefulRunnableQueue(boolean paramBoolean1, boolean paramBoolean2) {
    this.taskList = new LinkedList();
    this.t = new TaskThread(this);
    this.gentle_close_requested = false;
    this.strandedTasks = null;
    this.shutdown_on_interrupt = paramBoolean2;
    this.t.setDaemon(paramBoolean1);
    this.t.start();
  }
  
  public RunnableQueue asRunnableQueue() { return this; }
  
  public void postRunnable(Runnable paramRunnable) {
    try {
      if (this.gentle_close_requested)
        throw new ResourceClosedException("Attempted to post a task to a closing CarefulRunnableQueue."); 
      this.taskList.add(paramRunnable);
      notifyAll();
    } catch (NullPointerException nullPointerException) {
      if (logger.isLoggable(MLevel.FINE))
        logger.log(MLevel.FINE, "NullPointerException while posting Runnable.", nullPointerException); 
      if (this.taskList == null)
        throw new ResourceClosedException("Attempted to post a task to a CarefulRunnableQueue which has been closed, or whose TaskThread has been interrupted."); 
      throw nullPointerException;
    } 
  }
  
  public void close(boolean paramBoolean) {
    if (paramBoolean) {
      this.t.safeStop();
      this.t.interrupt();
    } else {
      this.gentle_close_requested = true;
    } 
  }
  
  public void close() { close(true); }
  
  public List getStrandedTasks() {
    try {
      while (this.gentle_close_requested && this.taskList != null)
        wait(); 
      return this.strandedTasks;
    } catch (InterruptedException interruptedException) {
      if (logger.isLoggable(MLevel.WARNING))
        logger.log(MLevel.WARNING, 
            Thread.currentThread() + " interrupted while waiting for stranded tasks from CarefulRunnableQueue.", interruptedException); 
      throw new RuntimeException(Thread.currentThread() + " interrupted while waiting for stranded tasks from CarefulRunnableQueue.");
    } 
  }
  
  private Runnable dequeueRunnable() {
    Runnable runnable = (Runnable)this.taskList.get(0);
    this.taskList.remove(0);
    return runnable;
  }
  
  private void awaitTask() {
    while (this.taskList.size() == 0) {
      if (this.gentle_close_requested) {
        this.t.safeStop();
        this.t.interrupt();
      } 
      wait();
    } 
  }
}
