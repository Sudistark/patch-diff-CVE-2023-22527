package com.mchange.v2.async;

import com.mchange.v2.io.IndentedWriter;
import com.mchange.v2.log.MLevel;
import com.mchange.v2.log.MLog;
import com.mchange.v2.log.MLogger;
import com.mchange.v2.util.ResourceClosedException;
import java.io.IOException;
import java.io.StringWriter;
import java.lang.reflect.Method;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Random;
import java.util.Timer;
import java.util.TimerTask;

public final class ThreadPoolAsynchronousRunner implements AsynchronousRunner {
  static final MLogger logger = MLog.getLogger(ThreadPoolAsynchronousRunner.class);
  
  static final int POLL_FOR_STOP_INTERVAL = 5000;
  
  static final int DFLT_DEADLOCK_DETECTOR_INTERVAL = 10000;
  
  static final int DFLT_INTERRUPT_DELAY_AFTER_APPARENT_DEADLOCK = 60000;
  
  static final int DFLT_MAX_INDIVIDUAL_TASK_TIME = 0;
  
  static final int DFLT_MAX_EMERGENCY_THREADS = 10;
  
  static final long PURGE_EVERY = 500L;
  
  int deadlock_detector_interval;
  
  int interrupt_delay_after_apparent_deadlock;
  
  int max_individual_task_time;
  
  int num_threads;
  
  boolean daemon;
  
  HashSet managed;
  
  HashSet available;
  
  LinkedList pendingTasks;
  
  Random rnd;
  
  Timer myTimer;
  
  boolean should_cancel_timer;
  
  TimerTask deadlockDetector;
  
  TimerTask replacedThreadInterruptor;
  
  Map stoppedThreadsToStopDates;
  
  String threadLabel;
  
  private ThreadPoolAsynchronousRunner(int paramInt1, boolean paramBoolean1, int paramInt2, int paramInt3, int paramInt4, Timer paramTimer, boolean paramBoolean2, String paramString) {
    this.rnd = new Random();
    this.deadlockDetector = new DeadlockDetector(this);
    this.replacedThreadInterruptor = null;
    this.stoppedThreadsToStopDates = new HashMap();
    this.num_threads = paramInt1;
    this.daemon = paramBoolean1;
    this.max_individual_task_time = paramInt2;
    this.deadlock_detector_interval = paramInt3;
    this.interrupt_delay_after_apparent_deadlock = paramInt4;
    this.myTimer = paramTimer;
    this.should_cancel_timer = paramBoolean2;
    this.threadLabel = paramString;
    recreateThreadsAndTasks();
    paramTimer.schedule(this.deadlockDetector, paramInt3, paramInt3);
  }
  
  private ThreadPoolAsynchronousRunner(int paramInt1, boolean paramBoolean1, int paramInt2, int paramInt3, int paramInt4, Timer paramTimer, boolean paramBoolean2) { this(paramInt1, paramBoolean1, paramInt2, paramInt3, paramInt4, paramTimer, paramBoolean2, null); }
  
  public ThreadPoolAsynchronousRunner(int paramInt1, boolean paramBoolean, int paramInt2, int paramInt3, int paramInt4, Timer paramTimer, String paramString) { this(paramInt1, paramBoolean, paramInt2, paramInt3, paramInt4, paramTimer, false, paramString); }
  
  public ThreadPoolAsynchronousRunner(int paramInt1, boolean paramBoolean, int paramInt2, int paramInt3, int paramInt4, Timer paramTimer) { this(paramInt1, paramBoolean, paramInt2, paramInt3, paramInt4, paramTimer, false); }
  
  public ThreadPoolAsynchronousRunner(int paramInt1, boolean paramBoolean, int paramInt2, int paramInt3, int paramInt4, String paramString) { this(paramInt1, paramBoolean, paramInt2, paramInt3, paramInt4, new Timer(true), true, paramString); }
  
  public ThreadPoolAsynchronousRunner(int paramInt1, boolean paramBoolean, int paramInt2, int paramInt3, int paramInt4) { this(paramInt1, paramBoolean, paramInt2, paramInt3, paramInt4, new Timer(true), true); }
  
  public ThreadPoolAsynchronousRunner(int paramInt, boolean paramBoolean, Timer paramTimer, String paramString) { this(paramInt, paramBoolean, 0, 10000, 60000, paramTimer, false, paramString); }
  
  public ThreadPoolAsynchronousRunner(int paramInt, boolean paramBoolean, Timer paramTimer) { this(paramInt, paramBoolean, 0, 10000, 60000, paramTimer, false); }
  
  public ThreadPoolAsynchronousRunner(int paramInt, boolean paramBoolean) { this(paramInt, paramBoolean, 0, 10000, 60000, new Timer(true), true); }
  
  public void postRunnable(Runnable paramRunnable) {
    try {
      this.pendingTasks.add(paramRunnable);
      notifyAll();
      if (logger.isLoggable(MLevel.FINEST))
        logger.log(MLevel.FINEST, this + ": Adding task to queue -- " + paramRunnable); 
    } catch (NullPointerException nullPointerException) {
      if (logger.isLoggable(MLevel.FINE))
        logger.log(MLevel.FINE, "NullPointerException while posting Runnable -- Probably we're closed.", nullPointerException); 
      throw new ResourceClosedException("Attempted to use a ThreadPoolAsynchronousRunner in a closed or broken state.");
    } 
  }
  
  public int getThreadCount() { return this.managed.size(); }
  
  public void close(boolean paramBoolean) {
    synchronized (this) {
      if (this.managed == null)
        return; 
      this.deadlockDetector.cancel();
      if (this.should_cancel_timer)
        this.myTimer.cancel(); 
      this.myTimer = null;
      for (PoolThread poolThread : this.managed) {
        poolThread.gentleStop();
        if (paramBoolean)
          poolThread.interrupt(); 
      } 
      this.managed = null;
      if (!paramBoolean)
        for (Iterator iterator = this.pendingTasks.iterator(); iterator.hasNext(); ) {
          Runnable runnable = (Runnable)iterator.next();
          (new Thread(runnable)).start();
          iterator.remove();
        }  
      this.available = null;
      this.pendingTasks = null;
    } 
  }
  
  public void close() { close(true); }
  
  public int getActiveCount() { return this.managed.size() - this.available.size(); }
  
  public int getIdleCount() { return this.available.size(); }
  
  public int getPendingTaskCount() { return this.pendingTasks.size(); }
  
  public String getStatus() { return getMultiLineStatusString(); }
  
  public String getStackTraces() { return getStackTraces(0); }
  
  private String getStackTraces(int paramInt) {
    assert Thread.holdsLock(this);
    if (this.managed == null)
      return null; 
    try {
      Method method = Thread.class.getMethod("getStackTrace", (Class[])null);
      StringWriter stringWriter = new StringWriter(2048);
      IndentedWriter indentedWriter = new IndentedWriter(stringWriter);
      byte b;
      for (b = 0; b < paramInt; b++)
        indentedWriter.upIndent(); 
      for (Object object : this.managed) {
        Object[] arrayOfObject = (Object[])method.invoke(object, (Object[])null);
        printStackTraces(indentedWriter, object, arrayOfObject);
      } 
      for (b = 0; b < paramInt; b++)
        indentedWriter.downIndent(); 
      indentedWriter.flush();
      String str = stringWriter.toString();
      indentedWriter.close();
      return str;
    } catch (NoSuchMethodException noSuchMethodException) {
      if (logger.isLoggable(MLevel.FINE))
        logger.fine(this + ": stack traces unavailable because this is a pre-Java 1.5 VM."); 
      return null;
    } catch (Exception exception) {
      if (logger.isLoggable(MLevel.FINE))
        logger.log(MLevel.FINE, this + ": An Exception occurred while trying to extract PoolThread stack traces.", exception); 
      return null;
    } 
  }
  
  private String getJvmStackTraces(int paramInt) {
    try {
      Method method = Thread.class.getMethod("getAllStackTraces", (Class[])null);
      Map map = (Map)method.invoke(null, (Object[])null);
      StringWriter stringWriter = new StringWriter(2048);
      IndentedWriter indentedWriter = new IndentedWriter(stringWriter);
      byte b;
      for (b = 0; b < paramInt; b++)
        indentedWriter.upIndent(); 
      for (Map.Entry entry : map.entrySet()) {
        Object object = entry.getKey();
        Object[] arrayOfObject = (Object[])entry.getValue();
        printStackTraces(indentedWriter, object, arrayOfObject);
      } 
      for (b = 0; b < paramInt; b++)
        indentedWriter.downIndent(); 
      indentedWriter.flush();
      String str = stringWriter.toString();
      indentedWriter.close();
      return str;
    } catch (NoSuchMethodException noSuchMethodException) {
      if (logger.isLoggable(MLevel.FINE))
        logger.fine(this + ": JVM stack traces unavailable because this is a pre-Java 1.5 VM."); 
      return null;
    } catch (Exception exception) {
      if (logger.isLoggable(MLevel.FINE))
        logger.log(MLevel.FINE, this + ": An Exception occurred while trying to extract PoolThread stack traces.", exception); 
      return null;
    } 
  }
  
  private void printStackTraces(IndentedWriter paramIndentedWriter, Object paramObject, Object[] paramArrayOfObject) throws IOException {
    paramIndentedWriter.println(paramObject);
    paramIndentedWriter.upIndent();
    byte b;
    int i;
    for (b = 0, i = paramArrayOfObject.length; b < i; b++)
      paramIndentedWriter.println(paramArrayOfObject[b]); 
    paramIndentedWriter.downIndent();
  }
  
  public String getMultiLineStatusString() { return getMultiLineStatusString(0); }
  
  private String getMultiLineStatusString(int paramInt) {
    try {
      StringWriter stringWriter = new StringWriter(2048);
      IndentedWriter indentedWriter = new IndentedWriter(stringWriter);
      byte b;
      for (b = 0; b < paramInt; b++)
        indentedWriter.upIndent(); 
      if (this.managed == null) {
        indentedWriter.print("[");
        indentedWriter.print(this);
        indentedWriter.println(" closed.]");
      } else {
        HashSet hashSet = (HashSet)this.managed.clone();
        hashSet.removeAll(this.available);
        indentedWriter.print("Managed Threads: ");
        indentedWriter.println(this.managed.size());
        indentedWriter.print("Active Threads: ");
        indentedWriter.println(hashSet.size());
        indentedWriter.println("Active Tasks: ");
        indentedWriter.upIndent();
        for (PoolThread poolThread : hashSet) {
          indentedWriter.println(poolThread.getCurrentTask());
          indentedWriter.upIndent();
          indentedWriter.print("on thread: ");
          indentedWriter.println(poolThread.getName());
          indentedWriter.downIndent();
        } 
        indentedWriter.downIndent();
        indentedWriter.println("Pending Tasks: ");
        indentedWriter.upIndent();
        byte b1;
        int i;
        for (b1 = 0, i = this.pendingTasks.size(); b1 < i; b1++)
          indentedWriter.println(this.pendingTasks.get(b1)); 
        indentedWriter.downIndent();
      } 
      for (b = 0; b < paramInt; b++)
        indentedWriter.downIndent(); 
      indentedWriter.flush();
      String str = stringWriter.toString();
      indentedWriter.close();
      return str;
    } catch (IOException iOException) {
      if (logger.isLoggable(MLevel.WARNING))
        logger.log(MLevel.WARNING, "Huh? An IOException when working with a StringWriter?!?", iOException); 
      throw new RuntimeException("Huh? An IOException when working with a StringWriter?!? " + iOException);
    } 
  }
  
  private void appendStatusString(StringBuffer paramStringBuffer) {
    if (this.managed == null) {
      paramStringBuffer.append("[closed]");
    } else {
      HashSet hashSet = (HashSet)this.managed.clone();
      hashSet.removeAll(this.available);
      paramStringBuffer.append("[num_managed_threads: ");
      paramStringBuffer.append(this.managed.size());
      paramStringBuffer.append(", num_active: ");
      paramStringBuffer.append(hashSet.size());
      paramStringBuffer.append("; activeTasks: ");
      boolean bool = true;
      for (Iterator iterator = hashSet.iterator(); iterator.hasNext(); ) {
        if (bool) {
          bool = false;
        } else {
          paramStringBuffer.append(", ");
        } 
        PoolThread poolThread = (PoolThread)iterator.next();
        paramStringBuffer.append(poolThread.getCurrentTask());
        paramStringBuffer.append(" (");
        paramStringBuffer.append(poolThread.getName());
        paramStringBuffer.append(')');
      } 
      paramStringBuffer.append("; pendingTasks: ");
      byte b;
      int i;
      for (b = 0, i = this.pendingTasks.size(); b < i; b++) {
        if (b)
          paramStringBuffer.append(", "); 
        paramStringBuffer.append(this.pendingTasks.get(b));
      } 
      paramStringBuffer.append(']');
    } 
  }
  
  private void recreateThreadsAndTasks() {
    if (this.managed != null) {
      Date date = new Date();
      for (PoolThread poolThread : this.managed) {
        poolThread.gentleStop();
        this.stoppedThreadsToStopDates.put(poolThread, date);
        ensureReplacedThreadsProcessing();
      } 
    } 
    this.managed = new HashSet();
    this.available = new HashSet();
    this.pendingTasks = new LinkedList();
    for (byte b = 0; b < this.num_threads; b++) {
      PoolThread poolThread = new PoolThread(this, b, this.daemon);
      this.managed.add(poolThread);
      this.available.add(poolThread);
      poolThread.start();
    } 
  }
  
  private void processReplacedThreads() {
    long l = System.currentTimeMillis();
    for (Iterator iterator = this.stoppedThreadsToStopDates.keySet().iterator(); iterator.hasNext(); ) {
      PoolThread poolThread = (PoolThread)iterator.next();
      if (!poolThread.isAlive()) {
        iterator.remove();
      } else {
        Date date = (Date)this.stoppedThreadsToStopDates.get(poolThread);
        if (l - date.getTime() > this.interrupt_delay_after_apparent_deadlock) {
          if (logger.isLoggable(MLevel.WARNING))
            logger.log(MLevel.WARNING, "Task " + poolThread
                .getCurrentTask() + " (in deadlocked PoolThread) failed to complete in maximum time " + this.interrupt_delay_after_apparent_deadlock + "ms. Trying interrupt()."); 
          poolThread.interrupt();
          iterator.remove();
        } 
      } 
      if (this.stoppedThreadsToStopDates.isEmpty())
        stopReplacedThreadsProcessing(); 
    } 
  }
  
  private void ensureReplacedThreadsProcessing() {
    if (this.replacedThreadInterruptor == null) {
      if (logger.isLoggable(MLevel.FINE))
        logger.fine("Apparently some threads have been replaced. Replacement thread processing enabled."); 
      this.replacedThreadInterruptor = new ReplacedThreadInterruptor(this);
      int i = this.interrupt_delay_after_apparent_deadlock / 4;
      this.myTimer.schedule(this.replacedThreadInterruptor, i, i);
    } 
  }
  
  private void stopReplacedThreadsProcessing() {
    if (this.replacedThreadInterruptor != null) {
      this.replacedThreadInterruptor.cancel();
      this.replacedThreadInterruptor = null;
      if (logger.isLoggable(MLevel.FINE))
        logger.fine("Apparently all replaced threads have either completed their tasks or been interrupted(). Replacement thread processing cancelled."); 
    } 
  }
  
  private void shuttingDown(PoolThread paramPoolThread) {
    if (this.managed != null && this.managed.contains(paramPoolThread)) {
      this.managed.remove(paramPoolThread);
      this.available.remove(paramPoolThread);
      PoolThread poolThread = new PoolThread(this, paramPoolThread.getIndex(), this.daemon);
      this.managed.add(poolThread);
      this.available.add(poolThread);
      poolThread.start();
    } 
  }
  
  private void runInEmergencyThread(Runnable paramRunnable) {
    Thread thread = new Thread(paramRunnable);
    thread.start();
    if (this.max_individual_task_time > 0) {
      MaxIndividualTaskTimeEnforcer maxIndividualTaskTimeEnforcer = new MaxIndividualTaskTimeEnforcer(this, thread, thread + " [One-off emergency thread!!!]", paramRunnable.toString());
      this.myTimer.schedule(maxIndividualTaskTimeEnforcer, this.max_individual_task_time);
    } 
  }
}
