package com.mchange.v2.c3p0.stmt;

import com.mchange.v2.async.AsynchronousRunner;
import com.mchange.v2.io.IndentedWriter;
import com.mchange.v2.log.MLevel;
import com.mchange.v2.log.MLog;
import com.mchange.v2.log.MLogger;
import com.mchange.v2.sql.SqlUtils;
import com.mchange.v2.util.ResourceClosedException;
import java.io.IOException;
import java.io.StringWriter;
import java.lang.reflect.Method;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Set;

public abstract class GooGooStatementCache {
  private static final MLogger logger = MLog.getLogger(GooGooStatementCache.class);
  
  private static final int DESTROY_NEVER = 0;
  
  private static final int DESTROY_IF_CHECKED_IN = 1;
  
  private static final int DESTROY_IF_CHECKED_OUT = 2;
  
  private static final int DESTROY_ALWAYS = 3;
  
  private static final boolean CULL_ONLY_FROM_UNUSED_CONNECTIONS = false;
  
  ConnectionStatementManager cxnStmtMgr;
  
  HashMap stmtToKey;
  
  HashMap keyToKeyRec;
  
  HashSet checkedOut;
  
  AsynchronousRunner blockingTaskAsyncRunner;
  
  HashSet removalPending;
  
  StatementDestructionManager destructo;
  
  public GooGooStatementCache(AsynchronousRunner blockingTaskAsyncRunner, AsynchronousRunner deferredStatementDestroyer) {
    this.stmtToKey = new HashMap();
    this.keyToKeyRec = new HashMap();
    this.checkedOut = new HashSet();
    this.removalPending = new HashSet();
    this.blockingTaskAsyncRunner = blockingTaskAsyncRunner;
    this.cxnStmtMgr = createConnectionStatementManager();
    this.destructo = (deferredStatementDestroyer != null) ? new CautiousStatementDestructionManager(this, deferredStatementDestroyer) : new IncautiousStatementDestructionManager(this, blockingTaskAsyncRunner);
  }
  
  public int getNumStatements() { return isClosed() ? -1 : countCachedStatements(); }
  
  public int getNumStatementsCheckedOut() { return isClosed() ? -1 : this.checkedOut.size(); }
  
  public int getNumConnectionsWithCachedStatements() { return isClosed() ? -1 : this.cxnStmtMgr.getNumConnectionsWithCachedStatements(); }
  
  public String dumpStatementCacheStatus() {
    if (isClosed())
      return this + "status: Closed."; 
    StringWriter sw = new StringWriter(2048);
    IndentedWriter iw = new IndentedWriter(sw);
    try {
      iw.print(this);
      iw.println(" status:");
      iw.upIndent();
      iw.println("core stats:");
      iw.upIndent();
      iw.print("num cached statements: ");
      iw.println(countCachedStatements());
      iw.print("num cached statements in use: ");
      iw.println(this.checkedOut.size());
      iw.print("num connections with cached statements: ");
      iw.println(this.cxnStmtMgr.getNumConnectionsWithCachedStatements());
      iw.downIndent();
      iw.println("cached statement dump:");
      iw.upIndent();
      for (Iterator ii = this.cxnStmtMgr.connectionSet().iterator(); ii.hasNext(); ) {
        Connection pcon = (Connection)ii.next();
        iw.print(pcon);
        iw.println(':');
        iw.upIndent();
        for (Iterator jj = this.cxnStmtMgr.statementSet(pcon).iterator(); jj.hasNext();)
          iw.println(jj.next()); 
        iw.downIndent();
      } 
      iw.downIndent();
      iw.downIndent();
      return sw.toString();
    } catch (IOException e) {
      if (logger.isLoggable(MLevel.SEVERE))
        logger.log(MLevel.SEVERE, "Huh? We've seen an IOException writing to s StringWriter?!", e); 
      return e.toString();
    } 
  }
  
  public void waitMarkConnectionInUse(Connection physicalConnection) throws InterruptedException { this.destructo.waitMarkConnectionInUse(physicalConnection); }
  
  public boolean tryMarkConnectionInUse(Connection physicalConnection) { return this.destructo.tryMarkConnectionInUse(physicalConnection); }
  
  public void unmarkConnectionInUse(Connection physicalConnection) throws InterruptedException { this.destructo.unmarkConnectionInUse(physicalConnection); }
  
  public Boolean inUse(Connection physicalConnection) { return this.destructo.tvlInUse(physicalConnection); }
  
  public int getStatementDestroyerNumConnectionsInUse() { return this.destructo.getNumConnectionsInUse(); }
  
  public int getStatementDestroyerNumConnectionsWithDeferredDestroyStatements() { return this.destructo.getNumConnectionsWithDeferredDestroyStatements(); }
  
  public int getStatementDestroyerNumDeferredDestroyStatements() { return this.destructo.getNumDeferredDestroyStatements(); }
  
  public Object checkoutStatement(Connection physicalConnection, Method stmtProducingMethod, Object[] args) throws SQLException, ResourceClosedException {
    try {
      Object out = null;
      StatementCacheKey key = StatementCacheKey.find(physicalConnection, stmtProducingMethod, args);
      LinkedList l = checkoutQueue(key);
      if (l == null || l.isEmpty()) {
        out = acquireStatement(physicalConnection, stmtProducingMethod, args);
        if (prepareAssimilateNewStatement(physicalConnection))
          assimilateNewCheckedOutStatement(key, physicalConnection, out); 
      } else {
        logger.finest(getClass().getName() + " ----> CACHE HIT");
        out = l.get(0);
        l.remove(0);
        if (!this.checkedOut.add(out))
          throw new RuntimeException("Internal inconsistency: Checking out a statement marked as already checked out!"); 
        removeStatementFromDeathmarches(out, physicalConnection);
      } 
      if (logger.isLoggable(MLevel.FINEST))
        logger.finest("checkoutStatement: " + statsString()); 
      return out;
    } catch (NullPointerException npe) {
      if (this.checkedOut == null) {
        if (logger.isLoggable(MLevel.FINE))
          logger.log(MLevel.FINE, "A client attempted to work with a closed Statement cache, provoking a NullPointerException. c3p0 recovers, but this should be rare.", npe); 
        throw new ResourceClosedException(npe);
      } 
      throw npe;
    } 
  }
  
  public void checkinStatement(Object pstmt) throws SQLException {
    if (this.checkedOut == null) {
      this.destructo.synchronousDestroyStatement(pstmt);
      return;
    } 
    if (!this.checkedOut.remove(pstmt)) {
      if (!ourResource(pstmt))
        this.destructo.uncheckedDestroyStatement(pstmt); 
      return;
    } 
    try {
      refreshStatement((PreparedStatement)pstmt);
    } catch (Exception e) {
      if (logger.isLoggable(MLevel.INFO))
        logger.log(MLevel.INFO, "Problem with checked-in Statement, discarding.", e); 
      this.checkedOut.add(pstmt);
      removeStatement(pstmt, 3);
      return;
    } 
    StatementCacheKey key = (StatementCacheKey)this.stmtToKey.get(pstmt);
    if (key == null)
      throw new RuntimeException("Internal inconsistency: A checked-out statement has no key associated with it!"); 
    LinkedList l = checkoutQueue(key);
    l.add(pstmt);
    addStatementToDeathmarches(pstmt, key.physicalConnection);
    if (logger.isLoggable(MLevel.FINEST))
      logger.finest("checkinStatement(): " + statsString()); 
  }
  
  public void checkinAll(Connection pcon) throws InterruptedException {
    Set stmtSet = this.cxnStmtMgr.statementSet(pcon);
    if (stmtSet != null)
      for (Iterator ii = stmtSet.iterator(); ii.hasNext(); ) {
        Object stmt = ii.next();
        if (this.checkedOut.contains(stmt))
          checkinStatement(stmt); 
      }  
    if (logger.isLoggable(MLevel.FINEST))
      logger.log(MLevel.FINEST, "checkinAll(): " + statsString()); 
  }
  
  public void closeAll(Connection pcon) throws InterruptedException {
    if (!isClosed()) {
      if (logger.isLoggable(MLevel.FINEST))
        logger.log(MLevel.FINEST, "ENTER METHOD: closeAll( " + pcon + " )! -- num_connections: " + this.cxnStmtMgr
            .getNumConnectionsWithCachedStatements()); 
      Set stmtSet = null;
      synchronized (this) {
        Set cSet = this.cxnStmtMgr.statementSet(pcon);
        if (cSet != null) {
          stmtSet = new HashSet(cSet);
          for (Iterator ii = stmtSet.iterator(); ii.hasNext(); ) {
            Object stmt = ii.next();
            removeStatement(stmt, 0);
          } 
        } 
      } 
      if (stmtSet != null)
        for (Iterator ii = stmtSet.iterator(); ii.hasNext(); ) {
          Object stmt = ii.next();
          this.destructo.synchronousDestroyStatement(stmt);
        }  
      if (logger.isLoggable(MLevel.FINEST))
        logger.finest("closeAll(): " + statsString()); 
    } 
  }
  
  public void close() throws SQLException {
    if (!isClosed()) {
      for (Iterator ii = this.stmtToKey.keySet().iterator(); ii.hasNext();)
        this.destructo.synchronousDestroyStatement(ii.next()); 
      this.destructo.close();
      this.cxnStmtMgr = null;
      this.stmtToKey = null;
      this.keyToKeyRec = null;
      this.checkedOut = null;
    } else if (logger.isLoggable(MLevel.FINE)) {
      logger.log(MLevel.FINE, this + ": duplicate call to close() [not harmful! -- debug only!]", new Exception("DUPLICATE CLOSE DEBUG STACK TRACE."));
    } 
  }
  
  public boolean isClosed() { return (this.cxnStmtMgr == null); }
  
  final int countCachedStatements() { return this.stmtToKey.size(); }
  
  private void assimilateNewCheckedOutStatement(StatementCacheKey key, Connection pConn, Object ps) {
    this.stmtToKey.put(ps, key);
    HashSet ks = keySet(key);
    if (ks == null) {
      this.keyToKeyRec.put(key, new KeyRec(null));
    } else {
      if (logger.isLoggable(MLevel.INFO))
        logger.info("Multiply-cached PreparedStatement: " + key.stmtText); 
      if (logger.isLoggable(MLevel.FINE))
        logger.fine("(The same statement has already been prepared by this Connection, and that other instance has not yet been closed, so the statement pool has to prepare a second PreparedStatement object rather than reusing the previously-cached Statement. The new Statement will be cached, in case you frequently need multiple copies of this Statement.)"); 
    } 
    keySet(key).add(ps);
    this.cxnStmtMgr.addStatementForConnection(ps, pConn);
    if (logger.isLoggable(MLevel.FINEST))
      logger.finest("cxnStmtMgr.statementSet( " + pConn + " ).size(): " + this.cxnStmtMgr
          .statementSet(pConn).size()); 
    this.checkedOut.add(ps);
  }
  
  private void removeStatement(Object ps, int destruction_policy) {
    synchronized (this.removalPending) {
      if (this.removalPending.contains(ps))
        return; 
      this.removalPending.add(ps);
    } 
    StatementCacheKey sck = (StatementCacheKey)this.stmtToKey.remove(ps);
    removeFromKeySet(sck, ps);
    Connection pConn = sck.physicalConnection;
    boolean checked_in = !this.checkedOut.contains(ps);
    if (checked_in) {
      removeStatementFromDeathmarches(ps, pConn);
      removeFromCheckoutQueue(sck, ps);
      if ((destruction_policy & true) != 0)
        this.destructo.deferredDestroyStatement(pConn, ps); 
    } else {
      this.checkedOut.remove(ps);
      if ((destruction_policy & 0x2) != 0)
        this.destructo.deferredDestroyStatement(pConn, ps); 
    } 
    boolean check = this.cxnStmtMgr.removeStatementForConnection(ps, pConn);
    if (!check)
      if (logger.isLoggable(MLevel.WARNING))
        logger.log(MLevel.WARNING, this + " removed a statement that apparently wasn't in a statement set!!!", new Exception("LOG STACK TRACE"));  
    synchronized (this.removalPending) {
      this.removalPending.remove(ps);
    } 
  }
  
  private Object acquireStatement(Connection pConn, Method stmtProducingMethod, Object[] args) throws SQLException, ResourceClosedException {
    try {
      Object[] outHolder = new Object[1];
      Throwable[] exceptionHolder = new Throwable[1];
      StmtAcquireTask stmtAcquireTask = new StmtAcquireTask(this, outHolder, stmtProducingMethod, pConn, args, exceptionHolder);
      this.blockingTaskAsyncRunner.postRunnable(stmtAcquireTask);
      while (outHolder[false] == null && exceptionHolder[false] == null)
        wait(); 
      if (exceptionHolder[false] != null)
        throw new SQLException("A problem occurred while trying to acquire a cached PreparedStatement in a background thread.", exceptionHolder[0]); 
      return outHolder[0];
    } catch (InterruptedException e) {
      throw SqlUtils.toSQLException(e);
    } 
  }
  
  private KeyRec keyRec(StatementCacheKey key) { return (KeyRec)this.keyToKeyRec.get(key); }
  
  private HashSet keySet(StatementCacheKey key) {
    KeyRec rec = keyRec(key);
    return (rec == null) ? null : rec.allStmts;
  }
  
  private boolean removeFromKeySet(StatementCacheKey key, Object pstmt) {
    HashSet stmtSet = keySet(key);
    boolean out = stmtSet.remove(pstmt);
    if (stmtSet.isEmpty() && checkoutQueue(key).isEmpty())
      this.keyToKeyRec.remove(key); 
    return out;
  }
  
  private LinkedList checkoutQueue(StatementCacheKey key) {
    KeyRec rec = keyRec(key);
    return (rec == null) ? null : rec.checkoutQueue;
  }
  
  private boolean removeFromCheckoutQueue(StatementCacheKey key, Object pstmt) {
    LinkedList q = checkoutQueue(key);
    boolean out = q.remove(pstmt);
    if (q.isEmpty() && keySet(key).isEmpty())
      this.keyToKeyRec.remove(key); 
    return out;
  }
  
  private boolean ourResource(Object ps) { return this.stmtToKey.keySet().contains(ps); }
  
  private void refreshStatement(PreparedStatement ps) throws Exception {
    ps.clearParameters();
    ps.clearBatch();
  }
  
  private void printStats() throws SQLException {
    int total_size = countCachedStatements();
    int checked_out_size = this.checkedOut.size();
    int num_connections = this.cxnStmtMgr.getNumConnectionsWithCachedStatements();
    int num_keys = this.keyToKeyRec.size();
    System.err.print(getClass().getName() + " stats -- ");
    System.err.print("total size: " + total_size);
    System.err.print("; checked out: " + checked_out_size);
    System.err.print("; num connections: " + num_connections);
    System.err.println("; num keys: " + num_keys);
  }
  
  private String statsString() {
    int total_size = countCachedStatements();
    int checked_out_size = this.checkedOut.size();
    int num_connections = this.cxnStmtMgr.getNumConnectionsWithCachedStatements();
    int num_keys = this.keyToKeyRec.size();
    StringBuffer sb = new StringBuffer(255);
    sb.append(getClass().getName());
    sb.append(" stats -- ");
    sb.append("total size: ");
    sb.append(total_size);
    sb.append("; checked out: ");
    sb.append(checked_out_size);
    sb.append("; num connections: ");
    sb.append(num_connections);
    int in_use = this.destructo.countConnectionsInUse();
    if (in_use >= 0) {
      sb.append("; num connections in use: ");
      sb.append(in_use);
    } 
    sb.append("; num keys: ");
    sb.append(num_keys);
    return sb.toString();
  }
  
  abstract ConnectionStatementManager createConnectionStatementManager();
  
  abstract boolean prepareAssimilateNewStatement(Connection paramConnection);
  
  abstract void addStatementToDeathmarches(Object paramObject, Connection paramConnection);
  
  abstract void removeStatementFromDeathmarches(Object paramObject, Connection paramConnection);
}
