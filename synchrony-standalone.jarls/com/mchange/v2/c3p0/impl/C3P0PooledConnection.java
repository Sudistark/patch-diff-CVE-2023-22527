package com.mchange.v2.c3p0.impl;

import com.mchange.v2.c3p0.ConnectionCustomizer;
import com.mchange.v2.c3p0.ConnectionTester;
import com.mchange.v2.c3p0.stmt.GooGooStatementCache;
import com.mchange.v2.c3p0.util.ConnectionEventSupport;
import com.mchange.v2.c3p0.util.StatementEventSupport;
import com.mchange.v2.log.MLevel;
import com.mchange.v2.log.MLog;
import com.mchange.v2.log.MLogger;
import com.mchange.v2.sql.SqlUtils;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import javax.sql.ConnectionEventListener;
import javax.sql.StatementEventListener;

public final class C3P0PooledConnection extends AbstractC3P0PooledConnection {
  static final MLogger logger = MLog.getLogger(C3P0PooledConnection.class);
  
  static final Class[] PROXY_CTOR_ARGS = { java.lang.reflect.InvocationHandler.class };
  
  static final Constructor CON_PROXY_CTOR;
  
  static final Method RS_CLOSE_METHOD;
  
  static final Method STMT_CLOSE_METHOD;
  
  static final Object[] CLOSE_ARGS;
  
  static final Set OBJECT_METHODS;
  
  final ConnectionTester connectionTester;
  
  final boolean autoCommitOnClose;
  
  final boolean forceIgnoreUnresolvedTransactions;
  
  final boolean supports_setTypeMap;
  
  final boolean supports_setHoldability;
  
  final int dflt_txn_isolation;
  
  final String dflt_catalog;
  
  final int dflt_holdability;
  
  private static Constructor createProxyConstructor(Class intfc) throws NoSuchMethodException {
    Class[] proxyInterfaces = { intfc };
    Class proxyCl = Proxy.getProxyClass(C3P0PooledConnection.class.getClassLoader(), proxyInterfaces);
    return proxyCl.getConstructor(PROXY_CTOR_ARGS);
  }
  
  static  {
    try {
      CON_PROXY_CTOR = createProxyConstructor(ProxyConnection.class);
      argClasses = new Class[0];
      RS_CLOSE_METHOD = ResultSet.class.getMethod("close", argClasses);
      STMT_CLOSE_METHOD = Statement.class.getMethod("close", argClasses);
      CLOSE_ARGS = new Object[0];
      OBJECT_METHODS = Collections.unmodifiableSet(new HashSet(Arrays.asList(Object.class.getMethods())));
    } catch (Exception e) {
      logger.log(MLevel.SEVERE, "An Exception occurred in static initializer of" + C3P0PooledConnection.class.getName(), e);
      throw new InternalError("Something is very wrong, or this is a pre 1.3 JVM.We cannot set up dynamic proxies and/or methods!");
    } 
  }
  
  final ConnectionEventSupport ces = new ConnectionEventSupport(this);
  
  final StatementEventSupport ses = new StatementEventSupport(this);
  
  ProxyConnection exposedProxy;
  
  int connection_status = 0;
  
  final Set uncachedActiveStatements = Collections.synchronizedSet(new HashSet());
  
  public C3P0PooledConnection(Connection con, ConnectionTester connectionTester, boolean autoCommitOnClose, boolean forceIgnoreUnresolvedTransactions, ConnectionCustomizer cc, String pdsIdt) throws SQLException {
    try {
      if (cc != null)
        cc.onAcquire(con, pdsIdt); 
    } catch (Exception e) {
      throw SqlUtils.toSQLException(e);
    } 
    this.physicalConnection = con;
    this.connectionTester = connectionTester;
    this.autoCommitOnClose = autoCommitOnClose;
    this.forceIgnoreUnresolvedTransactions = forceIgnoreUnresolvedTransactions;
    this.supports_setTypeMap = C3P0ImplUtils.supportsMethod(con, "setTypeMap", new Class[] { java.util.Map.class });
    this.supports_setHoldability = C3P0ImplUtils.supportsMethod(con, "setHoldability", new Class[] { int.class });
    this.dflt_txn_isolation = con.getTransactionIsolation();
    this.dflt_catalog = con.getCatalog();
    this.dflt_holdability = this.supports_setHoldability ? con.getHoldability() : 2;
  }
  
  Connection getPhysicalConnection() { return this.physicalConnection; }
  
  boolean isClosed() throws SQLException { return (this.physicalConnection == null); }
  
  void initStatementCache(GooGooStatementCache scache) { this.scache = scache; }
  
  public Connection getConnection() {
    if (this.exposedProxy != null) {
      logger.warning("c3p0 -- Uh oh... getConnection() was called on a PooledConnection when it had already provided a client with a Connection that has not yet been closed. This probably indicates a bug in the connection pool!!!");
      return this.exposedProxy;
    } 
    return getCreateNewConnection();
  }
  
  private Connection getCreateNewConnection() {
    try {
      ensureOkay();
      return this.exposedProxy = createProxyConnection();
    } catch (SQLException e) {
      throw e;
    } catch (Exception e) {
      logger.log(MLevel.WARNING, "Failed to acquire connection!", e);
      throw new SQLException("Failed to acquire connection!");
    } 
  }
  
  public void closeAll() throws SQLException {
    if (this.scache != null)
      this.scache.closeAll(this.physicalConnection); 
  }
  
  public void close() throws SQLException { close(false); }
  
  void closeMaybeCheckedOut(boolean checked_out) throws SQLException {
    if (checked_out)
      try {
        C3P0ImplUtils.resetTxnState(this.physicalConnection, this.forceIgnoreUnresolvedTransactions, this.autoCommitOnClose, false);
      } catch (Exception e) {
        if (logger.isLoggable(MLevel.FINER))
          logger.log(MLevel.FINER, "Failed to reset the transaction state of  " + this.physicalConnection + "just prior to close(). Only relevant at all if this was a Connection being forced close()ed midtransaction.", e); 
      }  
    close(false);
  }
  
  private void close(boolean known_invalid) throws SQLException {
    if (this.physicalConnection != null)
      try {
        StringBuffer debugOnlyLog = null;
        if (known_invalid) {
          debugOnlyLog = new StringBuffer();
          debugOnlyLog.append("[ exceptions: ");
        } 
        Exception exc = cleanupUncachedActiveStatements();
        if (exc != null)
          if (known_invalid) {
            debugOnlyLog.append(exc.toString() + ' ');
          } else {
            logger.log(MLevel.WARNING, "An exception occurred while cleaning up uncached active Statements.", exc);
          }  
        try {
          if (this.exposedProxy != null)
            this.exposedProxy.silentClose(known_invalid); 
        } catch (Exception e) {
          if (known_invalid) {
            debugOnlyLog.append(e.toString() + ' ');
          } else {
            logger.log(MLevel.WARNING, "An exception occurred.", exc);
          } 
          exc = e;
        } 
        try {
          closeAll();
        } catch (Exception e) {
          if (known_invalid) {
            debugOnlyLog.append(e.toString() + ' ');
          } else {
            logger.log(MLevel.WARNING, "An exception occurred.", exc);
          } 
          exc = e;
        } 
        try {
          this.physicalConnection.close();
        } catch (Exception e) {
          if (known_invalid) {
            debugOnlyLog.append(e.toString() + ' ');
          } else {
            logger.log(MLevel.WARNING, "An exception occurred.", exc);
          } 
          e.printStackTrace();
          exc = e;
        } 
        if (exc != null)
          if (known_invalid) {
            debugOnlyLog.append(" ]");
            logger.fine(this + ": while closing a PooledConnection known to be invalid,   some exceptions occurred. This is probably not a problem: " + debugOnlyLog
                
                .toString());
          } else {
            throw new SQLException("At least one error occurred while attempting to close() the PooledConnection: " + exc);
          }  
        logger.fine("C3P0PooledConnection closed. [" + this + ']');
      } finally {
        this.physicalConnection = null;
      }  
  }
  
  public void addConnectionEventListener(ConnectionEventListener listener) { this.ces.addConnectionEventListener(listener); }
  
  public void removeConnectionEventListener(ConnectionEventListener listener) { this.ces.removeConnectionEventListener(listener); }
  
  public void addStatementEventListener(StatementEventListener sel) {
    if (logger.isLoggable(MLevel.INFO))
      logger.info("Per the JDBC4 spec, " + getClass().getName() + " accepts StatementListeners, but for now there is no circumstance under which they are notified!"); 
    this.ses.addStatementEventListener(sel);
  }
  
  public void removeStatementEventListener(StatementEventListener sel) { this.ses.removeStatementEventListener(sel); }
  
  private void reset() throws SQLException { reset(false); }
  
  private void reset(boolean known_resolved_txn) throws SQLException {
    ensureOkay();
    C3P0ImplUtils.resetTxnState(this.physicalConnection, this.forceIgnoreUnresolvedTransactions, this.autoCommitOnClose, known_resolved_txn);
    if (this.isolation_lvl_nondefault) {
      this.physicalConnection.setTransactionIsolation(this.dflt_txn_isolation);
      this.isolation_lvl_nondefault = false;
    } 
    if (this.catalog_nondefault) {
      this.physicalConnection.setCatalog(this.dflt_catalog);
      this.catalog_nondefault = false;
    } 
    if (this.holdability_nondefault) {
      this.physicalConnection.setHoldability(this.dflt_holdability);
      this.holdability_nondefault = false;
    } 
    try {
      this.physicalConnection.setReadOnly(false);
    } catch (Throwable t) {
      if (logger.isLoggable(MLevel.FINE))
        logger.log(MLevel.FINE, "A Throwable occurred while trying to reset the readOnly property of our Connection to false!", t); 
    } 
    try {
      if (this.supports_setTypeMap)
        this.physicalConnection.setTypeMap(Collections.EMPTY_MAP); 
    } catch (Throwable t) {
      if (logger.isLoggable(MLevel.FINE))
        logger.log(MLevel.FINE, "A Throwable occurred while trying to reset the typeMap property of our Connection to Collections.EMPTY_MAP!", t); 
    } 
  }
  
  boolean closeAndRemoveResultSets(Set rsSet) {
    boolean okay = true;
    synchronized (rsSet) {
      for (ii = rsSet.iterator(); ii.hasNext(); ) {
        ResultSet rs = (ResultSet)ii.next();
        try {
          rs.close();
        } catch (SQLException e) {
          logger.log(MLevel.WARNING, "An exception occurred while cleaning up a ResultSet.", e);
          okay = false;
        } finally {
          ii.remove();
        } 
      } 
    } 
    return okay;
  }
  
  void ensureOkay() throws SQLException {
    if (this.physicalConnection == null)
      throw new SQLException((this.invalidatingException == null) ? "Connection is closed or broken." : ("Connection is broken. Invalidating Exception: " + this.invalidatingException
          
          .toString())); 
  }
  
  boolean closeAndRemoveResourcesInSet(Set s, Method closeMethod) {
    Set temp;
    boolean okay = true;
    synchronized (s) {
      temp = new HashSet(s);
    } 
    for (Iterator ii = temp.iterator(); ii.hasNext(); ) {
      rsrc = ii.next();
      try {
        closeMethod.invoke(rsrc, CLOSE_ARGS);
      } catch (Exception e) {
        Throwable t = e;
        if (t instanceof InvocationTargetException)
          t = ((InvocationTargetException)e).getTargetException(); 
        logger.log(MLevel.WARNING, "An exception occurred while cleaning up a resource.", t);
        okay = false;
      } finally {
        s.remove(rsrc);
      } 
    } 
    return okay;
  }
  
  private SQLException cleanupUncachedActiveStatements() {
    boolean okay = closeAndRemoveResourcesInSet(this.uncachedActiveStatements, STMT_CLOSE_METHOD);
    if (okay)
      return null; 
    return new SQLException("An exception occurred while trying to clean up orphaned resources.");
  }
  
  ProxyConnection createProxyConnection() throws Exception {
    ProxyConnectionInvocationHandler proxyConnectionInvocationHandler = new ProxyConnectionInvocationHandler(this);
    return (ProxyConnection)CON_PROXY_CTOR.newInstance(new Object[] { proxyConnectionInvocationHandler });
  }
  
  Statement createProxyStatement(Statement innerStmt) throws Exception { return createProxyStatement(false, innerStmt); }
  
  Statement createProxyStatement(boolean inner_is_cached, Statement innerStmt) throws Exception {
    Set activeResultSets = Collections.synchronizedSet(new HashSet());
    ProxyConnection proxyConnection = this.exposedProxy;
    if (proxyConnection == null)
      logger.warning("PROBABLE C3P0 BUG -- " + this + ": created a proxy Statement when there is no active, exposed proxy Connection???"); 
    StatementProxyingSetManagedResultSet mainResultSet = new StatementProxyingSetManagedResultSet(activeResultSets);
    if (innerStmt instanceof CallableStatement)
      return new ProxyCallableStatement(this, (CallableStatement)innerStmt, innerStmt, mainResultSet, activeResultSets, inner_is_cached, proxyConnection); 
    if (innerStmt instanceof PreparedStatement)
      return new ProxyPreparedStatement(this, (PreparedStatement)innerStmt, innerStmt, mainResultSet, activeResultSets, inner_is_cached, proxyConnection); 
    return new ProxyStatement(this, innerStmt, innerStmt, mainResultSet, activeResultSets, inner_is_cached, proxyConnection);
  }
  
  public int getConnectionStatus() { return this.connection_status; }
  
  private void updateConnectionStatus(int status) {
    switch (this.connection_status) {
      case -8:
        return;
      case -1:
        if (status == -8)
          doBadUpdate(status); 
      case 0:
        if (status != 0)
          doBadUpdate(status); 
    } 
    throw new InternalError(this + " -- Illegal Connection Status: " + this.connection_status);
  }
  
  private void doBadUpdate(int new_status) {
    this.connection_status = new_status;
    try {
      close(true);
    } catch (SQLException e) {
      logger.log(MLevel.WARNING, "Broken Connection Close Error. ", e);
    } 
  }
}
