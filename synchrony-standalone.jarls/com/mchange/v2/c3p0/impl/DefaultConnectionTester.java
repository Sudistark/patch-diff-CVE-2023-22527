package com.mchange.v2.c3p0.impl;

import com.mchange.v1.db.sql.ResultSetUtils;
import com.mchange.v1.db.sql.StatementUtils;
import com.mchange.v2.c3p0.AbstractConnectionTester;
import com.mchange.v2.c3p0.cfg.C3P0Config;
import com.mchange.v2.log.MLevel;
import com.mchange.v2.log.MLog;
import com.mchange.v2.log.MLogger;
import java.lang.reflect.Field;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

public final class DefaultConnectionTester extends AbstractConnectionTester {
  private static final String PROP_KEY = "com.mchange.v2.c3p0.impl.DefaultConnectionTester.querylessTestRunner";
  
  private static final String IS_VALID_TIMEOUT_KEY = "com.mchange.v2.c3p0.impl.DefaultConnectionTester.isValidTimeout";
  
  static final MLogger logger = MLog.getLogger(DefaultConnectionTester.class);
  
  static final int IS_VALID_TIMEOUT;
  
  static final String CONNECTION_TESTING_URL = "http://www.mchange.com/projects/c3p0/#configuring_connection_testing";
  
  static final int HASH_CODE = DefaultConnectionTester.class.getName().hashCode();
  
  static final Set INVALID_DB_STATES;
  
  public static boolean probableInvalidDb(SQLException sqle) { return INVALID_DB_STATES.contains(sqle.getSQLState()); }
  
  static final QuerylessTestRunner METADATA_TABLESEARCH = new Object();
  
  static final QuerylessTestRunner IS_VALID = new Object();
  
  static final QuerylessTestRunner SWITCH = new Object();
  
  static final QuerylessTestRunner THREAD_LOCAL = new ThreadLocalQuerylessTestRunner();
  
  private final QuerylessTestRunner querylessTestRunner;
  
  private static QuerylessTestRunner reflectTestRunner(String propval) {
    try {
      if (propval.indexOf('.') >= 0)
        return (QuerylessTestRunner)Class.forName(propval).newInstance(); 
      Field staticField = DefaultConnectionTester.class.getDeclaredField(propval);
      return (QuerylessTestRunner)staticField.get(null);
    } catch (Exception e) {
      if (logger.isLoggable(MLevel.WARNING))
        logger.log(MLevel.WARNING, "Specified QuerylessTestRunner '" + propval + "' could not be found or instantiated. Reverting to default 'SWITCH'", e); 
      return null;
    } 
  }
  
  static  {
    temp = new HashSet();
    temp.add("08001");
    temp.add("08007");
    INVALID_DB_STATES = Collections.unmodifiableSet(temp);
    int isValidTimeout = -1;
    String timeoutStr = C3P0Config.getMultiPropertiesConfig().getProperty("com.mchange.v2.c3p0.impl.DefaultConnectionTester.isValidTimeout");
    try {
      if (timeoutStr != null)
        isValidTimeout = Integer.parseInt(timeoutStr); 
    } catch (NumberFormatException e) {
      if (logger.isLoggable(MLevel.WARNING))
        logger.log(MLevel.WARNING, "Could not parse value set for com.mchange.v2.c3p0.impl.DefaultConnectionTester.isValidTimeout ['" + timeoutStr + "'] into int.", e); 
    } 
    if (isValidTimeout <= 0) {
      isValidTimeout = 0;
    } else if (logger.isLoggable(MLevel.INFO)) {
      logger.log(MLevel.INFO, "Connection.isValid(...) based Connection tests will timeout and fail after " + isValidTimeout + " seconds.");
    } 
    IS_VALID_TIMEOUT = isValidTimeout;
  }
  
  public DefaultConnectionTester() {
    QuerylessTestRunner defaultQuerylessTestRunner = SWITCH;
    String prop = C3P0Config.getMultiPropertiesConfig().getProperty("com.mchange.v2.c3p0.impl.DefaultConnectionTester.querylessTestRunner");
    if (prop == null) {
      this.querylessTestRunner = defaultQuerylessTestRunner;
    } else {
      QuerylessTestRunner reflected = reflectTestRunner(prop.trim());
      this.querylessTestRunner = (reflected != null) ? reflected : defaultQuerylessTestRunner;
    } 
  }
  
  public int activeCheckConnection(Connection c, String query, Throwable[] rootCauseOutParamHolder) {
    if (query == null)
      return this.querylessTestRunner.activeCheckConnectionNoQuery(c, rootCauseOutParamHolder); 
    stmt = null;
    rs = null;
    try {
      stmt = c.createStatement();
      rs = stmt.executeQuery(query);
      return 0;
    } catch (SQLException e) {
      if (logger.isLoggable(MLevel.FINE))
        logger.log(MLevel.FINE, "Connection " + c + " failed Connection test with an Exception! [query=" + query + "]", e); 
      if (rootCauseOutParamHolder != null)
        rootCauseOutParamHolder[0] = e; 
      String state = e.getSQLState();
      if (INVALID_DB_STATES.contains(state)) {
        if (logger.isLoggable(MLevel.WARNING))
          logger.log(MLevel.WARNING, "SQL State '" + state + "' of Exception which occurred during a Connection test (test with query '" + query + "') implies that the database is invalid, and the pool should refill itself with fresh Connections.", e); 
        return -8;
      } 
      return -1;
    } catch (Exception e) {
      if (logger.isLoggable(MLevel.FINE))
        logger.log(MLevel.FINE, "Connection " + c + " failed Connection test with an Exception!", e); 
      if (rootCauseOutParamHolder != null)
        rootCauseOutParamHolder[0] = e; 
      return -1;
    } finally {
      ResultSetUtils.attemptClose(rs);
      StatementUtils.attemptClose(stmt);
    } 
  }
  
  public int statusOnException(Connection c, Throwable t, String query, Throwable[] rootCauseOutParamHolder) {
    if (logger.isLoggable(MLevel.FINER))
      logger.log(MLevel.FINER, "Testing a Connection in response to an Exception:", t); 
    try {
      if (t instanceof SQLException) {
        String state = ((SQLException)t).getSQLState();
        if (INVALID_DB_STATES.contains(state)) {
          if (logger.isLoggable(MLevel.WARNING))
            logger.log(MLevel.WARNING, "SQL State '" + state + "' of Exception tested by statusOnException() implies that the database is invalid, and the pool should refill itself with fresh Connections.", t); 
          return -8;
        } 
        return activeCheckConnection(c, query, rootCauseOutParamHolder);
      } 
      if (logger.isLoggable(MLevel.FINE))
        logger.log(MLevel.FINE, "Connection test failed because test-provoking Throwable is an unexpected, non-SQLException.", t); 
      if (rootCauseOutParamHolder != null)
        rootCauseOutParamHolder[0] = t; 
      return -1;
    } catch (Exception e) {
      if (logger.isLoggable(MLevel.FINE))
        logger.log(MLevel.FINE, "Connection " + c + " failed Connection test with an Exception!", e); 
      if (rootCauseOutParamHolder != null)
        rootCauseOutParamHolder[0] = e; 
      return -1;
    } finally {}
  }
  
  private static String queryInfo(String query) { return (query == null) ? "[using Connection.isValid(...) if supported, or else traditional default query]" : ("[query=" + query + "]"); }
  
  public boolean equals(Object o) { return (o != null && o.getClass() == DefaultConnectionTester.class); }
  
  public int hashCode() { return HASH_CODE; }
}
