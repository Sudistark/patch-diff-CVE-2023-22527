package com.mchange.v3.concurrent;

import com.mchange.v2.log.MLevel;
import com.mchange.v2.log.MLog;
import com.mchange.v2.log.MLogger;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.AbstractExecutorService;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.RunnableFuture;
import java.util.concurrent.TimeUnit;

public final class BoundedExecutorService extends AbstractExecutorService {
  static final MLogger logger = MLog.getLogger(BoundedExecutorService.class);
  
  final ExecutorService inner;
  
  final int blockBound;
  
  final int restartBeneath;
  
  State state;
  
  int permits;
  
  Map<Thread, Runnable> waiters = new HashMap();
  
  public BoundedExecutorService(ExecutorService paramExecutorService, int paramInt1, int paramInt2) {
    if (paramInt1 <= 0 || paramInt2 <= 0)
      throw new IllegalArgumentException("blockBound and restartBeneath must both be greater than zero!"); 
    if (paramInt2 > paramInt1)
      throw new IllegalArgumentException("restartBeneath must be less than or equal to blockBound!"); 
    this.inner = paramExecutorService;
    this.blockBound = paramInt1;
    this.restartBeneath = paramInt2;
    this.state = State.ACCEPTING;
    this.permits = 0;
  }
  
  public BoundedExecutorService(ExecutorService paramExecutorService, int paramInt) { this(paramExecutorService, paramInt, paramInt); }
  
  public State getState() { return this.state; }
  
  public boolean isShutdown() { return (this.state == State.SHUTDOWN || this.state == State.SHUTDOWN_NOW); }
  
  public boolean isTerminated() { return (isShutdown() && this.permits == 0); }
  
  public void shutdown() {
    this.inner.shutdown();
    updateState(State.SHUTDOWN);
    notifyAll();
  }
  
  public List<Runnable> shutdownNow() {
    updateState(State.SHUTDOWN_NOW);
    List list = this.inner.shutdownNow();
    Collection collection = this.waiters.values();
    ArrayList arrayList = new ArrayList(list.size() + collection.size());
    arrayList.addAll(list);
    arrayList.addAll(collection);
    for (Iterator iterator = this.waiters.keySet().iterator(); iterator.hasNext(); ((Thread)iterator.next()).interrupt());
    this.waiters.clear();
    return Collections.unmodifiableList(arrayList);
  }
  
  public boolean awaitTermination(long paramLong, TimeUnit paramTimeUnit) throws InterruptedException {
    long l1 = System.currentTimeMillis();
    long l2 = l1 + TimeUnit.MILLISECONDS.convert(paramLong, paramTimeUnit);
    boolean bool = this.inner.awaitTermination(paramLong, paramTimeUnit);
    if (bool) {
      long l = System.currentTimeMillis();
      while (!isTerminated()) {
        if (l > l2)
          return false; 
        wait(l2 - l);
      } 
      return true;
    } 
    return false;
  }
  
  public void execute(Runnable paramRunnable) { this.inner.execute(newTaskFor(paramRunnable, null)); }
  
  protected <V> RunnableFuture<V> newTaskFor(Callable<V> paramCallable) {
    ReleasingFutureTask releasingFutureTask = new ReleasingFutureTask(this, paramCallable);
    acquirePermit(releasingFutureTask);
    return releasingFutureTask;
  }
  
  protected <V> RunnableFuture<V> newTaskFor(Runnable paramRunnable, V paramV) {
    ReleasingFutureTask releasingFutureTask = new ReleasingFutureTask(this, paramRunnable, paramV);
    acquirePermit(releasingFutureTask);
    return releasingFutureTask;
  }
  
  private boolean shouldWait() {
    switch (null.$SwitchMap$com$mchange$v3$concurrent$BoundedExecutorService$State[this.state.ordinal()]) {
      case 1:
      case 2:
        return (this.permits == this.blockBound);
      case 3:
        return false;
      case 4:
      case 5:
        return true;
    } 
    throw new AssertionError("This should be dead code.");
  }
  
  private void acquirePermit(Runnable paramRunnable) {
    try {
      switch (null.$SwitchMap$com$mchange$v3$concurrent$BoundedExecutorService$State[this.state.ordinal()]) {
        case 1:
        case 2:
          throw new RejectedExecutionException(this + " has been shut down. [state=" + this.state + "]");
        case 3:
        case 4:
        case 5:
          while (shouldWait()) {
            try {
              this.waiters.put(Thread.currentThread(), paramRunnable);
              wait();
            } finally {
              this.waiters.remove(Thread.currentThread());
            } 
          } 
          if (this.state != State.SHUTDOWN_NOW) {
            this.permits++;
            if (this.permits == this.blockBound)
              updateState(State.SATURATED); 
          } 
          break;
      } 
    } catch (InterruptedException interruptedException) {
      throw new RejectedExecutionException(this + " has been forcibly shut down. [state=" + this.state + "]", interruptedException);
    } 
  }
  
  private void releasePermit() {
    this.permits--;
    if (this.permits < this.restartBeneath) {
      updateState(State.ACCEPTING);
    } else if (this.state == State.SATURATED && this.permits < this.blockBound) {
      updateState(State.UNWINDING);
    } 
  }
  
  private void updateState(State paramState) {
    switch (null.$SwitchMap$com$mchange$v3$concurrent$BoundedExecutorService$State[this.state.ordinal()]) {
      case 3:
      case 4:
      case 5:
        if (this.state != paramState)
          doUpdateState(paramState); 
        break;
      case 1:
        if (paramState == State.SHUTDOWN_NOW)
          doUpdateState(paramState); 
        break;
    } 
  }
  
  private void doUpdateState(State paramState) {
    if (logger.isLoggable(MLevel.FINE))
      logger.log(MLevel.FINE, "State transition " + this.state + " => " + paramState + "; blockBound=" + this.blockBound + "; restartBeneath=" + this.restartBeneath + "; permits=" + this.permits); 
    this.state = paramState;
    if (this.state == State.SHUTDOWN_NOW)
      this.permits = 0; 
    notifyAll();
  }
}
