package com.mysema.query.support;

import com.mysema.query.Detachable;
import com.mysema.query.JoinExpression;
import com.mysema.query.QueryMetadata;
import com.mysema.query.Tuple;
import com.mysema.query.types.ConstantImpl;
import com.mysema.query.types.Expression;
import com.mysema.query.types.NullExpression;
import com.mysema.query.types.Operation;
import com.mysema.query.types.Ops;
import com.mysema.query.types.Predicate;
import com.mysema.query.types.ProjectionRole;
import com.mysema.query.types.expr.BooleanExpression;
import com.mysema.query.types.expr.ComparableExpression;
import com.mysema.query.types.expr.DateExpression;
import com.mysema.query.types.expr.DateTimeExpression;
import com.mysema.query.types.expr.NumberExpression;
import com.mysema.query.types.expr.StringExpression;
import com.mysema.query.types.expr.TimeExpression;
import com.mysema.query.types.expr.Wildcard;
import com.mysema.query.types.query.BooleanSubQuery;
import com.mysema.query.types.query.ComparableSubQuery;
import com.mysema.query.types.query.DateSubQuery;
import com.mysema.query.types.query.DateTimeSubQuery;
import com.mysema.query.types.query.ListSubQuery;
import com.mysema.query.types.query.NumberSubQuery;
import com.mysema.query.types.query.SimpleSubQuery;
import com.mysema.query.types.query.StringSubQuery;
import com.mysema.query.types.query.TimeSubQuery;
import javax.annotation.Nullable;

public class DetachableMixin implements Detachable {
  private final QueryMixin<?> queryMixin;
  
  public DetachableMixin(QueryMixin<?> queryMixin) { this.queryMixin = queryMixin; }
  
  public NumberSubQuery<Long> count() { return new NumberSubQuery(Long.class, projection(new Expression[] { Wildcard.count })); }
  
  public BooleanExpression exists() {
    if (this.queryMixin.getMetadata().getJoins().isEmpty())
      throw new IllegalArgumentException("No sources given"); 
    Expression<?> expr = ((JoinExpression)this.queryMixin.getMetadata().getJoins().get(0)).getTarget();
    if (expr instanceof Operation && ((Operation)expr).getOperator() == Ops.ALIAS)
      expr = ((Operation)expr).getArg(1); 
    return unique(expr).exists();
  }
  
  public ListSubQuery<Tuple> list(Expression... args) { return new ListSubQuery(Tuple.class, projection(args)); }
  
  public <RT> ListSubQuery<RT> list(Expression<RT> projection) { return new ListSubQuery(projection.getType(), projection(new Expression[] { projection })); }
  
  public ListSubQuery<Tuple> list(Object arg) { return list(convert(arg)); }
  
  public ListSubQuery<Tuple> list(Object... args) { return list(convert(args)); }
  
  public SimpleSubQuery<Tuple> unique(Object... args) { return unique(convert(args)); }
  
  private Expression<?> convert(Object arg) {
    if (arg instanceof Expression)
      return (Expression)arg; 
    if (arg instanceof ProjectionRole)
      return ((ProjectionRole)arg).getProjection(); 
    if (arg != null)
      return ConstantImpl.create(arg); 
    return NullExpression.DEFAULT;
  }
  
  private Expression<?>[] convert(Object... args) {
    Expression[] exprs = new Expression[args.length];
    for (int i = 0; i < exprs.length; i++)
      exprs[i] = convert(args[i]); 
    return exprs;
  }
  
  public BooleanExpression notExists() { return exists().not(); }
  
  private QueryMetadata projection(Expression... projection) {
    QueryMetadata metadata = this.queryMixin.getMetadata().clone();
    for (Expression<?> expr : projection) {
      expr = this.queryMixin.convert(expr, false);
      metadata.addProjection(nullAsTemplate(expr));
    } 
    return metadata;
  }
  
  private Expression<?> nullAsTemplate(@Nullable Expression<?> expr) { return (expr != null) ? expr : NullExpression.DEFAULT; }
  
  public <RT extends Comparable<?>> ComparableSubQuery<RT> unique(ComparableExpression<RT> projection) { return new ComparableSubQuery(projection.getType(), uniqueProjection(new Expression[] { projection })); }
  
  public <RT extends Comparable<?>> DateSubQuery<RT> unique(DateExpression<RT> projection) { return new DateSubQuery(projection.getType(), uniqueProjection(new Expression[] { projection })); }
  
  public <RT extends Comparable<?>> DateTimeSubQuery<RT> unique(DateTimeExpression<RT> projection) { return new DateTimeSubQuery(projection.getType(), uniqueProjection(new Expression[] { projection })); }
  
  public SimpleSubQuery<Tuple> unique(Expression... args) { return new SimpleSubQuery(Tuple.class, uniqueProjection(args)); }
  
  public <RT> SimpleSubQuery<RT> unique(Expression<RT> projection) { return new SimpleSubQuery(projection.getType(), uniqueProjection(new Expression[] { projection })); }
  
  public <RT extends Number & Comparable<?>> NumberSubQuery<RT> unique(NumberExpression<RT> projection) { return new NumberSubQuery(projection.getType(), uniqueProjection(new Expression[] { projection })); }
  
  public BooleanSubQuery unique(Predicate projection) { return new BooleanSubQuery(uniqueProjection(new Expression[] { projection })); }
  
  public StringSubQuery unique(StringExpression projection) { return new StringSubQuery(uniqueProjection(new Expression[] { projection })); }
  
  public <RT extends Comparable<?>> TimeSubQuery<RT> unique(TimeExpression<RT> projection) { return new TimeSubQuery(projection.getType(), uniqueProjection(new Expression[] { projection })); }
  
  private QueryMetadata uniqueProjection(Expression... projection) {
    QueryMetadata metadata = projection(projection);
    metadata.setUnique(true);
    return metadata;
  }
}
