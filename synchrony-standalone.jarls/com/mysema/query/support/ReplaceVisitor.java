package com.mysema.query.support;

import com.google.common.base.Objects;
import com.google.common.collect.ImmutableList;
import com.mysema.query.DefaultQueryMetadata;
import com.mysema.query.JoinExpression;
import com.mysema.query.JoinFlag;
import com.mysema.query.QueryFlag;
import com.mysema.query.types.Constant;
import com.mysema.query.types.Expression;
import com.mysema.query.types.FactoryExpression;
import com.mysema.query.types.FactoryExpressionUtils;
import com.mysema.query.types.Operation;
import com.mysema.query.types.OperationImpl;
import com.mysema.query.types.OrderSpecifier;
import com.mysema.query.types.ParamExpression;
import com.mysema.query.types.Path;
import com.mysema.query.types.PathImpl;
import com.mysema.query.types.PathMetadata;
import com.mysema.query.types.Predicate;
import com.mysema.query.types.PredicateOperation;
import com.mysema.query.types.SubQueryExpression;
import com.mysema.query.types.SubQueryExpressionImpl;
import com.mysema.query.types.TemplateExpression;
import com.mysema.query.types.TemplateExpressionImpl;
import com.mysema.query.types.Visitor;
import com.mysema.query.types.template.BooleanTemplate;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;

public class ReplaceVisitor extends Object implements Visitor<Expression<?>, Void> {
  public Expression<?> visit(Constant<?> expr, @Nullable Void context) { return expr; }
  
  public Expression<?> visit(FactoryExpression<?> expr, @Nullable Void context) {
    ImmutableList immutableList = visit(expr.getArgs());
    if (immutableList.equals(expr.getArgs()))
      return expr; 
    return FactoryExpressionUtils.wrap(expr, immutableList);
  }
  
  public Expression<?> visit(Operation<?> expr, @Nullable Void context) {
    ImmutableList<Expression<?>> args = visit(expr.getArgs());
    if (args.equals(expr.getArgs()))
      return expr; 
    if (expr instanceof Predicate)
      return new PredicateOperation(expr.getOperator(), args); 
    return new OperationImpl(expr.getType(), expr.getOperator(), args);
  }
  
  public Expression<?> visit(ParamExpression<?> expr, @Nullable Void context) { return expr; }
  
  public Expression<?> visit(Path<?> expr, @Nullable Void context) {
    if (expr.getMetadata().isRoot())
      return expr; 
    PathMetadata metadata = expr.getMetadata();
    Path<?> parent = (Path)metadata.getParent().accept(this, null);
    Object element = metadata.getElement();
    if (element instanceof Expression)
      element = ((Expression)element).accept(this, null); 
    if (parent.equals(metadata.getParent()) && Objects.equal(element, metadata.getElement()))
      return expr; 
    metadata = new PathMetadata(parent, element, metadata.getPathType());
    return new PathImpl(expr.getType(), metadata);
  }
  
  public Expression<?> visit(SubQueryExpression<?> expr, @Nullable Void context) {
    DefaultQueryMetadata defaultQueryMetadata = new DefaultQueryMetadata();
    defaultQueryMetadata.setValidate(false);
    defaultQueryMetadata.setDistinct(expr.getMetadata().isDistinct());
    defaultQueryMetadata.setModifiers(expr.getMetadata().getModifiers());
    defaultQueryMetadata.setUnique(expr.getMetadata().isUnique());
    for (QueryFlag flag : expr.getMetadata().getFlags())
      defaultQueryMetadata.addFlag(new QueryFlag(flag.getPosition(), (Expression)flag.getFlag().accept(this, null))); 
    for (Expression<?> e : expr.getMetadata().getGroupBy())
      defaultQueryMetadata.addGroupBy((Expression)e.accept(this, null)); 
    Predicate having = expr.getMetadata().getHaving();
    if (having != null)
      defaultQueryMetadata.addHaving((Predicate)having.accept(this, null)); 
    for (JoinExpression je : expr.getMetadata().getJoins()) {
      defaultQueryMetadata.addJoin(je.getType(), (Expression)je.getTarget().accept(this, null));
      if (je.getCondition() != null)
        defaultQueryMetadata.addJoinCondition((Predicate)je.getCondition().accept(this, null)); 
      for (JoinFlag jf : je.getFlags())
        defaultQueryMetadata.addJoinFlag(new JoinFlag((Expression)jf.getFlag().accept(this, null), jf.getPosition())); 
    } 
    for (OrderSpecifier<?> os : expr.getMetadata().getOrderBy()) {
      OrderSpecifier<?> os2 = new OrderSpecifier<?>(os.getOrder(), (Expression)os.getTarget().accept(this, null), os.getNullHandling());
      defaultQueryMetadata.addOrderBy(os2);
    } 
    for (Map.Entry<ParamExpression<?>, Object> entry : expr.getMetadata().getParams()
      .entrySet())
      defaultQueryMetadata.setParam((ParamExpression)((ParamExpression)entry.getKey()).accept(this, null), entry.getValue()); 
    for (Expression<?> e : expr.getMetadata().getProjection())
      defaultQueryMetadata.addProjection((Expression)e.accept(this, null)); 
    Predicate where = expr.getMetadata().getWhere();
    if (where != null)
      defaultQueryMetadata.addWhere((Predicate)where.accept(this, null)); 
    if (expr.getMetadata().equals(defaultQueryMetadata))
      return expr; 
    return new SubQueryExpressionImpl(expr.getType(), defaultQueryMetadata);
  }
  
  public Expression<?> visit(TemplateExpression<?> expr, @Nullable Void context) {
    ImmutableList.Builder builder = ImmutableList.builder();
    for (Object arg : expr.getArgs()) {
      if (arg instanceof Expression) {
        builder.add(((Expression)arg).accept(this, null));
        continue;
      } 
      builder.add(arg);
    } 
    ImmutableList args = builder.build();
    if (args.equals(expr.getArgs()))
      return expr; 
    if (expr instanceof Predicate)
      return BooleanTemplate.create(expr.getTemplate(), new Object[] { args }); 
    return new TemplateExpressionImpl(expr.getType(), expr.getTemplate(), args);
  }
  
  private ImmutableList<Expression<?>> visit(List<Expression<?>> args) {
    ImmutableList.Builder<Expression<?>> builder = ImmutableList.builder();
    for (Expression<?> arg : args)
      builder.add(arg.accept(this, null)); 
    return builder.build();
  }
}
