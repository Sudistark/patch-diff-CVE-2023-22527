package com.mysema.query.support;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.mysema.query.JoinFlag;
import com.mysema.query.QueryFlag;
import com.mysema.query.types.Constant;
import com.mysema.query.types.Expression;
import com.mysema.query.types.FactoryExpression;
import com.mysema.query.types.Operation;
import com.mysema.query.types.Operator;
import com.mysema.query.types.Ops;
import com.mysema.query.types.ParamExpression;
import com.mysema.query.types.Path;
import com.mysema.query.types.PathType;
import com.mysema.query.types.Template;
import com.mysema.query.types.TemplateExpression;
import com.mysema.query.types.Templates;
import com.mysema.query.types.Visitor;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

public abstract class SerializerBase<S extends SerializerBase<S>> extends Object implements Visitor<Void, Void> {
  private static final Set<Operator> SAME_PRECEDENCE = ImmutableSet.of(Ops.CASE, Ops.CASE_WHEN, Ops.CASE_ELSE, Ops.CASE_EQ, Ops.CASE_EQ_WHEN, Ops.CASE_EQ_ELSE, new Operator[0]);
  
  private final StringBuilder builder;
  
  private String constantPrefix;
  
  private String paramPrefix;
  
  private String anonParamPrefix;
  
  private Map<Object, String> constantToLabel;
  
  private final S self;
  
  private final Templates templates;
  
  private final char escape;
  
  private boolean normalize;
  
  private boolean strict;
  
  public SerializerBase(Templates templates) {
    this.builder = new StringBuilder(128);
    this.constantPrefix = "a";
    this.paramPrefix = "p";
    this.anonParamPrefix = "_";
    this.self = this;
    this.normalize = true;
    this.strict = true;
    this.templates = templates;
    this.escape = templates.getEscapeChar();
  }
  
  public final S prepend(String str) {
    this.builder.insert(0, str);
    return (S)this.self;
  }
  
  public final S insert(int position, String str) {
    this.builder.insert(position, str);
    return (S)this.self;
  }
  
  public final S append(String str) {
    this.builder.append(str);
    return (S)this.self;
  }
  
  protected String getConstantPrefix() { return this.constantPrefix; }
  
  public Map<Object, String> getConstantToLabel() {
    if (this.constantToLabel == null)
      this.constantToLabel = new HashMap(4); 
    return this.constantToLabel;
  }
  
  public int getLength() { return this.builder.length(); }
  
  protected final Template getTemplate(Operator<?> op) { return this.templates.getTemplate(op); }
  
  public final S handle(Expression<?> expr) {
    expr.accept(this, null);
    return (S)this.self;
  }
  
  public final S handle(Object arg) {
    if (arg instanceof Expression) {
      ((Expression)arg).accept(this, null);
    } else {
      visitConstant(arg);
    } 
    return (S)this.self;
  }
  
  public final S handle(JoinFlag joinFlag) { return (S)handle(joinFlag.getFlag()); }
  
  public final S handle(String sep, Expression[] expressions) {
    for (int i = 0; i < expressions.length; i++) {
      if (i != 0)
        append(sep); 
      handle(expressions[i]);
    } 
    return (S)this.self;
  }
  
  public final S handle(String sep, List<?> expressions) {
    for (int i = 0; i < expressions.size(); i++) {
      if (i != 0)
        append(sep); 
      handle((Expression)expressions.get(i));
    } 
    return (S)this.self;
  }
  
  protected void handleTemplate(Template template, List<?> args) {
    for (Template.Element element : template.getElements()) {
      Object rv = element.convert(args);
      if (rv instanceof Expression) {
        ((Expression)rv).accept(this, null);
        continue;
      } 
      if (element.isString()) {
        this.builder.append(rv.toString());
        continue;
      } 
      visitConstant(rv);
    } 
  }
  
  public final boolean serialize(QueryFlag.Position position, Set<QueryFlag> flags) {
    boolean handled = false;
    for (QueryFlag flag : flags) {
      if (flag.getPosition() == position) {
        handle(flag.getFlag());
        handled = true;
      } 
    } 
    return handled;
  }
  
  public final boolean serialize(JoinFlag.Position position, Set<JoinFlag> flags) {
    boolean handled = false;
    for (JoinFlag flag : flags) {
      if (flag.getPosition() == position) {
        handle(flag.getFlag());
        handled = true;
      } 
    } 
    return handled;
  }
  
  public void setConstantPrefix(String prefix) { this.constantPrefix = prefix; }
  
  public void setParamPrefix(String prefix) { this.paramPrefix = prefix; }
  
  public void setAnonParamPrefix(String prefix) { this.anonParamPrefix = prefix; }
  
  public void setNormalize(boolean normalize) { this.normalize = normalize; }
  
  public void setStrict(boolean strict) { this.strict = strict; }
  
  public String toString() {
    if (this.normalize)
      return Normalization.normalize(this.builder.toString()); 
    return this.builder.toString();
  }
  
  public final Void visit(Constant<?> expr, Void context) {
    visitConstant(expr.getConstant());
    return null;
  }
  
  public void visitConstant(Object constant) {
    if (!getConstantToLabel().containsKey(constant)) {
      String constLabel = this.constantPrefix + (getConstantToLabel().size() + 1);
      getConstantToLabel().put(constant, constLabel);
      append(constLabel);
    } else {
      append((String)getConstantToLabel().get(constant));
    } 
  }
  
  public Void visit(ParamExpression<?> param, Void context) {
    String paramLabel;
    if (param.isAnon()) {
      paramLabel = this.anonParamPrefix + param.getName();
    } else {
      paramLabel = this.paramPrefix + param.getName();
    } 
    getConstantToLabel().put(param, paramLabel);
    append(paramLabel);
    return null;
  }
  
  public Void visit(TemplateExpression<?> expr, Void context) {
    handleTemplate(expr.getTemplate(), expr.getArgs());
    return null;
  }
  
  public Void visit(FactoryExpression<?> expr, Void context) {
    handle(", ", expr.getArgs());
    return null;
  }
  
  public Void visit(Operation<?> expr, Void context) {
    visitOperation(expr.getType(), expr.getOperator(), expr.getArgs());
    return null;
  }
  
  public Void visit(Path<?> path, Void context) {
    ImmutableList immutableList;
    PathType pathType = path.getMetadata().getPathType();
    Template template = this.templates.getTemplate(pathType);
    Object element = path.getMetadata().getElement();
    if (path.getMetadata().getParent() != null) {
      immutableList = ImmutableList.of(path.getMetadata().getParent(), element);
    } else {
      immutableList = ImmutableList.of(element);
    } 
    handleTemplate(template, immutableList);
    return null;
  }
  
  protected void visitOperation(Class<?> type, Operator<?> operator, List<? extends Expression<?>> args) {
    Template template = this.templates.getTemplate(operator);
    if (template != null) {
      int precedence = this.templates.getPrecedence(operator);
      boolean first = true;
      for (Template.Element element : template.getElements()) {
        Object rv = element.convert(args);
        if (rv instanceof Expression) {
          Expression<?> expr = (Expression)rv;
          if (precedence > -1 && expr instanceof Operation) {
            Operator op = ((Operation)expr).getOperator();
            int opPrecedence = this.templates.getPrecedence(op);
            if (precedence < opPrecedence) {
              append("(").handle(expr).append(")");
            } else if (!first && precedence == opPrecedence && !SAME_PRECEDENCE.contains(op)) {
              append("(").handle(expr).append(")");
            } else {
              handle(expr);
            } 
          } else {
            handle(expr);
          } 
          first = false;
          continue;
        } 
        if (element.isString()) {
          append(rv.toString());
          continue;
        } 
        visitConstant(rv);
      } 
    } else {
      if (this.strict)
        throw new IllegalArgumentException("Got no pattern for " + operator); 
      append(operator.toString());
      append("(");
      handle(", ", args);
      append(")");
    } 
  }
}
