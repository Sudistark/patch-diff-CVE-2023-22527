package com.mysema.query.sql.spatial;

import com.google.common.collect.Lists;
import com.vividsolutions.jts.io.ByteArrayInStream;
import com.vividsolutions.jts.io.ByteOrderDataInStream;
import com.vividsolutions.jts.io.InStream;
import java.io.IOException;
import java.util.List;
import org.geolatte.geom.DimensionalFlag;
import org.geolatte.geom.Geometry;
import org.geolatte.geom.GeometryCollection;
import org.geolatte.geom.GeometryType;
import org.geolatte.geom.LineString;
import org.geolatte.geom.LinearRing;
import org.geolatte.geom.MultiLineString;
import org.geolatte.geom.MultiPoint;
import org.geolatte.geom.MultiPolygon;
import org.geolatte.geom.Point;
import org.geolatte.geom.PointSequence;
import org.geolatte.geom.PointSequenceBuilder;
import org.geolatte.geom.PointSequenceBuilders;
import org.geolatte.geom.Points;
import org.geolatte.geom.Polygon;
import org.geolatte.geom.crs.CrsId;

public class SQLServerGeometryReader {
  private static GeometryType[] TYPES = { GeometryType.POINT, GeometryType.LINE_STRING, GeometryType.POLYGON, GeometryType.MULTI_POINT, GeometryType.MULTI_LINE_STRING, GeometryType.MULTI_POLYGON, GeometryType.GEOMETRY_COLLECTION };
  
  private int srid;
  
  private int version;
  
  private int serializationProps;
  
  private int numberOfPoints;
  
  private boolean hasZ;
  
  private boolean hasM;
  
  private boolean singlePoint;
  
  private boolean singleLine;
  
  private DimensionalFlag dimensionalFlag;
  
  private double[][] points;
  
  private double[] zValues;
  
  private double[] mValues;
  
  private Figure[] figures;
  
  private Shape[] shapes;
  
  private CrsId crsId;
  
  public Geometry read(byte[] bytes) throws IOException { return read(new ByteArrayInStream(bytes)); }
  
  public Geometry read(InStream is) throws IOException {
    ByteOrderDataInStream dis = new ByteOrderDataInStream(is);
    dis.setOrder(2);
    this.srid = dis.readInt();
    this.version = dis.readByte();
    this.serializationProps = dis.readByte();
    this.hasZ = ((this.serializationProps & true) == 1);
    this.hasM = ((this.serializationProps & 0x2) == 2);
    this.singlePoint = ((this.serializationProps & 0x8) == 8);
    this.singleLine = ((this.serializationProps & 0x10) == 16);
    this.numberOfPoints = 1;
    if (this.singleLine) {
      this.numberOfPoints = 2;
    } else if (!this.singlePoint) {
      this.numberOfPoints = dis.readInt();
    } 
    this.dimensionalFlag = DimensionalFlag.d2D;
    if (this.hasM) {
      if (this.hasZ) {
        this.dimensionalFlag = DimensionalFlag.d3DM;
      } else {
        this.dimensionalFlag = DimensionalFlag.d2DM;
      } 
    } else if (this.hasZ) {
      this.dimensionalFlag = DimensionalFlag.d3D;
    } 
    this.points = readPoints(dis, this.numberOfPoints);
    if (this.hasZ)
      this.zValues = readDoubles(dis, this.numberOfPoints); 
    if (this.hasM)
      this.mValues = readDoubles(dis, this.numberOfPoints); 
    this.crsId = CrsId.valueOf(this.srid);
    if (this.singlePoint)
      return createPoint(0); 
    if (this.singleLine) {
      PointSequence points = createPoints(0, 2);
      return new LineString(points);
    } 
    int numberOfFigures = dis.readInt();
    this.figures = readFigures(dis, numberOfFigures);
    int numberOfShapes = dis.readInt();
    this.shapes = readShapes(dis, numberOfShapes);
    return decode(0);
  }
  
  private Geometry decode(int shapeIdx) {
    switch (null.$SwitchMap$org$geolatte$geom$GeometryType[(this.shapes[shapeIdx]).type.ordinal()]) {
      case 1:
        return decodePoint(shapeIdx);
      case 2:
        return decodeLineString(shapeIdx);
      case 3:
        return decodePolygon(shapeIdx);
      case 4:
        return decodeMultiPoint(shapeIdx);
      case 5:
        return decodeMultiLineString(shapeIdx);
      case 6:
        return decodeMultiPolygon(shapeIdx);
      case 7:
        return decodeGeometryCollection(shapeIdx);
    } 
    throw new IllegalArgumentException(String.valueOf(shapeIdx));
  }
  
  private GeometryCollection decodeGeometryCollection(int shapeIdx) {
    List<Geometry> geometries = Lists.newArrayList();
    for (int i = shapeIdx; i < this.shapes.length; i++) {
      if ((this.shapes[i]).parentOffset == shapeIdx)
        geometries.add(decode(i)); 
    } 
    return new GeometryCollection((Geometry[])geometries.toArray(new Geometry[0]));
  }
  
  private MultiLineString decodeMultiLineString(int shapeIdx) {
    List<LineString> lineStrings = Lists.newArrayList();
    for (int i = shapeIdx; i < this.shapes.length; i++) {
      if ((this.shapes[i]).parentOffset == shapeIdx)
        lineStrings.add(decodeLineString(i)); 
    } 
    return new MultiLineString((LineString[])lineStrings.toArray(new LineString[0]));
  }
  
  private MultiPolygon decodeMultiPolygon(int shapeIdx) {
    List<Polygon> polygons = Lists.newArrayList();
    for (int i = shapeIdx; i < this.shapes.length; i++) {
      if ((this.shapes[i]).parentOffset == shapeIdx)
        polygons.add(decodePolygon(i)); 
    } 
    return new MultiPolygon((Polygon[])polygons.toArray(new Polygon[0]));
  }
  
  private MultiPoint decodeMultiPoint(int shapeIdx) {
    List<Point> points = Lists.newArrayList();
    for (int i = shapeIdx; i < this.shapes.length; i++) {
      if ((this.shapes[i]).parentOffset == shapeIdx)
        points.add(decodePoint(i)); 
    } 
    return new MultiPoint((Point[])points.toArray(new Point[0]));
  }
  
  private Polygon decodePolygon(int shapeIdx) {
    Shape shape = this.shapes[shapeIdx];
    int figureOffset = shape.figureOffset;
    if (figureOffset <= -1)
      return Polygon.createEmpty(); 
    int figureStopIdx = this.figures.length - 1;
    if (shapeIdx < this.shapes.length - 1)
      figureStopIdx = (this.shapes[shapeIdx + 1]).figureOffset - 1; 
    List<LinearRing> linearRings = Lists.newArrayList();
    for (int i = figureOffset; i <= figureStopIdx; i++)
      linearRings.add(new LinearRing(createPoints(i))); 
    return new Polygon((LinearRing[])linearRings.toArray(new LinearRing[0]));
  }
  
  private LineString decodeLineString(int shapeIdx) {
    Shape shape = this.shapes[shapeIdx];
    return new LineString(createPoints(shape.figureOffset));
  }
  
  private Point decodePoint(int shapeIdx) {
    int pointIdx = (this.figures[(this.shapes[shapeIdx]).figureOffset]).pointOffset;
    return createPoint(pointIdx);
  }
  
  private Point createPoint(int idx) {
    double x = this.points[idx][0];
    double y = this.points[idx][1];
    if (this.hasM) {
      if (this.hasZ)
        return Points.create3DM(x, y, this.zValues[idx], this.mValues[idx], this.crsId); 
      return Points.create2DM(x, y, this.mValues[idx], this.crsId);
    } 
    if (this.hasZ)
      return Points.create3D(x, y, this.zValues[idx], this.crsId); 
    return Points.create2D(x, y, this.crsId);
  }
  
  private PointSequence createPoints(int idx1, int idx2) {
    PointSequenceBuilder builder = PointSequenceBuilders.fixedSized(idx2 - idx1, this.dimensionalFlag, this.crsId);
    for (int i = idx1; i < idx2; i++)
      builder.add(createPoint(i)); 
    return builder.toPointSequence();
  }
  
  private PointSequence createPoints(int figureIdx) {
    int idx1 = (this.figures[figureIdx]).pointOffset;
    int idx2 = this.points.length;
    if (figureIdx < this.figures.length - 1)
      idx2 = (this.figures[figureIdx + 1]).pointOffset; 
    return createPoints(idx1, idx2);
  }
  
  private double[] readDoubles(ByteOrderDataInStream is, int num) throws IOException {
    double[] doubles = new double[num];
    for (int i = 0; i < num; i++)
      doubles[i] = is.readDouble(); 
    return doubles;
  }
  
  private Figure[] readFigures(ByteOrderDataInStream is, int num) throws IOException {
    Figure[] arrayOfFigure = new Figure[num];
    for (int i = 0; i < num; i++) {
      Figure figure = new Figure(null);
      figure.attributes = is.readByte();
      figure.pointOffset = is.readInt();
      arrayOfFigure[i] = figure;
    } 
    return arrayOfFigure;
  }
  
  private double[][] readPoints(ByteOrderDataInStream is, int num) throws IOException {
    double[][] points = new double[num][];
    for (int i = 0; i < num; i++) {
      new double[2][0] = is.readDouble();
      new double[2][1] = is.readDouble();
      points[i] = new double[2];
    } 
    return points;
  }
  
  private Shape[] readShapes(ByteOrderDataInStream is, int num) throws IOException {
    Shape[] arrayOfShape = new Shape[num];
    for (int i = 0; i < num; i++) {
      Shape shape = new Shape(null);
      shape.parentOffset = is.readInt();
      shape.figureOffset = is.readInt();
      shape.type = TYPES[is.readByte() - 1];
      arrayOfShape[i] = shape;
    } 
    return arrayOfShape;
  }
}
