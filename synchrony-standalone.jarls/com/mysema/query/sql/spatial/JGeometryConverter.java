package com.mysema.query.sql.spatial;

import oracle.spatial.geometry.JGeometry;
import org.geolatte.geom.DimensionalFlag;
import org.geolatte.geom.Geometry;
import org.geolatte.geom.GeometryCollection;
import org.geolatte.geom.LineString;
import org.geolatte.geom.LinearRing;
import org.geolatte.geom.MultiLineString;
import org.geolatte.geom.MultiPoint;
import org.geolatte.geom.MultiPolygon;
import org.geolatte.geom.Point;
import org.geolatte.geom.PointCollection;
import org.geolatte.geom.PointCollectionFactory;
import org.geolatte.geom.PointSequence;
import org.geolatte.geom.PolyHedralSurface;
import org.geolatte.geom.Polygon;
import org.geolatte.geom.crs.CrsId;

public class JGeometryConverter {
  public static JGeometry convert(Geometry geometry) {
    switch (null.$SwitchMap$org$geolatte$geom$GeometryType[geometry.getGeometryType().ordinal()]) {
      case 1:
        return convert((Point)geometry);
      case 2:
        return convert((GeometryCollection)geometry);
      case 3:
        return convert((LineString)geometry);
      case 4:
        return convert((LinearRing)geometry);
      case 5:
        return convert((Polygon)geometry);
      case 6:
        return convert((PolyHedralSurface)geometry);
      case 7:
        return convert((MultiPoint)geometry);
      case 8:
        return convert((MultiPolygon)geometry);
      case 9:
        return convert((MultiLineString)geometry);
    } 
    throw new IllegalArgumentException(geometry.toString());
  }
  
  private static double[] getPoints(PointCollection points) {
    int dim = points.getCoordinateDimension();
    double[] values = new double[points.size() * dim];
    int offset = 0;
    for (int i = 0; i < points.size(); i++) {
      values[offset++] = points.getX(i);
      values[offset++] = points.getY(i);
      if (points.is3D())
        values[offset++] = points.getZ(i); 
      if (points.isMeasured())
        values[offset++] = points.getM(i); 
    } 
    return values;
  }
  
  private static double[] getCoordinates(Point geometry) {
    double[] value = new double[geometry.getCoordinateDimension()];
    int offset = 0;
    value[offset++] = geometry.getX();
    value[offset++] = geometry.getY();
    if (geometry.is3D())
      value[offset++] = geometry.getZ(); 
    if (geometry.isMeasured())
      value[offset++] = geometry.getM(); 
    return value;
  }
  
  private static JGeometry convert(Polygon geometry) {
    int srid = geometry.getSRID();
    int dim = geometry.getCoordinateDimension();
    double[] points = getPoints(geometry.getPoints());
    int[] elemInfo = new int[3 + geometry.getNumInteriorRing() * 3];
    int offset = 0;
    int pointOffset = 1;
    elemInfo[offset++] = pointOffset;
    elemInfo[offset++] = 1003;
    elemInfo[offset++] = 1;
    pointOffset += geometry.getExteriorRing().getNumPoints() * dim;
    for (int i = 0; i < geometry.getNumInteriorRing(); i++) {
      elemInfo[offset++] = pointOffset;
      elemInfo[offset++] = 2003;
      elemInfo[offset++] = 1;
      pointOffset += geometry.getInteriorRingN(i).getNumPoints() * dim;
    } 
    int gtype = dim * 1000 + (geometry.isMeasured() ? dim : 0) * 100 + 3;
    return new JGeometry(gtype, srid, elemInfo, points);
  }
  
  private static JGeometry convert(PolyHedralSurface geometry) { throw new UnsupportedOperationException(); }
  
  private static JGeometry convert(LineString geometry) {
    int srid = geometry.getSRID();
    int dim = geometry.getCoordinateDimension();
    double[] points = getPoints(geometry.getPoints());
    int[] elemInfo = { 1, 2, 1 };
    int gtype = dim * 1000 + (geometry.isMeasured() ? dim : 0) * 100 + 2;
    return new JGeometry(gtype, srid, elemInfo, points);
  }
  
  private static JGeometry convert(GeometryCollection geometry) { throw new UnsupportedOperationException(); }
  
  private static JGeometry convert(MultiPoint geometry) {
    int srid = geometry.getSRID();
    int dim = geometry.getCoordinateDimension();
    double[] points = getPoints(geometry.getPoints());
    int[] elemInfo = { 1, 1, geometry.getNumPoints() };
    int gtype = dim * 1000 + (geometry.isMeasured() ? dim : 0) * 100 + 5;
    return new JGeometry(gtype, srid, elemInfo, points);
  }
  
  private static JGeometry convert(MultiPolygon geometry) { throw new UnsupportedOperationException(); }
  
  private static JGeometry convert(MultiLineString geometry) {
    int srid = geometry.getSRID();
    int dim = geometry.getCoordinateDimension();
    double[] points = getPoints(geometry.getPoints());
    int[] elemInfo = new int[geometry.getNumGeometries() * 3];
    int offset = 0;
    int pointOffset = 1;
    for (int i = 0; i < geometry.getNumGeometries(); i++) {
      elemInfo[offset++] = pointOffset;
      elemInfo[offset++] = 2;
      elemInfo[offset++] = 1;
      pointOffset += geometry.getGeometryN(i).getNumPoints() * dim;
    } 
    int gtype = dim * 1000 + (geometry.isMeasured() ? dim : 0) * 100 + 6;
    return new JGeometry(gtype, srid, elemInfo, points);
  }
  
  private static JGeometry convert(Point geometry) {
    double[] value = getCoordinates(geometry);
    int srid = geometry.getSRID();
    if (geometry.isMeasured())
      return JGeometry.createLRSPoint(value, value.length - 1, srid); 
    return JGeometry.createPoint(value, value.length, srid);
  }
  
  public static Geometry convert(JGeometry geometry) {
    switch (geometry.getType()) {
      case 4:
        return convertCollection(geometry);
      case 2:
        return convertCurve(geometry);
      case 6:
        return convertMultiCurve(geometry);
      case 5:
        return convertMultiPoint(geometry);
      case 7:
        return convertMultiPolygon(geometry);
      case 1:
        return convertPoint(geometry);
      case 3:
        return convertPolygon(geometry);
    } 
    throw new IllegalArgumentException(geometry.toString());
  }
  
  private static PointSequence getPoints(JGeometry geometry) {
    CrsId crs = CrsId.valueOf(geometry.getSRID());
    int dimensions = geometry.getDimensions();
    boolean measured = geometry.isLRSGeometry();
    DimensionalFlag flag = DimensionalFlag.valueOf((dimensions > (measured ? 3 : 2)), measured);
    double[] ordinates = geometry.getOrdinatesArray();
    return PointCollectionFactory.create(ordinates, flag, crs);
  }
  
  private static Polygon convertPolygon(JGeometry geometry) {
    CrsId crs = CrsId.valueOf(geometry.getSRID());
    int dimensions = geometry.getDimensions();
    boolean measured = geometry.isLRSGeometry();
    DimensionalFlag flag = DimensionalFlag.valueOf((dimensions > (measured ? 3 : 2)), measured);
    Object[] elements = geometry.getOrdinatesOfElements();
    LinearRing[] rings = new LinearRing[elements.length];
    for (int i = 0; i < elements.length; i++) {
      PointSequence points = PointCollectionFactory.create((double[])elements[i], flag, crs);
      rings[i] = new LinearRing(points);
    } 
    return new Polygon(rings);
  }
  
  private static Point convertPoint(JGeometry geometry) {
    CrsId crs = CrsId.valueOf(geometry.getSRID());
    double[] point = geometry.getPoint();
    int dimensions = geometry.getDimensions();
    boolean measured = geometry.isLRSGeometry();
    DimensionalFlag flag = DimensionalFlag.valueOf((dimensions > (measured ? 3 : 2)), measured);
    return new Point(PointCollectionFactory.create(point, flag, crs));
  }
  
  private static LineString convertCurve(JGeometry geometry) {
    CrsId crs = CrsId.valueOf(geometry.getSRID());
    PointSequence points = getPoints(geometry);
    return new LineString(points);
  }
  
  private static MultiPoint convertMultiPoint(JGeometry geometry) {
    CrsId crs = CrsId.valueOf(geometry.getSRID());
    JGeometry[] elements = geometry.getElements();
    if (elements == null || elements.length == 0)
      return MultiPoint.createEmpty(); 
    Point[] points = new Point[elements.length];
    int dimensions = geometry.getDimensions();
    double[] ordinates = geometry.getOrdinatesArray();
    boolean measured = geometry.isLRSGeometry();
    DimensionalFlag flag = DimensionalFlag.valueOf((dimensions > (measured ? 3 : 2)), measured);
    int offset = 0;
    for (int i = 0; i < points.length; i++) {
      double[] coords = new double[dimensions];
      System.arraycopy(ordinates, offset, coords, 0, coords.length);
      points[i] = new Point(PointCollectionFactory.create(coords, flag, crs));
      offset += dimensions;
    } 
    return new MultiPoint(points);
  }
  
  private static MultiPolygon convertMultiPolygon(JGeometry geometry) {
    JGeometry[] elements = geometry.getElements();
    if (elements == null || elements.length == 0)
      return MultiPolygon.createEmpty(); 
    Polygon[] polygons = new Polygon[elements.length];
    for (int i = 0; i < elements.length; i++)
      polygons[i] = convertPolygon(elements[i]); 
    return new MultiPolygon(polygons);
  }
  
  private static MultiLineString convertMultiCurve(JGeometry geometry) {
    JGeometry[] elements = geometry.getElements();
    if (elements == null || elements.length == 0)
      return MultiLineString.createEmpty(); 
    CrsId crs = CrsId.valueOf(geometry.getSRID());
    LineString[] lineStrings = new LineString[elements.length];
    for (int i = 0; i < elements.length; i++) {
      PointSequence points = getPoints(elements[i]);
      lineStrings[i] = new LineString(points);
    } 
    return new MultiLineString(lineStrings);
  }
  
  private static GeometryCollection convertCollection(JGeometry geometry) {
    JGeometry[] elements = geometry.getElements();
    if (elements == null || elements.length == 0)
      return GeometryCollection.createEmpty(); 
    Geometry[] geometries = new Geometry[elements.length];
    for (int i = 0; i < elements.length; i++)
      geometries[i] = convert(elements[i]); 
    return new GeometryCollection(geometries);
  }
}
