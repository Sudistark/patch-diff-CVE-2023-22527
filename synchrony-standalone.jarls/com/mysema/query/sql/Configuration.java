package com.mysema.query.sql;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.google.common.primitives.Primitives;
import com.mysema.query.sql.types.ArrayType;
import com.mysema.query.sql.types.Type;
import com.mysema.query.types.Path;
import java.lang.reflect.Array;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public final class Configuration {
  private static final Logger logger = LoggerFactory.getLogger(Configuration.class);
  
  public static final Configuration DEFAULT = new Configuration(SQLTemplates.DEFAULT);
  
  private final JDBCTypeMapping jdbcTypeMapping;
  
  private final JavaTypeMapping javaTypeMapping;
  
  private final Map<SchemaAndTable, SchemaAndTable> schemaTables;
  
  private final Map<String, String> schemas;
  
  private final Map<String, String> tables;
  
  private final Map<SchemaAndTable, Map<String, String>> schemaTableColumns;
  
  private final Map<String, Map<String, String>> tableColumns;
  
  private final Map<String, Class<?>> typeToName;
  
  private SQLTemplates templates;
  
  private SQLExceptionTranslator exceptionTranslator;
  
  private final SQLListeners listeners;
  
  private boolean hasTableColumnTypes;
  
  private boolean useLiterals;
  
  public Configuration(SQLTemplates templates) {
    this.jdbcTypeMapping = new JDBCTypeMapping();
    this.javaTypeMapping = new JavaTypeMapping();
    this.schemaTables = Maps.newHashMap();
    this.schemas = Maps.newHashMap();
    this.tables = Maps.newHashMap();
    this.schemaTableColumns = Maps.newHashMap();
    this.tableColumns = Maps.newHashMap();
    this.typeToName = Maps.newHashMap();
    this.exceptionTranslator = DefaultSQLExceptionTranslator.DEFAULT;
    this.listeners = new SQLListeners();
    this.hasTableColumnTypes = false;
    this.useLiterals = false;
    this.templates = templates;
    for (Type<?> customType : templates.getCustomTypes())
      this.javaTypeMapping.register(customType); 
    for (Map.Entry<SchemaAndTable, SchemaAndTable> entry : templates.getTableOverrides().entrySet())
      this.schemaTables.put(entry.getKey(), entry.getValue()); 
    if (templates.isArraysSupported()) {
      ImmutableList immutableList = ImmutableList.of(String.class, Long.class, Integer.class, Short.class, Byte.class, Boolean.class, java.sql.Date.class, java.sql.Timestamp.class, java.sql.Time.class, Double.class, Float.class);
      for (Class<?> cl : immutableList) {
        int code = this.jdbcTypeMapping.get(cl).intValue();
        String name = templates.getTypeNameForCode(code);
        Class<?> arrType = Array.newInstance(cl, 0).getClass();
        this.javaTypeMapping.register(new ArrayType(arrType, name));
        if (Primitives.isWrapperType(cl) && !cl.equals(Byte.class)) {
          cl = Primitives.unwrap(cl);
          arrType = Array.newInstance(cl, 0).getClass();
          this.javaTypeMapping.register(new ArrayType(arrType, name));
        } 
      } 
    } 
  }
  
  public String asLiteral(Object o) {
    if (com.mysema.query.sql.types.Null.class.isInstance(o))
      return "null"; 
    Type type = this.javaTypeMapping.getType(o.getClass());
    if (type != null)
      return this.templates.serialize(type.getLiteral(o), type.getSQLTypes()[0]); 
    throw new IllegalArgumentException("Unsupported literal type " + o.getClass().getName());
  }
  
  public SQLTemplates getTemplates() { return this.templates; }
  
  @Deprecated
  public Class<?> getJavaType(int sqlType, int size, int digits, String tableName, String columnName) { return getJavaType(sqlType, null, size, digits, tableName, columnName); }
  
  public Class<?> getJavaType(int sqlType, String typeName, int size, int digits, String tableName, String columnName) {
    Type<?> type = this.javaTypeMapping.getType(tableName, columnName);
    if (type != null)
      return type.getReturnedClass(); 
    if (typeName != null && !typeName.isEmpty()) {
      typeName = typeName.toLowerCase();
      Class<?> clazz = (Class)this.typeToName.get(typeName);
      if (clazz != null)
        return clazz; 
      if (sqlType == 2003) {
        if (typeName.startsWith("_")) {
          typeName = typeName.substring(1);
        } else if (typeName.endsWith(" array")) {
          typeName = typeName.substring(0, typeName.length() - 6);
        } 
        if (typeName.contains("["))
          typeName = typeName.substring(0, typeName.indexOf("[")); 
        if (typeName.contains("("))
          typeName = typeName.substring(0, typeName.indexOf("(")); 
        Integer sqlComponentType = this.templates.getCodeForTypeName(typeName);
        if (sqlComponentType == null) {
          logger.warn("Found no JDBC type for " + typeName + " using OTHER instead");
          sqlComponentType = Integer.valueOf(1111);
        } 
        Class<?> componentType = this.jdbcTypeMapping.get(sqlComponentType.intValue(), size, digits);
        return Array.newInstance(componentType, 0).getClass();
      } 
    } 
    return this.jdbcTypeMapping.get(sqlType, size, digits);
  }
  
  @Nullable
  public <T> T get(ResultSet rs, @Nullable Path<?> path, int i, Class<T> clazz) throws SQLException { return (T)getType(path, clazz).getValue(rs, i); }
  
  @Deprecated
  public String getSchema(String schema) { return (String)this.schemas.get(schema); }
  
  @Deprecated
  public String getTable(String schema, String table) { return getOverride(new SchemaAndTable(schema, table)).getTable(); }
  
  @Nullable
  public SchemaAndTable getOverride(SchemaAndTable key) {
    if (!this.schemaTables.isEmpty() && key.getSchema() != null && 
      this.schemaTables.containsKey(key))
      return (SchemaAndTable)this.schemaTables.get(key); 
    String schema = key.getSchema(), table = key.getTable();
    boolean changed = false;
    if (this.schemas.containsKey(key.getSchema())) {
      schema = (String)this.schemas.get(key.getSchema());
      changed = true;
    } 
    if (this.tables.containsKey(key.getTable())) {
      table = (String)this.tables.get(key.getTable());
      changed = true;
    } 
    return changed ? new SchemaAndTable(schema, table) : key;
  }
  
  public String getColumnOverride(SchemaAndTable key, String column) {
    String newColumn = null;
    Map<String, String> columnOverrides = (Map)this.schemaTableColumns.get(key);
    if (columnOverrides != null && (newColumn = (String)columnOverrides.get(column)) != null)
      return newColumn; 
    columnOverrides = (Map)this.tableColumns.get(key.getTable());
    if (columnOverrides != null && (newColumn = (String)columnOverrides.get(column)) != null)
      return newColumn; 
    return column;
  }
  
  public <T> void set(PreparedStatement stmt, Path<?> path, int i, T value) throws SQLException {
    if (com.mysema.query.sql.types.Null.class.isInstance(value)) {
      Integer sqlType = (path != null) ? Integer.valueOf(ColumnMetadata.getColumnMetadata(path).getJdbcType()) : null;
      if (sqlType != null) {
        stmt.setNull(i, sqlType.intValue());
      } else {
        stmt.setNull(i, 0);
      } 
    } else {
      getType(path, value.getClass()).setValue(stmt, i, value);
    } 
  }
  
  private <T> Type<T> getType(@Nullable Path<?> path, Class<T> clazz) {
    if (this.hasTableColumnTypes && path != null && !clazz.equals(com.mysema.query.sql.types.Null.class) && path
      .getMetadata().getParent() instanceof RelationalPath) {
      String table = ((RelationalPath)path.getMetadata().getParent()).getTableName();
      String column = ColumnMetadata.getName(path);
      Type<T> type = this.javaTypeMapping.getType(table, column);
      if (type != null)
        return type; 
    } 
    return this.javaTypeMapping.getType(clazz);
  }
  
  public String getTypeName(Class<?> type) {
    Integer jdbcType = this.jdbcTypeMapping.get(type);
    if (jdbcType == null)
      jdbcType = Integer.valueOf(this.javaTypeMapping.getType(type).getSQLTypes()[0]); 
    return this.templates.getTypeNameForCode(jdbcType.intValue());
  }
  
  public String getTypeNameForCast(Class<?> type) {
    Integer jdbcType = this.jdbcTypeMapping.get(type);
    if (jdbcType == null)
      jdbcType = Integer.valueOf(this.javaTypeMapping.getType(type).getSQLTypes()[0]); 
    return this.templates.getCastTypeNameForCode(jdbcType.intValue());
  }
  
  public String registerSchemaOverride(String oldSchema, String newSchema) { return (String)this.schemas.put(oldSchema, newSchema); }
  
  public String registerTableOverride(String oldTable, String newTable) { return (String)this.tables.put(oldTable, newTable); }
  
  public String registerTableOverride(String schema, String oldTable, String newTable) {
    SchemaAndTable st = registerTableOverride(schema, oldTable, schema, newTable);
    return (st != null) ? st.getTable() : null;
  }
  
  public SchemaAndTable registerTableOverride(String schema, String oldTable, String newSchema, String newTable) { return registerTableOverride(new SchemaAndTable(schema, oldTable), new SchemaAndTable(newSchema, newTable)); }
  
  public SchemaAndTable registerTableOverride(SchemaAndTable from, SchemaAndTable to) { return (SchemaAndTable)this.schemaTables.put(from, to); }
  
  public String registerColumnOverride(String schema, String table, String oldColumn, String newColumn) {
    SchemaAndTable key = new SchemaAndTable(schema, table);
    Map<String, String> columnOverrides = (Map)this.schemaTableColumns.get(key);
    if (columnOverrides == null) {
      columnOverrides = new HashMap<String, String>();
      this.schemaTableColumns.put(key, columnOverrides);
    } 
    return (String)columnOverrides.put(oldColumn, newColumn);
  }
  
  public String registerColumnOverride(String table, String oldColumn, String newColumn) {
    Map<String, String> columnOverrides = (Map)this.tableColumns.get(table);
    if (columnOverrides == null) {
      columnOverrides = new HashMap<String, String>();
      this.tableColumns.put(table, columnOverrides);
    } 
    return (String)columnOverrides.put(oldColumn, newColumn);
  }
  
  public void register(Type<?> type) {
    this.jdbcTypeMapping.register(type.getSQLTypes()[0], type.getReturnedClass());
    this.javaTypeMapping.register(type);
  }
  
  public void registerType(String typeName, Class<?> clazz) { this.typeToName.put(typeName.toLowerCase(), clazz); }
  
  public void registerNumeric(int total, int decimal, Class<?> javaType) { this.jdbcTypeMapping.registerNumeric(total, decimal, javaType); }
  
  public void registerNumeric(int beginTotal, int endTotal, int beginDecimal, int endDecimal, Class<?> javaType) {
    for (int total = beginTotal; total <= endTotal; total++) {
      for (int decimal = beginDecimal; decimal <= endDecimal; decimal++)
        registerNumeric(total, decimal, javaType); 
    } 
  }
  
  public void register(String table, String column, Class<?> javaType) { register(table, column, this.javaTypeMapping.getType(javaType)); }
  
  public void register(String table, String column, Type<?> type) {
    this.javaTypeMapping.setType(table, column, type);
    this.hasTableColumnTypes = true;
  }
  
  public RuntimeException translate(SQLException ex) { return this.exceptionTranslator.translate(ex); }
  
  public RuntimeException translate(String sql, List<Object> bindings, SQLException ex) { return this.exceptionTranslator.translate(sql, bindings, ex); }
  
  public void addListener(SQLListener listener) { this.listeners.add(listener); }
  
  public SQLListeners getListeners() { return this.listeners; }
  
  public boolean getUseLiterals() { return this.useLiterals; }
  
  public void setUseLiterals(boolean useLiterals) { this.useLiterals = useLiterals; }
  
  public void setExceptionTranslator(SQLExceptionTranslator exceptionTranslator) { this.exceptionTranslator = exceptionTranslator; }
  
  public void setTemplates(SQLTemplates templates) { this.templates = templates; }
}
