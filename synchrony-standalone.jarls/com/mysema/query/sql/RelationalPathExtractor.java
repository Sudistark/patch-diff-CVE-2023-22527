package com.mysema.query.sql;

import com.google.common.collect.ImmutableSet;
import com.mysema.query.JoinExpression;
import com.mysema.query.QueryMetadata;
import com.mysema.query.types.Constant;
import com.mysema.query.types.Expression;
import com.mysema.query.types.FactoryExpression;
import com.mysema.query.types.Operation;
import com.mysema.query.types.OrderSpecifier;
import com.mysema.query.types.ParamExpression;
import com.mysema.query.types.Path;
import com.mysema.query.types.SubQueryExpression;
import com.mysema.query.types.TemplateExpression;
import com.mysema.query.types.Visitor;
import com.mysema.query.util.CollectionUtils;
import java.util.Set;

public final class RelationalPathExtractor extends Object implements Visitor<Set<RelationalPath<?>>, Set<RelationalPath<?>>> {
  public static final RelationalPathExtractor DEFAULT = new RelationalPathExtractor();
  
  public static Set<RelationalPath<?>> extract(QueryMetadata md) {
    ImmutableSet immutableSet = ImmutableSet.of();
    Set set = DEFAULT.visitJoins(md.getJoins(), immutableSet);
    for (Expression<?> p : md.getProjection())
      set = (Set)p.accept(DEFAULT, set); 
    for (OrderSpecifier<?> o : md.getOrderBy())
      set = (Set)o.getTarget().accept(DEFAULT, set); 
    for (Expression<?> g : md.getGroupBy())
      set = (Set)g.accept(DEFAULT, set); 
    if (md.getHaving() != null)
      set = (Set)md.getHaving().accept(DEFAULT, set); 
    if (md.getWhere() != null)
      set = (Set)md.getWhere().accept(DEFAULT, set); 
    return set;
  }
  
  public static Set<RelationalPath<?>> extract(Expression<?> expr) { return (Set)expr.accept(DEFAULT, ImmutableSet.of()); }
  
  public Set<RelationalPath<?>> visit(Constant<?> expr, Set<RelationalPath<?>> known) { return known; }
  
  public Set<RelationalPath<?>> visit(FactoryExpression<?> expr, Set<RelationalPath<?>> known) {
    for (Expression<?> arg : expr.getArgs())
      known = (Set)arg.accept(this, known); 
    return known;
  }
  
  public Set<RelationalPath<?>> visit(Operation<?> expr, Set<RelationalPath<?>> known) {
    for (Expression<?> arg : expr.getArgs())
      known = (Set)arg.accept(this, known); 
    return known;
  }
  
  public Set<RelationalPath<?>> visit(ParamExpression<?> expr, Set<RelationalPath<?>> known) { return known; }
  
  public Set<RelationalPath<?>> visit(Path<?> expr, Set<RelationalPath<?>> known) {
    if (expr.getMetadata().isRoot()) {
      if (expr instanceof RelationalPath)
        known = CollectionUtils.add(known, (RelationalPath)expr); 
    } else {
      known = (Set)expr.getMetadata().getParent().accept(this, known);
    } 
    return known;
  }
  
  public Set<RelationalPath<?>> visit(SubQueryExpression<?> expr, Set<RelationalPath<?>> known) {
    Set<RelationalPath<?>> old = known;
    QueryMetadata md = expr.getMetadata();
    known = visitJoins(md.getJoins(), known);
    for (Expression<?> p : md.getProjection())
      known = (Set)p.accept(this, known); 
    for (OrderSpecifier<?> o : md.getOrderBy())
      known = (Set)o.getTarget().accept(this, known); 
    for (Expression<?> g : md.getGroupBy())
      known = (Set)g.accept(this, known); 
    if (md.getHaving() != null)
      known = (Set)md.getHaving().accept(this, known); 
    if (md.getWhere() != null)
      md.getWhere().accept(this, known); 
    return old;
  }
  
  public Set<RelationalPath<?>> visit(TemplateExpression<?> expr, Set<RelationalPath<?>> known) {
    for (Object arg : expr.getArgs()) {
      if (arg instanceof Expression)
        known = (Set)((Expression)arg).accept(this, known); 
    } 
    return known;
  }
  
  private Set<RelationalPath<?>> visitJoins(Iterable<JoinExpression> joins, Set<RelationalPath<?>> known) {
    for (JoinExpression j : joins) {
      known = (Set)j.getTarget().accept(this, known);
      if (j.getCondition() != null)
        known = (Set)j.getCondition().accept(this, known); 
    } 
    return known;
  }
}
