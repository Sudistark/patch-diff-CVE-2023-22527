package com.mysema.query.sql;

import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.mysema.commons.lang.Pair;
import com.mysema.query.JoinExpression;
import com.mysema.query.JoinFlag;
import com.mysema.query.QueryFlag;
import com.mysema.query.QueryMetadata;
import com.mysema.query.support.Expressions;
import com.mysema.query.support.SerializerBase;
import com.mysema.query.types.Constant;
import com.mysema.query.types.ConstantImpl;
import com.mysema.query.types.Expression;
import com.mysema.query.types.ExpressionUtils;
import com.mysema.query.types.FactoryExpression;
import com.mysema.query.types.Operator;
import com.mysema.query.types.Ops;
import com.mysema.query.types.Order;
import com.mysema.query.types.OrderSpecifier;
import com.mysema.query.types.ParamExpression;
import com.mysema.query.types.Path;
import com.mysema.query.types.PathMetadata;
import com.mysema.query.types.Predicate;
import com.mysema.query.types.SubQueryExpression;
import com.mysema.query.types.Template;
import com.mysema.query.types.TemplateExpression;
import com.mysema.query.types.TemplateFactory;
import com.mysema.query.types.template.NumberTemplate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import javax.annotation.Nullable;

public class SQLSerializer extends SerializerBase<SQLSerializer> {
  private static final Expression Q = Expressions.template(Object.class, "?", new Object[0]);
  
  private static final String COMMA = ", ";
  
  private final LinkedList<Path<?>> constantPaths = new LinkedList();
  
  private final List<Object> constants = new ArrayList();
  
  private final boolean dml;
  
  protected Stage stage = Stage.SELECT;
  
  private boolean skipParent;
  
  private boolean dmlWithSchema;
  
  private RelationalPath<?> entity;
  
  private final Configuration configuration;
  
  private final SQLTemplates templates;
  
  private boolean inUnion = false;
  
  private boolean inJoin = false;
  
  private boolean useLiterals = false;
  
  public SQLSerializer(Configuration conf) { this(conf, false); }
  
  public SQLSerializer(Configuration conf, boolean dml) {
    super(conf.getTemplates());
    this.configuration = conf;
    this.templates = conf.getTemplates();
    this.dml = dml;
  }
  
  protected void appendAsColumnName(Path<?> path, boolean precededByDot) {
    String column = ColumnMetadata.getName(path);
    if (path.getMetadata().getParent() instanceof RelationalPath) {
      RelationalPath<?> parent = (RelationalPath)path.getMetadata().getParent();
      column = this.configuration.getColumnOverride(parent.getSchemaAndTable(), column);
    } 
    append(this.templates.quoteIdentifier(column, precededByDot));
  }
  
  private SchemaAndTable getSchemaAndTable(RelationalPath<?> path) { return this.configuration.getOverride(path.getSchemaAndTable()); }
  
  protected void appendSchemaName(String schema) { append(this.templates.quoteIdentifier(schema)); }
  
  protected void appendTableName(String table, boolean precededByDot) { append(this.templates.quoteIdentifier(table, precededByDot)); }
  
  public List<Object> getConstants() { return this.constants; }
  
  public List<Path<?>> getConstantPaths() { return this.constantPaths; }
  
  private List<Expression<?>> getIdentifierColumns(List<JoinExpression> joins, boolean alias) {
    if (joins.size() == 1) {
      JoinExpression join = (JoinExpression)joins.get(0);
      if (join.getTarget() instanceof RelationalPath)
        return ((RelationalPath)join.getTarget()).getColumns(); 
      return Collections.emptyList();
    } 
    List<Expression<?>> rv = Lists.newArrayList();
    int counter = 0;
    for (JoinExpression join : joins) {
      if (join.getTarget() instanceof RelationalPath) {
        List<Expression<?>> columns;
        RelationalPath path = (RelationalPath)join.getTarget();
        if (path.getPrimaryKey() != null) {
          columns = path.getPrimaryKey().getLocalColumns();
        } else {
          columns = path.getColumns();
        } 
        if (alias) {
          for (Expression<?> column : columns)
            rv.add(ExpressionUtils.as(column, "col" + ++counter)); 
          continue;
        } 
        rv.addAll(columns);
        continue;
      } 
      return Collections.emptyList();
    } 
    return rv;
  }
  
  protected SQLTemplates getTemplates() { return this.templates; }
  
  public void handle(String template, Object... args) { handleTemplate(TemplateFactory.DEFAULT.create(template), Arrays.asList(args)); }
  
  protected void handleJoinTarget(JoinExpression je) {
    if (je.getTarget() instanceof RelationalPath && this.templates.isSupportsAlias()) {
      RelationalPath<?> pe = (RelationalPath)je.getTarget();
      if (pe.getMetadata().getParent() == null) {
        boolean precededByDot;
        SchemaAndTable schemaAndTable = getSchemaAndTable(pe);
        if (this.templates.isPrintSchema()) {
          appendSchemaName(schemaAndTable.getSchema());
          append(".");
          precededByDot = true;
        } else {
          precededByDot = false;
        } 
        appendTableName(schemaAndTable.getTable(), precededByDot);
        append(this.templates.getTableAlias());
      } 
    } 
    this.inJoin = true;
    handle(je.getTarget());
    this.inJoin = false;
  }
  
  public void serialize(QueryMetadata metadata, boolean forCountRow) { this.templates.serialize(metadata, forCountRow, this); }
  
  void serializeForQuery(QueryMetadata metadata, boolean forCountRow) {
    List<Expression<?>> sqlSelect;
    boolean oldSkipParent = this.skipParent;
    this.skipParent = false;
    List<? extends Expression<?>> select = metadata.getProjection();
    List<JoinExpression> joins = metadata.getJoins();
    Predicate where = metadata.getWhere();
    List<? extends Expression<?>> groupBy = metadata.getGroupBy();
    Predicate having = metadata.getHaving();
    List<OrderSpecifier<?>> orderBy = metadata.getOrderBy();
    Set<QueryFlag> flags = metadata.getFlags();
    boolean hasFlags = !flags.isEmpty();
    String suffix = null;
    if (select.size() == 1) {
      Expression<?> first = (Expression)select.get(0);
      if (first instanceof FactoryExpression) {
        sqlSelect = ((FactoryExpression)first).getArgs();
      } else {
        sqlSelect = select;
      } 
    } else {
      sqlSelect = new ArrayList<Expression<?>>(select.size());
      for (Expression<?> selectExpr : select) {
        if (selectExpr instanceof FactoryExpression) {
          sqlSelect.addAll(((FactoryExpression)selectExpr).getArgs());
          continue;
        } 
        sqlSelect.add(selectExpr);
      } 
    } 
    if (hasFlags) {
      List<Expression<?>> withFlags = Lists.newArrayList();
      boolean recursive = false;
      for (QueryFlag flag : flags) {
        if (flag.getPosition() == QueryFlag.Position.WITH) {
          if (flag.getFlag() == SQLTemplates.RECURSIVE) {
            recursive = true;
            continue;
          } 
          withFlags.add(flag.getFlag());
        } 
      } 
      if (!withFlags.isEmpty()) {
        if (recursive) {
          append(this.templates.getWithRecursive());
        } else {
          append(this.templates.getWith());
        } 
        handle(", ", withFlags);
        append("\n");
      } 
    } 
    if (hasFlags)
      serialize(QueryFlag.Position.START, flags); 
    Stage oldStage = this.stage;
    this.stage = Stage.SELECT;
    if (forCountRow) {
      append(this.templates.getSelect());
      if (hasFlags)
        serialize(QueryFlag.Position.AFTER_SELECT, flags); 
      if (!metadata.isDistinct()) {
        append(this.templates.getCountStar());
        if (!groupBy.isEmpty()) {
          append(this.templates.getFrom());
          append("(");
          append(this.templates.getSelect());
          append("1 as one ");
          suffix = ") internal";
        } 
      } else {
        List<? extends Expression<?>> columns;
        if (sqlSelect.isEmpty()) {
          columns = getIdentifierColumns(joins, !this.templates.isCountDistinctMultipleColumns());
        } else {
          columns = sqlSelect;
        } 
        if (!groupBy.isEmpty()) {
          append(this.templates.getCountStar());
          append(this.templates.getFrom());
          append("(");
          append(this.templates.getSelectDistinct());
          handle(", ", columns);
          suffix = ") internal";
        } else if (columns.size() == 1) {
          append(this.templates.getDistinctCountStart());
          handle((Expression)columns.get(0));
          append(this.templates.getDistinctCountEnd());
        } else if (this.templates.isCountDistinctMultipleColumns()) {
          append(this.templates.getDistinctCountStart());
          ((SQLSerializer)((SQLSerializer)append("(")).handle(", ", columns)).append(")");
          append(this.templates.getDistinctCountEnd());
        } else {
          append(this.templates.getCountStar());
          append(this.templates.getFrom());
          append("(");
          append(this.templates.getSelectDistinct());
          handle(", ", columns);
          suffix = ") internal";
        } 
      } 
    } else if (!sqlSelect.isEmpty()) {
      if (!metadata.isDistinct()) {
        append(this.templates.getSelect());
      } else {
        append(this.templates.getSelectDistinct());
      } 
      if (hasFlags)
        serialize(QueryFlag.Position.AFTER_SELECT, flags); 
      handle(", ", sqlSelect);
    } 
    if (hasFlags)
      serialize(QueryFlag.Position.AFTER_PROJECTION, flags); 
    this.stage = Stage.FROM;
    serializeSources(joins);
    if (where != null) {
      this.stage = Stage.WHERE;
      if (hasFlags)
        serialize(QueryFlag.Position.BEFORE_FILTERS, flags); 
      ((SQLSerializer)append(this.templates.getWhere())).handle(where);
      if (hasFlags)
        serialize(QueryFlag.Position.AFTER_FILTERS, flags); 
    } 
    if (!groupBy.isEmpty()) {
      this.stage = Stage.GROUP_BY;
      if (hasFlags)
        serialize(QueryFlag.Position.BEFORE_GROUP_BY, flags); 
      ((SQLSerializer)append(this.templates.getGroupBy())).handle(", ", groupBy);
      if (hasFlags)
        serialize(QueryFlag.Position.AFTER_GROUP_BY, flags); 
    } 
    if (having != null) {
      this.stage = Stage.HAVING;
      if (hasFlags)
        serialize(QueryFlag.Position.BEFORE_HAVING, flags); 
      ((SQLSerializer)append(this.templates.getHaving())).handle(having);
      if (hasFlags)
        serialize(QueryFlag.Position.AFTER_HAVING, flags); 
    } 
    if (hasFlags)
      serialize(QueryFlag.Position.BEFORE_ORDER, flags); 
    if (!orderBy.isEmpty() && !forCountRow) {
      this.stage = Stage.ORDER_BY;
      append(this.templates.getOrderBy());
      handleOrderBy(orderBy);
      if (hasFlags)
        serialize(QueryFlag.Position.AFTER_ORDER, flags); 
    } 
    if (!forCountRow && metadata.getModifiers().isRestricting() && !joins.isEmpty()) {
      this.stage = Stage.MODIFIERS;
      this.templates.serializeModifiers(metadata, this);
    } 
    if (suffix != null)
      append(suffix); 
    this.stage = oldStage;
    this.skipParent = oldSkipParent;
  }
  
  protected void handleOrderBy(List<OrderSpecifier<?>> orderBy) {
    boolean first = true;
    for (OrderSpecifier<?> os : orderBy) {
      if (!first)
        append(", "); 
      String order = (os.getOrder() == Order.ASC) ? this.templates.getAsc() : this.templates.getDesc();
      if (os.getNullHandling() == OrderSpecifier.NullHandling.NullsFirst) {
        if (this.templates.getNullsFirst() != null) {
          handle(os.getTarget());
          append(order);
          append(this.templates.getNullsFirst());
        } else {
          append("(case when ");
          handle(os.getTarget());
          append(" is null then 0 else 1 end), ");
          handle(os.getTarget());
          append(order);
        } 
      } else if (os.getNullHandling() == OrderSpecifier.NullHandling.NullsLast) {
        if (this.templates.getNullsLast() != null) {
          handle(os.getTarget());
          append(order);
          append(this.templates.getNullsLast());
        } else {
          append("(case when ");
          handle(os.getTarget());
          append(" is null then 1 else 0 end), ");
          handle(os.getTarget());
          append(order);
        } 
      } else {
        handle(os.getTarget());
        append(order);
      } 
      first = false;
    } 
  }
  
  public void serializeDelete(QueryMetadata metadata, RelationalPath<?> entity) {
    this.entity = entity;
    this.templates.serializeDelete(metadata, entity, this);
  }
  
  void serializeForDelete(QueryMetadata metadata, RelationalPath<?> entity) {
    serialize(QueryFlag.Position.START, metadata.getFlags());
    if (!serialize(QueryFlag.Position.START_OVERRIDE, metadata.getFlags()))
      append(this.templates.getDelete()); 
    serialize(QueryFlag.Position.AFTER_SELECT, metadata.getFlags());
    append("from ");
    this.dmlWithSchema = true;
    handle(entity);
    this.dmlWithSchema = false;
    if (metadata.getWhere() != null)
      ((SQLSerializer)append(this.templates.getWhere())).handle(metadata.getWhere()); 
  }
  
  public void serializeMerge(QueryMetadata metadata, RelationalPath<?> entity, List<Path<?>> keys, List<Path<?>> columns, List<Expression<?>> values, @Nullable SubQueryExpression<?> subQuery) {
    this.entity = entity;
    this.templates.serializeMerge(metadata, entity, keys, columns, values, subQuery, this);
  }
  
  void serializeForMerge(QueryMetadata metadata, RelationalPath<?> entity, List<Path<?>> keys, List<Path<?>> columns, List<Expression<?>> values, @Nullable SubQueryExpression<?> subQuery) {
    serialize(QueryFlag.Position.START, metadata.getFlags());
    if (!serialize(QueryFlag.Position.START_OVERRIDE, metadata.getFlags()))
      append(this.templates.getMergeInto()); 
    serialize(QueryFlag.Position.AFTER_SELECT, metadata.getFlags());
    this.dmlWithSchema = true;
    handle(entity);
    this.dmlWithSchema = false;
    append(" ");
    if (!columns.isEmpty()) {
      this.skipParent = true;
      ((SQLSerializer)((SQLSerializer)append("(")).handle(", ", columns)).append(") ");
      this.skipParent = false;
    } 
    if (!keys.isEmpty()) {
      append(this.templates.getKey());
      this.skipParent = true;
      ((SQLSerializer)((SQLSerializer)append("(")).handle(", ", keys)).append(") ");
      this.skipParent = false;
    } 
    if (subQuery != null) {
      append("\n");
      serialize(subQuery.getMetadata(), false);
    } else {
      if (!this.useLiterals)
        for (int i = 0; i < columns.size(); i++) {
          if (values.get(i) instanceof Constant)
            this.constantPaths.add(columns.get(i)); 
        }  
      append(this.templates.getValues());
      ((SQLSerializer)((SQLSerializer)append("(")).handle(", ", values)).append(") ");
    } 
  }
  
  public void serializeInsert(QueryMetadata metadata, RelationalPath<?> entity, List<Path<?>> columns, List<Expression<?>> values, @Nullable SubQueryExpression<?> subQuery) {
    this.entity = entity;
    this.templates.serializeInsert(metadata, entity, columns, values, subQuery, this);
  }
  
  void serializeForInsert(QueryMetadata metadata, RelationalPath<?> entity, List<Path<?>> columns, List<Expression<?>> values, @Nullable SubQueryExpression<?> subQuery) {
    serialize(QueryFlag.Position.START, metadata.getFlags());
    if (!serialize(QueryFlag.Position.START_OVERRIDE, metadata.getFlags()))
      append(this.templates.getInsertInto()); 
    serialize(QueryFlag.Position.AFTER_SELECT, metadata.getFlags());
    this.dmlWithSchema = true;
    handle(entity);
    this.dmlWithSchema = false;
    if (!columns.isEmpty()) {
      append(" (");
      this.skipParent = true;
      handle(", ", columns);
      this.skipParent = false;
      append(")");
    } 
    if (subQuery != null) {
      append("\n");
      serialize(subQuery.getMetadata(), false);
    } else {
      if (!this.useLiterals)
        for (int i = 0; i < columns.size(); i++) {
          if (values.get(i) instanceof Constant)
            this.constantPaths.add(columns.get(i)); 
        }  
      if (!values.isEmpty()) {
        append(this.templates.getValues());
        append("(");
        handle(", ", values);
        append(")");
      } else {
        append(this.templates.getDefaultValues());
      } 
    } 
  }
  
  public void serializeUpdate(QueryMetadata metadata, RelationalPath<?> entity, List<Pair<Path<?>, Expression<?>>> updates) { this.templates.serializeUpdate(metadata, entity, updates, this); }
  
  void serializeForUpdate(QueryMetadata metadata, RelationalPath<?> entity, List<Pair<Path<?>, Expression<?>>> updates) {
    this.entity = entity;
    serialize(QueryFlag.Position.START, metadata.getFlags());
    if (!serialize(QueryFlag.Position.START_OVERRIDE, metadata.getFlags()))
      append(this.templates.getUpdate()); 
    serialize(QueryFlag.Position.AFTER_SELECT, metadata.getFlags());
    this.dmlWithSchema = true;
    handle(entity);
    this.dmlWithSchema = false;
    append("\n");
    append(this.templates.getSet());
    boolean first = true;
    this.skipParent = true;
    for (Pair<Path<?>, Expression<?>> update : updates) {
      if (!first)
        append(", "); 
      handle((Expression)update.getFirst());
      append(" = ");
      if (!this.useLiterals && update.getSecond() instanceof Constant)
        this.constantPaths.add(update.getFirst()); 
      handle((Expression)update.getSecond());
      first = false;
    } 
    this.skipParent = false;
    if (metadata.getWhere() != null)
      ((SQLSerializer)append(this.templates.getWhere())).handle(metadata.getWhere()); 
  }
  
  private void serializeSources(List<JoinExpression> joins) {
    if (joins.isEmpty()) {
      String dummyTable = this.templates.getDummyTable();
      if (!Strings.isNullOrEmpty(dummyTable)) {
        append(this.templates.getFrom());
        append(dummyTable);
      } 
    } else {
      append(this.templates.getFrom());
      for (int i = 0; i < joins.size(); i++) {
        JoinExpression je = (JoinExpression)joins.get(i);
        if (je.getFlags().isEmpty()) {
          if (i > 0)
            append(this.templates.getJoinSymbol(je.getType())); 
          handleJoinTarget(je);
          if (je.getCondition() != null)
            ((SQLSerializer)append(this.templates.getOn())).handle(je.getCondition()); 
        } else {
          serialize(JoinFlag.Position.START, je.getFlags());
          if (!serialize(JoinFlag.Position.OVERRIDE, je.getFlags()) && i > 0)
            append(this.templates.getJoinSymbol(je.getType())); 
          serialize(JoinFlag.Position.BEFORE_TARGET, je.getFlags());
          handleJoinTarget(je);
          serialize(JoinFlag.Position.BEFORE_CONDITION, je.getFlags());
          if (je.getCondition() != null)
            ((SQLSerializer)append(this.templates.getOn())).handle(je.getCondition()); 
          serialize(JoinFlag.Position.END, je.getFlags());
        } 
      } 
    } 
  }
  
  public void serializeUnion(Expression<?> union, QueryMetadata metadata, boolean unionAll) {
    List<? extends Expression<?>> groupBy = metadata.getGroupBy();
    Predicate having = metadata.getHaving();
    List<OrderSpecifier<?>> orderBy = metadata.getOrderBy();
    Set<QueryFlag> flags = metadata.getFlags();
    boolean hasFlags = !flags.isEmpty();
    if (hasFlags) {
      boolean handled = false;
      boolean recursive = false;
      for (QueryFlag flag : flags) {
        if (flag.getPosition() == QueryFlag.Position.WITH) {
          if (flag.getFlag() == SQLTemplates.RECURSIVE) {
            recursive = true;
            continue;
          } 
          if (handled)
            append(", "); 
          handle(flag.getFlag());
          handled = true;
        } 
      } 
      if (handled) {
        if (recursive) {
          prepend(this.templates.getWithRecursive());
        } else {
          prepend(this.templates.getWith());
        } 
        append("\n");
      } 
    } 
    Stage oldStage = this.stage;
    handle(union);
    if (!groupBy.isEmpty()) {
      this.stage = Stage.GROUP_BY;
      if (hasFlags)
        serialize(QueryFlag.Position.BEFORE_GROUP_BY, flags); 
      ((SQLSerializer)append(this.templates.getGroupBy())).handle(", ", groupBy);
      if (hasFlags)
        serialize(QueryFlag.Position.AFTER_GROUP_BY, flags); 
    } 
    if (having != null) {
      this.stage = Stage.HAVING;
      if (hasFlags)
        serialize(QueryFlag.Position.BEFORE_HAVING, flags); 
      ((SQLSerializer)append(this.templates.getHaving())).handle(having);
      if (hasFlags)
        serialize(QueryFlag.Position.AFTER_HAVING, flags); 
    } 
    if (hasFlags)
      serialize(QueryFlag.Position.BEFORE_ORDER, flags); 
    if (!orderBy.isEmpty()) {
      this.stage = Stage.ORDER_BY;
      append(this.templates.getOrderBy());
      this.skipParent = true;
      handleOrderBy(orderBy);
      this.skipParent = false;
      if (hasFlags)
        serialize(QueryFlag.Position.AFTER_ORDER, flags); 
    } 
    if (hasFlags)
      serialize(QueryFlag.Position.END, flags); 
    this.stage = oldStage;
  }
  
  public void visitConstant(Object constant) {
    if (this.useLiterals) {
      if (constant instanceof Collection) {
        append("(");
        boolean first = true;
        for (Object o : (Collection)constant) {
          if (!first)
            append(", "); 
          append(this.configuration.asLiteral(o));
          first = false;
        } 
        append(")");
      } else {
        append(this.configuration.asLiteral(constant));
      } 
    } else if (constant instanceof Collection) {
      append("(");
      boolean first = true;
      for (Object o : (Collection)constant) {
        if (!first)
          append(", "); 
        append("?");
        this.constants.add(o);
        if (first && this.constantPaths.size() < this.constants.size())
          this.constantPaths.add(null); 
        first = false;
      } 
      append(")");
      int size = ((Collection)constant).size() - 1;
      Path<?> lastPath = (Path)this.constantPaths.peekLast();
      for (int i = 0; i < size; i++)
        this.constantPaths.add(lastPath); 
    } else {
      if (this.stage == Stage.SELECT && 
        !com.mysema.query.sql.types.Null.class.isInstance(constant) && this.configuration
        .getTemplates().isWrapSelectParameters()) {
        String typeName = this.configuration.getTypeNameForCast(constant.getClass());
        Expression type = Expressions.constant(typeName);
        super.visitOperation(constant.getClass(), SQLOps.CAST, ImmutableList.of(Q, type));
      } else {
        append("?");
      } 
      this.constants.add(constant);
      if (this.constantPaths.size() < this.constants.size())
        this.constantPaths.add(null); 
    } 
  }
  
  public Void visit(ParamExpression<?> param, Void context) {
    append("?");
    this.constants.add(param);
    if (this.constantPaths.size() < this.constants.size())
      this.constantPaths.add(null); 
    return null;
  }
  
  public Void visit(Path<?> path, Void context) {
    boolean precededByDot;
    if (this.dml) {
      if (path.equals(this.entity) && path instanceof RelationalPath) {
        SchemaAndTable schemaAndTable = getSchemaAndTable((RelationalPath)path);
        if (this.dmlWithSchema && this.templates.isPrintSchema()) {
          appendSchemaName(schemaAndTable.getSchema());
          append(".");
          precededByDot = true;
        } else {
          precededByDot = false;
        } 
        appendTableName(schemaAndTable.getTable(), precededByDot);
        return null;
      } 
      if (this.entity.equals(path.getMetadata().getParent()) && this.skipParent) {
        appendAsColumnName(path, false);
        return null;
      } 
    } 
    PathMetadata<?> metadata = path.getMetadata();
    if (metadata.getParent() != null && (!this.skipParent || this.dml)) {
      visit(metadata.getParent(), context);
      append(".");
      precededByDot = true;
    } else {
      precededByDot = false;
    } 
    appendAsColumnName(path, precededByDot);
    return null;
  }
  
  public Void visit(SubQueryExpression<?> query, Void context) {
    if (this.inUnion && !this.templates.isUnionsWrapped()) {
      serialize(query.getMetadata(), false);
    } else {
      append("(");
      serialize(query.getMetadata(), false);
      append(")");
    } 
    return null;
  }
  
  public Void visit(TemplateExpression<?> expr, Void context) {
    if (this.inJoin && expr instanceof RelationalFunctionCall && this.templates
      .isFunctionJoinsWrapped()) {
      append("table(");
      super.visit(expr, context);
      append(")");
    } else {
      super.visit(expr, context);
    } 
    return null;
  }
  
  protected void visitOperation(Class<?> type, Operator<?> operator, List<? extends Expression<?>> args) {
    boolean pathAdded = false;
    if (args.size() == 2 && !this.useLiterals && args
      
      .get(0) instanceof Path && args
      .get(1) instanceof Constant && operator != Ops.NUMCAST) {
      Object constant = ((Constant)args.get(1)).getConstant();
      if (!Collection.class.isInstance(constant) || !((Collection)constant).isEmpty())
        for (Template.Element element : this.templates.getTemplate(operator).getElements()) {
          if (element instanceof Template.ByIndex && ((Template.ByIndex)element).getIndex() == 1) {
            this.constantPaths.add((Path)args.get(0));
            pathAdded = true;
            break;
          } 
        }  
    } 
    if (operator == SQLOps.UNION || operator == SQLOps.UNION_ALL) {
      boolean oldUnion = this.inUnion;
      this.inUnion = true;
      super.visitOperation(type, operator, args);
      this.inUnion = oldUnion;
    } else if (operator == Ops.LIKE && args.get(1) instanceof Constant) {
      String escape = String.valueOf(this.templates.getEscapeChar());
      String escaped = ((Expression)args.get(1)).toString().replace(escape, escape + escape);
      super.visitOperation(String.class, Ops.LIKE, 
          ImmutableList.of(args.get(0), ConstantImpl.create(escaped)));
    } else if (operator == Ops.STRING_CAST) {
      String typeName = this.configuration.getTypeNameForCast(String.class);
      super.visitOperation(String.class, SQLOps.CAST, 
          ImmutableList.of(args.get(0), ConstantImpl.create(typeName)));
    } else if (operator == Ops.NUMCAST) {
      Class<?> targetType = (Class)((Constant)args.get(1)).getConstant();
      String typeName = this.configuration.getTypeNameForCast(targetType);
      super.visitOperation(targetType, SQLOps.CAST, 
          ImmutableList.of(args.get(0), ConstantImpl.create(typeName)));
    } else if (operator == Ops.ALIAS) {
      if (this.stage == Stage.SELECT || this.stage == Stage.FROM) {
        super.visitOperation(type, operator, args);
      } else {
        handle((Expression)args.get(1));
      } 
    } else if ((operator == Ops.IN || operator == Ops.NOT_IN) && args
      .get(0) instanceof Path && args
      .get(1) instanceof Constant) {
      Collection<Object> coll = (Collection)((Constant)args.get(1)).getConstant();
      if (coll.isEmpty()) {
        super.visitOperation(type, (operator == Ops.IN) ? Ops.EQ : Ops.NE, 
            ImmutableList.of(NumberTemplate.ONE, NumberTemplate.TWO));
      } else if (this.templates.getListMaxSize() == 0 || coll.size() <= this.templates.getListMaxSize()) {
        super.visitOperation(type, operator, args);
      } else {
        Predicate result;
        Expression<Object> path = (Expression)args.get(0);
        if (pathAdded)
          this.constantPaths.removeLast(); 
        Iterable<List<Object>> partitioned = Iterables.partition(coll, this.templates.getListMaxSize());
        if (operator == Ops.IN) {
          result = ExpressionUtils.inAny(path, partitioned);
        } else {
          result = ExpressionUtils.notInAny(path, partitioned);
        } 
        result.accept(this, null);
      } 
    } else if (operator == SQLOps.WITH_COLUMNS) {
      boolean oldSkipParent = this.skipParent;
      this.skipParent = true;
      super.visitOperation(type, operator, args);
      this.skipParent = oldSkipParent;
    } else if (operator == Ops.ORDER) {
      List<OrderSpecifier<?>> order = (List)((Constant)args.get(0)).getConstant();
      handleOrderBy(order);
    } else {
      super.visitOperation(type, operator, args);
    } 
  }
  
  public void setUseLiterals(boolean useLiterals) { this.useLiterals = useLiterals; }
  
  protected void setSkipParent(boolean b) { this.skipParent = b; }
  
  protected void setDmlWithSchema(boolean b) { this.dmlWithSchema = b; }
}
