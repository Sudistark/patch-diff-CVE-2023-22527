package com.mysema.query.sql;

import com.google.common.collect.ImmutableList;
import com.mysema.commons.lang.CloseableIterator;
import com.mysema.query.DefaultQueryMetadata;
import com.mysema.query.QueryFlag;
import com.mysema.query.QueryMetadata;
import com.mysema.query.QueryModifiers;
import com.mysema.query.SearchResults;
import com.mysema.query.support.QueryMixin;
import com.mysema.query.types.Expression;
import com.mysema.query.types.FactoryExpression;
import com.mysema.query.types.ParamExpression;
import com.mysema.query.types.ParamNotSetException;
import com.mysema.query.types.Path;
import com.mysema.query.types.expr.Wildcard;
import java.lang.reflect.InvocationTargetException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

public abstract class AbstractSQLQuery<Q extends AbstractSQLQuery<Q>> extends ProjectableSQLQuery<Q> {
  private static final Logger logger = LoggerFactory.getLogger(AbstractSQLQuery.class);
  
  private static final QueryFlag rowCountFlag = new QueryFlag(QueryFlag.Position.AFTER_PROJECTION, ", count(*) over() ");
  
  @Nullable
  private final Connection conn;
  
  protected SQLListeners listeners;
  
  protected boolean useLiterals;
  
  private boolean getLastCell;
  
  private Object lastCell;
  
  private StatementOptions statementOptions = StatementOptions.DEFAULT;
  
  public AbstractSQLQuery(@Nullable Connection conn, Configuration configuration) { this(conn, configuration, (new DefaultQueryMetadata()).noValidate()); }
  
  public AbstractSQLQuery(@Nullable Connection conn, Configuration configuration, QueryMetadata metadata) {
    super(new QueryMixin(metadata, false), configuration);
    this.conn = conn;
    this.listeners = new SQLListeners(configuration.getListeners());
    this.useLiterals = configuration.getUseLiterals();
  }
  
  public void addListener(SQLListener listener) { this.listeners.add(listener); }
  
  public long count() {
    try {
      return unsafeCount();
    } catch (SQLException e) {
      String error = "Caught " + e.getClass().getName();
      logger.error(error, e);
      throw this.configuration.translate(e);
    } 
  }
  
  public Q forUpdate() { return (Q)(AbstractSQLQuery)addFlag(SQLOps.FOR_UPDATE_FLAG); }
  
  protected SQLSerializer createSerializer() {
    SQLSerializer serializer = new SQLSerializer(this.configuration);
    serializer.setUseLiterals(this.useLiterals);
    return serializer;
  }
  
  @Nullable
  private <T> T get(ResultSet rs, Expression<?> expr, int i, Class<T> type) throws SQLException { return (T)this.configuration.get(rs, (expr instanceof Path) ? (Path)expr : null, i, type); }
  
  private void set(PreparedStatement stmt, Path<?> path, int i, Object value) throws SQLException { this.configuration.set(stmt, path, i, value); }
  
  protected SQLListenerContextImpl startContext(Connection connection, QueryMetadata metadata) {
    SQLListenerContextImpl context = new SQLListenerContextImpl(metadata, connection);
    this.listeners.start(context);
    return context;
  }
  
  protected void onException(SQLListenerContextImpl context, Exception e) {
    context.setException(e);
    this.listeners.exception(context);
  }
  
  protected void endContext(SQLListenerContext context) { this.listeners.end(context); }
  
  public ResultSet getResults(Expression... exprs) {
    this.queryMixin.addProjection(exprs);
    context = startContext(this.conn, this.queryMixin.getMetadata());
    String queryString = null;
    List list = ImmutableList.of();
    try {
      this.listeners.preRender(context);
      SQLSerializer serializer = serialize(false);
      queryString = serializer.toString();
      logQuery(queryString, serializer.getConstants());
      context.addSQL(queryString);
      this.listeners.rendered(context);
      this.listeners.notifyQuery(this.queryMixin.getMetadata());
      list = serializer.getConstants();
      this.listeners.prePrepare(context);
      PreparedStatement stmt = getPreparedStatement(queryString);
      setParameters(stmt, list, serializer.getConstantPaths(), getMetadata().getParams());
      context.addPreparedStatement(stmt);
      this.listeners.prepared(context);
      this.listeners.preExecute(context);
      ResultSet rs = stmt.executeQuery();
      this.listeners.executed(context);
      return new Object(this, rs, stmt);
    } catch (SQLException e) {
      onException(context, e);
      throw this.configuration.translate(queryString, list, e);
    } finally {
      reset();
      endContext(context);
    } 
  }
  
  private PreparedStatement getPreparedStatement(String queryString) throws SQLException {
    PreparedStatement statement = this.conn.prepareStatement(queryString);
    if (this.statementOptions.getFetchSize() != null)
      statement.setFetchSize(this.statementOptions.getFetchSize().intValue()); 
    if (this.statementOptions.getMaxFieldSize() != null)
      statement.setMaxFieldSize(this.statementOptions.getMaxFieldSize().intValue()); 
    if (this.statementOptions.getQueryTimeout() != null)
      statement.setQueryTimeout(this.statementOptions.getQueryTimeout().intValue()); 
    if (this.statementOptions.getMaxRows() != null)
      statement.setMaxRows(this.statementOptions.getMaxRows().intValue()); 
    return statement;
  }
  
  protected Configuration getConfiguration() { return this.configuration; }
  
  public <RT> CloseableIterator<RT> iterate(Expression<RT> expr) {
    expr = this.queryMixin.addProjection(expr);
    return iterateSingle(this.queryMixin.getMetadata(), expr);
  }
  
  private <RT> CloseableIterator<RT> iterateSingle(QueryMetadata metadata, @Nullable Expression<RT> expr) {
    context = startContext(this.conn, this.queryMixin.getMetadata());
    String queryString = null;
    List list = ImmutableList.of();
    try {
      this.listeners.preRender(context);
      SQLSerializer serializer = serialize(false);
      queryString = serializer.toString();
      logQuery(queryString, serializer.getConstants());
      context.addSQL(queryString);
      this.listeners.rendered(context);
      this.listeners.notifyQuery(this.queryMixin.getMetadata());
      list = serializer.getConstants();
      this.listeners.prePrepare(context);
      PreparedStatement stmt = getPreparedStatement(queryString);
      setParameters(stmt, list, serializer.getConstantPaths(), metadata.getParams());
      context.addPreparedStatement(stmt);
      this.listeners.prepared(context);
      this.listeners.preExecute(context);
      ResultSet rs = stmt.executeQuery();
      this.listeners.executed(context);
      if (expr == null)
        return new Object(this, this.configuration, stmt, rs); 
      if (expr instanceof FactoryExpression)
        return new Object(this, this.configuration, stmt, rs, expr); 
      if (expr.equals(Wildcard.all))
        return new Object(this, this.configuration, stmt, rs); 
      return new Object(this, this.configuration, stmt, rs, expr);
    } catch (SQLException e) {
      onException(context, e);
      throw this.configuration.translate(queryString, list, e);
    } finally {
      endContext(context);
      reset();
    } 
  }
  
  public <RT> List<RT> list(Expression<RT> expr) {
    expr = this.queryMixin.addProjection(expr);
    context = startContext(this.conn, this.queryMixin.getMetadata());
    queryString = null;
    list = ImmutableList.of();
    try {
      this.listeners.preRender(context);
      serializer = serialize(false);
      queryString = serializer.toString();
      logQuery(queryString, serializer.getConstants());
      context.addSQL(queryString);
      this.listeners.rendered(context);
      this.listeners.notifyQuery(this.queryMixin.getMetadata());
      list = serializer.getConstants();
      this.listeners.prePrepare(context);
    } catch (SQLException e) {
      onException(context, e);
      throw this.configuration.translate(queryString, list, e);
    } finally {
      endContext(context);
      reset();
    } 
  }
  
  public <RT> SearchResults<RT> listResults(Expression<RT> expr) {
    QueryModifiers originalModifiers = this.queryMixin.getMetadata().getModifiers();
    try {
      if (this.configuration.getTemplates().isCountViaAnalytics() && this.queryMixin
        .getMetadata().getGroupBy().isEmpty()) {
        long total;
        List<RT> results;
        try {
          this.queryMixin.addFlag(rowCountFlag);
          this.getLastCell = true;
          results = list(expr);
        } finally {
          this.queryMixin.removeFlag(rowCountFlag);
        } 
        if (!results.isEmpty()) {
          if (this.lastCell instanceof Number) {
            total = ((Number)this.lastCell).longValue();
          } else {
            throw new IllegalStateException("Unsupported lastCell instance " + this.lastCell);
          } 
        } else {
          total = count();
        } 
        return new SearchResults(results, originalModifiers, total);
      } 
      this.queryMixin.addProjection(expr);
      long total = count();
      if (total > 0L) {
        this.queryMixin.getMetadata().clearProjection();
        return new SearchResults(list(expr), originalModifiers, total);
      } 
      return SearchResults.emptyResults();
    } finally {
      this.getLastCell = false;
      reset();
    } 
  }
  
  private <RT> RT newInstance(FactoryExpression<RT> c, ResultSet rs, int offset) throws InstantiationException, IllegalAccessException, InvocationTargetException, SQLException {
    Object[] args = new Object[c.getArgs().size()];
    for (int i = 0; i < args.length; i++)
      args[i] = get(rs, (Expression)c.getArgs().get(i), offset + i + 1, ((Expression)c.getArgs().get(i)).getType()); 
    return (RT)c.newInstance(args);
  }
  
  private void reset() {
    getMetadata().clearProjection();
    cleanupMDC();
  }
  
  protected void setParameters(PreparedStatement stmt, List<?> objects, List<Path<?>> constantPaths, Map<ParamExpression<?>, ?> params) {
    if (objects.size() != constantPaths.size())
      throw new IllegalArgumentException("Expected " + objects.size() + " paths, but got " + constantPaths
          .size()); 
    for (int i = 0; i < objects.size(); i++) {
      Object o = objects.get(i);
      try {
        if (o instanceof ParamExpression) {
          if (!params.containsKey(o))
            throw new ParamNotSetException((ParamExpression)o); 
          o = params.get(o);
        } 
        set(stmt, (Path)constantPaths.get(i), i + 1, o);
      } catch (SQLException e) {
        throw this.configuration.translate(e);
      } 
    } 
  }
  
  public <RT> RT uniqueResult(Expression<RT> expr) {
    if (getMetadata().getModifiers().getLimit() == null && 
      !expr.toString().contains("count("))
      limit(2L); 
    CloseableIterator<RT> iterator = iterate(expr);
    return (RT)uniqueResult(iterator);
  }
  
  private long unsafeCount() {
    context = startContext(this.conn, getMetadata());
    String queryString = null;
    List list = ImmutableList.of();
    stmt = null;
    rs = null;
    try {
      this.listeners.preRender(context);
      SQLSerializer serializer = serialize(true);
      queryString = serializer.toString();
      logQuery(queryString, serializer.getConstants());
      context.addSQL(queryString);
      this.listeners.rendered(context);
      list = serializer.getConstants();
      this.listeners.prePrepare(context);
      stmt = getPreparedStatement(queryString);
      setParameters(stmt, list, serializer.getConstantPaths(), getMetadata().getParams());
      context.addPreparedStatement(stmt);
      this.listeners.prepared(context);
      this.listeners.preExecute(context);
      rs = stmt.executeQuery();
      boolean hasResult = rs.next();
      this.listeners.executed(context);
      if (hasResult)
        return rs.getLong(1); 
      return 0L;
    } catch (SQLException e) {
      onException(context, e);
      throw this.configuration.translate(queryString, list, e);
    } finally {
      try {
        if (rs != null)
          rs.close(); 
      } finally {
        if (stmt != null)
          stmt.close(); 
      } 
      endContext(context);
      cleanupMDC();
    } 
  }
  
  protected void logQuery(String queryString, Collection<Object> parameters) {
    if (logger.isDebugEnabled()) {
      String normalizedQuery = queryString.replace('\n', ' ');
      MDC.put("querydsl.query", normalizedQuery);
      MDC.put("querydsl.parameters", String.valueOf(parameters));
      logger.debug(normalizedQuery);
    } 
  }
  
  protected void cleanupMDC() {
    MDC.remove("querydsl.query");
    MDC.remove("querydsl.parameters");
  }
  
  public void setUseLiterals(boolean useLiterals) { this.useLiterals = useLiterals; }
  
  protected void clone(Q query) {
    super.clone(query);
    this.useLiterals = query.useLiterals;
    this.listeners = new SQLListeners(query.listeners);
  }
  
  public Q clone() { return (Q)clone(this.conn); }
  
  public void setStatementOptions(StatementOptions statementOptions) { this.statementOptions = statementOptions; }
  
  public abstract Q clone(Connection paramConnection);
}
