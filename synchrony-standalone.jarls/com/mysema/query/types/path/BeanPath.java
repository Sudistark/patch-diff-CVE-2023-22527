package com.mysema.query.types.path;

import com.mysema.query.types.ConstantImpl;
import com.mysema.query.types.ExpressionException;
import com.mysema.query.types.Ops;
import com.mysema.query.types.Path;
import com.mysema.query.types.PathImpl;
import com.mysema.query.types.PathMetadata;
import com.mysema.query.types.PathMetadataFactory;
import com.mysema.query.types.PathType;
import com.mysema.query.types.Visitor;
import com.mysema.query.types.expr.BooleanExpression;
import com.mysema.query.types.expr.BooleanOperation;
import com.mysema.query.types.expr.SimpleExpression;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.InvocationTargetException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import javax.annotation.Nullable;

public class BeanPath<T> extends SimpleExpression<T> implements Path<T> {
  private static final long serialVersionUID = -1845524024957822731L;
  
  private final Map<Class<?>, Object> casts = new ConcurrentHashMap();
  
  @Nullable
  private final PathInits inits;
  
  private final PathImpl<T> pathMixin;
  
  public BeanPath(Class<? extends T> type, String variable) { this(type, PathMetadataFactory.forVariable(variable), null); }
  
  public BeanPath(Class<? extends T> type, Path<?> parent, String property) { this(type, PathMetadataFactory.forProperty(parent, property), null); }
  
  public BeanPath(Class<? extends T> type, PathMetadata<?> metadata) { this(type, metadata, null); }
  
  public BeanPath(Class<? extends T> type, PathMetadata<?> metadata, @Nullable PathInits inits) {
    super(new PathImpl(type, metadata));
    this.pathMixin = (PathImpl)this.mixin;
    this.inits = inits;
  }
  
  public final <R, C> R accept(Visitor<R, C> v, C context) { return (R)v.visit(this, context); }
  
  public <U extends BeanPath<? extends T>> U as(Class<U> clazz) {
    try {
      if (!this.casts.containsKey(clazz)) {
        U rv;
        PathMetadata<T> metadata;
        if (this.pathMixin.getMetadata().getPathType() != PathType.COLLECTION_ANY) {
          metadata = PathMetadataFactory.forDelegate(this.pathMixin);
        } else {
          metadata = this.pathMixin.getMetadata();
        } 
        if (this.inits != null && this.pathMixin.getMetadata().getPathType() != PathType.VARIABLE) {
          rv = (U)(BeanPath)clazz.getConstructor(new Class[] { PathMetadata.class, PathInits.class }).newInstance(new Object[] { metadata, this.inits });
        } else {
          rv = (U)(BeanPath)clazz.getConstructor(new Class[] { PathMetadata.class }).newInstance(new Object[] { metadata });
        } 
        this.casts.put(clazz, rv);
        return rv;
      } 
      return (U)(BeanPath)this.casts.get(clazz);
    } catch (InstantiationException e) {
      throw new ExpressionException(e.getMessage(), e);
    } catch (IllegalAccessException e) {
      throw new ExpressionException(e.getMessage(), e);
    } catch (InvocationTargetException e) {
      throw new ExpressionException(e.getMessage(), e);
    } catch (NoSuchMethodException e) {
      throw new ExpressionException(e.getMessage(), e);
    } 
  }
  
  protected <P extends Path<?>> P add(P path) { return path; }
  
  protected <A, E> ArrayPath<A, E> createArray(String property, Class<? super A> type) { return (ArrayPath)add(new ArrayPath(type, forProperty(property))); }
  
  protected BooleanPath createBoolean(String property) { return (BooleanPath)add(new BooleanPath(forProperty(property))); }
  
  protected <A, Q extends SimpleExpression<? super A>> CollectionPath<A, Q> createCollection(String property, Class<? super A> type, Class<? super Q> queryType, PathInits inits) { return (CollectionPath)add(new CollectionPath(type, queryType, forProperty(property), inits)); }
  
  protected <A extends Comparable> ComparablePath<A> createComparable(String property, Class<? super A> type) { return (ComparablePath)add(new ComparablePath(type, forProperty(property))); }
  
  protected <A extends Enum<A>> EnumPath<A> createEnum(String property, Class<A> type) { return (EnumPath)add(new EnumPath(type, forProperty(property))); }
  
  protected <A extends Comparable> DatePath<A> createDate(String property, Class<? super A> type) { return (DatePath)add(new DatePath(type, forProperty(property))); }
  
  protected <A extends Comparable> DateTimePath<A> createDateTime(String property, Class<? super A> type) { return (DateTimePath)add(new DateTimePath(type, forProperty(property))); }
  
  protected <A, E extends SimpleExpression<? super A>> ListPath<A, E> createList(String property, Class<? super A> type, Class<? super E> queryType, PathInits inits) { return (ListPath)add(new ListPath(type, queryType, forProperty(property), inits)); }
  
  protected <K, V, E extends SimpleExpression<? super V>> MapPath<K, V, E> createMap(String property, Class<? super K> key, Class<? super V> value, Class<? super E> queryType) { return (MapPath)add(new MapPath(key, value, queryType, forProperty(property))); }
  
  protected <A extends Number & Comparable<?>> NumberPath<A> createNumber(String property, Class<? super A> type) { return (NumberPath)add(new NumberPath(type, forProperty(property))); }
  
  protected <A, E extends SimpleExpression<? super A>> SetPath<A, E> createSet(String property, Class<? super A> type, Class<? super E> queryType, PathInits inits) { return (SetPath)add(new SetPath(type, queryType, forProperty(property), inits)); }
  
  protected <A> SimplePath<A> createSimple(String property, Class<? super A> type) { return (SimplePath)add(new SimplePath(type, forProperty(property))); }
  
  protected StringPath createString(String property) { return (StringPath)add(new StringPath(forProperty(property))); }
  
  protected <A extends Comparable> TimePath<A> createTime(String property, Class<? super A> type) { return (TimePath)add(new TimePath(type, forProperty(property))); }
  
  protected PathMetadata<?> forProperty(String property) { return PathMetadataFactory.forProperty(this, property); }
  
  public PathMetadata<?> getMetadata() { return this.pathMixin.getMetadata(); }
  
  public Path<?> getRoot() { return this.pathMixin.getRoot(); }
  
  public <B extends T> BooleanExpression instanceOf(Class<B> type) { return BooleanOperation.create(Ops.INSTANCE_OF, this.pathMixin, ConstantImpl.create(type)); }
  
  public BooleanExpression instanceOfAny(Class... types) {
    BooleanExpression[] exprs = new BooleanExpression[types.length];
    for (int i = 0; i < types.length; i++)
      exprs[i] = instanceOf(types[i]); 
    return BooleanExpression.anyOf(exprs);
  }
  
  public AnnotatedElement getAnnotatedElement() { return this.pathMixin.getAnnotatedElement(); }
}
