package com.mysema.query.types;

import com.mysema.query.JoinExpression;
import com.mysema.query.QueryMetadata;
import com.mysema.query.util.CollectionUtils;
import java.io.Serializable;
import java.util.Set;

public final class ValidatingVisitor extends Object implements Visitor<Set<Expression<?>>, Set<Expression<?>>>, Serializable {
  private static final long serialVersionUID = 691350069621050872L;
  
  public static final ValidatingVisitor DEFAULT = new ValidatingVisitor();
  
  private final String errorTemplate;
  
  public ValidatingVisitor() { this.errorTemplate = "Undeclared path '%s'. Add this path as a source to the query to be able to reference it."; }
  
  public ValidatingVisitor(String errorTemplate) { this.errorTemplate = errorTemplate; }
  
  public Set<Expression<?>> visit(Constant<?> expr, Set<Expression<?>> known) { return known; }
  
  public Set<Expression<?>> visit(FactoryExpression<?> expr, Set<Expression<?>> known) {
    for (Expression<?> arg : expr.getArgs())
      known = (Set)arg.accept(this, known); 
    return known;
  }
  
  public Set<Expression<?>> visit(Operation<?> expr, Set<Expression<?>> known) {
    if (expr.getOperator() == Ops.ALIAS)
      known = CollectionUtils.add(known, expr.getArg(1)); 
    for (Expression<?> arg : expr.getArgs())
      known = (Set)arg.accept(this, known); 
    return known;
  }
  
  public Set<Expression<?>> visit(ParamExpression<?> expr, Set<Expression<?>> known) { return known; }
  
  public Set<Expression<?>> visit(Path<?> expr, Set<Expression<?>> known) {
    if (!known.contains(expr.getRoot()))
      throw new IllegalArgumentException(String.format(this.errorTemplate, new Object[] { expr.getRoot() })); 
    return known;
  }
  
  public Set<Expression<?>> visit(SubQueryExpression<?> expr, Set<Expression<?>> known) {
    Set<Expression<?>> old = known;
    QueryMetadata md = expr.getMetadata();
    known = visitJoins(md.getJoins(), known);
    for (Expression<?> p : md.getProjection())
      known = (Set)p.accept(this, known); 
    for (OrderSpecifier<?> o : md.getOrderBy())
      known = (Set)o.getTarget().accept(this, known); 
    for (Expression<?> g : md.getGroupBy())
      known = (Set)g.accept(this, known); 
    if (md.getHaving() != null)
      known = (Set)md.getHaving().accept(this, known); 
    if (md.getWhere() != null)
      known = (Set)md.getWhere().accept(this, known); 
    return old;
  }
  
  public Set<Expression<?>> visit(TemplateExpression<?> expr, Set<Expression<?>> known) {
    for (Object arg : expr.getArgs()) {
      if (arg instanceof Expression)
        known = (Set)((Expression)arg).accept(this, known); 
    } 
    return known;
  }
  
  private Set<Expression<?>> visitJoins(Iterable<JoinExpression> joins, Set<Expression<?>> known) {
    for (JoinExpression j : joins) {
      Expression<?> expr = j.getTarget();
      if (expr instanceof Path && ((Path)expr).getMetadata().isRoot()) {
        known = CollectionUtils.add(known, expr);
      } else {
        known = (Set)expr.accept(this, known);
      } 
      if (j.getCondition() != null)
        known = (Set)j.getCondition().accept(this, known); 
    } 
    return known;
  }
}
