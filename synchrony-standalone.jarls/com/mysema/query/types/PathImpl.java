package com.mysema.query.types;

import com.mysema.util.ReflectionUtils;
import java.lang.reflect.AnnotatedElement;
import javax.annotation.Nullable;
import javax.annotation.concurrent.Immutable;

@Immutable
public class PathImpl<T> extends ExpressionBase<T> implements Path<T> {
  private static final long serialVersionUID = -2498447742798348162L;
  
  private final PathMetadata<?> metadata;
  
  private final Path<?> root;
  
  @Nullable
  private AnnotatedElement annotatedElement;
  
  public PathImpl(Class<? extends T> type, String variable) { this(type, PathMetadataFactory.forVariable(variable)); }
  
  public PathImpl(Class<? extends T> type, PathMetadata<?> metadata) {
    super(type);
    this.metadata = metadata;
    this.root = (metadata.getRoot() != null) ? metadata.getRoot() : this;
  }
  
  public PathImpl(Class<? extends T> type, Path<?> parent, String property) { this(type, PathMetadataFactory.forProperty(parent, property)); }
  
  public final boolean equals(Object o) {
    if (o == this)
      return true; 
    if (o instanceof Path)
      return ((Path)o).getMetadata().equals(this.metadata); 
    return false;
  }
  
  public final PathMetadata<?> getMetadata() { return this.metadata; }
  
  public final Path<?> getRoot() { return this.root; }
  
  public final AnnotatedElement getAnnotatedElement() {
    if (this.annotatedElement == null)
      if (this.metadata.getPathType() == PathType.PROPERTY) {
        Class<?> beanClass = this.metadata.getParent().getType();
        String propertyName = this.metadata.getName();
        this.annotatedElement = ReflectionUtils.getAnnotatedElement(beanClass, propertyName, getType());
      } else {
        this.annotatedElement = getType();
      }  
    return this.annotatedElement;
  }
  
  public final <R, C> R accept(Visitor<R, C> v, C context) { return (R)v.visit(this, context); }
}
