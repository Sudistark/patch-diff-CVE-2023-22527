package com.mysema.query.types.expr;

import com.mysema.query.types.CollectionExpression;
import com.mysema.query.types.ConstantImpl;
import com.mysema.query.types.Expression;
import com.mysema.query.types.ExpressionUtils;
import com.mysema.query.types.Ops;
import com.mysema.query.types.Path;
import com.mysema.query.types.PathImpl;
import javax.annotation.Nullable;

public abstract class ComparableExpression<T extends Comparable> extends ComparableExpressionBase<T> {
  private static final long serialVersionUID = 5761359576767404270L;
  
  public ComparableExpression(Expression<T> mixin) { super(mixin); }
  
  public ComparableExpression<T> as(Path<T> alias) { return ComparableOperation.create(getType(), Ops.ALIAS, new Expression[] { this.mixin, alias }); }
  
  public ComparableExpression<T> as(String alias) { return as(new PathImpl(getType(), alias)); }
  
  public final BooleanExpression between(@Nullable T from, @Nullable T to) {
    if (from == null) {
      if (to != null)
        return BooleanOperation.create(Ops.LOE, this.mixin, ConstantImpl.create(to)); 
      throw new IllegalArgumentException("Either from or to needs to be non-null");
    } 
    if (to == null)
      return BooleanOperation.create(Ops.GOE, this.mixin, ConstantImpl.create(from)); 
    return BooleanOperation.create(Ops.BETWEEN, new Expression[] { this.mixin, ConstantImpl.create(from), ConstantImpl.create(to) });
  }
  
  public final BooleanExpression between(@Nullable Expression<T> from, @Nullable Expression<T> to) {
    if (from == null) {
      if (to != null)
        return BooleanOperation.create(Ops.LOE, this.mixin, to); 
      throw new IllegalArgumentException("Either from or to needs to be non-null");
    } 
    if (to == null)
      return BooleanOperation.create(Ops.GOE, this.mixin, from); 
    return BooleanOperation.create(Ops.BETWEEN, new Expression[] { this.mixin, from, to });
  }
  
  public final BooleanExpression notBetween(T from, T to) { return between(from, to).not(); }
  
  public final BooleanExpression notBetween(Expression<T> from, Expression<T> to) { return between(from, to).not(); }
  
  public BooleanExpression gt(T right) { return gt(ConstantImpl.create(right)); }
  
  public BooleanExpression gt(Expression<T> right) { return BooleanOperation.create(Ops.GT, this.mixin, right); }
  
  public BooleanExpression gtAll(CollectionExpression<?, ? super T> right) { return gt(ExpressionUtils.all(right)); }
  
  public BooleanExpression gtAny(CollectionExpression<?, ? super T> right) { return gt(ExpressionUtils.any(right)); }
  
  public BooleanExpression goe(T right) { return goe(ConstantImpl.create(right)); }
  
  public BooleanExpression goe(Expression<T> right) { return BooleanOperation.create(Ops.GOE, this.mixin, right); }
  
  public BooleanExpression goeAll(CollectionExpression<?, ? super T> right) { return goe(ExpressionUtils.all(right)); }
  
  public BooleanExpression goeAny(CollectionExpression<?, ? super T> right) { return goe(ExpressionUtils.any(right)); }
  
  public final BooleanExpression lt(T right) { return lt(ConstantImpl.create(right)); }
  
  public final BooleanExpression lt(Expression<T> right) { return BooleanOperation.create(Ops.LT, this.mixin, right); }
  
  public BooleanExpression ltAll(CollectionExpression<?, ? super T> right) { return lt(ExpressionUtils.all(right)); }
  
  public BooleanExpression ltAny(CollectionExpression<?, ? super T> right) { return lt(ExpressionUtils.any(right)); }
  
  public final BooleanExpression loe(T right) { return BooleanOperation.create(Ops.LOE, this.mixin, ConstantImpl.create(right)); }
  
  public final BooleanExpression loe(Expression<T> right) { return BooleanOperation.create(Ops.LOE, this.mixin, right); }
  
  public BooleanExpression loeAll(CollectionExpression<?, ? super T> right) { return loe(ExpressionUtils.all(right)); }
  
  public BooleanExpression loeAny(CollectionExpression<?, ? super T> right) { return loe(ExpressionUtils.any(right)); }
}
