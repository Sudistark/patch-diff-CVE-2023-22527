package com.mysema.query.types.expr;

import com.mysema.query.types.CollectionExpression;
import com.mysema.query.types.ConstantImpl;
import com.mysema.query.types.Expression;
import com.mysema.query.types.ExpressionUtils;
import com.mysema.query.types.Ops;
import com.mysema.query.types.Path;
import com.mysema.query.types.PathImpl;
import com.mysema.util.MathUtils;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.Nullable;

public abstract class NumberExpression<T extends Number & Comparable<?>> extends ComparableExpressionBase<T> {
  private static final long serialVersionUID = -5485902768703364888L;
  
  @Nullable
  private static final NumberExpression<Double> random = NumberOperation.create(Double.class, Ops.MathOps.RANDOM, new Expression[0]);
  
  public static <A extends Number & Comparable<?>> NumberExpression<A> max(Expression<A> left, Expression<A> right) { return NumberOperation.create(left.getType(), Ops.MathOps.MAX, left, right); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<A> min(Expression<A> left, Expression<A> right) { return NumberOperation.create(left.getType(), Ops.MathOps.MIN, left, right); }
  
  public static NumberExpression<Double> random() { return random; }
  
  public NumberExpression(Expression<T> mixin) { super(mixin); }
  
  public NumberExpression<T> as(Path<T> alias) { return NumberOperation.create(getType(), Ops.ALIAS, this.mixin, alias); }
  
  public NumberExpression<T> as(String alias) { return NumberOperation.create(getType(), Ops.ALIAS, this.mixin, new PathImpl(getType(), alias)); }
  
  public NumberExpression<T> abs() {
    if (this.abs == null)
      this.abs = NumberOperation.create(getType(), Ops.MathOps.ABS, this.mixin); 
    return this.abs;
  }
  
  public <N extends Number & Comparable<?>> NumberExpression<T> add(Expression<N> right) { return NumberOperation.create(getType(), Ops.ADD, this.mixin, right); }
  
  public <N extends Number & Comparable<N>> NumberExpression<T> add(N right) { return NumberOperation.create(getType(), Ops.ADD, this.mixin, ConstantImpl.create(right)); }
  
  public NumberExpression<Double> avg() {
    if (this.avg == null)
      this.avg = NumberOperation.create(Double.class, Ops.AggOps.AVG_AGG, this.mixin); 
    return this.avg;
  }
  
  public NumberExpression<Byte> byteValue() { return castToNum(Byte.class); }
  
  private T cast(Number number) { return (T)MathUtils.cast(number, getType()); }
  
  public <A extends Number & Comparable<? super A>> NumberExpression<A> castToNum(Class<A> type) {
    if (type.equals(getType()))
      return this; 
    return NumberOperation.create(type, Ops.NUMCAST, this.mixin, ConstantImpl.create(type));
  }
  
  public NumberExpression<T> ceil() {
    if (this.ceil == null)
      this.ceil = NumberOperation.create(getType(), Ops.MathOps.CEIL, this.mixin); 
    return this.ceil;
  }
  
  private Class<?> getDivisionType(Class<?> left, Class<?> right) {
    if (!left.equals(right))
      return Double.class; 
    return left;
  }
  
  public <N extends Number & Comparable<?>> NumberExpression<T> divide(Expression<N> right) {
    Class<?> type = getDivisionType(getType(), right.getType());
    return NumberOperation.create(type, Ops.DIV, this.mixin, right);
  }
  
  public <N extends Number & Comparable<?>> NumberExpression<T> divide(N right) {
    Class<?> type = getDivisionType(getType(), right.getClass());
    return NumberOperation.create(type, Ops.DIV, this.mixin, ConstantImpl.create(right));
  }
  
  public NumberExpression<Double> doubleValue() { return castToNum(Double.class); }
  
  public NumberExpression<Float> floatValue() { return castToNum(Float.class); }
  
  public NumberExpression<T> floor() {
    if (this.floor == null)
      this.floor = NumberOperation.create(getType(), Ops.MathOps.FLOOR, this.mixin); 
    return this.floor;
  }
  
  public final <A extends Number & Comparable<?>> BooleanExpression goe(A right) { return goe(ConstantImpl.create(cast(right))); }
  
  public final <A extends Number & Comparable<?>> BooleanExpression goe(Expression<A> right) { return BooleanOperation.create(Ops.GOE, this.mixin, right); }
  
  public BooleanExpression goeAll(CollectionExpression<?, ? super T> right) { return goe(ExpressionUtils.all(right)); }
  
  public BooleanExpression goeAny(CollectionExpression<?, ? super T> right) { return goe(ExpressionUtils.any(right)); }
  
  public final <A extends Number & Comparable<?>> BooleanExpression gt(A right) { return gt(ConstantImpl.create(cast(right))); }
  
  public final <A extends Number & Comparable<?>> BooleanExpression gt(Expression<A> right) { return BooleanOperation.create(Ops.GT, this.mixin, right); }
  
  public BooleanExpression gtAll(CollectionExpression<?, ? super T> right) { return gt(ExpressionUtils.all(right)); }
  
  public BooleanExpression gtAny(CollectionExpression<?, ? super T> right) { return gt(ExpressionUtils.any(right)); }
  
  public final <A extends Number & Comparable<?>> BooleanExpression between(@Nullable A from, @Nullable A to) {
    if (from == null) {
      if (to != null)
        return loe(to); 
      throw new IllegalArgumentException("Either from or to needs to be non-null");
    } 
    if (to == null)
      return goe(from); 
    return between(ConstantImpl.create(cast(from)), ConstantImpl.create(cast(to)));
  }
  
  public final <A extends Number & Comparable<?>> BooleanExpression between(@Nullable Expression<A> from, @Nullable Expression<A> to) {
    if (from == null) {
      if (to != null)
        return BooleanOperation.create(Ops.LOE, this.mixin, to); 
      throw new IllegalArgumentException("Either from or to needs to be non-null");
    } 
    if (to == null)
      return BooleanOperation.create(Ops.GOE, this.mixin, from); 
    return BooleanOperation.create(Ops.BETWEEN, new Expression[] { this.mixin, from, to });
  }
  
  public final <A extends Number & Comparable<?>> BooleanExpression notBetween(A from, A to) { return between(from, to).not(); }
  
  public final <A extends Number & Comparable<?>> BooleanExpression notBetween(Expression<A> from, Expression<A> to) { return between(from, to).not(); }
  
  public NumberExpression<Integer> intValue() { return castToNum(Integer.class); }
  
  public BooleanExpression like(String str) { return BooleanOperation.create(Ops.LIKE, stringValue(), ConstantImpl.create(str)); }
  
  public BooleanExpression like(Expression<String> str) { return BooleanOperation.create(Ops.LIKE, stringValue(), str); }
  
  public final <A extends Number & Comparable<?>> BooleanExpression loe(A right) { return loe(ConstantImpl.create(cast(right))); }
  
  public final <A extends Number & Comparable<?>> BooleanExpression loe(Expression<A> right) { return BooleanOperation.create(Ops.LOE, this.mixin, right); }
  
  public BooleanExpression loeAll(CollectionExpression<?, ? super T> right) { return loe(ExpressionUtils.all(right)); }
  
  public BooleanExpression loeAny(CollectionExpression<?, ? super T> right) { return loe(ExpressionUtils.any(right)); }
  
  public NumberExpression<Long> longValue() { return castToNum(Long.class); }
  
  public final <A extends Number & Comparable<?>> BooleanExpression lt(A right) { return lt(ConstantImpl.create(cast(right))); }
  
  public final <A extends Number & Comparable<?>> BooleanExpression lt(Expression<A> right) { return BooleanOperation.create(Ops.LT, this, right); }
  
  public BooleanExpression ltAll(CollectionExpression<?, ? super T> right) { return lt(ExpressionUtils.all(right)); }
  
  public BooleanExpression ltAny(CollectionExpression<?, ? super T> right) { return lt(ExpressionUtils.any(right)); }
  
  public NumberExpression<T> max() {
    if (this.max == null)
      this.max = NumberOperation.create(getType(), Ops.AggOps.MAX_AGG, this.mixin); 
    return this.max;
  }
  
  public NumberExpression<T> min() {
    if (this.min == null)
      this.min = NumberOperation.create(getType(), Ops.AggOps.MIN_AGG, this.mixin); 
    return this.min;
  }
  
  public NumberExpression<T> mod(Expression<T> num) { return NumberOperation.create(getType(), Ops.MOD, this.mixin, num); }
  
  public NumberExpression<T> mod(T num) { return NumberOperation.create(getType(), Ops.MOD, this.mixin, ConstantImpl.create(num)); }
  
  public <N extends Number & Comparable<?>> NumberExpression<T> multiply(Expression<N> right) { return NumberOperation.create(getType(), Ops.MULT, this.mixin, right); }
  
  public <N extends Number & Comparable<N>> NumberExpression<T> multiply(N right) { return NumberOperation.create(getType(), Ops.MULT, this.mixin, ConstantImpl.create(right)); }
  
  public NumberExpression<T> negate() {
    if (this.negation == null)
      this.negation = NumberOperation.create(getType(), Ops.NEGATE, this.mixin); 
    return this.negation;
  }
  
  public NumberExpression<T> round() {
    if (this.round == null)
      this.round = NumberOperation.create(getType(), Ops.MathOps.ROUND, this.mixin); 
    return this.round;
  }
  
  public NumberExpression<Short> shortValue() { return castToNum(Short.class); }
  
  public NumberExpression<Double> sqrt() {
    if (this.sqrt == null)
      this.sqrt = NumberOperation.create(Double.class, Ops.MathOps.SQRT, this.mixin); 
    return this.sqrt;
  }
  
  public <N extends Number & Comparable<?>> NumberExpression<T> subtract(Expression<N> right) { return NumberOperation.create(getType(), Ops.SUB, this.mixin, right); }
  
  public <N extends Number & Comparable<?>> NumberExpression<T> subtract(N right) { return NumberOperation.create(getType(), Ops.SUB, this.mixin, ConstantImpl.create(right)); }
  
  public NumberExpression<T> sum() {
    if (this.sum == null)
      this.sum = NumberOperation.create(getType(), Ops.AggOps.SUM_AGG, this.mixin); 
    return this.sum;
  }
  
  public BooleanExpression in(Number... numbers) { return in(convert(numbers)); }
  
  public BooleanExpression notIn(Number... numbers) { return notIn(convert(numbers)); }
  
  private List<T> convert(Number... numbers) {
    List<T> list = new ArrayList<T>(numbers.length);
    for (int i = 0; i < numbers.length; i++)
      list.add(MathUtils.cast(numbers[i], getType())); 
    return list;
  }
}
