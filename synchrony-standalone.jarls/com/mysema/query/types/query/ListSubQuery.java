package com.mysema.query.types.query;

import com.mysema.query.QueryMetadata;
import com.mysema.query.types.Expression;
import com.mysema.query.types.ExpressionUtils;
import com.mysema.query.types.OperationImpl;
import com.mysema.query.types.Operator;
import com.mysema.query.types.Ops;
import com.mysema.query.types.SubQueryExpressionImpl;
import com.mysema.query.types.Visitor;
import com.mysema.query.types.expr.BooleanExpression;
import com.mysema.query.types.expr.BooleanOperation;
import com.mysema.query.types.expr.CollectionExpressionBase;
import com.mysema.query.types.expr.NumberExpression;
import com.mysema.query.types.expr.SimpleExpression;
import com.mysema.query.types.expr.SimpleOperation;
import com.mysema.query.types.expr.Wildcard;
import java.util.List;
import javax.annotation.Nullable;

public final class ListSubQuery<T> extends CollectionExpressionBase<List<T>, T> implements ExtendedSubQueryExpression<List<T>> {
  private static final long serialVersionUID = 3399354334765602960L;
  
  private final Class<T> elementType;
  
  private final SubQueryExpressionImpl<List<T>> subQueryMixin;
  
  public ListSubQuery(Class<T> elementType, QueryMetadata md) {
    super(new SubQueryExpressionImpl(List.class, md));
    this.elementType = elementType;
    this.subQueryMixin = (SubQueryExpressionImpl)this.mixin;
  }
  
  public <R, C> R accept(Visitor<R, C> v, C context) { return (R)v.visit(this.subQueryMixin, context); }
  
  public NumberExpression<Long> count() {
    if (this.count == null)
      this.count = count(Ops.AggOps.COUNT_AGG); 
    return this.count;
  }
  
  public NumberExpression<Long> countDistinct() {
    if (this.countDistinct == null)
      this.countDistinct = count(Ops.AggOps.COUNT_DISTINCT_AGG); 
    return this.countDistinct;
  }
  
  private NumberExpression<Long> count(Operator<Long> operator) {
    QueryMetadata md = this.subQueryMixin.getMetadata().clone();
    Expression<?> e = null;
    if (md.getProjection().size() == 1) {
      e = (Expression)md.getProjection().get(0);
    } else if (!md.getProjection().isEmpty()) {
      e = ExpressionUtils.list(Object.class, md.getProjection());
    } 
    md.clearProjection();
    if (e != null) {
      md.addProjection(OperationImpl.create(Long.class, operator, e));
    } else if (operator == Ops.AggOps.COUNT_AGG) {
      md.addProjection(Wildcard.count);
    } else {
      md.addProjection(Wildcard.countDistinct);
    } 
    return new NumberSubQuery(Long.class, md);
  }
  
  public BooleanExpression exists() {
    if (this.exists == null)
      this.exists = BooleanOperation.create(Ops.EXISTS, this.mixin); 
    return this.exists;
  }
  
  public Class<T> getElementType() { return this.elementType; }
  
  public QueryMetadata getMetadata() { return this.subQueryMixin.getMetadata(); }
  
  public BooleanExpression notExists() { return exists().not(); }
  
  public SimpleExpression<?> as(Expression<?> alias) { return SimpleOperation.create(alias.getType(), Ops.ALIAS, this, alias); }
  
  public Class<?> getParameter(int index) {
    if (index == 0)
      return this.elementType; 
    throw new IndexOutOfBoundsException(String.valueOf(index));
  }
}
