package com.mysema.query.group;

import com.infradna.tool.bridge_method_injector.BridgeMethodsAdded;
import com.infradna.tool.bridge_method_injector.WithBridgeMethods;
import com.mysema.commons.lang.Pair;
import com.mysema.query.types.Expression;
import com.mysema.query.types.QList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;

@BridgeMethodsAdded
public final class GroupBy {
  public static <K> GroupByBuilder<K> groupBy(Expression<K> key) { return new GroupByBuilder(key); }
  
  public static GroupByBuilder<List<?>> groupBy(Expression... keys) { return new GroupByBuilder(new QList(keys)); }
  
  public static <E extends Comparable<? super E>> AbstractGroupExpression<E, E> min(Expression<E> expression) { return new GMin(expression); }
  
  public static <E extends Number> AbstractGroupExpression<E, E> sum(Expression<E> expression) { return new GSum(expression); }
  
  public static <E extends Number> AbstractGroupExpression<E, E> avg(Expression<E> expression) { return new GAvg(expression); }
  
  public static <E extends Comparable<? super E>> AbstractGroupExpression<E, E> max(Expression<E> expression) { return new GMax(expression); }
  
  public static <E> AbstractGroupExpression<E, List<E>> list(Expression<E> expression) { return new GList(expression); }
  
  public static <E, F> AbstractGroupExpression<E, List<F>> list(GroupExpression<E, F> groupExpression) { return new MixinGroupExpression(groupExpression, new GList(groupExpression)); }
  
  public static <E> AbstractGroupExpression<E, Set<E>> set(Expression<E> expression) { return GSet.createLinked(expression); }
  
  public static <E, F> GroupExpression<E, Set<F>> set(GroupExpression<E, F> groupExpression) { return new MixinGroupExpression(groupExpression, GSet.createLinked(groupExpression)); }
  
  public static <E extends Comparable<? super E>> AbstractGroupExpression<E, SortedSet<E>> sortedSet(Expression<E> expression) { return GSet.createSorted(expression); }
  
  public static <E, F extends Comparable<? super F>> GroupExpression<E, SortedSet<F>> sortedSet(GroupExpression<E, F> groupExpression) { return new MixinGroupExpression(groupExpression, GSet.createSorted(groupExpression)); }
  
  public static <E> AbstractGroupExpression<E, SortedSet<E>> sortedSet(Expression<E> expression, Comparator<? super E> comparator) { return GSet.createSorted(expression, comparator); }
  
  public static <E, F> GroupExpression<E, SortedSet<F>> sortedSet(GroupExpression<E, F> groupExpression, Comparator<? super F> comparator) { return new MixinGroupExpression(groupExpression, GSet.createSorted(groupExpression, comparator)); }
  
  @WithBridgeMethods(value = {Expression.class}, castRequired = true)
  public static <K, V> AbstractGroupExpression<Pair<K, V>, Map<K, V>> map(Expression<K> key, Expression<V> value) { return GMap.createLinked(QPair.create(key, value)); }
  
  public static <K, V, T> AbstractGroupExpression<Pair<K, V>, Map<T, V>> map(GroupExpression<K, T> key, Expression<V> value) { return map(key, new GOne(value)); }
  
  public static <K, V, U> AbstractGroupExpression<Pair<K, V>, Map<K, U>> map(Expression<K> key, GroupExpression<V, U> value) { return map(new GOne(key), value); }
  
  public static <K, V, T, U> AbstractGroupExpression<Pair<K, V>, Map<T, U>> map(GroupExpression<K, T> key, GroupExpression<V, U> value) { return new GMap.Mixin(key, value, GMap.createLinked(QPair.create(key, value))); }
  
  public static <K extends Comparable<? super K>, V> AbstractGroupExpression<Pair<K, V>, SortedMap<K, V>> sortedMap(Expression<K> key, Expression<V> value) { return GMap.createSorted(QPair.create(key, value)); }
  
  public static <K extends Comparable<? super K>, V, T extends Comparable<? super T>> AbstractGroupExpression<Pair<K, V>, SortedMap<T, V>> sortedMap(GroupExpression<K, T> key, Expression<V> value) { return sortedMap(key, new GOne(value)); }
  
  public static <K extends Comparable<? super K>, V, U> AbstractGroupExpression<Pair<K, V>, SortedMap<K, U>> sortedMap(Expression<K> key, GroupExpression<V, U> value) { return sortedMap(new GOne(key), value); }
  
  public static <K extends Comparable<? super K>, V, T extends Comparable<? super T>, U> AbstractGroupExpression<Pair<K, V>, SortedMap<T, U>> sortedMap(GroupExpression<K, T> key, GroupExpression<V, U> value) { return new GMap.Mixin(key, value, GMap.createSorted(QPair.create(key, value))); }
  
  public static <K, V> AbstractGroupExpression<Pair<K, V>, SortedMap<K, V>> sortedMap(Expression<K> key, Expression<V> value, Comparator<? super K> comparator) { return GMap.createSorted(QPair.create(key, value), comparator); }
  
  public static <K, V, T> AbstractGroupExpression<Pair<K, V>, SortedMap<T, V>> sortedMap(GroupExpression<K, T> key, Expression<V> value, Comparator<? super K> comparator) { return sortedMap(key, new GOne(value), comparator); }
  
  public static <K, V, U> AbstractGroupExpression<Pair<K, V>, SortedMap<K, U>> sortedMap(Expression<K> key, GroupExpression<V, U> value, Comparator<? super U> comparator) { return sortedMap(new GOne(key), value, comparator); }
  
  public static <K, V, T, U> AbstractGroupExpression<Pair<K, V>, SortedMap<T, U>> sortedMap(GroupExpression<K, T> key, GroupExpression<V, U> value, Comparator<? super T> comparator) { return new GMap.Mixin(key, value, GMap.createSorted(QPair.create(key, value), comparator)); }
}
