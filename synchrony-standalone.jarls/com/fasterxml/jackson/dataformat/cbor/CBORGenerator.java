package com.fasterxml.jackson.dataformat.cbor;

import com.fasterxml.jackson.core.Base64Variant;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonStreamContext;
import com.fasterxml.jackson.core.ObjectCodec;
import com.fasterxml.jackson.core.PrettyPrinter;
import com.fasterxml.jackson.core.SerializableString;
import com.fasterxml.jackson.core.StreamWriteCapability;
import com.fasterxml.jackson.core.Version;
import com.fasterxml.jackson.core.base.GeneratorBase;
import com.fasterxml.jackson.core.io.IOContext;
import com.fasterxml.jackson.core.json.DupDetector;
import com.fasterxml.jackson.core.util.JacksonFeatureSet;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.HashMap;

public class CBORGenerator extends GeneratorBase {
  private static final int[] NO_INTS = new int[0];
  
  protected static final int BYTE_BUFFER_FOR_OUTPUT = 16000;
  
  protected static final int REPLACEMENT_CHAR = 65533;
  
  private static final int MAX_LONG_STRING_CHARS = 3996;
  
  private static final int MAX_LONG_STRING_BYTES = 11991;
  
  private static final int MIN_BUFFER_LENGTH = 770;
  
  private static final int INDEFINITE_LENGTH = -2;
  
  protected final IOContext _ioContext;
  
  protected final OutputStream _out;
  
  protected int _formatFeatures;
  
  protected boolean _cfgMinimalInts;
  
  protected boolean _cfgMinimalDoubles;
  
  protected CBORWriteContext _streamWriteContext;
  
  protected byte[] _outputBuffer;
  
  protected int _outputTail = 0;
  
  protected final int _outputEnd;
  
  protected char[] _charBuffer;
  
  protected final int _charBufferLength;
  
  protected int _bytesWritten;
  
  protected int[] _elementCounts = NO_INTS;
  
  protected int _elementCountsPtr;
  
  protected int _currentRemainingElements = -2;
  
  protected boolean _bufferRecyclable;
  
  protected HashMap<Object, Integer> _stringRefs;
  
  private static final int MAX_SHORT_STRING_CHARS = 23;
  
  private static final int MAX_SHORT_STRING_BYTES = 71;
  
  private static final int MAX_MEDIUM_STRING_CHARS = 255;
  
  private static final int MAX_MEDIUM_STRING_BYTES = 768;
  
  public CBORGenerator(IOContext ctxt, int stdFeatures, int formatFeatures, ObjectCodec codec, OutputStream out) {
    super(stdFeatures, codec, null);
    DupDetector dups = JsonGenerator.Feature.STRICT_DUPLICATE_DETECTION.enabledIn(stdFeatures) ? DupDetector.rootDetector(this) : null;
    this._streamWriteContext = CBORWriteContext.createRootContext(dups);
    this._formatFeatures = formatFeatures;
    this._cfgMinimalInts = Feature.WRITE_MINIMAL_INTS.enabledIn(formatFeatures);
    this._cfgMinimalDoubles = Feature.WRITE_MINIMAL_DOUBLES.enabledIn(formatFeatures);
    this._ioContext = ctxt;
    this._out = out;
    this._bufferRecyclable = true;
    this._stringRefs = Feature.STRINGREF.enabledIn(formatFeatures) ? new HashMap() : null;
    this._outputBuffer = ctxt.allocWriteEncodingBuffer(16000);
    this._outputEnd = this._outputBuffer.length;
    this._charBuffer = ctxt.allocConcatBuffer();
    this._charBufferLength = this._charBuffer.length;
    if (this._outputEnd < 770)
      throw new IllegalStateException("Internal encoding buffer length (" + this._outputEnd + ") too short, must be at least " + '̂'); 
  }
  
  public CBORGenerator(IOContext ctxt, int stdFeatures, int formatFeatures, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int offset, boolean bufferRecyclable) {
    super(stdFeatures, codec, null);
    DupDetector dups = JsonGenerator.Feature.STRICT_DUPLICATE_DETECTION.enabledIn(stdFeatures) ? DupDetector.rootDetector(this) : null;
    this._streamWriteContext = CBORWriteContext.createRootContext(dups);
    this._formatFeatures = formatFeatures;
    this._cfgMinimalInts = Feature.WRITE_MINIMAL_INTS.enabledIn(formatFeatures);
    this._cfgMinimalDoubles = Feature.WRITE_MINIMAL_DOUBLES.enabledIn(formatFeatures);
    this._ioContext = ctxt;
    this._out = out;
    this._bufferRecyclable = bufferRecyclable;
    this._outputTail = offset;
    this._outputBuffer = outputBuffer;
    this._stringRefs = Feature.STRINGREF.enabledIn(formatFeatures) ? new HashMap() : null;
    this._outputEnd = this._outputBuffer.length;
    this._charBuffer = ctxt.allocConcatBuffer();
    this._charBufferLength = this._charBuffer.length;
    if (this._outputEnd < 770)
      throw new IllegalStateException("Internal encoding buffer length (" + this._outputEnd + ") too short, must be at least " + '̂'); 
  }
  
  public Version version() { return PackageVersion.VERSION; }
  
  public boolean canWriteBinaryNatively() { return true; }
  
  public JacksonFeatureSet<StreamWriteCapability> getWriteCapabilities() { return DEFAULT_BINARY_WRITE_CAPABILITIES; }
  
  public JsonGenerator useDefaultPrettyPrinter() { return this; }
  
  public JsonGenerator setPrettyPrinter(PrettyPrinter pp) { return this; }
  
  public Object getOutputTarget() { return this._out; }
  
  public int getOutputBuffered() { return this._outputTail; }
  
  public int getFormatFeatures() { return this._formatFeatures; }
  
  public JsonGenerator overrideStdFeatures(int values, int mask) {
    int oldState = this._features;
    int newState = oldState & (mask ^ 0xFFFFFFFF) | values & mask;
    if (oldState != newState)
      this._features = newState; 
    return this;
  }
  
  public JsonGenerator overrideFormatFeatures(int values, int mask) {
    int oldState = this._formatFeatures;
    int newState = this._formatFeatures & (mask ^ 0xFFFFFFFF) | values & mask;
    if (oldState != newState) {
      this._formatFeatures = newState;
      this._cfgMinimalInts = Feature.WRITE_MINIMAL_INTS.enabledIn(newState);
      this._cfgMinimalDoubles = Feature.WRITE_MINIMAL_DOUBLES.enabledIn(newState);
    } 
    return this;
  }
  
  public Object currentValue() { return this._streamWriteContext.getCurrentValue(); }
  
  public Object getCurrentValue() { return this._streamWriteContext.getCurrentValue(); }
  
  public void assignCurrentValue(Object v) { this._streamWriteContext.setCurrentValue(v); }
  
  public void setCurrentValue(Object v) { this._streamWriteContext.setCurrentValue(v); }
  
  public JsonStreamContext getOutputContext() { return this._streamWriteContext; }
  
  public CBORGenerator enable(Feature f) {
    this._formatFeatures |= f.getMask();
    if (f == Feature.WRITE_MINIMAL_INTS) {
      this._cfgMinimalInts = true;
    } else if (f == Feature.WRITE_MINIMAL_DOUBLES) {
      this._cfgMinimalDoubles = true;
    } 
    return this;
  }
  
  public CBORGenerator disable(Feature f) {
    this._formatFeatures &= (f.getMask() ^ 0xFFFFFFFF);
    if (f == Feature.WRITE_MINIMAL_INTS) {
      this._cfgMinimalInts = false;
    } else if (f == Feature.WRITE_MINIMAL_DOUBLES) {
      this._cfgMinimalDoubles = false;
    } 
    return this;
  }
  
  public final boolean isEnabled(Feature f) { return ((this._formatFeatures & f.getMask()) != 0); }
  
  public CBORGenerator configure(Feature f, boolean state) {
    if (state) {
      enable(f);
    } else {
      disable(f);
    } 
    return this;
  }
  
  public final void writeFieldName(String name) throws IOException {
    if (!this._streamWriteContext.writeFieldName(name))
      _reportError("Can not write a field name, expecting a value"); 
    _writeString(name);
  }
  
  public final void writeFieldName(SerializableString name) throws IOException {
    if (!this._streamWriteContext.writeFieldName(name.getValue()))
      _reportError("Can not write a field name, expecting a value"); 
    byte[] raw = name.asUnquotedUTF8();
    int len = raw.length;
    if (len == 0) {
      _writeByte((byte)96);
      return;
    } 
    if (this._stringRefs != null) {
      String str = name.getValue();
      Integer index = (Integer)this._stringRefs.get(str);
      if (index != null) {
        writeTag(25);
        _writeIntMinimal(0, index.intValue());
        return;
      } 
      if (CBORConstants.shouldReferenceString(this._stringRefs.size(), len))
        this._stringRefs.put(str, Integer.valueOf(this._stringRefs.size())); 
    } 
    _writeLengthMarker(96, len);
    _writeBytes(raw, 0, len);
  }
  
  public final void writeFieldId(long id) throws IOException {
    if (!this._streamWriteContext.writeFieldId(id))
      _reportError("Can not write a field id, expecting a value"); 
    _writeLongNoCheck(id);
  }
  
  public final void writeStartArray() throws IOException {
    _verifyValueWrite("start an array");
    this._streamWriteContext = this._streamWriteContext.createChildArrayContext(null);
    if (this._elementCountsPtr > 0)
      _pushRemainingElements(); 
    this._currentRemainingElements = -2;
    _writeByte((byte)-97);
  }
  
  public void writeStartArray(Object forValue) {
    _verifyValueWrite("start an array");
    this._streamWriteContext = this._streamWriteContext.createChildArrayContext(forValue);
    if (this._elementCountsPtr > 0)
      _pushRemainingElements(); 
    this._currentRemainingElements = -2;
    _writeByte((byte)-97);
  }
  
  public void writeStartArray(Object forValue, int elementsToWrite) throws IOException {
    _verifyValueWrite("start an array");
    this._streamWriteContext = this._streamWriteContext.createChildArrayContext(forValue);
    _pushRemainingElements();
    this._currentRemainingElements = elementsToWrite;
    _writeLengthMarker(128, elementsToWrite);
  }
  
  @Deprecated
  public void writeStartArray(int elementsToWrite) throws IOException {
    _verifyValueWrite("start an array");
    this._streamWriteContext = this._streamWriteContext.createChildArrayContext(null);
    _pushRemainingElements();
    this._currentRemainingElements = elementsToWrite;
    _writeLengthMarker(128, elementsToWrite);
  }
  
  public final void writeEndArray() throws IOException {
    if (!this._streamWriteContext.inArray())
      _reportError("Current context not Array but " + this._streamWriteContext.typeDesc()); 
    closeComplexElement();
    this._streamWriteContext = this._streamWriteContext.getParent();
  }
  
  public final void writeStartObject() throws IOException {
    _verifyValueWrite("start an object");
    this._streamWriteContext = this._streamWriteContext.createChildObjectContext(null);
    if (this._elementCountsPtr > 0)
      _pushRemainingElements(); 
    this._currentRemainingElements = -2;
    _writeByte((byte)-65);
  }
  
  public final void writeStartObject(Object forValue) {
    _verifyValueWrite("start an object");
    CBORWriteContext ctxt = this._streamWriteContext.createChildObjectContext(forValue);
    this._streamWriteContext = ctxt;
    if (this._elementCountsPtr > 0)
      _pushRemainingElements(); 
    this._currentRemainingElements = -2;
    _writeByte((byte)-65);
  }
  
  public final void writeStartObject(int elementsToWrite) throws IOException { writeStartObject(null, elementsToWrite); }
  
  public void writeStartObject(Object forValue, int elementsToWrite) throws IOException {
    _verifyValueWrite("start an object");
    this._streamWriteContext = this._streamWriteContext.createChildObjectContext(forValue);
    _pushRemainingElements();
    this._currentRemainingElements = elementsToWrite;
    _writeLengthMarker(160, elementsToWrite);
  }
  
  public final void writeEndObject() throws IOException {
    if (!this._streamWriteContext.inObject())
      _reportError("Current context not Object but " + this._streamWriteContext.typeDesc()); 
    closeComplexElement();
    this._streamWriteContext = this._streamWriteContext.getParent();
  }
  
  public void writeArray(int[] array, int offset, int length) throws IOException {
    _verifyOffsets(array.length, offset, length);
    _verifyValueWrite("write int array");
    _writeLengthMarker(128, length);
    if (this._cfgMinimalInts) {
      for (int i = offset, end = offset + length; i < end; i++) {
        int value = array[i];
        if (value < 0) {
          _writeIntMinimal(32, -value - 1);
        } else {
          _writeIntMinimal(0, value);
        } 
      } 
    } else {
      for (int i = offset, end = offset + length; i < end; i++) {
        int value = array[i];
        if (value < 0) {
          _writeIntFull(32, -value - 1);
        } else {
          _writeIntFull(0, value);
        } 
      } 
    } 
  }
  
  public void writeArray(long[] array, int offset, int length) throws IOException {
    _verifyOffsets(array.length, offset, length);
    _verifyValueWrite("write int array");
    _writeLengthMarker(128, length);
    for (int i = offset, end = offset + length; i < end; i++)
      _writeLongNoCheck(array[i]); 
  }
  
  public void writeArray(double[] array, int offset, int length) throws IOException {
    _verifyOffsets(array.length, offset, length);
    _verifyValueWrite("write int array");
    _writeLengthMarker(128, length);
    if (this._cfgMinimalDoubles) {
      for (int i = offset, end = offset + length; i < end; i++)
        _writeDoubleMinimal(array[i]); 
    } else {
      for (int i = offset, end = offset + length; i < end; i++)
        _writeDoubleNoCheck(array[i]); 
    } 
  }
  
  private final void _pushRemainingElements() throws IOException {
    if (this._elementCounts.length == this._elementCountsPtr)
      this._elementCounts = Arrays.copyOf(this._elementCounts, this._elementCounts.length + 10); 
    this._elementCounts[this._elementCountsPtr++] = this._currentRemainingElements;
  }
  
  private final void _writeIntMinimal(int markerBase, int i) throws IOException {
    byte b0;
    _ensureRoomForOutput(5);
    if (i >= 0) {
      if (i < 24) {
        this._outputBuffer[this._outputTail++] = (byte)(markerBase + i);
        return;
      } 
      if (i <= 255) {
        this._outputBuffer[this._outputTail++] = (byte)(markerBase + 24);
        this._outputBuffer[this._outputTail++] = (byte)i;
        return;
      } 
      b0 = (byte)i;
      i >>= 8;
      if (i <= 255) {
        this._outputBuffer[this._outputTail++] = (byte)(markerBase + 25);
        this._outputBuffer[this._outputTail++] = (byte)i;
        this._outputBuffer[this._outputTail++] = b0;
        return;
      } 
    } else {
      b0 = (byte)i;
      i >>= 8;
    } 
    this._outputBuffer[this._outputTail++] = (byte)(markerBase + 26);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 16);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 8);
    this._outputBuffer[this._outputTail++] = (byte)i;
    this._outputBuffer[this._outputTail++] = b0;
  }
  
  private final void _writeIntFull(int markerBase, int i) throws IOException {
    _ensureRoomForOutput(5);
    this._outputBuffer[this._outputTail++] = (byte)(markerBase + 26);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 24);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 16);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 8);
    this._outputBuffer[this._outputTail++] = (byte)i;
  }
  
  private final void _writeLongNoCheck(long l) throws IOException {
    if (this._cfgMinimalInts)
      if (l >= 0L) {
        if (l < 4294967296L) {
          _writeIntMinimal(0, (int)l);
          return;
        } 
      } else if (l >= -4294967296L) {
        _writeIntMinimal(32, (int)(-l - 1L));
        return;
      }  
    _ensureRoomForOutput(9);
    if (l < 0L) {
      l++;
      l = -l;
      this._outputBuffer[this._outputTail++] = 59;
    } else {
      this._outputBuffer[this._outputTail++] = 27;
    } 
    int i = (int)(l >> 32);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 24);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 16);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 8);
    this._outputBuffer[this._outputTail++] = (byte)i;
    i = (int)l;
    this._outputBuffer[this._outputTail++] = (byte)(i >> 24);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 16);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 8);
    this._outputBuffer[this._outputTail++] = (byte)i;
  }
  
  private final void _writeFloatNoCheck(float f) throws IOException {
    _ensureRoomForOutput(5);
    int i = Float.floatToRawIntBits(f);
    this._outputBuffer[this._outputTail++] = -6;
    this._outputBuffer[this._outputTail++] = (byte)(i >> 24);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 16);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 8);
    this._outputBuffer[this._outputTail++] = (byte)i;
  }
  
  private final void _writeDoubleNoCheck(double d) throws IOException {
    _ensureRoomForOutput(9);
    long l = Double.doubleToRawLongBits(d);
    this._outputBuffer[this._outputTail++] = -5;
    int i = (int)(l >> 32);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 24);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 16);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 8);
    this._outputBuffer[this._outputTail++] = (byte)i;
    i = (int)l;
    this._outputBuffer[this._outputTail++] = (byte)(i >> 24);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 16);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 8);
    this._outputBuffer[this._outputTail++] = (byte)i;
  }
  
  private final void _writeDoubleMinimal(double d) throws IOException {
    float f = (float)d;
    if (f == d) {
      _writeFloatNoCheck(f);
    } else {
      _writeDoubleNoCheck(d);
    } 
  }
  
  public void writeString(String text) throws IOException {
    if (text == null) {
      writeNull();
      return;
    } 
    _verifyValueWrite("write String value");
    _writeString(text);
  }
  
  public final void writeString(SerializableString sstr) throws IOException {
    _verifyValueWrite("write String value");
    byte[] raw = sstr.asUnquotedUTF8();
    int len = raw.length;
    if (len == 0) {
      _writeByte((byte)96);
      return;
    } 
    if (this._stringRefs != null) {
      String str = sstr.getValue();
      Integer index = (Integer)this._stringRefs.get(str);
      if (index != null) {
        writeTag(25);
        _writeIntMinimal(0, index.intValue());
        return;
      } 
      if (CBORConstants.shouldReferenceString(this._stringRefs.size(), len))
        this._stringRefs.put(str, Integer.valueOf(this._stringRefs.size())); 
    } 
    _writeLengthMarker(96, len);
    _writeBytes(raw, 0, len);
  }
  
  public void writeString(char[] text, int offset, int len) throws IOException {
    _verifyValueWrite("write String value");
    String str = null;
    if (len == 0) {
      _writeByte((byte)96);
      return;
    } 
    if (this._stringRefs != null && len <= 3996) {
      str = new String(text, offset, len);
      Integer index = (Integer)this._stringRefs.get(str);
      if (index != null) {
        writeTag(25);
        _writeIntMinimal(0, index.intValue());
        return;
      } 
    } 
    int actual = _writeString(text, offset, len);
    if (str != null && CBORConstants.shouldReferenceString(this._stringRefs.size(), actual))
      this._stringRefs.put(str, Integer.valueOf(this._stringRefs.size())); 
  }
  
  public void writeRawUTF8String(byte[] raw, int offset, int len) throws IOException {
    _verifyValueWrite("write String value");
    if (len == 0) {
      _writeByte((byte)96);
      return;
    } 
    if (this._stringRefs != null) {
      String str = new String(raw, offset, len, StandardCharsets.UTF_8);
      Integer index = (Integer)this._stringRefs.get(str);
      if (index != null) {
        writeTag(25);
        _writeIntMinimal(0, index.intValue());
        return;
      } 
      if (CBORConstants.shouldReferenceString(this._stringRefs.size(), len))
        this._stringRefs.put(str, Integer.valueOf(this._stringRefs.size())); 
    } 
    _writeLengthMarker(96, len);
    _writeBytes(raw, offset, len);
  }
  
  public final void writeUTF8String(byte[] text, int offset, int len) throws IOException { writeRawUTF8String(text, offset, len); }
  
  public void writeRaw(String text) throws IOException { throw _notSupported(); }
  
  public void writeRaw(String text, int offset, int len) throws IOException { throw _notSupported(); }
  
  public void writeRaw(char[] text, int offset, int len) throws IOException { throw _notSupported(); }
  
  public void writeRaw(char c) throws IOException { throw _notSupported(); }
  
  public void writeRawValue(String text) throws IOException { throw _notSupported(); }
  
  public void writeRawValue(String text, int offset, int len) throws IOException { throw _notSupported(); }
  
  public void writeRawValue(char[] text, int offset, int len) throws IOException { throw _notSupported(); }
  
  public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException {
    if (data == null) {
      writeNull();
      return;
    } 
    _verifyValueWrite("write Binary value");
    ByteBuffer bytesRef = null;
    if (this._stringRefs != null) {
      bytesRef = ByteBuffer.wrap(data, offset, len);
      Integer index = (Integer)this._stringRefs.get(bytesRef);
      if (index != null) {
        writeTag(25);
        _writeIntMinimal(0, index.intValue());
        return;
      } 
    } 
    _writeLengthMarker(64, len);
    _writeBytes(data, offset, len);
    if (bytesRef != null && CBORConstants.shouldReferenceString(this._stringRefs.size(), len))
      this._stringRefs.put(ByteBuffer.wrap(Arrays.copyOfRange(data, offset, len)), 
          Integer.valueOf(this._stringRefs.size())); 
  }
  
  public int writeBinary(InputStream data, int dataLength) throws IOException {
    int missing;
    if (dataLength < 0)
      throw new UnsupportedOperationException("Must pass actual length for CBOR encoded data"); 
    _verifyValueWrite("write Binary value");
    if (this._stringRefs == null) {
      _writeLengthMarker(64, dataLength);
      missing = _writeBytes(data, dataLength);
    } else {
      byte[] bytes = new byte[dataLength];
      missing = dataLength - data.read(bytes);
      if (missing == 0) {
        ByteBuffer bytesRef = ByteBuffer.wrap(bytes);
        Integer index = (Integer)this._stringRefs.get(bytesRef);
        if (index != null) {
          writeTag(25);
          _writeIntMinimal(0, index.intValue());
        } else {
          _writeLengthMarker(64, dataLength);
          _writeBytes(bytes, 0, dataLength);
          if (CBORConstants.shouldReferenceString(this._stringRefs.size(), dataLength))
            this._stringRefs.put(bytesRef, Integer.valueOf(this._stringRefs.size())); 
        } 
      } 
    } 
    if (missing > 0)
      _reportError("Too few bytes available: missing " + missing + " bytes (out of " + dataLength + ")"); 
    return dataLength;
  }
  
  public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException { return writeBinary(data, dataLength); }
  
  public void writeBoolean(boolean state) throws IOException {
    _verifyValueWrite("write boolean value");
    if (state) {
      _writeByte((byte)-11);
    } else {
      _writeByte((byte)-12);
    } 
  }
  
  public void writeNull() throws IOException {
    _verifyValueWrite("write null value");
    _writeByte((byte)-10);
  }
  
  public void writeNumber(int i) throws IOException {
    byte b0;
    int marker;
    _verifyValueWrite("write number");
    if (i < 0) {
      i = -i - 1;
      marker = 32;
    } else {
      marker = 0;
    } 
    _ensureRoomForOutput(5);
    if (this._cfgMinimalInts) {
      if (i < 24) {
        this._outputBuffer[this._outputTail++] = (byte)(marker + i);
        return;
      } 
      if (i <= 255) {
        this._outputBuffer[this._outputTail++] = (byte)(marker + 24);
        this._outputBuffer[this._outputTail++] = (byte)i;
        return;
      } 
      b0 = (byte)i;
      i >>= 8;
      if (i <= 255) {
        this._outputBuffer[this._outputTail++] = (byte)(marker + 25);
        this._outputBuffer[this._outputTail++] = (byte)i;
        this._outputBuffer[this._outputTail++] = b0;
        return;
      } 
    } else {
      b0 = (byte)i;
      i >>= 8;
    } 
    this._outputBuffer[this._outputTail++] = (byte)(marker + 26);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 16);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 8);
    this._outputBuffer[this._outputTail++] = (byte)i;
    this._outputBuffer[this._outputTail++] = b0;
  }
  
  public void writeNumber(long l) throws IOException {
    _verifyValueWrite("write number");
    if (this._cfgMinimalInts)
      if (l >= 0L) {
        if (l < 4294967296L) {
          _writeIntMinimal(0, (int)l);
          return;
        } 
      } else if (l >= -4294967296L) {
        _writeIntMinimal(32, (int)(-l - 1L));
        return;
      }  
    _ensureRoomForOutput(9);
    if (l < 0L) {
      l++;
      l = -l;
      this._outputBuffer[this._outputTail++] = 59;
    } else {
      this._outputBuffer[this._outputTail++] = 27;
    } 
    int i = (int)(l >> 32);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 24);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 16);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 8);
    this._outputBuffer[this._outputTail++] = (byte)i;
    i = (int)l;
    this._outputBuffer[this._outputTail++] = (byte)(i >> 24);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 16);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 8);
    this._outputBuffer[this._outputTail++] = (byte)i;
  }
  
  public void writeNumber(BigInteger v) throws IOException {
    if (v == null) {
      writeNull();
      return;
    } 
    _verifyValueWrite("write number");
    _write(v);
  }
  
  protected void _write(BigInteger v) throws IOException {
    if (v.signum() < 0) {
      _writeByte((byte)-61);
      v = v.negate();
    } else {
      _writeByte((byte)-62);
    } 
    byte[] data = v.toByteArray();
    int len = data.length;
    if (this._stringRefs == null) {
      _writeLengthMarker(64, len);
      _writeBytes(data, 0, len);
    } else {
      ByteBuffer bytesRef = ByteBuffer.wrap(data);
      Integer index = (Integer)this._stringRefs.get(bytesRef);
      if (index != null) {
        writeTag(25);
        _writeIntMinimal(0, index.intValue());
      } else {
        _writeLengthMarker(64, len);
        _writeBytes(data, 0, len);
        if (CBORConstants.shouldReferenceString(this._stringRefs.size(), len))
          this._stringRefs.put(bytesRef, Integer.valueOf(this._stringRefs.size())); 
      } 
    } 
  }
  
  public void writeNumber(double d) throws IOException {
    _verifyValueWrite("write number");
    if (this._cfgMinimalDoubles) {
      _writeDoubleMinimal(d);
    } else {
      _writeDoubleNoCheck(d);
    } 
  }
  
  public void writeNumber(float f) throws IOException {
    _verifyValueWrite("write number");
    _writeFloatNoCheck(f);
  }
  
  public void writeNumber(BigDecimal dec) throws IOException {
    if (dec == null) {
      writeNull();
      return;
    } 
    _verifyValueWrite("write number");
    _writeByte((byte)-60);
    _writeByte((byte)-126);
    int scale = dec.scale();
    _writeIntValue(-scale);
    BigInteger unscaled = dec.unscaledValue();
    int bitLength = unscaled.bitLength();
    if (bitLength <= 31) {
      _writeIntValue(unscaled.intValue());
    } else if (bitLength <= 63) {
      _writeLongValue(unscaled.longValue());
    } else {
      _write(unscaled);
    } 
  }
  
  public void writeNumber(String encodedValue) throws IOException { writeString(encodedValue); }
  
  protected final void _verifyValueWrite(String typeMsg) throws IOException {
    if (!this._streamWriteContext.writeValue())
      _reportError("Can not " + typeMsg + ", expecting field name/id"); 
    int count = this._currentRemainingElements;
    if (count != -2) {
      count--;
      if (count < 0) {
        _failSizedArrayOrObject();
        return;
      } 
      this._currentRemainingElements = count;
    } 
  }
  
  private void _failSizedArrayOrObject() throws IOException {
    _reportError(String.format("%s size mismatch: number of element encoded is not equal to reported array/map size.", new Object[] { this._streamWriteContext
            .typeDesc() }));
  }
  
  public final void flush() throws IOException {
    _flushBuffer();
    if (isEnabled(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM))
      this._out.flush(); 
  }
  
  public void close() throws IOException {
    if (this._outputBuffer != null && 
      isEnabled(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT))
      while (true) {
        JsonStreamContext ctxt = getOutputContext();
        if (ctxt.inArray()) {
          writeEndArray();
          continue;
        } 
        if (ctxt.inObject()) {
          writeEndObject();
          continue;
        } 
        break;
      }  
    super.close();
    _flushBuffer();
    if (this._ioContext.isResourceManaged() || 
      isEnabled(JsonGenerator.Feature.AUTO_CLOSE_TARGET)) {
      this._out.close();
    } else if (isEnabled(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM)) {
      this._out.flush();
    } 
    _releaseBuffers();
  }
  
  public void writeTag(int tagId) throws IOException {
    if (tagId < 0)
      throw new IllegalArgumentException("Can not write negative tag ids (" + tagId + ")"); 
    _writeLengthMarker(192, tagId);
  }
  
  public void writeRaw(byte b) throws IOException { _writeByte(b); }
  
  public void writeBytes(byte[] data, int offset, int len) throws IOException { _writeBytes(data, offset, len); }
  
  protected final void _writeString(String name) throws IOException {
    int len = name.length();
    if (len == 0) {
      _writeByte((byte)96);
      return;
    } 
    if (this._stringRefs != null && len <= 3996) {
      Integer index = (Integer)this._stringRefs.get(name);
      if (index != null) {
        writeTag(25);
        _writeIntMinimal(0, index.intValue());
        return;
      } 
    } 
    if (len <= 23) {
      _ensureSpace(71);
      int actual = _encode(this._outputTail + 1, name, len);
      if (this._stringRefs != null && CBORConstants.shouldReferenceString(this._stringRefs.size(), actual))
        this._stringRefs.put(name, Integer.valueOf(this._stringRefs.size())); 
      byte[] buf = this._outputBuffer;
      int ix = this._outputTail;
      if (actual <= 23) {
        buf[ix++] = (byte)(96 + actual);
        this._outputTail = ix + actual;
        return;
      } 
      System.arraycopy(buf, ix + 1, buf, ix + 2, actual);
      buf[ix++] = 120;
      buf[ix++] = (byte)actual;
      this._outputTail = ix + actual;
      return;
    } 
    char[] cbuf = this._charBuffer;
    if (len > cbuf.length)
      this
        ._charBuffer = cbuf = new char[Math.max(this._charBuffer.length + 32, len)]; 
    name.getChars(0, len, cbuf, 0);
    int actual = _writeString(cbuf, 0, len);
    if (actual >= 0 && this._stringRefs != null && 
      CBORConstants.shouldReferenceString(this._stringRefs.size(), actual))
      this._stringRefs.put(name, Integer.valueOf(this._stringRefs.size())); 
  }
  
  protected final void _ensureSpace(int needed) throws IOException {
    if (this._outputTail + needed + 3 > this._outputEnd)
      _flushBuffer(); 
  }
  
  protected final int _writeString(char[] text, int offset, int len) throws IOException {
    if (len <= 23) {
      _ensureSpace(71);
      int actual = _encode(this._outputTail + 1, text, offset, offset + len);
      byte[] buf = this._outputBuffer;
      int ix = this._outputTail;
      if (actual <= 23) {
        buf[ix++] = (byte)(96 + actual);
        this._outputTail = ix + actual;
        return actual;
      } 
      System.arraycopy(buf, ix + 1, buf, ix + 2, actual);
      buf[ix++] = 120;
      buf[ix++] = (byte)actual;
      this._outputTail = ix + actual;
      return actual;
    } 
    if (len <= 255) {
      _ensureSpace(768);
      int actual = _encode(this._outputTail + 2, text, offset, offset + len);
      byte[] buf = this._outputBuffer;
      int ix = this._outputTail;
      if (actual <= 255) {
        buf[ix++] = 120;
        buf[ix++] = (byte)actual;
        this._outputTail = ix + actual;
        return actual;
      } 
      System.arraycopy(buf, ix + 2, buf, ix + 3, actual);
      buf[ix++] = 121;
      buf[ix++] = (byte)(actual >> 8);
      buf[ix++] = (byte)actual;
      this._outputTail = ix + actual;
      return actual;
    } 
    if (len <= 3996) {
      _ensureSpace(11991);
      int ix = this._outputTail;
      int actual = _encode(ix + 3, text, offset, offset + len);
      byte[] buf = this._outputBuffer;
      buf[ix++] = 121;
      buf[ix++] = (byte)(actual >> 8);
      buf[ix++] = (byte)actual;
      this._outputTail = ix + actual;
      return actual;
    } 
    _writeChunkedString(text, offset, len);
    return -1;
  }
  
  protected final void _writeChunkedString(char[] text, int offset, int len) throws IOException {
    _writeByte(127);
    while (len > 3996) {
      _ensureSpace(11991);
      int ix = this._outputTail;
      int amount = 3996;
      int end = offset + amount;
      char c = text[end - 1];
      if (c >= '?' && c <= '?') {
        end--;
        amount--;
      } 
      int actual = _encode(this._outputTail + 3, text, offset, end);
      byte[] buf = this._outputBuffer;
      buf[ix++] = 121;
      buf[ix++] = (byte)(actual >> 8);
      buf[ix++] = (byte)actual;
      this._outputTail = ix + actual;
      offset += amount;
      len -= amount;
    } 
    if (len > 0)
      _writeString(text, offset, len); 
    _writeByte((byte)-1);
  }
  
  private final int _encode(int outputPtr, char[] str, int i, int end) throws IOException {
    byte[] outBuf = this._outputBuffer;
    int outputStart = outputPtr;
    do {
      int c = str[i];
      if (c > 127)
        return _shortUTF8Encode2(str, i, end, outputPtr, outputStart); 
      outBuf[outputPtr++] = (byte)c;
    } while (++i < end);
    return outputPtr - outputStart;
  }
  
  private final int _shortUTF8Encode2(char[] str, int i, int end, int outputPtr, int outputStart) throws IOException {
    byte[] outBuf = this._outputBuffer;
    while (i < end) {
      int c = str[i++];
      if (c <= 127) {
        outBuf[outputPtr++] = (byte)c;
        continue;
      } 
      if (c < 2048) {
        outBuf[outputPtr++] = (byte)(0xC0 | c >> 6);
        outBuf[outputPtr++] = (byte)(0x80 | c & 0x3F);
        continue;
      } 
      if (c < 55296 || c > 57343) {
        outBuf[outputPtr++] = (byte)(0xE0 | c >> 12);
        outBuf[outputPtr++] = (byte)(0x80 | c >> 6 & 0x3F);
        outBuf[outputPtr++] = (byte)(0x80 | c & 0x3F);
        continue;
      } 
      if (c <= 56319 && i < end) {
        int d = str[i];
        if (d <= 57343 && d >= 56320) {
          i++;
          outputPtr = _decodeAndWriteSurrogate(c, d, outBuf, outputPtr);
          continue;
        } 
        outputPtr = _invalidSurrogateEnd(c, d, outBuf, outputPtr);
        continue;
      } 
      outputPtr = _invalidSurrogateStart(c, outBuf, outputPtr);
    } 
    return outputPtr - outputStart;
  }
  
  private final int _encode(int outputPtr, String str, int len) throws IOException {
    byte[] outBuf = this._outputBuffer;
    int outputStart = outputPtr;
    for (int i = 0; i < len; i++) {
      int c = str.charAt(i);
      if (c > 127)
        return _encode2(i, outputPtr, str, len, outputStart); 
      outBuf[outputPtr++] = (byte)c;
    } 
    return outputPtr - outputStart;
  }
  
  private final int _encode2(int i, int outputPtr, String str, int len, int outputStart) throws IOException {
    byte[] outBuf = this._outputBuffer;
    while (i < len) {
      int c = str.charAt(i++);
      if (c <= 127) {
        outBuf[outputPtr++] = (byte)c;
        continue;
      } 
      if (c < 2048) {
        outBuf[outputPtr++] = (byte)(0xC0 | c >> 6);
        outBuf[outputPtr++] = (byte)(0x80 | c & 0x3F);
        continue;
      } 
      if (c < 55296 || c > 57343) {
        outBuf[outputPtr++] = (byte)(0xE0 | c >> 12);
        outBuf[outputPtr++] = (byte)(0x80 | c >> 6 & 0x3F);
        outBuf[outputPtr++] = (byte)(0x80 | c & 0x3F);
        continue;
      } 
      if (c <= 56319 && i < len) {
        int d = str.charAt(i);
        if (d <= 57343 && d >= 56320) {
          i++;
          outputPtr = _decodeAndWriteSurrogate(c, d, outBuf, outputPtr);
          continue;
        } 
        outputPtr = _invalidSurrogateEnd(c, d, outBuf, outputPtr);
        continue;
      } 
      outputPtr = _invalidSurrogateStart(c, outBuf, outputPtr);
    } 
    return outputPtr - outputStart;
  }
  
  private int _invalidSurrogateStart(int code, byte[] outBuf, int outputPtr) throws IOException {
    if (isEnabled(Feature.LENIENT_UTF_ENCODING))
      return _appendReplacementChar(outBuf, outputPtr); 
    if (code <= 56319)
      _reportError(String.format("Unmatched surrogate pair, starts with valid high surrogate (0x%04X) but ends without low surrogate", new Object[] { Integer.valueOf(code) })); 
    _reportError(String.format("Invalid surrogate pair, starts with invalid high surrogate (0x%04X), not in valid range [0xD800, 0xDBFF]", new Object[] { Integer.valueOf(code) }));
    return 0;
  }
  
  private int _invalidSurrogateEnd(int surr1, int surr2, byte[] outBuf, int outputPtr) throws IOException {
    if (isEnabled(Feature.LENIENT_UTF_ENCODING))
      return _appendReplacementChar(outBuf, outputPtr); 
    _reportError(String.format("Invalid surrogate pair, starts with valid high surrogate (0x%04X) but ends with invalid low surrogate (0x%04X), not in valid range [0xDC00, 0xDFFF]", new Object[] { Integer.valueOf(surr1), Integer.valueOf(surr2) }));
    return 0;
  }
  
  private int _appendReplacementChar(byte[] outBuf, int outputPtr) {
    outBuf[outputPtr++] = -17;
    outBuf[outputPtr++] = -65;
    outBuf[outputPtr++] = -67;
    return outputPtr;
  }
  
  private int _decodeAndWriteSurrogate(int surr1, int surr2, byte[] outBuf, int outputPtr) throws IOException {
    int c = 65536 + (surr1 - 55296 << 10) + surr2 - 56320;
    outBuf[outputPtr++] = (byte)(0xF0 | c >> 18);
    outBuf[outputPtr++] = (byte)(0x80 | c >> 12 & 0x3F);
    outBuf[outputPtr++] = (byte)(0x80 | c >> 6 & 0x3F);
    outBuf[outputPtr++] = (byte)(0x80 | c & 0x3F);
    return outputPtr;
  }
  
  private final void _ensureRoomForOutput(int needed) throws IOException {
    if (this._outputTail + needed >= this._outputEnd)
      _flushBuffer(); 
  }
  
  private final void _writeIntValue(int i) throws IOException {
    int marker;
    if (i < 0) {
      i = -i - 1;
      marker = 32;
    } else {
      marker = 0;
    } 
    _writeLengthMarker(marker, i);
  }
  
  private final void _writeLongValue(long l) throws IOException {
    _ensureRoomForOutput(9);
    if (l < 0L) {
      l++;
      l = -l;
      this._outputBuffer[this._outputTail++] = 59;
    } else {
      this._outputBuffer[this._outputTail++] = 27;
    } 
    int i = (int)(l >> 32);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 24);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 16);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 8);
    this._outputBuffer[this._outputTail++] = (byte)i;
    i = (int)l;
    this._outputBuffer[this._outputTail++] = (byte)(i >> 24);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 16);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 8);
    this._outputBuffer[this._outputTail++] = (byte)i;
  }
  
  private final void _writeLengthMarker(int majorType, int i) throws IOException {
    _ensureRoomForOutput(5);
    if (i < 24) {
      this._outputBuffer[this._outputTail++] = (byte)(majorType + i);
      return;
    } 
    if (i <= 255) {
      this._outputBuffer[this._outputTail++] = (byte)(majorType + 24);
      this._outputBuffer[this._outputTail++] = (byte)i;
      return;
    } 
    byte b0 = (byte)i;
    i >>= 8;
    if (i <= 255) {
      this._outputBuffer[this._outputTail++] = (byte)(majorType + 25);
      this._outputBuffer[this._outputTail++] = (byte)i;
      this._outputBuffer[this._outputTail++] = b0;
      return;
    } 
    this._outputBuffer[this._outputTail++] = (byte)(majorType + 26);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 16);
    this._outputBuffer[this._outputTail++] = (byte)(i >> 8);
    this._outputBuffer[this._outputTail++] = (byte)i;
    this._outputBuffer[this._outputTail++] = b0;
  }
  
  private final void _writeByte(byte b) throws IOException {
    if (this._outputTail >= this._outputEnd)
      _flushBuffer(); 
    this._outputBuffer[this._outputTail++] = b;
  }
  
  private final void _writeBytes(byte[] data, int offset, int len) throws IOException {
    if (len == 0)
      return; 
    if (this._outputTail + len >= this._outputEnd) {
      _writeBytesLong(data, offset, len);
      return;
    } 
    System.arraycopy(data, offset, this._outputBuffer, this._outputTail, len);
    this._outputTail += len;
  }
  
  private final int _writeBytes(InputStream in, int bytesLeft) throws IOException {
    while (bytesLeft > 0) {
      int room = this._outputEnd - this._outputTail;
      if (room <= 0) {
        _flushBuffer();
        room = this._outputEnd - this._outputTail;
      } 
      int count = in.read(this._outputBuffer, this._outputTail, room);
      if (count < 0)
        break; 
      this._outputTail += count;
      bytesLeft -= count;
    } 
    return bytesLeft;
  }
  
  private final void _writeBytesLong(byte[] data, int offset, int len) throws IOException {
    if (this._outputTail >= this._outputEnd)
      _flushBuffer(); 
    int currLen = Math.min(len, this._outputEnd - this._outputTail);
    System.arraycopy(data, offset, this._outputBuffer, this._outputTail, currLen);
    this._outputTail += currLen;
    while (len -= currLen != 0) {
      offset += currLen;
      _flushBuffer();
    } 
  }
  
  protected void _releaseBuffers() throws IOException {
    byte[] buf = this._outputBuffer;
    if (buf != null && this._bufferRecyclable) {
      this._outputBuffer = null;
      this._ioContext.releaseWriteEncodingBuffer(buf);
    } 
    char[] cbuf = this._charBuffer;
    if (cbuf != null) {
      this._charBuffer = null;
      this._ioContext.releaseConcatBuffer(cbuf);
    } 
  }
  
  protected final void _flushBuffer() throws IOException {
    if (this._outputTail > 0) {
      this._bytesWritten += this._outputTail;
      this._out.write(this._outputBuffer, 0, this._outputTail);
      this._outputTail = 0;
    } 
  }
  
  private final void closeComplexElement() throws IOException {
    switch (this._currentRemainingElements) {
      case -2:
        _writeByte((byte)-1);
        break;
      case 0:
        break;
      default:
        _reportError(String.format("%s size mismatch: expected %d more elements", new Object[] { this._streamWriteContext
                .typeDesc(), Integer.valueOf(this._currentRemainingElements) }));
        break;
    } 
    this._currentRemainingElements = (this._elementCountsPtr == 0) ? -2 : this._elementCounts[--this._elementCountsPtr];
  }
  
  protected UnsupportedOperationException _notSupported() { return new UnsupportedOperationException(); }
}
