package com.fasterxml.jackson.dataformat.smile;

import com.fasterxml.jackson.core.Base64Variant;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.core.ObjectCodec;
import com.fasterxml.jackson.core.SerializableString;
import com.fasterxml.jackson.core.io.IOContext;
import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;
import com.fasterxml.jackson.core.util.ByteArrayBuilder;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Writer;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;

public class SmileParser extends SmileParserBase {
  private static final boolean JDK11_OR_LATER;
  
  protected ObjectCodec _objectCodec;
  
  protected InputStream _inputStream;
  
  protected byte[] _inputBuffer;
  
  protected boolean _bufferRecyclable;
  
  protected int _typeAsInt;
  
  static  {
    try {
      String.class.getMethod("strip", new Class[0]);
      recentJdk = true;
    } catch (Exception e) {
      recentJdk = false;
    } 
    JDK11_OR_LATER = recentJdk;
  }
  
  protected boolean _tokenIncomplete = false;
  
  public SmileParser(IOContext ctxt, int parserFeatures, int smileFeatures, ObjectCodec codec, ByteQuadsCanonicalizer sym, InputStream in, byte[] inputBuffer, int start, int end, boolean bufferRecyclable) {
    super(ctxt, parserFeatures, smileFeatures, sym);
    this._objectCodec = codec;
    this._inputStream = in;
    this._inputBuffer = inputBuffer;
    this._inputPtr = start;
    this._inputEnd = end;
    this._bufferRecyclable = bufferRecyclable;
  }
  
  public ObjectCodec getCodec() { return this._objectCodec; }
  
  public void setCodec(ObjectCodec c) { this._objectCodec = c; }
  
  protected boolean handleSignature(boolean consumeFirstByte, boolean throwException) throws IOException {
    if (consumeFirstByte)
      this._inputPtr++; 
    byte b = _nextByteGuaranteed();
    if (b != 41) {
      if (throwException)
        _reportError(String.format("Malformed content: signature not valid, starts with 0x3A but followed by 0x%02X, not 0x29", new Object[] { Integer.valueOf(b & 0xFF) })); 
      return false;
    } 
    b = _nextByteGuaranteed();
    if (b != 10) {
      if (throwException)
        _reportError(String.format("Malformed content: signature not valid, starts with 0x3A, 0x29, but followed by 0x%02X, not 0xA", new Object[] { Integer.valueOf(b & 0xFF) })); 
      return false;
    } 
    int ch = _nextByteGuaranteed();
    int versionBits = ch >> 4 & 0xF;
    if (versionBits != 0)
      _reportError(String.format("Header version number bits (0x%X) indicate unrecognized version; only 0x0 accepted by parser", new Object[] { Integer.valueOf(versionBits) })); 
    if ((ch & true) == 0) {
      this._seenNames = null;
      this._seenNameCount = -1;
    } 
    if ((ch & 0x2) != 0) {
      this._seenStringValues = NO_STRINGS;
      this._seenStringValueCount = 0;
    } 
    this._mayContainRawBinary = ((ch & 0x4) != 0);
    return true;
  }
  
  public int releaseBuffered(OutputStream out) throws IOException {
    int count = this._inputEnd - this._inputPtr;
    if (count < 1)
      return 0; 
    int origPtr = this._inputPtr;
    out.write(this._inputBuffer, origPtr, count);
    return count;
  }
  
  public Object getInputSource() { return this._inputStream; }
  
  private final byte _nextByteGuaranteed() throws IOException {
    int ptr = this._inputPtr;
    if (ptr < this._inputEnd) {
      byte b = this._inputBuffer[ptr];
      this._inputPtr = ptr + 1;
      return b;
    } 
    _loadMoreGuaranteed();
    return this._inputBuffer[this._inputPtr++];
  }
  
  protected final void _loadMoreGuaranteed() throws IOException {
    if (!_loadMore())
      _reportInvalidEOF(); 
  }
  
  protected final boolean _loadMore() throws IOException {
    if (this._inputStream != null) {
      int count = this._inputStream.read(this._inputBuffer, 0, this._inputBuffer.length);
      this._currInputProcessed += this._inputEnd;
      this._inputPtr = 0;
      if (count > 0) {
        this._inputEnd = count;
        return true;
      } 
      this._inputEnd = 0;
      _closeInput();
      if (count == 0)
        throw new IOException("InputStream.read() returned 0 characters when trying to read " + this._inputBuffer.length + " bytes"); 
    } 
    return false;
  }
  
  protected final void _loadToHaveAtLeast(int minAvailable) throws IOException {
    if (this._inputStream == null)
      throw _constructError(String.format("Needed to read %d bytes, reached end-of-input", new Object[] { Integer.valueOf(minAvailable) })); 
    int missing = _tryToLoadToHaveAtLeast(minAvailable);
    if (missing > 0)
      throw _constructError(String.format("Needed to read %d bytes, only got %d before end-of-input", new Object[] { Integer.valueOf(minAvailable), Integer.valueOf(minAvailable - missing) })); 
  }
  
  protected final int _tryToLoadToHaveAtLeast(int minAvailable) throws IOException {
    if (this._inputStream == null)
      return minAvailable; 
    int amount = this._inputEnd - this._inputPtr;
    this._currInputProcessed += this._inputPtr;
    if (amount > 0 && this._inputPtr > 0) {
      System.arraycopy(this._inputBuffer, this._inputPtr, this._inputBuffer, 0, amount);
      this._inputEnd = amount;
    } else {
      this._inputEnd = 0;
    } 
    this._inputPtr = 0;
    while (this._inputEnd < minAvailable) {
      int toRead = this._inputBuffer.length - this._inputEnd;
      int count = this._inputStream.read(this._inputBuffer, this._inputEnd, toRead);
      if (count < 1) {
        _closeInput();
        if (count == 0)
          throw new IOException("InputStream.read() returned 0 characters when trying to read " + amount + " bytes"); 
        return minAvailable - this._inputEnd;
      } 
      this._inputEnd += count;
    } 
    return 0;
  }
  
  protected void _closeInput() throws IOException {
    if (this._inputStream != null) {
      if (this._ioContext.isResourceManaged() || isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE))
        this._inputStream.close(); 
      this._inputStream = null;
    } 
  }
  
  public boolean hasTextCharacters() throws IOException {
    if (this._currToken == JsonToken.VALUE_STRING)
      return this._textBuffer.hasTextAsCharacters(); 
    if (this._currToken == JsonToken.FIELD_NAME)
      return this._nameCopied; 
    return false;
  }
  
  protected void _releaseBuffers2() throws IOException {
    if (this._bufferRecyclable) {
      byte[] buf = this._inputBuffer;
      if (buf != null) {
        this._inputBuffer = null;
        this._ioContext.releaseReadIOBuffer(buf);
      } 
    } 
  }
  
  public JsonToken nextToken() throws IOException {
    int typeBits;
    this._numTypesValid = 0;
    if (this._tokenIncomplete)
      _skipIncomplete(); 
    this._tokenOffsetForTotal = this._inputPtr;
    this._binaryValue = null;
    if (this._currToken != JsonToken.FIELD_NAME && this._streamReadContext.inObject())
      return this._currToken = _handleFieldName(); 
    if (this._inputPtr >= this._inputEnd && 
      !_loadMore())
      return _eofAsNextToken(); 
    int ch = this._inputBuffer[this._inputPtr++] & 0xFF;
    this._typeAsInt = ch;
    switch (ch >> 5) {
      case 0:
        if (ch != 0)
          return _handleSharedString(ch - 1); 
        break;
      case 1:
        typeBits = ch & 0x1F;
        if (typeBits < 4) {
          switch (typeBits) {
            case 0:
              this._textBuffer.resetWithEmpty();
              return this._currToken = JsonToken.VALUE_STRING;
            case 1:
              return this._currToken = JsonToken.VALUE_NULL;
            case 2:
              return this._currToken = JsonToken.VALUE_FALSE;
          } 
          return this._currToken = JsonToken.VALUE_TRUE;
        } 
        if (typeBits == 4) {
          _finishInt();
          return this._currToken = JsonToken.VALUE_NUMBER_INT;
        } 
        if (typeBits <= 6) {
          this._tokenIncomplete = true;
          return this._currToken = JsonToken.VALUE_NUMBER_INT;
        } 
        if (typeBits < 11 && typeBits != 7) {
          this._tokenIncomplete = true;
          return this._currToken = JsonToken.VALUE_NUMBER_FLOAT;
        } 
        if (typeBits == 26) {
          if (handleSignature(false, false)) {
            if (this._currToken == null)
              return _nextAfterHeader(); 
            return this._currToken = null;
          } 
          _reportError("Unrecognized token byte 0x3A (malformed segment header?");
        } 
        break;
      case 2:
      case 3:
      case 4:
      case 5:
        if (this._seenStringValueCount >= 0)
          return _addSeenStringValue(); 
        this._tokenIncomplete = true;
        return this._currToken = JsonToken.VALUE_STRING;
      case 6:
        this._numberInt = SmileUtil.zigzagDecode(ch & 0x1F);
        this._numTypesValid = 1;
        this._numberType = JsonParser.NumberType.INT;
        return this._currToken = JsonToken.VALUE_NUMBER_INT;
      case 7:
        switch (ch & 0x1F) {
          case 0:
          case 4:
            this._tokenIncomplete = true;
            return this._currToken = JsonToken.VALUE_STRING;
          case 8:
            this._tokenIncomplete = true;
            return this._currToken = JsonToken.VALUE_EMBEDDED_OBJECT;
          case 12:
          case 13:
          case 14:
          case 15:
            if (this._inputPtr >= this._inputEnd)
              _loadMoreGuaranteed(); 
            return _handleSharedString(((ch & 0x3) << 8) + (this._inputBuffer[this._inputPtr++] & 0xFF));
          case 24:
            createChildArrayContext(-1, -1);
            return this._currToken = JsonToken.START_ARRAY;
          case 25:
            if (!this._streamReadContext.inArray())
              _reportMismatchedEndMarker(93, '}'); 
            this._streamReadContext = this._streamReadContext.getParent();
            return this._currToken = JsonToken.END_ARRAY;
          case 26:
            createChildObjectContext(-1, -1);
            return this._currToken = JsonToken.START_OBJECT;
          case 27:
            _reportError("Invalid type marker byte 0xFB in value mode (would be END_OBJECT in key mode)");
          case 29:
            this._tokenIncomplete = true;
            return this._currToken = JsonToken.VALUE_EMBEDDED_OBJECT;
          case 31:
            return this._currToken = null;
        } 
        break;
    } 
    return _reportUnknownValueTypeToken(ch);
  }
  
  private JsonToken _reportUnknownValueTypeToken(int ch) throws IOException { throw _constructReadException("Invalid type marker byte 0x%s for expected value token", 
        Integer.toHexString(ch & 0xFF)); }
  
  private JsonToken _nextAfterHeader() throws IOException {
    if ((this._inputPtr < this._inputEnd || _loadMore()) && 
      this._inputBuffer[this._inputPtr] == 58)
      return this._currToken = null; 
    return nextToken();
  }
  
  private final JsonToken _handleSharedString(int index) throws IOException {
    if (index >= this._seenStringValueCount)
      _reportInvalidSharedStringValue(index); 
    this._textBuffer.resetWithString(this._seenStringValues[index]);
    return this._currToken = JsonToken.VALUE_STRING;
  }
  
  private final JsonToken _addSeenStringValue() throws IOException {
    _finishToken();
    String v = this._textBuffer.contentsAsString();
    if (this._seenStringValueCount < this._seenStringValues.length) {
      this._seenStringValues[this._seenStringValueCount++] = v;
    } else {
      _expandSeenStringValues(v);
    } 
    return this._currToken = JsonToken.VALUE_STRING;
  }
  
  private final void _expandSeenStringValues(String newText) {
    String[] newShared, oldShared = this._seenStringValues;
    int len = oldShared.length;
    if (len == 0) {
      newShared = (String[])this._smileBufferRecycler.allocSeenStringValuesBuffer();
      if (newShared == null)
        newShared = new String[64]; 
    } else if (len == 1024) {
      newShared = oldShared;
      this._seenStringValueCount = 0;
    } else {
      int newSize = (len == 64) ? 256 : 1024;
      newShared = (String[])Arrays.copyOf(oldShared, newSize);
    } 
    this._seenStringValues = newShared;
    this._seenStringValues[this._seenStringValueCount++] = newText;
  }
  
  public void finishToken() throws IOException {
    if (this._tokenIncomplete)
      _finishToken(); 
  }
  
  public boolean nextFieldName(SerializableString str) throws IOException {
    if (this._currToken != JsonToken.FIELD_NAME && this._streamReadContext.inObject()) {
      this._numTypesValid = 0;
      if (this._tokenIncomplete)
        _skipIncomplete(); 
      this._tokenOffsetForTotal = this._inputPtr;
      this._binaryValue = null;
      byte[] nameBytes = str.asQuotedUTF8();
      int byteLen = nameBytes.length;
      if (this._inputPtr + byteLen + 1 < this._inputEnd) {
        String name, name;
        int len, index, index, len, ptr = this._inputPtr;
        int ch = this._inputBuffer[ptr++] & 0xFF;
        this._typeAsInt = ch;
        switch (ch >> 6) {
          case 0:
            switch (ch) {
              case 32:
                this._currToken = JsonToken.FIELD_NAME;
                this._inputPtr = ptr;
                this._streamReadContext.setCurrentName("");
                return (byteLen == 0);
              case 48:
              case 49:
              case 50:
              case 51:
                index = ((ch & 0x3) << 8) + (this._inputBuffer[ptr++] & 0xFF);
                if (index >= this._seenNameCount)
                  _reportInvalidSharedName(index); 
                name = this._seenNames[index];
                this._streamReadContext.setCurrentName(name);
                this._inputPtr = ptr;
                this._currToken = JsonToken.FIELD_NAME;
                return name.equals(str.getValue());
            } 
            break;
          case 1:
            index = ch & 0x3F;
            if (index >= this._seenNameCount)
              _reportInvalidSharedName(index); 
            name = this._seenNames[index];
            this._streamReadContext.setCurrentName(name);
            this._inputPtr = ptr;
            this._currToken = JsonToken.FIELD_NAME;
            return name.equals(str.getValue());
          case 2:
            len = 1 + (ch & 0x3F);
            if (len == byteLen) {
              int i = 0;
              for (; i < len; i++) {
                if (nameBytes[i] != this._inputBuffer[ptr + i])
                  // Byte code: goto -> 684 
              } 
              this._inputPtr = ptr + len;
              String name = str.getValue();
              if (this._seenNames != null) {
                if (this._seenNameCount >= this._seenNames.length)
                  this._seenNames = _expandSeenNames(this._seenNames); 
                this._seenNames[this._seenNameCount++] = name;
              } 
              this._streamReadContext.setCurrentName(name);
              this._currToken = JsonToken.FIELD_NAME;
              return true;
            } 
            break;
          case 3:
            len = ch & 0x3F;
            if (len > 55) {
              if (len == 59) {
                this._currToken = JsonToken.END_OBJECT;
                this._inputPtr = ptr;
                this._streamReadContext = this._streamReadContext.getParent();
                return false;
              } 
              break;
            } 
            len += 2;
            if (len == byteLen) {
              int i = 0;
              for (; i < len; i++) {
                if (nameBytes[i] != this._inputBuffer[ptr + i])
                  // Byte code: goto -> 684 
              } 
              this._inputPtr = ptr + len;
              String name = str.getValue();
              if (this._seenNames != null) {
                if (this._seenNameCount >= this._seenNames.length)
                  this._seenNames = _expandSeenNames(this._seenNames); 
                this._seenNames[this._seenNameCount++] = name;
              } 
              this._streamReadContext.setCurrentName(name);
              this._currToken = JsonToken.FIELD_NAME;
              return true;
            } 
            break;
        } 
      } 
    } 
    return (nextToken() == JsonToken.FIELD_NAME && str.getValue().equals(currentName()));
  }
  
  public String nextFieldName() throws IOException {
    if (this._currToken != JsonToken.FIELD_NAME && this._streamReadContext.inObject()) {
      String name, name, name, name;
      int index, index, len, len;
      this._numTypesValid = 0;
      if (this._tokenIncomplete)
        _skipIncomplete(); 
      this._tokenOffsetForTotal = this._inputPtr;
      this._binaryValue = null;
      if (this._inputPtr >= this._inputEnd)
        _loadMoreGuaranteed(); 
      int ch = this._inputBuffer[this._inputPtr++] & 0xFF;
      this._typeAsInt = ch;
      switch (ch >> 6) {
        case 0:
          switch (ch) {
            case 32:
              this._streamReadContext.setCurrentName("");
              this._currToken = JsonToken.FIELD_NAME;
              return "";
            case 48:
            case 49:
            case 50:
            case 51:
              if (this._inputPtr >= this._inputEnd)
                _loadMoreGuaranteed(); 
              index = ((ch & 0x3) << 8) + (this._inputBuffer[this._inputPtr++] & 0xFF);
              if (index >= this._seenNameCount)
                _reportInvalidSharedName(index); 
              name = this._seenNames[index];
              this._streamReadContext.setCurrentName(name);
              this._currToken = JsonToken.FIELD_NAME;
              return name;
            case 52:
              this._currToken = JsonToken.FIELD_NAME;
              return _handleLongFieldName();
          } 
          break;
        case 1:
          index = ch & 0x3F;
          if (index >= this._seenNameCount)
            _reportInvalidSharedName(index); 
          name = this._seenNames[index];
          this._streamReadContext.setCurrentName(name);
          this._currToken = JsonToken.FIELD_NAME;
          return name;
        case 2:
          len = 1 + (ch & 0x3F);
          name = _findOrDecodeShortAsciiName(len);
          if (this._seenNames != null) {
            if (this._seenNameCount >= this._seenNames.length)
              this._seenNames = _expandSeenNames(this._seenNames); 
            this._seenNames[this._seenNameCount++] = name;
          } 
          this._streamReadContext.setCurrentName(name);
          this._currToken = JsonToken.FIELD_NAME;
          return name;
        case 3:
          ch &= 0x3F;
          if (ch > 55) {
            if (ch == 59) {
              this._streamReadContext = this._streamReadContext.getParent();
              this._currToken = JsonToken.END_OBJECT;
              return null;
            } 
            break;
          } 
          len = ch + 2;
          name = _findOrDecodeShortUnicodeName(len);
          if (this._seenNames != null) {
            if (this._seenNameCount >= this._seenNames.length)
              this._seenNames = _expandSeenNames(this._seenNames); 
            this._seenNames[this._seenNameCount++] = name;
          } 
          this._streamReadContext.setCurrentName(name);
          this._currToken = JsonToken.FIELD_NAME;
          return name;
      } 
      return _reportUnknownNameToken(this._typeAsInt);
    } 
    return (nextToken() == JsonToken.FIELD_NAME) ? currentName() : null;
  }
  
  private String _reportUnknownNameToken(int ch) throws IOException { throw _constructReadException("Invalid type marker byte 0x%s for expected field name (or END_OBJECT marker)", 
        Integer.toHexString(ch & 0xFF)); }
  
  public String nextTextValue() throws IOException {
    if (!this._streamReadContext.inObject() || this._currToken == JsonToken.FIELD_NAME) {
      String text;
      int typeBits;
      String text;
      if (this._tokenIncomplete)
        _skipIncomplete(); 
      int ptr = this._inputPtr;
      if (ptr >= this._inputEnd) {
        if (!_loadMore()) {
          _eofAsNextToken();
          return null;
        } 
        ptr = this._inputPtr;
      } 
      this._tokenOffsetForTotal = ptr;
      int ch = this._inputBuffer[ptr++] & 0xFF;
      this._typeAsInt = ch;
      this._binaryValue = null;
      switch (ch >> 5) {
        case 0:
          if (ch != 0) {
            ch--;
            if (ch >= this._seenStringValueCount)
              _reportInvalidSharedStringValue(ch); 
            this._inputPtr = ptr;
            String text = this._seenStringValues[ch];
            this._textBuffer.resetWithString(text);
            this._currToken = JsonToken.VALUE_STRING;
            return text;
          } 
          _reportError("Invalid token byte 0x00");
        case 1:
          typeBits = ch & 0x1F;
          if (typeBits == 0) {
            this._inputPtr = ptr;
            this._textBuffer.resetWithEmpty();
            this._currToken = JsonToken.VALUE_STRING;
            return "";
          } 
          break;
        case 2:
        case 3:
          this._currToken = JsonToken.VALUE_STRING;
          this._inputPtr = ptr;
          text = _decodeShortAsciiValue(1 + (ch & 0x3F));
          if (this._seenStringValueCount >= 0)
            if (this._seenStringValueCount < this._seenStringValues.length) {
              this._seenStringValues[this._seenStringValueCount++] = text;
            } else {
              _expandSeenStringValues(text);
            }  
          return text;
        case 4:
        case 5:
          this._currToken = JsonToken.VALUE_STRING;
          this._inputPtr = ptr;
          text = _decodeShortUnicodeValue(2 + (ch & 0x3F));
          if (this._seenStringValueCount >= 0)
            if (this._seenStringValueCount < this._seenStringValues.length) {
              this._seenStringValues[this._seenStringValueCount++] = text;
            } else {
              _expandSeenStringValues(text);
            }  
          return text;
      } 
    } 
    return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
  }
  
  public int nextIntValue(int defaultValue) throws IOException {
    if (nextToken() == JsonToken.VALUE_NUMBER_INT)
      return getIntValue(); 
    return defaultValue;
  }
  
  public long nextLongValue(long defaultValue) throws IOException {
    if (nextToken() == JsonToken.VALUE_NUMBER_INT)
      return getLongValue(); 
    return defaultValue;
  }
  
  public Boolean nextBooleanValue() throws IOException {
    JsonToken t = nextToken();
    if (t == JsonToken.VALUE_TRUE)
      return Boolean.TRUE; 
    if (t == JsonToken.VALUE_FALSE)
      return Boolean.FALSE; 
    return null;
  }
  
  public String getText() throws IOException {
    if (this._tokenIncomplete) {
      this._tokenIncomplete = false;
      int tb = this._typeAsInt;
      int type = tb >> 5;
      if (type == 2 || type == 3)
        return _decodeShortAsciiValue(1 + (tb & 0x3F)); 
      if (type == 4 || type == 5)
        return _decodeShortUnicodeValue(2 + (tb & 0x3F)); 
      _finishToken();
    } 
    if (this._currToken == JsonToken.VALUE_STRING)
      return this._textBuffer.contentsAsString(); 
    JsonToken t = this._currToken;
    if (t == null)
      return null; 
    if (t == JsonToken.FIELD_NAME)
      return this._streamReadContext.getCurrentName(); 
    if (t.isNumeric())
      return getNumberValue().toString(); 
    return this._currToken.asString();
  }
  
  public char[] getTextCharacters() throws IOException {
    if (this._currToken != null) {
      if (this._tokenIncomplete)
        _finishToken(); 
      if (this._currToken == JsonToken.VALUE_STRING)
        return this._textBuffer.getTextBuffer(); 
      if (this._currToken == JsonToken.FIELD_NAME) {
        if (!this._nameCopied) {
          String name = this._streamReadContext.getCurrentName();
          int nameLen = name.length();
          if (this._nameCopyBuffer == null) {
            this._nameCopyBuffer = this._ioContext.allocNameCopyBuffer(nameLen);
          } else if (this._nameCopyBuffer.length < nameLen) {
            this._nameCopyBuffer = new char[nameLen];
          } 
          name.getChars(0, nameLen, this._nameCopyBuffer, 0);
          this._nameCopied = true;
        } 
        return this._nameCopyBuffer;
      } 
      if (this._currToken.isNumeric())
        return getNumberValue().toString().toCharArray(); 
      return this._currToken.asCharArray();
    } 
    return null;
  }
  
  public int getTextLength() throws IOException {
    if (this._currToken != null) {
      if (this._tokenIncomplete)
        _finishToken(); 
      if (this._currToken == JsonToken.VALUE_STRING)
        return this._textBuffer.size(); 
      if (this._currToken == JsonToken.FIELD_NAME)
        return this._streamReadContext.getCurrentName().length(); 
      if (this._currToken == JsonToken.VALUE_NUMBER_INT || this._currToken == JsonToken.VALUE_NUMBER_FLOAT)
        return getNumberValue().toString().length(); 
      return this._currToken.asCharArray().length;
    } 
    return 0;
  }
  
  public int getTextOffset() throws IOException { return 0; }
  
  public String getValueAsString() throws IOException {
    if (this._tokenIncomplete) {
      this._tokenIncomplete = false;
      int tb = this._typeAsInt;
      int type = tb >> 5;
      if (type == 2 || type == 3)
        return _decodeShortAsciiValue(1 + (tb & 0x3F)); 
      if (type == 4 || type == 5)
        return _decodeShortUnicodeValue(2 + (tb & 0x3F)); 
      _finishToken();
    } 
    if (this._currToken == JsonToken.VALUE_STRING)
      return this._textBuffer.contentsAsString(); 
    if (this._currToken == null || this._currToken == JsonToken.VALUE_NULL || !this._currToken.isScalarValue())
      return null; 
    return getText();
  }
  
  public String getValueAsString(String defaultValue) throws IOException {
    if (this._currToken != JsonToken.VALUE_STRING && (
      this._currToken == null || this._currToken == JsonToken.VALUE_NULL || !this._currToken.isScalarValue()))
      return defaultValue; 
    return getText();
  }
  
  public int getText(Writer writer) throws IOException {
    if (this._tokenIncomplete)
      _finishToken(); 
    JsonToken t = this._currToken;
    if (t == JsonToken.VALUE_STRING)
      return this._textBuffer.contentsToWriter(writer); 
    if (t == JsonToken.FIELD_NAME) {
      String n = this._streamReadContext.getCurrentName();
      writer.write(n);
      return n.length();
    } 
    if (t != null) {
      if (t.isNumeric())
        return this._textBuffer.contentsToWriter(writer); 
      char[] ch = t.asCharArray();
      writer.write(ch);
      return ch.length;
    } 
    return 0;
  }
  
  public byte[] getBinaryValue(Base64Variant b64variant) throws IOException {
    if (this._currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {
      if (this._tokenIncomplete)
        _finishToken(); 
    } else {
      if (this._currToken == JsonToken.VALUE_STRING)
        return _getBinaryFromString(b64variant); 
      throw _constructReadException("Current token (%s) not VALUE_EMBEDDED_OBJECT or VALUE_STRING, can not access as binary", 
          
          currentToken());
    } 
    return this._binaryValue;
  }
  
  public Object getEmbeddedObject() {
    if (this._tokenIncomplete)
      _finishToken(); 
    if (this._currToken == JsonToken.VALUE_EMBEDDED_OBJECT)
      return this._binaryValue; 
    return null;
  }
  
  public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException {
    if (this._currToken != JsonToken.VALUE_EMBEDDED_OBJECT) {
      if (this._currToken == JsonToken.VALUE_STRING) {
        byte[] b = _getBinaryFromString(b64variant);
        int len = b.length;
        out.write(b, 0, len);
        return len;
      } 
      throw _constructReadException("Current token (%s) not VALUE_EMBEDDED_OBJECT or VALUE_STRING, can not access as binary", 
          
          currentToken());
    } 
    if (!this._tokenIncomplete) {
      if (this._binaryValue == null)
        return 0; 
      int len = this._binaryValue.length;
      out.write(this._binaryValue, 0, len);
      return len;
    } 
    if (this._typeAsInt == 253) {
      int totalCount = _readUnsignedVInt();
      int left = totalCount;
      while (left > 0) {
        int avail = this._inputEnd - this._inputPtr;
        if (this._inputPtr >= this._inputEnd) {
          _loadMoreGuaranteed();
          avail = this._inputEnd - this._inputPtr;
        } 
        int count = Math.min(avail, left);
        out.write(this._inputBuffer, this._inputPtr, count);
        this._inputPtr += count;
        left -= count;
      } 
      this._tokenIncomplete = false;
      return totalCount;
    } 
    if (this._typeAsInt != 232)
      _throwInternal(); 
    int totalCount = _readUnsignedVInt();
    encodingBuffer = this._ioContext.allocBase64Buffer();
    try {
      _readBinaryEncoded(out, totalCount, encodingBuffer);
    } finally {
      this._ioContext.releaseBase64Buffer(encodingBuffer);
    } 
    this._tokenIncomplete = false;
    return totalCount;
  }
  
  private void _readBinaryEncoded(OutputStream out, int length, byte[] buffer) throws IOException {
    int outPtr = 0;
    int lastSafeOut = buffer.length - 7;
    while (length > 7) {
      if (this._inputEnd - this._inputPtr < 8)
        _loadToHaveAtLeast(8); 
      int i1 = (this._inputBuffer[this._inputPtr++] << 25) + (this._inputBuffer[this._inputPtr++] << 18) + (this._inputBuffer[this._inputPtr++] << 11) + (this._inputBuffer[this._inputPtr++] << 4);
      int x = this._inputBuffer[this._inputPtr++];
      i1 += (x >> 3);
      int i2 = ((x & 0x7) << 21) + (this._inputBuffer[this._inputPtr++] << 14) + (this._inputBuffer[this._inputPtr++] << 7) + this._inputBuffer[this._inputPtr++];
      buffer[outPtr++] = (byte)(i1 >> 24);
      buffer[outPtr++] = (byte)(i1 >> 16);
      buffer[outPtr++] = (byte)(i1 >> 8);
      buffer[outPtr++] = (byte)i1;
      buffer[outPtr++] = (byte)(i2 >> 16);
      buffer[outPtr++] = (byte)(i2 >> 8);
      buffer[outPtr++] = (byte)i2;
      length -= 7;
      if (outPtr > lastSafeOut) {
        out.write(buffer, 0, outPtr);
        outPtr = 0;
      } 
    } 
    if (length > 0) {
      if (this._inputEnd - this._inputPtr < length + 1)
        _loadToHaveAtLeast(length + 1); 
      int value = this._inputBuffer[this._inputPtr++];
      for (int i = 1; i < length; i++) {
        value = (value << 7) + this._inputBuffer[this._inputPtr++];
        buffer[outPtr++] = (byte)(value >> 7 - i);
      } 
      value <<= length;
      buffer[outPtr++] = (byte)(value + this._inputBuffer[this._inputPtr++]);
    } 
    if (outPtr > 0)
      out.write(buffer, 0, outPtr); 
  }
  
  private final byte[] _getBinaryFromString(Base64Variant variant) throws IOException {
    if (this._tokenIncomplete)
      _finishToken(); 
    if (this._binaryValue == null) {
      ByteArrayBuilder builder = new ByteArrayBuilder();
      _decodeBase64(getText(), builder, variant);
      this._binaryValue = builder.toByteArray();
    } 
    return this._binaryValue;
  }
  
  protected final JsonToken _handleFieldName() throws IOException {
    String name, name;
    int len, len, index, index;
    if (this._inputPtr >= this._inputEnd)
      _loadMoreGuaranteed(); 
    int ch = this._inputBuffer[this._inputPtr++] & 0xFF;
    this._typeAsInt = ch;
    switch (ch >> 6) {
      case 0:
        switch (ch) {
          case 32:
            this._streamReadContext.setCurrentName("");
            return JsonToken.FIELD_NAME;
          case 48:
          case 49:
          case 50:
          case 51:
            if (this._inputPtr >= this._inputEnd)
              _loadMoreGuaranteed(); 
            index = ((ch & 0x3) << 8) + (this._inputBuffer[this._inputPtr++] & 0xFF);
            if (index >= this._seenNameCount)
              _reportInvalidSharedName(index); 
            this._streamReadContext.setCurrentName(this._seenNames[index]);
            return JsonToken.FIELD_NAME;
          case 52:
            _handleLongFieldName();
            return JsonToken.FIELD_NAME;
        } 
        break;
      case 1:
        index = ch & 0x3F;
        if (index >= this._seenNameCount)
          _reportInvalidSharedName(index); 
        this._streamReadContext.setCurrentName(this._seenNames[index]);
        return JsonToken.FIELD_NAME;
      case 2:
        len = 1 + (ch & 0x3F);
        name = _findOrDecodeShortAsciiName(len);
        if (this._seenNames != null) {
          if (this._seenNameCount >= this._seenNames.length)
            this._seenNames = _expandSeenNames(this._seenNames); 
          this._seenNames[this._seenNameCount++] = name;
        } 
        this._streamReadContext.setCurrentName(name);
        return JsonToken.FIELD_NAME;
      case 3:
        ch &= 0x3F;
        if (ch > 55) {
          if (ch == 59) {
            if (!this._streamReadContext.inObject())
              _reportMismatchedEndMarker(125, ']'); 
            this._streamReadContext = this._streamReadContext.getParent();
            return JsonToken.END_OBJECT;
          } 
          break;
        } 
        len = ch + 2;
        name = _findOrDecodeShortUnicodeName(len);
        if (this._seenNames != null) {
          if (this._seenNameCount >= this._seenNames.length)
            this._seenNames = _expandSeenNames(this._seenNames); 
          this._seenNames[this._seenNameCount++] = name;
        } 
        this._streamReadContext.setCurrentName(name);
        return JsonToken.FIELD_NAME;
    } 
    throw _constructReadException("Invalid type marker byte 0x%s for expected field name (or END_OBJECT marker)", 
        Integer.toHexString(this._typeAsInt));
  }
  
  private String _findOrDecodeShortAsciiName(int len) throws IOException {
    if (this._inputEnd - this._inputPtr < len)
      _loadToHaveAtLeast(len); 
    if (this._symbolsCanonical) {
      String name = _findDecodedFromSymbols(len);
      if (name != null) {
        this._inputPtr += len;
      } else {
        name = _decodeShortAsciiName(len);
        name = _addDecodedToSymbols(len, name);
      } 
      return name;
    } 
    return _decodeShortAsciiName(len);
  }
  
  private String _findOrDecodeShortUnicodeName(int len) throws IOException {
    if (this._inputEnd - this._inputPtr < len)
      _loadToHaveAtLeast(len); 
    if (this._symbolsCanonical) {
      String name = _findDecodedFromSymbols(len);
      if (name != null) {
        this._inputPtr += len;
      } else {
        name = _decodeShortUnicodeName(len);
        name = _addDecodedToSymbols(len, name);
      } 
      return name;
    } 
    return _decodeShortUnicodeName(len);
  }
  
  private final String[] _expandSeenNames(String[] oldShared) {
    String[] newShared;
    int len = oldShared.length;
    if (len == 0) {
      newShared = (String[])this._smileBufferRecycler.allocSeenNamesBuffer();
      if (newShared == null)
        newShared = new String[64]; 
    } else if (len == 1024) {
      newShared = oldShared;
      this._seenNameCount = 0;
    } else {
      int newSize = (len == 64) ? 256 : 1024;
      newShared = (String[])Arrays.copyOf(oldShared, newSize);
    } 
    return newShared;
  }
  
  private final String _addDecodedToSymbols(int len, String name) throws IOException {
    if (len < 5)
      return this._symbols.addName(name, this._quad1); 
    if (len < 9)
      return this._symbols.addName(name, this._quad1, this._quad2); 
    if (len < 13)
      return this._symbols.addName(name, this._quad1, this._quad2, this._quad3); 
    int qlen = len + 3 >> 2;
    return this._symbols.addName(name, this._quadBuffer, qlen);
  }
  
  private final String _decodeShortAsciiName(int len) throws IOException {
    if (JDK11_OR_LATER) {
      int inPtr = this._inputPtr;
      this._inputPtr = inPtr + len;
      String str = new String(this._inputBuffer, inPtr, len, StandardCharsets.US_ASCII);
      this._textBuffer.resetWithString(str);
      return str;
    } 
    char[] outBuf = this._textBuffer.emptyAndGetCurrentSegment();
    int outPtr = 0;
    byte[] inBuf = this._inputBuffer;
    int inPtr = this._inputPtr;
    for (int inEnd = inPtr + len; inPtr < inEnd; inPtr++)
      outBuf[outPtr++] = (char)inBuf[inPtr]; 
    this._inputPtr = inPtr;
    return this._textBuffer.setCurrentAndReturn(len);
  }
  
  private final String _decodeShortUnicodeName(int len) throws IOException {
    int outPtr = 0;
    char[] outBuf = this._textBuffer.emptyAndGetCurrentSegment();
    int inPtr = this._inputPtr;
    int[] codes = SmileConstants.sUtf8UnitLengths;
    byte[] inBuf = this._inputBuffer;
    for (int end = inPtr + len; inPtr < end; ) {
      int i = inBuf[inPtr++] & 0xFF;
      int code = codes[i];
      if (code != 0) {
        if (inPtr + code > end) {
          int firstCharOffset = len - end - inPtr - 1;
          _reportTruncatedUTF8InName(len, firstCharOffset, i, code);
        } 
        switch (code) {
          case 1:
            i = (i & 0x1F) << 6 | inBuf[inPtr++] & 0x3F;
            break;
          case 2:
            i = (i & 0xF) << 12 | (inBuf[inPtr++] & 0x3F) << 6 | inBuf[inPtr++] & 0x3F;
            break;
          case 3:
            i = (i & 0x7) << 18 | (inBuf[inPtr++] & 0x3F) << 12 | (inBuf[inPtr++] & 0x3F) << 6 | inBuf[inPtr++] & 0x3F;
            i -= 65536;
            outBuf[outPtr++] = (char)(0xD800 | i >> 10);
            i = 0xDC00 | i & 0x3FF;
            break;
          default:
            this._inputPtr = inPtr;
            throw _constructReadException("Invalid byte 0x%02X in short Unicode text block", 
                Integer.valueOf(i));
        } 
      } 
      outBuf[outPtr++] = (char)i;
    } 
    this._inputPtr += len;
    return this._textBuffer.setCurrentAndReturn(outPtr);
  }
  
  private final String _decodeLongUnicodeName(int[] quads, int byteLen, int quadLen, boolean addToSymbolTable) throws IOException {
    int lastQuad, lastQuadBytes = byteLen & 0x3;
    if (lastQuadBytes > 0) {
      lastQuad = quads[quadLen - 1];
      quads[quadLen - 1] = lastQuad << 4 - lastQuadBytes << 3;
    } else {
      lastQuad = 0;
    } 
    char[] cbuf = this._textBuffer.emptyAndGetCurrentSegment();
    int cix = 0;
    for (int ix = 0; ix < byteLen; ) {
      int ch = quads[ix >> 2];
      int byteIx = ix & 0x3;
      ch = ch >> 3 - byteIx << 3 & 0xFF;
      ix++;
      if (ch > 127) {
        int needed;
        if ((ch & 0xE0) == 192) {
          ch &= 0x1F;
          needed = 1;
        } else if ((ch & 0xF0) == 224) {
          ch &= 0xF;
          needed = 2;
        } else if ((ch & 0xF8) == 240) {
          ch &= 0x7;
          needed = 3;
        } else {
          _reportInvalidInitial(ch);
          needed = ch = 1;
        } 
        if (ix + needed > byteLen)
          _reportInvalidEOF(" in long field name", JsonToken.FIELD_NAME); 
        int ch2 = quads[ix >> 2];
        byteIx = ix & 0x3;
        ch2 >>= 3 - byteIx << 3;
        ix++;
        if ((ch2 & 0xC0) != 128)
          _reportInvalidOther(ch2); 
        ch = ch << 6 | ch2 & 0x3F;
        if (needed > 1) {
          ch2 = quads[ix >> 2];
          byteIx = ix & 0x3;
          ch2 >>= 3 - byteIx << 3;
          ix++;
          if ((ch2 & 0xC0) != 128)
            _reportInvalidOther(ch2); 
          ch = ch << 6 | ch2 & 0x3F;
          if (needed > 2) {
            ch2 = quads[ix >> 2];
            byteIx = ix & 0x3;
            ch2 >>= 3 - byteIx << 3;
            ix++;
            if ((ch2 & 0xC0) != 128)
              _reportInvalidOther(ch2 & 0xFF); 
            ch = ch << 6 | ch2 & 0x3F;
          } 
        } 
        if (needed > 2) {
          ch -= 65536;
          if (cix >= cbuf.length)
            cbuf = this._textBuffer.expandCurrentSegment(); 
          cbuf[cix++] = (char)(55296 + (ch >> 10));
          ch = 0xDC00 | ch & 0x3FF;
        } 
      } 
      if (cix >= cbuf.length)
        cbuf = this._textBuffer.expandCurrentSegment(); 
      cbuf[cix++] = (char)ch;
    } 
    String baseName = new String(cbuf, 0, cix);
    if (lastQuadBytes > 0)
      quads[quadLen - 1] = lastQuad; 
    if (addToSymbolTable)
      return this._symbols.addName(baseName, quads, quadLen); 
    return baseName;
  }
  
  private final String _handleLongFieldName() throws IOException {
    byte[] inBuf = this._inputBuffer;
    int quads = 0;
    int bytes = 0;
    int q = 0;
    while (true) {
      if (this._inputPtr >= this._inputEnd)
        _loadMoreGuaranteed(); 
      byte b = inBuf[this._inputPtr++];
      if (-4 == b) {
        bytes = 0;
        break;
      } 
      q = b & 0xFF;
      if (this._inputPtr >= this._inputEnd)
        _loadMoreGuaranteed(); 
      b = inBuf[this._inputPtr++];
      if (-4 == b) {
        bytes = 1;
        break;
      } 
      q = q << 8 | b & 0xFF;
      if (this._inputPtr >= this._inputEnd)
        _loadMoreGuaranteed(); 
      b = inBuf[this._inputPtr++];
      if (-4 == b) {
        bytes = 2;
        break;
      } 
      q = q << 8 | b & 0xFF;
      if (this._inputPtr >= this._inputEnd)
        _loadMoreGuaranteed(); 
      b = inBuf[this._inputPtr++];
      if (-4 == b) {
        bytes = 3;
        break;
      } 
      q = q << 8 | b & 0xFF;
      if (quads >= this._quadBuffer.length)
        this._quadBuffer = _growArrayTo(this._quadBuffer, this._quadBuffer.length + 256); 
      this._quadBuffer[quads++] = q;
    } 
    int byteLen = quads << 2;
    if (bytes > 0) {
      if (quads >= this._quadBuffer.length)
        this._quadBuffer = _growArrayTo(this._quadBuffer, this._quadBuffer.length + 256); 
      q = _padLastQuad(q, bytes);
      this._quadBuffer[quads++] = q;
      byteLen += bytes;
    } 
    String name = this._symbolsCanonical ? this._symbols.findName(this._quadBuffer, quads) : null;
    if (name == null)
      name = _decodeLongUnicodeName(this._quadBuffer, byteLen, quads, this._symbolsCanonical); 
    if (this._seenNames != null) {
      if (this._seenNameCount >= this._seenNames.length)
        this._seenNames = _expandSeenNames(this._seenNames); 
      this._seenNames[this._seenNameCount++] = name;
    } 
    this._streamReadContext.setCurrentName(name);
    return name;
  }
  
  private final String _findDecodedFromSymbols(int len) throws IOException {
    if (len < 5) {
      int inPtr = this._inputPtr;
      byte[] inBuf = this._inputBuffer;
      int q = _padQuadForNulls(inBuf[inPtr]);
      if (len > 1) {
        q = (q << 8) + (inBuf[++inPtr] & 0xFF);
        if (len > 2) {
          q = (q << 8) + (inBuf[++inPtr] & 0xFF);
          if (len > 3)
            q = (q << 8) + (inBuf[++inPtr] & 0xFF); 
        } 
      } 
      this._quad1 = q;
      return this._symbols.findName(q);
    } 
    byte[] inBuf = this._inputBuffer;
    int inPtr = this._inputPtr;
    int q1 = inBuf[inPtr++] & 0xFF;
    q1 = q1 << 8 | inBuf[inPtr++] & 0xFF;
    q1 = q1 << 8 | inBuf[inPtr++] & 0xFF;
    q1 = q1 << 8 | inBuf[inPtr++] & 0xFF;
    if (len < 9) {
      int q2 = _padQuadForNulls(inBuf[inPtr++]);
      int left = len - 5;
      if (left > 0) {
        q2 = (q2 << 8) + (inBuf[inPtr++] & 0xFF);
        if (left > 1) {
          q2 = (q2 << 8) + (inBuf[inPtr++] & 0xFF);
          if (left > 2)
            q2 = (q2 << 8) + (inBuf[inPtr++] & 0xFF); 
        } 
      } 
      this._quad1 = q1;
      this._quad2 = q2;
      return this._symbols.findName(q1, q2);
    } 
    int q2 = inBuf[inPtr++] & 0xFF;
    q2 = q2 << 8 | inBuf[inPtr++] & 0xFF;
    q2 = q2 << 8 | inBuf[inPtr++] & 0xFF;
    q2 = q2 << 8 | inBuf[inPtr++] & 0xFF;
    if (len < 13) {
      int q3 = _padQuadForNulls(inBuf[inPtr++]);
      int left = len - 9;
      if (left > 0) {
        q3 = (q3 << 8) + (inBuf[inPtr++] & 0xFF);
        if (left > 1) {
          q3 = (q3 << 8) + (inBuf[inPtr++] & 0xFF);
          if (left > 2)
            q3 = (q3 << 8) + (inBuf[inPtr++] & 0xFF); 
        } 
      } 
      this._quad1 = q1;
      this._quad2 = q2;
      this._quad3 = q3;
      return this._symbols.findName(q1, q2, q3);
    } 
    return _findDecodedFixed12(len, q1, q2);
  }
  
  private final String _findDecodedFixed12(int len, int q1, int q2) throws IOException {
    int bufLen = len + 3 >> 2;
    if (bufLen > this._quadBuffer.length)
      this._quadBuffer = _growArrayTo(this._quadBuffer, bufLen); 
    this._quadBuffer[0] = q1;
    this._quadBuffer[1] = q2;
    int offset = 2;
    int inPtr = this._inputPtr + 8;
    len -= 8;
    byte[] inBuf = this._inputBuffer;
    do {
      int q = inBuf[inPtr++] & 0xFF;
      q = q << 8 | inBuf[inPtr++] & 0xFF;
      q = q << 8 | inBuf[inPtr++] & 0xFF;
      q = q << 8 | inBuf[inPtr++] & 0xFF;
      this._quadBuffer[offset++] = q;
      len -= 4;
    } while (len > 3);
    if (len > 0) {
      int q = _padQuadForNulls(inBuf[inPtr]);
      if (len > 1) {
        q = (q << 8) + (inBuf[++inPtr] & 0xFF);
        if (len > 2)
          q = (q << 8) + (inBuf[++inPtr] & 0xFF); 
      } 
      this._quadBuffer[offset++] = q;
    } 
    return this._symbols.findName(this._quadBuffer, offset);
  }
  
  private static int[] _growArrayTo(int[] arr, int minSize) {
    int size = minSize + 4;
    if (arr == null)
      return new int[size]; 
    return Arrays.copyOf(arr, size);
  }
  
  private static final int _padLastQuad(int q, int bytes) { return (bytes == 4) ? q : (q | -1 << bytes << 3); }
  
  private static final int _padQuadForNulls(int firstByte) throws IOException { return firstByte & 0xFF | 0xFFFFFF00; }
  
  protected void _parseNumericValue() throws IOException {
    if (!this._tokenIncomplete)
      _reportError("Internal error: number token (%s) decoded, no value set", this._currToken); 
    this._tokenIncomplete = false;
    int tb = this._typeAsInt;
    if (tb >> 5 != 1)
      _reportError("Current token (%s) not numeric, can not use numeric value accessors", this._currToken); 
    _finishNumberToken(tb);
  }
  
  protected final void _finishToken() throws IOException {
    this._tokenIncomplete = false;
    int tb = this._typeAsInt;
    int type = tb >> 5;
    if (type == 1) {
      _finishNumberToken(tb);
      return;
    } 
    if (type <= 3) {
      _decodeShortAsciiValue(1 + (tb & 0x3F));
      return;
    } 
    if (type <= 5) {
      _decodeShortUnicodeValue(2 + (tb & 0x3F));
      return;
    } 
    if (type == 7) {
      tb &= 0x1F;
      switch (tb >> 2) {
        case 0:
          _decodeLongAsciiValue();
          return;
        case 1:
          _decodeLongUnicodeValue();
          return;
        case 2:
          this._binaryValue = _read7BitBinaryWithLength();
          return;
        case 7:
          this._binaryValue = _finishBinaryRaw();
          return;
      } 
    } 
    _throwInternal();
  }
  
  protected final void _finishNumberToken(int tb) throws IOException {
    switch (tb & 0x1F) {
      case 4:
        _finishInt();
        return;
      case 5:
        _finishLong();
        return;
      case 6:
        _finishBigInteger();
        return;
      case 8:
        _finishFloat();
        return;
      case 9:
        _finishDouble();
        return;
      case 10:
        _finishBigDecimal();
        return;
    } 
    _throwInternal();
  }
  
  private final void _finishInt() throws IOException {
    this._numTypesValid = 1;
    this._numberType = JsonParser.NumberType.INT;
    int ptr = this._inputPtr;
    if (ptr + 5 >= this._inputEnd) {
      _finishIntSlow();
      return;
    } 
    int value = this._inputBuffer[ptr++];
    if (value < 0) {
      value &= 0x3F;
    } else {
      int i = this._inputBuffer[ptr++];
      if (i >= 0) {
        value = (value << 7) + i;
        i = this._inputBuffer[ptr++];
        if (i >= 0) {
          value = (value << 7) + i;
          i = this._inputBuffer[ptr++];
          if (i >= 0) {
            value = (value << 7) + i;
            i = this._inputBuffer[ptr++];
            if (i >= 0)
              _reportError("Corrupt input; 32-bit VInt extends beyond 5 data bytes"); 
          } 
        } 
      } 
      value = (value << 6) + (i & 0x3F);
    } 
    this._inputPtr = ptr;
    this._numberInt = SmileUtil.zigzagDecode(value);
  }
  
  private final void _finishIntSlow() throws IOException {
    if (this._inputPtr >= this._inputEnd)
      _loadMoreGuaranteed(); 
    int value = this._inputBuffer[this._inputPtr++];
    if (value < 0) {
      value &= 0x3F;
    } else {
      if (this._inputPtr >= this._inputEnd)
        _loadMoreGuaranteed(); 
      int i = this._inputBuffer[this._inputPtr++];
      if (i >= 0) {
        value = (value << 7) + i;
        if (this._inputPtr >= this._inputEnd)
          _loadMoreGuaranteed(); 
        i = this._inputBuffer[this._inputPtr++];
        if (i >= 0) {
          value = (value << 7) + i;
          if (this._inputPtr >= this._inputEnd)
            _loadMoreGuaranteed(); 
          i = this._inputBuffer[this._inputPtr++];
          if (i >= 0) {
            value = (value << 7) + i;
            if (this._inputPtr >= this._inputEnd)
              _loadMoreGuaranteed(); 
            i = this._inputBuffer[this._inputPtr++];
            if (i >= 0)
              _reportError("Corrupt input; 32-bit VInt extends beyond 5 data bytes"); 
          } 
        } 
      } 
      value = (value << 6) + (i & 0x3F);
    } 
    this._numberInt = SmileUtil.zigzagDecode(value);
  }
  
  private final void _finishLong() throws IOException {
    this._numTypesValid = 2;
    this._numberType = JsonParser.NumberType.LONG;
    int ptr = this._inputPtr;
    int maxEnd = ptr + 11;
    if (maxEnd >= this._inputEnd) {
      _finishLongSlow();
      return;
    } 
    int i = this._inputBuffer[ptr++];
    i = (i << 7) + this._inputBuffer[ptr++];
    i = (i << 7) + this._inputBuffer[ptr++];
    i = (i << 7) + this._inputBuffer[ptr++];
    long l = i;
    do {
      int value = this._inputBuffer[ptr++];
      if (value < 0) {
        l = (l << 6) + (value & 0x3F);
        this._inputPtr = ptr;
        this._numberLong = SmileUtil.zigzagDecode(l);
        return;
      } 
      l = (l << 7) + value;
    } while (ptr < maxEnd);
    _reportError("Corrupt input; 64-bit VInt extends beyond 11 data bytes");
  }
  
  private final void _finishLongSlow() throws IOException {
    long l = _fourBytesToInt();
    while (true) {
      if (this._inputPtr >= this._inputEnd)
        _loadMoreGuaranteed(); 
      int value = this._inputBuffer[this._inputPtr++];
      if (value < 0) {
        l = (l << 6) + (value & 0x3F);
        this._numberLong = SmileUtil.zigzagDecode(l);
        return;
      } 
      l = (l << 7) + value;
    } 
  }
  
  private final int _fourBytesToInt() throws IOException {
    int ptr = this._inputPtr;
    if (ptr + 3 >= this._inputEnd)
      return _fourBytesToIntSlow(); 
    int i = this._inputBuffer[ptr++];
    i = (i << 7) + this._inputBuffer[ptr++];
    i = (i << 7) + this._inputBuffer[ptr++];
    i = (i << 7) + this._inputBuffer[ptr++];
    this._inputPtr = ptr;
    return i;
  }
  
  private final int _fourBytesToIntSlow() throws IOException {
    if (this._inputPtr >= this._inputEnd)
      _loadMoreGuaranteed(); 
    int i = this._inputBuffer[this._inputPtr++];
    if (this._inputPtr >= this._inputEnd)
      _loadMoreGuaranteed(); 
    i = (i << 7) + this._inputBuffer[this._inputPtr++];
    if (this._inputPtr >= this._inputEnd)
      _loadMoreGuaranteed(); 
    i = (i << 7) + this._inputBuffer[this._inputPtr++];
    if (this._inputPtr >= this._inputEnd)
      _loadMoreGuaranteed(); 
    return (i << 7) + this._inputBuffer[this._inputPtr++];
  }
  
  private final void _finishBigInteger() throws IOException {
    byte[] raw = _read7BitBinaryWithLength();
    if (raw.length == 0) {
      this._numberBigInt = BigInteger.ZERO;
    } else {
      streamReadConstraints().validateIntegerLength(raw.length);
      this._numberBigInt = new BigInteger(raw);
    } 
    this._numTypesValid = 4;
    this._numberType = JsonParser.NumberType.BIG_INTEGER;
  }
  
  private final void _finishFloat() throws IOException {
    int i = _fourBytesToInt();
    if (this._inputPtr >= this._inputEnd)
      _loadMoreGuaranteed(); 
    i = (i << 7) + this._inputBuffer[this._inputPtr++];
    float f = Float.intBitsToFloat(i);
    this._numberFloat = f;
    this._numberType = JsonParser.NumberType.FLOAT;
    this._numTypesValid = 32;
  }
  
  private final void _finishDouble() throws IOException {
    long hi = _fourBytesToInt();
    long value = (hi << 28) + _fourBytesToInt();
    if (this._inputPtr >= this._inputEnd)
      _loadMoreGuaranteed(); 
    value = (value << 7) + this._inputBuffer[this._inputPtr++];
    if (this._inputPtr >= this._inputEnd)
      _loadMoreGuaranteed(); 
    value = (value << 7) + this._inputBuffer[this._inputPtr++];
    this._numberDouble = Double.longBitsToDouble(value);
    this._numberType = JsonParser.NumberType.DOUBLE;
    this._numTypesValid = 8;
  }
  
  private final void _finishBigDecimal() throws IOException {
    int scale = SmileUtil.zigzagDecode(_readUnsignedVInt());
    byte[] raw = _read7BitBinaryWithLength();
    if (raw.length == 0) {
      this._numberBigDecimal = BigDecimal.ZERO;
    } else {
      streamReadConstraints().validateFPLength(raw.length);
      BigInteger unscaledValue = new BigInteger(raw);
      this._numberBigDecimal = new BigDecimal(unscaledValue, scale);
    } 
    this._numTypesValid = 16;
    this._numberType = JsonParser.NumberType.BIG_DECIMAL;
  }
  
  protected final int _readUnsignedVInt() throws IOException {
    if (this._inputPtr + 5 > this._inputEnd)
      return _readUnsignedVIntSlow(); 
    int ch = this._inputBuffer[this._inputPtr++];
    if (ch < 0)
      return ch & 0x3F; 
    int value = ch;
    ch = this._inputBuffer[this._inputPtr++];
    if (ch < 0)
      return (value << 6) + (ch & 0x3F); 
    value = (value << 7) + ch;
    ch = this._inputBuffer[this._inputPtr++];
    if (ch < 0)
      return (value << 6) + (ch & 0x3F); 
    value = (value << 7) + ch;
    ch = this._inputBuffer[this._inputPtr++];
    if (ch < 0)
      return (value << 6) + (ch & 0x3F); 
    value = (value << 7) + ch;
    ch = this._inputBuffer[this._inputPtr++];
    if (ch >= 0 || value >>> 25 != 0)
      _reportInvalidUnsignedVInt(value >>> 21, ch); 
    return (value << 6) + (ch & 0x3F);
  }
  
  protected final int _readUnsignedVIntSlow() throws IOException {
    value = 0;
    int count = 0;
    do {
      if (this._inputPtr >= this._inputEnd)
        _loadMoreGuaranteed(); 
      int ch = this._inputBuffer[this._inputPtr++];
      if (ch < 0)
        return (value << 6) + (ch & 0x3F); 
      value = (value << 7) + ch;
    } while (++count < 4);
    if (this._inputPtr >= this._inputEnd)
      _loadMoreGuaranteed(); 
    int ch = this._inputBuffer[this._inputPtr++];
    if (ch >= 0 || value >>> 25 != 0)
      _reportInvalidUnsignedVInt(value >>> 21, ch); 
    return (value << 6) + (ch & 0x3F);
  }
  
  protected final void _reportInvalidUnsignedVInt(int firstCh, int lastCh) throws IOException {
    if (lastCh >= 0)
      _reportError("Overflow in VInt (current token %s): 5th byte (0x%2X) of 5-byte sequence must have its highest bit set to indicate end", 
          
          currentToken(), Integer.valueOf(lastCh)); 
    _reportError("Overflow in VInt (current token %s): 1st byte (0x%2X) of 5-byte sequence must have its top 4 bits zeroes", 
        
        currentToken(), Integer.valueOf(firstCh));
  }
  
  protected final String _decodeShortAsciiValue(int len) throws IOException {
    if (this._inputEnd - this._inputPtr < len)
      _loadToHaveAtLeast(len); 
    if (JDK11_OR_LATER) {
      int inPtr = this._inputPtr;
      this._inputPtr = inPtr + len;
      String str = new String(this._inputBuffer, inPtr, len, StandardCharsets.US_ASCII);
      this._textBuffer.resetWithString(str);
      return str;
    } 
    char[] outBuf = this._textBuffer.emptyAndGetCurrentSegment();
    int outPtr = 0;
    byte[] inBuf = this._inputBuffer;
    int inPtr = this._inputPtr;
    for (int end = inPtr + len; inPtr < end; inPtr++)
      outBuf[outPtr++] = (char)inBuf[inPtr]; 
    this._inputPtr = inPtr;
    return this._textBuffer.setCurrentAndReturn(len);
  }
  
  protected final String _decodeShortUnicodeValue(int byteLen) throws IOException {
    if (this._inputEnd - this._inputPtr < byteLen)
      _loadToHaveAtLeast(byteLen); 
    int outPtr = 0;
    char[] outBuf = this._textBuffer.emptyAndGetCurrentSegment();
    int inPtr = this._inputPtr;
    this._inputPtr += byteLen;
    int[] codes = SmileConstants.sUtf8UnitLengths;
    byte[] inputBuf = this._inputBuffer;
    for (int end = inPtr + byteLen; inPtr < end; ) {
      int i = inputBuf[inPtr++];
      if (i >= 0) {
        outBuf[outPtr++] = (char)i;
        continue;
      } 
      i &= 0xFF;
      int unitLen = codes[i];
      if (inPtr + unitLen > end) {
        int firstCharOffset = byteLen - end - inPtr - 1;
        return _reportTruncatedUTF8InString(byteLen, firstCharOffset, i, unitLen);
      } 
      switch (unitLen) {
        case 1:
          i = (i & 0x1F) << 6 | inputBuf[inPtr++] & 0x3F;
          break;
        case 2:
          i = (i & 0xF) << 12 | (inputBuf[inPtr++] & 0x3F) << 6 | inputBuf[inPtr++] & 0x3F;
          break;
        case 3:
          i = (i & 0x7) << 18 | (inputBuf[inPtr++] & 0x3F) << 12 | (inputBuf[inPtr++] & 0x3F) << 6 | inputBuf[inPtr++] & 0x3F;
          i -= 65536;
          outBuf[outPtr++] = (char)(0xD800 | i >> 10);
          i = 0xDC00 | i & 0x3FF;
          break;
        default:
          throw _constructReadException("Invalid byte 0x%02X in short Unicode text block", Integer.valueOf(i));
      } 
      outBuf[outPtr++] = (char)i;
    } 
    return this._textBuffer.setCurrentAndReturn(outPtr);
  }
  
  private final void _decodeLongAsciiValue() throws IOException {
    int outPtr = 0;
    char[] outBuf = this._textBuffer.emptyAndGetCurrentSegment();
    while (true) {
      if (this._inputPtr >= this._inputEnd)
        _loadMoreGuaranteed(); 
      int inPtr = this._inputPtr;
      int left = this._inputEnd - inPtr;
      if (outPtr >= outBuf.length) {
        outBuf = this._textBuffer.finishCurrentSegment();
        outPtr = 0;
      } 
      left = Math.min(left, outBuf.length - outPtr);
      while (true) {
        byte b = this._inputBuffer[inPtr++];
        if (b == -4) {
          this._inputPtr = inPtr;
          break;
        } 
        outBuf[outPtr++] = (char)b;
        if (--left <= 0)
          this._inputPtr = inPtr; 
      } 
      break;
    } 
    this._textBuffer.setCurrentLength(outPtr);
  }
  
  private final void _decodeLongUnicodeValue() throws IOException {
    int outPtr = 0;
    char[] outBuf = this._textBuffer.emptyAndGetCurrentSegment();
    int[] codes = SmileConstants.sUtf8UnitLengths;
    byte[] inputBuffer = this._inputBuffer;
    while (true) {
      int ptr = this._inputPtr;
      if (ptr >= this._inputEnd) {
        _loadMoreGuaranteed();
        ptr = this._inputPtr;
      } 
      if (outPtr >= outBuf.length) {
        outBuf = this._textBuffer.finishCurrentSegment();
        outPtr = 0;
      } 
      int max = this._inputEnd;
      int max2 = ptr + outBuf.length - outPtr;
      if (max2 < max)
        max = max2; 
      while (ptr < max) {
        int c, c = inputBuffer[ptr++] & 0xFF;
        if (codes[c] != 0) {
          this._inputPtr = ptr;
        } else {
          outBuf[outPtr++] = (char)c;
          continue;
        } 
        if (c == 252)
          break; 
        switch (codes[c]) {
          case 1:
            c = _decodeUtf8_2(c);
            break;
          case 2:
            if (this._inputEnd - this._inputPtr >= 2) {
              c = _decodeUtf8_3fast(c);
              break;
            } 
            c = _decodeUtf8_3(c);
            break;
          case 3:
            c = _decodeUtf8_4(c);
            outBuf[outPtr++] = (char)(0xD800 | c >> 10);
            if (outPtr >= outBuf.length) {
              outBuf = this._textBuffer.finishCurrentSegment();
              outPtr = 0;
            } 
            c = 0xDC00 | c & 0x3FF;
            break;
          default:
            _reportInvalidChar(c);
            break;
        } 
        if (outPtr >= outBuf.length) {
          outBuf = this._textBuffer.finishCurrentSegment();
          outPtr = 0;
        } 
        outBuf[outPtr++] = (char)c;
      } 
      this._inputPtr = ptr;
    } 
    this._textBuffer.setCurrentLength(outPtr);
  }
  
  private final byte[] _finishBinaryRaw() throws IOException {
    int byteLen = _readUnsignedVInt();
    if (byteLen > 250000)
      return _finishBinaryRawLong(byteLen); 
    int expLen = byteLen;
    byte[] b = new byte[byteLen];
    int ptr = 0;
    while (byteLen > 0) {
      if (this._inputPtr >= this._inputEnd && 
        !_loadMore())
        _reportIncompleteBinaryReadRaw(expLen, ptr); 
      int toAdd = Math.min(byteLen, this._inputEnd - this._inputPtr);
      System.arraycopy(this._inputBuffer, this._inputPtr, b, ptr, toAdd);
      this._inputPtr += toAdd;
      ptr += toAdd;
      byteLen -= toAdd;
    } 
    return b;
  }
  
  protected byte[] _finishBinaryRawLong(int expLen) throws IOException {
    int left = expLen;
    try (ByteArrayBuilder bb = new ByteArrayBuilder(125000)) {
      while (left > 0) {
        int avail = this._inputEnd - this._inputPtr;
        if (avail <= 0) {
          if (!_loadMore())
            _reportIncompleteBinaryReadRaw(expLen, expLen - left); 
          avail = this._inputEnd - this._inputPtr;
        } 
        int count = Math.min(avail, left);
        bb.write(this._inputBuffer, this._inputPtr, count);
        this._inputPtr += count;
        left -= count;
      } 
      return bb.toByteArray();
    } 
  }
  
  private final byte[] _read7BitBinaryWithLength() throws IOException {
    int byteLen = _readUnsignedVInt();
    if (byteLen > 250000)
      return _finishBinary7BitLong(byteLen); 
    byte[] result = new byte[byteLen];
    int lastOkPtr = byteLen - 7;
    int ptr = 0;
    while (ptr <= lastOkPtr) {
      if (this._inputEnd - this._inputPtr < 8) {
        int missing = _tryToLoadToHaveAtLeast(8);
        if (missing > 0)
          _reportIncompleteBinaryRead7Bit(byteLen, ptr); 
      } 
      int i1 = (this._inputBuffer[this._inputPtr++] << 25) + (this._inputBuffer[this._inputPtr++] << 18) + (this._inputBuffer[this._inputPtr++] << 11) + (this._inputBuffer[this._inputPtr++] << 4);
      int x = this._inputBuffer[this._inputPtr++];
      i1 += (x >> 3);
      int i2 = ((x & 0x7) << 21) + (this._inputBuffer[this._inputPtr++] << 14) + (this._inputBuffer[this._inputPtr++] << 7) + this._inputBuffer[this._inputPtr++];
      result[ptr++] = (byte)(i1 >> 24);
      result[ptr++] = (byte)(i1 >> 16);
      result[ptr++] = (byte)(i1 >> 8);
      result[ptr++] = (byte)i1;
      result[ptr++] = (byte)(i2 >> 16);
      result[ptr++] = (byte)(i2 >> 8);
      result[ptr++] = (byte)i2;
    } 
    int toDecode = result.length - ptr;
    if (toDecode > 0) {
      if (this._inputEnd - this._inputPtr < toDecode + 1) {
        int missing = _tryToLoadToHaveAtLeast(toDecode + 1);
        if (missing > 0)
          _reportIncompleteBinaryRead7Bit(byteLen, ptr); 
      } 
      int value = this._inputBuffer[this._inputPtr++];
      for (int i = 1; i < toDecode; i++) {
        value = (value << 7) + this._inputBuffer[this._inputPtr++];
        result[ptr++] = (byte)(value >> 7 - i);
      } 
      value <<= toDecode;
      result[ptr] = (byte)(value + this._inputBuffer[this._inputPtr++]);
    } 
    return result;
  }
  
  protected byte[] _finishBinary7BitLong(int expLen) throws IOException {
    try (ByteArrayBuilder bb = new ByteArrayBuilder(125000)) {
      byte[] buffer = new byte[896];
      int left = expLen;
      int bufPtr = 0;
      while (left >= 7) {
        if (this._inputEnd - this._inputPtr < 8) {
          int missing = _tryToLoadToHaveAtLeast(8);
          if (missing > 0)
            _reportIncompleteBinaryRead7Bit(expLen, bb.size() + bufPtr); 
        } 
        int i1 = (this._inputBuffer[this._inputPtr++] << 25) + (this._inputBuffer[this._inputPtr++] << 18) + (this._inputBuffer[this._inputPtr++] << 11) + (this._inputBuffer[this._inputPtr++] << 4);
        int x = this._inputBuffer[this._inputPtr++];
        i1 += (x >> 3);
        int i2 = ((x & 0x7) << 21) + (this._inputBuffer[this._inputPtr++] << 14) + (this._inputBuffer[this._inputPtr++] << 7) + this._inputBuffer[this._inputPtr++];
        buffer[bufPtr++] = (byte)(i1 >> 24);
        buffer[bufPtr++] = (byte)(i1 >> 16);
        buffer[bufPtr++] = (byte)(i1 >> 8);
        buffer[bufPtr++] = (byte)i1;
        buffer[bufPtr++] = (byte)(i2 >> 16);
        buffer[bufPtr++] = (byte)(i2 >> 8);
        buffer[bufPtr++] = (byte)i2;
        if (bufPtr >= buffer.length) {
          bb.write(buffer, 0, bufPtr);
          bufPtr = 0;
        } 
        left -= 7;
      } 
      if (left > 0) {
        if (this._inputEnd - this._inputPtr < left + 1)
          _loadToHaveAtLeast(left + 1); 
        int value = this._inputBuffer[this._inputPtr++];
        for (int i = 1; i < left; i++) {
          value = (value << 7) + this._inputBuffer[this._inputPtr++];
          buffer[bufPtr++] = (byte)(value >> 7 - i);
        } 
        value <<= left;
        buffer[bufPtr++] = (byte)(value + this._inputBuffer[this._inputPtr++]);
      } 
      if (bufPtr > 0)
        bb.write(buffer, 0, bufPtr); 
      return bb.toByteArray();
    } 
  }
  
  protected void _skipIncomplete() throws IOException {
    this._tokenIncomplete = false;
    int tb = this._typeAsInt;
    switch (tb >> 5) {
      case 1:
        tb &= 0x1F;
        switch (tb >> 2) {
          case 1:
            switch (tb & 0x3) {
              case 1:
                _skipBytes(4);
              case 0:
                while (true) {
                  int end = this._inputEnd;
                  byte[] buf = this._inputBuffer;
                  while (this._inputPtr < end) {
                    if (buf[this._inputPtr++] < 0)
                      return; 
                  } 
                  _loadMoreGuaranteed();
                } 
              case 2:
                _skip7BitBinary();
                return;
            } 
            break;
          case 2:
            switch (tb & 0x3) {
              case 0:
                _skipBytes(5);
                return;
              case 1:
                _skipBytes(10);
                return;
              case 2:
                _readUnsignedVInt();
                _skip7BitBinary();
                return;
            } 
            break;
        } 
        break;
      case 2:
      case 3:
        _skipBytes(1 + (tb & 0x3F));
        return;
      case 4:
      case 5:
        _skipBytes(2 + (tb & 0x3F));
        return;
      case 7:
        tb &= 0x1F;
        switch (tb >> 2) {
          case 0:
          case 1:
            while (true) {
              int end = this._inputEnd;
              byte[] buf = this._inputBuffer;
              while (this._inputPtr < end) {
                if (buf[this._inputPtr++] == -4)
                  return; 
              } 
              _loadMoreGuaranteed();
            } 
          case 2:
            _skip7BitBinary();
            return;
          case 7:
            _skipBytes(_readUnsignedVInt());
            return;
        } 
        break;
    } 
    _throwInternal();
  }
  
  protected void _skipBytes(int len) throws IOException {
    while (true) {
      int toAdd = Math.min(len, this._inputEnd - this._inputPtr);
      this._inputPtr += toAdd;
      len -= toAdd;
      if (len <= 0)
        return; 
      _loadMoreGuaranteed();
    } 
  }
  
  protected void _skip7BitBinary() throws IOException {
    int origBytes = _readUnsignedVInt();
    int chunks = origBytes / 7;
    int encBytes = chunks * 8;
    origBytes -= 7 * chunks;
    if (origBytes > 0)
      encBytes += 1 + origBytes; 
    _skipBytes(encBytes);
  }
  
  private final int _decodeUtf8_2(int c) throws IOException {
    if (this._inputPtr >= this._inputEnd)
      _loadMoreGuaranteed(); 
    int d = this._inputBuffer[this._inputPtr++];
    if ((d & 0xC0) != 128)
      _reportInvalidOther(d & 0xFF, this._inputPtr); 
    return (c & 0x1F) << 6 | d & 0x3F;
  }
  
  private final int _decodeUtf8_3(int c1) throws IOException {
    if (this._inputPtr >= this._inputEnd)
      _loadMoreGuaranteed(); 
    c1 &= 0xF;
    int d = this._inputBuffer[this._inputPtr++];
    if ((d & 0xC0) != 128)
      _reportInvalidOther(d & 0xFF, this._inputPtr); 
    c = c1 << 6 | d & 0x3F;
    if (this._inputPtr >= this._inputEnd)
      _loadMoreGuaranteed(); 
    d = this._inputBuffer[this._inputPtr++];
    if ((d & 0xC0) != 128)
      _reportInvalidOther(d & 0xFF, this._inputPtr); 
    return c << 6 | d & 0x3F;
  }
  
  private final int _decodeUtf8_3fast(int c1) throws IOException {
    c1 &= 0xF;
    int d = this._inputBuffer[this._inputPtr++];
    if ((d & 0xC0) != 128)
      _reportInvalidOther(d & 0xFF, this._inputPtr); 
    c = c1 << 6 | d & 0x3F;
    d = this._inputBuffer[this._inputPtr++];
    if ((d & 0xC0) != 128)
      _reportInvalidOther(d & 0xFF, this._inputPtr); 
    return c << 6 | d & 0x3F;
  }
  
  private final int _decodeUtf8_4(int c) throws IOException {
    if (this._inputPtr >= this._inputEnd)
      _loadMoreGuaranteed(); 
    int d = this._inputBuffer[this._inputPtr++];
    if ((d & 0xC0) != 128)
      _reportInvalidOther(d & 0xFF, this._inputPtr); 
    c = (c & 0x7) << 6 | d & 0x3F;
    if (this._inputPtr >= this._inputEnd)
      _loadMoreGuaranteed(); 
    d = this._inputBuffer[this._inputPtr++];
    if ((d & 0xC0) != 128)
      _reportInvalidOther(d & 0xFF, this._inputPtr); 
    c = c << 6 | d & 0x3F;
    if (this._inputPtr >= this._inputEnd)
      _loadMoreGuaranteed(); 
    d = this._inputBuffer[this._inputPtr++];
    if ((d & 0xC0) != 128)
      _reportInvalidOther(d & 0xFF, this._inputPtr); 
    return (c << 6 | d & 0x3F) - 65536;
  }
  
  protected void _reportInvalidSharedName(int index) throws IOException {
    if (this._seenNames == null)
      _reportError("Encountered shared name reference, even though document header explicitly declared no shared name references are included"); 
    _reportError("Invalid shared name reference " + index + "; only got " + this._seenNameCount + " names in buffer (invalid content)");
  }
  
  protected void _reportInvalidSharedStringValue(int index) throws IOException {
    if (this._seenStringValues == null)
      _reportError("Encountered shared text value reference, even though document header did not declare shared text value references may be included"); 
    _reportError("Invalid shared text value reference " + index + "; only got " + this._seenStringValueCount + " names in buffer (invalid content)");
  }
  
  protected void _reportInvalidChar(int c) throws IOException {
    if (c < 32)
      _throwInvalidSpace(c); 
    _reportInvalidInitial(c);
  }
  
  protected void _reportInvalidInitial(int mask) throws IOException { _reportError("Invalid UTF-8 start byte 0x" + Integer.toHexString(mask)); }
  
  protected void _reportInvalidOther(int mask) throws IOException { _reportError("Invalid UTF-8 middle byte 0x" + Integer.toHexString(mask)); }
  
  protected void _reportInvalidOther(int mask, int ptr) throws IOException {
    this._inputPtr = ptr;
    _reportInvalidOther(mask);
  }
  
  protected void _reportIncompleteBinaryReadRaw(int expLen, int actLen) throws IOException {
    _reportInvalidEOF(String.format(" for Binary value (raw): expected %d bytes, only found %d", new Object[] { Integer.valueOf(expLen), Integer.valueOf(actLen) }), currentToken());
  }
  
  protected void _reportIncompleteBinaryRead7Bit(int expLen, int actLen) throws IOException {
    long encodedLen = (7L + 8L * expLen) / 7L;
    _reportInvalidEOF(String.format(" for Binary value (7-bit): expected %d payload bytes (from %d encoded), only decoded %d", new Object[] { Integer.valueOf(expLen), Long.valueOf(encodedLen), Integer.valueOf(actLen) }), currentToken());
  }
  
  protected String _reportTruncatedUTF8InString(int strLenBytes, int truncatedCharOffset, int firstUTFByteValue, int bytesExpected) throws IOException {
    throw _constructReadException(String.format("Truncated UTF-8 character in Short Unicode String value (%d bytes): byte 0x%02X at offset #%d indicated %d more bytes needed", new Object[] { Integer.valueOf(strLenBytes), Integer.valueOf(firstUTFByteValue), Integer.valueOf(truncatedCharOffset), Integer.valueOf(bytesExpected) }));
  }
  
  protected String _reportTruncatedUTF8InName(int strLenBytes, int truncatedCharOffset, int firstUTFByteValue, int bytesExpected) throws IOException {
    throw _constructReadException(String.format("Truncated UTF-8 character in Short Unicode Name (%d bytes): byte 0x%02X at offset #%d indicated %d more bytes needed", new Object[] { Integer.valueOf(strLenBytes), Integer.valueOf(firstUTFByteValue), Integer.valueOf(truncatedCharOffset), Integer.valueOf(bytesExpected) }));
  }
  
  private final JsonToken _eofAsNextToken() throws IOException {
    if (!this._streamReadContext.inRoot())
      _handleEOF(); 
    close();
    return this._currToken = null;
  }
  
  private void createChildArrayContext(int lineNr, int colNr) throws IOException {
    this._streamReadContext = this._streamReadContext.createChildArrayContext(lineNr, colNr);
    streamReadConstraints().validateNestingDepth(this._streamReadContext.getNestingDepth());
  }
  
  private void createChildObjectContext(int lineNr, int colNr) throws IOException {
    this._streamReadContext = this._streamReadContext.createChildObjectContext(lineNr, colNr);
    streamReadConstraints().validateNestingDepth(this._streamReadContext.getNestingDepth());
  }
}
