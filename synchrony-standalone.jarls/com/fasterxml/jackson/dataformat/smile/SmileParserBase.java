package com.fasterxml.jackson.dataformat.smile;

import com.fasterxml.jackson.core.JsonLocation;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonStreamContext;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.core.StreamReadCapability;
import com.fasterxml.jackson.core.StreamReadConstraints;
import com.fasterxml.jackson.core.StreamReadFeature;
import com.fasterxml.jackson.core.Version;
import com.fasterxml.jackson.core.base.ParserMinimalBase;
import com.fasterxml.jackson.core.io.ContentReference;
import com.fasterxml.jackson.core.io.IOContext;
import com.fasterxml.jackson.core.io.NumberInput;
import com.fasterxml.jackson.core.json.DupDetector;
import com.fasterxml.jackson.core.json.JsonReadContext;
import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;
import com.fasterxml.jackson.core.util.JacksonFeatureSet;
import com.fasterxml.jackson.core.util.TextBuffer;
import java.io.IOException;
import java.lang.ref.SoftReference;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Arrays;

public abstract class SmileParserBase extends ParserMinimalBase {
  protected static final String[] NO_STRINGS = new String[0];
  
  protected static final int LONGEST_NON_CHUNKED_BINARY = 250000;
  
  protected static final JacksonFeatureSet<StreamReadCapability> SMILE_READ_CAPABILITIES = DEFAULT_READ_CAPABILITIES
    .with(StreamReadCapability.EXACT_FLOATS);
  
  protected int _formatFeatures;
  
  protected boolean _mayContainRawBinary;
  
  protected final IOContext _ioContext;
  
  protected boolean _closed;
  
  protected int _inputPtr = 0;
  
  protected int _inputEnd = 0;
  
  protected long _currInputProcessed;
  
  protected int _tokenOffsetForTotal;
  
  protected JsonReadContext _streamReadContext;
  
  protected final TextBuffer _textBuffer;
  
  protected char[] _nameCopyBuffer;
  
  protected boolean _nameCopied;
  
  protected byte[] _binaryValue;
  
  protected JsonParser.NumberType _numberType;
  
  protected int _numTypesValid = 0;
  
  protected BigInteger _numberBigInt;
  
  protected BigDecimal _numberBigDecimal;
  
  protected int _numberInt;
  
  protected float _numberFloat;
  
  protected long _numberLong;
  
  protected double _numberDouble;
  
  protected final ByteQuadsCanonicalizer _symbols;
  
  protected int[] _quadBuffer = NO_INTS;
  
  protected int _quad1;
  
  protected int _quad2;
  
  protected int _quad3;
  
  protected String[] _seenNames = NO_STRINGS;
  
  protected int _seenNameCount = 0;
  
  protected String[] _seenStringValues = null;
  
  protected int _seenStringValueCount = -1;
  
  protected final boolean _symbolsCanonical;
  
  protected static final ThreadLocal<SoftReference<SmileBufferRecycler<String>>> _smileRecyclerRef = new ThreadLocal();
  
  protected final SmileBufferRecycler<String> _smileBufferRecycler;
  
  public SmileParserBase(IOContext ctxt, int parserFeatures, int formatFeatures, ByteQuadsCanonicalizer sym) {
    super(parserFeatures);
    this._formatFeatures = formatFeatures;
    this._ioContext = ctxt;
    this._symbols = sym;
    this._symbolsCanonical = sym.isCanonicalizing();
    DupDetector dups = JsonParser.Feature.STRICT_DUPLICATE_DETECTION.enabledIn(parserFeatures) ? DupDetector.rootDetector(this) : null;
    this._streamReadContext = JsonReadContext.createRootContext(dups);
    this._textBuffer = ctxt.constructReadConstrainedTextBuffer();
    this._smileBufferRecycler = _smileBufferRecycler();
  }
  
  public StreamReadConstraints streamReadConstraints() { return this._ioContext.streamReadConstraints(); }
  
  protected static final SmileBufferRecycler<String> _smileBufferRecycler() {
    ref = (SoftReference)_smileRecyclerRef.get();
    SmileBufferRecycler<String> br = (ref == null) ? null : (SmileBufferRecycler)ref.get();
    if (br == null) {
      br = new SmileBufferRecycler<String>();
      _smileRecyclerRef.set(new SoftReference(br));
    } 
    return br;
  }
  
  public final Version version() { return PackageVersion.VERSION; }
  
  public final boolean mayContainRawBinary() { return this._mayContainRawBinary; }
  
  public final int getFormatFeatures() { return this._formatFeatures; }
  
  public final JsonParser overrideFormatFeatures(int values, int mask) {
    this._formatFeatures = this._formatFeatures & (mask ^ 0xFFFFFFFF) | values & mask;
    return this;
  }
  
  public JacksonFeatureSet<StreamReadCapability> getReadCapabilities() { return SMILE_READ_CAPABILITIES; }
  
  public final JsonLocation getTokenLocation() {
    long total = this._currInputProcessed + this._tokenOffsetForTotal;
    return new JsonLocation(this._ioContext.contentReference(), total, -1L, -1, (int)total);
  }
  
  public final JsonLocation getCurrentLocation() {
    long offset = this._currInputProcessed + this._inputPtr;
    return new JsonLocation(this._ioContext.contentReference(), offset, -1L, -1, (int)offset);
  }
  
  public final String getCurrentName() throws IOException {
    if (this._currToken == JsonToken.START_OBJECT || this._currToken == JsonToken.START_ARRAY)
      return this._streamReadContext.getParent().getCurrentName(); 
    return this._streamReadContext.getCurrentName();
  }
  
  public final void overrideCurrentName(String name) {
    JsonReadContext ctxt = this._streamReadContext;
    if (this._currToken == JsonToken.START_OBJECT || this._currToken == JsonToken.START_ARRAY)
      ctxt = ctxt.getParent(); 
    try {
      ctxt.setCurrentName(name);
    } catch (IOException e) {
      throw new IllegalStateException(e);
    } 
  }
  
  public final void close() throws IOException {
    if (!this._closed) {
      this._closed = true;
      this._inputEnd = 0;
      this._symbols.release();
      try {
        _closeInput();
      } finally {
        _releaseBuffers();
      } 
    } 
  }
  
  protected final void _releaseBuffers() throws IOException {
    this._textBuffer.releaseBuffers();
    char[] buf = this._nameCopyBuffer;
    if (buf != null) {
      this._nameCopyBuffer = null;
      this._ioContext.releaseNameCopyBuffer(buf);
    } 
    String[] nameBuf = this._seenNames;
    if (nameBuf != null && nameBuf.length > 0) {
      this._seenNames = null;
      if (this._seenNameCount > 0)
        Arrays.fill(nameBuf, 0, this._seenNameCount, null); 
      this._smileBufferRecycler.releaseSeenNamesBuffer(nameBuf);
    } 
    String[] valueBuf = this._seenStringValues;
    if (valueBuf != null && valueBuf.length > 0) {
      this._seenStringValues = null;
      if (this._seenStringValueCount > 0)
        Arrays.fill(valueBuf, 0, this._seenStringValueCount, null); 
      this._smileBufferRecycler.releaseSeenStringValuesBuffer(valueBuf);
    } 
    _releaseBuffers2();
  }
  
  public final boolean isClosed() { return this._closed; }
  
  public final JsonReadContext getParsingContext() { return this._streamReadContext; }
  
  public final boolean isNaN() {
    if (this._currToken == JsonToken.VALUE_NUMBER_FLOAT) {
      if (this._numTypesValid == 0)
        _parseNumericValue(); 
      if (this._numberType == JsonParser.NumberType.DOUBLE) {
        double d = this._numberDouble;
        return (Double.isNaN(d) || Double.isInfinite(d));
      } 
      if (this._numberType == JsonParser.NumberType.FLOAT) {
        float f = this._numberFloat;
        return (Float.isNaN(f) || Float.isInfinite(f));
      } 
    } 
    return false;
  }
  
  public final Number getNumberValue() throws IOException {
    if (this._numTypesValid == 0)
      _parseNumericValue(); 
    switch (null.$SwitchMap$com$fasterxml$jackson$core$JsonParser$NumberType[this._numberType.ordinal()]) {
      case 1:
        return Integer.valueOf(this._numberInt);
      case 2:
        return Long.valueOf(this._numberLong);
      case 3:
        return this._numberBigInt;
      case 4:
        return Float.valueOf(this._numberFloat);
      case 5:
        return Double.valueOf(this._numberDouble);
    } 
    return this._numberBigDecimal;
  }
  
  public final Number getNumberValueExact() throws IOException { return getNumberValue(); }
  
  public final JsonParser.NumberType getNumberType() throws IOException {
    if (this._numTypesValid == 0)
      _parseNumericValue(); 
    return this._numberType;
  }
  
  public final int getIntValue() {
    if ((this._numTypesValid & true) == 0) {
      if (this._numTypesValid == 0)
        _parseNumericValue(); 
      if ((this._numTypesValid & true) == 0)
        convertNumberToInt(); 
    } 
    return this._numberInt;
  }
  
  public final long getLongValue() throws IOException {
    if ((this._numTypesValid & 0x2) == 0) {
      if (this._numTypesValid == 0)
        _parseNumericValue(); 
      if ((this._numTypesValid & 0x2) == 0)
        convertNumberToLong(); 
    } 
    return this._numberLong;
  }
  
  public final BigInteger getBigIntegerValue() throws IOException {
    if ((this._numTypesValid & 0x4) == 0) {
      if (this._numTypesValid == 0)
        _parseNumericValue(); 
      if ((this._numTypesValid & 0x4) == 0)
        convertNumberToBigInteger(); 
    } 
    return this._numberBigInt;
  }
  
  public final float getFloatValue() throws IOException {
    if ((this._numTypesValid & 0x20) == 0) {
      if (this._numTypesValid == 0)
        _parseNumericValue(); 
      if ((this._numTypesValid & 0x20) == 0)
        convertNumberToFloat(); 
    } 
    return this._numberFloat;
  }
  
  public final double getDoubleValue() throws IOException {
    if ((this._numTypesValid & 0x8) == 0) {
      if (this._numTypesValid == 0)
        _parseNumericValue(); 
      if ((this._numTypesValid & 0x8) == 0)
        convertNumberToDouble(); 
    } 
    return this._numberDouble;
  }
  
  public final BigDecimal getDecimalValue() throws IOException {
    if ((this._numTypesValid & 0x10) == 0) {
      if (this._numTypesValid == 0)
        _parseNumericValue(); 
      if ((this._numTypesValid & 0x10) == 0)
        convertNumberToBigDecimal(); 
    } 
    return this._numberBigDecimal;
  }
  
  protected final void convertNumberToInt() throws IOException {
    if ((this._numTypesValid & 0x2) != 0) {
      int result = (int)this._numberLong;
      if (result != this._numberLong)
        _reportError("Numeric value (%s) out of range of int", getText()); 
      this._numberInt = result;
    } else if ((this._numTypesValid & 0x4) != 0) {
      if (BI_MIN_INT.compareTo(this._numberBigInt) > 0 || BI_MAX_INT
        .compareTo(this._numberBigInt) < 0)
        reportOverflowInt(); 
      this._numberInt = this._numberBigInt.intValue();
    } else if ((this._numTypesValid & 0x8) != 0) {
      if (this._numberDouble < -2.147483648E9D || this._numberDouble > 2.147483647E9D)
        reportOverflowInt(); 
      this._numberInt = (int)this._numberDouble;
    } else if ((this._numTypesValid & 0x20) != 0) {
      if (this._numberFloat < -2.147483648E9D || this._numberFloat > 2.147483647E9D)
        reportOverflowInt(); 
      this._numberInt = (int)this._numberFloat;
    } else if ((this._numTypesValid & 0x10) != 0) {
      if (BD_MIN_INT.compareTo(this._numberBigDecimal) > 0 || BD_MAX_INT
        .compareTo(this._numberBigDecimal) < 0)
        reportOverflowInt(); 
      this._numberInt = this._numberBigDecimal.intValue();
    } else {
      _throwInternal();
    } 
    this._numTypesValid |= 0x1;
  }
  
  protected final void convertNumberToLong() throws IOException {
    int v = this._numTypesValid;
    if ((v & true) != 0) {
      this._numberLong = this._numberInt;
    } else if ((v & 0x4) != 0) {
      if (BI_MIN_LONG.compareTo(this._numberBigInt) > 0 || BI_MAX_LONG
        .compareTo(this._numberBigInt) < 0)
        reportOverflowLong(); 
      this._numberLong = this._numberBigInt.longValue();
    } else if ((v & 0x8) != 0) {
      if (this._numberDouble < -9.223372036854776E18D || this._numberDouble > 9.223372036854776E18D)
        reportOverflowLong(); 
      this._numberLong = (long)this._numberDouble;
    } else if ((v & 0x20) != 0) {
      if (this._numberFloat < -9.223372036854776E18D || this._numberFloat > 9.223372036854776E18D)
        reportOverflowInt(); 
      this._numberLong = (long)this._numberFloat;
    } else if ((v & 0x10) != 0) {
      if (BD_MIN_LONG.compareTo(this._numberBigDecimal) > 0 || BD_MAX_LONG
        .compareTo(this._numberBigDecimal) < 0)
        reportOverflowLong(); 
      this._numberLong = this._numberBigDecimal.longValue();
    } else {
      _throwInternal();
    } 
    this._numTypesValid |= 0x2;
  }
  
  protected final void convertNumberToBigInteger() throws IOException {
    if ((this._numTypesValid & 0x10) != 0) {
      streamReadConstraints().validateBigIntegerScale(this._numberBigDecimal.scale());
      this._numberBigInt = this._numberBigDecimal.toBigInteger();
    } else if ((this._numTypesValid & 0x2) != 0) {
      this._numberBigInt = BigInteger.valueOf(this._numberLong);
    } else if ((this._numTypesValid & true) != 0) {
      this._numberBigInt = BigInteger.valueOf(this._numberInt);
    } else if ((this._numTypesValid & 0x8) != 0) {
      this._numberBigInt = BigDecimal.valueOf(this._numberDouble).toBigInteger();
    } else if ((this._numTypesValid & 0x20) != 0) {
      this._numberBigInt = BigDecimal.valueOf(this._numberFloat).toBigInteger();
    } else {
      _throwInternal();
    } 
    this._numTypesValid |= 0x4;
  }
  
  protected final void convertNumberToFloat() throws IOException {
    if ((this._numTypesValid & 0x10) != 0) {
      this._numberFloat = this._numberBigDecimal.floatValue();
    } else if ((this._numTypesValid & 0x4) != 0) {
      this._numberFloat = this._numberBigInt.floatValue();
    } else if ((this._numTypesValid & 0x8) != 0) {
      this._numberFloat = (float)this._numberDouble;
    } else if ((this._numTypesValid & 0x2) != 0) {
      this._numberFloat = (float)this._numberLong;
    } else if ((this._numTypesValid & true) != 0) {
      this._numberFloat = this._numberInt;
    } else {
      _throwInternal();
    } 
    this._numTypesValid |= 0x20;
  }
  
  protected final void convertNumberToDouble() throws IOException {
    if ((this._numTypesValid & 0x10) != 0) {
      this._numberDouble = this._numberBigDecimal.doubleValue();
    } else if ((this._numTypesValid & 0x20) != 0) {
      this._numberDouble = this._numberFloat;
    } else if ((this._numTypesValid & 0x4) != 0) {
      this._numberDouble = this._numberBigInt.doubleValue();
    } else if ((this._numTypesValid & 0x2) != 0) {
      this._numberDouble = this._numberLong;
    } else if ((this._numTypesValid & true) != 0) {
      this._numberDouble = this._numberInt;
    } else {
      _throwInternal();
    } 
    this._numTypesValid |= 0x8;
  }
  
  protected final void convertNumberToBigDecimal() throws IOException {
    if ((this._numTypesValid & 0x28) != 0) {
      String text = getText();
      streamReadConstraints().validateFPLength(text.length());
      this._numberBigDecimal = NumberInput.parseBigDecimal(text, 
          isEnabled(StreamReadFeature.USE_FAST_BIG_NUMBER_PARSER));
    } else if ((this._numTypesValid & 0x4) != 0) {
      this._numberBigDecimal = new BigDecimal(this._numberBigInt);
    } else if ((this._numTypesValid & 0x2) != 0) {
      this._numberBigDecimal = BigDecimal.valueOf(this._numberLong);
    } else if ((this._numTypesValid & true) != 0) {
      this._numberBigDecimal = BigDecimal.valueOf(this._numberInt);
    } else {
      _throwInternal();
    } 
    this._numTypesValid |= 0x10;
  }
  
  protected void _handleEOF() throws IOException {
    if (!this._streamReadContext.inRoot()) {
      String marker = this._streamReadContext.inArray() ? "Array" : "Object";
      _reportInvalidEOF(String.format(": expected close marker for %s (start marker at %s)", new Object[] { marker, this._streamReadContext

              
              .startLocation(_sourceReference()) }), null);
    } 
  }
  
  protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException {
    JsonReadContext ctxt = getParsingContext();
    _reportError(String.format("Unexpected close marker '%s': expected '%c' (for %s starting at %s)", new Object[] { Character.valueOf((char)actCh), Character.valueOf(expCh), ctxt.typeDesc(), ctxt.startLocation(_sourceReference()) }));
  }
  
  protected ContentReference _sourceReference() {
    if (isEnabled(StreamReadFeature.INCLUDE_SOURCE_IN_LOCATION))
      return this._ioContext.contentReference(); 
    return ContentReference.unknown();
  }
  
  protected abstract void _closeInput() throws IOException;
  
  protected abstract void _parseNumericValue() throws IOException;
  
  protected abstract void _releaseBuffers2() throws IOException;
}
