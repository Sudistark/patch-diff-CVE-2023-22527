package com.fasterxml.jackson.dataformat.smile;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.ObjectCodec;
import com.fasterxml.jackson.core.format.InputAccessor;
import com.fasterxml.jackson.core.format.MatchStrength;
import com.fasterxml.jackson.core.io.IOContext;
import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;
import java.io.IOException;
import java.io.InputStream;

public class SmileParserBootstrapper {
  protected final IOContext _context;
  
  protected final InputStream _in;
  
  protected final byte[] _inputBuffer;
  
  protected int _inputPtr;
  
  protected int _inputEnd;
  
  protected final boolean _bufferRecyclable;
  
  protected int _inputProcessed;
  
  public SmileParserBootstrapper(IOContext ctxt, InputStream in) {
    this._context = ctxt;
    this._in = in;
    this._inputBuffer = ctxt.allocReadIOBuffer();
    this._inputEnd = this._inputPtr = 0;
    this._inputProcessed = 0;
    this._bufferRecyclable = true;
  }
  
  public SmileParserBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen) {
    this._context = ctxt;
    this._in = null;
    this._inputBuffer = inputBuffer;
    this._inputPtr = inputStart;
    this._inputEnd = inputStart + inputLen;
    this._inputProcessed = -inputStart;
    this._bufferRecyclable = false;
  }
  
  public SmileParser constructParser(int factoryFeatures, int generalParserFeatures, int smileFeatures, ObjectCodec codec, ByteQuadsCanonicalizer rootByteSymbols) throws IOException, JsonParseException {
    ByteQuadsCanonicalizer can = rootByteSymbols.makeChildOrPlaceholder(factoryFeatures);
    int end = this._inputEnd;
    if (this._inputPtr < end && this._in != null) {
      int count = this._in.read(this._inputBuffer, end, this._inputBuffer.length - end);
      if (count > 0)
        this._inputEnd += count; 
    } 
    SmileParser p = new SmileParser(this._context, generalParserFeatures, smileFeatures, codec, can, this._in, this._inputBuffer, this._inputPtr, this._inputEnd, this._bufferRecyclable);
    boolean hadSig = false;
    if (this._inputPtr >= this._inputEnd)
      return p; 
    byte firstByte = this._inputBuffer[this._inputPtr];
    if (firstByte == 58)
      hadSig = p.handleSignature(true, true); 
    if (!hadSig && SmileParser.Feature.REQUIRE_HEADER.enabledIn(smileFeatures)) {
      String msg;
      if (firstByte == 123 || firstByte == 91) {
        msg = "Input does not start with Smile format header (first byte = 0x" + Integer.toHexString(firstByte & 0xFF) + ") -- rather, it starts with '" + (char)firstByte + "' (plain JSON input?) -- can not parse";
      } else {
        msg = "Input does not start with Smile format header (first byte = 0x" + Integer.toHexString(firstByte & 0xFF) + ") and parser has REQUIRE_HEADER enabled: can not parse";
      } 
      throw new JsonParseException(p, msg);
    } 
    return p;
  }
  
  public static MatchStrength hasSmileFormat(InputAccessor acc) throws IOException {
    if (!acc.hasMoreBytes())
      return MatchStrength.INCONCLUSIVE; 
    byte b1 = acc.nextByte();
    if (!acc.hasMoreBytes())
      return MatchStrength.INCONCLUSIVE; 
    byte b2 = acc.nextByte();
    if (b1 == 58) {
      if (b2 != 41)
        return MatchStrength.NO_MATCH; 
      if (!acc.hasMoreBytes())
        return MatchStrength.INCONCLUSIVE; 
      return (acc.nextByte() == 10) ? MatchStrength.FULL_MATCH : MatchStrength.NO_MATCH;
    } 
    if (b1 == -6) {
      if (b2 == 52)
        return MatchStrength.SOLID_MATCH; 
      int ch = b2 & 0xFF;
      if (ch >= 128 && ch < 248)
        return MatchStrength.SOLID_MATCH; 
      return MatchStrength.NO_MATCH;
    } 
    if (b1 == -8) {
      if (!acc.hasMoreBytes())
        return MatchStrength.INCONCLUSIVE; 
      if (likelySmileValue(b2) || possibleSmileValue(b2, true))
        return MatchStrength.SOLID_MATCH; 
      return MatchStrength.NO_MATCH;
    } 
    if (likelySmileValue(b1) || possibleSmileValue(b2, false))
      return MatchStrength.SOLID_MATCH; 
    return MatchStrength.NO_MATCH;
  }
  
  private static boolean likelySmileValue(byte b) {
    if (b == -32 || b == -28 || b == -24 || b == -8 || b == -6)
      return true; 
    int ch = b & 0xFF;
    if (ch >= 128 && ch <= 159)
      return true; 
    return false;
  }
  
  private static boolean possibleSmileValue(byte b, boolean lenient) {
    int ch = b & 0xFF;
    if (ch >= 128)
      return (ch <= 224); 
    if (lenient) {
      if (ch >= 64)
        return true; 
      if (ch >= 32)
        return (ch < 44); 
    } 
    return false;
  }
}
