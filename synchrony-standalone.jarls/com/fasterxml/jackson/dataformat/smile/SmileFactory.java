package com.fasterxml.jackson.dataformat.smile;

import com.fasterxml.jackson.core.JsonEncoding;
import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonGenerationException;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.ObjectCodec;
import com.fasterxml.jackson.core.TSFBuilder;
import com.fasterxml.jackson.core.Version;
import com.fasterxml.jackson.core.format.InputAccessor;
import com.fasterxml.jackson.core.format.MatchStrength;
import com.fasterxml.jackson.core.io.IOContext;
import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;
import com.fasterxml.jackson.dataformat.smile.async.NonBlockingByteArrayParser;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import java.net.URL;

public class SmileFactory extends JsonFactory {
  private static final long serialVersionUID = 1L;
  
  public static final String FORMAT_NAME_SMILE = "Smile";
  
  static final int DEFAULT_SMILE_PARSER_FEATURE_FLAGS = SmileParser.Feature.collectDefaults();
  
  static final int DEFAULT_SMILE_GENERATOR_FEATURE_FLAGS = SmileGenerator.Feature.collectDefaults();
  
  protected boolean _cfgDelegateToTextual;
  
  protected int _smileParserFeatures;
  
  protected int _smileGeneratorFeatures;
  
  public SmileFactory() { this((ObjectCodec)null); }
  
  public SmileFactory(ObjectCodec oc) {
    super(oc);
    this._smileParserFeatures = DEFAULT_SMILE_PARSER_FEATURE_FLAGS;
    this._smileGeneratorFeatures = DEFAULT_SMILE_GENERATOR_FEATURE_FLAGS;
  }
  
  public SmileFactory(SmileFactory src, ObjectCodec oc) {
    super(src, oc);
    this._cfgDelegateToTextual = src._cfgDelegateToTextual;
    this._smileParserFeatures = src._smileParserFeatures;
    this._smileGeneratorFeatures = src._smileGeneratorFeatures;
  }
  
  protected SmileFactory(SmileFactoryBuilder b) {
    super(b, false);
    this._smileParserFeatures = b.formatParserFeaturesMask();
    this._smileGeneratorFeatures = b.formatGeneratorFeaturesMask();
  }
  
  public SmileFactoryBuilder rebuild() { return new SmileFactoryBuilder(this); }
  
  public static SmileFactoryBuilder builder() { return new SmileFactoryBuilder(); }
  
  public SmileFactory copy() {
    _checkInvalidCopy(SmileFactory.class);
    return new SmileFactory(this, null);
  }
  
  public void delegateToTextual(boolean state) { this._cfgDelegateToTextual = state; }
  
  protected Object readResolve() { return new SmileFactory(this, this._objectCodec); }
  
  public Version version() { return PackageVersion.VERSION; }
  
  public String getFormatName() { return "Smile"; }
  
  public MatchStrength hasFormat(InputAccessor acc) throws IOException { return SmileParserBootstrapper.hasSmileFormat(acc); }
  
  public boolean canUseCharArrays() { return false; }
  
  public boolean canHandleBinaryNatively() { return true; }
  
  public boolean canParseAsync() { return true; }
  
  public Class<SmileParser.Feature> getFormatReadFeatureType() { return SmileParser.Feature.class; }
  
  public Class<SmileGenerator.Feature> getFormatWriteFeatureType() { return SmileGenerator.Feature.class; }
  
  public final SmileFactory configure(SmileParser.Feature f, boolean state) {
    if (state) {
      enable(f);
    } else {
      disable(f);
    } 
    return this;
  }
  
  public SmileFactory enable(SmileParser.Feature f) {
    this._smileParserFeatures |= f.getMask();
    return this;
  }
  
  public SmileFactory disable(SmileParser.Feature f) {
    this._smileParserFeatures &= (f.getMask() ^ 0xFFFFFFFF);
    return this;
  }
  
  public final boolean isEnabled(SmileParser.Feature f) { return ((this._smileParserFeatures & f.getMask()) != 0); }
  
  public int getFormatParserFeatures() { return this._smileParserFeatures; }
  
  public final SmileFactory configure(SmileGenerator.Feature f, boolean state) {
    if (state) {
      enable(f);
    } else {
      disable(f);
    } 
    return this;
  }
  
  public SmileFactory enable(SmileGenerator.Feature f) {
    this._smileGeneratorFeatures |= f.getMask();
    return this;
  }
  
  public SmileFactory disable(SmileGenerator.Feature f) {
    this._smileGeneratorFeatures &= (f.getMask() ^ 0xFFFFFFFF);
    return this;
  }
  
  public final boolean isEnabled(SmileGenerator.Feature f) { return ((this._smileGeneratorFeatures & f.getMask()) != 0); }
  
  public int getFormatGeneratorFeatures() { return this._smileGeneratorFeatures; }
  
  public SmileParser createParser(File f) throws IOException {
    IOContext ctxt = _createContext(_createContentReference(f), true);
    return _createParser(_decorate(new FileInputStream(f), ctxt), ctxt);
  }
  
  public SmileParser createParser(URL url) throws IOException {
    IOContext ctxt = _createContext(_createContentReference(url), true);
    return _createParser(_decorate(_optimizedStreamFromURL(url), ctxt), ctxt);
  }
  
  public SmileParser createParser(InputStream in) throws IOException {
    IOContext ctxt = _createContext(_createContentReference(in), false);
    return _createParser(_decorate(in, ctxt), ctxt);
  }
  
  public SmileParser createParser(byte[] data) throws IOException { return createParser(data, 0, data.length); }
  
  public SmileParser createParser(byte[] data, int offset, int len) throws IOException {
    IOContext ctxt = _createContext(_createContentReference(data, offset, len), true);
    if (this._inputDecorator != null) {
      InputStream in = this._inputDecorator.decorate(ctxt, data, 0, data.length);
      if (in != null)
        return _createParser(in, ctxt); 
    } 
    return _createParser(data, offset, len, ctxt);
  }
  
  public SmileGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException {
    IOContext ctxt = _createContext(_createContentReference(out), false);
    return _createGenerator(_decorate(out, ctxt), ctxt);
  }
  
  public SmileGenerator createGenerator(OutputStream out) throws IOException {
    IOContext ctxt = _createContext(_createContentReference(out), false);
    return _createGenerator(_decorate(out, ctxt), ctxt);
  }
  
  public NonBlockingByteArrayParser createNonBlockingByteArrayParser() throws IOException {
    IOContext ctxt = _createContext(null, false);
    ByteQuadsCanonicalizer can = this._byteSymbolCanonicalizer.makeChild(this._factoryFeatures);
    return new NonBlockingByteArrayParser(ctxt, this._parserFeatures, this._smileParserFeatures, can);
  }
  
  protected SmileParser _createParser(InputStream in, IOContext ctxt) throws IOException {
    SmileParserBootstrapper bs = new SmileParserBootstrapper(ctxt, in);
    return bs.constructParser(this._factoryFeatures, this._parserFeatures, this._smileParserFeatures, this._objectCodec, this._byteSymbolCanonicalizer);
  }
  
  protected JsonParser _createParser(Reader r, IOContext ctxt) throws IOException {
    if (this._cfgDelegateToTextual)
      return super._createParser(r, ctxt); 
    return (JsonParser)_nonByteSource();
  }
  
  protected JsonParser _createParser(char[] data, int offset, int len, IOContext ctxt, boolean recyclable) throws IOException {
    if (this._cfgDelegateToTextual)
      return super._createParser(data, offset, len, ctxt, recyclable); 
    return (JsonParser)_nonByteSource();
  }
  
  protected SmileParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException { return (new SmileParserBootstrapper(ctxt, data, offset, len)).constructParser(this._factoryFeatures, this._parserFeatures, this._smileParserFeatures, this._objectCodec, this._byteSymbolCanonicalizer); }
  
  protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException {
    if (this._cfgDelegateToTextual)
      return super._createGenerator(out, ctxt); 
    return (JsonGenerator)_nonByteTarget();
  }
  
  protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException { return _createGenerator(out, ctxt); }
  
  protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException {
    if (this._cfgDelegateToTextual)
      return super._createWriter(out, enc, ctxt); 
    return (Writer)_nonByteTarget();
  }
  
  protected <T> T _nonByteSource() throws IOException { throw new UnsupportedOperationException("Can not create parser for character-based (not byte-based) source"); }
  
  protected <T> T _nonByteTarget() throws IOException { throw new UnsupportedOperationException("Can not create generator for character-based (not byte-based) target"); }
  
  protected SmileGenerator _createGenerator(OutputStream out, IOContext ctxt) throws IOException {
    int feats = this._smileGeneratorFeatures;
    SmileGenerator gen = new SmileGenerator(ctxt, this._generatorFeatures, feats, this._objectCodec, out);
    if ((feats & SmileGenerator.Feature.WRITE_HEADER.getMask()) != 0) {
      gen.writeHeader();
    } else {
      if ((feats & SmileGenerator.Feature.CHECK_SHARED_STRING_VALUES.getMask()) != 0)
        throw new JsonGenerationException("Inconsistent settings: WRITE_HEADER disabled, but CHECK_SHARED_STRING_VALUES enabled; can not construct generator due to possible data loss (either enable WRITE_HEADER, or disable CHECK_SHARED_STRING_VALUES to resolve)", gen); 
      if ((feats & SmileGenerator.Feature.ENCODE_BINARY_AS_7BIT.getMask()) == 0)
        throw new JsonGenerationException("Inconsistent settings: WRITE_HEADER disabled, but ENCODE_BINARY_AS_7BIT disabled; can not construct generator due to possible data loss (either enable WRITE_HEADER, or ENCODE_BINARY_AS_7BIT to resolve)", gen); 
    } 
    return gen;
  }
}
