package com.fasterxml.jackson.databind.jsontype.impl;

import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.databind.AnnotationIntrospector;
import com.fasterxml.jackson.databind.DeserializationConfig;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.SerializationConfig;
import com.fasterxml.jackson.databind.cfg.MapperConfig;
import com.fasterxml.jackson.databind.introspect.AnnotatedClass;
import com.fasterxml.jackson.databind.introspect.AnnotatedClassResolver;
import com.fasterxml.jackson.databind.jsontype.NamedType;
import com.fasterxml.jackson.databind.jsontype.PolymorphicTypeValidator;
import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;
import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;
import com.fasterxml.jackson.databind.jsontype.TypeSerializer;
import com.fasterxml.jackson.databind.util.ClassUtil;
import java.util.Collection;

public class StdTypeResolverBuilder extends Object implements TypeResolverBuilder<StdTypeResolverBuilder> {
  protected JsonTypeInfo.Id _idType;
  
  protected JsonTypeInfo.As _includeAs;
  
  protected String _typeProperty;
  
  protected boolean _typeIdVisible = false;
  
  protected Class<?> _defaultImpl;
  
  protected TypeIdResolver _customIdResolver;
  
  protected StdTypeResolverBuilder(JsonTypeInfo.Id idType, JsonTypeInfo.As idAs, String propName) {
    this._idType = idType;
    this._includeAs = idAs;
    this._typeProperty = propName;
  }
  
  protected StdTypeResolverBuilder(StdTypeResolverBuilder base, Class<?> defaultImpl) {
    this._idType = base._idType;
    this._includeAs = base._includeAs;
    this._typeProperty = base._typeProperty;
    this._typeIdVisible = base._typeIdVisible;
    this._customIdResolver = base._customIdResolver;
    this._defaultImpl = defaultImpl;
  }
  
  public static StdTypeResolverBuilder noTypeInfoBuilder() { return (new StdTypeResolverBuilder()).init(JsonTypeInfo.Id.NONE, null); }
  
  public StdTypeResolverBuilder init(JsonTypeInfo.Id idType, TypeIdResolver idRes) {
    if (idType == null)
      throw new IllegalArgumentException("idType cannot be null"); 
    this._idType = idType;
    this._customIdResolver = idRes;
    this._typeProperty = idType.getDefaultPropertyName();
    return this;
  }
  
  public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (this._idType == JsonTypeInfo.Id.NONE)
      return null; 
    if (baseType.isPrimitive())
      if (!allowPrimitiveTypes(config, baseType))
        return null;  
    if (this._idType == JsonTypeInfo.Id.DEDUCTION)
      return AsDeductionTypeSerializer.instance(); 
    TypeIdResolver idRes = idResolver(config, baseType, subTypeValidator(config), subtypes, true, false);
    switch (null.$SwitchMap$com$fasterxml$jackson$annotation$JsonTypeInfo$As[this._includeAs.ordinal()]) {
      case 1:
        return new AsArrayTypeSerializer(idRes, null);
      case 2:
        return new AsPropertyTypeSerializer(idRes, null, this._typeProperty);
      case 3:
        return new AsWrapperTypeSerializer(idRes, null);
      case 4:
        return new AsExternalTypeSerializer(idRes, null, this._typeProperty);
      case 5:
        return new AsExistingPropertyTypeSerializer(idRes, null, this._typeProperty);
    } 
    throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + this._includeAs);
  }
  
  public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {
    if (this._idType == JsonTypeInfo.Id.NONE)
      return null; 
    if (baseType.isPrimitive())
      if (!allowPrimitiveTypes(config, baseType))
        return null;  
    PolymorphicTypeValidator subTypeValidator = verifyBaseTypeValidity(config, baseType);
    TypeIdResolver idRes = idResolver(config, baseType, subTypeValidator, subtypes, false, true);
    JavaType defaultImpl = defineDefaultImpl(config, baseType);
    if (this._idType == JsonTypeInfo.Id.DEDUCTION)
      return new AsDeductionTypeDeserializer(baseType, idRes, defaultImpl, config, subtypes); 
    switch (null.$SwitchMap$com$fasterxml$jackson$annotation$JsonTypeInfo$As[this._includeAs.ordinal()]) {
      case 1:
        return new AsArrayTypeDeserializer(baseType, idRes, this._typeProperty, this._typeIdVisible, defaultImpl);
      case 2:
      case 5:
        return new AsPropertyTypeDeserializer(baseType, idRes, this._typeProperty, this._typeIdVisible, defaultImpl, this._includeAs, 
            
            _strictTypeIdHandling(config, baseType));
      case 3:
        return new AsWrapperTypeDeserializer(baseType, idRes, this._typeProperty, this._typeIdVisible, defaultImpl);
      case 4:
        return new AsExternalTypeDeserializer(baseType, idRes, this._typeProperty, this._typeIdVisible, defaultImpl);
    } 
    throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + this._includeAs);
  }
  
  protected JavaType defineDefaultImpl(DeserializationConfig config, JavaType baseType) {
    if (this._defaultImpl != null) {
      if (this._defaultImpl == Void.class || this._defaultImpl == com.fasterxml.jackson.databind.annotation.NoClass.class)
        return config.getTypeFactory().constructType(this._defaultImpl); 
      if (baseType.hasRawClass(this._defaultImpl))
        return baseType; 
      if (baseType.isTypeOrSuperTypeOf(this._defaultImpl))
        return config.getTypeFactory()
          .constructSpecializedType(baseType, this._defaultImpl); 
      if (baseType.hasRawClass(this._defaultImpl))
        return baseType; 
    } 
    if (config.isEnabled(MapperFeature.USE_BASE_TYPE_AS_DEFAULT_IMPL) && 
      !baseType.isAbstract())
      return baseType; 
    return null;
  }
  
  public StdTypeResolverBuilder inclusion(JsonTypeInfo.As includeAs) {
    if (includeAs == null)
      throw new IllegalArgumentException("includeAs cannot be null"); 
    this._includeAs = includeAs;
    return this;
  }
  
  public StdTypeResolverBuilder typeProperty(String typeIdPropName) {
    if (typeIdPropName == null || typeIdPropName.isEmpty())
      typeIdPropName = this._idType.getDefaultPropertyName(); 
    this._typeProperty = typeIdPropName;
    return this;
  }
  
  public StdTypeResolverBuilder defaultImpl(Class<?> defaultImpl) {
    this._defaultImpl = defaultImpl;
    return this;
  }
  
  public StdTypeResolverBuilder typeIdVisibility(boolean isVisible) {
    this._typeIdVisible = isVisible;
    return this;
  }
  
  public StdTypeResolverBuilder withDefaultImpl(Class<?> defaultImpl) {
    if (this._defaultImpl == defaultImpl)
      return this; 
    ClassUtil.verifyMustOverride(StdTypeResolverBuilder.class, this, "withDefaultImpl");
    return new StdTypeResolverBuilder(this, defaultImpl);
  }
  
  public Class<?> getDefaultImpl() { return this._defaultImpl; }
  
  public String getTypeProperty() { return this._typeProperty; }
  
  public boolean isTypeIdVisible() { return this._typeIdVisible; }
  
  protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, PolymorphicTypeValidator subtypeValidator, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) {
    if (this._customIdResolver != null)
      return this._customIdResolver; 
    if (this._idType == null)
      throw new IllegalStateException("Cannot build, 'init()' not yet called"); 
    switch (null.$SwitchMap$com$fasterxml$jackson$annotation$JsonTypeInfo$Id[this._idType.ordinal()]) {
      case 1:
      case 2:
        return ClassNameIdResolver.construct(baseType, config, subtypeValidator);
      case 3:
        return MinimalClassNameIdResolver.construct(baseType, config, subtypeValidator);
      case 4:
        return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser);
      case 5:
        return null;
    } 
    throw new IllegalStateException("Do not know how to construct standard type id resolver for idType: " + this._idType);
  }
  
  public PolymorphicTypeValidator subTypeValidator(MapperConfig<?> config) { return config.getPolymorphicTypeValidator(); }
  
  protected PolymorphicTypeValidator verifyBaseTypeValidity(MapperConfig<?> config, JavaType baseType) {
    PolymorphicTypeValidator ptv = subTypeValidator(config);
    if (this._idType == JsonTypeInfo.Id.CLASS || this._idType == JsonTypeInfo.Id.MINIMAL_CLASS) {
      PolymorphicTypeValidator.Validity validity = ptv.validateBaseType(config, baseType);
      if (validity == PolymorphicTypeValidator.Validity.DENIED)
        return reportInvalidBaseType(config, baseType, ptv); 
      if (validity == PolymorphicTypeValidator.Validity.ALLOWED)
        return LaissezFaireSubTypeValidator.instance; 
    } 
    return ptv;
  }
  
  protected PolymorphicTypeValidator reportInvalidBaseType(MapperConfig<?> config, JavaType baseType, PolymorphicTypeValidator ptv) {
    throw new IllegalArgumentException(String.format("Configured `PolymorphicTypeValidator` (of type %s) denied resolution of all subtypes of base type %s", new Object[] { ClassUtil.classNameOf(ptv), ClassUtil.classNameOf(baseType.getRawClass()) }));
  }
  
  protected boolean allowPrimitiveTypes(MapperConfig<?> config, JavaType baseType) { return false; }
  
  protected boolean _strictTypeIdHandling(DeserializationConfig config, JavaType baseType) {
    if (config.isEnabled(MapperFeature.REQUIRE_TYPE_ID_FOR_SUBTYPES))
      return true; 
    return _hasTypeResolver(config, baseType);
  }
  
  protected boolean _hasTypeResolver(DeserializationConfig config, JavaType baseType) {
    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, baseType.getRawClass());
    AnnotationIntrospector ai = config.getAnnotationIntrospector();
    return (ai.findTypeResolver(config, ac, baseType) != null);
  }
  
  public StdTypeResolverBuilder() {}
}
