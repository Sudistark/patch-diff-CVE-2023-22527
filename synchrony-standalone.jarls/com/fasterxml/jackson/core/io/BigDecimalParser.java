package com.fasterxml.jackson.core.io;

import com.fasterxml.jackson.core.io.doubleparser.JavaBigDecimalParser;
import java.math.BigDecimal;
import java.util.Arrays;

public final class BigDecimalParser {
  static final int MAX_CHARS_TO_REPORT = 1000;
  
  public static BigDecimal parse(String valueStr) { return parse(valueStr.toCharArray()); }
  
  public static BigDecimal parse(char[] chars, int off, int len) {
    try {
      if (len < 500)
        return new BigDecimal(chars, off, len); 
      return parseBigDecimal(chars, off, len, len / 10);
    } catch (ArithmeticException|NumberFormatException e) {
      String stringToReport, desc = e.getMessage();
      if (desc == null)
        desc = "Not a valid number representation"; 
      if (len <= 1000) {
        stringToReport = new String(chars, off, len);
      } else {
        stringToReport = new String(Arrays.copyOfRange(chars, off, 1000)) + "(truncated, full length is " + chars.length + " chars)";
      } 
      throw new NumberFormatException("Value \"" + stringToReport + "\" can not be represented as `java.math.BigDecimal`, reason: " + desc);
    } 
  }
  
  public static BigDecimal parse(char[] chars) { return parse(chars, 0, chars.length); }
  
  public static BigDecimal parseWithFastParser(String valueStr) {
    try {
      return JavaBigDecimalParser.parseBigDecimal(valueStr);
    } catch (NumberFormatException nfe) {
      String reportNum = (valueStr.length() <= 1000) ? valueStr : (valueStr.substring(0, 1000) + " [truncated]");
      throw new NumberFormatException("Value \"" + reportNum + "\" can not be represented as `java.math.BigDecimal`, reason: " + nfe
          .getMessage());
    } 
  }
  
  public static BigDecimal parseWithFastParser(char[] ch, int off, int len) {
    try {
      return JavaBigDecimalParser.parseBigDecimal(ch, off, len);
    } catch (NumberFormatException nfe) {
      String reportNum = (len <= 1000) ? new String(ch, off, len) : (new String(ch, off, 1000) + " [truncated]");
      throw new NumberFormatException("Value \"" + reportNum + "\" can not be represented as `java.math.BigDecimal`, reason: " + nfe
          .getMessage());
    } 
  }
  
  private static BigDecimal parseBigDecimal(char[] chars, int off, int len, int splitLen) {
    BigDecimal res;
    boolean numHasSign = false;
    boolean expHasSign = false;
    boolean neg = false;
    int numIdx = off;
    int expIdx = -1;
    int dotIdx = -1;
    int scale = 0;
    int endIdx = off + len;
    int numEndIdx;
    for (numEndIdx = off; numEndIdx < endIdx; numEndIdx++) {
      char c = chars[numEndIdx];
      switch (c) {
        case '+':
          if (expIdx >= 0) {
            if (expHasSign)
              throw new NumberFormatException("Multiple signs in exponent"); 
            expHasSign = true;
            break;
          } 
          if (numHasSign)
            throw new NumberFormatException("Multiple signs in number"); 
          numHasSign = true;
          numIdx = numEndIdx + 1;
          break;
        case '-':
          if (expIdx >= 0) {
            if (expHasSign)
              throw new NumberFormatException("Multiple signs in exponent"); 
            expHasSign = true;
            break;
          } 
          if (numHasSign)
            throw new NumberFormatException("Multiple signs in number"); 
          numHasSign = true;
          neg = true;
          numIdx = numEndIdx + 1;
          break;
        case 'E':
        case 'e':
          if (expIdx >= 0)
            throw new NumberFormatException("Multiple exponent markers"); 
          expIdx = numEndIdx;
          break;
        case '.':
          if (dotIdx >= 0)
            throw new NumberFormatException("Multiple decimal points"); 
          dotIdx = numEndIdx;
          break;
        default:
          if (dotIdx >= 0 && expIdx == -1)
            scale++; 
          break;
      } 
    } 
    int exp = 0;
    if (expIdx >= 0) {
      int numEndIdx = expIdx;
      res = new String(chars, expIdx + 1, endIdx - expIdx - 1);
      exp = Integer.parseInt(res);
      scale = adjustScale(scale, exp);
    } else {
      numEndIdx = endIdx;
    } 
    if (dotIdx >= 0) {
      int leftLen = dotIdx - numIdx;
      BigDecimal left = toBigDecimalRec(chars, numIdx, leftLen, exp, splitLen);
      int rightLen = numEndIdx - dotIdx - 1;
      BigDecimal right = toBigDecimalRec(chars, dotIdx + 1, rightLen, exp - rightLen, splitLen);
      res = left.add(right);
    } else {
      res = toBigDecimalRec(chars, numIdx, numEndIdx - numIdx, exp, splitLen);
    } 
    if (scale != 0)
      res = res.setScale(scale); 
    if (neg)
      res = res.negate(); 
    return res;
  }
  
  private static int adjustScale(int scale, long exp) {
    long adjScale = scale - exp;
    if (adjScale > 2147483647L || adjScale < -2147483648L)
      throw new NumberFormatException("Scale out of range: " + adjScale + " while adjusting scale " + scale + " to exponent " + exp); 
    return (int)adjScale;
  }
  
  private static BigDecimal toBigDecimalRec(char[] chars, int off, int len, int scale, int splitLen) {
    if (len > splitLen) {
      int mid = len / 2;
      BigDecimal left = toBigDecimalRec(chars, off, mid, scale + len - mid, splitLen);
      BigDecimal right = toBigDecimalRec(chars, off + mid, len - mid, scale, splitLen);
      return left.add(right);
    } 
    if (len == 0)
      return BigDecimal.ZERO; 
    return (new BigDecimal(chars, off, len))
      
      .scaleByPowerOfTen(scale);
  }
}
