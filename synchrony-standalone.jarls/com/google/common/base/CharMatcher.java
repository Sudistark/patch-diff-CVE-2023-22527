package com.google.common.base;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import java.util.BitSet;
import java.util.function.Predicate;

@ElementTypesAreNonnullByDefault
@GwtCompatible(emulated = true)
public abstract class CharMatcher extends Object implements Predicate<Character> {
  private static final int DISTINCT_CHARS = 65536;
  
  public static CharMatcher any() { return Any.INSTANCE; }
  
  public static CharMatcher none() { return None.INSTANCE; }
  
  public static CharMatcher whitespace() { return Whitespace.INSTANCE; }
  
  public static CharMatcher breakingWhitespace() { return BreakingWhitespace.INSTANCE; }
  
  public static CharMatcher ascii() { return Ascii.INSTANCE; }
  
  @Deprecated
  public static CharMatcher digit() { return Digit.INSTANCE; }
  
  @Deprecated
  public static CharMatcher javaDigit() { return JavaDigit.INSTANCE; }
  
  @Deprecated
  public static CharMatcher javaLetter() { return JavaLetter.INSTANCE; }
  
  @Deprecated
  public static CharMatcher javaLetterOrDigit() { return JavaLetterOrDigit.INSTANCE; }
  
  @Deprecated
  public static CharMatcher javaUpperCase() { return JavaUpperCase.INSTANCE; }
  
  @Deprecated
  public static CharMatcher javaLowerCase() { return JavaLowerCase.INSTANCE; }
  
  public static CharMatcher javaIsoControl() { return JavaIsoControl.INSTANCE; }
  
  @Deprecated
  public static CharMatcher invisible() { return Invisible.INSTANCE; }
  
  @Deprecated
  public static CharMatcher singleWidth() { return SingleWidth.INSTANCE; }
  
  public static CharMatcher is(char match) { return new Is(match); }
  
  public static CharMatcher isNot(char match) { return new IsNot(match); }
  
  public static CharMatcher anyOf(CharSequence sequence) {
    switch (sequence.length()) {
      case 0:
        return none();
      case 1:
        return is(sequence.charAt(0));
      case 2:
        return isEither(sequence.charAt(0), sequence.charAt(1));
    } 
    return new AnyOf(sequence);
  }
  
  public static CharMatcher noneOf(CharSequence sequence) { return anyOf(sequence).negate(); }
  
  public static CharMatcher inRange(char startInclusive, char endInclusive) { return new InRange(startInclusive, endInclusive); }
  
  public static CharMatcher forPredicate(Predicate<? super Character> predicate) { return (predicate instanceof CharMatcher) ? (CharMatcher)predicate : new ForPredicate(predicate); }
  
  public CharMatcher negate() { return new Negated(this); }
  
  public CharMatcher and(CharMatcher other) { return new And(this, other); }
  
  public CharMatcher or(CharMatcher other) { return new Or(this, other); }
  
  public CharMatcher precomputed() { return Platform.precomputeCharMatcher(this); }
  
  @J2ktIncompatible
  @GwtIncompatible
  CharMatcher precomputedInternal() {
    BitSet table = new BitSet();
    setBits(table);
    int totalCharacters = table.cardinality();
    if (totalCharacters * 2 <= 65536)
      return precomputedPositive(totalCharacters, table, toString()); 
    table.flip(0, 65536);
    int negatedCharacters = 65536 - totalCharacters;
    String suffix = ".negate()";
    String description = toString();
    String negatedDescription = description.endsWith(suffix) ? description.substring(0, description.length() - suffix.length()) : (description + suffix);
    return new Object(this, 
        precomputedPositive(negatedCharacters, table, negatedDescription), description);
  }
  
  @J2ktIncompatible
  @GwtIncompatible
  private static CharMatcher precomputedPositive(int totalCharacters, BitSet table, String description) {
    char c2;
    char c1;
    switch (totalCharacters) {
      case 0:
        return none();
      case 1:
        return is((char)table.nextSetBit(0));
      case 2:
        c1 = (char)table.nextSetBit(0);
        c2 = (char)table.nextSetBit(c1 + '\001');
        return isEither(c1, c2);
    } 
    return isSmall(totalCharacters, table.length()) ? 
      SmallCharMatcher.from(table, description) : 
      new BitSetMatcher(table, description, null);
  }
  
  @J2ktIncompatible
  @GwtIncompatible
  private static boolean isSmall(int totalCharacters, int tableLength) { return (totalCharacters <= 1023 && tableLength > totalCharacters * 4 * 16); }
  
  @J2ktIncompatible
  @GwtIncompatible
  void setBits(BitSet table) {
    for (int c = 65535; c >= 0; c--) {
      if (matches((char)c))
        table.set(c); 
    } 
  }
  
  public boolean matchesAnyOf(CharSequence sequence) { return !matchesNoneOf(sequence); }
  
  public boolean matchesAllOf(CharSequence sequence) {
    for (int i = sequence.length() - 1; i >= 0; i--) {
      if (!matches(sequence.charAt(i)))
        return false; 
    } 
    return true;
  }
  
  public boolean matchesNoneOf(CharSequence sequence) { return (indexIn(sequence) == -1); }
  
  public int indexIn(CharSequence sequence) { return indexIn(sequence, 0); }
  
  public int indexIn(CharSequence sequence, int start) {
    int length = sequence.length();
    Preconditions.checkPositionIndex(start, length);
    for (int i = start; i < length; i++) {
      if (matches(sequence.charAt(i)))
        return i; 
    } 
    return -1;
  }
  
  public int lastIndexIn(CharSequence sequence) {
    for (int i = sequence.length() - 1; i >= 0; i--) {
      if (matches(sequence.charAt(i)))
        return i; 
    } 
    return -1;
  }
  
  public int countIn(CharSequence sequence) {
    int count = 0;
    for (int i = 0; i < sequence.length(); i++) {
      if (matches(sequence.charAt(i)))
        count++; 
    } 
    return count;
  }
  
  public String removeFrom(CharSequence sequence) {
    String string = sequence.toString();
    int pos = indexIn(string);
    if (pos == -1)
      return string; 
    char[] chars = string.toCharArray();
    int spread = 1;
    while (true) {
      pos++;
      while (pos != chars.length) {
        if (matches(chars[pos])) {
          spread++;
          continue;
        } 
        chars[pos - spread] = chars[pos];
        pos++;
      } 
      break;
    } 
    return new String(chars, 0, pos - spread);
  }
  
  public String retainFrom(CharSequence sequence) { return negate().removeFrom(sequence); }
  
  public String replaceFrom(CharSequence sequence, char replacement) {
    String string = sequence.toString();
    int pos = indexIn(string);
    if (pos == -1)
      return string; 
    char[] chars = string.toCharArray();
    chars[pos] = replacement;
    for (int i = pos + 1; i < chars.length; i++) {
      if (matches(chars[i]))
        chars[i] = replacement; 
    } 
    return new String(chars);
  }
  
  public String replaceFrom(CharSequence sequence, CharSequence replacement) {
    int replacementLen = replacement.length();
    if (replacementLen == 0)
      return removeFrom(sequence); 
    if (replacementLen == 1)
      return replaceFrom(sequence, replacement.charAt(0)); 
    String string = sequence.toString();
    int pos = indexIn(string);
    if (pos == -1)
      return string; 
    int len = string.length();
    StringBuilder buf = new StringBuilder(len * 3 / 2 + 16);
    int oldpos = 0;
    do {
      buf.append(string, oldpos, pos);
      buf.append(replacement);
      oldpos = pos + 1;
      pos = indexIn(string, oldpos);
    } while (pos != -1);
    buf.append(string, oldpos, len);
    return buf.toString();
  }
  
  public String trimFrom(CharSequence sequence) {
    int len = sequence.length();
    int first;
    for (first = 0; first < len && 
      matches(sequence.charAt(first)); first++);
    int last;
    for (last = len - 1; last > first && 
      matches(sequence.charAt(last)); last--);
    return sequence.subSequence(first, last + 1).toString();
  }
  
  public String trimLeadingFrom(CharSequence sequence) {
    int len = sequence.length();
    for (int first = 0; first < len; first++) {
      if (!matches(sequence.charAt(first)))
        return sequence.subSequence(first, len).toString(); 
    } 
    return "";
  }
  
  public String trimTrailingFrom(CharSequence sequence) {
    int len = sequence.length();
    for (int last = len - 1; last >= 0; last--) {
      if (!matches(sequence.charAt(last)))
        return sequence.subSequence(0, last + 1).toString(); 
    } 
    return "";
  }
  
  public String collapseFrom(CharSequence sequence, char replacement) {
    int len = sequence.length();
    for (int i = 0; i < len; i++) {
      char c = sequence.charAt(i);
      if (matches(c))
        if (c == replacement && (i == len - 1 || !matches(sequence.charAt(i + 1)))) {
          i++;
        } else {
          StringBuilder builder = (new StringBuilder(len)).append(sequence, 0, i).append(replacement);
          return finishCollapseFrom(sequence, i + 1, len, replacement, builder, true);
        }  
    } 
    return sequence.toString();
  }
  
  public String trimAndCollapseFrom(CharSequence sequence, char replacement) {
    int len = sequence.length();
    int first = 0;
    int last = len - 1;
    while (first < len && matches(sequence.charAt(first)))
      first++; 
    while (last > first && matches(sequence.charAt(last)))
      last--; 
    return (first == 0 && last == len - 1) ? 
      collapseFrom(sequence, replacement) : 
      finishCollapseFrom(sequence, first, last + 1, replacement, new StringBuilder(last + 1 - first), false);
  }
  
  private String finishCollapseFrom(CharSequence sequence, int start, int end, char replacement, StringBuilder builder, boolean inMatchingGroup) {
    for (int i = start; i < end; i++) {
      char c = sequence.charAt(i);
      if (matches(c)) {
        if (!inMatchingGroup) {
          builder.append(replacement);
          inMatchingGroup = true;
        } 
      } else {
        builder.append(c);
        inMatchingGroup = false;
      } 
    } 
    return builder.toString();
  }
  
  @Deprecated
  public boolean apply(Character character) { return matches(character.charValue()); }
  
  public String toString() { return super.toString(); }
  
  private static String showCharacter(char c) {
    String hex = "0123456789ABCDEF";
    char[] tmp = { '\\', 'u', Character.MIN_VALUE, Character.MIN_VALUE, Character.MIN_VALUE, Character.MIN_VALUE };
    for (int i = 0; i < 4; i++) {
      tmp[5 - i] = hex.charAt(c & 0xF);
      c = (char)(c >> '\004');
    } 
    return String.copyValueOf(tmp);
  }
  
  private static IsEither isEither(char c1, char c2) { return new IsEither(c1, c2); }
  
  public abstract boolean matches(char paramChar);
}
