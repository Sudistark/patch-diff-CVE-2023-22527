package com.google.common.io;

import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.errorprone.annotations.concurrent.GuardedBy;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Objects;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@Beta
@J2ktIncompatible
@GwtIncompatible
public final class FileBackedOutputStream extends OutputStream {
  private final int fileThreshold;
  
  private final boolean resetOnFinalize;
  
  private final ByteSource source;
  
  @GuardedBy("this")
  private OutputStream out;
  
  @CheckForNull
  @GuardedBy("this")
  private MemoryOutput memory;
  
  @CheckForNull
  @GuardedBy("this")
  private File file;
  
  @CheckForNull
  @VisibleForTesting
  File getFile() { return this.file; }
  
  public FileBackedOutputStream(int fileThreshold) { this(fileThreshold, false); }
  
  public FileBackedOutputStream(int fileThreshold, boolean resetOnFinalize) {
    Preconditions.checkArgument((fileThreshold >= 0), "fileThreshold must be non-negative, but was %s", fileThreshold);
    this.fileThreshold = fileThreshold;
    this.resetOnFinalize = resetOnFinalize;
    this.memory = new MemoryOutput(null);
    this.out = this.memory;
    if (resetOnFinalize) {
      this.source = new Object(this);
    } else {
      this.source = new Object(this);
    } 
  }
  
  public ByteSource asByteSource() { return this.source; }
  
  private InputStream openInputStream() throws IOException {
    if (this.file != null)
      return new FileInputStream(this.file); 
    Objects.requireNonNull(this.memory);
    return new ByteArrayInputStream(this.memory.getBuffer(), 0, this.memory.getCount());
  }
  
  public void reset() throws IOException {
    try {
      close();
    } finally {
      if (this.memory == null) {
        this.memory = new MemoryOutput(null);
      } else {
        this.memory.reset();
      } 
      this.out = this.memory;
      if (this.file != null) {
        File deleteMe = this.file;
        this.file = null;
        if (!deleteMe.delete())
          throw new IOException("Could not delete: " + deleteMe); 
      } 
    } 
  }
  
  public void write(int b) {
    update(1);
    this.out.write(b);
  }
  
  public void write(byte[] b) throws IOException { write(b, 0, b.length); }
  
  public void write(byte[] b, int off, int len) throws IOException {
    update(len);
    this.out.write(b, off, len);
  }
  
  public void close() throws IOException { this.out.close(); }
  
  public void flush() throws IOException { this.out.flush(); }
  
  @GuardedBy("this")
  private void update(int len) {
    if (this.memory != null && this.memory.getCount() + len > this.fileThreshold) {
      File temp = TempFileCreator.INSTANCE.createTempFile("FileBackedOutputStream");
      if (this.resetOnFinalize)
        temp.deleteOnExit(); 
      try {
        FileOutputStream transfer = new FileOutputStream(temp);
        transfer.write(this.memory.getBuffer(), 0, this.memory.getCount());
        transfer.flush();
        this.out = transfer;
      } catch (IOException e) {
        temp.delete();
        throw e;
      } 
      this.file = temp;
      this.memory = null;
    } 
  }
}
