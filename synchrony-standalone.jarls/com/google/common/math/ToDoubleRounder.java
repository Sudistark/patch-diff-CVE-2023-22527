package com.google.common.math;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.base.Preconditions;
import java.math.RoundingMode;

@ElementTypesAreNonnullByDefault
@J2ktIncompatible
@GwtIncompatible
abstract class ToDoubleRounder<X extends Number & Comparable<X>> extends Object {
  abstract double roundToDoubleArbitrarily(X paramX);
  
  abstract int sign(X paramX);
  
  abstract X toX(double paramDouble, RoundingMode paramRoundingMode);
  
  abstract X minus(X paramX1, X paramX2);
  
  final double roundToDouble(X x, RoundingMode mode) {
    int diff;
    X deltaToCeiling, deltaToFloor;
    double roundCeilingAsDouble;
    X roundCeiling;
    double roundFloorAsDouble;
    X roundFloor;
    Preconditions.checkNotNull(x, "x");
    Preconditions.checkNotNull(mode, "mode");
    double roundArbitrarily = roundToDoubleArbitrarily(x);
    if (Double.isInfinite(roundArbitrarily))
      switch (null.$SwitchMap$java$math$RoundingMode[mode.ordinal()]) {
        case 1:
        case 2:
        case 3:
        case 4:
          return Double.MAX_VALUE * sign(x);
        case 5:
          return (roundArbitrarily == Double.POSITIVE_INFINITY) ? 
            Double.MAX_VALUE : 
            Double.NEGATIVE_INFINITY;
        case 6:
          return (roundArbitrarily == Double.POSITIVE_INFINITY) ? 
            Double.POSITIVE_INFINITY : 
            -1.7976931348623157E308D;
        case 7:
          return roundArbitrarily;
        case 8:
          throw new ArithmeticException(x + " cannot be represented precisely as a double");
      }  
    X roundArbitrarilyAsX = (X)toX(roundArbitrarily, RoundingMode.UNNECESSARY);
    int cmpXToRoundArbitrarily = ((Comparable)x).compareTo(roundArbitrarilyAsX);
    switch (null.$SwitchMap$java$math$RoundingMode[mode.ordinal()]) {
      case 8:
        MathPreconditions.checkRoundingUnnecessary((cmpXToRoundArbitrarily == 0));
        return roundArbitrarily;
      case 5:
        return (cmpXToRoundArbitrarily >= 0) ? 
          roundArbitrarily : 
          DoubleUtils.nextDown(roundArbitrarily);
      case 6:
        return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);
      case 1:
        if (sign(x) >= 0)
          return (cmpXToRoundArbitrarily >= 0) ? 
            roundArbitrarily : 
            DoubleUtils.nextDown(roundArbitrarily); 
        return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);
      case 7:
        if (sign(x) >= 0)
          return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily); 
        return (cmpXToRoundArbitrarily >= 0) ? 
          roundArbitrarily : 
          DoubleUtils.nextDown(roundArbitrarily);
      case 2:
      case 3:
      case 4:
        if (cmpXToRoundArbitrarily >= 0) {
          roundFloorAsDouble = roundArbitrarily;
          roundFloor = roundArbitrarilyAsX;
          roundCeilingAsDouble = Math.nextUp(roundArbitrarily);
          if (roundCeilingAsDouble == Double.POSITIVE_INFINITY)
            return roundFloorAsDouble; 
          roundCeiling = (X)toX(roundCeilingAsDouble, RoundingMode.CEILING);
        } else {
          roundCeilingAsDouble = roundArbitrarily;
          roundCeiling = roundArbitrarilyAsX;
          roundFloorAsDouble = DoubleUtils.nextDown(roundArbitrarily);
          if (roundFloorAsDouble == Double.NEGATIVE_INFINITY)
            return roundCeilingAsDouble; 
          roundFloor = (X)toX(roundFloorAsDouble, RoundingMode.FLOOR);
        } 
        deltaToFloor = (X)minus(x, roundFloor);
        deltaToCeiling = (X)minus(roundCeiling, x);
        diff = ((Comparable)deltaToFloor).compareTo(deltaToCeiling);
        if (diff < 0)
          return roundFloorAsDouble; 
        if (diff > 0)
          return roundCeilingAsDouble; 
        switch (null.$SwitchMap$java$math$RoundingMode[mode.ordinal()]) {
          case 2:
            return ((Double.doubleToRawLongBits(roundFloorAsDouble) & 0x1L) == 0L) ? 
              roundFloorAsDouble : 
              roundCeilingAsDouble;
          case 3:
            return (sign(x) >= 0) ? roundFloorAsDouble : roundCeilingAsDouble;
          case 4:
            return (sign(x) >= 0) ? roundCeilingAsDouble : roundFloorAsDouble;
        } 
        throw new AssertionError("impossible");
    } 
    throw new AssertionError("impossible");
  }
}
