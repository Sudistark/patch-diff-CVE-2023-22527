package com.google.common.primitives;

import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Preconditions;
import com.google.errorprone.annotations.Immutable;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.DoubleConsumer;
import java.util.stream.DoubleStream;
import javax.annotation.CheckForNull;

@Immutable
@ElementTypesAreNonnullByDefault
@GwtCompatible
public final class ImmutableDoubleArray implements Serializable {
  private static final ImmutableDoubleArray EMPTY = new ImmutableDoubleArray(new double[0]);
  
  private final double[] array;
  
  private final int start;
  
  private final int end;
  
  public static ImmutableDoubleArray of() { return EMPTY; }
  
  public static ImmutableDoubleArray of(double e0) { return new ImmutableDoubleArray(new double[] { e0 }); }
  
  public static ImmutableDoubleArray of(double e0, double e1) { return new ImmutableDoubleArray(new double[] { e0, e1 }); }
  
  public static ImmutableDoubleArray of(double e0, double e1, double e2) { return new ImmutableDoubleArray(new double[] { e0, e1, e2 }); }
  
  public static ImmutableDoubleArray of(double e0, double e1, double e2, double e3) { return new ImmutableDoubleArray(new double[] { e0, e1, e2, e3 }); }
  
  public static ImmutableDoubleArray of(double e0, double e1, double e2, double e3, double e4) { return new ImmutableDoubleArray(new double[] { e0, e1, e2, e3, e4 }); }
  
  public static ImmutableDoubleArray of(double e0, double e1, double e2, double e3, double e4, double e5) { return new ImmutableDoubleArray(new double[] { e0, e1, e2, e3, e4, e5 }); }
  
  public static ImmutableDoubleArray of(double first, double... rest) {
    Preconditions.checkArgument((rest.length <= 2147483646), "the total number of elements must fit in an int");
    double[] array = new double[rest.length + 1];
    array[0] = first;
    System.arraycopy(rest, 0, array, 1, rest.length);
    return new ImmutableDoubleArray(array);
  }
  
  public static ImmutableDoubleArray copyOf(double[] values) {
    return (values.length == 0) ? 
      EMPTY : 
      new ImmutableDoubleArray(Arrays.copyOf(values, values.length));
  }
  
  public static ImmutableDoubleArray copyOf(Collection<Double> values) { return values.isEmpty() ? EMPTY : new ImmutableDoubleArray(Doubles.toArray(values)); }
  
  public static ImmutableDoubleArray copyOf(Iterable<Double> values) {
    if (values instanceof Collection)
      return copyOf((Collection)values); 
    return builder().addAll(values).build();
  }
  
  public static ImmutableDoubleArray copyOf(DoubleStream stream) {
    double[] array = stream.toArray();
    return (array.length == 0) ? EMPTY : new ImmutableDoubleArray(array);
  }
  
  public static Builder builder(int initialCapacity) {
    Preconditions.checkArgument((initialCapacity >= 0), "Invalid initialCapacity: %s", initialCapacity);
    return new Builder(initialCapacity);
  }
  
  public static Builder builder() { return new Builder(10); }
  
  private ImmutableDoubleArray(double[] array) { this(array, 0, array.length); }
  
  private ImmutableDoubleArray(double[] array, int start, int end) {
    this.array = array;
    this.start = start;
    this.end = end;
  }
  
  public int length() { return this.end - this.start; }
  
  public boolean isEmpty() { return (this.end == this.start); }
  
  public double get(int index) {
    Preconditions.checkElementIndex(index, length());
    return this.array[this.start + index];
  }
  
  public int indexOf(double target) {
    for (int i = this.start; i < this.end; i++) {
      if (areEqual(this.array[i], target))
        return i - this.start; 
    } 
    return -1;
  }
  
  public int lastIndexOf(double target) {
    for (int i = this.end - 1; i >= this.start; i--) {
      if (areEqual(this.array[i], target))
        return i - this.start; 
    } 
    return -1;
  }
  
  public boolean contains(double target) { return (indexOf(target) >= 0); }
  
  public void forEach(DoubleConsumer consumer) {
    Preconditions.checkNotNull(consumer);
    for (int i = this.start; i < this.end; i++)
      consumer.accept(this.array[i]); 
  }
  
  public DoubleStream stream() { return Arrays.stream(this.array, this.start, this.end); }
  
  public double[] toArray() { return Arrays.copyOfRange(this.array, this.start, this.end); }
  
  public ImmutableDoubleArray subArray(int startIndex, int endIndex) {
    Preconditions.checkPositionIndexes(startIndex, endIndex, length());
    return (startIndex == endIndex) ? 
      EMPTY : 
      new ImmutableDoubleArray(this.array, this.start + startIndex, this.start + endIndex);
  }
  
  private Spliterator.OfDouble spliterator() { return Spliterators.spliterator(this.array, this.start, this.end, 1040); }
  
  public List<Double> asList() { return new AsList(this, null); }
  
  public boolean equals(@CheckForNull Object object) {
    if (object == this)
      return true; 
    if (!(object instanceof ImmutableDoubleArray))
      return false; 
    ImmutableDoubleArray that = (ImmutableDoubleArray)object;
    if (length() != that.length())
      return false; 
    for (int i = 0; i < length(); i++) {
      if (!areEqual(get(i), that.get(i)))
        return false; 
    } 
    return true;
  }
  
  private static boolean areEqual(double a, double b) { return (Double.doubleToLongBits(a) == Double.doubleToLongBits(b)); }
  
  public int hashCode() {
    int hash = 1;
    for (int i = this.start; i < this.end; i++) {
      hash *= 31;
      hash += Doubles.hashCode(this.array[i]);
    } 
    return hash;
  }
  
  public String toString() {
    if (isEmpty())
      return "[]"; 
    StringBuilder builder = new StringBuilder(length() * 5);
    builder.append('[').append(this.array[this.start]);
    for (int i = this.start + 1; i < this.end; i++)
      builder.append(", ").append(this.array[i]); 
    builder.append(']');
    return builder.toString();
  }
  
  public ImmutableDoubleArray trimmed() { return isPartialView() ? new ImmutableDoubleArray(toArray()) : this; }
  
  private boolean isPartialView() { return (this.start > 0 || this.end < this.array.length); }
  
  Object writeReplace() { return trimmed(); }
  
  Object readResolve() { return isEmpty() ? EMPTY : this; }
}
