package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.base.Preconditions;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.DoNotCall;
import com.google.errorprone.annotations.InlineMe;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Objects;
import java.util.RandomAccess;
import java.util.Spliterator;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;
import java.util.stream.Collector;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible(serializable = true, emulated = true)
public abstract class ImmutableList<E> extends ImmutableCollection<E> implements List<E>, RandomAccess {
  public static <E> Collector<E, ?, ImmutableList<E>> toImmutableList() { return CollectCollectors.toImmutableList(); }
  
  public static <E> ImmutableList<E> of() { return RegularImmutableList.EMPTY; }
  
  public static <E> ImmutableList<E> of(E element) { return new SingletonImmutableList(element); }
  
  public static <E> ImmutableList<E> of(E e1, E e2) { return construct(new Object[] { e1, e2 }); }
  
  public static <E> ImmutableList<E> of(E e1, E e2, E e3) { return construct(new Object[] { e1, e2, e3 }); }
  
  public static <E> ImmutableList<E> of(E e1, E e2, E e3, E e4) { return construct(new Object[] { e1, e2, e3, e4 }); }
  
  public static <E> ImmutableList<E> of(E e1, E e2, E e3, E e4, E e5) { return construct(new Object[] { e1, e2, e3, e4, e5 }); }
  
  public static <E> ImmutableList<E> of(E e1, E e2, E e3, E e4, E e5, E e6) { return construct(new Object[] { e1, e2, e3, e4, e5, e6 }); }
  
  public static <E> ImmutableList<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7) { return construct(new Object[] { e1, e2, e3, e4, e5, e6, e7 }); }
  
  public static <E> ImmutableList<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) { return construct(new Object[] { e1, e2, e3, e4, e5, e6, e7, e8 }); }
  
  public static <E> ImmutableList<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) { return construct(new Object[] { e1, e2, e3, e4, e5, e6, e7, e8, e9 }); }
  
  public static <E> ImmutableList<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) { return construct(new Object[] { e1, e2, e3, e4, e5, e6, e7, e8, e9, e10 }); }
  
  public static <E> ImmutableList<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11) { return construct(new Object[] { 
          e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, 
          e11 }); }
  
  @SafeVarargs
  public static <E> ImmutableList<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E... others) {
    Preconditions.checkArgument((others.length <= 2147483635), "the total number of elements must fit in an int");
    Object[] array = new Object[12 + others.length];
    array[0] = e1;
    array[1] = e2;
    array[2] = e3;
    array[3] = e4;
    array[4] = e5;
    array[5] = e6;
    array[6] = e7;
    array[7] = e8;
    array[8] = e9;
    array[9] = e10;
    array[10] = e11;
    array[11] = e12;
    System.arraycopy(others, 0, array, 12, others.length);
    return construct(array);
  }
  
  public static <E> ImmutableList<E> copyOf(Iterable<? extends E> elements) {
    Preconditions.checkNotNull(elements);
    return (elements instanceof Collection) ? 
      copyOf((Collection)elements) : 
      copyOf(elements.iterator());
  }
  
  public static <E> ImmutableList<E> copyOf(Collection<? extends E> elements) {
    if (elements instanceof ImmutableCollection) {
      ImmutableList<E> list = ((ImmutableCollection)elements).asList();
      return list.isPartialView() ? asImmutableList(list.toArray()) : list;
    } 
    return construct(elements.toArray());
  }
  
  public static <E> ImmutableList<E> copyOf(Iterator<? extends E> elements) {
    if (!elements.hasNext())
      return of(); 
    E first = (E)elements.next();
    if (!elements.hasNext())
      return of(first); 
    return (new Builder()).add(first).addAll(elements).build();
  }
  
  public static <E> ImmutableList<E> copyOf(E[] elements) {
    switch (elements.length) {
      case 0:
        return of();
      case 1:
        return of(elements[0]);
    } 
    return construct((Object[])elements.clone());
  }
  
  public static <E extends Comparable<? super E>> ImmutableList<E> sortedCopyOf(Iterable<? extends E> elements) {
    Comparable[] array = (Comparable[])Iterables.toArray(elements, new Comparable[0]);
    ObjectArrays.checkElementsNotNull((Object[])array);
    Arrays.sort(array);
    return asImmutableList(array);
  }
  
  public static <E> ImmutableList<E> sortedCopyOf(Comparator<? super E> comparator, Iterable<? extends E> elements) {
    Preconditions.checkNotNull(comparator);
    E[] array = (E[])Iterables.toArray(elements);
    ObjectArrays.checkElementsNotNull(array);
    Arrays.sort(array, comparator);
    return asImmutableList(array);
  }
  
  private static <E> ImmutableList<E> construct(Object... elements) { return asImmutableList(ObjectArrays.checkElementsNotNull(elements)); }
  
  static <E> ImmutableList<E> asImmutableList(Object[] elements) { return asImmutableList(elements, elements.length); }
  
  static <E> ImmutableList<E> asImmutableList(Object[] elements, int length) {
    E onlyElement;
    switch (length) {
      case 0:
        return of();
      case 1:
        onlyElement = (E)Objects.requireNonNull(elements[0]);
        return of(onlyElement);
    } 
    Object[] elementsWithoutTrailingNulls = (length < elements.length) ? Arrays.copyOf(elements, length) : elements;
    return new RegularImmutableList(elementsWithoutTrailingNulls);
  }
  
  public UnmodifiableIterator<E> iterator() { return listIterator(); }
  
  public UnmodifiableListIterator<E> listIterator() { return listIterator(0); }
  
  public UnmodifiableListIterator<E> listIterator(int index) { return new Object(this, size(), index); }
  
  public void forEach(Consumer<? super E> consumer) {
    Preconditions.checkNotNull(consumer);
    int n = size();
    for (int i = 0; i < n; i++)
      consumer.accept(get(i)); 
  }
  
  public int indexOf(@CheckForNull Object object) { return (object == null) ? -1 : Lists.indexOfImpl(this, object); }
  
  public int lastIndexOf(@CheckForNull Object object) { return (object == null) ? -1 : Lists.lastIndexOfImpl(this, object); }
  
  public boolean contains(@CheckForNull Object object) { return (indexOf(object) >= 0); }
  
  public ImmutableList<E> subList(int fromIndex, int toIndex) {
    Preconditions.checkPositionIndexes(fromIndex, toIndex, size());
    int length = toIndex - fromIndex;
    if (length == size())
      return this; 
    if (length == 0)
      return of(); 
    if (length == 1)
      return of(get(fromIndex)); 
    return subListUnchecked(fromIndex, toIndex);
  }
  
  ImmutableList<E> subListUnchecked(int fromIndex, int toIndex) { return new SubList(this, fromIndex, toIndex - fromIndex); }
  
  @Deprecated
  @CanIgnoreReturnValue
  @DoNotCall("Always throws UnsupportedOperationException")
  public final boolean addAll(int index, Collection<? extends E> newElements) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @CanIgnoreReturnValue
  @DoNotCall("Always throws UnsupportedOperationException")
  public final E set(int index, E element) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public final void add(int index, E element) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @CanIgnoreReturnValue
  @DoNotCall("Always throws UnsupportedOperationException")
  public final E remove(int index) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public final void replaceAll(UnaryOperator<E> operator) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public final void sort(Comparator<? super E> c) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @InlineMe(replacement = "this")
  public final ImmutableList<E> asList() { return this; }
  
  public Spliterator<E> spliterator() { return CollectSpliterators.indexed(size(), 1296, this::get); }
  
  int copyIntoArray(Object[] dst, int offset) {
    int size = size();
    for (int i = 0; i < size; i++)
      dst[offset + i] = get(i); 
    return offset + size;
  }
  
  public ImmutableList<E> reverse() { return (size() <= 1) ? this : new ReverseImmutableList(this); }
  
  public boolean equals(@CheckForNull Object obj) { return Lists.equalsImpl(this, obj); }
  
  public int hashCode() {
    int hashCode = 1;
    int n = size();
    for (int i = 0; i < n; i++) {
      hashCode = 31 * hashCode + get(i).hashCode();
      hashCode = hashCode ^ 0xFFFFFFFF ^ 0xFFFFFFFF;
    } 
    return hashCode;
  }
  
  @J2ktIncompatible
  private void readObject(ObjectInputStream stream) throws InvalidObjectException { throw new InvalidObjectException("Use SerializedForm"); }
  
  @J2ktIncompatible
  Object writeReplace() { return new SerializedForm(toArray()); }
  
  public static <E> Builder<E> builder() { return new Builder(); }
  
  public static <E> Builder<E> builderWithExpectedSize(int expectedSize) {
    CollectPreconditions.checkNonnegative(expectedSize, "expectedSize");
    return new Builder(expectedSize);
  }
}
