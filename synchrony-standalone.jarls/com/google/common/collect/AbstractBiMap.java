package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.base.Objects;
import com.google.common.base.Preconditions;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.concurrent.LazyInit;
import com.google.j2objc.annotations.RetainedWith;
import java.io.Serializable;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.function.BiFunction;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible(emulated = true)
abstract class AbstractBiMap<K, V> extends ForwardingMap<K, V> implements BiMap<K, V>, Serializable {
  private Map<K, V> delegate;
  
  @RetainedWith
  AbstractBiMap<V, K> inverse;
  
  @LazyInit
  @CheckForNull
  private Set<K> keySet;
  
  @LazyInit
  @CheckForNull
  private Set<V> valueSet;
  
  @LazyInit
  @CheckForNull
  private Set<Map.Entry<K, V>> entrySet;
  
  @GwtIncompatible
  @J2ktIncompatible
  private static final long serialVersionUID = 0L;
  
  AbstractBiMap(Map<K, V> forward, Map<V, K> backward) { setDelegates(forward, backward); }
  
  private AbstractBiMap(Map<K, V> backward, AbstractBiMap<V, K> forward) {
    this.delegate = backward;
    this.inverse = forward;
  }
  
  protected Map<K, V> delegate() { return this.delegate; }
  
  @ParametricNullness
  @CanIgnoreReturnValue
  K checkKey(@ParametricNullness K key) { return key; }
  
  @ParametricNullness
  @CanIgnoreReturnValue
  V checkValue(@ParametricNullness V value) { return value; }
  
  void setDelegates(Map<K, V> forward, Map<V, K> backward) {
    Preconditions.checkState((this.delegate == null));
    Preconditions.checkState((this.inverse == null));
    Preconditions.checkArgument(forward.isEmpty());
    Preconditions.checkArgument(backward.isEmpty());
    Preconditions.checkArgument((forward != backward));
    this.delegate = forward;
    this.inverse = makeInverse(backward);
  }
  
  AbstractBiMap<V, K> makeInverse(Map<V, K> backward) { return new Inverse(backward, this); }
  
  void setInverse(AbstractBiMap<V, K> inverse) { this.inverse = inverse; }
  
  public boolean containsValue(@CheckForNull Object value) { return this.inverse.containsKey(value); }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V put(@ParametricNullness K key, @ParametricNullness V value) { return (V)putInBothMaps(key, value, false); }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V forcePut(@ParametricNullness K key, @ParametricNullness V value) { return (V)putInBothMaps(key, value, true); }
  
  @CheckForNull
  private V putInBothMaps(@ParametricNullness K key, @ParametricNullness V value, boolean force) {
    checkKey(key);
    checkValue(value);
    boolean containedKey = containsKey(key);
    if (containedKey && Objects.equal(value, get(key)))
      return value; 
    if (force) {
      inverse().remove(value);
    } else {
      Preconditions.checkArgument(!containsValue(value), "value already present: %s", value);
    } 
    V oldValue = (V)this.delegate.put(key, value);
    updateInverseMap(key, containedKey, oldValue, value);
    return oldValue;
  }
  
  private void updateInverseMap(@ParametricNullness K key, boolean containedKey, @CheckForNull V oldValue, @ParametricNullness V newValue) {
    if (containedKey)
      removeFromInverseMap(NullnessCasts.uncheckedCastNullableTToT(oldValue)); 
    this.inverse.delegate.put(newValue, key);
  }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V remove(@CheckForNull Object key) { return (V)(containsKey(key) ? removeFromBothMaps(key) : null); }
  
  @ParametricNullness
  @CanIgnoreReturnValue
  private V removeFromBothMaps(@CheckForNull Object key) {
    V oldValue = (V)NullnessCasts.uncheckedCastNullableTToT(this.delegate.remove(key));
    removeFromInverseMap(oldValue);
    return oldValue;
  }
  
  private void removeFromInverseMap(@ParametricNullness V oldValue) { this.inverse.delegate.remove(oldValue); }
  
  public void putAll(Map<? extends K, ? extends V> map) {
    for (Map.Entry<? extends K, ? extends V> entry : map.entrySet())
      put(entry.getKey(), entry.getValue()); 
  }
  
  public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
    this.delegate.replaceAll(function);
    this.inverse.delegate.clear();
    Map.Entry<K, V> broken = null;
    Iterator<Map.Entry<K, V>> itr = this.delegate.entrySet().iterator();
    while (itr.hasNext()) {
      Map.Entry<K, V> entry = (Map.Entry)itr.next();
      K k = (K)entry.getKey();
      V v = (V)entry.getValue();
      K conflict = (K)this.inverse.delegate.putIfAbsent(v, k);
      if (conflict != null) {
        broken = entry;
        itr.remove();
      } 
    } 
    if (broken != null)
      throw new IllegalArgumentException("value already present: " + broken.getValue()); 
  }
  
  public void clear() {
    this.delegate.clear();
    this.inverse.delegate.clear();
  }
  
  public BiMap<V, K> inverse() { return this.inverse; }
  
  public Set<K> keySet() {
    Set<K> result = this.keySet;
    return (result == null) ? (this.keySet = new KeySet(this, null)) : result;
  }
  
  public Set<V> values() {
    Set<V> result = this.valueSet;
    return (result == null) ? (this.valueSet = new ValueSet(this, null)) : result;
  }
  
  public Set<Map.Entry<K, V>> entrySet() {
    Set<Map.Entry<K, V>> result = this.entrySet;
    return (result == null) ? (this.entrySet = new EntrySet(this, null)) : result;
  }
  
  Iterator<Map.Entry<K, V>> entrySetIterator() {
    Iterator<Map.Entry<K, V>> iterator = this.delegate.entrySet().iterator();
    return new Object(this, iterator);
  }
}
