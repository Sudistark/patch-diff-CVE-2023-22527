package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible(serializable = true, emulated = true)
public class LinkedListMultimap<K, V> extends AbstractMultimap<K, V> implements ListMultimap<K, V>, Serializable {
  @CheckForNull
  private Node<K, V> head;
  
  @CheckForNull
  private Node<K, V> tail;
  
  private Map<K, KeyList<K, V>> keyToKeyList;
  
  private int size;
  
  private int modCount;
  
  @GwtIncompatible
  @J2ktIncompatible
  private static final long serialVersionUID = 0L;
  
  public static <K, V> LinkedListMultimap<K, V> create() { return new LinkedListMultimap(); }
  
  public static <K, V> LinkedListMultimap<K, V> create(int expectedKeys) { return new LinkedListMultimap(expectedKeys); }
  
  public static <K, V> LinkedListMultimap<K, V> create(Multimap<? extends K, ? extends V> multimap) { return new LinkedListMultimap(multimap); }
  
  LinkedListMultimap() { this(12); }
  
  private LinkedListMultimap(int expectedKeys) { this.keyToKeyList = Platform.newHashMapWithExpectedSize(expectedKeys); }
  
  private LinkedListMultimap(Multimap<? extends K, ? extends V> multimap) {
    this(multimap.keySet().size());
    putAll(multimap);
  }
  
  @CanIgnoreReturnValue
  private Node<K, V> addNode(@ParametricNullness K key, @ParametricNullness V value, @CheckForNull Node<K, V> nextSibling) {
    Node<K, V> node = new Node<K, V>(key, value);
    if (this.head == null) {
      this.head = this.tail = node;
      this.keyToKeyList.put(key, new KeyList(node));
      this.modCount++;
    } else if (nextSibling == null) {
      ((Node)Objects.requireNonNull(this.tail)).next = node;
      node.previous = this.tail;
      this.tail = node;
      KeyList<K, V> keyList = (KeyList)this.keyToKeyList.get(key);
      if (keyList == null) {
        this.keyToKeyList.put(key, keyList = new KeyList<K, V>(node));
        this.modCount++;
      } else {
        keyList.count++;
        Node<K, V> keyTail = keyList.tail;
        keyTail.nextSibling = node;
        node.previousSibling = keyTail;
        keyList.tail = node;
      } 
    } else {
      KeyList<K, V> keyList = (KeyList)Objects.requireNonNull((KeyList)this.keyToKeyList.get(key));
      keyList.count++;
      node.previous = nextSibling.previous;
      node.previousSibling = nextSibling.previousSibling;
      node.next = nextSibling;
      node.nextSibling = nextSibling;
      if (nextSibling.previousSibling == null) {
        keyList.head = node;
      } else {
        nextSibling.previousSibling.nextSibling = node;
      } 
      if (nextSibling.previous == null) {
        this.head = node;
      } else {
        nextSibling.previous.next = node;
      } 
      nextSibling.previous = node;
      nextSibling.previousSibling = node;
    } 
    this.size++;
    return node;
  }
  
  private void removeNode(Node<K, V> node) {
    if (node.previous != null) {
      node.previous.next = node.next;
    } else {
      this.head = node.next;
    } 
    if (node.next != null) {
      node.next.previous = node.previous;
    } else {
      this.tail = node.previous;
    } 
    if (node.previousSibling == null && node.nextSibling == null) {
      KeyList<K, V> keyList = (KeyList)Objects.requireNonNull((KeyList)this.keyToKeyList.remove(node.key));
      keyList.count = 0;
      this.modCount++;
    } else {
      KeyList<K, V> keyList = (KeyList)Objects.requireNonNull((KeyList)this.keyToKeyList.get(node.key));
      keyList.count--;
      if (node.previousSibling == null) {
        keyList.head = (Node)Objects.requireNonNull(node.nextSibling);
      } else {
        node.previousSibling.nextSibling = node.nextSibling;
      } 
      if (node.nextSibling == null) {
        keyList.tail = (Node)Objects.requireNonNull(node.previousSibling);
      } else {
        node.nextSibling.previousSibling = node.previousSibling;
      } 
    } 
    this.size--;
  }
  
  private void removeAllNodes(@ParametricNullness K key) { Iterators.clear(new ValueForKeyIterator(this, key)); }
  
  public int size() { return this.size; }
  
  public boolean isEmpty() { return (this.head == null); }
  
  public boolean containsKey(@CheckForNull Object key) { return this.keyToKeyList.containsKey(key); }
  
  public boolean containsValue(@CheckForNull Object value) { return values().contains(value); }
  
  @CanIgnoreReturnValue
  public boolean put(@ParametricNullness K key, @ParametricNullness V value) {
    addNode(key, value, null);
    return true;
  }
  
  @CanIgnoreReturnValue
  public List<V> replaceValues(@ParametricNullness K key, Iterable<? extends V> values) {
    List<V> oldValues = getCopy(key);
    ValueForKeyIterator valueForKeyIterator = new ValueForKeyIterator(this, key);
    Iterator<? extends V> newValues = values.iterator();
    while (valueForKeyIterator.hasNext() && newValues.hasNext()) {
      valueForKeyIterator.next();
      valueForKeyIterator.set(newValues.next());
    } 
    while (valueForKeyIterator.hasNext()) {
      valueForKeyIterator.next();
      valueForKeyIterator.remove();
    } 
    while (newValues.hasNext())
      valueForKeyIterator.add(newValues.next()); 
    return oldValues;
  }
  
  private List<V> getCopy(@ParametricNullness K key) { return Collections.unmodifiableList(Lists.newArrayList(new ValueForKeyIterator(this, key))); }
  
  @CanIgnoreReturnValue
  public List<V> removeAll(@CheckForNull Object key) {
    K castKey = (K)key;
    List<V> oldValues = getCopy(castKey);
    removeAllNodes(castKey);
    return oldValues;
  }
  
  public void clear() {
    this.head = null;
    this.tail = null;
    this.keyToKeyList.clear();
    this.size = 0;
    this.modCount++;
  }
  
  public List<V> get(@ParametricNullness K key) { return new Object(this, key); }
  
  Set<K> createKeySet() { return new KeySetImpl(this); }
  
  Multiset<K> createKeys() { return new Multimaps.Keys(this); }
  
  public List<V> values() { return (List)super.values(); }
  
  List<V> createValues() { return new ValuesImpl(this); }
  
  public List<Map.Entry<K, V>> entries() { return (List)super.entries(); }
  
  List<Map.Entry<K, V>> createEntries() { return new EntriesImpl(this); }
  
  Iterator<Map.Entry<K, V>> entryIterator() { throw new AssertionError("should never be called"); }
  
  Map<K, Collection<V>> createAsMap() { return new Multimaps.AsMap(this); }
  
  @GwtIncompatible
  @J2ktIncompatible
  private void writeObject(ObjectOutputStream stream) throws IOException {
    stream.defaultWriteObject();
    stream.writeInt(size());
    for (Map.Entry<K, V> entry : entries()) {
      stream.writeObject(entry.getKey());
      stream.writeObject(entry.getValue());
    } 
  }
  
  @GwtIncompatible
  @J2ktIncompatible
  private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    stream.defaultReadObject();
    this.keyToKeyList = Maps.newLinkedHashMap();
    int size = stream.readInt();
    for (int i = 0; i < size; i++) {
      K key = (K)stream.readObject();
      V value = (V)stream.readObject();
      put(key, value);
    } 
  }
}
