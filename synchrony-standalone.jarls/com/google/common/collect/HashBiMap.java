package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.base.Objects;
import com.google.common.base.Preconditions;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.concurrent.LazyInit;
import com.google.j2objc.annotations.RetainedWith;
import com.google.j2objc.annotations.Weak;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible(emulated = true)
public final class HashBiMap<K, V> extends Maps.IteratorBasedAbstractMap<K, V> implements BiMap<K, V>, Serializable {
  private static final double LOAD_FACTOR = 1.0D;
  
  private BiEntry<K, V>[] hashTableKToV;
  
  private BiEntry<K, V>[] hashTableVToK;
  
  @CheckForNull
  @Weak
  private BiEntry<K, V> firstInKeyInsertionOrder;
  
  @CheckForNull
  @Weak
  private BiEntry<K, V> lastInKeyInsertionOrder;
  
  private int size;
  
  private int mask;
  
  private int modCount;
  
  @LazyInit
  @CheckForNull
  @RetainedWith
  private BiMap<V, K> inverse;
  
  @GwtIncompatible
  @J2ktIncompatible
  private static final long serialVersionUID = 0L;
  
  public static <K, V> HashBiMap<K, V> create() { return create(16); }
  
  public static <K, V> HashBiMap<K, V> create(int expectedSize) { return new HashBiMap(expectedSize); }
  
  public static <K, V> HashBiMap<K, V> create(Map<? extends K, ? extends V> map) {
    HashBiMap<K, V> bimap = create(map.size());
    bimap.putAll(map);
    return bimap;
  }
  
  private HashBiMap(int expectedSize) { init(expectedSize); }
  
  private void init(int expectedSize) {
    CollectPreconditions.checkNonnegative(expectedSize, "expectedSize");
    int tableSize = Hashing.closedTableSize(expectedSize, 1.0D);
    this.hashTableKToV = createTable(tableSize);
    this.hashTableVToK = createTable(tableSize);
    this.firstInKeyInsertionOrder = null;
    this.lastInKeyInsertionOrder = null;
    this.size = 0;
    this.mask = tableSize - 1;
    this.modCount = 0;
  }
  
  private void delete(BiEntry<K, V> entry) {
    int keyBucket = entry.keyHash & this.mask;
    BiEntry<K, V> prevBucketEntry = null;
    BiEntry<K, V> bucketEntry = this.hashTableKToV[keyBucket];
    for (;; bucketEntry = bucketEntry.nextInKToVBucket) {
      if (bucketEntry == entry) {
        if (prevBucketEntry == null) {
          this.hashTableKToV[keyBucket] = entry.nextInKToVBucket;
          break;
        } 
        prevBucketEntry.nextInKToVBucket = entry.nextInKToVBucket;
        break;
      } 
      prevBucketEntry = bucketEntry;
    } 
    int valueBucket = entry.valueHash & this.mask;
    prevBucketEntry = null;
    BiEntry<K, V> bucketEntry = this.hashTableVToK[valueBucket];
    for (;; bucketEntry = bucketEntry.nextInVToKBucket) {
      if (bucketEntry == entry) {
        if (prevBucketEntry == null) {
          this.hashTableVToK[valueBucket] = entry.nextInVToKBucket;
          break;
        } 
        prevBucketEntry.nextInVToKBucket = entry.nextInVToKBucket;
        break;
      } 
      prevBucketEntry = bucketEntry;
    } 
    if (entry.prevInKeyInsertionOrder == null) {
      this.firstInKeyInsertionOrder = entry.nextInKeyInsertionOrder;
    } else {
      entry.prevInKeyInsertionOrder.nextInKeyInsertionOrder = entry.nextInKeyInsertionOrder;
    } 
    if (entry.nextInKeyInsertionOrder == null) {
      this.lastInKeyInsertionOrder = entry.prevInKeyInsertionOrder;
    } else {
      entry.nextInKeyInsertionOrder.prevInKeyInsertionOrder = entry.prevInKeyInsertionOrder;
    } 
    this.size--;
    this.modCount++;
  }
  
  private void insert(BiEntry<K, V> entry, @CheckForNull BiEntry<K, V> oldEntryForKey) {
    int keyBucket = entry.keyHash & this.mask;
    entry.nextInKToVBucket = this.hashTableKToV[keyBucket];
    this.hashTableKToV[keyBucket] = entry;
    int valueBucket = entry.valueHash & this.mask;
    entry.nextInVToKBucket = this.hashTableVToK[valueBucket];
    this.hashTableVToK[valueBucket] = entry;
    if (oldEntryForKey == null) {
      entry.prevInKeyInsertionOrder = this.lastInKeyInsertionOrder;
      entry.nextInKeyInsertionOrder = null;
      if (this.lastInKeyInsertionOrder == null) {
        this.firstInKeyInsertionOrder = entry;
      } else {
        this.lastInKeyInsertionOrder.nextInKeyInsertionOrder = entry;
      } 
      this.lastInKeyInsertionOrder = entry;
    } else {
      entry.prevInKeyInsertionOrder = oldEntryForKey.prevInKeyInsertionOrder;
      if (entry.prevInKeyInsertionOrder == null) {
        this.firstInKeyInsertionOrder = entry;
      } else {
        entry.prevInKeyInsertionOrder.nextInKeyInsertionOrder = entry;
      } 
      entry.nextInKeyInsertionOrder = oldEntryForKey.nextInKeyInsertionOrder;
      if (entry.nextInKeyInsertionOrder == null) {
        this.lastInKeyInsertionOrder = entry;
      } else {
        entry.nextInKeyInsertionOrder.prevInKeyInsertionOrder = entry;
      } 
    } 
    this.size++;
    this.modCount++;
  }
  
  @CheckForNull
  private BiEntry<K, V> seekByKey(@CheckForNull Object key, int keyHash) {
    BiEntry<K, V> entry = this.hashTableKToV[keyHash & this.mask];
    for (; entry != null; 
      entry = entry.nextInKToVBucket) {
      if (keyHash == entry.keyHash && Objects.equal(key, entry.key))
        return entry; 
    } 
    return null;
  }
  
  @CheckForNull
  private BiEntry<K, V> seekByValue(@CheckForNull Object value, int valueHash) {
    BiEntry<K, V> entry = this.hashTableVToK[valueHash & this.mask];
    for (; entry != null; 
      entry = entry.nextInVToKBucket) {
      if (valueHash == entry.valueHash && Objects.equal(value, entry.value))
        return entry; 
    } 
    return null;
  }
  
  public boolean containsKey(@CheckForNull Object key) { return (seekByKey(key, Hashing.smearedHash(key)) != null); }
  
  public boolean containsValue(@CheckForNull Object value) { return (seekByValue(value, Hashing.smearedHash(value)) != null); }
  
  @CheckForNull
  public V get(@CheckForNull Object key) { return (V)Maps.valueOrNull(seekByKey(key, Hashing.smearedHash(key))); }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V put(@ParametricNullness K key, @ParametricNullness V value) { return (V)put(key, value, false); }
  
  @CheckForNull
  private V put(@ParametricNullness K key, @ParametricNullness V value, boolean force) {
    int keyHash = Hashing.smearedHash(key);
    int valueHash = Hashing.smearedHash(value);
    BiEntry<K, V> oldEntryForKey = seekByKey(key, keyHash);
    if (oldEntryForKey != null && valueHash == oldEntryForKey.valueHash && 
      
      Objects.equal(value, oldEntryForKey.value))
      return value; 
    BiEntry<K, V> oldEntryForValue = seekByValue(value, valueHash);
    if (oldEntryForValue != null)
      if (force) {
        delete(oldEntryForValue);
      } else {
        throw new IllegalArgumentException("value already present: " + value);
      }  
    BiEntry<K, V> newEntry = new BiEntry<K, V>(key, keyHash, value, valueHash);
    if (oldEntryForKey != null) {
      delete(oldEntryForKey);
      insert(newEntry, oldEntryForKey);
      oldEntryForKey.prevInKeyInsertionOrder = null;
      oldEntryForKey.nextInKeyInsertionOrder = null;
      return (V)oldEntryForKey.value;
    } 
    insert(newEntry, null);
    rehashIfNecessary();
    return null;
  }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V forcePut(@ParametricNullness K key, @ParametricNullness V value) { return (V)put(key, value, true); }
  
  @CheckForNull
  @CanIgnoreReturnValue
  private K putInverse(@ParametricNullness V value, @ParametricNullness K key, boolean force) {
    int valueHash = Hashing.smearedHash(value);
    int keyHash = Hashing.smearedHash(key);
    BiEntry<K, V> oldEntryForValue = seekByValue(value, valueHash);
    BiEntry<K, V> oldEntryForKey = seekByKey(key, keyHash);
    if (oldEntryForValue != null && keyHash == oldEntryForValue.keyHash && 
      
      Objects.equal(key, oldEntryForValue.key))
      return key; 
    if (oldEntryForKey != null && !force)
      throw new IllegalArgumentException("key already present: " + key); 
    if (oldEntryForValue != null)
      delete(oldEntryForValue); 
    if (oldEntryForKey != null)
      delete(oldEntryForKey); 
    BiEntry<K, V> newEntry = new BiEntry<K, V>(key, keyHash, value, valueHash);
    insert(newEntry, oldEntryForKey);
    if (oldEntryForKey != null) {
      oldEntryForKey.prevInKeyInsertionOrder = null;
      oldEntryForKey.nextInKeyInsertionOrder = null;
    } 
    if (oldEntryForValue != null) {
      oldEntryForValue.prevInKeyInsertionOrder = null;
      oldEntryForValue.nextInKeyInsertionOrder = null;
    } 
    rehashIfNecessary();
    return (K)Maps.keyOrNull(oldEntryForValue);
  }
  
  private void rehashIfNecessary() {
    BiEntry[] arrayOfBiEntry = this.hashTableKToV;
    if (Hashing.needsResizing(this.size, arrayOfBiEntry.length, 1.0D)) {
      int newTableSize = arrayOfBiEntry.length * 2;
      this.hashTableKToV = createTable(newTableSize);
      this.hashTableVToK = createTable(newTableSize);
      this.mask = newTableSize - 1;
      this.size = 0;
      BiEntry<K, V> entry = this.firstInKeyInsertionOrder;
      for (; entry != null; 
        entry = entry.nextInKeyInsertionOrder)
        insert(entry, entry); 
      this.modCount++;
    } 
  }
  
  private BiEntry<K, V>[] createTable(int length) { return new BiEntry[length]; }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V remove(@CheckForNull Object key) {
    BiEntry<K, V> entry = seekByKey(key, Hashing.smearedHash(key));
    if (entry == null)
      return null; 
    delete(entry);
    entry.prevInKeyInsertionOrder = null;
    entry.nextInKeyInsertionOrder = null;
    return (V)entry.value;
  }
  
  public void clear() {
    this.size = 0;
    Arrays.fill(this.hashTableKToV, null);
    Arrays.fill(this.hashTableVToK, null);
    this.firstInKeyInsertionOrder = null;
    this.lastInKeyInsertionOrder = null;
    this.modCount++;
  }
  
  public int size() { return this.size; }
  
  public Set<K> keySet() { return new KeySet(this); }
  
  public Set<V> values() { return inverse().keySet(); }
  
  Iterator<Map.Entry<K, V>> entryIterator() { return new Object(this); }
  
  public void forEach(BiConsumer<? super K, ? super V> action) {
    Preconditions.checkNotNull(action);
    BiEntry<K, V> entry = this.firstInKeyInsertionOrder;
    for (; entry != null; 
      entry = entry.nextInKeyInsertionOrder)
      action.accept(entry.key, entry.value); 
  }
  
  public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
    Preconditions.checkNotNull(function);
    BiEntry<K, V> oldFirst = this.firstInKeyInsertionOrder;
    clear();
    for (BiEntry<K, V> entry = oldFirst; entry != null; entry = entry.nextInKeyInsertionOrder)
      put(entry.key, function.apply(entry.key, entry.value)); 
  }
  
  public BiMap<V, K> inverse() {
    BiMap<V, K> result = this.inverse;
    return (result == null) ? (this.inverse = new Inverse(this, null)) : result;
  }
  
  @GwtIncompatible
  @J2ktIncompatible
  private void writeObject(ObjectOutputStream stream) throws IOException {
    stream.defaultWriteObject();
    Serialization.writeMap(this, stream);
  }
  
  @GwtIncompatible
  @J2ktIncompatible
  private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    stream.defaultReadObject();
    int size = Serialization.readCount(stream);
    init(16);
    Serialization.populateMap(this, stream, size);
  }
}
