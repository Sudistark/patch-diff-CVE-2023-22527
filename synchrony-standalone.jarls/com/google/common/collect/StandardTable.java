package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Preconditions;
import com.google.common.base.Supplier;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.concurrent.LazyInit;
import java.io.Serializable;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import java.util.Spliterator;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible
class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializable {
  @GwtTransient
  final Map<R, Map<C, V>> backingMap;
  
  @GwtTransient
  final Supplier<? extends Map<C, V>> factory;
  
  @LazyInit
  @CheckForNull
  private Set<C> columnKeySet;
  
  @LazyInit
  @CheckForNull
  private Map<R, Map<C, V>> rowMap;
  
  @LazyInit
  @CheckForNull
  private ColumnMap columnMap;
  
  private static final long serialVersionUID = 0L;
  
  StandardTable(Map<R, Map<C, V>> backingMap, Supplier<? extends Map<C, V>> factory) {
    this.backingMap = backingMap;
    this.factory = factory;
  }
  
  public boolean contains(@CheckForNull Object rowKey, @CheckForNull Object columnKey) { return (rowKey != null && columnKey != null && super.contains(rowKey, columnKey)); }
  
  public boolean containsColumn(@CheckForNull Object columnKey) {
    if (columnKey == null)
      return false; 
    for (Map<C, V> map : this.backingMap.values()) {
      if (Maps.safeContainsKey(map, columnKey))
        return true; 
    } 
    return false;
  }
  
  public boolean containsRow(@CheckForNull Object rowKey) { return (rowKey != null && Maps.safeContainsKey(this.backingMap, rowKey)); }
  
  public boolean containsValue(@CheckForNull Object value) { return (value != null && super.containsValue(value)); }
  
  @CheckForNull
  public V get(@CheckForNull Object rowKey, @CheckForNull Object columnKey) { return (V)((rowKey == null || columnKey == null) ? null : super.get(rowKey, columnKey)); }
  
  public boolean isEmpty() { return this.backingMap.isEmpty(); }
  
  public int size() {
    int size = 0;
    for (Map<C, V> map : this.backingMap.values())
      size += map.size(); 
    return size;
  }
  
  public void clear() { this.backingMap.clear(); }
  
  private Map<C, V> getOrCreate(R rowKey) {
    Map<C, V> map = (Map)this.backingMap.get(rowKey);
    if (map == null) {
      map = (Map)this.factory.get();
      this.backingMap.put(rowKey, map);
    } 
    return map;
  }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V put(R rowKey, C columnKey, V value) {
    Preconditions.checkNotNull(rowKey);
    Preconditions.checkNotNull(columnKey);
    Preconditions.checkNotNull(value);
    return (V)getOrCreate(rowKey).put(columnKey, value);
  }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
    if (rowKey == null || columnKey == null)
      return null; 
    Map<C, V> map = (Map)Maps.safeGet(this.backingMap, rowKey);
    if (map == null)
      return null; 
    V value = (V)map.remove(columnKey);
    if (map.isEmpty())
      this.backingMap.remove(rowKey); 
    return value;
  }
  
  @CanIgnoreReturnValue
  private Map<R, V> removeColumn(@CheckForNull Object column) {
    Map<R, V> output = new LinkedHashMap<R, V>();
    Iterator<Map.Entry<R, Map<C, V>>> iterator = this.backingMap.entrySet().iterator();
    while (iterator.hasNext()) {
      Map.Entry<R, Map<C, V>> entry = (Map.Entry)iterator.next();
      V value = (V)((Map)entry.getValue()).remove(column);
      if (value != null) {
        output.put(entry.getKey(), value);
        if (((Map)entry.getValue()).isEmpty())
          iterator.remove(); 
      } 
    } 
    return output;
  }
  
  private boolean containsMapping(@CheckForNull Object rowKey, @CheckForNull Object columnKey, @CheckForNull Object value) { return (value != null && value.equals(get(rowKey, columnKey))); }
  
  private boolean removeMapping(@CheckForNull Object rowKey, @CheckForNull Object columnKey, @CheckForNull Object value) {
    if (containsMapping(rowKey, columnKey, value)) {
      remove(rowKey, columnKey);
      return true;
    } 
    return false;
  }
  
  public Set<Table.Cell<R, C, V>> cellSet() { return super.cellSet(); }
  
  Iterator<Table.Cell<R, C, V>> cellIterator() { return new CellIterator(this, null); }
  
  Spliterator<Table.Cell<R, C, V>> cellSpliterator() {
    return CollectSpliterators.flatMap(this.backingMap
        .entrySet().spliterator(), rowEntry -> 
        
        CollectSpliterators.map(((Map)rowEntry
          .getValue()).entrySet().spliterator(), ()), 65, 



        
        size());
  }
  
  public Map<C, V> row(R rowKey) { return new Row(this, rowKey); }
  
  public Map<R, V> column(C columnKey) { return new Column(this, columnKey); }
  
  public Set<R> rowKeySet() { return rowMap().keySet(); }
  
  public Set<C> columnKeySet() {
    Set<C> result = this.columnKeySet;
    return (result == null) ? (this.columnKeySet = new ColumnKeySet(this, null)) : result;
  }
  
  Iterator<C> createColumnKeyIterator() { return new ColumnKeyIterator(this, null); }
  
  public Collection<V> values() { return super.values(); }
  
  public Map<R, Map<C, V>> rowMap() {
    Map<R, Map<C, V>> result = this.rowMap;
    return (result == null) ? (this.rowMap = createRowMap()) : result;
  }
  
  Map<R, Map<C, V>> createRowMap() { return new RowMap(this); }
  
  public Map<C, Map<R, V>> columnMap() {
    ColumnMap result = this.columnMap;
    return (result == null) ? (this.columnMap = new ColumnMap(this, null)) : result;
  }
}
