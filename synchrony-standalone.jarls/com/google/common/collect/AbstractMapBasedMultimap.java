package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Preconditions;
import java.io.Serializable;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NavigableMap;
import java.util.Set;
import java.util.SortedMap;
import java.util.Spliterator;
import java.util.function.BiConsumer;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible
abstract class AbstractMapBasedMultimap<K, V> extends AbstractMultimap<K, V> implements Serializable {
  private Map<K, Collection<V>> map;
  
  private int totalSize;
  
  private static final long serialVersionUID = 2447537837011683357L;
  
  protected AbstractMapBasedMultimap(Map<K, Collection<V>> map) {
    Preconditions.checkArgument(map.isEmpty());
    this.map = map;
  }
  
  final void setMap(Map<K, Collection<V>> map) {
    this.map = map;
    this.totalSize = 0;
    for (Collection<V> values : map.values()) {
      Preconditions.checkArgument(!values.isEmpty());
      this.totalSize += values.size();
    } 
  }
  
  Collection<V> createUnmodifiableEmptyCollection() { return unmodifiableCollectionSubclass(createCollection()); }
  
  Collection<V> createCollection(@ParametricNullness K key) { return createCollection(); }
  
  Map<K, Collection<V>> backingMap() { return this.map; }
  
  public int size() { return this.totalSize; }
  
  public boolean containsKey(@CheckForNull Object key) { return this.map.containsKey(key); }
  
  public boolean put(@ParametricNullness K key, @ParametricNullness V value) {
    Collection<V> collection = (Collection)this.map.get(key);
    if (collection == null) {
      collection = createCollection(key);
      if (collection.add(value)) {
        this.totalSize++;
        this.map.put(key, collection);
        return true;
      } 
      throw new AssertionError("New Collection violated the Collection spec");
    } 
    if (collection.add(value)) {
      this.totalSize++;
      return true;
    } 
    return false;
  }
  
  private Collection<V> getOrCreateCollection(@ParametricNullness K key) {
    Collection<V> collection = (Collection)this.map.get(key);
    if (collection == null) {
      collection = createCollection(key);
      this.map.put(key, collection);
    } 
    return collection;
  }
  
  public Collection<V> replaceValues(@ParametricNullness K key, Iterable<? extends V> values) {
    Iterator<? extends V> iterator = values.iterator();
    if (!iterator.hasNext())
      return removeAll(key); 
    Collection<V> collection = getOrCreateCollection(key);
    Collection<V> oldValues = createCollection();
    oldValues.addAll(collection);
    this.totalSize -= collection.size();
    collection.clear();
    while (iterator.hasNext()) {
      if (collection.add(iterator.next()))
        this.totalSize++; 
    } 
    return unmodifiableCollectionSubclass(oldValues);
  }
  
  public Collection<V> removeAll(@CheckForNull Object key) {
    Collection<V> collection = (Collection)this.map.remove(key);
    if (collection == null)
      return createUnmodifiableEmptyCollection(); 
    Collection<V> output = createCollection();
    output.addAll(collection);
    this.totalSize -= collection.size();
    collection.clear();
    return unmodifiableCollectionSubclass(output);
  }
  
  <E> Collection<E> unmodifiableCollectionSubclass(Collection<E> collection) { return Collections.unmodifiableCollection(collection); }
  
  public void clear() {
    for (Collection<V> collection : this.map.values())
      collection.clear(); 
    this.map.clear();
    this.totalSize = 0;
  }
  
  public Collection<V> get(@ParametricNullness K key) {
    Collection<V> collection = (Collection)this.map.get(key);
    if (collection == null)
      collection = createCollection(key); 
    return wrapCollection(key, collection);
  }
  
  Collection<V> wrapCollection(@ParametricNullness K key, Collection<V> collection) { return new WrappedCollection(this, key, collection, null); }
  
  final List<V> wrapList(@ParametricNullness K key, List<V> list, @CheckForNull WrappedCollection ancestor) {
    return (list instanceof java.util.RandomAccess) ? 
      new RandomAccessWrappedList(this, key, list, ancestor) : 
      new WrappedList(this, key, list, ancestor);
  }
  
  private static <E> Iterator<E> iteratorOrListIterator(Collection<E> collection) {
    return (collection instanceof List) ? (
      (List)collection).listIterator() : 
      collection.iterator();
  }
  
  Set<K> createKeySet() { return new KeySet(this, this.map); }
  
  final Set<K> createMaybeNavigableKeySet() {
    if (this.map instanceof NavigableMap)
      return new NavigableKeySet(this, (NavigableMap)this.map); 
    if (this.map instanceof SortedMap)
      return new SortedKeySet(this, (SortedMap)this.map); 
    return new KeySet(this, this.map);
  }
  
  private void removeValuesForKey(@CheckForNull Object key) {
    Collection<V> collection = (Collection)Maps.safeRemove(this.map, key);
    if (collection != null) {
      int count = collection.size();
      collection.clear();
      this.totalSize -= count;
    } 
  }
  
  public Collection<V> values() { return super.values(); }
  
  Collection<V> createValues() { return new AbstractMultimap.Values(this); }
  
  Iterator<V> valueIterator() { return new Object(this); }
  
  Spliterator<V> valueSpliterator() {
    return CollectSpliterators.flatMap(this.map
        .values().spliterator(), Collection::spliterator, 64, size());
  }
  
  Multiset<K> createKeys() { return new Multimaps.Keys(this); }
  
  public Collection<Map.Entry<K, V>> entries() { return super.entries(); }
  
  Collection<Map.Entry<K, V>> createEntries() {
    if (this instanceof SetMultimap)
      return new AbstractMultimap.EntrySet(this); 
    return new AbstractMultimap.Entries(this);
  }
  
  Iterator<Map.Entry<K, V>> entryIterator() { return new Object(this); }
  
  Spliterator<Map.Entry<K, V>> entrySpliterator() {
    return CollectSpliterators.flatMap(this.map
        .entrySet().spliterator(), keyToValueCollectionEntry -> {
          K key = (K)keyToValueCollectionEntry.getKey();
          Collection<V> valueCollection = (Collection)keyToValueCollectionEntry.getValue();
          return CollectSpliterators.map(valueCollection
              .spliterator(), ());
        }64, size());
  }
  
  public void forEach(BiConsumer<? super K, ? super V> action) { Preconditions.checkNotNull(action);
    this.map.forEach((key, valueCollection) -> 
        valueCollection.forEach(())); }
  
  Map<K, Collection<V>> createAsMap() { return new AsMap(this, this.map); }
  
  final Map<K, Collection<V>> createMaybeNavigableAsMap() {
    if (this.map instanceof NavigableMap)
      return new NavigableAsMap(this, (NavigableMap)this.map); 
    if (this.map instanceof SortedMap)
      return new SortedAsMap(this, (SortedMap)this.map); 
    return new AsMap(this, this.map);
  }
  
  abstract Collection<V> createCollection();
}
