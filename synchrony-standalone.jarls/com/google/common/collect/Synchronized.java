package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.VisibleForTesting;
import java.util.Collection;
import java.util.Deque;
import java.util.List;
import java.util.Map;
import java.util.NavigableMap;
import java.util.NavigableSet;
import java.util.Queue;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible(emulated = true)
final class Synchronized {
  private static <E> Collection<E> collection(Collection<E> collection, @CheckForNull Object mutex) { return new SynchronizedCollection(collection, mutex, null); }
  
  @VisibleForTesting
  static <E> Set<E> set(Set<E> set, @CheckForNull Object mutex) { return new SynchronizedSet(set, mutex); }
  
  private static <E> SortedSet<E> sortedSet(SortedSet<E> set, @CheckForNull Object mutex) { return new SynchronizedSortedSet(set, mutex); }
  
  private static <E> List<E> list(List<E> list, @CheckForNull Object mutex) {
    return (list instanceof java.util.RandomAccess) ? 
      new SynchronizedRandomAccessList(list, mutex) : 
      new SynchronizedList(list, mutex);
  }
  
  static <E> Multiset<E> multiset(Multiset<E> multiset, @CheckForNull Object mutex) {
    if (multiset instanceof SynchronizedMultiset || multiset instanceof ImmutableMultiset)
      return multiset; 
    return new SynchronizedMultiset(multiset, mutex);
  }
  
  static <K, V> Multimap<K, V> multimap(Multimap<K, V> multimap, @CheckForNull Object mutex) {
    if (multimap instanceof SynchronizedMultimap || multimap instanceof BaseImmutableMultimap)
      return multimap; 
    return new SynchronizedMultimap(multimap, mutex);
  }
  
  static <K, V> ListMultimap<K, V> listMultimap(ListMultimap<K, V> multimap, @CheckForNull Object mutex) {
    if (multimap instanceof SynchronizedListMultimap || multimap instanceof BaseImmutableMultimap)
      return multimap; 
    return new SynchronizedListMultimap(multimap, mutex);
  }
  
  static <K, V> SetMultimap<K, V> setMultimap(SetMultimap<K, V> multimap, @CheckForNull Object mutex) {
    if (multimap instanceof SynchronizedSetMultimap || multimap instanceof BaseImmutableMultimap)
      return multimap; 
    return new SynchronizedSetMultimap(multimap, mutex);
  }
  
  static <K, V> SortedSetMultimap<K, V> sortedSetMultimap(SortedSetMultimap<K, V> multimap, @CheckForNull Object mutex) {
    if (multimap instanceof SynchronizedSortedSetMultimap)
      return multimap; 
    return new SynchronizedSortedSetMultimap(multimap, mutex);
  }
  
  private static <E> Collection<E> typePreservingCollection(Collection<E> collection, @CheckForNull Object mutex) {
    if (collection instanceof SortedSet)
      return sortedSet((SortedSet)collection, mutex); 
    if (collection instanceof Set)
      return set((Set)collection, mutex); 
    if (collection instanceof List)
      return list((List)collection, mutex); 
    return collection(collection, mutex);
  }
  
  private static <E> Set<E> typePreservingSet(Set<E> set, @CheckForNull Object mutex) {
    if (set instanceof SortedSet)
      return sortedSet((SortedSet)set, mutex); 
    return set(set, mutex);
  }
  
  @VisibleForTesting
  static <K, V> Map<K, V> map(Map<K, V> map, @CheckForNull Object mutex) { return new SynchronizedMap(map, mutex); }
  
  static <K, V> SortedMap<K, V> sortedMap(SortedMap<K, V> sortedMap, @CheckForNull Object mutex) { return new SynchronizedSortedMap(sortedMap, mutex); }
  
  static <K, V> BiMap<K, V> biMap(BiMap<K, V> bimap, @CheckForNull Object mutex) {
    if (bimap instanceof SynchronizedBiMap || bimap instanceof ImmutableBiMap)
      return bimap; 
    return new SynchronizedBiMap(bimap, mutex, null, null);
  }
  
  @GwtIncompatible
  static <E> NavigableSet<E> navigableSet(NavigableSet<E> navigableSet, @CheckForNull Object mutex) { return new SynchronizedNavigableSet(navigableSet, mutex); }
  
  @GwtIncompatible
  static <E> NavigableSet<E> navigableSet(NavigableSet<E> navigableSet) { return navigableSet(navigableSet, null); }
  
  @GwtIncompatible
  static <K, V> NavigableMap<K, V> navigableMap(NavigableMap<K, V> navigableMap) { return navigableMap(navigableMap, null); }
  
  @GwtIncompatible
  static <K, V> NavigableMap<K, V> navigableMap(NavigableMap<K, V> navigableMap, @CheckForNull Object mutex) { return new SynchronizedNavigableMap(navigableMap, mutex); }
  
  @CheckForNull
  @GwtIncompatible
  private static <K, V> Map.Entry<K, V> nullableSynchronizedEntry(@CheckForNull Map.Entry<K, V> entry, @CheckForNull Object mutex) {
    if (entry == null)
      return null; 
    return new SynchronizedEntry(entry, mutex);
  }
  
  static <E> Queue<E> queue(Queue<E> queue, @CheckForNull Object mutex) { return (queue instanceof SynchronizedQueue) ? queue : new SynchronizedQueue(queue, mutex); }
  
  static <E> Deque<E> deque(Deque<E> deque, @CheckForNull Object mutex) { return new SynchronizedDeque(deque, mutex); }
  
  static <R, C, V> Table<R, C, V> table(Table<R, C, V> table, @CheckForNull Object mutex) { return new SynchronizedTable(table, mutex); }
}
