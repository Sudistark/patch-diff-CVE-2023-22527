package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.base.Preconditions;
import com.google.common.primitives.Ints;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Comparator;
import java.util.Iterator;
import java.util.NavigableSet;
import java.util.Objects;
import java.util.Set;
import java.util.function.ObjIntConsumer;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible(emulated = true)
public final class TreeMultiset<E> extends AbstractSortedMultiset<E> implements Serializable {
  private final Reference<AvlNode<E>> rootReference;
  
  private final GeneralRange<E> range;
  
  private final AvlNode<E> header;
  
  @GwtIncompatible
  @J2ktIncompatible
  private static final long serialVersionUID = 1L;
  
  public static <E extends Comparable> TreeMultiset<E> create() { return new TreeMultiset(Ordering.natural()); }
  
  public static <E> TreeMultiset<E> create(@CheckForNull Comparator<? super E> comparator) {
    return (comparator == null) ? 
      new TreeMultiset(Ordering.natural()) : 
      new TreeMultiset(comparator);
  }
  
  public static <E extends Comparable> TreeMultiset<E> create(Iterable<? extends E> elements) {
    TreeMultiset<E> multiset = create();
    Iterables.addAll(multiset, elements);
    return multiset;
  }
  
  TreeMultiset(Reference<AvlNode<E>> rootReference, GeneralRange<E> range, AvlNode<E> endLink) {
    super(range.comparator());
    this.rootReference = rootReference;
    this.range = range;
    this.header = endLink;
  }
  
  TreeMultiset(Comparator<? super E> comparator) {
    super(comparator);
    this.range = GeneralRange.all(comparator);
    this.header = new AvlNode();
    successor(this.header, this.header);
    this.rootReference = new Reference(null);
  }
  
  private long aggregateForEntries(Aggregate aggr) {
    AvlNode<E> root = (AvlNode)this.rootReference.get();
    long total = aggr.treeAggregate(root);
    if (this.range.hasLowerBound())
      total -= aggregateBelowRange(aggr, root); 
    if (this.range.hasUpperBound())
      total -= aggregateAboveRange(aggr, root); 
    return total;
  }
  
  private long aggregateBelowRange(Aggregate aggr, @CheckForNull AvlNode<E> node) {
    if (node == null)
      return 0L; 
    int cmp = comparator().compare(NullnessCasts.uncheckedCastNullableTToT(this.range.getLowerEndpoint()), node.getElement());
    if (cmp < 0)
      return aggregateBelowRange(aggr, AvlNode.access$500(node)); 
    if (cmp == 0) {
      switch (null.$SwitchMap$com$google$common$collect$BoundType[this.range.getLowerBoundType().ordinal()]) {
        case 1:
          return aggr.nodeAggregate(node) + aggr.treeAggregate(AvlNode.access$500(node));
        case 2:
          return aggr.treeAggregate(AvlNode.access$500(node));
      } 
      throw new AssertionError();
    } 
    return aggr.treeAggregate(AvlNode.access$500(node)) + aggr
      .nodeAggregate(node) + 
      aggregateBelowRange(aggr, AvlNode.access$600(node));
  }
  
  private long aggregateAboveRange(Aggregate aggr, @CheckForNull AvlNode<E> node) {
    if (node == null)
      return 0L; 
    int cmp = comparator().compare(NullnessCasts.uncheckedCastNullableTToT(this.range.getUpperEndpoint()), node.getElement());
    if (cmp > 0)
      return aggregateAboveRange(aggr, AvlNode.access$600(node)); 
    if (cmp == 0) {
      switch (null.$SwitchMap$com$google$common$collect$BoundType[this.range.getUpperBoundType().ordinal()]) {
        case 1:
          return aggr.nodeAggregate(node) + aggr.treeAggregate(AvlNode.access$600(node));
        case 2:
          return aggr.treeAggregate(AvlNode.access$600(node));
      } 
      throw new AssertionError();
    } 
    return aggr.treeAggregate(AvlNode.access$600(node)) + aggr
      .nodeAggregate(node) + 
      aggregateAboveRange(aggr, AvlNode.access$500(node));
  }
  
  public int size() { return Ints.saturatedCast(aggregateForEntries(Aggregate.SIZE)); }
  
  int distinctElements() { return Ints.saturatedCast(aggregateForEntries(Aggregate.DISTINCT)); }
  
  static int distinctElements(@CheckForNull AvlNode<?> node) { return (node == null) ? 0 : AvlNode.access$400(node); }
  
  public int count(@CheckForNull Object element) {
    try {
      E e = (E)element;
      AvlNode<E> root = (AvlNode)this.rootReference.get();
      if (!this.range.contains(e) || root == null)
        return 0; 
      return root.count(comparator(), e);
    } catch (ClassCastException|NullPointerException e) {
      return 0;
    } 
  }
  
  @CanIgnoreReturnValue
  public int add(@ParametricNullness E element, int occurrences) {
    CollectPreconditions.checkNonnegative(occurrences, "occurrences");
    if (occurrences == 0)
      return count(element); 
    Preconditions.checkArgument(this.range.contains(element));
    AvlNode<E> root = (AvlNode)this.rootReference.get();
    if (root == null) {
      int unused = comparator().compare(element, element);
      AvlNode<E> newRoot = new AvlNode<E>(element, occurrences);
      successor(this.header, newRoot, this.header);
      this.rootReference.checkAndSet(root, newRoot);
      return 0;
    } 
    int[] result = new int[1];
    AvlNode<E> newRoot = root.add(comparator(), element, occurrences, result);
    this.rootReference.checkAndSet(root, newRoot);
    return result[0];
  }
  
  @CanIgnoreReturnValue
  public int remove(@CheckForNull Object element, int occurrences) {
    AvlNode<E> newRoot;
    CollectPreconditions.checkNonnegative(occurrences, "occurrences");
    if (occurrences == 0)
      return count(element); 
    AvlNode<E> root = (AvlNode)this.rootReference.get();
    int[] result = new int[1];
    try {
      E e = (E)element;
      if (!this.range.contains(e) || root == null)
        return 0; 
      newRoot = root.remove(comparator(), e, occurrences, result);
    } catch (ClassCastException|NullPointerException e) {
      return 0;
    } 
    this.rootReference.checkAndSet(root, newRoot);
    return result[0];
  }
  
  @CanIgnoreReturnValue
  public int setCount(@ParametricNullness E element, int count) {
    CollectPreconditions.checkNonnegative(count, "count");
    if (!this.range.contains(element)) {
      Preconditions.checkArgument((count == 0));
      return 0;
    } 
    AvlNode<E> root = (AvlNode)this.rootReference.get();
    if (root == null) {
      if (count > 0)
        add(element, count); 
      return 0;
    } 
    int[] result = new int[1];
    AvlNode<E> newRoot = root.setCount(comparator(), element, count, result);
    this.rootReference.checkAndSet(root, newRoot);
    return result[0];
  }
  
  @CanIgnoreReturnValue
  public boolean setCount(@ParametricNullness E element, int oldCount, int newCount) {
    CollectPreconditions.checkNonnegative(newCount, "newCount");
    CollectPreconditions.checkNonnegative(oldCount, "oldCount");
    Preconditions.checkArgument(this.range.contains(element));
    AvlNode<E> root = (AvlNode)this.rootReference.get();
    if (root == null) {
      if (oldCount == 0) {
        if (newCount > 0)
          add(element, newCount); 
        return true;
      } 
      return false;
    } 
    int[] result = new int[1];
    AvlNode<E> newRoot = root.setCount(comparator(), element, oldCount, newCount, result);
    this.rootReference.checkAndSet(root, newRoot);
    return (result[0] == oldCount);
  }
  
  public void clear() {
    if (!this.range.hasLowerBound() && !this.range.hasUpperBound()) {
      for (AvlNode<E> current = AvlNode.access$700(this.header); current != this.header; ) {
        AvlNode<E> next = AvlNode.access$700(current);
        AvlNode.access$202(current, 0);
        AvlNode.access$502(current, null);
        AvlNode.access$602(current, null);
        AvlNode.access$802(current, null);
        AvlNode.access$902(current, null);
        current = next;
      } 
      successor(this.header, this.header);
      this.rootReference.clear();
    } else {
      Iterators.clear(entryIterator());
    } 
  }
  
  private Multiset.Entry<E> wrapEntry(AvlNode<E> baseEntry) { return new Object(this, baseEntry); }
  
  @CheckForNull
  private AvlNode<E> firstNode() {
    AvlNode<E> node, root = (AvlNode)this.rootReference.get();
    if (root == null)
      return null; 
    if (this.range.hasLowerBound()) {
      E endpoint = (E)NullnessCasts.uncheckedCastNullableTToT(this.range.getLowerEndpoint());
      node = AvlNode.access$1000(root, comparator(), endpoint);
      if (node == null)
        return null; 
      if (this.range.getLowerBoundType() == BoundType.OPEN && 
        comparator().compare(endpoint, node.getElement()) == 0)
        node = AvlNode.access$700(node); 
    } else {
      node = AvlNode.access$700(this.header);
    } 
    return (node == this.header || !this.range.contains(node.getElement())) ? null : node;
  }
  
  @CheckForNull
  private AvlNode<E> lastNode() {
    AvlNode<E> node, root = (AvlNode)this.rootReference.get();
    if (root == null)
      return null; 
    if (this.range.hasUpperBound()) {
      E endpoint = (E)NullnessCasts.uncheckedCastNullableTToT(this.range.getUpperEndpoint());
      node = AvlNode.access$1100(root, comparator(), endpoint);
      if (node == null)
        return null; 
      if (this.range.getUpperBoundType() == BoundType.OPEN && 
        comparator().compare(endpoint, node.getElement()) == 0)
        node = AvlNode.access$1200(node); 
    } else {
      node = AvlNode.access$1200(this.header);
    } 
    return (node == this.header || !this.range.contains(node.getElement())) ? null : node;
  }
  
  Iterator<E> elementIterator() { return Multisets.elementIterator(entryIterator()); }
  
  Iterator<Multiset.Entry<E>> entryIterator() { return new Object(this); }
  
  Iterator<Multiset.Entry<E>> descendingEntryIterator() { return new Object(this); }
  
  public void forEachEntry(ObjIntConsumer<? super E> action) {
    Preconditions.checkNotNull(action);
    AvlNode<E> node = firstNode();
    for (; node != this.header && node != null && !this.range.tooHigh(node.getElement()); 
      node = AvlNode.access$700(node))
      action.accept(node.getElement(), node.getCount()); 
  }
  
  public Iterator<E> iterator() { return Multisets.iteratorImpl(this); }
  
  public SortedMultiset<E> headMultiset(@ParametricNullness E upperBound, BoundType boundType) {
    return new TreeMultiset(this.rootReference, this.range
        
        .intersect(GeneralRange.upTo(comparator(), upperBound, boundType)), this.header);
  }
  
  public SortedMultiset<E> tailMultiset(@ParametricNullness E lowerBound, BoundType boundType) {
    return new TreeMultiset(this.rootReference, this.range
        
        .intersect(GeneralRange.downTo(comparator(), lowerBound, boundType)), this.header);
  }
  
  private static <T> void successor(AvlNode<T> a, AvlNode<T> b) {
    AvlNode.access$902(a, b);
    AvlNode.access$802(b, a);
  }
  
  private static <T> void successor(AvlNode<T> a, AvlNode<T> b, AvlNode<T> c) {
    successor(a, b);
    successor(b, c);
  }
  
  @J2ktIncompatible
  @GwtIncompatible
  private void writeObject(ObjectOutputStream stream) throws IOException {
    stream.defaultWriteObject();
    stream.writeObject(elementSet().comparator());
    Serialization.writeMultiset(this, stream);
  }
  
  @J2ktIncompatible
  @GwtIncompatible
  private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    stream.defaultReadObject();
    Comparator<? super E> comparator = (Comparator)Objects.requireNonNull(stream.readObject());
    Serialization.getFieldSetter(AbstractSortedMultiset.class, "comparator").set(this, comparator);
    Serialization.getFieldSetter(TreeMultiset.class, "range")
      .set(this, GeneralRange.all(comparator));
    Serialization.getFieldSetter(TreeMultiset.class, "rootReference")
      .set(this, new Reference(null));
    AvlNode<E> header = new AvlNode<E>();
    Serialization.getFieldSetter(TreeMultiset.class, "header").set(this, header);
    successor(header, header);
    Serialization.populateMultiset(this, stream);
  }
}
