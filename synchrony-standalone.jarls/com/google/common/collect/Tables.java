package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.google.common.base.Supplier;
import java.util.Map;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collector;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible
public final class Tables {
  public static <T, R, C, V, I extends Table<R, C, V>> Collector<T, ?, I> toTable(Function<? super T, ? extends R> rowFunction, Function<? super T, ? extends C> columnFunction, Function<? super T, ? extends V> valueFunction, Supplier<I> tableSupplier) { return TableCollectors.toTable(rowFunction, columnFunction, valueFunction, tableSupplier); }
  
  public static <T, R, C, V, I extends Table<R, C, V>> Collector<T, ?, I> toTable(Function<? super T, ? extends R> rowFunction, Function<? super T, ? extends C> columnFunction, Function<? super T, ? extends V> valueFunction, BinaryOperator<V> mergeFunction, Supplier<I> tableSupplier) { return TableCollectors.toTable(rowFunction, columnFunction, valueFunction, mergeFunction, tableSupplier); }
  
  public static <R, C, V> Table.Cell<R, C, V> immutableCell(@ParametricNullness R rowKey, @ParametricNullness C columnKey, @ParametricNullness V value) { return new ImmutableCell(rowKey, columnKey, value); }
  
  public static <R, C, V> Table<C, R, V> transpose(Table<R, C, V> table) {
    return (table instanceof TransposeTable) ? 
      ((TransposeTable)table).original : 
      new TransposeTable(table);
  }
  
  public static <R, C, V> Table<R, C, V> newCustomTable(Map<R, Map<C, V>> backingMap, Supplier<? extends Map<C, V>> factory) {
    Preconditions.checkArgument(backingMap.isEmpty());
    Preconditions.checkNotNull(factory);
    return new StandardTable(backingMap, factory);
  }
  
  public static <R, C, V1, V2> Table<R, C, V2> transformValues(Table<R, C, V1> fromTable, Function<? super V1, V2> function) { return new TransformedTable(fromTable, function); }
  
  public static <R, C, V> Table<R, C, V> unmodifiableTable(Table<? extends R, ? extends C, ? extends V> table) { return new UnmodifiableTable(table); }
  
  public static <R, C, V> RowSortedTable<R, C, V> unmodifiableRowSortedTable(RowSortedTable<R, ? extends C, ? extends V> table) { return new UnmodifiableRowSortedMap(table); }
  
  private static <K, V> Function<Map<K, V>, Map<K, V>> unmodifiableWrapper() { return UNMODIFIABLE_WRAPPER; }
  
  private static final Function<? extends Map<?, ?>, ? extends Map<?, ?>> UNMODIFIABLE_WRAPPER = new Object();
  
  public static <R, C, V> Table<R, C, V> synchronizedTable(Table<R, C, V> table) { return Synchronized.table(table, null); }
  
  static boolean equalsImpl(Table<?, ?, ?> table, @CheckForNull Object obj) {
    if (obj == table)
      return true; 
    if (obj instanceof Table) {
      Table<?, ?, ?> that = (Table)obj;
      return table.cellSet().equals(that.cellSet());
    } 
    return false;
  }
}
