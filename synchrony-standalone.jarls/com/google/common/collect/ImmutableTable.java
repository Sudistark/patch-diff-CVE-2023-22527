package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.base.MoreObjects;
import com.google.common.base.Preconditions;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.DoNotCall;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.Spliterator;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.stream.Collector;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible
public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V> implements Serializable {
  private static final long serialVersionUID = -889275714L;
  
  public static <T, R, C, V> Collector<T, ?, ImmutableTable<R, C, V>> toImmutableTable(Function<? super T, ? extends R> rowFunction, Function<? super T, ? extends C> columnFunction, Function<? super T, ? extends V> valueFunction) { return TableCollectors.toImmutableTable(rowFunction, columnFunction, valueFunction); }
  
  public static <T, R, C, V> Collector<T, ?, ImmutableTable<R, C, V>> toImmutableTable(Function<? super T, ? extends R> rowFunction, Function<? super T, ? extends C> columnFunction, Function<? super T, ? extends V> valueFunction, BinaryOperator<V> mergeFunction) { return TableCollectors.toImmutableTable(rowFunction, columnFunction, valueFunction, mergeFunction); }
  
  public static <R, C, V> ImmutableTable<R, C, V> of() { return SparseImmutableTable.EMPTY; }
  
  public static <R, C, V> ImmutableTable<R, C, V> of(R rowKey, C columnKey, V value) { return new SingletonImmutableTable(rowKey, columnKey, value); }
  
  public static <R, C, V> ImmutableTable<R, C, V> copyOf(Table<? extends R, ? extends C, ? extends V> table) {
    if (table instanceof ImmutableTable)
      return (ImmutableTable)table; 
    return copyOf(table.cellSet());
  }
  
  static <R, C, V> ImmutableTable<R, C, V> copyOf(Iterable<? extends Table.Cell<? extends R, ? extends C, ? extends V>> cells) {
    Builder<R, C, V> builder = builder();
    for (Table.Cell<? extends R, ? extends C, ? extends V> cell : cells)
      builder.put(cell); 
    return builder.build();
  }
  
  public static <R, C, V> Builder<R, C, V> builder() { return new Builder(); }
  
  static <R, C, V> Table.Cell<R, C, V> cellOf(R rowKey, C columnKey, V value) {
    return Tables.immutableCell(
        Preconditions.checkNotNull(rowKey, "rowKey"), 
        Preconditions.checkNotNull(columnKey, "columnKey"), 
        Preconditions.checkNotNull(value, "value"));
  }
  
  public ImmutableSet<Table.Cell<R, C, V>> cellSet() { return (ImmutableSet)super.cellSet(); }
  
  final UnmodifiableIterator<Table.Cell<R, C, V>> cellIterator() { throw new AssertionError("should never be called"); }
  
  final Spliterator<Table.Cell<R, C, V>> cellSpliterator() { throw new AssertionError("should never be called"); }
  
  public ImmutableCollection<V> values() { return (ImmutableCollection)super.values(); }
  
  final Iterator<V> valuesIterator() { throw new AssertionError("should never be called"); }
  
  public ImmutableMap<R, V> column(C columnKey) {
    Preconditions.checkNotNull(columnKey, "columnKey");
    return (ImmutableMap)MoreObjects.firstNonNull((ImmutableMap)
        columnMap().get(columnKey), ImmutableMap.of());
  }
  
  public ImmutableSet<C> columnKeySet() { return columnMap().keySet(); }
  
  public ImmutableMap<C, V> row(R rowKey) {
    Preconditions.checkNotNull(rowKey, "rowKey");
    return (ImmutableMap)MoreObjects.firstNonNull((ImmutableMap)
        rowMap().get(rowKey), ImmutableMap.of());
  }
  
  public ImmutableSet<R> rowKeySet() { return rowMap().keySet(); }
  
  public boolean contains(@CheckForNull Object rowKey, @CheckForNull Object columnKey) { return (get(rowKey, columnKey) != null); }
  
  public boolean containsValue(@CheckForNull Object value) { return values().contains(value); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public final void clear() { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @CheckForNull
  @CanIgnoreReturnValue
  @DoNotCall("Always throws UnsupportedOperationException")
  public final V put(R rowKey, C columnKey, V value) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public final void putAll(Table<? extends R, ? extends C, ? extends V> table) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @CheckForNull
  @CanIgnoreReturnValue
  @DoNotCall("Always throws UnsupportedOperationException")
  public final V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) { throw new UnsupportedOperationException(); }
  
  final Object writeReplace() { return createSerializedForm(); }
  
  @GwtIncompatible
  @J2ktIncompatible
  private void readObject(ObjectInputStream stream) throws InvalidObjectException { throw new InvalidObjectException("Use SerializedForm"); }
  
  abstract ImmutableSet<Table.Cell<R, C, V>> createCellSet();
  
  abstract ImmutableCollection<V> createValues();
  
  public abstract ImmutableMap<C, Map<R, V>> columnMap();
  
  public abstract ImmutableMap<R, Map<C, V>> rowMap();
  
  abstract SerializedForm createSerializedForm();
}
