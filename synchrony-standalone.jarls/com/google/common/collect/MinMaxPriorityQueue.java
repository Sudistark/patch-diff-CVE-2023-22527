package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.math.IntMath;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.util.AbstractQueue;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Objects;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible
public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
  private final Heap minHeap;
  
  private final Heap maxHeap;
  
  @VisibleForTesting
  final int maximumSize;
  
  private Object[] queue;
  
  private int size;
  
  private int modCount;
  
  private static final int EVEN_POWERS_OF_TWO = 1431655765;
  
  private static final int ODD_POWERS_OF_TWO = -1431655766;
  
  private static final int DEFAULT_CAPACITY = 11;
  
  public static <E extends Comparable<E>> MinMaxPriorityQueue<E> create() { return (new Builder(Ordering.natural(), null)).create(); }
  
  public static <E extends Comparable<E>> MinMaxPriorityQueue<E> create(Iterable<? extends E> initialContents) { return (new Builder(Ordering.natural(), null)).create(initialContents); }
  
  public static <B> Builder<B> orderedBy(Comparator<B> comparator) { return new Builder(comparator, null); }
  
  public static Builder<Comparable> expectedSize(int expectedSize) { return (new Builder(Ordering.natural(), null)).expectedSize(expectedSize); }
  
  public static Builder<Comparable> maximumSize(int maximumSize) { return (new Builder(Ordering.natural(), null)).maximumSize(maximumSize); }
  
  private MinMaxPriorityQueue(Builder<? super E> builder, int queueSize) {
    Ordering<E> ordering = Builder.access$200(builder);
    this.minHeap = new Heap(this, ordering);
    this.maxHeap = new Heap(this, ordering.reverse());
    this.minHeap.otherHeap = this.maxHeap;
    this.maxHeap.otherHeap = this.minHeap;
    this.maximumSize = Builder.access$300(builder);
    this.queue = new Object[queueSize];
  }
  
  public int size() { return this.size; }
  
  @CanIgnoreReturnValue
  public boolean add(E element) {
    offer(element);
    return true;
  }
  
  @CanIgnoreReturnValue
  public boolean addAll(Collection<? extends E> newElements) {
    boolean modified = false;
    for (E element : newElements) {
      offer(element);
      modified = true;
    } 
    return modified;
  }
  
  @CanIgnoreReturnValue
  public boolean offer(E element) {
    Preconditions.checkNotNull(element);
    this.modCount++;
    int insertIndex = this.size++;
    growIfNeeded();
    heapForIndex(insertIndex).bubbleUp(insertIndex, element);
    return (this.size <= this.maximumSize || pollLast() != element);
  }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public E poll() { return (E)(isEmpty() ? null : removeAndGet(0)); }
  
  E elementData(int index) { return (E)Objects.requireNonNull(this.queue[index]); }
  
  @CheckForNull
  public E peek() { return (E)(isEmpty() ? null : elementData(0)); }
  
  private int getMaxElementIndex() {
    switch (this.size) {
      case 1:
        return 0;
      case 2:
        return 1;
    } 
    return (this.maxHeap.compareElements(1, 2) <= 0) ? 1 : 2;
  }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public E pollFirst() { return (E)poll(); }
  
  @CanIgnoreReturnValue
  public E removeFirst() { return (E)remove(); }
  
  @CheckForNull
  public E peekFirst() { return (E)peek(); }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public E pollLast() { return (E)(isEmpty() ? null : removeAndGet(getMaxElementIndex())); }
  
  @CanIgnoreReturnValue
  public E removeLast() {
    if (isEmpty())
      throw new NoSuchElementException(); 
    return (E)removeAndGet(getMaxElementIndex());
  }
  
  @CheckForNull
  public E peekLast() { return (E)(isEmpty() ? null : elementData(getMaxElementIndex())); }
  
  @CheckForNull
  @VisibleForTesting
  @CanIgnoreReturnValue
  MoveDesc<E> removeAt(int index) {
    Preconditions.checkPositionIndex(index, this.size);
    this.modCount++;
    this.size--;
    if (this.size == index) {
      this.queue[this.size] = null;
      return null;
    } 
    E actualLastElement = (E)elementData(this.size);
    int lastElementAt = heapForIndex(this.size).swapWithConceptuallyLastElement(actualLastElement);
    if (lastElementAt == index) {
      this.queue[this.size] = null;
      return null;
    } 
    E toTrickle = (E)elementData(this.size);
    this.queue[this.size] = null;
    MoveDesc<E> changes = fillHole(index, toTrickle);
    if (lastElementAt < index) {
      if (changes == null)
        return new MoveDesc(actualLastElement, toTrickle); 
      return new MoveDesc(actualLastElement, changes.replaced);
    } 
    return changes;
  }
  
  @CheckForNull
  private MoveDesc<E> fillHole(int index, E toTrickle) {
    Heap heap = heapForIndex(index);
    int vacated = heap.fillHoleAt(index);
    int bubbledTo = heap.bubbleUpAlternatingLevels(vacated, toTrickle);
    if (bubbledTo == vacated)
      return heap.tryCrossOverAndBubbleUp(index, vacated, toTrickle); 
    return (bubbledTo < index) ? new MoveDesc(toTrickle, elementData(index)) : null;
  }
  
  private E removeAndGet(int index) {
    E value = (E)elementData(index);
    removeAt(index);
    return value;
  }
  
  private Heap heapForIndex(int i) { return isEvenLevel(i) ? this.minHeap : this.maxHeap; }
  
  @VisibleForTesting
  static boolean isEvenLevel(int index) {
    int oneBased = index + 1 ^ 0xFFFFFFFF ^ 0xFFFFFFFF;
    Preconditions.checkState((oneBased > 0), "negative index");
    return ((oneBased & 0x55555555) > (oneBased & 0xAAAAAAAA));
  }
  
  @VisibleForTesting
  boolean isIntact() {
    for (int i = 1; i < this.size; i++) {
      if (!Heap.access$400(heapForIndex(i), i))
        return false; 
    } 
    return true;
  }
  
  public Iterator<E> iterator() { return new QueueIterator(this, null); }
  
  public void clear() {
    for (int i = 0; i < this.size; i++)
      this.queue[i] = null; 
    this.size = 0;
  }
  
  @J2ktIncompatible
  public Object[] toArray() {
    Object[] copyTo = new Object[this.size];
    System.arraycopy(this.queue, 0, copyTo, 0, this.size);
    return copyTo;
  }
  
  public Comparator<? super E> comparator() { return this.minHeap.ordering; }
  
  @VisibleForTesting
  int capacity() { return this.queue.length; }
  
  @VisibleForTesting
  static int initialQueueSize(int configuredExpectedSize, int maximumSize, Iterable<?> initialContents) {
    int result = (configuredExpectedSize == -1) ? 11 : configuredExpectedSize;
    if (initialContents instanceof Collection) {
      int initialSize = ((Collection)initialContents).size();
      result = Math.max(result, initialSize);
    } 
    return capAtMaximumSize(result, maximumSize);
  }
  
  private void growIfNeeded() {
    if (this.size > this.queue.length) {
      int newCapacity = calculateNewCapacity();
      Object[] newQueue = new Object[newCapacity];
      System.arraycopy(this.queue, 0, newQueue, 0, this.queue.length);
      this.queue = newQueue;
    } 
  }
  
  private int calculateNewCapacity() {
    int oldCapacity = this.queue.length;
    int newCapacity = (oldCapacity < 64) ? ((oldCapacity + 1) * 2) : IntMath.checkedMultiply(oldCapacity / 2, 3);
    return capAtMaximumSize(newCapacity, this.maximumSize);
  }
  
  private static int capAtMaximumSize(int queueSize, int maximumSize) { return Math.min(queueSize - 1, maximumSize) + 1; }
}
