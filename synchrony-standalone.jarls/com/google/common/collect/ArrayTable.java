package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.Objects;
import com.google.common.base.Preconditions;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.DoNotCall;
import com.google.errorprone.annotations.concurrent.LazyInit;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.Spliterator;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible(emulated = true)
public final class ArrayTable<R, C, V> extends AbstractTable<R, C, V> implements Serializable {
  private final ImmutableList<R> rowList;
  
  private final ImmutableList<C> columnList;
  
  private final ImmutableMap<R, Integer> rowKeyToIndex;
  
  private final ImmutableMap<C, Integer> columnKeyToIndex;
  
  private final V[][] array;
  
  @LazyInit
  @CheckForNull
  private ColumnMap columnMap;
  
  @LazyInit
  @CheckForNull
  private RowMap rowMap;
  
  private static final long serialVersionUID = 0L;
  
  public static <R, C, V> ArrayTable<R, C, V> create(Iterable<? extends R> rowKeys, Iterable<? extends C> columnKeys) { return new ArrayTable(rowKeys, columnKeys); }
  
  public static <R, C, V> ArrayTable<R, C, V> create(Table<R, C, ? extends V> table) {
    return (table instanceof ArrayTable) ? 
      new ArrayTable((ArrayTable)table) : 
      new ArrayTable(table);
  }
  
  private ArrayTable(Iterable<? extends R> rowKeys, Iterable<? extends C> columnKeys) {
    this.rowList = ImmutableList.copyOf(rowKeys);
    this.columnList = ImmutableList.copyOf(columnKeys);
    Preconditions.checkArgument((this.rowList.isEmpty() == this.columnList.isEmpty()));
    this.rowKeyToIndex = Maps.indexMap(this.rowList);
    this.columnKeyToIndex = Maps.indexMap(this.columnList);
    V[][] tmpArray = (V[][])new Object[this.rowList.size()][this.columnList.size()];
    this.array = tmpArray;
    eraseAll();
  }
  
  private ArrayTable(Table<R, C, ? extends V> table) {
    this(table.rowKeySet(), table.columnKeySet());
    putAll(table);
  }
  
  private ArrayTable(ArrayTable<R, C, V> table) {
    this.rowList = table.rowList;
    this.columnList = table.columnList;
    this.rowKeyToIndex = table.rowKeyToIndex;
    this.columnKeyToIndex = table.columnKeyToIndex;
    V[][] copy = (V[][])new Object[this.rowList.size()][this.columnList.size()];
    this.array = copy;
    for (int i = 0; i < this.rowList.size(); i++)
      System.arraycopy(table.array[i], 0, copy[i], 0, table.array[i].length); 
  }
  
  public ImmutableList<R> rowKeyList() { return this.rowList; }
  
  public ImmutableList<C> columnKeyList() { return this.columnList; }
  
  @CheckForNull
  public V at(int rowIndex, int columnIndex) {
    Preconditions.checkElementIndex(rowIndex, this.rowList.size());
    Preconditions.checkElementIndex(columnIndex, this.columnList.size());
    return (V)this.array[rowIndex][columnIndex];
  }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V set(int rowIndex, int columnIndex, @CheckForNull V value) {
    Preconditions.checkElementIndex(rowIndex, this.rowList.size());
    Preconditions.checkElementIndex(columnIndex, this.columnList.size());
    V oldValue = (V)this.array[rowIndex][columnIndex];
    this.array[rowIndex][columnIndex] = value;
    return oldValue;
  }
  
  @GwtIncompatible
  public V[][] toArray(Class<V> valueClass) {
    V[][] copy = (V[][])(Object[][])Array.newInstance(valueClass, new int[] { this.rowList.size(), this.columnList.size() });
    for (int i = 0; i < this.rowList.size(); i++)
      System.arraycopy(this.array[i], 0, copy[i], 0, this.array[i].length); 
    return copy;
  }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public void clear() { throw new UnsupportedOperationException(); }
  
  public void eraseAll() {
    Object[][] arrayOfObject;
    int i;
    byte b;
    for (arrayOfObject = this.array, i = arrayOfObject.length, b = 0; b < i; ) {
      V[] row = (V[])arrayOfObject[b];
      Arrays.fill(row, null);
      b++;
    } 
  }
  
  public boolean contains(@CheckForNull Object rowKey, @CheckForNull Object columnKey) { return (containsRow(rowKey) && containsColumn(columnKey)); }
  
  public boolean containsColumn(@CheckForNull Object columnKey) { return this.columnKeyToIndex.containsKey(columnKey); }
  
  public boolean containsRow(@CheckForNull Object rowKey) { return this.rowKeyToIndex.containsKey(rowKey); }
  
  public boolean containsValue(@CheckForNull Object value) {
    Object[][] arrayOfObject;
    int i;
    byte b;
    for (arrayOfObject = this.array, i = arrayOfObject.length, b = 0; b < i; ) {
      V[] row = (V[])arrayOfObject[b];
      for (V element : row) {
        if (Objects.equal(value, element))
          return true; 
      } 
      b++;
    } 
    return false;
  }
  
  @CheckForNull
  public V get(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
    Integer rowIndex = (Integer)this.rowKeyToIndex.get(rowKey);
    Integer columnIndex = (Integer)this.columnKeyToIndex.get(columnKey);
    return (V)((rowIndex == null || columnIndex == null) ? null : at(rowIndex.intValue(), columnIndex.intValue()));
  }
  
  public boolean isEmpty() { return (this.rowList.isEmpty() || this.columnList.isEmpty()); }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V put(R rowKey, C columnKey, @CheckForNull V value) {
    Preconditions.checkNotNull(rowKey);
    Preconditions.checkNotNull(columnKey);
    Integer rowIndex = (Integer)this.rowKeyToIndex.get(rowKey);
    Preconditions.checkArgument((rowIndex != null), "Row %s not in %s", rowKey, this.rowList);
    Integer columnIndex = (Integer)this.columnKeyToIndex.get(columnKey);
    Preconditions.checkArgument((columnIndex != null), "Column %s not in %s", columnKey, this.columnList);
    return (V)set(rowIndex.intValue(), columnIndex.intValue(), value);
  }
  
  public void putAll(Table<? extends R, ? extends C, ? extends V> table) { super.putAll(table); }
  
  @Deprecated
  @CheckForNull
  @DoNotCall("Always throws UnsupportedOperationException")
  @CanIgnoreReturnValue
  public V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) { throw new UnsupportedOperationException(); }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V erase(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
    Integer rowIndex = (Integer)this.rowKeyToIndex.get(rowKey);
    Integer columnIndex = (Integer)this.columnKeyToIndex.get(columnKey);
    if (rowIndex == null || columnIndex == null)
      return null; 
    return (V)set(rowIndex.intValue(), columnIndex.intValue(), null);
  }
  
  public int size() { return this.rowList.size() * this.columnList.size(); }
  
  public Set<Table.Cell<R, C, V>> cellSet() { return super.cellSet(); }
  
  Iterator<Table.Cell<R, C, V>> cellIterator() { return new Object(this, size()); }
  
  Spliterator<Table.Cell<R, C, V>> cellSpliterator() {
    return CollectSpliterators.indexed(
        size(), 273, this::getCell);
  }
  
  private Table.Cell<R, C, V> getCell(int index) { return new Object(this, index); }
  
  @CheckForNull
  private V getValue(int index) {
    int rowIndex = index / this.columnList.size();
    int columnIndex = index % this.columnList.size();
    return (V)at(rowIndex, columnIndex);
  }
  
  public Map<R, V> column(C columnKey) {
    Preconditions.checkNotNull(columnKey);
    Integer columnIndex = (Integer)this.columnKeyToIndex.get(columnKey);
    if (columnIndex == null)
      return Collections.emptyMap(); 
    return new Column(this, columnIndex.intValue());
  }
  
  public ImmutableSet<C> columnKeySet() { return this.columnKeyToIndex.keySet(); }
  
  public Map<C, Map<R, V>> columnMap() {
    ColumnMap map = this.columnMap;
    return (map == null) ? (this.columnMap = new ColumnMap(this, null)) : map;
  }
  
  public Map<C, V> row(R rowKey) {
    Preconditions.checkNotNull(rowKey);
    Integer rowIndex = (Integer)this.rowKeyToIndex.get(rowKey);
    if (rowIndex == null)
      return Collections.emptyMap(); 
    return new Row(this, rowIndex.intValue());
  }
  
  public ImmutableSet<R> rowKeySet() { return this.rowKeyToIndex.keySet(); }
  
  public Map<R, Map<C, V>> rowMap() {
    RowMap map = this.rowMap;
    return (map == null) ? (this.rowMap = new RowMap(this, null)) : map;
  }
  
  public Collection<V> values() { return super.values(); }
  
  Iterator<V> valuesIterator() { return new Object(this, size()); }
  
  Spliterator<V> valuesSpliterator() { return CollectSpliterators.indexed(size(), 16, this::getValue); }
}
