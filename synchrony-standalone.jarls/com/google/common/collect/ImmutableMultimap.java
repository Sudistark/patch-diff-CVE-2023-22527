package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.base.Preconditions;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.DoNotCall;
import java.io.Serializable;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.Spliterator;
import java.util.function.BiConsumer;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible(emulated = true)
public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V> implements Serializable {
  final ImmutableMap<K, ? extends ImmutableCollection<V>> map;
  
  final int size;
  
  @J2ktIncompatible
  private static final long serialVersionUID = 0L;
  
  public static <K, V> ImmutableMultimap<K, V> of() { return ImmutableListMultimap.of(); }
  
  public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1) { return ImmutableListMultimap.of(k1, v1); }
  
  public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1, K k2, V v2) { return ImmutableListMultimap.of(k1, v1, k2, v2); }
  
  public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3) { return ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3); }
  
  public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) { return ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4); }
  
  public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) { return ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5); }
  
  public static <K, V> Builder<K, V> builder() { return new Builder(); }
  
  public static <K, V> ImmutableMultimap<K, V> copyOf(Multimap<? extends K, ? extends V> multimap) {
    if (multimap instanceof ImmutableMultimap) {
      ImmutableMultimap<K, V> kvMultimap = (ImmutableMultimap)multimap;
      if (!kvMultimap.isPartialView())
        return kvMultimap; 
    } 
    return ImmutableListMultimap.copyOf(multimap);
  }
  
  public static <K, V> ImmutableMultimap<K, V> copyOf(Iterable<? extends Map.Entry<? extends K, ? extends V>> entries) { return ImmutableListMultimap.copyOf(entries); }
  
  ImmutableMultimap(ImmutableMap<K, ? extends ImmutableCollection<V>> map, int size) {
    this.map = map;
    this.size = size;
  }
  
  @Deprecated
  @CanIgnoreReturnValue
  @DoNotCall("Always throws UnsupportedOperationException")
  public ImmutableCollection<V> removeAll(@CheckForNull Object key) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @CanIgnoreReturnValue
  @DoNotCall("Always throws UnsupportedOperationException")
  public ImmutableCollection<V> replaceValues(K key, Iterable<? extends V> values) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public final void clear() { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @CanIgnoreReturnValue
  @DoNotCall("Always throws UnsupportedOperationException")
  public final boolean put(K key, V value) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @CanIgnoreReturnValue
  @DoNotCall("Always throws UnsupportedOperationException")
  public final boolean putAll(K key, Iterable<? extends V> values) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @CanIgnoreReturnValue
  @DoNotCall("Always throws UnsupportedOperationException")
  public final boolean putAll(Multimap<? extends K, ? extends V> multimap) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @CanIgnoreReturnValue
  @DoNotCall("Always throws UnsupportedOperationException")
  public final boolean remove(@CheckForNull Object key, @CheckForNull Object value) { throw new UnsupportedOperationException(); }
  
  boolean isPartialView() { return this.map.isPartialView(); }
  
  public boolean containsKey(@CheckForNull Object key) { return this.map.containsKey(key); }
  
  public boolean containsValue(@CheckForNull Object value) { return (value != null && super.containsValue(value)); }
  
  public int size() { return this.size; }
  
  public ImmutableSet<K> keySet() { return this.map.keySet(); }
  
  Set<K> createKeySet() { throw new AssertionError("unreachable"); }
  
  public ImmutableMap<K, Collection<V>> asMap() { return this.map; }
  
  Map<K, Collection<V>> createAsMap() { throw new AssertionError("should never be called"); }
  
  public ImmutableCollection<Map.Entry<K, V>> entries() { return (ImmutableCollection)super.entries(); }
  
  ImmutableCollection<Map.Entry<K, V>> createEntries() { return new EntryCollection(this); }
  
  UnmodifiableIterator<Map.Entry<K, V>> entryIterator() { return new Object(this); }
  
  Spliterator<Map.Entry<K, V>> entrySpliterator() {
    return CollectSpliterators.flatMap(
        asMap().entrySet().spliterator(), keyToValueCollectionEntry -> {
          K key = (K)keyToValueCollectionEntry.getKey();
          Collection<V> valueCollection = (Collection)keyToValueCollectionEntry.getValue();
          return CollectSpliterators.map(valueCollection
              .spliterator(), ());
        }0x40 | ((this instanceof SetMultimap) ? 1 : 0), 
        size());
  }
  
  public void forEach(BiConsumer<? super K, ? super V> action) { Preconditions.checkNotNull(action);
    asMap()
      .forEach((key, valueCollection) -> 
        valueCollection.forEach(())); }
  
  public ImmutableMultiset<K> keys() { return (ImmutableMultiset)super.keys(); }
  
  ImmutableMultiset<K> createKeys() { return new Keys(this); }
  
  public ImmutableCollection<V> values() { return (ImmutableCollection)super.values(); }
  
  ImmutableCollection<V> createValues() { return new Values(this); }
  
  UnmodifiableIterator<V> valueIterator() { return new Object(this); }
  
  public abstract ImmutableCollection<V> get(K paramK);
  
  public abstract ImmutableMultimap<V, K> inverse();
}
