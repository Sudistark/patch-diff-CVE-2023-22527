package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.base.MoreObjects;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible
class FilteredEntryMultimap<K, V> extends AbstractMultimap<K, V> implements FilteredMultimap<K, V> {
  final Multimap<K, V> unfiltered;
  
  final Predicate<? super Map.Entry<K, V>> predicate;
  
  FilteredEntryMultimap(Multimap<K, V> unfiltered, Predicate<? super Map.Entry<K, V>> predicate) {
    this.unfiltered = (Multimap)Preconditions.checkNotNull(unfiltered);
    this.predicate = (Predicate)Preconditions.checkNotNull(predicate);
  }
  
  public Multimap<K, V> unfiltered() { return this.unfiltered; }
  
  public Predicate<? super Map.Entry<K, V>> entryPredicate() { return this.predicate; }
  
  public int size() { return entries().size(); }
  
  private boolean satisfies(@ParametricNullness K key, @ParametricNullness V value) { return this.predicate.apply(Maps.immutableEntry(key, value)); }
  
  static <E> Collection<E> filterCollection(Collection<E> collection, Predicate<? super E> predicate) {
    if (collection instanceof Set)
      return Sets.filter((Set)collection, predicate); 
    return Collections2.filter(collection, predicate);
  }
  
  public boolean containsKey(@CheckForNull Object key) { return (asMap().get(key) != null); }
  
  public Collection<V> removeAll(@CheckForNull Object key) { return (Collection)MoreObjects.firstNonNull((Collection)asMap().remove(key), unmodifiableEmptyCollection()); }
  
  Collection<V> unmodifiableEmptyCollection() {
    return (this.unfiltered instanceof SetMultimap) ? 
      Collections.emptySet() : 
      Collections.emptyList();
  }
  
  public void clear() { entries().clear(); }
  
  public Collection<V> get(@ParametricNullness K key) { return filterCollection(this.unfiltered.get(key), new ValuePredicate(this, key)); }
  
  Collection<Map.Entry<K, V>> createEntries() { return filterCollection(this.unfiltered.entries(), this.predicate); }
  
  Collection<V> createValues() { return new FilteredMultimapValues(this); }
  
  Iterator<Map.Entry<K, V>> entryIterator() { throw new AssertionError("should never be called"); }
  
  Map<K, Collection<V>> createAsMap() { return new AsMap(this); }
  
  Set<K> createKeySet() { return asMap().keySet(); }
  
  boolean removeEntriesIf(Predicate<? super Map.Entry<K, Collection<V>>> predicate) {
    Iterator<Map.Entry<K, Collection<V>>> entryIterator = this.unfiltered.asMap().entrySet().iterator();
    boolean changed = false;
    while (entryIterator.hasNext()) {
      Map.Entry<K, Collection<V>> entry = (Map.Entry)entryIterator.next();
      K key = (K)entry.getKey();
      Collection<V> collection = filterCollection((Collection)entry.getValue(), new ValuePredicate(this, key));
      if (!collection.isEmpty() && predicate.apply(Maps.immutableEntry(key, collection))) {
        if (collection.size() == ((Collection)entry.getValue()).size()) {
          entryIterator.remove();
        } else {
          collection.clear();
        } 
        changed = true;
      } 
    } 
    return changed;
  }
  
  Multiset<K> createKeys() { return new Keys(this); }
}
