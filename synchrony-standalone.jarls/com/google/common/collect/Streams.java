package com.google.common.collect;

import com.google.common.annotations.Beta;
import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.math.LongMath;
import com.google.errorprone.annotations.InlineMe;
import com.google.errorprone.annotations.InlineMeValidationDisabled;
import java.util.ArrayDeque;
import java.util.Collection;
import java.util.Deque;
import java.util.Iterator;
import java.util.Objects;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.OptionalLong;
import java.util.PrimitiveIterator;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.stream.BaseStream;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

@ElementTypesAreNonnullByDefault
@GwtCompatible
public final class Streams {
  public static <T> Stream<T> stream(Iterable<T> iterable) {
    return (iterable instanceof Collection) ? (
      (Collection)iterable).stream() : 
      StreamSupport.stream(iterable.spliterator(), false);
  }
  
  @Deprecated
  @InlineMe(replacement = "collection.stream()")
  public static <T> Stream<T> stream(Collection<T> collection) { return collection.stream(); }
  
  public static <T> Stream<T> stream(Iterator<T> iterator) { return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, 0), false); }
  
  public static <T> Stream<T> stream(Optional<T> optional) { return optional.isPresent() ? Stream.of(optional.get()) : Stream.empty(); }
  
  @Beta
  @InlineMe(replacement = "optional.stream()")
  @InlineMeValidationDisabled("Java 9+ API only")
  public static <T> Stream<T> stream(Optional<T> optional) { return optional.isPresent() ? Stream.of(optional.get()) : Stream.empty(); }
  
  @Beta
  @InlineMe(replacement = "optional.stream()")
  @InlineMeValidationDisabled("Java 9+ API only")
  public static IntStream stream(OptionalInt optional) { return optional.isPresent() ? IntStream.of(optional.getAsInt()) : IntStream.empty(); }
  
  @Beta
  @InlineMe(replacement = "optional.stream()")
  @InlineMeValidationDisabled("Java 9+ API only")
  public static LongStream stream(OptionalLong optional) { return optional.isPresent() ? LongStream.of(optional.getAsLong()) : LongStream.empty(); }
  
  @Beta
  @InlineMe(replacement = "optional.stream()")
  @InlineMeValidationDisabled("Java 9+ API only")
  public static DoubleStream stream(OptionalDouble optional) { return optional.isPresent() ? DoubleStream.of(optional.getAsDouble()) : DoubleStream.empty(); }
  
  private static void closeAll(BaseStream[] toClose) {
    RuntimeException exception = null;
    for (BaseStream<?, ?> stream : toClose) {
      try {
        stream.close();
      } catch (RuntimeException e) {
        if (exception == null) {
          exception = e;
        } else {
          exception.addSuppressed(e);
        } 
      } 
    } 
    if (exception != null)
      throw exception; 
  }
  
  @SafeVarargs
  public static <T> Stream<T> concat(Stream... streams) {
    boolean isParallel = false;
    int characteristics = 336;
    long estimatedSize = 0L;
    ImmutableList.Builder<Spliterator<? extends T>> splitrsBuilder = new ImmutableList.Builder<Spliterator<? extends T>>(streams.length);
    for (Stream<? extends T> stream : streams) {
      isParallel |= stream.isParallel();
      Spliterator<? extends T> splitr = stream.spliterator();
      splitrsBuilder.add(splitr);
      characteristics &= splitr.characteristics();
      estimatedSize = LongMath.saturatedAdd(estimatedSize, splitr.estimateSize());
    } 
    return (Stream)StreamSupport.stream(
        CollectSpliterators.flatMap(splitrsBuilder
          .build().spliterator(), splitr -> 
          splitr, characteristics, estimatedSize), isParallel)


      
      .onClose(() -> closeAll(streams));
  }
  
  public static IntStream concat(IntStream... streams) {
    boolean isParallel = false;
    int characteristics = 336;
    long estimatedSize = 0L;
    ImmutableList.Builder<Spliterator.OfInt> splitrsBuilder = new ImmutableList.Builder<Spliterator.OfInt>(streams.length);
    for (IntStream stream : streams) {
      isParallel |= stream.isParallel();
      Spliterator.OfInt splitr = stream.spliterator();
      splitrsBuilder.add(splitr);
      characteristics &= splitr.characteristics();
      estimatedSize = LongMath.saturatedAdd(estimatedSize, splitr.estimateSize());
    } 
    return (IntStream)StreamSupport.intStream(
        CollectSpliterators.flatMapToInt(splitrsBuilder
          .build().spliterator(), splitr -> 
          splitr, characteristics, estimatedSize), isParallel)


      
      .onClose(() -> closeAll(streams));
  }
  
  public static LongStream concat(LongStream... streams) {
    boolean isParallel = false;
    int characteristics = 336;
    long estimatedSize = 0L;
    ImmutableList.Builder<Spliterator.OfLong> splitrsBuilder = new ImmutableList.Builder<Spliterator.OfLong>(streams.length);
    for (LongStream stream : streams) {
      isParallel |= stream.isParallel();
      Spliterator.OfLong splitr = stream.spliterator();
      splitrsBuilder.add(splitr);
      characteristics &= splitr.characteristics();
      estimatedSize = LongMath.saturatedAdd(estimatedSize, splitr.estimateSize());
    } 
    return (LongStream)StreamSupport.longStream(
        CollectSpliterators.flatMapToLong(splitrsBuilder
          .build().spliterator(), splitr -> 
          splitr, characteristics, estimatedSize), isParallel)


      
      .onClose(() -> closeAll(streams));
  }
  
  public static DoubleStream concat(DoubleStream... streams) {
    boolean isParallel = false;
    int characteristics = 336;
    long estimatedSize = 0L;
    ImmutableList.Builder<Spliterator.OfDouble> splitrsBuilder = new ImmutableList.Builder<Spliterator.OfDouble>(streams.length);
    for (DoubleStream stream : streams) {
      isParallel |= stream.isParallel();
      Spliterator.OfDouble splitr = stream.spliterator();
      splitrsBuilder.add(splitr);
      characteristics &= splitr.characteristics();
      estimatedSize = LongMath.saturatedAdd(estimatedSize, splitr.estimateSize());
    } 
    return (DoubleStream)StreamSupport.doubleStream(
        CollectSpliterators.flatMapToDouble(splitrsBuilder
          .build().spliterator(), splitr -> 
          splitr, characteristics, estimatedSize), isParallel)


      
      .onClose(() -> closeAll(streams));
  }
  
  @Beta
  public static <A, B, R> Stream<R> zip(Stream<A> streamA, Stream<B> streamB, BiFunction<? super A, ? super B, R> function) {
    Preconditions.checkNotNull(streamA);
    Preconditions.checkNotNull(streamB);
    Preconditions.checkNotNull(function);
    boolean isParallel = (streamA.isParallel() || streamB.isParallel());
    Spliterator<A> splitrA = streamA.spliterator();
    Spliterator<B> splitrB = streamB.spliterator();
    int characteristics = splitrA.characteristics() & splitrB.characteristics() & 0x50;
    Iterator<A> itrA = Spliterators.iterator(splitrA);
    Iterator<B> itrB = Spliterators.iterator(splitrB);
    Objects.requireNonNull(streamA);
    Objects.requireNonNull(streamB);
    return (Stream)((Stream)StreamSupport.stream(new Object(Math.min(splitrA.estimateSize(), splitrB.estimateSize()), characteristics, itrA, itrB, function), isParallel).onClose(streamA::close)).onClose(streamB::close);
  }
  
  @Beta
  public static <A, B> void forEachPair(Stream<A> streamA, Stream<B> streamB, BiConsumer<? super A, ? super B> consumer) {
    Preconditions.checkNotNull(consumer);
    if (streamA.isParallel() || streamB.isParallel()) {
      zip(streamA, streamB, TemporaryPair::new).forEach(pair -> consumer.accept(pair.a, pair.b));
    } else {
      Iterator<A> iterA = streamA.iterator();
      Iterator<B> iterB = streamB.iterator();
      while (iterA.hasNext() && iterB.hasNext())
        consumer.accept(iterA.next(), iterB.next()); 
    } 
  }
  
  public static <T, R> Stream<R> mapWithIndex(Stream<T> stream, FunctionWithIndex<? super T, ? extends R> function) {
    Preconditions.checkNotNull(stream);
    Preconditions.checkNotNull(function);
    boolean isParallel = stream.isParallel();
    Spliterator<T> fromSpliterator = stream.spliterator();
    if (!fromSpliterator.hasCharacteristics(16384)) {
      Iterator<T> fromIterator = Spliterators.iterator(fromSpliterator);
      Objects.requireNonNull(stream);
      return (Stream)StreamSupport.stream(new Object(fromSpliterator.estimateSize(), fromSpliterator.characteristics() & 0x50, fromIterator, function), isParallel).onClose(stream::close);
    } 
    Objects.requireNonNull(stream);
    return (Stream)StreamSupport.stream(new Splitr(fromSpliterator, 0L, function), isParallel).onClose(stream::close);
  }
  
  public static <R> Stream<R> mapWithIndex(IntStream stream, IntFunctionWithIndex<R> function) {
    Preconditions.checkNotNull(stream);
    Preconditions.checkNotNull(function);
    boolean isParallel = stream.isParallel();
    Spliterator.OfInt fromSpliterator = stream.spliterator();
    if (!fromSpliterator.hasCharacteristics(16384)) {
      PrimitiveIterator.OfInt fromIterator = Spliterators.iterator(fromSpliterator);
      Objects.requireNonNull(stream);
      return (Stream)StreamSupport.stream(new Object(fromSpliterator.estimateSize(), fromSpliterator.characteristics() & 0x50, fromIterator, function), isParallel).onClose(stream::close);
    } 
    Objects.requireNonNull(stream);
    return (Stream)StreamSupport.stream(new Splitr(fromSpliterator, 0L, function), isParallel).onClose(stream::close);
  }
  
  public static <R> Stream<R> mapWithIndex(LongStream stream, LongFunctionWithIndex<R> function) {
    Preconditions.checkNotNull(stream);
    Preconditions.checkNotNull(function);
    boolean isParallel = stream.isParallel();
    Spliterator.OfLong fromSpliterator = stream.spliterator();
    if (!fromSpliterator.hasCharacteristics(16384)) {
      PrimitiveIterator.OfLong fromIterator = Spliterators.iterator(fromSpliterator);
      Objects.requireNonNull(stream);
      return (Stream)StreamSupport.stream(new Object(fromSpliterator.estimateSize(), fromSpliterator.characteristics() & 0x50, fromIterator, function), isParallel).onClose(stream::close);
    } 
    Objects.requireNonNull(stream);
    return (Stream)StreamSupport.stream(new Splitr(fromSpliterator, 0L, function), isParallel).onClose(stream::close);
  }
  
  public static <R> Stream<R> mapWithIndex(DoubleStream stream, DoubleFunctionWithIndex<R> function) {
    Preconditions.checkNotNull(stream);
    Preconditions.checkNotNull(function);
    boolean isParallel = stream.isParallel();
    Spliterator.OfDouble fromSpliterator = stream.spliterator();
    if (!fromSpliterator.hasCharacteristics(16384)) {
      PrimitiveIterator.OfDouble fromIterator = Spliterators.iterator(fromSpliterator);
      Objects.requireNonNull(stream);
      return (Stream)StreamSupport.stream(new Object(fromSpliterator.estimateSize(), fromSpliterator.characteristics() & 0x50, fromIterator, function), isParallel).onClose(stream::close);
    } 
    Objects.requireNonNull(stream);
    return (Stream)StreamSupport.stream(new Splitr(fromSpliterator, 0L, function), isParallel).onClose(stream::close);
  }
  
  public static <T> Optional<T> findLast(Stream<T> stream) {
    OptionalState state = new OptionalState();
    Deque<Spliterator<T>> splits = new ArrayDeque<Spliterator<T>>();
    splits.addLast(stream.spliterator());
    while (!splits.isEmpty()) {
      Spliterator<T> spliterator = (Spliterator)splits.removeLast();
      if (spliterator.getExactSizeIfKnown() == 0L)
        continue; 
      if (spliterator.hasCharacteristics(16384)) {
        while (true) {
          Spliterator<T> prefix = spliterator.trySplit();
          if (prefix == null || prefix.getExactSizeIfKnown() == 0L)
            break; 
          if (spliterator.getExactSizeIfKnown() == 0L) {
            spliterator = prefix;
            break;
          } 
        } 
        Objects.requireNonNull(state);
        spliterator.forEachRemaining(state::set);
        return Optional.of(state.get());
      } 
      Spliterator<T> prefix = spliterator.trySplit();
      if (prefix == null || prefix.getExactSizeIfKnown() == 0L) {
        Objects.requireNonNull(state);
        spliterator.forEachRemaining(state::set);
        if (state.set)
          return Optional.of(state.get()); 
        continue;
      } 
      splits.addLast(prefix);
      splits.addLast(spliterator);
    } 
    return Optional.empty();
  }
  
  public static OptionalInt findLast(IntStream stream) {
    Optional<Integer> boxedLast = findLast(stream.boxed());
    return (OptionalInt)boxedLast.map(OptionalInt::of).orElseGet(OptionalInt::empty);
  }
  
  public static OptionalLong findLast(LongStream stream) {
    Optional<Long> boxedLast = findLast(stream.boxed());
    return (OptionalLong)boxedLast.map(OptionalLong::of).orElseGet(OptionalLong::empty);
  }
  
  public static OptionalDouble findLast(DoubleStream stream) {
    Optional<Double> boxedLast = findLast(stream.boxed());
    return (OptionalDouble)boxedLast.map(OptionalDouble::of).orElseGet(OptionalDouble::empty);
  }
}
