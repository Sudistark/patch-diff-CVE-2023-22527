package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible(serializable = true, emulated = true)
public final class LinkedHashMultimap<K, V> extends LinkedHashMultimapGwtSerializationDependencies<K, V> {
  private static final int DEFAULT_KEY_CAPACITY = 16;
  
  private static final int DEFAULT_VALUE_SET_CAPACITY = 2;
  
  @VisibleForTesting
  static final double VALUE_SET_LOAD_FACTOR = 1.0D;
  
  public static <K, V> LinkedHashMultimap<K, V> create() { return new LinkedHashMultimap(16, 2); }
  
  public static <K, V> LinkedHashMultimap<K, V> create(int expectedKeys, int expectedValuesPerKey) {
    return new LinkedHashMultimap(
        Maps.capacity(expectedKeys), Maps.capacity(expectedValuesPerKey));
  }
  
  public static <K, V> LinkedHashMultimap<K, V> create(Multimap<? extends K, ? extends V> multimap) {
    LinkedHashMultimap<K, V> result = create(multimap.keySet().size(), 2);
    result.putAll(multimap);
    return result;
  }
  
  private static <K, V> void succeedsInValueSet(ValueSetLink<K, V> pred, ValueSetLink<K, V> succ) {
    pred.setSuccessorInValueSet(succ);
    succ.setPredecessorInValueSet(pred);
  }
  
  private static <K, V> void succeedsInMultimap(ValueEntry<K, V> pred, ValueEntry<K, V> succ) {
    pred.setSuccessorInMultimap(succ);
    succ.setPredecessorInMultimap(pred);
  }
  
  private static <K, V> void deleteFromValueSet(ValueSetLink<K, V> entry) { succeedsInValueSet(entry.getPredecessorInValueSet(), entry.getSuccessorInValueSet()); }
  
  private static <K, V> void deleteFromMultimap(ValueEntry<K, V> entry) { succeedsInMultimap(entry.getPredecessorInMultimap(), entry.getSuccessorInMultimap()); }
  
  @VisibleForTesting
  int valueSetCapacity = 2;
  
  private ValueEntry<K, V> multimapHeaderEntry;
  
  @GwtIncompatible
  @J2ktIncompatible
  private static final long serialVersionUID = 1L;
  
  private LinkedHashMultimap(int keyCapacity, int valueSetCapacity) {
    super(Platform.newLinkedHashMapWithExpectedSize(keyCapacity));
    CollectPreconditions.checkNonnegative(valueSetCapacity, "expectedValuesPerKey");
    this.valueSetCapacity = valueSetCapacity;
    this.multimapHeaderEntry = ValueEntry.newHeader();
    succeedsInMultimap(this.multimapHeaderEntry, this.multimapHeaderEntry);
  }
  
  Set<V> createCollection() { return Platform.newLinkedHashSetWithExpectedSize(this.valueSetCapacity); }
  
  Collection<V> createCollection(@ParametricNullness K key) { return new ValueSet(this, key, this.valueSetCapacity); }
  
  @CanIgnoreReturnValue
  public Set<V> replaceValues(@ParametricNullness K key, Iterable<? extends V> values) { return super.replaceValues(key, values); }
  
  public Set<Map.Entry<K, V>> entries() { return super.entries(); }
  
  public Set<K> keySet() { return super.keySet(); }
  
  public Collection<V> values() { return super.values(); }
  
  Iterator<Map.Entry<K, V>> entryIterator() { return new Object(this); }
  
  Spliterator<Map.Entry<K, V>> entrySpliterator() { return Spliterators.spliterator(entries(), 17); }
  
  Iterator<V> valueIterator() { return Maps.valueIterator(entryIterator()); }
  
  Spliterator<V> valueSpliterator() { return CollectSpliterators.map(entrySpliterator(), Map.Entry::getValue); }
  
  public void clear() {
    super.clear();
    succeedsInMultimap(this.multimapHeaderEntry, this.multimapHeaderEntry);
  }
  
  @GwtIncompatible
  @J2ktIncompatible
  private void writeObject(ObjectOutputStream stream) throws IOException {
    stream.defaultWriteObject();
    stream.writeInt(keySet().size());
    for (K key : keySet())
      stream.writeObject(key); 
    stream.writeInt(size());
    for (Map.Entry<K, V> entry : entries()) {
      stream.writeObject(entry.getKey());
      stream.writeObject(entry.getValue());
    } 
  }
  
  @GwtIncompatible
  @J2ktIncompatible
  private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    stream.defaultReadObject();
    this.multimapHeaderEntry = ValueEntry.newHeader();
    succeedsInMultimap(this.multimapHeaderEntry, this.multimapHeaderEntry);
    this.valueSetCapacity = 2;
    int distinctKeys = stream.readInt();
    Map<K, Collection<V>> map = Platform.newLinkedHashMapWithExpectedSize(12);
    for (int i = 0; i < distinctKeys; i++) {
      K key = (K)stream.readObject();
      map.put(key, createCollection(key));
    } 
    int entries = stream.readInt();
    for (int i = 0; i < entries; i++) {
      K key = (K)stream.readObject();
      V value = (V)stream.readObject();
      ((Collection)Objects.requireNonNull((Collection)map.get(key))).add(value);
    } 
    setMap(map);
  }
}
