package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.base.Preconditions;
import com.google.common.primitives.Ints;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.concurrent.CopyOnWriteArrayList;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible(emulated = true)
public final class Lists {
  @GwtCompatible(serializable = true)
  public static <E> ArrayList<E> newArrayList() { return new ArrayList(); }
  
  @SafeVarargs
  @GwtCompatible(serializable = true)
  public static <E> ArrayList<E> newArrayList(E... elements) {
    Preconditions.checkNotNull(elements);
    int capacity = computeArrayListCapacity(elements.length);
    ArrayList<E> list = new ArrayList<E>(capacity);
    Collections.addAll(list, elements);
    return list;
  }
  
  @GwtCompatible(serializable = true)
  public static <E> ArrayList<E> newArrayList(Iterable<? extends E> elements) {
    Preconditions.checkNotNull(elements);
    return (elements instanceof Collection) ? 
      new ArrayList((Collection)elements) : 
      newArrayList(elements.iterator());
  }
  
  @GwtCompatible(serializable = true)
  public static <E> ArrayList<E> newArrayList(Iterator<? extends E> elements) {
    ArrayList<E> list = newArrayList();
    Iterators.addAll(list, elements);
    return list;
  }
  
  @VisibleForTesting
  static int computeArrayListCapacity(int arraySize) {
    CollectPreconditions.checkNonnegative(arraySize, "arraySize");
    return Ints.saturatedCast(5L + arraySize + (arraySize / 10));
  }
  
  @GwtCompatible(serializable = true)
  public static <E> ArrayList<E> newArrayListWithCapacity(int initialArraySize) {
    CollectPreconditions.checkNonnegative(initialArraySize, "initialArraySize");
    return new ArrayList(initialArraySize);
  }
  
  @GwtCompatible(serializable = true)
  public static <E> ArrayList<E> newArrayListWithExpectedSize(int estimatedSize) { return new ArrayList(computeArrayListCapacity(estimatedSize)); }
  
  @GwtCompatible(serializable = true)
  public static <E> LinkedList<E> newLinkedList() { return new LinkedList(); }
  
  @GwtCompatible(serializable = true)
  public static <E> LinkedList<E> newLinkedList(Iterable<? extends E> elements) {
    LinkedList<E> list = newLinkedList();
    Iterables.addAll(list, elements);
    return list;
  }
  
  @J2ktIncompatible
  @GwtIncompatible
  public static <E> CopyOnWriteArrayList<E> newCopyOnWriteArrayList() { return new CopyOnWriteArrayList(); }
  
  @J2ktIncompatible
  @GwtIncompatible
  public static <E> CopyOnWriteArrayList<E> newCopyOnWriteArrayList(Iterable<? extends E> elements) {
    Collection<? extends E> elementsCollection = (elements instanceof Collection) ? (Collection)elements : newArrayList(elements);
    return new CopyOnWriteArrayList(elementsCollection);
  }
  
  public static <E> List<E> asList(@ParametricNullness E first, E[] rest) { return new OnePlusArrayList(first, rest); }
  
  public static <E> List<E> asList(@ParametricNullness E first, @ParametricNullness E second, E[] rest) { return new TwoPlusArrayList(first, second, rest); }
  
  public static <B> List<List<B>> cartesianProduct(List<? extends List<? extends B>> lists) { return CartesianList.create(lists); }
  
  @SafeVarargs
  public static <B> List<List<B>> cartesianProduct(List... lists) { return cartesianProduct(Arrays.asList(lists)); }
  
  public static <F, T> List<T> transform(List<F> fromList, Function<? super F, ? extends T> function) {
    return (fromList instanceof java.util.RandomAccess) ? 
      new TransformingRandomAccessList(fromList, function) : 
      new TransformingSequentialList(fromList, function);
  }
  
  public static <T> List<List<T>> partition(List<T> list, int size) {
    Preconditions.checkNotNull(list);
    Preconditions.checkArgument((size > 0));
    return (list instanceof java.util.RandomAccess) ? 
      new RandomAccessPartition(list, size) : 
      new Partition(list, size);
  }
  
  public static ImmutableList<Character> charactersOf(String string) { return new StringAsImmutableList((String)Preconditions.checkNotNull(string)); }
  
  public static List<Character> charactersOf(CharSequence sequence) { return new CharSequenceAsList((CharSequence)Preconditions.checkNotNull(sequence)); }
  
  public static <T> List<T> reverse(List<T> list) {
    if (list instanceof ImmutableList) {
      ImmutableList immutableList = ((ImmutableList)list).reverse();
      return immutableList;
    } 
    if (list instanceof ReverseList)
      return ((ReverseList)list).getForwardList(); 
    if (list instanceof java.util.RandomAccess)
      return new RandomAccessReverseList(list); 
    return new ReverseList(list);
  }
  
  static int hashCodeImpl(List<?> list) {
    int hashCode = 1;
    for (Object o : list) {
      hashCode = 31 * hashCode + ((o == null) ? 0 : o.hashCode());
      hashCode = hashCode ^ 0xFFFFFFFF ^ 0xFFFFFFFF;
    } 
    return hashCode;
  }
  
  static boolean equalsImpl(List<?> thisList, @CheckForNull Object other) {
    if (other == Preconditions.checkNotNull(thisList))
      return true; 
    if (!(other instanceof List))
      return false; 
    List<?> otherList = (List)other;
    int size = thisList.size();
    if (size != otherList.size())
      return false; 
    if (thisList instanceof java.util.RandomAccess && otherList instanceof java.util.RandomAccess) {
      for (int i = 0; i < size; i++) {
        if (!Objects.equal(thisList.get(i), otherList.get(i)))
          return false; 
      } 
      return true;
    } 
    return Iterators.elementsEqual(thisList.iterator(), otherList.iterator());
  }
  
  static <E> boolean addAllImpl(List<E> list, int index, Iterable<? extends E> elements) {
    boolean changed = false;
    ListIterator<E> listIterator = list.listIterator(index);
    for (E e : elements) {
      listIterator.add(e);
      changed = true;
    } 
    return changed;
  }
  
  static int indexOfImpl(List<?> list, @CheckForNull Object element) {
    if (list instanceof java.util.RandomAccess)
      return indexOfRandomAccess(list, element); 
    ListIterator<?> listIterator = list.listIterator();
    while (listIterator.hasNext()) {
      if (Objects.equal(element, listIterator.next()))
        return listIterator.previousIndex(); 
    } 
    return -1;
  }
  
  private static int indexOfRandomAccess(List<?> list, @CheckForNull Object element) {
    int size = list.size();
    if (element == null) {
      for (int i = 0; i < size; i++) {
        if (list.get(i) == null)
          return i; 
      } 
    } else {
      for (int i = 0; i < size; i++) {
        if (element.equals(list.get(i)))
          return i; 
      } 
    } 
    return -1;
  }
  
  static int lastIndexOfImpl(List<?> list, @CheckForNull Object element) {
    if (list instanceof java.util.RandomAccess)
      return lastIndexOfRandomAccess(list, element); 
    ListIterator<?> listIterator = list.listIterator(list.size());
    while (listIterator.hasPrevious()) {
      if (Objects.equal(element, listIterator.previous()))
        return listIterator.nextIndex(); 
    } 
    return -1;
  }
  
  private static int lastIndexOfRandomAccess(List<?> list, @CheckForNull Object element) {
    if (element == null) {
      for (int i = list.size() - 1; i >= 0; i--) {
        if (list.get(i) == null)
          return i; 
      } 
    } else {
      for (int i = list.size() - 1; i >= 0; i--) {
        if (element.equals(list.get(i)))
          return i; 
      } 
    } 
    return -1;
  }
  
  static <E> ListIterator<E> listIteratorImpl(List<E> list, int index) { return (new AbstractListWrapper(list)).listIterator(index); }
  
  static <E> List<E> subListImpl(List<E> list, int fromIndex, int toIndex) {
    Object object;
    if (list instanceof java.util.RandomAccess) {
      object = new Object(list);
    } else {
      object = new Object(list);
    } 
    return object.subList(fromIndex, toIndex);
  }
  
  static <T> List<T> cast(Iterable<T> iterable) { return (List)iterable; }
}
