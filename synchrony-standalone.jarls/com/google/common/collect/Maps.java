package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.base.Converter;
import com.google.common.base.Equivalence;
import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.NavigableMap;
import java.util.NavigableSet;
import java.util.Objects;
import java.util.Properties;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.stream.Collector;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible(emulated = true)
public final class Maps {
  static <K> Function<Map.Entry<K, ?>, K> keyFunction() { return EntryFunction.KEY; }
  
  static <V> Function<Map.Entry<?, V>, V> valueFunction() { return EntryFunction.VALUE; }
  
  static <K, V> Iterator<K> keyIterator(Iterator<Map.Entry<K, V>> entryIterator) { return new Object(entryIterator); }
  
  static <K, V> Iterator<V> valueIterator(Iterator<Map.Entry<K, V>> entryIterator) { return new Object(entryIterator); }
  
  @GwtCompatible(serializable = true)
  @J2ktIncompatible
  public static <K extends Enum<K>, V> ImmutableMap<K, V> immutableEnumMap(Map<K, ? extends V> map) {
    if (map instanceof ImmutableEnumMap)
      return (ImmutableEnumMap)map; 
    Iterator<? extends Map.Entry<K, ? extends V>> entryItr = map.entrySet().iterator();
    if (!entryItr.hasNext())
      return ImmutableMap.of(); 
    Map.Entry<K, ? extends V> entry1 = (Map.Entry)entryItr.next();
    K key1 = (K)(Enum)entry1.getKey();
    V value1 = (V)entry1.getValue();
    CollectPreconditions.checkEntryNotNull(key1, value1);
    EnumMap<K, V> enumMap = new EnumMap<K, V>(Collections.singletonMap(key1, value1));
    while (entryItr.hasNext()) {
      Map.Entry<K, ? extends V> entry = (Map.Entry)entryItr.next();
      K key = (K)(Enum)entry.getKey();
      V value = (V)entry.getValue();
      CollectPreconditions.checkEntryNotNull(key, value);
      enumMap.put(key, value);
    } 
    return ImmutableEnumMap.asImmutable(enumMap);
  }
  
  @J2ktIncompatible
  public static <T, K extends Enum<K>, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableEnumMap(Function<? super T, ? extends K> keyFunction, Function<? super T, ? extends V> valueFunction) { return CollectCollectors.toImmutableEnumMap(keyFunction, valueFunction); }
  
  @J2ktIncompatible
  public static <T, K extends Enum<K>, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableEnumMap(Function<? super T, ? extends K> keyFunction, Function<? super T, ? extends V> valueFunction, BinaryOperator<V> mergeFunction) { return CollectCollectors.toImmutableEnumMap(keyFunction, valueFunction, mergeFunction); }
  
  public static <K, V> HashMap<K, V> newHashMap() { return new HashMap(); }
  
  public static <K, V> HashMap<K, V> newHashMap(Map<? extends K, ? extends V> map) { return new HashMap(map); }
  
  public static <K, V> HashMap<K, V> newHashMapWithExpectedSize(int expectedSize) { return new HashMap(capacity(expectedSize)); }
  
  static int capacity(int expectedSize) {
    if (expectedSize < 3) {
      CollectPreconditions.checkNonnegative(expectedSize, "expectedSize");
      return expectedSize + 1;
    } 
    if (expectedSize < 1073741824)
      return (int)Math.ceil(expectedSize / 0.75D); 
    return Integer.MAX_VALUE;
  }
  
  public static <K, V> LinkedHashMap<K, V> newLinkedHashMap() { return new LinkedHashMap(); }
  
  public static <K, V> LinkedHashMap<K, V> newLinkedHashMap(Map<? extends K, ? extends V> map) { return new LinkedHashMap(map); }
  
  public static <K, V> LinkedHashMap<K, V> newLinkedHashMapWithExpectedSize(int expectedSize) { return new LinkedHashMap(capacity(expectedSize)); }
  
  public static <K, V> ConcurrentMap<K, V> newConcurrentMap() { return new ConcurrentHashMap(); }
  
  public static <K extends Comparable, V> TreeMap<K, V> newTreeMap() { return new TreeMap(); }
  
  public static <K, V> TreeMap<K, V> newTreeMap(SortedMap<K, ? extends V> map) { return new TreeMap(map); }
  
  public static <C, K extends C, V> TreeMap<K, V> newTreeMap(@CheckForNull Comparator<C> comparator) { return new TreeMap(comparator); }
  
  public static <K extends Enum<K>, V> EnumMap<K, V> newEnumMap(Class<K> type) { return new EnumMap((Class)Preconditions.checkNotNull(type)); }
  
  public static <K extends Enum<K>, V> EnumMap<K, V> newEnumMap(Map<K, ? extends V> map) { return new EnumMap(map); }
  
  public static <K, V> IdentityHashMap<K, V> newIdentityHashMap() { return new IdentityHashMap(); }
  
  public static <K, V> MapDifference<K, V> difference(Map<? extends K, ? extends V> left, Map<? extends K, ? extends V> right) {
    if (left instanceof SortedMap) {
      SortedMap<K, ? extends V> sortedLeft = (SortedMap)left;
      return difference(sortedLeft, right);
    } 
    return difference(left, right, Equivalence.equals());
  }
  
  public static <K, V> MapDifference<K, V> difference(Map<? extends K, ? extends V> left, Map<? extends K, ? extends V> right, Equivalence<? super V> valueEquivalence) {
    Preconditions.checkNotNull(valueEquivalence);
    Map<K, V> onlyOnLeft = newLinkedHashMap();
    Map<K, V> onlyOnRight = new LinkedHashMap<K, V>(right);
    Map<K, V> onBoth = newLinkedHashMap();
    Map<K, MapDifference.ValueDifference<V>> differences = newLinkedHashMap();
    doDifference(left, right, valueEquivalence, onlyOnLeft, onlyOnRight, onBoth, differences);
    return new MapDifferenceImpl(onlyOnLeft, onlyOnRight, onBoth, differences);
  }
  
  public static <K, V> SortedMapDifference<K, V> difference(SortedMap<K, ? extends V> left, Map<? extends K, ? extends V> right) {
    Preconditions.checkNotNull(left);
    Preconditions.checkNotNull(right);
    Comparator<? super K> comparator = orNaturalOrder(left.comparator());
    SortedMap<K, V> onlyOnLeft = newTreeMap(comparator);
    SortedMap<K, V> onlyOnRight = newTreeMap(comparator);
    onlyOnRight.putAll(right);
    SortedMap<K, V> onBoth = newTreeMap(comparator);
    SortedMap<K, MapDifference.ValueDifference<V>> differences = newTreeMap(comparator);
    doDifference(left, right, Equivalence.equals(), onlyOnLeft, onlyOnRight, onBoth, differences);
    return new SortedMapDifferenceImpl(onlyOnLeft, onlyOnRight, onBoth, differences);
  }
  
  private static <K, V> void doDifference(Map<? extends K, ? extends V> left, Map<? extends K, ? extends V> right, Equivalence<? super V> valueEquivalence, Map<K, V> onlyOnLeft, Map<K, V> onlyOnRight, Map<K, V> onBoth, Map<K, MapDifference.ValueDifference<V>> differences) {
    for (Map.Entry<? extends K, ? extends V> entry : left.entrySet()) {
      K leftKey = (K)entry.getKey();
      V leftValue = (V)entry.getValue();
      if (right.containsKey(leftKey)) {
        V rightValue = (V)NullnessCasts.uncheckedCastNullableTToT(onlyOnRight.remove(leftKey));
        if (valueEquivalence.equivalent(leftValue, rightValue)) {
          onBoth.put(leftKey, leftValue);
          continue;
        } 
        differences.put(leftKey, ValueDifferenceImpl.create(leftValue, rightValue));
        continue;
      } 
      onlyOnLeft.put(leftKey, leftValue);
    } 
  }
  
  private static <K, V> Map<K, V> unmodifiableMap(Map<K, ? extends V> map) {
    if (map instanceof SortedMap)
      return Collections.unmodifiableSortedMap((SortedMap)map); 
    return Collections.unmodifiableMap(map);
  }
  
  static <E> Comparator<? super E> orNaturalOrder(@CheckForNull Comparator<? super E> comparator) {
    if (comparator != null)
      return comparator; 
    return Ordering.natural();
  }
  
  public static <K, V> Map<K, V> asMap(Set<K> set, Function<? super K, V> function) { return new AsMapView(set, function); }
  
  public static <K, V> SortedMap<K, V> asMap(SortedSet<K> set, Function<? super K, V> function) { return new SortedAsMapView(set, function); }
  
  @GwtIncompatible
  public static <K, V> NavigableMap<K, V> asMap(NavigableSet<K> set, Function<? super K, V> function) { return new NavigableAsMapView(set, function); }
  
  static <K, V> Iterator<Map.Entry<K, V>> asMapEntryIterator(Set<K> set, Function<? super K, V> function) { return new Object(set.iterator(), function); }
  
  private static <E> Set<E> removeOnlySet(Set<E> set) { return new Object(set); }
  
  private static <E> SortedSet<E> removeOnlySortedSet(SortedSet<E> set) { return new Object(set); }
  
  @GwtIncompatible
  private static <E> NavigableSet<E> removeOnlyNavigableSet(NavigableSet<E> set) { return new Object(set); }
  
  public static <K, V> ImmutableMap<K, V> toMap(Iterable<K> keys, Function<? super K, V> valueFunction) { return toMap(keys.iterator(), valueFunction); }
  
  public static <K, V> ImmutableMap<K, V> toMap(Iterator<K> keys, Function<? super K, V> valueFunction) {
    Preconditions.checkNotNull(valueFunction);
    ImmutableMap.Builder<K, V> builder = ImmutableMap.builder();
    while (keys.hasNext()) {
      K key = (K)keys.next();
      builder.put(key, valueFunction.apply(key));
    } 
    return builder.buildKeepingLast();
  }
  
  @CanIgnoreReturnValue
  public static <K, V> ImmutableMap<K, V> uniqueIndex(Iterable<V> values, Function<? super V, K> keyFunction) {
    if (values instanceof Collection)
      return uniqueIndex(values
          .iterator(), keyFunction, 
          
          ImmutableMap.builderWithExpectedSize(((Collection)values).size())); 
    return uniqueIndex(values.iterator(), keyFunction);
  }
  
  @CanIgnoreReturnValue
  public static <K, V> ImmutableMap<K, V> uniqueIndex(Iterator<V> values, Function<? super V, K> keyFunction) { return uniqueIndex(values, keyFunction, ImmutableMap.builder()); }
  
  private static <K, V> ImmutableMap<K, V> uniqueIndex(Iterator<V> values, Function<? super V, K> keyFunction, ImmutableMap.Builder<K, V> builder) {
    Preconditions.checkNotNull(keyFunction);
    while (values.hasNext()) {
      V value = (V)values.next();
      builder.put(keyFunction.apply(value), value);
    } 
    try {
      return builder.buildOrThrow();
    } catch (IllegalArgumentException duplicateKeys) {
      throw new IllegalArgumentException(duplicateKeys
          .getMessage() + ". To index multiple values under a key, use Multimaps.index.");
    } 
  }
  
  @J2ktIncompatible
  @GwtIncompatible
  public static ImmutableMap<String, String> fromProperties(Properties properties) {
    ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();
    for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements(); ) {
      String key = (String)Objects.requireNonNull(e.nextElement());
      builder.put(key, (String)Objects.requireNonNull(properties.getProperty(key)));
    } 
    return builder.buildOrThrow();
  }
  
  @GwtCompatible(serializable = true)
  public static <K, V> Map.Entry<K, V> immutableEntry(@ParametricNullness K key, @ParametricNullness V value) { return new ImmutableEntry(key, value); }
  
  static <K, V> Set<Map.Entry<K, V>> unmodifiableEntrySet(Set<Map.Entry<K, V>> entrySet) { return new UnmodifiableEntrySet(Collections.unmodifiableSet(entrySet)); }
  
  static <K, V> Map.Entry<K, V> unmodifiableEntry(Map.Entry<? extends K, ? extends V> entry) {
    Preconditions.checkNotNull(entry);
    return new Object(entry);
  }
  
  static <K, V> UnmodifiableIterator<Map.Entry<K, V>> unmodifiableEntryIterator(Iterator<Map.Entry<K, V>> entryIterator) { return new Object(entryIterator); }
  
  public static <A, B> Converter<A, B> asConverter(BiMap<A, B> bimap) { return new BiMapConverter(bimap); }
  
  public static <K, V> BiMap<K, V> synchronizedBiMap(BiMap<K, V> bimap) { return Synchronized.biMap(bimap, null); }
  
  public static <K, V> BiMap<K, V> unmodifiableBiMap(BiMap<? extends K, ? extends V> bimap) { return new UnmodifiableBiMap(bimap, null); }
  
  public static <K, V1, V2> Map<K, V2> transformValues(Map<K, V1> fromMap, Function<? super V1, V2> function) { return transformEntries(fromMap, asEntryTransformer(function)); }
  
  public static <K, V1, V2> SortedMap<K, V2> transformValues(SortedMap<K, V1> fromMap, Function<? super V1, V2> function) { return transformEntries(fromMap, asEntryTransformer(function)); }
  
  @GwtIncompatible
  public static <K, V1, V2> NavigableMap<K, V2> transformValues(NavigableMap<K, V1> fromMap, Function<? super V1, V2> function) { return transformEntries(fromMap, asEntryTransformer(function)); }
  
  public static <K, V1, V2> Map<K, V2> transformEntries(Map<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) { return new TransformedEntriesMap(fromMap, transformer); }
  
  public static <K, V1, V2> SortedMap<K, V2> transformEntries(SortedMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) { return new TransformedEntriesSortedMap(fromMap, transformer); }
  
  @GwtIncompatible
  public static <K, V1, V2> NavigableMap<K, V2> transformEntries(NavigableMap<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) { return new TransformedEntriesNavigableMap(fromMap, transformer); }
  
  static <K, V1, V2> EntryTransformer<K, V1, V2> asEntryTransformer(Function<? super V1, V2> function) {
    Preconditions.checkNotNull(function);
    return new Object(function);
  }
  
  static <K, V1, V2> Function<V1, V2> asValueToValueFunction(EntryTransformer<? super K, V1, V2> transformer, @ParametricNullness K key) {
    Preconditions.checkNotNull(transformer);
    return new Object(transformer, key);
  }
  
  static <K, V1, V2> Function<Map.Entry<K, V1>, V2> asEntryToValueFunction(EntryTransformer<? super K, ? super V1, V2> transformer) {
    Preconditions.checkNotNull(transformer);
    return new Object(transformer);
  }
  
  static <V2, K, V1> Map.Entry<K, V2> transformEntry(EntryTransformer<? super K, ? super V1, V2> transformer, Map.Entry<K, V1> entry) {
    Preconditions.checkNotNull(transformer);
    Preconditions.checkNotNull(entry);
    return new Object(entry, transformer);
  }
  
  static <K, V1, V2> Function<Map.Entry<K, V1>, Map.Entry<K, V2>> asEntryToEntryFunction(EntryTransformer<? super K, ? super V1, V2> transformer) {
    Preconditions.checkNotNull(transformer);
    return new Object(transformer);
  }
  
  static <K> Predicate<Map.Entry<K, ?>> keyPredicateOnEntries(Predicate<? super K> keyPredicate) { return Predicates.compose(keyPredicate, keyFunction()); }
  
  static <V> Predicate<Map.Entry<?, V>> valuePredicateOnEntries(Predicate<? super V> valuePredicate) { return Predicates.compose(valuePredicate, valueFunction()); }
  
  public static <K, V> Map<K, V> filterKeys(Map<K, V> unfiltered, Predicate<? super K> keyPredicate) {
    Preconditions.checkNotNull(keyPredicate);
    Predicate<Map.Entry<K, ?>> entryPredicate = keyPredicateOnEntries(keyPredicate);
    return (unfiltered instanceof AbstractFilteredMap) ? 
      filterFiltered((AbstractFilteredMap)unfiltered, entryPredicate) : 
      new FilteredKeyMap((Map)Preconditions.checkNotNull(unfiltered), keyPredicate, entryPredicate);
  }
  
  public static <K, V> SortedMap<K, V> filterKeys(SortedMap<K, V> unfiltered, Predicate<? super K> keyPredicate) { return filterEntries(unfiltered, keyPredicateOnEntries(keyPredicate)); }
  
  @GwtIncompatible
  public static <K, V> NavigableMap<K, V> filterKeys(NavigableMap<K, V> unfiltered, Predicate<? super K> keyPredicate) { return filterEntries(unfiltered, keyPredicateOnEntries(keyPredicate)); }
  
  public static <K, V> BiMap<K, V> filterKeys(BiMap<K, V> unfiltered, Predicate<? super K> keyPredicate) {
    Preconditions.checkNotNull(keyPredicate);
    return filterEntries(unfiltered, keyPredicateOnEntries(keyPredicate));
  }
  
  public static <K, V> Map<K, V> filterValues(Map<K, V> unfiltered, Predicate<? super V> valuePredicate) { return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate)); }
  
  public static <K, V> SortedMap<K, V> filterValues(SortedMap<K, V> unfiltered, Predicate<? super V> valuePredicate) { return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate)); }
  
  @GwtIncompatible
  public static <K, V> NavigableMap<K, V> filterValues(NavigableMap<K, V> unfiltered, Predicate<? super V> valuePredicate) { return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate)); }
  
  public static <K, V> BiMap<K, V> filterValues(BiMap<K, V> unfiltered, Predicate<? super V> valuePredicate) { return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate)); }
  
  public static <K, V> Map<K, V> filterEntries(Map<K, V> unfiltered, Predicate<? super Map.Entry<K, V>> entryPredicate) {
    Preconditions.checkNotNull(entryPredicate);
    return (unfiltered instanceof AbstractFilteredMap) ? 
      filterFiltered((AbstractFilteredMap)unfiltered, entryPredicate) : 
      new FilteredEntryMap((Map)Preconditions.checkNotNull(unfiltered), entryPredicate);
  }
  
  public static <K, V> SortedMap<K, V> filterEntries(SortedMap<K, V> unfiltered, Predicate<? super Map.Entry<K, V>> entryPredicate) {
    Preconditions.checkNotNull(entryPredicate);
    return (unfiltered instanceof FilteredEntrySortedMap) ? 
      filterFiltered((FilteredEntrySortedMap)unfiltered, entryPredicate) : 
      new FilteredEntrySortedMap((SortedMap)Preconditions.checkNotNull(unfiltered), entryPredicate);
  }
  
  @GwtIncompatible
  public static <K, V> NavigableMap<K, V> filterEntries(NavigableMap<K, V> unfiltered, Predicate<? super Map.Entry<K, V>> entryPredicate) {
    Preconditions.checkNotNull(entryPredicate);
    return (unfiltered instanceof FilteredEntryNavigableMap) ? 
      filterFiltered((FilteredEntryNavigableMap)unfiltered, entryPredicate) : 
      new FilteredEntryNavigableMap((NavigableMap)Preconditions.checkNotNull(unfiltered), entryPredicate);
  }
  
  public static <K, V> BiMap<K, V> filterEntries(BiMap<K, V> unfiltered, Predicate<? super Map.Entry<K, V>> entryPredicate) {
    Preconditions.checkNotNull(unfiltered);
    Preconditions.checkNotNull(entryPredicate);
    return (unfiltered instanceof FilteredEntryBiMap) ? 
      filterFiltered((FilteredEntryBiMap)unfiltered, entryPredicate) : 
      new FilteredEntryBiMap(unfiltered, entryPredicate);
  }
  
  private static <K, V> Map<K, V> filterFiltered(AbstractFilteredMap<K, V> map, Predicate<? super Map.Entry<K, V>> entryPredicate) { return new FilteredEntryMap(map.unfiltered, 
        Predicates.and(map.predicate, entryPredicate)); }
  
  private static <K, V> SortedMap<K, V> filterFiltered(FilteredEntrySortedMap<K, V> map, Predicate<? super Map.Entry<K, V>> entryPredicate) {
    Predicate<Map.Entry<K, V>> predicate = Predicates.and(map.predicate, entryPredicate);
    return new FilteredEntrySortedMap(map.sortedMap(), predicate);
  }
  
  @GwtIncompatible
  private static <K, V> NavigableMap<K, V> filterFiltered(FilteredEntryNavigableMap<K, V> map, Predicate<? super Map.Entry<K, V>> entryPredicate) {
    Predicate<Map.Entry<K, V>> predicate = Predicates.and(FilteredEntryNavigableMap.access$500(map), entryPredicate);
    return new FilteredEntryNavigableMap(FilteredEntryNavigableMap.access$600(map), predicate);
  }
  
  private static <K, V> BiMap<K, V> filterFiltered(FilteredEntryBiMap<K, V> map, Predicate<? super Map.Entry<K, V>> entryPredicate) {
    Predicate<Map.Entry<K, V>> predicate = Predicates.and(map.predicate, entryPredicate);
    return new FilteredEntryBiMap(map.unfiltered(), predicate);
  }
  
  @GwtIncompatible
  public static <K, V> NavigableMap<K, V> unmodifiableNavigableMap(NavigableMap<K, ? extends V> map) {
    Preconditions.checkNotNull(map);
    if (map instanceof UnmodifiableNavigableMap)
      return map; 
    return new UnmodifiableNavigableMap(map);
  }
  
  @CheckForNull
  private static <K, V> Map.Entry<K, V> unmodifiableOrNull(@CheckForNull Map.Entry<K, ? extends V> entry) { return (entry == null) ? null : unmodifiableEntry(entry); }
  
  @GwtIncompatible
  public static <K, V> NavigableMap<K, V> synchronizedNavigableMap(NavigableMap<K, V> navigableMap) { return Synchronized.navigableMap(navigableMap); }
  
  @CheckForNull
  static <V> V safeGet(Map<?, V> map, @CheckForNull Object key) {
    Preconditions.checkNotNull(map);
    try {
      return (V)map.get(key);
    } catch (ClassCastException|NullPointerException e) {
      return null;
    } 
  }
  
  static boolean safeContainsKey(Map<?, ?> map, @CheckForNull Object key) {
    Preconditions.checkNotNull(map);
    try {
      return map.containsKey(key);
    } catch (ClassCastException|NullPointerException e) {
      return false;
    } 
  }
  
  @CheckForNull
  static <V> V safeRemove(Map<?, V> map, @CheckForNull Object key) {
    Preconditions.checkNotNull(map);
    try {
      return (V)map.remove(key);
    } catch (ClassCastException|NullPointerException e) {
      return null;
    } 
  }
  
  static boolean containsKeyImpl(Map<?, ?> map, @CheckForNull Object key) { return Iterators.contains(keyIterator(map.entrySet().iterator()), key); }
  
  static boolean containsValueImpl(Map<?, ?> map, @CheckForNull Object value) { return Iterators.contains(valueIterator(map.entrySet().iterator()), value); }
  
  static <K, V> boolean containsEntryImpl(Collection<Map.Entry<K, V>> c, @CheckForNull Object o) {
    if (!(o instanceof Map.Entry))
      return false; 
    return c.contains(unmodifiableEntry((Map.Entry)o));
  }
  
  static <K, V> boolean removeEntryImpl(Collection<Map.Entry<K, V>> c, @CheckForNull Object o) {
    if (!(o instanceof Map.Entry))
      return false; 
    return c.remove(unmodifiableEntry((Map.Entry)o));
  }
  
  static boolean equalsImpl(Map<?, ?> map, @CheckForNull Object object) {
    if (map == object)
      return true; 
    if (object instanceof Map) {
      Map<?, ?> o = (Map)object;
      return map.entrySet().equals(o.entrySet());
    } 
    return false;
  }
  
  static String toStringImpl(Map<?, ?> map) {
    StringBuilder sb = Collections2.newStringBuilderForCollection(map.size()).append('{');
    boolean first = true;
    for (Map.Entry<?, ?> entry : map.entrySet()) {
      if (!first)
        sb.append(", "); 
      first = false;
      sb.append(entry.getKey()).append('=').append(entry.getValue());
    } 
    return sb.append('}').toString();
  }
  
  static <K, V> void putAllImpl(Map<K, V> self, Map<? extends K, ? extends V> map) {
    for (Map.Entry<? extends K, ? extends V> entry : map.entrySet())
      self.put(entry.getKey(), entry.getValue()); 
  }
  
  @CheckForNull
  static <K> K keyOrNull(@CheckForNull Map.Entry<K, ?> entry) { return (K)((entry == null) ? null : entry.getKey()); }
  
  @CheckForNull
  static <V> V valueOrNull(@CheckForNull Map.Entry<?, V> entry) { return (V)((entry == null) ? null : entry.getValue()); }
  
  static <E> ImmutableMap<E, Integer> indexMap(Collection<E> list) {
    ImmutableMap.Builder<E, Integer> builder = new ImmutableMap.Builder<E, Integer>(list.size());
    int i = 0;
    for (E e : list)
      builder.put(e, Integer.valueOf(i++)); 
    return builder.buildOrThrow();
  }
  
  @GwtIncompatible
  public static <K extends Comparable<? super K>, V> NavigableMap<K, V> subMap(NavigableMap<K, V> map, Range<K> range) {
    if (map.comparator() != null && map
      .comparator() != Ordering.natural() && range
      .hasLowerBound() && range
      .hasUpperBound())
      Preconditions.checkArgument(
          (map.comparator().compare(range.lowerEndpoint(), range.upperEndpoint()) <= 0), "map is using a custom comparator which is inconsistent with the natural ordering."); 
    if (range.hasLowerBound() && range.hasUpperBound())
      return map.subMap(range
          .lowerEndpoint(), 
          (range.lowerBoundType() == BoundType.CLOSED), range
          .upperEndpoint(), 
          (range.upperBoundType() == BoundType.CLOSED)); 
    if (range.hasLowerBound())
      return map.tailMap(range.lowerEndpoint(), (range.lowerBoundType() == BoundType.CLOSED)); 
    if (range.hasUpperBound())
      return map.headMap(range.upperEndpoint(), (range.upperBoundType() == BoundType.CLOSED)); 
    return (NavigableMap)Preconditions.checkNotNull(map);
  }
}
