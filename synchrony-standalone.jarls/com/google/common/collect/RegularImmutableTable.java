package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Preconditions;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible
abstract class RegularImmutableTable<R, C, V> extends ImmutableTable<R, C, V> {
  final ImmutableSet<Table.Cell<R, C, V>> createCellSet() { return isEmpty() ? ImmutableSet.of() : new CellSet(this, null); }
  
  final ImmutableCollection<V> createValues() { return isEmpty() ? ImmutableList.of() : new Values(this, null); }
  
  static <R, C, V> RegularImmutableTable<R, C, V> forCells(List<Table.Cell<R, C, V>> cells, @CheckForNull Comparator<? super R> rowComparator, @CheckForNull Comparator<? super C> columnComparator) {
    Preconditions.checkNotNull(cells);
    if (rowComparator != null || columnComparator != null) {
      Comparator<Table.Cell<R, C, V>> comparator = (cell1, cell2) -> {
          int rowCompare = (rowComparator == null) ? 0 : rowComparator.compare(cell1.getRowKey(), cell2.getRowKey());
          if (rowCompare != 0)
            return rowCompare; 
          return (columnComparator == null) ? 
            0 : 
            columnComparator.compare(cell1.getColumnKey(), cell2.getColumnKey());
        };
      Collections.sort(cells, comparator);
    } 
    return forCellsInternal(cells, rowComparator, columnComparator);
  }
  
  static <R, C, V> RegularImmutableTable<R, C, V> forCells(Iterable<Table.Cell<R, C, V>> cells) { return forCellsInternal(cells, null, null); }
  
  private static <R, C, V> RegularImmutableTable<R, C, V> forCellsInternal(Iterable<Table.Cell<R, C, V>> cells, @CheckForNull Comparator<? super R> rowComparator, @CheckForNull Comparator<? super C> columnComparator) {
    Set<R> rowSpaceBuilder = new LinkedHashSet<R>();
    Set<C> columnSpaceBuilder = new LinkedHashSet<C>();
    ImmutableList<Table.Cell<R, C, V>> cellList = ImmutableList.copyOf(cells);
    for (Table.Cell<R, C, V> cell : cells) {
      rowSpaceBuilder.add(cell.getRowKey());
      columnSpaceBuilder.add(cell.getColumnKey());
    } 
    ImmutableSet<R> rowSpace = (rowComparator == null) ? ImmutableSet.copyOf(rowSpaceBuilder) : ImmutableSet.copyOf(ImmutableList.sortedCopyOf(rowComparator, rowSpaceBuilder));
    ImmutableSet<C> columnSpace = (columnComparator == null) ? ImmutableSet.copyOf(columnSpaceBuilder) : ImmutableSet.copyOf(ImmutableList.sortedCopyOf(columnComparator, columnSpaceBuilder));
    return forOrderedComponents(cellList, rowSpace, columnSpace);
  }
  
  static <R, C, V> RegularImmutableTable<R, C, V> forOrderedComponents(ImmutableList<Table.Cell<R, C, V>> cellList, ImmutableSet<R> rowSpace, ImmutableSet<C> columnSpace) {
    return (cellList.size() > rowSpace.size() * columnSpace.size() / 2L) ? 
      new DenseImmutableTable(cellList, rowSpace, columnSpace) : 
      new SparseImmutableTable(cellList, rowSpace, columnSpace);
  }
  
  final void checkNoDuplicate(R rowKey, C columnKey, @CheckForNull V existingValue, V newValue) { Preconditions.checkArgument((existingValue == null), "Duplicate key: (row=%s, column=%s), values: [%s, %s].", rowKey, columnKey, newValue, existingValue); }
  
  abstract Table.Cell<R, C, V> getCell(int paramInt);
  
  abstract V getValue(int paramInt);
}
