package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Objects;
import com.google.common.base.Preconditions;
import com.google.common.primitives.Ints;
import com.google.errorprone.annotations.concurrent.LazyInit;
import java.util.Arrays;
import java.util.Collection;
import java.util.Set;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible(emulated = true, serializable = true)
class RegularImmutableMultiset<E> extends ImmutableMultiset<E> {
  private static final Multisets.ImmutableEntry<?>[] EMPTY_ARRAY = new Multisets.ImmutableEntry[0];
  
  static final ImmutableMultiset<Object> EMPTY = create(ImmutableList.of());
  
  @VisibleForTesting
  static final double MAX_LOAD_FACTOR = 1.0D;
  
  @VisibleForTesting
  static final double HASH_FLOODING_FPP = 0.001D;
  
  @VisibleForTesting
  static final int MAX_HASH_BUCKET_LENGTH = 9;
  
  private final Multisets.ImmutableEntry<E>[] entries;
  
  private final Multisets.ImmutableEntry<?>[] hashTable;
  
  private final int size;
  
  private final int hashCode;
  
  @LazyInit
  @CheckForNull
  private ImmutableSet<E> elementSet;
  
  static <E> ImmutableMultiset<E> create(Collection<? extends Multiset.Entry<? extends E>> entries) {
    int distinct = entries.size();
    Multisets.ImmutableEntry[] arrayOfImmutableEntry1 = new Multisets.ImmutableEntry[distinct];
    if (distinct == 0)
      return new RegularImmutableMultiset(arrayOfImmutableEntry1, EMPTY_ARRAY, 0, 0, ImmutableSet.of()); 
    int tableSize = Hashing.closedTableSize(distinct, 1.0D);
    int mask = tableSize - 1;
    Multisets.ImmutableEntry[] arrayOfImmutableEntry2 = new Multisets.ImmutableEntry[tableSize];
    int index = 0;
    int hashCode = 0;
    long size = 0L;
    for (Multiset.Entry<? extends E> entryWithWildcard : entries) {
      NonTerminalEntry nonTerminalEntry;
      Multiset.Entry<E> entry = entryWithWildcard;
      E element = (E)Preconditions.checkNotNull(entry.getElement());
      int count = entry.getCount();
      int hash = element.hashCode();
      int bucket = Hashing.smear(hash) & mask;
      Multisets.ImmutableEntry<E> bucketHead = arrayOfImmutableEntry2[bucket];
      if (bucketHead == null) {
        boolean canReuseEntry = (entry instanceof Multisets.ImmutableEntry && !(entry instanceof NonTerminalEntry));
        nonTerminalEntry = canReuseEntry ? (Multisets.ImmutableEntry)entry : new Multisets.ImmutableEntry(element, count);
      } else {
        nonTerminalEntry = new NonTerminalEntry(element, count, bucketHead);
      } 
      hashCode += (hash ^ count);
      arrayOfImmutableEntry1[index++] = nonTerminalEntry;
      arrayOfImmutableEntry2[bucket] = nonTerminalEntry;
      size += count;
    } 
    return hashFloodingDetected(arrayOfImmutableEntry2) ? 
      JdkBackedImmutableMultiset.create(ImmutableList.asImmutableList(arrayOfImmutableEntry1)) : 
      new RegularImmutableMultiset(arrayOfImmutableEntry1, arrayOfImmutableEntry2, 
        Ints.saturatedCast(size), hashCode, null);
  }
  
  private static boolean hashFloodingDetected(ImmutableEntry[] hashTable) {
    for (int i = 0; i < hashTable.length; i++) {
      int bucketLength = 0;
      for (Multisets.ImmutableEntry<?> entry = hashTable[i]; entry != null; entry = entry.nextInBucket()) {
        bucketLength++;
        if (bucketLength > 9)
          return true; 
      } 
    } 
    return false;
  }
  
  private RegularImmutableMultiset(ImmutableEntry[] entries, ImmutableEntry[] hashTable, int size, int hashCode, @CheckForNull ImmutableSet<E> elementSet) {
    this.entries = entries;
    this.hashTable = hashTable;
    this.size = size;
    this.hashCode = hashCode;
    this.elementSet = elementSet;
  }
  
  boolean isPartialView() { return false; }
  
  public int count(@CheckForNull Object element) {
    Multisets.ImmutableEntry[] arrayOfImmutableEntry = this.hashTable;
    if (element == null || arrayOfImmutableEntry.length == 0)
      return 0; 
    int hash = Hashing.smearedHash(element);
    int mask = arrayOfImmutableEntry.length - 1;
    Multisets.ImmutableEntry<?> entry = arrayOfImmutableEntry[hash & mask];
    for (; entry != null; 
      entry = entry.nextInBucket()) {
      if (Objects.equal(element, entry.getElement()))
        return entry.getCount(); 
    } 
    return 0;
  }
  
  public int size() { return this.size; }
  
  public ImmutableSet<E> elementSet() {
    ImmutableSet<E> result = this.elementSet;
    return (result == null) ? (this.elementSet = new ImmutableMultiset.ElementSet(Arrays.asList(this.entries), this)) : result;
  }
  
  Multiset.Entry<E> getEntry(int index) { return this.entries[index]; }
  
  public int hashCode() { return this.hashCode; }
}
