package com.google.common.util.concurrent;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.base.Preconditions;
import com.google.errorprone.annotations.concurrent.GuardedBy;
import com.google.j2objc.annotations.RetainedWith;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.concurrent.Executor;
import java.util.logging.Logger;

@ElementTypesAreNonnullByDefault
@J2ktIncompatible
@GwtIncompatible
final class SequentialExecutor implements Executor {
  private static final Logger log = Logger.getLogger(SequentialExecutor.class.getName());
  
  private final Executor executor;
  
  @GuardedBy("queue")
  private final Deque<Runnable> queue;
  
  @GuardedBy("queue")
  private WorkerRunningState workerRunningState;
  
  @GuardedBy("queue")
  private long workerRunCount;
  
  @RetainedWith
  private final QueueWorker worker;
  
  SequentialExecutor(Executor executor) {
    this.queue = new ArrayDeque();
    this.workerRunningState = WorkerRunningState.IDLE;
    this.workerRunCount = 0L;
    this.worker = new QueueWorker(this, null);
    this.executor = (Executor)Preconditions.checkNotNull(executor);
  }
  
  public void execute(Runnable task) {
    long oldRunCount;
    Object object;
    Preconditions.checkNotNull(task);
    synchronized (this.queue) {
      if (this.workerRunningState == WorkerRunningState.RUNNING || this.workerRunningState == WorkerRunningState.QUEUED) {
        this.queue.add(task);
        return;
      } 
      oldRunCount = this.workerRunCount;
      object = new Object(this, task);
      this.queue.add(object);
      this.workerRunningState = WorkerRunningState.QUEUING;
    } 
    try {
      this.executor.execute(this.worker);
    } catch (RuntimeException|Error t) {
      synchronized (this.queue) {
        boolean removed = ((this.workerRunningState == WorkerRunningState.IDLE || this.workerRunningState == WorkerRunningState.QUEUING) && this.queue.removeLastOccurrence(object));
        if (!(t instanceof java.util.concurrent.RejectedExecutionException) || removed)
          throw t; 
      } 
      return;
    } 
    boolean alreadyMarkedQueued = (this.workerRunningState != WorkerRunningState.QUEUING);
    if (alreadyMarkedQueued)
      return; 
    synchronized (this.queue) {
      if (this.workerRunCount == oldRunCount && this.workerRunningState == WorkerRunningState.QUEUING)
        this.workerRunningState = WorkerRunningState.QUEUED; 
    } 
  }
  
  public String toString() { return "SequentialExecutor@" + System.identityHashCode(this) + "{" + this.executor + "}"; }
}
