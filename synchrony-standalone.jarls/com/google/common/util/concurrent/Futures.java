package com.google.common.util.concurrent;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.time.Duration;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@ElementTypesAreNonnullByDefault
@GwtCompatible(emulated = true)
public final class Futures extends GwtFuturesCatchingSpecialization {
  public static <V> ListenableFuture<V> immediateFuture(@ParametricNullness V value) {
    if (value == null)
      return ImmediateFuture.NULL; 
    return new ImmediateFuture(value);
  }
  
  public static ListenableFuture<Void> immediateVoidFuture() { return ImmediateFuture.NULL; }
  
  public static <V> ListenableFuture<V> immediateFailedFuture(Throwable throwable) {
    Preconditions.checkNotNull(throwable);
    return new ImmediateFuture.ImmediateFailedFuture(throwable);
  }
  
  public static <V> ListenableFuture<V> immediateCancelledFuture() {
    ImmediateFuture.ImmediateCancelledFuture immediateCancelledFuture = ImmediateFuture.ImmediateCancelledFuture.INSTANCE;
    if (immediateCancelledFuture != null)
      return immediateCancelledFuture; 
    return new ImmediateFuture.ImmediateCancelledFuture();
  }
  
  public static <O> ListenableFuture<O> submit(Callable<O> callable, Executor executor) {
    TrustedListenableFutureTask<O> task = TrustedListenableFutureTask.create(callable);
    executor.execute(task);
    return task;
  }
  
  public static ListenableFuture<Void> submit(Runnable runnable, Executor executor) {
    TrustedListenableFutureTask<Void> task = TrustedListenableFutureTask.create(runnable, null);
    executor.execute(task);
    return task;
  }
  
  public static <O> ListenableFuture<O> submitAsync(AsyncCallable<O> callable, Executor executor) {
    TrustedListenableFutureTask<O> task = TrustedListenableFutureTask.create(callable);
    executor.execute(task);
    return task;
  }
  
  @J2ktIncompatible
  @GwtIncompatible
  public static <O> ListenableFuture<O> scheduleAsync(AsyncCallable<O> callable, Duration delay, ScheduledExecutorService executorService) { return scheduleAsync(callable, Internal.toNanosSaturated(delay), TimeUnit.NANOSECONDS, executorService); }
  
  @J2ktIncompatible
  @GwtIncompatible
  public static <O> ListenableFuture<O> scheduleAsync(AsyncCallable<O> callable, long delay, TimeUnit timeUnit, ScheduledExecutorService executorService) {
    TrustedListenableFutureTask<O> task = TrustedListenableFutureTask.create(callable);
    Future<?> scheduled = executorService.schedule(task, delay, timeUnit);
    task.addListener(() -> scheduled.cancel(false), MoreExecutors.directExecutor());
    return task;
  }
  
  @J2ktIncompatible
  @GwtIncompatible("AVAILABLE but requires exceptionType to be Throwable.class")
  public static <V, X extends Throwable> ListenableFuture<V> catching(ListenableFuture<? extends V> input, Class<X> exceptionType, Function<? super X, ? extends V> fallback, Executor executor) { return AbstractCatchingFuture.create(input, exceptionType, fallback, executor); }
  
  @J2ktIncompatible
  @GwtIncompatible("AVAILABLE but requires exceptionType to be Throwable.class")
  public static <V, X extends Throwable> ListenableFuture<V> catchingAsync(ListenableFuture<? extends V> input, Class<X> exceptionType, AsyncFunction<? super X, ? extends V> fallback, Executor executor) { return AbstractCatchingFuture.create(input, exceptionType, fallback, executor); }
  
  @J2ktIncompatible
  @GwtIncompatible
  public static <V> ListenableFuture<V> withTimeout(ListenableFuture<V> delegate, Duration time, ScheduledExecutorService scheduledExecutor) { return withTimeout(delegate, Internal.toNanosSaturated(time), TimeUnit.NANOSECONDS, scheduledExecutor); }
  
  @J2ktIncompatible
  @GwtIncompatible
  public static <V> ListenableFuture<V> withTimeout(ListenableFuture<V> delegate, long time, TimeUnit unit, ScheduledExecutorService scheduledExecutor) {
    if (delegate.isDone())
      return delegate; 
    return TimeoutFuture.create(delegate, time, unit, scheduledExecutor);
  }
  
  public static <I, O> ListenableFuture<O> transformAsync(ListenableFuture<I> input, AsyncFunction<? super I, ? extends O> function, Executor executor) { return AbstractTransformFuture.create(input, function, executor); }
  
  public static <I, O> ListenableFuture<O> transform(ListenableFuture<I> input, Function<? super I, ? extends O> function, Executor executor) { return AbstractTransformFuture.create(input, function, executor); }
  
  @J2ktIncompatible
  @GwtIncompatible
  public static <I, O> Future<O> lazyTransform(Future<I> input, Function<? super I, ? extends O> function) {
    Preconditions.checkNotNull(input);
    Preconditions.checkNotNull(function);
    return new Object(input, function);
  }
  
  @SafeVarargs
  public static <V> ListenableFuture<List<V>> allAsList(ListenableFuture... futures) {
    CollectionFuture.ListFuture listFuture = new CollectionFuture.ListFuture(ImmutableList.copyOf(futures), true);
    return listFuture;
  }
  
  public static <V> ListenableFuture<List<V>> allAsList(Iterable<? extends ListenableFuture<? extends V>> futures) {
    CollectionFuture.ListFuture listFuture = new CollectionFuture.ListFuture(ImmutableList.copyOf(futures), true);
    return listFuture;
  }
  
  @SafeVarargs
  public static <V> FutureCombiner<V> whenAllComplete(ListenableFuture... futures) { return new FutureCombiner(false, ImmutableList.copyOf(futures), null); }
  
  public static <V> FutureCombiner<V> whenAllComplete(Iterable<? extends ListenableFuture<? extends V>> futures) { return new FutureCombiner(false, ImmutableList.copyOf(futures), null); }
  
  @SafeVarargs
  public static <V> FutureCombiner<V> whenAllSucceed(ListenableFuture... futures) { return new FutureCombiner(true, ImmutableList.copyOf(futures), null); }
  
  public static <V> FutureCombiner<V> whenAllSucceed(Iterable<? extends ListenableFuture<? extends V>> futures) { return new FutureCombiner(true, ImmutableList.copyOf(futures), null); }
  
  public static <V> ListenableFuture<V> nonCancellationPropagating(ListenableFuture<V> future) {
    if (future.isDone())
      return future; 
    NonCancellationPropagatingFuture<V> output = new NonCancellationPropagatingFuture<V>(future);
    future.addListener(output, MoreExecutors.directExecutor());
    return output;
  }
  
  @SafeVarargs
  public static <V> ListenableFuture<List<V>> successfulAsList(ListenableFuture... futures) { return new CollectionFuture.ListFuture(ImmutableList.copyOf(futures), false); }
  
  public static <V> ListenableFuture<List<V>> successfulAsList(Iterable<? extends ListenableFuture<? extends V>> futures) { return new CollectionFuture.ListFuture(ImmutableList.copyOf(futures), false); }
  
  public static <T> ImmutableList<ListenableFuture<T>> inCompletionOrder(Iterable<? extends ListenableFuture<? extends T>> futures) {
    ListenableFuture[] copy = gwtCompatibleToArray(futures);
    InCompletionOrderState<T> state = new InCompletionOrderState<T>(copy, null);
    ImmutableList.Builder<AbstractFuture<T>> delegatesBuilder = ImmutableList.builderWithExpectedSize(copy.length);
    for (int i = 0; i < copy.length; i++)
      delegatesBuilder.add(new InCompletionOrderFuture(state, null)); 
    ImmutableList<AbstractFuture<T>> delegates = delegatesBuilder.build();
    for (int i = 0; i < copy.length; i++) {
      int localI = i;
      copy[i].addListener(() -> InCompletionOrderState.access$600(state, delegates, localI), MoreExecutors.directExecutor());
    } 
    return delegates;
  }
  
  private static <T> ListenableFuture<? extends T>[] gwtCompatibleToArray(Iterable<? extends ListenableFuture<? extends T>> futures) {
    ImmutableList immutableList;
    if (futures instanceof Collection) {
      immutableList = (Collection)futures;
    } else {
      immutableList = ImmutableList.copyOf(futures);
    } 
    return (ListenableFuture[])immutableList.toArray(new ListenableFuture[0]);
  }
  
  public static <V> void addCallback(ListenableFuture<V> future, FutureCallback<? super V> callback, Executor executor) {
    Preconditions.checkNotNull(callback);
    future.addListener(new CallbackListener(future, callback), executor);
  }
  
  @ParametricNullness
  @CanIgnoreReturnValue
  public static <V> V getDone(Future<V> future) throws ExecutionException {
    Preconditions.checkState(future.isDone(), "Future was expected to be done: %s", future);
    return (V)Uninterruptibles.getUninterruptibly(future);
  }
  
  @ParametricNullness
  @CanIgnoreReturnValue
  @J2ktIncompatible
  @GwtIncompatible
  public static <V, X extends Exception> V getChecked(Future<V> future, Class<X> exceptionClass) throws X { return (V)FuturesGetChecked.getChecked(future, exceptionClass); }
  
  @ParametricNullness
  @CanIgnoreReturnValue
  @J2ktIncompatible
  @GwtIncompatible
  public static <V, X extends Exception> V getChecked(Future<V> future, Class<X> exceptionClass, Duration timeout) throws X { return (V)getChecked(future, exceptionClass, Internal.toNanosSaturated(timeout), TimeUnit.NANOSECONDS); }
  
  @ParametricNullness
  @CanIgnoreReturnValue
  @J2ktIncompatible
  @GwtIncompatible
  public static <V, X extends Exception> V getChecked(Future<V> future, Class<X> exceptionClass, long timeout, TimeUnit unit) throws X { return (V)FuturesGetChecked.getChecked(future, exceptionClass, timeout, unit); }
  
  @ParametricNullness
  @CanIgnoreReturnValue
  public static <V> V getUnchecked(Future<V> future) throws ExecutionException {
    Preconditions.checkNotNull(future);
    try {
      return (V)Uninterruptibles.getUninterruptibly(future);
    } catch (ExecutionException e) {
      wrapAndThrowUnchecked(e.getCause());
      throw new AssertionError();
    } 
  }
  
  private static void wrapAndThrowUnchecked(Throwable cause) {
    if (cause instanceof Error)
      throw new ExecutionError((Error)cause); 
    throw new UncheckedExecutionException(cause);
  }
}
