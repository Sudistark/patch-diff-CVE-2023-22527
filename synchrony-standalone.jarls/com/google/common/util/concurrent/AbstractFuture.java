package com.google.common.util.concurrent;

import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Preconditions;
import com.google.common.base.Strings;
import com.google.common.util.concurrent.internal.InternalFutureFailureAccess;
import com.google.common.util.concurrent.internal.InternalFutures;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.ForOverride;
import com.google.j2objc.annotations.ReflectionSupport;
import java.util.Locale;
import java.util.Objects;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import java.util.concurrent.locks.LockSupport;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible(emulated = true)
@ReflectionSupport(ReflectionSupport.Level.FULL)
public abstract class AbstractFuture<V> extends InternalFutureFailureAccess implements ListenableFuture<V> {
  static final boolean GENERATE_CANCELLATION_CAUSES;
  
  private static final Logger log;
  
  private static final long SPIN_THRESHOLD_NANOS = 1000L;
  
  private static final AtomicHelper ATOMIC_HELPER;
  
  private static final Object NULL;
  
  static  {
    SynchronizedHelper synchronizedHelper;
    boolean bool;
    try {
      bool = Boolean.parseBoolean(
          System.getProperty("guava.concurrent.generate_cancellation_cause", "false"));
    } catch (SecurityException e) {
      bool = false;
    } 
    GENERATE_CANCELLATION_CAUSES = bool;
    log = Logger.getLogger(AbstractFuture.class.getName());
    Throwable thrownUnsafeFailure = null;
    Throwable thrownAtomicReferenceFieldUpdaterFailure = null;
    try {
      synchronizedHelper = new UnsafeAtomicHelper(null);
    } catch (RuntimeException|Error unsafeFailure) {
      thrownUnsafeFailure = unsafeFailure;
      try {
        synchronizedHelper = new SafeAtomicHelper(AtomicReferenceFieldUpdater.newUpdater(Waiter.class, Thread.class, "thread"), AtomicReferenceFieldUpdater.newUpdater(Waiter.class, Waiter.class, "next"), AtomicReferenceFieldUpdater.newUpdater(AbstractFuture.class, Waiter.class, "waiters"), AtomicReferenceFieldUpdater.newUpdater(AbstractFuture.class, Listener.class, "listeners"), AtomicReferenceFieldUpdater.newUpdater(AbstractFuture.class, Object.class, "value"));
      } catch (RuntimeException|Error atomicReferenceFieldUpdaterFailure) {
        thrownAtomicReferenceFieldUpdaterFailure = atomicReferenceFieldUpdaterFailure;
        synchronizedHelper = new SynchronizedHelper(null);
      } 
    } 
    ATOMIC_HELPER = synchronizedHelper;
    Class<?> ensureLoaded = LockSupport.class;
    if (thrownAtomicReferenceFieldUpdaterFailure != null) {
      log.log(Level.SEVERE, "UnsafeAtomicHelper is broken!", thrownUnsafeFailure);
      log.log(Level.SEVERE, "SafeAtomicHelper is broken!", thrownAtomicReferenceFieldUpdaterFailure);
    } 
    NULL = new Object();
  }
  
  private void removeWaiter(Waiter node) {
    node.thread = null;
    label22: while (true) {
      Waiter pred = null;
      Waiter curr = this.waiters;
      if (curr == Waiter.TOMBSTONE)
        return; 
      while (curr != null) {
        Waiter succ = curr.next;
        if (curr.thread != null) {
          pred = curr;
        } else if (pred != null) {
          pred.next = succ;
          if (pred.thread == null)
            continue label22; 
        } else if (!ATOMIC_HELPER.casWaiters(this, curr, succ)) {
          continue label22;
        } 
        curr = succ;
      } 
      break;
    } 
  }
  
  @ParametricNullness
  @CanIgnoreReturnValue
  public V get(long timeout, TimeUnit unit) throws InterruptedException, TimeoutException, ExecutionException {
    long timeoutNanos = unit.toNanos(timeout);
    long remainingNanos = timeoutNanos;
    if (Thread.interrupted())
      throw new InterruptedException(); 
    Object localValue = this.value;
    if (((localValue != null) ? 1 : 0) & (!(localValue instanceof SetFuture) ? 1 : 0))
      return (V)getDoneValue(localValue); 
    long endNanos = (remainingNanos > 0L) ? (System.nanoTime() + remainingNanos) : 0L;
    if (remainingNanos >= 1000L) {
      Waiter oldHead = this.waiters;
      if (oldHead != Waiter.TOMBSTONE) {
        Waiter node = new Waiter();
        label77: while (true) {
          node.setNext(oldHead);
          if (ATOMIC_HELPER.casWaiters(this, oldHead, node)) {
            do {
              OverflowAvoidingLockSupport.parkNanos(this, remainingNanos);
              if (Thread.interrupted()) {
                removeWaiter(node);
                throw new InterruptedException();
              } 
              localValue = this.value;
              if (((localValue != null) ? 1 : 0) & (!(localValue instanceof SetFuture) ? 1 : 0))
                return (V)getDoneValue(localValue); 
              remainingNanos = endNanos - System.nanoTime();
            } while (remainingNanos >= 1000L);
            removeWaiter(node);
            break;
          } 
          oldHead = this.waiters;
          if (oldHead == Waiter.TOMBSTONE)
            break label77; 
        } 
      } else {
        return (V)getDoneValue(Objects.requireNonNull(this.value));
      } 
    } 
    while (remainingNanos > 0L) {
      localValue = this.value;
      if (((localValue != null) ? 1 : 0) & (!(localValue instanceof SetFuture) ? 1 : 0))
        return (V)getDoneValue(localValue); 
      if (Thread.interrupted())
        throw new InterruptedException(); 
      remainingNanos = endNanos - System.nanoTime();
    } 
    String futureToString = toString();
    String unitString = unit.toString().toLowerCase(Locale.ROOT);
    String message = "Waited " + timeout + " " + unit.toString().toLowerCase(Locale.ROOT);
    if (remainingNanos + 1000L < 0L) {
      message = message + " (plus ";
      long overWaitNanos = -remainingNanos;
      long overWaitUnits = unit.convert(overWaitNanos, TimeUnit.NANOSECONDS);
      long overWaitLeftoverNanos = overWaitNanos - unit.toNanos(overWaitUnits);
      boolean shouldShowExtraNanos = (overWaitUnits == 0L || overWaitLeftoverNanos > 1000L);
      if (overWaitUnits > 0L) {
        message = message + overWaitUnits + " " + unitString;
        if (shouldShowExtraNanos)
          message = message + ","; 
        message = message + " ";
      } 
      if (shouldShowExtraNanos)
        message = message + overWaitLeftoverNanos + " nanoseconds "; 
      message = message + "delay)";
    } 
    if (isDone())
      throw new TimeoutException(message + " but future completed as timeout expired"); 
    throw new TimeoutException(message + " for " + futureToString);
  }
  
  @ParametricNullness
  @CanIgnoreReturnValue
  public V get() throws InterruptedException, ExecutionException {
    if (Thread.interrupted())
      throw new InterruptedException(); 
    Object localValue = this.value;
    if (((localValue != null) ? 1 : 0) & (!(localValue instanceof SetFuture) ? 1 : 0))
      return (V)getDoneValue(localValue); 
    Waiter oldHead = this.waiters;
    if (oldHead != Waiter.TOMBSTONE) {
      Waiter node = new Waiter();
      do {
        node.setNext(oldHead);
        if (ATOMIC_HELPER.casWaiters(this, oldHead, node)) {
          do {
            LockSupport.park(this);
            if (Thread.interrupted()) {
              removeWaiter(node);
              throw new InterruptedException();
            } 
            localValue = this.value;
          } while (!(((localValue != null) ? 1 : 0) & (!(localValue instanceof SetFuture) ? 1 : 0)));
          return (V)getDoneValue(localValue);
        } 
        oldHead = this.waiters;
      } while (oldHead != Waiter.TOMBSTONE);
    } 
    return (V)getDoneValue(Objects.requireNonNull(this.value));
  }
  
  @ParametricNullness
  private V getDoneValue(Object obj) throws ExecutionException {
    if (obj instanceof Cancellation)
      throw cancellationExceptionWithCause("Task was cancelled.", ((Cancellation)obj).cause); 
    if (obj instanceof Failure)
      throw new ExecutionException(((Failure)obj).exception); 
    if (obj == NULL)
      return (V)NullnessCasts.uncheckedNull(); 
    return (V)obj;
  }
  
  public boolean isDone() {
    Object localValue = this.value;
    return ((localValue != null) ? 1 : 0) & (!(localValue instanceof SetFuture) ? 1 : 0);
  }
  
  public boolean isCancelled() {
    Object localValue = this.value;
    return localValue instanceof Cancellation;
  }
  
  @CanIgnoreReturnValue
  public boolean cancel(boolean mayInterruptIfRunning) {
    Object localValue = this.value;
    boolean rValue = false;
    if (((localValue == null) ? 1 : 0) | localValue instanceof SetFuture) {
      Object valueToSet = GENERATE_CANCELLATION_CAUSES ? new Cancellation(mayInterruptIfRunning, new CancellationException("Future.cancel() was called.")) : Objects.requireNonNull(
          mayInterruptIfRunning ? 
          Cancellation.CAUSELESS_INTERRUPTED : 
          Cancellation.CAUSELESS_CANCELLED);
      AbstractFuture<?> abstractFuture = this;
      do {
        while (ATOMIC_HELPER.casValue(abstractFuture, localValue, valueToSet)) {
          rValue = true;
          complete(abstractFuture, mayInterruptIfRunning);
          if (localValue instanceof SetFuture) {
            ListenableFuture<?> futureToPropagateTo = ((SetFuture)localValue).future;
            if (futureToPropagateTo instanceof Trusted) {
              AbstractFuture<?> trusted = (AbstractFuture)futureToPropagateTo;
              localValue = trusted.value;
              if (((localValue == null) ? 1 : 0) | localValue instanceof SetFuture) {
                abstractFuture = trusted;
                continue;
              } 
              // Byte code: goto -> 185
            } 
            futureToPropagateTo.cancel(mayInterruptIfRunning);
            break;
          } 
          // Byte code: goto -> 185
        } 
        localValue = abstractFuture.value;
      } while (localValue instanceof SetFuture);
    } 
    return rValue;
  }
  
  protected void interruptTask() {}
  
  protected final boolean wasInterrupted() {
    Object localValue = this.value;
    return (localValue instanceof Cancellation && ((Cancellation)localValue).wasInterrupted);
  }
  
  public void addListener(Runnable listener, Executor executor) {
    Preconditions.checkNotNull(listener, "Runnable was null.");
    Preconditions.checkNotNull(executor, "Executor was null.");
    if (!isDone()) {
      Listener oldHead = this.listeners;
      if (oldHead != Listener.TOMBSTONE) {
        Listener newNode = new Listener(listener, executor);
        do {
          newNode.next = oldHead;
          if (ATOMIC_HELPER.casListeners(this, oldHead, newNode))
            return; 
          oldHead = this.listeners;
        } while (oldHead != Listener.TOMBSTONE);
      } 
    } 
    executeListener(listener, executor);
  }
  
  @CanIgnoreReturnValue
  protected boolean set(@ParametricNullness V value) {
    Object valueToSet = (value == null) ? NULL : value;
    if (ATOMIC_HELPER.casValue(this, null, valueToSet)) {
      complete(this, false);
      return true;
    } 
    return false;
  }
  
  @CanIgnoreReturnValue
  protected boolean setException(Throwable throwable) {
    Object valueToSet = new Failure((Throwable)Preconditions.checkNotNull(throwable));
    if (ATOMIC_HELPER.casValue(this, null, valueToSet)) {
      complete(this, false);
      return true;
    } 
    return false;
  }
  
  @CanIgnoreReturnValue
  protected boolean setFuture(ListenableFuture<? extends V> future) {
    Preconditions.checkNotNull(future);
    Object localValue = this.value;
    if (localValue == null) {
      if (future.isDone()) {
        Object value = getFutureValue(future);
        if (ATOMIC_HELPER.casValue(this, null, value)) {
          complete(this, false);
          return true;
        } 
        return false;
      } 
      SetFuture<V> valueToSet = new SetFuture<V>(this, future);
      if (ATOMIC_HELPER.casValue(this, null, valueToSet)) {
        try {
          future.addListener(valueToSet, DirectExecutor.INSTANCE);
        } catch (RuntimeException|Error t) {
          Failure failure;
          try {
            failure = new Failure(t);
          } catch (RuntimeException|Error oomMostLikely) {
            failure = Failure.FALLBACK_INSTANCE;
          } 
          boolean bool = ATOMIC_HELPER.casValue(this, valueToSet, failure);
        } 
        return true;
      } 
      localValue = this.value;
    } 
    if (localValue instanceof Cancellation)
      future.cancel(((Cancellation)localValue).wasInterrupted); 
    return false;
  }
  
  private static Object getFutureValue(ListenableFuture<?> future) {
    if (future instanceof Trusted) {
      Object v = ((AbstractFuture)future).value;
      if (v instanceof Cancellation) {
        Cancellation c = (Cancellation)v;
        if (c.wasInterrupted)
          v = (c.cause != null) ? new Cancellation(false, c.cause) : Cancellation.CAUSELESS_CANCELLED; 
      } 
      return Objects.requireNonNull(v);
    } 
    if (future instanceof InternalFutureFailureAccess) {
      Throwable throwable = InternalFutures.tryInternalFastPathGetFailure((InternalFutureFailureAccess)future);
      if (throwable != null)
        return new Failure(throwable); 
    } 
    boolean wasCancelled = future.isCancelled();
    if ((!GENERATE_CANCELLATION_CAUSES ? 1 : 0) & wasCancelled)
      return Objects.requireNonNull(Cancellation.CAUSELESS_CANCELLED); 
    try {
      Object v = getUninterruptibly(future);
      if (wasCancelled)
        return new Cancellation(false, new IllegalArgumentException("get() did not throw CancellationException, despite reporting isCancelled() == true: " + future)); 
      return (v == null) ? NULL : v;
    } catch (ExecutionException exception) {
      if (wasCancelled)
        return new Cancellation(false, new IllegalArgumentException("get() did not throw CancellationException, despite reporting isCancelled() == true: " + future, exception)); 
      return new Failure(exception.getCause());
    } catch (CancellationException cancellation) {
      if (!wasCancelled)
        return new Failure(new IllegalArgumentException("get() threw CancellationException, despite reporting isCancelled() == false: " + future, cancellation)); 
      return new Cancellation(false, cancellation);
    } catch (RuntimeException|Error t) {
      return new Failure(t);
    } 
  }
  
  @ParametricNullness
  private static <V> V getUninterruptibly(Future<V> future) throws ExecutionException {
    interrupted = false;
    while (true) {
      try {
        object = future.get();
        return (V)object;
      } catch (InterruptedException e) {
      
      } finally {
        if (interrupted)
          Thread.currentThread().interrupt(); 
      } 
    } 
  }
  
  private static void complete(AbstractFuture<?> param, boolean callInterruptTask) {
    AbstractFuture<?> future = param;
    Listener next = null;
    label20: while (true) {
      future.releaseWaiters();
      if (callInterruptTask) {
        future.interruptTask();
        callInterruptTask = false;
      } 
      future.afterDone();
      next = future.clearListeners(next);
      future = null;
      while (next != null) {
        Listener curr = next;
        next = next.next;
        Runnable task = (Runnable)Objects.requireNonNull(curr.task);
        if (task instanceof SetFuture) {
          SetFuture<?> setFuture = (SetFuture)task;
          future = setFuture.owner;
          if (future.value == setFuture) {
            Object valueToSet = getFutureValue(setFuture.future);
            if (ATOMIC_HELPER.casValue(future, setFuture, valueToSet))
              continue label20; 
          } 
          continue;
        } 
        executeListener(task, (Executor)Objects.requireNonNull(curr.executor));
      } 
      break;
    } 
  }
  
  @ForOverride
  protected void afterDone() {}
  
  @CheckForNull
  protected final Throwable tryInternalFastPathGetFailure() {
    if (this instanceof Trusted) {
      Object obj = this.value;
      if (obj instanceof Failure)
        return ((Failure)obj).exception; 
    } 
    return null;
  }
  
  final void maybePropagateCancellationTo(@CheckForNull Future<?> related) {
    if (((related != null) ? 1 : 0) & isCancelled())
      related.cancel(wasInterrupted()); 
  }
  
  private void releaseWaiters() {
    Waiter head = ATOMIC_HELPER.gasWaiters(this, Waiter.TOMBSTONE);
    for (Waiter currentWaiter = head; currentWaiter != null; currentWaiter = currentWaiter.next)
      currentWaiter.unpark(); 
  }
  
  @CheckForNull
  private Listener clearListeners(@CheckForNull Listener onto) {
    Listener head = ATOMIC_HELPER.gasListeners(this, Listener.TOMBSTONE);
    Listener reversedList = onto;
    while (head != null) {
      Listener tmp = head;
      head = head.next;
      tmp.next = reversedList;
      reversedList = tmp;
    } 
    return reversedList;
  }
  
  public String toString() {
    StringBuilder builder = new StringBuilder();
    if (getClass().getName().startsWith("com.google.common.util.concurrent.")) {
      builder.append(getClass().getSimpleName());
    } else {
      builder.append(getClass().getName());
    } 
    builder.append('@').append(Integer.toHexString(System.identityHashCode(this))).append("[status=");
    if (isCancelled()) {
      builder.append("CANCELLED");
    } else if (isDone()) {
      addDoneString(builder);
    } else {
      addPendingString(builder);
    } 
    return builder.append("]").toString();
  }
  
  @CheckForNull
  protected String pendingToString() {
    if (this instanceof ScheduledFuture)
      return "remaining delay=[" + ((ScheduledFuture)this)
        .getDelay(TimeUnit.MILLISECONDS) + " ms]"; 
    return null;
  }
  
  private void addPendingString(StringBuilder builder) {
    int truncateLength = builder.length();
    builder.append("PENDING");
    Object localValue = this.value;
    if (localValue instanceof SetFuture) {
      builder.append(", setFuture=[");
      appendUserObject(builder, ((SetFuture)localValue).future);
      builder.append("]");
    } else {
      String pendingDescription;
      try {
        pendingDescription = Strings.emptyToNull(pendingToString());
      } catch (RuntimeException|StackOverflowError e) {
        pendingDescription = "Exception thrown from implementation: " + e.getClass();
      } 
      if (pendingDescription != null)
        builder.append(", info=[").append(pendingDescription).append("]"); 
    } 
    if (isDone()) {
      builder.delete(truncateLength, builder.length());
      addDoneString(builder);
    } 
  }
  
  private void addDoneString(StringBuilder builder) {
    try {
      V value = (V)getUninterruptibly(this);
      builder.append("SUCCESS, result=[");
      appendResultObject(builder, value);
      builder.append("]");
    } catch (ExecutionException e) {
      builder.append("FAILURE, cause=[").append(e.getCause()).append("]");
    } catch (CancellationException e) {
      builder.append("CANCELLED");
    } catch (RuntimeException e) {
      builder.append("UNKNOWN, cause=[").append(e.getClass()).append(" thrown from get()]");
    } 
  }
  
  private void appendResultObject(StringBuilder builder, @CheckForNull Object o) {
    if (o == null) {
      builder.append("null");
    } else if (o == this) {
      builder.append("this future");
    } else {
      builder
        .append(o.getClass().getName())
        .append("@")
        .append(Integer.toHexString(System.identityHashCode(o)));
    } 
  }
  
  private void appendUserObject(StringBuilder builder, @CheckForNull Object o) {
    try {
      if (o == this) {
        builder.append("this future");
      } else {
        builder.append(o);
      } 
    } catch (RuntimeException|StackOverflowError e) {
      builder.append("Exception thrown from implementation: ").append(e.getClass());
    } 
  }
  
  private static void executeListener(Runnable runnable, Executor executor) {
    try {
      executor.execute(runnable);
    } catch (RuntimeException e) {
      log.log(Level.SEVERE, "RuntimeException while executing runnable " + runnable + " with executor " + executor, e);
    } 
  }
  
  private static CancellationException cancellationExceptionWithCause(String message, @CheckForNull Throwable cause) {
    CancellationException exception = new CancellationException(message);
    exception.initCause(cause);
    return exception;
  }
}
