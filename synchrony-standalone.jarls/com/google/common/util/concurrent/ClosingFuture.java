package com.google.common.util.concurrent;

import com.google.common.annotations.J2ktIncompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Functions;
import com.google.common.base.MoreObjects;
import com.google.common.base.Preconditions;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.Lists;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.DoNotMock;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.atomic.AtomicReference;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.annotation.CheckForNull;

@DoNotMock("Use ClosingFuture.from(Futures.immediate*Future)")
@ElementTypesAreNonnullByDefault
@J2ktIncompatible
public final class ClosingFuture<V> extends Object {
  private static final Logger logger = Logger.getLogger(ClosingFuture.class.getName());
  
  private final AtomicReference<State> state;
  
  private final CloseableList closeables;
  
  private final FluentFuture<V> future;
  
  public static <V> ClosingFuture<V> submit(ClosingCallable<V> callable, Executor executor) { return new ClosingFuture(callable, executor); }
  
  public static <V> ClosingFuture<V> submitAsync(AsyncClosingCallable<V> callable, Executor executor) { return new ClosingFuture(callable, executor); }
  
  public static <V> ClosingFuture<V> from(ListenableFuture<V> future) { return new ClosingFuture(future); }
  
  @Deprecated
  public static <C extends AutoCloseable> ClosingFuture<C> eventuallyClosing(ListenableFuture<C> future, Executor closingExecutor) {
    Preconditions.checkNotNull(closingExecutor);
    ClosingFuture<C> closingFuture = new ClosingFuture<C>(Futures.nonCancellationPropagating(future));
    Futures.addCallback(future, new Object(closingFuture, closingExecutor), 









        
        MoreExecutors.directExecutor());
    return closingFuture;
  }
  
  public static Combiner whenAllComplete(Iterable<? extends ClosingFuture<?>> futures) { return new Combiner(false, futures, null); }
  
  public static Combiner whenAllComplete(ClosingFuture<?> future1, ClosingFuture... moreFutures) { return whenAllComplete(Lists.asList(future1, moreFutures)); }
  
  public static Combiner whenAllSucceed(Iterable<? extends ClosingFuture<?>> futures) { return new Combiner(true, futures, null); }
  
  public static <V1, V2> Combiner2<V1, V2> whenAllSucceed(ClosingFuture<V1> future1, ClosingFuture<V2> future2) { return new Combiner2(future1, future2, null); }
  
  public static <V1, V2, V3> Combiner3<V1, V2, V3> whenAllSucceed(ClosingFuture<V1> future1, ClosingFuture<V2> future2, ClosingFuture<V3> future3) { return new Combiner3(future1, future2, future3, null); }
  
  public static <V1, V2, V3, V4> Combiner4<V1, V2, V3, V4> whenAllSucceed(ClosingFuture<V1> future1, ClosingFuture<V2> future2, ClosingFuture<V3> future3, ClosingFuture<V4> future4) { return new Combiner4(future1, future2, future3, future4, null); }
  
  public static <V1, V2, V3, V4, V5> Combiner5<V1, V2, V3, V4, V5> whenAllSucceed(ClosingFuture<V1> future1, ClosingFuture<V2> future2, ClosingFuture<V3> future3, ClosingFuture<V4> future4, ClosingFuture<V5> future5) { return new Combiner5(future1, future2, future3, future4, future5, null); }
  
  public static Combiner whenAllSucceed(ClosingFuture<?> future1, ClosingFuture<?> future2, ClosingFuture<?> future3, ClosingFuture<?> future4, ClosingFuture<?> future5, ClosingFuture<?> future6, ClosingFuture... moreFutures) {
    return whenAllSucceed(
        FluentIterable.of(future1, new ClosingFuture[] { future2, future3, future4, future5, future6 }).append(moreFutures));
  }
  
  private ClosingFuture(ListenableFuture<V> future) {
    this.state = new AtomicReference(State.OPEN);
    this.closeables = new CloseableList(null);
    this.future = FluentFuture.from(future);
  }
  
  private ClosingFuture(ClosingCallable<V> callable, Executor executor) {
    this.state = new AtomicReference(State.OPEN);
    this.closeables = new CloseableList(null);
    Preconditions.checkNotNull(callable);
    TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(new Object(this, callable));
    executor.execute(task);
    this.future = task;
  }
  
  private ClosingFuture(AsyncClosingCallable<V> callable, Executor executor) {
    this.state = new AtomicReference(State.OPEN);
    this.closeables = new CloseableList(null);
    Preconditions.checkNotNull(callable);
    TrustedListenableFutureTask<V> task = TrustedListenableFutureTask.create(new Object(this, callable));
    executor.execute(task);
    this.future = task;
  }
  
  public ListenableFuture<?> statusFuture() { return Futures.nonCancellationPropagating(this.future.transform(Functions.constant(null), MoreExecutors.directExecutor())); }
  
  public <U> ClosingFuture<U> transform(ClosingFunction<? super V, U> function, Executor executor) {
    Preconditions.checkNotNull(function);
    Object object = new Object(this, function);
    return derive(this.future.transformAsync(object, executor));
  }
  
  public <U> ClosingFuture<U> transformAsync(AsyncClosingFunction<? super V, U> function, Executor executor) {
    Preconditions.checkNotNull(function);
    Object object = new Object(this, function);
    return derive(this.future.transformAsync(object, executor));
  }
  
  public static <V, U> AsyncClosingFunction<V, U> withoutCloser(AsyncFunction<V, U> function) {
    Preconditions.checkNotNull(function);
    return new Object(function);
  }
  
  public <X extends Throwable> ClosingFuture<V> catching(Class<X> exceptionType, ClosingFunction<? super X, ? extends V> fallback, Executor executor) { return catchingMoreGeneric(exceptionType, fallback, executor); }
  
  private <X extends Throwable, W extends V> ClosingFuture<V> catchingMoreGeneric(Class<X> exceptionType, ClosingFunction<? super X, W> fallback, Executor executor) {
    Preconditions.checkNotNull(fallback);
    Object object = new Object(this, fallback);
    return derive(this.future.catchingAsync(exceptionType, object, executor));
  }
  
  public <X extends Throwable> ClosingFuture<V> catchingAsync(Class<X> exceptionType, AsyncClosingFunction<? super X, ? extends V> fallback, Executor executor) { return catchingAsyncMoreGeneric(exceptionType, fallback, executor); }
  
  private <X extends Throwable, W extends V> ClosingFuture<V> catchingAsyncMoreGeneric(Class<X> exceptionType, AsyncClosingFunction<? super X, W> fallback, Executor executor) {
    Preconditions.checkNotNull(fallback);
    Object object = new Object(this, fallback);
    return derive(this.future.catchingAsync(exceptionType, object, executor));
  }
  
  public FluentFuture<V> finishToFuture() {
    if (compareAndUpdateState(State.OPEN, State.WILL_CLOSE)) {
      logger.log(Level.FINER, "will close {0}", this);
      this.future.addListener(new Object(this), 







          
          MoreExecutors.directExecutor());
    } else {
      switch (null.$SwitchMap$com$google$common$util$concurrent$ClosingFuture$State[((State)this.state.get()).ordinal()]) {
        case 1:
          throw new IllegalStateException("Cannot call finishToFuture() after deriving another step");
        case 2:
          throw new IllegalStateException("Cannot call finishToFuture() after calling finishToValueAndCloser()");
        case 3:
        case 4:
        case 5:
          throw new IllegalStateException("Cannot call finishToFuture() twice");
        case 6:
          throw new AssertionError();
      } 
    } 
    return this.future;
  }
  
  public void finishToValueAndCloser(ValueAndCloserConsumer<? super V> consumer, Executor executor) {
    Preconditions.checkNotNull(consumer);
    if (!compareAndUpdateState(State.OPEN, State.WILL_CREATE_VALUE_AND_CLOSER)) {
      switch (null.$SwitchMap$com$google$common$util$concurrent$ClosingFuture$State[((State)this.state.get()).ordinal()]) {
        case 1:
          throw new IllegalStateException("Cannot call finishToValueAndCloser() after deriving another step");
        case 3:
        case 4:
        case 5:
          throw new IllegalStateException("Cannot call finishToValueAndCloser() after calling finishToFuture()");
        case 2:
          throw new IllegalStateException("Cannot call finishToValueAndCloser() twice");
      } 
      throw new AssertionError(this.state);
    } 
    this.future.addListener(new Object(this, consumer), executor);
  }
  
  private static <C, V extends C> void provideValueAndCloser(ValueAndCloserConsumer<C> consumer, ClosingFuture<V> closingFuture) { consumer.accept(new ValueAndCloser(closingFuture)); }
  
  @CanIgnoreReturnValue
  public boolean cancel(boolean mayInterruptIfRunning) {
    logger.log(Level.FINER, "cancelling {0}", this);
    boolean cancelled = this.future.cancel(mayInterruptIfRunning);
    if (cancelled)
      close(); 
    return cancelled;
  }
  
  private void close() {
    logger.log(Level.FINER, "closing {0}", this);
    this.closeables.close();
  }
  
  private <U> ClosingFuture<U> derive(FluentFuture<U> future) {
    ClosingFuture<U> derived = new ClosingFuture<U>(future);
    becomeSubsumedInto(derived.closeables);
    return derived;
  }
  
  private void becomeSubsumedInto(CloseableList otherCloseables) {
    checkAndUpdateState(State.OPEN, State.SUBSUMED);
    otherCloseables.add(this.closeables, MoreExecutors.directExecutor());
  }
  
  public String toString() { return MoreObjects.toStringHelper(this).add("state", this.state.get()).addValue(this.future).toString(); }
  
  protected void finalize() {
    if (((State)this.state.get()).equals(State.OPEN)) {
      logger.log(Level.SEVERE, "Uh oh! An open ClosingFuture has leaked and will close: {0}", this);
      FluentFuture fluentFuture = finishToFuture();
    } 
  }
  
  private static void closeQuietly(@CheckForNull AutoCloseable closeable, Executor executor) {
    if (closeable == null)
      return; 
    try {
      executor.execute(() -> {
            try {
              closeable.close();
            } catch (Exception e) {
              Platform.restoreInterruptIfIsInterruptedException(e);
              logger.log(Level.WARNING, "thrown by close()", e);
            } 
          });
    } catch (RejectedExecutionException e) {
      if (logger.isLoggable(Level.WARNING))
        logger.log(Level.WARNING, 
            String.format("while submitting close to %s; will close inline", new Object[] { executor }), e); 
      closeQuietly(closeable, MoreExecutors.directExecutor());
    } 
  }
  
  private void checkAndUpdateState(State oldState, State newState) {
    Preconditions.checkState(
        compareAndUpdateState(oldState, newState), "Expected state to be %s, but it was %s", oldState, newState);
  }
  
  private boolean compareAndUpdateState(State oldState, State newState) { return this.state.compareAndSet(oldState, newState); }
  
  @VisibleForTesting
  CountDownLatch whenClosedCountDown() { return this.closeables.whenClosedCountDown(); }
}
