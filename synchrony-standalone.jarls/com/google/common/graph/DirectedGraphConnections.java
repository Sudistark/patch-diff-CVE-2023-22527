package com.google.common.graph;

import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterators;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
final class DirectedGraphConnections<N, V> extends Object implements GraphConnections<N, V> {
  private static final Object PRED = new Object();
  
  private final Map<N, Object> adjacentNodeValues;
  
  @CheckForNull
  private final List<NodeConnection<N>> orderedNodeConnections;
  
  private int predecessorCount;
  
  private int successorCount;
  
  private DirectedGraphConnections(Map<N, Object> adjacentNodeValues, @CheckForNull List<NodeConnection<N>> orderedNodeConnections, int predecessorCount, int successorCount) {
    this.adjacentNodeValues = (Map)Preconditions.checkNotNull(adjacentNodeValues);
    this.orderedNodeConnections = orderedNodeConnections;
    this.predecessorCount = Graphs.checkNonNegative(predecessorCount);
    this.successorCount = Graphs.checkNonNegative(successorCount);
    Preconditions.checkState((predecessorCount <= adjacentNodeValues
        .size() && successorCount <= adjacentNodeValues
        .size()));
  }
  
  static <N, V> DirectedGraphConnections<N, V> of(ElementOrder<N> incidentEdgeOrder) {
    List<NodeConnection<N>> orderedNodeConnections, orderedNodeConnections;
    int initialCapacity = 4;
    switch (null.$SwitchMap$com$google$common$graph$ElementOrder$Type[incidentEdgeOrder.type().ordinal()]) {
      case 1:
        orderedNodeConnections = null;
        return new DirectedGraphConnections(new HashMap(initialCapacity, 1.0F), orderedNodeConnections, 0, 0);
      case 2:
        orderedNodeConnections = new ArrayList<NodeConnection<N>>();
        return new DirectedGraphConnections(new HashMap(initialCapacity, 1.0F), orderedNodeConnections, 0, 0);
    } 
    throw new AssertionError(incidentEdgeOrder.type());
  }
  
  static <N, V> DirectedGraphConnections<N, V> ofImmutable(N thisNode, Iterable<EndpointPair<N>> incidentEdges, Function<N, V> successorNodeToValueFn) {
    Preconditions.checkNotNull(thisNode);
    Preconditions.checkNotNull(successorNodeToValueFn);
    Map<N, Object> adjacentNodeValues = new HashMap<N, Object>();
    ImmutableList.Builder<NodeConnection<N>> orderedNodeConnectionsBuilder = ImmutableList.builder();
    int predecessorCount = 0;
    int successorCount = 0;
    for (EndpointPair<N> incidentEdge : incidentEdges) {
      if (incidentEdge.nodeU().equals(thisNode) && incidentEdge.nodeV().equals(thisNode)) {
        adjacentNodeValues.put(thisNode, new PredAndSucc(successorNodeToValueFn.apply(thisNode)));
        orderedNodeConnectionsBuilder.add(new NodeConnection.Pred(thisNode));
        orderedNodeConnectionsBuilder.add(new NodeConnection.Succ(thisNode));
        predecessorCount++;
        successorCount++;
        continue;
      } 
      if (incidentEdge.nodeV().equals(thisNode)) {
        N predecessor = (N)incidentEdge.nodeU();
        Object existingValue = adjacentNodeValues.put(predecessor, PRED);
        if (existingValue != null)
          adjacentNodeValues.put(predecessor, new PredAndSucc(existingValue)); 
        orderedNodeConnectionsBuilder.add(new NodeConnection.Pred(predecessor));
        predecessorCount++;
        continue;
      } 
      Preconditions.checkArgument(incidentEdge.nodeU().equals(thisNode));
      N successor = (N)incidentEdge.nodeV();
      V value = (V)successorNodeToValueFn.apply(successor);
      Object existingValue = adjacentNodeValues.put(successor, value);
      if (existingValue != null) {
        Preconditions.checkArgument((existingValue == PRED));
        adjacentNodeValues.put(successor, new PredAndSucc(value));
      } 
      orderedNodeConnectionsBuilder.add(new NodeConnection.Succ(successor));
      successorCount++;
    } 
    return new DirectedGraphConnections(adjacentNodeValues, orderedNodeConnectionsBuilder
        
        .build(), predecessorCount, successorCount);
  }
  
  public Set<N> adjacentNodes() {
    if (this.orderedNodeConnections == null)
      return Collections.unmodifiableSet(this.adjacentNodeValues.keySet()); 
    return new Object(this);
  }
  
  public Set<N> predecessors() { return new Object(this); }
  
  public Set<N> successors() { return new Object(this); }
  
  public Iterator<EndpointPair<N>> incidentEdgeIterator(N thisNode) {
    Iterator<EndpointPair<N>> resultWithDoubleSelfLoop;
    Preconditions.checkNotNull(thisNode);
    if (this.orderedNodeConnections == null) {
      resultWithDoubleSelfLoop = Iterators.concat(
          Iterators.transform(
            predecessors().iterator(), predecessor -> 
            EndpointPair.ordered(predecessor, thisNode)), 
          Iterators.transform(
            successors().iterator(), successor -> 
            EndpointPair.ordered(thisNode, successor)));
    } else {
      resultWithDoubleSelfLoop = Iterators.transform(this.orderedNodeConnections
          .iterator(), connection -> {
            if (connection instanceof NodeConnection.Succ)
              return EndpointPair.ordered(thisNode, connection.node); 
            return EndpointPair.ordered(connection.node, thisNode);
          });
    } 
    AtomicBoolean alreadySeenSelfLoop = new AtomicBoolean(false);
    return new Object(this, resultWithDoubleSelfLoop, alreadySeenSelfLoop);
  }
  
  @CheckForNull
  public V value(N node) {
    Preconditions.checkNotNull(node);
    Object value = this.adjacentNodeValues.get(node);
    if (value == PRED)
      return null; 
    if (value instanceof PredAndSucc)
      return (V)PredAndSucc.access$600((PredAndSucc)value); 
    return (V)value;
  }
  
  public void removePredecessor(N node) {
    boolean removedPredecessor;
    Preconditions.checkNotNull(node);
    Object previousValue = this.adjacentNodeValues.get(node);
    if (previousValue == PRED) {
      this.adjacentNodeValues.remove(node);
      removedPredecessor = true;
    } else if (previousValue instanceof PredAndSucc) {
      this.adjacentNodeValues.put(node, PredAndSucc.access$600((PredAndSucc)previousValue));
      removedPredecessor = true;
    } else {
      removedPredecessor = false;
    } 
    if (removedPredecessor) {
      Graphs.checkNonNegative(--this.predecessorCount);
      if (this.orderedNodeConnections != null)
        this.orderedNodeConnections.remove(new NodeConnection.Pred(node)); 
    } 
  }
  
  @CheckForNull
  public V removeSuccessor(Object node) {
    Object removedValue;
    Preconditions.checkNotNull(node);
    Object previousValue = this.adjacentNodeValues.get(node);
    if (previousValue == null || previousValue == PRED) {
      removedValue = null;
    } else if (previousValue instanceof PredAndSucc) {
      this.adjacentNodeValues.put(node, PRED);
      removedValue = PredAndSucc.access$600((PredAndSucc)previousValue);
    } else {
      this.adjacentNodeValues.remove(node);
      removedValue = previousValue;
    } 
    if (removedValue != null) {
      Graphs.checkNonNegative(--this.successorCount);
      if (this.orderedNodeConnections != null)
        this.orderedNodeConnections.remove(new NodeConnection.Succ(node)); 
    } 
    return (V)((removedValue == null) ? null : removedValue);
  }
  
  public void addPredecessor(N node, V unused) {
    boolean addedPredecessor;
    Object previousValue = this.adjacentNodeValues.put(node, PRED);
    if (previousValue == null) {
      addedPredecessor = true;
    } else if (previousValue instanceof PredAndSucc) {
      this.adjacentNodeValues.put(node, previousValue);
      addedPredecessor = false;
    } else if (previousValue != PRED) {
      this.adjacentNodeValues.put(node, new PredAndSucc(previousValue));
      addedPredecessor = true;
    } else {
      addedPredecessor = false;
    } 
    if (addedPredecessor) {
      Graphs.checkPositive(++this.predecessorCount);
      if (this.orderedNodeConnections != null)
        this.orderedNodeConnections.add(new NodeConnection.Pred(node)); 
    } 
  }
  
  @CheckForNull
  public V addSuccessor(N node, V value) {
    Object previousSuccessor, previousValue = this.adjacentNodeValues.put(node, value);
    if (previousValue == null) {
      previousSuccessor = null;
    } else if (previousValue instanceof PredAndSucc) {
      this.adjacentNodeValues.put(node, new PredAndSucc(value));
      previousSuccessor = PredAndSucc.access$600((PredAndSucc)previousValue);
    } else if (previousValue == PRED) {
      this.adjacentNodeValues.put(node, new PredAndSucc(value));
      previousSuccessor = null;
    } else {
      previousSuccessor = previousValue;
    } 
    if (previousSuccessor == null) {
      Graphs.checkPositive(++this.successorCount);
      if (this.orderedNodeConnections != null)
        this.orderedNodeConnections.add(new NodeConnection.Succ(node)); 
    } 
    return (V)((previousSuccessor == null) ? null : previousSuccessor);
  }
  
  private static boolean isPredecessor(@CheckForNull Object value) { return (value == PRED || value instanceof PredAndSucc); }
  
  private static boolean isSuccessor(@CheckForNull Object value) { return (value != PRED && value != null); }
}
