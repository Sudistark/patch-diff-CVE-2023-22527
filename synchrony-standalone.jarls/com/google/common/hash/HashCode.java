package com.google.common.hash;

import com.google.common.base.Preconditions;
import com.google.common.primitives.Ints;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
public abstract class HashCode {
  public abstract int bits();
  
  public abstract int asInt();
  
  public abstract long asLong();
  
  public abstract long padToLong();
  
  public abstract byte[] asBytes();
  
  @CanIgnoreReturnValue
  public int writeBytesTo(byte[] dest, int offset, int maxLength) {
    maxLength = Ints.min(new int[] { maxLength, bits() / 8 });
    Preconditions.checkPositionIndexes(offset, offset + maxLength, dest.length);
    writeBytesToImpl(dest, offset, maxLength);
    return maxLength;
  }
  
  abstract void writeBytesToImpl(byte[] paramArrayOfByte, int paramInt1, int paramInt2);
  
  byte[] getBytesInternal() { return asBytes(); }
  
  abstract boolean equalsSameBits(HashCode paramHashCode);
  
  public static HashCode fromInt(int hash) { return new IntHashCode(hash); }
  
  public static HashCode fromLong(long hash) { return new LongHashCode(hash); }
  
  public static HashCode fromBytes(byte[] bytes) {
    Preconditions.checkArgument((bytes.length >= 1), "A HashCode must contain at least 1 byte.");
    return fromBytesNoCopy((byte[])bytes.clone());
  }
  
  static HashCode fromBytesNoCopy(byte[] bytes) { return new BytesHashCode(bytes); }
  
  public static HashCode fromString(String string) {
    Preconditions.checkArgument(
        (string.length() >= 2), "input string (%s) must have at least 2 characters", string);
    Preconditions.checkArgument(
        (string.length() % 2 == 0), "input string (%s) must have an even number of characters", string);
    byte[] bytes = new byte[string.length() / 2];
    for (int i = 0; i < string.length(); i += 2) {
      int ch1 = decode(string.charAt(i)) << 4;
      int ch2 = decode(string.charAt(i + 1));
      bytes[i / 2] = (byte)(ch1 + ch2);
    } 
    return fromBytesNoCopy(bytes);
  }
  
  private static int decode(char ch) {
    if (ch >= '0' && ch <= '9')
      return ch - '0'; 
    if (ch >= 'a' && ch <= 'f')
      return ch - 'a' + '\n'; 
    throw new IllegalArgumentException("Illegal hexadecimal character: " + ch);
  }
  
  public final boolean equals(@CheckForNull Object object) {
    if (object instanceof HashCode) {
      HashCode that = (HashCode)object;
      return (bits() == that.bits() && equalsSameBits(that));
    } 
    return false;
  }
  
  public final int hashCode() {
    if (bits() >= 32)
      return asInt(); 
    byte[] bytes = getBytesInternal();
    int val = bytes[0] & 0xFF;
    for (int i = 1; i < bytes.length; i++)
      val |= (bytes[i] & 0xFF) << i * 8; 
    return val;
  }
  
  public final String toString() {
    byte[] bytes = getBytesInternal();
    StringBuilder sb = new StringBuilder(2 * bytes.length);
    for (byte b : bytes)
      sb.append(hexDigits[b >> 4 & 0xF]).append(hexDigits[b & 0xF]); 
    return sb.toString();
  }
  
  private static final char[] hexDigits = "0123456789abcdef".toCharArray();
}
