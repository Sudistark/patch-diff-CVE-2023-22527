package com.google.common.hash;

import com.google.common.annotations.GwtIncompatible;
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.util.Random;
import javax.annotation.CheckForNull;
import sun.misc.Unsafe;

@ElementTypesAreNonnullByDefault
@GwtIncompatible
abstract class Striped64 extends Number {
  static final ThreadLocal<int[]> threadHashCode = new ThreadLocal();
  
  static final Random rng = new Random();
  
  static final int NCPU = Runtime.getRuntime().availableProcessors();
  
  private static final Unsafe UNSAFE;
  
  private static final long baseOffset;
  
  private static final long busyOffset;
  
  final boolean casBase(long cmp, long val) { return UNSAFE.compareAndSwapLong(this, baseOffset, cmp, val); }
  
  final boolean casBusy() { return UNSAFE.compareAndSwapInt(this, busyOffset, 0, 1); }
  
  final void retryUpdate(long x, @CheckForNull int[] hc, boolean wasUncontended) {
    int h;
    if (hc == null) {
      threadHashCode.set(hc = new int[1]);
      int r = rng.nextInt();
      h = hc[0] = (r == 0) ? 1 : r;
    } else {
      h = hc[0];
    } 
    boolean collide = false;
    while (true) {
      Cell[] arrayOfCell;
      int n;
      if ((arrayOfCell = this.cells) != null && (n = arrayOfCell.length) > 0) {
        Cell a;
        if ((a = arrayOfCell[n - true & h]) == null) {
          if (this.busy == 0) {
            Cell r = new Cell(x);
            if (this.busy == 0 && casBusy()) {
              boolean created = false;
              try {
                Cell[] arrayOfCell1;
                int m;
                int j;
                if ((arrayOfCell1 = this.cells) != null && (m = arrayOfCell1.length) > 0 && arrayOfCell1[j = m - true & h] == null) {
                  arrayOfCell1[j] = r;
                  created = true;
                } 
              } finally {
                this.busy = 0;
              } 
              if (created)
                break; 
              continue;
            } 
          } 
          collide = false;
        } else if (!wasUncontended) {
          wasUncontended = true;
        } else {
          long v;
          if (a.cas(v = a.value, fn(v, x)))
            break; 
          if (n >= NCPU || this.cells != arrayOfCell) {
            collide = false;
          } else if (!collide) {
            collide = true;
          } else if (this.busy == 0 && casBusy()) {
            try {
              if (this.cells == arrayOfCell) {
                Cell[] arrayOfCell1 = new Cell[n << 1];
                for (int i = 0; i < n; ) {
                  arrayOfCell1[i] = arrayOfCell[i];
                  i++;
                } 
                this.cells = arrayOfCell1;
              } 
            } finally {
              this.busy = 0;
            } 
            collide = false;
            continue;
          } 
        } 
        h ^= h << 13;
        h ^= h >>> 17;
        h ^= h << 5;
        hc[0] = h;
        continue;
      } 
      if (this.busy == 0 && this.cells == arrayOfCell && casBusy()) {
        boolean init = false;
        try {
          if (this.cells == arrayOfCell) {
            Cell[] arrayOfCell1 = new Cell[2];
            arrayOfCell1[h & true] = new Cell(x);
            this.cells = arrayOfCell1;
            init = true;
          } 
        } finally {
          this.busy = 0;
        } 
        if (init)
          break; 
        continue;
      } 
      long v;
      if (casBase(v = this.base, fn(v, x)))
        break; 
    } 
  }
  
  final void internalReset(long initialValue) {
    Cell[] arrayOfCell = this.cells;
    this.base = initialValue;
    if (arrayOfCell != null) {
      int n = arrayOfCell.length;
      for (int i = 0; i < n; i++) {
        Cell a = arrayOfCell[i];
        if (a != null)
          a.value = initialValue; 
      } 
    } 
  }
  
  static  {
    try {
      UNSAFE = getUnsafe();
      sk = Striped64.class;
      baseOffset = UNSAFE.objectFieldOffset(sk.getDeclaredField("base"));
      busyOffset = UNSAFE.objectFieldOffset(sk.getDeclaredField("busy"));
    } catch (Exception e) {
      throw new Error(e);
    } 
  }
  
  private static Unsafe getUnsafe() {
    try {
      return Unsafe.getUnsafe();
    } catch (SecurityException e) {
      try {
        return (Unsafe)AccessController.doPrivileged(new Object());
      } catch (PrivilegedActionException e) {
        throw new RuntimeException("Could not initialize intrinsics", e.getCause());
      } 
    } 
  }
  
  abstract long fn(long paramLong1, long paramLong2);
}
