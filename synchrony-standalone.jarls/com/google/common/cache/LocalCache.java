package com.google.common.cache;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Equivalence;
import com.google.common.base.Preconditions;
import com.google.common.base.Stopwatch;
import com.google.common.base.Ticker;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Iterators;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.google.common.primitives.Ints;
import com.google.common.util.concurrent.ExecutionError;
import com.google.common.util.concurrent.UncheckedExecutionException;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.concurrent.LazyInit;
import com.google.j2objc.annotations.RetainedWith;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReferenceArray;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.annotation.CheckForNull;

@GwtCompatible(emulated = true)
class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V> {
  static final int MAXIMUM_CAPACITY = 1073741824;
  
  static final int MAX_SEGMENTS = 65536;
  
  static final int CONTAINS_VALUE_RETRIES = 3;
  
  static final int DRAIN_THRESHOLD = 63;
  
  static final int DRAIN_MAX = 16;
  
  static final Logger logger = Logger.getLogger(LocalCache.class.getName());
  
  final int segmentMask;
  
  final int segmentShift;
  
  final Segment<K, V>[] segments;
  
  final int concurrencyLevel;
  
  final Equivalence<Object> keyEquivalence;
  
  final Equivalence<Object> valueEquivalence;
  
  final Strength keyStrength;
  
  final Strength valueStrength;
  
  final long maxWeight;
  
  final Weigher<K, V> weigher;
  
  final long expireAfterAccessNanos;
  
  final long expireAfterWriteNanos;
  
  final long refreshNanos;
  
  final Queue<RemovalNotification<K, V>> removalNotificationQueue;
  
  final RemovalListener<K, V> removalListener;
  
  final Ticker ticker;
  
  final EntryFactory entryFactory;
  
  final AbstractCache.StatsCounter globalStatsCounter;
  
  @CheckForNull
  final CacheLoader<? super K, V> defaultLoader;
  
  LocalCache(CacheBuilder<? super K, ? super V> builder, @CheckForNull CacheLoader<? super K, V> loader) {
    this.concurrencyLevel = Math.min(builder.getConcurrencyLevel(), 65536);
    this.keyStrength = builder.getKeyStrength();
    this.valueStrength = builder.getValueStrength();
    this.keyEquivalence = builder.getKeyEquivalence();
    this.valueEquivalence = builder.getValueEquivalence();
    this.maxWeight = builder.getMaximumWeight();
    this.weigher = builder.getWeigher();
    this.expireAfterAccessNanos = builder.getExpireAfterAccessNanos();
    this.expireAfterWriteNanos = builder.getExpireAfterWriteNanos();
    this.refreshNanos = builder.getRefreshNanos();
    this.removalListener = builder.getRemovalListener();
    this

      
      .removalNotificationQueue = (this.removalListener == CacheBuilder.NullListener.INSTANCE) ? discardingQueue() : new ConcurrentLinkedQueue();
    this.ticker = builder.getTicker(recordsTime());
    this.entryFactory = EntryFactory.getFactory(this.keyStrength, usesAccessEntries(), usesWriteEntries());
    this.globalStatsCounter = (AbstractCache.StatsCounter)builder.getStatsCounterSupplier().get();
    this.defaultLoader = loader;
    int initialCapacity = Math.min(builder.getInitialCapacity(), 1073741824);
    if (evictsBySize() && !customWeigher())
      initialCapacity = (int)Math.min(initialCapacity, this.maxWeight); 
    int segmentShift = 0;
    int segmentCount = 1;
    while (segmentCount < this.concurrencyLevel && (
      !evictsBySize() || segmentCount * 20L <= this.maxWeight)) {
      segmentShift++;
      segmentCount <<= 1;
    } 
    this.segmentShift = 32 - segmentShift;
    this.segmentMask = segmentCount - 1;
    this.segments = newSegmentArray(segmentCount);
    int segmentCapacity = initialCapacity / segmentCount;
    if (segmentCapacity * segmentCount < initialCapacity)
      segmentCapacity++; 
    int segmentSize = 1;
    while (segmentSize < segmentCapacity)
      segmentSize <<= 1; 
    if (evictsBySize()) {
      long maxSegmentWeight = this.maxWeight / segmentCount + 1L;
      long remainder = this.maxWeight % segmentCount;
      for (int i = 0; i < this.segments.length; i++) {
        if (i == remainder)
          maxSegmentWeight--; 
        this.segments[i] = 
          createSegment(segmentSize, maxSegmentWeight, (AbstractCache.StatsCounter)builder.getStatsCounterSupplier().get());
      } 
    } else {
      for (int i = 0; i < this.segments.length; i++)
        this.segments[i] = 
          createSegment(segmentSize, -1L, (AbstractCache.StatsCounter)builder.getStatsCounterSupplier().get()); 
    } 
  }
  
  boolean evictsBySize() { return (this.maxWeight >= 0L); }
  
  boolean customWeigher() { return (this.weigher != CacheBuilder.OneWeigher.INSTANCE); }
  
  boolean expires() { return (expiresAfterWrite() || expiresAfterAccess()); }
  
  boolean expiresAfterWrite() { return (this.expireAfterWriteNanos > 0L); }
  
  boolean expiresAfterAccess() { return (this.expireAfterAccessNanos > 0L); }
  
  boolean refreshes() { return (this.refreshNanos > 0L); }
  
  boolean usesAccessQueue() { return (expiresAfterAccess() || evictsBySize()); }
  
  boolean usesWriteQueue() { return expiresAfterWrite(); }
  
  boolean recordsWrite() { return (expiresAfterWrite() || refreshes()); }
  
  boolean recordsAccess() { return expiresAfterAccess(); }
  
  boolean recordsTime() { return (recordsWrite() || recordsAccess()); }
  
  boolean usesWriteEntries() { return (usesWriteQueue() || recordsWrite()); }
  
  boolean usesAccessEntries() { return (usesAccessQueue() || recordsAccess()); }
  
  boolean usesKeyReferences() { return (this.keyStrength != Strength.STRONG); }
  
  boolean usesValueReferences() { return (this.valueStrength != Strength.STRONG); }
  
  static final ValueReference<Object, Object> UNSET = new Object();
  
  static <K, V> ValueReference<K, V> unset() { return UNSET; }
  
  static <K, V> ReferenceEntry<K, V> nullEntry() { return NullEntry.INSTANCE; }
  
  static final Queue<?> DISCARDING_QUEUE = new Object();
  
  @LazyInit
  @CheckForNull
  @RetainedWith
  Set<K> keySet;
  
  @LazyInit
  @CheckForNull
  @RetainedWith
  Collection<V> values;
  
  @LazyInit
  @CheckForNull
  @RetainedWith
  Set<Map.Entry<K, V>> entrySet;
  
  static <E> Queue<E> discardingQueue() { return DISCARDING_QUEUE; }
  
  static int rehash(int h) {
    h += (h << 15 ^ 0xFFFFCD7D);
    h ^= h >>> 10;
    h += (h << 3);
    h ^= h >>> 6;
    h += (h << 2) + (h << 14);
    return h ^ h >>> 16;
  }
  
  @VisibleForTesting
  ReferenceEntry<K, V> newEntry(K key, int hash, @CheckForNull ReferenceEntry<K, V> next) {
    segment = segmentFor(hash);
    segment.lock();
    try {
      return segment.newEntry(key, hash, next);
    } finally {
      segment.unlock();
    } 
  }
  
  @VisibleForTesting
  ReferenceEntry<K, V> copyEntry(ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
    int hash = original.getHash();
    return segmentFor(hash).copyEntry(original, newNext);
  }
  
  @VisibleForTesting
  ValueReference<K, V> newValueReference(ReferenceEntry<K, V> entry, V value, int weight) {
    int hash = entry.getHash();
    return this.valueStrength.referenceValue(segmentFor(hash), entry, Preconditions.checkNotNull(value), weight);
  }
  
  int hash(@CheckForNull Object key) {
    int h = this.keyEquivalence.hash(key);
    return rehash(h);
  }
  
  void reclaimValue(ValueReference<K, V> valueReference) {
    ReferenceEntry<K, V> entry = valueReference.getEntry();
    int hash = entry.getHash();
    segmentFor(hash).reclaimValue(entry.getKey(), hash, valueReference);
  }
  
  void reclaimKey(ReferenceEntry<K, V> entry) {
    int hash = entry.getHash();
    segmentFor(hash).reclaimKey(entry, hash);
  }
  
  @VisibleForTesting
  boolean isLive(ReferenceEntry<K, V> entry, long now) { return (segmentFor(entry.getHash()).getLiveValue(entry, now) != null); }
  
  Segment<K, V> segmentFor(int hash) { return this.segments[hash >>> this.segmentShift & this.segmentMask]; }
  
  Segment<K, V> createSegment(int initialCapacity, long maxSegmentWeight, AbstractCache.StatsCounter statsCounter) { return new Segment(this, initialCapacity, maxSegmentWeight, statsCounter); }
  
  @CheckForNull
  V getLiveValue(ReferenceEntry<K, V> entry, long now) {
    if (entry.getKey() == null)
      return null; 
    V value = (V)entry.getValueReference().get();
    if (value == null)
      return null; 
    if (isExpired(entry, now))
      return null; 
    return value;
  }
  
  boolean isExpired(ReferenceEntry<K, V> entry, long now) {
    Preconditions.checkNotNull(entry);
    if (expiresAfterAccess() && now - entry.getAccessTime() >= this.expireAfterAccessNanos)
      return true; 
    if (expiresAfterWrite() && now - entry.getWriteTime() >= this.expireAfterWriteNanos)
      return true; 
    return false;
  }
  
  static <K, V> void connectAccessOrder(ReferenceEntry<K, V> previous, ReferenceEntry<K, V> next) {
    previous.setNextInAccessQueue(next);
    next.setPreviousInAccessQueue(previous);
  }
  
  static <K, V> void nullifyAccessOrder(ReferenceEntry<K, V> nulled) {
    ReferenceEntry<K, V> nullEntry = nullEntry();
    nulled.setNextInAccessQueue(nullEntry);
    nulled.setPreviousInAccessQueue(nullEntry);
  }
  
  static <K, V> void connectWriteOrder(ReferenceEntry<K, V> previous, ReferenceEntry<K, V> next) {
    previous.setNextInWriteQueue(next);
    next.setPreviousInWriteQueue(previous);
  }
  
  static <K, V> void nullifyWriteOrder(ReferenceEntry<K, V> nulled) {
    ReferenceEntry<K, V> nullEntry = nullEntry();
    nulled.setNextInWriteQueue(nullEntry);
    nulled.setPreviousInWriteQueue(nullEntry);
  }
  
  void processPendingNotifications() {
    RemovalNotification<K, V> notification;
    while ((notification = (RemovalNotification)this.removalNotificationQueue.poll()) != null) {
      try {
        this.removalListener.onRemoval(notification);
      } catch (Throwable e) {
        logger.log(Level.WARNING, "Exception thrown by removal listener", e);
      } 
    } 
  }
  
  final Segment<K, V>[] newSegmentArray(int ssize) { return new Segment[ssize]; }
  
  public void cleanUp() {
    for (Segment<?, ?> segment : this.segments)
      segment.cleanUp(); 
  }
  
  public boolean isEmpty() {
    long sum = 0L;
    Segment[] arrayOfSegment = this.segments;
    for (Segment<K, V> segment : arrayOfSegment) {
      if (segment.count != 0)
        return false; 
      sum += segment.modCount;
    } 
    if (sum != 0L) {
      for (Segment<K, V> segment : arrayOfSegment) {
        if (segment.count != 0)
          return false; 
        sum -= segment.modCount;
      } 
      return (sum == 0L);
    } 
    return true;
  }
  
  long longSize() {
    Segment[] arrayOfSegment = this.segments;
    long sum = 0L;
    for (Segment<K, V> segment : arrayOfSegment)
      sum += segment.count; 
    return sum;
  }
  
  public int size() { return Ints.saturatedCast(longSize()); }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V get(@CheckForNull Object key) {
    if (key == null)
      return null; 
    int hash = hash(key);
    return (V)segmentFor(hash).get(key, hash);
  }
  
  @CanIgnoreReturnValue
  V get(K key, CacheLoader<? super K, V> loader) throws ExecutionException {
    int hash = hash(Preconditions.checkNotNull(key));
    return (V)segmentFor(hash).get(key, hash, loader);
  }
  
  @CheckForNull
  public V getIfPresent(Object key) {
    int hash = hash(Preconditions.checkNotNull(key));
    V value = (V)segmentFor(hash).get(key, hash);
    if (value == null) {
      this.globalStatsCounter.recordMisses(1);
    } else {
      this.globalStatsCounter.recordHits(1);
    } 
    return value;
  }
  
  @CheckForNull
  public V getOrDefault(@CheckForNull Object key, @CheckForNull V defaultValue) {
    V result = (V)get(key);
    return (result != null) ? result : defaultValue;
  }
  
  V getOrLoad(K key) throws ExecutionException { return (V)get(key, this.defaultLoader); }
  
  ImmutableMap<K, V> getAllPresent(Iterable<?> keys) {
    int hits = 0;
    int misses = 0;
    ImmutableMap.Builder<K, V> result = ImmutableMap.builder();
    for (Object key : keys) {
      V value = (V)get(key);
      if (value == null) {
        misses++;
        continue;
      } 
      K castKey = (K)key;
      result.put(castKey, value);
      hits++;
    } 
    this.globalStatsCounter.recordHits(hits);
    this.globalStatsCounter.recordMisses(misses);
    return result.buildKeepingLast();
  }
  
  ImmutableMap<K, V> getAll(Iterable<? extends K> keys) throws ExecutionException {
    hits = 0;
    misses = 0;
    Map<K, V> result = Maps.newLinkedHashMap();
    Set<K> keysToLoad = Sets.newLinkedHashSet();
    for (K key : keys) {
      V value = (V)get(key);
      if (!result.containsKey(key)) {
        result.put(key, value);
        if (value == null) {
          misses++;
          keysToLoad.add(key);
          continue;
        } 
        hits++;
      } 
    } 
    try {
      if (!keysToLoad.isEmpty())
        try {
          Map<K, V> newEntries = loadAll(Collections.unmodifiableSet(keysToLoad), this.defaultLoader);
          for (K key : keysToLoad) {
            V value = (V)newEntries.get(key);
            if (value == null)
              throw new CacheLoader.InvalidCacheLoadException("loadAll failed to return a value for " + key); 
            result.put(key, value);
          } 
        } catch (UnsupportedLoadingOperationException e) {
          for (K key : keysToLoad) {
            misses--;
            result.put(key, get(key, this.defaultLoader));
          } 
        }  
      return ImmutableMap.copyOf(result);
    } finally {
      this.globalStatsCounter.recordHits(hits);
      this.globalStatsCounter.recordMisses(misses);
    } 
  }
  
  @CheckForNull
  Map<K, V> loadAll(Set<? extends K> keys, CacheLoader<? super K, V> loader) throws ExecutionException {
    Map<K, V> result;
    Preconditions.checkNotNull(loader);
    Preconditions.checkNotNull(keys);
    stopwatch = Stopwatch.createStarted();
    success = false;
    try {
      Map<K, V> map = loader.loadAll(keys);
      result = map;
      success = true;
    } catch (UnsupportedLoadingOperationException e) {
      success = true;
      throw e;
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ExecutionException(e);
    } catch (RuntimeException e) {
      throw new UncheckedExecutionException(e);
    } catch (Exception e) {
      throw new ExecutionException(e);
    } catch (Error e) {
      throw new ExecutionError(e);
    } finally {
      if (!success)
        this.globalStatsCounter.recordLoadException(stopwatch.elapsed(TimeUnit.NANOSECONDS)); 
    } 
    if (result == null) {
      this.globalStatsCounter.recordLoadException(stopwatch.elapsed(TimeUnit.NANOSECONDS));
      throw new CacheLoader.InvalidCacheLoadException(loader + " returned null map from loadAll");
    } 
    stopwatch.stop();
    boolean nullsPresent = false;
    for (Map.Entry<K, V> entry : result.entrySet()) {
      K key = (K)entry.getKey();
      V value = (V)entry.getValue();
      if (key == null || value == null) {
        nullsPresent = true;
        continue;
      } 
      put(key, value);
    } 
    if (nullsPresent) {
      this.globalStatsCounter.recordLoadException(stopwatch.elapsed(TimeUnit.NANOSECONDS));
      throw new CacheLoader.InvalidCacheLoadException(loader + " returned null keys or values from loadAll");
    } 
    this.globalStatsCounter.recordLoadSuccess(stopwatch.elapsed(TimeUnit.NANOSECONDS));
    return result;
  }
  
  @CheckForNull
  ReferenceEntry<K, V> getEntry(@CheckForNull Object key) {
    if (key == null)
      return null; 
    int hash = hash(key);
    return segmentFor(hash).getEntry(key, hash);
  }
  
  void refresh(K key) {
    int hash = hash(Preconditions.checkNotNull(key));
    segmentFor(hash).refresh(key, hash, this.defaultLoader, false);
  }
  
  public boolean containsKey(@CheckForNull Object key) {
    if (key == null)
      return false; 
    int hash = hash(key);
    return segmentFor(hash).containsKey(key, hash);
  }
  
  public boolean containsValue(@CheckForNull Object value) {
    if (value == null)
      return false; 
    long now = this.ticker.read();
    Segment[] arrayOfSegment = this.segments;
    long last = -1L;
    for (int i = 0; i < 3; i++) {
      long sum = 0L;
      for (Segment<K, V> segment : arrayOfSegment) {
        int unused = segment.count;
        AtomicReferenceArray<ReferenceEntry<K, V>> table = segment.table;
        for (int j = 0; j < table.length(); j++) {
          for (ReferenceEntry<K, V> e = (ReferenceEntry)table.get(j); e != null; e = e.getNext()) {
            V v = (V)segment.getLiveValue(e, now);
            if (v != null && this.valueEquivalence.equivalent(value, v))
              return true; 
          } 
        } 
        sum += segment.modCount;
      } 
      if (sum == last)
        break; 
      last = sum;
    } 
    return false;
  }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V put(K key, V value) {
    Preconditions.checkNotNull(key);
    Preconditions.checkNotNull(value);
    int hash = hash(key);
    return (V)segmentFor(hash).put(key, hash, value, false);
  }
  
  @CheckForNull
  public V putIfAbsent(K key, V value) {
    Preconditions.checkNotNull(key);
    Preconditions.checkNotNull(value);
    int hash = hash(key);
    return (V)segmentFor(hash).put(key, hash, value, true);
  }
  
  @CheckForNull
  public V compute(K key, BiFunction<? super K, ? super V, ? extends V> function) {
    Preconditions.checkNotNull(key);
    Preconditions.checkNotNull(function);
    int hash = hash(key);
    return (V)segmentFor(hash).compute(key, hash, function);
  }
  
  public V computeIfAbsent(K key, Function<? super K, ? extends V> function) {
    Preconditions.checkNotNull(key);
    Preconditions.checkNotNull(function);
    return (V)compute(key, (k, oldValue) -> (oldValue == null) ? function.apply(key) : oldValue);
  }
  
  @CheckForNull
  public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> function) {
    Preconditions.checkNotNull(key);
    Preconditions.checkNotNull(function);
    return (V)compute(key, (k, oldValue) -> (oldValue == null) ? null : function.apply(k, oldValue));
  }
  
  @CheckForNull
  public V merge(K key, V newValue, BiFunction<? super V, ? super V, ? extends V> function) {
    Preconditions.checkNotNull(key);
    Preconditions.checkNotNull(newValue);
    Preconditions.checkNotNull(function);
    return (V)compute(key, (k, oldValue) -> 
        (oldValue == null) ? newValue : function.apply(oldValue, newValue));
  }
  
  public void putAll(Map<? extends K, ? extends V> m) {
    for (Map.Entry<? extends K, ? extends V> e : m.entrySet())
      put(e.getKey(), e.getValue()); 
  }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V remove(@CheckForNull Object key) {
    if (key == null)
      return null; 
    int hash = hash(key);
    return (V)segmentFor(hash).remove(key, hash);
  }
  
  @CanIgnoreReturnValue
  public boolean remove(@CheckForNull Object key, @CheckForNull Object value) {
    if (key == null || value == null)
      return false; 
    int hash = hash(key);
    return segmentFor(hash).remove(key, hash, value);
  }
  
  @CanIgnoreReturnValue
  public boolean replace(K key, @CheckForNull V oldValue, V newValue) {
    Preconditions.checkNotNull(key);
    Preconditions.checkNotNull(newValue);
    if (oldValue == null)
      return false; 
    int hash = hash(key);
    return segmentFor(hash).replace(key, hash, oldValue, newValue);
  }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V replace(K key, V value) {
    Preconditions.checkNotNull(key);
    Preconditions.checkNotNull(value);
    int hash = hash(key);
    return (V)segmentFor(hash).replace(key, hash, value);
  }
  
  public void clear() {
    for (Segment<K, V> segment : this.segments)
      segment.clear(); 
  }
  
  void invalidateAll(Iterable<?> keys) {
    for (Object key : keys)
      remove(key); 
  }
  
  public Set<K> keySet() {
    Set<K> ks = this.keySet;
    return (ks != null) ? ks : (this.keySet = new KeySet(this));
  }
  
  public Collection<V> values() {
    Collection<V> vs = this.values;
    return (vs != null) ? vs : (this.values = new Values(this));
  }
  
  @GwtIncompatible
  public Set<Map.Entry<K, V>> entrySet() {
    Set<Map.Entry<K, V>> es = this.entrySet;
    return (es != null) ? es : (this.entrySet = new EntrySet(this));
  }
  
  private static <E> ArrayList<E> toArrayList(Collection<E> c) {
    ArrayList<E> result = new ArrayList<E>(c.size());
    Iterators.addAll(result, c.iterator());
    return result;
  }
  
  boolean removeIf(BiPredicate<? super K, ? super V> filter) {
    Preconditions.checkNotNull(filter);
    boolean changed = false;
    label17: for (K key : keySet()) {
      while (true) {
        V value = (V)get(key);
        if (value != null) {
          if (!filter.test(key, value))
            continue label17; 
          if (remove(key, value))
            break; 
          continue;
        } 
        continue label17;
      } 
      changed = true;
    } 
    return changed;
  }
}
