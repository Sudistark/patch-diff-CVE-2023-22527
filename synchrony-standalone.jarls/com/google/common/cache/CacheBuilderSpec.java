package com.google.common.cache;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.MoreObjects;
import com.google.common.base.Objects;
import com.google.common.base.Preconditions;
import com.google.common.base.Splitter;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import java.util.Locale;
import java.util.concurrent.TimeUnit;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtIncompatible
public final class CacheBuilderSpec {
  private static final Splitter KEYS_SPLITTER = Splitter.on(',').trimResults();
  
  private static final Splitter KEY_VALUE_SPLITTER = Splitter.on('=').trimResults();
  
  private static final ImmutableMap<String, ValueParser> VALUE_PARSERS = ImmutableMap.builder()
    .put("initialCapacity", new InitialCapacityParser())
    .put("maximumSize", new MaximumSizeParser())
    .put("maximumWeight", new MaximumWeightParser())
    .put("concurrencyLevel", new ConcurrencyLevelParser())
    .put("weakKeys", new KeyStrengthParser(LocalCache.Strength.WEAK))
    .put("softValues", new ValueStrengthParser(LocalCache.Strength.SOFT))
    .put("weakValues", new ValueStrengthParser(LocalCache.Strength.WEAK))
    .put("recordStats", new RecordStatsParser())
    .put("expireAfterAccess", new AccessDurationParser())
    .put("expireAfterWrite", new WriteDurationParser())
    .put("refreshAfterWrite", new RefreshDurationParser())
    .put("refreshInterval", new RefreshDurationParser())
    .buildOrThrow();
  
  @CheckForNull
  @VisibleForTesting
  Integer initialCapacity;
  
  @CheckForNull
  @VisibleForTesting
  Long maximumSize;
  
  @CheckForNull
  @VisibleForTesting
  Long maximumWeight;
  
  @CheckForNull
  @VisibleForTesting
  Integer concurrencyLevel;
  
  @CheckForNull
  @VisibleForTesting
  LocalCache.Strength keyStrength;
  
  @CheckForNull
  @VisibleForTesting
  LocalCache.Strength valueStrength;
  
  @CheckForNull
  @VisibleForTesting
  Boolean recordStats;
  
  @VisibleForTesting
  long writeExpirationDuration;
  
  @CheckForNull
  @VisibleForTesting
  TimeUnit writeExpirationTimeUnit;
  
  @VisibleForTesting
  long accessExpirationDuration;
  
  @CheckForNull
  @VisibleForTesting
  TimeUnit accessExpirationTimeUnit;
  
  @VisibleForTesting
  long refreshDuration;
  
  @CheckForNull
  @VisibleForTesting
  TimeUnit refreshTimeUnit;
  
  private final String specification;
  
  private CacheBuilderSpec(String specification) { this.specification = specification; }
  
  public static CacheBuilderSpec parse(String cacheBuilderSpecification) {
    CacheBuilderSpec spec = new CacheBuilderSpec(cacheBuilderSpecification);
    if (!cacheBuilderSpecification.isEmpty())
      for (String keyValuePair : KEYS_SPLITTER.split(cacheBuilderSpecification)) {
        ImmutableList immutableList = ImmutableList.copyOf(KEY_VALUE_SPLITTER.split(keyValuePair));
        Preconditions.checkArgument(!immutableList.isEmpty(), "blank key-value pair");
        Preconditions.checkArgument(
            (immutableList.size() <= 2), "key-value pair %s with more than one equals sign", keyValuePair);
        String key = (String)immutableList.get(0);
        ValueParser valueParser = (ValueParser)VALUE_PARSERS.get(key);
        Preconditions.checkArgument((valueParser != null), "unknown key %s", key);
        String value = (immutableList.size() == 1) ? null : (String)immutableList.get(1);
        valueParser.parse(spec, key, value);
      }  
    return spec;
  }
  
  public static CacheBuilderSpec disableCaching() { return parse("maximumSize=0"); }
  
  CacheBuilder<Object, Object> toCacheBuilder() {
    CacheBuilder<Object, Object> builder = CacheBuilder.newBuilder();
    if (this.initialCapacity != null)
      builder.initialCapacity(this.initialCapacity.intValue()); 
    if (this.maximumSize != null)
      builder.maximumSize(this.maximumSize.longValue()); 
    if (this.maximumWeight != null)
      builder.maximumWeight(this.maximumWeight.longValue()); 
    if (this.concurrencyLevel != null)
      builder.concurrencyLevel(this.concurrencyLevel.intValue()); 
    if (this.keyStrength != null)
      switch (null.$SwitchMap$com$google$common$cache$LocalCache$Strength[this.keyStrength.ordinal()]) {
        case 1:
          builder.weakKeys();
          break;
        default:
          throw new AssertionError();
      }  
    if (this.valueStrength != null)
      switch (null.$SwitchMap$com$google$common$cache$LocalCache$Strength[this.valueStrength.ordinal()]) {
        case 2:
          builder.softValues();
          break;
        case 1:
          builder.weakValues();
          break;
        default:
          throw new AssertionError();
      }  
    if (this.recordStats != null && this.recordStats.booleanValue())
      builder.recordStats(); 
    if (this.writeExpirationTimeUnit != null)
      builder.expireAfterWrite(this.writeExpirationDuration, this.writeExpirationTimeUnit); 
    if (this.accessExpirationTimeUnit != null)
      builder.expireAfterAccess(this.accessExpirationDuration, this.accessExpirationTimeUnit); 
    if (this.refreshTimeUnit != null)
      builder.refreshAfterWrite(this.refreshDuration, this.refreshTimeUnit); 
    return builder;
  }
  
  public String toParsableString() { return this.specification; }
  
  public String toString() { return MoreObjects.toStringHelper(this).addValue(toParsableString()).toString(); }
  
  public int hashCode() {
    return Objects.hashCode(new Object[] { this.initialCapacity, this.maximumSize, this.maximumWeight, this.concurrencyLevel, this.keyStrength, this.valueStrength, this.recordStats, 






          
          durationInNanos(this.writeExpirationDuration, this.writeExpirationTimeUnit), 
          durationInNanos(this.accessExpirationDuration, this.accessExpirationTimeUnit), 
          durationInNanos(this.refreshDuration, this.refreshTimeUnit) });
  }
  
  public boolean equals(@CheckForNull Object obj) {
    if (this == obj)
      return true; 
    if (!(obj instanceof CacheBuilderSpec))
      return false; 
    CacheBuilderSpec that = (CacheBuilderSpec)obj;
    return (Objects.equal(this.initialCapacity, that.initialCapacity) && 
      Objects.equal(this.maximumSize, that.maximumSize) && 
      Objects.equal(this.maximumWeight, that.maximumWeight) && 
      Objects.equal(this.concurrencyLevel, that.concurrencyLevel) && 
      Objects.equal(this.keyStrength, that.keyStrength) && 
      Objects.equal(this.valueStrength, that.valueStrength) && 
      Objects.equal(this.recordStats, that.recordStats) && 
      Objects.equal(
        durationInNanos(this.writeExpirationDuration, this.writeExpirationTimeUnit), 
        durationInNanos(that.writeExpirationDuration, that.writeExpirationTimeUnit)) && 
      Objects.equal(
        durationInNanos(this.accessExpirationDuration, this.accessExpirationTimeUnit), 
        durationInNanos(that.accessExpirationDuration, that.accessExpirationTimeUnit)) && 
      Objects.equal(
        durationInNanos(this.refreshDuration, this.refreshTimeUnit), 
        durationInNanos(that.refreshDuration, that.refreshTimeUnit)));
  }
  
  @CheckForNull
  private static Long durationInNanos(long duration, @CheckForNull TimeUnit unit) { return (unit == null) ? null : Long.valueOf(unit.toNanos(duration)); }
  
  private static String format(String format, Object... args) { return String.format(Locale.ROOT, format, args); }
}
