package com.google.common.reflect;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.UnmodifiableIterator;
import com.google.common.primitives.Primitives;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.concurrent.LazyInit;
import java.io.Serializable;
import java.lang.reflect.Constructor;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
public abstract class TypeToken<T> extends TypeCapture<T> implements Serializable {
  private final Type runtimeType;
  
  @LazyInit
  @CheckForNull
  private TypeResolver invariantTypeResolver;
  
  @LazyInit
  @CheckForNull
  private TypeResolver covariantTypeResolver;
  
  private static final long serialVersionUID = 3637540370352322684L;
  
  protected TypeToken() {
    this.runtimeType = capture();
    Preconditions.checkState(!(this.runtimeType instanceof TypeVariable), "Cannot construct a TypeToken for a type variable.\nYou probably meant to call new TypeToken<%s>(getClass()) that can resolve the type variable for you.\nIf you do need to create a TypeToken of a type variable, please use TypeToken.of() instead.", this.runtimeType);
  }
  
  protected TypeToken(Class<?> declaringClass) {
    Type captured = capture();
    if (captured instanceof Class) {
      this.runtimeType = captured;
    } else {
      this.runtimeType = TypeResolver.covariantly(declaringClass).resolveType(captured);
    } 
  }
  
  private TypeToken(Type type) { this.runtimeType = (Type)Preconditions.checkNotNull(type); }
  
  public static <T> TypeToken<T> of(Class<T> type) { return new SimpleTypeToken(type); }
  
  public static TypeToken<?> of(Type type) { return new SimpleTypeToken(type); }
  
  public final Class<? super T> getRawType() {
    Class<?> rawType = (Class)getRawTypes().iterator().next();
    return rawType;
  }
  
  public final Type getType() { return this.runtimeType; }
  
  public final <X> TypeToken<T> where(TypeParameter<X> typeParam, TypeToken<X> typeArg) {
    TypeResolver resolver = (new TypeResolver()).where(
        ImmutableMap.of(new TypeResolver.TypeVariableKey(typeParam.typeVariable), typeArg.runtimeType));
    return new SimpleTypeToken(resolver.resolveType(this.runtimeType));
  }
  
  public final <X> TypeToken<T> where(TypeParameter<X> typeParam, Class<X> typeArg) { return where(typeParam, of(typeArg)); }
  
  public final TypeToken<?> resolveType(Type type) {
    Preconditions.checkNotNull(type);
    return of(getInvariantTypeResolver().resolveType(type));
  }
  
  private TypeToken<?> resolveSupertype(Type type) {
    TypeToken<?> supertype = of(getCovariantTypeResolver().resolveType(type));
    supertype.covariantTypeResolver = this.covariantTypeResolver;
    supertype.invariantTypeResolver = this.invariantTypeResolver;
    return supertype;
  }
  
  @CheckForNull
  final TypeToken<? super T> getGenericSuperclass() {
    if (this.runtimeType instanceof TypeVariable)
      return boundAsSuperclass(((TypeVariable)this.runtimeType).getBounds()[0]); 
    if (this.runtimeType instanceof WildcardType)
      return boundAsSuperclass(((WildcardType)this.runtimeType).getUpperBounds()[0]); 
    Type superclass = getRawType().getGenericSuperclass();
    if (superclass == null)
      return null; 
    return resolveSupertype(superclass);
  }
  
  @CheckForNull
  private TypeToken<? super T> boundAsSuperclass(Type bound) {
    TypeToken<?> token = of(bound);
    if (token.getRawType().isInterface())
      return null; 
    return token;
  }
  
  final ImmutableList<TypeToken<? super T>> getGenericInterfaces() {
    if (this.runtimeType instanceof TypeVariable)
      return boundsAsInterfaces(((TypeVariable)this.runtimeType).getBounds()); 
    if (this.runtimeType instanceof WildcardType)
      return boundsAsInterfaces(((WildcardType)this.runtimeType).getUpperBounds()); 
    ImmutableList.Builder<TypeToken<? super T>> builder = ImmutableList.builder();
    for (Type interfaceType : getRawType().getGenericInterfaces()) {
      TypeToken<? super T> resolvedInterface = resolveSupertype(interfaceType);
      builder.add(resolvedInterface);
    } 
    return builder.build();
  }
  
  private ImmutableList<TypeToken<? super T>> boundsAsInterfaces(Type[] bounds) {
    ImmutableList.Builder<TypeToken<? super T>> builder = ImmutableList.builder();
    for (Type bound : bounds) {
      TypeToken<? super T> boundType = of(bound);
      if (boundType.getRawType().isInterface())
        builder.add(boundType); 
    } 
    return builder.build();
  }
  
  public final TypeSet getTypes() { return new TypeSet(this); }
  
  public final TypeToken<? super T> getSupertype(Class<? super T> superclass) {
    Preconditions.checkArgument(
        someRawTypeIsSubclassOf(superclass), "%s is not a super class of %s", superclass, this);
    if (this.runtimeType instanceof TypeVariable)
      return getSupertypeFromUpperBounds(superclass, ((TypeVariable)this.runtimeType).getBounds()); 
    if (this.runtimeType instanceof WildcardType)
      return getSupertypeFromUpperBounds(superclass, ((WildcardType)this.runtimeType).getUpperBounds()); 
    if (superclass.isArray())
      return getArraySupertype(superclass); 
    return resolveSupertype((toGenericType(superclass)).runtimeType);
  }
  
  public final TypeToken<? extends T> getSubtype(Class<?> subclass) {
    Preconditions.checkArgument(!(this.runtimeType instanceof TypeVariable), "Cannot get subtype of type variable <%s>", this);
    if (this.runtimeType instanceof WildcardType)
      return getSubtypeFromLowerBounds(subclass, ((WildcardType)this.runtimeType).getLowerBounds()); 
    if (isArray())
      return getArraySubtype(subclass); 
    Preconditions.checkArgument(
        getRawType().isAssignableFrom(subclass), "%s isn't a subclass of %s", subclass, this);
    Type resolvedTypeArgs = resolveTypeArgsForSubclass(subclass);
    TypeToken<? extends T> subtype = of(resolvedTypeArgs);
    Preconditions.checkArgument(subtype
        .isSubtypeOf(this), "%s does not appear to be a subtype of %s", subtype, this);
    return subtype;
  }
  
  public final boolean isSupertypeOf(TypeToken<?> type) { return type.isSubtypeOf(getType()); }
  
  public final boolean isSupertypeOf(Type type) { return of(type).isSubtypeOf(getType()); }
  
  public final boolean isSubtypeOf(TypeToken<?> type) { return isSubtypeOf(type.getType()); }
  
  public final boolean isSubtypeOf(Type supertype) {
    Preconditions.checkNotNull(supertype);
    if (supertype instanceof WildcardType)
      return any(((WildcardType)supertype).getLowerBounds()).isSupertypeOf(this.runtimeType); 
    if (this.runtimeType instanceof WildcardType)
      return any(((WildcardType)this.runtimeType).getUpperBounds()).isSubtypeOf(supertype); 
    if (this.runtimeType instanceof TypeVariable)
      return (this.runtimeType.equals(supertype) || 
        any(((TypeVariable)this.runtimeType).getBounds()).isSubtypeOf(supertype)); 
    if (this.runtimeType instanceof GenericArrayType)
      return of(supertype).isSupertypeOfArray((GenericArrayType)this.runtimeType); 
    if (supertype instanceof Class)
      return someRawTypeIsSubclassOf((Class)supertype); 
    if (supertype instanceof ParameterizedType)
      return isSubtypeOfParameterizedType((ParameterizedType)supertype); 
    if (supertype instanceof GenericArrayType)
      return isSubtypeOfArrayType((GenericArrayType)supertype); 
    return false;
  }
  
  public final boolean isArray() { return (getComponentType() != null); }
  
  public final boolean isPrimitive() { return (this.runtimeType instanceof Class && ((Class)this.runtimeType).isPrimitive()); }
  
  public final TypeToken<T> wrap() {
    if (isPrimitive()) {
      Class<T> type = (Class)this.runtimeType;
      return of(Primitives.wrap(type));
    } 
    return this;
  }
  
  private boolean isWrapper() { return Primitives.allWrapperTypes().contains(this.runtimeType); }
  
  public final TypeToken<T> unwrap() {
    if (isWrapper()) {
      Class<T> type = (Class)this.runtimeType;
      return of(Primitives.unwrap(type));
    } 
    return this;
  }
  
  @CheckForNull
  public final TypeToken<?> getComponentType() {
    Type componentType = Types.getComponentType(this.runtimeType);
    if (componentType == null)
      return null; 
    return of(componentType);
  }
  
  public final Invokable<T, Object> method(Method method) {
    Preconditions.checkArgument(
        someRawTypeIsSubclassOf(method.getDeclaringClass()), "%s not declared by %s", method, this);
    return new Object(this, method);
  }
  
  public final Invokable<T, T> constructor(Constructor<?> constructor) {
    Preconditions.checkArgument(
        (constructor.getDeclaringClass() == getRawType()), "%s not declared by %s", constructor, 

        
        getRawType());
    return new Object(this, constructor);
  }
  
  public boolean equals(@CheckForNull Object o) {
    if (o instanceof TypeToken) {
      TypeToken<?> that = (TypeToken)o;
      return this.runtimeType.equals(that.runtimeType);
    } 
    return false;
  }
  
  public int hashCode() { return this.runtimeType.hashCode(); }
  
  public String toString() { return Types.toString(this.runtimeType); }
  
  protected Object writeReplace() { return of((new TypeResolver()).resolveType(this.runtimeType)); }
  
  @CanIgnoreReturnValue
  final TypeToken<T> rejectTypeVariables() {
    (new Object(this))





















      
      .visit(new Type[] { this.runtimeType });
    return this;
  }
  
  private boolean someRawTypeIsSubclassOf(Class<?> superclass) {
    for (UnmodifiableIterator unmodifiableIterator = getRawTypes().iterator(); unmodifiableIterator.hasNext(); ) {
      Class<?> rawType = (Class)unmodifiableIterator.next();
      if (superclass.isAssignableFrom(rawType))
        return true; 
    } 
    return false;
  }
  
  private boolean isSubtypeOfParameterizedType(ParameterizedType supertype) {
    Class<?> matchedClass = of(supertype).getRawType();
    if (!someRawTypeIsSubclassOf(matchedClass))
      return false; 
    TypeVariable[] typeVars = matchedClass.getTypeParameters();
    Type[] supertypeArgs = supertype.getActualTypeArguments();
    for (int i = 0; i < typeVars.length; i++) {
      Type subtypeParam = getCovariantTypeResolver().resolveType(typeVars[i]);
      if (!of(subtypeParam).is(supertypeArgs[i], typeVars[i]))
        return false; 
    } 
    return (Modifier.isStatic(((Class)supertype.getRawType()).getModifiers()) || supertype
      .getOwnerType() == null || 
      isOwnedBySubtypeOf(supertype.getOwnerType()));
  }
  
  private boolean isSubtypeOfArrayType(GenericArrayType supertype) {
    if (this.runtimeType instanceof Class) {
      Class<?> fromClass = (Class)this.runtimeType;
      if (!fromClass.isArray())
        return false; 
      return of(fromClass.getComponentType()).isSubtypeOf(supertype.getGenericComponentType());
    } 
    if (this.runtimeType instanceof GenericArrayType) {
      GenericArrayType fromArrayType = (GenericArrayType)this.runtimeType;
      return of(fromArrayType.getGenericComponentType())
        .isSubtypeOf(supertype.getGenericComponentType());
    } 
    return false;
  }
  
  private boolean isSupertypeOfArray(GenericArrayType subtype) {
    if (this.runtimeType instanceof Class) {
      Class<?> thisClass = (Class)this.runtimeType;
      if (!thisClass.isArray())
        return thisClass.isAssignableFrom(Object[].class); 
      return of(subtype.getGenericComponentType()).isSubtypeOf(thisClass.getComponentType());
    } 
    if (this.runtimeType instanceof GenericArrayType)
      return of(subtype.getGenericComponentType())
        .isSubtypeOf(((GenericArrayType)this.runtimeType).getGenericComponentType()); 
    return false;
  }
  
  private boolean is(Type formalType, TypeVariable<?> declaration) {
    if (this.runtimeType.equals(formalType))
      return true; 
    if (formalType instanceof WildcardType) {
      WildcardType your = canonicalizeWildcardType(declaration, (WildcardType)formalType);
      return (every(your.getUpperBounds()).isSupertypeOf(this.runtimeType) && 
        every(your.getLowerBounds()).isSubtypeOf(this.runtimeType));
    } 
    return canonicalizeWildcardsInType(this.runtimeType).equals(canonicalizeWildcardsInType(formalType));
  }
  
  private static Type canonicalizeTypeArg(TypeVariable<?> declaration, Type typeArg) {
    return (typeArg instanceof WildcardType) ? 
      canonicalizeWildcardType(declaration, (WildcardType)typeArg) : 
      canonicalizeWildcardsInType(typeArg);
  }
  
  private static Type canonicalizeWildcardsInType(Type type) {
    if (type instanceof ParameterizedType)
      return canonicalizeWildcardsInParameterizedType((ParameterizedType)type); 
    if (type instanceof GenericArrayType)
      return Types.newArrayType(
          canonicalizeWildcardsInType(((GenericArrayType)type).getGenericComponentType())); 
    return type;
  }
  
  private static WildcardType canonicalizeWildcardType(TypeVariable<?> declaration, WildcardType type) {
    Type[] declared = declaration.getBounds();
    List<Type> upperBounds = new ArrayList<Type>();
    for (Type bound : type.getUpperBounds()) {
      if (!any(declared).isSubtypeOf(bound))
        upperBounds.add(canonicalizeWildcardsInType(bound)); 
    } 
    return new Types.WildcardTypeImpl(type.getLowerBounds(), (Type[])upperBounds.toArray(new Type[0]));
  }
  
  private static ParameterizedType canonicalizeWildcardsInParameterizedType(ParameterizedType type) {
    Class<?> rawType = (Class)type.getRawType();
    TypeVariable[] typeVars = rawType.getTypeParameters();
    Type[] typeArgs = type.getActualTypeArguments();
    for (int i = 0; i < typeArgs.length; i++)
      typeArgs[i] = canonicalizeTypeArg(typeVars[i], typeArgs[i]); 
    return Types.newParameterizedTypeWithOwner(type.getOwnerType(), rawType, typeArgs);
  }
  
  private static Bounds every(Type[] bounds) { return new Bounds(bounds, false); }
  
  private static Bounds any(Type[] bounds) { return new Bounds(bounds, true); }
  
  private ImmutableSet<Class<? super T>> getRawTypes() {
    ImmutableSet.Builder<Class<?>> builder = ImmutableSet.builder();
    (new Object(this, builder))























      
      .visit(new Type[] { this.runtimeType });
    return builder.build();
  }
  
  private boolean isOwnedBySubtypeOf(Type supertype) {
    for (TypeToken<?> type : getTypes()) {
      Type ownerType = type.getOwnerTypeIfPresent();
      if (ownerType != null && of(ownerType).isSubtypeOf(supertype))
        return true; 
    } 
    return false;
  }
  
  @CheckForNull
  private Type getOwnerTypeIfPresent() {
    if (this.runtimeType instanceof ParameterizedType)
      return ((ParameterizedType)this.runtimeType).getOwnerType(); 
    if (this.runtimeType instanceof Class)
      return ((Class)this.runtimeType).getEnclosingClass(); 
    return null;
  }
  
  @VisibleForTesting
  static <T> TypeToken<? extends T> toGenericType(Class<T> cls) {
    if (cls.isArray()) {
      Type arrayOfGenericType = Types.newArrayType(
          
          (toGenericType(cls.getComponentType())).runtimeType);
      return of(arrayOfGenericType);
    } 
    TypeVariable[] typeParams = cls.getTypeParameters();
    Type ownerType = (cls.isMemberClass() && !Modifier.isStatic(cls.getModifiers())) ? (toGenericType(cls.getEnclosingClass())).runtimeType : null;
    if (typeParams.length > 0 || (ownerType != null && ownerType != cls.getEnclosingClass()))
      return of(Types.newParameterizedTypeWithOwner(ownerType, cls, typeParams)); 
    return of(cls);
  }
  
  private TypeResolver getCovariantTypeResolver() {
    TypeResolver resolver = this.covariantTypeResolver;
    if (resolver == null)
      resolver = this.covariantTypeResolver = TypeResolver.covariantly(this.runtimeType); 
    return resolver;
  }
  
  private TypeResolver getInvariantTypeResolver() {
    TypeResolver resolver = this.invariantTypeResolver;
    if (resolver == null)
      resolver = this.invariantTypeResolver = TypeResolver.invariantly(this.runtimeType); 
    return resolver;
  }
  
  private TypeToken<? super T> getSupertypeFromUpperBounds(Class<? super T> supertype, Type[] upperBounds) {
    for (Type upperBound : upperBounds) {
      TypeToken<? super T> bound = of(upperBound);
      if (bound.isSubtypeOf(supertype))
        return bound.getSupertype(supertype); 
    } 
    throw new IllegalArgumentException(supertype + " isn't a super type of " + this);
  }
  
  private TypeToken<? extends T> getSubtypeFromLowerBounds(Class<?> subclass, Type[] lowerBounds) {
    if (lowerBounds.length > 0) {
      TypeToken<? extends T> bound = of(lowerBounds[0]);
      return bound.getSubtype(subclass);
    } 
    throw new IllegalArgumentException(subclass + " isn't a subclass of " + this);
  }
  
  private TypeToken<? super T> getArraySupertype(Class<? super T> supertype) {
    TypeToken componentType = getComponentType();
    if (componentType == null)
      throw new IllegalArgumentException(supertype + " isn't a super type of " + this); 
    TypeToken<?> componentSupertype = componentType.getSupertype((Class)Objects.requireNonNull(supertype.getComponentType()));
    return of(newArrayClassOrGenericArrayType(componentSupertype.runtimeType));
  }
  
  private TypeToken<? extends T> getArraySubtype(Class<?> subclass) {
    Class<?> subclassComponentType = subclass.getComponentType();
    if (subclassComponentType == null)
      throw new IllegalArgumentException(subclass + " does not appear to be a subtype of " + this); 
    TypeToken<?> componentSubtype = ((TypeToken)Objects.requireNonNull(getComponentType())).getSubtype(subclassComponentType);
    return of(newArrayClassOrGenericArrayType(componentSubtype.runtimeType));
  }
  
  private Type resolveTypeArgsForSubclass(Class<?> subclass) {
    if (this.runtimeType instanceof Class && (subclass
      .getTypeParameters().length == 0 || 
      getRawType().getTypeParameters().length != 0))
      return subclass; 
    TypeToken<?> genericSubtype = toGenericType(subclass);
    Type supertypeWithArgsFromSubtype = (genericSubtype.getSupertype(getRawType())).runtimeType;
    return (new TypeResolver())
      .where(supertypeWithArgsFromSubtype, this.runtimeType)
      .resolveType(genericSubtype.runtimeType);
  }
  
  private static Type newArrayClassOrGenericArrayType(Type componentType) { return Types.JavaVersion.JAVA7.newArrayType(componentType); }
}
