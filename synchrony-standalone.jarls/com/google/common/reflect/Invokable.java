package com.google.common.reflect;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.lang.annotation.Annotation;
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.AnnotatedType;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
public abstract class Invokable<T, R> extends Object implements AnnotatedElement, Member {
  private final AccessibleObject accessibleObject;
  
  private final Member member;
  
  <M extends AccessibleObject & Member> Invokable(M member) {
    Preconditions.checkNotNull(member);
    this.accessibleObject = member;
    this.member = (Member)member;
  }
  
  public static Invokable<?, Object> from(Method method) { return new MethodInvokable(method); }
  
  public static <T> Invokable<T, T> from(Constructor<T> constructor) { return new ConstructorInvokable(constructor); }
  
  public final boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) { return this.accessibleObject.isAnnotationPresent(annotationClass); }
  
  @CheckForNull
  public final <A extends Annotation> A getAnnotation(Class<A> annotationClass) { return (A)this.accessibleObject.getAnnotation(annotationClass); }
  
  public final Annotation[] getAnnotations() { return this.accessibleObject.getAnnotations(); }
  
  public final Annotation[] getDeclaredAnnotations() { return this.accessibleObject.getDeclaredAnnotations(); }
  
  public abstract TypeVariable<?>[] getTypeParameters();
  
  public final void setAccessible(boolean flag) { this.accessibleObject.setAccessible(flag); }
  
  public final boolean trySetAccessible() {
    try {
      this.accessibleObject.setAccessible(true);
      return true;
    } catch (RuntimeException e) {
      return false;
    } 
  }
  
  public final boolean isAccessible() { return this.accessibleObject.isAccessible(); }
  
  public final String getName() { return this.member.getName(); }
  
  public final int getModifiers() { return this.member.getModifiers(); }
  
  public final boolean isSynthetic() { return this.member.isSynthetic(); }
  
  public final boolean isPublic() { return Modifier.isPublic(getModifiers()); }
  
  public final boolean isProtected() { return Modifier.isProtected(getModifiers()); }
  
  public final boolean isPackagePrivate() { return (!isPrivate() && !isPublic() && !isProtected()); }
  
  public final boolean isPrivate() { return Modifier.isPrivate(getModifiers()); }
  
  public final boolean isStatic() { return Modifier.isStatic(getModifiers()); }
  
  public final boolean isFinal() { return Modifier.isFinal(getModifiers()); }
  
  public final boolean isAbstract() { return Modifier.isAbstract(getModifiers()); }
  
  public final boolean isNative() { return Modifier.isNative(getModifiers()); }
  
  public final boolean isSynchronized() { return Modifier.isSynchronized(getModifiers()); }
  
  final boolean isVolatile() { return Modifier.isVolatile(getModifiers()); }
  
  final boolean isTransient() { return Modifier.isTransient(getModifiers()); }
  
  public boolean equals(@CheckForNull Object obj) {
    if (obj instanceof Invokable) {
      Invokable<?, ?> that = (Invokable)obj;
      return (getOwnerType().equals(that.getOwnerType()) && this.member.equals(that.member));
    } 
    return false;
  }
  
  public int hashCode() { return this.member.hashCode(); }
  
  public String toString() { return this.member.toString(); }
  
  public abstract boolean isOverridable();
  
  public abstract boolean isVarArgs();
  
  @CheckForNull
  @CanIgnoreReturnValue
  public final R invoke(@CheckForNull T receiver, Object... args) throws InvocationTargetException, IllegalAccessException { return (R)invokeInternal(receiver, (Object[])Preconditions.checkNotNull(args)); }
  
  public final TypeToken<? extends R> getReturnType() { return TypeToken.of(getGenericReturnType()); }
  
  @IgnoreJRERequirement
  public final ImmutableList<Parameter> getParameters() {
    Type[] parameterTypes = getGenericParameterTypes();
    Annotation[][] annotations = getParameterAnnotations();
    AnnotatedType[] arrayOfAnnotatedType = ANNOTATED_TYPE_EXISTS ? getAnnotatedParameterTypes() : new Object[parameterTypes.length];
    ImmutableList.Builder<Parameter> builder = ImmutableList.builder();
    for (int i = 0; i < parameterTypes.length; i++)
      builder.add(new Parameter(this, i, 
            
            TypeToken.of(parameterTypes[i]), annotations[i], arrayOfAnnotatedType[i])); 
    return builder.build();
  }
  
  public final ImmutableList<TypeToken<? extends Throwable>> getExceptionTypes() {
    ImmutableList.Builder<TypeToken<? extends Throwable>> builder = ImmutableList.builder();
    for (Type type : getGenericExceptionTypes()) {
      TypeToken<? extends Throwable> exceptionType = TypeToken.of(type);
      builder.add(exceptionType);
    } 
    return builder.build();
  }
  
  public final <R1 extends R> Invokable<T, R1> returning(Class<R1> returnType) { return returning(TypeToken.of(returnType)); }
  
  public final <R1 extends R> Invokable<T, R1> returning(TypeToken<R1> returnType) {
    if (!returnType.isSupertypeOf(getReturnType()))
      throw new IllegalArgumentException("Invokable is known to return " + 
          getReturnType() + ", not " + returnType); 
    return this;
  }
  
  public final Class<? super T> getDeclaringClass() { return this.member.getDeclaringClass(); }
  
  public TypeToken<T> getOwnerType() { return TypeToken.of(getDeclaringClass()); }
  
  private static final boolean ANNOTATED_TYPE_EXISTS = initAnnotatedTypeExists();
  
  @CheckForNull
  abstract Object invokeInternal(@CheckForNull Object paramObject, Object[] paramArrayOfObject) throws InvocationTargetException, IllegalAccessException;
  
  abstract Type[] getGenericParameterTypes();
  
  @IgnoreJRERequirement
  abstract AnnotatedType[] getAnnotatedParameterTypes();
  
  abstract Type[] getGenericExceptionTypes();
  
  abstract Annotation[][] getParameterAnnotations();
  
  abstract Type getGenericReturnType();
  
  @IgnoreJRERequirement
  public abstract AnnotatedType getAnnotatedReturnType();
  
  private static boolean initAnnotatedTypeExists() {
    try {
      Class.forName("java.lang.reflect.AnnotatedType");
    } catch (ClassNotFoundException e) {
      return false;
    } 
    return true;
  }
}
