package com.google.common.reflect;

import com.google.common.base.Preconditions;
import com.google.common.collect.Maps;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.Map;

@ElementTypesAreNonnullByDefault
public final class TypeResolver {
  private final TypeTable typeTable;
  
  public TypeResolver() { this.typeTable = new TypeTable(); }
  
  private TypeResolver(TypeTable typeTable) { this.typeTable = typeTable; }
  
  static TypeResolver covariantly(Type contextType) { return (new TypeResolver()).where(TypeMappingIntrospector.getTypeMappings(contextType)); }
  
  static TypeResolver invariantly(Type contextType) {
    Type invariantContext = WildcardCapturer.INSTANCE.capture(contextType);
    return (new TypeResolver()).where(TypeMappingIntrospector.getTypeMappings(invariantContext));
  }
  
  public TypeResolver where(Type formal, Type actual) {
    Map<TypeVariableKey, Type> mappings = Maps.newHashMap();
    populateTypeMappings(mappings, (Type)Preconditions.checkNotNull(formal), (Type)Preconditions.checkNotNull(actual));
    return where(mappings);
  }
  
  TypeResolver where(Map<TypeVariableKey, ? extends Type> mappings) { return new TypeResolver(this.typeTable.where(mappings)); }
  
  private static void populateTypeMappings(Map<TypeVariableKey, Type> mappings, Type from, Type to) {
    if (from.equals(to))
      return; 
    (new Object(mappings, to))












































































      
      .visit(new Type[] { from });
  }
  
  public Type resolveType(Type type) {
    Preconditions.checkNotNull(type);
    if (type instanceof TypeVariable)
      return this.typeTable.resolve((TypeVariable)type); 
    if (type instanceof ParameterizedType)
      return resolveParameterizedType((ParameterizedType)type); 
    if (type instanceof GenericArrayType)
      return resolveGenericArrayType((GenericArrayType)type); 
    if (type instanceof WildcardType)
      return resolveWildcardType((WildcardType)type); 
    return type;
  }
  
  Type[] resolveTypesInPlace(Type[] types) {
    for (int i = 0; i < types.length; i++)
      types[i] = resolveType(types[i]); 
    return types;
  }
  
  private Type[] resolveTypes(Type[] types) {
    Type[] result = new Type[types.length];
    for (int i = 0; i < types.length; i++)
      result[i] = resolveType(types[i]); 
    return result;
  }
  
  private WildcardType resolveWildcardType(WildcardType type) {
    Type[] lowerBounds = type.getLowerBounds();
    Type[] upperBounds = type.getUpperBounds();
    return new Types.WildcardTypeImpl(resolveTypes(lowerBounds), resolveTypes(upperBounds));
  }
  
  private Type resolveGenericArrayType(GenericArrayType type) {
    Type componentType = type.getGenericComponentType();
    Type resolvedComponentType = resolveType(componentType);
    return Types.newArrayType(resolvedComponentType);
  }
  
  private ParameterizedType resolveParameterizedType(ParameterizedType type) {
    Type owner = type.getOwnerType();
    Type resolvedOwner = (owner == null) ? null : resolveType(owner);
    Type resolvedRawType = resolveType(type.getRawType());
    Type[] args = type.getActualTypeArguments();
    Type[] resolvedArgs = resolveTypes(args);
    return Types.newParameterizedTypeWithOwner(resolvedOwner, (Class)resolvedRawType, resolvedArgs);
  }
  
  private static <T> T expectArgument(Class<T> type, Object arg) {
    try {
      return (T)type.cast(arg);
    } catch (ClassCastException e) {
      throw new IllegalArgumentException(arg + " is not a " + type.getSimpleName());
    } 
  }
}
