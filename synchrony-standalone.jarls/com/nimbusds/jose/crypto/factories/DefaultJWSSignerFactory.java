package com.nimbusds.jose.crypto.factories;

import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.JWSSigner;
import com.nimbusds.jose.crypto.ECDSASigner;
import com.nimbusds.jose.crypto.Ed25519Signer;
import com.nimbusds.jose.crypto.MACSigner;
import com.nimbusds.jose.crypto.RSASSASigner;
import com.nimbusds.jose.jca.JCAContext;
import com.nimbusds.jose.jwk.ECKey;
import com.nimbusds.jose.jwk.JWK;
import com.nimbusds.jose.jwk.JWKException;
import com.nimbusds.jose.jwk.KeyUse;
import com.nimbusds.jose.jwk.OctetKeyPair;
import com.nimbusds.jose.jwk.OctetSequenceKey;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jose.produce.JWSSignerFactory;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.Set;

public class DefaultJWSSignerFactory implements JWSSignerFactory {
  private final JCAContext jcaContext = new JCAContext();
  
  public static final Set<JWSAlgorithm> SUPPORTED_ALGORITHMS;
  
  static  {
    algs = new LinkedHashSet();
    algs.addAll(MACSigner.SUPPORTED_ALGORITHMS);
    algs.addAll(RSASSASigner.SUPPORTED_ALGORITHMS);
    algs.addAll(ECDSASigner.SUPPORTED_ALGORITHMS);
    algs.addAll(Ed25519Signer.SUPPORTED_ALGORITHMS);
    SUPPORTED_ALGORITHMS = Collections.unmodifiableSet(algs);
  }
  
  public Set<JWSAlgorithm> supportedJWSAlgorithms() { return SUPPORTED_ALGORITHMS; }
  
  public JCAContext getJCAContext() { return this.jcaContext; }
  
  public JWSSigner createJWSSigner(JWK key) throws JOSEException {
    Ed25519Signer ed25519Signer;
    if (!key.isPrivate())
      throw JWKException.expectedPrivate(); 
    if (key.getKeyUse() != null && !KeyUse.SIGNATURE.equals(key.getKeyUse()))
      throw new JWKException("The JWK use must be sig (signature) or unspecified"); 
    if (key instanceof OctetSequenceKey) {
      ed25519Signer = new MACSigner((OctetSequenceKey)key);
    } else if (key instanceof RSAKey) {
      ed25519Signer = new RSASSASigner((RSAKey)key);
    } else if (key instanceof ECKey) {
      ed25519Signer = new ECDSASigner((ECKey)key);
    } else if (key instanceof OctetKeyPair) {
      ed25519Signer = new Ed25519Signer((OctetKeyPair)key);
    } else {
      throw new JOSEException("Unsupported JWK type: " + key);
    } 
    ed25519Signer.getJCAContext().setSecureRandom(this.jcaContext.getSecureRandom());
    ed25519Signer.getJCAContext().setProvider(this.jcaContext.getProvider());
    return ed25519Signer;
  }
  
  public JWSSigner createJWSSigner(JWK key, JWSAlgorithm alg) throws JOSEException {
    Ed25519Signer ed25519Signer;
    if (!key.isPrivate())
      throw JWKException.expectedPrivate(); 
    if (key.getKeyUse() != null && !KeyUse.SIGNATURE.equals(key.getKeyUse()))
      throw new JWKException("The JWK use must be sig (signature) or unspecified"); 
    if (MACSigner.SUPPORTED_ALGORITHMS.contains(alg)) {
      if (!(key instanceof OctetSequenceKey))
        throw JWKException.expectedClass(OctetSequenceKey.class); 
      ed25519Signer = new MACSigner((OctetSequenceKey)key);
    } else if (RSASSASigner.SUPPORTED_ALGORITHMS.contains(alg)) {
      if (!(key instanceof RSAKey))
        throw JWKException.expectedClass(RSAKey.class); 
      ed25519Signer = new RSASSASigner((RSAKey)key);
    } else if (ECDSASigner.SUPPORTED_ALGORITHMS.contains(alg)) {
      if (!(key instanceof ECKey))
        throw JWKException.expectedClass(ECKey.class); 
      ed25519Signer = new ECDSASigner((ECKey)key);
    } else if (Ed25519Signer.SUPPORTED_ALGORITHMS.contains(alg)) {
      if (!(key instanceof OctetKeyPair))
        throw JWKException.expectedClass(OctetKeyPair.class); 
      ed25519Signer = new Ed25519Signer((OctetKeyPair)key);
    } else {
      throw new JOSEException("Unsupported JWS algorithm: " + alg);
    } 
    ed25519Signer.getJCAContext().setSecureRandom(this.jcaContext.getSecureRandom());
    ed25519Signer.getJCAContext().setProvider(this.jcaContext.getProvider());
    return ed25519Signer;
  }
}
