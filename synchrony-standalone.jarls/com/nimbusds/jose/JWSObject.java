package com.nimbusds.jose;

import com.nimbusds.jose.util.Base64URL;
import com.nimbusds.jose.util.StandardCharset;
import java.text.ParseException;
import net.jcip.annotations.ThreadSafe;

@ThreadSafe
public class JWSObject extends JOSEObject {
  private static final long serialVersionUID = 1L;
  
  private final JWSHeader header;
  
  private final String signingInputString;
  
  private Base64URL signature;
  
  private State state;
  
  public JWSObject(JWSHeader header, Payload payload) {
    if (header == null)
      throw new IllegalArgumentException("The JWS header must not be null"); 
    this.header = header;
    if (payload == null)
      throw new IllegalArgumentException("The payload must not be null"); 
    setPayload(payload);
    this.signingInputString = composeSigningInput();
    this.signature = null;
    this.state = State.UNSIGNED;
  }
  
  public JWSObject(Base64URL firstPart, Base64URL secondPart, Base64URL thirdPart) throws ParseException { this(firstPart, new Payload(secondPart), thirdPart); }
  
  public JWSObject(Base64URL firstPart, Payload payload, Base64URL thirdPart) throws ParseException {
    if (firstPart == null)
      throw new IllegalArgumentException("The first part must not be null"); 
    try {
      this.header = JWSHeader.parse(firstPart);
    } catch (ParseException e) {
      throw new ParseException("Invalid JWS header: " + e.getMessage(), 0);
    } 
    if (payload == null)
      throw new IllegalArgumentException("The payload (second part) must not be null"); 
    setPayload(payload);
    this.signingInputString = composeSigningInput();
    if (thirdPart == null)
      throw new IllegalArgumentException("The third part must not be null"); 
    this.signature = thirdPart;
    this.state = State.SIGNED;
    if (getHeader().isBase64URLEncodePayload()) {
      setParsedParts(new Base64URL[] { firstPart, payload.toBase64URL(), thirdPart });
    } else {
      setParsedParts(new Base64URL[] { firstPart, new Base64URL(""), thirdPart });
    } 
  }
  
  public JWSHeader getHeader() { return this.header; }
  
  private String composeSigningInput() {
    if (this.header.isBase64URLEncodePayload())
      return getHeader().toBase64URL().toString() + '.' + getPayload().toBase64URL().toString(); 
    return getHeader().toBase64URL().toString() + '.' + getPayload().toString();
  }
  
  public byte[] getSigningInput() { return this.signingInputString.getBytes(StandardCharset.UTF_8); }
  
  public Base64URL getSignature() { return this.signature; }
  
  public State getState() { return this.state; }
  
  private void ensureUnsignedState() {
    if (this.state != State.UNSIGNED)
      throw new IllegalStateException("The JWS object must be in an unsigned state"); 
  }
  
  private void ensureSignedOrVerifiedState() {
    if (this.state != State.SIGNED && this.state != State.VERIFIED)
      throw new IllegalStateException("The JWS object must be in a signed or verified state"); 
  }
  
  private void ensureJWSSignerSupport(JWSSigner signer) throws JOSEException {
    if (!signer.supportedJWSAlgorithms().contains(getHeader().getAlgorithm()))
      throw new JOSEException("The \"" + getHeader().getAlgorithm() + "\" algorithm is not allowed or supported by the JWS signer: Supported algorithms: " + signer
          .supportedJWSAlgorithms()); 
  }
  
  public void sign(JWSSigner signer) throws JOSEException {
    ensureUnsignedState();
    ensureJWSSignerSupport(signer);
    try {
      this.signature = signer.sign(getHeader(), getSigningInput());
    } catch (JOSEException e) {
      throw e;
    } catch (Exception e) {
      throw new JOSEException(e.getMessage(), e);
    } 
    this.state = State.SIGNED;
  }
  
  public boolean verify(JWSVerifier verifier) throws JOSEException {
    boolean verified;
    ensureSignedOrVerifiedState();
    try {
      verified = verifier.verify(getHeader(), getSigningInput(), getSignature());
    } catch (JOSEException e) {
      throw e;
    } catch (Exception e) {
      throw new JOSEException(e.getMessage(), e);
    } 
    if (verified)
      this.state = State.VERIFIED; 
    return verified;
  }
  
  public String serialize() { return serialize(false); }
  
  public String serialize(boolean detachedPayload) {
    ensureSignedOrVerifiedState();
    if (detachedPayload)
      return this.header.toBase64URL().toString() + '.' + '.' + this.signature.toString(); 
    return this.signingInputString + '.' + this.signature.toString();
  }
  
  public static JWSObject parse(String s) throws ParseException {
    Base64URL[] parts = JOSEObject.split(s);
    if (parts.length != 3)
      throw new ParseException("Unexpected number of Base64URL parts, must be three", 0); 
    return new JWSObject(parts[0], parts[1], parts[2]);
  }
  
  public static JWSObject parse(String s, Payload detachedPayload) throws ParseException {
    Base64URL[] parts = JOSEObject.split(s);
    if (parts.length != 3)
      throw new ParseException("Unexpected number of Base64URL parts, must be three", 0); 
    if (!parts[1].toString().isEmpty())
      throw new ParseException("The payload Base64URL part must be empty", 0); 
    return new JWSObject(parts[0], detachedPayload, parts[2]);
  }
}
