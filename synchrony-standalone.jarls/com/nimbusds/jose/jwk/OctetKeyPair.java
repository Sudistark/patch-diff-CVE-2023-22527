package com.nimbusds.jose.jwk;

import com.nimbusds.jose.Algorithm;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.util.Base64;
import com.nimbusds.jose.util.Base64URL;
import com.nimbusds.jose.util.ByteUtils;
import com.nimbusds.jose.util.JSONObjectUtils;
import java.net.URI;
import java.security.KeyPair;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.X509Certificate;
import java.text.ParseException;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import net.jcip.annotations.Immutable;
import net.minidev.json.JSONObject;

@Immutable
public class OctetKeyPair extends JWK implements AsymmetricJWK, CurveBasedJWK {
  private static final long serialVersionUID = 1L;
  
  public static final Set<Curve> SUPPORTED_CURVES = Collections.unmodifiableSet(new HashSet(
        Arrays.asList(new Curve[] { Curve.Ed25519, Curve.Ed448, Curve.X25519, Curve.X448 })));
  
  private final Curve crv;
  
  private final Base64URL x;
  
  private final byte[] decodedX;
  
  private final Base64URL d;
  
  private final byte[] decodedD;
  
  public OctetKeyPair(Curve crv, Base64URL x, KeyUse use, Set<KeyOperation> ops, Algorithm alg, String kid, URI x5u, Base64URL x5t, Base64URL x5t256, List<Base64> x5c, KeyStore ks) {
    super(KeyType.OKP, use, ops, alg, kid, x5u, x5t, x5t256, x5c, ks);
    if (crv == null)
      throw new IllegalArgumentException("The curve must not be null"); 
    if (!SUPPORTED_CURVES.contains(crv))
      throw new IllegalArgumentException("Unknown / unsupported curve: " + crv); 
    this.crv = crv;
    if (x == null)
      throw new IllegalArgumentException("The 'x' parameter must not be null"); 
    this.x = x;
    this.decodedX = x.decode();
    this.d = null;
    this.decodedD = null;
  }
  
  public OctetKeyPair(Curve crv, Base64URL x, Base64URL d, KeyUse use, Set<KeyOperation> ops, Algorithm alg, String kid, URI x5u, Base64URL x5t, Base64URL x5t256, List<Base64> x5c, KeyStore ks) {
    super(KeyType.OKP, use, ops, alg, kid, x5u, x5t, x5t256, x5c, ks);
    if (crv == null)
      throw new IllegalArgumentException("The curve must not be null"); 
    if (!SUPPORTED_CURVES.contains(crv))
      throw new IllegalArgumentException("Unknown / unsupported curve: " + crv); 
    this.crv = crv;
    if (x == null)
      throw new IllegalArgumentException("The 'x' parameter must not be null"); 
    this.x = x;
    this.decodedX = x.decode();
    if (d == null)
      throw new IllegalArgumentException("The 'd' parameter must not be null"); 
    this.d = d;
    this.decodedD = d.decode();
  }
  
  public Curve getCurve() { return this.crv; }
  
  public Base64URL getX() { return this.x; }
  
  public byte[] getDecodedX() { return (byte[])this.decodedX.clone(); }
  
  public Base64URL getD() { return this.d; }
  
  public byte[] getDecodedD() { return (this.decodedD == null) ? null : (byte[])this.decodedD.clone(); }
  
  public PublicKey toPublicKey() throws JOSEException { throw new JOSEException("Export to java.security.PublicKey not supported"); }
  
  public PrivateKey toPrivateKey() throws JOSEException { throw new JOSEException("Export to java.security.PrivateKey not supported"); }
  
  public KeyPair toKeyPair() throws JOSEException { throw new JOSEException("Export to java.security.KeyPair not supported"); }
  
  public boolean matches(X509Certificate cert) { return false; }
  
  public LinkedHashMap<String, ?> getRequiredParams() {
    LinkedHashMap<String, String> requiredParams = new LinkedHashMap<String, String>();
    requiredParams.put("crv", this.crv.toString());
    requiredParams.put("kty", getKeyType().getValue());
    requiredParams.put("x", this.x.toString());
    return requiredParams;
  }
  
  public boolean isPrivate() { return (this.d != null); }
  
  public OctetKeyPair toPublicJWK() {
    return new OctetKeyPair(
        getCurve(), getX(), 
        getKeyUse(), getKeyOperations(), getAlgorithm(), getKeyID(), 
        getX509CertURL(), getX509CertThumbprint(), getX509CertSHA256Thumbprint(), getX509CertChain(), 
        getKeyStore());
  }
  
  public JSONObject toJSONObject() {
    JSONObject o = super.toJSONObject();
    o.put("crv", this.crv.toString());
    o.put("x", this.x.toString());
    if (this.d != null)
      o.put("d", this.d.toString()); 
    return o;
  }
  
  public int size() { return ByteUtils.bitLength(this.x.decode()); }
  
  public static OctetKeyPair parse(String s) throws ParseException { return parse(JSONObjectUtils.parse(s)); }
  
  public static OctetKeyPair parse(JSONObject jsonObject) throws ParseException {
    Curve crv;
    if (!KeyType.OKP.equals(JWKMetadata.parseKeyType(jsonObject)))
      throw new ParseException("The key type \"kty\" must be OKP", 0); 
    try {
      crv = Curve.parse(JSONObjectUtils.getString(jsonObject, "crv"));
    } catch (IllegalArgumentException e) {
      throw new ParseException(e.getMessage(), 0);
    } 
    Base64URL x = JSONObjectUtils.getBase64URL(jsonObject, "x");
    Base64URL d = JSONObjectUtils.getBase64URL(jsonObject, "d");
    try {
      if (d == null)
        return new OctetKeyPair(crv, x, 
            JWKMetadata.parseKeyUse(jsonObject), 
            JWKMetadata.parseKeyOperations(jsonObject), 
            JWKMetadata.parseAlgorithm(jsonObject), 
            JWKMetadata.parseKeyID(jsonObject), 
            JWKMetadata.parseX509CertURL(jsonObject), 
            JWKMetadata.parseX509CertThumbprint(jsonObject), 
            JWKMetadata.parseX509CertSHA256Thumbprint(jsonObject), 
            JWKMetadata.parseX509CertChain(jsonObject), null); 
      return new OctetKeyPair(crv, x, d, 
          JWKMetadata.parseKeyUse(jsonObject), 
          JWKMetadata.parseKeyOperations(jsonObject), 
          JWKMetadata.parseAlgorithm(jsonObject), 
          JWKMetadata.parseKeyID(jsonObject), 
          JWKMetadata.parseX509CertURL(jsonObject), 
          JWKMetadata.parseX509CertThumbprint(jsonObject), 
          JWKMetadata.parseX509CertSHA256Thumbprint(jsonObject), 
          JWKMetadata.parseX509CertChain(jsonObject), null);
    } catch (IllegalArgumentException ex) {
      throw new ParseException(ex.getMessage(), 0);
    } 
  }
  
  public boolean equals(Object o) {
    if (this == o)
      return true; 
    if (!(o instanceof OctetKeyPair))
      return false; 
    if (!super.equals(o))
      return false; 
    OctetKeyPair that = (OctetKeyPair)o;
    return (Objects.equals(this.crv, that.crv) && 
      Objects.equals(this.x, that.x) && 
      Arrays.equals(this.decodedX, that.decodedX) && 
      Objects.equals(this.d, that.d) && 
      Arrays.equals(this.decodedD, that.decodedD));
  }
  
  public int hashCode() {
    result = Objects.hash(new Object[] { Integer.valueOf(super.hashCode()), this.crv, this.x, this.d });
    result = 31 * result + Arrays.hashCode(this.decodedX);
    return 31 * result + Arrays.hashCode(this.decodedD);
  }
}
