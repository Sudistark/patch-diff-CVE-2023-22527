package com.hazelcast.ringbuffer.impl.operations;

import com.hazelcast.core.IFunction;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.impl.Versioned;
import com.hazelcast.ringbuffer.impl.ReadResultSetImpl;
import com.hazelcast.ringbuffer.impl.RingbufferContainer;
import com.hazelcast.spi.BlockingOperation;
import com.hazelcast.spi.ReadonlyOperation;
import com.hazelcast.spi.WaitNotifyKey;
import java.io.IOException;

public class ReadManyOperation<O> extends AbstractRingBufferOperation implements BlockingOperation, ReadonlyOperation, Versioned {
  long sequence;
  
  private int minSize;
  
  private int maxSize;
  
  private long startSequence;
  
  private IFunction<O, Boolean> filter;
  
  private ReadResultSetImpl<O, O> resultSet;
  
  public ReadManyOperation() {}
  
  public ReadManyOperation(String name, long startSequence, int minSize, int maxSize, IFunction<O, Boolean> filter) {
    super(name);
    this.minSize = minSize;
    this.maxSize = maxSize;
    this.startSequence = startSequence;
    this.filter = filter;
  }
  
  public void beforeRun() {
    RingbufferContainer ringbuffer = getRingBufferContainer();
    ringbuffer.checkBlockableReadSequence(this.startSequence);
  }
  
  public boolean shouldWait() {
    if (this.resultSet == null) {
      this.resultSet = new ReadResultSetImpl(this.minSize, this.maxSize, getNodeEngine().getSerializationService(), this.filter);
      this.sequence = this.startSequence;
    } 
    RingbufferContainer ringbuffer = getRingBufferContainer();
    if (this.minSize == 0) {
      if (!ringbuffer.shouldWait(this.sequence))
        this.sequence = ringbuffer.readMany(this.sequence, this.resultSet); 
      return false;
    } 
    if (this.resultSet.isMinSizeReached())
      return false; 
    if (ringbuffer.isTooLargeSequence(this.sequence) || ringbuffer.isStaleSequence(this.sequence))
      return false; 
    if (this.sequence == ringbuffer.tailSequence() + 1L)
      return true; 
    this.sequence = ringbuffer.readMany(this.sequence, this.resultSet);
    return !this.resultSet.isMinSizeReached();
  }
  
  public void run() {}
  
  public Object getResponse() { return this.resultSet; }
  
  public WaitNotifyKey getWaitKey() {
    RingbufferContainer ringbuffer = getRingBufferContainer();
    return ringbuffer.getRingEmptyWaitNotifyKey();
  }
  
  public void onWaitExpire() {}
  
  public int getId() { return 6; }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException {
    super.writeInternal(out);
    out.writeLong(this.startSequence);
    out.writeInt(this.minSize);
    out.writeInt(this.maxSize);
    out.writeObject(this.filter);
  }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    super.readInternal(in);
    this.startSequence = in.readLong();
    this.minSize = in.readInt();
    this.maxSize = in.readInt();
    this.filter = (IFunction)in.readObject();
  }
}
