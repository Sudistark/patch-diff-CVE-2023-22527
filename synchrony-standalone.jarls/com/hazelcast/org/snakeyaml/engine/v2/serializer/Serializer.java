package com.hazelcast.org.snakeyaml.engine.v2.serializer;

import com.hazelcast.org.snakeyaml.engine.v2.api.DumpSettings;
import com.hazelcast.org.snakeyaml.engine.v2.common.Anchor;
import com.hazelcast.org.snakeyaml.engine.v2.emitter.Emitable;
import com.hazelcast.org.snakeyaml.engine.v2.events.AliasEvent;
import com.hazelcast.org.snakeyaml.engine.v2.events.DocumentEndEvent;
import com.hazelcast.org.snakeyaml.engine.v2.events.DocumentStartEvent;
import com.hazelcast.org.snakeyaml.engine.v2.events.ImplicitTuple;
import com.hazelcast.org.snakeyaml.engine.v2.events.MappingEndEvent;
import com.hazelcast.org.snakeyaml.engine.v2.events.MappingStartEvent;
import com.hazelcast.org.snakeyaml.engine.v2.events.ScalarEvent;
import com.hazelcast.org.snakeyaml.engine.v2.events.SequenceEndEvent;
import com.hazelcast.org.snakeyaml.engine.v2.events.SequenceStartEvent;
import com.hazelcast.org.snakeyaml.engine.v2.events.StreamEndEvent;
import com.hazelcast.org.snakeyaml.engine.v2.events.StreamStartEvent;
import com.hazelcast.org.snakeyaml.engine.v2.nodes.AnchorNode;
import com.hazelcast.org.snakeyaml.engine.v2.nodes.CollectionNode;
import com.hazelcast.org.snakeyaml.engine.v2.nodes.MappingNode;
import com.hazelcast.org.snakeyaml.engine.v2.nodes.Node;
import com.hazelcast.org.snakeyaml.engine.v2.nodes.NodeTuple;
import com.hazelcast.org.snakeyaml.engine.v2.nodes.NodeType;
import com.hazelcast.org.snakeyaml.engine.v2.nodes.ScalarNode;
import com.hazelcast.org.snakeyaml.engine.v2.nodes.SequenceNode;
import com.hazelcast.org.snakeyaml.engine.v2.nodes.Tag;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

public class Serializer {
  private final DumpSettings settings;
  
  private final Emitable emitable;
  
  private final Set<Node> serializedNodes;
  
  private final Map<Node, Anchor> anchors;
  
  public Serializer(DumpSettings settings, Emitable emitable) {
    this.settings = settings;
    this.emitable = emitable;
    this.serializedNodes = new HashSet();
    this.anchors = new HashMap();
  }
  
  public void serialize(Node node) {
    this.emitable.emit(new DocumentStartEvent(this.settings.isExplicitStart(), this.settings.getYamlDirective(), this.settings.getTagDirective()));
    anchorNode(node);
    this.settings.getExplicitRootTag().ifPresent(node::setTag);
    serializeNode(node);
    this.emitable.emit(new DocumentEndEvent(this.settings.isExplicitEnd()));
    this.serializedNodes.clear();
    this.anchors.clear();
  }
  
  public void open() { this.emitable.emit(new StreamStartEvent()); }
  
  public void close() {
    this.emitable.emit(new StreamEndEvent());
    this.anchors.clear();
    this.serializedNodes.clear();
  }
  
  private void anchorNode(Node node) {
    Node realNode;
    if (node.getNodeType() == NodeType.ANCHOR) {
      realNode = ((AnchorNode)node).getRealNode();
    } else {
      realNode = node;
    } 
    if (this.anchors.containsKey(realNode)) {
      this.anchors.computeIfAbsent(realNode, a -> this.settings.getAnchorGenerator().nextAnchor(realNode));
    } else {
      List<NodeTuple> map;
      MappingNode mappingNode;
      List<Node> list;
      SequenceNode seqNode;
      this.anchors.put(realNode, null);
      switch (null.$SwitchMap$org$snakeyaml$engine$v2$nodes$NodeType[realNode.getNodeType().ordinal()]) {
        case 1:
          seqNode = (SequenceNode)realNode;
          list = seqNode.getValue();
          for (Node item : list)
            anchorNode(item); 
          break;
        case 2:
          mappingNode = (MappingNode)realNode;
          map = mappingNode.getValue();
          for (NodeTuple object : map) {
            Node key = object.getKeyNode();
            Node value = object.getValueNode();
            anchorNode(key);
            anchorNode(value);
          } 
          break;
      } 
    } 
  }
  
  private void serializeNode(Node node) {
    if (node.getNodeType() == NodeType.ANCHOR)
      node = ((AnchorNode)node).getRealNode(); 
    Optional<Anchor> tAlias = Optional.ofNullable(this.anchors.get(node));
    if (this.serializedNodes.contains(node)) {
      this.emitable.emit(new AliasEvent(tAlias));
    } else {
      List<Node> list;
      boolean implicitS;
      SequenceNode seqNode;
      ScalarEvent event;
      ImplicitTuple tuple;
      Tag defaultTag, detectedTag;
      ScalarNode scalarNode;
      this.serializedNodes.add(node);
      switch (null.$SwitchMap$org$snakeyaml$engine$v2$nodes$NodeType[node.getNodeType().ordinal()]) {
        case 3:
          scalarNode = (ScalarNode)node;
          detectedTag = this.settings.getScalarResolver().resolve(scalarNode.getValue(), Boolean.valueOf(true));
          defaultTag = this.settings.getScalarResolver().resolve(scalarNode.getValue(), Boolean.valueOf(false));
          tuple = new ImplicitTuple(node.getTag().equals(detectedTag), node.getTag().equals(defaultTag));
          event = new ScalarEvent(tAlias, Optional.of(node.getTag().getValue()), tuple, scalarNode.getValue(), scalarNode.getScalarStyle());
          this.emitable.emit(event);
          return;
        case 1:
          seqNode = (SequenceNode)node;
          implicitS = node.getTag().equals(Tag.SEQ);
          this.emitable.emit(new SequenceStartEvent(tAlias, Optional.of(node.getTag().getValue()), implicitS, seqNode
                .getFlowStyle()));
          list = seqNode.getValue();
          for (Node item : list)
            serializeNode(item); 
          this.emitable.emit(new SequenceEndEvent());
          return;
      } 
      boolean implicitM = node.getTag().equals(Tag.MAP);
      this.emitable.emit(new MappingStartEvent(tAlias, Optional.of(node.getTag().getValue()), implicitM, ((CollectionNode)node)
            .getFlowStyle()));
      MappingNode mappingNode = (MappingNode)node;
      List<NodeTuple> map = mappingNode.getValue();
      for (NodeTuple entry : map) {
        Node key = entry.getKeyNode();
        Node value = entry.getValueNode();
        serializeNode(key);
        serializeNode(value);
      } 
      this.emitable.emit(new MappingEndEvent());
    } 
  }
}
