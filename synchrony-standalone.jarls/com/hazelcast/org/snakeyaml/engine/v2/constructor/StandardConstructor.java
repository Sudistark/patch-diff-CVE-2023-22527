package com.hazelcast.org.snakeyaml.engine.v2.constructor;

import com.hazelcast.org.snakeyaml.engine.v2.api.LoadSettings;
import com.hazelcast.org.snakeyaml.engine.v2.exceptions.ConstructorException;
import com.hazelcast.org.snakeyaml.engine.v2.exceptions.DuplicateKeyException;
import com.hazelcast.org.snakeyaml.engine.v2.exceptions.Mark;
import com.hazelcast.org.snakeyaml.engine.v2.nodes.MappingNode;
import com.hazelcast.org.snakeyaml.engine.v2.nodes.Node;
import com.hazelcast.org.snakeyaml.engine.v2.nodes.NodeTuple;
import com.hazelcast.org.snakeyaml.engine.v2.nodes.Tag;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.TreeSet;

public class StandardConstructor extends BaseConstructor {
  private static final String ERROR_PREFIX = "while constructing an ordered map";
  
  public StandardConstructor(LoadSettings settings) {
    super(settings);
    this.tagConstructors.put(Tag.NULL, new ConstructYamlNull(this));
    this.tagConstructors.put(Tag.BOOL, new ConstructYamlBool(this));
    this.tagConstructors.put(Tag.INT, new ConstructYamlInt(this));
    this.tagConstructors.put(Tag.FLOAT, new ConstructYamlFloat(this));
    this.tagConstructors.put(Tag.BINARY, new ConstructYamlBinary(this));
    this.tagConstructors.put(Tag.SET, new ConstructYamlSet(this));
    this.tagConstructors.put(Tag.STR, new ConstructYamlStr(this));
    this.tagConstructors.put(Tag.SEQ, new ConstructYamlSeq(this));
    this.tagConstructors.put(Tag.MAP, new ConstructYamlMap(this));
    this.tagConstructors.put(Tag.ENV_TAG, new ConstructEnv(this));
    this.tagConstructors.put(new Tag(java.util.UUID.class), new ConstructUuidClass(this));
    this.tagConstructors.put(new Tag(Optional.class), new ConstructOptionalClass(this));
    this.tagConstructors.putAll(settings.getTagConstructors());
  }
  
  protected void flattenMapping(MappingNode node) {
    processDuplicateKeys(node);
    if (node.isMerged())
      node.setValue(mergeNode(node, true, new HashMap(), new ArrayList())); 
  }
  
  protected void processDuplicateKeys(MappingNode node) {
    List<NodeTuple> nodeValue = node.getValue();
    Map<Object, Integer> keys = new HashMap<Object, Integer>(nodeValue.size());
    TreeSet<Integer> toRemove = new TreeSet<Integer>();
    int i = 0;
    for (NodeTuple tuple : nodeValue) {
      Node keyNode = tuple.getKeyNode();
      Object key = constructKey(keyNode, node.getStartMark(), tuple.getKeyNode().getStartMark());
      Integer prevIndex = (Integer)keys.put(key, Integer.valueOf(i));
      if (prevIndex != null) {
        if (!this.settings.getAllowDuplicateKeys())
          throw new DuplicateKeyException(node.getStartMark(), key, tuple
              .getKeyNode().getStartMark()); 
        toRemove.add(prevIndex);
      } 
      i++;
    } 
    Iterator<Integer> indices2remove = toRemove.descendingIterator();
    while (indices2remove.hasNext())
      nodeValue.remove(((Integer)indices2remove.next()).intValue()); 
  }
  
  private Object constructKey(Node keyNode, Optional<Mark> contextMark, Optional<Mark> problemMark) {
    Object key = constructObject(keyNode);
    if (key != null)
      try {
        key.hashCode();
      } catch (Exception e) {
        throw new ConstructorException("while constructing a mapping", contextMark, "found unacceptable key " + key, problemMark, e);
      }  
    return key;
  }
  
  private List<NodeTuple> mergeNode(MappingNode node, boolean isPreferred, Map<Object, Integer> key2index, List<NodeTuple> values) {
    Iterator<NodeTuple> iter = node.getValue().iterator();
    while (iter.hasNext()) {
      NodeTuple nodeTuple = (NodeTuple)iter.next();
      Node keyNode = nodeTuple.getKeyNode();
      Object key = constructObject(keyNode);
      if (!key2index.containsKey(key)) {
        values.add(nodeTuple);
        key2index.put(key, Integer.valueOf(values.size() - 1));
        continue;
      } 
      if (isPreferred)
        values.set(((Integer)key2index.get(key)).intValue(), nodeTuple); 
    } 
    return values;
  }
  
  protected void constructMapping2ndStep(MappingNode node, Map<Object, Object> mapping) {
    flattenMapping(node);
    super.constructMapping2ndStep(node, mapping);
  }
  
  protected void constructSet2ndStep(MappingNode node, Set<Object> set) {
    flattenMapping(node);
    super.constructSet2ndStep(node, set);
  }
  
  private static final Map<String, Boolean> BOOL_VALUES = new HashMap();
  
  static  {
    BOOL_VALUES.put("true", Boolean.TRUE);
    BOOL_VALUES.put("false", Boolean.FALSE);
  }
}
