package com.hazelcast.map.impl.record;

import com.hazelcast.nio.serialization.Data;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

class CachedDataRecord extends DataRecord {
  private static final AtomicReferenceFieldUpdater<CachedDataRecord, Object> CACHED_VALUE = AtomicReferenceFieldUpdater.newUpdater(CachedDataRecord.class, Object.class, "cachedValue");
  
  CachedDataRecord() {}
  
  CachedDataRecord(Data value) { super(value); }
  
  public void setValue(Data o) {
    super.setValue(o);
    this.cachedValue = null;
  }
  
  public Object getCachedValueUnsafe() { return this.cachedValue; }
  
  public boolean casCachedValue(Object expectedValue, Object newValue) { return CACHED_VALUE.compareAndSet(this, expectedValue, newValue); }
  
  public boolean equals(Object o) {
    if (this == o)
      return true; 
    if (o == null || getClass() != o.getClass())
      return false; 
    if (!super.equals(o))
      return false; 
    CachedDataRecord that = (CachedDataRecord)o;
    return (this.cachedValue != null) ? this.cachedValue.equals(that.cachedValue) : ((that.cachedValue == null) ? 1 : 0);
  }
  
  public int hashCode() {
    result = super.hashCode();
    return 31 * result + ((this.cachedValue != null) ? this.cachedValue.hashCode() : 0);
  }
}
