package com.hazelcast.map.impl;

import com.hazelcast.config.InMemoryFormat;
import com.hazelcast.internal.cluster.ClusterService;
import com.hazelcast.internal.nearcache.NearCache;
import com.hazelcast.logging.ILogger;
import com.hazelcast.map.impl.nearcache.MapNearCacheManager;
import com.hazelcast.map.impl.recordstore.RecordStore;
import com.hazelcast.monitor.LocalMapStats;
import com.hazelcast.monitor.LocalRecordStoreStats;
import com.hazelcast.monitor.NearCacheStats;
import com.hazelcast.monitor.impl.IndexesStats;
import com.hazelcast.monitor.impl.LocalMapStatsImpl;
import com.hazelcast.monitor.impl.OnDemandIndexStats;
import com.hazelcast.monitor.impl.PerIndexStats;
import com.hazelcast.nio.Address;
import com.hazelcast.query.impl.Indexes;
import com.hazelcast.query.impl.InternalIndex;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.ProxyService;
import com.hazelcast.spi.partition.IPartition;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.ExceptionUtil;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;

public class LocalMapStatsProvider {
  public static final LocalMapStats EMPTY_LOCAL_MAP_STATS = new LocalMapStatsImpl();
  
  private static final int RETRY_COUNT = 3;
  
  private static final int WAIT_PARTITION_TABLE_UPDATE_MILLIS = 100;
  
  private final ILogger logger;
  
  private final Address localAddress;
  
  private final NodeEngine nodeEngine;
  
  private final ClusterService clusterService;
  
  private final MapServiceContext mapServiceContext;
  
  private final MapNearCacheManager mapNearCacheManager;
  
  private final IPartitionService partitionService;
  
  private final ConcurrentMap<String, LocalMapStatsImpl> statsMap;
  
  private final ConstructorFunction<String, LocalMapStatsImpl> constructorFunction;
  
  public LocalMapStatsProvider(MapServiceContext mapServiceContext) {
    this.statsMap = new ConcurrentHashMap(1000);
    this.constructorFunction = new Object(this);
    this.mapServiceContext = mapServiceContext;
    this.nodeEngine = mapServiceContext.getNodeEngine();
    this.logger = this.nodeEngine.getLogger(getClass());
    this.mapNearCacheManager = mapServiceContext.getMapNearCacheManager();
    this.clusterService = this.nodeEngine.getClusterService();
    this.partitionService = this.nodeEngine.getPartitionService();
    this.localAddress = this.clusterService.getThisAddress();
  }
  
  protected MapServiceContext getMapServiceContext() { return this.mapServiceContext; }
  
  public LocalMapStatsImpl getLocalMapStatsImpl(String name) { return (LocalMapStatsImpl)ConcurrencyUtil.getOrPutIfAbsent(this.statsMap, name, this.constructorFunction); }
  
  public void destroyLocalMapStatsImpl(String name) { this.statsMap.remove(name); }
  
  public LocalMapStatsImpl createLocalMapStats(String mapName) {
    LocalMapStatsImpl stats = getLocalMapStatsImpl(mapName);
    LocalMapOnDemandCalculatedStats onDemandStats = new LocalMapOnDemandCalculatedStats();
    addNearCacheStats(mapName, stats, onDemandStats);
    addIndexStats(mapName, stats);
    updateMapOnDemandStats(mapName, onDemandStats);
    return onDemandStats.updateAndGet(stats);
  }
  
  public Map<String, LocalMapStats> createAllLocalMapStats() {
    Map statsPerMap = new HashMap();
    PartitionContainer[] partitionContainers = this.mapServiceContext.getPartitionContainers();
    for (PartitionContainer partitionContainer : partitionContainers) {
      Collection<RecordStore> allRecordStores = partitionContainer.getAllRecordStores();
      for (RecordStore recordStore : allRecordStores) {
        if (!isStatsCalculationEnabledFor(recordStore))
          continue; 
        IPartition partition = this.partitionService.getPartition(partitionContainer.getPartitionId(), false);
        if (partition.isLocal()) {
          addPrimaryStatsOf(recordStore, getOrCreateOnDemandStats(statsPerMap, recordStore));
          continue;
        } 
        addReplicaStatsOf(recordStore, getOrCreateOnDemandStats(statsPerMap, recordStore));
      } 
    } 
    for (Object object : statsPerMap.entrySet()) {
      Map.Entry entry = (Map.Entry)object;
      String mapName = (String)entry.getKey();
      LocalMapStatsImpl existingStats = getLocalMapStatsImpl(mapName);
      LocalMapOnDemandCalculatedStats onDemand = (LocalMapOnDemandCalculatedStats)entry.getValue();
      addNearCacheStats(mapName, existingStats, onDemand);
      addIndexStats(mapName, existingStats);
      addStructureStats(mapName, onDemand);
      LocalMapStatsImpl updatedStats = onDemand.updateAndGet(existingStats);
      entry.setValue(updatedStats);
    } 
    addStatsOfNoDataIncludedMaps(statsPerMap);
    return statsPerMap;
  }
  
  private void addStatsOfNoDataIncludedMaps(Map statsPerMap) {
    ProxyService proxyService = this.nodeEngine.getProxyService();
    Collection<String> mapNames = proxyService.getDistributedObjectNames("hz:impl:mapService");
    for (String mapName : mapNames) {
      if (!statsPerMap.containsKey(mapName))
        statsPerMap.put(mapName, EMPTY_LOCAL_MAP_STATS); 
    } 
  }
  
  private static boolean isStatsCalculationEnabledFor(RecordStore recordStore) { return recordStore.getMapContainer().getMapConfig().isStatisticsEnabled(); }
  
  private static LocalMapOnDemandCalculatedStats getOrCreateOnDemandStats(Map<String, Object> onDemandStats, RecordStore recordStore) {
    String mapName = recordStore.getName();
    Object stats = onDemandStats.get(mapName);
    if (stats == null) {
      stats = new LocalMapOnDemandCalculatedStats();
      onDemandStats.put(mapName, stats);
    } 
    return (LocalMapOnDemandCalculatedStats)stats;
  }
  
  private void updateMapOnDemandStats(String mapName, LocalMapOnDemandCalculatedStats onDemandStats) {
    PartitionContainer[] partitionContainers = this.mapServiceContext.getPartitionContainers();
    for (PartitionContainer partitionContainer : partitionContainers) {
      IPartition partition = this.partitionService.getPartition(partitionContainer.getPartitionId());
      if (partition.isLocal()) {
        addPrimaryStatsOf(partitionContainer.getExistingRecordStore(mapName), onDemandStats);
      } else {
        addReplicaStatsOf(partitionContainer.getExistingRecordStore(mapName), onDemandStats);
      } 
    } 
    addStructureStats(mapName, onDemandStats);
  }
  
  protected void addStructureStats(String mapName, LocalMapOnDemandCalculatedStats onDemandStats) {}
  
  private static void addPrimaryStatsOf(RecordStore recordStore, LocalMapOnDemandCalculatedStats onDemandStats) {
    if (recordStore != null)
      onDemandStats.incrementLockedEntryCount(recordStore.getLockedEntryCount()); 
    if (!hasRecords(recordStore))
      return; 
    LocalRecordStoreStats stats = recordStore.getLocalRecordStoreStats();
    onDemandStats.incrementHits(stats.getHits());
    onDemandStats.incrementDirtyEntryCount(recordStore.getMapDataStore().notFinishedOperationsCount());
    onDemandStats.incrementOwnedEntryMemoryCost(recordStore.getOwnedEntryCost());
    if (InMemoryFormat.NATIVE != recordStore.getMapContainer().getMapConfig().getInMemoryFormat())
      onDemandStats.incrementHeapCost(recordStore.getOwnedEntryCost()); 
    onDemandStats.incrementOwnedEntryCount(recordStore.size());
    onDemandStats.setLastAccessTime(stats.getLastAccessTime());
    onDemandStats.setLastUpdateTime(stats.getLastUpdateTime());
    onDemandStats.setBackupCount(recordStore.getMapContainer().getMapConfig().getTotalBackupCount());
  }
  
  private void addReplicaStatsOf(RecordStore recordStore, LocalMapOnDemandCalculatedStats onDemandStats) {
    if (!hasRecords(recordStore))
      return; 
    long backupEntryCount = 0L;
    long backupEntryMemoryCost = 0L;
    int totalBackupCount = recordStore.getMapContainer().getTotalBackupCount();
    for (int replicaNumber = 1; replicaNumber <= totalBackupCount; replicaNumber++) {
      int partitionId = recordStore.getPartitionId();
      Address replicaAddress = getReplicaAddress(partitionId, replicaNumber, totalBackupCount);
      if (!isReplicaAvailable(replicaAddress, totalBackupCount)) {
        printWarning(partitionId, replicaNumber);
      } else if (isReplicaOnThisNode(replicaAddress)) {
        backupEntryMemoryCost += recordStore.getOwnedEntryCost();
        backupEntryCount += recordStore.size();
      } 
    } 
    if (InMemoryFormat.NATIVE != recordStore.getMapContainer().getMapConfig().getInMemoryFormat())
      onDemandStats.incrementHeapCost(backupEntryMemoryCost); 
    onDemandStats.incrementBackupEntryMemoryCost(backupEntryMemoryCost);
    onDemandStats.incrementBackupEntryCount(backupEntryCount);
    onDemandStats.setBackupCount(recordStore.getMapContainer().getMapConfig().getTotalBackupCount());
  }
  
  private static boolean hasRecords(RecordStore recordStore) { return (recordStore != null && recordStore.size() > 0); }
  
  private boolean isReplicaAvailable(Address replicaAddress, int backupCount) { return (replicaAddress != null || this.partitionService.getMaxAllowedBackupCount() < backupCount); }
  
  private boolean isReplicaOnThisNode(Address replicaAddress) { return (replicaAddress != null && this.localAddress.equals(replicaAddress)); }
  
  private void printWarning(int partitionId, int replica) { this.logger.warning("partitionId: " + partitionId + ", replica: " + replica + " has no owner!"); }
  
  private Address getReplicaAddress(int partitionId, int replicaNumber, int backupCount) {
    IPartition partition = this.partitionService.getPartition(partitionId);
    Address replicaAddress = partition.getReplicaAddress(replicaNumber);
    if (replicaAddress == null)
      replicaAddress = waitForReplicaAddress(replicaNumber, partition, backupCount); 
    return replicaAddress;
  }
  
  private Address waitForReplicaAddress(int replica, IPartition partition, int backupCount) {
    int tryCount = 3;
    Address replicaAddress = null;
    while (replicaAddress == null && this.partitionService.getMaxAllowedBackupCount() >= backupCount && tryCount-- > 0) {
      sleep();
      replicaAddress = partition.getReplicaAddress(replica);
    } 
    return replicaAddress;
  }
  
  private static void sleep() {
    try {
      TimeUnit.MILLISECONDS.sleep(100L);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw ExceptionUtil.rethrow(e);
    } 
  }
  
  private void addNearCacheStats(String mapName, LocalMapStatsImpl localMapStats, LocalMapOnDemandCalculatedStats onDemandStats) {
    NearCache nearCache = this.mapNearCacheManager.getNearCache(mapName);
    if (nearCache == null)
      return; 
    NearCacheStats nearCacheStats = nearCache.getNearCacheStats();
    localMapStats.setNearCacheStats(nearCacheStats);
    onDemandStats.incrementHeapCost(nearCacheStats.getOwnedEntryMemoryCost());
  }
  
  private void addIndexStats(String mapName, LocalMapStatsImpl localMapStats) {
    MapContainer mapContainer = this.mapServiceContext.getMapContainer(mapName);
    Indexes globalIndexes = mapContainer.getIndexes();
    Map<String, OnDemandIndexStats> freshStats = null;
    if (globalIndexes != null) {
      assert globalIndexes.isGlobal();
      localMapStats.setQueryCount(globalIndexes.getIndexesStats().getQueryCount());
      localMapStats.setIndexedQueryCount(globalIndexes.getIndexesStats().getIndexedQueryCount());
      freshStats = aggregateFreshIndexStats(globalIndexes.getIndexes(), null);
      finalizeFreshIndexStats(freshStats);
    } else {
      long queryCount = 0L;
      long indexedQueryCount = 0L;
      PartitionContainer[] partitionContainers = this.mapServiceContext.getPartitionContainers();
      for (PartitionContainer partitionContainer : partitionContainers) {
        IPartition partition = this.partitionService.getPartition(partitionContainer.getPartitionId());
        if (partition.isLocal()) {
          Indexes partitionIndexes = (Indexes)partitionContainer.getIndexes().get(mapName);
          if (partitionIndexes != null) {
            assert !partitionIndexes.isGlobal();
            IndexesStats indexesStats = partitionIndexes.getIndexesStats();
            queryCount = Math.max(queryCount, indexesStats.getQueryCount());
            indexedQueryCount = Math.max(indexedQueryCount, indexesStats.getIndexedQueryCount());
            freshStats = aggregateFreshIndexStats(partitionIndexes.getIndexes(), freshStats);
          } 
        } 
      } 
      localMapStats.setQueryCount(queryCount);
      localMapStats.setIndexedQueryCount(indexedQueryCount);
      finalizeFreshIndexStats(freshStats);
    } 
    localMapStats.updateIndexStats(freshStats);
  }
  
  private static Map<String, OnDemandIndexStats> aggregateFreshIndexStats(InternalIndex[] freshIndexes, Map<String, OnDemandIndexStats> freshStats) {
    if (freshIndexes.length > 0 && freshStats == null)
      freshStats = new HashMap<String, OnDemandIndexStats>(); 
    for (InternalIndex index : freshIndexes) {
      String indexName = index.getName();
      OnDemandIndexStats freshIndexStats = (OnDemandIndexStats)freshStats.get(indexName);
      if (freshIndexStats == null) {
        freshIndexStats = new OnDemandIndexStats();
        freshIndexStats.setCreationTime(Float.MAX_VALUE);
        freshStats.put(indexName, freshIndexStats);
      } 
      PerIndexStats indexStats = index.getPerIndexStats();
      freshIndexStats.setCreationTime(Math.min(freshIndexStats.getCreationTime(), indexStats.getCreationTime()));
      long hitCount = indexStats.getHitCount();
      freshIndexStats.setHitCount(Math.max(freshIndexStats.getHitCount(), hitCount));
      freshIndexStats.setQueryCount(Math.max(freshIndexStats.getQueryCount(), indexStats.getQueryCount()));
      freshIndexStats.setMemoryCost(freshIndexStats.getMemoryCost() + indexStats.getMemoryCost());
      freshIndexStats.setAverageHitSelectivity(freshIndexStats
          .getAverageHitSelectivity() + indexStats.getTotalNormalizedHitCardinality());
      freshIndexStats.setAverageHitLatency(freshIndexStats.getAverageHitLatency() + indexStats.getTotalHitLatency());
      freshIndexStats.setTotalHitCount(freshIndexStats.getTotalHitCount() + hitCount);
      freshIndexStats.setInsertCount(freshIndexStats.getInsertCount() + indexStats.getInsertCount());
      freshIndexStats.setTotalInsertLatency(freshIndexStats.getTotalInsertLatency() + indexStats.getTotalInsertLatency());
      freshIndexStats.setUpdateCount(freshIndexStats.getUpdateCount() + indexStats.getUpdateCount());
      freshIndexStats.setTotalUpdateLatency(freshIndexStats.getTotalUpdateLatency() + indexStats.getTotalUpdateLatency());
      freshIndexStats.setRemoveCount(freshIndexStats.getRemoveCount() + indexStats.getRemoveCount());
      freshIndexStats.setTotalRemoveLatency(freshIndexStats.getTotalRemoveLatency() + indexStats.getTotalRemoveLatency());
    } 
    return freshStats;
  }
  
  private static void finalizeFreshIndexStats(Map<String, OnDemandIndexStats> freshStats) {
    if (freshStats == null)
      return; 
    for (OnDemandIndexStats freshIndexStats : freshStats.values()) {
      long totalHitCount = freshIndexStats.getTotalHitCount();
      if (totalHitCount != 0L) {
        double averageHitSelectivity = 1.0D - freshIndexStats.getAverageHitSelectivity() / totalHitCount;
        averageHitSelectivity = Math.max(0.0D, averageHitSelectivity);
        freshIndexStats.setAverageHitSelectivity(averageHitSelectivity);
        freshIndexStats.setAverageHitLatency(freshIndexStats.getAverageHitLatency() / totalHitCount);
      } 
    } 
  }
}
