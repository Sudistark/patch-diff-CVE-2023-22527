package com.hazelcast.map.impl;

import com.hazelcast.config.MapConfig;
import com.hazelcast.map.impl.record.Record;
import com.hazelcast.util.Preconditions;
import java.util.concurrent.TimeUnit;

public final class ExpirationTimeSetter {
  public static void setExpirationTime(Record record) {
    long expirationTime = calculateExpirationTime(record);
    record.setExpirationTime(expirationTime);
  }
  
  private static long calculateExpirationTime(Record record) {
    long ttl = checkedTime(record.getTtl());
    long ttlExpirationTime = sumForExpiration(ttl, getLifeStartTime(record));
    long maxIdle = checkedTime(record.getMaxIdle());
    long maxIdleExpirationTime = sumForExpiration(maxIdle, getIdlenessStartTime(record));
    return Math.min(ttlExpirationTime, maxIdleExpirationTime);
  }
  
  public static long getIdlenessStartTime(Record record) {
    long lastAccessTime = record.getLastAccessTime();
    return (lastAccessTime <= 0L) ? record.getCreationTime() : lastAccessTime;
  }
  
  public static long getLifeStartTime(Record record) {
    long lastUpdateTime = record.getLastUpdateTime();
    return (lastUpdateTime <= 0L) ? record.getCreationTime() : lastUpdateTime;
  }
  
  private static long checkedTime(long time) { return (time <= 0L) ? Float.MAX_VALUE : time; }
  
  private static long sumForExpiration(long criteriaTime, long now) {
    if (criteriaTime < 0L || now < 0L)
      throw new IllegalArgumentException("Parameters can not have negative values"); 
    if (criteriaTime == 0L)
      return Float.MAX_VALUE; 
    long expirationTime = criteriaTime + now;
    if (expirationTime < 0L)
      return Float.MAX_VALUE; 
    return expirationTime;
  }
  
  public static void setExpirationTimes(long operationTTLMillis, long operationMaxIdleMillis, Record record, MapConfig mapConfig, boolean consultMapConfig) {
    long ttlMillis = pickTTLMillis(operationTTLMillis, record.getTtl(), mapConfig, consultMapConfig);
    long maxIdleMillis = pickMaxIdleMillis(operationMaxIdleMillis, record.getMaxIdle(), mapConfig, consultMapConfig);
    record.setTtl(ttlMillis);
    record.setMaxIdle(maxIdleMillis);
    setExpirationTime(record);
  }
  
  private static long pickTTLMillis(long operationTTLMillis, long existingTTLMillis, MapConfig mapConfig, boolean consultMapConfig) {
    if (operationTTLMillis > 0L)
      return checkedTime(operationTTLMillis); 
    if (consultMapConfig && operationTTLMillis < 0L && mapConfig.getTimeToLiveSeconds() > 0)
      return checkedTime(TimeUnit.SECONDS.toMillis(mapConfig.getTimeToLiveSeconds())); 
    if (operationTTLMillis < 0L)
      return checkedTime(existingTTLMillis); 
    return Float.MAX_VALUE;
  }
  
  private static long pickMaxIdleMillis(long operationMaxIdleMillis, long existingMaxIdleMillis, MapConfig mapConfig, boolean entryCreated) {
    if (operationMaxIdleMillis > 0L)
      return checkedTime(operationMaxIdleMillis); 
    if (entryCreated && operationMaxIdleMillis < 0L && mapConfig.getMaxIdleSeconds() > 0)
      return checkedTime(TimeUnit.SECONDS.toMillis(mapConfig.getMaxIdleSeconds())); 
    if (operationMaxIdleMillis < 0L)
      return checkedTime(existingMaxIdleMillis); 
    return Float.MAX_VALUE;
  }
  
  public static long calculateExpirationWithDelay(long timeInMillis, long delayMillis, boolean backup) {
    Preconditions.checkNotNegative(timeInMillis, "timeInMillis can't be negative");
    if (backup) {
      long delayedTime = timeInMillis + delayMillis;
      if (delayedTime < 0L)
        return Float.MAX_VALUE; 
      return delayedTime;
    } 
    return timeInMillis;
  }
}
