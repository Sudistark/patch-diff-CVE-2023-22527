package com.hazelcast.map.impl.query;

import com.hazelcast.query.PagingPredicate;
import com.hazelcast.query.PagingPredicateAccessor;
import com.hazelcast.query.Predicate;
import com.hazelcast.query.impl.QueryableEntriesSegment;
import com.hazelcast.util.FutureUtil;
import com.hazelcast.util.executor.ManagedExecutorService;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class ParallelPartitionScanExecutor implements PartitionScanExecutor {
  private final PartitionScanRunner partitionScanRunner;
  
  private final ManagedExecutorService executor;
  
  private final int timeoutInMillis;
  
  public ParallelPartitionScanExecutor(PartitionScanRunner partitionScanRunner, ManagedExecutorService executor, int timeoutInMillis) {
    this.partitionScanRunner = partitionScanRunner;
    this.executor = executor;
    this.timeoutInMillis = timeoutInMillis;
  }
  
  public void execute(String mapName, Predicate predicate, Collection<Integer> partitions, Result result) {
    runUsingPartitionScanWithoutPaging(mapName, predicate, partitions, result);
    if (predicate instanceof PagingPredicate) {
      Map.Entry<Integer, Map.Entry> nearestAnchorEntry = PagingPredicateAccessor.getNearestAnchorEntry((PagingPredicate)predicate);
      result.orderAndLimit((PagingPredicate)predicate, nearestAnchorEntry);
    } 
  }
  
  public QueryableEntriesSegment execute(String mapName, Predicate predicate, int partitionId, int tableIndex, int fetchSize) { return this.partitionScanRunner.run(mapName, predicate, partitionId, tableIndex, fetchSize); }
  
  protected void runUsingPartitionScanWithoutPaging(String name, Predicate predicate, Collection<Integer> partitions, Result result) {
    List<Future<Result>> futures = new ArrayList<Future<Result>>(partitions.size());
    for (Integer partitionId : partitions) {
      Future<Result> future = runPartitionScanForPartition(name, predicate, partitionId.intValue(), result.createSubResult());
      futures.add(future);
    } 
    Collection<Result> subResults = waitForResult(futures, this.timeoutInMillis);
    for (Result subResult : subResults)
      result.combine(subResult); 
  }
  
  protected Future<Result> runPartitionScanForPartition(String name, Predicate predicate, int partitionId, Result result) {
    QueryPartitionCallable task = new QueryPartitionCallable(this, name, predicate, partitionId, result, null);
    return this.executor.submit(task);
  }
  
  private static Collection<Result> waitForResult(List<Future<Result>> lsFutures, int timeoutInMillis) { return FutureUtil.returnWithDeadline(lsFutures, timeoutInMillis, TimeUnit.MILLISECONDS, FutureUtil.RETHROW_EVERYTHING); }
}
