package com.hazelcast.map.impl.mapstore.writebehind;

import com.hazelcast.util.Preconditions;
import java.util.Collection;
import java.util.List;

class SynchronizedWriteBehindQueue<E> extends Object implements WriteBehindQueue<E> {
  private final WriteBehindQueue<E> queue;
  
  private final Object mutex;
  
  SynchronizedWriteBehindQueue(WriteBehindQueue<E> queue) {
    this.queue = (WriteBehindQueue)Preconditions.checkNotNull(queue, "queue can't be null");
    this.mutex = this;
  }
  
  public void addFirst(Collection<E> collection) {
    if (collection == null || collection.isEmpty())
      return; 
    synchronized (this.mutex) {
      this.queue.addFirst(collection);
    } 
  }
  
  public void addLast(E e) {
    synchronized (this.mutex) {
      this.queue.addLast(e);
    } 
  }
  
  public E peek() {
    synchronized (this.mutex) {
      return (E)this.queue.peek();
    } 
  }
  
  public boolean removeFirstOccurrence(E e) {
    synchronized (this.mutex) {
      return this.queue.removeFirstOccurrence(e);
    } 
  }
  
  public boolean contains(E e) {
    synchronized (this.mutex) {
      return this.queue.contains(e);
    } 
  }
  
  public int size() {
    synchronized (this.mutex) {
      return this.queue.size();
    } 
  }
  
  public void clear() {
    synchronized (this.mutex) {
      this.queue.clear();
    } 
  }
  
  public int drainTo(Collection<E> collection) {
    synchronized (this.mutex) {
      return this.queue.drainTo(collection);
    } 
  }
  
  public List<E> asList() {
    synchronized (this.mutex) {
      return this.queue.asList();
    } 
  }
  
  public void filter(IPredicate<E> predicate, Collection<E> collection) {
    synchronized (this.mutex) {
      this.queue.filter(predicate, collection);
    } 
  }
}
