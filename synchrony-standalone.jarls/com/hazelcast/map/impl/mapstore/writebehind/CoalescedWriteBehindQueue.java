package com.hazelcast.map.impl.mapstore.writebehind;

import com.hazelcast.map.impl.mapstore.writebehind.entry.DelayedEntry;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.util.CollectionUtil;
import com.hazelcast.util.MapUtil;
import com.hazelcast.util.Preconditions;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

class CoalescedWriteBehindQueue extends Object implements WriteBehindQueue<DelayedEntry> {
  private Map<Data, DelayedEntry> map = new LinkedHashMap();
  
  public void addFirst(Collection<DelayedEntry> collection) {
    if (CollectionUtil.isEmpty(collection))
      return; 
    int expectedCapacity = this.map.size() + collection.size();
    Map<Data, DelayedEntry> newMap = MapUtil.createLinkedHashMap(expectedCapacity);
    for (DelayedEntry next : collection)
      newMap.put((Data)next.getKey(), next); 
    newMap.putAll(this.map);
    this.map = newMap;
  }
  
  public void addLast(DelayedEntry delayedEntry) {
    if (delayedEntry == null)
      return; 
    calculateStoreTime(delayedEntry);
    Data key = (Data)delayedEntry.getKey();
    this.map.put(key, delayedEntry);
  }
  
  public DelayedEntry peek() {
    Collection<DelayedEntry> values = this.map.values();
    Iterator iterator = values.iterator();
    if (iterator.hasNext())
      return (DelayedEntry)iterator.next(); 
    return null;
  }
  
  public boolean removeFirstOccurrence(DelayedEntry incoming) {
    Data incomingKey = (Data)incoming.getKey();
    Object incomingValue = incoming.getValue();
    DelayedEntry current = (DelayedEntry)this.map.get(incomingKey);
    if (current == null)
      return false; 
    if (current.getSequence() > incoming.getSequence())
      return false; 
    Object currentValue = current.getValue();
    if ((incomingValue == null && currentValue == null) || (incomingValue != null && currentValue != null && incomingValue
      .equals(currentValue))) {
      this.map.remove(incomingKey);
      return true;
    } 
    return false;
  }
  
  public boolean contains(DelayedEntry entry) { return this.map.containsKey(entry.getKey()); }
  
  public int size() { return this.map.size(); }
  
  public void clear() { this.map.clear(); }
  
  public int drainTo(Collection<DelayedEntry> collection) {
    Preconditions.checkNotNull(collection, "collection can not be null");
    Collection<DelayedEntry> delayedEntries = this.map.values();
    for (DelayedEntry delayedEntry : delayedEntries)
      collection.add(delayedEntry); 
    this.map.clear();
    return collection.size();
  }
  
  public List<DelayedEntry> asList() {
    Collection<DelayedEntry> values = this.map.values();
    return Collections.unmodifiableList(new ArrayList(values));
  }
  
  public void filter(IPredicate<DelayedEntry> predicate, Collection<DelayedEntry> collection) {
    Collection<DelayedEntry> values = this.map.values();
    for (DelayedEntry e : values) {
      if (predicate.test(e))
        collection.add(e); 
    } 
  }
  
  private void calculateStoreTime(DelayedEntry delayedEntry) {
    Data key = (Data)delayedEntry.getKey();
    DelayedEntry currentEntry = (DelayedEntry)this.map.get(key);
    if (currentEntry != null) {
      long currentStoreTime = currentEntry.getStoreTime();
      delayedEntry.setStoreTime(currentStoreTime);
    } 
  }
}
