package com.hazelcast.map.impl.mapstore.writebehind;

import com.hazelcast.map.impl.mapstore.MapStoreContext;
import com.hazelcast.map.impl.mapstore.writebehind.entry.DelayedEntry;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.util.CollectionUtil;
import com.hazelcast.util.MapUtil;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

class DefaultWriteBehindProcessor extends AbstractWriteBehindProcessor<DelayedEntry> {
  private static final Comparator<DelayedEntry> DELAYED_ENTRY_COMPARATOR = new Object();
  
  private static final int RETRY_TIMES_OF_A_FAILED_STORE_OPERATION = 3;
  
  private static final int RETRY_STORE_AFTER_WAIT_SECONDS = 1;
  
  private final List<StoreListener> storeListeners;
  
  DefaultWriteBehindProcessor(MapStoreContext mapStoreContext) {
    super(mapStoreContext);
    this.storeListeners = new ArrayList(2);
  }
  
  public Map<Integer, List<DelayedEntry>> process(List<DelayedEntry> delayedEntries) {
    Map<Integer, List<DelayedEntry>> failMap;
    sort(delayedEntries);
    if (this.writeBatchSize > 1) {
      failMap = doStoreUsingBatchSize(delayedEntries);
    } else {
      failMap = processInternal(delayedEntries);
    } 
    return failMap;
  }
  
  private Map<Integer, List<DelayedEntry>> processInternal(List<DelayedEntry> delayedEntries) {
    if (delayedEntries == null || delayedEntries.isEmpty())
      return Collections.emptyMap(); 
    Map<Integer, List<DelayedEntry>> failuresByPartition = new HashMap<Integer, List<DelayedEntry>>();
    List<DelayedEntry> entriesToProcess = new ArrayList<DelayedEntry>();
    AbstractWriteBehindProcessor.StoreOperationType operationType = null;
    for (DelayedEntry<Data, Object> entry : delayedEntries) {
      AbstractWriteBehindProcessor.StoreOperationType previousOperationType = operationType;
      if (entry.getValue() == null) {
        operationType = AbstractWriteBehindProcessor.StoreOperationType.DELETE;
      } else {
        operationType = AbstractWriteBehindProcessor.StoreOperationType.WRITE;
      } 
      if (previousOperationType != null && !previousOperationType.equals(operationType)) {
        List<DelayedEntry> failures = callHandler(entriesToProcess, previousOperationType);
        addFailsTo(failuresByPartition, failures);
        entriesToProcess.clear();
      } 
      entriesToProcess.add(entry);
    } 
    List<DelayedEntry> failures = callHandler(entriesToProcess, operationType);
    addFailsTo(failuresByPartition, failures);
    entriesToProcess.clear();
    return failuresByPartition;
  }
  
  private void addFailsTo(Map<Integer, List<DelayedEntry>> failsPerPartition, List<DelayedEntry> fails) {
    if (fails == null || fails.isEmpty())
      return; 
    for (DelayedEntry entry : fails) {
      int partitionId = entry.getPartitionId();
      List<DelayedEntry> delayedEntriesPerPartition = (List)failsPerPartition.get(Integer.valueOf(partitionId));
      if (delayedEntriesPerPartition == null) {
        delayedEntriesPerPartition = new ArrayList<DelayedEntry>();
        failsPerPartition.put(Integer.valueOf(partitionId), delayedEntriesPerPartition);
      } 
      delayedEntriesPerPartition.add(entry);
    } 
  }
  
  private List<DelayedEntry> callHandler(Collection<DelayedEntry> delayedEntries, AbstractWriteBehindProcessor.StoreOperationType operationType) {
    int size = delayedEntries.size();
    if (size == 0)
      return Collections.emptyList(); 
    if (size == 1 || !this.writeCoalescing)
      return processEntriesOneByOne(delayedEntries, operationType); 
    DelayedEntry[] delayedEntriesArray = (DelayedEntry[])delayedEntries.toArray(new DelayedEntry[0]);
    Map<Object, DelayedEntry> batchMap = prepareBatchMap(delayedEntriesArray);
    if (batchMap.size() == 1) {
      DelayedEntry delayedEntry = delayedEntriesArray[delayedEntriesArray.length - 1];
      return callSingleStoreWithListeners(delayedEntry, operationType);
    } 
    List<DelayedEntry> failedEntryList = callBatchStoreWithListeners(batchMap, operationType);
    List<DelayedEntry> failedTries = new ArrayList<DelayedEntry>();
    for (DelayedEntry entry : failedEntryList) {
      Collection<DelayedEntry> tmpFails = callSingleStoreWithListeners(entry, operationType);
      failedTries.addAll(tmpFails);
    } 
    return failedTries;
  }
  
  private List<DelayedEntry> processEntriesOneByOne(Collection<DelayedEntry> delayedEntries, AbstractWriteBehindProcessor.StoreOperationType operationType) {
    List<DelayedEntry> totalFailures = null;
    for (DelayedEntry delayedEntry : delayedEntries) {
      List<DelayedEntry> failures = callSingleStoreWithListeners(delayedEntry, operationType);
      if (CollectionUtil.isNotEmpty(failures)) {
        if (totalFailures == null) {
          totalFailures = failures;
          continue;
        } 
        totalFailures.addAll(failures);
      } 
    } 
    return (totalFailures == null) ? Collections.EMPTY_LIST : totalFailures;
  }
  
  private Map prepareBatchMap(DelayedEntry[] delayedEntries) {
    int length = delayedEntries.length;
    Map<Object, DelayedEntry> batchMap = MapUtil.createHashMap(length);
    for (int i = length - 1; i >= 0; i--) {
      DelayedEntry delayedEntry = delayedEntries[i];
      Object key = delayedEntry.getKey();
      if (!batchMap.containsKey(key))
        batchMap.put(key, delayedEntry); 
    } 
    return batchMap;
  }
  
  private List<DelayedEntry> callSingleStoreWithListeners(DelayedEntry entry, AbstractWriteBehindProcessor.StoreOperationType operationType) { return retryCall(new Object(this, entry, operationType)); }
  
  private Map convertToObject(Map<Object, DelayedEntry> batchMap) {
    Map map = MapUtil.createHashMap(batchMap.size());
    for (DelayedEntry entry : batchMap.values()) {
      Object key = toObject(entry.getKey());
      Object value = toObject(entry.getValue());
      map.put(key, value);
    } 
    return map;
  }
  
  private List<DelayedEntry> callBatchStoreWithListeners(Map<Object, DelayedEntry> batchMap, AbstractWriteBehindProcessor.StoreOperationType operationType) { return retryCall(new Object(this, batchMap, operationType)); }
  
  private void callBeforeStoreListeners(DelayedEntry entry) {
    for (StoreListener listener : this.storeListeners)
      listener.beforeStore(StoreEvent.createStoreEvent(entry)); 
  }
  
  private void callAfterStoreListeners(DelayedEntry entry) {
    for (StoreListener listener : this.storeListeners)
      listener.afterStore(StoreEvent.createStoreEvent(entry)); 
  }
  
  public void callBeforeStoreListeners(Collection<DelayedEntry> entries) {
    for (DelayedEntry entry : entries)
      callBeforeStoreListeners(entry); 
  }
  
  public void addStoreListener(StoreListener listeners) { this.storeListeners.add(listeners); }
  
  public void flush(WriteBehindQueue queue) {
    int size = queue.size();
    if (size == 0)
      return; 
    List<DelayedEntry> delayedEntries = new ArrayList<DelayedEntry>(size);
    queue.drainTo(delayedEntries);
    flushInternal(delayedEntries);
  }
  
  public void flush(DelayedEntry entry) {
    List<DelayedEntry> entries = Collections.singletonList(entry);
    flushInternal(entries);
  }
  
  private void flushInternal(List<DelayedEntry> delayedEntries) {
    sort(delayedEntries);
    Map<Integer, List<DelayedEntry>> failedStoreOpPerPartition = process(delayedEntries);
    if (failedStoreOpPerPartition.size() > 0)
      printErrorLog(failedStoreOpPerPartition); 
  }
  
  private void printErrorLog(Map<Integer, List<DelayedEntry>> failsPerPartition) {
    int size = 0;
    Collection<List<DelayedEntry>> values = failsPerPartition.values();
    for (Collection<DelayedEntry> value : values)
      size += value.size(); 
    String logMessage = String.format("Map store flush operation can not be done for %d entries", new Object[] { Integer.valueOf(size) });
    this.logger.severe(logMessage);
  }
  
  public void callAfterStoreListeners(Collection<DelayedEntry> entries) {
    for (DelayedEntry entry : entries)
      callAfterStoreListeners(entry); 
  }
  
  private Map<Integer, List<DelayedEntry>> doStoreUsingBatchSize(List<DelayedEntry> sortedDelayedEntries) {
    Map<Integer, List<DelayedEntry>> failsPerPartition = new HashMap<Integer, List<DelayedEntry>>();
    int page = 0;
    List<DelayedEntry> delayedEntryList;
    while ((delayedEntryList = getBatchChunk(sortedDelayedEntries, this.writeBatchSize, page++)) != null) {
      Map<Integer, List<DelayedEntry>> fails = processInternal(delayedEntryList);
      Set<Map.Entry<Integer, List<DelayedEntry>>> entries = fails.entrySet();
      for (Map.Entry<Integer, List<DelayedEntry>> entry : entries)
        addFailsTo(failsPerPartition, (List)entry.getValue()); 
    } 
    return failsPerPartition;
  }
  
  private List<DelayedEntry> retryCall(RetryTask task) {
    boolean result = false;
    Exception exception = null;
    int k = 0;
    while (k < 3) {
      try {
        result = task.run();
      } catch (InterruptedException ex) {
        Thread.currentThread().interrupt();
        break;
      } catch (Exception ex) {
        exception = ex;
      } 
      if (!result) {
        sleepSeconds(1L);
        k++;
      } 
    } 
    if (k > 0 && 
      !result) {
      List failureList = task.failureList();
      this.logger.severe("Number of entries which could not be stored is = [" + failureList.size() + "], Hazelcast will indefinitely retry to store them", exception);
      return failureList;
    } 
    return Collections.emptyList();
  }
  
  private void sort(List<DelayedEntry> entries) {
    if (entries == null || entries.isEmpty())
      return; 
    Collections.sort(entries, DELAYED_ENTRY_COMPARATOR);
  }
  
  private void sleepSeconds(long secs) {
    try {
      TimeUnit.SECONDS.sleep(secs);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
    } 
  }
}
