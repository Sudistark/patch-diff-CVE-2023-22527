package com.hazelcast.map.impl.querycache.subscriber;

import com.hazelcast.core.EntryEventType;
import com.hazelcast.internal.serialization.InternalSerializationService;
import com.hazelcast.map.impl.querycache.accumulator.AccumulatorHandler;
import com.hazelcast.map.impl.querycache.event.QueryCacheEventData;
import com.hazelcast.nio.serialization.Data;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicReferenceArray;

class SubscriberAccumulatorHandler extends Object implements AccumulatorHandler<QueryCacheEventData> {
  private static final Queue<Integer> POLL_PERMIT = new ConcurrentLinkedQueue();
  
  private final int partitionCount;
  
  private final boolean includeValue;
  
  private final InternalQueryCache queryCache;
  
  private final InternalSerializationService serializationService;
  
  private final AtomicReferenceArray<Queue<Integer>> clearAllRemovedCountHolders;
  
  private final AtomicReferenceArray<Queue<Integer>> evictAllRemovedCountHolders;
  
  public SubscriberAccumulatorHandler(boolean includeValue, InternalQueryCache queryCache, InternalSerializationService serializationService) {
    this.includeValue = includeValue;
    this.queryCache = queryCache;
    this.serializationService = serializationService;
    this.partitionCount = ((DefaultQueryCache)queryCache).context.getPartitionCount();
    this.clearAllRemovedCountHolders = initRemovedCountHolders(this.partitionCount);
    this.evictAllRemovedCountHolders = initRemovedCountHolders(this.partitionCount);
  }
  
  public void reset() {
    this.queryCache.clear();
    for (int i = 0; i < this.partitionCount; i++) {
      this.clearAllRemovedCountHolders.set(i, new ConcurrentLinkedQueue());
      this.evictAllRemovedCountHolders.set(i, new ConcurrentLinkedQueue());
    } 
  }
  
  private static AtomicReferenceArray<Queue<Integer>> initRemovedCountHolders(int partitionCount) {
    AtomicReferenceArray<Queue<Integer>> removedCountHolders = new AtomicReferenceArray<Queue<Integer>>(partitionCount + 1);
    for (int i = 0; i < partitionCount; i++)
      removedCountHolders.set(i, new ConcurrentLinkedQueue()); 
    removedCountHolders.set(partitionCount, POLL_PERMIT);
    return removedCountHolders;
  }
  
  public void handle(QueryCacheEventData eventData, boolean ignored) {
    eventData.setSerializationService(this.serializationService);
    Data keyData = eventData.getDataKey();
    Data valueData = this.includeValue ? eventData.getDataNewValue() : null;
    int eventType = eventData.getEventType();
    EntryEventType entryEventType = EntryEventType.getByType(eventType);
    if (entryEventType == null)
      throwException(String.format("No matching EntryEventType found for event type id `%d`", new Object[] { Integer.valueOf(eventType) })); 
    switch (null.$SwitchMap$com$hazelcast$core$EntryEventType[entryEventType.ordinal()]) {
      case 1:
      case 2:
      case 3:
      case 4:
        this.queryCache.set(keyData, valueData, entryEventType);
        return;
      case 5:
      case 6:
        this.queryCache.delete(keyData, entryEventType);
        return;
      case 7:
        handleMapWideEvent(eventData, entryEventType, this.clearAllRemovedCountHolders);
        return;
      case 8:
        handleMapWideEvent(eventData, entryEventType, this.evictAllRemovedCountHolders);
        return;
    } 
    throwException(String.format("Unexpected EntryEventType was found: `%s`", new Object[] { entryEventType }));
  }
  
  private void handleMapWideEvent(QueryCacheEventData eventData, EntryEventType eventType, AtomicReferenceArray<Queue<Integer>> removedCountHolders) {
    int partitionId = eventData.getPartitionId();
    int removedCount = this.queryCache.removeEntriesOf(partitionId);
    tryPublishMapWideEvent(eventType, partitionId, removedCount, removedCountHolders);
  }
  
  private void tryPublishMapWideEvent(EntryEventType eventType, int partitionId, int removedEntryCount, AtomicReferenceArray<Queue<Integer>> removedCountHolders) {
    if (!EventPublisherHelper.hasListener(this.queryCache))
      return; 
    ((Queue)removedCountHolders.get(partitionId)).offer(Integer.valueOf(removedEntryCount));
    if (noMissingMapWideEvent(removedCountHolders) && removedCountHolders
      .compareAndSet(this.partitionCount, POLL_PERMIT, null))
      try {
        if (noMissingMapWideEvent(removedCountHolders)) {
          int totalRemovedCount = pollRemovedCountHolders(removedCountHolders);
          EventPublisherHelper.publishCacheWideEvent(this.queryCache, totalRemovedCount, eventType);
        } 
      } finally {
        removedCountHolders.set(this.partitionCount, POLL_PERMIT);
      }  
  }
  
  private boolean noMissingMapWideEvent(AtomicReferenceArray<Queue<Integer>> removedCountHolders) {
    for (int i = 0; i < this.partitionCount; i++) {
      if (((Queue)removedCountHolders.get(i)).isEmpty())
        return false; 
    } 
    return true;
  }
  
  private int pollRemovedCountHolders(AtomicReferenceArray<Queue<Integer>> removedCountHolders) {
    int count = 0;
    for (int i = 0; i < this.partitionCount; i++) {
      Queue<Integer> removalCounts = (Queue)removedCountHolders.get(i);
      count += ((Integer)removalCounts.poll()).intValue();
    } 
    return count;
  }
  
  private static void throwException(String msg) { throw new IllegalArgumentException(msg); }
}
