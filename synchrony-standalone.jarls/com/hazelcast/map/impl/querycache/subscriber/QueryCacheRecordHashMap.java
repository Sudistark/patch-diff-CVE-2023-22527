package com.hazelcast.map.impl.querycache.subscriber;

import com.hazelcast.internal.eviction.EvictionListener;
import com.hazelcast.internal.eviction.impl.strategy.sampling.SampleableEvictableStore;
import com.hazelcast.map.impl.querycache.subscriber.record.QueryCacheRecord;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.nio.serialization.SerializableByConvention;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.SampleableConcurrentHashMap;

@SerializableByConvention
public class QueryCacheRecordHashMap extends SampleableConcurrentHashMap<Data, QueryCacheRecord> implements SampleableEvictableStore<Data, QueryCacheRecord> {
  private final SerializationService serializationService;
  
  public QueryCacheRecordHashMap(SerializationService serializationService, int initialCapacity) {
    super(initialCapacity);
    this.serializationService = serializationService;
  }
  
  protected QueryCacheEvictableSamplingEntry createSamplingEntry(Data key, QueryCacheRecord value) { return new QueryCacheEvictableSamplingEntry(this, key, value); }
  
  public <C extends com.hazelcast.internal.eviction.EvictionCandidate<Data, QueryCacheRecord>> boolean tryEvict(C evictionCandidate, EvictionListener<Data, QueryCacheRecord> evictionListener) {
    if (evictionCandidate == null)
      return false; 
    if (remove(evictionCandidate.getAccessor()) == null)
      return false; 
    if (evictionListener != null)
      evictionListener.onEvict(evictionCandidate.getAccessor(), evictionCandidate.getEvictable(), false); 
    return true;
  }
  
  public Iterable<QueryCacheEvictableSamplingEntry> sample(int sampleCount) { return getRandomSamples(sampleCount); }
}
