package com.hazelcast.map.impl.querycache.subscriber;

import com.hazelcast.internal.serialization.InternalSerializationService;
import com.hazelcast.map.impl.querycache.QueryCacheContext;
import com.hazelcast.map.impl.querycache.accumulator.AccumulatorHandler;
import com.hazelcast.map.impl.querycache.accumulator.AccumulatorInfo;
import com.hazelcast.map.impl.querycache.accumulator.BasicAccumulator;
import com.hazelcast.map.impl.querycache.event.QueryCacheEventData;
import com.hazelcast.map.impl.querycache.event.sequence.DefaultSubscriberSequencerProvider;
import com.hazelcast.map.impl.querycache.event.sequence.Sequenced;
import com.hazelcast.map.impl.querycache.event.sequence.SubscriberSequencerProvider;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class SubscriberAccumulator extends BasicAccumulator<QueryCacheEventData> {
  private final SubscriberSequencerProvider sequenceProvider;
  
  private final ConcurrentMap<Integer, Long> brokenSequences = new ConcurrentHashMap();
  
  protected SubscriberAccumulator(QueryCacheContext context, AccumulatorInfo info) {
    super(context, info);
    this.sequenceProvider = new DefaultSubscriberSequencerProvider();
  }
  
  public void reset() {
    this.brokenSequences.clear();
    this.sequenceProvider.resetAll();
    super.reset();
  }
  
  ConcurrentMap<Integer, Long> getBrokenSequences() { return this.brokenSequences; }
  
  public void accumulate(QueryCacheEventData event) {
    if (isApplicable(event))
      addQueryCache(event); 
  }
  
  private boolean isApplicable(QueryCacheEventData event) {
    if (!getInfo().isPublishable())
      return false; 
    int partitionId = event.getPartitionId();
    if (isEndEvent(event)) {
      this.sequenceProvider.reset(partitionId);
      removeFromBrokenSequences(event);
      return false;
    } 
    if (isNextEvent(event)) {
      long currentSequence = this.sequenceProvider.getSequence(partitionId);
      this.sequenceProvider.compareAndSetSequence(currentSequence, event.getSequence(), partitionId);
      removeFromBrokenSequences(event);
      return true;
    } 
    handleUnexpectedEvent(event);
    return false;
  }
  
  private void handleUnexpectedEvent(QueryCacheEventData event) {
    int partitionId = event.getPartitionId();
    long sequence = event.getSequence();
    Long prev = (Long)this.brokenSequences.putIfAbsent(Integer.valueOf(partitionId), Long.valueOf(sequence));
    if (prev != null)
      return; 
    InternalQueryCache queryCache = getQueryCache();
    if (queryCache != null) {
      if (this.logger.isWarningEnabled()) {
        long currentSequence = this.sequenceProvider.getSequence(partitionId);
        this.logger.warning(String.format("Event lost detected for queryCache=`%s`: partitionId=%d, expectedSequence=%d, foundSequence=%d, cacheSize=%d", new Object[] { queryCache

                
                .getCacheId(), Integer.valueOf(partitionId), 
                Long.valueOf(currentSequence + 1L), Long.valueOf(sequence), Integer.valueOf(queryCache.size()) }));
      } 
      EventPublisherHelper.publishEventLost(this.context, this.info.getMapName(), this.info.getCacheId(), event
          .getPartitionId(), queryCache.getExtractors());
    } 
  }
  
  private void removeFromBrokenSequences(QueryCacheEventData event) {
    if (this.brokenSequences.isEmpty())
      return; 
    int partitionId = event.getPartitionId();
    long sequence = event.getSequence();
    if (sequence == -1L) {
      this.brokenSequences.remove(Integer.valueOf(partitionId));
    } else {
      Long expected = (Long)this.brokenSequences.get(Integer.valueOf(partitionId));
      if (expected != null && expected.longValue() == event.getSequence())
        this.brokenSequences.remove(Integer.valueOf(partitionId)); 
    } 
    if (this.logger.isFinestEnabled())
      this.logger.finest(String.format("Size of broken sequences=%d", new Object[] { Integer.valueOf(this.brokenSequences.size()) })); 
  }
  
  protected boolean isNextEvent(Sequenced event) {
    int partitionId = event.getPartitionId();
    long currentSequence = this.sequenceProvider.getSequence(partitionId);
    long foundSequence = event.getSequence();
    long expectedSequence = currentSequence + 1L;
    return (foundSequence == expectedSequence);
  }
  
  private InternalQueryCache getQueryCache() {
    AccumulatorInfo info = getInfo();
    String cacheId = info.getCacheId();
    SubscriberContext subscriberContext = this.context.getSubscriberContext();
    QueryCacheFactory queryCacheFactory = subscriberContext.getQueryCacheFactory();
    return queryCacheFactory.getOrNull(cacheId);
  }
  
  protected AccumulatorHandler<QueryCacheEventData> createAccumulatorHandler(QueryCacheContext context, AccumulatorInfo info) {
    boolean includeValue = info.isIncludeValue();
    InternalQueryCache queryCache = getQueryCache();
    InternalSerializationService serializationService = context.getSerializationService();
    return new SubscriberAccumulatorHandler(includeValue, queryCache, serializationService);
  }
  
  private void addQueryCache(QueryCacheEventData eventData) { this.handler.handle(eventData, false); }
  
  private boolean isEndEvent(QueryCacheEventData event) { return (event.getSequence() == -1L); }
}
