package com.hazelcast.map.impl.querycache.subscriber;

import com.hazelcast.internal.serialization.InternalSerializationService;
import com.hazelcast.map.EventLostEvent;
import com.hazelcast.map.impl.EntryEventFilter;
import com.hazelcast.map.impl.ListenerAdapter;
import com.hazelcast.map.impl.MapServiceContext;
import com.hazelcast.map.impl.event.EventData;
import com.hazelcast.map.impl.querycache.ListenerRegistrationHelper;
import com.hazelcast.map.impl.querycache.QueryCacheEventService;
import com.hazelcast.map.impl.querycache.event.LocalEntryEventData;
import com.hazelcast.map.listener.MapListener;
import com.hazelcast.nio.IOUtil;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.query.impl.QueryEntry;
import com.hazelcast.query.impl.getters.Extractors;
import com.hazelcast.spi.EventFilter;
import com.hazelcast.spi.EventRegistration;
import com.hazelcast.spi.EventService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.impl.eventservice.impl.Registration;
import com.hazelcast.spi.impl.eventservice.impl.TrueEventFilter;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.ContextMutexFactory;
import com.hazelcast.util.Preconditions;
import java.util.Collection;

public class NodeQueryCacheEventService extends Object implements QueryCacheEventService<EventData> {
  private final EventService eventService;
  
  private final ContextMutexFactory mutexFactory;
  
  private final MapServiceContext mapServiceContext;
  
  public NodeQueryCacheEventService(MapServiceContext mapServiceContext, ContextMutexFactory mutexFactory) {
    this.mapServiceContext = mapServiceContext;
    NodeEngine nodeEngine = mapServiceContext.getNodeEngine();
    this.eventService = nodeEngine.getEventService();
    this.mutexFactory = mutexFactory;
  }
  
  public void publish(String mapName, String cacheId, EventData eventData, int orderKey, Extractors extractors) {
    Preconditions.checkHasText(mapName, "mapName");
    Preconditions.checkHasText(cacheId, "cacheId");
    Preconditions.checkNotNull(eventData, "eventData cannot be null");
    publishLocalEvent(mapName, cacheId, eventData, extractors);
  }
  
  public String addListener(String mapName, String cacheId, MapListener listener) { return addListener(mapName, cacheId, listener, null); }
  
  public String addPublisherListener(String mapName, String cacheId, ListenerAdapter listenerAdapter) {
    String listenerName = ListenerRegistrationHelper.generateListenerName(mapName, cacheId);
    return this.mapServiceContext.addListenerAdapter(listenerAdapter, TrueEventFilter.INSTANCE, listenerName);
  }
  
  public boolean removePublisherListener(String mapName, String cacheId, String listenerId) {
    String listenerName = ListenerRegistrationHelper.generateListenerName(mapName, cacheId);
    return this.mapServiceContext.removeEventListener(listenerName, listenerId);
  }
  
  public String addListener(String mapName, String cacheId, MapListener listener, EventFilter filter) {
    Preconditions.checkHasText(mapName, "mapName");
    Preconditions.checkHasText(cacheId, "cacheId");
    Preconditions.checkNotNull(listener, "listener cannot be null");
    ListenerAdapter queryCacheListenerAdaptor = QueryCacheEventListenerAdapters.createQueryCacheListenerAdaptor(listener);
    simpleQueryCacheListenerAdapter = new SimpleQueryCacheListenerAdapter(queryCacheListenerAdaptor);
    listenerName = ListenerRegistrationHelper.generateListenerName(mapName, cacheId);
    mutex = this.mutexFactory.mutexFor(mapName);
    try {
    
    } finally {
      IOUtil.closeResource(mutex);
    } 
  }
  
  public boolean removeListener(String mapName, String cacheId, String listenerId) {
    String listenerName = ListenerRegistrationHelper.generateListenerName(mapName, cacheId);
    return this.eventService.deregisterListener("hz:impl:mapService", listenerName, listenerId);
  }
  
  public void removeAllListeners(String mapName, String cacheId) {
    String listenerName = ListenerRegistrationHelper.generateListenerName(mapName, cacheId);
    mutex = this.mutexFactory.mutexFor(mapName);
    try {
      synchronized (mutex) {
        this.eventService.deregisterAllListeners("hz:impl:mapService", listenerName);
      } 
    } finally {
      IOUtil.closeResource(mutex);
    } 
  }
  
  public boolean hasListener(String mapName, String cacheId) {
    String listenerName = ListenerRegistrationHelper.generateListenerName(mapName, cacheId);
    Collection<EventRegistration> eventRegistrations = getRegistrations(listenerName);
    if (eventRegistrations.isEmpty())
      return false; 
    for (EventRegistration eventRegistration : eventRegistrations) {
      Registration registration = (Registration)eventRegistration;
      Object listener = registration.getListener();
      if (listener instanceof com.hazelcast.map.impl.querycache.QueryCacheListenerAdapter)
        return true; 
    } 
    return false;
  }
  
  private void publishLocalEvent(String mapName, String cacheId, Object eventData, Extractors extractors) {
    String listenerName = ListenerRegistrationHelper.generateListenerName(mapName, cacheId);
    Collection<EventRegistration> eventRegistrations = getRegistrations(listenerName);
    if (eventRegistrations.isEmpty())
      return; 
    for (EventRegistration eventRegistration : eventRegistrations) {
      Registration registration = (Registration)eventRegistration;
      Object listener = registration.getListener();
      if (!(listener instanceof com.hazelcast.map.impl.querycache.QueryCacheListenerAdapter))
        continue; 
      Object eventDataToPublish = eventData;
      int orderKey = -1;
      if (eventDataToPublish instanceof com.hazelcast.map.impl.querycache.event.LocalCacheWideEventData) {
        orderKey = listenerName.hashCode();
      } else if (eventDataToPublish instanceof LocalEntryEventData) {
        LocalEntryEventData localEntryEventData = (LocalEntryEventData)eventDataToPublish;
        if (localEntryEventData.getEventType() != EventLostEvent.EVENT_TYPE) {
          EventFilter filter = registration.getFilter();
          if (!canPassFilter(localEntryEventData, filter, extractors))
            continue; 
          boolean includeValue = isIncludeValue(filter);
          eventDataToPublish = includeValue ? localEntryEventData : localEntryEventData.cloneWithoutValue();
          Data keyData = localEntryEventData.getKeyData();
          orderKey = (keyData == null) ? -1 : keyData.hashCode();
        } 
      } 
      publishEventInternal(registration, eventDataToPublish, orderKey);
    } 
  }
  
  private boolean canPassFilter(LocalEntryEventData localEntryEventData, EventFilter filter, Extractors extractors) {
    if (filter == null || filter instanceof TrueEventFilter)
      return true; 
    NodeEngine nodeEngine = this.mapServiceContext.getNodeEngine();
    SerializationService serializationService = nodeEngine.getSerializationService();
    Data keyData = localEntryEventData.getKeyData();
    Object value = getValueOrOldValue(localEntryEventData);
    QueryEntry queryEntry = new QueryEntry((InternalSerializationService)serializationService, keyData, value, extractors);
    return filter.eval(queryEntry);
  }
  
  private boolean isIncludeValue(EventFilter filter) {
    if (filter instanceof EntryEventFilter)
      return ((EntryEventFilter)filter).isIncludeValue(); 
    return true;
  }
  
  private Object getValueOrOldValue(LocalEntryEventData localEntryEventData) {
    Object value = localEntryEventData.getValue();
    return (value != null) ? value : localEntryEventData.getOldValue();
  }
  
  private Collection<EventRegistration> getRegistrations(String mapName) { return this.eventService.getRegistrations("hz:impl:mapService", mapName); }
  
  private void publishEventInternal(EventRegistration registration, Object eventData, int orderKey) { this.eventService.publishEvent("hz:impl:mapService", registration, eventData, orderKey); }
  
  public void sendEventToSubscriber(String name, Object eventData, int orderKey) {
    Collection<EventRegistration> eventRegistrations = getRegistrations(name);
    if (eventRegistrations.isEmpty())
      return; 
    for (EventRegistration eventRegistration : eventRegistrations) {
      Registration registration = (Registration)eventRegistration;
      Object listener = registration.getListener();
      if (listener instanceof com.hazelcast.map.impl.querycache.QueryCacheListenerAdapter)
        continue; 
      publishEventInternal(registration, eventData, orderKey);
    } 
  }
}
