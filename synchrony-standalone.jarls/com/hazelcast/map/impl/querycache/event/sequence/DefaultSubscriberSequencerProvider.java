package com.hazelcast.map.impl.querycache.event.sequence;

import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class DefaultSubscriberSequencerProvider implements SubscriberSequencerProvider {
  private static final ConstructorFunction<Integer, PartitionSequencer> PARTITION_SEQUENCER_CONSTRUCTOR = new Object();
  
  private final ConcurrentMap<Integer, PartitionSequencer> partitionSequences = new ConcurrentHashMap();
  
  public boolean compareAndSetSequence(long expect, long update, int partitionId) {
    PartitionSequencer sequence = getOrCreateSequence(partitionId);
    return sequence.compareAndSetSequence(expect, update);
  }
  
  public long getSequence(int partitionId) {
    PartitionSequencer sequence = getOrCreateSequence(partitionId);
    return sequence.getSequence();
  }
  
  public void reset(int partitionId) {
    PartitionSequencer sequence = getOrCreateSequence(partitionId);
    sequence.reset();
  }
  
  public void resetAll() {
    for (PartitionSequencer partitionSequencer : this.partitionSequences.values())
      partitionSequencer.reset(); 
  }
  
  private PartitionSequencer getOrCreateSequence(int partitionId) { return (PartitionSequencer)ConcurrencyUtil.getOrPutIfAbsent(this.partitionSequences, Integer.valueOf(partitionId), PARTITION_SEQUENCER_CONSTRUCTOR); }
}
