package com.hazelcast.map.impl.querycache.accumulator;

import com.hazelcast.map.impl.querycache.event.sequence.Sequenced;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.QuickMath;
import java.util.concurrent.atomic.AtomicLong;

public class DefaultCyclicBuffer<E extends Sequenced> extends Object implements CyclicBuffer<E> {
  private static final long UNAVAILABLE = -1L;
  
  private int capacity;
  
  private E[] buffer;
  
  private AtomicLong headSequence;
  
  private AtomicLong tailSequence;
  
  public DefaultCyclicBuffer(int capacity) throws IllegalArgumentException {
    Preconditions.checkPositive(capacity, "capacity");
    init(capacity);
  }
  
  private void init(int maxSize) throws IllegalArgumentException {
    this.capacity = QuickMath.nextPowerOfTwo(maxSize);
    this.buffer = (Sequenced[])new Sequenced[this.capacity];
    this.tailSequence = new AtomicLong(-1L);
    this.headSequence = new AtomicLong(-1L);
  }
  
  public void add(E event) {
    Preconditions.checkNotNull(event, "event cannot be null");
    long sequence = event.getSequence();
    int tailIndex = findIndex(sequence);
    this.buffer[tailIndex] = event;
    this.tailSequence.set(sequence);
    long head = this.headSequence.get();
    if (head == -1L) {
      this.headSequence.set(sequence);
    } else if (head != sequence) {
      int headIndex = findIndex(head);
      if (headIndex == tailIndex) {
        if (++headIndex == this.capacity)
          headIndex = 0; 
        E e = (E)this.buffer[headIndex];
        if (e != null) {
          this.headSequence.set(e.getSequence());
        } else {
          this.headSequence.incrementAndGet();
        } 
      } 
    } 
  }
  
  public E get(long sequence) {
    Preconditions.checkPositive(sequence, "sequence");
    int index = findIndex(sequence);
    E e = (E)this.buffer[index];
    if (e != null && e.getSequence() != sequence)
      return null; 
    return e;
  }
  
  public boolean setHead(long sequence) {
    Preconditions.checkPositive(sequence, "sequence");
    E e = (E)get(sequence);
    if (e == null)
      return false; 
    this.headSequence.set(sequence);
    return true;
  }
  
  public E getAndAdvance() {
    long head = this.headSequence.get();
    long tail = this.tailSequence.get();
    if (tail == -1L || head > tail)
      return null; 
    int headIndex = findIndex(head);
    E e = (E)this.buffer[headIndex];
    if (e == null)
      return null; 
    this.headSequence.incrementAndGet();
    return e;
  }
  
  public void reset() { init(this.capacity); }
  
  public int size() {
    long head = this.headSequence.get();
    long tail = this.tailSequence.get();
    if (tail == -1L)
      return 0; 
    int avail = (int)(tail - head + 1L);
    if (avail <= this.capacity)
      return avail; 
    return this.capacity;
  }
  
  public long getHeadSequence() { return this.headSequence.get(); }
  
  private int findIndex(long sequence) { return (int)(sequence % this.capacity); }
}
