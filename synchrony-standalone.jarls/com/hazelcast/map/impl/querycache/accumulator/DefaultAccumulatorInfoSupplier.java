package com.hazelcast.map.impl.querycache.accumulator;

import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class DefaultAccumulatorInfoSupplier implements AccumulatorInfoSupplier {
  private static final ConstructorFunction<String, ConcurrentMap<String, AccumulatorInfo>> INFO_CTOR = new Object();
  
  private final ConcurrentMap<String, ConcurrentMap<String, AccumulatorInfo>> cacheInfoPerMap = new ConcurrentHashMap();
  
  public AccumulatorInfo getAccumulatorInfoOrNull(String mapName, String cacheId) {
    ConcurrentMap<String, AccumulatorInfo> cacheToInfoMap = (ConcurrentMap)this.cacheInfoPerMap.get(mapName);
    if (cacheToInfoMap == null)
      return null; 
    return (AccumulatorInfo)cacheToInfoMap.get(cacheId);
  }
  
  public void putIfAbsent(String mapName, String cacheId, AccumulatorInfo info) {
    ConcurrentMap<String, AccumulatorInfo> cacheToInfoMap = (ConcurrentMap)ConcurrencyUtil.getOrPutIfAbsent(this.cacheInfoPerMap, mapName, INFO_CTOR);
    cacheToInfoMap.putIfAbsent(cacheId, info);
  }
  
  public void remove(String mapName, String cacheId) {
    ConcurrentMap<String, AccumulatorInfo> cacheToInfoMap = (ConcurrentMap)this.cacheInfoPerMap.get(mapName);
    if (cacheToInfoMap == null)
      return; 
    cacheToInfoMap.remove(cacheId);
  }
  
  public ConcurrentMap<String, ConcurrentMap<String, AccumulatorInfo>> getAll() { return this.cacheInfoPerMap; }
  
  public int accumulatorInfoCountOfMap(String mapName) {
    ConcurrentMap<String, AccumulatorInfo> accumulatorInfo = (ConcurrentMap)this.cacheInfoPerMap.get(mapName);
    if (accumulatorInfo == null)
      return 0; 
    return accumulatorInfo.size();
  }
}
