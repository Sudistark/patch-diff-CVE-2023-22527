package com.hazelcast.map.impl.querycache.accumulator;

import com.hazelcast.map.impl.operation.AccumulatorConsumerOperation;
import com.hazelcast.map.impl.querycache.QueryCacheContext;
import com.hazelcast.map.impl.querycache.publisher.MapPublisherRegistry;
import com.hazelcast.map.impl.querycache.publisher.PartitionAccumulatorRegistry;
import com.hazelcast.map.impl.querycache.publisher.PublisherContext;
import com.hazelcast.map.impl.querycache.publisher.PublisherRegistry;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.impl.NodeEngineImpl;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

public class AccumulatorScannerTask implements Runnable {
  private static final int MAX_PROCESSABLE_ACCUMULATOR_COUNT = 10;
  
  private final ScannerConsumer consumer;
  
  private final QueryCacheContext context;
  
  public AccumulatorScannerTask(QueryCacheContext context) {
    this.context = context;
    this.consumer = new ScannerConsumer();
  }
  
  public void run() { scanAccumulators(); }
  
  void scanAccumulators() {
    PublisherContext publisherContext = this.context.getPublisherContext();
    MapPublisherRegistry mapPublisherRegistry = publisherContext.getMapPublisherRegistry();
    Map<String, PublisherRegistry> publisherRegistryMap = mapPublisherRegistry.getAll();
    Set<Map.Entry<String, PublisherRegistry>> publishers = publisherRegistryMap.entrySet();
    for (Map.Entry<String, PublisherRegistry> entry : publishers) {
      PublisherRegistry publisherRegistry = (PublisherRegistry)entry.getValue();
      Map<String, PartitionAccumulatorRegistry> accumulatorRegistryMap = publisherRegistry.getAll();
      Set<Map.Entry<String, PartitionAccumulatorRegistry>> accumulators = accumulatorRegistryMap.entrySet();
      for (Map.Entry<String, PartitionAccumulatorRegistry> accumulatorRegistryEntry : accumulators) {
        PartitionAccumulatorRegistry accumulatorRegistry = (PartitionAccumulatorRegistry)accumulatorRegistryEntry.getValue();
        Map<Integer, Accumulator> accumulatorMap = accumulatorRegistry.getAll();
        for (Map.Entry<Integer, Accumulator> accumulatorEntry : accumulatorMap.entrySet()) {
          Integer partitionId = (Integer)accumulatorEntry.getKey();
          Accumulator accumulator = (Accumulator)accumulatorEntry.getValue();
          int size = accumulator.size();
          if (size > 0)
            this.consumer.consume(accumulator, partitionId.intValue()); 
        } 
      } 
    } 
    sendConsumerOperation();
    this.consumer.reset();
  }
  
  private void sendConsumerOperation() {
    Map<Integer, Queue<Accumulator>> partitionAccumulators = this.consumer.getPartitionAccumulators();
    if (partitionAccumulators == null || partitionAccumulators.isEmpty())
      return; 
    Set<Map.Entry<Integer, Queue<Accumulator>>> entries = partitionAccumulators.entrySet();
    for (Map.Entry<Integer, Queue<Accumulator>> entry : entries) {
      Integer partitionId = (Integer)entry.getKey();
      Queue<Accumulator> accumulators = (Queue)entry.getValue();
      if (accumulators.isEmpty())
        continue; 
      Operation operation = createConsumerOperation(partitionId.intValue(), accumulators);
      this.context.getInvokerWrapper().executeOperation(operation);
    } 
  }
  
  private Operation createConsumerOperation(int partitionId, Queue<Accumulator> accumulators) {
    PublisherContext publisherContext = this.context.getPublisherContext();
    NodeEngineImpl nodeEngine = (NodeEngineImpl)publisherContext.getNodeEngine();
    AccumulatorConsumerOperation accumulatorConsumerOperation = new AccumulatorConsumerOperation(accumulators, 10);
    accumulatorConsumerOperation
      .setNodeEngine(nodeEngine)
      .setCallerUuid(nodeEngine.getLocalMember().getUuid())
      .setPartitionId(partitionId)
      .setValidateTarget(false)
      .setService(nodeEngine.getService("hz:impl:mapService"));
    return accumulatorConsumerOperation;
  }
}
