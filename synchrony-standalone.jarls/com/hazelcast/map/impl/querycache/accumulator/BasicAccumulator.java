package com.hazelcast.map.impl.querycache.accumulator;

import com.hazelcast.logging.ILogger;
import com.hazelcast.logging.Logger;
import com.hazelcast.map.impl.querycache.QueryCacheContext;
import com.hazelcast.map.impl.querycache.QueryCacheEventService;
import com.hazelcast.map.impl.querycache.event.QueryCacheEventData;
import com.hazelcast.map.impl.querycache.event.sequence.Sequenced;
import com.hazelcast.map.impl.querycache.publisher.EventPublisherAccumulatorProcessor;
import com.hazelcast.map.impl.querycache.publisher.PublisherAccumulatorHandler;
import java.util.Iterator;
import java.util.concurrent.TimeUnit;

public class BasicAccumulator<E extends Sequenced> extends AbstractAccumulator<E> {
  protected final AccumulatorHandler<E> handler;
  
  protected final ILogger logger = Logger.getLogger(getClass());
  
  protected BasicAccumulator(QueryCacheContext context, AccumulatorInfo info) {
    super(context, info);
    this.handler = createAccumulatorHandler(context, info);
  }
  
  public void accumulate(E event) {
    long sequence = this.partitionSequencer.nextSequence();
    event.setSequence(sequence);
    getBuffer().add(event);
  }
  
  public int poll(AccumulatorHandler<E> handler, int maxItems) {
    if (maxItems < 1)
      return 0; 
    CyclicBuffer<E> buffer = getBuffer();
    int size = size();
    if (size < 1 || size < maxItems)
      return 0; 
    int count = 0;
    do {
      E current = (E)buffer.getAndAdvance();
      if (current == null)
        break; 
      count++;
      handler.handle(current, (count == maxItems));
    } while (count < maxItems);
    return count;
  }
  
  public int poll(AccumulatorHandler<E> handler, long delay, TimeUnit unit) {
    E next;
    CyclicBuffer<E> buffer = getBuffer();
    if (size() < 1)
      return 0; 
    long now = getNow();
    int count = 0;
    do {
      E current = (E)readCurrentExpiredOrNull(now, delay, unit);
      if (current == null)
        break; 
      next = (E)readNextExpiredOrNull(now, delay, unit);
      handler.handle(current, (next == null));
      count++;
      buffer.getAndAdvance();
    } while (next != null);
    return count;
  }
  
  public Iterator<E> iterator() {
    CyclicBuffer<E> buffer = getBuffer();
    return new ReadOnlyIterator(buffer);
  }
  
  public int size() { return this.buffer.size(); }
  
  public boolean isEmpty() { return (size() == 0); }
  
  public AccumulatorInfo getInfo() { return this.info; }
  
  public boolean setHead(long sequence) { return this.buffer.setHead(sequence); }
  
  public void reset() {
    this.handler.reset();
    super.reset();
  }
  
  private E readNextExpiredOrNull(long now, long delay, TimeUnit unit) {
    long headSequence = this.buffer.getHeadSequence();
    headSequence++;
    E sequenced = (E)this.buffer.get(headSequence);
    if (sequenced == null)
      return null; 
    return isExpired((QueryCacheEventData)sequenced, unit.toMillis(delay), now) ? sequenced : null;
  }
  
  private E readCurrentExpiredOrNull(long now, long delay, TimeUnit unit) {
    long headSequence = this.buffer.getHeadSequence();
    E sequenced = (E)this.buffer.get(headSequence);
    if (sequenced == null)
      return null; 
    return isExpired((QueryCacheEventData)sequenced, unit.toMillis(delay), now) ? sequenced : null;
  }
  
  protected AccumulatorHandler<E> createAccumulatorHandler(QueryCacheContext context, AccumulatorInfo info) {
    QueryCacheEventService queryCacheEventService = context.getQueryCacheEventService();
    AccumulatorProcessor<Sequenced> processor = createAccumulatorProcessor(info, queryCacheEventService);
    return new PublisherAccumulatorHandler(context, processor);
  }
  
  protected AccumulatorProcessor<Sequenced> createAccumulatorProcessor(AccumulatorInfo info, QueryCacheEventService eventService) { return new EventPublisherAccumulatorProcessor(info, eventService); }
}
