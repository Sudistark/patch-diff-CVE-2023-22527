package com.hazelcast.map.impl.operation;

import com.hazelcast.internal.nearcache.impl.invalidation.MetaDataGenerator;
import com.hazelcast.map.impl.MapDataSerializerHook;
import com.hazelcast.map.impl.MapService;
import com.hazelcast.map.impl.MapServiceContext;
import com.hazelcast.map.impl.nearcache.MapNearCacheManager;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.IdentifiedDataSerializable;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.ReadonlyOperation;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.util.CollectionUtil;
import com.hazelcast.util.MapUtil;
import com.hazelcast.util.Preconditions;
import java.io.IOException;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

public class MapGetInvalidationMetaDataOperation extends Operation implements IdentifiedDataSerializable, ReadonlyOperation {
  private List<String> mapNames;
  
  private MetaDataResponse response;
  
  public MapGetInvalidationMetaDataOperation() {}
  
  public MapGetInvalidationMetaDataOperation(List<String> mapNames) {
    Preconditions.checkTrue(CollectionUtil.isNotEmpty(mapNames), "mapNames cannot be null or empty");
    this.mapNames = mapNames;
  }
  
  public String getServiceName() { return "hz:impl:mapService"; }
  
  public void run() {
    List<Integer> ownedPartitions = getOwnedPartitions();
    this.response = new MetaDataResponse();
    MetaDataResponse.access$002(this.response, getPartitionUuidList(ownedPartitions));
    MetaDataResponse.access$102(this.response, getNamePartitionSequenceList(ownedPartitions));
  }
  
  private List<Integer> getOwnedPartitions() {
    IPartitionService partitionService = getNodeEngine().getPartitionService();
    Map<Address, List<Integer>> memberPartitionsMap = partitionService.getMemberPartitionsMap();
    List<Integer> ownedPartitions = (List)memberPartitionsMap.get(getNodeEngine().getThisAddress());
    return (ownedPartitions == null) ? Collections.emptyList() : ownedPartitions;
  }
  
  private Map<Integer, UUID> getPartitionUuidList(List<Integer> ownedPartitionIds) {
    MetaDataGenerator metaDataGenerator = getPartitionMetaDataGenerator();
    Map<Integer, UUID> partitionUuids = MapUtil.createHashMap(ownedPartitionIds.size());
    for (Integer partitionId : ownedPartitionIds) {
      UUID uuid = metaDataGenerator.getOrCreateUuid(partitionId.intValue());
      partitionUuids.put(partitionId, uuid);
    } 
    return partitionUuids;
  }
  
  private Map<String, List<Map.Entry<Integer, Long>>> getNamePartitionSequenceList(List<Integer> ownedPartitionIds) {
    MetaDataGenerator metaDataGenerator = getPartitionMetaDataGenerator();
    Map<String, List<Map.Entry<Integer, Long>>> sequences = new HashMap<String, List<Map.Entry<Integer, Long>>>(ownedPartitionIds.size());
    for (String name : this.mapNames) {
      List<Map.Entry<Integer, Long>> mapSequences = new ArrayList<Map.Entry<Integer, Long>>();
      for (Integer partitionId : ownedPartitionIds) {
        long partitionSequence = metaDataGenerator.currentSequence(name, partitionId.intValue());
        if (partitionSequence != 0L)
          mapSequences.add(new AbstractMap.SimpleEntry(partitionId, Long.valueOf(partitionSequence))); 
      } 
      sequences.put(name, mapSequences);
    } 
    return sequences;
  }
  
  private MetaDataGenerator getPartitionMetaDataGenerator() {
    MapService mapService = (MapService)getService();
    MapServiceContext mapServiceContext = mapService.getMapServiceContext();
    MapNearCacheManager nearCacheManager = mapServiceContext.getMapNearCacheManager();
    return nearCacheManager.getInvalidator().getMetaDataGenerator();
  }
  
  public Object getResponse() { return this.response; }
  
  public void writeInternal(ObjectDataOutput out) throws IOException {
    super.writeInternal(out);
    out.writeInt(this.mapNames.size());
    for (String mapName : this.mapNames)
      out.writeUTF(mapName); 
  }
  
  public void readInternal(ObjectDataInput in) throws IOException {
    super.readInternal(in);
    int size = in.readInt();
    List<String> mapNames = new ArrayList<String>(size);
    for (int i = 0; i < size; i++)
      mapNames.add(in.readUTF()); 
    this.mapNames = mapNames;
  }
  
  public int getFactoryId() { return MapDataSerializerHook.F_ID; }
  
  public int getId() { return 118; }
}
