package com.hazelcast.map.impl.operation;

import com.hazelcast.core.EntryEventType;
import com.hazelcast.map.impl.record.Record;
import com.hazelcast.map.impl.record.RecordInfo;
import com.hazelcast.map.impl.record.Records;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.BackupAwareOperation;
import com.hazelcast.spi.Operation;

public abstract class BasePutOperation extends LockAwareOperation implements BackupAwareOperation {
  protected Object oldValue;
  
  protected Data dataMergingValue;
  
  protected EntryEventType eventType;
  
  protected boolean putTransient;
  
  public BasePutOperation(String name, Data dataKey, Data value) { super(name, dataKey, value, -1L, -1L); }
  
  public BasePutOperation(String name, Data dataKey, Data value, long ttl, long maxIdle) { super(name, dataKey, value, ttl, maxIdle); }
  
  public BasePutOperation() {}
  
  public void afterRun() {
    this.mapServiceContext.interceptAfterPut(this.name, this.dataValue);
    Record record = this.recordStore.getRecord(this.dataKey);
    Object value = isPostProcessing(this.recordStore) ? record.getValue() : this.dataValue;
    this.mapEventPublisher.publishEvent(getCallerAddress(), this.name, getEventType(), this.dataKey, this.oldValue, value, this.dataMergingValue);
    invalidateNearCache(this.dataKey);
    publishWanUpdate(this.dataKey, value);
    evict(this.dataKey);
  }
  
  private EntryEventType getEventType() {
    if (this.eventType == null)
      this.eventType = (this.oldValue == null) ? EntryEventType.ADDED : EntryEventType.UPDATED; 
    return this.eventType;
  }
  
  public boolean shouldBackup() {
    Record record = this.recordStore.getRecord(this.dataKey);
    return (record != null);
  }
  
  public Operation getBackupOperation() {
    Record record = this.recordStore.getRecord(this.dataKey);
    RecordInfo replicationInfo = Records.buildRecordInfo(record);
    if (isPostProcessing(this.recordStore))
      this.dataValue = this.mapServiceContext.toData(record.getValue()); 
    return new PutBackupOperation(this.name, this.dataKey, this.dataValue, replicationInfo, shouldUnlockKeyOnBackup(), this.putTransient, 
        !canThisOpGenerateWANEvent());
  }
  
  protected boolean shouldUnlockKeyOnBackup() { return false; }
  
  public final int getAsyncBackupCount() { return this.mapContainer.getAsyncBackupCount(); }
  
  public final int getSyncBackupCount() { return this.mapContainer.getBackupCount(); }
  
  public void onWaitExpire() { sendResponse(null); }
}
