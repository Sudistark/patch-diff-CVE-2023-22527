package com.hazelcast.map.impl.operation;

import com.hazelcast.concurrent.lock.LockWaitNotifyKey;
import com.hazelcast.core.ManagedContext;
import com.hazelcast.core.Offloadable;
import com.hazelcast.logging.ILogger;
import com.hazelcast.map.EntryBackupProcessor;
import com.hazelcast.map.EntryProcessor;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.BackupAwareOperation;
import com.hazelcast.spi.BlockingOperation;
import com.hazelcast.spi.CallStatus;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.WaitNotifyKey;
import com.hazelcast.spi.impl.MutatingOperation;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.Clock;
import java.io.IOException;

public class EntryOperation extends KeyBasedMapOperation implements BackupAwareOperation, BlockingOperation, MutatingOperation {
  private static final int SET_UNLOCK_FAST_RETRY_LIMIT = 10;
  
  private EntryProcessor entryProcessor;
  
  private boolean offload;
  
  private Object response;
  
  private boolean readOnly;
  
  private int setUnlockRetryCount;
  
  private long begin;
  
  public EntryOperation() {}
  
  public EntryOperation(String name, Data dataKey, EntryProcessor entryProcessor) {
    super(name, dataKey);
    this.entryProcessor = entryProcessor;
  }
  
  public void innerBeforeRun() {
    super.innerBeforeRun();
    this.begin = Clock.currentTimeMillis();
    this.readOnly = this.entryProcessor instanceof com.hazelcast.core.ReadOnly;
    SerializationService serializationService = getNodeEngine().getSerializationService();
    ManagedContext managedContext = serializationService.getManagedContext();
    managedContext.initialize(this.entryProcessor);
  }
  
  public CallStatus call() {
    if (shouldWait())
      return CallStatus.WAIT; 
    if (this.offload)
      return new EntryOperationOffload(this, getCallerAddress(), null); 
    this

      
      .response = EntryOperator.operator(this, this.entryProcessor).operateOnKey(this.dataKey).doPostOperateOps().getResult();
    return CallStatus.DONE_RESPONSE;
  }
  
  public WaitNotifyKey getWaitKey() { return new LockWaitNotifyKey(getServiceNamespace(), this.dataKey); }
  
  public boolean shouldWait() {
    if (this.entryProcessor instanceof com.hazelcast.core.ReadOnly) {
      this.offload = isOffloadingRequested(this.entryProcessor);
      return false;
    } 
    if (!this.recordStore.isLocked(this.dataKey) && isOffloadingRequested(this.entryProcessor)) {
      this.offload = true;
      return false;
    } 
    this.offload = false;
    return !this.recordStore.canAcquireLock(this.dataKey, getCallerUuid(), getThreadId());
  }
  
  private boolean isOffloadingRequested(EntryProcessor entryProcessor) {
    if (entryProcessor instanceof Offloadable) {
      String executorName = ((Offloadable)entryProcessor).getExecutorName();
      if (!executorName.equals("no-offloading"))
        return true; 
    } 
    return false;
  }
  
  public void onWaitExpire() { sendResponse(null); }
  
  public Object getResponse() { return this.response; }
  
  public Operation getBackupOperation() {
    EntryBackupProcessor backupProcessor = this.entryProcessor.getBackupProcessor();
    return (backupProcessor != null) ? new EntryBackupOperation(this.name, this.dataKey, backupProcessor) : null;
  }
  
  public boolean shouldBackup() { return (this.mapContainer.getTotalBackupCount() > 0 && this.entryProcessor.getBackupProcessor() != null); }
  
  public int getAsyncBackupCount() { return this.mapContainer.getAsyncBackupCount(); }
  
  public int getSyncBackupCount() { return this.mapContainer.getBackupCount(); }
  
  public int getId() { return 20; }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    super.readInternal(in);
    this.entryProcessor = (EntryProcessor)in.readObject();
  }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException {
    super.writeInternal(out);
    out.writeObject(this.entryProcessor);
  }
}
