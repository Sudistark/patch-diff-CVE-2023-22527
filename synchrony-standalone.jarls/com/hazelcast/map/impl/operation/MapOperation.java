package com.hazelcast.map.impl.operation;

import com.hazelcast.core.EntryView;
import com.hazelcast.internal.nearcache.impl.invalidation.Invalidator;
import com.hazelcast.internal.util.ToHeapDataConverter;
import com.hazelcast.map.impl.EntryViews;
import com.hazelcast.map.impl.MapContainer;
import com.hazelcast.map.impl.MapDataSerializerHook;
import com.hazelcast.map.impl.MapService;
import com.hazelcast.map.impl.MapServiceContext;
import com.hazelcast.map.impl.PartitionContainer;
import com.hazelcast.map.impl.event.MapEventPublisher;
import com.hazelcast.map.impl.mapstore.MapDataStore;
import com.hazelcast.map.impl.nearcache.MapNearCacheManager;
import com.hazelcast.map.impl.record.Record;
import com.hazelcast.map.impl.recordstore.RecordStore;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.nio.serialization.IdentifiedDataSerializable;
import com.hazelcast.spi.ObjectNamespace;
import com.hazelcast.spi.ServiceNamespace;
import com.hazelcast.spi.ServiceNamespaceAware;
import com.hazelcast.spi.impl.AbstractNamedOperation;
import com.hazelcast.util.CollectionUtil;
import com.hazelcast.wan.impl.CallerProvenance;
import java.util.List;

public abstract class MapOperation extends AbstractNamedOperation implements IdentifiedDataSerializable, ServiceNamespaceAware {
  protected MapService mapService;
  
  protected MapContainer mapContainer;
  
  protected MapServiceContext mapServiceContext;
  
  protected MapEventPublisher mapEventPublisher;
  
  protected RecordStore recordStore;
  
  protected boolean createRecordStoreOnDemand = true;
  
  protected boolean disableWanReplicationEvent;
  
  public MapOperation(String name) { this.name = name; }
  
  public void setMapService(MapService mapService) { this.mapService = mapService; }
  
  public void setMapContainer(MapContainer mapContainer) { this.mapContainer = mapContainer; }
  
  protected final CallerProvenance getCallerProvenance() { return this.disableWanReplicationEvent ? CallerProvenance.WAN : CallerProvenance.NOT_WAN; }
  
  public void beforeRun() {
    super.beforeRun();
    this.mapService = (MapService)getService();
    this.mapServiceContext = this.mapService.getMapServiceContext();
    this.mapEventPublisher = this.mapServiceContext.getMapEventPublisher();
    innerBeforeRun();
  }
  
  public void innerBeforeRun() {
    this.recordStore = getRecordStoreOrNull();
    if (this.recordStore == null) {
      this.mapContainer = this.mapServiceContext.getMapContainer(this.name);
    } else {
      this.mapContainer = this.recordStore.getMapContainer();
    } 
  }
  
  public String getServiceName() { return "hz:impl:mapService"; }
  
  public boolean isPostProcessing(RecordStore recordStore) {
    MapDataStore mapDataStore = recordStore.getMapDataStore();
    return (mapDataStore.isPostProcessingMapStore() || this.mapServiceContext.hasInterceptor(this.name));
  }
  
  public void setThreadId(long threadId) { throw new UnsupportedOperationException(); }
  
  public long getThreadId() { throw new UnsupportedOperationException(); }
  
  protected final void invalidateNearCache(List<Data> keys) {
    if (!this.mapContainer.hasInvalidationListener() || CollectionUtil.isEmpty(keys))
      return; 
    Invalidator invalidator = getNearCacheInvalidator();
    for (Data key : keys)
      invalidator.invalidateKey(key, this.name, getCallerUuid()); 
  }
  
  public final void invalidateNearCache(Data key) {
    if (!this.mapContainer.hasInvalidationListener() || key == null)
      return; 
    Invalidator invalidator = getNearCacheInvalidator();
    invalidator.invalidateKey(key, this.name, getCallerUuid());
  }
  
  protected final void invalidateAllKeysInNearCaches() {
    if (this.mapContainer.hasInvalidationListener()) {
      int partitionId = getPartitionId();
      Invalidator invalidator = getNearCacheInvalidator();
      if (partitionId == getNodeEngine().getPartitionService().getPartitionId(this.name))
        invalidator.invalidateAllKeys(this.name, getCallerUuid()); 
      invalidator.resetPartitionMetaData(this.name, getPartitionId());
    } 
  }
  
  private Invalidator getNearCacheInvalidator() {
    MapNearCacheManager mapNearCacheManager = this.mapServiceContext.getMapNearCacheManager();
    return mapNearCacheManager.getInvalidator();
  }
  
  protected void evict(Data excludedKey) {
    assert this.recordStore != null : "Record-store cannot be null";
    this.recordStore.evictEntries(excludedKey);
  }
  
  private RecordStore getRecordStoreOrNull() {
    int partitionId = getPartitionId();
    if (partitionId == -1)
      return null; 
    PartitionContainer partitionContainer = this.mapServiceContext.getPartitionContainer(partitionId);
    if (this.createRecordStoreOnDemand)
      return partitionContainer.getRecordStore(this.name); 
    return partitionContainer.getExistingRecordStore(this.name);
  }
  
  public int getFactoryId() { return MapDataSerializerHook.F_ID; }
  
  public ObjectNamespace getServiceNamespace() {
    MapContainer container = this.mapContainer;
    if (container == null) {
      MapService service = (MapService)getService();
      container = service.getMapServiceContext().getMapContainer(this.name);
    } 
    return container.getObjectNamespace();
  }
  
  protected final boolean canThisOpGenerateWANEvent() { return !this.disableWanReplicationEvent; }
  
  protected final void publishWanUpdate(Data dataKey, Object value) { publishWanUpdateInternal(dataKey, value, false); }
  
  private void publishWanUpdateInternal(Data dataKey, Object value, boolean hasLoadProvenance) {
    if (!canPublishWANEvent())
      return; 
    Record record = this.recordStore.getRecord(dataKey);
    if (record == null)
      return; 
    Data dataValue = ToHeapDataConverter.toHeapData(this.mapServiceContext.toData(value));
    EntryView entryView = EntryViews.createSimpleEntryView(ToHeapDataConverter.toHeapData(dataKey), dataValue, record);
    this.mapEventPublisher.publishWanUpdate(this.name, entryView, hasLoadProvenance);
  }
  
  protected final void publishLoadAsWanUpdate(Data dataKey, Object value) { publishWanUpdateInternal(dataKey, value, true); }
  
  protected final void publishWanRemove(Data dataKey) {
    if (!canPublishWANEvent())
      return; 
    this.mapEventPublisher.publishWanRemove(this.name, ToHeapDataConverter.toHeapData(dataKey));
  }
  
  private boolean canPublishWANEvent() { return (this.mapContainer.isWanReplicationEnabled() && canThisOpGenerateWANEvent()); }
  
  public MapOperation() {}
}
