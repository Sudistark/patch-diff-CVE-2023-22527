package com.hazelcast.map.impl;

import com.hazelcast.cluster.ClusterState;
import com.hazelcast.config.InMemoryFormat;
import com.hazelcast.config.MapConfig;
import com.hazelcast.config.MergePolicyConfig;
import com.hazelcast.config.MetadataPolicy;
import com.hazelcast.config.PartitioningStrategyConfig;
import com.hazelcast.core.PartitioningStrategy;
import com.hazelcast.internal.eviction.ExpirationManager;
import com.hazelcast.internal.serialization.InternalSerializationService;
import com.hazelcast.internal.util.InvocationUtil;
import com.hazelcast.internal.util.LocalRetryableExecution;
import com.hazelcast.internal.util.comparators.ValueComparator;
import com.hazelcast.internal.util.comparators.ValueComparatorUtil;
import com.hazelcast.logging.ILogger;
import com.hazelcast.map.MapInterceptor;
import com.hazelcast.map.impl.event.MapEventPublisher;
import com.hazelcast.map.impl.event.MapEventPublisherImpl;
import com.hazelcast.map.impl.eviction.MapClearExpiredRecordsTask;
import com.hazelcast.map.impl.journal.MapEventJournal;
import com.hazelcast.map.impl.journal.RingbufferMapEventJournalImpl;
import com.hazelcast.map.impl.mapstore.MapDataStore;
import com.hazelcast.map.impl.nearcache.MapNearCacheManager;
import com.hazelcast.map.impl.operation.MapOperationProvider;
import com.hazelcast.map.impl.operation.MapOperationProviders;
import com.hazelcast.map.impl.operation.MapPartitionDestroyOperation;
import com.hazelcast.map.impl.query.AggregationResultProcessor;
import com.hazelcast.map.impl.query.CallerRunsAccumulationExecutor;
import com.hazelcast.map.impl.query.CallerRunsPartitionScanExecutor;
import com.hazelcast.map.impl.query.ParallelAccumulationExecutor;
import com.hazelcast.map.impl.query.ParallelPartitionScanExecutor;
import com.hazelcast.map.impl.query.PartitionScanRunner;
import com.hazelcast.map.impl.query.QueryEngine;
import com.hazelcast.map.impl.query.QueryEngineImpl;
import com.hazelcast.map.impl.query.QueryResultProcessor;
import com.hazelcast.map.impl.query.QueryRunner;
import com.hazelcast.map.impl.query.ResultProcessorRegistry;
import com.hazelcast.map.impl.querycache.NodeQueryCacheContext;
import com.hazelcast.map.impl.querycache.QueryCacheContext;
import com.hazelcast.map.impl.record.Record;
import com.hazelcast.map.impl.recordstore.DefaultRecordStore;
import com.hazelcast.map.impl.recordstore.EventJournalWriterRecordStoreMutationObserver;
import com.hazelcast.map.impl.recordstore.JsonMetadataRecordStoreMutationObserver;
import com.hazelcast.map.impl.recordstore.RecordStore;
import com.hazelcast.map.impl.recordstore.RecordStoreMutationObserver;
import com.hazelcast.map.listener.MapPartitionLostListener;
import com.hazelcast.map.merge.MergePolicyProvider;
import com.hazelcast.monitor.impl.LocalMapStatsImpl;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.nio.serialization.DataType;
import com.hazelcast.query.impl.DefaultIndexProvider;
import com.hazelcast.query.impl.IndexCopyBehavior;
import com.hazelcast.query.impl.IndexProvider;
import com.hazelcast.query.impl.getters.Extractors;
import com.hazelcast.query.impl.predicates.QueryOptimizer;
import com.hazelcast.query.impl.predicates.QueryOptimizerFactory;
import com.hazelcast.spi.EventFilter;
import com.hazelcast.spi.EventRegistration;
import com.hazelcast.spi.EventService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.impl.eventservice.impl.TrueEventFilter;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.spi.properties.GroupProperty;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.ContextMutexFactory;
import com.hazelcast.util.executor.ManagedExecutorService;
import com.hazelcast.util.function.Predicate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

class MapServiceContextImpl implements MapServiceContext {
  protected static final long DESTROY_TIMEOUT_SECONDS = 30L;
  
  protected final ConcurrentMap<String, MapContainer> mapContainers;
  
  protected final AtomicReference<Collection<Integer>> ownedPartitions;
  
  protected final IndexProvider indexProvider;
  
  protected final ContextMutexFactory contextMutexFactory;
  
  protected final AtomicInteger writeBehindQueueItemCounter;
  
  protected final NodeEngine nodeEngine;
  
  protected final InternalSerializationService serializationService;
  
  protected final ConstructorFunction<String, MapContainer> mapConstructor;
  
  protected final PartitionContainer[] partitionContainers;
  
  protected final MapClearExpiredRecordsTask clearExpiredRecordsTask;
  
  protected final ExpirationManager expirationManager;
  
  protected final MapNearCacheManager mapNearCacheManager;
  
  protected final LocalMapStatsProvider localMapStatsProvider;
  
  protected final MergePolicyProvider mergePolicyProvider;
  
  protected final QueryEngine queryEngine;
  
  protected final QueryRunner mapQueryRunner;
  
  protected final PartitionScanRunner partitionScanRunner;
  
  protected final QueryOptimizer queryOptimizer;
  
  protected final PartitioningStrategyFactory partitioningStrategyFactory;
  
  protected final QueryCacheContext queryCacheContext;
  
  protected final MapEventJournal eventJournal;
  
  protected final MapEventPublisher mapEventPublisher;
  
  protected final EventService eventService;
  
  protected final MapOperationProviders operationProviders;
  
  protected final ResultProcessorRegistry resultProcessorRegistry;
  
  protected ILogger logger;
  
  protected MapService mapService;
  
  MapServiceContextImpl(NodeEngine nodeEngine) {
    this.mapContainers = new ConcurrentHashMap();
    this.ownedPartitions = new AtomicReference();
    this.indexProvider = new DefaultIndexProvider();
    this.contextMutexFactory = new ContextMutexFactory();
    this.writeBehindQueueItemCounter = new AtomicInteger(0);
    this.nodeEngine = nodeEngine;
    this.serializationService = (InternalSerializationService)nodeEngine.getSerializationService();
    this.mapConstructor = createMapConstructor();
    this.queryCacheContext = new NodeQueryCacheContext(this);
    this.partitionContainers = createPartitionContainers();
    this.clearExpiredRecordsTask = new MapClearExpiredRecordsTask(this.partitionContainers, nodeEngine);
    this.expirationManager = new ExpirationManager(this.clearExpiredRecordsTask, nodeEngine);
    this.mapNearCacheManager = createMapNearCacheManager();
    this.localMapStatsProvider = createLocalMapStatsProvider();
    this.mergePolicyProvider = new MergePolicyProvider(nodeEngine);
    this.mapEventPublisher = createMapEventPublisherSupport();
    this.eventJournal = createEventJournal();
    this.queryOptimizer = QueryOptimizerFactory.newOptimizer(nodeEngine.getProperties());
    this.resultProcessorRegistry = createResultProcessorRegistry(this.serializationService);
    this.partitionScanRunner = createPartitionScanRunner();
    this.queryEngine = createMapQueryEngine();
    this.mapQueryRunner = createMapQueryRunner(nodeEngine, this.queryOptimizer, this.resultProcessorRegistry, this.partitionScanRunner);
    this.eventService = nodeEngine.getEventService();
    this.operationProviders = createOperationProviders();
    this.partitioningStrategyFactory = new PartitioningStrategyFactory(nodeEngine.getConfigClassLoader());
    this.logger = nodeEngine.getLogger(getClass());
  }
  
  ConstructorFunction<String, MapContainer> createMapConstructor() { return new Object(this); }
  
  MapNearCacheManager createMapNearCacheManager() { return new MapNearCacheManager(this); }
  
  MapOperationProviders createOperationProviders() { return new MapOperationProviders(this); }
  
  MapEventPublisherImpl createMapEventPublisherSupport() { return new MapEventPublisherImpl(this); }
  
  private MapEventJournal createEventJournal() { return new RingbufferMapEventJournalImpl(getNodeEngine(), this); }
  
  protected LocalMapStatsProvider createLocalMapStatsProvider() { return new LocalMapStatsProvider(this); }
  
  private QueryEngineImpl createMapQueryEngine() { return new QueryEngineImpl(this); }
  
  private PartitionScanRunner createPartitionScanRunner() { return new PartitionScanRunner(this); }
  
  protected QueryRunner createMapQueryRunner(NodeEngine nodeEngine, QueryOptimizer queryOptimizer, ResultProcessorRegistry resultProcessorRegistry, PartitionScanRunner partitionScanRunner) {
    CallerRunsPartitionScanExecutor callerRunsPartitionScanExecutor;
    boolean parallelEvaluation = nodeEngine.getProperties().getBoolean(GroupProperty.QUERY_PREDICATE_PARALLEL_EVALUATION);
    if (parallelEvaluation) {
      int opTimeoutInMillis = nodeEngine.getProperties().getInteger(GroupProperty.OPERATION_CALL_TIMEOUT_MILLIS);
      ManagedExecutorService queryExecutorService = nodeEngine.getExecutionService().getExecutor("hz:query");
      callerRunsPartitionScanExecutor = new ParallelPartitionScanExecutor(partitionScanRunner, queryExecutorService, opTimeoutInMillis);
    } else {
      callerRunsPartitionScanExecutor = new CallerRunsPartitionScanExecutor(partitionScanRunner);
    } 
    return new QueryRunner(this, queryOptimizer, callerRunsPartitionScanExecutor, resultProcessorRegistry);
  }
  
  private ResultProcessorRegistry createResultProcessorRegistry(SerializationService ss) {
    ResultProcessorRegistry registry = new ResultProcessorRegistry();
    registry.registerProcessor(com.hazelcast.map.impl.query.QueryResult.class, createQueryResultProcessor(ss));
    registry.registerProcessor(com.hazelcast.map.impl.query.AggregationResult.class, createAggregationResultProcessor(ss));
    return registry;
  }
  
  private QueryResultProcessor createQueryResultProcessor(SerializationService ss) { return new QueryResultProcessor(ss); }
  
  private AggregationResultProcessor createAggregationResultProcessor(SerializationService ss) {
    CallerRunsAccumulationExecutor callerRunsAccumulationExecutor;
    boolean parallelAccumulation = this.nodeEngine.getProperties().getBoolean(GroupProperty.AGGREGATION_ACCUMULATION_PARALLEL_EVALUATION);
    int opTimeoutInMillis = this.nodeEngine.getProperties().getInteger(GroupProperty.OPERATION_CALL_TIMEOUT_MILLIS);
    if (parallelAccumulation) {
      ManagedExecutorService queryExecutorService = this.nodeEngine.getExecutionService().getExecutor("hz:query");
      callerRunsAccumulationExecutor = new ParallelAccumulationExecutor(queryExecutorService, ss, opTimeoutInMillis);
    } else {
      callerRunsAccumulationExecutor = new CallerRunsAccumulationExecutor(ss);
    } 
    return new AggregationResultProcessor(callerRunsAccumulationExecutor, this.serializationService);
  }
  
  private PartitionContainer[] createPartitionContainers() {
    int partitionCount = this.nodeEngine.getPartitionService().getPartitionCount();
    return new PartitionContainer[partitionCount];
  }
  
  public MapContainer getMapContainer(String mapName) { return (MapContainer)ConcurrencyUtil.getOrPutSynchronized(this.mapContainers, mapName, this.contextMutexFactory, this.mapConstructor); }
  
  public Map<String, MapContainer> getMapContainers() { return this.mapContainers; }
  
  public PartitionContainer getPartitionContainer(int partitionId) {
    assert partitionId != -1 : "Cannot be called with GENERIC_PARTITION_ID";
    return this.partitionContainers[partitionId];
  }
  
  public void initPartitionsContainers() {
    int partitionCount = this.nodeEngine.getPartitionService().getPartitionCount();
    for (int i = 0; i < partitionCount; i++)
      this.partitionContainers[i] = createPartitionContainer(getService(), i); 
  }
  
  protected PartitionContainer createPartitionContainer(MapService service, int partitionId) { return new PartitionContainer(service, partitionId); }
  
  protected void removeAllRecordStoresOfAllMaps(boolean onShutdown, boolean onRecordStoreDestroy) {
    for (PartitionContainer partitionContainer : this.partitionContainers) {
      if (partitionContainer != null)
        removeRecordStoresFromPartitionMatchingWith(allRecordStores(), partitionContainer
            .getPartitionId(), onShutdown, onRecordStoreDestroy); 
    } 
  }
  
  private static Predicate<RecordStore> allRecordStores() { return new Object(); }
  
  public void removeRecordStoresFromPartitionMatchingWith(Predicate<RecordStore> predicate, int partitionId, boolean onShutdown, boolean onRecordStoreDestroy) {
    PartitionContainer container = this.partitionContainers[partitionId];
    if (container == null)
      return; 
    Iterator<RecordStore> partitionIterator = container.getMaps().values().iterator();
    while (partitionIterator.hasNext()) {
      RecordStore partition = (RecordStore)partitionIterator.next();
      if (predicate.test(partition)) {
        partition.clearPartition(onShutdown, onRecordStoreDestroy);
        partitionIterator.remove();
      } 
    } 
  }
  
  public MapService getService() { return this.mapService; }
  
  public void setService(MapService mapService) { this.mapService = mapService; }
  
  public void destroyMapStores() {
    for (MapContainer mapContainer : this.mapContainers.values()) {
      MapStoreWrapper store = mapContainer.getMapStoreContext().getMapStoreWrapper();
      if (store != null)
        store.destroy(); 
    } 
  }
  
  public void flushMaps() {
    for (MapContainer mapContainer : this.mapContainers.values())
      mapContainer.getMapStoreContext().stop(); 
    for (PartitionContainer partitionContainer : this.partitionContainers) {
      for (String mapName : this.mapContainers.keySet()) {
        RecordStore recordStore = partitionContainer.getExistingRecordStore(mapName);
        if (recordStore != null) {
          MapDataStore mapDataStore = recordStore.getMapDataStore();
          mapDataStore.hardFlush();
        } 
      } 
    } 
  }
  
  public void destroyMap(String mapName) {
    this.mapNearCacheManager.destroyNearCache(mapName);
    this.nodeEngine.getEventService().deregisterAllListeners("hz:impl:mapService", mapName);
    MapContainer mapContainer = (MapContainer)this.mapContainers.get(mapName);
    if (mapContainer == null)
      return; 
    this.nodeEngine.getWanReplicationService().removeWanEventCounters("hz:impl:mapService", mapName);
    mapContainer.getMapStoreContext().stop();
    this.localMapStatsProvider.destroyLocalMapStatsImpl(mapContainer.getName());
    destroyPartitionsAndMapContainer(mapContainer);
  }
  
  private void destroyPartitionsAndMapContainer(MapContainer mapContainer) {
    List<LocalRetryableExecution> executions = new ArrayList<LocalRetryableExecution>();
    for (PartitionContainer container : this.partitionContainers) {
      MapPartitionDestroyOperation op = new MapPartitionDestroyOperation(container, mapContainer);
      executions.add(InvocationUtil.executeLocallyWithRetry(this.nodeEngine, op));
    } 
    for (LocalRetryableExecution execution : executions) {
      try {
        if (!execution.awaitCompletion(30L, TimeUnit.SECONDS))
          this.logger.warning("Map partition was not destroyed in expected time, possible leak"); 
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        this.nodeEngine.getLogger(getClass()).warning(e);
      } 
    } 
  }
  
  public void reset() {
    removeAllRecordStoresOfAllMaps(false, false);
    this.mapNearCacheManager.reset();
  }
  
  public void shutdown() {
    removeAllRecordStoresOfAllMaps(true, false);
    this.mapNearCacheManager.shutdown();
    this.mapContainers.clear();
    this.expirationManager.onShutdown();
  }
  
  public RecordStore getRecordStore(int partitionId, String mapName) { return getPartitionContainer(partitionId).getRecordStore(mapName); }
  
  public RecordStore getRecordStore(int partitionId, String mapName, boolean skipLoadingOnCreate) { return getPartitionContainer(partitionId).getRecordStore(mapName, skipLoadingOnCreate); }
  
  public RecordStore getExistingRecordStore(int partitionId, String mapName) { return getPartitionContainer(partitionId).getExistingRecordStore(mapName); }
  
  public Collection<Integer> getOwnedPartitions() {
    Collection<Integer> partitions = (Collection)this.ownedPartitions.get();
    if (partitions == null) {
      reloadOwnedPartitions();
      partitions = (Collection)this.ownedPartitions.get();
    } 
    return partitions;
  }
  
  public void reloadOwnedPartitions() {
    Set<Integer> newSet;
    Collection<Integer> expected;
    IPartitionService partitionService = this.nodeEngine.getPartitionService();
    do {
      expected = (Collection)this.ownedPartitions.get();
      Collection<Integer> partitions = partitionService.getMemberPartitions(this.nodeEngine.getThisAddress());
      newSet = Collections.unmodifiableSet(new LinkedHashSet(partitions));
    } while (!this.ownedPartitions.compareAndSet(expected, newSet));
  }
  
  public AtomicInteger getWriteBehindQueueItemCounter() { return this.writeBehindQueueItemCounter; }
  
  public ExpirationManager getExpirationManager() { return this.expirationManager; }
  
  public NodeEngine getNodeEngine() { return this.nodeEngine; }
  
  public MergePolicyProvider getMergePolicyProvider() { return this.mergePolicyProvider; }
  
  public Object getMergePolicy(String name) {
    MapContainer mapContainer = getMapContainer(name);
    MergePolicyConfig mergePolicyConfig = mapContainer.getMapConfig().getMergePolicyConfig();
    return this.mergePolicyProvider.getMergePolicy(mergePolicyConfig.getPolicy());
  }
  
  public MapEventPublisher getMapEventPublisher() { return this.mapEventPublisher; }
  
  public MapEventJournal getEventJournal() { return this.eventJournal; }
  
  public QueryEngine getQueryEngine(String mapName) { return this.queryEngine; }
  
  public QueryRunner getMapQueryRunner(String name) { return this.mapQueryRunner; }
  
  public QueryOptimizer getQueryOptimizer() { return this.queryOptimizer; }
  
  public LocalMapStatsProvider getLocalMapStatsProvider() { return this.localMapStatsProvider; }
  
  public Object toObject(Object data) { return this.serializationService.toObject(data); }
  
  public Data toData(Object object, PartitioningStrategy partitionStrategy) { return this.serializationService.toData(object, partitionStrategy); }
  
  public Data toData(Object object) { return this.serializationService.toData(object, DataType.HEAP); }
  
  public void interceptAfterGet(String mapName, Object value) {
    MapContainer mapContainer = getMapContainer(mapName);
    List<MapInterceptor> interceptors = mapContainer.getInterceptorRegistry().getInterceptors();
    if (!interceptors.isEmpty()) {
      value = toObject(value);
      for (MapInterceptor interceptor : interceptors)
        interceptor.afterGet(value); 
    } 
  }
  
  public Object interceptPut(String mapName, Object oldValue, Object newValue) {
    MapContainer mapContainer = getMapContainer(mapName);
    List<MapInterceptor> interceptors = mapContainer.getInterceptorRegistry().getInterceptors();
    Object result = null;
    if (!interceptors.isEmpty()) {
      result = toObject(newValue);
      oldValue = toObject(oldValue);
      for (MapInterceptor interceptor : interceptors) {
        Object temp = interceptor.interceptPut(oldValue, result);
        if (temp != null)
          result = temp; 
      } 
    } 
    return (result == null) ? newValue : result;
  }
  
  public void interceptAfterPut(String mapName, Object newValue) {
    MapContainer mapContainer = getMapContainer(mapName);
    List<MapInterceptor> interceptors = mapContainer.getInterceptorRegistry().getInterceptors();
    if (!interceptors.isEmpty()) {
      newValue = toObject(newValue);
      for (MapInterceptor interceptor : interceptors)
        interceptor.afterPut(newValue); 
    } 
  }
  
  public MapClearExpiredRecordsTask getClearExpiredRecordsTask() { return this.clearExpiredRecordsTask; }
  
  public Object interceptRemove(String mapName, Object value) {
    MapContainer mapContainer = getMapContainer(mapName);
    List<MapInterceptor> interceptors = mapContainer.getInterceptorRegistry().getInterceptors();
    Object result = null;
    if (!interceptors.isEmpty()) {
      result = toObject(value);
      for (MapInterceptor interceptor : interceptors) {
        Object temp = interceptor.interceptRemove(result);
        if (temp != null)
          result = temp; 
      } 
    } 
    return (result == null) ? value : result;
  }
  
  public void interceptAfterRemove(String mapName, Object value) {
    MapContainer mapContainer = getMapContainer(mapName);
    InterceptorRegistry interceptorRegistry = mapContainer.getInterceptorRegistry();
    List<MapInterceptor> interceptors = interceptorRegistry.getInterceptors();
    if (!interceptors.isEmpty()) {
      value = toObject(value);
      for (MapInterceptor interceptor : interceptors)
        interceptor.afterRemove(value); 
    } 
  }
  
  public void addInterceptor(String id, String mapName, MapInterceptor interceptor) {
    MapContainer mapContainer = getMapContainer(mapName);
    mapContainer.getInterceptorRegistry().register(id, interceptor);
  }
  
  public String generateInterceptorId(String mapName, MapInterceptor interceptor) { return interceptor.getClass().getName() + interceptor.hashCode(); }
  
  public void removeInterceptor(String mapName, String id) {
    MapContainer mapContainer = getMapContainer(mapName);
    mapContainer.getInterceptorRegistry().deregister(id);
  }
  
  public Object interceptGet(String mapName, Object value) {
    MapContainer mapContainer = getMapContainer(mapName);
    InterceptorRegistry interceptorRegistry = mapContainer.getInterceptorRegistry();
    List<MapInterceptor> interceptors = interceptorRegistry.getInterceptors();
    Object result = null;
    if (!interceptors.isEmpty()) {
      result = toObject(value);
      for (MapInterceptor interceptor : interceptors) {
        Object temp = interceptor.interceptGet(result);
        if (temp != null)
          result = temp; 
      } 
    } 
    return (result == null) ? value : result;
  }
  
  public boolean hasInterceptor(String mapName) {
    MapContainer mapContainer = getMapContainer(mapName);
    return !mapContainer.getInterceptorRegistry().getInterceptors().isEmpty();
  }
  
  public String addLocalEventListener(Object listener, String mapName) {
    EventRegistration registration = addListenerInternal(listener, TrueEventFilter.INSTANCE, mapName, true);
    return registration.getId();
  }
  
  public String addLocalEventListener(Object listener, EventFilter eventFilter, String mapName) {
    EventRegistration registration = addListenerInternal(listener, eventFilter, mapName, true);
    return registration.getId();
  }
  
  public String addLocalPartitionLostListener(MapPartitionLostListener listener, String mapName) {
    InternalMapPartitionLostListenerAdapter internalMapPartitionLostListenerAdapter = new InternalMapPartitionLostListenerAdapter(listener);
    MapPartitionLostEventFilter mapPartitionLostEventFilter = new MapPartitionLostEventFilter();
    EventRegistration registration = this.eventService.registerLocalListener("hz:impl:mapService", mapName, mapPartitionLostEventFilter, internalMapPartitionLostListenerAdapter);
    return registration.getId();
  }
  
  public String addEventListener(Object listener, EventFilter eventFilter, String mapName) {
    EventRegistration registration = addListenerInternal(listener, eventFilter, mapName, false);
    return registration.getId();
  }
  
  public String addPartitionLostListener(MapPartitionLostListener listener, String mapName) {
    InternalMapPartitionLostListenerAdapter internalMapPartitionLostListenerAdapter = new InternalMapPartitionLostListenerAdapter(listener);
    MapPartitionLostEventFilter mapPartitionLostEventFilter = new MapPartitionLostEventFilter();
    EventRegistration registration = this.eventService.registerListener("hz:impl:mapService", mapName, mapPartitionLostEventFilter, internalMapPartitionLostListenerAdapter);
    return registration.getId();
  }
  
  private EventRegistration addListenerInternal(Object listener, EventFilter filter, String mapName, boolean local) {
    EventListenerFilter eventListenerFilter;
    ListenerAdapter listenerAdaptor = ListenerAdapters.createListenerAdapter(listener);
    if (!(filter instanceof EventListenerFilter)) {
      int enabledListeners = MapListenerFlagOperator.setAndGetListenerFlags(listenerAdaptor);
      eventListenerFilter = new EventListenerFilter(enabledListeners, filter);
    } 
    if (local)
      return this.eventService.registerLocalListener("hz:impl:mapService", mapName, eventListenerFilter, listenerAdaptor); 
    return this.eventService.registerListener("hz:impl:mapService", mapName, eventListenerFilter, listenerAdaptor);
  }
  
  public boolean removeEventListener(String mapName, String registrationId) { return this.eventService.deregisterListener("hz:impl:mapService", mapName, registrationId); }
  
  public boolean removePartitionLostListener(String mapName, String registrationId) { return this.eventService.deregisterListener("hz:impl:mapService", mapName, registrationId); }
  
  public MapOperationProvider getMapOperationProvider(String name) { return this.operationProviders.getOperationProvider(name); }
  
  public MapOperationProvider getMapOperationProvider(MapConfig mapConfig) { return this.operationProviders.getOperationProvider(mapConfig); }
  
  public IndexProvider getIndexProvider(MapConfig mapConfig) { return this.indexProvider; }
  
  public Extractors getExtractors(String mapName) {
    MapContainer mapContainer = getMapContainer(mapName);
    return mapContainer.getExtractors();
  }
  
  public void incrementOperationStats(long startTime, LocalMapStatsImpl localMapStats, String mapName, Operation operation) {
    long durationNanos = System.nanoTime() - startTime;
    if (operation instanceof com.hazelcast.map.impl.operation.BasePutOperation) {
      localMapStats.incrementPutLatencyNanos(durationNanos);
    } else if (operation instanceof com.hazelcast.map.impl.operation.BaseRemoveOperation) {
      localMapStats.incrementRemoveLatencyNanos(durationNanos);
    } else if (operation instanceof com.hazelcast.map.impl.operation.GetOperation) {
      localMapStats.incrementGetLatencyNanos(durationNanos);
    } 
  }
  
  public RecordStore createRecordStore(MapContainer mapContainer, int partitionId, MapKeyLoader keyLoader) {
    assert partitionId != -1 : "Cannot be called with GENERIC_PARTITION_ID";
    ILogger logger = this.nodeEngine.getLogger(DefaultRecordStore.class);
    return new DefaultRecordStore(mapContainer, partitionId, keyLoader, logger);
  }
  
  public boolean removeMapContainer(MapContainer mapContainer) { return this.mapContainers.remove(mapContainer.getName(), mapContainer); }
  
  public PartitioningStrategy getPartitioningStrategy(String mapName, PartitioningStrategyConfig config) { return this.partitioningStrategyFactory.getPartitioningStrategy(mapName, config); }
  
  public void removePartitioningStrategyFromCache(String mapName) { this.partitioningStrategyFactory.removePartitioningStrategyFromCache(mapName); }
  
  public PartitionContainer[] getPartitionContainers() { return this.partitionContainers; }
  
  public void onClusterStateChange(ClusterState newState) { this.expirationManager.onClusterStateChange(newState); }
  
  public PartitionScanRunner getPartitionScanRunner() { return this.partitionScanRunner; }
  
  public ResultProcessorRegistry getResultProcessorRegistry() { return this.resultProcessorRegistry; }
  
  public MapNearCacheManager getMapNearCacheManager() { return this.mapNearCacheManager; }
  
  public String addListenerAdapter(ListenerAdapter listenerAdaptor, EventFilter eventFilter, String mapName) {
    EventRegistration registration = getNodeEngine().getEventService().registerListener("hz:impl:mapService", mapName, eventFilter, listenerAdaptor);
    return registration.getId();
  }
  
  public String addLocalListenerAdapter(ListenerAdapter adapter, String mapName) {
    EventService eventService = getNodeEngine().getEventService();
    EventRegistration registration = eventService.registerLocalListener("hz:impl:mapService", mapName, adapter);
    return registration.getId();
  }
  
  public QueryCacheContext getQueryCacheContext() { return this.queryCacheContext; }
  
  public IndexCopyBehavior getIndexCopyBehavior() { return (IndexCopyBehavior)this.nodeEngine.getProperties().getEnum(GroupProperty.INDEX_COPY_BEHAVIOR, IndexCopyBehavior.class); }
  
  public Collection<RecordStoreMutationObserver<Record>> createRecordStoreMutationObservers(String mapName, int partitionId) {
    Collection<RecordStoreMutationObserver<Record>> observers = new LinkedList<RecordStoreMutationObserver<Record>>();
    addEventJournalUpdaterObserver(observers, mapName, partitionId);
    addMetadataInitializerObserver(observers, mapName, partitionId);
    return observers;
  }
  
  protected void addMetadataInitializerObserver(Collection<RecordStoreMutationObserver<Record>> observers, String mapName, int partitionId) {
    MapContainer mapContainer = getMapContainer(mapName);
    MetadataPolicy policy = mapContainer.getMapConfig().getMetadataPolicy();
    if (policy == MetadataPolicy.CREATE_ON_UPDATE) {
      JsonMetadataRecordStoreMutationObserver jsonMetadataRecordStoreMutationObserver = new JsonMetadataRecordStoreMutationObserver(this.serializationService, JsonMetadataInitializer.INSTANCE);
      observers.add(jsonMetadataRecordStoreMutationObserver);
    } 
  }
  
  private void addEventJournalUpdaterObserver(Collection<RecordStoreMutationObserver<Record>> observers, String mapName, int partitionId) {
    EventJournalWriterRecordStoreMutationObserver eventJournalWriterRecordStoreMutationObserver = new EventJournalWriterRecordStoreMutationObserver(getEventJournal(), getMapContainer(mapName), partitionId);
    observers.add(eventJournalWriterRecordStoreMutationObserver);
  }
  
  public ValueComparator getValueComparatorOf(InMemoryFormat inMemoryFormat) { return ValueComparatorUtil.getValueComparatorOf(inMemoryFormat); }
}
