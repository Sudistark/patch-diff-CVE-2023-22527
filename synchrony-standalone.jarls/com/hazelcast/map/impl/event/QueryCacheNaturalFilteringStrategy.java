package com.hazelcast.map.impl.event;

import com.hazelcast.core.EntryEventType;
import com.hazelcast.internal.serialization.InternalSerializationService;
import com.hazelcast.map.impl.EventListenerFilter;
import com.hazelcast.map.impl.MapServiceContext;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.EventFilter;

public class QueryCacheNaturalFilteringStrategy extends AbstractFilteringStrategy {
  private static final int EVENT_DATA_MAP_CAPACITY = 4;
  
  public QueryCacheNaturalFilteringStrategy(InternalSerializationService serializationService, MapServiceContext mapServiceContext) { super(serializationService, mapServiceContext); }
  
  public int doFilter(EventFilter filter, Data dataKey, Object oldValue, Object dataValue, EntryEventType eventType, String mapNameOrNull) {
    if (filter instanceof com.hazelcast.map.impl.MapPartitionLostEventFilter)
      return -1; 
    EventListenerFilter filterAsEventListenerFilter = null;
    boolean originalFilterEventTypeMatches = true;
    if (filter instanceof EventListenerFilter) {
      int type = eventType.getType();
      if (type == EntryEventType.INVALIDATION.getType())
        return -1; 
      originalFilterEventTypeMatches = filter.eval(Integer.valueOf(type));
      filterAsEventListenerFilter = (EventListenerFilter)filter;
      filter = ((EventListenerFilter)filter).getEventFilter();
      if (filter instanceof com.hazelcast.map.impl.nearcache.invalidation.UuidFilter)
        return -1; 
    } 
    if (originalFilterEventTypeMatches && filter instanceof com.hazelcast.spi.impl.eventservice.impl.TrueEventFilter)
      return eventType.getType(); 
    if (filter instanceof com.hazelcast.map.impl.query.QueryEventFilter) {
      int effectiveEventType = processQueryEventFilterWithAlternativeEventType(filter, eventType, dataKey, oldValue, dataValue, mapNameOrNull);
      if (effectiveEventType == -1)
        return -1; 
      if (filterAsEventListenerFilter != null && effectiveEventType != eventType.getType())
        return filterAsEventListenerFilter.eval(Integer.valueOf(effectiveEventType)) ? effectiveEventType : -1; 
      return effectiveEventType;
    } 
    if (filter instanceof com.hazelcast.map.impl.EntryEventFilter)
      return (originalFilterEventTypeMatches && processEntryEventFilter(filter, dataKey)) ? eventType
        .getType() : -1; 
    throw new IllegalArgumentException("Unknown EventFilter type = [" + filter.getClass().getCanonicalName() + "]");
  }
  
  public EntryEventDataCache getEntryEventDataCache() { return new EntryEventDataPerEventTypeCache(this, null); }
  
  public String toString() { return "QueryCacheNaturalFilteringStrategy"; }
  
  private int processQueryEventFilterWithAlternativeEventType(EventFilter filter, EntryEventType eventType, Data dataKey, Object dataOldValue, Object dataValue, String mapNameOrNull) {
    Object testValue;
    if (eventType == EntryEventType.UPDATED) {
      boolean newValueMatches = evaluateQueryEventFilter(filter, dataKey, dataValue, mapNameOrNull);
      boolean oldValueMatches = evaluateQueryEventFilter(filter, dataKey, dataOldValue, mapNameOrNull);
      if (oldValueMatches)
        return newValueMatches ? EntryEventType.UPDATED.getType() : EntryEventType.REMOVED.getType(); 
      return newValueMatches ? EntryEventType.ADDED.getType() : -1;
    } 
    if (eventType == EntryEventType.REMOVED || eventType == EntryEventType.EVICTED || eventType == EntryEventType.EXPIRED) {
      testValue = dataOldValue;
    } else {
      testValue = dataValue;
    } 
    return evaluateQueryEventFilter(filter, dataKey, testValue, mapNameOrNull) ? eventType
      .getType() : -1;
  }
}
