package com.hazelcast.map.impl.recordstore;

import com.hazelcast.config.InMemoryFormat;
import com.hazelcast.config.MapConfig;
import com.hazelcast.core.EntryEventType;
import com.hazelcast.core.EntryView;
import com.hazelcast.internal.eviction.ClearExpiredRecordsTask;
import com.hazelcast.internal.eviction.ExpiredKey;
import com.hazelcast.internal.nearcache.impl.invalidation.InvalidationQueue;
import com.hazelcast.internal.util.ToHeapDataConverter;
import com.hazelcast.map.impl.EntryCostEstimator;
import com.hazelcast.map.impl.ExpirationTimeSetter;
import com.hazelcast.map.impl.MapContainer;
import com.hazelcast.map.impl.event.MapEventPublisher;
import com.hazelcast.map.impl.eviction.Evictor;
import com.hazelcast.map.impl.record.Record;
import com.hazelcast.map.impl.record.RecordFactory;
import com.hazelcast.monitor.LocalRecordStoreStats;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.EventService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.merge.SplitBrainMergeTypes;
import com.hazelcast.spi.properties.GroupProperty;
import com.hazelcast.spi.properties.HazelcastProperties;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.TimeUnit;

public abstract class AbstractEvictableRecordStore extends AbstractRecordStore {
  protected final long expiryDelayMillis;
  
  protected final Address thisAddress;
  
  protected final EventService eventService;
  
  protected final MapEventPublisher mapEventPublisher;
  
  protected final ClearExpiredRecordsTask clearExpiredRecordsTask;
  
  protected final InvalidationQueue<ExpiredKey> expiredKeys = new InvalidationQueue();
  
  protected Iterator<Record> expirationIterator;
  
  protected AbstractEvictableRecordStore(MapContainer mapContainer, int partitionId) {
    super(mapContainer, partitionId);
    NodeEngine nodeEngine = this.mapServiceContext.getNodeEngine();
    HazelcastProperties hazelcastProperties = nodeEngine.getProperties();
    this.expiryDelayMillis = hazelcastProperties.getMillis(GroupProperty.MAP_EXPIRY_DELAY_SECONDS);
    this.eventService = nodeEngine.getEventService();
    this.mapEventPublisher = this.mapServiceContext.getMapEventPublisher();
    this.thisAddress = nodeEngine.getThisAddress();
    this.clearExpiredRecordsTask = this.mapServiceContext.getExpirationManager().getTask();
  }
  
  private boolean isRecordStoreExpirable() {
    MapConfig mapConfig = this.mapContainer.getMapConfig();
    return (this.hasEntryWithCustomExpiration || mapConfig.getMaxIdleSeconds() > 0 || mapConfig
      .getTimeToLiveSeconds() > 0);
  }
  
  public void evictExpiredEntries(int percentage, boolean backup) {
    long now = getNow();
    int size = size();
    int maxIterationCount = getMaxIterationCount(size, percentage);
    int maxRetry = 3;
    int loop = 0;
    int evictedEntryCount = 0;
    do {
      evictedEntryCount += evictExpiredEntriesInternal(maxIterationCount, now, backup);
      if (evictedEntryCount >= maxIterationCount)
        break; 
      ++loop;
    } while (loop <= maxRetry);
    accumulateOrSendExpiredKey(null);
  }
  
  public boolean isExpirable() { return isRecordStoreExpirable(); }
  
  public Object get(Data dataKey, boolean backup, Address callerAddress) { return get(dataKey, backup, callerAddress, true); }
  
  private int getMaxIterationCount(int size, int percentage) {
    int defaultMaxIterationCount = 100;
    float oneHundred = 100.0F;
    float maxIterationCount = size * percentage / 100.0F;
    if (maxIterationCount <= 100.0F)
      return 100; 
    return Math.round(maxIterationCount);
  }
  
  private int evictExpiredEntriesInternal(int maxIterationCount, long now, boolean backup) {
    int evictedEntryCount = 0;
    int checkedEntryCount = 0;
    initExpirationIterator();
    LinkedList<Record> records = new LinkedList<Record>();
    while (this.expirationIterator.hasNext() && 
      checkedEntryCount < maxIterationCount) {
      checkedEntryCount++;
      records.add(this.expirationIterator.next());
    } 
    while (!records.isEmpty()) {
      if (getOrNullIfExpired((Record)records.poll(), now, backup) == null)
        evictedEntryCount++; 
    } 
    return evictedEntryCount;
  }
  
  private void initExpirationIterator() {
    if (this.expirationIterator == null || !this.expirationIterator.hasNext())
      this.expirationIterator = this.storage.mutationTolerantIterator(); 
  }
  
  public void evictEntries(Data excludedKey) {
    if (shouldEvict())
      this.mapContainer.getEvictor().evict(this, excludedKey); 
  }
  
  public void sampleAndForceRemoveEntries(int entryCountToRemove) {
    Queue<Data> keysToRemove = new LinkedList<Data>();
    Iterable<EntryView> sample = this.storage.getRandomSamples(entryCountToRemove);
    for (EntryView entryView : sample) {
      Data dataKey = this.storage.extractRecordFromLazy(entryView).getKey();
      keysToRemove.add(dataKey);
    } 
    Data dataKey;
    while ((dataKey = (Data)keysToRemove.poll()) != null)
      evict(dataKey, true); 
  }
  
  public boolean shouldEvict() {
    Evictor evictor = this.mapContainer.getEvictor();
    return (evictor != Evictor.NULL_EVICTOR && evictor.checkEvictable(this));
  }
  
  protected void markRecordStoreExpirable(long ttl, long maxIdle) {
    if (isTtlDefined(ttl) || isMaxIdleDefined(maxIdle))
      this.hasEntryWithCustomExpiration = true; 
    if (isRecordStoreExpirable())
      this.mapServiceContext.getExpirationManager().scheduleExpirationTask(); 
  }
  
  protected boolean isTtlDefined(long ttl) { return (ttl > 0L && ttl < Float.MAX_VALUE); }
  
  protected boolean isMaxIdleDefined(long maxIdle) { return (maxIdle > 0L && maxIdle < Float.MAX_VALUE); }
  
  protected Record getOrNullIfExpired(Record record, long now, boolean backup) {
    if (!isRecordStoreExpirable())
      return record; 
    if (record == null)
      return null; 
    Data key = record.getKey();
    if (isLocked(key))
      return record; 
    if (!isExpired(record, now, backup))
      return record; 
    evict(key, backup);
    if (!backup)
      doPostEvictionOperations(record); 
    return null;
  }
  
  public boolean isExpired(Record record, long now, boolean backup) {
    return (record == null || 
      isIdleExpired(record, now, backup) || 
      isTTLExpired(record, now, backup));
  }
  
  private boolean isIdleExpired(Record record, long now, boolean backup) {
    if (backup && this.mapServiceContext.getClearExpiredRecordsTask().canPrimaryDriveExpiration())
      return false; 
    long maxIdleMillis = getRecordMaxIdleOrConfig(record);
    if (maxIdleMillis < 1L || maxIdleMillis == Float.MAX_VALUE)
      return false; 
    long idlenessStartTime = ExpirationTimeSetter.getIdlenessStartTime(record);
    long idleMillis = ExpirationTimeSetter.calculateExpirationWithDelay(maxIdleMillis, this.expiryDelayMillis, backup);
    long elapsedMillis = now - idlenessStartTime;
    return (elapsedMillis >= idleMillis);
  }
  
  private boolean isTTLExpired(Record record, long now, boolean backup) {
    if (record == null)
      return false; 
    long ttl = getRecordTTLOrConfig(record);
    if (ttl < 1L || ttl == Float.MAX_VALUE)
      return false; 
    long ttlStartTime = ExpirationTimeSetter.getLifeStartTime(record);
    long ttlMillis = ExpirationTimeSetter.calculateExpirationWithDelay(ttl, this.expiryDelayMillis, backup);
    long elapsedMillis = now - ttlStartTime;
    return (elapsedMillis >= ttlMillis);
  }
  
  private long getRecordMaxIdleOrConfig(Record record) {
    if (record.getMaxIdle() != -1L)
      return record.getMaxIdle(); 
    return TimeUnit.SECONDS.toMillis(this.mapContainer.getMapConfig().getMaxIdleSeconds());
  }
  
  private long getRecordTTLOrConfig(Record record) {
    if (record.getTtl() != -1L)
      return record.getTtl(); 
    return TimeUnit.SECONDS.toMillis(this.mapContainer.getMapConfig().getTimeToLiveSeconds());
  }
  
  public void doPostEvictionOperations(Record record) {
    Data key = record.getKey();
    Object value = record.getValue();
    boolean hasEventRegistration = this.eventService.hasEventRegistration("hz:impl:mapService", this.name);
    if (hasEventRegistration)
      this.mapEventPublisher.publishEvent(this.thisAddress, this.name, EntryEventType.EVICTED, key, value, null); 
    long now = getNow();
    boolean idleExpired = isIdleExpired(record, now, false);
    boolean ttlExpired = isTTLExpired(record, now, false);
    boolean expired = (idleExpired || ttlExpired);
    if (expired && hasEventRegistration)
      this.mapEventPublisher.publishEvent(this.thisAddress, this.name, EntryEventType.EXPIRED, key, value, null); 
    if (!ttlExpired && idleExpired)
      accumulateOrSendExpiredKey(record); 
  }
  
  public InvalidationQueue<ExpiredKey> getExpiredKeysQueue() { return this.expiredKeys; }
  
  private void accumulateOrSendExpiredKey(Record record) {
    if (this.mapContainer.getTotalBackupCount() == 0)
      return; 
    if (record != null)
      this.expiredKeys.offer(new ExpiredKey(ToHeapDataConverter.toHeapData(record.getKey()), record.getCreationTime())); 
    this.clearExpiredRecordsTask.tryToSendBackupExpiryOp(this, true);
  }
  
  public void accessRecord(Record record, long now) {
    record.onAccess(now);
    updateStatsOnGet(now);
    ExpirationTimeSetter.setExpirationTime(record);
  }
  
  protected void mergeRecordExpiration(Record record, EntryView mergingEntry) {
    mergeRecordExpiration(record, mergingEntry.getTtl(), mergingEntry.getMaxIdle(), mergingEntry.getCreationTime(), mergingEntry
        .getLastAccessTime(), mergingEntry.getLastUpdateTime());
  }
  
  protected void mergeRecordExpiration(Record record, SplitBrainMergeTypes.MapMergeTypes mergingEntry) {
    mergeRecordExpiration(record, mergingEntry.getTtl(), mergingEntry.getMaxIdle(), mergingEntry.getCreationTime(), mergingEntry
        .getLastAccessTime(), mergingEntry.getLastUpdateTime());
  }
  
  private void mergeRecordExpiration(Record record, long ttlMillis, Long maxIdleMillis, long creationTime, long lastAccessTime, long lastUpdateTime) {
    record.setTtl(ttlMillis);
    if (maxIdleMillis != null)
      record.setMaxIdle(maxIdleMillis.longValue()); 
    record.setCreationTime(creationTime);
    record.setLastAccessTime(lastAccessTime);
    record.setLastUpdateTime(lastUpdateTime);
    ExpirationTimeSetter.setExpirationTime(record);
    markRecordStoreExpirable(record.getTtl(), record.getMaxIdle());
  }
}
