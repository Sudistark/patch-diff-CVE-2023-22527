package com.hazelcast.map.impl.tx;

import com.hazelcast.core.TransactionalMap;
import com.hazelcast.internal.nearcache.NearCachingHook;
import com.hazelcast.map.impl.MapService;
import com.hazelcast.map.impl.query.Query;
import com.hazelcast.map.impl.query.QueryEngine;
import com.hazelcast.map.impl.query.QueryResult;
import com.hazelcast.map.impl.query.QueryResultUtils;
import com.hazelcast.map.impl.query.Target;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.query.Predicate;
import com.hazelcast.query.TruePredicate;
import com.hazelcast.query.impl.CachedQueryEntry;
import com.hazelcast.query.impl.getters.Extractors;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.transaction.impl.Transaction;
import com.hazelcast.util.IterationType;
import com.hazelcast.util.Preconditions;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

public class TransactionalMapProxy extends TransactionalMapProxySupport implements TransactionalMap {
  private final Map<Data, TxnValueWrapper> txMap = new HashMap();
  
  public TransactionalMapProxy(String name, MapService mapService, NodeEngine nodeEngine, Transaction transaction) { super(name, mapService, nodeEngine, transaction); }
  
  public boolean containsKey(Object key) { return containsKey(key, false); }
  
  public boolean containsKey(Object key, boolean skipNearCacheLookup) {
    checkTransactionState();
    Preconditions.checkNotNull(key, "key can't be null");
    Data keyData = this.mapServiceContext.toData(key, this.partitionStrategy);
    TxnValueWrapper valueWrapper = (TxnValueWrapper)this.txMap.get(keyData);
    if (valueWrapper != null)
      return (valueWrapper.type != TxnValueWrapper.Type.REMOVED); 
    return containsKeyInternal(keyData, key, skipNearCacheLookup);
  }
  
  public int size() {
    checkTransactionState();
    int currentSize = sizeInternal();
    for (Map.Entry<Data, TxnValueWrapper> entry : this.txMap.entrySet()) {
      TxnValueWrapper wrapper = (TxnValueWrapper)entry.getValue();
      if (wrapper.type == TxnValueWrapper.Type.NEW) {
        currentSize++;
        continue;
      } 
      if (wrapper.type == TxnValueWrapper.Type.REMOVED) {
        VersionedValue versionedValue = (VersionedValue)this.valueMap.get(entry.getKey());
        if (versionedValue != null && versionedValue.value != null)
          currentSize--; 
      } 
    } 
    return currentSize;
  }
  
  public boolean isEmpty() {
    checkTransactionState();
    return (size() == 0);
  }
  
  public Object get(Object key) { return get(key, false); }
  
  public Object get(Object key, boolean skipNearCacheLookup) {
    checkTransactionState();
    Preconditions.checkNotNull(key, "key can't be null");
    Object nearCacheKey = toNearCacheKeyWithStrategy(key);
    Data keyData = this.mapServiceContext.toData(nearCacheKey, this.partitionStrategy);
    TxnValueWrapper currentValue = (TxnValueWrapper)this.txMap.get(keyData);
    if (currentValue != null)
      return checkIfRemoved(currentValue); 
    return toObjectIfNeeded(getInternal(nearCacheKey, keyData, skipNearCacheLookup));
  }
  
  public Object getForUpdate(Object key) {
    checkTransactionState();
    Preconditions.checkNotNull(key, "key can't be null");
    Data keyData = this.mapServiceContext.toData(key, this.partitionStrategy);
    TxnValueWrapper currentValue = (TxnValueWrapper)this.txMap.get(keyData);
    if (currentValue != null)
      return checkIfRemoved(currentValue); 
    return toObjectIfNeeded(getForUpdateInternal(keyData));
  }
  
  public Object put(Object key, Object value) { return put(key, value, -1L, TimeUnit.MILLISECONDS); }
  
  public Object put(Object key, Object value, long ttl, TimeUnit timeUnit) {
    checkTransactionState();
    Preconditions.checkNotNull(key, "key can't be null");
    Preconditions.checkNotNull(value, "value can't be null");
    Data keyData = this.mapServiceContext.toData(key, this.partitionStrategy);
    Data valueData = this.mapServiceContext.toData(value);
    NearCachingHook nearCachingHook = newNearCachingHook();
    nearCachingHook.beforeRemoteCall(key, keyData, value, valueData);
    Object valueBeforeTxn = toObjectIfNeeded(putInternal(keyData, valueData, ttl, timeUnit, nearCachingHook));
    TxnValueWrapper currentValue = (TxnValueWrapper)this.txMap.get(keyData);
    TxnValueWrapper.Type type = (valueBeforeTxn == null) ? TxnValueWrapper.Type.NEW : TxnValueWrapper.Type.UPDATED;
    TxnValueWrapper wrapper = new TxnValueWrapper(value, type);
    this.txMap.put(keyData, wrapper);
    return (currentValue == null) ? valueBeforeTxn : checkIfRemoved(currentValue);
  }
  
  public void set(Object key, Object value) {
    checkTransactionState();
    Preconditions.checkNotNull(key, "key can't be null");
    Preconditions.checkNotNull(value, "value can't be null");
    Data keyData = this.mapServiceContext.toData(key, this.partitionStrategy);
    Data valueData = this.mapServiceContext.toData(value);
    NearCachingHook nearCachingHook = newNearCachingHook();
    nearCachingHook.beforeRemoteCall(key, keyData, value, valueData);
    Data dataBeforeTxn = putInternal(keyData, valueData, -1L, TimeUnit.MILLISECONDS, nearCachingHook);
    TxnValueWrapper.Type type = (dataBeforeTxn == null) ? TxnValueWrapper.Type.NEW : TxnValueWrapper.Type.UPDATED;
    TxnValueWrapper wrapper = new TxnValueWrapper(value, type);
    this.txMap.put(keyData, wrapper);
  }
  
  public Object putIfAbsent(Object key, Object value) {
    checkTransactionState();
    Preconditions.checkNotNull(key, "key can't be null");
    Preconditions.checkNotNull(value, "value can't be null");
    Data keyData = this.mapServiceContext.toData(key, this.partitionStrategy);
    Data valueData = this.mapServiceContext.toData(value);
    NearCachingHook nearCachingHook = newNearCachingHook();
    nearCachingHook.beforeRemoteCall(key, keyData, value, valueData);
    TxnValueWrapper wrapper = (TxnValueWrapper)this.txMap.get(keyData);
    boolean haveTxnPast = (wrapper != null);
    if (haveTxnPast) {
      if (wrapper.type != TxnValueWrapper.Type.REMOVED)
        return wrapper.value; 
      putInternal(keyData, valueData, -1L, TimeUnit.MILLISECONDS, nearCachingHook);
      this.txMap.put(keyData, new TxnValueWrapper(value, TxnValueWrapper.Type.NEW));
      return null;
    } 
    Data oldValue = putIfAbsentInternal(keyData, valueData, nearCachingHook);
    if (oldValue == null)
      this.txMap.put(keyData, new TxnValueWrapper(value, TxnValueWrapper.Type.NEW)); 
    return toObjectIfNeeded(oldValue);
  }
  
  public Object replace(Object key, Object value) {
    checkTransactionState();
    Preconditions.checkNotNull(key, "key can't be null");
    Preconditions.checkNotNull(value, "value can't be null");
    Data keyData = this.mapServiceContext.toData(key, this.partitionStrategy);
    Data valueData = this.mapServiceContext.toData(value);
    NearCachingHook nearCachingHook = newNearCachingHook();
    nearCachingHook.beforeRemoteCall(key, keyData, value, valueData);
    TxnValueWrapper wrapper = (TxnValueWrapper)this.txMap.get(keyData);
    boolean haveTxnPast = (wrapper != null);
    if (haveTxnPast) {
      if (wrapper.type == TxnValueWrapper.Type.REMOVED)
        return null; 
      putInternal(keyData, valueData, -1L, TimeUnit.MILLISECONDS, nearCachingHook);
      this.txMap.put(keyData, new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED));
      return wrapper.value;
    } 
    Data oldValue = replaceInternal(keyData, valueData, nearCachingHook);
    if (oldValue != null)
      this.txMap.put(keyData, new TxnValueWrapper(value, TxnValueWrapper.Type.UPDATED)); 
    return toObjectIfNeeded(oldValue);
  }
  
  public boolean replace(Object key, Object oldValue, Object newValue) {
    checkTransactionState();
    Preconditions.checkNotNull(key, "key can't be null");
    Preconditions.checkNotNull(oldValue, "oldValue can't be null");
    Preconditions.checkNotNull(newValue, "newValue can't be null");
    Data keyData = this.mapServiceContext.toData(key, this.partitionStrategy);
    Data newValueData = this.mapServiceContext.toData(newValue);
    NearCachingHook nearCachingHook = newNearCachingHook();
    nearCachingHook.beforeRemoteCall(key, keyData, newValue, newValueData);
    TxnValueWrapper wrapper = (TxnValueWrapper)this.txMap.get(keyData);
    boolean haveTxnPast = (wrapper != null);
    if (haveTxnPast) {
      if (!wrapper.value.equals(oldValue))
        return false; 
      putInternal(keyData, newValueData, -1L, TimeUnit.MILLISECONDS, nearCachingHook);
      this.txMap.put(keyData, new TxnValueWrapper(wrapper.value, TxnValueWrapper.Type.UPDATED));
      return true;
    } 
    boolean success = replaceIfSameInternal(keyData, this.mapServiceContext
        .toData(oldValue), newValueData, nearCachingHook);
    if (success)
      this.txMap.put(keyData, new TxnValueWrapper(newValue, TxnValueWrapper.Type.UPDATED)); 
    return success;
  }
  
  public boolean remove(Object key, Object value) {
    checkTransactionState();
    Preconditions.checkNotNull(key, "key can't be null");
    Preconditions.checkNotNull(value, "value can't be null");
    Data keyData = this.mapServiceContext.toData(key, this.partitionStrategy);
    NearCachingHook nearCachingHook = newNearCachingHook();
    nearCachingHook.beforeRemoteCall(key, keyData, null, null);
    TxnValueWrapper wrapper = (TxnValueWrapper)this.txMap.get(keyData);
    if (wrapper == null) {
      boolean removed = removeIfSameInternal(keyData, value, nearCachingHook);
      if (removed)
        this.txMap.put(keyData, new TxnValueWrapper(value, TxnValueWrapper.Type.REMOVED)); 
      return removed;
    } 
    if (wrapper.type == TxnValueWrapper.Type.REMOVED)
      return false; 
    if (!isEquals(wrapper.value, value))
      return false; 
    removeInternal(keyData, nearCachingHook);
    this.txMap.put(keyData, new TxnValueWrapper(value, TxnValueWrapper.Type.REMOVED));
    return true;
  }
  
  public Object remove(Object key) {
    checkTransactionState();
    Preconditions.checkNotNull(key, "key can't be null");
    Data keyData = this.mapServiceContext.toData(key, this.partitionStrategy);
    NearCachingHook nearCachingHook = newNearCachingHook();
    nearCachingHook.beforeRemoteCall(key, keyData, null, null);
    Object valueBeforeTxn = toObjectIfNeeded(removeInternal(keyData, nearCachingHook));
    TxnValueWrapper wrapper = null;
    if (valueBeforeTxn != null || this.txMap.containsKey(keyData))
      wrapper = (TxnValueWrapper)this.txMap.put(keyData, new TxnValueWrapper(valueBeforeTxn, TxnValueWrapper.Type.REMOVED)); 
    return (wrapper == null) ? valueBeforeTxn : checkIfRemoved(wrapper);
  }
  
  public void delete(Object key) {
    checkTransactionState();
    Preconditions.checkNotNull(key, "key can't be null");
    Data keyData = this.mapServiceContext.toData(key, this.partitionStrategy);
    NearCachingHook nearCachingHook = newNearCachingHook();
    nearCachingHook.beforeRemoteCall(key, keyData, null, null);
    Data data = removeInternal(keyData, nearCachingHook);
    if (data != null || this.txMap.containsKey(keyData))
      this.txMap.put(keyData, new TxnValueWrapper(toObjectIfNeeded(data), TxnValueWrapper.Type.REMOVED)); 
  }
  
  public Set<Object> keySet() { return keySet(TruePredicate.INSTANCE); }
  
  public Set keySet(Predicate predicate) {
    checkTransactionState();
    Preconditions.checkNotNull(predicate, "Predicate should not be null!");
    Preconditions.checkNotInstanceOf(com.hazelcast.query.PagingPredicate.class, predicate, "Paging is not supported for Transactional queries!");
    QueryEngine queryEngine = this.mapServiceContext.getQueryEngine(this.name);
    Query query = Query.of().mapName(this.name).predicate(predicate).iterationType(IterationType.KEY).build();
    QueryResult queryResult = (QueryResult)queryEngine.execute(query, Target.ALL_NODES);
    Set queryResultSet = QueryResultUtils.transformToSet(this.ss, queryResult, predicate, IterationType.KEY, true, this.tx
        .isOriginatedFromClient());
    Extractors extractors = this.mapServiceContext.getExtractors(this.name);
    Set<Object> returningKeySet = new HashSet<Object>(queryResultSet);
    CachedQueryEntry cachedQueryEntry = new CachedQueryEntry();
    for (Map.Entry<Data, TxnValueWrapper> entry : this.txMap.entrySet()) {
      if (((TxnValueWrapper)entry.getValue()).type == TxnValueWrapper.Type.REMOVED) {
        returningKeySet.remove(toObjectIfNeeded(entry.getKey()));
        continue;
      } 
      Data keyData = (Data)entry.getKey();
      if (predicate == TruePredicate.INSTANCE) {
        returningKeySet.add(toObjectIfNeeded(keyData));
        continue;
      } 
      cachedQueryEntry.init(this.ss, keyData, ((TxnValueWrapper)entry.getValue()).value, extractors);
      if (predicate.apply(cachedQueryEntry))
        returningKeySet.add(toObjectIfNeeded(keyData)); 
    } 
    return returningKeySet;
  }
  
  public Collection<Object> values() { return values(TruePredicate.INSTANCE); }
  
  public Collection values(Predicate predicate) {
    checkTransactionState();
    Preconditions.checkNotNull(predicate, "Predicate can not be null!");
    Preconditions.checkNotInstanceOf(com.hazelcast.query.PagingPredicate.class, predicate, "Paging is not supported for Transactional queries");
    QueryEngine queryEngine = this.mapServiceContext.getQueryEngine(this.name);
    Query query = Query.of().mapName(this.name).predicate(predicate).iterationType(IterationType.ENTRY).build();
    QueryResult queryResult = (QueryResult)queryEngine.execute(query, Target.ALL_NODES);
    Set result = QueryResultUtils.transformToSet(this.ss, queryResult, predicate, IterationType.ENTRY, true, true);
    List<Object> valueSet = new ArrayList<Object>();
    Set<Data> keyWontBeIncluded = new HashSet<Data>();
    Extractors extractors = this.mapServiceContext.getExtractors(this.name);
    CachedQueryEntry cachedQueryEntry = new CachedQueryEntry();
    for (Map.Entry<Data, TxnValueWrapper> entry : this.txMap.entrySet()) {
      boolean isRemoved = TxnValueWrapper.Type.REMOVED.equals(((TxnValueWrapper)entry.getValue()).type);
      boolean isUpdated = TxnValueWrapper.Type.UPDATED.equals(((TxnValueWrapper)entry.getValue()).type);
      if (isRemoved) {
        keyWontBeIncluded.add(entry.getKey());
        continue;
      } 
      if (isUpdated)
        keyWontBeIncluded.add(entry.getKey()); 
      Object entryValue = ((TxnValueWrapper)entry.getValue()).value;
      cachedQueryEntry.init(this.ss, (Data)entry.getKey(), entryValue, extractors);
      if (predicate.apply(cachedQueryEntry))
        valueSet.add(toObjectIfNeeded(cachedQueryEntry.getValueData())); 
    } 
    removeFromResultSet(result, valueSet, keyWontBeIncluded);
    return valueSet;
  }
  
  public String toString() { return "TransactionalMap{name='" + this.name + '\'' + '}'; }
  
  private Object checkIfRemoved(TxnValueWrapper wrapper) {
    checkTransactionState();
    return (wrapper == null || wrapper.type == TxnValueWrapper.Type.REMOVED) ? null : wrapper.value;
  }
  
  private void removeFromResultSet(Set<Map.Entry> queryResultSet, List<Object> valueSet, Set<Data> keyWontBeIncluded) {
    for (Map.Entry entry : queryResultSet) {
      if (keyWontBeIncluded.contains(entry.getKey()))
        continue; 
      valueSet.add(toObjectIfNeeded(entry.getValue()));
    } 
  }
}
