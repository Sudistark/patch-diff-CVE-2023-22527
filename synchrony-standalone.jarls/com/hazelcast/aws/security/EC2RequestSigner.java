package com.hazelcast.aws.security;

import com.hazelcast.aws.AwsConfig;
import com.hazelcast.aws.utility.AwsURLEncoder;
import com.hazelcast.util.QuickMath;
import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

public class EC2RequestSigner {
  private static final String NEW_LINE = "\n";
  
  private static final String API_TERMINATOR = "aws4_request";
  
  private static final String HMAC_SHA256 = "HmacSHA256";
  
  private static final String UTF_8 = "UTF-8";
  
  private static final int DATE_LENGTH = 8;
  
  private static final int LAST_INDEX = 8;
  
  private final AwsConfig config;
  
  private final String timestamp;
  
  private String service;
  
  private Map<String, String> attributes;
  
  private String endpoint;
  
  public EC2RequestSigner(AwsConfig config, String timeStamp, String endpoint) {
    this.config = config;
    this.timestamp = timeStamp;
    this.service = null;
    this.endpoint = endpoint;
  }
  
  public String getCredentialScope() {
    String dateStamp = this.timestamp.substring(0, 8);
    return String.format("%s/%s/%s/%s", new Object[] { dateStamp, this.config.getRegion(), this.service, "aws4_request" });
  }
  
  public String getSignedHeaders() { return "host"; }
  
  public String sign(String service, Map<String, String> attributes) {
    this.service = service;
    this.attributes = attributes;
    String canonicalRequest = getCanonicalizedRequest();
    String stringToSign = createStringToSign(canonicalRequest);
    byte[] signingKey = deriveSigningKey();
    return createSignature(stringToSign, signingKey);
  }
  
  private String getCanonicalizedRequest() {
    return "GET\n/\n" + getCanonicalizedQueryString(this.attributes) + "\n" + 
      getCanonicalHeaders() + "\n" + getSignedHeaders() + "\n" + sha256Hashhex("");
  }
  
  private String createStringToSign(String canonicalRequest) { return "AWS4-HMAC-SHA256\n" + this.timestamp + "\n" + getCredentialScope() + "\n" + sha256Hashhex(canonicalRequest); }
  
  private byte[] deriveSigningKey() {
    String signKey = this.config.getSecretKey();
    String dateStamp = this.timestamp.substring(0, 8);
    try {
      String key = "AWS4" + signKey;
      Mac mDate = Mac.getInstance("HmacSHA256");
      SecretKeySpec skDate = new SecretKeySpec(key.getBytes("UTF-8"), "HmacSHA256");
      mDate.init(skDate);
      byte[] kDate = mDate.doFinal(dateStamp.getBytes("UTF-8"));
      Mac mRegion = Mac.getInstance("HmacSHA256");
      SecretKeySpec skRegion = new SecretKeySpec(kDate, "HmacSHA256");
      mRegion.init(skRegion);
      byte[] kRegion = mRegion.doFinal(this.config.getRegion().getBytes("UTF-8"));
      Mac mService = Mac.getInstance("HmacSHA256");
      SecretKeySpec skService = new SecretKeySpec(kRegion, "HmacSHA256");
      mService.init(skService);
      byte[] kService = mService.doFinal(this.service.getBytes("UTF-8"));
      Mac mSigning = Mac.getInstance("HmacSHA256");
      SecretKeySpec skSigning = new SecretKeySpec(kService, "HmacSHA256");
      mSigning.init(skSigning);
      return mSigning.doFinal("aws4_request".getBytes("UTF-8"));
    } catch (NoSuchAlgorithmException e) {
      return null;
    } catch (InvalidKeyException e) {
      return null;
    } catch (UnsupportedEncodingException e) {
      return null;
    } 
  }
  
  private String createSignature(String stringToSign, byte[] signingKey) {
    byte[] signature;
    try {
      Mac signMac = Mac.getInstance("HmacSHA256");
      SecretKeySpec signKS = new SecretKeySpec(signingKey, "HmacSHA256");
      signMac.init(signKS);
      signature = signMac.doFinal(stringToSign.getBytes("UTF-8"));
    } catch (NoSuchAlgorithmException e) {
      return null;
    } catch (InvalidKeyException e) {
      return null;
    } catch (UnsupportedEncodingException e) {
      return null;
    } 
    return QuickMath.bytesToHex(signature);
  }
  
  protected String getCanonicalHeaders() { return String.format("host:%s%s", new Object[] { this.endpoint, "\n" }); }
  
  public String getCanonicalizedQueryString(Map<String, String> attributes) {
    List<String> components = getListOfEntries(attributes);
    Collections.sort(components);
    return getCanonicalizedQueryString(components);
  }
  
  protected String getCanonicalizedQueryString(List<String> list) {
    Iterator<String> it = list.iterator();
    StringBuilder result = new StringBuilder((String)it.next());
    while (it.hasNext())
      result.append('&').append((String)it.next()); 
    return result.toString();
  }
  
  protected void addComponents(List<String> components, Map<String, String> attributes, String key) { components.add(AwsURLEncoder.urlEncode(key) + '=' + AwsURLEncoder.urlEncode((String)attributes.get(key))); }
  
  protected List<String> getListOfEntries(Map<String, String> entries) {
    List<String> components = new ArrayList<String>();
    for (String key : entries.keySet())
      addComponents(components, entries, key); 
    return components;
  }
  
  private String sha256Hashhex(String in) {
    String payloadHash;
    try {
      MessageDigest md = MessageDigest.getInstance("SHA-256");
      md.update(in.getBytes("UTF-8"));
      byte[] digest = md.digest();
      payloadHash = QuickMath.bytesToHex(digest);
    } catch (NoSuchAlgorithmException e) {
      return null;
    } catch (UnsupportedEncodingException e) {
      return null;
    } 
    return payloadHash;
  }
  
  public String createFormattedCredential() { return this.config.getAccessKey() + '/' + this.timestamp.substring(0, 8) + '/' + this.config.getRegion() + '/' + "ec2/aws4_request"; }
}
