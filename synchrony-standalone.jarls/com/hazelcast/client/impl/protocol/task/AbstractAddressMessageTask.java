package com.hazelcast.client.impl.protocol.task;

import com.hazelcast.client.impl.protocol.ClientMessage;
import com.hazelcast.core.ExecutionCallback;
import com.hazelcast.instance.Node;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.Connection;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.impl.executionservice.InternalExecutionService;
import com.hazelcast.util.executor.ManagedExecutorService;
import java.util.concurrent.Executor;

public abstract class AbstractAddressMessageTask<P> extends AbstractMessageTask<P> implements ExecutionCallback, Executor {
  protected AbstractAddressMessageTask(ClientMessage clientMessage, Node node, Connection connection) { super(clientMessage, node, connection); }
  
  protected void beforeProcess() {}
  
  protected void beforeResponse() {}
  
  protected void afterResponse() {}
  
  public final void processMessage() {
    beforeProcess();
    Operation op = prepareOperation();
    op.setCallerUuid(this.endpoint.getUuid());
    InternalCompletableFuture internalCompletableFuture = this.nodeEngine.getOperationService().createInvocationBuilder(getServiceName(), op, getAddress()).setResultDeserialized(false).invoke();
    internalCompletableFuture.andThen(this, this);
  }
  
  protected abstract Address getAddress();
  
  protected abstract Operation prepareOperation();
  
  public void execute(Runnable command) {
    if (Thread.currentThread().getClass() == com.hazelcast.spi.impl.operationexecutor.impl.PartitionOperationThread.class) {
      command.run();
    } else {
      InternalExecutionService internalExecutionService = this.nodeEngine.getExecutionService();
      ManagedExecutorService managedExecutorService = internalExecutionService.getExecutor("hz:async");
      managedExecutorService.execute(command);
    } 
  }
  
  public void onResponse(Object response) {
    beforeResponse();
    sendResponse(response);
    afterResponse();
  }
  
  public void onFailure(Throwable t) {
    beforeResponse();
    handleProcessingFailure(t);
    afterResponse();
  }
}
