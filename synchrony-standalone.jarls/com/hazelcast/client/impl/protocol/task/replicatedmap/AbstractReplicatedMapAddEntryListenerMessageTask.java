package com.hazelcast.client.impl.protocol.task.replicatedmap;

import com.hazelcast.client.impl.protocol.ClientMessage;
import com.hazelcast.client.impl.protocol.task.AbstractCallableMessageTask;
import com.hazelcast.client.impl.protocol.task.ListenerMessageTask;
import com.hazelcast.core.EntryEvent;
import com.hazelcast.core.EntryListener;
import com.hazelcast.core.IMapEvent;
import com.hazelcast.core.MapEvent;
import com.hazelcast.core.Member;
import com.hazelcast.instance.Node;
import com.hazelcast.map.impl.DataAwareEntryEvent;
import com.hazelcast.nio.Connection;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.query.Predicate;
import com.hazelcast.replicatedmap.impl.ReplicatedMapEventPublishingService;
import com.hazelcast.replicatedmap.impl.ReplicatedMapService;
import com.hazelcast.replicatedmap.impl.record.ReplicatedEntryEventFilter;
import com.hazelcast.replicatedmap.impl.record.ReplicatedQueryEventFilter;
import com.hazelcast.security.permission.MapPermission;
import java.security.Permission;

public abstract class AbstractReplicatedMapAddEntryListenerMessageTask<Parameter> extends AbstractCallableMessageTask<Parameter> implements EntryListener<Object, Object>, ListenerMessageTask {
  public AbstractReplicatedMapAddEntryListenerMessageTask(ClientMessage clientMessage, Node node, Connection connection) { super(clientMessage, node, connection); }
  
  protected Object call() {
    String registrationId;
    ReplicatedMapService service = (ReplicatedMapService)getService("hz:impl:replicatedMapService");
    ReplicatedMapEventPublishingService eventPublishingService = service.getEventPublishingService();
    Predicate predicate = getPredicate();
    if (predicate == null) {
      registrationId = eventPublishingService.addEventListener(this, new ReplicatedEntryEventFilter(
            getKey()), getDistributedObjectName());
    } else {
      registrationId = eventPublishingService.addEventListener(this, new ReplicatedQueryEventFilter(
            getKey(), predicate), getDistributedObjectName());
    } 
    this.endpoint.addListenerDestroyAction("hz:impl:replicatedMapService", getDistributedObjectName(), registrationId);
    return registrationId;
  }
  
  public String getServiceName() { return "hz:impl:replicatedMapService"; }
  
  public String getMethodName() { return "addEntryListener"; }
  
  public Permission getRequiredPermission() { return new MapPermission(getDistributedObjectName(), new String[] { "listen" }); }
  
  public abstract Predicate getPredicate();
  
  public abstract Data getKey();
  
  protected abstract boolean isLocalOnly();
  
  private void handleEvent(EntryEvent<Object, Object> event) {
    if (!shouldSendEvent(event))
      return; 
    DataAwareEntryEvent dataAwareEntryEvent = (DataAwareEntryEvent)event;
    Data key = dataAwareEntryEvent.getKeyData();
    Data newValue = dataAwareEntryEvent.getNewValueData();
    Data oldValue = dataAwareEntryEvent.getOldValueData();
    Data mergingValue = dataAwareEntryEvent.getMergingValueData();
    ClientMessage clientMessage = encodeEvent(key, newValue, oldValue, mergingValue, event
        .getEventType().getType(), event
        .getMember().getUuid(), 1);
    sendClientMessage(key, clientMessage);
  }
  
  private void handleMapEvent(MapEvent event) {
    if (!shouldSendEvent(event))
      return; 
    ClientMessage clientMessage = encodeEvent(null, null, null, null, event
        .getEventType().getType(), event
        .getMember().getUuid(), event.getNumberOfEntriesAffected());
    sendClientMessage(null, clientMessage);
  }
  
  private boolean shouldSendEvent(IMapEvent event) {
    if (!this.endpoint.isAlive())
      return false; 
    Member originatedMember = event.getMember();
    if (isLocalOnly() && !this.nodeEngine.getLocalMember().equals(originatedMember))
      return false; 
    return true;
  }
  
  protected abstract ClientMessage encodeEvent(Data paramData1, Data paramData2, Data paramData3, Data paramData4, int paramInt1, String paramString, int paramInt2);
  
  public void entryAdded(EntryEvent<Object, Object> event) { handleEvent(event); }
  
  public void entryRemoved(EntryEvent<Object, Object> event) { handleEvent(event); }
  
  public void entryUpdated(EntryEvent<Object, Object> event) { handleEvent(event); }
  
  public void entryEvicted(EntryEvent<Object, Object> event) { handleEvent(event); }
  
  public void mapEvicted(MapEvent event) {}
  
  public void mapCleared(MapEvent event) { handleMapEvent(event); }
}
