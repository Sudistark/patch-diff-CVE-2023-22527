package com.hazelcast.client.impl.protocol.codec;

import com.hazelcast.client.impl.protocol.ClientMessage;
import com.hazelcast.nio.serialization.Data;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;

@SuppressFBWarnings({"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD"})
public final class MapReduceForMapCodec {
  public static final MapReduceMessageType REQUEST_TYPE = MapReduceMessageType.MAPREDUCE_FORMAP;
  
  public static final int RESPONSE_TYPE = 117;
  
  public static ClientMessage encodeRequest(String name, String jobId, Data predicate, Data mapper, Data combinerFactory, Data reducerFactory, String mapName, int chunkSize, Collection<Data> keys, String topologyChangedStrategy) {
    int requiredDataSize = RequestParameters.calculateDataSize(name, jobId, predicate, mapper, combinerFactory, reducerFactory, mapName, chunkSize, keys, topologyChangedStrategy);
    ClientMessage clientMessage = ClientMessage.createForEncode(requiredDataSize);
    clientMessage.setMessageType(REQUEST_TYPE.id());
    clientMessage.setRetryable(false);
    clientMessage.setAcquiresResource(false);
    clientMessage.setOperationName("MapReduce.forMap");
    clientMessage.set(name);
    clientMessage.set(jobId);
    if (predicate == null) {
      boolean predicate_isNull = true;
      clientMessage.set(predicate_isNull);
    } else {
      boolean predicate_isNull = false;
      clientMessage.set(predicate_isNull);
      clientMessage.set(predicate);
    } 
    clientMessage.set(mapper);
    if (combinerFactory == null) {
      boolean combinerFactory_isNull = true;
      clientMessage.set(combinerFactory_isNull);
    } else {
      boolean combinerFactory_isNull = false;
      clientMessage.set(combinerFactory_isNull);
      clientMessage.set(combinerFactory);
    } 
    if (reducerFactory == null) {
      boolean reducerFactory_isNull = true;
      clientMessage.set(reducerFactory_isNull);
    } else {
      boolean reducerFactory_isNull = false;
      clientMessage.set(reducerFactory_isNull);
      clientMessage.set(reducerFactory);
    } 
    clientMessage.set(mapName);
    clientMessage.set(chunkSize);
    if (keys == null) {
      boolean keys_isNull = true;
      clientMessage.set(keys_isNull);
    } else {
      boolean keys_isNull = false;
      clientMessage.set(keys_isNull);
      clientMessage.set(keys.size());
      for (Data keys_item : keys)
        clientMessage.set(keys_item); 
    } 
    if (topologyChangedStrategy == null) {
      boolean topologyChangedStrategy_isNull = true;
      clientMessage.set(topologyChangedStrategy_isNull);
    } else {
      boolean topologyChangedStrategy_isNull = false;
      clientMessage.set(topologyChangedStrategy_isNull);
      clientMessage.set(topologyChangedStrategy);
    } 
    clientMessage.updateFrameLength();
    return clientMessage;
  }
  
  public static RequestParameters decodeRequest(ClientMessage clientMessage) {
    RequestParameters parameters = new RequestParameters();
    String name = null;
    name = clientMessage.getStringUtf8();
    parameters.name = name;
    String jobId = null;
    jobId = clientMessage.getStringUtf8();
    parameters.jobId = jobId;
    Data predicate = null;
    boolean predicate_isNull = clientMessage.getBoolean();
    if (!predicate_isNull) {
      predicate = clientMessage.getData();
      parameters.predicate = predicate;
    } 
    Data mapper = null;
    mapper = clientMessage.getData();
    parameters.mapper = mapper;
    Data combinerFactory = null;
    boolean combinerFactory_isNull = clientMessage.getBoolean();
    if (!combinerFactory_isNull) {
      combinerFactory = clientMessage.getData();
      parameters.combinerFactory = combinerFactory;
    } 
    Data reducerFactory = null;
    boolean reducerFactory_isNull = clientMessage.getBoolean();
    if (!reducerFactory_isNull) {
      reducerFactory = clientMessage.getData();
      parameters.reducerFactory = reducerFactory;
    } 
    String mapName = null;
    mapName = clientMessage.getStringUtf8();
    parameters.mapName = mapName;
    int chunkSize = 0;
    chunkSize = clientMessage.getInt();
    parameters.chunkSize = chunkSize;
    List<Data> keys = null;
    boolean keys_isNull = clientMessage.getBoolean();
    if (!keys_isNull) {
      int keys_size = clientMessage.getInt();
      keys = new ArrayList<Data>(keys_size);
      for (int keys_index = 0; keys_index < keys_size; keys_index++) {
        Data keys_item = clientMessage.getData();
        keys.add(keys_item);
      } 
      parameters.keys = keys;
    } 
    String topologyChangedStrategy = null;
    boolean topologyChangedStrategy_isNull = clientMessage.getBoolean();
    if (!topologyChangedStrategy_isNull) {
      topologyChangedStrategy = clientMessage.getStringUtf8();
      parameters.topologyChangedStrategy = topologyChangedStrategy;
    } 
    return parameters;
  }
  
  public static ClientMessage encodeResponse(Collection<Map.Entry<Data, Data>> response) {
    int requiredDataSize = ResponseParameters.calculateDataSize(response);
    ClientMessage clientMessage = ClientMessage.createForEncode(requiredDataSize);
    clientMessage.setMessageType(117);
    clientMessage.set(response.size());
    for (Map.Entry<Data, Data> response_item : response) {
      Data response_itemKey = (Data)response_item.getKey();
      Data response_itemVal = (Data)response_item.getValue();
      clientMessage.set(response_itemKey);
      clientMessage.set(response_itemVal);
    } 
    clientMessage.updateFrameLength();
    return clientMessage;
  }
  
  public static ResponseParameters decodeResponse(ClientMessage clientMessage) {
    ResponseParameters parameters = new ResponseParameters();
    List<Map.Entry<Data, Data>> response = null;
    int response_size = clientMessage.getInt();
    response = new ArrayList<Map.Entry<Data, Data>>(response_size);
    for (int response_index = 0; response_index < response_size; response_index++) {
      Data response_item_key = clientMessage.getData();
      Data response_item_val = clientMessage.getData();
      Map.Entry<Data, Data> response_item = new AbstractMap.SimpleEntry<Data, Data>(response_item_key, response_item_val);
      response.add(response_item);
    } 
    parameters.response = response;
    return parameters;
  }
}
