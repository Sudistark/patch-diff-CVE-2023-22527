package com.hazelcast.client.impl;

import com.hazelcast.client.impl.client.ClientPrincipal;
import com.hazelcast.core.ClientType;
import com.hazelcast.core.HazelcastInstanceNotActiveException;
import com.hazelcast.instance.BuildInfo;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Connection;
import com.hazelcast.nio.tcp.TcpIpConnection;
import com.hazelcast.security.Credentials;
import com.hazelcast.spi.EventService;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.transaction.TransactionContext;
import com.hazelcast.transaction.TransactionException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import javax.security.auth.Subject;
import javax.security.auth.login.LoginContext;

public final class ClientEndpointImpl implements ClientEndpoint {
  private final ClientEngine clientEngine;
  
  private final ILogger logger;
  
  private final NodeEngineImpl nodeEngine;
  
  private final Connection connection;
  
  private final ConcurrentMap<String, TransactionContext> transactionContextMap;
  
  private final ConcurrentMap<String, Callable> removeListenerActions;
  
  private final SocketAddress socketAddress;
  
  private final long creationTime;
  
  private LoginContext loginContext;
  
  private ClientPrincipal principal;
  
  private boolean ownerConnection;
  
  private Credentials credentials;
  
  private int clientVersion;
  
  private String clientVersionString;
  
  private long authenticationCorrelationId;
  
  private String clientName;
  
  private Set<String> labels;
  
  public ClientEndpointImpl(ClientEngine clientEngine, NodeEngineImpl nodeEngine, Connection connection) {
    this.transactionContextMap = new ConcurrentHashMap();
    this.removeListenerActions = new ConcurrentHashMap();
    this.clientEngine = clientEngine;
    this.logger = clientEngine.getLogger(getClass());
    this.nodeEngine = nodeEngine;
    this.connection = connection;
    if (connection instanceof TcpIpConnection) {
      TcpIpConnection tcpIpConnection = (TcpIpConnection)connection;
      this.socketAddress = tcpIpConnection.getRemoteSocketAddress();
    } else {
      this.socketAddress = null;
    } 
    this.clientVersion = -1;
    this.clientVersionString = "Unknown";
    this.creationTime = System.currentTimeMillis();
  }
  
  public Connection getConnection() { return this.connection; }
  
  public String getUuid() { return (this.principal != null) ? this.principal.getUuid() : null; }
  
  public boolean isAlive() { return this.connection.isAlive(); }
  
  public void setLoginContext(LoginContext loginContext) { this.loginContext = loginContext; }
  
  public Subject getSubject() { return (this.loginContext != null) ? this.loginContext.getSubject() : null; }
  
  public boolean isOwnerConnection() { return this.ownerConnection; }
  
  public void authenticated(ClientPrincipal principal, Credentials credentials, boolean firstConnection, String clientVersion, long authCorrelationId, String clientName, Set<String> labels) {
    this.principal = principal;
    this.ownerConnection = firstConnection;
    this.credentials = credentials;
    this.authenticated = true;
    this.authenticationCorrelationId = authCorrelationId;
    setClientVersion(clientVersion);
    this.clientName = clientName;
    this.labels = labels;
  }
  
  public void authenticated(ClientPrincipal principal) {
    this.principal = principal;
    this.authenticated = true;
  }
  
  public boolean isAuthenticated() { return this.authenticated; }
  
  public int getClientVersion() { return this.clientVersion; }
  
  public void setClientVersion(String version) {
    this.clientVersionString = version;
    this.clientVersion = BuildInfo.calculateVersion(version);
  }
  
  public void setClientStatistics(String stats) { this.stats = stats; }
  
  public String getClientStatistics() { return this.stats; }
  
  public InetSocketAddress getSocketAddress() { return (InetSocketAddress)this.socketAddress; }
  
  public ClientType getClientType() {
    ClientType type;
    ClientType type;
    ClientType type;
    ClientType type;
    ClientType type;
    ClientType type;
    ClientType type;
    switch (null.$SwitchMap$com$hazelcast$nio$ConnectionType[this.connection.getType().ordinal()]) {
      case 1:
        return ClientType.JAVA;
      case 2:
        return ClientType.CSHARP;
      case 3:
        return ClientType.CPP;
      case 4:
        return ClientType.PYTHON;
      case 5:
        return ClientType.RUBY;
      case 6:
        return ClientType.NODEJS;
      case 7:
        return ClientType.GO;
      case 8:
        return ClientType.OTHER;
    } 
    throw new IllegalArgumentException("Invalid connection type: " + this.connection.getType());
  }
  
  public String getName() { return this.clientName; }
  
  public Set<String> getLabels() { return this.labels; }
  
  public TransactionContext getTransactionContext(String txnId) {
    TransactionContext transactionContext = (TransactionContext)this.transactionContextMap.get(txnId);
    if (transactionContext == null)
      throw new TransactionException("No transaction context found for txnId:" + txnId); 
    return transactionContext;
  }
  
  public Credentials getCredentials() { return this.credentials; }
  
  public void setTransactionContext(TransactionContext transactionContext) {
    this.transactionContextMap.put(transactionContext.getTxnId(), transactionContext);
    if (this.destroyed)
      removedAndRollbackTransactionContext(transactionContext.getTxnId()); 
  }
  
  public void removeTransactionContext(String txnId) { this.transactionContextMap.remove(txnId); }
  
  public void addListenerDestroyAction(String service, String topic, String id) {
    EventService eventService = this.clientEngine.getEventService();
    addDestroyAction(id, new Object(this, eventService, service, topic, id));
  }
  
  public void addDestroyAction(String registrationId, Callable<Boolean> removeAction) {
    this.removeListenerActions.put(registrationId, removeAction);
    if (this.destroyed)
      removeAndCallRemoveAction(registrationId); 
  }
  
  public boolean removeDestroyAction(String id) { return (this.removeListenerActions.remove(id) != null); }
  
  public void clearAllListeners() {
    for (String registrationId : this.removeListenerActions.keySet())
      removeAndCallRemoveAction(registrationId); 
  }
  
  public void destroy() {
    this.destroyed = true;
    this.nodeEngine.onClientDisconnected(getUuid());
    clearAllListeners();
    for (String txnId : this.transactionContextMap.keySet())
      removedAndRollbackTransactionContext(txnId); 
    try {
      LoginContext lc = this.loginContext;
      if (lc != null)
        lc.logout(); 
    } finally {
      this.authenticated = false;
    } 
  }
  
  private void removeAndCallRemoveAction(String uuid) {
    Callable callable = (Callable)this.removeListenerActions.remove(uuid);
    if (callable != null)
      try {
        callable.call();
      } catch (Exception e) {
        this.logger.warning("Exception during remove listener action", e);
      }  
  }
  
  private void removedAndRollbackTransactionContext(String txnId) {
    TransactionContext context = (TransactionContext)this.transactionContextMap.remove(txnId);
    if (context != null) {
      if (context instanceof com.hazelcast.transaction.impl.xa.XATransactionContextImpl)
        return; 
      try {
        context.rollbackTransaction();
      } catch (HazelcastInstanceNotActiveException e) {
        this.logger.finest(e);
      } catch (Exception e) {
        this.logger.warning(e);
      } 
    } 
  }
  
  public String toString() { return "ClientEndpoint{connection=" + this.connection + ", principal='" + this.principal + ", ownerConnection=" + this.ownerConnection + ", authenticated=" + this.authenticated + ", clientVersion=" + this.clientVersionString + ", creationTime=" + this.creationTime + ", latest statistics=" + this.stats + '}'; }
  
  public long getAuthenticationCorrelationId() { return this.authenticationCorrelationId; }
}
