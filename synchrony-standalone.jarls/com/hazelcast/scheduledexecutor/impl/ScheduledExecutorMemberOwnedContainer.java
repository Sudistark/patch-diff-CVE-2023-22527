package com.hazelcast.scheduledexecutor.impl;

import com.hazelcast.scheduledexecutor.ScheduledTaskHandler;
import com.hazelcast.spi.InvocationBuilder;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.OperationService;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.atomic.AtomicBoolean;

public class ScheduledExecutorMemberOwnedContainer extends ScheduledExecutorContainer {
  private static final int MEMBER_DURABILITY = 0;
  
  private final AtomicBoolean memberPartitionLock = new AtomicBoolean();
  
  ScheduledExecutorMemberOwnedContainer(String name, int capacity, NodeEngine nodeEngine) { super(name, -1, nodeEngine, 0, capacity, new ConcurrentHashMap()); }
  
  public ScheduledFuture schedule(TaskDefinition definition) {
    try {
      acquireMemberPartitionLockIfNeeded();
      checkNotDuplicateTask(definition.getName());
      checkNotAtCapacity();
      return createContextAndSchedule(definition);
    } finally {
      releaseMemberPartitionLockIfNeeded();
    } 
  }
  
  public boolean shouldParkGetResult(String taskName) { return false; }
  
  public ScheduledTaskHandler offprintHandler(String taskName) { return ScheduledTaskHandlerImpl.of(getNodeEngine().getThisAddress(), getName(), taskName); }
  
  protected InvocationBuilder createInvocationBuilder(Operation op) {
    OperationService operationService = getNodeEngine().getOperationService();
    return operationService.createInvocationBuilder("hz:impl:scheduledExecutorService", op, getNodeEngine().getThisAddress());
  }
  
  private void acquireMemberPartitionLockIfNeeded() {
    while (!this.memberPartitionLock.compareAndSet(false, true))
      Thread.yield(); 
  }
  
  private void releaseMemberPartitionLockIfNeeded() { this.memberPartitionLock.set(false); }
}
