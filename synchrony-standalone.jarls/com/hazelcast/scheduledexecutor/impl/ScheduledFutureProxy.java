package com.hazelcast.scheduledexecutor.impl;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.HazelcastInstanceAware;
import com.hazelcast.core.MembershipEvent;
import com.hazelcast.instance.HazelcastInstanceImpl;
import com.hazelcast.nio.Address;
import com.hazelcast.partition.PartitionLostEvent;
import com.hazelcast.scheduledexecutor.IScheduledFuture;
import com.hazelcast.scheduledexecutor.ScheduledTaskHandler;
import com.hazelcast.scheduledexecutor.ScheduledTaskStatistics;
import com.hazelcast.scheduledexecutor.StaleTaskException;
import com.hazelcast.scheduledexecutor.impl.operations.CancelTaskOperation;
import com.hazelcast.scheduledexecutor.impl.operations.DisposeTaskOperation;
import com.hazelcast.scheduledexecutor.impl.operations.GetDelayOperation;
import com.hazelcast.scheduledexecutor.impl.operations.GetResultOperation;
import com.hazelcast.scheduledexecutor.impl.operations.GetStatisticsOperation;
import com.hazelcast.scheduledexecutor.impl.operations.IsCanceledOperation;
import com.hazelcast.scheduledexecutor.impl.operations.IsDoneOperation;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.impl.operationservice.InternalOperationService;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.Preconditions;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.concurrent.Delayed;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;

@SuppressFBWarnings({"EQ_COMPARETO_USE_OBJECT_EQUALS"})
public final class ScheduledFutureProxy<V> extends Object implements IScheduledFuture<V>, HazelcastInstanceAware {
  private HazelcastInstance instance;
  
  private final AtomicBoolean partitionLost;
  
  private final AtomicBoolean memberLost;
  
  ScheduledFutureProxy(ScheduledTaskHandler handler, ScheduledExecutorServiceProxy executor) {
    this.partitionLost = new AtomicBoolean(false);
    this.memberLost = new AtomicBoolean(false);
    Preconditions.checkNotNull(handler);
    this.handler = handler;
    ((DistributedScheduledExecutorService)executor.getService()).addLossListener(this);
  }
  
  public void setHazelcastInstance(HazelcastInstance hazelcastInstance) { this.instance = hazelcastInstance; }
  
  public ScheduledTaskHandler getHandler() { return this.handler; }
  
  public ScheduledTaskStatistics getStats() {
    checkAccessibleHandler();
    checkAccessibleOwner();
    GetStatisticsOperation getStatisticsOperation = new GetStatisticsOperation(this.handler);
    return (ScheduledTaskStatistics)invoke(getStatisticsOperation).join();
  }
  
  public long getDelay(TimeUnit unit) {
    Preconditions.checkNotNull(unit, "Unit is null");
    checkAccessibleHandler();
    checkAccessibleOwner();
    GetDelayOperation getDelayOperation = new GetDelayOperation(this.handler, unit);
    return ((Long)invoke(getDelayOperation).join()).longValue();
  }
  
  public int compareTo(Delayed o) { throw new UnsupportedOperationException(); }
  
  public boolean cancel(boolean mayInterruptIfRunning) {
    if (mayInterruptIfRunning)
      throw new UnsupportedOperationException("mayInterruptIfRunning flag is not supported."); 
    checkAccessibleHandler();
    checkAccessibleOwner();
    CancelTaskOperation cancelTaskOperation = new CancelTaskOperation(this.handler, mayInterruptIfRunning);
    return ((Boolean)invoke(cancelTaskOperation).join()).booleanValue();
  }
  
  public boolean isCancelled() {
    checkAccessibleHandler();
    checkAccessibleOwner();
    IsCanceledOperation isCanceledOperation = new IsCanceledOperation(this.handler);
    return ((Boolean)invoke(isCanceledOperation).join()).booleanValue();
  }
  
  public boolean isDone() {
    checkAccessibleHandler();
    checkAccessibleOwner();
    IsDoneOperation isDoneOperation = new IsDoneOperation(this.handler);
    return ((Boolean)invoke(isDoneOperation).join()).booleanValue();
  }
  
  private InternalCompletableFuture<V> get0() {
    checkAccessibleHandler();
    checkAccessibleOwner();
    GetResultOperation getResultOperation = new GetResultOperation(this.handler);
    return invoke(getResultOperation);
  }
  
  public V get() throws InterruptedException, ExecutionException {
    try {
      return (V)get0().get();
    } catch (ExecutionExceptionDecorator ex) {
      return (V)ExceptionUtil.sneakyThrow(ex.getCause());
    } 
  }
  
  public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
    Preconditions.checkNotNull(unit, "Unit is null");
    try {
      return (V)get0().get(timeout, unit);
    } catch (ExecutionExceptionDecorator ex) {
      return (V)ExceptionUtil.sneakyThrow(ex.getCause());
    } 
  }
  
  public void dispose() {
    checkAccessibleHandler();
    checkAccessibleOwner();
    DisposeTaskOperation disposeTaskOperation = new DisposeTaskOperation(this.handler);
    InternalCompletableFuture future = invoke(disposeTaskOperation);
    this.handler = null;
    future.join();
  }
  
  void notifyMemberLost(MembershipEvent event) {
    ScheduledTaskHandler handler = this.handler;
    if (handler == null)
      return; 
    if (handler.isAssignedToMember() && handler
      .getAddress().equals(event.getMember().getAddress()))
      this.memberLost.set(true); 
  }
  
  void notifyPartitionLost(PartitionLostEvent event) {
    ScheduledTaskHandler handler = this.handler;
    if (handler == null)
      return; 
    int durability = this.instance.getConfig().getScheduledExecutorConfig(handler.getSchedulerName()).getDurability();
    if (handler.isAssignedToPartition() && handler
      .getPartitionId() == event.getPartitionId() && event
      .getLostBackupCount() >= durability)
      this.partitionLost.set(true); 
  }
  
  private void checkAccessibleOwner() {
    if (this.handler.isAssignedToPartition()) {
      if (this.partitionLost.get())
        throw new IllegalStateException("Partition " + this.handler.getPartitionId() + ", holding this scheduled task was lost along with all backups."); 
    } else if (this.memberLost.get()) {
      throw new IllegalStateException("Member with address: " + this.handler.getAddress() + ",  holding this scheduled task is not part of this cluster.");
    } 
  }
  
  private void checkAccessibleHandler() {
    if (this.handler == null)
      throw new StaleTaskException("Scheduled task was previously disposed."); 
  }
  
  private <T> InternalCompletableFuture<T> invoke(Operation op) {
    if (this.handler.isAssignedToPartition()) {
      op.setPartitionId(this.handler.getPartitionId());
      return invokeOnPartition(op);
    } 
    return invokeOnAddress(op, this.handler.getAddress());
  }
  
  private <T> InternalCompletableFuture<T> invokeOnPartition(Operation op) {
    InternalOperationService internalOperationService = ((HazelcastInstanceImpl)this.instance).node.getNodeEngine().getOperationService();
    return internalOperationService.invokeOnPartition(op);
  }
  
  private <T> InternalCompletableFuture<T> invokeOnAddress(Operation op, Address address) {
    InternalOperationService internalOperationService = ((HazelcastInstanceImpl)this.instance).node.getNodeEngine().getOperationService();
    return internalOperationService.invokeOnTarget(op.getServiceName(), op, address);
  }
}
