package com.hazelcast.scheduledexecutor.impl;

import com.hazelcast.logging.ILogger;
import com.hazelcast.scheduledexecutor.impl.operations.ReplicationOperation;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.MapUtil;
import java.util.Iterator;
import java.util.Map;

public class ScheduledExecutorPartition extends AbstractScheduledExecutorContainerHolder {
  private final ILogger logger;
  
  private final int partitionId;
  
  private final ConstructorFunction<String, ScheduledExecutorContainer> containerConstructorFunction = new Object(this);
  
  ScheduledExecutorPartition(NodeEngine nodeEngine, int partitionId) {
    super(nodeEngine);
    this.logger = nodeEngine.getLogger(getClass());
    this.partitionId = partitionId;
  }
  
  public Operation prepareReplicationOperation(int replicaIndex, boolean migrationMode) {
    Map<String, Map<String, ScheduledTaskDescriptor>> map = MapUtil.createHashMap(this.containers.size());
    if (this.logger.isFinestEnabled())
      this.logger.finest("[Partition: " + this.partitionId + "] Prepare replication(migration: " + migrationMode + ") for index: " + replicaIndex); 
    for (ScheduledExecutorContainer container : this.containers.values()) {
      if (replicaIndex > container.getDurability())
        continue; 
      map.put(container.getName(), container.prepareForReplication(migrationMode));
    } 
    return new ReplicationOperation(map);
  }
  
  public ConstructorFunction<String, ScheduledExecutorContainer> getContainerConstructorFunction() { return this.containerConstructorFunction; }
  
  void disposeObsoleteReplicas(int thresholdReplicaIndex) {
    if (this.logger.isFinestEnabled())
      this.logger.finest("[Partition: " + this.partitionId + "] Dispose obsolete replicas with thresholdReplicaIndex: " + thresholdReplicaIndex); 
    if (thresholdReplicaIndex < 0) {
      for (ScheduledExecutorContainer container : this.containers.values())
        container.destroy(); 
      this.containers.clear();
    } else {
      Iterator<ScheduledExecutorContainer> iterator = this.containers.values().iterator();
      while (iterator.hasNext()) {
        ScheduledExecutorContainer container = (ScheduledExecutorContainer)iterator.next();
        if (thresholdReplicaIndex > container.getDurability()) {
          container.destroy();
          iterator.remove();
        } 
      } 
    } 
  }
  
  void promoteSuspended() {
    if (this.logger.isFinestEnabled())
      this.logger.finest("[Partition: " + this.partitionId + "] Promote suspended"); 
    for (ScheduledExecutorContainer container : this.containers.values())
      container.promoteSuspended(); 
  }
}
