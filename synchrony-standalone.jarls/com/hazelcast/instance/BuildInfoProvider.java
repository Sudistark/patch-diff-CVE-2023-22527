package com.hazelcast.instance;

import com.hazelcast.core.HazelcastException;
import com.hazelcast.logging.ILogger;
import com.hazelcast.logging.Logger;
import com.hazelcast.nio.IOUtil;
import com.hazelcast.util.EmptyStatement;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.util.Properties;

public final class BuildInfoProvider {
  public static final String HAZELCAST_INTERNAL_OVERRIDE_VERSION = "hazelcast.internal.override.version";
  
  public static final String HAZELCAST_INTERNAL_OVERRIDE_ENTERPRISE = "hazelcast.internal.override.enterprise";
  
  private static final String HAZELCAST_INTERNAL_OVERRIDE_BUILD = "hazelcast.build";
  
  private static final ILogger LOGGER = Logger.getLogger(BuildInfoProvider.class);
  
  private static final BuildInfo BUILD_INFO_CACHE = populateBuildInfoCache();
  
  private static BuildInfo populateBuildInfoCache() { return getBuildInfoInternalVersion(Overrides.access$000()); }
  
  public static BuildInfo getBuildInfo() {
    if (Overrides.access$100()) {
      overrides = Overrides.access$200();
      return getBuildInfoInternalVersion(overrides);
    } 
    return BUILD_INFO_CACHE;
  }
  
  private static BuildInfo getBuildInfoInternalVersion(Overrides overrides) {
    BuildInfo buildInfo = readBuildPropertiesClass(GeneratedBuildProperties.class, null, overrides);
    try {
      Class<?> enterpriseClass = BuildInfoProvider.class.getClassLoader().loadClass("com.hazelcast.instance.GeneratedEnterpriseBuildProperties");
      if (enterpriseClass.getClassLoader() == BuildInfoProvider.class.getClassLoader())
        buildInfo = readBuildPropertiesClass(enterpriseClass, buildInfo, overrides); 
    } catch (ClassNotFoundException e) {
      EmptyStatement.ignore(e);
    } 
    Properties jetProperties = loadPropertiesFromResource("jet-runtime.properties");
    return withJetProperties(jetProperties, buildInfo);
  }
  
  private static BuildInfo withJetProperties(Properties properties, BuildInfo buildInfo) {
    if (properties.isEmpty())
      return buildInfo; 
    String version = properties.getProperty("jet.version");
    String build = properties.getProperty("jet.build");
    String revision = properties.getProperty("jet.git.revision");
    JetBuildInfo jetBuildInfo = new JetBuildInfo(version, build, revision);
    return buildInfo.withJetBuildInfo(jetBuildInfo);
  }
  
  private static Properties loadPropertiesFromResource(String resourceName) {
    properties = BuildInfoProvider.class.getClassLoader().getResourceAsStream(resourceName);
    Properties runtimeProperties = new Properties();
    try {
      if (properties != null)
        runtimeProperties.load(properties); 
    } catch (Exception ignored) {
      EmptyStatement.ignore(ignored);
    } finally {
      IOUtil.closeResource(properties);
    } 
    return runtimeProperties;
  }
  
  private static BuildInfo readBuildPropertiesClass(Class<?> clazz, BuildInfo upstreamBuildInfo, Overrides overrides) {
    String version = readStaticStringField(clazz, "VERSION");
    String build = readStaticStringField(clazz, "BUILD");
    String revision = readStaticStringField(clazz, "REVISION");
    String distribution = readStaticStringField(clazz, "DISTRIBUTION");
    if (!revision.isEmpty() && revision.equals("${git.commit.id.abbrev}"))
      revision = ""; 
    int buildNumber = Integer.parseInt(build);
    boolean enterprise = !"Hazelcast".equals(distribution);
    String serialVersionString = readStaticStringField(clazz, "SERIALIZATION_VERSION");
    byte serialVersion = Byte.parseByte(serialVersionString);
    return Overrides.access$300(overrides, version, build, revision, buildNumber, enterprise, serialVersion, upstreamBuildInfo);
  }
  
  private static String readStaticStringField(Class<?> clazz, String fieldName) {
    try {
      Field field = clazz.getField(fieldName);
      return (String)field.get(null);
    } catch (NoSuchFieldException e) {
      throw new HazelcastException(e);
    } catch (IllegalAccessException e) {
      throw new HazelcastException(e);
    } 
  }
}
