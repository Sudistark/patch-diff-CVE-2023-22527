package com.hazelcast.transaction.impl;

import com.hazelcast.internal.cluster.ClusterService;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.OperationService;
import com.hazelcast.transaction.TransactionException;
import com.hazelcast.transaction.TransactionNotActiveException;
import com.hazelcast.transaction.TransactionOptions;
import com.hazelcast.transaction.impl.operations.CreateTxBackupLogOperation;
import com.hazelcast.transaction.impl.operations.PurgeTxBackupLogOperation;
import com.hazelcast.transaction.impl.operations.ReplicateTxBackupLogOperation;
import com.hazelcast.transaction.impl.operations.RollbackTxBackupLogOperation;
import com.hazelcast.util.Clock;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.FutureUtil;
import com.hazelcast.util.UuidUtil;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;

public class TransactionImpl implements Transaction {
  private static final Address[] EMPTY_ADDRESSES = new Address[0];
  
  private static final ThreadLocal<Boolean> TRANSACTION_EXISTS = new ThreadLocal();
  
  private final FutureUtil.ExceptionHandler rollbackExceptionHandler;
  
  private final FutureUtil.ExceptionHandler rollbackTxExceptionHandler;
  
  private final FutureUtil.ExceptionHandler replicationTxExceptionHandler;
  
  private final TransactionManagerServiceImpl transactionManagerService;
  
  private final NodeEngine nodeEngine;
  
  private final String txnId;
  
  private final int durability;
  
  private final TransactionOptions.TransactionType transactionType;
  
  private final boolean checkThreadAccess;
  
  private final ILogger logger;
  
  private final String txOwnerUuid;
  
  private final TransactionLog transactionLog;
  
  private Long threadId;
  
  private long timeoutMillis;
  
  private Transaction.State state;
  
  private long startTime;
  
  private Address[] backupAddresses;
  
  private boolean backupLogsCreated;
  
  private boolean originatedFromClient;
  
  public TransactionImpl(TransactionManagerServiceImpl transactionManagerService, NodeEngine nodeEngine, TransactionOptions options, String txOwnerUuid) { this(transactionManagerService, nodeEngine, options, txOwnerUuid, false); }
  
  public TransactionImpl(TransactionManagerServiceImpl transactionManagerService, NodeEngine nodeEngine, TransactionOptions options, String txOwnerUuid, boolean originatedFromClient) {
    this.state = Transaction.State.NO_TXN;
    this.backupAddresses = EMPTY_ADDRESSES;
    this.transactionLog = new TransactionLog();
    this.transactionManagerService = transactionManagerService;
    this.nodeEngine = nodeEngine;
    this.txnId = UuidUtil.newUnsecureUuidString();
    this.timeoutMillis = options.getTimeoutMillis();
    this.transactionType = (options.getTransactionType() == TransactionOptions.TransactionType.LOCAL) ? TransactionOptions.TransactionType.ONE_PHASE : options.getTransactionType();
    this.durability = (this.transactionType == TransactionOptions.TransactionType.ONE_PHASE) ? 0 : options.getDurability();
    this.txOwnerUuid = (txOwnerUuid == null) ? nodeEngine.getLocalMember().getUuid() : txOwnerUuid;
    this.checkThreadAccess = (txOwnerUuid == null);
    this.logger = nodeEngine.getLogger(getClass());
    this.rollbackExceptionHandler = FutureUtil.logAllExceptions(this.logger, "Error during rollback!", Level.FINEST);
    this.rollbackTxExceptionHandler = FutureUtil.logAllExceptions(this.logger, "Error during tx rollback backup!", Level.FINEST);
    this.replicationTxExceptionHandler = createReplicationTxExceptionHandler(this.logger);
    this.originatedFromClient = originatedFromClient;
  }
  
  TransactionImpl(TransactionManagerServiceImpl transactionManagerService, NodeEngine nodeEngine, String txnId, List<TransactionLogRecord> transactionLog, long timeoutMillis, long startTime, String txOwnerUuid) {
    this.state = Transaction.State.NO_TXN;
    this.backupAddresses = EMPTY_ADDRESSES;
    this.transactionLog = new TransactionLog(transactionLog);
    this.transactionManagerService = transactionManagerService;
    this.nodeEngine = nodeEngine;
    this.txnId = txnId;
    this.timeoutMillis = timeoutMillis;
    this.startTime = startTime;
    this.durability = 0;
    this.transactionType = TransactionOptions.TransactionType.TWO_PHASE;
    this.state = Transaction.State.PREPARED;
    this.txOwnerUuid = txOwnerUuid;
    this.checkThreadAccess = false;
    this.logger = nodeEngine.getLogger(getClass());
    this.rollbackExceptionHandler = FutureUtil.logAllExceptions(this.logger, "Error during rollback!", Level.FINEST);
    this.rollbackTxExceptionHandler = FutureUtil.logAllExceptions(this.logger, "Error during tx rollback backup!", Level.FINEST);
    this.replicationTxExceptionHandler = createReplicationTxExceptionHandler(this.logger);
  }
  
  public String getTxnId() { return this.txnId; }
  
  public long getStartTime() { return this.startTime; }
  
  public String getOwnerUuid() { return this.txOwnerUuid; }
  
  public boolean isOriginatedFromClient() { return this.originatedFromClient; }
  
  public Transaction.State getState() { return this.state; }
  
  public long getTimeoutMillis() { return this.timeoutMillis; }
  
  protected TransactionLog getTransactionLog() { return this.transactionLog; }
  
  public void add(TransactionLogRecord record) {
    if (this.state != Transaction.State.ACTIVE)
      throw new TransactionNotActiveException("Transaction is not active!"); 
    checkThread();
    this.transactionLog.add(record);
  }
  
  public TransactionLogRecord get(Object key) { return this.transactionLog.get(key); }
  
  public void remove(Object key) { this.transactionLog.remove(key); }
  
  private void checkThread() {
    if (this.checkThreadAccess && this.threadId != null && this.threadId.longValue() != Thread.currentThread().getId())
      throw new IllegalStateException("Transaction cannot span multiple threads!"); 
  }
  
  public void begin() {
    if (this.state == Transaction.State.ACTIVE)
      throw new IllegalStateException("Transaction is already active"); 
    if (TRANSACTION_EXISTS.get() != null)
      throw new IllegalStateException("Nested transactions are not allowed!"); 
    this.startTime = Clock.currentTimeMillis();
    this.backupAddresses = this.transactionManagerService.pickBackupLogAddresses(this.durability);
    if (this.threadId == null) {
      this.threadId = Long.valueOf(Thread.currentThread().getId());
      setThreadFlag(Boolean.TRUE);
    } 
    this.state = Transaction.State.ACTIVE;
    this.transactionManagerService.startCount.inc();
  }
  
  private void setThreadFlag(Boolean flag) {
    if (this.checkThreadAccess)
      TRANSACTION_EXISTS.set(flag); 
  }
  
  public void prepare() {
    if (this.state != Transaction.State.ACTIVE)
      throw new TransactionNotActiveException("Transaction is not active"); 
    checkThread();
    checkTimeout();
    try {
      createBackupLogs();
      this.state = Transaction.State.PREPARING;
      List<Future> futures = this.transactionLog.prepare(this.nodeEngine);
      FutureUtil.waitUntilAllRespondedWithDeadline(futures, this.timeoutMillis, TimeUnit.MILLISECONDS, FutureUtil.RETHROW_TRANSACTION_EXCEPTION);
      this.state = Transaction.State.PREPARED;
      replicateTxnLog();
    } catch (Throwable e) {
      throw ExceptionUtil.rethrow(e, TransactionException.class);
    } 
  }
  
  public boolean requiresPrepare() {
    if (this.transactionType == TransactionOptions.TransactionType.ONE_PHASE)
      return false; 
    return (this.transactionLog.size() > 1);
  }
  
  public void commit() {
    try {
      if (this.transactionType == TransactionOptions.TransactionType.TWO_PHASE) {
        if (this.transactionLog.size() > 1) {
          if (this.state != Transaction.State.PREPARED)
            throw new IllegalStateException("Transaction is not prepared"); 
        } else if (this.state != Transaction.State.PREPARED && this.state != Transaction.State.ACTIVE) {
          throw new IllegalStateException("Transaction is not prepared or active");
        } 
      } else if (this.transactionType == TransactionOptions.TransactionType.ONE_PHASE && this.state != Transaction.State.ACTIVE) {
        throw new IllegalStateException("Transaction is not active");
      } 
      checkThread();
      checkTimeout();
      try {
        this.state = Transaction.State.COMMITTING;
        List<Future> futures = this.transactionLog.commit(this.nodeEngine);
        FutureUtil.waitWithDeadline(futures, Float.MAX_VALUE, TimeUnit.MILLISECONDS, FutureUtil.RETHROW_TRANSACTION_EXCEPTION);
        this.state = Transaction.State.COMMITTED;
        this.transactionLog.onCommitSuccess();
        this.transactionManagerService.commitCount.inc();
      } catch (Throwable e) {
        this.state = Transaction.State.COMMIT_FAILED;
        this.transactionLog.onCommitFailure();
        throw ExceptionUtil.rethrow(e, TransactionException.class);
      } finally {
        purgeBackupLogs();
      } 
    } finally {
      setThreadFlag(null);
    } 
  }
  
  private void checkTimeout() {
    if (this.startTime + this.timeoutMillis < Clock.currentTimeMillis())
      throw new TransactionException("Transaction is timed-out!"); 
  }
  
  public void rollback() {
    try {
      if (this.state == Transaction.State.NO_TXN || this.state == Transaction.State.ROLLED_BACK)
        throw new IllegalStateException("Transaction is not active"); 
      checkThread();
      this.state = Transaction.State.ROLLING_BACK;
      try {
        rollbackBackupLogs();
        List<Future> futures = this.transactionLog.rollback(this.nodeEngine);
        FutureUtil.waitWithDeadline(futures, Float.MAX_VALUE, TimeUnit.MILLISECONDS, this.rollbackExceptionHandler);
        purgeBackupLogs();
      } catch (Throwable e) {
        throw ExceptionUtil.rethrow(e);
      } finally {
        this.state = Transaction.State.ROLLED_BACK;
        this.transactionManagerService.rollbackCount.inc();
      } 
    } finally {
      setThreadFlag(null);
    } 
  }
  
  private void replicateTxnLog() {
    if (skipBackupLogReplication())
      return; 
    OperationService operationService = this.nodeEngine.getOperationService();
    ClusterService clusterService = this.nodeEngine.getClusterService();
    List<Future> futures = new ArrayList<Future>(this.backupAddresses.length);
    for (Address backupAddress : this.backupAddresses) {
      if (clusterService.getMember(backupAddress) != null) {
        ReplicateTxBackupLogOperation replicateTxBackupLogOperation = createReplicateTxBackupLogOperation();
        InternalCompletableFuture internalCompletableFuture = operationService.invokeOnTarget("hz:core:txManagerService", replicateTxBackupLogOperation, backupAddress);
        futures.add(internalCompletableFuture);
      } 
    } 
    FutureUtil.waitWithDeadline(futures, this.timeoutMillis, TimeUnit.MILLISECONDS, this.replicationTxExceptionHandler);
  }
  
  public void ensureBackupLogsExist() {
    if (this.backupLogsCreated || this.backupAddresses.length == 0)
      return; 
    forceCreateBackupLogs();
  }
  
  private void createBackupLogs() {
    if (this.backupLogsCreated || skipBackupLogReplication())
      return; 
    forceCreateBackupLogs();
  }
  
  private void forceCreateBackupLogs() {
    this.backupLogsCreated = true;
    OperationService operationService = this.nodeEngine.getOperationService();
    List<Future> futures = new ArrayList<Future>(this.backupAddresses.length);
    for (Address backupAddress : this.backupAddresses) {
      if (this.nodeEngine.getClusterService().getMember(backupAddress) != null) {
        CreateTxBackupLogOperation op = createCreateTxBackupLogOperation();
        InternalCompletableFuture internalCompletableFuture = operationService.invokeOnTarget("hz:core:txManagerService", op, backupAddress);
        futures.add(internalCompletableFuture);
      } 
    } 
    FutureUtil.waitWithDeadline(futures, this.timeoutMillis, TimeUnit.MILLISECONDS, this.replicationTxExceptionHandler);
  }
  
  private void rollbackBackupLogs() {
    if (!this.backupLogsCreated)
      return; 
    OperationService operationService = this.nodeEngine.getOperationService();
    ClusterService clusterService = this.nodeEngine.getClusterService();
    List<Future> futures = new ArrayList<Future>(this.backupAddresses.length);
    for (Address backupAddress : this.backupAddresses) {
      if (clusterService.getMember(backupAddress) != null) {
        InternalCompletableFuture internalCompletableFuture = operationService.invokeOnTarget("hz:core:txManagerService", createRollbackTxBackupLogOperation(), backupAddress);
        futures.add(internalCompletableFuture);
      } 
    } 
    FutureUtil.waitWithDeadline(futures, this.timeoutMillis, TimeUnit.MILLISECONDS, this.rollbackTxExceptionHandler);
  }
  
  private void purgeBackupLogs() {
    if (!this.backupLogsCreated)
      return; 
    OperationService operationService = this.nodeEngine.getOperationService();
    ClusterService clusterService = this.nodeEngine.getClusterService();
    for (Address backupAddress : this.backupAddresses) {
      if (clusterService.getMember(backupAddress) != null)
        try {
          operationService.invokeOnTarget("hz:core:txManagerService", createPurgeTxBackupLogOperation(), backupAddress);
        } catch (Throwable e) {
          this.logger.warning("Error during purging backups!", e);
        }  
    } 
  }
  
  private boolean skipBackupLogReplication() { return (this.durability == 0 || this.transactionLog.size() <= 1 || this.backupAddresses.length == 0); }
  
  protected CreateTxBackupLogOperation createCreateTxBackupLogOperation() { return new CreateTxBackupLogOperation(this.txOwnerUuid, this.txnId); }
  
  protected ReplicateTxBackupLogOperation createReplicateTxBackupLogOperation() {
    return new ReplicateTxBackupLogOperation(this.transactionLog
        .getRecords(), this.txOwnerUuid, this.txnId, this.timeoutMillis, this.startTime);
  }
  
  protected RollbackTxBackupLogOperation createRollbackTxBackupLogOperation() { return new RollbackTxBackupLogOperation(this.txnId); }
  
  protected PurgeTxBackupLogOperation createPurgeTxBackupLogOperation() { return new PurgeTxBackupLogOperation(this.txnId); }
  
  public TransactionOptions.TransactionType getTransactionType() { return this.transactionType; }
  
  public String toString() { return "Transaction{txnId='" + this.txnId + '\'' + ", state=" + this.state + ", txType=" + this.transactionType + ", timeoutMillis=" + this.timeoutMillis + '}'; }
  
  static FutureUtil.ExceptionHandler createReplicationTxExceptionHandler(ILogger logger) { return new Object(logger); }
}
