package com.hazelcast.cache.impl;

import com.hazelcast.cache.CacheEventType;
import com.hazelcast.internal.nearcache.impl.invalidation.BatchInvalidator;
import com.hazelcast.internal.nearcache.impl.invalidation.InvalidationUtils;
import com.hazelcast.internal.nearcache.impl.invalidation.Invalidator;
import com.hazelcast.internal.nearcache.impl.invalidation.MetaDataGenerator;
import com.hazelcast.internal.nearcache.impl.invalidation.NonStopInvalidator;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.EventRegistration;
import com.hazelcast.spi.EventService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.properties.GroupProperty;
import com.hazelcast.spi.properties.HazelcastProperties;
import java.util.Collection;

public class CacheEventHandler {
  private final NodeEngine nodeEngine;
  
  private final Invalidator invalidator;
  
  CacheEventHandler(NodeEngine nodeEngine) {
    this.nodeEngine = nodeEngine;
    this.invalidator = createInvalidator();
  }
  
  private Invalidator createInvalidator() {
    HazelcastProperties hazelcastProperties = this.nodeEngine.getProperties();
    int batchSize = hazelcastProperties.getInteger(GroupProperty.CACHE_INVALIDATION_MESSAGE_BATCH_SIZE);
    int batchFrequencySeconds = hazelcastProperties.getInteger(GroupProperty.CACHE_INVALIDATION_MESSAGE_BATCH_FREQUENCY_SECONDS);
    boolean batchingEnabled = (hazelcastProperties.getBoolean(GroupProperty.CACHE_INVALIDATION_MESSAGE_BATCH_ENABLED) && batchSize > 1);
    if (batchingEnabled)
      return new BatchInvalidator("hz:impl:cacheService", batchSize, batchFrequencySeconds, InvalidationUtils.TRUE_FILTER, this.nodeEngine); 
    return new NonStopInvalidator("hz:impl:cacheService", InvalidationUtils.TRUE_FILTER, this.nodeEngine);
  }
  
  public MetaDataGenerator getMetaDataGenerator() { return this.invalidator.getMetaDataGenerator(); }
  
  void publishEvent(CacheEventContext cacheEventContext) {
    CacheEventDataImpl cacheEventDataImpl2;
    CacheEventSet eventSet, eventSet;
    CacheEventDataImpl cacheEventDataImpl1;
    Object eventData, eventData, eventData;
    EventService eventService = this.nodeEngine.getEventService();
    String cacheName = cacheEventContext.getCacheName();
    Collection<EventRegistration> candidates = eventService.getRegistrations("hz:impl:cacheService", cacheName);
    if (candidates.isEmpty())
      return; 
    CacheEventType eventType = cacheEventContext.getEventType();
    switch (null.$SwitchMap$com$hazelcast$cache$CacheEventType[eventType.ordinal()]) {
      case 1:
      case 2:
      case 3:
      case 4:
        cacheEventDataImpl1 = new CacheEventDataImpl(cacheName, eventType, cacheEventContext.getDataKey(), cacheEventContext.getDataValue(), cacheEventContext.getDataOldValue(), cacheEventContext.isOldValueAvailable());
        eventSet = new CacheEventSet(eventType, cacheEventContext.getCompletionId());
        eventSet.addEventData(cacheEventDataImpl1);
        eventData = eventSet;
        break;
      case 5:
      case 6:
        eventData = new CacheEventDataImpl(cacheName, eventType, cacheEventContext.getDataKey(), null, null, false);
        break;
      case 7:
        cacheEventDataImpl2 = new CacheEventDataImpl(cacheName, eventType, cacheEventContext.getDataKey(), cacheEventContext.getDataValue(), null, false);
        eventSet = new CacheEventSet(eventType, cacheEventContext.getCompletionId());
        eventSet.addEventData(cacheEventDataImpl2);
        eventData = eventSet;
        break;
      default:
        throw new IllegalArgumentException("Event Type not defined to create an eventData during publish: " + eventType
            .name());
    } 
    eventService.publishEvent("hz:impl:cacheService", candidates, eventData, cacheEventContext
        .getOrderKey());
  }
  
  void publishEvent(String cacheNameWithPrefix, CacheEventSet eventSet, int orderKey) {
    EventService eventService = this.nodeEngine.getEventService();
    Collection<EventRegistration> candidates = eventService.getRegistrations("hz:impl:cacheService", cacheNameWithPrefix);
    if (candidates.isEmpty())
      return; 
    eventService.publishEvent("hz:impl:cacheService", candidates, eventSet, orderKey);
  }
  
  void sendInvalidationEvent(String name, Data key, String sourceUuid) {
    if (key == null) {
      this.invalidator.invalidateAllKeys(name, sourceUuid);
    } else {
      this.invalidator.invalidateKey(key, name, sourceUuid);
    } 
  }
  
  public void resetPartitionMetaData(String name, int partitionId) { this.invalidator.resetPartitionMetaData(name, partitionId); }
  
  public void destroy(String name, String sourceUuid) { this.invalidator.destroy(name, sourceUuid); }
  
  void shutdown() { this.invalidator.shutdown(); }
}
