package com.hazelcast.cache.impl.record;

import com.hazelcast.cache.impl.CacheContext;
import com.hazelcast.cache.impl.CacheEntryIterationResult;
import com.hazelcast.cache.impl.CacheKeyIterationResult;
import com.hazelcast.internal.eviction.EvictionListener;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.nio.serialization.SerializableByConvention;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.SampleableConcurrentHashMap;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@SerializableByConvention
public class CacheRecordHashMap extends SampleableConcurrentHashMap<Data, CacheRecord> implements SampleableCacheRecordMap<Data, CacheRecord> {
  private static final long serialVersionUID = 1L;
  
  private final SerializationService serializationService;
  
  private final CacheContext cacheContext;
  
  private boolean entryCountingEnable;
  
  public CacheRecordHashMap(SerializationService serializationService, int initialCapacity, CacheContext cacheContext) {
    super(initialCapacity);
    this.serializationService = serializationService;
    this.cacheContext = cacheContext;
  }
  
  public void setEntryCounting(boolean enable) {
    if (enable) {
      if (!this.entryCountingEnable)
        this.cacheContext.increaseEntryCount(size()); 
    } else if (this.entryCountingEnable) {
      this.cacheContext.decreaseEntryCount(size());
    } 
    this.entryCountingEnable = enable;
  }
  
  public CacheRecord put(Data key, CacheRecord value) {
    CacheRecord oldRecord = (CacheRecord)super.put(key, value);
    if (oldRecord == null && this.entryCountingEnable)
      this.cacheContext.increaseEntryCount(); 
    return oldRecord;
  }
  
  public CacheRecord putIfAbsent(Data key, CacheRecord value) {
    CacheRecord oldRecord = (CacheRecord)super.putIfAbsent(key, value);
    if (oldRecord == null && this.entryCountingEnable)
      this.cacheContext.increaseEntryCount(); 
    return oldRecord;
  }
  
  public CacheRecord remove(Object key) {
    CacheRecord removedRecord = (CacheRecord)super.remove(key);
    if (removedRecord != null && this.entryCountingEnable)
      this.cacheContext.decreaseEntryCount(); 
    return removedRecord;
  }
  
  public boolean remove(Object key, Object value) {
    boolean removed = super.remove(key, value);
    if (removed && this.entryCountingEnable)
      this.cacheContext.decreaseEntryCount(); 
    return removed;
  }
  
  public void clear() {
    int sizeBeforeClear = size();
    super.clear();
    if (this.entryCountingEnable)
      this.cacheContext.decreaseEntryCount(sizeBeforeClear); 
  }
  
  protected CacheEvictableSamplingEntry createSamplingEntry(Data key, CacheRecord value) { return new CacheEvictableSamplingEntry(this, key, value); }
  
  public CacheKeyIterationResult fetchKeys(int nextTableIndex, int size) {
    List<Data> keys = new ArrayList<Data>(size);
    int tableIndex = fetchKeys(nextTableIndex, size, keys);
    return new CacheKeyIterationResult(keys, tableIndex);
  }
  
  public CacheEntryIterationResult fetchEntries(int nextTableIndex, int size) {
    List<Map.Entry<Data, CacheRecord>> entries = new ArrayList<Map.Entry<Data, CacheRecord>>(size);
    int newTableIndex = fetchEntries(nextTableIndex, size, entries);
    List<Map.Entry<Data, Data>> entriesData = new ArrayList<Map.Entry<Data, Data>>(entries.size());
    for (Map.Entry<Data, CacheRecord> entry : entries) {
      CacheRecord record = (CacheRecord)entry.getValue();
      Data dataValue = this.serializationService.toData(record.getValue());
      entriesData.add(new AbstractMap.SimpleEntry(entry.getKey(), dataValue));
    } 
    return new CacheEntryIterationResult(entriesData, newTableIndex);
  }
  
  public <C extends com.hazelcast.internal.eviction.EvictionCandidate<Data, CacheRecord>> boolean tryEvict(C evictionCandidate, EvictionListener<Data, CacheRecord> evictionListener) {
    if (evictionCandidate == null)
      return false; 
    if (remove(evictionCandidate.getAccessor()) == null)
      return false; 
    if (evictionListener != null)
      evictionListener.onEvict(evictionCandidate.getAccessor(), evictionCandidate.getEvictable(), false); 
    return true;
  }
  
  public Iterable<CacheEvictableSamplingEntry> sample(int sampleCount) { return getRandomSamples(sampleCount); }
}
