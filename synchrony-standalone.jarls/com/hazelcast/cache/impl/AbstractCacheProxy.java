package com.hazelcast.cache.impl;

import com.hazelcast.config.CacheConfig;
import com.hazelcast.core.ICompletableFuture;
import com.hazelcast.internal.cluster.Versions;
import com.hazelcast.map.impl.MapEntries;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.OperationFactory;
import com.hazelcast.spi.OperationService;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.FutureUtil;
import com.hazelcast.util.MapUtil;
import com.hazelcast.util.SetUtil;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Future;
import javax.cache.expiry.ExpiryPolicy;

abstract class AbstractCacheProxy<K, V> extends AbstractInternalCacheProxy<K, V> {
  AbstractCacheProxy(CacheConfig<K, V> cacheConfig, NodeEngine nodeEngine, ICacheService cacheService) { super(cacheConfig, nodeEngine, cacheService); }
  
  public InternalCompletableFuture<V> getAsync(K key) { return getAsync(key, null); }
  
  public InternalCompletableFuture<V> getAsync(K key, ExpiryPolicy expiryPolicy) {
    ensureOpen();
    CacheProxyUtil.validateNotNull(key);
    Data keyData = this.serializationService.toData(key);
    Operation op = this.operationProvider.createGetOperation(keyData, expiryPolicy);
    return invoke(op, keyData, false);
  }
  
  public InternalCompletableFuture<Void> putAsync(K key, V value) { return putAsync(key, value, null); }
  
  public InternalCompletableFuture<Void> putAsync(K key, V value, ExpiryPolicy expiryPolicy) { return putAsyncInternal(key, value, expiryPolicy, false, false); }
  
  public InternalCompletableFuture<Boolean> putIfAbsentAsync(K key, V value) { return putIfAbsentAsyncInternal(key, value, null, false); }
  
  public InternalCompletableFuture<Boolean> putIfAbsentAsync(K key, V value, ExpiryPolicy expiryPolicy) { return putIfAbsentAsyncInternal(key, value, expiryPolicy, false); }
  
  public ICompletableFuture<V> getAndPutAsync(K key, V value) { return getAndPutAsync(key, value, null); }
  
  public ICompletableFuture<V> getAndPutAsync(K key, V value, ExpiryPolicy expiryPolicy) { return putAsyncInternal(key, value, expiryPolicy, true, false); }
  
  public InternalCompletableFuture<Boolean> removeAsync(K key) { return removeAsyncInternal(key, null, false, false, false); }
  
  public InternalCompletableFuture<Boolean> removeAsync(K key, V oldValue) { return removeAsyncInternal(key, oldValue, true, false, false); }
  
  public ICompletableFuture<V> getAndRemoveAsync(K key) { return removeAsyncInternal(key, null, false, true, false); }
  
  public ICompletableFuture<Boolean> replaceAsync(K key, V value) { return replaceAsyncInternal(key, null, value, null, false, false, false); }
  
  public ICompletableFuture<Boolean> replaceAsync(K key, V value, ExpiryPolicy expiryPolicy) { return replaceAsyncInternal(key, null, value, expiryPolicy, false, false, false); }
  
  public ICompletableFuture<Boolean> replaceAsync(K key, V oldValue, V newValue) { return replaceAsyncInternal(key, oldValue, newValue, null, true, false, false); }
  
  public ICompletableFuture<Boolean> replaceAsync(K key, V oldValue, V newValue, ExpiryPolicy expiryPolicy) { return replaceAsyncInternal(key, oldValue, newValue, expiryPolicy, true, false, false); }
  
  public ICompletableFuture<V> getAndReplaceAsync(K key, V value) { return replaceAsyncInternal(key, null, value, null, false, true, false); }
  
  public ICompletableFuture<V> getAndReplaceAsync(K key, V value, ExpiryPolicy expiryPolicy) { return replaceAsyncInternal(key, null, value, expiryPolicy, false, true, false); }
  
  public V get(K key, ExpiryPolicy expiryPolicy) {
    try {
      InternalCompletableFuture internalCompletableFuture = getAsync(key, expiryPolicy);
      return (V)internalCompletableFuture.get();
    } catch (Throwable e) {
      throw ExceptionUtil.rethrowAllowedTypeFirst(e, javax.cache.CacheException.class);
    } 
  }
  
  public Map<K, V> getAll(Set<? extends K> keys, ExpiryPolicy expiryPolicy) {
    ensureOpen();
    CacheProxyUtil.validateNotNull(keys);
    if (keys.isEmpty())
      return Collections.emptyMap(); 
    int keyCount = keys.size();
    Set<Data> ks = SetUtil.createHashSet(keyCount);
    for (K key : keys) {
      CacheProxyUtil.validateNotNull(key);
      Data dataKey = this.serializationService.toData(key);
      ks.add(dataKey);
    } 
    Map<K, V> result = MapUtil.createHashMap(keyCount);
    Collection<Integer> partitions = getPartitionsForKeys(ks);
    try {
      OperationFactory factory = this.operationProvider.createGetAllOperationFactory(ks, expiryPolicy);
      OperationService operationService = getNodeEngine().getOperationService();
      Map<Integer, Object> responses = operationService.invokeOnPartitions(getServiceName(), factory, partitions);
      for (Object response : responses.values()) {
        MapEntries mapEntries = (MapEntries)this.serializationService.toObject(response);
        mapEntries.putAllToMap(this.serializationService, result);
      } 
    } catch (Throwable e) {
      throw ExceptionUtil.rethrowAllowedTypeFirst(e, javax.cache.CacheException.class);
    } 
    return result;
  }
  
  public void put(K key, V value, ExpiryPolicy expiryPolicy) {
    try {
      InternalCompletableFuture<Object> future = putAsyncInternal(key, value, expiryPolicy, false, true);
      future.get();
    } catch (Throwable e) {
      throw ExceptionUtil.rethrowAllowedTypeFirst(e, javax.cache.CacheException.class);
    } 
  }
  
  public V getAndPut(K key, V value, ExpiryPolicy expiryPolicy) {
    try {
      InternalCompletableFuture<V> future = putAsyncInternal(key, value, expiryPolicy, true, true);
      return (V)future.get();
    } catch (Throwable e) {
      throw ExceptionUtil.rethrowAllowedTypeFirst(e, javax.cache.CacheException.class);
    } 
  }
  
  public void putAll(Map<? extends K, ? extends V> map, ExpiryPolicy expiryPolicy) {
    ensureOpen();
    CacheProxyUtil.validateNotNull(map);
    try {
      int partitionCount = this.partitionService.getPartitionCount();
      List[] entriesPerPartition = groupDataToPartitions(map, partitionCount);
      putToAllPartitionsAndWaitForCompletion(entriesPerPartition, expiryPolicy);
    } catch (Exception e) {
      throw ExceptionUtil.rethrow(e);
    } 
  }
  
  public boolean setExpiryPolicy(K key, ExpiryPolicy expiryPolicy) {
    if (isClusterVersionLessThan(Versions.V3_11))
      throw new UnsupportedOperationException("setExpiryPolicy operation is availablewhen cluster version is 3.11 or higher"); 
    try {
      ensureOpen();
      CacheProxyUtil.validateNotNull(key);
      CacheProxyUtil.validateNotNull(expiryPolicy);
      Data keyData = this.serializationService.toData(key);
      Data expiryPolicyData = this.serializationService.toData(expiryPolicy);
      List<Data> list = Collections.singletonList(keyData);
      Operation operation = this.operationProvider.createSetExpiryPolicyOperation(list, expiryPolicyData);
      InternalCompletableFuture internalCompletableFuture = invoke(operation, keyData, true);
      return ((Boolean)internalCompletableFuture.get()).booleanValue();
    } catch (Throwable e) {
      throw ExceptionUtil.rethrowAllowedTypeFirst(e, javax.cache.CacheException.class);
    } 
  }
  
  public void setExpiryPolicy(Set<? extends K> keys, ExpiryPolicy expiryPolicy) {
    if (isClusterVersionLessThan(Versions.V3_11))
      throw new UnsupportedOperationException("setExpiryPolicy operation is availablewhen cluster version is 3.11 or higher"); 
    ensureOpen();
    CacheProxyUtil.validateNotNull(keys);
    CacheProxyUtil.validateNotNull(expiryPolicy);
    try {
      int partitionCount = this.partitionService.getPartitionCount();
      List[] keysPerPartition = groupDataToPartitions(keys, partitionCount);
      setTTLAllPartitionsAndWaitForCompletion(keysPerPartition, this.serializationService.toData(expiryPolicy));
    } catch (Exception e) {
      ExceptionUtil.rethrow(e);
    } 
  }
  
  private List<Data>[] groupDataToPartitions(Collection<? extends K> keys, int partitionCount) {
    ArrayList[] arrayOfArrayList = new ArrayList[partitionCount];
    for (K key : keys) {
      CacheProxyUtil.validateNotNull(key);
      Data dataKey = this.serializationService.toData(key);
      int partitionId = this.partitionService.getPartitionId(dataKey);
      List<Data> partition = arrayOfArrayList[partitionId];
      if (partition == null) {
        partition = new ArrayList<Data>();
        arrayOfArrayList[partitionId] = partition;
      } 
      partition.add(dataKey);
    } 
    return arrayOfArrayList;
  }
  
  private List<Map.Entry<Data, Data>>[] groupDataToPartitions(Map<? extends K, ? extends V> map, int partitionCount) {
    List[] entriesPerPartition = new List[partitionCount];
    for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {
      K key = (K)entry.getKey();
      V value = (V)entry.getValue();
      CacheProxyUtil.validateNotNull(key, value);
      Data keyData = this.serializationService.toData(key);
      Data valueData = this.serializationService.toData(value);
      int partitionId = this.partitionService.getPartitionId(keyData);
      List<Map.Entry<Data, Data>> entries = entriesPerPartition[partitionId];
      if (entries == null) {
        entries = new ArrayList<Map.Entry<Data, Data>>();
        entriesPerPartition[partitionId] = entries;
      } 
      entries.add(new AbstractMap.SimpleImmutableEntry(keyData, valueData));
    } 
    return entriesPerPartition;
  }
  
  private void putToAllPartitionsAndWaitForCompletion(List[] entriesPerPartition, ExpiryPolicy expiryPolicy) throws Exception {
    List<Future> futures = new ArrayList<Future>(entriesPerPartition.length);
    for (int partitionId = 0; partitionId < entriesPerPartition.length; partitionId++) {
      List<Map.Entry<Data, Data>> entries = entriesPerPartition[partitionId];
      if (entries != null) {
        Operation operation = this.operationProvider.createPutAllOperation(entries, expiryPolicy, partitionId);
        InternalCompletableFuture internalCompletableFuture = invoke(operation, partitionId, true);
        futures.add(internalCompletableFuture);
      } 
    } 
    Throwable error = null;
    for (Future future : futures) {
      try {
        future.get();
      } catch (Throwable t) {
        this.logger.finest("Error occurred while putting entries as batch!", t);
        if (error == null)
          error = t; 
      } 
    } 
    if (error != null)
      throw ExceptionUtil.rethrow(error); 
  }
  
  private void setTTLAllPartitionsAndWaitForCompletion(List[] keysPerPartition, Data expiryPolicy) {
    List<Future> futures = new ArrayList<Future>(keysPerPartition.length);
    for (int partitionId = 0; partitionId < keysPerPartition.length; partitionId++) {
      List<Data> keys = keysPerPartition[partitionId];
      if (keys != null) {
        Operation operation = this.operationProvider.createSetExpiryPolicyOperation(keys, expiryPolicy);
        futures.add(invoke(operation, partitionId, true));
      } 
    } 
    List<Throwable> throwables = FutureUtil.waitUntilAllResponded(futures);
    if (throwables.size() > 0)
      throw ExceptionUtil.rethrow((Throwable)throwables.get(0)); 
  }
  
  public boolean putIfAbsent(K key, V value, ExpiryPolicy expiryPolicy) {
    try {
      InternalCompletableFuture internalCompletableFuture = putIfAbsentAsyncInternal(key, value, expiryPolicy, true);
      return ((Boolean)internalCompletableFuture.get()).booleanValue();
    } catch (Throwable e) {
      throw ExceptionUtil.rethrowAllowedTypeFirst(e, javax.cache.CacheException.class);
    } 
  }
  
  public boolean replace(K key, V oldValue, V newValue, ExpiryPolicy expiryPolicy) {
    try {
      InternalCompletableFuture internalCompletableFuture = replaceAsyncInternal(key, oldValue, newValue, expiryPolicy, true, false, true);
      return ((Boolean)internalCompletableFuture.get()).booleanValue();
    } catch (Throwable e) {
      throw ExceptionUtil.rethrowAllowedTypeFirst(e, javax.cache.CacheException.class);
    } 
  }
  
  public boolean replace(K key, V value, ExpiryPolicy expiryPolicy) {
    try {
      InternalCompletableFuture internalCompletableFuture = replaceAsyncInternal(key, null, value, expiryPolicy, false, false, true);
      return ((Boolean)internalCompletableFuture.get()).booleanValue();
    } catch (Throwable e) {
      throw ExceptionUtil.rethrowAllowedTypeFirst(e, javax.cache.CacheException.class);
    } 
  }
  
  public V getAndReplace(K key, V value, ExpiryPolicy expiryPolicy) {
    try {
      InternalCompletableFuture internalCompletableFuture = replaceAsyncInternal(key, null, value, expiryPolicy, false, true, true);
      return (V)internalCompletableFuture.get();
    } catch (Throwable e) {
      throw ExceptionUtil.rethrowAllowedTypeFirst(e, javax.cache.CacheException.class);
    } 
  }
  
  public int size() {
    ensureOpen();
    try {
      OperationFactory operationFactory = this.operationProvider.createSizeOperationFactory();
      Map<Integer, Object> results = getNodeEngine().getOperationService().invokeOnAllPartitions(getServiceName(), operationFactory);
      long total = 0L;
      for (Object result : results.values())
        total += ((Integer)getNodeEngine().toObject(result)).intValue(); 
      return MapUtil.toIntSize(total);
    } catch (Throwable t) {
      throw ExceptionUtil.rethrowAllowedTypeFirst(t, javax.cache.CacheException.class);
    } 
  }
  
  private Set<Integer> getPartitionsForKeys(Set<Data> keys) {
    IPartitionService partitionService = getNodeEngine().getPartitionService();
    int partitions = partitionService.getPartitionCount();
    int capacity = Math.min(partitions, keys.size());
    Set<Integer> partitionIds = SetUtil.createHashSet(capacity);
    Iterator<Data> iterator = keys.iterator();
    while (iterator.hasNext() && partitionIds.size() < partitions) {
      Data key = (Data)iterator.next();
      partitionIds.add(Integer.valueOf(partitionService.getPartitionId(key)));
    } 
    return partitionIds;
  }
}
