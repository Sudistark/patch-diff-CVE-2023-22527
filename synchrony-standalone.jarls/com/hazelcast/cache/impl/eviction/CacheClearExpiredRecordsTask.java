package com.hazelcast.cache.impl.eviction;

import com.hazelcast.cache.impl.CachePartitionSegment;
import com.hazelcast.cache.impl.ICacheRecordStore;
import com.hazelcast.cache.impl.operation.CacheClearExpiredOperation;
import com.hazelcast.cache.impl.operation.CacheExpireBatchBackupOperation;
import com.hazelcast.core.IBiFunction;
import com.hazelcast.internal.eviction.ClearExpiredRecordsTask;
import com.hazelcast.internal.eviction.ExpiredKey;
import com.hazelcast.internal.nearcache.impl.invalidation.InvalidationQueue;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.spi.properties.HazelcastProperty;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.TimeUnit;

public class CacheClearExpiredRecordsTask extends ClearExpiredRecordsTask<CachePartitionSegment, ICacheRecordStore> {
  public static final String PROP_CLEANUP_PERCENTAGE = "hazelcast.internal.cache.expiration.cleanup.percentage";
  
  public static final String PROP_TASK_PERIOD_SECONDS = "hazelcast.internal.cache.expiration.task.period.seconds";
  
  public static final String PROP_CLEANUP_OPERATION_COUNT = "hazelcast.internal.cache.expiration.cleanup.operation.count";
  
  private static final int DEFAULT_TASK_PERIOD_SECONDS = 5;
  
  private static final int DEFAULT_CLEANUP_PERCENTAGE = 10;
  
  private static final HazelcastProperty TASK_PERIOD_SECONDS = new HazelcastProperty("hazelcast.internal.cache.expiration.task.period.seconds", 
      Integer.valueOf(5), TimeUnit.SECONDS);
  
  private static final HazelcastProperty CLEANUP_PERCENTAGE = new HazelcastProperty("hazelcast.internal.cache.expiration.cleanup.percentage", 
      Integer.valueOf(10));
  
  private static final HazelcastProperty CLEANUP_OPERATION_COUNT = new HazelcastProperty("hazelcast.internal.cache.expiration.cleanup.operation.count");
  
  private final Comparator<CachePartitionSegment> partitionSegmentComparator = new Object(this);
  
  public CacheClearExpiredRecordsTask(CachePartitionSegment[] containers, NodeEngine nodeEngine) { super("hz:impl:cacheService", containers, CLEANUP_OPERATION_COUNT, CLEANUP_PERCENTAGE, TASK_PERIOD_SECONDS, nodeEngine); }
  
  public void tryToSendBackupExpiryOp(ICacheRecordStore store, boolean sendIfAtBatchSize) {
    InvalidationQueue<ExpiredKey> expiredKeys = store.getExpiredKeysQueue();
    int totalBackupCount = store.getConfig().getTotalBackupCount();
    int partitionId = store.getPartitionId();
    this.toBackupSender.trySendExpiryOp(store, expiredKeys, totalBackupCount, partitionId, sendIfAtBatchSize);
  }
  
  public Iterator<ICacheRecordStore> storeIterator(CachePartitionSegment container) { return container.recordStoreIterator(); }
  
  protected Operation newPrimaryExpiryOp(int expirationPercentage, CachePartitionSegment container) {
    return (new CacheClearExpiredOperation(expirationPercentage))
      .setNodeEngine(this.nodeEngine)
      .setCallerUuid(this.nodeEngine.getLocalMember().getUuid())
      .setPartitionId(container.getPartitionId())
      .setValidateTarget(false)
      .setServiceName("hz:impl:cacheService");
  }
  
  protected Operation newBackupExpiryOp(ICacheRecordStore store, Collection<ExpiredKey> expiredKeys) { return new CacheExpireBatchBackupOperation(store.getName(), expiredKeys, store.size()); }
  
  protected IBiFunction<Integer, Integer, Boolean> newBackupExpiryOpFilter() { return new Object(this); }
  
  protected void equalizeBackupSizeWithPrimary(CachePartitionSegment container) {
    Iterator<ICacheRecordStore> iterator = container.recordStoreIterator();
    while (iterator.hasNext()) {
      ICacheRecordStore recordStore = (ICacheRecordStore)iterator.next();
      int totalBackupCount = recordStore.getConfig().getTotalBackupCount();
      int partitionId = recordStore.getPartitionId();
      this.toBackupSender.invokeBackupExpiryOperation(Collections.emptyList(), totalBackupCount, partitionId, recordStore);
    } 
  }
  
  protected boolean hasExpiredKeyToSendBackup(CachePartitionSegment container) {
    Iterator<ICacheRecordStore> iterator = container.recordStoreIterator();
    while (iterator.hasNext()) {
      ICacheRecordStore store = (ICacheRecordStore)iterator.next();
      if (store.getExpiredKeysQueue().size() > 0)
        return true; 
    } 
    return false;
  }
  
  protected boolean hasRunningCleanup(CachePartitionSegment container) { return container.hasRunningCleanupOperation(); }
  
  protected void setHasRunningCleanup(CachePartitionSegment container) { container.setRunningCleanupOperation(true); }
  
  protected boolean isContainerEmpty(CachePartitionSegment container) {
    Iterator<ICacheRecordStore> iterator = container.recordStoreIterator();
    while (iterator.hasNext()) {
      ICacheRecordStore store = (ICacheRecordStore)iterator.next();
      if (store.size() > 0)
        return false; 
    } 
    return true;
  }
  
  protected boolean notHaveAnyExpirableRecord(CachePartitionSegment container) {
    Iterator<ICacheRecordStore> iterator = container.recordStoreIterator();
    while (iterator.hasNext()) {
      ICacheRecordStore store = (ICacheRecordStore)iterator.next();
      if (store.isExpirable())
        return false; 
    } 
    return true;
  }
  
  protected long getLastCleanupTime(CachePartitionSegment container) { return container.getLastCleanupTime(); }
  
  protected void sortPartitionContainers(List<CachePartitionSegment> containers) {
    for (CachePartitionSegment segment : containers)
      segment.storeLastCleanupTime(); 
    Collections.sort(containers, this.partitionSegmentComparator);
  }
  
  protected ClearExpiredRecordsTask.ProcessablePartitionType getProcessablePartitionType() { return ClearExpiredRecordsTask.ProcessablePartitionType.PRIMARY_PARTITION; }
  
  public String toString() { return CacheClearExpiredRecordsTask.class.getName(); }
}
