package com.hazelcast.cache.impl;

import com.hazelcast.cache.impl.record.CacheRecord;
import com.hazelcast.cache.impl.record.CacheRecordHashMap;
import com.hazelcast.cache.impl.record.SampleableCacheRecordMap;
import com.hazelcast.config.EvictionConfig;
import com.hazelcast.internal.eviction.EvictionChecker;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.serialization.SerializationService;

public class CacheRecordStore extends AbstractCacheRecordStore<CacheRecord, CacheRecordHashMap> {
  protected SerializationService serializationService;
  
  public CacheRecordStore(String cacheNameWithPrefix, int partitionId, NodeEngine nodeEngine, AbstractCacheService cacheService) {
    super(cacheNameWithPrefix, partitionId, nodeEngine, cacheService);
    this.serializationService = nodeEngine.getSerializationService();
  }
  
  protected EvictionChecker createCacheEvictionChecker(int size, EvictionConfig.MaxSizePolicy maxSizePolicy) {
    if (maxSizePolicy == null)
      throw new IllegalArgumentException("Max-Size policy cannot be null"); 
    if (maxSizePolicy != EvictionConfig.MaxSizePolicy.ENTRY_COUNT)
      throw new IllegalArgumentException("Invalid max-size policy (" + maxSizePolicy + ") for " + 
          getClass().getName() + "! Only " + EvictionConfig.MaxSizePolicy.ENTRY_COUNT + " is supported."); 
    return super.createCacheEvictionChecker(size, maxSizePolicy);
  }
  
  protected CacheRecordHashMap createRecordCacheMap() { return new CacheRecordHashMap(this.nodeEngine.getSerializationService(), 256, this.cacheContext); }
  
  protected CacheEntryProcessorEntry createCacheEntryProcessorEntry(Data key, CacheRecord record, long now, int completionId) { return new CacheEntryProcessorEntry(key, record, this, now, completionId); }
  
  protected CacheRecord createRecord(Object value, long creationTime, long expiryTime) {
    evictIfRequired();
    markExpirable(expiryTime);
    return this.cacheRecordFactory.newRecordWithExpiry(value, creationTime, expiryTime);
  }
  
  protected Data valueToData(Object value) { return this.cacheService.toData(value); }
  
  protected Object dataToValue(Data data) { return this.serializationService.toObject(data); }
  
  protected Object recordToValue(CacheRecord record) {
    Object value = record.getValue();
    if (value instanceof Data) {
      switch (null.$SwitchMap$com$hazelcast$config$InMemoryFormat[this.cacheConfig.getInMemoryFormat().ordinal()]) {
        case 1:
          return value;
        case 2:
          return dataToValue((Data)value);
      } 
      throw new IllegalStateException("Unsupported in-memory format: " + this.cacheConfig
          .getInMemoryFormat());
    } 
    return value;
  }
  
  protected Data recordToData(CacheRecord record) {
    Object value = recordToValue(record);
    if (value == null)
      return null; 
    if (value instanceof Data)
      return (Data)value; 
    return valueToData(value);
  }
  
  protected Data toHeapData(Object obj) {
    if (obj == null)
      return null; 
    if (obj instanceof Data)
      return (Data)obj; 
    if (obj instanceof CacheRecord) {
      CacheRecord record = (CacheRecord)obj;
      Object value = record.getValue();
      return toHeapData(value);
    } 
    return this.serializationService.toData(obj);
  }
  
  public void disposeDeferredBlocks() {}
}
