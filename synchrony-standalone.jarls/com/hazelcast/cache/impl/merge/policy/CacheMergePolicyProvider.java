package com.hazelcast.cache.impl.merge.policy;

import com.hazelcast.cache.BuiltInCacheMergePolicies;
import com.hazelcast.cache.CacheMergePolicy;
import com.hazelcast.config.InvalidConfigurationException;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.merge.SplitBrainMergePolicyProvider;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public final class CacheMergePolicyProvider {
  private final ConcurrentMap<String, CacheMergePolicy> mergePolicyMap;
  
  private final ConstructorFunction<String, CacheMergePolicy> policyConstructorFunction;
  
  private final NodeEngine nodeEngine;
  
  private final SplitBrainMergePolicyProvider policyProvider;
  
  public CacheMergePolicyProvider(NodeEngine nodeEngine) {
    this.mergePolicyMap = new ConcurrentHashMap();
    this.policyConstructorFunction = new Object(this);
    this.nodeEngine = nodeEngine;
    this.policyProvider = nodeEngine.getSplitBrainMergePolicyProvider();
    addOutOfBoxPolicies();
  }
  
  private void addOutOfBoxPolicies() {
    for (BuiltInCacheMergePolicies mergePolicy : BuiltInCacheMergePolicies.values()) {
      CacheMergePolicy cacheMergePolicy = mergePolicy.newInstance();
      this.mergePolicyMap.put(mergePolicy.name(), cacheMergePolicy);
      this.mergePolicyMap.put(mergePolicy.getImplementationClassName(), cacheMergePolicy);
    } 
  }
  
  public Object getMergePolicy(String className) {
    if (className == null)
      throw new InvalidConfigurationException("Class name is mandatory!"); 
    try {
      return this.policyProvider.getMergePolicy(className);
    } catch (InvalidConfigurationException e) {
      return ConcurrencyUtil.getOrPutIfAbsent(this.mergePolicyMap, className, this.policyConstructorFunction);
    } 
  }
}
