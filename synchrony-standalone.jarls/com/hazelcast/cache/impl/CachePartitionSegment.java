package com.hazelcast.cache.impl;

import com.hazelcast.config.CacheConfig;
import com.hazelcast.spi.ServiceNamespace;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class CachePartitionSegment extends Object implements ConstructorFunction<String, ICacheRecordStore> {
  protected final int partitionId;
  
  protected final Object mutex;
  
  protected final AbstractCacheService cacheService;
  
  protected final ConcurrentMap<String, ICacheRecordStore> recordStores;
  
  private boolean runningCleanupOperation;
  
  private long lastCleanupTimeCopy;
  
  public CachePartitionSegment(AbstractCacheService cacheService, int partitionId) {
    this.mutex = new Object();
    this.recordStores = new ConcurrentHashMap();
    this.cacheService = cacheService;
    this.partitionId = partitionId;
  }
  
  public ICacheRecordStore createNew(String cacheNameWithPrefix) { return this.cacheService.createNewRecordStore(cacheNameWithPrefix, this.partitionId); }
  
  public Iterator<ICacheRecordStore> recordStoreIterator() { return this.recordStores.values().iterator(); }
  
  public boolean hasRunningCleanupOperation() { return this.runningCleanupOperation; }
  
  public void setRunningCleanupOperation(boolean status) { this.runningCleanupOperation = status; }
  
  public long getLastCleanupTime() { return this.lastCleanupTime; }
  
  public void setLastCleanupTime(long time) { this.lastCleanupTime = time; }
  
  public long getLastCleanupTimeBeforeSorting() { return this.lastCleanupTimeCopy; }
  
  public void storeLastCleanupTime() { this.lastCleanupTimeCopy = getLastCleanupTime(); }
  
  public Collection<CacheConfig> getCacheConfigs() { return this.cacheService.getCacheConfigs(); }
  
  public int getPartitionId() { return this.partitionId; }
  
  public ICacheRecordStore getOrCreateRecordStore(String cacheNameWithPrefix) { return (ICacheRecordStore)ConcurrencyUtil.getOrPutSynchronized(this.recordStores, cacheNameWithPrefix, this.mutex, this); }
  
  public ICacheRecordStore getRecordStore(String cacheNameWithPrefix) { return (ICacheRecordStore)this.recordStores.get(cacheNameWithPrefix); }
  
  public ICacheService getCacheService() { return this.cacheService; }
  
  public void deleteRecordStore(String name, boolean destroy) {
    if (destroy) {
      ICacheRecordStore store = (ICacheRecordStore)this.recordStores.remove(name);
      if (store != null)
        store.destroy(); 
    } else {
      ICacheRecordStore store = (ICacheRecordStore)this.recordStores.get(name);
      if (store != null)
        store.close(false); 
    } 
  }
  
  public boolean hasAnyRecordStore() { return !this.recordStores.isEmpty(); }
  
  public boolean hasRecordStore(String name) { return this.recordStores.containsKey(name); }
  
  public void init() {
    synchronized (this.mutex) {
      for (ICacheRecordStore store : this.recordStores.values())
        store.init(); 
    } 
  }
  
  public void reset() {
    synchronized (this.mutex) {
      for (ICacheRecordStore store : this.recordStores.values())
        store.reset(); 
    } 
  }
  
  public void shutdown() {
    synchronized (this.mutex) {
      for (ICacheRecordStore store : this.recordStores.values())
        store.close(true); 
    } 
    this.recordStores.clear();
  }
  
  void clearHavingLesserBackupCountThan(int backupCount) {
    synchronized (this.mutex) {
      for (ICacheRecordStore store : this.recordStores.values()) {
        CacheConfig cacheConfig = store.getConfig();
        if (backupCount > cacheConfig.getTotalBackupCount())
          store.reset(); 
      } 
    } 
  }
  
  public Collection<ServiceNamespace> getAllNamespaces(int replicaIndex) {
    Collection<ServiceNamespace> namespaces = new HashSet<ServiceNamespace>();
    for (ICacheRecordStore recordStore : this.recordStores.values()) {
      if (recordStore.getConfig().getTotalBackupCount() >= replicaIndex)
        namespaces.add(recordStore.getObjectNamespace()); 
    } 
    return namespaces;
  }
}
