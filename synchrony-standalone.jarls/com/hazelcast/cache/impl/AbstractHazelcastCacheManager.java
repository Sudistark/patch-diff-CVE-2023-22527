package com.hazelcast.cache.impl;

import com.hazelcast.cache.CacheUtil;
import com.hazelcast.cache.HazelcastCacheManager;
import com.hazelcast.cache.ICache;
import com.hazelcast.config.CacheConfig;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.HazelcastInstanceNotActiveException;
import com.hazelcast.core.LifecycleService;
import com.hazelcast.util.EmptyStatement;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.SetUtil;
import java.lang.ref.WeakReference;
import java.net.URI;
import java.util.Collections;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.cache.Cache;
import javax.cache.CacheException;
import javax.cache.configuration.CacheEntryListenerConfiguration;
import javax.cache.configuration.CompleteConfiguration;
import javax.cache.configuration.Configuration;
import javax.cache.spi.CachingProvider;

public abstract class AbstractHazelcastCacheManager implements HazelcastCacheManager {
  protected final ConcurrentMap<String, ICacheInternal<?, ?>> caches;
  
  protected final CachingProvider cachingProvider;
  
  protected final HazelcastInstance hazelcastInstance;
  
  protected final boolean isDefaultURI;
  
  protected final boolean isDefaultClassLoader;
  
  protected final URI uri;
  
  protected final Properties properties;
  
  private final AtomicBoolean isClosed;
  
  private final AtomicBoolean isDestroyed;
  
  private final WeakReference<ClassLoader> classLoaderReference;
  
  private final String cacheNamePrefix;
  
  private final String lifecycleListenerRegistrationId;
  
  public AbstractHazelcastCacheManager(CachingProvider cachingProvider, HazelcastInstance hazelcastInstance, URI uri, ClassLoader classLoader, Properties properties) {
    this.caches = new ConcurrentHashMap();
    this.isClosed = new AtomicBoolean(false);
    this.isDestroyed = new AtomicBoolean(false);
    Preconditions.checkNotNull(cachingProvider, "CachingProvider missing");
    this.cachingProvider = cachingProvider;
    Preconditions.checkNotNull(hazelcastInstance, "hazelcastInstance cannot be null");
    this.hazelcastInstance = hazelcastInstance;
    this.isDefaultURI = (uri == null || cachingProvider.getDefaultURI().equals(uri));
    this.uri = this.isDefaultURI ? cachingProvider.getDefaultURI() : uri;
    this.isDefaultClassLoader = (classLoader == null || cachingProvider.getDefaultClassLoader().equals(classLoader));
    ClassLoader localClassLoader = this.isDefaultClassLoader ? cachingProvider.getDefaultClassLoader() : classLoader;
    this.classLoaderReference = new WeakReference(localClassLoader);
    this.properties = (properties == null) ? new Properties() : new Properties(properties);
    this.cacheNamePrefix = getCacheNamePrefix();
    this.lifecycleListenerRegistrationId = registerLifecycleListener();
  }
  
  private <K, V, C extends Configuration<K, V>> ICacheInternal<K, V> createCacheInternal(String cacheName, C configuration) throws IllegalArgumentException {
    ensureOpen();
    Preconditions.checkNotNull(cacheName, "cacheName must not be null");
    Preconditions.checkNotNull(configuration, "configuration must not be null");
    CacheConfig<K, V> newCacheConfig = createCacheConfig(cacheName, configuration);
    validateCacheConfig(newCacheConfig);
    if (this.caches.containsKey(newCacheConfig.getNameWithPrefix()))
      throw new CacheException("A cache named '" + cacheName + "' already exists"); 
    createCacheConfig(cacheName, newCacheConfig);
    ICacheInternal<K, V> cacheProxy = createCacheProxy(newCacheConfig);
    addCacheConfigIfAbsent(newCacheConfig);
    ICacheInternal<?, ?> existingCache = (ICacheInternal)this.caches.putIfAbsent(newCacheConfig.getNameWithPrefix(), cacheProxy);
    if (existingCache == null) {
      registerListeners(newCacheConfig, cacheProxy);
      return cacheProxy;
    } 
    CacheConfig<?, ?> config = (CacheConfig)existingCache.getConfiguration(CacheConfig.class);
    if (config.equals(newCacheConfig))
      return existingCache; 
    throw new CacheException("A cache named " + cacheName + " already exists");
  }
  
  public HazelcastInstance getHazelcastInstance() { return this.hazelcastInstance; }
  
  public <K, V, C extends Configuration<K, V>> ICache<K, V> createCache(String cacheName, C configuration) throws IllegalArgumentException { return createCacheInternal(cacheName, configuration); }
  
  public CachingProvider getCachingProvider() { return this.cachingProvider; }
  
  public URI getURI() { return this.uri; }
  
  public ClassLoader getClassLoader() { return (ClassLoader)this.classLoaderReference.get(); }
  
  public Properties getProperties() { return this.properties; }
  
  public <K, V> ICache<K, V> getCache(String cacheName, Class<K> keyType, Class<V> valueType) {
    ensureOpen();
    Preconditions.checkNotNull(keyType, "keyType can not be null");
    Preconditions.checkNotNull(valueType, "valueType can not be null");
    ICacheInternal<?, ?> cache = getCacheUnchecked(cacheName);
    if (cache != null) {
      Configuration<?, ?> configuration = cache.getConfiguration(CacheConfig.class);
      if (configuration.getKeyType() != null && configuration.getKeyType().equals(keyType)) {
        if (configuration.getValueType() != null && configuration.getValueType().equals(valueType))
          return ensureOpenIfAvailable(cache); 
        throw new ClassCastException("Incompatible cache value types specified, expected " + configuration
            .getValueType() + " but " + valueType + " was specified");
      } 
      throw new ClassCastException("Incompatible cache key types specified, expected " + configuration
          .getKeyType() + " but " + keyType + " was specified");
    } 
    return null;
  }
  
  public <K, V> ICache<K, V> getOrCreateCache(String cacheName, CacheConfig<K, V> cacheConfig) {
    ensureOpen();
    String cacheNameWithPrefix = getCacheNameWithPrefix(cacheName);
    ICacheInternal<?, ?> cache = (ICacheInternal)this.caches.get(cacheNameWithPrefix);
    if (cache == null)
      cache = createCacheInternal(cacheName, cacheConfig); 
    return ensureOpenIfAvailable(cache);
  }
  
  public <K, V> ICache<K, V> getCache(String cacheName) {
    ensureOpen();
    ICacheInternal<?, ?> cache = getCacheUnchecked(cacheName);
    if (cache != null)
      return ensureOpenIfAvailable(cache); 
    return null;
  }
  
  private <K, V> ICacheInternal<K, V> ensureOpenIfAvailable(ICacheInternal<K, V> cache) {
    if (cache != null && cache.isClosed() && !cache.isDestroyed())
      cache.open(); 
    return cache;
  }
  
  private <K, V> ICacheInternal<?, ?> getCacheUnchecked(String cacheName) {
    String cacheNameWithPrefix = getCacheNameWithPrefix(cacheName);
    ICacheInternal<?, ?> cache = (ICacheInternal)this.caches.get(cacheNameWithPrefix);
    if (cache == null) {
      CacheConfig<K, V> cacheConfig = findCacheConfig(cacheNameWithPrefix, cacheName);
      if (cacheConfig == null)
        return null; 
      ICacheInternal<K, V> cacheProxy = createCacheProxy(cacheConfig);
      addCacheConfigIfAbsent(cacheConfig);
      cache = (ICacheInternal)this.caches.putIfAbsent(cacheNameWithPrefix, cacheProxy);
      if (cache == null) {
        registerListeners(cacheConfig, cacheProxy);
        cache = cacheProxy;
      } 
    } 
    if (cache != null)
      cache.setCacheManager(this); 
    return cache;
  }
  
  public Iterable<String> getCacheNames() {
    ensureOpen();
    Set<String> names = SetUtil.createLinkedHashSet(this.caches.size());
    for (Map.Entry<String, ICacheInternal<?, ?>> entry : this.caches.entrySet()) {
      String nameWithPrefix = (String)entry.getKey();
      int index = nameWithPrefix.indexOf(this.cacheNamePrefix) + this.cacheNamePrefix.length();
      String name = nameWithPrefix.substring(index);
      names.add(name);
    } 
    return Collections.unmodifiableCollection(names);
  }
  
  public void destroyCache(String cacheName) { removeCache(cacheName, true); }
  
  public void removeCache(String cacheName, boolean destroy) {
    ensureOpen();
    Preconditions.checkNotNull(cacheName, "cacheName cannot be null");
    String cacheNameWithPrefix = getCacheNameWithPrefix(cacheName);
    ICacheInternal<?, ?> cache = (ICacheInternal)this.caches.remove(cacheNameWithPrefix);
    if (cache != null && destroy)
      cache.destroy(); 
    removeCacheConfigFromLocal(cacheNameWithPrefix);
  }
  
  protected void removeCacheConfigFromLocal(String cacheNameWithPrefix) {}
  
  private String registerLifecycleListener() { return this.hazelcastInstance.getLifecycleService().addLifecycleListener(new Object(this)); }
  
  private void deregisterLifecycleListener() {
    LifecycleService lifecycleService = this.hazelcastInstance.getLifecycleService();
    try {
      lifecycleService.removeLifecycleListener(this.lifecycleListenerRegistrationId);
    } catch (HazelcastInstanceNotActiveException e) {
      EmptyStatement.ignore(e);
    } 
  }
  
  public void close() {
    if (this.isDestroyed.get() || !this.isClosed.compareAndSet(false, true))
      return; 
    deregisterLifecycleListener();
    for (ICacheInternal cache : this.caches.values())
      cache.close(); 
    postClose();
  }
  
  public void destroy() {
    if (!this.isDestroyed.compareAndSet(false, true))
      return; 
    deregisterLifecycleListener();
    for (ICacheInternal cache : this.caches.values())
      cache.destroy(); 
    this.caches.clear();
    this.isClosed.set(true);
    postDestroy();
  }
  
  protected void postDestroy() {}
  
  public boolean isClosed() { return (this.isClosed.get() || !this.hazelcastInstance.getLifecycleService().isRunning()); }
  
  protected void ensureOpen() {
    if (isClosed())
      throw new IllegalStateException("CacheManager " + this.cacheNamePrefix + " is already closed."); 
  }
  
  private String getCacheNamePrefix() {
    String cacheNamePrefix = CacheUtil.getPrefix(this.isDefaultURI ? null : this.uri, this.isDefaultClassLoader ? null : 
        
        getClassLoader());
    if (cacheNamePrefix == null)
      return "/hz/"; 
    return "/hz/" + cacheNamePrefix;
  }
  
  public String getCacheNameWithPrefix(String name) { return this.cacheNamePrefix + name; }
  
  protected <K, V, C extends Configuration<K, V>> CacheConfig<K, V> createCacheConfig(String cacheName, C configuration) {
    CacheConfig<K, V> cacheConfig;
    if (configuration instanceof CompleteConfiguration) {
      cacheConfig = new CacheConfig<K, V>((CompleteConfiguration)configuration);
    } else {
      cacheConfig = new CacheConfig<K, V>();
      cacheConfig.setStoreByValue(configuration.isStoreByValue());
      Class<K> keyType = configuration.getKeyType();
      Class<V> valueType = configuration.getValueType();
      cacheConfig.setTypes(keyType, valueType);
    } 
    cacheConfig.setName(cacheName);
    cacheConfig.setManagerPrefix(this.cacheNamePrefix);
    cacheConfig.setUriString(getURI().toString());
    return cacheConfig;
  }
  
  private <K, V> void registerListeners(CacheConfig<K, V> cacheConfig, ICache<K, V> source) {
    for (CacheEntryListenerConfiguration<K, V> listenerConfig : cacheConfig.getCacheEntryListenerConfigurations())
      ((ICacheInternal)source).registerCacheEntryListener(listenerConfig, false); 
  }
  
  public String toString() { return "HazelcastCacheManager{hazelcastInstance=" + this.hazelcastInstance + ", cachingProvider=" + this.cachingProvider + '}'; }
  
  protected abstract <K, V> void validateCacheConfig(CacheConfig<K, V> paramCacheConfig);
  
  protected abstract <K, V> void addCacheConfigIfAbsent(CacheConfig<K, V> paramCacheConfig);
  
  protected abstract <K, V> ICacheInternal<K, V> createCacheProxy(CacheConfig<K, V> paramCacheConfig);
  
  protected abstract <K, V> CacheConfig<K, V> findCacheConfig(String paramString1, String paramString2);
  
  protected abstract <K, V> void createCacheConfig(String paramString, CacheConfig<K, V> paramCacheConfig);
  
  protected abstract <K, V> CacheConfig<K, V> getCacheConfig(String paramString1, String paramString2);
  
  protected abstract void postClose();
  
  protected abstract void onShuttingDown();
}
