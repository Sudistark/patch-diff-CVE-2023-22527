package com.hazelcast.cache.impl;

import com.hazelcast.config.CacheConfig;
import com.hazelcast.core.ManagedContext;
import com.hazelcast.logging.ILogger;
import com.hazelcast.spi.AbstractDistributedObject;
import com.hazelcast.spi.ExecutionService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.executor.CompletableFutureTask;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.cache.CacheException;

abstract class AbstractCacheProxyBase<K, V> extends AbstractDistributedObject<ICacheService> implements ICacheInternal<K, V> {
  private static final int TIMEOUT = 10;
  
  private static final double SIZING_FUDGE_FACTOR = 1.3D;
  
  protected final ILogger logger;
  
  protected final CacheConfig<K, V> cacheConfig;
  
  protected final String name;
  
  protected final String nameWithPrefix;
  
  protected final ICacheService cacheService;
  
  protected final SerializationService serializationService;
  
  protected final CacheOperationProvider operationProvider;
  
  protected final IPartitionService partitionService;
  
  private final NodeEngine nodeEngine;
  
  private final CopyOnWriteArrayList<Future> loadAllTasks = new CopyOnWriteArrayList();
  
  private final AtomicBoolean isClosed = new AtomicBoolean(false);
  
  private final AtomicBoolean isDestroyed = new AtomicBoolean(false);
  
  AbstractCacheProxyBase(CacheConfig<K, V> cacheConfig, NodeEngine nodeEngine, ICacheService cacheService) {
    super(nodeEngine, cacheService);
    this.name = cacheConfig.getName();
    this.nameWithPrefix = cacheConfig.getNameWithPrefix();
    this.cacheConfig = cacheConfig;
    this.nodeEngine = nodeEngine;
    this.logger = nodeEngine.getLogger(getClass());
    this.partitionService = nodeEngine.getPartitionService();
    this.cacheService = cacheService;
    this.serializationService = nodeEngine.getSerializationService();
    this
      .operationProvider = cacheService.getCacheOperationProvider(this.nameWithPrefix, cacheConfig.getInMemoryFormat());
  }
  
  void injectDependencies(Object obj) {
    ManagedContext managedContext = this.serializationService.getManagedContext();
    managedContext.initialize(obj);
  }
  
  public String getName() { return this.name; }
  
  protected String getDistributedObjectName() { return this.nameWithPrefix; }
  
  public String getPrefixedName() { return this.nameWithPrefix; }
  
  public String getServiceName() { return "hz:impl:cacheService"; }
  
  public void open() {
    if (this.isDestroyed.get())
      throw new IllegalStateException("Cache is already destroyed! Cannot be reopened"); 
    this.isClosed.compareAndSet(true, false);
  }
  
  public void close() { close0(false); }
  
  private void close0(boolean destroy) {
    if (!this.isClosed.compareAndSet(false, true))
      return; 
    Exception caughtException = null;
    for (Future f : this.loadAllTasks) {
      try {
        f.get(10L, TimeUnit.SECONDS);
      } catch (Exception e) {
        if (caughtException == null)
          caughtException = e; 
        getNodeEngine().getLogger(getClass()).warning("Problem while waiting for loadAll tasks to complete", e);
      } 
    } 
    this.loadAllTasks.clear();
    closeListeners();
    if (!destroy)
      resetCacheManager(); 
    if (caughtException != null)
      throw new CacheException("Problem while waiting for loadAll tasks to complete", caughtException); 
  }
  
  protected boolean preDestroy() {
    close0(true);
    if (!this.isDestroyed.compareAndSet(false, true))
      return false; 
    this.isClosed.set(true);
    return true;
  }
  
  public boolean isClosed() { return this.isClosed.get(); }
  
  public boolean isDestroyed() { return this.isDestroyed.get(); }
  
  void ensureOpen() {
    if (isClosed())
      throw new IllegalStateException("Cache operations can not be performed. The cache closed"); 
  }
  
  void submitLoadAllTask(LoadAllTask loadAllTask) {
    ExecutionService executionService = this.nodeEngine.getExecutionService();
    CompletableFutureTask<Object> future = (CompletableFutureTask)executionService.submit("loadAll-" + this.nameWithPrefix, loadAllTask);
    this.loadAllTasks.add(future);
    future.andThen(new Object(this, future));
  }
  
  public boolean equals(Object o) {
    if (this == o)
      return true; 
    if (o == null || getClass() != o.getClass())
      return false; 
    AbstractCacheProxyBase that = (AbstractCacheProxyBase)o;
    if ((this.nameWithPrefix != null) ? !this.nameWithPrefix.equals(that.nameWithPrefix) : (that.nameWithPrefix != null))
      return false; 
    return true;
  }
  
  public int hashCode() { return (this.nameWithPrefix != null) ? this.nameWithPrefix.hashCode() : 0; }
  
  public String toString() { return getClass().getName() + '{' + "name=" + this.name + ", nameWithPrefix=" + this.nameWithPrefix + '}'; }
  
  abstract void closeListeners();
}
