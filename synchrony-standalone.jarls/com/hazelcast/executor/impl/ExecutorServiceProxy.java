package com.hazelcast.executor.impl;

import com.hazelcast.core.ExecutionCallback;
import com.hazelcast.core.HazelcastInstanceNotActiveException;
import com.hazelcast.core.IExecutorService;
import com.hazelcast.core.Member;
import com.hazelcast.core.MemberSelector;
import com.hazelcast.core.MultiExecutionCallback;
import com.hazelcast.core.PartitionAware;
import com.hazelcast.executor.impl.operations.CallableTaskOperation;
import com.hazelcast.executor.impl.operations.MemberCallableTaskOperation;
import com.hazelcast.executor.impl.operations.ShutdownOperation;
import com.hazelcast.logging.ILogger;
import com.hazelcast.monitor.LocalExecutorStats;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.AbstractDistributedObject;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.OperationService;
import com.hazelcast.util.Clock;
import com.hazelcast.util.FutureUtil;
import com.hazelcast.util.MapUtil;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.UuidUtil;
import com.hazelcast.util.executor.CompletedFuture;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;

public class ExecutorServiceProxy extends AbstractDistributedObject<DistributedExecutorService> implements IExecutorService {
  public static final int SYNC_FREQUENCY = 100;
  
  public static final int SYNC_DELAY_MS = 10;
  
  private static final AtomicIntegerFieldUpdater<ExecutorServiceProxy> CONSECUTIVE_SUBMITS = AtomicIntegerFieldUpdater.newUpdater(ExecutorServiceProxy.class, "consecutiveSubmits");
  
  private final FutureUtil.ExceptionHandler shutdownExceptionHandler = new Object(this);
  
  private final String name;
  
  private final Random random = new Random(-System.currentTimeMillis());
  
  private final int partitionCount;
  
  private final ILogger logger;
  
  public ExecutorServiceProxy(String name, NodeEngine nodeEngine, DistributedExecutorService service) {
    super(nodeEngine, service);
    this.name = name;
    this.partitionCount = nodeEngine.getPartitionService().getPartitionCount();
    this.logger = nodeEngine.getLogger(ExecutorServiceProxy.class);
    getLocalExecutorStats();
  }
  
  public void execute(Runnable command, MemberSelector memberSelector) {
    List<Member> members = selectMembers(memberSelector);
    int selectedMember = this.random.nextInt(members.size());
    executeOnMember(command, (Member)members.get(selectedMember));
  }
  
  public void executeOnMembers(Runnable command, MemberSelector memberSelector) {
    List<Member> members = selectMembers(memberSelector);
    executeOnMembers(command, members);
  }
  
  public <T> Future<T> submit(Callable<T> task, MemberSelector memberSelector) {
    List<Member> members = selectMembers(memberSelector);
    int selectedMember = this.random.nextInt(members.size());
    return submitToMember(task, (Member)members.get(selectedMember));
  }
  
  public <T> Map<Member, Future<T>> submitToMembers(Callable<T> task, MemberSelector memberSelector) {
    List<Member> members = selectMembers(memberSelector);
    return submitToMembers(task, members);
  }
  
  public void submit(Runnable task, MemberSelector memberSelector, ExecutionCallback callback) {
    List<Member> members = selectMembers(memberSelector);
    int selectedMember = this.random.nextInt(members.size());
    submitToMember(task, (Member)members.get(selectedMember), callback);
  }
  
  public void submitToMembers(Runnable task, MemberSelector memberSelector, MultiExecutionCallback callback) {
    List<Member> members = selectMembers(memberSelector);
    submitToMembers(task, members, callback);
  }
  
  public <T> void submit(Callable<T> task, MemberSelector memberSelector, ExecutionCallback<T> callback) {
    List<Member> members = selectMembers(memberSelector);
    int selectedMember = this.random.nextInt(members.size());
    submitToMember(task, (Member)members.get(selectedMember), callback);
  }
  
  public <T> void submitToMembers(Callable<T> task, MemberSelector memberSelector, MultiExecutionCallback callback) {
    List<Member> members = selectMembers(memberSelector);
    submitToMembers(task, members, callback);
  }
  
  public void execute(Runnable command) {
    RunnableAdapter runnableAdapter = createRunnableAdapter(command);
    submit(runnableAdapter);
  }
  
  private <T> RunnableAdapter<T> createRunnableAdapter(Runnable command) {
    Preconditions.checkNotNull(command, "Command can't be null");
    return new RunnableAdapter(command);
  }
  
  public void executeOnKeyOwner(Runnable command, Object key) {
    RunnableAdapter runnableAdapter = createRunnableAdapter(command);
    submitToKeyOwner(runnableAdapter, key);
  }
  
  public void executeOnMember(Runnable command, Member member) {
    RunnableAdapter runnableAdapter = createRunnableAdapter(command);
    submitToMember(runnableAdapter, member);
  }
  
  public void executeOnMembers(Runnable command, Collection<Member> members) {
    RunnableAdapter runnableAdapter = createRunnableAdapter(command);
    submitToMembers(runnableAdapter, members);
  }
  
  public void executeOnAllMembers(Runnable command) {
    RunnableAdapter runnableAdapter = createRunnableAdapter(command);
    submitToAllMembers(runnableAdapter);
  }
  
  public Future<?> submit(Runnable task) {
    RunnableAdapter runnableAdapter = createRunnableAdapter(task);
    return submit(runnableAdapter);
  }
  
  public <T> Future<T> submit(Runnable task, T result) {
    Preconditions.checkNotNull(task, "task can't be null");
    checkNotShutdown();
    NodeEngine nodeEngine = getNodeEngine();
    RunnableAdapter runnableAdapter = createRunnableAdapter(task);
    Data callableData = nodeEngine.toData(runnableAdapter);
    String uuid = UuidUtil.newUnsecureUuidString();
    int partitionId = getTaskPartitionId(runnableAdapter);
    Operation op = (new CallableTaskOperation(this.name, uuid, callableData)).setPartitionId(partitionId);
    InternalCompletableFuture future = invokeOnPartition(op);
    boolean sync = checkSync();
    if (sync) {
      try {
        future.get();
      } catch (Exception exception) {
        this.logger.warning(exception);
      } 
      return new CompletedFuture(nodeEngine.getSerializationService(), result, getAsyncExecutor());
    } 
    return new CancellableDelegatingFuture(future, result, nodeEngine, uuid, partitionId);
  }
  
  private void checkNotShutdown() {
    if (isShutdown())
      throw new RejectedExecutionException(getRejectionMessage()); 
  }
  
  public <T> Future<T> submit(Callable<T> task) {
    int partitionId = getTaskPartitionId(task);
    return submitToPartitionOwner(task, partitionId, false);
  }
  
  private <T> Future<T> submitToPartitionOwner(Callable<T> task, int partitionId, boolean preventSync) {
    Preconditions.checkNotNull(task, "task can't be null");
    checkNotShutdown();
    NodeEngine nodeEngine = getNodeEngine();
    Data taskData = nodeEngine.toData(task);
    String uuid = UuidUtil.newUnsecureUuidString();
    boolean sync = (!preventSync && checkSync());
    Operation op = (new CallableTaskOperation(this.name, uuid, taskData)).setPartitionId(partitionId);
    InternalCompletableFuture future = invokeOnPartition(op);
    if (sync) {
      Object response;
      try {
        response = future.get();
      } catch (Exception e) {
        response = e;
      } 
      return new CompletedFuture(nodeEngine.getSerializationService(), response, getAsyncExecutor());
    } 
    return new CancellableDelegatingFuture(future, nodeEngine, uuid, partitionId);
  }
  
  private boolean checkSync() {
    boolean sync = false;
    long last = this.lastSubmitTime;
    long now = Clock.currentTimeMillis();
    if (last + 10L < now) {
      CONSECUTIVE_SUBMITS.set(this, 0);
    } else if (CONSECUTIVE_SUBMITS.incrementAndGet(this) % 100 == 0) {
      sync = true;
    } 
    this.lastSubmitTime = now;
    return sync;
  }
  
  private <T> int getTaskPartitionId(Callable<T> task) {
    if (task instanceof PartitionAware) {
      Object partitionKey = ((PartitionAware)task).getPartitionKey();
      if (partitionKey != null)
        return getNodeEngine().getPartitionService().getPartitionId(partitionKey); 
    } 
    return this.random.nextInt(this.partitionCount);
  }
  
  public <T> Future<T> submitToKeyOwner(Callable<T> task, Object key) {
    NodeEngine nodeEngine = getNodeEngine();
    return submitToPartitionOwner(task, nodeEngine.getPartitionService().getPartitionId(key), false);
  }
  
  public <T> Future<T> submitToMember(Callable<T> task, Member member) {
    Preconditions.checkNotNull(task, "task can't be null");
    checkNotShutdown();
    Data taskData = getNodeEngine().toData(task);
    return submitToMember(taskData, member);
  }
  
  private <T> Future<T> submitToMember(Data taskData, Member member) {
    NodeEngine nodeEngine = getNodeEngine();
    String uuid = UuidUtil.newUnsecureUuidString();
    Address target = member.getAddress();
    boolean sync = checkSync();
    MemberCallableTaskOperation op = new MemberCallableTaskOperation(this.name, uuid, taskData);
    InternalCompletableFuture future = nodeEngine.getOperationService().invokeOnTarget("hz:impl:executorService", op, target);
    if (sync) {
      Object response;
      try {
        response = future.get();
      } catch (Exception e) {
        response = e;
      } 
      return new CompletedFuture(nodeEngine.getSerializationService(), response, getAsyncExecutor());
    } 
    return new CancellableDelegatingFuture(future, nodeEngine, uuid, target);
  }
  
  public <T> Map<Member, Future<T>> submitToMembers(Callable<T> task, Collection<Member> members) {
    Preconditions.checkNotNull(task, "task can't be null");
    checkNotShutdown();
    Data taskData = getNodeEngine().toData(task);
    Map<Member, Future<T>> futures = MapUtil.createHashMap(members.size());
    for (Member member : members) {
      Future<T> future = submitToMember(taskData, member);
      futures.put(member, future);
    } 
    return futures;
  }
  
  public <T> Map<Member, Future<T>> submitToAllMembers(Callable<T> task) {
    NodeEngine nodeEngine = getNodeEngine();
    return submitToMembers(task, nodeEngine.getClusterService().getMembers());
  }
  
  public void submit(Runnable task, ExecutionCallback callback) {
    RunnableAdapter runnableAdapter = createRunnableAdapter(task);
    submit(runnableAdapter, callback);
  }
  
  public void submitToKeyOwner(Runnable task, Object key, ExecutionCallback callback) {
    RunnableAdapter runnableAdapter = createRunnableAdapter(task);
    submitToKeyOwner(runnableAdapter, key, callback);
  }
  
  public void submitToMember(Runnable task, Member member, ExecutionCallback callback) {
    RunnableAdapter runnableAdapter = createRunnableAdapter(task);
    submitToMember(runnableAdapter, member, callback);
  }
  
  public void submitToMembers(Runnable task, Collection<Member> members, MultiExecutionCallback callback) {
    RunnableAdapter runnableAdapter = createRunnableAdapter(task);
    submitToMembers(runnableAdapter, members, callback);
  }
  
  public void submitToAllMembers(Runnable task, MultiExecutionCallback callback) {
    RunnableAdapter runnableAdapter = createRunnableAdapter(task);
    submitToAllMembers(runnableAdapter, callback);
  }
  
  private <T> void submitToPartitionOwner(Callable<T> task, ExecutionCallback<T> callback, int partitionId) {
    checkNotShutdown();
    NodeEngine nodeEngine = getNodeEngine();
    Data taskData = nodeEngine.toData(task);
    CallableTaskOperation op = new CallableTaskOperation(this.name, null, taskData);
    OperationService operationService = nodeEngine.getOperationService();
    operationService.createInvocationBuilder("hz:impl:executorService", op, partitionId)
      .setExecutionCallback(callback).invoke();
  }
  
  public <T> void submit(Callable<T> task, ExecutionCallback<T> callback) {
    int partitionId = getTaskPartitionId(task);
    submitToPartitionOwner(task, callback, partitionId);
  }
  
  public <T> void submitToKeyOwner(Callable<T> task, Object key, ExecutionCallback<T> callback) {
    NodeEngine nodeEngine = getNodeEngine();
    submitToPartitionOwner(task, callback, nodeEngine.getPartitionService().getPartitionId(key));
  }
  
  private <T> void submitToMember(Data taskData, Member member, ExecutionCallback<T> callback) {
    checkNotShutdown();
    NodeEngine nodeEngine = getNodeEngine();
    String uuid = UuidUtil.newUnsecureUuidString();
    MemberCallableTaskOperation op = new MemberCallableTaskOperation(this.name, uuid, taskData);
    OperationService operationService = nodeEngine.getOperationService();
    Address address = member.getAddress();
    operationService
      .createInvocationBuilder("hz:impl:executorService", op, address)
      .setExecutionCallback(callback).invoke();
  }
  
  public <T> void submitToMember(Callable<T> task, Member member, ExecutionCallback<T> callback) {
    checkNotShutdown();
    Data taskData = getNodeEngine().toData(task);
    submitToMember(taskData, member, callback);
  }
  
  private String getRejectionMessage() { return "ExecutorService[" + this.name + "] is shutdown! In order to create a new ExecutorService with name '" + this.name + "', you need to destroy current ExecutorService first!"; }
  
  public <T> void submitToMembers(Callable<T> task, Collection<Member> members, MultiExecutionCallback callback) {
    NodeEngine nodeEngine = getNodeEngine();
    ExecutionCallbackAdapterFactory executionCallbackFactory = new ExecutionCallbackAdapterFactory(nodeEngine.getLogger(ExecutionCallbackAdapterFactory.class), members, callback);
    Data taskData = nodeEngine.toData(task);
    for (Member member : members)
      submitToMember(taskData, member, executionCallbackFactory.callbackFor(member)); 
  }
  
  public <T> void submitToAllMembers(Callable<T> task, MultiExecutionCallback callback) {
    NodeEngine nodeEngine = getNodeEngine();
    submitToMembers(task, nodeEngine.getClusterService().getMembers(), callback);
  }
  
  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
    List<Future<T>> futures = new ArrayList<Future<T>>(tasks.size());
    List<Future<T>> result = new ArrayList<Future<T>>(tasks.size());
    for (Callable<T> task : tasks)
      futures.add(submit(task)); 
    for (Future<T> future : futures) {
      Object value;
      try {
        value = future.get();
      } catch (ExecutionException e) {
        value = e;
      } 
      result.add(new CompletedFuture(getNodeEngine().getSerializationService(), value, getAsyncExecutor()));
    } 
    return result;
  }
  
  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {
    Preconditions.checkNotNull(unit, "unit must not be null");
    Preconditions.checkNotNull(tasks, "tasks must not be null");
    long timeoutNanos = unit.toNanos(timeout);
    futures = new ArrayList<Future<T>>(tasks.size());
    done = false;
    try {
      for (Callable<T> task : tasks) {
        long start = System.nanoTime();
        int partitionId = getTaskPartitionId(task);
        futures.add(submitToPartitionOwner(task, partitionId, true));
        timeoutNanos -= System.nanoTime() - start;
      } 
      if (timeoutNanos <= 0L)
        return futures; 
      done = wait(timeoutNanos, futures);
      return futures;
    } catch (Throwable t) {
      this.logger.severe(t);
      return futures;
    } finally {
      if (!done)
        cancelAll(futures); 
    } 
  }
  
  private <T> boolean wait(long timeoutNanos, List<Future<T>> futures) throws InterruptedException {
    boolean done = true;
    for (int i = 0, size = futures.size(); i < size; i++) {
      Object value;
      long start = System.nanoTime();
      try {
        Future<T> future = (Future)futures.get(i);
        value = future.get(timeoutNanos, TimeUnit.NANOSECONDS);
      } catch (ExecutionException e) {
        value = e;
      } catch (TimeoutException e) {
        done = false;
        for (int l = i; l < size; l++) {
          Future<T> f = (Future)futures.get(i);
          if (f.isDone()) {
            Object v;
            try {
              v = f.get();
            } catch (ExecutionException ex) {
              v = ex;
            } 
            futures.set(l, new CompletedFuture(getNodeEngine().getSerializationService(), v, getAsyncExecutor()));
          } 
        } 
        break;
      } 
      futures.set(i, new CompletedFuture(getNodeEngine().getSerializationService(), value, getAsyncExecutor()));
      timeoutNanos -= System.nanoTime() - start;
    } 
    return done;
  }
  
  private static <T> void cancelAll(List<Future<T>> result) {
    for (Future<T> aResult : result)
      aResult.cancel(true); 
  }
  
  public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException { throw new UnsupportedOperationException(); }
  
  public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException { throw new UnsupportedOperationException(); }
  
  protected void throwNotActiveException() { throw new RejectedExecutionException(); }
  
  public boolean isShutdown() {
    try {
      return ((DistributedExecutorService)getService()).isShutdown(this.name);
    } catch (HazelcastInstanceNotActiveException e) {
      return true;
    } 
  }
  
  public boolean isTerminated() { return isShutdown(); }
  
  public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException { return false; }
  
  public void shutdown() {
    NodeEngine nodeEngine = getNodeEngine();
    Collection<Member> members = nodeEngine.getClusterService().getMembers();
    OperationService operationService = nodeEngine.getOperationService();
    Collection<Future> calls = new LinkedList<Future>();
    for (Member member : members) {
      InternalCompletableFuture internalCompletableFuture = submitShutdownOperation(operationService, member);
      calls.add(internalCompletableFuture);
    } 
    FutureUtil.waitWithDeadline(calls, 3L, TimeUnit.SECONDS, this.shutdownExceptionHandler);
  }
  
  private InternalCompletableFuture submitShutdownOperation(OperationService operationService, Member member) {
    ShutdownOperation op = new ShutdownOperation(this.name);
    return operationService.invokeOnTarget(getServiceName(), op, member.getAddress());
  }
  
  public List<Runnable> shutdownNow() {
    shutdown();
    return Collections.emptyList();
  }
  
  public LocalExecutorStats getLocalExecutorStats() { return ((DistributedExecutorService)getService()).getLocalExecutorStats(this.name); }
  
  public String getServiceName() { return "hz:impl:executorService"; }
  
  public String getName() { return this.name; }
  
  private ExecutorService getAsyncExecutor() { return getNodeEngine().getExecutionService().getExecutor("hz:async"); }
  
  private List<Member> selectMembers(MemberSelector memberSelector) {
    if (memberSelector == null)
      throw new IllegalArgumentException("memberSelector must not be null"); 
    List<Member> selected = new ArrayList<Member>();
    Collection<Member> members = getNodeEngine().getClusterService().getMembers();
    for (Member member : members) {
      if (memberSelector.select(member))
        selected.add(member); 
    } 
    if (selected.isEmpty())
      throw new RejectedExecutionException("No member selected with memberSelector[" + memberSelector + "]"); 
    return selected;
  }
  
  public String toString() { return "IExecutorService{name='" + this.name + '\'' + '}'; }
}
