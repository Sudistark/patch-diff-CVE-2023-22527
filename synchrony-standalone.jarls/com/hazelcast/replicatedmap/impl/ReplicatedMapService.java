package com.hazelcast.replicatedmap.impl;

import com.hazelcast.config.Config;
import com.hazelcast.config.InMemoryFormat;
import com.hazelcast.config.ListenerConfig;
import com.hazelcast.config.MergePolicyConfig;
import com.hazelcast.config.ReplicatedMapConfig;
import com.hazelcast.core.DistributedObject;
import com.hazelcast.core.EntryListener;
import com.hazelcast.core.HazelcastInstanceAware;
import com.hazelcast.core.Member;
import com.hazelcast.core.MemberSelector;
import com.hazelcast.internal.cluster.ClusterService;
import com.hazelcast.internal.config.ConfigValidator;
import com.hazelcast.internal.partition.impl.InternalPartitionServiceImpl;
import com.hazelcast.internal.serialization.impl.HeapData;
import com.hazelcast.monitor.LocalReplicatedMapStats;
import com.hazelcast.monitor.impl.LocalReplicatedMapStatsImpl;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.ClassLoaderUtil;
import com.hazelcast.quorum.QuorumService;
import com.hazelcast.quorum.QuorumType;
import com.hazelcast.replicatedmap.ReplicatedMapCantBeCreatedOnLiteMemberException;
import com.hazelcast.replicatedmap.impl.operation.ReplicationOperation;
import com.hazelcast.replicatedmap.impl.record.ReplicatedRecord;
import com.hazelcast.replicatedmap.impl.record.ReplicatedRecordStore;
import com.hazelcast.replicatedmap.merge.MergePolicyProvider;
import com.hazelcast.spi.EventPublishingService;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.MigrationAwareService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.OperationService;
import com.hazelcast.spi.PartitionMigrationEvent;
import com.hazelcast.spi.PartitionReplicationEvent;
import com.hazelcast.spi.QuorumAwareService;
import com.hazelcast.spi.RemoteService;
import com.hazelcast.spi.SplitBrainHandlerService;
import com.hazelcast.spi.StatisticsAwareService;
import com.hazelcast.spi.impl.eventservice.impl.TrueEventFilter;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.ContextMutexFactory;
import com.hazelcast.util.ExceptionUtil;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

public class ReplicatedMapService extends Object implements ManagedService, RemoteService, EventPublishingService<Object, Object>, MigrationAwareService, SplitBrainHandlerService, StatisticsAwareService<LocalReplicatedMapStats>, QuorumAwareService {
  public static final String SERVICE_NAME = "hz:impl:replicatedMapService";
  
  public static final int INVOCATION_TRY_COUNT = 3;
  
  private static final int SYNC_INTERVAL_SECONDS = 30;
  
  private static final Object NULL_OBJECT = new Object();
  
  private final AntiEntropyTask antiEntropyTask;
  
  private final ConcurrentMap<String, Object> quorumConfigCache;
  
  private final ContextMutexFactory quorumConfigCacheMutexFactory;
  
  private final ConstructorFunction<String, Object> quorumConfigConstructor;
  
  private final ConcurrentHashMap<String, LocalReplicatedMapStatsImpl> statsMap;
  
  private final ConstructorFunction<String, LocalReplicatedMapStatsImpl> statsConstructorFunction;
  
  private final Config config;
  
  private final NodeEngine nodeEngine;
  
  private final PartitionContainer[] partitionContainers;
  
  private final InternalPartitionServiceImpl partitionService;
  
  private final ClusterService clusterService;
  
  private final OperationService operationService;
  
  private final QuorumService quorumService;
  
  private final ReplicatedMapEventPublishingService eventPublishingService;
  
  private final ReplicatedMapSplitBrainHandlerService splitBrainHandlerService;
  
  private ScheduledFuture antiEntropyFuture;
  
  private MergePolicyProvider mergePolicyProvider;
  
  public ReplicatedMapService(NodeEngine nodeEngine) {
    this.antiEntropyTask = new AntiEntropyTask(this, null);
    this.quorumConfigCache = new ConcurrentHashMap();
    this.quorumConfigCacheMutexFactory = new ContextMutexFactory();
    this.quorumConfigConstructor = new Object(this);
    this.statsMap = new ConcurrentHashMap();
    this.statsConstructorFunction = new Object(this);
    this.nodeEngine = nodeEngine;
    this.config = nodeEngine.getConfig();
    this.partitionService = (InternalPartitionServiceImpl)nodeEngine.getPartitionService();
    this.clusterService = nodeEngine.getClusterService();
    this.operationService = nodeEngine.getOperationService();
    this.partitionContainers = new PartitionContainer[nodeEngine.getPartitionService().getPartitionCount()];
    this.eventPublishingService = new ReplicatedMapEventPublishingService(this);
    this.splitBrainHandlerService = new ReplicatedMapSplitBrainHandlerService(this);
    this.quorumService = nodeEngine.getQuorumService();
    this.mergePolicyProvider = new MergePolicyProvider(nodeEngine);
  }
  
  public void init(NodeEngine nodeEngine, Properties properties) {
    for (int i = 0; i < nodeEngine.getPartitionService().getPartitionCount(); i++)
      this.partitionContainers[i] = new PartitionContainer(this, i); 
    this
      .antiEntropyFuture = nodeEngine.getExecutionService().getGlobalTaskScheduler().scheduleWithRepetition(this.antiEntropyTask, 0L, 30L, TimeUnit.SECONDS);
  }
  
  public void reset() {
    for (int i = 0; i < this.nodeEngine.getPartitionService().getPartitionCount(); i++) {
      ConcurrentMap<String, ReplicatedRecordStore> stores = this.partitionContainers[i].getStores();
      for (ReplicatedRecordStore store : stores.values())
        store.reset(); 
    } 
  }
  
  public void shutdown(boolean terminate) {
    for (PartitionContainer container : this.partitionContainers) {
      if (container != null)
        container.shutdown(); 
    } 
    if (this.antiEntropyFuture != null)
      this.antiEntropyFuture.cancel(true); 
  }
  
  public LocalReplicatedMapStatsImpl getLocalMapStatsImpl(String name) { return (LocalReplicatedMapStatsImpl)ConcurrencyUtil.getOrPutIfAbsent(this.statsMap, name, this.statsConstructorFunction); }
  
  public LocalReplicatedMapStatsImpl createReplicatedMapStats(String name) {
    LocalReplicatedMapStatsImpl stats = getLocalMapStatsImpl(name);
    long hits = 0L;
    long count = 0L;
    long memoryUsage = 0L;
    boolean isBinary = (getReplicatedMapConfig(name).getInMemoryFormat() == InMemoryFormat.BINARY);
    for (PartitionContainer container : this.partitionContainers) {
      ReplicatedRecordStore store = container.getRecordStore(name);
      if (store != null) {
        Iterator<ReplicatedRecord> iterator = store.recordIterator();
        while (iterator.hasNext()) {
          ReplicatedRecord record = (ReplicatedRecord)iterator.next();
          stats.setLastAccessTime(Math.max(stats.getLastAccessTime(), record.getLastAccessTime()));
          stats.setLastUpdateTime(Math.max(stats.getLastUpdateTime(), record.getUpdateTime()));
          hits += record.getHits();
          if (isBinary)
            memoryUsage += ((HeapData)record.getValueInternal()).getHeapCost(); 
          count++;
        } 
      } 
    } 
    stats.setOwnedEntryCount(count);
    stats.setHits(hits);
    stats.setOwnedEntryMemoryCost(memoryUsage);
    return stats;
  }
  
  public DistributedObject createDistributedObject(String objectName) {
    ReplicatedMapConfig replicatedMapConfig = getReplicatedMapConfig(objectName);
    ConfigValidator.checkReplicatedMapConfig(replicatedMapConfig, this.mergePolicyProvider);
    if (this.nodeEngine.getLocalMember().isLiteMember())
      throw new ReplicatedMapCantBeCreatedOnLiteMemberException(this.nodeEngine.getThisAddress()); 
    for (int i = 0; i < this.nodeEngine.getPartitionService().getPartitionCount(); i++) {
      PartitionContainer partitionContainer = this.partitionContainers[i];
      if (partitionContainer != null)
        partitionContainer.getOrCreateRecordStore(objectName); 
    } 
    return new ReplicatedMapProxy(this.nodeEngine, objectName, this, replicatedMapConfig);
  }
  
  public void destroyDistributedObject(String objectName) {
    if (this.nodeEngine.getLocalMember().isLiteMember())
      return; 
    for (int i = 0; i < this.nodeEngine.getPartitionService().getPartitionCount(); i++)
      this.partitionContainers[i].destroy(objectName); 
    this.quorumConfigCache.remove(objectName);
  }
  
  public void dispatchEvent(Object event, Object listener) { this.eventPublishingService.dispatchEvent(event, listener); }
  
  public ReplicatedMapConfig getReplicatedMapConfig(String name) { return this.config.findReplicatedMapConfig(name); }
  
  public ReplicatedRecordStore getReplicatedRecordStore(String name, boolean create, Object key) { return getReplicatedRecordStore(name, create, this.partitionService.getPartitionId(key)); }
  
  public ReplicatedRecordStore getReplicatedRecordStore(String name, boolean create, int partitionId) {
    if (this.nodeEngine.getLocalMember().isLiteMember())
      throw new ReplicatedMapCantBeCreatedOnLiteMemberException(this.nodeEngine.getThisAddress()); 
    PartitionContainer partitionContainer = this.partitionContainers[partitionId];
    if (create)
      return partitionContainer.getOrCreateRecordStore(name); 
    return partitionContainer.getRecordStore(name);
  }
  
  public Collection<ReplicatedRecordStore> getAllReplicatedRecordStores(String name) {
    int partitionCount = this.nodeEngine.getPartitionService().getPartitionCount();
    ArrayList<ReplicatedRecordStore> stores = new ArrayList<ReplicatedRecordStore>(partitionCount);
    for (int i = 0; i < partitionCount; i++) {
      PartitionContainer partitionContainer = this.partitionContainers[i];
      if (partitionContainer != null) {
        ReplicatedRecordStore recordStore = partitionContainer.getRecordStore(name);
        if (recordStore != null)
          stores.add(recordStore); 
      } 
    } 
    return stores;
  }
  
  private Collection<Address> getMemberAddresses(MemberSelector memberSelector) {
    Collection<Member> members = this.clusterService.getMembers(memberSelector);
    Collection<Address> addresses = new ArrayList<Address>(members.size());
    for (Member member : members)
      addresses.add(member.getAddress()); 
    return addresses;
  }
  
  public void initializeListeners(String name) {
    List<ListenerConfig> listenerConfigs = getReplicatedMapConfig(name).getListenerConfigs();
    for (ListenerConfig listenerConfig : listenerConfigs) {
      EntryListener listener = null;
      if (listenerConfig.getImplementation() != null) {
        listener = (EntryListener)listenerConfig.getImplementation();
      } else if (listenerConfig.getClassName() != null) {
        try {
          listener = (EntryListener)ClassLoaderUtil.newInstance(this.nodeEngine.getConfigClassLoader(), listenerConfig
              .getClassName());
        } catch (Exception e) {
          throw ExceptionUtil.rethrow(e);
        } 
      } 
      if (listener != null) {
        if (listener instanceof HazelcastInstanceAware)
          ((HazelcastInstanceAware)listener).setHazelcastInstance(this.nodeEngine.getHazelcastInstance()); 
        this.eventPublishingService.addEventListener(listener, TrueEventFilter.INSTANCE, name);
      } 
    } 
  }
  
  public PartitionContainer getPartitionContainer(int partitionId) { return this.partitionContainers[partitionId]; }
  
  public NodeEngine getNodeEngine() { return this.nodeEngine; }
  
  public ReplicatedMapEventPublishingService getEventPublishingService() { return this.eventPublishingService; }
  
  public Operation prepareReplicationOperation(PartitionReplicationEvent event) {
    if (this.nodeEngine.getLocalMember().isLiteMember())
      return null; 
    if (event.getReplicaIndex() > 0)
      return null; 
    PartitionContainer container = this.partitionContainers[event.getPartitionId()];
    SerializationService serializationService = this.nodeEngine.getSerializationService();
    ReplicationOperation operation = new ReplicationOperation(serializationService, container, event.getPartitionId());
    operation.setService(this);
    return operation.isEmpty() ? null : operation;
  }
  
  public void beforeMigration(PartitionMigrationEvent event) {}
  
  public void commitMigration(PartitionMigrationEvent event) {}
  
  public void rollbackMigration(PartitionMigrationEvent event) {}
  
  public Runnable prepareMergeRunnable() { return this.splitBrainHandlerService.prepareMergeRunnable(); }
  
  public Map<String, LocalReplicatedMapStats> getStats() {
    Collection<String> maps = getNodeEngine().getProxyService().getDistributedObjectNames("hz:impl:replicatedMapService");
    Map<String, LocalReplicatedMapStats> mapStats = new HashMap<String, LocalReplicatedMapStats>(maps.size());
    for (String map : maps)
      mapStats.put(map, createReplicatedMapStats(map)); 
    return mapStats;
  }
  
  public String getQuorumName(String name) {
    Object quorumName = ConcurrencyUtil.getOrPutSynchronized(this.quorumConfigCache, name, this.quorumConfigCacheMutexFactory, this.quorumConfigConstructor);
    return (quorumName == NULL_OBJECT) ? null : (String)quorumName;
  }
  
  public void ensureQuorumPresent(String distributedObjectName, QuorumType requiredQuorumPermissionType) { this.quorumService.ensureQuorumPresent(getQuorumName(distributedObjectName), requiredQuorumPermissionType); }
  
  public void triggerAntiEntropy() { this.antiEntropyTask.triggerAntiEntropy(); }
  
  public Object getMergePolicy(String name) {
    MergePolicyConfig mergePolicyConfig = getReplicatedMapConfig(name).getMergePolicyConfig();
    return this.mergePolicyProvider.getMergePolicy(mergePolicyConfig.getPolicy());
  }
}
