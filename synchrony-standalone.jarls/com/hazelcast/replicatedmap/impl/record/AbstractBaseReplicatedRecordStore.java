package com.hazelcast.replicatedmap.impl.record;

import com.hazelcast.config.ReplicatedMapConfig;
import com.hazelcast.monitor.impl.LocalReplicatedMapStatsImpl;
import com.hazelcast.replicatedmap.impl.ReplicatedMapEvictionProcessor;
import com.hazelcast.replicatedmap.impl.ReplicatedMapService;
import com.hazelcast.spi.EventService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.scheduler.EntryTaskScheduler;
import com.hazelcast.util.scheduler.EntryTaskSchedulerFactory;
import com.hazelcast.util.scheduler.ScheduleType;
import com.hazelcast.util.scheduler.ScheduledEntry;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

public abstract class AbstractBaseReplicatedRecordStore<K, V> extends Object implements ReplicatedRecordStore {
  protected int partitionId;
  
  protected final String name;
  
  protected final NodeEngine nodeEngine;
  
  protected final EventService eventService;
  
  protected final IPartitionService partitionService;
  
  protected final ReplicatedMapConfig replicatedMapConfig;
  
  protected final SerializationService serializationService;
  
  protected final ReplicatedMapService replicatedMapService;
  
  protected final AtomicReference<InternalReplicatedMapStorage<K, V>> storageRef;
  
  protected final AtomicBoolean isLoaded;
  
  private final EntryTaskScheduler<Object, Object> ttlEvictionScheduler;
  
  protected AbstractBaseReplicatedRecordStore(String name, ReplicatedMapService replicatedMapService, int partitionId) {
    this.isLoaded = new AtomicBoolean(false);
    this.name = name;
    this.partitionId = partitionId;
    this.nodeEngine = replicatedMapService.getNodeEngine();
    this.serializationService = this.nodeEngine.getSerializationService();
    this.partitionService = this.nodeEngine.getPartitionService();
    this.eventService = this.nodeEngine.getEventService();
    this.replicatedMapService = replicatedMapService;
    this.replicatedMapConfig = replicatedMapService.getReplicatedMapConfig(name);
    this.storageRef = new AtomicReference();
    this.storageRef.set(new InternalReplicatedMapStorage());
    this
      .ttlEvictionScheduler = EntryTaskSchedulerFactory.newScheduler(this.nodeEngine.getExecutionService().getGlobalTaskScheduler(), new ReplicatedMapEvictionProcessor(this, this.nodeEngine, partitionId), ScheduleType.POSTPONE);
  }
  
  public InternalReplicatedMapStorage<K, V> getStorage() { return (InternalReplicatedMapStorage)this.storageRef.get(); }
  
  public AtomicReference<InternalReplicatedMapStorage<K, V>> getStorageRef() { return this.storageRef; }
  
  public EntryTaskScheduler getTtlEvictionScheduler() { return this.ttlEvictionScheduler; }
  
  public int getPartitionId() { return this.partitionId; }
  
  public String getName() { return this.name; }
  
  public LocalReplicatedMapStatsImpl getStats() { return this.replicatedMapService.getLocalMapStatsImpl(this.name); }
  
  public void destroy() {
    InternalReplicatedMapStorage storage = (InternalReplicatedMapStorage)this.storageRef.getAndSet(new InternalReplicatedMapStorage());
    if (storage != null)
      storage.clear(); 
    this.ttlEvictionScheduler.cancelAll();
  }
  
  protected InternalReplicatedMapStorage<K, V> clearInternal() {
    InternalReplicatedMapStorage<K, V> storage = getStorage();
    storage.clear();
    getStats().incrementOtherOperations();
    this.ttlEvictionScheduler.cancelAll();
    return storage;
  }
  
  public long getVersion() { return ((InternalReplicatedMapStorage)this.storageRef.get()).getVersion(); }
  
  public boolean isStale(long version) { return ((InternalReplicatedMapStorage)this.storageRef.get()).isStale(version); }
  
  public Set<ReplicatedRecord> getRecords() { return new HashSet(((InternalReplicatedMapStorage)this.storageRef.get()).values()); }
  
  public ScheduledEntry<Object, Object> cancelTtlEntry(Object key) { return this.ttlEvictionScheduler.cancel(key); }
  
  public boolean scheduleTtlEntry(long delayMillis, Object key, Object value) { return this.ttlEvictionScheduler.schedule(delayMillis, key, value); }
  
  public boolean isLoaded() { return this.isLoaded.get(); }
  
  public void setLoaded(boolean loaded) { this.isLoaded.set(loaded); }
  
  public boolean equals(Object o) {
    if (this == o)
      return true; 
    if (o == null || getClass() != o.getClass())
      return false; 
    AbstractBaseReplicatedRecordStore that = (AbstractBaseReplicatedRecordStore)o;
    if ((this.name != null) ? !this.name.equals(that.name) : (that.name != null))
      return false; 
    if (!((InternalReplicatedMapStorage)this.storageRef.get()).equals(that.storageRef.get()))
      return false; 
    return true;
  }
  
  public int hashCode() {
    result = ((InternalReplicatedMapStorage)this.storageRef.get()).hashCode();
    return 31 * result + ((this.name != null) ? this.name.hashCode() : 0);
  }
}
