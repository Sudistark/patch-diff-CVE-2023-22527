package com.hazelcast.replicatedmap.impl.record;

import com.hazelcast.cluster.memberselector.MemberSelectors;
import com.hazelcast.core.EntryEventType;
import com.hazelcast.core.Member;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.replicatedmap.impl.ReplicatedMapEventPublishingService;
import com.hazelcast.replicatedmap.impl.ReplicatedMapService;
import com.hazelcast.replicatedmap.impl.operation.ReplicateUpdateOperation;
import com.hazelcast.replicatedmap.impl.operation.VersionResponsePair;
import com.hazelcast.replicatedmap.merge.ReplicatedMapMergePolicy;
import com.hazelcast.spi.OperationService;
import com.hazelcast.spi.impl.merge.MergingValueFactory;
import com.hazelcast.spi.merge.SplitBrainMergePolicy;
import com.hazelcast.spi.merge.SplitBrainMergeTypes;
import com.hazelcast.util.Clock;
import com.hazelcast.util.Preconditions;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

public abstract class AbstractReplicatedRecordStore<K, V> extends AbstractBaseReplicatedRecordStore<K, V> {
  public AbstractReplicatedRecordStore(String name, ReplicatedMapService replicatedMapService, int partitionId) { super(name, replicatedMapService, partitionId); }
  
  public Object remove(Object key) {
    InternalReplicatedMapStorage<K, V> storage = getStorage();
    Object old = remove(storage, key);
    storage.incrementVersion();
    return old;
  }
  
  public Object removeWithVersion(Object key, long version) {
    InternalReplicatedMapStorage<K, V> storage = getStorage();
    Object old = remove(storage, key);
    storage.setVersion(version);
    return old;
  }
  
  private Object remove(InternalReplicatedMapStorage<K, V> storage, Object key) {
    V oldValue;
    Preconditions.isNotNull(key, "key");
    long time = Clock.currentTimeMillis();
    K marshalledKey = (K)marshall(key);
    ReplicatedRecord current = storage.get(marshalledKey);
    if (current == null) {
      oldValue = null;
    } else {
      oldValue = (V)current.getValueInternal();
      storage.remove(marshalledKey, current);
    } 
    if (this.replicatedMapConfig.isStatisticsEnabled())
      getStats().incrementRemoves(Clock.currentTimeMillis() - time); 
    cancelTtlEntry(marshalledKey);
    return oldValue;
  }
  
  public void evict(Object key) {
    V oldValue;
    Preconditions.isNotNull(key, "key");
    long time = Clock.currentTimeMillis();
    K marshalledKey = (K)marshall(key);
    InternalReplicatedMapStorage<K, V> storage = getStorage();
    ReplicatedRecord current = storage.get(marshalledKey);
    if (current == null) {
      oldValue = null;
    } else {
      oldValue = (V)current.getValueInternal();
      storage.remove(marshalledKey, current);
    } 
    Data dataKey = this.nodeEngine.toData(key);
    Data dataOldValue = this.nodeEngine.toData(oldValue);
    ReplicatedMapEventPublishingService eventPublishingService = this.replicatedMapService.getEventPublishingService();
    eventPublishingService.fireEntryListenerEvent(dataKey, dataOldValue, null, EntryEventType.EVICTED, this.name, this.nodeEngine.getThisAddress());
    if (this.replicatedMapConfig.isStatisticsEnabled())
      getStats().incrementRemoves(Clock.currentTimeMillis() - time); 
  }
  
  public Object get(Object key) {
    Preconditions.isNotNull(key, "key");
    long time = Clock.currentTimeMillis();
    ReplicatedRecord replicatedRecord = getStorage().get(marshall(key));
    long ttlMillis = (replicatedRecord == null) ? 0L : replicatedRecord.getTtlMillis();
    if (ttlMillis > 0L && Clock.currentTimeMillis() - replicatedRecord.getUpdateTime() >= ttlMillis)
      replicatedRecord = null; 
    Object value = (replicatedRecord == null) ? null : unmarshall(replicatedRecord.getValue());
    if (this.replicatedMapConfig.isStatisticsEnabled())
      getStats().incrementGets(Clock.currentTimeMillis() - time); 
    return value;
  }
  
  public Object put(Object key, Object value) {
    Preconditions.isNotNull(key, "key");
    Preconditions.isNotNull(value, "value");
    return put(key, value, 0L, TimeUnit.MILLISECONDS, true);
  }
  
  public Object put(Object key, Object value, long ttl, TimeUnit timeUnit, boolean incrementHits) {
    InternalReplicatedMapStorage<K, V> storage = getStorage();
    Object old = put(storage, key, value, ttl, timeUnit, incrementHits);
    storage.incrementVersion();
    return old;
  }
  
  public Object putWithVersion(Object key, Object value, long ttl, TimeUnit timeUnit, boolean incrementHits, long version) {
    InternalReplicatedMapStorage<K, V> storage = getStorage();
    Object old = put(storage, key, value, ttl, timeUnit, incrementHits);
    storage.setVersion(version);
    return old;
  }
  
  private Object put(InternalReplicatedMapStorage<K, V> storage, Object key, Object value, long ttl, TimeUnit timeUnit, boolean incrementHits) {
    Preconditions.isNotNull(key, "key");
    Preconditions.isNotNull(value, "value");
    Preconditions.isNotNull(timeUnit, "timeUnit");
    if (ttl < 0L)
      throw new IllegalArgumentException("ttl must be a positive integer"); 
    long time = Clock.currentTimeMillis();
    V oldValue = null;
    K marshalledKey = (K)marshall(key);
    V marshalledValue = (V)marshall(value);
    long ttlMillis = (ttl == 0L) ? 0L : timeUnit.toMillis(ttl);
    ReplicatedRecord<K, V> old = storage.get(marshalledKey);
    if (old == null) {
      ReplicatedRecord<K, V> record = buildReplicatedRecord(marshalledKey, marshalledValue, ttlMillis);
      storage.put(marshalledKey, record);
    } else {
      oldValue = (V)old.getValueInternal();
      if (incrementHits) {
        old.setValue(marshalledValue, ttlMillis);
      } else {
        old.setValueInternal(marshalledValue, ttlMillis);
      } 
      storage.put(marshalledKey, old);
    } 
    if (ttlMillis > 0L) {
      scheduleTtlEntry(ttlMillis, marshalledKey, marshalledValue);
    } else {
      cancelTtlEntry(marshalledKey);
    } 
    if (this.replicatedMapConfig.isStatisticsEnabled())
      getStats().incrementPuts(Clock.currentTimeMillis() - time); 
    return oldValue;
  }
  
  public boolean containsKey(Object key) {
    Preconditions.isNotNull(key, "key");
    getStats().incrementOtherOperations();
    return containsKeyAndValue(key);
  }
  
  private boolean containsKeyAndValue(Object key) {
    ReplicatedRecord replicatedRecord = getStorage().get(marshall(key));
    return (replicatedRecord != null && replicatedRecord.getValue() != null);
  }
  
  public boolean containsValue(Object value) {
    Preconditions.isNotNull(value, "value");
    getStats().incrementOtherOperations();
    Object v = unmarshall(value);
    for (Map.Entry<K, ReplicatedRecord<K, V>> entry : getStorage().entrySet()) {
      V entryValue = (V)((ReplicatedRecord)entry.getValue()).getValue();
      if (v == entryValue || (entryValue != null && unmarshall(entryValue).equals(v)))
        return true; 
    } 
    return false;
  }
  
  public Set keySet(boolean lazy) {
    getStats().incrementOtherOperations();
    if (lazy)
      return new LazySet(new KeySetIteratorFactory(this), getStorage()); 
    return getStorage().keySet();
  }
  
  public Collection values(boolean lazy) {
    getStats().incrementOtherOperations();
    if (lazy)
      return new LazyCollection(new ValuesIteratorFactory(this), getStorage()); 
    return getStorage().values();
  }
  
  public Collection values(Comparator comparator) {
    InternalReplicatedMapStorage<K, V> storage = getStorage();
    List<Object> values = new ArrayList<Object>(storage.size());
    for (ReplicatedRecord record : storage.values())
      values.add(unmarshall(record.getValue())); 
    getStats().incrementOtherOperations();
    return values;
  }
  
  public Set entrySet(boolean lazy) {
    getStats().incrementOtherOperations();
    if (lazy)
      return new LazySet(new EntrySetIteratorFactory(this), getStorage()); 
    return getStorage().entrySet();
  }
  
  public ReplicatedRecord getReplicatedRecord(Object key) {
    Preconditions.isNotNull(key, "key");
    return getStorage().get(marshall(key));
  }
  
  public boolean isEmpty() {
    getStats().incrementOtherOperations();
    return getStorage().isEmpty();
  }
  
  public int size() {
    getStats().incrementOtherOperations();
    return getStorage().size();
  }
  
  public void clear() { clearInternal().incrementVersion(); }
  
  public void clearWithVersion(long version) { clearInternal().setVersion(version); }
  
  public void reset() { destroy(); }
  
  public Iterator recordIterator() { return new RecordIterator(this, getStorage().entrySet().iterator(), null); }
  
  public void putRecords(Collection<RecordMigrationInfo> records, long version) {
    InternalReplicatedMapStorage<K, V> storage = getStorage();
    for (RecordMigrationInfo record : records)
      putRecord(storage, record); 
    storage.syncVersion(version);
  }
  
  private void putRecord(InternalReplicatedMapStorage<K, V> storage, RecordMigrationInfo record) {
    K key = (K)marshall(record.getKey());
    V value = (V)marshall(record.getValue());
    ReplicatedRecord newRecord = buildReplicatedRecord(key, value, record.getTtl());
    newRecord.setHits(record.getHits());
    newRecord.setCreationTime(record.getCreationTime());
    newRecord.setLastAccessTime(record.getLastAccessTime());
    newRecord.setUpdateTime(record.getLastUpdateTime());
    storage.put(key, newRecord);
    if (record.getTtl() > 0L)
      scheduleTtlEntry(record.getTtl(), key, value); 
  }
  
  private ReplicatedRecord<K, V> buildReplicatedRecord(K key, V value, long ttlMillis) { return new ReplicatedRecord(key, value, ttlMillis); }
  
  public boolean merge(SplitBrainMergeTypes.ReplicatedMapMergeTypes mergingEntry, SplitBrainMergePolicy<Object, SplitBrainMergeTypes.ReplicatedMapMergeTypes> mergePolicy) {
    this.serializationService.getManagedContext().initialize(mergingEntry);
    this.serializationService.getManagedContext().initialize(mergePolicy);
    K marshalledKey = (K)marshall(mergingEntry.getKey());
    InternalReplicatedMapStorage<K, V> storage = getStorage();
    ReplicatedRecord<K, V> record = storage.get(marshalledKey);
    if (record == null) {
      V newValue = (V)mergePolicy.merge(mergingEntry, null);
      if (newValue == null)
        return false; 
      record = buildReplicatedRecord(marshalledKey, newValue, 0L);
      storage.put(marshalledKey, record);
      storage.incrementVersion();
      Data dataKey = this.serializationService.toData(marshalledKey);
      Data dataValue = this.serializationService.toData(newValue);
      VersionResponsePair responsePair = new VersionResponsePair(mergingEntry.getValue(), getVersion());
      sendReplicationOperation(false, this.name, dataKey, dataValue, record.getTtlMillis(), responsePair);
    } else {
      SplitBrainMergeTypes.ReplicatedMapMergeTypes existingEntry = MergingValueFactory.createMergingEntry(this.serializationService, record);
      V newValue = (V)mergePolicy.merge(mergingEntry, existingEntry);
      if (newValue == null) {
        storage.remove(marshalledKey, record);
        storage.incrementVersion();
        Data dataKey = this.serializationService.toData(marshalledKey);
        VersionResponsePair responsePair = new VersionResponsePair(mergingEntry.getValue(), getVersion());
        sendReplicationOperation(true, this.name, dataKey, null, record.getTtlMillis(), responsePair);
        return false;
      } 
      record.setValueInternal(newValue, record.getTtlMillis());
      storage.incrementVersion();
      Data dataKey = this.serializationService.toData(marshalledKey);
      Data dataValue = this.serializationService.toData(newValue);
      VersionResponsePair responsePair = new VersionResponsePair(mergingEntry.getValue(), getVersion());
      sendReplicationOperation(false, this.name, dataKey, dataValue, record.getTtlMillis(), responsePair);
    } 
    return true;
  }
  
  public boolean merge(Object key, ReplicatedMapEntryView mergingEntry, ReplicatedMapMergePolicy mergePolicy) {
    K marshalledKey = (K)marshall(key);
    InternalReplicatedMapStorage<K, V> storage = getStorage();
    ReplicatedRecord<K, V> existingRecord = storage.get(marshalledKey);
    if (existingRecord == null) {
      ReplicatedMapEntryView nullEntryView = (new ReplicatedMapEntryView(this.serializationService)).setKey(key);
      V newValue = (V)mergePolicy.merge(this.name, mergingEntry, nullEntryView);
      if (newValue == null)
        return false; 
      existingRecord = buildReplicatedRecord(marshalledKey, newValue, 0L);
      storage.put(marshalledKey, existingRecord);
      storage.incrementVersion();
      Data dataKey = this.serializationService.toData(marshalledKey);
      Data dataValue = this.serializationService.toData(newValue);
      VersionResponsePair responsePair = new VersionResponsePair(mergingEntry.getValue(), getVersion());
      sendReplicationOperation(false, this.name, dataKey, dataValue, existingRecord.getTtlMillis(), responsePair);
    } else {
      ReplicatedMapEntryView existingEntry = (new ReplicatedMapEntryView(this.serializationService)).setKey(key).setValue(existingRecord.getValueInternal()).setCreationTime(existingRecord.getCreationTime()).setLastUpdateTime(existingRecord.getUpdateTime()).setLastAccessTime(existingRecord.getLastAccessTime()).setHits(existingRecord.getHits()).setTtl(existingRecord.getTtlMillis());
      V newValue = (V)mergePolicy.merge(this.name, mergingEntry, existingEntry);
      if (newValue == null) {
        storage.remove(marshalledKey, existingRecord);
        storage.incrementVersion();
        Data dataKey = this.serializationService.toData(marshalledKey);
        VersionResponsePair responsePair = new VersionResponsePair(mergingEntry.getValue(), getVersion());
        sendReplicationOperation(true, this.name, dataKey, null, existingRecord.getTtlMillis(), responsePair);
        return false;
      } 
      existingRecord.setValueInternal(newValue, existingRecord.getTtlMillis());
      storage.incrementVersion();
      Data dataKey = this.serializationService.toData(marshalledKey);
      Data dataValue = this.serializationService.toData(newValue);
      VersionResponsePair responsePair = new VersionResponsePair(mergingEntry.getValue(), getVersion());
      sendReplicationOperation(false, this.name, dataKey, dataValue, existingRecord.getTtlMillis(), responsePair);
    } 
    return true;
  }
  
  private void sendReplicationOperation(boolean isRemove, String name, Data key, Data value, long ttl, VersionResponsePair response) {
    Collection<Member> members = this.nodeEngine.getClusterService().getMembers(MemberSelectors.DATA_MEMBER_SELECTOR);
    for (Member member : members)
      invoke(isRemove, member.getAddress(), name, key, value, ttl, response); 
  }
  
  private void invoke(boolean isRemove, Address address, String name, Data key, Data value, long ttl, VersionResponsePair response) {
    OperationService operationService = this.nodeEngine.getOperationService();
    ReplicateUpdateOperation updateOperation = new ReplicateUpdateOperation(name, key, value, ttl, response, isRemove, this.nodeEngine.getThisAddress());
    updateOperation.setPartitionId(this.partitionId);
    updateOperation.setValidateTarget(false);
    operationService.invokeOnTarget("hz:impl:replicatedMapService", updateOperation, address);
  }
}
