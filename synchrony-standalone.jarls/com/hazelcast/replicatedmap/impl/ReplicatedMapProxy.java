package com.hazelcast.replicatedmap.impl;

import com.hazelcast.config.ReplicatedMapConfig;
import com.hazelcast.core.EntryListener;
import com.hazelcast.core.ReplicatedMap;
import com.hazelcast.internal.partition.impl.InternalPartitionServiceImpl;
import com.hazelcast.internal.util.ResultSet;
import com.hazelcast.monitor.LocalReplicatedMapStats;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.query.Predicate;
import com.hazelcast.quorum.QuorumType;
import com.hazelcast.replicatedmap.impl.client.ReplicatedMapEntries;
import com.hazelcast.replicatedmap.impl.operation.ClearOperationFactory;
import com.hazelcast.replicatedmap.impl.operation.PutAllOperation;
import com.hazelcast.replicatedmap.impl.operation.PutOperation;
import com.hazelcast.replicatedmap.impl.operation.RemoveOperation;
import com.hazelcast.replicatedmap.impl.operation.RequestMapDataOperation;
import com.hazelcast.replicatedmap.impl.operation.VersionResponsePair;
import com.hazelcast.replicatedmap.impl.record.ReplicatedEntryEventFilter;
import com.hazelcast.replicatedmap.impl.record.ReplicatedQueryEventFilter;
import com.hazelcast.replicatedmap.impl.record.ReplicatedRecordStore;
import com.hazelcast.spi.AbstractDistributedObject;
import com.hazelcast.spi.InitializingObject;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.OperationService;
import com.hazelcast.spi.impl.eventservice.impl.TrueEventFilter;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.IterationType;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.SetUtil;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class ReplicatedMapProxy<K, V> extends AbstractDistributedObject<ReplicatedMapService> implements ReplicatedMap<K, V>, InitializingObject {
  private static final int WAIT_INTERVAL_MILLIS = 1000;
  
  private static final int RETRY_INTERVAL_COUNT = 3;
  
  private static final int KEY_SET_MIN_SIZE = 16;
  
  private static final int KEY_SET_STORE_MULTIPLE = 4;
  
  private final String name;
  
  private final NodeEngine nodeEngine;
  
  private final ReplicatedMapService service;
  
  private final ReplicatedMapEventPublishingService eventPublishingService;
  
  private final SerializationService serializationService;
  
  private final InternalPartitionServiceImpl partitionService;
  
  private final ReplicatedMapConfig config;
  
  private int retryCount;
  
  ReplicatedMapProxy(NodeEngine nodeEngine, String name, ReplicatedMapService service, ReplicatedMapConfig config) {
    super(nodeEngine, service);
    this.name = name;
    this.nodeEngine = nodeEngine;
    this.service = service;
    this.eventPublishingService = service.getEventPublishingService();
    this.serializationService = nodeEngine.getSerializationService();
    this.partitionService = (InternalPartitionServiceImpl)nodeEngine.getPartitionService();
    this.config = config;
  }
  
  public void initialize() {
    this.service.initializeListeners(this.name);
    if (this.nodeEngine.getClusterService().getSize() == 1)
      return; 
    fireMapDataLoadingTasks();
    if (!this.config.isAsyncFillup())
      for (int i = 0; i < this.nodeEngine.getPartitionService().getPartitionCount(); i++) {
        ReplicatedRecordStore store = this.service.getReplicatedRecordStore(this.name, false, i);
        while (store == null || !store.isLoaded()) {
          if (this.retryCount++ % 3 == 0)
            requestDataForPartition(i); 
          sleep();
          if (store == null)
            store = this.service.getReplicatedRecordStore(this.name, false, i); 
        } 
      }  
  }
  
  private void sleep() {
    try {
      TimeUnit.MILLISECONDS.sleep(1000L);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw ExceptionUtil.rethrow(e);
    } 
  }
  
  private void fireMapDataLoadingTasks() {
    for (int i = 0; i < this.nodeEngine.getPartitionService().getPartitionCount(); i++)
      requestDataForPartition(i); 
  }
  
  private void requestDataForPartition(int partitionId) {
    RequestMapDataOperation requestMapDataOperation = new RequestMapDataOperation(this.name);
    OperationService operationService = this.nodeEngine.getOperationService();
    operationService
      .createInvocationBuilder("hz:impl:replicatedMapService", requestMapDataOperation, partitionId)
      .setTryCount(3)
      .invoke();
  }
  
  protected boolean preDestroy() {
    if (super.preDestroy()) {
      this.eventPublishingService.fireMapClearedEvent(size(), this.name);
      return true;
    } 
    return false;
  }
  
  public String getName() { return this.name; }
  
  public String getPartitionKey() { return getName(); }
  
  public String getServiceName() { return "hz:impl:replicatedMapService"; }
  
  public int size() {
    ensureQuorumPresent(QuorumType.READ);
    Collection<ReplicatedRecordStore> stores = this.service.getAllReplicatedRecordStores(getName());
    int size = 0;
    for (ReplicatedRecordStore store : stores)
      size += store.size(); 
    return size;
  }
  
  public boolean isEmpty() {
    ensureQuorumPresent(QuorumType.READ);
    Collection<ReplicatedRecordStore> stores = this.service.getAllReplicatedRecordStores(getName());
    for (ReplicatedRecordStore store : stores) {
      if (!store.isEmpty())
        return false; 
    } 
    return true;
  }
  
  public boolean containsKey(Object key) {
    ensureQuorumPresent(QuorumType.READ);
    Preconditions.isNotNull(key, "key");
    int partitionId = this.partitionService.getPartitionId(key);
    ReplicatedRecordStore store = this.service.getReplicatedRecordStore(this.name, false, partitionId);
    return (store != null && store.containsKey(key));
  }
  
  public boolean containsValue(Object value) {
    ensureQuorumPresent(QuorumType.READ);
    Preconditions.isNotNull(value, "value");
    Collection<ReplicatedRecordStore> stores = this.service.getAllReplicatedRecordStores(getName());
    for (ReplicatedRecordStore store : stores) {
      if (store.containsValue(value))
        return true; 
    } 
    return false;
  }
  
  public V get(Object key) {
    ensureQuorumPresent(QuorumType.READ);
    Preconditions.isNotNull(key, "key");
    int partitionId = this.partitionService.getPartitionId(key);
    ReplicatedRecordStore store = this.service.getReplicatedRecordStore(getName(), false, partitionId);
    if (store == null)
      return null; 
    return (V)store.get(key);
  }
  
  public V put(K key, V value) {
    Preconditions.isNotNull(key, "key");
    Preconditions.isNotNull(value, "value");
    Data dataKey = this.nodeEngine.toData(key);
    Data dataValue = this.nodeEngine.toData(value);
    int partitionId = this.nodeEngine.getPartitionService().getPartitionId(dataKey);
    PutOperation putOperation = new PutOperation(getName(), dataKey, dataValue);
    InternalCompletableFuture<Object> future = getOperationService().invokeOnPartition(getServiceName(), putOperation, partitionId);
    VersionResponsePair result = (VersionResponsePair)future.join();
    return (V)this.nodeEngine.toObject(result.getResponse());
  }
  
  public V put(K key, V value, long ttl, TimeUnit timeUnit) {
    Preconditions.isNotNull(key, "key");
    Preconditions.isNotNull(value, "value");
    Preconditions.isNotNull(timeUnit, "timeUnit");
    if (ttl < 0L)
      throw new IllegalArgumentException("ttl must be a positive integer"); 
    long ttlMillis = timeUnit.toMillis(ttl);
    Data dataKey = this.nodeEngine.toData(key);
    Data dataValue = this.nodeEngine.toData(value);
    int partitionId = this.partitionService.getPartitionId(dataKey);
    PutOperation putOperation = new PutOperation(getName(), dataKey, dataValue, ttlMillis);
    InternalCompletableFuture<Object> future = getOperationService().invokeOnPartition(getServiceName(), putOperation, partitionId);
    VersionResponsePair result = (VersionResponsePair)future.join();
    return (V)this.nodeEngine.toObject(result.getResponse());
  }
  
  public V remove(Object key) {
    Preconditions.isNotNull(key, "key");
    Data dataKey = this.nodeEngine.toData(key);
    int partitionId = this.partitionService.getPartitionId(key);
    RemoveOperation removeOperation = new RemoveOperation(getName(), dataKey);
    InternalCompletableFuture<Object> future = getOperationService().invokeOnPartition(getServiceName(), removeOperation, partitionId);
    VersionResponsePair result = (VersionResponsePair)future.join();
    return (V)this.nodeEngine.toObject(result.getResponse());
  }
  
  public void putAll(Map<? extends K, ? extends V> entries) {
    Preconditions.checkNotNull(entries, "entries cannot be null");
    int mapSize = entries.size();
    if (mapSize == 0)
      return; 
    int partitionCount = this.partitionService.getPartitionCount();
    int initialSize = getPutAllInitialSize(mapSize, partitionCount);
    try {
      List<Future> futures = new ArrayList<Future>(partitionCount);
      ReplicatedMapEntries[] entrySetPerPartition = new ReplicatedMapEntries[partitionCount];
      for (Map.Entry entry : entries.entrySet()) {
        Preconditions.isNotNull(entry.getKey(), "key");
        Preconditions.isNotNull(entry.getValue(), "value");
        int partitionId = this.partitionService.getPartitionId(entry.getKey());
        ReplicatedMapEntries mapEntries = entrySetPerPartition[partitionId];
        if (mapEntries == null) {
          mapEntries = new ReplicatedMapEntries(initialSize);
          entrySetPerPartition[partitionId] = mapEntries;
        } 
        Data keyData = this.serializationService.toData(entry.getKey());
        Data valueData = this.serializationService.toData(entry.getValue());
        mapEntries.add(keyData, valueData);
      } 
      for (int partitionId = 0; partitionId < partitionCount; partitionId++) {
        ReplicatedMapEntries entrySet = entrySetPerPartition[partitionId];
        if (entrySet != null) {
          Future future = createPutAllOperationFuture(this.name, entrySet, partitionId);
          futures.add(future);
        } 
      } 
      for (Future future : futures)
        future.get(); 
    } catch (Exception e) {
      throw ExceptionUtil.rethrow(e);
    } 
  }
  
  private int getPutAllInitialSize(int mapSize, int partitionCount) {
    if (mapSize == 1)
      return 1; 
    return (int)Math.ceil((20.0F * mapSize / partitionCount) / Math.log10(mapSize));
  }
  
  private Future createPutAllOperationFuture(String name, ReplicatedMapEntries entrySet, int partitionId) {
    OperationService operationService = this.nodeEngine.getOperationService();
    PutAllOperation putAllOperation = new PutAllOperation(name, entrySet);
    return operationService.invokeOnPartition("hz:impl:replicatedMapService", putAllOperation, partitionId);
  }
  
  public void clear() {
    OperationService operationService = this.nodeEngine.getOperationService();
    try {
      Map<Integer, Object> results = operationService.invokeOnAllPartitions("hz:impl:replicatedMapService", new ClearOperationFactory(this.name));
      int deletedEntrySize = 0;
      for (Object deletedEntryPerPartition : results.values())
        deletedEntrySize += ((Integer)deletedEntryPerPartition).intValue(); 
      this.eventPublishingService.fireMapClearedEvent(deletedEntrySize, this.name);
    } catch (Throwable t) {
      throw ExceptionUtil.rethrow(t);
    } 
  }
  
  public boolean removeEntryListener(String id) { return this.eventPublishingService.removeEventListener(this.name, id); }
  
  public String addEntryListener(EntryListener<K, V> listener) {
    Preconditions.isNotNull(listener, "listener");
    return this.eventPublishingService.addEventListener(listener, TrueEventFilter.INSTANCE, this.name);
  }
  
  public String addEntryListener(EntryListener<K, V> listener, K key) {
    Preconditions.isNotNull(listener, "listener");
    ReplicatedEntryEventFilter replicatedEntryEventFilter = new ReplicatedEntryEventFilter(this.serializationService.toData(key));
    return this.eventPublishingService.addEventListener(listener, replicatedEntryEventFilter, this.name);
  }
  
  public String addEntryListener(EntryListener<K, V> listener, Predicate<K, V> predicate) {
    Preconditions.isNotNull(listener, "listener");
    Preconditions.isNotNull(predicate, "predicate");
    ReplicatedQueryEventFilter replicatedQueryEventFilter = new ReplicatedQueryEventFilter(null, predicate);
    return this.eventPublishingService.addEventListener(listener, replicatedQueryEventFilter, this.name);
  }
  
  public String addEntryListener(EntryListener<K, V> listener, Predicate<K, V> predicate, K key) {
    Preconditions.isNotNull(listener, "listener");
    Preconditions.isNotNull(predicate, "predicate");
    ReplicatedQueryEventFilter replicatedQueryEventFilter = new ReplicatedQueryEventFilter(this.serializationService.toData(key), predicate);
    return this.eventPublishingService.addEventListener(listener, replicatedQueryEventFilter, this.name);
  }
  
  public Set<K> keySet() {
    ensureQuorumPresent(QuorumType.READ);
    Collection<ReplicatedRecordStore> stores = this.service.getAllReplicatedRecordStores(getName());
    Set<K> keySet = SetUtil.createHashSet(Math.max(16, stores.size() * 4));
    for (ReplicatedRecordStore store : stores)
      keySet.addAll(store.keySet(true)); 
    return keySet;
  }
  
  public Collection<V> values() {
    ensureQuorumPresent(QuorumType.READ);
    Collection<ReplicatedRecordStore> stores = this.service.getAllReplicatedRecordStores(getName());
    Collection<V> values = new ArrayList<V>();
    for (ReplicatedRecordStore store : stores)
      values.addAll(store.values(true)); 
    return values;
  }
  
  public Collection<V> values(Comparator<V> comparator) {
    ensureQuorumPresent(QuorumType.READ);
    Collection<ReplicatedRecordStore> stores = this.service.getAllReplicatedRecordStores(getName());
    List<V> values = new ArrayList<V>();
    for (ReplicatedRecordStore store : stores)
      values.addAll(store.values(comparator)); 
    Collections.sort(values, comparator);
    return values;
  }
  
  public Set<Map.Entry<K, V>> entrySet() {
    ensureQuorumPresent(QuorumType.READ);
    Collection<ReplicatedRecordStore> stores = this.service.getAllReplicatedRecordStores(getName());
    List<Map.Entry> entries = new ArrayList<Map.Entry>();
    for (ReplicatedRecordStore store : stores)
      entries.addAll(store.entrySet(true)); 
    return new ResultSet(entries, IterationType.ENTRY);
  }
  
  public int hashCode() {
    result = super.hashCode();
    return 31 * result + this.name.hashCode();
  }
  
  public String toString() { return getClass().getSimpleName() + " -> " + this.name; }
  
  public LocalReplicatedMapStats getReplicatedMapStats() { return this.service.createReplicatedMapStats(this.name); }
  
  private void ensureQuorumPresent(QuorumType requiredQuorumPermissionType) { this.service.ensureQuorumPresent(this.name, requiredQuorumPermissionType); }
}
