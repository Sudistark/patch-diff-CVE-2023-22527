package com.hazelcast.config.replacer;

import com.hazelcast.config.DomConfigHelper;
import com.hazelcast.nio.IOUtil;
import com.hazelcast.util.Base64;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.StringUtil;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.util.Enumeration;
import java.util.Properties;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathException;
import javax.xml.xpath.XPathFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class EncryptionReplacer extends AbstractPbeReplacer {
  public static final String PROPERTY_PASSWORD_USER_PROPERTIES = "passwordUserProperties";
  
  public static final String PROPERTY_PASSWORD_NETWORK_INTERFACE = "passwordNetworkInterface";
  
  public static final String PROPERTY_PASSWORD_FILE = "passwordFile";
  
  private static final String PREFIX = "ENC";
  
  private static final int DEFAULT_ITERATIONS = 531;
  
  private boolean passwordUserProperties;
  
  private String passwordNetworkInterface;
  
  private String passwordFile;
  
  public void init(Properties properties) {
    super.init(properties);
    this.passwordFile = properties.getProperty("passwordFile");
    this.passwordUserProperties = Boolean.parseBoolean(properties.getProperty("passwordUserProperties", "true"));
    this.passwordNetworkInterface = properties.getProperty("passwordNetworkInterface");
    Preconditions.checkFalse((this.passwordFile == null && this.passwordNetworkInterface == null && !this.passwordUserProperties), "At least one of the properties used to generate encryption password has to be configured");
  }
  
  public String getPrefix() { return "ENC"; }
  
  protected char[] getPassword() {
    try {
      ByteArrayOutputStream baos = new ByteArrayOutputStream();
      if (this.passwordFile != null) {
        fis = new FileInputStream(this.passwordFile);
        try {
          baos.write(IOUtil.toByteArray(fis));
        } finally {
          IOUtil.closeResource(fis);
        } 
      } 
      if (this.passwordUserProperties) {
        baos.write(System.getProperty("user.home").getBytes(StringUtil.UTF8_CHARSET));
        baos.write(System.getProperty("user.name").getBytes(StringUtil.UTF8_CHARSET));
      } 
      if (this.passwordNetworkInterface != null)
        try {
          NetworkInterface iface = NetworkInterface.getByName(this.passwordNetworkInterface);
          baos.write(iface.getHardwareAddress());
        } catch (SocketException e) {
          throw ExceptionUtil.rethrow(e);
        }  
      return (new String(Base64.encode(baos.toByteArray()), StringUtil.UTF8_CHARSET)).toCharArray();
    } catch (Exception e) {
      throw ExceptionUtil.rethrow(e);
    } 
  }
  
  public static final void main(String... args) throws Exception {
    if (args == null || args.length < 1 || args.length > 2) {
      System.err.println("Usage:");
      System.err.println("\tjava -D<propertyName>=<propertyValue>  " + EncryptionReplacer.class.getName() + " \"<String To Encrypt>\" [iterations]");
      System.err.println();
      System.err.println("The replacer configuration can be loaded either from hazelcast/hazelcast-client XML file:");
      System.err.println("\t-Dhazelcast.config=/path/to/hazelcast.xml");
      System.err.println();
      System.err.println("or provided directly via following property names:");
      System.err.println("\tcipherAlgorithm");
      System.err.println("\tkeyLengthBits");
      System.err.println("\tsaltLengthBytes");
      System.err.println("\tsecretKeyAlgorithm");
      System.err.println("\tsecretKeyFactoryAlgorithm");
      System.err.println("\tsecurityProvider");
      System.err.println("\tpasswordFile");
      System.err.println("\tpasswordNetworkInterface");
      System.err.println("\tpasswordUserProperties");
      System.err.println();
      System.err.println("Values available for property passwordNetworkInterface");
      Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
      while (networkInterfaces.hasMoreElements()) {
        NetworkInterface networkInterface = (NetworkInterface)networkInterfaces.nextElement();
        byte[] hardwareAddress = networkInterface.getHardwareAddress();
        if (hardwareAddress != null)
          System.err.println("\t" + networkInterface.getName()); 
      } 
      System.err.println();
      System.exit(1);
    } 
    System.out.println(encrypt(args));
  }
  
  protected static String encrypt(String... args) throws Exception {
    int iterations = (args.length == 2) ? Integer.parseInt(args[1]) : 531;
    EncryptionReplacer replacer = new EncryptionReplacer();
    String xmlPath = System.getProperty("hazelcast.config");
    Properties properties = (xmlPath == null) ? System.getProperties() : loadPropertiesFromConfig(new FileInputStream(xmlPath));
    replacer.init(properties);
    String encrypted = replacer.encrypt(args[0], iterations);
    return "$" + replacer.getPrefix() + "{" + encrypted + "}";
  }
  
  private static Properties loadPropertiesFromConfig(FileInputStream fileInputStream) throws Exception {
    try {
      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
      dbf.setNamespaceAware(true);
      dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
      DocumentBuilder builder = dbf.newDocumentBuilder();
      Document doc = builder.parse(fileInputStream);
      Element root = doc.getDocumentElement();
      return loadProperties(findReplacerDefinition(root));
    } finally {
      IOUtil.closeResource(fileInputStream);
    } 
  }
  
  private static Node findReplacerDefinition(Element root) throws XPathException {
    XPath xpath = XPathFactory.newInstance().newXPath();
    xpath.setNamespaceContext(new HzNsContext(null));
    String xpathExp = "//%s:config-replacers/%1$s:replacer[@class-name='%s']";
    NodeList replaceTags = (NodeList)xpath.evaluate(String.format(xpathExp, new Object[] { "hz", EncryptionReplacer.class.getName() }), root, XPathConstants.NODESET);
    if (replaceTags.getLength() < 1) {
      replaceTags = (NodeList)xpath.evaluate(String.format(xpathExp, new Object[] { "hz-client", EncryptionReplacer.class.getName() }), root, XPathConstants.NODESET);
      Preconditions.checkPositive(replaceTags.getLength(), "No EncryptionReplacer definition found within the provided XML document.");
    } 
    return replaceTags.item(0);
  }
  
  private static Properties loadProperties(Node node) {
    Properties properties = new Properties();
    for (Node n : DomConfigHelper.childElements(node)) {
      String value = DomConfigHelper.cleanNodeName(n);
      if ("properties".equals(value))
        fillProperties(n, properties); 
    } 
    return properties;
  }
  
  private static void fillProperties(Node node, Properties properties) {
    if (properties == null)
      return; 
    for (Node n : DomConfigHelper.childElements(node)) {
      String name = DomConfigHelper.cleanNodeName(n);
      if ("property".equals(name)) {
        String propertyName = getTextContent(n.getAttributes().getNamedItem("name"));
        String value = StringUtil.trim(getTextContent(n));
        properties.setProperty(propertyName, (value == null) ? "" : value);
      } 
    } 
  }
  
  private static String getTextContent(Node node) {
    try {
      return node.getTextContent();
    } catch (Exception e) {
      return getTextContentOld(node);
    } 
  }
  
  private static String getTextContentOld(Node node) {
    Node child = node.getFirstChild();
    if (child != null) {
      Node next = child.getNextSibling();
      if (next == null)
        return hasTextContent(child) ? child.getNodeValue() : null; 
      StringBuilder buf = new StringBuilder();
      appendTextContents(node, buf);
      return buf.toString();
    } 
    return null;
  }
  
  private static void appendTextContents(Node node, StringBuilder buf) {
    Node child = node.getFirstChild();
    while (child != null) {
      if (hasTextContent(child))
        buf.append(child.getNodeValue()); 
      child = child.getNextSibling();
    } 
  }
  
  private static boolean hasTextContent(Node node) {
    short nodeType = node.getNodeType();
    return (nodeType != 8 && nodeType != 7);
  }
}
