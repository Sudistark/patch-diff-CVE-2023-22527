package com.hazelcast.config;

import com.hazelcast.config.cp.CPSemaphoreConfig;
import com.hazelcast.config.cp.CPSubsystemConfig;
import com.hazelcast.config.cp.FencedLockConfig;
import com.hazelcast.config.cp.RaftAlgorithmConfig;
import com.hazelcast.core.HazelcastException;
import com.hazelcast.instance.ProtocolType;
import com.hazelcast.internal.config.ConfigValidator;
import com.hazelcast.logging.ILogger;
import com.hazelcast.logging.Logger;
import com.hazelcast.map.eviction.MapEvictionPolicy;
import com.hazelcast.mapreduce.TopologyChangedStrategy;
import com.hazelcast.nio.ClassLoaderUtil;
import com.hazelcast.quorum.QuorumType;
import com.hazelcast.spi.ServiceConfigurationParser;
import com.hazelcast.topic.TopicOverloadPolicy;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.StringUtil;
import com.hazelcast.util.function.Function;
import java.io.File;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;

class MemberDomConfigProcessor extends AbstractDomConfigProcessor {
  private static final ILogger LOGGER = Logger.getLogger(MemberDomConfigProcessor.class);
  
  protected final Config config;
  
  MemberDomConfigProcessor(boolean domLevel3, Config config) {
    super(domLevel3);
    this.config = config;
  }
  
  public void buildConfig(Node rootNode) throws Exception {
    for (Node node : DomConfigHelper.childElements(rootNode)) {
      String nodeName = DomConfigHelper.cleanNodeName(node);
      if (this.occurrenceSet.contains(nodeName))
        throw new InvalidConfigurationException("Duplicate '" + nodeName + "' definition found in the configuration."); 
      if (handleNode(node, nodeName))
        continue; 
      if (!ConfigSections.canOccurMultipleTimes(nodeName))
        this.occurrenceSet.add(nodeName); 
    } 
    if (this.occurrenceSet.contains("network") && this.occurrenceSet.contains("advanced-network") && this.config
      .getAdvancedNetworkConfig().isEnabled())
      throw new InvalidConfigurationException("Ambiguous configuration: cannot include both <network> and an enabled <advanced-network> element. Configure network using one of <network> or <advanced-network enabled=\"true\">."); 
  }
  
  private boolean handleNode(Node node, String nodeName) throws Exception {
    if (ConfigSections.INSTANCE_NAME.isEqual(nodeName)) {
      handleInstanceName(node);
    } else if (ConfigSections.NETWORK.isEqual(nodeName)) {
      handleNetwork(node);
    } else {
      if (ConfigSections.IMPORT.isEqual(nodeName))
        throw new HazelcastException("Non-expanded <import> element found"); 
      if (ConfigSections.GROUP.isEqual(nodeName)) {
        handleGroup(node);
      } else if (ConfigSections.PROPERTIES.isEqual(nodeName)) {
        fillProperties(node, this.config.getProperties());
      } else if (ConfigSections.WAN_REPLICATION.isEqual(nodeName)) {
        handleWanReplication(node);
      } else if (ConfigSections.EXECUTOR_SERVICE.isEqual(nodeName)) {
        handleExecutor(node);
      } else if (ConfigSections.DURABLE_EXECUTOR_SERVICE.isEqual(nodeName)) {
        handleDurableExecutor(node);
      } else if (ConfigSections.SCHEDULED_EXECUTOR_SERVICE.isEqual(nodeName)) {
        handleScheduledExecutor(node);
      } else if (ConfigSections.EVENT_JOURNAL.isEqual(nodeName)) {
        handleEventJournal(node);
      } else if (ConfigSections.MERKLE_TREE.isEqual(nodeName)) {
        handleMerkleTree(node);
      } else if (ConfigSections.SERVICES.isEqual(nodeName)) {
        handleServices(node);
      } else if (ConfigSections.QUEUE.isEqual(nodeName)) {
        handleQueue(node);
      } else if (ConfigSections.MAP.isEqual(nodeName)) {
        handleMap(node);
      } else if (ConfigSections.MULTIMAP.isEqual(nodeName)) {
        handleMultiMap(node);
      } else if (ConfigSections.REPLICATED_MAP.isEqual(nodeName)) {
        handleReplicatedMap(node);
      } else if (ConfigSections.LIST.isEqual(nodeName)) {
        handleList(node);
      } else if (ConfigSections.SET.isEqual(nodeName)) {
        handleSet(node);
      } else if (ConfigSections.TOPIC.isEqual(nodeName)) {
        handleTopic(node);
      } else if (ConfigSections.RELIABLE_TOPIC.isEqual(nodeName)) {
        handleReliableTopic(node);
      } else if (ConfigSections.CACHE.isEqual(nodeName)) {
        handleCache(node);
      } else if (ConfigSections.NATIVE_MEMORY.isEqual(nodeName)) {
        fillNativeMemoryConfig(node, this.config.getNativeMemoryConfig());
      } else if (ConfigSections.JOB_TRACKER.isEqual(nodeName)) {
        handleJobTracker(node);
      } else if (ConfigSections.SEMAPHORE.isEqual(nodeName)) {
        handleSemaphore(node);
      } else if (ConfigSections.LOCK.isEqual(nodeName)) {
        handleLock(node);
      } else if (ConfigSections.RINGBUFFER.isEqual(nodeName)) {
        handleRingbuffer(node);
      } else if (ConfigSections.ATOMIC_LONG.isEqual(nodeName)) {
        handleAtomicLong(node);
      } else if (ConfigSections.ATOMIC_REFERENCE.isEqual(nodeName)) {
        handleAtomicReference(node);
      } else if (ConfigSections.COUNT_DOWN_LATCH.isEqual(nodeName)) {
        handleCountDownLatchConfig(node);
      } else if (ConfigSections.LISTENERS.isEqual(nodeName)) {
        handleListeners(node);
      } else if (ConfigSections.PARTITION_GROUP.isEqual(nodeName)) {
        handlePartitionGroup(node);
      } else if (ConfigSections.SERIALIZATION.isEqual(nodeName)) {
        handleSerialization(node);
      } else if (ConfigSections.SECURITY.isEqual(nodeName)) {
        handleSecurity(node);
      } else if (ConfigSections.MEMBER_ATTRIBUTES.isEqual(nodeName)) {
        handleMemberAttributes(node);
      } else if (ConfigSections.LICENSE_KEY.isEqual(nodeName)) {
        this.config.setLicenseKey(getTextContent(node));
      } else if (ConfigSections.MANAGEMENT_CENTER.isEqual(nodeName)) {
        handleManagementCenterConfig(node);
      } else if (ConfigSections.QUORUM.isEqual(nodeName)) {
        handleQuorum(node);
      } else if (ConfigSections.LITE_MEMBER.isEqual(nodeName)) {
        handleLiteMember(node);
      } else if (ConfigSections.HOT_RESTART_PERSISTENCE.isEqual(nodeName)) {
        handleHotRestartPersistence(node);
      } else if (ConfigSections.USER_CODE_DEPLOYMENT.isEqual(nodeName)) {
        handleUserCodeDeployment(node);
      } else if (ConfigSections.CARDINALITY_ESTIMATOR.isEqual(nodeName)) {
        handleCardinalityEstimator(node);
      } else if (ConfigSections.FLAKE_ID_GENERATOR.isEqual(nodeName)) {
        handleFlakeIdGenerator(node);
      } else if (ConfigSections.CRDT_REPLICATION.isEqual(nodeName)) {
        handleCRDTReplication(node);
      } else if (ConfigSections.PN_COUNTER.isEqual(nodeName)) {
        handlePNCounter(node);
      } else if (ConfigSections.ADVANCED_NETWORK.isEqual(nodeName)) {
        handleAdvancedNetwork(node);
      } else if (ConfigSections.CP_SUBSYSTEM.isEqual(nodeName)) {
        handleCPSubsystem(node);
      } else {
        return true;
      } 
    } 
    return false;
  }
  
  private void handleInstanceName(Node node) throws Exception {
    String instanceName = getTextContent(node);
    if (instanceName.isEmpty())
      throw new InvalidConfigurationException("Instance name in XML configuration is empty"); 
    this.config.setInstanceName(instanceName);
  }
  
  private void handleUserCodeDeployment(Node dcRoot) throws Exception {
    UserCodeDeploymentConfig dcConfig = new UserCodeDeploymentConfig();
    Node attrEnabled = dcRoot.getAttributes().getNamedItem("enabled");
    boolean enabled = DomConfigHelper.getBooleanValue(getTextContent(attrEnabled));
    dcConfig.setEnabled(enabled);
    String classCacheModeName = "class-cache-mode";
    String providerModeName = "provider-mode";
    String blacklistPrefixesName = "blacklist-prefixes";
    String whitelistPrefixesName = "whitelist-prefixes";
    String providerFilterName = "provider-filter";
    for (Node n : DomConfigHelper.childElements(dcRoot)) {
      String name = DomConfigHelper.cleanNodeName(n);
      if (classCacheModeName.equals(name)) {
        String value = getTextContent(n);
        UserCodeDeploymentConfig.ClassCacheMode classCacheMode = UserCodeDeploymentConfig.ClassCacheMode.valueOf(value);
        dcConfig.setClassCacheMode(classCacheMode);
        continue;
      } 
      if (providerModeName.equals(name)) {
        String value = getTextContent(n);
        UserCodeDeploymentConfig.ProviderMode providerMode = UserCodeDeploymentConfig.ProviderMode.valueOf(value);
        dcConfig.setProviderMode(providerMode);
        continue;
      } 
      if (blacklistPrefixesName.equals(name)) {
        String value = getTextContent(n);
        dcConfig.setBlacklistedPrefixes(value);
        continue;
      } 
      if (whitelistPrefixesName.equals(name)) {
        String value = getTextContent(n);
        dcConfig.setWhitelistedPrefixes(value);
        continue;
      } 
      if (providerFilterName.equals(name)) {
        String value = getTextContent(n);
        dcConfig.setProviderFilter(value);
      } 
    } 
    this.config.setUserCodeDeploymentConfig(dcConfig);
  }
  
  private void handleHotRestartPersistence(Node hrRoot) throws Exception {
    HotRestartPersistenceConfig hrConfig = (new HotRestartPersistenceConfig()).setEnabled(DomConfigHelper.getBooleanValue(getAttribute(hrRoot, "enabled")));
    String parallelismName = "parallelism";
    String validationTimeoutName = "validation-timeout-seconds";
    String dataLoadTimeoutName = "data-load-timeout-seconds";
    String clusterDataRecoveryPolicyName = "cluster-data-recovery-policy";
    String autoRemoveStaleDataName = "auto-remove-stale-data";
    for (Node n : DomConfigHelper.childElements(hrRoot)) {
      String name = DomConfigHelper.cleanNodeName(n);
      String value = getTextContent(n);
      if ("base-dir".equals(name)) {
        hrConfig.setBaseDir((new File(value)).getAbsoluteFile());
        continue;
      } 
      if ("backup-dir".equals(name)) {
        hrConfig.setBackupDir((new File(value)).getAbsoluteFile());
        continue;
      } 
      if (parallelismName.equals(name)) {
        hrConfig.setParallelism(DomConfigHelper.getIntegerValue(parallelismName, value));
        continue;
      } 
      if (validationTimeoutName.equals(name)) {
        hrConfig.setValidationTimeoutSeconds(DomConfigHelper.getIntegerValue(validationTimeoutName, value));
        continue;
      } 
      if (dataLoadTimeoutName.equals(name)) {
        hrConfig.setDataLoadTimeoutSeconds(DomConfigHelper.getIntegerValue(dataLoadTimeoutName, value));
        continue;
      } 
      if (clusterDataRecoveryPolicyName.equals(name)) {
        hrConfig.setClusterDataRecoveryPolicy(
            HotRestartClusterDataRecoveryPolicy.valueOf(StringUtil.upperCaseInternal(value)));
        continue;
      } 
      if (autoRemoveStaleDataName.equals(name))
        hrConfig.setAutoRemoveStaleData(DomConfigHelper.getBooleanValue(value)); 
    } 
    this.config.setHotRestartPersistenceConfig(hrConfig);
  }
  
  private void handleCRDTReplication(Node root) throws Exception {
    CRDTReplicationConfig replicationConfig = new CRDTReplicationConfig();
    String replicationPeriodMillisName = "replication-period-millis";
    String maxConcurrentReplicationTargetsName = "max-concurrent-replication-targets";
    for (Node n : DomConfigHelper.childElements(root)) {
      String name = DomConfigHelper.cleanNodeName(n);
      if ("replication-period-millis".equals(name)) {
        replicationConfig.setReplicationPeriodMillis(
            DomConfigHelper.getIntegerValue("replication-period-millis", getTextContent(n)));
        continue;
      } 
      if ("max-concurrent-replication-targets".equals(name))
        replicationConfig.setMaxConcurrentReplicationTargets(
            DomConfigHelper.getIntegerValue("max-concurrent-replication-targets", getTextContent(n))); 
    } 
    this.config.setCRDTReplicationConfig(replicationConfig);
  }
  
  private void handleLiteMember(Node node) throws Exception {
    Node attrEnabled = node.getAttributes().getNamedItem("enabled");
    boolean liteMember = (attrEnabled != null && DomConfigHelper.getBooleanValue(getTextContent(attrEnabled)));
    this.config.setLiteMember(liteMember);
  }
  
  protected void handleQuorum(Node node) throws Exception {
    QuorumConfig quorumConfig = new QuorumConfig();
    String name = getAttribute(node, "name");
    quorumConfig.setName(name);
    handleQuorumNode(node, quorumConfig, name);
  }
  
  protected void handleQuorumNode(Node node, QuorumConfig quorumConfig, String name) {
    Node attrEnabled = node.getAttributes().getNamedItem("enabled");
    boolean enabled = (attrEnabled != null && DomConfigHelper.getBooleanValue(getTextContent(attrEnabled)));
    QuorumConfigBuilder quorumConfigBuilder = null;
    quorumConfig.setEnabled(enabled);
    for (Node n : DomConfigHelper.childElements(node)) {
      String value = getTextContent(n).trim();
      String nodeName = DomConfigHelper.cleanNodeName(n);
      if ("quorum-size".equals(nodeName)) {
        quorumConfig.setSize(DomConfigHelper.getIntegerValue("quorum-size", value));
        continue;
      } 
      if ("quorum-listeners".equals(nodeName)) {
        handleQuorumListeners(quorumConfig, n);
        continue;
      } 
      if ("quorum-type".equals(nodeName)) {
        quorumConfig.setType(QuorumType.valueOf(StringUtil.upperCaseInternal(value)));
        continue;
      } 
      if ("quorum-function-class-name".equals(nodeName)) {
        quorumConfig.setQuorumFunctionClassName(value);
        continue;
      } 
      if ("recently-active-quorum".equals(nodeName)) {
        quorumConfigBuilder = handleRecentlyActiveQuorum(name, n, quorumConfig.getSize());
        continue;
      } 
      if ("probabilistic-quorum".equals(nodeName))
        quorumConfigBuilder = handleProbabilisticQuorum(name, n, quorumConfig.getSize()); 
    } 
    if (quorumConfigBuilder != null) {
      boolean quorumFunctionDefinedByClassName = !StringUtil.isNullOrEmpty(quorumConfig.getQuorumFunctionClassName());
      if (quorumFunctionDefinedByClassName)
        throw new ConfigurationException("A quorum cannot simultaneously define probabilistic-quorum or recently-active-quorum and a quorum function class name."); 
      QuorumConfig constructedConfig = quorumConfigBuilder.build();
      constructedConfig.setSize(quorumConfig.getSize());
      constructedConfig.setType(quorumConfig.getType());
      constructedConfig.setListenerConfigs(quorumConfig.getListenerConfigs());
      quorumConfig = constructedConfig;
    } 
    this.config.addQuorumConfig(quorumConfig);
  }
  
  protected void handleQuorumListeners(QuorumConfig quorumConfig, Node n) {
    for (Node listenerNode : DomConfigHelper.childElements(n)) {
      if ("quorum-listener".equals(DomConfigHelper.cleanNodeName(listenerNode))) {
        String listenerClass = getTextContent(listenerNode);
        quorumConfig.addListenerConfig(new QuorumListenerConfig(listenerClass));
      } 
    } 
  }
  
  private QuorumConfigBuilder handleRecentlyActiveQuorum(String name, Node node, int quorumSize) {
    int heartbeatToleranceMillis = DomConfigHelper.getIntegerValue("heartbeat-tolerance-millis", 
        getAttribute(node, "heartbeat-tolerance-millis"), RecentlyActiveQuorumConfigBuilder.DEFAULT_HEARTBEAT_TOLERANCE_MILLIS);
    return QuorumConfig.newRecentlyActiveQuorumConfigBuilder(name, quorumSize, heartbeatToleranceMillis);
  }
  
  private QuorumConfigBuilder handleProbabilisticQuorum(String name, Node node, int quorumSize) {
    long acceptableHeartPause = DomConfigHelper.getLongValue("acceptable-heartbeat-pause-millis", 
        getAttribute(node, "acceptable-heartbeat-pause-millis"), ProbabilisticQuorumConfigBuilder.DEFAULT_HEARTBEAT_PAUSE_MILLIS);
    double threshold = DomConfigHelper.getDoubleValue("suspicion-threshold", 
        getAttribute(node, "suspicion-threshold"), ProbabilisticQuorumConfigBuilder.DEFAULT_PHI_THRESHOLD);
    int maxSampleSize = DomConfigHelper.getIntegerValue("max-sample-size", 
        getAttribute(node, "max-sample-size"), ProbabilisticQuorumConfigBuilder.DEFAULT_SAMPLE_SIZE);
    long minStdDeviation = DomConfigHelper.getLongValue("min-std-deviation-millis", 
        getAttribute(node, "min-std-deviation-millis"), ProbabilisticQuorumConfigBuilder.DEFAULT_MIN_STD_DEVIATION);
    long heartbeatIntervalMillis = DomConfigHelper.getLongValue("heartbeat-interval-millis", 
        getAttribute(node, "heartbeat-interval-millis"), ProbabilisticQuorumConfigBuilder.DEFAULT_HEARTBEAT_INTERVAL_MILLIS);
    return QuorumConfig.newProbabilisticQuorumConfigBuilder(name, quorumSize).withAcceptableHeartbeatPauseMillis(acceptableHeartPause).withSuspicionThreshold(threshold).withHeartbeatIntervalMillis(heartbeatIntervalMillis).withMinStdDeviationMillis(minStdDeviation).withMaxSampleSize(maxSampleSize);
  }
  
  private void handleServices(Node node) throws Exception {
    Node attDefaults = node.getAttributes().getNamedItem("enable-defaults");
    boolean enableDefaults = (attDefaults == null || DomConfigHelper.getBooleanValue(getTextContent(attDefaults)));
    ServicesConfig servicesConfig = this.config.getServicesConfig();
    servicesConfig.setEnableDefaults(enableDefaults);
    handleServiceNodes(node, servicesConfig);
  }
  
  protected void handleServiceNodes(Node node, ServicesConfig servicesConfig) {
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      if ("service".equals(nodeName)) {
        ServiceConfig serviceConfig = new ServiceConfig();
        String enabledValue = getAttribute(child, "enabled");
        boolean enabled = DomConfigHelper.getBooleanValue(enabledValue);
        serviceConfig.setEnabled(enabled);
        for (Node n : DomConfigHelper.childElements(child))
          handleServiceNode(n, serviceConfig); 
        servicesConfig.addServiceConfig(serviceConfig);
      } 
    } 
  }
  
  protected void handleServiceNode(Node n, ServiceConfig serviceConfig) {
    String value = DomConfigHelper.cleanNodeName(n);
    if ("name".equals(value)) {
      String name = getTextContent(n);
      serviceConfig.setName(name);
    } else if ("class-name".equals(value)) {
      String className = getTextContent(n);
      serviceConfig.setClassName(className);
    } else if ("properties".equals(value)) {
      fillProperties(n, serviceConfig.getProperties());
    } else if ("configuration".equals(value)) {
      Node parserNode = n.getAttributes().getNamedItem("parser");
      String parserClass = getTextContent(parserNode);
      if (parserNode == null || parserClass == null)
        throw new InvalidConfigurationException("Parser is required!"); 
      try {
        ServiceConfigurationParser parser = (ServiceConfigurationParser)ClassLoaderUtil.newInstance(this.config.getClassLoader(), parserClass);
        Object obj = parser.parse((Element)n);
        serviceConfig.setConfigObject(obj);
      } catch (Exception e) {
        ExceptionUtil.sneakyThrow(e);
      } 
    } 
  }
  
  protected void handleWanReplication(Node node) throws Exception {
    Node attName = node.getAttributes().getNamedItem("name");
    String name = getTextContent(attName);
    WanReplicationConfig wanReplicationConfig = new WanReplicationConfig();
    wanReplicationConfig.setName(name);
    handleWanReplicationNode(node, wanReplicationConfig);
  }
  
  void handleWanReplicationNode(Node node, WanReplicationConfig wanReplicationConfig) {
    for (Node nodeTarget : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(nodeTarget);
      handleWanReplicationChild(wanReplicationConfig, nodeTarget, nodeName);
    } 
    this.config.addWanReplicationConfig(wanReplicationConfig);
  }
  
  protected void handleWanReplicationChild(WanReplicationConfig wanReplicationConfig, Node nodeTarget, String nodeName) {
    if ("wan-publisher".equals(nodeName)) {
      WanPublisherConfig publisherConfig = new WanPublisherConfig();
      publisherConfig.setPublisherId(getAttribute(nodeTarget, "publisher-id"));
      publisherConfig.setGroupName(getAttribute(nodeTarget, "group-name"));
      handleWanPublisherNode(wanReplicationConfig, nodeTarget, publisherConfig);
    } else if ("wan-consumer".equals(nodeName)) {
      handleWanConsumerNode(wanReplicationConfig, nodeTarget);
    } 
  }
  
  void handleWanPublisherNode(WanReplicationConfig wanReplicationConfig, Node nodeTarget, WanPublisherConfig publisherConfig) {
    for (Node targetChild : DomConfigHelper.childElements(nodeTarget))
      handleWanPublisherConfig(publisherConfig, targetChild); 
    wanReplicationConfig.addWanPublisherConfig(publisherConfig);
  }
  
  void handleWanConsumerNode(WanReplicationConfig wanReplicationConfig, Node nodeTarget) {
    WanConsumerConfig consumerConfig = new WanConsumerConfig();
    for (Node targetChild : DomConfigHelper.childElements(nodeTarget))
      handleWanConsumerConfig(consumerConfig, targetChild); 
    wanReplicationConfig.setWanConsumerConfig(consumerConfig);
  }
  
  void handleWanPublisherConfig(WanPublisherConfig publisherConfig, Node targetChild) {
    String targetChildName = DomConfigHelper.cleanNodeName(targetChild);
    if ("class-name".equals(targetChildName)) {
      publisherConfig.setClassName(getTextContent(targetChild));
    } else if ("queue-full-behavior".equals(targetChildName)) {
      String queueFullBehavior = getTextContent(targetChild);
      publisherConfig.setQueueFullBehavior(WANQueueFullBehavior.valueOf(StringUtil.upperCaseInternal(queueFullBehavior)));
    } else if ("initial-publisher-state".equals(targetChildName)) {
      String initialPublisherState = getTextContent(targetChild);
      publisherConfig.setInitialPublisherState(
          WanPublisherState.valueOf(StringUtil.upperCaseInternal(initialPublisherState)));
    } else if ("queue-capacity".equals(targetChildName)) {
      int queueCapacity = DomConfigHelper.getIntegerValue("queue-capacity", getTextContent(targetChild));
      publisherConfig.setQueueCapacity(queueCapacity);
    } else if ("properties".equals(targetChildName)) {
      fillProperties(targetChild, publisherConfig.getProperties());
    } else if (AliasedDiscoveryConfigUtils.supports(targetChildName)) {
      handleAliasedDiscoveryStrategy(publisherConfig, targetChild, targetChildName);
    } else if ("discovery-strategies".equals(targetChildName)) {
      handleDiscoveryStrategies(publisherConfig.getDiscoveryConfig(), targetChild);
    } else if ("wan-sync".equals(targetChildName)) {
      handleWanSync(publisherConfig.getWanSyncConfig(), targetChild);
    } else if ("endpoint".equals(targetChildName)) {
      publisherConfig.setEndpoint(getTextContent(targetChild));
    } 
  }
  
  private void handleWanSync(WanSyncConfig wanSyncConfig, Node node) {
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      if ("consistency-check-strategy".equals(nodeName)) {
        String strategy = getTextContent(child);
        wanSyncConfig.setConsistencyCheckStrategy(
            ConsistencyCheckStrategy.valueOf(StringUtil.upperCaseInternal(strategy)));
      } 
    } 
  }
  
  private void handleWanConsumerConfig(WanConsumerConfig consumerConfig, Node targetChild) {
    String targetChildName = DomConfigHelper.cleanNodeName(targetChild);
    if ("class-name".equals(targetChildName)) {
      consumerConfig.setClassName(getTextContent(targetChild));
    } else if ("properties".equals(targetChildName)) {
      fillProperties(targetChild, consumerConfig.getProperties());
    } else if ("persist-wan-replicated-data".equals(targetChildName)) {
      consumerConfig.setPersistWanReplicatedData(DomConfigHelper.getBooleanValue(getTextContent(targetChild)));
    } 
  }
  
  private void handleNetwork(Node node) throws Exception {
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      if ("reuse-address".equals(nodeName)) {
        String value = getTextContent(child).trim();
        this.config.getNetworkConfig().setReuseAddress(DomConfigHelper.getBooleanValue(value));
        continue;
      } 
      if ("port".equals(nodeName)) {
        handlePort(child, this.config);
        continue;
      } 
      if ("outbound-ports".equals(nodeName)) {
        handleOutboundPorts(child);
        continue;
      } 
      if ("public-address".equals(nodeName)) {
        String address = getTextContent(child);
        this.config.getNetworkConfig().setPublicAddress(address);
        continue;
      } 
      if ("join".equals(nodeName)) {
        handleJoin(child, false);
        continue;
      } 
      if ("interfaces".equals(nodeName)) {
        handleInterfaces(child);
        continue;
      } 
      if ("symmetric-encryption".equals(nodeName)) {
        handleViaReflection(child, this.config.getNetworkConfig(), new SymmetricEncryptionConfig());
        continue;
      } 
      if ("ssl".equals(nodeName)) {
        handleSSLConfig(child);
        continue;
      } 
      if ("socket-interceptor".equals(nodeName)) {
        handleSocketInterceptorConfig(child);
        continue;
      } 
      if ("member-address-provider".equals(nodeName)) {
        handleMemberAddressProvider(child, false);
        continue;
      } 
      if ("failure-detector".equals(nodeName)) {
        handleFailureDetector(child, false);
        continue;
      } 
      if ("rest-api".equals(nodeName)) {
        handleRestApi(child);
        continue;
      } 
      if ("memcache-protocol".equals(nodeName))
        handleMemcacheProtocol(child); 
    } 
  }
  
  private void handleAdvancedNetwork(Node node) throws Exception {
    NamedNodeMap attributes = node.getAttributes();
    for (int a = 0; a < attributes.getLength(); a++) {
      Node att = attributes.item(a);
      if ("enabled".equals(att.getNodeName())) {
        String value = att.getNodeValue();
        this.config.getAdvancedNetworkConfig().setEnabled(DomConfigHelper.getBooleanValue(value));
      } 
    } 
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      if ("join".equals(nodeName)) {
        handleJoin(child, true);
        continue;
      } 
      if ("wan-endpoint-config".equals(nodeName)) {
        handleWanEndpointConfig(child);
        continue;
      } 
      if ("member-server-socket-endpoint-config".equals(nodeName)) {
        handleMemberServerSocketEndpointConfig(child);
        continue;
      } 
      if ("client-server-socket-endpoint-config".equals(nodeName)) {
        handleClientServerSocketEndpointConfig(child);
        continue;
      } 
      if ("wan-server-socket-endpoint-config".equals(nodeName)) {
        handleWanServerSocketEndpointConfig(child);
        continue;
      } 
      if ("rest-server-socket-endpoint-config".equals(nodeName)) {
        handleRestServerSocketEndpointConfig(child);
        continue;
      } 
      if ("memcache-server-socket-endpoint-config".equals(nodeName)) {
        handleMemcacheServerSocketEndpointConfig(child);
        continue;
      } 
      if ("member-address-provider".equals(nodeName)) {
        handleMemberAddressProvider(child, true);
        continue;
      } 
      if ("failure-detector".equals(nodeName))
        handleFailureDetector(child, true); 
    } 
  }
  
  private void handleEndpointConfig(EndpointConfig endpointConfig, Node node) throws Exception {
    String endpointName = getAttribute(node, "name");
    handleEndpointConfig(endpointConfig, node, endpointName);
  }
  
  protected void handleEndpointConfig(EndpointConfig endpointConfig, Node node, String endpointName) throws Exception {
    endpointConfig.setName(endpointName);
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      handleEndpointConfigCommons(child, nodeName, endpointConfig);
    } 
    this.config.getAdvancedNetworkConfig().addWanEndpointConfig(endpointConfig);
  }
  
  private void handleMemberServerSocketEndpointConfig(Node node) throws Exception {
    ServerSocketEndpointConfig config = new ServerSocketEndpointConfig();
    config.setProtocolType(ProtocolType.MEMBER);
    handleServerSocketEndpointConfig(config, node);
  }
  
  private void handleClientServerSocketEndpointConfig(Node node) throws Exception {
    ServerSocketEndpointConfig config = new ServerSocketEndpointConfig();
    config.setProtocolType(ProtocolType.CLIENT);
    handleServerSocketEndpointConfig(config, node);
  }
  
  protected void handleWanServerSocketEndpointConfig(Node node) throws Exception {
    ServerSocketEndpointConfig config = new ServerSocketEndpointConfig();
    config.setProtocolType(ProtocolType.WAN);
    handleServerSocketEndpointConfig(config, node);
  }
  
  private void handleRestServerSocketEndpointConfig(Node node) throws Exception {
    RestServerEndpointConfig config = new RestServerEndpointConfig();
    handleServerSocketEndpointConfig(config, node);
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      if ("endpoint-groups".equals(nodeName))
        for (Node endpointGroup : DomConfigHelper.childElements(child))
          handleRestEndpointGroup(config, endpointGroup);  
    } 
  }
  
  private void handleMemcacheServerSocketEndpointConfig(Node node) throws Exception {
    ServerSocketEndpointConfig config = new ServerSocketEndpointConfig();
    config.setProtocolType(ProtocolType.MEMCACHE);
    handleServerSocketEndpointConfig(config, node);
  }
  
  protected void handleWanEndpointConfig(Node node) throws Exception {
    EndpointConfig config = new EndpointConfig();
    config.setProtocolType(ProtocolType.WAN);
    handleEndpointConfig(config, node);
  }
  
  private void handleServerSocketEndpointConfig(ServerSocketEndpointConfig endpointConfig, Node node) throws Exception {
    String name = getAttribute(node, "name");
    handleServerSocketEndpointConfig(endpointConfig, node, name);
  }
  
  protected void handleServerSocketEndpointConfig(ServerSocketEndpointConfig endpointConfig, Node node, String name) throws Exception {
    endpointConfig.setName(name);
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      if ("port".equals(nodeName)) {
        handlePort(child, endpointConfig);
        continue;
      } 
      if ("public-address".equals(nodeName)) {
        String address = getTextContent(child);
        endpointConfig.setPublicAddress(address);
        continue;
      } 
      if ("reuse-address".equals(nodeName)) {
        String value = getTextContent(child).trim();
        endpointConfig.setReuseAddress(DomConfigHelper.getBooleanValue(value));
        continue;
      } 
      handleEndpointConfigCommons(child, nodeName, endpointConfig);
    } 
    addEndpointConfig(endpointConfig);
  }
  
  private void addEndpointConfig(EndpointConfig endpointConfig) {
    switch (null.$SwitchMap$com$hazelcast$instance$ProtocolType[endpointConfig.getProtocolType().ordinal()]) {
      case 1:
        ensureServerSocketEndpointConfig(endpointConfig);
        this.config.getAdvancedNetworkConfig().setMemberEndpointConfig((ServerSocketEndpointConfig)endpointConfig);
        return;
      case 2:
        ensureServerSocketEndpointConfig(endpointConfig);
        this.config.getAdvancedNetworkConfig().setClientEndpointConfig((ServerSocketEndpointConfig)endpointConfig);
        return;
      case 3:
        ensureServerSocketEndpointConfig(endpointConfig);
        this.config.getAdvancedNetworkConfig().setRestEndpointConfig((RestServerEndpointConfig)endpointConfig);
        return;
      case 4:
        this.config.getAdvancedNetworkConfig().addWanEndpointConfig(endpointConfig);
        return;
      case 5:
        this.config.getAdvancedNetworkConfig().setMemcacheEndpointConfig((ServerSocketEndpointConfig)endpointConfig);
        return;
    } 
    throw new InvalidConfigurationException("Endpoint config has invalid protocol type " + endpointConfig
        .getProtocolType());
  }
  
  private void ensureServerSocketEndpointConfig(EndpointConfig endpointConfig) {
    if (endpointConfig instanceof ServerSocketEndpointConfig)
      return; 
    throw new InvalidConfigurationException("Endpoint configuration of protocol type " + endpointConfig.getProtocolType() + " must be defined in a <server-socket-endpoint-config> element");
  }
  
  private void handleEndpointConfigCommons(Node node, String nodeName, EndpointConfig endpointConfig) throws Exception {
    if ("outbound-ports".equals(nodeName)) {
      handleOutboundPorts(node, endpointConfig);
    } else if ("interfaces".equals(nodeName)) {
      handleInterfaces(node, endpointConfig);
    } else if ("ssl".equals(nodeName)) {
      handleSSLConfig(node, endpointConfig);
    } else if ("socket-interceptor".equals(nodeName)) {
      handleSocketInterceptorConfig(node, endpointConfig);
    } else if ("socket-options".equals(nodeName)) {
      handleSocketOptions(node, endpointConfig);
    } else if ("symmetric-encryption".equals(nodeName)) {
      handleViaReflection(node, endpointConfig, new SymmetricEncryptionConfig());
    } 
  }
  
  private void handleSocketOptions(Node node, EndpointConfig endpointConfig) {
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      if ("buffer-direct".equals(nodeName)) {
        endpointConfig.setSocketBufferDirect(DomConfigHelper.getBooleanValue(getTextContent(child)));
        continue;
      } 
      if ("tcp-no-delay".equals(nodeName)) {
        endpointConfig.setSocketTcpNoDelay(DomConfigHelper.getBooleanValue(getTextContent(child)));
        continue;
      } 
      if ("keep-alive".equals(nodeName)) {
        endpointConfig.setSocketKeepAlive(DomConfigHelper.getBooleanValue(getTextContent(child)));
        continue;
      } 
      if ("connect-timeout-seconds".equals(nodeName)) {
        endpointConfig.setSocketConnectTimeoutSeconds(DomConfigHelper.getIntegerValue("connect-timeout-seconds", 
              getTextContent(child), 0));
        continue;
      } 
      if ("send-buffer-size-kb".equals(nodeName)) {
        endpointConfig.setSocketSendBufferSizeKb(DomConfigHelper.getIntegerValue("send-buffer-size-kb", 
              getTextContent(child), 128));
        continue;
      } 
      if ("receive-buffer-size-kb".equals(nodeName)) {
        endpointConfig.setSocketRcvBufferSizeKb(DomConfigHelper.getIntegerValue("receive-buffer-size-kb", 
              getTextContent(child), 128));
        continue;
      } 
      if ("linger-seconds".equals(nodeName))
        endpointConfig.setSocketLingerSeconds(DomConfigHelper.getIntegerValue("linger-seconds", 
              getTextContent(child), 0)); 
    } 
  }
  
  protected void handleExecutor(Node node) throws Exception {
    ExecutorConfig executorConfig = new ExecutorConfig();
    handleViaReflection(node, this.config, executorConfig);
  }
  
  protected void handleDurableExecutor(Node node) throws Exception {
    DurableExecutorConfig durableExecutorConfig = new DurableExecutorConfig();
    handleViaReflection(node, this.config, durableExecutorConfig);
  }
  
  protected void handleScheduledExecutor(Node node) throws Exception {
    ScheduledExecutorConfig scheduledExecutorConfig = new ScheduledExecutorConfig();
    scheduledExecutorConfig.setName(getTextContent(node.getAttributes().getNamedItem("name")));
    handleScheduledExecutorNode(node, scheduledExecutorConfig);
  }
  
  void handleScheduledExecutorNode(Node node, ScheduledExecutorConfig scheduledExecutorConfig) {
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      if ("merge-policy".equals(nodeName)) {
        scheduledExecutorConfig.setMergePolicyConfig(createMergePolicyConfig(child));
        continue;
      } 
      if ("capacity".equals(nodeName)) {
        scheduledExecutorConfig.setCapacity(Integer.parseInt(getTextContent(child)));
        continue;
      } 
      if ("durability".equals(nodeName)) {
        scheduledExecutorConfig.setDurability(Integer.parseInt(getTextContent(child)));
        continue;
      } 
      if ("pool-size".equals(nodeName)) {
        scheduledExecutorConfig.setPoolSize(Integer.parseInt(getTextContent(child)));
        continue;
      } 
      if ("quorum-ref".equals(nodeName))
        scheduledExecutorConfig.setQuorumName(getTextContent(child)); 
    } 
    this.config.addScheduledExecutorConfig(scheduledExecutorConfig);
  }
  
  protected void handleCardinalityEstimator(Node node) throws Exception {
    CardinalityEstimatorConfig cardinalityEstimatorConfig = new CardinalityEstimatorConfig();
    cardinalityEstimatorConfig.setName(getTextContent(node.getAttributes().getNamedItem("name")));
    handleCardinalityEstimatorNode(node, cardinalityEstimatorConfig);
  }
  
  void handleCardinalityEstimatorNode(Node node, CardinalityEstimatorConfig cardinalityEstimatorConfig) {
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      if ("merge-policy".equals(nodeName)) {
        MergePolicyConfig mergePolicyConfig = createMergePolicyConfig(child);
        cardinalityEstimatorConfig.setMergePolicyConfig(mergePolicyConfig);
        continue;
      } 
      if ("backup-count".equals(nodeName)) {
        cardinalityEstimatorConfig.setBackupCount(Integer.parseInt(getTextContent(child)));
        continue;
      } 
      if ("async-backup-count".equals(nodeName)) {
        cardinalityEstimatorConfig.setAsyncBackupCount(Integer.parseInt(getTextContent(child)));
        continue;
      } 
      if ("quorum-ref".equals(nodeName))
        cardinalityEstimatorConfig.setQuorumName(getTextContent(child)); 
    } 
    this.config.addCardinalityEstimatorConfig(cardinalityEstimatorConfig);
  }
  
  protected void handlePNCounter(Node node) throws Exception {
    PNCounterConfig pnCounterConfig = new PNCounterConfig();
    handleViaReflection(node, this.config, pnCounterConfig);
  }
  
  protected void handleFlakeIdGenerator(Node node) throws Exception {
    String name = getAttribute(node, "name");
    FlakeIdGeneratorConfig generatorConfig = new FlakeIdGeneratorConfig(name);
    handleFlakeIdGeneratorNode(node, generatorConfig);
  }
  
  void handleFlakeIdGeneratorNode(Node node, FlakeIdGeneratorConfig generatorConfig) {
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      String value = getTextContent(child).trim();
      if ("prefetch-count".equals(nodeName)) {
        generatorConfig.setPrefetchCount(Integer.parseInt(value));
        continue;
      } 
      if ("prefetch-validity-millis".equalsIgnoreCase(nodeName)) {
        generatorConfig.setPrefetchValidityMillis(Long.parseLong(value));
        continue;
      } 
      if ("id-offset".equalsIgnoreCase(nodeName)) {
        generatorConfig.setIdOffset(Long.parseLong(value));
        continue;
      } 
      if ("node-id-offset".equalsIgnoreCase(nodeName)) {
        generatorConfig.setNodeIdOffset(Long.parseLong(value));
        continue;
      } 
      if ("statistics-enabled".equals(nodeName))
        generatorConfig.setStatisticsEnabled(DomConfigHelper.getBooleanValue(value)); 
    } 
    this.config.addFlakeIdGeneratorConfig(generatorConfig);
  }
  
  private void handleGroup(Node node) throws Exception {
    for (Node n : DomConfigHelper.childElements(node)) {
      String value = getTextContent(n).trim();
      String nodeName = DomConfigHelper.cleanNodeName(n);
      if ("name".equals(nodeName)) {
        this.config.getGroupConfig().setName(value);
        continue;
      } 
      if ("password".equals(nodeName))
        this.config.getGroupConfig().setPassword(value); 
    } 
  }
  
  private void handleInterfaces(Node node) throws Exception {
    NamedNodeMap attributes = node.getAttributes();
    InterfacesConfig interfaces = this.config.getNetworkConfig().getInterfaces();
    for (int a = 0; a < attributes.getLength(); a++) {
      Node att = attributes.item(a);
      if ("enabled".equals(att.getNodeName())) {
        String value = att.getNodeValue();
        interfaces.setEnabled(DomConfigHelper.getBooleanValue(value));
      } 
    } 
    handleInterfacesList(node, interfaces);
  }
  
  protected void handleInterfacesList(Node node, InterfacesConfig interfaces) {
    for (Node n : DomConfigHelper.childElements(node)) {
      if ("interface".equals(StringUtil.lowerCaseInternal(DomConfigHelper.cleanNodeName(n)))) {
        String value = getTextContent(n).trim();
        interfaces.addInterface(value);
      } 
    } 
  }
  
  private void handleInterfaces(Node node, EndpointConfig endpointConfig) {
    NamedNodeMap attributes = node.getAttributes();
    InterfacesConfig interfaces = endpointConfig.getInterfaces();
    for (int a = 0; a < attributes.getLength(); a++) {
      Node att = attributes.item(a);
      if ("enabled".equals(att.getNodeName())) {
        String value = att.getNodeValue();
        interfaces.setEnabled(DomConfigHelper.getBooleanValue(value));
      } 
    } 
    handleInterfacesList(node, interfaces);
  }
  
  protected void handleViaReflection(Node node, Object parent, Object child) throws Exception {
    NamedNodeMap attributes = node.getAttributes();
    if (attributes != null)
      for (int a = 0; a < attributes.getLength(); a++) {
        Node att = attributes.item(a);
        invokeSetter(child, att, att.getNodeValue());
      }  
    for (Node n : DomConfigHelper.childElements(node)) {
      if (n instanceof Element)
        invokeSetter(child, n, getTextContent(n).trim()); 
    } 
    attachChildConfig(parent, child);
  }
  
  private static void invokeSetter(Object target, Node node, String argument) {
    Method method = getMethod(target, "set" + toPropertyName(DomConfigHelper.cleanNodeName(node)), true);
    if (method == null)
      throw new InvalidConfigurationException("Invalid element/attribute name in the configuration: " + node); 
    Class<?> arg = method.getParameterTypes()[0];
    Object coercedArg = (arg == String.class) ? argument : ((arg == int.class) ? Integer.valueOf(argument) : ((arg == long.class) ? Long.valueOf(argument) : ((arg == boolean.class) ? Boolean.valueOf(DomConfigHelper.getBooleanValue(argument)) : null)));
    if (coercedArg == null)
      throw new HazelcastException(String.format("Method %s has unsupported argument type %s", new Object[] { method
              .getName(), arg.getSimpleName() })); 
    try {
      method.invoke(target, new Object[] { coercedArg });
    } catch (Exception e) {
      throw new HazelcastException(e);
    } 
  }
  
  private static void attachChildConfig(Object parent, Object child) throws Exception {
    String targetName = child.getClass().getSimpleName();
    Method attacher = getMethod(parent, "set" + targetName, false);
    if (attacher == null)
      attacher = getMethod(parent, "add" + targetName, false); 
    if (attacher == null)
      throw new HazelcastException(String.format("%s doesn't accept %s as child", new Object[] { parent
              .getClass().getSimpleName(), targetName })); 
    attacher.invoke(parent, new Object[] { child });
  }
  
  private static Method getMethod(Object target, String methodName, boolean requiresArg) {
    Method[] methods = target.getClass().getMethods();
    for (Method method : methods) {
      if (method.getName().equalsIgnoreCase(methodName)) {
        if (!requiresArg)
          return method; 
        Class[] args = method.getParameterTypes();
        if (args.length == 1) {
          Class<?> arg = method.getParameterTypes()[0];
          if (arg == String.class || arg == int.class || arg == long.class || arg == boolean.class)
            return method; 
        } 
      } 
    } 
    return null;
  }
  
  private static String toPropertyName(String element) {
    String refPropertyName = handleRefProperty(element);
    if (refPropertyName != null)
      return refPropertyName; 
    StringBuilder sb = new StringBuilder();
    char[] chars = element.toCharArray();
    boolean upper = true;
    for (char c : chars) {
      if (c == '_' || c == '-' || c == '.') {
        upper = true;
      } else if (upper) {
        sb.append(Character.toUpperCase(c));
        upper = false;
      } else {
        sb.append(c);
      } 
    } 
    return sb.toString();
  }
  
  private static String handleRefProperty(String element) {
    if (element.equals("quorum-ref"))
      return "QuorumName"; 
    return null;
  }
  
  private void handleJoin(Node node, boolean advancedNetworkConfig) {
    JoinConfig joinConfig = joinConfig(advancedNetworkConfig);
    for (Node child : DomConfigHelper.childElements(node)) {
      String name = DomConfigHelper.cleanNodeName(child);
      if ("multicast".equals(name)) {
        handleMulticast(child, advancedNetworkConfig);
        continue;
      } 
      if ("tcp-ip".equals(name)) {
        handleTcpIp(child, advancedNetworkConfig);
        continue;
      } 
      if (AliasedDiscoveryConfigUtils.supports(name)) {
        handleAliasedDiscoveryStrategy(joinConfig, child, name);
        continue;
      } 
      if ("discovery-strategies".equals(name))
        handleDiscoveryStrategies(joinConfig.getDiscoveryConfig(), child); 
    } 
    joinConfig.verify();
  }
  
  protected JoinConfig joinConfig(boolean advancedNetworkConfig) {
    return advancedNetworkConfig ? this.config
      .getAdvancedNetworkConfig().getJoin() : this.config
      .getNetworkConfig().getJoin();
  }
  
  private void handleDiscoveryStrategies(DiscoveryConfig discoveryConfig, Node node) {
    for (Node child : DomConfigHelper.childElements(node))
      handleDiscoveryStrategiesChild(discoveryConfig, child); 
  }
  
  protected void handleDiscoveryStrategiesChild(DiscoveryConfig discoveryConfig, Node child) {
    String name = DomConfigHelper.cleanNodeName(child);
    if ("discovery-strategy".equals(name)) {
      handleDiscoveryStrategy(child, discoveryConfig);
    } else if ("node-filter".equals(name)) {
      handleDiscoveryNodeFilter(child, discoveryConfig);
    } 
  }
  
  void handleDiscoveryNodeFilter(Node node, DiscoveryConfig discoveryConfig) {
    NamedNodeMap attributes = node.getAttributes();
    Node att = attributes.getNamedItem("class");
    if (att != null)
      discoveryConfig.setNodeFilterClass(getTextContent(att).trim()); 
  }
  
  void handleDiscoveryStrategy(Node node, DiscoveryConfig discoveryConfig) {
    boolean enabled = false;
    String clazz = null;
    NamedNodeMap attributes = node.getAttributes();
    for (int a = 0; a < attributes.getLength(); a++) {
      Node att = attributes.item(a);
      String value = getTextContent(att).trim();
      if ("enabled".equals(StringUtil.lowerCaseInternal(att.getNodeName()))) {
        enabled = DomConfigHelper.getBooleanValue(value);
      } else if ("class".equals(att.getNodeName())) {
        clazz = value;
      } 
    } 
    if (!enabled || clazz == null)
      return; 
    Map<String, Comparable> properties = new HashMap<String, Comparable>();
    for (Node child : DomConfigHelper.childElements(node)) {
      String name = DomConfigHelper.cleanNodeName(child);
      if ("properties".equals(name))
        fillProperties(child, properties); 
    } 
    discoveryConfig.addDiscoveryStrategyConfig(new DiscoveryStrategyConfig(clazz, properties));
  }
  
  private void handleAliasedDiscoveryStrategy(JoinConfig joinConfig, Node node, String tag) {
    AliasedDiscoveryConfig aliasedDiscoveryConfig = AliasedDiscoveryConfigUtils.getConfigByTag(joinConfig, tag);
    updateConfig(aliasedDiscoveryConfig, node);
  }
  
  private void handleAliasedDiscoveryStrategy(WanPublisherConfig publisherConfig, Node node, String tag) {
    AliasedDiscoveryConfig aliasedDiscoveryConfig = AliasedDiscoveryConfigUtils.getConfigByTag(publisherConfig, tag);
    updateConfig(aliasedDiscoveryConfig, node);
  }
  
  private void updateConfig(AliasedDiscoveryConfig config, Node node) {
    NamedNodeMap attributes = node.getAttributes();
    for (int a = 0; a < attributes.getLength(); a++) {
      Node att = attributes.item(a);
      String value = getTextContent(att).trim();
      if ("enabled".equals(StringUtil.lowerCaseInternal(att.getNodeName()))) {
        config.setEnabled(DomConfigHelper.getBooleanValue(value));
      } else if (att.getNodeName().equals("connection-timeout-seconds")) {
        config.setProperty("connection-timeout-seconds", value);
      } 
    } 
    for (Node n : DomConfigHelper.childElements(node)) {
      String key = DomConfigHelper.cleanNodeName(n);
      String value = getTextContent(n).trim();
      config.setProperty(key, value);
    } 
  }
  
  private void handleMulticast(Node node, boolean advancedNetworkConfig) {
    JoinConfig join = joinConfig(advancedNetworkConfig);
    MulticastConfig multicastConfig = join.getMulticastConfig();
    NamedNodeMap attributes = node.getAttributes();
    for (int a = 0; a < attributes.getLength(); a++) {
      Node att = attributes.item(a);
      String value = getTextContent(att).trim();
      if ("enabled".equals(StringUtil.lowerCaseInternal(att.getNodeName()))) {
        multicastConfig.setEnabled(DomConfigHelper.getBooleanValue(value));
      } else if ("loopbackmodeenabled".equals(StringUtil.lowerCaseInternal(att.getNodeName())) || "loopback-mode-enabled"
        .equals(StringUtil.lowerCaseInternal(att.getNodeName()))) {
        multicastConfig.setLoopbackModeEnabled(DomConfigHelper.getBooleanValue(value));
      } 
    } 
    for (Node n : DomConfigHelper.childElements(node)) {
      String value = getTextContent(n).trim();
      if ("multicast-group".equals(DomConfigHelper.cleanNodeName(n))) {
        multicastConfig.setMulticastGroup(value);
        continue;
      } 
      if ("multicast-port".equals(DomConfigHelper.cleanNodeName(n))) {
        multicastConfig.setMulticastPort(Integer.parseInt(value));
        continue;
      } 
      if ("multicast-timeout-seconds".equals(DomConfigHelper.cleanNodeName(n))) {
        multicastConfig.setMulticastTimeoutSeconds(Integer.parseInt(value));
        continue;
      } 
      if ("multicast-time-to-live-seconds".equals(DomConfigHelper.cleanNodeName(n))) {
        multicastConfig.setMulticastTimeToLive(Integer.parseInt(value));
        continue;
      } 
      if ("multicast-time-to-live".equals(DomConfigHelper.cleanNodeName(n))) {
        multicastConfig.setMulticastTimeToLive(Integer.parseInt(value));
        continue;
      } 
      if ("trusted-interfaces".equals(DomConfigHelper.cleanNodeName(n)))
        handleTrustedInterfaces(multicastConfig, n); 
    } 
  }
  
  protected void handleTrustedInterfaces(MulticastConfig multicastConfig, Node n) {
    for (Node child : DomConfigHelper.childElements(n)) {
      if ("interface".equals(StringUtil.lowerCaseInternal(DomConfigHelper.cleanNodeName(child))))
        multicastConfig.addTrustedInterface(getTextContent(child).trim()); 
    } 
  }
  
  private void handleTcpIp(Node node, boolean advancedNetworkConfig) {
    NamedNodeMap attributes = node.getAttributes();
    JoinConfig join = joinConfig(advancedNetworkConfig);
    TcpIpConfig tcpIpConfig = join.getTcpIpConfig();
    for (int a = 0; a < attributes.getLength(); a++) {
      Node att = attributes.item(a);
      String value = getTextContent(att).trim();
      if (att.getNodeName().equals("enabled")) {
        tcpIpConfig.setEnabled(DomConfigHelper.getBooleanValue(value));
      } else if (att.getNodeName().equals("connection-timeout-seconds")) {
        tcpIpConfig.setConnectionTimeoutSeconds(DomConfigHelper.getIntegerValue("connection-timeout-seconds", value));
      } 
    } 
    Set<String> memberTags = new HashSet<String>(Arrays.asList(new String[] { "interface", "member", "members" }));
    for (Node n : DomConfigHelper.childElements(node)) {
      String value = getTextContent(n).trim();
      if (DomConfigHelper.cleanNodeName(n).equals("member-list")) {
        handleMemberList(n, advancedNetworkConfig);
        continue;
      } 
      if (DomConfigHelper.cleanNodeName(n).equals("required-member")) {
        if (tcpIpConfig.getRequiredMember() != null)
          throw new InvalidConfigurationException("Duplicate required-member definition found in the configuration. "); 
        tcpIpConfig.setRequiredMember(value);
        continue;
      } 
      if (memberTags.contains(DomConfigHelper.cleanNodeName(n)))
        tcpIpConfig.addMember(value); 
    } 
  }
  
  protected void handleMemberList(Node node, boolean advancedNetworkConfig) {
    JoinConfig join = joinConfig(advancedNetworkConfig);
    TcpIpConfig tcpIpConfig = join.getTcpIpConfig();
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      if ("member".equals(nodeName)) {
        String value = getTextContent(n).trim();
        tcpIpConfig.addMember(value);
      } 
    } 
  }
  
  protected void handlePort(Node node, Config config) {
    String portStr = getTextContent(node).trim();
    NetworkConfig networkConfig = config.getNetworkConfig();
    if (portStr.length() > 0)
      networkConfig.setPort(Integer.parseInt(portStr)); 
    NamedNodeMap attributes = node.getAttributes();
    for (int a = 0; a < attributes.getLength(); a++) {
      Node att = attributes.item(a);
      String value = getTextContent(att).trim();
      if ("auto-increment".equals(att.getNodeName())) {
        networkConfig.setPortAutoIncrement(DomConfigHelper.getBooleanValue(value));
      } else if ("port-count".equals(att.getNodeName())) {
        int portCount = Integer.parseInt(value);
        networkConfig.setPortCount(portCount);
      } 
    } 
  }
  
  protected void handlePort(Node node, ServerSocketEndpointConfig endpointConfig) {
    String portStr = getTextContent(node).trim();
    if (portStr.length() > 0)
      endpointConfig.setPort(Integer.parseInt(portStr)); 
    handlePortAttributes(node, endpointConfig);
  }
  
  protected void handlePortAttributes(Node node, ServerSocketEndpointConfig endpointConfig) {
    NamedNodeMap attributes = node.getAttributes();
    for (int a = 0; a < attributes.getLength(); a++) {
      Node att = attributes.item(a);
      String value = getTextContent(att).trim();
      if ("auto-increment".equals(att.getNodeName())) {
        endpointConfig.setPortAutoIncrement(DomConfigHelper.getBooleanValue(value));
      } else if ("port-count".equals(att.getNodeName())) {
        int portCount = Integer.parseInt(value);
        endpointConfig.setPortCount(portCount);
      } 
    } 
  }
  
  protected void handleOutboundPorts(Node child) throws Exception {
    NetworkConfig networkConfig = this.config.getNetworkConfig();
    for (Node n : DomConfigHelper.childElements(child)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      if ("ports".equals(nodeName)) {
        String value = getTextContent(n);
        networkConfig.addOutboundPortDefinition(value);
      } 
    } 
  }
  
  protected void handleOutboundPorts(Node child, EndpointConfig endpointConfig) {
    for (Node n : DomConfigHelper.childElements(child)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      if ("ports".equals(nodeName)) {
        String value = getTextContent(n);
        endpointConfig.addOutboundPortDefinition(value);
      } 
    } 
  }
  
  protected void handleLock(Node node) throws Exception {
    String name = getAttribute(node, "name");
    LockConfig lockConfig = new LockConfig();
    lockConfig.setName(name);
    handleLockNode(node, lockConfig);
  }
  
  void handleLockNode(Node node, LockConfig lockConfig) {
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      String value = getTextContent(n).trim();
      if ("quorum-ref".equals(nodeName))
        lockConfig.setQuorumName(value); 
    } 
    this.config.addLockConfig(lockConfig);
  }
  
  protected void handleQueue(Node node) throws Exception {
    Node attName = node.getAttributes().getNamedItem("name");
    String name = getTextContent(attName);
    QueueConfig qConfig = new QueueConfig();
    qConfig.setName(name);
    handleQueueNode(node, qConfig);
  }
  
  void handleQueueNode(Node node, QueueConfig qConfig) {
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      String value = getTextContent(n).trim();
      if ("max-size".equals(nodeName)) {
        qConfig.setMaxSize(DomConfigHelper.getIntegerValue("max-size", value));
        continue;
      } 
      if ("backup-count".equals(nodeName)) {
        qConfig.setBackupCount(DomConfigHelper.getIntegerValue("backup-count", value));
        continue;
      } 
      if ("async-backup-count".equals(nodeName)) {
        qConfig.setAsyncBackupCount(DomConfigHelper.getIntegerValue("async-backup-count", value));
        continue;
      } 
      if ("item-listeners".equals(nodeName)) {
        handleItemListeners(n, new Object(this, qConfig));
        continue;
      } 
      if ("statistics-enabled".equals(nodeName)) {
        qConfig.setStatisticsEnabled(DomConfigHelper.getBooleanValue(value));
        continue;
      } 
      if ("queue-store".equals(nodeName)) {
        QueueStoreConfig queueStoreConfig = createQueueStoreConfig(n);
        qConfig.setQueueStoreConfig(queueStoreConfig);
        continue;
      } 
      if ("quorum-ref".equals(nodeName)) {
        qConfig.setQuorumName(value);
        continue;
      } 
      if ("empty-queue-ttl".equals(nodeName)) {
        qConfig.setEmptyQueueTtl(DomConfigHelper.getIntegerValue("empty-queue-ttl", value));
        continue;
      } 
      if ("merge-policy".equals(nodeName)) {
        MergePolicyConfig mergePolicyConfig = createMergePolicyConfig(n);
        qConfig.setMergePolicyConfig(mergePolicyConfig);
      } 
    } 
    this.config.addQueueConfig(qConfig);
  }
  
  protected void handleItemListeners(Node n, Function<ItemListenerConfig, Void> configAddFunction) {
    for (Node listenerNode : DomConfigHelper.childElements(n)) {
      if ("item-listener".equals(DomConfigHelper.cleanNodeName(listenerNode))) {
        NamedNodeMap attrs = listenerNode.getAttributes();
        boolean incValue = DomConfigHelper.getBooleanValue(getTextContent(attrs.getNamedItem("include-value")));
        String listenerClass = getTextContent(listenerNode);
        configAddFunction.apply(new ItemListenerConfig(listenerClass, incValue));
      } 
    } 
  }
  
  protected void handleList(Node node) throws Exception {
    Node attName = node.getAttributes().getNamedItem("name");
    String name = getTextContent(attName);
    ListConfig lConfig = new ListConfig();
    lConfig.setName(name);
    handleListNode(node, lConfig);
  }
  
  void handleListNode(Node node, ListConfig lConfig) {
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      String value = getTextContent(n).trim();
      if ("max-size".equals(nodeName)) {
        lConfig.setMaxSize(DomConfigHelper.getIntegerValue("max-size", value));
        continue;
      } 
      if ("backup-count".equals(nodeName)) {
        lConfig.setBackupCount(DomConfigHelper.getIntegerValue("backup-count", value));
        continue;
      } 
      if ("async-backup-count".equals(nodeName)) {
        lConfig.setAsyncBackupCount(DomConfigHelper.getIntegerValue("async-backup-count", value));
        continue;
      } 
      if ("item-listeners".equals(nodeName)) {
        handleItemListeners(n, new Object(this, lConfig));
        continue;
      } 
      if ("statistics-enabled".equals(nodeName)) {
        lConfig.setStatisticsEnabled(DomConfigHelper.getBooleanValue(value));
        continue;
      } 
      if ("quorum-ref".equals(nodeName)) {
        lConfig.setQuorumName(value);
        continue;
      } 
      if ("merge-policy".equals(nodeName)) {
        MergePolicyConfig mergePolicyConfig = createMergePolicyConfig(n);
        lConfig.setMergePolicyConfig(mergePolicyConfig);
      } 
    } 
    this.config.addListConfig(lConfig);
  }
  
  protected void handleSet(Node node) throws Exception {
    Node attName = node.getAttributes().getNamedItem("name");
    String name = getTextContent(attName);
    SetConfig sConfig = new SetConfig();
    sConfig.setName(name);
    handleSetNode(node, sConfig);
  }
  
  void handleSetNode(Node node, SetConfig sConfig) {
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      String value = getTextContent(n).trim();
      if ("max-size".equals(nodeName)) {
        sConfig.setMaxSize(DomConfigHelper.getIntegerValue("max-size", value));
        continue;
      } 
      if ("backup-count".equals(nodeName)) {
        sConfig.setBackupCount(DomConfigHelper.getIntegerValue("backup-count", value));
        continue;
      } 
      if ("async-backup-count".equals(nodeName)) {
        sConfig.setAsyncBackupCount(DomConfigHelper.getIntegerValue("async-backup-count", value));
        continue;
      } 
      if ("item-listeners".equals(nodeName)) {
        handleItemListeners(n, new Object(this, sConfig));
        continue;
      } 
      if ("statistics-enabled".equals(nodeName)) {
        sConfig.setStatisticsEnabled(DomConfigHelper.getBooleanValue(value));
        continue;
      } 
      if ("quorum-ref".equals(nodeName)) {
        sConfig.setQuorumName(value);
        continue;
      } 
      if ("merge-policy".equals(nodeName)) {
        MergePolicyConfig mergePolicyConfig = createMergePolicyConfig(n);
        sConfig.setMergePolicyConfig(mergePolicyConfig);
      } 
    } 
    this.config.addSetConfig(sConfig);
  }
  
  protected void handleMultiMap(Node node) throws Exception {
    Node attName = node.getAttributes().getNamedItem("name");
    String name = getTextContent(attName);
    MultiMapConfig multiMapConfig = new MultiMapConfig();
    multiMapConfig.setName(name);
    handleMultiMapNode(node, multiMapConfig);
  }
  
  void handleMultiMapNode(Node node, MultiMapConfig multiMapConfig) {
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      String value = getTextContent(n).trim();
      if ("value-collection-type".equals(nodeName)) {
        multiMapConfig.setValueCollectionType(value);
        continue;
      } 
      if ("backup-count".equals(nodeName)) {
        multiMapConfig.setBackupCount(DomConfigHelper.getIntegerValue("backup-count", value));
        continue;
      } 
      if ("async-backup-count".equals(nodeName)) {
        multiMapConfig.setAsyncBackupCount(DomConfigHelper.getIntegerValue("async-backup-count", value));
        continue;
      } 
      if ("entry-listeners".equals(nodeName)) {
        handleEntryListeners(n, new Object(this, multiMapConfig));
        continue;
      } 
      if ("statistics-enabled".equals(nodeName)) {
        multiMapConfig.setStatisticsEnabled(DomConfigHelper.getBooleanValue(value));
        continue;
      } 
      if ("binary".equals(nodeName)) {
        multiMapConfig.setBinary(DomConfigHelper.getBooleanValue(value));
        continue;
      } 
      if ("quorum-ref".equals(nodeName)) {
        multiMapConfig.setQuorumName(value);
        continue;
      } 
      if ("merge-policy".equals(nodeName)) {
        MergePolicyConfig mergePolicyConfig = createMergePolicyConfig(n);
        multiMapConfig.setMergePolicyConfig(mergePolicyConfig);
      } 
    } 
    this.config.addMultiMapConfig(multiMapConfig);
  }
  
  protected void handleEntryListeners(Node n, Function<EntryListenerConfig, Void> configAddFunction) {
    for (Node listenerNode : DomConfigHelper.childElements(n)) {
      if ("entry-listener".equals(DomConfigHelper.cleanNodeName(listenerNode))) {
        NamedNodeMap attrs = listenerNode.getAttributes();
        boolean incValue = DomConfigHelper.getBooleanValue(getTextContent(attrs.getNamedItem("include-value")));
        boolean local = DomConfigHelper.getBooleanValue(getTextContent(attrs.getNamedItem("local")));
        String listenerClass = getTextContent(listenerNode);
        configAddFunction.apply(new EntryListenerConfig(listenerClass, local, incValue));
      } 
    } 
  }
  
  protected void handleReplicatedMap(Node node) throws Exception {
    Node attName = node.getAttributes().getNamedItem("name");
    String name = getTextContent(attName);
    ReplicatedMapConfig replicatedMapConfig = new ReplicatedMapConfig();
    replicatedMapConfig.setName(name);
    handleReplicatedMapNode(node, replicatedMapConfig);
  }
  
  void handleReplicatedMapNode(Node node, ReplicatedMapConfig replicatedMapConfig) {
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      String value = getTextContent(n).trim();
      if ("concurrency-level".equals(nodeName)) {
        replicatedMapConfig.setConcurrencyLevel(DomConfigHelper.getIntegerValue("concurrency-level", value));
        continue;
      } 
      if ("in-memory-format".equals(nodeName)) {
        replicatedMapConfig.setInMemoryFormat(InMemoryFormat.valueOf(StringUtil.upperCaseInternal(value)));
        continue;
      } 
      if ("replication-delay-millis".equals(nodeName)) {
        replicatedMapConfig.setReplicationDelayMillis(DomConfigHelper.getIntegerValue("replication-delay-millis", value));
        continue;
      } 
      if ("async-fillup".equals(nodeName)) {
        replicatedMapConfig.setAsyncFillup(DomConfigHelper.getBooleanValue(value));
        continue;
      } 
      if ("statistics-enabled".equals(nodeName)) {
        replicatedMapConfig.setStatisticsEnabled(DomConfigHelper.getBooleanValue(value));
        continue;
      } 
      if ("entry-listeners".equals(nodeName)) {
        handleEntryListeners(n, new Object(this, replicatedMapConfig));
        continue;
      } 
      if ("merge-policy".equals(nodeName)) {
        MergePolicyConfig mergePolicyConfig = createMergePolicyConfig(n);
        replicatedMapConfig.setMergePolicyConfig(mergePolicyConfig);
        continue;
      } 
      if ("quorum-ref".equals(nodeName))
        replicatedMapConfig.setQuorumName(value); 
    } 
    this.config.addReplicatedMapConfig(replicatedMapConfig);
  }
  
  protected void handleMap(Node parentNode) throws Exception {
    String name = getAttribute(parentNode, "name");
    MapConfig mapConfig = new MapConfig();
    mapConfig.setName(name);
    handleMapNode(parentNode, mapConfig);
  }
  
  void handleMapNode(Node parentNode, MapConfig mapConfig) {
    for (Node node : DomConfigHelper.childElements(parentNode)) {
      String nodeName = DomConfigHelper.cleanNodeName(node);
      String value = getTextContent(node).trim();
      if ("backup-count".equals(nodeName)) {
        mapConfig.setBackupCount(DomConfigHelper.getIntegerValue("backup-count", value));
        continue;
      } 
      if ("metadata-policy".equals(nodeName)) {
        mapConfig.setMetadataPolicy(MetadataPolicy.valueOf(StringUtil.upperCaseInternal(value)));
        continue;
      } 
      if ("in-memory-format".equals(nodeName)) {
        mapConfig.setInMemoryFormat(InMemoryFormat.valueOf(StringUtil.upperCaseInternal(value)));
        continue;
      } 
      if ("async-backup-count".equals(nodeName)) {
        mapConfig.setAsyncBackupCount(DomConfigHelper.getIntegerValue("async-backup-count", value));
        continue;
      } 
      if ("eviction-policy".equals(nodeName)) {
        mapConfig.setEvictionPolicy(EvictionPolicy.valueOf(StringUtil.upperCaseInternal(value)));
        continue;
      } 
      if ("max-size".equals(nodeName)) {
        handleMaxSizeConfig(mapConfig, node, value);
        continue;
      } 
      if ("eviction-percentage".equals(nodeName)) {
        mapConfig.setEvictionPercentage(DomConfigHelper.getIntegerValue("eviction-percentage", value));
        continue;
      } 
      if ("min-eviction-check-millis".equals(nodeName)) {
        mapConfig.setMinEvictionCheckMillis(DomConfigHelper.getLongValue("min-eviction-check-millis", value));
        continue;
      } 
      if ("time-to-live-seconds".equals(nodeName)) {
        mapConfig.setTimeToLiveSeconds(DomConfigHelper.getIntegerValue("time-to-live-seconds", value));
        continue;
      } 
      if ("max-idle-seconds".equals(nodeName)) {
        mapConfig.setMaxIdleSeconds(DomConfigHelper.getIntegerValue("max-idle-seconds", value));
        continue;
      } 
      if ("map-store".equals(nodeName)) {
        MapStoreConfig mapStoreConfig = createMapStoreConfig(node);
        mapConfig.setMapStoreConfig(mapStoreConfig);
        continue;
      } 
      if ("near-cache".equals(nodeName)) {
        mapConfig.setNearCacheConfig(handleNearCacheConfig(node));
        continue;
      } 
      if ("merge-policy".equals(nodeName)) {
        MergePolicyConfig mergePolicyConfig = createMergePolicyConfig(node);
        mapConfig.setMergePolicyConfig(mergePolicyConfig);
        continue;
      } 
      if ("hot-restart".equals(nodeName)) {
        mapConfig.setHotRestartConfig(createHotRestartConfig(node));
        continue;
      } 
      if ("read-backup-data".equals(nodeName)) {
        mapConfig.setReadBackupData(DomConfigHelper.getBooleanValue(value));
        continue;
      } 
      if ("statistics-enabled".equals(nodeName)) {
        mapConfig.setStatisticsEnabled(DomConfigHelper.getBooleanValue(value));
        continue;
      } 
      if ("optimize-queries".equals(nodeName)) {
        mapConfig.setOptimizeQueries(DomConfigHelper.getBooleanValue(value));
        continue;
      } 
      if ("cache-deserialized-values".equals(nodeName)) {
        CacheDeserializedValues cacheDeserializedValues = CacheDeserializedValues.parseString(value);
        mapConfig.setCacheDeserializedValues(cacheDeserializedValues);
        continue;
      } 
      if ("wan-replication-ref".equals(nodeName)) {
        mapWanReplicationRefHandle(node, mapConfig);
        continue;
      } 
      if ("indexes".equals(nodeName)) {
        mapIndexesHandle(node, mapConfig);
        continue;
      } 
      if ("attributes".equals(nodeName)) {
        mapAttributesHandle(node, mapConfig);
        continue;
      } 
      if ("entry-listeners".equals(nodeName)) {
        handleEntryListeners(node, new Object(this, mapConfig));
        continue;
      } 
      if ("partition-lost-listeners".equals(nodeName)) {
        mapPartitionLostListenerHandle(node, mapConfig);
        continue;
      } 
      if ("partition-strategy".equals(nodeName)) {
        mapConfig.setPartitioningStrategyConfig(new PartitioningStrategyConfig(value));
        continue;
      } 
      if ("quorum-ref".equals(nodeName)) {
        mapConfig.setQuorumName(value);
        continue;
      } 
      if ("query-caches".equals(nodeName)) {
        mapQueryCacheHandler(node, mapConfig);
        continue;
      } 
      if ("map-eviction-policy-class-name".equals(nodeName)) {
        String className = Preconditions.checkHasText(getTextContent(node), "map-eviction-policy-class-name cannot be null or empty");
        try {
          MapEvictionPolicy mapEvictionPolicy = (MapEvictionPolicy)ClassLoaderUtil.newInstance(this.config.getClassLoader(), className);
          mapConfig.setMapEvictionPolicy(mapEvictionPolicy);
        } catch (Exception e) {
          throw ExceptionUtil.rethrow(e);
        } 
      } 
    } 
    this.config.addMapConfig(mapConfig);
  }
  
  protected void handleMaxSizeConfig(MapConfig mapConfig, Node node, String value) {
    MaxSizeConfig msc = mapConfig.getMaxSizeConfig();
    Node maxSizePolicy = node.getAttributes().getNamedItem("policy");
    if (maxSizePolicy != null)
      msc.setMaxSizePolicy(MaxSizeConfig.MaxSizePolicy.valueOf(
            StringUtil.upperCaseInternal(getTextContent(maxSizePolicy)))); 
    msc.setSize(DomConfigHelper.getIntegerValue("max-size", value));
  }
  
  private NearCacheConfig handleNearCacheConfig(Node node) {
    String name = getAttribute(node, "name");
    NearCacheConfig nearCacheConfig = new NearCacheConfig(name);
    Boolean serializeKeys = null;
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      String value = getTextContent(child).trim();
      if ("max-size".equals(nodeName)) {
        nearCacheConfig.setMaxSize(Integer.parseInt(value));
        LOGGER.warning("The element <max-size/> for <near-cache/> is deprecated, please use <eviction/> instead!");
        continue;
      } 
      if ("time-to-live-seconds".equals(nodeName)) {
        nearCacheConfig.setTimeToLiveSeconds(Integer.parseInt(value));
        continue;
      } 
      if ("max-idle-seconds".equals(nodeName)) {
        nearCacheConfig.setMaxIdleSeconds(Integer.parseInt(value));
        continue;
      } 
      if ("eviction-policy".equals(nodeName)) {
        nearCacheConfig.setEvictionPolicy(value);
        LOGGER.warning("The element <eviction-policy/> for <near-cache/> is deprecated, please use <eviction/> instead!");
        continue;
      } 
      if ("in-memory-format".equals(nodeName)) {
        nearCacheConfig.setInMemoryFormat(InMemoryFormat.valueOf(StringUtil.upperCaseInternal(value)));
        continue;
      } 
      if ("serialize-keys".equals(nodeName)) {
        serializeKeys = Boolean.valueOf(Boolean.parseBoolean(value));
        nearCacheConfig.setSerializeKeys(serializeKeys.booleanValue());
        continue;
      } 
      if ("invalidate-on-change".equals(nodeName)) {
        nearCacheConfig.setInvalidateOnChange(Boolean.parseBoolean(value));
        continue;
      } 
      if ("cache-local-entries".equals(nodeName)) {
        nearCacheConfig.setCacheLocalEntries(Boolean.parseBoolean(value));
        continue;
      } 
      if ("local-update-policy".equals(nodeName)) {
        NearCacheConfig.LocalUpdatePolicy policy = NearCacheConfig.LocalUpdatePolicy.valueOf(value);
        nearCacheConfig.setLocalUpdatePolicy(policy);
        continue;
      } 
      if ("eviction".equals(nodeName))
        nearCacheConfig.setEvictionConfig(getEvictionConfig(child, true)); 
    } 
    if (serializeKeys != null && !serializeKeys.booleanValue() && nearCacheConfig.getInMemoryFormat() == InMemoryFormat.NATIVE)
      LOGGER.warning("The Near Cache doesn't support keys by-reference with NATIVE in-memory-format. This setting will have no effect!"); 
    return nearCacheConfig;
  }
  
  private HotRestartConfig createHotRestartConfig(Node node) {
    HotRestartConfig hotRestartConfig = new HotRestartConfig();
    Node attrEnabled = node.getAttributes().getNamedItem("enabled");
    boolean enabled = DomConfigHelper.getBooleanValue(getTextContent(attrEnabled));
    hotRestartConfig.setEnabled(enabled);
    for (Node n : DomConfigHelper.childElements(node)) {
      String name = DomConfigHelper.cleanNodeName(n);
      if ("fsync".equals(name))
        hotRestartConfig.setFsync(DomConfigHelper.getBooleanValue(getTextContent(n))); 
    } 
    return hotRestartConfig;
  }
  
  protected void handleCache(Node node) throws Exception {
    String name = getAttribute(node, "name");
    CacheSimpleConfig cacheConfig = new CacheSimpleConfig();
    cacheConfig.setName(name);
    handleCacheNode(node, cacheConfig);
  }
  
  void handleCacheNode(Node node, CacheSimpleConfig cacheConfig) {
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      String value = getTextContent(n).trim();
      if ("key-type".equals(nodeName)) {
        cacheConfig.setKeyType(getAttribute(n, "class-name"));
        continue;
      } 
      if ("value-type".equals(nodeName)) {
        cacheConfig.setValueType(getAttribute(n, "class-name"));
        continue;
      } 
      if ("statistics-enabled".equals(nodeName)) {
        cacheConfig.setStatisticsEnabled(DomConfigHelper.getBooleanValue(value));
        continue;
      } 
      if ("management-enabled".equals(nodeName)) {
        cacheConfig.setManagementEnabled(DomConfigHelper.getBooleanValue(value));
        continue;
      } 
      if ("read-through".equals(nodeName)) {
        cacheConfig.setReadThrough(DomConfigHelper.getBooleanValue(value));
        continue;
      } 
      if ("write-through".equals(nodeName)) {
        cacheConfig.setWriteThrough(DomConfigHelper.getBooleanValue(value));
        continue;
      } 
      if ("cache-loader-factory".equals(nodeName)) {
        cacheConfig.setCacheLoaderFactory(getAttribute(n, "class-name"));
        continue;
      } 
      if ("cache-loader".equals(nodeName)) {
        cacheConfig.setCacheLoader(getAttribute(n, "class-name"));
        continue;
      } 
      if ("cache-writer-factory".equals(nodeName)) {
        cacheConfig.setCacheWriterFactory(getAttribute(n, "class-name"));
        continue;
      } 
      if ("cache-writer".equals(nodeName)) {
        cacheConfig.setCacheWriter(getAttribute(n, "class-name"));
        continue;
      } 
      if ("expiry-policy-factory".equals(nodeName)) {
        cacheConfig.setExpiryPolicyFactoryConfig(getExpiryPolicyFactoryConfig(n));
        continue;
      } 
      if ("cache-entry-listeners".equals(nodeName)) {
        cacheListenerHandle(n, cacheConfig);
        continue;
      } 
      if ("in-memory-format".equals(nodeName)) {
        cacheConfig.setInMemoryFormat(InMemoryFormat.valueOf(StringUtil.upperCaseInternal(value)));
        continue;
      } 
      if ("backup-count".equals(nodeName)) {
        cacheConfig.setBackupCount(DomConfigHelper.getIntegerValue("backup-count", value));
        continue;
      } 
      if ("async-backup-count".equals(nodeName)) {
        cacheConfig.setAsyncBackupCount(DomConfigHelper.getIntegerValue("async-backup-count", value));
        continue;
      } 
      if ("wan-replication-ref".equals(nodeName)) {
        cacheWanReplicationRefHandle(n, cacheConfig);
        continue;
      } 
      if ("eviction".equals(nodeName)) {
        cacheConfig.setEvictionConfig(getEvictionConfig(n, false));
        continue;
      } 
      if ("quorum-ref".equals(nodeName)) {
        cacheConfig.setQuorumName(value);
        continue;
      } 
      if ("partition-lost-listeners".equals(nodeName)) {
        cachePartitionLostListenerHandle(n, cacheConfig);
        continue;
      } 
      if ("merge-policy".equals(nodeName)) {
        cacheConfig.setMergePolicy(value);
        continue;
      } 
      if ("hot-restart".equals(nodeName)) {
        cacheConfig.setHotRestartConfig(createHotRestartConfig(n));
        continue;
      } 
      if ("disable-per-entry-invalidation-events".equals(nodeName))
        cacheConfig.setDisablePerEntryInvalidationEvents(DomConfigHelper.getBooleanValue(value)); 
    } 
    try {
      ConfigValidator.checkCacheConfig(cacheConfig, null);
    } catch (IllegalArgumentException e) {
      throw new InvalidConfigurationException(e.getMessage());
    } 
    this.config.addCacheConfig(cacheConfig);
  }
  
  private CacheSimpleConfig.ExpiryPolicyFactoryConfig getExpiryPolicyFactoryConfig(Node node) {
    String className = getAttribute(node, "class-name");
    if (!StringUtil.isNullOrEmpty(className))
      return new CacheSimpleConfig.ExpiryPolicyFactoryConfig(className); 
    CacheSimpleConfig.ExpiryPolicyFactoryConfig.TimedExpiryPolicyFactoryConfig timedExpiryPolicyFactoryConfig = null;
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      if ("timed-expiry-policy-factory".equals(nodeName))
        timedExpiryPolicyFactoryConfig = getTimedExpiryPolicyFactoryConfig(n); 
    } 
    if (timedExpiryPolicyFactoryConfig == null)
      throw new InvalidConfigurationException("One of the \"class-name\" or \"timed-expire-policy-factory\" configuration is needed for expiry policy factory configuration"); 
    return new CacheSimpleConfig.ExpiryPolicyFactoryConfig(timedExpiryPolicyFactoryConfig);
  }
  
  private CacheSimpleConfig.ExpiryPolicyFactoryConfig.TimedExpiryPolicyFactoryConfig getTimedExpiryPolicyFactoryConfig(Node node) {
    String expiryPolicyTypeStr = getAttribute(node, "expiry-policy-type");
    String durationAmountStr = getAttribute(node, "duration-amount");
    String timeUnitStr = getAttribute(node, "time-unit");
    CacheSimpleConfig.ExpiryPolicyFactoryConfig.TimedExpiryPolicyFactoryConfig.ExpiryPolicyType expiryPolicyType = CacheSimpleConfig.ExpiryPolicyFactoryConfig.TimedExpiryPolicyFactoryConfig.ExpiryPolicyType.valueOf(StringUtil.upperCaseInternal(expiryPolicyTypeStr));
    if (expiryPolicyType != CacheSimpleConfig.ExpiryPolicyFactoryConfig.TimedExpiryPolicyFactoryConfig.ExpiryPolicyType.ETERNAL && (StringUtil.isNullOrEmpty(durationAmountStr) || StringUtil.isNullOrEmpty(timeUnitStr)))
      throw new InvalidConfigurationException("Both of the \"duration-amount\" or \"time-unit\" attributes are required for expiry policy factory configuration (except \"ETERNAL\" expiry policy type)"); 
    CacheSimpleConfig.ExpiryPolicyFactoryConfig.DurationConfig durationConfig = null;
    if (expiryPolicyType != CacheSimpleConfig.ExpiryPolicyFactoryConfig.TimedExpiryPolicyFactoryConfig.ExpiryPolicyType.ETERNAL) {
      TimeUnit timeUnit;
      long durationAmount;
      try {
        durationAmount = Long.parseLong(durationAmountStr);
      } catch (NumberFormatException e) {
        throw new InvalidConfigurationException("Invalid value for duration amount: " + durationAmountStr, timeUnit);
      } 
      if (durationAmount <= 0L)
        throw new InvalidConfigurationException("Duration amount must be positive: " + durationAmount); 
      try {
        timeUnit = TimeUnit.valueOf(StringUtil.upperCaseInternal(timeUnitStr));
      } catch (IllegalArgumentException e) {
        throw new InvalidConfigurationException("Invalid value for time unit: " + timeUnitStr, e);
      } 
      durationConfig = new CacheSimpleConfig.ExpiryPolicyFactoryConfig.DurationConfig(durationAmount, timeUnit);
    } 
    return new CacheSimpleConfig.ExpiryPolicyFactoryConfig.TimedExpiryPolicyFactoryConfig(expiryPolicyType, durationConfig);
  }
  
  private EvictionConfig getEvictionConfig(Node node, boolean isNearCache) {
    EvictionConfig evictionConfig = new EvictionConfig();
    Node size = node.getAttributes().getNamedItem("size");
    Node maxSizePolicy = node.getAttributes().getNamedItem("max-size-policy");
    Node evictionPolicy = node.getAttributes().getNamedItem("eviction-policy");
    Node comparatorClassName = node.getAttributes().getNamedItem("comparator-class-name");
    if (size != null)
      evictionConfig.setSize(Integer.parseInt(getTextContent(size))); 
    if (maxSizePolicy != null)
      evictionConfig
        .setMaximumSizePolicy(EvictionConfig.MaxSizePolicy.valueOf(StringUtil.upperCaseInternal(getTextContent(maxSizePolicy)))); 
    if (evictionPolicy != null)
      evictionConfig.setEvictionPolicy(EvictionPolicy.valueOf(StringUtil.upperCaseInternal(getTextContent(evictionPolicy)))); 
    if (comparatorClassName != null)
      evictionConfig.setComparatorClassName(getTextContent(comparatorClassName)); 
    try {
      ConfigValidator.checkEvictionConfig(evictionConfig, isNearCache);
    } catch (IllegalArgumentException e) {
      throw new InvalidConfigurationException(e.getMessage());
    } 
    return evictionConfig;
  }
  
  private void cacheWanReplicationRefHandle(Node n, CacheSimpleConfig cacheConfig) {
    WanReplicationRef wanReplicationRef = new WanReplicationRef();
    String wanName = getAttribute(n, "name");
    wanReplicationRef.setName(wanName);
    for (Node wanChild : DomConfigHelper.childElements(n)) {
      String wanChildName = DomConfigHelper.cleanNodeName(wanChild);
      String wanChildValue = getTextContent(wanChild);
      if ("merge-policy".equals(wanChildName)) {
        wanReplicationRef.setMergePolicy(wanChildValue);
        continue;
      } 
      if ("filters".equals(wanChildName)) {
        handleWanFilters(wanChild, wanReplicationRef);
        continue;
      } 
      if ("republishing-enabled".equals(wanChildName))
        wanReplicationRef.setRepublishingEnabled(DomConfigHelper.getBooleanValue(wanChildValue)); 
    } 
    cacheConfig.setWanReplicationRef(wanReplicationRef);
  }
  
  protected void handleWanFilters(Node wanChild, WanReplicationRef wanReplicationRef) {
    for (Node filter : DomConfigHelper.childElements(wanChild)) {
      if ("filter-impl".equals(DomConfigHelper.cleanNodeName(filter)))
        wanReplicationRef.addFilter(getTextContent(filter)); 
    } 
  }
  
  protected void cachePartitionLostListenerHandle(Node n, CacheSimpleConfig cacheConfig) {
    for (Node listenerNode : DomConfigHelper.childElements(n)) {
      if ("partition-lost-listener".equals(DomConfigHelper.cleanNodeName(listenerNode))) {
        String listenerClass = getTextContent(listenerNode);
        cacheConfig.addCachePartitionLostListenerConfig(new CachePartitionLostListenerConfig(listenerClass));
      } 
    } 
  }
  
  protected void cacheListenerHandle(Node n, CacheSimpleConfig cacheSimpleConfig) {
    for (Node listenerNode : DomConfigHelper.childElements(n)) {
      if ("cache-entry-listener".equals(DomConfigHelper.cleanNodeName(listenerNode)))
        handleCacheEntryListenerNode(cacheSimpleConfig, listenerNode); 
    } 
  }
  
  protected void handleCacheEntryListenerNode(CacheSimpleConfig cacheSimpleConfig, Node listenerNode) {
    CacheSimpleEntryListenerConfig listenerConfig = new CacheSimpleEntryListenerConfig();
    for (Node listenerChildNode : DomConfigHelper.childElements(listenerNode)) {
      if ("cache-entry-listener-factory".equals(DomConfigHelper.cleanNodeName(listenerChildNode)))
        listenerConfig.setCacheEntryListenerFactory(getAttribute(listenerChildNode, "class-name")); 
      if ("cache-entry-event-filter-factory".equals(DomConfigHelper.cleanNodeName(listenerChildNode)))
        listenerConfig.setCacheEntryEventFilterFactory(getAttribute(listenerChildNode, "class-name")); 
    } 
    NamedNodeMap attrs = listenerNode.getAttributes();
    listenerConfig.setOldValueRequired(DomConfigHelper.getBooleanValue(getTextContent(attrs.getNamedItem("old-value-required"))));
    listenerConfig.setSynchronous(DomConfigHelper.getBooleanValue(getTextContent(attrs.getNamedItem("synchronous"))));
    cacheSimpleConfig.addEntryListenerConfig(listenerConfig);
  }
  
  protected void mapWanReplicationRefHandle(Node n, MapConfig mapConfig) {
    WanReplicationRef wanReplicationRef = new WanReplicationRef();
    String wanName = getAttribute(n, "name");
    wanReplicationRef.setName(wanName);
    handleMapWanReplicationRefNode(n, mapConfig, wanReplicationRef);
  }
  
  void handleMapWanReplicationRefNode(Node n, MapConfig mapConfig, WanReplicationRef wanReplicationRef) {
    for (Node wanChild : DomConfigHelper.childElements(n)) {
      String wanChildName = DomConfigHelper.cleanNodeName(wanChild);
      String wanChildValue = getTextContent(wanChild);
      if ("merge-policy".equals(wanChildName)) {
        wanReplicationRef.setMergePolicy(wanChildValue);
        continue;
      } 
      if ("republishing-enabled".equals(wanChildName)) {
        wanReplicationRef.setRepublishingEnabled(DomConfigHelper.getBooleanValue(wanChildValue));
        continue;
      } 
      if ("filters".equals(wanChildName))
        handleWanFilters(wanChild, wanReplicationRef); 
    } 
    mapConfig.setWanReplicationRef(wanReplicationRef);
  }
  
  protected void mapIndexesHandle(Node n, MapConfig mapConfig) {
    for (Node indexNode : DomConfigHelper.childElements(n)) {
      if ("index".equals(DomConfigHelper.cleanNodeName(indexNode))) {
        NamedNodeMap attrs = indexNode.getAttributes();
        boolean ordered = DomConfigHelper.getBooleanValue(getTextContent(attrs.getNamedItem("ordered")));
        String attribute = getTextContent(indexNode);
        mapConfig.addMapIndexConfig(new MapIndexConfig(attribute, ordered));
      } 
    } 
  }
  
  protected void queryCacheIndexesHandle(Node n, QueryCacheConfig queryCacheConfig) {
    for (Node indexNode : DomConfigHelper.childElements(n)) {
      if ("index".equals(DomConfigHelper.cleanNodeName(indexNode))) {
        NamedNodeMap attrs = indexNode.getAttributes();
        boolean ordered = DomConfigHelper.getBooleanValue(getTextContent(attrs.getNamedItem("ordered")));
        String attribute = getTextContent(indexNode);
        queryCacheConfig.addIndexConfig(new MapIndexConfig(attribute, ordered));
      } 
    } 
  }
  
  protected void mapAttributesHandle(Node n, MapConfig mapConfig) {
    for (Node extractorNode : DomConfigHelper.childElements(n)) {
      if ("attribute".equals(DomConfigHelper.cleanNodeName(extractorNode))) {
        NamedNodeMap attrs = extractorNode.getAttributes();
        String extractor = getTextContent(attrs.getNamedItem("extractor"));
        String name = getTextContent(extractorNode);
        mapConfig.addMapAttributeConfig(new MapAttributeConfig(name, extractor));
      } 
    } 
  }
  
  protected void mapPartitionLostListenerHandle(Node n, MapConfig mapConfig) {
    for (Node listenerNode : DomConfigHelper.childElements(n)) {
      if ("partition-lost-listener".equals(DomConfigHelper.cleanNodeName(listenerNode))) {
        String listenerClass = getTextContent(listenerNode);
        mapConfig.addMapPartitionLostListenerConfig(new MapPartitionLostListenerConfig(listenerClass));
      } 
    } 
  }
  
  protected void mapQueryCacheHandler(Node n, MapConfig mapConfig) {
    for (Node queryCacheNode : DomConfigHelper.childElements(n)) {
      if ("query-cache".equals(DomConfigHelper.cleanNodeName(queryCacheNode))) {
        NamedNodeMap attrs = queryCacheNode.getAttributes();
        String cacheName = getTextContent(attrs.getNamedItem("name"));
        QueryCacheConfig queryCacheConfig = new QueryCacheConfig(cacheName);
        handleMapQueryCacheNode(mapConfig, queryCacheNode, queryCacheConfig);
      } 
    } 
  }
  
  void handleMapQueryCacheNode(MapConfig mapConfig, Node queryCacheNode, QueryCacheConfig queryCacheConfig) {
    for (Node childNode : DomConfigHelper.childElements(queryCacheNode)) {
      String nodeName = DomConfigHelper.cleanNodeName(childNode);
      if ("entry-listeners".equals(nodeName)) {
        handleEntryListeners(childNode, new Object(this, queryCacheConfig));
        continue;
      } 
      String textContent = getTextContent(childNode);
      if ("include-value".equals(nodeName)) {
        boolean includeValue = DomConfigHelper.getBooleanValue(textContent);
        queryCacheConfig.setIncludeValue(includeValue);
        continue;
      } 
      if ("batch-size".equals(nodeName)) {
        int batchSize = DomConfigHelper.getIntegerValue("batch-size", textContent.trim());
        queryCacheConfig.setBatchSize(batchSize);
        continue;
      } 
      if ("buffer-size".equals(nodeName)) {
        int bufferSize = DomConfigHelper.getIntegerValue("buffer-size", textContent.trim());
        queryCacheConfig.setBufferSize(bufferSize);
        continue;
      } 
      if ("delay-seconds".equals(nodeName)) {
        int delaySeconds = DomConfigHelper.getIntegerValue("delay-seconds", textContent.trim());
        queryCacheConfig.setDelaySeconds(delaySeconds);
        continue;
      } 
      if ("in-memory-format".equals(nodeName)) {
        String value = textContent.trim();
        queryCacheConfig.setInMemoryFormat(InMemoryFormat.valueOf(StringUtil.upperCaseInternal(value)));
        continue;
      } 
      if ("coalesce".equals(nodeName)) {
        boolean coalesce = DomConfigHelper.getBooleanValue(textContent);
        queryCacheConfig.setCoalesce(coalesce);
        continue;
      } 
      if ("populate".equals(nodeName)) {
        boolean populate = DomConfigHelper.getBooleanValue(textContent);
        queryCacheConfig.setPopulate(populate);
        continue;
      } 
      if ("indexes".equals(nodeName)) {
        queryCacheIndexesHandle(childNode, queryCacheConfig);
        continue;
      } 
      if ("predicate".equals(nodeName)) {
        queryCachePredicateHandler(childNode, queryCacheConfig);
        continue;
      } 
      if ("eviction".equals(nodeName))
        queryCacheConfig.setEvictionConfig(getEvictionConfig(childNode, false)); 
    } 
    mapConfig.addQueryCacheConfig(queryCacheConfig);
  }
  
  protected void queryCachePredicateHandler(Node childNode, QueryCacheConfig queryCacheConfig) {
    NamedNodeMap predicateAttributes = childNode.getAttributes();
    String predicateType = getTextContent(predicateAttributes.getNamedItem("type"));
    String textContent = getTextContent(childNode);
    PredicateConfig predicateConfig = new PredicateConfig();
    if ("class-name".equals(predicateType)) {
      predicateConfig.setClassName(textContent);
    } else if ("sql".equals(predicateType)) {
      predicateConfig.setSql(textContent);
    } 
    queryCacheConfig.setPredicateConfig(predicateConfig);
  }
  
  private MapStoreConfig createMapStoreConfig(Node node) {
    MapStoreConfig mapStoreConfig = new MapStoreConfig();
    NamedNodeMap attributes = node.getAttributes();
    for (int a = 0; a < attributes.getLength(); a++) {
      Node att = attributes.item(a);
      String value = getTextContent(att).trim();
      if ("enabled".equals(att.getNodeName())) {
        mapStoreConfig.setEnabled(DomConfigHelper.getBooleanValue(value));
      } else if ("initial-mode".equals(att.getNodeName())) {
        MapStoreConfig.InitialLoadMode mode = MapStoreConfig.InitialLoadMode.valueOf(StringUtil.upperCaseInternal(getTextContent(att)));
        mapStoreConfig.setInitialLoadMode(mode);
      } 
    } 
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      if ("class-name".equals(nodeName)) {
        mapStoreConfig.setClassName(getTextContent(n).trim());
        continue;
      } 
      if ("factory-class-name".equals(nodeName)) {
        mapStoreConfig.setFactoryClassName(getTextContent(n).trim());
        continue;
      } 
      if ("write-delay-seconds".equals(nodeName)) {
        mapStoreConfig.setWriteDelaySeconds(DomConfigHelper.getIntegerValue("write-delay-seconds", getTextContent(n).trim()));
        continue;
      } 
      if ("write-batch-size".equals(nodeName)) {
        mapStoreConfig.setWriteBatchSize(DomConfigHelper.getIntegerValue("write-batch-size", getTextContent(n).trim()));
        continue;
      } 
      if ("write-coalescing".equals(nodeName)) {
        String writeCoalescing = getTextContent(n).trim();
        if (StringUtil.isNullOrEmpty(writeCoalescing)) {
          mapStoreConfig.setWriteCoalescing(true);
          continue;
        } 
        mapStoreConfig.setWriteCoalescing(DomConfigHelper.getBooleanValue(writeCoalescing));
        continue;
      } 
      if ("properties".equals(nodeName))
        fillProperties(n, mapStoreConfig.getProperties()); 
    } 
    return mapStoreConfig;
  }
  
  private RingbufferStoreConfig createRingbufferStoreConfig(Node node) {
    RingbufferStoreConfig config = new RingbufferStoreConfig();
    NamedNodeMap attributes = node.getAttributes();
    for (int a = 0; a < attributes.getLength(); a++) {
      Node att = attributes.item(a);
      String value = getTextContent(att).trim();
      if (att.getNodeName().equals("enabled"))
        config.setEnabled(DomConfigHelper.getBooleanValue(value)); 
    } 
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      if ("class-name".equals(nodeName)) {
        config.setClassName(getTextContent(n).trim());
        continue;
      } 
      if ("factory-class-name".equals(nodeName)) {
        config.setFactoryClassName(getTextContent(n).trim());
        continue;
      } 
      if ("properties".equals(nodeName))
        fillProperties(n, config.getProperties()); 
    } 
    return config;
  }
  
  protected MergePolicyConfig createMergePolicyConfig(Node node) {
    MergePolicyConfig mergePolicyConfig = new MergePolicyConfig();
    String policyString = getTextContent(node).trim();
    mergePolicyConfig.setPolicy(policyString);
    String att = getAttribute(node, "batch-size");
    if (att != null)
      mergePolicyConfig.setBatchSize(DomConfigHelper.getIntegerValue("batch-size", att)); 
    return mergePolicyConfig;
  }
  
  private QueueStoreConfig createQueueStoreConfig(Node node) {
    QueueStoreConfig queueStoreConfig = new QueueStoreConfig();
    NamedNodeMap attributes = node.getAttributes();
    for (int a = 0; a < attributes.getLength(); a++) {
      Node att = attributes.item(a);
      String value = getTextContent(att).trim();
      if (att.getNodeName().equals("enabled"))
        queueStoreConfig.setEnabled(DomConfigHelper.getBooleanValue(value)); 
    } 
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      if ("class-name".equals(nodeName)) {
        queueStoreConfig.setClassName(getTextContent(n).trim());
        continue;
      } 
      if ("factory-class-name".equals(nodeName)) {
        queueStoreConfig.setFactoryClassName(getTextContent(n).trim());
        continue;
      } 
      if ("properties".equals(nodeName))
        fillProperties(n, queueStoreConfig.getProperties()); 
    } 
    return queueStoreConfig;
  }
  
  private void handleSSLConfig(Node node) throws Exception {
    SSLConfig sslConfig = parseSslConfig(node);
    this.config.getNetworkConfig().setSSLConfig(sslConfig);
  }
  
  private void handleSSLConfig(Node node, EndpointConfig endpointConfig) {
    SSLConfig sslConfig = parseSslConfig(node);
    endpointConfig.setSSLConfig(sslConfig);
  }
  
  private void handleMcMutualAuthConfig(Node node) throws Exception {
    MCMutualAuthConfig mcMutualAuthConfig = new MCMutualAuthConfig();
    NamedNodeMap attributes = node.getAttributes();
    Node enabledNode = attributes.getNamedItem("enabled");
    boolean enabled = (enabledNode != null && DomConfigHelper.getBooleanValue(getTextContent(enabledNode).trim()));
    mcMutualAuthConfig.setEnabled(enabled);
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      if ("factory-class-name".equals(nodeName)) {
        mcMutualAuthConfig.setFactoryClassName(getTextContent(n).trim());
        continue;
      } 
      if ("properties".equals(nodeName))
        fillProperties(n, mcMutualAuthConfig.getProperties()); 
    } 
    this.config.getManagementCenterConfig().setMutualAuthConfig(mcMutualAuthConfig);
  }
  
  private void handleMemberAddressProvider(Node node, boolean advancedNetworkConfig) {
    MemberAddressProviderConfig memberAddressProviderConfig = memberAddressProviderConfig(advancedNetworkConfig);
    Node enabledNode = node.getAttributes().getNamedItem("enabled");
    boolean enabled = (enabledNode != null && DomConfigHelper.getBooleanValue(getTextContent(enabledNode)));
    memberAddressProviderConfig.setEnabled(enabled);
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      if (nodeName.equals("class-name")) {
        String className = getTextContent(n);
        memberAddressProviderConfig.setClassName(className);
        continue;
      } 
      if (nodeName.equals("properties"))
        fillProperties(n, memberAddressProviderConfig.getProperties()); 
    } 
  }
  
  private MemberAddressProviderConfig memberAddressProviderConfig(boolean advancedNetworkConfig) {
    return advancedNetworkConfig ? this.config
      .getAdvancedNetworkConfig().getMemberAddressProviderConfig() : this.config
      .getNetworkConfig().getMemberAddressProviderConfig();
  }
  
  private void handleFailureDetector(Node node, boolean advancedNetworkConfig) {
    if (!node.hasChildNodes())
      return; 
    for (Node child : DomConfigHelper.childElements(node)) {
      if (!DomConfigHelper.cleanNodeName(child).equals("icmp"))
        throw new IllegalStateException("Unsupported child under failure-detector"); 
      Node enabledNode = child.getAttributes().getNamedItem("enabled");
      boolean enabled = (enabledNode != null && DomConfigHelper.getBooleanValue(getTextContent(enabledNode)));
      IcmpFailureDetectorConfig icmpFailureDetectorConfig = new IcmpFailureDetectorConfig();
      icmpFailureDetectorConfig.setEnabled(enabled);
      for (Node n : DomConfigHelper.childElements(child)) {
        String nodeName = DomConfigHelper.cleanNodeName(n);
        if (nodeName.equals("ttl")) {
          int ttl = Integer.parseInt(getTextContent(n));
          icmpFailureDetectorConfig.setTtl(ttl);
          continue;
        } 
        if (nodeName.equals("timeout-milliseconds")) {
          int timeout = Integer.parseInt(getTextContent(n));
          icmpFailureDetectorConfig.setTimeoutMilliseconds(timeout);
          continue;
        } 
        if (nodeName.equals("parallel-mode")) {
          boolean mode = Boolean.parseBoolean(getTextContent(n));
          icmpFailureDetectorConfig.setParallelMode(mode);
          continue;
        } 
        if (nodeName.equals("fail-fast-on-startup")) {
          boolean failOnStartup = Boolean.parseBoolean(getTextContent(n));
          icmpFailureDetectorConfig.setFailFastOnStartup(failOnStartup);
          continue;
        } 
        if (nodeName.equals("max-attempts")) {
          int attempts = Integer.parseInt(getTextContent(n));
          icmpFailureDetectorConfig.setMaxAttempts(attempts);
          continue;
        } 
        if (nodeName.equals("interval-milliseconds")) {
          int interval = Integer.parseInt(getTextContent(n));
          icmpFailureDetectorConfig.setIntervalMilliseconds(interval);
        } 
      } 
      if (advancedNetworkConfig) {
        this.config.getAdvancedNetworkConfig().setIcmpFailureDetectorConfig(icmpFailureDetectorConfig);
        continue;
      } 
      this.config.getNetworkConfig().setIcmpFailureDetectorConfig(icmpFailureDetectorConfig);
    } 
  }
  
  private void handleSocketInterceptorConfig(Node node) throws Exception {
    SocketInterceptorConfig socketInterceptorConfig = parseSocketInterceptorConfig(node);
    this.config.getNetworkConfig().setSocketInterceptorConfig(socketInterceptorConfig);
  }
  
  private void handleSocketInterceptorConfig(Node node, EndpointConfig endpointConfig) {
    SocketInterceptorConfig socketInterceptorConfig = parseSocketInterceptorConfig(node);
    endpointConfig.setSocketInterceptorConfig(socketInterceptorConfig);
  }
  
  protected void handleTopic(Node node) throws Exception {
    Node attName = node.getAttributes().getNamedItem("name");
    String name = getTextContent(attName);
    TopicConfig tConfig = new TopicConfig();
    tConfig.setName(name);
    handleTopicNode(node, tConfig);
  }
  
  void handleTopicNode(Node node, TopicConfig tConfig) {
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      if (nodeName.equals("global-ordering-enabled")) {
        tConfig.setGlobalOrderingEnabled(DomConfigHelper.getBooleanValue(getTextContent(n)));
        continue;
      } 
      if ("message-listeners".equals(nodeName)) {
        handleMessageListeners(n, new Object(this, tConfig));
        continue;
      } 
      if ("statistics-enabled".equals(nodeName)) {
        tConfig.setStatisticsEnabled(DomConfigHelper.getBooleanValue(getTextContent(n)));
        continue;
      } 
      if ("multi-threading-enabled".equals(nodeName))
        tConfig.setMultiThreadingEnabled(DomConfigHelper.getBooleanValue(getTextContent(n))); 
    } 
    this.config.addTopicConfig(tConfig);
  }
  
  protected void handleReliableTopic(Node node) throws Exception {
    Node attName = node.getAttributes().getNamedItem("name");
    String name = getTextContent(attName);
    ReliableTopicConfig topicConfig = new ReliableTopicConfig(name);
    handleReliableTopicNode(node, topicConfig);
  }
  
  void handleReliableTopicNode(Node node, ReliableTopicConfig topicConfig) {
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      if ("read-batch-size".equals(nodeName)) {
        String batchSize = getTextContent(n);
        topicConfig.setReadBatchSize(DomConfigHelper.getIntegerValue("read-batch-size", batchSize));
        continue;
      } 
      if ("statistics-enabled".equals(nodeName)) {
        topicConfig.setStatisticsEnabled(DomConfigHelper.getBooleanValue(getTextContent(n)));
        continue;
      } 
      if ("topic-overload-policy".equals(nodeName)) {
        TopicOverloadPolicy topicOverloadPolicy = TopicOverloadPolicy.valueOf(StringUtil.upperCaseInternal(getTextContent(n)));
        topicConfig.setTopicOverloadPolicy(topicOverloadPolicy);
        continue;
      } 
      if ("message-listeners".equals(nodeName))
        handleMessageListeners(n, new Object(this, topicConfig)); 
    } 
    this.config.addReliableTopicConfig(topicConfig);
  }
  
  void handleMessageListeners(Node n, Function<ListenerConfig, Void> configAddFunction) {
    for (Node listenerNode : DomConfigHelper.childElements(n)) {
      if ("message-listener".equals(DomConfigHelper.cleanNodeName(listenerNode)))
        configAddFunction.apply(new ListenerConfig(getTextContent(listenerNode))); 
    } 
  }
  
  private void handleJobTracker(Node node) throws Exception {
    Node attName = node.getAttributes().getNamedItem("name");
    String name = getTextContent(attName);
    JobTrackerConfig jConfig = new JobTrackerConfig();
    jConfig.setName(name);
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      String value = getTextContent(n).trim();
      if ("max-thread-size".equals(nodeName)) {
        jConfig.setMaxThreadSize(DomConfigHelper.getIntegerValue("max-thread-size", value));
        continue;
      } 
      if ("queue-size".equals(nodeName)) {
        jConfig.setQueueSize(DomConfigHelper.getIntegerValue("queue-size", value));
        continue;
      } 
      if ("retry-count".equals(nodeName)) {
        jConfig.setRetryCount(DomConfigHelper.getIntegerValue("retry-count", value));
        continue;
      } 
      if ("chunk-size".equals(nodeName)) {
        jConfig.setChunkSize(DomConfigHelper.getIntegerValue("chunk-size", value));
        continue;
      } 
      if ("communicate-stats".equals(nodeName)) {
        jConfig.setCommunicateStats((value.length() == 0) ? true : Boolean.parseBoolean(value));
        continue;
      } 
      if ("topology-changed-strategy".equals(nodeName)) {
        TopologyChangedStrategy topologyChangedStrategy = JobTrackerConfig.DEFAULT_TOPOLOGY_CHANGED_STRATEGY;
        for (TopologyChangedStrategy temp : TopologyChangedStrategy.values()) {
          if (temp.name().equals(value))
            topologyChangedStrategy = temp; 
        } 
        jConfig.setTopologyChangedStrategy(topologyChangedStrategy);
      } 
    } 
    this.config.addJobTrackerConfig(jConfig);
  }
  
  protected void handleSemaphore(Node node) throws Exception {
    Node attName = node.getAttributes().getNamedItem("name");
    String name = getTextContent(attName);
    SemaphoreConfig sConfig = new SemaphoreConfig();
    sConfig.setName(name);
    handleSemaphoreNode(node, sConfig);
  }
  
  void handleSemaphoreNode(Node node, SemaphoreConfig sConfig) {
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      String value = getTextContent(n).trim();
      if ("initial-permits".equals(nodeName)) {
        sConfig.setInitialPermits(DomConfigHelper.getIntegerValue("initial-permits", value));
        continue;
      } 
      if ("backup-count".equals(nodeName)) {
        sConfig.setBackupCount(DomConfigHelper.getIntegerValue("backup-count", value));
        continue;
      } 
      if ("async-backup-count".equals(nodeName)) {
        sConfig.setAsyncBackupCount(DomConfigHelper.getIntegerValue("async-backup-count", value));
        continue;
      } 
      if ("quorum-ref".equals(nodeName))
        sConfig.setQuorumName(value); 
    } 
    this.config.addSemaphoreConfig(sConfig);
  }
  
  protected void handleEventJournal(Node node) throws Exception {
    EventJournalConfig journalConfig = new EventJournalConfig();
    handleViaReflection(node, this.config, journalConfig);
    this.config.addEventJournalConfig(journalConfig);
  }
  
  protected void handleMerkleTree(Node node) throws Exception {
    MerkleTreeConfig merkleTreeConfig = new MerkleTreeConfig();
    handleViaReflection(node, this.config, merkleTreeConfig);
    this.config.addMerkleTreeConfig(merkleTreeConfig);
  }
  
  protected void handleRingbuffer(Node node) throws Exception {
    Node attName = node.getAttributes().getNamedItem("name");
    String name = getTextContent(attName);
    RingbufferConfig rbConfig = new RingbufferConfig(name);
    handleRingBufferNode(node, rbConfig);
  }
  
  void handleRingBufferNode(Node node, RingbufferConfig rbConfig) {
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      String value = getTextContent(n).trim();
      if ("capacity".equals(nodeName)) {
        int capacity = DomConfigHelper.getIntegerValue("capacity", value);
        rbConfig.setCapacity(capacity);
        continue;
      } 
      if ("backup-count".equals(nodeName)) {
        int backupCount = DomConfigHelper.getIntegerValue("backup-count", value);
        rbConfig.setBackupCount(backupCount);
        continue;
      } 
      if ("async-backup-count".equals(nodeName)) {
        int asyncBackupCount = DomConfigHelper.getIntegerValue("async-backup-count", value);
        rbConfig.setAsyncBackupCount(asyncBackupCount);
        continue;
      } 
      if ("time-to-live-seconds".equals(nodeName)) {
        int timeToLiveSeconds = DomConfigHelper.getIntegerValue("time-to-live-seconds", value);
        rbConfig.setTimeToLiveSeconds(timeToLiveSeconds);
        continue;
      } 
      if ("in-memory-format".equals(nodeName)) {
        InMemoryFormat inMemoryFormat = InMemoryFormat.valueOf(StringUtil.upperCaseInternal(value));
        rbConfig.setInMemoryFormat(inMemoryFormat);
        continue;
      } 
      if ("ringbuffer-store".equals(nodeName)) {
        RingbufferStoreConfig ringbufferStoreConfig = createRingbufferStoreConfig(n);
        rbConfig.setRingbufferStoreConfig(ringbufferStoreConfig);
        continue;
      } 
      if ("quorum-ref".equals(nodeName)) {
        rbConfig.setQuorumName(value);
        continue;
      } 
      if ("merge-policy".equals(nodeName)) {
        MergePolicyConfig mergePolicyConfig = createMergePolicyConfig(n);
        rbConfig.setMergePolicyConfig(mergePolicyConfig);
      } 
    } 
    this.config.addRingBufferConfig(rbConfig);
  }
  
  protected void handleAtomicLong(Node node) throws Exception {
    Node attName = node.getAttributes().getNamedItem("name");
    String name = getTextContent(attName);
    AtomicLongConfig atomicLongConfig = new AtomicLongConfig(name);
    handleAtomicLongNode(node, atomicLongConfig);
  }
  
  void handleAtomicLongNode(Node node, AtomicLongConfig atomicLongConfig) {
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      String value = getTextContent(n).trim();
      if ("merge-policy".equals(nodeName)) {
        MergePolicyConfig mergePolicyConfig = createMergePolicyConfig(n);
        atomicLongConfig.setMergePolicyConfig(mergePolicyConfig);
        continue;
      } 
      if ("quorum-ref".equals(nodeName))
        atomicLongConfig.setQuorumName(value); 
    } 
    this.config.addAtomicLongConfig(atomicLongConfig);
  }
  
  protected void handleAtomicReference(Node node) throws Exception {
    Node attName = node.getAttributes().getNamedItem("name");
    String name = getTextContent(attName);
    AtomicReferenceConfig atomicReferenceConfig = new AtomicReferenceConfig(name);
    handleAtomicReferenceNode(node, atomicReferenceConfig);
  }
  
  void handleAtomicReferenceNode(Node node, AtomicReferenceConfig atomicReferenceConfig) {
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      String value = getTextContent(n).trim();
      if ("merge-policy".equals(nodeName)) {
        MergePolicyConfig mergePolicyConfig = createMergePolicyConfig(n);
        atomicReferenceConfig.setMergePolicyConfig(mergePolicyConfig);
        continue;
      } 
      if ("quorum-ref".equals(nodeName))
        atomicReferenceConfig.setQuorumName(value); 
    } 
    this.config.addAtomicReferenceConfig(atomicReferenceConfig);
  }
  
  protected void handleCountDownLatchConfig(Node node) throws Exception {
    Node attName = node.getAttributes().getNamedItem("name");
    String name = getTextContent(attName);
    CountDownLatchConfig countDownLatchConfig = new CountDownLatchConfig(name);
    handleCountDownLatchNode(node, countDownLatchConfig);
  }
  
  void handleCountDownLatchNode(Node node, CountDownLatchConfig countDownLatchConfig) {
    for (Node n : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(n);
      String value = getTextContent(n).trim();
      if ("quorum-ref".equals(nodeName))
        countDownLatchConfig.setQuorumName(value); 
    } 
    this.config.addCountDownLatchConfig(countDownLatchConfig);
  }
  
  protected void handleListeners(Node node) throws Exception {
    for (Node child : DomConfigHelper.childElements(node)) {
      if ("listener".equals(DomConfigHelper.cleanNodeName(child))) {
        String listenerClass = getTextContent(child);
        this.config.addListenerConfig(new ListenerConfig(listenerClass));
      } 
    } 
  }
  
  private void handlePartitionGroup(Node node) throws Exception {
    NamedNodeMap attributes = node.getAttributes();
    Node enabledNode = attributes.getNamedItem("enabled");
    boolean enabled = (enabledNode != null && DomConfigHelper.getBooleanValue(getTextContent(enabledNode)));
    this.config.getPartitionGroupConfig().setEnabled(enabled);
    Node groupTypeNode = attributes.getNamedItem("group-type");
    PartitionGroupConfig.MemberGroupType groupType = (groupTypeNode != null) ? PartitionGroupConfig.MemberGroupType.valueOf(StringUtil.upperCaseInternal(getTextContent(groupTypeNode))) : PartitionGroupConfig.MemberGroupType.PER_MEMBER;
    this.config.getPartitionGroupConfig().setGroupType(groupType);
    for (Node child : DomConfigHelper.childElements(node)) {
      if ("member-group".equals(DomConfigHelper.cleanNodeName(child)))
        handleMemberGroup(child, this.config); 
    } 
  }
  
  protected void handleMemberGroup(Node node, Config config) {
    MemberGroupConfig memberGroupConfig = new MemberGroupConfig();
    for (Node child : DomConfigHelper.childElements(node)) {
      if ("interface".equals(DomConfigHelper.cleanNodeName(child))) {
        String value = getTextContent(child);
        memberGroupConfig.addInterface(value);
      } 
    } 
    config.getPartitionGroupConfig().addMemberGroupConfig(memberGroupConfig);
  }
  
  private void handleSerialization(Node node) throws Exception {
    SerializationConfig serializationConfig = parseSerialization(node);
    this.config.setSerializationConfig(serializationConfig);
  }
  
  private void handleManagementCenterConfig(Node node) throws Exception {
    NamedNodeMap attrs = node.getAttributes();
    Node enabledNode = attrs.getNamedItem("enabled");
    boolean enabled = (enabledNode != null && DomConfigHelper.getBooleanValue(getTextContent(enabledNode)));
    Node intervalNode = attrs.getNamedItem("update-interval");
    int interval = (intervalNode != null) ? DomConfigHelper.getIntegerValue("update-interval", 
        getTextContent(intervalNode)) : 3;
    ManagementCenterConfig managementCenterConfig = this.config.getManagementCenterConfig();
    managementCenterConfig.setEnabled(enabled);
    managementCenterConfig.setUpdateInterval(interval);
    Node scriptingEnabledNode = attrs.getNamedItem("scripting-enabled");
    if (scriptingEnabledNode != null)
      managementCenterConfig.setScriptingEnabled(DomConfigHelper.getBooleanValue(getTextContent(scriptingEnabledNode))); 
    handleManagementCenterChildElements(node, managementCenterConfig);
  }
  
  private void handleManagementCenterChildElements(Node node, ManagementCenterConfig managementCenterConfig) {
    boolean isComplexType = false;
    List<String> complexTypeElements = Arrays.asList(new String[] { "url", "mutual-auth" });
    for (Node c : DomConfigHelper.childElements(node)) {
      if (complexTypeElements.contains(c.getNodeName())) {
        isComplexType = true;
        break;
      } 
    } 
    if (!isComplexType) {
      String url = getTextContent(node);
      managementCenterConfig.setUrl("".equals(url) ? null : url);
    } else {
      for (Node child : DomConfigHelper.childElements(node)) {
        if ("url".equals(DomConfigHelper.cleanNodeName(child))) {
          String url = getTextContent(child);
          managementCenterConfig.setUrl(url);
          continue;
        } 
        if ("mutual-auth".equals(DomConfigHelper.cleanNodeName(child)))
          handleMcMutualAuthConfig(child); 
      } 
    } 
  }
  
  private void handleSecurity(Node node) throws Exception {
    NamedNodeMap attributes = node.getAttributes();
    Node enabledNode = attributes.getNamedItem("enabled");
    boolean enabled = (enabledNode != null && DomConfigHelper.getBooleanValue(getTextContent(enabledNode)));
    this.config.getSecurityConfig().setEnabled(enabled);
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      if ("member-credentials-factory".equals(nodeName)) {
        handleCredentialsFactory(child);
        continue;
      } 
      if ("member-login-modules".equals(nodeName)) {
        handleLoginModules(child, true, this.config);
        continue;
      } 
      if ("client-login-modules".equals(nodeName)) {
        handleLoginModules(child, false, this.config);
        continue;
      } 
      if ("client-permission-policy".equals(nodeName)) {
        handlePermissionPolicy(child);
        continue;
      } 
      if ("client-permissions".equals(nodeName)) {
        handleSecurityPermissions(child);
        continue;
      } 
      if ("security-interceptors".equals(nodeName)) {
        handleSecurityInterceptors(child);
        continue;
      } 
      if ("client-block-unmapped-actions".equals(nodeName))
        this.config.getSecurityConfig().setClientBlockUnmappedActions(DomConfigHelper.getBooleanValue(getTextContent(child))); 
    } 
  }
  
  private void handleSecurityInterceptors(Node node) throws Exception {
    SecurityConfig cfg = this.config.getSecurityConfig();
    for (Node child : DomConfigHelper.childElements(node))
      handleSecurityInterceptorsChild(cfg, child); 
  }
  
  protected void handleSecurityInterceptorsChild(SecurityConfig cfg, Node child) {
    String nodeName = DomConfigHelper.cleanNodeName(child);
    if ("interceptor".equals(nodeName)) {
      NamedNodeMap attrs = child.getAttributes();
      Node classNameNode = attrs.getNamedItem("class-name");
      String className = getTextContent(classNameNode);
      cfg.addSecurityInterceptorConfig(new SecurityInterceptorConfig(className));
    } 
  }
  
  protected void handleMemberAttributes(Node node) throws Exception {
    for (Node n : DomConfigHelper.childElements(node)) {
      String name = DomConfigHelper.cleanNodeName(n);
      if (!"attribute".equals(name))
        continue; 
      String value = getTextContent(n);
      String attributeName = getTextContent(n.getAttributes().getNamedItem("name"));
      handleMemberAttributesNode(n, attributeName, value);
    } 
  }
  
  void handleMemberAttributesNode(Node n, String attributeName, String value) {
    String attributeType = getTextContent(n.getAttributes().getNamedItem("type"));
    if ("string".equals(attributeType)) {
      this.config.getMemberAttributeConfig().setStringAttribute(attributeName, value);
    } else if ("boolean".equals(attributeType)) {
      this.config.getMemberAttributeConfig().setBooleanAttribute(attributeName, Boolean.parseBoolean(value));
    } else if ("byte".equals(attributeType)) {
      this.config.getMemberAttributeConfig().setByteAttribute(attributeName, Byte.parseByte(value));
    } else if ("double".equals(attributeType)) {
      this.config.getMemberAttributeConfig().setDoubleAttribute(attributeName, Double.parseDouble(value));
    } else if ("float".equals(attributeType)) {
      this.config.getMemberAttributeConfig().setFloatAttribute(attributeName, Float.parseFloat(value));
    } else if ("int".equals(attributeType)) {
      this.config.getMemberAttributeConfig().setIntAttribute(attributeName, Integer.parseInt(value));
    } else if ("long".equals(attributeType)) {
      this.config.getMemberAttributeConfig().setLongAttribute(attributeName, Long.parseLong(value));
    } else if ("short".equals(attributeType)) {
      this.config.getMemberAttributeConfig().setShortAttribute(attributeName, Short.parseShort(value));
    } else {
      this.config.getMemberAttributeConfig().setStringAttribute(attributeName, value);
    } 
  }
  
  private void handleCredentialsFactory(Node node) throws Exception {
    NamedNodeMap attrs = node.getAttributes();
    Node classNameNode = attrs.getNamedItem("class-name");
    String className = getTextContent(classNameNode);
    SecurityConfig cfg = this.config.getSecurityConfig();
    CredentialsFactoryConfig credentialsFactoryConfig = new CredentialsFactoryConfig(className);
    cfg.setMemberCredentialsConfig(credentialsFactoryConfig);
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      if ("properties".equals(nodeName)) {
        fillProperties(child, credentialsFactoryConfig.getProperties());
        break;
      } 
    } 
  }
  
  protected void handleLoginModules(Node node, boolean member, Config config) {
    SecurityConfig cfg = config.getSecurityConfig();
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      if ("login-module".equals(nodeName)) {
        LoginModuleConfig lm = handleLoginModule(child);
        if (member) {
          cfg.addMemberLoginModuleConfig(lm);
          continue;
        } 
        cfg.addClientLoginModuleConfig(lm);
      } 
    } 
  }
  
  LoginModuleConfig handleLoginModule(Node node) {
    NamedNodeMap attrs = node.getAttributes();
    Node classNameNode = attrs.getNamedItem("class-name");
    String className = getTextContent(classNameNode);
    Node usageNode = attrs.getNamedItem("usage");
    LoginModuleConfig.LoginModuleUsage usage = (usageNode != null) ? LoginModuleConfig.LoginModuleUsage.get(getTextContent(usageNode)) : LoginModuleConfig.LoginModuleUsage.REQUIRED;
    LoginModuleConfig moduleConfig = new LoginModuleConfig(className, usage);
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      if ("properties".equals(nodeName)) {
        fillProperties(child, moduleConfig.getProperties());
        break;
      } 
    } 
    return moduleConfig;
  }
  
  private void handlePermissionPolicy(Node node) throws Exception {
    NamedNodeMap attrs = node.getAttributes();
    Node classNameNode = attrs.getNamedItem("class-name");
    String className = getTextContent(classNameNode);
    SecurityConfig cfg = this.config.getSecurityConfig();
    PermissionPolicyConfig policyConfig = new PermissionPolicyConfig(className);
    cfg.setClientPolicyConfig(policyConfig);
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      if ("properties".equals(nodeName)) {
        fillProperties(child, policyConfig.getProperties());
        break;
      } 
    } 
  }
  
  protected void handleSecurityPermissions(Node node) throws Exception {
    String onJoinOp = getAttribute(node, "on-join-operation");
    if (onJoinOp != null) {
      OnJoinPermissionOperationName onJoinPermissionOperation = OnJoinPermissionOperationName.valueOf(StringUtil.upperCaseInternal(onJoinOp));
      this.config.getSecurityConfig().setOnJoinPermissionOperation(onJoinPermissionOperation);
    } 
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      PermissionConfig.PermissionType type = PermissionConfig.PermissionType.getType(nodeName);
      if (type == null)
        throw new InvalidConfigurationException("Security permission type is not valid " + nodeName); 
      handleSecurityPermission(child, type);
    } 
  }
  
  void handleSecurityPermission(Node node, PermissionConfig.PermissionType type) {
    SecurityConfig cfg = this.config.getSecurityConfig();
    NamedNodeMap attrs = node.getAttributes();
    Node nameNode = attrs.getNamedItem("name");
    String name = (nameNode != null) ? getTextContent(nameNode) : "*";
    Node principalNode = attrs.getNamedItem("principal");
    String principal = (principalNode != null) ? getTextContent(principalNode) : "*";
    PermissionConfig permConfig = new PermissionConfig(type, name, principal);
    cfg.addClientPermissionConfig(permConfig);
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      if ("endpoints".equals(nodeName)) {
        handleSecurityPermissionEndpoints(child, permConfig);
        continue;
      } 
      if ("actions".equals(nodeName))
        handleSecurityPermissionActions(child, permConfig); 
    } 
  }
  
  void handleSecurityPermissionEndpoints(Node node, PermissionConfig permConfig) {
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      if ("endpoint".equals(nodeName))
        permConfig.addEndpoint(getTextContent(child).trim()); 
    } 
  }
  
  void handleSecurityPermissionActions(Node node, PermissionConfig permConfig) {
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      if ("action".equals(nodeName))
        permConfig.addAction(getTextContent(child).trim()); 
    } 
  }
  
  private void handleMemcacheProtocol(Node node) throws Exception {
    MemcacheProtocolConfig memcacheProtocolConfig = new MemcacheProtocolConfig();
    this.config.getNetworkConfig().setMemcacheProtocolConfig(memcacheProtocolConfig);
    boolean enabled = DomConfigHelper.getBooleanValue(getAttribute(node, "enabled"));
    memcacheProtocolConfig.setEnabled(enabled);
  }
  
  private void handleRestApi(Node node) throws Exception {
    RestApiConfig restApiConfig = new RestApiConfig();
    this.config.getNetworkConfig().setRestApiConfig(restApiConfig);
    boolean enabled = DomConfigHelper.getBooleanValue(getAttribute(node, "enabled"));
    restApiConfig.setEnabled(enabled);
    handleRestApiEndpointGroups(node);
  }
  
  protected void handleRestApiEndpointGroups(Node node) throws Exception {
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      if ("endpoint-group".equals(nodeName)) {
        String name = getAttribute(child, "name");
        handleEndpointGroup(child, name);
      } 
    } 
  }
  
  private void handleRestEndpointGroup(RestServerEndpointConfig config, Node node) {
    RestEndpointGroup endpointGroup;
    boolean enabled = DomConfigHelper.getBooleanValue(getAttribute(node, "enabled"));
    String name = extractName(node);
    try {
      endpointGroup = RestEndpointGroup.valueOf(name);
    } catch (IllegalArgumentException e) {
      throw new InvalidConfigurationException("Wrong name attribute value was provided in endpoint-group element: " + name + "\nAllowed values: " + 
          Arrays.toString(RestEndpointGroup.values()));
    } 
    if (enabled) {
      config.enableGroups(new RestEndpointGroup[] { endpointGroup });
    } else {
      config.disableGroups(new RestEndpointGroup[] { endpointGroup });
    } 
  }
  
  protected String extractName(Node node) { return getAttribute(node, "name"); }
  
  void handleEndpointGroup(Node node, String name) {
    RestEndpointGroup endpointGroup;
    boolean enabled = DomConfigHelper.getBooleanValue(getAttribute(node, "enabled"));
    try {
      endpointGroup = RestEndpointGroup.valueOf(name);
    } catch (IllegalArgumentException e) {
      throw new InvalidConfigurationException("Wrong name attribute value was provided in endpoint-group element: " + name + "\nAllowed values: " + 
          Arrays.toString(RestEndpointGroup.values()));
    } 
    RestApiConfig restApiConfig = this.config.getNetworkConfig().getRestApiConfig();
    if (enabled) {
      restApiConfig.enableGroups(new RestEndpointGroup[] { endpointGroup });
    } else {
      restApiConfig.disableGroups(new RestEndpointGroup[] { endpointGroup });
    } 
  }
  
  private void handleCPSubsystem(Node node) throws Exception {
    CPSubsystemConfig cpSubsystemConfig = this.config.getCPSubsystemConfig();
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      if ("raft-algorithm".equals(nodeName)) {
        handleRaftAlgorithm(cpSubsystemConfig.getRaftAlgorithmConfig(), child);
        continue;
      } 
      if ("semaphores".equals(nodeName)) {
        handleCPSemaphores(cpSubsystemConfig, child);
        continue;
      } 
      if ("locks".equals(nodeName)) {
        handleFencedLocks(cpSubsystemConfig, child);
        continue;
      } 
      String value = getTextContent(child).trim();
      if ("cp-member-count".equals(nodeName)) {
        cpSubsystemConfig.setCPMemberCount(Integer.parseInt(value));
        continue;
      } 
      if ("group-size".equals(nodeName)) {
        cpSubsystemConfig.setGroupSize(Integer.parseInt(value));
        continue;
      } 
      if ("session-time-to-live-seconds".equals(nodeName)) {
        cpSubsystemConfig.setSessionTimeToLiveSeconds(Integer.parseInt(value));
        continue;
      } 
      if ("session-heartbeat-interval-seconds".equals(nodeName)) {
        cpSubsystemConfig.setSessionHeartbeatIntervalSeconds(Integer.parseInt(value));
        continue;
      } 
      if ("missing-cp-member-auto-removal-seconds".equals(nodeName)) {
        cpSubsystemConfig.setMissingCPMemberAutoRemovalSeconds(Integer.parseInt(value));
        continue;
      } 
      if ("fail-on-indeterminate-operation-state".equals(nodeName))
        cpSubsystemConfig.setFailOnIndeterminateOperationState(Boolean.parseBoolean(value)); 
    } 
  }
  
  private void handleRaftAlgorithm(RaftAlgorithmConfig raftAlgorithmConfig, Node node) {
    for (Node child : DomConfigHelper.childElements(node)) {
      String nodeName = DomConfigHelper.cleanNodeName(child);
      String value = getTextContent(child).trim();
      if ("leader-election-timeout-in-millis".equals(nodeName)) {
        raftAlgorithmConfig.setLeaderElectionTimeoutInMillis(Long.parseLong(value));
        continue;
      } 
      if ("leader-heartbeat-period-in-millis".equals(nodeName)) {
        raftAlgorithmConfig.setLeaderHeartbeatPeriodInMillis(Long.parseLong(value));
        continue;
      } 
      if ("max-missed-leader-heartbeat-count".equals(nodeName)) {
        raftAlgorithmConfig.setMaxMissedLeaderHeartbeatCount(Integer.parseInt(value));
        continue;
      } 
      if ("append-request-max-entry-count".equals(nodeName)) {
        raftAlgorithmConfig.setAppendRequestMaxEntryCount(Integer.parseInt(value));
        continue;
      } 
      if ("commit-index-advance-count-to-snapshot".equals(nodeName)) {
        raftAlgorithmConfig.setCommitIndexAdvanceCountToSnapshot(Integer.parseInt(value));
        continue;
      } 
      if ("uncommitted-entry-count-to-reject-new-appends".equals(nodeName)) {
        raftAlgorithmConfig.setUncommittedEntryCountToRejectNewAppends(Integer.parseInt(value));
        continue;
      } 
      if ("append-request-backoff-timeout-in-millis".equals(nodeName))
        raftAlgorithmConfig.setAppendRequestBackoffTimeoutInMillis(Long.parseLong(value)); 
    } 
  }
  
  void handleCPSemaphores(CPSubsystemConfig cpSubsystemConfig, Node node) {
    for (Node child : DomConfigHelper.childElements(node)) {
      CPSemaphoreConfig cpSemaphoreConfig = new CPSemaphoreConfig();
      for (Node subChild : DomConfigHelper.childElements(child)) {
        String nodeName = DomConfigHelper.cleanNodeName(subChild);
        String value = getTextContent(subChild).trim();
        if ("name".equals(nodeName)) {
          cpSemaphoreConfig.setName(value);
          continue;
        } 
        if ("jdk-compatible".equals(nodeName))
          cpSemaphoreConfig.setJDKCompatible(Boolean.parseBoolean(value)); 
      } 
      cpSubsystemConfig.addSemaphoreConfig(cpSemaphoreConfig);
    } 
  }
  
  void handleFencedLocks(CPSubsystemConfig cpSubsystemConfig, Node node) {
    for (Node child : DomConfigHelper.childElements(node)) {
      FencedLockConfig lockConfig = new FencedLockConfig();
      for (Node subChild : DomConfigHelper.childElements(child)) {
        String nodeName = DomConfigHelper.cleanNodeName(subChild);
        String value = getTextContent(subChild).trim();
        if ("name".equals(nodeName)) {
          lockConfig.setName(value);
          continue;
        } 
        if ("lock-acquire-limit".equals(nodeName))
          lockConfig.setLockAcquireLimit(Integer.parseInt(value)); 
      } 
      cpSubsystemConfig.addLockConfig(lockConfig);
    } 
  }
}
