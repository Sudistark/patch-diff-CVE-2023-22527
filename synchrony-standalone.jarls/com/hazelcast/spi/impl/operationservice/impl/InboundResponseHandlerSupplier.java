package com.hazelcast.spi.impl.operationservice.impl;

import com.hazelcast.internal.metrics.MetricsProvider;
import com.hazelcast.internal.metrics.MetricsRegistry;
import com.hazelcast.internal.metrics.Probe;
import com.hazelcast.internal.metrics.ProbeLevel;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Packet;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.properties.GroupProperty;
import com.hazelcast.spi.properties.HazelcastProperties;
import com.hazelcast.spi.properties.HazelcastProperty;
import com.hazelcast.util.MutableInteger;
import com.hazelcast.util.concurrent.BackoffIdleStrategy;
import com.hazelcast.util.concurrent.BusySpinIdleStrategy;
import com.hazelcast.util.concurrent.IdleStrategy;
import com.hazelcast.util.function.Consumer;
import com.hazelcast.util.function.Supplier;
import java.util.concurrent.TimeUnit;

public class InboundResponseHandlerSupplier extends Object implements MetricsProvider, Supplier<Consumer<Packet>> {
  public static final HazelcastProperty IDLE_STRATEGY = new HazelcastProperty("hazelcast.operation.responsequeue.idlestrategy", "block");
  
  private static final ThreadLocal<MutableInteger> INT_HOLDER = new Object();
  
  private static final long IDLE_MAX_SPINS = 20L;
  
  private static final long IDLE_MAX_YIELDS = 50L;
  
  private static final long IDLE_MIN_PARK_NS = TimeUnit.NANOSECONDS.toNanos(1L);
  
  private static final long IDLE_MAX_PARK_NS = TimeUnit.MICROSECONDS.toNanos(100L);
  
  private final ResponseThread[] responseThreads;
  
  private final ILogger logger;
  
  private final Consumer<Packet> responseHandler;
  
  private final InboundResponseHandler[] inboundResponseHandlers;
  
  private final NodeEngine nodeEngine;
  
  private final InvocationRegistry invocationRegistry;
  
  private final HazelcastProperties properties;
  
  InboundResponseHandlerSupplier(ClassLoader classLoader, InvocationRegistry invocationRegistry, String hzName, NodeEngine nodeEngine) {
    this.nodeEngine = nodeEngine;
    this.invocationRegistry = invocationRegistry;
    this.logger = nodeEngine.getLogger(InboundResponseHandlerSupplier.class);
    this.properties = nodeEngine.getProperties();
    int responseThreadCount = this.properties.getInteger(GroupProperty.RESPONSE_THREAD_COUNT);
    if (responseThreadCount < 0)
      throw new IllegalArgumentException(GroupProperty.RESPONSE_THREAD_COUNT.getName() + " can't be smaller than 0"); 
    if (this.logger.isFineEnabled())
      this.logger.fine("Running with " + responseThreadCount + " response threads"); 
    this.responseThreads = new ResponseThread[responseThreadCount];
    if (responseThreadCount == 0) {
      this.inboundResponseHandlers = new InboundResponseHandler[1];
      this.inboundResponseHandlers[0] = new InboundResponseHandler(invocationRegistry, nodeEngine);
      this.responseHandler = this.inboundResponseHandlers[0];
    } else {
      this.inboundResponseHandlers = new InboundResponseHandler[responseThreadCount];
      for (int k = 0; k < this.responseThreads.length; k++) {
        ResponseThread responseThread = new ResponseThread(this, hzName, k, null);
        responseThread.setContextClassLoader(classLoader);
        this.responseThreads[k] = responseThread;
        this.inboundResponseHandlers[k] = ResponseThread.access$100(responseThread);
      } 
      this.responseHandler = (responseThreadCount == 1) ? new AsyncSingleThreadedResponseHandler(this, null) : new AsyncMultithreadedResponseHandler(this);
    } 
  }
  
  public InboundResponseHandler backupHandler() { return this.inboundResponseHandlers[0]; }
  
  @Probe(level = ProbeLevel.MANDATORY)
  public int responseQueueSize() {
    int result = 0;
    for (ResponseThread responseThread : this.responseThreads)
      result += ResponseThread.access$300(responseThread).size(); 
    return result;
  }
  
  @Probe(name = "responses[normal]", level = ProbeLevel.MANDATORY)
  long responsesNormal() {
    long result = 0L;
    for (InboundResponseHandler handler : this.inboundResponseHandlers)
      result += handler.responsesNormal.get(); 
    return result;
  }
  
  @Probe(name = "responses[timeout]", level = ProbeLevel.MANDATORY)
  long responsesTimeout() {
    long result = 0L;
    for (InboundResponseHandler handler : this.inboundResponseHandlers)
      result += handler.responsesTimeout.get(); 
    return result;
  }
  
  @Probe(name = "responses[backup]", level = ProbeLevel.MANDATORY)
  long responsesBackup() {
    long result = 0L;
    for (InboundResponseHandler handler : this.inboundResponseHandlers)
      result += handler.responsesBackup.get(); 
    return result;
  }
  
  @Probe(name = "responses[error]", level = ProbeLevel.MANDATORY)
  long responsesError() {
    long result = 0L;
    for (InboundResponseHandler handler : this.inboundResponseHandlers)
      result += handler.responsesError.get(); 
    return result;
  }
  
  @Probe(name = "responses[missing]", level = ProbeLevel.MANDATORY)
  long responsesMissing() {
    long result = 0L;
    for (InboundResponseHandler handler : this.inboundResponseHandlers)
      result += handler.responsesMissing.get(); 
    return result;
  }
  
  public void provideMetrics(MetricsRegistry registry) { registry.scanAndRegister(this, "operation"); }
  
  public Consumer<Packet> get() { return this.responseHandler; }
  
  public void start() {
    for (ResponseThread responseThread : this.responseThreads)
      responseThread.start(); 
  }
  
  public void shutdown() {
    for (ResponseThread responseThread : this.responseThreads)
      ResponseThread.access$400(responseThread); 
  }
  
  public static IdleStrategy getIdleStrategy(HazelcastProperties properties, HazelcastProperty property) {
    String idleStrategyString = properties.getString(property);
    if ("block".equals(idleStrategyString))
      return null; 
    if ("busyspin".equals(idleStrategyString))
      return new BusySpinIdleStrategy(); 
    if ("backoff".equals(idleStrategyString))
      return new BackoffIdleStrategy(20L, 50L, IDLE_MIN_PARK_NS, IDLE_MAX_PARK_NS); 
    if (idleStrategyString.startsWith("backoff,"))
      return BackoffIdleStrategy.createBackoffIdleStrategy(idleStrategyString); 
    throw new IllegalStateException("Unrecognized " + property.getName() + " value=" + idleStrategyString);
  }
}
