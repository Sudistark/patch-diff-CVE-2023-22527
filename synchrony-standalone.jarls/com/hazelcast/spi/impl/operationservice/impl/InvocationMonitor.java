package com.hazelcast.spi.impl.operationservice.impl;

import com.hazelcast.instance.MemberImpl;
import com.hazelcast.internal.metrics.MetricsProvider;
import com.hazelcast.internal.metrics.MetricsRegistry;
import com.hazelcast.internal.metrics.Probe;
import com.hazelcast.internal.metrics.ProbeLevel;
import com.hazelcast.internal.serialization.InternalSerializationService;
import com.hazelcast.internal.util.counters.SwCounter;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.Packet;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.impl.servicemanager.ServiceManager;
import com.hazelcast.spi.properties.GroupProperty;
import com.hazelcast.spi.properties.HazelcastProperties;
import com.hazelcast.util.function.Consumer;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

public class InvocationMonitor extends Object implements Consumer<Packet>, MetricsProvider {
  private static final int HEARTBEAT_CALL_TIMEOUT_RATIO = 4;
  
  private static final long MAX_DELAY_MILLIS = TimeUnit.SECONDS.toMillis(10L);
  
  private final NodeEngineImpl nodeEngine;
  
  private final InternalSerializationService serializationService;
  
  private final ServiceManager serviceManager;
  
  private final InvocationRegistry invocationRegistry;
  
  private final ILogger logger;
  
  private final ScheduledExecutorService scheduler;
  
  private final Address thisAddress;
  
  private final ConcurrentMap<Address, AtomicLong> heartbeatPerMember;
  
  @Probe(name = "backupTimeouts", level = ProbeLevel.MANDATORY)
  private final SwCounter backupTimeoutsCount;
  
  @Probe(name = "normalTimeouts", level = ProbeLevel.MANDATORY)
  private final SwCounter normalTimeoutsCount;
  
  @Probe
  private final SwCounter heartbeatPacketsReceived;
  
  @Probe
  private final SwCounter heartbeatPacketsSend;
  
  @Probe
  private final SwCounter delayedExecutionCount;
  
  @Probe
  private final long backupTimeoutMillis;
  
  @Probe
  private final long invocationTimeoutMillis;
  
  @Probe
  private final long heartbeatBroadcastPeriodMillis;
  
  @Probe
  private final long invocationScanPeriodMillis;
  
  InvocationMonitor(NodeEngineImpl nodeEngine, Address thisAddress, HazelcastProperties properties, InvocationRegistry invocationRegistry, ILogger logger, InternalSerializationService serializationService, ServiceManager serviceManager) {
    this.heartbeatPerMember = new ConcurrentHashMap();
    this
      .backupTimeoutsCount = SwCounter.newSwCounter();
    this
      .normalTimeoutsCount = SwCounter.newSwCounter();
    this
      .heartbeatPacketsReceived = SwCounter.newSwCounter();
    this
      .heartbeatPacketsSend = SwCounter.newSwCounter();
    this
      .delayedExecutionCount = SwCounter.newSwCounter();
    this
      .invocationScanPeriodMillis = TimeUnit.SECONDS.toMillis(1L);
    this.nodeEngine = nodeEngine;
    this.thisAddress = thisAddress;
    this.serializationService = serializationService;
    this.serviceManager = serviceManager;
    this.invocationRegistry = invocationRegistry;
    this.logger = logger;
    this.backupTimeoutMillis = backupTimeoutMillis(properties);
    this.invocationTimeoutMillis = invocationTimeoutMillis(properties);
    this.heartbeatBroadcastPeriodMillis = heartbeatBroadcastPeriodMillis(properties);
    this.scheduler = newScheduler(nodeEngine.getHazelcastInstance().getName());
  }
  
  public ConcurrentMap<Address, AtomicLong> getHeartbeatPerMember() { return this.heartbeatPerMember; }
  
  public long getHeartbeatBroadcastPeriodMillis() { return this.heartbeatBroadcastPeriodMillis; }
  
  public void provideMetrics(MetricsRegistry registry) { registry.scanAndRegister(this, "operation.invocations"); }
  
  private static ScheduledExecutorService newScheduler(String hzName) { return new ScheduledThreadPoolExecutor(1, new Object(hzName)); }
  
  private long invocationTimeoutMillis(HazelcastProperties properties) {
    long heartbeatTimeoutMillis = properties.getMillis(GroupProperty.OPERATION_CALL_TIMEOUT_MILLIS);
    if (this.logger.isFinestEnabled())
      this.logger.finest("Operation invocation timeout is " + heartbeatTimeoutMillis + " ms"); 
    return heartbeatTimeoutMillis;
  }
  
  private long backupTimeoutMillis(HazelcastProperties properties) {
    long backupTimeoutMillis = properties.getMillis(GroupProperty.OPERATION_BACKUP_TIMEOUT_MILLIS);
    if (this.logger.isFinestEnabled())
      this.logger.finest("Operation backup timeout is " + backupTimeoutMillis + " ms"); 
    return backupTimeoutMillis;
  }
  
  private long heartbeatBroadcastPeriodMillis(HazelcastProperties properties) {
    int callTimeoutMs = properties.getInteger(GroupProperty.OPERATION_CALL_TIMEOUT_MILLIS);
    long periodMs = Math.max(TimeUnit.SECONDS.toMillis(1L), (callTimeoutMs / 4));
    if (this.logger.isFinestEnabled())
      this.logger.finest("Operation heartbeat period is " + periodMs + " ms"); 
    return periodMs;
  }
  
  void onMemberLeft(MemberImpl member) {
    int memberListVersion = this.nodeEngine.getClusterService().getMemberListVersion();
    this.scheduler.execute(new OnMemberLeftTask(this, member, memberListVersion, null));
  }
  
  void onEndpointLeft(Address endpoint) { this.scheduler.execute(new OnEndpointLeftTask(this, endpoint, null)); }
  
  void execute(Runnable runnable) { this.scheduler.execute(runnable); }
  
  void schedule(Runnable command, long delayMillis) { this.scheduler.schedule(command, delayMillis, TimeUnit.MILLISECONDS); }
  
  public void accept(Packet packet) { this.scheduler.execute(new ProcessOperationControlTask(this, packet)); }
  
  public void start() {
    MonitorInvocationsTask monitorInvocationsTask = new MonitorInvocationsTask(this, this.invocationScanPeriodMillis, null);
    this.scheduler.scheduleAtFixedRate(monitorInvocationsTask, 0L, monitorInvocationsTask.periodMillis, TimeUnit.MILLISECONDS);
    BroadcastOperationControlTask broadcastOperationControlTask = new BroadcastOperationControlTask(this, this.heartbeatBroadcastPeriodMillis, null);
    this.scheduler.scheduleAtFixedRate(broadcastOperationControlTask, 0L, broadcastOperationControlTask.periodMillis, TimeUnit.MILLISECONDS);
  }
  
  public void shutdown() { this.scheduler.shutdown(); }
  
  public void awaitTermination(long timeoutMillis) throws InterruptedException { this.scheduler.awaitTermination(timeoutMillis, TimeUnit.MILLISECONDS); }
  
  long getLastMemberHeartbeatMillis(Address memberAddress) {
    if (memberAddress == null)
      return 0L; 
    AtomicLong heartbeat = (AtomicLong)this.heartbeatPerMember.get(memberAddress);
    return (heartbeat == null) ? 0L : heartbeat.get();
  }
}
