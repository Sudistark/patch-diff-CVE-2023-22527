package com.hazelcast.spi.impl.merge;

import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.SplitBrainHandlerService;
import com.hazelcast.spi.impl.operationexecutor.OperationExecutor;
import com.hazelcast.spi.impl.operationservice.impl.OperationServiceImpl;
import com.hazelcast.spi.partition.IPartitionService;
import java.util.Collection;
import java.util.Iterator;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CountDownLatch;

public abstract class AbstractSplitBrainHandlerService<Store> extends Object implements SplitBrainHandlerService {
  private final IPartitionService partitionService;
  
  private final OperationExecutor operationExecutor;
  
  protected AbstractSplitBrainHandlerService(NodeEngine nodeEngine) {
    this.partitionService = nodeEngine.getPartitionService();
    this.operationExecutor = ((OperationServiceImpl)nodeEngine.getOperationService()).getOperationExecutor();
  }
  
  public final Runnable prepareMergeRunnable() {
    ConcurrentLinkedQueue<Store> mergingStores = new ConcurrentLinkedQueue<Store>();
    collectStores(mergingStores);
    return newMergeRunnable(mergingStores);
  }
  
  private void collectStores(ConcurrentLinkedQueue<Store> mergingStores) {
    int partitionCount = this.partitionService.getPartitionCount();
    CountDownLatch latch = new CountDownLatch(partitionCount);
    for (i = 0; i < partitionCount; i++)
      this.operationExecutor.execute(new StoreCollector(this, mergingStores, i, latch)); 
    try {
      latch.await();
    } catch (InterruptedException i) {
      InterruptedException e;
      Thread.currentThread().interrupt();
    } 
  }
  
  void asyncDestroyStores(Collection<Store> stores, int partitionID) { this.operationExecutor.execute(new Object(this, stores, partitionID)); }
  
  private boolean isLocalPartition(int partitionId) { return this.partitionService.isPartitionOwner(partitionId); }
  
  protected void onStoreCollection(Store store) {}
  
  protected abstract Runnable newMergeRunnable(Collection<Store> paramCollection);
  
  protected abstract Iterator<Store> storeIterator(int paramInt);
  
  protected abstract void destroyStore(Store paramStore);
  
  protected abstract boolean hasEntries(Store paramStore);
  
  protected abstract boolean hasMergeablePolicy(Store paramStore);
}
