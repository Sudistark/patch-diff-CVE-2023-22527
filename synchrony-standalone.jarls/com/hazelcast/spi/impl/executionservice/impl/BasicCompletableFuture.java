package com.hazelcast.spi.impl.executionservice.impl;

import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.impl.AbstractCompletableFuture;
import com.hazelcast.util.EmptyStatement;
import com.hazelcast.util.ExceptionUtil;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

class BasicCompletableFuture<V> extends AbstractCompletableFuture<V> {
  final Future<V> delegate;
  
  BasicCompletableFuture(Future<V> delegate, NodeEngine nodeEngine) {
    super(nodeEngine, nodeEngine.getLogger(BasicCompletableFuture.class));
    this.delegate = delegate;
  }
  
  public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException { return (V)ensureResultSet(timeout, unit); }
  
  private Object ensureResultSet(long timeout, TimeUnit unit) throws ExecutionException, CancellationException {
    Object result = null;
    try {
      result = this.delegate.get(timeout, unit);
    } catch (TimeoutException ex) {
      ExceptionUtil.sneakyThrow(ex);
    } catch (InterruptedException ex) {
      Thread.currentThread().interrupt();
      ExceptionUtil.sneakyThrow(ex);
    } catch (ExecutionException ex) {
      setResult(ex);
      throw ex;
    } catch (CancellationException ex) {
      setResult(ex);
      throw ex;
    } catch (Throwable t) {
      result = t;
    } 
    setResult(result);
    return result;
  }
  
  public boolean isDone() {
    if (this.delegate.isDone()) {
      try {
        ensureResultSet(Float.MAX_VALUE, TimeUnit.DAYS);
      } catch (ExecutionException ignored) {
        EmptyStatement.ignore(ignored);
      } catch (CancellationException ignored) {
        EmptyStatement.ignore(ignored);
      } 
      return true;
    } 
    return super.isDone();
  }
  
  public boolean isCancelled() {
    if (this.delegate.isCancelled()) {
      cancel(true);
      return true;
    } 
    return super.isCancelled();
  }
  
  public boolean shouldCancel(boolean mayInterruptIfRunning) {
    if (!this.delegate.isCancelled())
      this.delegate.cancel(mayInterruptIfRunning); 
    return true;
  }
}
