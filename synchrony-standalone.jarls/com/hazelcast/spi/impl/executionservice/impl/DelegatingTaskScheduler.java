package com.hazelcast.spi.impl.executionservice.impl;

import com.hazelcast.spi.TaskScheduler;
import com.hazelcast.util.Preconditions;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

public final class DelegatingTaskScheduler implements TaskScheduler {
  private final ScheduledExecutorService scheduledExecutorService;
  
  private final ExecutorService executor;
  
  public DelegatingTaskScheduler(ScheduledExecutorService scheduledExecutorService, ExecutorService executor) {
    this.scheduledExecutorService = scheduledExecutorService;
    this.executor = executor;
  }
  
  public void execute(Runnable command) { this.executor.execute(command); }
  
  public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
    Preconditions.checkNotNull(command);
    DelegatingTaskDecorator delegatingTaskDecorator = new DelegatingTaskDecorator(command, this.executor);
    return this.scheduledExecutorService.schedule(delegatingTaskDecorator, delay, unit);
  }
  
  public <V> ScheduledFuture<Future<V>> schedule(Callable<V> command, long delay, TimeUnit unit) {
    Preconditions.checkNotNull(command);
    DelegatingCallableTaskDecorator delegatingCallableTaskDecorator = new DelegatingCallableTaskDecorator(command, this.executor);
    return this.scheduledExecutorService.schedule(delegatingCallableTaskDecorator, delay, unit);
  }
  
  public ScheduledFuture<?> scheduleWithRepetition(Runnable command, long initialDelay, long period, TimeUnit unit) {
    Preconditions.checkNotNull(command);
    DelegateAndSkipOnConcurrentExecutionDecorator delegateAndSkipOnConcurrentExecutionDecorator = new DelegateAndSkipOnConcurrentExecutionDecorator(command, this.executor);
    return this.scheduledExecutorService.scheduleAtFixedRate(delegateAndSkipOnConcurrentExecutionDecorator, initialDelay, period, unit);
  }
}
