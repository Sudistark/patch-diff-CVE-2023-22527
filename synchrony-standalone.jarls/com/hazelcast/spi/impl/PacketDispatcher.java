package com.hazelcast.spi.impl;

import com.hazelcast.instance.OutOfMemoryErrorDispatcher;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Connection;
import com.hazelcast.nio.EndpointManager;
import com.hazelcast.nio.Packet;
import com.hazelcast.util.function.Consumer;

public final class PacketDispatcher extends Object implements Consumer<Packet> {
  private final ILogger logger;
  
  private final Consumer<Packet> eventService;
  
  private final Consumer<Packet> operationExecutor;
  
  private final Consumer<Packet> jetPacketConsumer;
  
  private final Consumer<Packet> responseHandler;
  
  private final Consumer<Packet> invocationMonitor;
  
  public PacketDispatcher(ILogger logger, Consumer<Packet> operationExecutor, Consumer<Packet> responseHandler, Consumer<Packet> invocationMonitor, Consumer<Packet> eventService, Consumer<Packet> jetPacketConsumer) {
    this.logger = logger;
    this.responseHandler = responseHandler;
    this.eventService = eventService;
    this.invocationMonitor = invocationMonitor;
    this.operationExecutor = operationExecutor;
    this.jetPacketConsumer = jetPacketConsumer;
  }
  
  public void accept(Packet packet) {
    try {
      EndpointManager endpointManager;
      Connection connection;
      switch (null.$SwitchMap$com$hazelcast$nio$Packet$Type[packet.getPacketType().ordinal()]) {
        case 1:
          if (packet.isFlagRaised(2)) {
            this.responseHandler.accept(packet);
          } else if (packet.isFlagRaised(64)) {
            this.invocationMonitor.accept(packet);
          } else {
            this.operationExecutor.accept(packet);
          } 
          return;
        case 2:
          this.eventService.accept(packet);
          return;
        case 3:
        case 4:
          connection = packet.getConn();
          endpointManager = connection.getEndpointManager();
          endpointManager.accept(packet);
          return;
        case 5:
          this.jetPacketConsumer.accept(packet);
          return;
      } 
      this.logger.severe("Header flags [" + Integer.toBinaryString(packet.getFlags()) + "] specify an undefined packet type " + packet
          .getPacketType().name());
    } catch (Throwable t) {
      OutOfMemoryErrorDispatcher.inspectOutOfMemoryError(t);
      this.logger.severe("Failed to process: " + packet, t);
    } 
  }
}
