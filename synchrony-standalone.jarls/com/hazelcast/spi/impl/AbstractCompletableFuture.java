package com.hazelcast.spi.impl;

import com.hazelcast.core.ExecutionCallback;
import com.hazelcast.core.ICompletableFuture;
import com.hazelcast.logging.ILogger;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.util.EmptyStatement;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.Preconditions;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

@SuppressFBWarnings(value = {"NN_NAKED_NOTIFY"}, justification = "State handled with CAS, naked notify correct")
public abstract class AbstractCompletableFuture<V> extends Object implements ICompletableFuture<V> {
  private static final Object INITIAL_STATE = new ExecutionCallbackNode(null, null, null, null);
  
  private static final Object CANCELLED_STATE = new Object();
  
  private static final AtomicReferenceFieldUpdater<AbstractCompletableFuture, Object> STATE = AtomicReferenceFieldUpdater.newUpdater(AbstractCompletableFuture.class, Object.class, "state");
  
  private final ILogger logger;
  
  private final Executor defaultExecutor;
  
  protected AbstractCompletableFuture(NodeEngine nodeEngine, ILogger logger) { this(nodeEngine.getExecutionService().getExecutor("hz:async"), logger); }
  
  protected AbstractCompletableFuture(Executor defaultExecutor, ILogger logger) {
    this.state = INITIAL_STATE;
    this.defaultExecutor = defaultExecutor;
    this.logger = logger;
  }
  
  public void andThen(ExecutionCallback<V> callback) { andThen(callback, this.defaultExecutor); }
  
  public void andThen(ExecutionCallback<V> callback, Executor executor) {
    ExecutionCallbackNode newState;
    Object currentState;
    Preconditions.isNotNull(callback, "callback");
    Preconditions.isNotNull(executor, "executor");
    do {
      currentState = this.state;
      if (isCancelledState(currentState))
        return; 
      if (isDoneState(currentState)) {
        runAsynchronous(callback, executor, currentState);
        return;
      } 
      newState = new ExecutionCallbackNode(callback, executor, (ExecutionCallbackNode)currentState, null);
    } while (!STATE.compareAndSet(this, currentState, newState));
  }
  
  public boolean isDone() { return isDoneState(this.state); }
  
  private static boolean isDoneState(Object state) { return !(state instanceof ExecutionCallbackNode); }
  
  public final boolean cancel(boolean mayInterruptIfRunning) {
    Object currentState;
    Boolean shouldCancel = null;
    do {
      currentState = this.state;
      if (isDoneState(currentState))
        return false; 
      if (shouldCancel == null)
        shouldCancel = Boolean.valueOf(shouldCancel(mayInterruptIfRunning)); 
      if (!shouldCancel.booleanValue())
        return false; 
    } while (!STATE.compareAndSet(this, currentState, CANCELLED_STATE));
    cancelled(mayInterruptIfRunning);
    notifyThreadsWaitingOnGet();
    return true;
  }
  
  protected boolean shouldCancel(boolean mayInterruptIfRunning) { return true; }
  
  protected void cancelled(boolean mayInterruptIfRunning) {}
  
  private static boolean isCancelledState(Object state) { return (state == CANCELLED_STATE); }
  
  public boolean isCancelled() { return isCancelledState(this.state); }
  
  public final V get() throws InterruptedException, ExecutionException {
    while (true) {
      try {
        return (V)get(Float.MAX_VALUE, TimeUnit.MILLISECONDS);
      } catch (TimeoutException ignored) {
        EmptyStatement.ignore(ignored);
      } 
    } 
  }
  
  public V get(long timeout, TimeUnit unit) throws ExecutionException, InterruptedException, TimeoutException {
    long deadlineTimeMillis = System.currentTimeMillis() + unit.toMillis(timeout);
    while (true) {
      Object currentState = this.state;
      if (isCancelledState(currentState))
        throw new CancellationException(); 
      if (isDoneState(currentState))
        return (V)getResult(currentState); 
      if (Thread.interrupted())
        throw new InterruptedException(); 
      long millisToWait = deadlineTimeMillis - System.currentTimeMillis();
      if (millisToWait <= 0L)
        throw new TimeoutException(); 
      synchronized (this) {
        if (!isDoneState(this.state))
          wait(millisToWait); 
      } 
    } 
  }
  
  protected boolean setResult(Object result) {
    Object currentState;
    do {
      currentState = this.state;
      if (isDoneState(currentState))
        return false; 
    } while (!STATE.compareAndSet(this, currentState, result));
    done();
    notifyThreadsWaitingOnGet();
    runAsynchronous((ExecutionCallbackNode)currentState, result);
    return true;
  }
  
  protected void done() {}
  
  protected V getResult() throws InterruptedException, ExecutionException { return (V)getResult(this.state); }
  
  private static <V> V getResult(Object state) {
    if (isCancelledState(state))
      return null; 
    if (!isDoneState(state))
      return null; 
    if (state instanceof Throwable)
      ExceptionUtil.sneakyThrow((Throwable)state); 
    return (V)state;
  }
  
  private void notifyThreadsWaitingOnGet() {
    synchronized (this) {
      notifyAll();
    } 
  }
  
  private void runAsynchronous(ExecutionCallbackNode head, Object result) {
    while (head != INITIAL_STATE) {
      runAsynchronous(head.callback, head.executor, result);
      head = head.next;
    } 
  }
  
  private void runAsynchronous(ExecutionCallback<V> callback, Executor executor, Object result) { executor.execute(new ExecutionCallbackRunnable(getClass(), result, callback, this.logger)); }
}
