package com.hazelcast.spi.impl.operationparker.impl;

import com.hazelcast.core.HazelcastInstanceNotActiveException;
import com.hazelcast.internal.partition.MigrationInfo;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.spi.BlockingOperation;
import com.hazelcast.spi.LiveOperations;
import com.hazelcast.spi.LiveOperationsTracker;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Notifier;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.OperationResponseHandler;
import com.hazelcast.spi.OperationService;
import com.hazelcast.spi.WaitNotifyKey;
import com.hazelcast.spi.exception.PartitionMigratingException;
import java.util.Iterator;
import java.util.Map;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

public class WaitSet extends Object implements LiveOperationsTracker, Iterable<WaitSetEntry> {
  private static final long TIMEOUT_UPPER_BOUND = 1500L;
  
  private final Queue<WaitSetEntry> queue;
  
  private final ILogger logger;
  
  private final NodeEngine nodeEngine;
  
  private final Map<WaitNotifyKey, WaitSet> waitSetMap;
  
  private final Queue<WaitSetEntry> delayQueue;
  
  public WaitSet(ILogger logger, NodeEngine nodeEngine, Map<WaitNotifyKey, WaitSet> waitSetMap, Queue<WaitSetEntry> delayQueue) {
    this.queue = new ConcurrentLinkedQueue();
    this.nodeEngine = nodeEngine;
    this.logger = logger;
    this.waitSetMap = waitSetMap;
    this.delayQueue = delayQueue;
  }
  
  public void populate(LiveOperations liveOperations) {
    for (WaitSetEntry entry : this.queue) {
      Operation operation = entry.getOperation();
      liveOperations.add(operation.getCallerAddress(), operation.getCallId());
    } 
  }
  
  public void park(BlockingOperation op) {
    long timeout = op.getWaitTimeout();
    WaitSetEntry entry = new WaitSetEntry(this.queue, op);
    entry.setNodeEngine(this.nodeEngine);
    this.queue.offer(entry);
    if (timeout > -1L && timeout < 1500L)
      this.delayQueue.offer(entry); 
  }
  
  public void unpark(Notifier notifier, WaitNotifyKey key) {
    WaitSetEntry entry = (WaitSetEntry)this.queue.peek();
    while (entry != null) {
      Operation op = entry.getOperation();
      if (notifier == op)
        throw new IllegalStateException("Found cyclic wait-notify! -> " + notifier); 
      if (entry.isValid()) {
        if (entry.isExpired()) {
          entry.onExpire();
        } else if (entry.isCancelled()) {
          entry.onCancel();
        } else {
          if (entry.shouldWait())
            return; 
          OperationService operationService = this.nodeEngine.getOperationService();
          operationService.run(op);
        } 
        entry.setValid(false);
      } 
      this.queue.poll();
      entry = (WaitSetEntry)this.queue.peek();
      if (entry == null)
        this.waitSetMap.remove(key); 
    } 
  }
  
  void onPartitionMigrate(MigrationInfo migrationInfo) {
    Iterator<WaitSetEntry> it = this.queue.iterator();
    int partitionId = migrationInfo.getPartitionId();
    while (it.hasNext()) {
      if (Thread.currentThread().isInterrupted())
        return; 
      WaitSetEntry entry = (WaitSetEntry)it.next();
      if (!entry.isValid())
        continue; 
      Operation op = entry.getOperation();
      if (partitionId == op.getPartitionId()) {
        entry.setValid(false);
        PartitionMigratingException pme = new PartitionMigratingException(this.nodeEngine.getThisAddress(), partitionId, op.getClass().getName(), op.getServiceName());
        op.sendResponse(pme);
        it.remove();
      } 
    } 
  }
  
  public void onShutdown() {
    Object response = new HazelcastInstanceNotActiveException();
    Address thisAddress = this.nodeEngine.getThisAddress();
    for (WaitSetEntry entry : this.queue) {
      if (!entry.isValid())
        continue; 
      Operation op = entry.getOperation();
      if (thisAddress.equals(op.getCallerAddress()))
        try {
          OperationResponseHandler responseHandler = op.getOperationResponseHandler();
          responseHandler.sendResponse(op, response);
        } catch (Exception e) {
          this.logger.finest("While sending HazelcastInstanceNotActiveException response...", e);
        }  
      this.queue.clear();
    } 
  }
  
  public void invalidateAll(String callerUuid) {
    for (WaitSetEntry entry : this.queue) {
      if (!entry.isValid())
        continue; 
      Operation op = entry.getOperation();
      if (callerUuid.equals(op.getCallerUuid()))
        entry.setValid(false); 
    } 
  }
  
  public void cancelAll(String callerUuid, Throwable cause) {
    for (WaitSetEntry entry : this.queue) {
      if (!entry.isValid())
        continue; 
      Operation op = entry.getOperation();
      if (callerUuid.equals(op.getCallerUuid()))
        entry.cancel(cause); 
    } 
  }
  
  public void cancelAll(String serviceName, Object objectId, Throwable cause) {
    for (WaitSetEntry entry : this.queue) {
      if (!entry.isValid())
        continue; 
      WaitNotifyKey wnk = entry.blockingOperation.getWaitKey();
      if (serviceName.equals(wnk.getServiceName()) && objectId
        .equals(wnk.getObjectName()))
        entry.cancel(cause); 
    } 
  }
  
  WaitSetEntry find(Operation op) {
    for (WaitSetEntry entry : this.queue) {
      if (entry.op == op)
        return entry; 
    } 
    return null;
  }
  
  public int size() { return this.queue.size(); }
  
  public int totalValidWaitingOperationCount() {
    int count = 0;
    for (WaitSetEntry entry : this.queue) {
      if (entry.valid)
        count++; 
    } 
    return count;
  }
  
  public Iterator<WaitSetEntry> iterator() { return this.queue.iterator(); }
}
