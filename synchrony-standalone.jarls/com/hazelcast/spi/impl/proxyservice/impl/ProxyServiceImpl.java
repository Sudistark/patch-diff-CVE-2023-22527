package com.hazelcast.spi.impl.proxyservice.impl;

import com.hazelcast.core.DistributedObject;
import com.hazelcast.core.DistributedObjectEvent;
import com.hazelcast.core.DistributedObjectListener;
import com.hazelcast.core.HazelcastInstanceNotActiveException;
import com.hazelcast.core.Member;
import com.hazelcast.internal.metrics.MetricsProvider;
import com.hazelcast.internal.metrics.MetricsRegistry;
import com.hazelcast.internal.metrics.Probe;
import com.hazelcast.internal.metrics.ProbeLevel;
import com.hazelcast.internal.util.counters.MwCounter;
import com.hazelcast.logging.ILogger;
import com.hazelcast.spi.EventPublishingService;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.PostJoinAwareService;
import com.hazelcast.spi.RemoteService;
import com.hazelcast.spi.exception.DistributedObjectDestroyedException;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.impl.operationservice.InternalOperationService;
import com.hazelcast.spi.impl.proxyservice.InternalProxyService;
import com.hazelcast.spi.impl.proxyservice.impl.operations.DistributedObjectDestroyOperation;
import com.hazelcast.spi.impl.proxyservice.impl.operations.PostJoinProxyOperation;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.EmptyStatement;
import com.hazelcast.util.FutureUtil;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.UuidUtil;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedList;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class ProxyServiceImpl extends Object implements InternalProxyService, PostJoinAwareService, EventPublishingService<DistributedObjectEventPacket, Object>, MetricsProvider {
  public static final String SERVICE_NAME = "hz:core:proxyService";
  
  private static final int TRY_COUNT = 10;
  
  private static final long DESTROY_TIMEOUT_SECONDS = 30L;
  
  final NodeEngineImpl nodeEngine;
  
  final ILogger logger;
  
  final ConcurrentMap<String, DistributedObjectListener> listeners;
  
  private final ConstructorFunction<String, ProxyRegistry> registryConstructor;
  
  private final ConcurrentMap<String, ProxyRegistry> registries;
  
  @Probe(name = "createdCount", level = ProbeLevel.MANDATORY)
  private final MwCounter createdCounter;
  
  @Probe(name = "destroyedCount", level = ProbeLevel.MANDATORY)
  private final MwCounter destroyedCounter;
  
  private final FutureUtil.ExceptionHandler destroyProxyExceptionHandler;
  
  public ProxyServiceImpl(NodeEngineImpl nodeEngine) {
    this.listeners = new ConcurrentHashMap();
    this.registryConstructor = new Object(this);
    this.registries = new ConcurrentHashMap();
    this
      .createdCounter = MwCounter.newMwCounter();
    this
      .destroyedCounter = MwCounter.newMwCounter();
    this.destroyProxyExceptionHandler = new Object(this);
    this.nodeEngine = nodeEngine;
    this.logger = nodeEngine.getLogger(com.hazelcast.spi.ProxyService.class.getName());
  }
  
  public void provideMetrics(MetricsRegistry registry) { registry.scanAndRegister(this, "proxy"); }
  
  public void init() { this.nodeEngine.getEventService().registerListener("hz:core:proxyService", "hz:core:proxyService", new Object()); }
  
  @Probe(name = "proxyCount")
  public int getProxyCount() {
    int count = 0;
    for (ProxyRegistry registry : this.registries.values())
      count += registry.getProxyCount(); 
    return count;
  }
  
  public void initializeAndPublishProxies() {
    for (ProxyRegistry registry : this.registries.values())
      registry.initializeAndPublishProxies(); 
  }
  
  public void initializeDistributedObject(String serviceName, String name) {
    checkServiceNameNotNull(serviceName);
    checkObjectNameNotNull(name);
    ProxyRegistry registry = getOrCreateRegistry(serviceName);
    registry.createProxy(name, true, true);
    this.createdCounter.inc();
  }
  
  public ProxyRegistry getOrCreateRegistry(String serviceName) { return (ProxyRegistry)ConcurrencyUtil.getOrPutIfAbsent(this.registries, serviceName, this.registryConstructor); }
  
  public DistributedObject getDistributedObject(String serviceName, String name) {
    checkServiceNameNotNull(serviceName);
    checkObjectNameNotNull(name);
    ProxyRegistry registry = getOrCreateRegistry(serviceName);
    return registry.getOrCreateProxy(name, true);
  }
  
  public void destroyDistributedObject(String serviceName, String name) {
    checkServiceNameNotNull(serviceName);
    checkObjectNameNotNull(name);
    InternalOperationService internalOperationService = this.nodeEngine.getOperationService();
    Collection<Member> members = this.nodeEngine.getClusterService().getMembers();
    Collection<Future> calls = new ArrayList<Future>(members.size());
    for (Member member : members) {
      if (member.localMember())
        continue; 
      DistributedObjectDestroyOperation operation = new DistributedObjectDestroyOperation(serviceName, name);
      InternalCompletableFuture internalCompletableFuture = internalOperationService.createInvocationBuilder("hz:core:proxyService", operation, member.getAddress()).setTryCount(10).invoke();
      calls.add(internalCompletableFuture);
    } 
    destroyLocalDistributedObject(serviceName, name, true);
    FutureUtil.waitWithDeadline(calls, 30L, TimeUnit.SECONDS, this.destroyProxyExceptionHandler);
  }
  
  public void destroyLocalDistributedObject(String serviceName, String name, boolean fireEvent) {
    ProxyRegistry registry = (ProxyRegistry)this.registries.get(serviceName);
    if (registry != null) {
      registry.destroyProxy(name, fireEvent);
      this.destroyedCounter.inc();
    } 
    RemoteService service = (RemoteService)this.nodeEngine.getService(serviceName);
    service.destroyDistributedObject(name);
    String message = "DistributedObject[" + service + " -> " + name + "] has been destroyed!";
    DistributedObjectDestroyedException distributedObjectDestroyedException = new DistributedObjectDestroyedException(message);
    this.nodeEngine.getOperationParker().cancelParkedOperations(serviceName, name, distributedObjectDestroyedException);
  }
  
  public Collection<DistributedObject> getDistributedObjects(String serviceName) {
    checkServiceNameNotNull(serviceName);
    Collection<DistributedObject> result = new LinkedList<DistributedObject>();
    ProxyRegistry registry = (ProxyRegistry)this.registries.get(serviceName);
    if (registry != null)
      registry.getDistributedObjects(result); 
    return result;
  }
  
  public Collection<String> getDistributedObjectNames(String serviceName) {
    checkServiceNameNotNull(serviceName);
    ProxyRegistry registry = (ProxyRegistry)this.registries.get(serviceName);
    if (registry == null)
      return Collections.emptySet(); 
    return registry.getDistributedObjectNames();
  }
  
  public Collection<DistributedObject> getAllDistributedObjects() {
    Collection<DistributedObject> result = new LinkedList<DistributedObject>();
    for (ProxyRegistry registry : this.registries.values())
      registry.getDistributedObjects(result); 
    return result;
  }
  
  public String addProxyListener(DistributedObjectListener distributedObjectListener) {
    String id = UuidUtil.newUnsecureUuidString();
    this.listeners.put(id, distributedObjectListener);
    return id;
  }
  
  public boolean removeProxyListener(String registrationId) { return (this.listeners.remove(registrationId) != null); }
  
  public void dispatchEvent(DistributedObjectEventPacket eventPacket, Object ignore) {
    String serviceName = eventPacket.getServiceName();
    if (eventPacket.getEventType() == DistributedObjectEvent.EventType.CREATED) {
      try {
        ProxyRegistry registry = getOrCreateRegistry(serviceName);
        if (!registry.contains(eventPacket.getName()))
          registry.createProxy(eventPacket.getName(), false, true); 
      } catch (HazelcastInstanceNotActiveException ignored) {
        EmptyStatement.ignore(ignored);
      } 
    } else {
      ProxyRegistry registry = (ProxyRegistry)this.registries.get(serviceName);
      if (registry != null)
        registry.destroyProxy(eventPacket.getName(), false); 
    } 
  }
  
  public Operation getPostJoinOperation() {
    Collection<ProxyInfo> proxies = new LinkedList<ProxyInfo>();
    for (ProxyRegistry registry : this.registries.values())
      registry.getProxyInfos(proxies); 
    return proxies.isEmpty() ? null : new PostJoinProxyOperation(proxies);
  }
  
  public void shutdown() {
    for (ProxyRegistry registry : this.registries.values())
      registry.destroy(); 
    this.registries.clear();
    this.listeners.clear();
  }
  
  private static String checkServiceNameNotNull(String serviceName) { return (String)Preconditions.checkNotNull(serviceName, "Service name is required!"); }
  
  private static String checkObjectNameNotNull(String name) { return (String)Preconditions.checkNotNull(name, "Object name is required!"); }
}
