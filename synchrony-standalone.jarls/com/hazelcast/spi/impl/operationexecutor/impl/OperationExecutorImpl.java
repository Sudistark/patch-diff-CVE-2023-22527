package com.hazelcast.spi.impl.operationexecutor.impl;

import com.hazelcast.instance.NodeExtension;
import com.hazelcast.internal.metrics.MetricsProvider;
import com.hazelcast.internal.metrics.MetricsRegistry;
import com.hazelcast.internal.metrics.Probe;
import com.hazelcast.internal.metrics.ProbeLevel;
import com.hazelcast.internal.util.RuntimeAvailableProcessors;
import com.hazelcast.internal.util.concurrent.MPSCQueue;
import com.hazelcast.logging.ILogger;
import com.hazelcast.logging.LoggingService;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.Packet;
import com.hazelcast.spi.LiveOperations;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.impl.PartitionSpecificRunnable;
import com.hazelcast.spi.impl.operationexecutor.OperationExecutor;
import com.hazelcast.spi.impl.operationexecutor.OperationRunner;
import com.hazelcast.spi.impl.operationexecutor.OperationRunnerFactory;
import com.hazelcast.spi.impl.operationservice.PartitionTaskFactory;
import com.hazelcast.spi.impl.operationservice.impl.InboundResponseHandlerSupplier;
import com.hazelcast.spi.properties.GroupProperty;
import com.hazelcast.spi.properties.HazelcastProperties;
import com.hazelcast.spi.properties.HazelcastProperty;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.ThreadUtil;
import com.hazelcast.util.concurrent.IdleStrategy;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.BitSet;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public final class OperationExecutorImpl implements OperationExecutor, MetricsProvider {
  public static final HazelcastProperty IDLE_STRATEGY = new HazelcastProperty("hazelcast.operation.partitionthread.idlestrategy", "block");
  
  private static final int TERMINATION_TIMEOUT_SECONDS = 3;
  
  private final ILogger logger;
  
  private final PartitionOperationThread[] partitionThreads;
  
  private final OperationRunner[] partitionOperationRunners;
  
  private final OperationQueue genericQueue;
  
  private final GenericOperationThread[] genericThreads;
  
  private final OperationRunner[] genericOperationRunners;
  
  private final Address thisAddress;
  
  private final OperationRunner adHocOperationRunner;
  
  private final int priorityThreadCount;
  
  public OperationExecutorImpl(HazelcastProperties properties, LoggingService loggerService, Address thisAddress, OperationRunnerFactory runnerFactory, NodeExtension nodeExtension, String hzName, ClassLoader configClassLoader) {
    this.genericQueue = new OperationQueueImpl(new LinkedBlockingQueue(), new LinkedBlockingQueue());
    this.thisAddress = thisAddress;
    this.logger = loggerService.getLogger(OperationExecutorImpl.class);
    this.adHocOperationRunner = runnerFactory.createAdHocRunner();
    this.partitionOperationRunners = initPartitionOperationRunners(properties, runnerFactory);
    this.partitionThreads = initPartitionThreads(properties, hzName, nodeExtension, configClassLoader);
    this.priorityThreadCount = properties.getInteger(GroupProperty.PRIORITY_GENERIC_OPERATION_THREAD_COUNT);
    this.genericOperationRunners = initGenericOperationRunners(properties, runnerFactory);
    this.genericThreads = initGenericThreads(hzName, nodeExtension, configClassLoader);
  }
  
  private OperationRunner[] initPartitionOperationRunners(HazelcastProperties properties, OperationRunnerFactory runnerFactory) {
    OperationRunner[] operationRunners = new OperationRunner[properties.getInteger(GroupProperty.PARTITION_COUNT)];
    for (int partitionId = 0; partitionId < operationRunners.length; partitionId++)
      operationRunners[partitionId] = runnerFactory.createPartitionRunner(partitionId); 
    return operationRunners;
  }
  
  private OperationRunner[] initGenericOperationRunners(HazelcastProperties properties, OperationRunnerFactory runnerFactory) {
    int threadCount = properties.getInteger(GroupProperty.GENERIC_OPERATION_THREAD_COUNT);
    if (threadCount <= 0) {
      int coreSize = RuntimeAvailableProcessors.get();
      threadCount = Math.max(2, coreSize / 2);
    } 
    OperationRunner[] operationRunners = new OperationRunner[threadCount + this.priorityThreadCount];
    for (int partitionId = 0; partitionId < operationRunners.length; partitionId++)
      operationRunners[partitionId] = runnerFactory.createGenericRunner(); 
    return operationRunners;
  }
  
  private PartitionOperationThread[] initPartitionThreads(HazelcastProperties properties, String hzName, NodeExtension nodeExtension, ClassLoader configClassLoader) {
    int threadCount = properties.getInteger(GroupProperty.PARTITION_OPERATION_THREAD_COUNT);
    if (threadCount <= 0) {
      int coreSize = RuntimeAvailableProcessors.get();
      threadCount = Math.max(2, coreSize);
    } 
    IdleStrategy idleStrategy = InboundResponseHandlerSupplier.getIdleStrategy(properties, IDLE_STRATEGY);
    PartitionOperationThread[] threads = new PartitionOperationThread[threadCount];
    for (int threadId = 0; threadId < threads.length; threadId++) {
      String threadName = ThreadUtil.createThreadPoolName(hzName, "partition-operation") + threadId;
      MPSCQueue<Object> normalQueue = new MPSCQueue<Object>(idleStrategy);
      OperationQueueImpl operationQueueImpl = new OperationQueueImpl(normalQueue, new ConcurrentLinkedQueue());
      PartitionOperationThread partitionThread = new PartitionOperationThread(threadName, threadId, operationQueueImpl, this.logger, nodeExtension, this.partitionOperationRunners, configClassLoader);
      threads[threadId] = partitionThread;
      normalQueue.setConsumerThread(partitionThread);
    } 
    for (int partitionId = 0; partitionId < this.partitionOperationRunners.length; partitionId++) {
      int threadId = getPartitionThreadId(partitionId, threadCount);
      PartitionOperationThread partitionOperationThread = threads[threadId];
      OperationRunner runner = this.partitionOperationRunners[partitionId];
      runner.setCurrentThread(partitionOperationThread);
    } 
    return threads;
  }
  
  static int getPartitionThreadId(int partitionId, int partitionThreadCount) { return partitionId % partitionThreadCount; }
  
  private GenericOperationThread[] initGenericThreads(String hzName, NodeExtension nodeExtension, ClassLoader configClassLoader) {
    int threadCount = this.genericOperationRunners.length;
    GenericOperationThread[] threads = new GenericOperationThread[threadCount];
    int threadId = 0;
    for (int threadIndex = 0; threadIndex < threads.length; threadIndex++) {
      boolean priority = (threadIndex < this.priorityThreadCount);
      String baseName = priority ? "priority-generic-operation" : "generic-operation";
      String threadName = ThreadUtil.createThreadPoolName(hzName, baseName) + threadId;
      OperationRunner operationRunner = this.genericOperationRunners[threadIndex];
      GenericOperationThread operationThread = new GenericOperationThread(threadName, threadIndex, this.genericQueue, this.logger, nodeExtension, operationRunner, priority, configClassLoader);
      threads[threadIndex] = operationThread;
      operationRunner.setCurrentThread(operationThread);
      if (threadIndex == this.priorityThreadCount - 1) {
        threadId = 0;
      } else {
        threadId++;
      } 
    } 
    return threads;
  }
  
  public void provideMetrics(MetricsRegistry registry) {
    registry.scanAndRegister(this, "operation");
    registry.collectMetrics((Object[])this.genericThreads);
    registry.collectMetrics((Object[])this.partitionThreads);
    registry.collectMetrics(new Object[] { this.adHocOperationRunner });
    registry.collectMetrics((Object[])this.genericOperationRunners);
    registry.collectMetrics((Object[])this.partitionOperationRunners);
  }
  
  @SuppressFBWarnings({"EI_EXPOSE_REP"})
  public OperationRunner[] getPartitionOperationRunners() { return this.partitionOperationRunners; }
  
  @SuppressFBWarnings({"EI_EXPOSE_REP"})
  public OperationRunner[] getGenericOperationRunners() { return this.genericOperationRunners; }
  
  public void populate(LiveOperations liveOperations) {
    scan(this.partitionOperationRunners, liveOperations);
    scan(this.genericOperationRunners, liveOperations);
  }
  
  private void scan(OperationRunner[] runners, LiveOperations result) {
    for (OperationRunner runner : runners) {
      Object task = runner.currentTask();
      if (task instanceof Operation && task.getClass() != com.hazelcast.spi.impl.operationservice.impl.operations.Backup.class) {
        Operation operation = (Operation)task;
        result.add(operation.getCallerAddress(), operation.getCallId());
      } 
    } 
  }
  
  @Probe(name = "runningCount")
  public int getRunningOperationCount() { return getRunningPartitionOperationCount() + getRunningGenericOperationCount(); }
  
  @Probe(name = "runningPartitionCount")
  private int getRunningPartitionOperationCount() { return getRunningOperationCount(this.partitionOperationRunners); }
  
  @Probe(name = "runningGenericCount")
  private int getRunningGenericOperationCount() { return getRunningOperationCount(this.genericOperationRunners); }
  
  private static int getRunningOperationCount(OperationRunner[] runners) {
    int result = 0;
    for (OperationRunner runner : runners) {
      if (runner.currentTask() != null)
        result++; 
    } 
    return result;
  }
  
  @Probe(name = "queueSize", level = ProbeLevel.MANDATORY)
  public int getQueueSize() {
    size = 0;
    for (PartitionOperationThread partitionThread : this.partitionThreads)
      size += partitionThread.queue.normalSize(); 
    return this.genericQueue.normalSize();
  }
  
  @Probe(name = "priorityQueueSize", level = ProbeLevel.MANDATORY)
  public int getPriorityQueueSize() {
    size = 0;
    for (PartitionOperationThread partitionThread : this.partitionThreads)
      size += partitionThread.queue.prioritySize(); 
    return this.genericQueue.prioritySize();
  }
  
  @Probe
  private int getGenericQueueSize() { return this.genericQueue.normalSize(); }
  
  @Probe
  private int getGenericPriorityQueueSize() { return this.genericQueue.prioritySize(); }
  
  @Probe(name = "completedCount", level = ProbeLevel.MANDATORY)
  public long getExecutedOperationCount() {
    long result = this.adHocOperationRunner.executedOperationsCount();
    for (OperationRunner runner : this.genericOperationRunners)
      result += runner.executedOperationsCount(); 
    for (OperationRunner runner : this.partitionOperationRunners)
      result += runner.executedOperationsCount(); 
    return result;
  }
  
  @Probe
  public int getPartitionThreadCount() { return this.partitionThreads.length; }
  
  @Probe
  public int getGenericThreadCount() { return this.genericThreads.length; }
  
  public int getPartitionThreadId(int partitionId) { return getPartitionThreadId(partitionId, this.partitionThreads.length); }
  
  public void execute(Operation op) {
    Preconditions.checkNotNull(op, "op can't be null");
    execute(op, op.getPartitionId(), op.isUrgent());
  }
  
  public void executeOnPartitions(PartitionTaskFactory taskFactory, BitSet partitions) {
    Preconditions.checkNotNull(taskFactory, "taskFactory can't be null");
    Preconditions.checkNotNull(partitions, "partitions can't be null");
    for (PartitionOperationThread partitionThread : this.partitionThreads) {
      TaskBatch batch = new TaskBatch(taskFactory, partitions, partitionThread.threadId, this.partitionThreads.length);
      partitionThread.queue.add(batch, false);
    } 
  }
  
  public void execute(PartitionSpecificRunnable task) {
    Preconditions.checkNotNull(task, "task can't be null");
    execute(task, task.getPartitionId(), task instanceof com.hazelcast.spi.UrgentSystemOperation);
  }
  
  public void accept(Packet packet) { execute(packet, packet.getPartitionId(), packet.isUrgent()); }
  
  private void execute(Object task, int partitionId, boolean priority) {
    if (partitionId < 0) {
      this.genericQueue.add(task, priority);
    } else {
      PartitionOperationThread partitionOperationThread = this.partitionThreads[toPartitionThreadIndex(partitionId)];
      partitionOperationThread.queue.add(task, priority);
    } 
  }
  
  public void executeOnPartitionThreads(Runnable task) {
    Preconditions.checkNotNull(task, "task can't be null");
    boolean priority = task instanceof com.hazelcast.spi.UrgentSystemOperation;
    for (PartitionOperationThread partitionOperationThread : this.partitionThreads)
      partitionOperationThread.queue.add(task, priority); 
  }
  
  public void run(Operation operation) {
    Preconditions.checkNotNull(operation, "operation can't be null");
    if (!isRunAllowed(operation))
      throw new IllegalThreadStateException("Operation '" + operation + "' cannot be run in current thread: " + 
          Thread.currentThread()); 
    OperationRunner operationRunner = getOperationRunner(operation);
    operationRunner.run(operation);
  }
  
  OperationRunner getOperationRunner(Operation operation) {
    Preconditions.checkNotNull(operation, "operation can't be null");
    if (operation.getPartitionId() >= 0)
      return this.partitionOperationRunners[operation.getPartitionId()]; 
    Thread currentThread = Thread.currentThread();
    if (!(currentThread instanceof OperationThread))
      return this.adHocOperationRunner; 
    OperationThread operationThread = (OperationThread)currentThread;
    return operationThread.currentRunner;
  }
  
  public void runOrExecute(Operation op) {
    if (isRunAllowed(op)) {
      run(op);
    } else {
      execute(op);
    } 
  }
  
  public boolean isRunAllowed(Operation op) {
    Preconditions.checkNotNull(op, "op can't be null");
    Thread currentThread = Thread.currentThread();
    if (currentThread instanceof com.hazelcast.spi.impl.operationexecutor.OperationHostileThread)
      return false; 
    int partitionId = op.getPartitionId();
    if (partitionId < 0)
      return true; 
    if (currentThread.getClass() != PartitionOperationThread.class)
      return false; 
    PartitionOperationThread partitionThread = (PartitionOperationThread)currentThread;
    return (toPartitionThreadIndex(partitionId) == partitionThread.threadId);
  }
  
  public boolean isInvocationAllowed(Operation op, boolean isAsync) {
    Preconditions.checkNotNull(op, "op can't be null");
    Thread currentThread = Thread.currentThread();
    if (currentThread instanceof com.hazelcast.spi.impl.operationexecutor.OperationHostileThread)
      return false; 
    if (isAsync)
      return true; 
    if (op.getPartitionId() < 0)
      return true; 
    if (currentThread.getClass() != PartitionOperationThread.class)
      return true; 
    PartitionOperationThread partitionThread = (PartitionOperationThread)currentThread;
    OperationRunner runner = partitionThread.currentRunner;
    if (runner != null)
      return (runner.getPartitionId() == op.getPartitionId()); 
    return (toPartitionThreadIndex(op.getPartitionId()) == partitionThread.threadId);
  }
  
  public int toPartitionThreadIndex(int partitionId) { return partitionId % this.partitionThreads.length; }
  
  public void start() {
    this.logger.info("Starting " + this.partitionThreads.length + " partition threads and " + this.genericThreads.length + " generic threads (" + this.priorityThreadCount + " dedicated for priority tasks)");
    startAll(this.partitionThreads);
    startAll(this.genericThreads);
  }
  
  private static void startAll(OperationThread[] operationThreads) {
    for (OperationThread thread : operationThreads)
      thread.start(); 
  }
  
  public void shutdown() {
    shutdownAll(this.partitionThreads);
    shutdownAll(this.genericThreads);
    awaitTermination(this.partitionThreads);
    awaitTermination(this.genericThreads);
  }
  
  private static void shutdownAll(OperationThread[] operationThreads) {
    for (OperationThread thread : operationThreads)
      thread.shutdown(); 
  }
  
  private static void awaitTermination(OperationThread[] operationThreads) {
    for (OperationThread thread : operationThreads) {
      try {
        thread.awaitTermination(3, TimeUnit.SECONDS);
      } catch (InterruptedException ignored) {
        Thread.currentThread().interrupt();
      } 
    } 
  }
  
  public String toString() { return "OperationExecutorImpl{node=" + this.thisAddress + '}'; }
}
