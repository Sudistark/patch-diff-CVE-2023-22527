package com.hazelcast.spi.impl.operationexecutor.impl;

import com.hazelcast.util.Preconditions;
import java.util.Queue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.LinkedBlockingQueue;

public final class OperationQueueImpl implements OperationQueue {
  static final Object TRIGGER_TASK = new Object();
  
  private final BlockingQueue<Object> normalQueue;
  
  private final Queue<Object> priorityQueue;
  
  public OperationQueueImpl() { this(new LinkedBlockingQueue(), new ConcurrentLinkedQueue()); }
  
  public OperationQueueImpl(BlockingQueue<Object> normalQueue, Queue<Object> priorityQueue) {
    this.normalQueue = (BlockingQueue)Preconditions.checkNotNull(normalQueue, "normalQueue");
    this.priorityQueue = (Queue)Preconditions.checkNotNull(priorityQueue, "priorityQueue");
  }
  
  public int normalSize() { return this.normalQueue.size(); }
  
  public int prioritySize() { return this.priorityQueue.size(); }
  
  public int size() { return this.normalQueue.size() + this.priorityQueue.size(); }
  
  public void add(Object task, boolean priority) {
    Preconditions.checkNotNull(task, "task can't be null");
    if (priority) {
      this.priorityQueue.add(task);
      this.normalQueue.add(TRIGGER_TASK);
    } else {
      this.normalQueue.add(task);
    } 
  }
  
  public Object take(boolean priorityOnly) throws InterruptedException {
    Object normalItem;
    if (priorityOnly)
      return ((BlockingQueue)this.priorityQueue).take(); 
    while (true) {
      Object priorityItem = this.priorityQueue.poll();
      if (priorityItem != null)
        return priorityItem; 
      normalItem = this.normalQueue.take();
      if (normalItem == TRIGGER_TASK)
        continue; 
      break;
    } 
    return normalItem;
  }
}
