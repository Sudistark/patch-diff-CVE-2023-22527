package com.hazelcast.internal.networking.nio;

import com.hazelcast.core.HazelcastException;
import com.hazelcast.internal.metrics.MetricsRegistry;
import com.hazelcast.internal.networking.AbstractChannel;
import com.hazelcast.internal.networking.ChannelInitializer;
import com.hazelcast.internal.networking.ChannelOptions;
import com.hazelcast.internal.networking.InboundPipeline;
import com.hazelcast.internal.networking.OutboundFrame;
import com.hazelcast.internal.networking.OutboundPipeline;
import com.hazelcast.logging.ILogger;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.channels.SocketChannel;
import java.util.concurrent.Executor;
import java.util.concurrent.RejectedExecutionException;

public final class NioChannel extends AbstractChannel {
  NioInboundPipeline inboundPipeline;
  
  NioOutboundPipeline outboundPipeline;
  
  private final Executor closeListenerExecutor;
  
  private final MetricsRegistry metricsRegistry;
  
  private final ChannelInitializer channelInitializer;
  
  private final NioChannelOptions config;
  
  public NioChannel(SocketChannel socketChannel, boolean clientMode, ChannelInitializer channelInitializer, MetricsRegistry metricsRegistry, Executor closeListenerExecutor) {
    super(socketChannel, clientMode);
    this.channelInitializer = channelInitializer;
    this.metricsRegistry = metricsRegistry;
    this.closeListenerExecutor = closeListenerExecutor;
    this.config = new NioChannelOptions(socketChannel.socket());
  }
  
  public NioChannelOptions options() { return this.config; }
  
  public void init(NioInboundPipeline inboundPipeline, NioOutboundPipeline outboundPipeline) {
    this.inboundPipeline = inboundPipeline;
    this.outboundPipeline = outboundPipeline;
  }
  
  public NioOutboundPipeline outboundPipeline() { return this.outboundPipeline; }
  
  public NioInboundPipeline inboundPipeline() { return this.inboundPipeline; }
  
  public boolean write(OutboundFrame frame) {
    if (isClosed())
      return false; 
    this.outboundPipeline.write(frame);
    return true;
  }
  
  protected void onConnect() {
    String metricsId = localSocketAddress() + "->" + remoteSocketAddress();
    this.metricsRegistry.scanAndRegister(this.outboundPipeline, "tcp.connection[" + metricsId + "].out");
    this.metricsRegistry.scanAndRegister(this.inboundPipeline, "tcp.connection[" + metricsId + "].in");
  }
  
  public long lastReadTimeMillis() { return this.inboundPipeline.lastReadTimeMillis(); }
  
  public long lastWriteTimeMillis() { return this.outboundPipeline.lastWriteTimeMillis(); }
  
  public void start() {
    try {
      this.socketChannel.configureBlocking(false);
      this.channelInitializer.initChannel(this);
    } catch (Exception e) {
      throw new HazelcastException("Failed to start " + this, e);
    } 
    this.inboundPipeline.start();
    this.outboundPipeline.start();
  }
  
  protected void close0() {
    this.outboundPipeline.drainWriteQueues();
    try {
      this.socketChannel.close();
    } catch (IOException e) {
      if (this.logger.isFineEnabled())
        this.logger.fine("Failed to close " + this, e); 
    } 
    if (Thread.currentThread() instanceof NioThread) {
      try {
        this.closeListenerExecutor.execute(new NotifyCloseListenersTask(this, null));
      } catch (RejectedExecutionException e) {
        this.logger.fine(e);
      } 
    } else {
      notifyCloseListeners();
    } 
  }
  
  public long bytesRead() { return this.inboundPipeline.bytesRead(); }
  
  public long bytesWritten() { return this.outboundPipeline.bytesWritten(); }
  
  public String toString() { return "NioChannel{" + localSocketAddress() + "->" + remoteSocketAddress() + '}'; }
  
  private String getPort(SocketAddress socketAddress) { return (socketAddress == null) ? "*missing*" : Integer.toString(((InetSocketAddress)socketAddress).getPort()); }
}
