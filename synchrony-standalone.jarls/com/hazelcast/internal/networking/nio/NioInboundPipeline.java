package com.hazelcast.internal.networking.nio;

import com.hazelcast.internal.metrics.Probe;
import com.hazelcast.internal.networking.ChannelErrorHandler;
import com.hazelcast.internal.networking.ChannelHandler;
import com.hazelcast.internal.networking.HandlerStatus;
import com.hazelcast.internal.networking.InboundHandler;
import com.hazelcast.internal.networking.InboundPipeline;
import com.hazelcast.internal.networking.nio.iobalancer.IOBalancer;
import com.hazelcast.internal.util.counters.SwCounter;
import com.hazelcast.logging.ILogger;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.collection.ArrayUtils;
import java.io.EOFException;
import java.nio.ByteBuffer;
import java.util.Arrays;

public final class NioInboundPipeline extends NioPipeline implements InboundPipeline {
  private InboundHandler[] handlers = new InboundHandler[0];
  
  private ByteBuffer receiveBuffer;
  
  @Probe(name = "bytesRead")
  private final SwCounter bytesRead = SwCounter.newSwCounter();
  
  @Probe(name = "normalFramesRead")
  private final SwCounter normalFramesRead = SwCounter.newSwCounter();
  
  @Probe(name = "priorityFramesRead")
  private final SwCounter priorityFramesRead = SwCounter.newSwCounter();
  
  NioInboundPipeline(NioChannel channel, NioThread owner, ChannelErrorHandler errorHandler, ILogger logger, IOBalancer balancer) { super(channel, owner, errorHandler, 1, logger, balancer); }
  
  public long normalFramesRead() { return this.normalFramesRead.get(); }
  
  public long priorityFramesRead() { return this.priorityFramesRead.get(); }
  
  public long load() {
    switch (this.loadType) {
      case 0:
        return this.processCount.get();
      case 1:
        return this.bytesRead.get();
      case 2:
        return this.normalFramesRead.get() + this.priorityFramesRead.get();
    } 
    throw new RuntimeException();
  }
  
  @Probe(name = "idleTimeMs")
  private long idleTimeMs() { return Math.max(System.currentTimeMillis() - this.lastReadTime, 0L); }
  
  public long lastReadTimeMillis() { return this.lastReadTime; }
  
  void process() throws Exception {
    boolean unregisterRead, cleanPipeline;
    this.processCount.inc();
    this.lastReadTime = System.currentTimeMillis();
    int readBytes = this.socketChannel.read(this.receiveBuffer);
    if (readBytes == -1)
      throw new EOFException("Remote socket closed!"); 
    this.bytesRead.inc(readBytes);
    InboundHandler[] localHandlers = this.handlers;
    do {
      cleanPipeline = true;
      unregisterRead = false;
      for (int handlerIndex = 0; handlerIndex < localHandlers.length; handlerIndex++) {
        InboundHandler handler = localHandlers[handlerIndex];
        HandlerStatus handlerStatus = handler.onRead();
        if (localHandlers != this.handlers) {
          handlerIndex = -1;
          localHandlers = this.handlers;
        } else {
          switch (null.$SwitchMap$com$hazelcast$internal$networking$HandlerStatus[handlerStatus.ordinal()]) {
            case 1:
              break;
            case 2:
              cleanPipeline = false;
              break;
            case 3:
              cleanPipeline = true;
              unregisterRead = true;
              break;
            default:
              throw new IllegalStateException();
          } 
        } 
      } 
    } while (!cleanPipeline);
    if (unregisterRead)
      unregisterOp(1); 
  }
  
  long bytesRead() { return this.bytesRead.get(); }
  
  void publishMetrics() throws Exception {
    if (Thread.currentThread() != this.owner)
      return; 
    this.owner.bytesTransceived += this.bytesRead.get() - this.bytesReadLastPublish;
    this.owner.framesTransceived += this.normalFramesRead.get() - this.normalFramesReadLastPublish;
    this.owner.priorityFramesTransceived += this.priorityFramesRead.get() - this.priorityFramesReadLastPublish;
    this.owner.processCount += this.processCount.get() - this.processCountLastPublish;
    this.bytesReadLastPublish = this.bytesRead.get();
    this.normalFramesReadLastPublish = this.normalFramesRead.get();
    this.priorityFramesReadLastPublish = this.priorityFramesRead.get();
    this.processCountLastPublish = this.processCount.get();
  }
  
  public String toString() { return this.channel + ".inboundPipeline"; }
  
  protected Iterable<? extends ChannelHandler> handlers() { return Arrays.asList(this.handlers); }
  
  public InboundPipeline remove(InboundHandler handler) { return replace(handler, new InboundHandler[0]); }
  
  public InboundPipeline addLast(InboundHandler... addedHandlers) {
    Preconditions.checkNotNull(addedHandlers, "handlers can't be null");
    for (InboundHandler addedHandler : addedHandlers) {
      fixDependencies(addedHandler);
      addedHandler.setChannel(this.channel).handlerAdded();
    } 
    updatePipeline((InboundHandler[])ArrayUtils.append(this.handlers, addedHandlers));
    return this;
  }
  
  public InboundPipeline replace(InboundHandler oldHandler, InboundHandler... addedHandlers) {
    Preconditions.checkNotNull(oldHandler, "oldHandler can't be null");
    Preconditions.checkNotNull(addedHandlers, "addedHandlers can't be null");
    InboundHandler[] newHandlers = (InboundHandler[])ArrayUtils.replaceFirst(this.handlers, oldHandler, addedHandlers);
    if (newHandlers == this.handlers)
      throw new IllegalArgumentException("handler " + oldHandler + " isn't part of the pipeline"); 
    for (InboundHandler addedHandler : addedHandlers) {
      fixDependencies(addedHandler);
      addedHandler.setChannel(this.channel).handlerAdded();
    } 
    updatePipeline(newHandlers);
    return this;
  }
  
  private void fixDependencies(ChannelHandler addedHandler) {
    if (addedHandler instanceof InboundHandlerWithCounters) {
      InboundHandlerWithCounters c = (InboundHandlerWithCounters)addedHandler;
      c.setNormalPacketsRead(this.normalFramesRead);
      c.setPriorityPacketsRead(this.priorityFramesRead);
    } 
  }
  
  private void updatePipeline(InboundHandler[] handlers) {
    this.handlers = handlers;
    this.receiveBuffer = (handlers.length == 0) ? null : (ByteBuffer)handlers[0].src();
    InboundHandler prev = null;
    for (InboundHandler handler : handlers) {
      if (prev != null) {
        Object src = handler.src();
        if (src instanceof ByteBuffer)
          prev.dst(src); 
      } 
      prev = handler;
    } 
  }
  
  private String pipelineToString() {
    StringBuilder sb = new StringBuilder("in-pipeline[");
    InboundHandler[] handlers = this.handlers;
    for (int k = 0; k < handlers.length; k++) {
      if (k > 0)
        sb.append("->-"); 
      sb.append(handlers[k].getClass().getSimpleName());
    } 
    sb.append(']');
    return sb.toString();
  }
  
  public NioInboundPipeline wakeup() {
    addTaskAndWakeup(new Object(this, this));
    return this;
  }
}
