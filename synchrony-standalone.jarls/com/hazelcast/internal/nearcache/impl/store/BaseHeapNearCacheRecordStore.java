package com.hazelcast.internal.nearcache.impl.store;

import com.hazelcast.config.EvictionConfig;
import com.hazelcast.config.NearCacheConfig;
import com.hazelcast.config.NearCachePreloaderConfig;
import com.hazelcast.core.IBiFunction;
import com.hazelcast.internal.adapter.DataStructureAdapter;
import com.hazelcast.internal.eviction.Evictable;
import com.hazelcast.internal.eviction.EvictionChecker;
import com.hazelcast.internal.nearcache.NearCacheRecord;
import com.hazelcast.internal.nearcache.impl.SampleableNearCacheRecordMap;
import com.hazelcast.internal.nearcache.impl.maxsize.EntryCountNearCacheEvictionChecker;
import com.hazelcast.internal.nearcache.impl.preloader.NearCachePreloader;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.serialization.SerializationService;
import java.util.Map;

public abstract class BaseHeapNearCacheRecordStore<K, V, R extends NearCacheRecord> extends AbstractNearCacheRecordStore<K, V, K, R, HeapNearCacheRecordMap<K, R>> {
  private static final int DEFAULT_INITIAL_CAPACITY = 1000;
  
  private final NearCachePreloader<K> nearCachePreloader;
  
  private final IBiFunction<? super K, ? super R, ? extends R> invalidatorFunction = createInvalidatorFunction();
  
  BaseHeapNearCacheRecordStore(String name, NearCacheConfig nearCacheConfig, SerializationService serializationService, ClassLoader classLoader) {
    super(nearCacheConfig, serializationService, classLoader);
    NearCachePreloaderConfig preloaderConfig = nearCacheConfig.getPreloaderConfig();
    this.nearCachePreloader = preloaderConfig.isEnabled() ? new NearCachePreloader(name, preloaderConfig, this.nearCacheStats, serializationService) : null;
  }
  
  protected EvictionChecker createNearCacheEvictionChecker(EvictionConfig evictionConfig, NearCacheConfig nearCacheConfig) {
    EvictionConfig.MaxSizePolicy maxSizePolicy = evictionConfig.getMaximumSizePolicy();
    if (maxSizePolicy != EvictionConfig.MaxSizePolicy.ENTRY_COUNT)
      throw new IllegalArgumentException(String.format("Invalid max-size policy (%s) for %s! Only %s is supported.", new Object[] { maxSizePolicy, 
              getClass().getName(), EvictionConfig.MaxSizePolicy.ENTRY_COUNT })); 
    return new EntryCountNearCacheEvictionChecker(evictionConfig.getSize(), this.records);
  }
  
  protected HeapNearCacheRecordMap<K, R> createNearCacheRecordMap(NearCacheConfig nearCacheConfig) { return new HeapNearCacheRecordMap(this.serializationService, 1000); }
  
  public R getRecord(K key) { return (R)(NearCacheRecord)((HeapNearCacheRecordMap)this.records).get(key); }
  
  protected R putRecord(K key, R record) {
    R oldRecord = (R)(NearCacheRecord)((HeapNearCacheRecordMap)this.records).put(key, record);
    this.nearCacheStats.incrementOwnedEntryMemoryCost(getTotalStorageMemoryCost(key, record));
    if (oldRecord != null)
      this.nearCacheStats.decrementOwnedEntryMemoryCost(getTotalStorageMemoryCost(key, oldRecord)); 
    return oldRecord;
  }
  
  protected boolean containsRecordKey(K key) { return ((HeapNearCacheRecordMap)this.records).containsKey(key); }
  
  public void onEvict(K key, R record, boolean wasExpired) {
    super.onEvict(key, record, wasExpired);
    this.nearCacheStats.decrementOwnedEntryMemoryCost(getTotalStorageMemoryCost(key, record));
  }
  
  public void doExpiration() {
    for (Map.Entry<K, R> entry : ((HeapNearCacheRecordMap)this.records).entrySet()) {
      K key = (K)entry.getKey();
      R value = (R)(NearCacheRecord)entry.getValue();
      if (isRecordExpired(value)) {
        invalidate(key);
        onExpire(key, value);
      } 
    } 
  }
  
  public void loadKeys(DataStructureAdapter<Object, ?> adapter) {
    if (this.nearCachePreloader != null)
      this.nearCachePreloader.loadKeys(adapter); 
  }
  
  public void storeKeys() {
    if (this.nearCachePreloader != null)
      this.nearCachePreloader.storeKeys(((HeapNearCacheRecordMap)this.records).keySet().iterator()); 
  }
  
  public void destroy() {
    super.destroy();
    if (this.nearCachePreloader != null)
      this.nearCachePreloader.destroy(); 
  }
  
  protected R getOrCreateToReserve(K key, Data keyData) { return (R)(NearCacheRecord)((HeapNearCacheRecordMap)this.records).applyIfAbsent(key, new AbstractNearCacheRecordStore.ReserveForUpdateFunction(this, keyData)); }
  
  protected V updateAndGetReserved(K key, V value, long reservationId, boolean deserialize) {
    R existingRecord = (R)(NearCacheRecord)((HeapNearCacheRecordMap)this.records).applyIfPresent(key, new Object(this, value, reservationId));
    if (existingRecord == null || !deserialize)
      return null; 
    Object cachedValue = existingRecord.getValue();
    return (V)((cachedValue instanceof Data) ? toValue(cachedValue) : cachedValue);
  }
  
  public void invalidate(K key) {
    ((HeapNearCacheRecordMap)this.records).applyIfPresent(key, this.invalidatorFunction);
    this.nearCacheStats.incrementInvalidationRequests();
  }
  
  private IBiFunction<K, R, R> createInvalidatorFunction() { return new Object(this); }
}
