package com.hazelcast.internal.nearcache.impl.store;

import com.hazelcast.config.EvictionConfig;
import com.hazelcast.config.EvictionPolicy;
import com.hazelcast.config.InMemoryFormat;
import com.hazelcast.config.NearCacheConfig;
import com.hazelcast.internal.eviction.Evictable;
import com.hazelcast.internal.eviction.EvictionChecker;
import com.hazelcast.internal.eviction.EvictionListener;
import com.hazelcast.internal.eviction.EvictionPolicyEvaluatorProvider;
import com.hazelcast.internal.eviction.impl.evaluator.EvictionPolicyEvaluator;
import com.hazelcast.internal.eviction.impl.strategy.sampling.SamplingEvictionStrategy;
import com.hazelcast.internal.memory.GlobalMemoryAccessorRegistry;
import com.hazelcast.internal.nearcache.NearCache;
import com.hazelcast.internal.nearcache.NearCacheRecord;
import com.hazelcast.internal.nearcache.NearCacheRecordStore;
import com.hazelcast.internal.nearcache.impl.SampleableNearCacheRecordMap;
import com.hazelcast.internal.nearcache.impl.invalidation.MetaDataContainer;
import com.hazelcast.internal.nearcache.impl.invalidation.StaleReadDetector;
import com.hazelcast.monitor.NearCacheStats;
import com.hazelcast.monitor.impl.NearCacheStatsImpl;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.Clock;
import com.hazelcast.util.ExceptionUtil;
import java.util.concurrent.atomic.AtomicLongFieldUpdater;

public abstract class AbstractNearCacheRecordStore<K, V, KS, R extends NearCacheRecord, NCRM extends SampleableNearCacheRecordMap<KS, R>> extends Object implements NearCacheRecordStore<K, V>, EvictionListener<KS, R> {
  protected static final AtomicLongFieldUpdater<AbstractNearCacheRecordStore> RESERVATION_ID = AtomicLongFieldUpdater.newUpdater(AbstractNearCacheRecordStore.class, "reservationId");
  
  protected static final long REFERENCE_SIZE = GlobalMemoryAccessorRegistry.MEM_AVAILABLE ? GlobalMemoryAccessorRegistry.MEM.arrayIndexScale(Object[].class) : 4L;
  
  protected static final long MILLI_SECONDS_IN_A_SECOND = 1000L;
  
  protected final long timeToLiveMillis;
  
  protected final long maxIdleMillis;
  
  protected final boolean evictionDisabled;
  
  protected final ClassLoader classLoader;
  
  protected final InMemoryFormat inMemoryFormat;
  
  protected final NearCacheConfig nearCacheConfig;
  
  protected final NearCacheStatsImpl nearCacheStats;
  
  protected final SerializationService serializationService;
  
  protected NCRM records;
  
  protected EvictionChecker evictionChecker;
  
  protected SamplingEvictionStrategy<KS, R, NCRM> evictionStrategy;
  
  protected EvictionPolicyEvaluator<KS, R> evictionPolicyEvaluator;
  
  public AbstractNearCacheRecordStore(NearCacheConfig nearCacheConfig, SerializationService serializationService, ClassLoader classLoader) { this(nearCacheConfig, new NearCacheStatsImpl(), serializationService, classLoader); }
  
  protected AbstractNearCacheRecordStore(NearCacheConfig nearCacheConfig, NearCacheStatsImpl nearCacheStats, SerializationService serializationService, ClassLoader classLoader) {
    this.staleReadDetector = StaleReadDetector.ALWAYS_FRESH;
    this.nearCacheConfig = nearCacheConfig;
    this.inMemoryFormat = nearCacheConfig.getInMemoryFormat();
    this.timeToLiveMillis = nearCacheConfig.getTimeToLiveSeconds() * 1000L;
    this.maxIdleMillis = nearCacheConfig.getMaxIdleSeconds() * 1000L;
    this.serializationService = serializationService;
    this.classLoader = classLoader;
    this.nearCacheStats = nearCacheStats;
    this.evictionDisabled = (nearCacheConfig.getEvictionConfig().getEvictionPolicy() == EvictionPolicy.NONE);
  }
  
  public void initialize() {
    this.records = createNearCacheRecordMap(this.nearCacheConfig);
    EvictionConfig evictionConfig = this.nearCacheConfig.getEvictionConfig();
    this.evictionChecker = createNearCacheEvictionChecker(evictionConfig, this.nearCacheConfig);
    if (!this.evictionDisabled) {
      this.evictionStrategy = SamplingEvictionStrategy.INSTANCE;
      this.evictionPolicyEvaluator = EvictionPolicyEvaluatorProvider.getEvictionPolicyEvaluator(evictionConfig, this.classLoader);
    } 
  }
  
  public void setStaleReadDetector(StaleReadDetector staleReadDetector) { this.staleReadDetector = staleReadDetector; }
  
  protected void checkAvailable() {
    if (!isAvailable())
      throw new IllegalStateException(this.nearCacheConfig.getName() + " named Near Cache record store is not available"); 
  }
  
  private boolean isAvailable() { return (this.records != null); }
  
  protected Data toData(Object obj) { return this.serializationService.toData(obj); }
  
  protected V toValue(Object obj) { return (V)this.serializationService.toObject(obj); }
  
  protected long getTotalStorageMemoryCost(K key, R record) { return getKeyStorageMemoryCost(key) + getRecordStorageMemoryCost(record); }
  
  protected boolean isRecordExpired(R record) {
    long now = Clock.currentTimeMillis();
    if (record.isExpiredAt(now))
      return true; 
    return record.isIdleAt(this.maxIdleMillis, now);
  }
  
  protected V recordToValue(R record) {
    if (record.getValue() == null)
      return (V)NearCache.CACHED_AS_NULL; 
    return (V)toValue(record.getValue());
  }
  
  protected void onGet(K key, V value, R record) {}
  
  protected void onGetError(K key, V value, R record, Throwable error) {}
  
  protected void onPut(K key, V value, R record, R oldRecord) {}
  
  protected void onPutError(K key, V value, R record, R oldRecord, Throwable error) {}
  
  protected void onRemove(K key, R record, boolean removed) {}
  
  protected void onRemoveError(K key, R record, boolean removed, Throwable error) {}
  
  protected void onExpire(K key, R record) { this.nearCacheStats.incrementExpirations(); }
  
  public void onEvict(KS key, R record, boolean wasExpired) {
    if (wasExpired) {
      this.nearCacheStats.incrementExpirations();
    } else {
      this.nearCacheStats.incrementEvictions();
    } 
    this.nearCacheStats.decrementOwnedEntryCount();
  }
  
  public V get(K key) {
    checkAvailable();
    R record = null;
    V value = null;
    try {
      record = (R)getRecord(key);
      if (record != null) {
        if (record.getRecordState() != -4L)
          return null; 
        if (this.staleReadDetector.isStaleRead(key, record)) {
          invalidate(key);
          this.nearCacheStats.incrementMisses();
          return null;
        } 
        if (isRecordExpired(record)) {
          invalidate(key);
          onExpire(key, record);
          return null;
        } 
        onRecordAccess(record);
        this.nearCacheStats.incrementHits();
        value = (V)recordToValue(record);
        onGet(key, value, record);
        return value;
      } 
      this.nearCacheStats.incrementMisses();
      return null;
    } catch (Throwable error) {
      onGetError(key, value, record, error);
      throw ExceptionUtil.rethrow(error);
    } 
  }
  
  public void put(K key, Data keyData, V value, Data valueData) {
    checkAvailable();
    if (this.evictionDisabled && this.evictionChecker.isEvictionRequired() && !containsRecordKey(key))
      return; 
    R record = null;
    R oldRecord = null;
    try {
      record = (R)createRecord(selectInMemoryFormatFriendlyValue(this.inMemoryFormat, value, valueData));
      onRecordCreate(key, keyData, record);
      oldRecord = (R)putRecord(key, record);
      if (oldRecord == null)
        this.nearCacheStats.incrementOwnedEntryCount(); 
      onPut(key, value, record, oldRecord);
    } catch (Throwable error) {
      onPutError(key, value, record, oldRecord, error);
      throw ExceptionUtil.rethrow(error);
    } 
  }
  
  private static Object selectInMemoryFormatFriendlyValue(InMemoryFormat inMemoryFormat, Object value1, Object value2) {
    switch (null.$SwitchMap$com$hazelcast$config$InMemoryFormat[inMemoryFormat.ordinal()]) {
      case 1:
        return prioritizeObjectValue(value1, value2);
      case 2:
      case 3:
        return prioritizeDataValue(value1, value2);
    } 
    throw new IllegalArgumentException(String.format("Unrecognized in memory format was found: '%s'", new Object[] { inMemoryFormat }));
  }
  
  private static Object prioritizeObjectValue(Object value1, Object value2) {
    boolean value1NotNull = (value1 != null);
    if (value1NotNull && !(value1 instanceof Data))
      return value1; 
    boolean value2NotNull = (value2 != null);
    if (value2NotNull && !(value2 instanceof Data))
      return value2; 
    if (value1NotNull)
      return value1; 
    if (value2NotNull)
      return value2; 
    return null;
  }
  
  private static Object prioritizeDataValue(Object value1, Object value2) {
    if (value1 instanceof Data)
      return value1; 
    if (value2 instanceof Data)
      return value2; 
    if (value1 != null)
      return value1; 
    if (value2 != null)
      return value2; 
    return null;
  }
  
  protected boolean canUpdateStats(R record) { return (record != null && record.getRecordState() == -4L); }
  
  public void clear() {
    checkAvailable();
    int size = this.records.size();
    this.records.clear();
    this.nearCacheStats.setOwnedEntryCount(0L);
    this.nearCacheStats.setOwnedEntryMemoryCost(0L);
    this.nearCacheStats.incrementInvalidations(size);
    this.nearCacheStats.incrementInvalidationRequests();
  }
  
  public void destroy() { clear(); }
  
  public NearCacheStats getNearCacheStats() {
    checkAvailable();
    return this.nearCacheStats;
  }
  
  public int size() {
    checkAvailable();
    return this.records.size();
  }
  
  public void doEviction(boolean withoutMaxSizeCheck) {
    checkAvailable();
    if (!this.evictionDisabled) {
      EvictionChecker evictionChecker = withoutMaxSizeCheck ? null : this.evictionChecker;
      this.evictionStrategy.evict(this.records, this.evictionPolicyEvaluator, evictionChecker, this);
    } 
  }
  
  public long tryReserveForUpdate(K key, Data keyData) {
    checkAvailable();
    if (this.evictionDisabled && this.evictionChecker.isEvictionRequired() && !containsRecordKey(key))
      return -1L; 
    R reservedRecord = (R)getOrCreateToReserve(key, keyData);
    long reservationId = nextReservationId();
    if (reservedRecord.casRecordState(-2L, reservationId))
      return reservationId; 
    return -1L;
  }
  
  public V tryPublishReserved(K key, V value, long reservationId, boolean deserialize) {
    checkAvailable();
    return (V)updateAndGetReserved(key, value, reservationId, deserialize);
  }
  
  public StaleReadDetector getStaleReadDetector() { return this.staleReadDetector; }
  
  protected void onRecordCreate(K key, Data keyData, R record) {
    record.setCreationTime(Clock.currentTimeMillis());
    initInvalidationMetaData(record, key, keyData);
  }
  
  protected R updateReservedRecordInternal(K key, V value, R reservedRecord, long reservationId) {
    if (!reservedRecord.casRecordState(reservationId, -3L))
      return reservedRecord; 
    updateRecordValue(reservedRecord, value);
    reservedRecord.casRecordState(-3L, -4L);
    this.nearCacheStats.incrementOwnedEntryMemoryCost(getTotalStorageMemoryCost(key, reservedRecord));
    this.nearCacheStats.incrementOwnedEntryCount();
    return reservedRecord;
  }
  
  private void onRecordAccess(R record) {
    record.setAccessTime(Clock.currentTimeMillis());
    record.incrementAccessHit();
  }
  
  private void initInvalidationMetaData(R record, K key, Data keyData) {
    if (this.staleReadDetector == StaleReadDetector.ALWAYS_FRESH)
      return; 
    int partitionId = this.staleReadDetector.getPartitionId((keyData == null) ? toData(key) : keyData);
    MetaDataContainer metaDataContainer = this.staleReadDetector.getMetaDataContainer(partitionId);
    record.setPartitionId(partitionId);
    record.setInvalidationSequence(metaDataContainer.getSequence());
    record.setUuid(metaDataContainer.getUuid());
  }
  
  private long nextReservationId() { return RESERVATION_ID.incrementAndGet(this); }
  
  public abstract R getRecord(K paramK);
  
  protected abstract EvictionChecker createNearCacheEvictionChecker(EvictionConfig paramEvictionConfig, NearCacheConfig paramNearCacheConfig);
  
  protected abstract NCRM createNearCacheRecordMap(NearCacheConfig paramNearCacheConfig);
  
  protected abstract long getKeyStorageMemoryCost(K paramK);
  
  protected abstract long getRecordStorageMemoryCost(R paramR);
  
  protected abstract R createRecord(V paramV);
  
  protected abstract void updateRecordValue(R paramR, V paramV);
  
  protected abstract R getOrCreateToReserve(K paramK, Data paramData);
  
  protected abstract V updateAndGetReserved(K paramK, V paramV, long paramLong, boolean paramBoolean);
  
  protected abstract R putRecord(K paramK, R paramR);
  
  protected abstract boolean containsRecordKey(K paramK);
}
