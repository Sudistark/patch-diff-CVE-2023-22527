package com.hazelcast.internal.nearcache.impl.invalidation;

import com.hazelcast.core.Member;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.util.MapUtil;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentMap;

public abstract class InvalidationMetaDataFetcher {
  protected static final int ASYNC_RESULT_WAIT_TIMEOUT_MINUTES = 1;
  
  protected final ILogger logger;
  
  public InvalidationMetaDataFetcher(ILogger logger) { this.logger = logger; }
  
  public final void init(RepairingHandler handler) throws Exception {
    MetadataHolder resultHolder = new MetadataHolder();
    List<String> dataStructureNames = Collections.singletonList(handler.getName());
    Map<Member, InternalCompletableFuture> futureByMember = fetchMembersMetadataFor(dataStructureNames);
    for (Map.Entry<Member, InternalCompletableFuture> entry : futureByMember.entrySet()) {
      Member member = (Member)entry.getKey();
      InternalCompletableFuture future = (InternalCompletableFuture)entry.getValue();
      extractMemberMetadata(member, future, resultHolder);
      initUuid(MetadataHolder.access$000(resultHolder), handler);
      initSequence(MetadataHolder.access$100(resultHolder), handler);
    } 
  }
  
  public final void fetchMetadata(ConcurrentMap<String, RepairingHandler> handlers) {
    if (handlers.isEmpty())
      return; 
    List<String> dataStructureNames = getDataStructureNames(handlers);
    Map<Member, InternalCompletableFuture> futureByMember = fetchMembersMetadataFor(dataStructureNames);
    for (Map.Entry<Member, InternalCompletableFuture> entry : futureByMember.entrySet()) {
      Member member = (Member)entry.getKey();
      InternalCompletableFuture future = (InternalCompletableFuture)entry.getValue();
      processMemberMetadata(member, future, handlers);
    } 
  }
  
  protected abstract Collection<Member> getDataMembers();
  
  protected abstract void extractMemberMetadata(Member paramMember, InternalCompletableFuture paramInternalCompletableFuture, MetadataHolder paramMetadataHolder) throws Exception;
  
  protected abstract InternalCompletableFuture fetchMetadataOf(Address paramAddress, List<String> paramList);
  
  private Map<Member, InternalCompletableFuture> fetchMembersMetadataFor(List<String> names) {
    Collection<Member> members = getDataMembers();
    if (members.isEmpty())
      return Collections.emptyMap(); 
    Map<Member, InternalCompletableFuture> futureByMember = MapUtil.createHashMap(members.size());
    for (Member member : members) {
      Address address = member.getAddress();
      try {
        futureByMember.put(member, fetchMetadataOf(address, names));
      } catch (Exception e) {
        handleExceptionWhileProcessingMetadata(member, e);
      } 
    } 
    return futureByMember;
  }
  
  private void processMemberMetadata(Member member, InternalCompletableFuture future, ConcurrentMap<String, RepairingHandler> handlers) {
    MetadataHolder resultHolder = new MetadataHolder();
    try {
      extractMemberMetadata(member, future, resultHolder);
    } catch (Exception e) {
      handleExceptionWhileProcessingMetadata(member, e);
      return;
    } 
    repairUuids(MetadataHolder.access$000(resultHolder), handlers);
    repairSequences(MetadataHolder.access$100(resultHolder), handlers);
  }
  
  protected void handleExceptionWhileProcessingMetadata(Member member, Exception e) {
    if (e instanceof IllegalStateException) {
      this.logger.finest(e);
    } else if (this.logger.isWarningEnabled()) {
      this.logger.warning(String.format("Can't fetch or extract invalidation meta-data of %s", new Object[] { member }), e);
    } 
  }
  
  private List<String> getDataStructureNames(ConcurrentMap<String, RepairingHandler> handlers) {
    List<String> names = new ArrayList<String>(handlers.size());
    for (RepairingHandler handler : handlers.values())
      names.add(handler.getName()); 
    return names;
  }
  
  private void repairUuids(Collection<Map.Entry<Integer, UUID>> uuids, ConcurrentMap<String, RepairingHandler> handlers) {
    for (Map.Entry<Integer, UUID> entry : uuids) {
      for (RepairingHandler handler : handlers.values())
        handler.checkOrRepairUuid(((Integer)entry.getKey()).intValue(), (UUID)entry.getValue()); 
    } 
  }
  
  private void initUuid(Collection<Map.Entry<Integer, UUID>> uuids, RepairingHandler handler) {
    for (Map.Entry<Integer, UUID> entry : uuids) {
      int partitionID = ((Integer)entry.getKey()).intValue();
      UUID partitionUuid = (UUID)entry.getValue();
      handler.initUuid(partitionID, partitionUuid);
    } 
  }
  
  private void repairSequences(Collection<Map.Entry<String, List<Map.Entry<Integer, Long>>>> namePartitionSequenceList, ConcurrentMap<String, RepairingHandler> handlers) {
    for (Map.Entry<String, List<Map.Entry<Integer, Long>>> entry : namePartitionSequenceList) {
      for (Map.Entry<Integer, Long> subEntry : (List)entry.getValue()) {
        RepairingHandler repairingHandler = (RepairingHandler)handlers.get(entry.getKey());
        repairingHandler.checkOrRepairSequence(((Integer)subEntry.getKey()).intValue(), ((Long)subEntry.getValue()).longValue(), true);
      } 
    } 
  }
  
  private void initSequence(Collection<Map.Entry<String, List<Map.Entry<Integer, Long>>>> namePartitionSequenceList, RepairingHandler handler) {
    for (Map.Entry<String, List<Map.Entry<Integer, Long>>> entry : namePartitionSequenceList) {
      for (Map.Entry<Integer, Long> subEntry : (List)entry.getValue()) {
        int partitionID = ((Integer)subEntry.getKey()).intValue();
        long partitionSequence = ((Long)subEntry.getValue()).longValue();
        handler.initSequence(partitionID, partitionSequence);
      } 
    } 
  }
}
