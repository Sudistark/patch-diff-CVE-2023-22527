package com.hazelcast.internal.nearcache.impl;

import com.hazelcast.config.InMemoryFormat;
import com.hazelcast.config.NearCacheConfig;
import com.hazelcast.internal.adapter.DataStructureAdapter;
import com.hazelcast.internal.nearcache.NearCache;
import com.hazelcast.internal.nearcache.NearCacheRecordStore;
import com.hazelcast.internal.nearcache.impl.store.NearCacheDataRecordStore;
import com.hazelcast.internal.nearcache.impl.store.NearCacheObjectRecordStore;
import com.hazelcast.monitor.NearCacheStats;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.TaskScheduler;
import com.hazelcast.spi.properties.HazelcastProperties;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.Preconditions;
import java.util.concurrent.ScheduledFuture;

public class DefaultNearCache<K, V> extends Object implements NearCache<K, V> {
  protected final String name;
  
  protected final TaskScheduler scheduler;
  
  protected final ClassLoader classLoader;
  
  protected final NearCacheConfig nearCacheConfig;
  
  protected final SerializationService serializationService;
  
  protected ScheduledFuture expirationTaskFuture;
  
  protected NearCacheRecordStore<K, V> nearCacheRecordStore;
  
  private final boolean serializeKeys;
  
  private final HazelcastProperties properties;
  
  public DefaultNearCache(String name, NearCacheConfig nearCacheConfig, SerializationService serializationService, TaskScheduler scheduler, ClassLoader classLoader, HazelcastProperties properties) { this(name, nearCacheConfig, null, serializationService, scheduler, classLoader, properties); }
  
  public DefaultNearCache(String name, NearCacheConfig nearCacheConfig, NearCacheRecordStore<K, V> nearCacheRecordStore, SerializationService serializationService, TaskScheduler scheduler, ClassLoader classLoader, HazelcastProperties properties) {
    this.name = name;
    this.nearCacheConfig = nearCacheConfig;
    this.serializationService = serializationService;
    this.classLoader = classLoader;
    this.scheduler = scheduler;
    this.nearCacheRecordStore = nearCacheRecordStore;
    this.serializeKeys = nearCacheConfig.isSerializeKeys();
    this.properties = properties;
  }
  
  public void initialize() {
    if (this.nearCacheRecordStore == null)
      this.nearCacheRecordStore = createNearCacheRecordStore(this.name, this.nearCacheConfig); 
    this.nearCacheRecordStore.initialize();
    this.expirationTaskFuture = createAndScheduleExpirationTask();
  }
  
  protected NearCacheRecordStore<K, V> createNearCacheRecordStore(String name, NearCacheConfig nearCacheConfig) {
    InMemoryFormat inMemoryFormat = nearCacheConfig.getInMemoryFormat();
    if (inMemoryFormat == null)
      inMemoryFormat = NearCacheConfig.DEFAULT_MEMORY_FORMAT; 
    switch (null.$SwitchMap$com$hazelcast$config$InMemoryFormat[inMemoryFormat.ordinal()]) {
      case 1:
        return new NearCacheDataRecordStore(name, nearCacheConfig, this.serializationService, this.classLoader);
      case 2:
        return new NearCacheObjectRecordStore(name, nearCacheConfig, this.serializationService, this.classLoader);
    } 
    throw new IllegalArgumentException("Invalid in memory format: " + inMemoryFormat);
  }
  
  private ScheduledFuture createAndScheduleExpirationTask() {
    if (this.nearCacheConfig.getMaxIdleSeconds() > 0L || this.nearCacheConfig.getTimeToLiveSeconds() > 0L) {
      ExpirationTask expirationTask = new ExpirationTask(this, null);
      return ExpirationTask.access$100(expirationTask, this.scheduler);
    } 
    return null;
  }
  
  public String getName() { return this.name; }
  
  public V get(K key) {
    checkKeyFormat(key);
    return (V)this.nearCacheRecordStore.get(key);
  }
  
  public void put(K key, Data keyData, V value, Data valueData) {
    checkKeyFormat(key);
    this.nearCacheRecordStore.doEviction(false);
    this.nearCacheRecordStore.put(key, keyData, value, valueData);
  }
  
  public void invalidate(K key) {
    checkKeyFormat(key);
    this.nearCacheRecordStore.invalidate(key);
  }
  
  public void clear() { this.nearCacheRecordStore.clear(); }
  
  public void destroy() {
    if (this.expirationTaskFuture != null)
      this.expirationTaskFuture.cancel(true); 
    this.nearCacheRecordStore.destroy();
  }
  
  public NearCacheStats getNearCacheStats() { return this.nearCacheRecordStore.getNearCacheStats(); }
  
  public boolean isSerializeKeys() { return this.serializeKeys; }
  
  public int size() { return this.nearCacheRecordStore.size(); }
  
  public void preload(DataStructureAdapter<Object, ?> adapter) {
    this.nearCacheRecordStore.loadKeys(adapter);
    this.preloadDone = true;
  }
  
  public void storeKeys() {
    if (this.preloadDone)
      this.nearCacheRecordStore.storeKeys(); 
  }
  
  public boolean isPreloadDone() { return this.preloadDone; }
  
  public <T> T unwrap(Class<T> clazz) {
    if (clazz.isAssignableFrom(getClass()))
      return (T)clazz.cast(this); 
    throw new IllegalArgumentException("Unwrapping to " + clazz + " is not supported by this implementation");
  }
  
  public long tryReserveForUpdate(K key, Data keyData) {
    this.nearCacheRecordStore.doEviction(false);
    return this.nearCacheRecordStore.tryReserveForUpdate(key, keyData);
  }
  
  public V tryPublishReserved(K key, V value, long reservationId, boolean deserialize) { return (V)this.nearCacheRecordStore.tryPublishReserved(key, value, reservationId, deserialize); }
  
  public NearCacheRecordStore<K, V> getNearCacheRecordStore() { return this.nearCacheRecordStore; }
  
  private void checkKeyFormat(K key) {
    if (this.serializeKeys) {
      Preconditions.checkInstanceOf(Data.class, key, "key must be of type Data!");
    } else {
      Preconditions.checkNotInstanceOf(Data.class, key, "key cannot be of type Data!");
    } 
  }
}
