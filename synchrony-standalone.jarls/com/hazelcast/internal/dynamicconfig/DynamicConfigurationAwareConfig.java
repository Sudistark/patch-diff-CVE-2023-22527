package com.hazelcast.internal.dynamicconfig;

import com.hazelcast.config.AdvancedNetworkConfig;
import com.hazelcast.config.AtomicLongConfig;
import com.hazelcast.config.AtomicReferenceConfig;
import com.hazelcast.config.CRDTReplicationConfig;
import com.hazelcast.config.CacheSimpleConfig;
import com.hazelcast.config.CardinalityEstimatorConfig;
import com.hazelcast.config.Config;
import com.hazelcast.config.ConfigPatternMatcher;
import com.hazelcast.config.ConfigurationException;
import com.hazelcast.config.CountDownLatchConfig;
import com.hazelcast.config.DurableExecutorConfig;
import com.hazelcast.config.EventJournalConfig;
import com.hazelcast.config.ExecutorConfig;
import com.hazelcast.config.FlakeIdGeneratorConfig;
import com.hazelcast.config.GroupConfig;
import com.hazelcast.config.HotRestartPersistenceConfig;
import com.hazelcast.config.JobTrackerConfig;
import com.hazelcast.config.ListConfig;
import com.hazelcast.config.ListenerConfig;
import com.hazelcast.config.LockConfig;
import com.hazelcast.config.ManagementCenterConfig;
import com.hazelcast.config.MapConfig;
import com.hazelcast.config.MemberAttributeConfig;
import com.hazelcast.config.MerkleTreeConfig;
import com.hazelcast.config.MultiMapConfig;
import com.hazelcast.config.NativeMemoryConfig;
import com.hazelcast.config.NetworkConfig;
import com.hazelcast.config.PNCounterConfig;
import com.hazelcast.config.PartitionGroupConfig;
import com.hazelcast.config.QueueConfig;
import com.hazelcast.config.QuorumConfig;
import com.hazelcast.config.ReliableTopicConfig;
import com.hazelcast.config.ReplicatedMapConfig;
import com.hazelcast.config.RingbufferConfig;
import com.hazelcast.config.ScheduledExecutorConfig;
import com.hazelcast.config.SecurityConfig;
import com.hazelcast.config.SemaphoreConfig;
import com.hazelcast.config.SerializationConfig;
import com.hazelcast.config.ServicesConfig;
import com.hazelcast.config.SetConfig;
import com.hazelcast.config.TopicConfig;
import com.hazelcast.config.UserCodeDeploymentConfig;
import com.hazelcast.config.WanReplicationConfig;
import com.hazelcast.config.cp.CPSubsystemConfig;
import com.hazelcast.core.ManagedContext;
import com.hazelcast.internal.dynamicconfig.search.ConfigSearch;
import com.hazelcast.internal.dynamicconfig.search.ConfigSupplier;
import com.hazelcast.internal.dynamicconfig.search.Searcher;
import com.hazelcast.security.SecurityService;
import com.hazelcast.spi.properties.GroupProperty;
import com.hazelcast.spi.properties.HazelcastProperties;
import com.hazelcast.util.StringUtil;
import java.io.File;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentMap;

public class DynamicConfigurationAwareConfig extends Config {
  private final ConfigSupplier<MapConfig> mapConfigOrNullConfigSupplier = new Object(this);
  
  private final ConfigSupplier<EventJournalConfig> mapEventJournalConfigSupplier = new Object(this);
  
  private final ConfigSupplier<EventJournalConfig> cacheEventJournalConfigSupplier = new Object(this);
  
  private final ConfigSupplier<MerkleTreeConfig> mapMerkleTreeConfigSupplier = new Object(this);
  
  private final Config staticConfig;
  
  private final ConfigPatternMatcher configPatternMatcher;
  
  private final boolean isStaticFirst;
  
  private final DynamicCPSubsystemConfig dynamicCPSubsystemConfig;
  
  public DynamicConfigurationAwareConfig(Config staticConfig, HazelcastProperties properties) {
    assert !(staticConfig instanceof DynamicConfigurationAwareConfig) : "A static Config object is required";
    this.staticConfig = staticConfig;
    this.configPatternMatcher = staticConfig.getConfigPatternMatcher();
    this.isStaticFirst = !properties.getBoolean(GroupProperty.SEARCH_DYNAMIC_CONFIG_FIRST);
    this.dynamicSecurityConfig = new DynamicSecurityConfig(staticConfig.getSecurityConfig(), null);
    this.dynamicCPSubsystemConfig = new DynamicCPSubsystemConfig(staticConfig.getCPSubsystemConfig());
    this.configSearcher = initConfigSearcher();
  }
  
  public ClassLoader getClassLoader() { return this.staticConfig.getClassLoader(); }
  
  public Config setClassLoader(ClassLoader classLoader) { return this.staticConfig.setClassLoader(classLoader); }
  
  public ConfigPatternMatcher getConfigPatternMatcher() { return this.staticConfig.getConfigPatternMatcher(); }
  
  public void setConfigPatternMatcher(ConfigPatternMatcher configPatternMatcher) { this.staticConfig.setConfigPatternMatcher(configPatternMatcher); }
  
  public String getProperty(String name) { return this.staticConfig.getProperty(name); }
  
  public Config setProperty(String name, String value) { return this.staticConfig.setProperty(name, value); }
  
  public MemberAttributeConfig getMemberAttributeConfig() { return this.staticConfig.getMemberAttributeConfig(); }
  
  public void setMemberAttributeConfig(MemberAttributeConfig memberAttributeConfig) { this.staticConfig.setMemberAttributeConfig(memberAttributeConfig); }
  
  public Properties getProperties() { return this.staticConfig.getProperties(); }
  
  public Config setProperties(Properties properties) { return this.staticConfig.setProperties(properties); }
  
  public String getInstanceName() { return this.staticConfig.getInstanceName(); }
  
  public Config setInstanceName(String instanceName) { return this.staticConfig.setInstanceName(instanceName); }
  
  public GroupConfig getGroupConfig() { return this.staticConfig.getGroupConfig(); }
  
  public Config setGroupConfig(GroupConfig groupConfig) { return this.staticConfig.setGroupConfig(groupConfig); }
  
  public NetworkConfig getNetworkConfig() { return this.staticConfig.getNetworkConfig(); }
  
  public Config setNetworkConfig(NetworkConfig networkConfig) { return this.staticConfig.setNetworkConfig(networkConfig); }
  
  public AdvancedNetworkConfig getAdvancedNetworkConfig() { return this.staticConfig.getAdvancedNetworkConfig(); }
  
  public Config setAdvancedNetworkConfig(AdvancedNetworkConfig advancedNetworkConfig) { return this.staticConfig.setAdvancedNetworkConfig(advancedNetworkConfig); }
  
  public MapConfig findMapConfig(String name) { return getMapConfigInternal(name, "default").getAsReadOnly(); }
  
  public MapConfig getMapConfig(String name) { return getMapConfigInternal(name, name); }
  
  public MapConfig getMapConfigOrNull(String name) { return getMapConfigOrNullInternal(name); }
  
  private MapConfig getMapConfigOrNullInternal(String name) { return getMapConfigOrNullInternal(name, name); }
  
  private MapConfig getMapConfigOrNullInternal(String name, String fallbackName) { return (MapConfig)this.configSearcher.getConfig(name, fallbackName, this.mapConfigOrNullConfigSupplier); }
  
  private MapConfig getMapConfigInternal(String name, String fallbackName) { return (MapConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(MapConfig.class)); }
  
  public Config addMapConfig(MapConfig mapConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getMapConfigs(), mapConfig
        .getName(), mapConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(mapConfig); 
    return this;
  }
  
  public <T> boolean checkStaticConfigDoesNotExist(Map<String, T> staticConfigurations, String configName, T newConfig) {
    Object existingConfiguration = staticConfigurations.get(configName);
    if (existingConfiguration != null && !existingConfiguration.equals(newConfig))
      throw new ConfigurationException("Cannot add a new dynamic configuration " + newConfig + " as static configuration already contains " + existingConfiguration); 
    return (existingConfiguration == null);
  }
  
  public Config getStaticConfig() { return this.staticConfig; }
  
  public Map<String, MapConfig> getMapConfigs() {
    Map<String, MapConfig> staticMapConfigs = this.staticConfig.getMapConfigs();
    Map<String, MapConfig> dynamicMapConfigs = this.configurationService.getMapConfigs();
    return AggregatingMap.aggregate(staticMapConfigs, dynamicMapConfigs);
  }
  
  public Config setMapConfigs(Map<String, MapConfig> mapConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public CacheSimpleConfig findCacheConfig(String name) { return getCacheConfigInternal(name, "default").getAsReadOnly(); }
  
  public CacheSimpleConfig findCacheConfigOrNull(String name) {
    CacheSimpleConfig cacheConfig = getCacheConfigInternal(name, null);
    if (cacheConfig == null)
      return null; 
    return cacheConfig.getAsReadOnly();
  }
  
  public CacheSimpleConfig getCacheConfig(String name) { return getCacheConfigInternal(name, name); }
  
  private CacheSimpleConfig getCacheConfigInternal(String name, String fallbackName) { return (CacheSimpleConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(CacheSimpleConfig.class)); }
  
  public Config addCacheConfig(CacheSimpleConfig cacheConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getCacheConfigs(), cacheConfig
        .getName(), cacheConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(cacheConfig); 
    return this;
  }
  
  public Map<String, CacheSimpleConfig> getCacheConfigs() {
    Map<String, CacheSimpleConfig> staticConfigs = this.staticConfig.getCacheConfigs();
    Map<String, CacheSimpleConfig> dynamicConfigs = this.configurationService.getCacheSimpleConfigs();
    return AggregatingMap.aggregate(staticConfigs, dynamicConfigs);
  }
  
  public Config setCacheConfigs(Map<String, CacheSimpleConfig> cacheConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public QueueConfig findQueueConfig(String name) { return getQueueConfigInternal(name, "default").getAsReadOnly(); }
  
  public QueueConfig getQueueConfig(String name) { return getQueueConfigInternal(name, name); }
  
  private QueueConfig getQueueConfigInternal(String name, String fallbackName) { return (QueueConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(QueueConfig.class)); }
  
  public Config addQueueConfig(QueueConfig queueConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getQueueConfigs(), queueConfig
        .getName(), queueConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(queueConfig); 
    return this;
  }
  
  public Map<String, QueueConfig> getQueueConfigs() {
    Map<String, QueueConfig> staticQueueConfigs = this.staticConfig.getQueueConfigs();
    Map<String, QueueConfig> dynamicQueueConfigs = this.configurationService.getQueueConfigs();
    return AggregatingMap.aggregate(staticQueueConfigs, dynamicQueueConfigs);
  }
  
  public Config setQueueConfigs(Map<String, QueueConfig> queueConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public LockConfig findLockConfig(String name) { return getLockConfigInternal(name, "default").getAsReadOnly(); }
  
  public LockConfig getLockConfig(String name) { return getLockConfigInternal(name, name); }
  
  private LockConfig getLockConfigInternal(String name, String fallbackName) { return (LockConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(LockConfig.class)); }
  
  public Config addLockConfig(LockConfig lockConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getLockConfigs(), lockConfig
        .getName(), lockConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(lockConfig); 
    return this;
  }
  
  public Map<String, LockConfig> getLockConfigs() {
    Map<String, LockConfig> staticLockConfigs = this.staticConfig.getLockConfigs();
    Map<String, LockConfig> dynamiclockConfigs = this.configurationService.getLockConfigs();
    return AggregatingMap.aggregate(staticLockConfigs, dynamiclockConfigs);
  }
  
  public Config setLockConfigs(Map<String, LockConfig> lockConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public ListConfig findListConfig(String name) { return getListConfigInternal(name, "default").getAsReadOnly(); }
  
  public ListConfig getListConfig(String name) { return getListConfigInternal(name, name); }
  
  private ListConfig getListConfigInternal(String name, String fallbackName) { return (ListConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(ListConfig.class)); }
  
  public Config addListConfig(ListConfig listConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getListConfigs(), listConfig
        .getName(), listConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(listConfig); 
    return this;
  }
  
  public Map<String, ListConfig> getListConfigs() {
    Map<String, ListConfig> staticListConfigs = this.staticConfig.getListConfigs();
    Map<String, ListConfig> dynamicListConfigs = this.configurationService.getListConfigs();
    return AggregatingMap.aggregate(staticListConfigs, dynamicListConfigs);
  }
  
  public Config setListConfigs(Map<String, ListConfig> listConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public SetConfig findSetConfig(String name) { return getSetConfigInternal(name, "default").getAsReadOnly(); }
  
  public SetConfig getSetConfig(String name) { return getSetConfigInternal(name, name); }
  
  private SetConfig getSetConfigInternal(String name, String fallbackName) { return (SetConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(SetConfig.class)); }
  
  public Config addSetConfig(SetConfig setConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getSetConfigs(), setConfig
        .getName(), setConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(setConfig); 
    return this;
  }
  
  public Map<String, SetConfig> getSetConfigs() {
    Map<String, SetConfig> staticSetConfigs = this.staticConfig.getSetConfigs();
    Map<String, SetConfig> dynamicSetConfigs = this.configurationService.getSetConfigs();
    return AggregatingMap.aggregate(staticSetConfigs, dynamicSetConfigs);
  }
  
  public Config setSetConfigs(Map<String, SetConfig> setConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public MultiMapConfig findMultiMapConfig(String name) { return getMultiMapConfigInternal(name, "default").getAsReadOnly(); }
  
  public MultiMapConfig getMultiMapConfig(String name) { return getMultiMapConfigInternal(name, name); }
  
  private MultiMapConfig getMultiMapConfigInternal(String name, String fallbackName) { return (MultiMapConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(MultiMapConfig.class)); }
  
  public Config addMultiMapConfig(MultiMapConfig multiMapConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getMultiMapConfigs(), multiMapConfig
        .getName(), multiMapConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(multiMapConfig); 
    return this;
  }
  
  public Map<String, MultiMapConfig> getMultiMapConfigs() {
    Map<String, MultiMapConfig> staticConfigs = this.staticConfig.getMultiMapConfigs();
    Map<String, MultiMapConfig> dynamicConfigs = this.configurationService.getMultiMapConfigs();
    return AggregatingMap.aggregate(staticConfigs, dynamicConfigs);
  }
  
  public Config setMultiMapConfigs(Map<String, MultiMapConfig> multiMapConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public ReplicatedMapConfig findReplicatedMapConfig(String name) { return getReplicatedMapConfigInternal(name, "default").getAsReadOnly(); }
  
  public ReplicatedMapConfig getReplicatedMapConfig(String name) { return getReplicatedMapConfigInternal(name, name); }
  
  private ReplicatedMapConfig getReplicatedMapConfigInternal(String name, String fallbackName) { return (ReplicatedMapConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(ReplicatedMapConfig.class)); }
  
  public Config addReplicatedMapConfig(ReplicatedMapConfig replicatedMapConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getReplicatedMapConfigs(), replicatedMapConfig
        .getName(), replicatedMapConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(replicatedMapConfig); 
    return this;
  }
  
  public Map<String, ReplicatedMapConfig> getReplicatedMapConfigs() {
    Map<String, ReplicatedMapConfig> staticConfigs = this.staticConfig.getReplicatedMapConfigs();
    Map<String, ReplicatedMapConfig> dynamicConfigs = this.configurationService.getReplicatedMapConfigs();
    return AggregatingMap.aggregate(staticConfigs, dynamicConfigs);
  }
  
  public Config setReplicatedMapConfigs(Map<String, ReplicatedMapConfig> replicatedMapConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public RingbufferConfig findRingbufferConfig(String name) { return getRingbufferConfigInternal(name, "default").getAsReadOnly(); }
  
  public RingbufferConfig getRingbufferConfig(String name) { return getRingbufferConfigInternal(name, name); }
  
  private RingbufferConfig getRingbufferConfigInternal(String name, String fallbackName) { return (RingbufferConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(RingbufferConfig.class)); }
  
  public Config addRingBufferConfig(RingbufferConfig ringbufferConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getRingbufferConfigs(), ringbufferConfig
        .getName(), ringbufferConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(ringbufferConfig); 
    return this;
  }
  
  public Map<String, RingbufferConfig> getRingbufferConfigs() {
    Map<String, RingbufferConfig> staticConfigs = this.staticConfig.getRingbufferConfigs();
    Map<String, RingbufferConfig> dynamicConfigs = this.configurationService.getRingbufferConfigs();
    return AggregatingMap.aggregate(staticConfigs, dynamicConfigs);
  }
  
  public Config setRingbufferConfigs(Map<String, RingbufferConfig> ringbufferConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public AtomicLongConfig findAtomicLongConfig(String name) { return getAtomicLongConfigInternal(name, "default").getAsReadOnly(); }
  
  public AtomicLongConfig getAtomicLongConfig(String name) { return getAtomicLongConfigInternal(name, name); }
  
  public Config addAtomicLongConfig(AtomicLongConfig atomicLongConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getAtomicLongConfigs(), atomicLongConfig
        .getName(), atomicLongConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(atomicLongConfig); 
    return this;
  }
  
  public Map<String, AtomicLongConfig> getAtomicLongConfigs() {
    Map<String, AtomicLongConfig> staticConfigs = this.staticConfig.getAtomicLongConfigs();
    Map<String, AtomicLongConfig> dynamicConfigs = this.configurationService.getAtomicLongConfigs();
    return AggregatingMap.aggregate(staticConfigs, dynamicConfigs);
  }
  
  public Config setAtomicLongConfigs(Map<String, AtomicLongConfig> atomicLongConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  private AtomicLongConfig getAtomicLongConfigInternal(String name, String fallbackName) { return (AtomicLongConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(AtomicLongConfig.class)); }
  
  public AtomicReferenceConfig findAtomicReferenceConfig(String name) { return getAtomicReferenceConfigInternal(name, "default").getAsReadOnly(); }
  
  public AtomicReferenceConfig getAtomicReferenceConfig(String name) { return getAtomicReferenceConfigInternal(name, name); }
  
  public Config addAtomicReferenceConfig(AtomicReferenceConfig atomicReferenceConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getAtomicReferenceConfigs(), atomicReferenceConfig
        .getName(), atomicReferenceConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(atomicReferenceConfig); 
    return this;
  }
  
  public Map<String, AtomicReferenceConfig> getAtomicReferenceConfigs() {
    Map<String, AtomicReferenceConfig> staticConfigs = this.staticConfig.getAtomicReferenceConfigs();
    Map<String, AtomicReferenceConfig> dynamicConfigs = this.configurationService.getAtomicReferenceConfigs();
    return AggregatingMap.aggregate(staticConfigs, dynamicConfigs);
  }
  
  public Config setAtomicReferenceConfigs(Map<String, AtomicReferenceConfig> atomicReferenceConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  private AtomicReferenceConfig getAtomicReferenceConfigInternal(String name, String fallbackName) { return (AtomicReferenceConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(AtomicReferenceConfig.class)); }
  
  public CountDownLatchConfig findCountDownLatchConfig(String name) { return getCountDownLatchConfigInternal(name, "default").getAsReadOnly(); }
  
  public CountDownLatchConfig getCountDownLatchConfig(String name) { return getCountDownLatchConfigInternal(name, name); }
  
  public Config addCountDownLatchConfig(CountDownLatchConfig countDownLatchConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getCountDownLatchConfigs(), countDownLatchConfig
        .getName(), countDownLatchConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(countDownLatchConfig); 
    return this;
  }
  
  public Map<String, CountDownLatchConfig> getCountDownLatchConfigs() {
    Map<String, CountDownLatchConfig> staticConfigs = this.staticConfig.getCountDownLatchConfigs();
    Map<String, CountDownLatchConfig> dynamicConfigs = this.configurationService.getCountDownLatchConfigs();
    return AggregatingMap.aggregate(staticConfigs, dynamicConfigs);
  }
  
  public Config setCountDownLatchConfigs(Map<String, CountDownLatchConfig> countDownLatchConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  private CountDownLatchConfig getCountDownLatchConfigInternal(String name, String fallbackName) { return (CountDownLatchConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(CountDownLatchConfig.class)); }
  
  public TopicConfig findTopicConfig(String name) { return getTopicConfigInternal(name, "default").getAsReadOnly(); }
  
  public TopicConfig getTopicConfig(String name) { return getTopicConfigInternal(name, name); }
  
  private TopicConfig getTopicConfigInternal(String name, String fallbackName) { return (TopicConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(TopicConfig.class)); }
  
  public Config addTopicConfig(TopicConfig topicConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getTopicConfigs(), topicConfig
        .getName(), topicConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(topicConfig); 
    return this;
  }
  
  public Map<String, TopicConfig> getTopicConfigs() {
    Map<String, TopicConfig> staticConfigs = this.staticConfig.getTopicConfigs();
    Map<String, TopicConfig> dynamicConfigs = this.configurationService.getTopicConfigs();
    return AggregatingMap.aggregate(staticConfigs, dynamicConfigs);
  }
  
  public Config setTopicConfigs(Map<String, TopicConfig> mapTopicConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public ReliableTopicConfig findReliableTopicConfig(String name) { return getReliableTopicConfigInternal(name, "default").getAsReadOnly(); }
  
  public ReliableTopicConfig getReliableTopicConfig(String name) { return getReliableTopicConfigInternal(name, name); }
  
  private ReliableTopicConfig getReliableTopicConfigInternal(String name, String fallbackName) { return (ReliableTopicConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(ReliableTopicConfig.class)); }
  
  public Map<String, ReliableTopicConfig> getReliableTopicConfigs() {
    Map<String, ReliableTopicConfig> staticConfigs = this.staticConfig.getReliableTopicConfigs();
    Map<String, ReliableTopicConfig> dynamicConfigs = this.configurationService.getReliableTopicConfigs();
    return AggregatingMap.aggregate(staticConfigs, dynamicConfigs);
  }
  
  public Config addReliableTopicConfig(ReliableTopicConfig reliableTopicConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getReliableTopicConfigs(), reliableTopicConfig
        .getName(), reliableTopicConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(reliableTopicConfig); 
    return this;
  }
  
  public Config setReliableTopicConfigs(Map<String, ReliableTopicConfig> reliableTopicConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public ExecutorConfig findExecutorConfig(String name) { return getExecutorConfigInternal(name, "default").getAsReadOnly(); }
  
  public ExecutorConfig getExecutorConfig(String name) { return getExecutorConfigInternal(name, name); }
  
  private ExecutorConfig getExecutorConfigInternal(String name, String fallbackName) { return (ExecutorConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(ExecutorConfig.class)); }
  
  public Config addExecutorConfig(ExecutorConfig executorConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getExecutorConfigs(), executorConfig
        .getName(), executorConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(executorConfig); 
    return this;
  }
  
  public Map<String, ExecutorConfig> getExecutorConfigs() {
    Map<String, ExecutorConfig> staticConfigs = this.staticConfig.getExecutorConfigs();
    Map<String, ExecutorConfig> dynamicConfigs = this.configurationService.getExecutorConfigs();
    return AggregatingMap.aggregate(staticConfigs, dynamicConfigs);
  }
  
  public Config setExecutorConfigs(Map<String, ExecutorConfig> executorConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public DurableExecutorConfig findDurableExecutorConfig(String name) { return getDurableExecutorConfigInternal(name, "default"); }
  
  public DurableExecutorConfig getDurableExecutorConfig(String name) { return getDurableExecutorConfigInternal(name, name); }
  
  private DurableExecutorConfig getDurableExecutorConfigInternal(String name, String fallbackName) { return (DurableExecutorConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(DurableExecutorConfig.class)); }
  
  public Config addDurableExecutorConfig(DurableExecutorConfig durableExecutorConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getDurableExecutorConfigs(), durableExecutorConfig
        .getName(), durableExecutorConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(durableExecutorConfig); 
    return this;
  }
  
  public Map<String, DurableExecutorConfig> getDurableExecutorConfigs() {
    Map<String, DurableExecutorConfig> staticConfigs = this.staticConfig.getDurableExecutorConfigs();
    Map<String, DurableExecutorConfig> dynamicConfigs = this.configurationService.getDurableExecutorConfigs();
    return AggregatingMap.aggregate(staticConfigs, dynamicConfigs);
  }
  
  public Config setDurableExecutorConfigs(Map<String, DurableExecutorConfig> durableExecutorConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public ScheduledExecutorConfig findScheduledExecutorConfig(String name) { return getScheduledExecutorConfigInternal(name, "default"); }
  
  public ScheduledExecutorConfig getScheduledExecutorConfig(String name) { return getScheduledExecutorConfigInternal(name, name); }
  
  private ScheduledExecutorConfig getScheduledExecutorConfigInternal(String name, String fallbackName) { return (ScheduledExecutorConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(ScheduledExecutorConfig.class)); }
  
  public Map<String, ScheduledExecutorConfig> getScheduledExecutorConfigs() {
    Map<String, ScheduledExecutorConfig> staticConfigs = this.staticConfig.getScheduledExecutorConfigs();
    Map<String, ScheduledExecutorConfig> dynamicConfigs = this.configurationService.getScheduledExecutorConfigs();
    return AggregatingMap.aggregate(staticConfigs, dynamicConfigs);
  }
  
  public Config addScheduledExecutorConfig(ScheduledExecutorConfig scheduledExecutorConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getScheduledExecutorConfigs(), scheduledExecutorConfig
        .getName(), scheduledExecutorConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(scheduledExecutorConfig); 
    return this;
  }
  
  public Config setScheduledExecutorConfigs(Map<String, ScheduledExecutorConfig> scheduledExecutorConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public CardinalityEstimatorConfig findCardinalityEstimatorConfig(String name) { return getCardinalityEstimatorConfigInternal(name, "default"); }
  
  public CardinalityEstimatorConfig getCardinalityEstimatorConfig(String name) { return getCardinalityEstimatorConfigInternal(name, name); }
  
  private CardinalityEstimatorConfig getCardinalityEstimatorConfigInternal(String name, String fallbackName) { return (CardinalityEstimatorConfig)this.configSearcher.getConfig(name, fallbackName, 
        ConfigSearch.supplierFor(CardinalityEstimatorConfig.class)); }
  
  public Config addCardinalityEstimatorConfig(CardinalityEstimatorConfig cardinalityEstimatorConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getCardinalityEstimatorConfigs(), cardinalityEstimatorConfig
        .getName(), cardinalityEstimatorConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(cardinalityEstimatorConfig); 
    return this;
  }
  
  public Map<String, CardinalityEstimatorConfig> getCardinalityEstimatorConfigs() {
    Map<String, CardinalityEstimatorConfig> staticConfigs = this.staticConfig.getCardinalityEstimatorConfigs();
    Map<String, CardinalityEstimatorConfig> dynamicConfigs = this.configurationService.getCardinalityEstimatorConfigs();
    return AggregatingMap.aggregate(staticConfigs, dynamicConfigs);
  }
  
  public Config setCardinalityEstimatorConfigs(Map<String, CardinalityEstimatorConfig> cardinalityEstimatorConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public PNCounterConfig findPNCounterConfig(String name) { return getPNCounterConfigInternal(name, "default"); }
  
  public PNCounterConfig getPNCounterConfig(String name) { return getPNCounterConfigInternal(name, name); }
  
  private PNCounterConfig getPNCounterConfigInternal(String name, String fallbackName) { return (PNCounterConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(PNCounterConfig.class)); }
  
  public Config addPNCounterConfig(PNCounterConfig pnCounterConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getPNCounterConfigs(), pnCounterConfig
        .getName(), pnCounterConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(pnCounterConfig); 
    return this;
  }
  
  public Map<String, PNCounterConfig> getPNCounterConfigs() {
    Map<String, PNCounterConfig> staticConfigs = this.staticConfig.getPNCounterConfigs();
    Map<String, PNCounterConfig> dynamicConfigs = this.configurationService.getPNCounterConfigs();
    return AggregatingMap.aggregate(staticConfigs, dynamicConfigs);
  }
  
  public Config setPNCounterConfigs(Map<String, PNCounterConfig> pnCounterConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public SemaphoreConfig findSemaphoreConfig(String name) { return getSemaphoreConfigInternal(name, "default").getAsReadOnly(); }
  
  public SemaphoreConfig getSemaphoreConfig(String name) { return getSemaphoreConfigInternal(name, name); }
  
  private SemaphoreConfig getSemaphoreConfigInternal(String name, String fallbackName) { return (SemaphoreConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(SemaphoreConfig.class)); }
  
  public Config addSemaphoreConfig(SemaphoreConfig semaphoreConfig) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getSemaphoreConfigsAsMap(), semaphoreConfig
        .getName(), semaphoreConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(semaphoreConfig); 
    return this;
  }
  
  public Collection<SemaphoreConfig> getSemaphoreConfigs() {
    Collection<SemaphoreConfig> staticConfigs = this.staticConfig.getSemaphoreConfigs();
    Map<String, SemaphoreConfig> semaphoreConfigs = this.configurationService.getSemaphoreConfigs();
    ArrayList<SemaphoreConfig> aggregated = new ArrayList<SemaphoreConfig>(staticConfigs);
    aggregated.addAll(semaphoreConfigs.values());
    return aggregated;
  }
  
  public Map<String, SemaphoreConfig> getSemaphoreConfigsAsMap() {
    Map<String, SemaphoreConfig> staticConfigs = this.staticConfig.getSemaphoreConfigsAsMap();
    Map<String, SemaphoreConfig> dynamicConfigs = this.configurationService.getSemaphoreConfigs();
    return AggregatingMap.aggregate(staticConfigs, dynamicConfigs);
  }
  
  public Config setSemaphoreConfigs(Map<String, SemaphoreConfig> semaphoreConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public EventJournalConfig findCacheEventJournalConfig(String name) { return getCacheEventJournalConfigInternal(name, "default"); }
  
  public EventJournalConfig getCacheEventJournalConfig(String name) { return getCacheEventJournalConfigInternal(name, name); }
  
  private EventJournalConfig getCacheEventJournalConfigInternal(String name, String fallbackName) { return (EventJournalConfig)this.configSearcher.getConfig(name, fallbackName, this.cacheEventJournalConfigSupplier); }
  
  public Map<String, EventJournalConfig> getCacheEventJournalConfigs() {
    Map<String, EventJournalConfig> staticConfigs = this.staticConfig.getCacheEventJournalConfigs();
    Map<String, EventJournalConfig> dynamicConfigs = this.configurationService.getCacheEventJournalConfigs();
    return AggregatingMap.aggregate(staticConfigs, dynamicConfigs);
  }
  
  public EventJournalConfig findMapEventJournalConfig(String name) { return getMapEventJournalConfigInternal(name, "default"); }
  
  public EventJournalConfig getMapEventJournalConfig(String name) { return getMapEventJournalConfigInternal(name, name); }
  
  private EventJournalConfig getMapEventJournalConfigInternal(String name, String fallbackName) { return (EventJournalConfig)this.configSearcher.getConfig(name, fallbackName, this.mapEventJournalConfigSupplier); }
  
  public Map<String, EventJournalConfig> getMapEventJournalConfigs() {
    Map<String, EventJournalConfig> staticConfigs = this.staticConfig.getMapEventJournalConfigs();
    Map<String, EventJournalConfig> dynamicConfigs = this.configurationService.getMapEventJournalConfigs();
    return AggregatingMap.aggregate(staticConfigs, dynamicConfigs);
  }
  
  public Config addEventJournalConfig(EventJournalConfig eventJournalConfig) {
    String mapName = eventJournalConfig.getMapName();
    String cacheName = eventJournalConfig.getCacheName();
    if (StringUtil.isNullOrEmpty(mapName) && StringUtil.isNullOrEmpty(cacheName))
      throw new IllegalArgumentException("Event journal config should have non-empty map name and/or cache name"); 
    boolean staticConfigDoesNotExist = false;
    if (!StringUtil.isNullOrEmpty(mapName)) {
      Map<String, EventJournalConfig> staticConfigs = this.staticConfig.getMapEventJournalConfigs();
      staticConfigDoesNotExist = checkStaticConfigDoesNotExist(staticConfigs, mapName, eventJournalConfig);
    } 
    if (!StringUtil.isNullOrEmpty(cacheName)) {
      Map<String, EventJournalConfig> staticConfigs = this.staticConfig.getCacheEventJournalConfigs();
      staticConfigDoesNotExist |= 
        checkStaticConfigDoesNotExist(staticConfigs, cacheName, eventJournalConfig);
    } 
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(eventJournalConfig); 
    return this;
  }
  
  public Config setMapEventJournalConfigs(Map<String, EventJournalConfig> eventJournalConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public Config setCacheEventJournalConfigs(Map<String, EventJournalConfig> eventJournalConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public MerkleTreeConfig findMapMerkleTreeConfig(String name) { return getMapMerkleTreeConfigInternal(name, "default"); }
  
  public MerkleTreeConfig getMapMerkleTreeConfig(String name) { return getMapMerkleTreeConfigInternal(name, name); }
  
  private MerkleTreeConfig getMapMerkleTreeConfigInternal(String name, String fallbackName) { return (MerkleTreeConfig)this.configSearcher.getConfig(name, fallbackName, this.mapMerkleTreeConfigSupplier); }
  
  public Config addMerkleTreeConfig(MerkleTreeConfig merkleTreeConfig) {
    String mapName = merkleTreeConfig.getMapName();
    if (StringUtil.isNullOrEmpty(mapName))
      throw new IllegalArgumentException("Merkle tree config must define a map name"); 
    Map<String, MerkleTreeConfig> staticConfigs = this.staticConfig.getMapMerkleTreeConfigs();
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(staticConfigs, mapName, merkleTreeConfig);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(merkleTreeConfig); 
    return this;
  }
  
  public Map<String, MerkleTreeConfig> getMapMerkleTreeConfigs() {
    Map<String, MerkleTreeConfig> staticConfigs = this.staticConfig.getMapMerkleTreeConfigs();
    Map<String, MerkleTreeConfig> dynamicConfigs = this.configurationService.getMapMerkleTreeConfigs();
    return AggregatingMap.aggregate(staticConfigs, dynamicConfigs);
  }
  
  public Config setMapMerkleTreeConfigs(Map<String, MerkleTreeConfig> merkleTreeConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public Map<String, FlakeIdGeneratorConfig> getFlakeIdGeneratorConfigs() {
    Map<String, FlakeIdGeneratorConfig> staticMapConfigs = this.staticConfig.getFlakeIdGeneratorConfigs();
    Map<String, FlakeIdGeneratorConfig> dynamicMapConfigs = this.configurationService.getFlakeIdGeneratorConfigs();
    return AggregatingMap.aggregate(staticMapConfigs, dynamicMapConfigs);
  }
  
  public FlakeIdGeneratorConfig findFlakeIdGeneratorConfig(String name) { return getFlakeIdGeneratorConfigInternal(name, "default").getAsReadOnly(); }
  
  public FlakeIdGeneratorConfig getFlakeIdGeneratorConfig(String name) { return getFlakeIdGeneratorConfigInternal(name, name); }
  
  private FlakeIdGeneratorConfig getFlakeIdGeneratorConfigInternal(String name, String fallbackName) { return (FlakeIdGeneratorConfig)this.configSearcher.getConfig(name, fallbackName, ConfigSearch.supplierFor(FlakeIdGeneratorConfig.class)); }
  
  public Config addFlakeIdGeneratorConfig(FlakeIdGeneratorConfig config) {
    boolean staticConfigDoesNotExist = checkStaticConfigDoesNotExist(this.staticConfig.getFlakeIdGeneratorConfigs(), config
        .getName(), config);
    if (staticConfigDoesNotExist)
      this.configurationService.broadcastConfig(config); 
    return this;
  }
  
  public Config setFlakeIdGeneratorConfigs(Map<String, FlakeIdGeneratorConfig> map) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public WanReplicationConfig getWanReplicationConfig(String name) { return this.staticConfig.getWanReplicationConfig(name); }
  
  public Config addWanReplicationConfig(WanReplicationConfig wanReplicationConfig) { return this.staticConfig.addWanReplicationConfig(wanReplicationConfig); }
  
  public Map<String, WanReplicationConfig> getWanReplicationConfigs() { return this.staticConfig.getWanReplicationConfigs(); }
  
  public Config setWanReplicationConfigs(Map<String, WanReplicationConfig> wanReplicationConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public JobTrackerConfig findJobTrackerConfig(String name) { return this.staticConfig.findJobTrackerConfig(name); }
  
  public JobTrackerConfig getJobTrackerConfig(String name) { return this.staticConfig.getJobTrackerConfig(name); }
  
  public Config addJobTrackerConfig(JobTrackerConfig jobTrackerConfig) { return this.staticConfig.addJobTrackerConfig(jobTrackerConfig); }
  
  public Map<String, JobTrackerConfig> getJobTrackerConfigs() { return this.staticConfig.getJobTrackerConfigs(); }
  
  public Config setJobTrackerConfigs(Map<String, JobTrackerConfig> jobTrackerConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public Map<String, QuorumConfig> getQuorumConfigs() { return this.staticConfig.getQuorumConfigs(); }
  
  public QuorumConfig getQuorumConfig(String name) { return this.staticConfig.getQuorumConfig(name); }
  
  public QuorumConfig findQuorumConfig(String name) { return this.staticConfig.findQuorumConfig(name); }
  
  public Config setQuorumConfigs(Map<String, QuorumConfig> quorumConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public Config addQuorumConfig(QuorumConfig quorumConfig) { return this.staticConfig.addQuorumConfig(quorumConfig); }
  
  public ManagementCenterConfig getManagementCenterConfig() { return this.staticConfig.getManagementCenterConfig(); }
  
  public Config setManagementCenterConfig(ManagementCenterConfig managementCenterConfig) { return this.staticConfig.setManagementCenterConfig(managementCenterConfig); }
  
  public ServicesConfig getServicesConfig() { return this.staticConfig.getServicesConfig(); }
  
  public Config setServicesConfig(ServicesConfig servicesConfig) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public SecurityConfig getSecurityConfig() { return this.dynamicSecurityConfig; }
  
  public Config setSecurityConfig(SecurityConfig securityConfig) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public Config addListenerConfig(ListenerConfig listenerConfig) { return this.staticConfig.addListenerConfig(listenerConfig); }
  
  public List<ListenerConfig> getListenerConfigs() { return this.staticConfig.getListenerConfigs(); }
  
  public Config setListenerConfigs(List<ListenerConfig> listenerConfigs) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public SerializationConfig getSerializationConfig() { return this.staticConfig.getSerializationConfig(); }
  
  public Config setSerializationConfig(SerializationConfig serializationConfig) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public PartitionGroupConfig getPartitionGroupConfig() { return this.staticConfig.getPartitionGroupConfig(); }
  
  public Config setPartitionGroupConfig(PartitionGroupConfig partitionGroupConfig) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public HotRestartPersistenceConfig getHotRestartPersistenceConfig() { return this.staticConfig.getHotRestartPersistenceConfig(); }
  
  public Config setHotRestartPersistenceConfig(HotRestartPersistenceConfig hrConfig) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public CRDTReplicationConfig getCRDTReplicationConfig() { return this.staticConfig.getCRDTReplicationConfig(); }
  
  public Config setCRDTReplicationConfig(CRDTReplicationConfig crdtReplicationConfig) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public ManagedContext getManagedContext() { return this.staticConfig.getManagedContext(); }
  
  public Config setManagedContext(ManagedContext managedContext) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public ConcurrentMap<String, Object> getUserContext() { return this.staticConfig.getUserContext(); }
  
  public Config setUserContext(ConcurrentMap<String, Object> userContext) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public NativeMemoryConfig getNativeMemoryConfig() { return this.staticConfig.getNativeMemoryConfig(); }
  
  public Config setNativeMemoryConfig(NativeMemoryConfig nativeMemoryConfig) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public URL getConfigurationUrl() { return this.staticConfig.getConfigurationUrl(); }
  
  public Config setConfigurationUrl(URL configurationUrl) { throw new UnsupportedOperationException("Unsupported operation"); }
  
  public File getConfigurationFile() { return this.staticConfig.getConfigurationFile(); }
  
  public Config setConfigurationFile(File configurationFile) { return this.staticConfig.setConfigurationFile(configurationFile); }
  
  public String getLicenseKey() { return this.staticConfig.getLicenseKey(); }
  
  public Config setLicenseKey(String licenseKey) { return this.staticConfig.setLicenseKey(licenseKey); }
  
  public boolean isLiteMember() { return this.staticConfig.isLiteMember(); }
  
  public Config setLiteMember(boolean liteMember) { return this.staticConfig.setLiteMember(liteMember); }
  
  public UserCodeDeploymentConfig getUserCodeDeploymentConfig() { return this.staticConfig.getUserCodeDeploymentConfig(); }
  
  public Config setUserCodeDeploymentConfig(UserCodeDeploymentConfig userCodeDeploymentConfig) { return this.staticConfig.setUserCodeDeploymentConfig(userCodeDeploymentConfig); }
  
  public String toString() { return this.staticConfig.toString(); }
  
  public void setConfigurationService(ConfigurationService configurationService) {
    this.configurationService = configurationService;
    this.configSearcher = initConfigSearcher();
  }
  
  public void onSecurityServiceUpdated(SecurityService securityService) { this.dynamicSecurityConfig = new DynamicSecurityConfig(this.staticConfig.getSecurityConfig(), securityService); }
  
  private Searcher initConfigSearcher() { return ConfigSearch.searcherFor(this.staticConfig, this.configurationService, this.configPatternMatcher, this.isStaticFirst); }
  
  public CPSubsystemConfig getCPSubsystemConfig() { return this.dynamicCPSubsystemConfig; }
  
  public Config setCPSubsystemConfig(CPSubsystemConfig cpSubsystemConfig) { throw new UnsupportedOperationException("Unsupported operation"); }
}
