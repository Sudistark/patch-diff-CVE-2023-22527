package com.hazelcast.internal.eviction;

import com.hazelcast.core.IBiFunction;
import com.hazelcast.nio.Address;
import com.hazelcast.partition.PartitionLostEvent;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.impl.operationservice.InternalOperationService;
import com.hazelcast.spi.partition.IPartition;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.spi.properties.HazelcastProperties;
import com.hazelcast.spi.properties.HazelcastProperty;
import com.hazelcast.util.Clock;
import com.hazelcast.util.CollectionUtil;
import com.hazelcast.util.Preconditions;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

@SuppressFBWarnings({"URF_UNREAD_FIELD"})
public abstract class ClearExpiredRecordsTask<T, S> extends Object implements Runnable {
  private static final int DIFFERENCE_BETWEEN_TWO_SUBSEQUENT_PARTITION_CLEANUP_MILLIS = 1000;
  
  protected final T[] containers;
  
  protected final NodeEngine nodeEngine;
  
  protected final ToBackupSender<S> toBackupSender;
  
  protected final IPartitionService partitionService;
  
  private final int partitionCount;
  
  private final int taskPeriodSeconds;
  
  private final int cleanupPercentage;
  
  private final int cleanupOperationCount;
  
  private final Address thisAddress;
  
  private final InternalOperationService operationService;
  
  private final AtomicBoolean singleRunPermit;
  
  private final AtomicInteger lostPartitionCounter;
  
  private final AtomicInteger nextExpiryQueueToScanIndex;
  
  private int runningCleanupOperationsCount;
  
  @SuppressFBWarnings({"EI_EXPOSE_REP2"})
  protected ClearExpiredRecordsTask(String serviceName, T[] containers, HazelcastProperty cleanupOpProperty, HazelcastProperty cleanupPercentageProperty, HazelcastProperty taskPeriodProperty, NodeEngine nodeEngine) {
    this.singleRunPermit = new AtomicBoolean(false);
    this.lostPartitionCounter = new AtomicInteger();
    this.nextExpiryQueueToScanIndex = new AtomicInteger();
    this.nodeEngine = nodeEngine;
    this.containers = containers;
    this.operationService = (InternalOperationService)nodeEngine.getOperationService();
    this.partitionService = nodeEngine.getPartitionService();
    this.partitionCount = nodeEngine.getPartitionService().getPartitionCount();
    this.thisAddress = nodeEngine.getThisAddress();
    HazelcastProperties properties = nodeEngine.getProperties();
    this.cleanupOperationCount = calculateCleanupOperationCount(properties, cleanupOpProperty, this.partitionCount, this.operationService
        .getPartitionThreadCount());
    Preconditions.checkPositive(this.cleanupOperationCount, "cleanupOperationCount should be a positive number");
    this.cleanupPercentage = properties.getInteger(cleanupPercentageProperty);
    Preconditions.checkTrue((this.cleanupPercentage > 0 && this.cleanupPercentage <= 100), "cleanupPercentage should be in range (0,100]");
    this.taskPeriodSeconds = properties.getSeconds(taskPeriodProperty);
    this.toBackupSender = ToBackupSender.newToBackupSender(serviceName, newBackupExpiryOpSupplier(), 
        newBackupExpiryOpFilter(), nodeEngine);
  }
  
  protected IBiFunction<Integer, Integer, Boolean> newBackupExpiryOpFilter() { return new Object(this); }
  
  public void run() {
    try {
      if (!this.singleRunPermit.compareAndSet(false, true))
        return; 
      runInternal();
    } finally {
      this.singleRunPermit.set(false);
    } 
  }
  
  private void runInternal() {
    this.runningCleanupOperationsCount = 0;
    long nowInMillis = nowInMillis();
    boolean lostPartitionDetected = lostPartitionDetected();
    List<T> containersToProcess = null;
    for (int partitionId = 0; partitionId < this.partitionCount; partitionId++) {
      T container = (T)this.containers[partitionId];
      IPartition partition = this.partitionService.getPartition(partitionId, false);
      if (!partition.isMigrating()) {
        if (partition.isLocal() && 
          lostPartitionDetected)
          equalizeBackupSizeWithPrimary(container); 
        if (canProcessContainer(container, partition, nowInMillis))
          containersToProcess = addContainerTo(containersToProcess, container); 
      } 
    } 
    if (!CollectionUtil.isEmpty(containersToProcess)) {
      sortPartitionContainers(containersToProcess);
      sendCleanupOperations(containersToProcess);
    } 
    sendExpiryQueuesToBackupIncrementally();
  }
  
  private void sendExpiryQueuesToBackupIncrementally() {
    int scanned = 0;
    for (int partitionId = this.nextExpiryQueueToScanIndex.get(); partitionId < this.partitionCount; partitionId++) {
      sendQueuedExpiredKeys(this.containers[partitionId]);
      this.nextExpiryQueueToScanIndex.incrementAndGet();
      if (++scanned % this.cleanupOperationCount == 0)
        break; 
    } 
    if (this.nextExpiryQueueToScanIndex.get() == this.partitionCount)
      this.nextExpiryQueueToScanIndex.set(0); 
  }
  
  private boolean canProcessContainer(T container, IPartition partition, long nowInMillis) {
    if (!getProcessablePartitionType().isProcessable(partition, this.thisAddress))
      return false; 
    if (isContainerEmpty(container) && !hasExpiredKeyToSendBackup(container))
      return false; 
    if (hasRunningCleanup(container)) {
      this.runningCleanupOperationsCount++;
      return false;
    } 
    return (this.runningCleanupOperationsCount <= this.cleanupOperationCount && 
      !notInProcessableTimeWindow(container, nowInMillis) && 
      !notHaveAnyExpirableRecord(container));
  }
  
  public final void partitionLost(PartitionLostEvent ignored) { this.lostPartitionCounter.incrementAndGet(); }
  
  private static long nowInMillis() { return Clock.currentTimeMillis(); }
  
  private boolean lostPartitionDetected() {
    int currentLostPartitionCount = this.lostPartitionCounter.get();
    if (currentLostPartitionCount == this.lastKnownLostPartitionCount)
      return false; 
    this.lastKnownLostPartitionCount = currentLostPartitionCount;
    return true;
  }
  
  private static int calculateCleanupOperationCount(HazelcastProperties properties, HazelcastProperty cleanupOpCountProperty, int partitionCount, int partitionThreadCount) {
    String stringValue = properties.getString(cleanupOpCountProperty);
    if (stringValue != null)
      return Integer.parseInt(stringValue); 
    double scanPercentage = 0.1D;
    int opCountFromPartitionCount = (int)(partitionCount * 0.1D);
    int inflationFactor = 3;
    int opCountFromThreadCount = partitionThreadCount * 3;
    if (opCountFromPartitionCount == 0)
      return opCountFromThreadCount; 
    return Math.min(opCountFromPartitionCount, opCountFromThreadCount);
  }
  
  private boolean notInProcessableTimeWindow(T container, long now) { return (now - getLastCleanupTime(container) < 1000L); }
  
  private List<T> addContainerTo(List<T> containersToProcess, T container) {
    if (containersToProcess == null)
      containersToProcess = new ArrayList<T>(); 
    containersToProcess.add(container);
    return containersToProcess;
  }
  
  private void sendCleanupOperations(List<T> partitionContainers) {
    int start = 0;
    int end = this.cleanupOperationCount;
    if (end > partitionContainers.size())
      end = partitionContainers.size(); 
    List<T> partitionIds = partitionContainers.subList(0, end);
    for (T container : partitionIds) {
      setHasRunningCleanup(container);
      Operation operation = newPrimaryExpiryOp(this.cleanupPercentage, container);
      this.operationService.execute(operation);
    } 
  }
  
  private IBiFunction<S, Collection<ExpiredKey>, Operation> newBackupExpiryOpSupplier() { return new Object(this); }
  
  public final void sendQueuedExpiredKeys(T container) {
    Iterator<S> storeIterator = storeIterator(container);
    while (storeIterator.hasNext())
      tryToSendBackupExpiryOp(storeIterator.next(), false); 
  }
  
  int getCleanupPercentage() { return this.cleanupPercentage; }
  
  int getTaskPeriodSeconds() { return this.taskPeriodSeconds; }
  
  int getCleanupOperationCount() { return this.cleanupOperationCount; }
  
  protected abstract boolean isContainerEmpty(T paramT);
  
  protected abstract boolean hasRunningCleanup(T paramT);
  
  protected abstract long getLastCleanupTime(T paramT);
  
  protected abstract void equalizeBackupSizeWithPrimary(T paramT);
  
  protected abstract boolean hasExpiredKeyToSendBackup(T paramT);
  
  protected abstract boolean notHaveAnyExpirableRecord(T paramT);
  
  protected abstract void sortPartitionContainers(List<T> paramList);
  
  protected abstract void setHasRunningCleanup(T paramT);
  
  protected abstract ProcessablePartitionType getProcessablePartitionType();
  
  protected abstract Operation newPrimaryExpiryOp(int paramInt, T paramT);
  
  protected abstract Operation newBackupExpiryOp(S paramS, Collection<ExpiredKey> paramCollection);
  
  public abstract void tryToSendBackupExpiryOp(S paramS, boolean paramBoolean);
  
  public abstract Iterator<S> storeIterator(T paramT);
}
