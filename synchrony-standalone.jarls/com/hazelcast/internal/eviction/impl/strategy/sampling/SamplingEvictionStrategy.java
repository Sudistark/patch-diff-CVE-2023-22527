package com.hazelcast.internal.eviction.impl.strategy.sampling;

import com.hazelcast.internal.eviction.Evictable;
import com.hazelcast.internal.eviction.EvictionCandidate;
import com.hazelcast.internal.eviction.EvictionChecker;
import com.hazelcast.internal.eviction.EvictionListener;
import com.hazelcast.internal.eviction.impl.evaluator.EvictionPolicyEvaluator;

public final class SamplingEvictionStrategy<A, E extends Evictable, S extends SampleableEvictableStore<A, E>> extends Object {
  public static final SamplingEvictionStrategy INSTANCE = new SamplingEvictionStrategy();
  
  private static final int SAMPLE_COUNT = 15;
  
  public boolean evict(S evictableStore, EvictionPolicyEvaluator<A, E> evictionPolicyEvaluator, EvictionChecker evictionChecker, EvictionListener<A, E> evictionListener) {
    if (evictionChecker != null) {
      if (evictionChecker.isEvictionRequired())
        return evictInternal(evictableStore, evictionPolicyEvaluator, evictionListener); 
      return false;
    } 
    return evictInternal(evictableStore, evictionPolicyEvaluator, evictionListener);
  }
  
  protected boolean evictInternal(S sampleableEvictableStore, EvictionPolicyEvaluator<A, E> evictionPolicyEvaluator, EvictionListener<A, E> evictionListener) {
    Iterable<EvictionCandidate<A, E>> samples = sampleableEvictableStore.sample(15);
    EvictionCandidate<A, E> evictionCandidate = evictionPolicyEvaluator.evaluate(samples);
    return sampleableEvictableStore.tryEvict(evictionCandidate, evictionListener);
  }
}
