package com.hazelcast.internal.management;

import com.hazelcast.instance.HazelcastInstanceImpl;
import com.hazelcast.internal.management.dto.ConnectionManagerDTO;
import com.hazelcast.internal.management.dto.EventServiceDTO;
import com.hazelcast.internal.management.dto.MXBeansDTO;
import com.hazelcast.internal.management.dto.ManagedExecutorDTO;
import com.hazelcast.internal.management.dto.OperationServiceDTO;
import com.hazelcast.internal.management.dto.PartitionServiceBeanDTO;
import com.hazelcast.internal.management.dto.ProxyServiceDTO;
import com.hazelcast.internal.partition.impl.InternalPartitionServiceImpl;
import com.hazelcast.internal.util.RuntimeAvailableProcessors;
import com.hazelcast.monitor.impl.MemberStateImpl;
import com.hazelcast.nio.NetworkingService;
import com.hazelcast.spi.impl.eventservice.InternalEventService;
import com.hazelcast.spi.impl.executionservice.InternalExecutionService;
import com.hazelcast.spi.impl.operationservice.InternalOperationService;
import com.hazelcast.spi.impl.proxyservice.InternalProxyService;
import com.hazelcast.util.MapUtil;
import com.hazelcast.util.OperatingSystemMXBeanSupport;
import com.hazelcast.util.executor.ManagedExecutorService;
import java.lang.management.ClassLoadingMXBean;
import java.lang.management.ManagementFactory;
import java.lang.management.MemoryMXBean;
import java.lang.management.MemoryUsage;
import java.lang.management.OperatingSystemMXBean;
import java.lang.management.RuntimeMXBean;
import java.lang.management.ThreadMXBean;
import java.lang.reflect.Method;
import java.util.Map;

final class TimedMemberStateFactoryHelper {
  private static final int PERCENT_MULTIPLIER = 100;
  
  static void registerJMXBeans(HazelcastInstanceImpl instance, MemberStateImpl memberState) {
    InternalEventService internalEventService = instance.node.nodeEngine.getEventService();
    InternalOperationService os = instance.node.nodeEngine.getOperationService();
    NetworkingService cm = instance.node.networkingService;
    InternalPartitionServiceImpl internalPartitionServiceImpl = instance.node.partitionService;
    InternalProxyService internalProxyService = instance.node.nodeEngine.getProxyService();
    InternalExecutionService internalExecutionService = instance.node.nodeEngine.getExecutionService();
    MXBeansDTO beans = new MXBeansDTO();
    EventServiceDTO esBean = new EventServiceDTO(internalEventService);
    beans.setEventServiceBean(esBean);
    OperationServiceDTO osBean = new OperationServiceDTO(os);
    beans.setOperationServiceBean(osBean);
    ConnectionManagerDTO cmBean = new ConnectionManagerDTO(cm);
    beans.setConnectionManagerBean(cmBean);
    PartitionServiceBeanDTO psBean = new PartitionServiceBeanDTO(internalPartitionServiceImpl, instance);
    beans.setPartitionServiceBean(psBean);
    ProxyServiceDTO proxyServiceBean = new ProxyServiceDTO(internalProxyService);
    beans.setProxyServiceBean(proxyServiceBean);
    ManagedExecutorService systemExecutor = internalExecutionService.getExecutor("hz:system");
    ManagedExecutorService asyncExecutor = internalExecutionService.getExecutor("hz:async");
    ManagedExecutorService scheduledExecutor = internalExecutionService.getExecutor("hz:scheduled");
    ManagedExecutorService clientExecutor = internalExecutionService.getExecutor("hz:client");
    ManagedExecutorService queryExecutor = internalExecutionService.getExecutor("hz:query");
    ManagedExecutorService ioExecutor = internalExecutionService.getExecutor("hz:io");
    ManagedExecutorService offloadableExecutor = internalExecutionService.getExecutor("hz:offloadable");
    ManagedExecutorDTO systemExecutorDTO = new ManagedExecutorDTO(systemExecutor);
    ManagedExecutorDTO asyncExecutorDTO = new ManagedExecutorDTO(asyncExecutor);
    ManagedExecutorDTO scheduledExecutorDTO = new ManagedExecutorDTO(scheduledExecutor);
    ManagedExecutorDTO clientExecutorDTO = new ManagedExecutorDTO(clientExecutor);
    ManagedExecutorDTO queryExecutorDTO = new ManagedExecutorDTO(queryExecutor);
    ManagedExecutorDTO ioExecutorDTO = new ManagedExecutorDTO(ioExecutor);
    ManagedExecutorDTO offloadableExecutorDTO = new ManagedExecutorDTO(offloadableExecutor);
    beans.putManagedExecutor("hz:system", systemExecutorDTO);
    beans.putManagedExecutor("hz:async", asyncExecutorDTO);
    beans.putManagedExecutor("hz:scheduled", scheduledExecutorDTO);
    beans.putManagedExecutor("hz:client", clientExecutorDTO);
    beans.putManagedExecutor("hz:query", queryExecutorDTO);
    beans.putManagedExecutor("hz:io", ioExecutorDTO);
    beans.putManagedExecutor("hz:offloadable", offloadableExecutorDTO);
    memberState.setBeans(beans);
  }
  
  static void createRuntimeProps(MemberStateImpl memberState) {
    Runtime runtime = Runtime.getRuntime();
    ThreadMXBean threadMxBean = ManagementFactory.getThreadMXBean();
    RuntimeMXBean runtimeMxBean = ManagementFactory.getRuntimeMXBean();
    ClassLoadingMXBean clMxBean = ManagementFactory.getClassLoadingMXBean();
    MemoryMXBean memoryMxBean = ManagementFactory.getMemoryMXBean();
    MemoryUsage heapMemory = memoryMxBean.getHeapMemoryUsage();
    MemoryUsage nonHeapMemory = memoryMxBean.getNonHeapMemoryUsage();
    int propertyCount = 29;
    Map<String, Long> map = MapUtil.createHashMap(29);
    map.put("runtime.availableProcessors", Long.valueOf(RuntimeAvailableProcessors.get()));
    map.put("date.startTime", Long.valueOf(runtimeMxBean.getStartTime()));
    map.put("seconds.upTime", Long.valueOf(runtimeMxBean.getUptime()));
    map.put("memory.maxMemory", Long.valueOf(runtime.maxMemory()));
    map.put("memory.freeMemory", Long.valueOf(runtime.freeMemory()));
    map.put("memory.totalMemory", Long.valueOf(runtime.totalMemory()));
    map.put("memory.heapMemoryMax", Long.valueOf(heapMemory.getMax()));
    map.put("memory.heapMemoryUsed", Long.valueOf(heapMemory.getUsed()));
    map.put("memory.nonHeapMemoryMax", Long.valueOf(nonHeapMemory.getMax()));
    map.put("memory.nonHeapMemoryUsed", Long.valueOf(nonHeapMemory.getUsed()));
    map.put("runtime.totalLoadedClassCount", Long.valueOf(clMxBean.getTotalLoadedClassCount()));
    map.put("runtime.loadedClassCount", Long.valueOf(clMxBean.getLoadedClassCount()));
    map.put("runtime.unloadedClassCount", Long.valueOf(clMxBean.getUnloadedClassCount()));
    map.put("runtime.totalStartedThreadCount", Long.valueOf(threadMxBean.getTotalStartedThreadCount()));
    map.put("runtime.threadCount", Long.valueOf(threadMxBean.getThreadCount()));
    map.put("runtime.peakThreadCount", Long.valueOf(threadMxBean.getPeakThreadCount()));
    map.put("runtime.daemonThreadCount", Long.valueOf(threadMxBean.getDaemonThreadCount()));
    OperatingSystemMXBean osMxBean = ManagementFactory.getOperatingSystemMXBean();
    map.put("osMemory.freePhysicalMemory", get(osMxBean, "getFreePhysicalMemorySize", Long.valueOf(0L)));
    map.put("osMemory.committedVirtualMemory", get(osMxBean, "getCommittedVirtualMemorySize", Long.valueOf(0L)));
    map.put("osMemory.totalPhysicalMemory", get(osMxBean, "getTotalPhysicalMemorySize", Long.valueOf(0L)));
    map.put("osSwap.freeSwapSpace", get(osMxBean, "getFreeSwapSpaceSize", Long.valueOf(0L)));
    map.put("osSwap.totalSwapSpace", get(osMxBean, "getTotalSwapSpaceSize", Long.valueOf(0L)));
    map.put("os.maxFileDescriptorCount", get(osMxBean, "getMaxFileDescriptorCount", Long.valueOf(0L)));
    map.put("os.openFileDescriptorCount", get(osMxBean, "getOpenFileDescriptorCount", Long.valueOf(0L)));
    map.put("os.processCpuLoad", get(osMxBean, "getProcessCpuLoad", Long.valueOf(-1L)));
    map.put("os.systemLoadAverage", get(osMxBean, "getSystemLoadAverage", Long.valueOf(-1L)));
    map.put("os.systemCpuLoad", get(osMxBean, "getSystemCpuLoad", Long.valueOf(-1L)));
    map.put("os.processCpuTime", get(osMxBean, "getProcessCpuTime", Long.valueOf(0L)));
    map.put("os.availableProcessors", get(osMxBean, "getAvailableProcessors", Long.valueOf(0L)));
    memberState.setRuntimeProps(map);
  }
  
  private static Long get(OperatingSystemMXBean mbean, String methodName, Long defaultValue) {
    if (OperatingSystemMXBeanSupport.GET_FREE_PHYSICAL_MEMORY_SIZE_DISABLED && methodName
      .equals("getFreePhysicalMemorySize"))
      return defaultValue; 
    try {
      Method method = mbean.getClass().getMethod(methodName, new Class[0]);
      method.setAccessible(true);
      Object value = method.invoke(mbean, new Object[0]);
      if (value instanceof Integer)
        return Long.valueOf(((Integer)value).intValue()); 
      if (value instanceof Double) {
        double v = ((Double)value).doubleValue();
        return Long.valueOf(Math.round(v * 100.0D));
      } 
      if (value instanceof Long)
        return (Long)value; 
      return defaultValue;
    } catch (RuntimeException e) {
      return defaultValue;
    } catch (Exception e) {
      return defaultValue;
    } 
  }
}
