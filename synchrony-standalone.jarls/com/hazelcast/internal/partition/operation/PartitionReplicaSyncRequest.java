package com.hazelcast.internal.partition.operation;

import com.hazelcast.internal.partition.InternalPartitionService;
import com.hazelcast.internal.partition.MigrationCycleOperation;
import com.hazelcast.internal.partition.NonFragmentedServiceNamespace;
import com.hazelcast.internal.partition.PartitionReplica;
import com.hazelcast.internal.partition.PartitionReplicaVersionManager;
import com.hazelcast.internal.partition.ReplicaErrorLogger;
import com.hazelcast.internal.partition.impl.InternalPartitionImpl;
import com.hazelcast.internal.partition.impl.InternalPartitionServiceImpl;
import com.hazelcast.internal.partition.impl.PartitionStateManager;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.impl.Versioned;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.OperationService;
import com.hazelcast.spi.PartitionAwareOperation;
import com.hazelcast.spi.PartitionReplicationEvent;
import com.hazelcast.spi.ServiceNamespace;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

public final class PartitionReplicaSyncRequest extends AbstractPartitionOperation implements PartitionAwareOperation, MigrationCycleOperation, Versioned {
  private List<ServiceNamespace> namespaces;
  
  public PartitionReplicaSyncRequest() { this.namespaces = Collections.emptyList(); }
  
  public PartitionReplicaSyncRequest(int partitionId, List<ServiceNamespace> namespaces, int replicaIndex) {
    this.namespaces = namespaces;
    setPartitionId(partitionId);
    setReplicaIndex(replicaIndex);
  }
  
  public void beforeRun() {
    int syncReplicaIndex = getReplicaIndex();
    if (syncReplicaIndex < 1 || syncReplicaIndex > 6)
      throw new IllegalArgumentException("Replica index " + syncReplicaIndex + " should be in the range [1-" + '\006' + "]"); 
  }
  
  public void run() {
    InternalPartitionServiceImpl partitionService = (InternalPartitionServiceImpl)getService();
    if (!partitionService.areMigrationTasksAllowed()) {
      ILogger logger = getLogger();
      if (logger.isFinestEnabled())
        logger.finest("Migration is paused! Cannot process request. partitionId=" + 
            getPartitionId() + ", replicaIndex=" + getReplicaIndex() + ", namespaces=" + this.namespaces); 
      sendRetryResponse();
      return;
    } 
    if (!checkPartitionOwner()) {
      sendRetryResponse();
      return;
    } 
    int permits = partitionService.getReplicaManager().tryAcquireReplicaSyncPermits(this.namespaces.size());
    if (permits == 0) {
      logNotEnoughPermits();
      sendRetryResponse();
      return;
    } 
    sendOperationsForNamespaces(permits);
    if (!this.namespaces.isEmpty()) {
      logNotEnoughPermits();
      sendRetryResponse();
    } 
  }
  
  private void logNotEnoughPermits() {
    ILogger logger = getLogger();
    if (logger.isFinestEnabled())
      logger.finest("Not enough permits available! Cannot process request. partitionId=" + 
          getPartitionId() + ", replicaIndex=" + getReplicaIndex() + ", namespaces=" + this.namespaces); 
  }
  
  private void sendOperationsForNamespaces(int permits) {
    partitionService = (InternalPartitionServiceImpl)getService();
    try {
      PartitionReplicationEvent event = new PartitionReplicationEvent(getPartitionId(), getReplicaIndex());
      Iterator<ServiceNamespace> iterator = this.namespaces.iterator();
      for (int i = 0; i < permits; i++) {
        Collection<Operation> operations;
        ServiceNamespace namespace = (ServiceNamespace)iterator.next();
        if (NonFragmentedServiceNamespace.INSTANCE.equals(namespace)) {
          operations = createNonFragmentedReplicationOperations(event);
        } else {
          operations = createFragmentReplicationOperations(event, namespace);
        } 
        sendOperations(operations, namespace);
        iterator.remove();
      } 
    } finally {
      partitionService.getReplicaManager().releaseReplicaSyncPermits(permits);
    } 
  }
  
  private void sendOperations(Collection<Operation> operations, ServiceNamespace ns) {
    if (operations.isEmpty()) {
      logNoReplicaDataFound(getPartitionId(), ns, getReplicaIndex());
      sendResponse(null, ns);
    } else {
      sendResponse(operations, ns);
    } 
  }
  
  private boolean checkPartitionOwner() {
    InternalPartitionServiceImpl partitionService = (InternalPartitionServiceImpl)getService();
    PartitionStateManager partitionStateManager = partitionService.getPartitionStateManager();
    InternalPartitionImpl partition = partitionStateManager.getPartitionImpl(getPartitionId());
    PartitionReplica owner = partition.getOwnerReplicaOrNull();
    NodeEngine nodeEngine = getNodeEngine();
    if (owner == null || !owner.isIdentical(nodeEngine.getLocalMember())) {
      ILogger logger = getLogger();
      if (logger.isFinestEnabled())
        logger.finest("This node is not owner partition. Cannot process request. partitionId=" + 
            getPartitionId() + ", replicaIndex=" + getReplicaIndex() + ", namespaces=" + this.namespaces); 
      return false;
    } 
    return true;
  }
  
  private void sendRetryResponse() {
    NodeEngine nodeEngine = getNodeEngine();
    int partitionId = getPartitionId();
    int replicaIndex = getReplicaIndex();
    PartitionReplicaSyncRetryResponse response = new PartitionReplicaSyncRetryResponse(this.namespaces);
    response.setPartitionId(partitionId).setReplicaIndex(replicaIndex);
    Address target = getCallerAddress();
    OperationService operationService = nodeEngine.getOperationService();
    operationService.send(response, target);
  }
  
  private void sendResponse(Collection<Operation> operations, ServiceNamespace ns) {
    NodeEngine nodeEngine = getNodeEngine();
    PartitionReplicaSyncResponse syncResponse = createResponse(operations, ns);
    Address target = getCallerAddress();
    ILogger logger = getLogger();
    if (logger.isFinestEnabled())
      logger.finest("Sending sync response to -> " + target + " for partitionId=" + 
          getPartitionId() + ", replicaIndex=" + getReplicaIndex() + ", namespaces=" + ns); 
    syncResponse.setTarget(target);
    OperationService operationService = nodeEngine.getOperationService();
    operationService.send(syncResponse, target);
  }
  
  private PartitionReplicaSyncResponse createResponse(Collection<Operation> operations, ServiceNamespace ns) {
    int partitionId = getPartitionId();
    int replicaIndex = getReplicaIndex();
    InternalPartitionService partitionService = (InternalPartitionService)getService();
    PartitionReplicaVersionManager versionManager = partitionService.getPartitionReplicaVersionManager();
    long[] versions = versionManager.getPartitionReplicaVersions(partitionId, ns);
    PartitionReplicaSyncResponse syncResponse = new PartitionReplicaSyncResponse(operations, ns, versions);
    syncResponse.setPartitionId(partitionId).setReplicaIndex(replicaIndex);
    return syncResponse;
  }
  
  private void logNoReplicaDataFound(int partitionId, ServiceNamespace namespace, int replicaIndex) {
    ILogger logger = getLogger();
    if (logger.isFinestEnabled())
      logger.finest("No replica data is found for partitionId=" + partitionId + ", replicaIndex=" + replicaIndex + ", namespace= " + namespace); 
  }
  
  public boolean returnsResponse() { return false; }
  
  public Object getResponse() { return Boolean.TRUE; }
  
  public boolean validatesTarget() { return false; }
  
  public void logError(Throwable e) { ReplicaErrorLogger.log(e, getLogger()); }
  
  public String getServiceName() { return "hz:core:partitionService"; }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException {
    out.writeInt(this.namespaces.size());
    for (ServiceNamespace namespace : this.namespaces)
      out.writeObject(namespace); 
  }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    int len = in.readInt();
    this.namespaces = new ArrayList(len);
    for (int i = 0; i < len; i++) {
      ServiceNamespace ns = (ServiceNamespace)in.readObject();
      this.namespaces.add(ns);
    } 
  }
  
  public int getId() { return 11; }
}
