package com.hazelcast.internal.partition.operation;

import com.hazelcast.internal.cluster.Versions;
import com.hazelcast.internal.partition.MigrationInfo;
import com.hazelcast.internal.partition.ReplicaFragmentMigrationState;
import com.hazelcast.internal.partition.impl.InternalMigrationListener;
import com.hazelcast.internal.partition.impl.InternalPartitionServiceImpl;
import com.hazelcast.internal.partition.impl.PartitionReplicaManager;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.impl.Versioned;
import com.hazelcast.spi.ExceptionAction;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.OperationAccessor;
import com.hazelcast.spi.OperationResponseHandler;
import com.hazelcast.spi.PartitionMigrationEvent;
import com.hazelcast.spi.ServiceNamespace;
import com.hazelcast.spi.impl.operationservice.TargetAware;
import com.hazelcast.spi.partition.MigrationEndpoint;
import com.hazelcast.version.Version;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;

public class MigrationOperation extends BaseMigrationOperation implements TargetAware, Versioned {
  private static final OperationResponseHandler ERROR_RESPONSE_HANDLER = new Object();
  
  private ReplicaFragmentMigrationState fragmentMigrationState;
  
  private boolean firstFragment;
  
  private boolean lastFragment;
  
  private Throwable failureReason;
  
  public MigrationOperation() {}
  
  public MigrationOperation(MigrationInfo migrationInfo, List<MigrationInfo> completedMigrations, int partitionStateVersion, ReplicaFragmentMigrationState fragmentMigrationState, boolean firstFragment, boolean lastFragment) {
    super(migrationInfo, completedMigrations, partitionStateVersion);
    this.fragmentMigrationState = fragmentMigrationState;
    this.firstFragment = firstFragment;
    this.lastFragment = lastFragment;
    setReplicaIndex(migrationInfo.getDestinationNewReplicaIndex());
  }
  
  public void run() {
    if (this.firstFragment)
      setActiveMigration(); 
    try {
      checkActiveMigration();
      doRun();
    } catch (Throwable t) {
      logMigrationFailure(t);
      this.failureReason = t;
    } finally {
      onMigrationComplete();
      if (!this.success)
        onExecutionFailure(this.failureReason); 
    } 
  }
  
  private void doRun() {
    if (this.migrationInfo.startProcessing()) {
      try {
        if (this.firstFragment)
          executeBeforeMigrations(); 
        for (Operation migrationOperation : this.fragmentMigrationState.getMigrationOperations())
          runMigrationOperation(migrationOperation); 
        this.success = true;
      } catch (Throwable e) {
        this.failureReason = e;
        getLogger().severe("Error while executing replication operations " + this.migrationInfo, e);
      } finally {
        afterMigrate();
      } 
    } else {
      logMigrationCancelled();
    } 
  }
  
  private void checkActiveMigration() {
    InternalPartitionServiceImpl partitionService = (InternalPartitionServiceImpl)getService();
    MigrationInfo activeMigration = partitionService.getMigrationManager().getActiveMigration();
    if (!this.migrationInfo.equals(activeMigration))
      throw new IllegalStateException("Unexpected active migration " + activeMigration + "! First migration fragment should have set active migration to: " + this.migrationInfo); 
  }
  
  private void runMigrationOperation(Operation op) throws Exception {
    prepareOperation(op);
    op.beforeRun();
    op.run();
    op.afterRun();
  }
  
  protected void prepareOperation(Operation op) throws Exception {
    op.setNodeEngine(getNodeEngine())
      .setPartitionId(getPartitionId())
      .setReplicaIndex(getReplicaIndex());
    op.setOperationResponseHandler(ERROR_RESPONSE_HANDLER);
    OperationAccessor.setCallerAddress(op, this.migrationInfo.getSourceAddress());
  }
  
  private void afterMigrate() {
    ILogger logger = getLogger();
    if (this.success) {
      InternalPartitionServiceImpl partitionService = (InternalPartitionServiceImpl)getService();
      PartitionReplicaManager replicaManager = partitionService.getReplicaManager();
      int destinationNewReplicaIndex = this.migrationInfo.getDestinationNewReplicaIndex();
      int replicaOffset = Math.max(destinationNewReplicaIndex, 1);
      Map<ServiceNamespace, long[]> namespaceVersions = this.fragmentMigrationState.getNamespaceVersionMap();
      for (Map.Entry<ServiceNamespace, long[]> e : namespaceVersions.entrySet()) {
        ServiceNamespace namespace = (ServiceNamespace)e.getKey();
        long[] replicaVersions = (long[])e.getValue();
        replicaManager.setPartitionReplicaVersions(this.migrationInfo.getPartitionId(), namespace, replicaVersions, replicaOffset);
        if (logger.isFinestEnabled())
          logger.finest("ReplicaVersions are set after migration. partitionId=" + this.migrationInfo
              .getPartitionId() + " namespace: " + namespace + " replicaVersions=" + 
              Arrays.toString(replicaVersions)); 
      } 
    } else if (logger.isFinestEnabled()) {
      logger.finest("ReplicaVersions are not set since migration failed. partitionId=" + this.migrationInfo
          .getPartitionId());
    } 
    this.migrationInfo.doneProcessing();
  }
  
  private void logMigrationCancelled() { getLogger().warning("Migration is cancelled -> " + this.migrationInfo); }
  
  private void logMigrationFailure(Throwable e) {
    ILogger logger = getLogger();
    if (e instanceof IllegalStateException) {
      logger.warning(e.getMessage());
    } else {
      logger.warning(e.getMessage(), e);
    } 
  }
  
  protected PartitionMigrationEvent getMigrationEvent() {
    return new PartitionMigrationEvent(MigrationEndpoint.DESTINATION, this.migrationInfo
        .getPartitionId(), this.migrationInfo.getDestinationCurrentReplicaIndex(), this.migrationInfo
        .getDestinationNewReplicaIndex());
  }
  
  protected InternalMigrationListener.MigrationParticipant getMigrationParticipantType() { return InternalMigrationListener.MigrationParticipant.DESTINATION; }
  
  public void onExecutionFailure(Throwable e) {
    if (this.fragmentMigrationState == null)
      return; 
    Collection<Operation> tasks = this.fragmentMigrationState.getMigrationOperations();
    if (tasks != null)
      for (Operation op : tasks) {
        prepareOperation(op);
        onOperationFailure(op, e);
      }  
  }
  
  private void onOperationFailure(Operation op, Throwable e) {
    try {
      op.onExecutionFailure(e);
    } catch (Throwable t) {
      getLogger().warning("While calling operation.onFailure(). op: " + op, t);
    } 
  }
  
  public int getId() { return 18; }
  
  void onMigrationStart() {
    if (this.firstFragment)
      super.onMigrationStart(); 
  }
  
  void onMigrationComplete() {
    if (this.lastFragment)
      super.onMigrationComplete(); 
  }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException {
    super.writeInternal(out);
    Version version = out.getVersion();
    if (version.isGreaterOrEqual(Versions.V3_12)) {
      out.writeObject(this.fragmentMigrationState);
    } else {
      this.fragmentMigrationState.writeData(out);
    } 
    out.writeBoolean(this.firstFragment);
    out.writeBoolean(this.lastFragment);
  }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    super.readInternal(in);
    Version version = in.getVersion();
    if (version.isGreaterOrEqual(Versions.V3_12)) {
      this.fragmentMigrationState = (ReplicaFragmentMigrationState)in.readObject();
    } else {
      this.fragmentMigrationState = new ReplicaFragmentMigrationState();
      this.fragmentMigrationState.readData(in);
    } 
    this.firstFragment = in.readBoolean();
    this.lastFragment = in.readBoolean();
  }
  
  public void setTarget(Address address) { this.fragmentMigrationState.setTarget(address); }
}
