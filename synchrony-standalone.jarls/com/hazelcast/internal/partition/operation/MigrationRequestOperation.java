package com.hazelcast.internal.partition.operation;

import com.hazelcast.internal.partition.InternalPartitionService;
import com.hazelcast.internal.partition.MigrationInfo;
import com.hazelcast.internal.partition.NonFragmentedServiceNamespace;
import com.hazelcast.internal.partition.PartitionReplica;
import com.hazelcast.internal.partition.PartitionReplicaVersionManager;
import com.hazelcast.internal.partition.ReplicaFragmentMigrationState;
import com.hazelcast.internal.partition.impl.InternalMigrationListener;
import com.hazelcast.internal.partition.impl.InternalPartitionServiceImpl;
import com.hazelcast.internal.partition.impl.MigrationManager;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.spi.CallStatus;
import com.hazelcast.spi.ExceptionAction;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.PartitionMigrationEvent;
import com.hazelcast.spi.PartitionReplicationEvent;
import com.hazelcast.spi.ServiceNamespace;
import com.hazelcast.spi.partition.MigrationEndpoint;
import java.io.IOException;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;

public class MigrationRequestOperation extends BaseMigrationOperation {
  private boolean fragmentedMigrationEnabled;
  
  private ServiceNamespacesContext namespacesContext;
  
  public MigrationRequestOperation() {}
  
  public MigrationRequestOperation(MigrationInfo migrationInfo, List<MigrationInfo> completedMigrations, int partitionStateVersion, boolean fragmentedMigrationEnabled) {
    super(migrationInfo, completedMigrations, partitionStateVersion);
    this.fragmentedMigrationEnabled = fragmentedMigrationEnabled;
  }
  
  public CallStatus call() throws Exception {
    setActiveMigration();
    if (!this.migrationInfo.startProcessing()) {
      getLogger().warning("Migration is cancelled -> " + this.migrationInfo);
      completeMigration(false);
      return CallStatus.DONE_VOID;
    } 
    return new OffloadImpl(this, null);
  }
  
  void executeBeforeMigrations() {
    NodeEngine nodeEngine = getNodeEngine();
    PartitionReplica source = this.migrationInfo.getSource();
    boolean ownerMigration = (source != null && source.isIdentical(nodeEngine.getLocalMember()));
    if (!ownerMigration)
      return; 
    super.executeBeforeMigrations();
  }
  
  private void invokeMigrationOperation(ReplicaFragmentMigrationState migrationState, boolean firstFragment) {
    boolean lastFragment = (!this.fragmentedMigrationEnabled || !this.namespacesContext.hasNext());
    MigrationOperation migrationOperation = new MigrationOperation(this.migrationInfo, firstFragment ? this.completedMigrations : Collections.emptyList(), this.partitionStateVersion, migrationState, firstFragment, lastFragment);
    ILogger logger = getLogger();
    if (logger.isFinestEnabled()) {
      Set<ServiceNamespace> namespaces = (migrationState != null) ? migrationState.getNamespaceVersionMap().keySet() : Collections.emptySet();
      logger.finest("Invoking MigrationOperation for namespaces " + namespaces + " and " + this.migrationInfo + ", lastFragment: " + lastFragment);
    } 
    NodeEngine nodeEngine = getNodeEngine();
    InternalPartitionServiceImpl partitionService = (InternalPartitionServiceImpl)getService();
    Address target = this.migrationInfo.getDestinationAddress();
    nodeEngine.getOperationService()
      .createInvocationBuilder("hz:core:partitionService", migrationOperation, target)
      .setExecutionCallback(new MigrationCallback(this, null))
      .setResultDeserialized(true)
      .setCallTimeout(partitionService.getPartitionMigrationTimeout())
      .setTryCount(12)
      .setTryPauseMillis(10000L)
      .invoke();
  }
  
  private void trySendNewFragment() {
    try {
      assert this.fragmentedMigrationEnabled : "Fragmented migration should be enabled!";
      verifyMaster();
      verifyExistingDestination();
      InternalPartitionServiceImpl partitionService = (InternalPartitionServiceImpl)getService();
      MigrationManager migrationManager = partitionService.getMigrationManager();
      MigrationInfo currentActiveMigration = migrationManager.setActiveMigration(this.migrationInfo);
      if (!this.migrationInfo.equals(currentActiveMigration))
        throw new IllegalStateException("Current active migration " + currentActiveMigration + " is different than expected: " + this.migrationInfo); 
      ReplicaFragmentMigrationState migrationState = createNextReplicaFragmentMigrationState();
      if (migrationState != null) {
        invokeMigrationOperation(migrationState, false);
      } else {
        getLogger().finest("All migration fragments done for " + this.migrationInfo);
        completeMigration(true);
      } 
    } catch (Throwable e) {
      logThrowable(e);
      completeMigration(false);
    } 
  }
  
  private ReplicaFragmentMigrationState createNextReplicaFragmentMigrationState() {
    assert this.fragmentedMigrationEnabled : "Fragmented migration should be enabled!";
    if (!this.namespacesContext.hasNext())
      return null; 
    ServiceNamespace namespace = this.namespacesContext.next();
    if (namespace.equals(NonFragmentedServiceNamespace.INSTANCE))
      return createNonFragmentedReplicaFragmentMigrationState(); 
    return createReplicaFragmentMigrationStateFor(namespace);
  }
  
  private ReplicaFragmentMigrationState createNonFragmentedReplicaFragmentMigrationState() {
    PartitionReplicationEvent event = getPartitionReplicationEvent();
    Collection<Operation> operations = createNonFragmentedReplicationOperations(event);
    Collection<ServiceNamespace> namespaces = Collections.singleton(NonFragmentedServiceNamespace.INSTANCE);
    return createReplicaFragmentMigrationState(namespaces, operations);
  }
  
  private ReplicaFragmentMigrationState createReplicaFragmentMigrationStateFor(ServiceNamespace ns) {
    PartitionReplicationEvent event = getPartitionReplicationEvent();
    Collection<String> serviceNames = this.namespacesContext.getServiceNames(ns);
    Collection<Operation> operations = createFragmentReplicationOperations(event, ns, serviceNames);
    return createReplicaFragmentMigrationState(Collections.singleton(ns), operations);
  }
  
  private ReplicaFragmentMigrationState createAllReplicaFragmentsMigrationState() {
    PartitionReplicationEvent event = getPartitionReplicationEvent();
    Collection<Operation> operations = createAllReplicationOperations(event);
    return createReplicaFragmentMigrationState(this.namespacesContext.allNamespaces, operations);
  }
  
  private ReplicaFragmentMigrationState createReplicaFragmentMigrationState(Collection<ServiceNamespace> namespaces, Collection<Operation> operations) {
    InternalPartitionService partitionService = (InternalPartitionService)getService();
    PartitionReplicaVersionManager versionManager = partitionService.getPartitionReplicaVersionManager();
    Map<ServiceNamespace, long[]> versions = new HashMap<ServiceNamespace, long[]>(namespaces.size());
    for (ServiceNamespace namespace : namespaces) {
      long[] v = versionManager.getPartitionReplicaVersions(getPartitionId(), namespace);
      versions.put(namespace, v);
    } 
    return new ReplicaFragmentMigrationState(versions, operations);
  }
  
  protected PartitionMigrationEvent getMigrationEvent() {
    return new PartitionMigrationEvent(MigrationEndpoint.SOURCE, this.migrationInfo
        .getPartitionId(), this.migrationInfo.getSourceCurrentReplicaIndex(), this.migrationInfo
        .getSourceNewReplicaIndex());
  }
  
  protected InternalMigrationListener.MigrationParticipant getMigrationParticipantType() { return InternalMigrationListener.MigrationParticipant.SOURCE; }
  
  private PartitionReplicationEvent getPartitionReplicationEvent() { return new PartitionReplicationEvent(this.migrationInfo.getPartitionId(), this.migrationInfo.getDestinationNewReplicaIndex()); }
  
  private void completeMigration(boolean result) {
    this.success = result;
    this.migrationInfo.doneProcessing();
    onMigrationComplete();
    sendResponse(Boolean.valueOf(result));
  }
  
  private void logThrowable(Throwable t) {
    Throwable throwableToLog = t;
    if (throwableToLog instanceof java.util.concurrent.ExecutionException)
      throwableToLog = (throwableToLog.getCause() != null) ? throwableToLog.getCause() : throwableToLog; 
    Level level = getLogLevel(throwableToLog);
    getLogger().log(level, throwableToLog.getMessage(), throwableToLog);
  }
  
  private Level getLogLevel(Throwable e) {
    return (e instanceof com.hazelcast.core.MemberLeftException || e instanceof InterruptedException || 
      !getNodeEngine().isRunning()) ? Level.INFO : Level.WARNING;
  }
  
  public int getId() { return 19; }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException {
    super.writeInternal(out);
    out.writeBoolean(this.fragmentedMigrationEnabled);
  }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    super.readInternal(in);
    this.fragmentedMigrationEnabled = in.readBoolean();
  }
}
