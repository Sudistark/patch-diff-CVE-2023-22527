package com.hazelcast.internal.partition.impl;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

class MigrationQueue {
  private final AtomicInteger migrateTaskCount = new AtomicInteger();
  
  private final BlockingQueue<MigrationRunnable> queue = new LinkedBlockingQueue();
  
  @SuppressFBWarnings(value = {"RV_RETURN_VALUE_IGNORED"}, justification = "offer will always be successful since queue is unbounded")
  public void add(MigrationRunnable task) {
    this.migrateTaskCount.incrementAndGet();
    this.queue.offer(task);
  }
  
  public MigrationRunnable poll(int timeout, TimeUnit unit) throws InterruptedException { return (MigrationRunnable)this.queue.poll(timeout, unit); }
  
  public void clear() {
    List<MigrationRunnable> sink = new ArrayList<MigrationRunnable>();
    this.queue.drainTo(sink);
    for (MigrationRunnable task : sink)
      afterTaskCompletion(task); 
  }
  
  public void afterTaskCompletion(MigrationRunnable task) {
    if (this.migrateTaskCount.decrementAndGet() < 0)
      throw new IllegalStateException(); 
  }
  
  public int migrationTaskCount() { return this.migrateTaskCount.get(); }
  
  public boolean hasMigrationTasks() { return (this.migrateTaskCount.get() > 0); }
  
  public String toString() { return "MigrationQueue{migrateTaskCount=" + this.migrateTaskCount + ", queue=" + this.queue + '}'; }
}
