package com.hazelcast.internal.partition.impl;

import com.hazelcast.instance.OutOfMemoryErrorDispatcher;
import com.hazelcast.logging.ILogger;
import com.hazelcast.util.ThreadUtil;
import java.util.concurrent.TimeUnit;

class MigrationThread extends Thread implements Runnable {
  private static final long DEFAULT_MIGRATION_SLEEP_INTERVAL = 250L;
  
  private final MigrationManager migrationManager;
  
  private final MigrationQueue queue;
  
  private final ILogger logger;
  
  private final long partitionMigrationInterval;
  
  private final long sleepTime;
  
  MigrationThread(MigrationManager migrationManager, String hzName, ILogger logger, MigrationQueue queue) {
    super(ThreadUtil.createThreadName(hzName, "migration"));
    this.migrationManager = migrationManager;
    this.queue = queue;
    this.partitionMigrationInterval = migrationManager.partitionMigrationInterval;
    this.sleepTime = Math.max(250L, this.partitionMigrationInterval);
    this.logger = logger;
  }
  
  public void run() {
    try {
      while (this.running)
        doRun(); 
    } catch (InterruptedException e) {
      if (this.logger.isFinestEnabled())
        this.logger.finest("MigrationThread is interrupted: " + e.getMessage()); 
    } catch (OutOfMemoryError e) {
      OutOfMemoryErrorDispatcher.onOutOfMemory(e);
    } finally {
      this.queue.clear();
    } 
  }
  
  private void doRun() {
    boolean migrating = false;
    while (this.migrationManager.areMigrationTasksAllowed()) {
      MigrationRunnable runnable = this.queue.poll(1, TimeUnit.SECONDS);
      if (runnable == null)
        break; 
      migrating |= runnable instanceof MigrationManager.MigrateTask;
      processTask(runnable);
      if (migrating && this.partitionMigrationInterval > 0L)
        Thread.sleep(this.partitionMigrationInterval); 
    } 
    boolean hasNoTasks = !this.queue.hasMigrationTasks();
    if (hasNoTasks) {
      if (migrating)
        this.logger.info("All migration tasks have been completed. (" + this.migrationManager
            .getStats().formatToString(this.logger.isFineEnabled()) + ")"); 
      Thread.sleep(this.sleepTime);
    } else if (!this.migrationManager.areMigrationTasksAllowed()) {
      Thread.sleep(this.sleepTime);
    } 
  }
  
  private boolean processTask(MigrationRunnable runnable) {
    try {
      if (runnable == null || !this.running)
        return false; 
      this.activeTask = runnable;
      runnable.run();
    } catch (Throwable t) {
      this.logger.warning(t);
    } finally {
      this.queue.afterTaskCompletion(runnable);
      this.activeTask = null;
    } 
    return true;
  }
  
  MigrationRunnable getActiveTask() { return this.activeTask; }
  
  void stopNow() {
    assert currentThread() != this : "stopNow must not be called on the migration thread";
    this.running = false;
    this.queue.clear();
    interrupt();
    boolean currentThreadInterrupted = false;
    while (true) {
      try {
        join();
        break;
      } catch (InterruptedException e) {
        currentThreadInterrupted = true;
      } 
    } 
    if (currentThreadInterrupted)
      currentThread().interrupt(); 
  }
}
