package com.hazelcast.internal.partition.impl;

import com.hazelcast.cluster.ClusterState;
import com.hazelcast.core.Member;
import com.hazelcast.instance.MemberImpl;
import com.hazelcast.instance.Node;
import com.hazelcast.internal.cluster.Versions;
import com.hazelcast.internal.cluster.impl.ClusterServiceImpl;
import com.hazelcast.internal.metrics.Probe;
import com.hazelcast.internal.partition.MigrationInfo;
import com.hazelcast.internal.partition.PartitionReplica;
import com.hazelcast.internal.partition.PartitionRuntimeState;
import com.hazelcast.internal.partition.operation.FinalizeMigrationOperation;
import com.hazelcast.internal.partition.operation.MigrationCommitOperation;
import com.hazelcast.internal.partition.operation.PublishCompletedMigrationsOperation;
import com.hazelcast.internal.partition.operation.ShutdownResponseOperation;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.impl.executionservice.InternalExecutionService;
import com.hazelcast.spi.impl.operationservice.InternalOperationService;
import com.hazelcast.spi.partition.MigrationEndpoint;
import com.hazelcast.spi.properties.GroupProperty;
import com.hazelcast.spi.properties.HazelcastProperties;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.scheduler.CoalescingDelayedTrigger;
import com.hazelcast.version.Version;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Lock;

public class MigrationManager {
  private static final int MIGRATION_PAUSE_DURATION_SECONDS_ON_MIGRATION_FAILURE = 3;
  
  private static final int PUBLISH_COMPLETED_MIGRATIONS_BATCH_SIZE = 10;
  
  final long partitionMigrationInterval;
  
  private final Node node;
  
  private final NodeEngineImpl nodeEngine;
  
  private final InternalPartitionServiceImpl partitionService;
  
  private final ILogger logger;
  
  private final PartitionStateManager partitionStateManager;
  
  private final MigrationQueue migrationQueue;
  
  private final MigrationThread migrationThread;
  
  private final AtomicBoolean migrationTasksAllowed;
  
  private final long partitionMigrationTimeout;
  
  private final CoalescingDelayedTrigger delayedResumeMigrationTrigger;
  
  private final Set<Member> shutdownRequestedMembers;
  
  private final LinkedHashSet<MigrationInfo> completedMigrations;
  
  private final AtomicBoolean promotionPermit;
  
  private final MigrationStats stats;
  
  private final Lock partitionServiceLock;
  
  private final MigrationPlanner migrationPlanner;
  
  private final boolean fragmentedMigrationEnabled;
  
  private final long memberHeartbeatTimeoutMillis;
  
  private boolean triggerRepartitioningWhenClusterStateAllowsMigration;
  
  private final Set<MigrationInfo> finalizingMigrationsRegistry;
  
  MigrationManager(Node node, InternalPartitionServiceImpl service, Lock partitionServiceLock) {
    this.migrationQueue = new MigrationQueue();
    this.migrationTasksAllowed = new AtomicBoolean(true);
    this.shutdownRequestedMembers = new HashSet();
    this.completedMigrations = new LinkedHashSet();
    this.promotionPermit = new AtomicBoolean(false);
    this.stats = new MigrationStats();
    this.internalMigrationListener = new InternalMigrationListener.NopInternalMigrationListener();
    this
      .finalizingMigrationsRegistry = Collections.newSetFromMap(new ConcurrentHashMap());
    this.node = node;
    this.nodeEngine = node.getNodeEngine();
    this.partitionService = service;
    this.logger = node.getLogger(getClass());
    this.partitionServiceLock = partitionServiceLock;
    this.migrationPlanner = new MigrationPlanner(node.getLogger(MigrationPlanner.class));
    HazelcastProperties properties = node.getProperties();
    this.partitionMigrationInterval = properties.getPositiveMillisOrDefault(GroupProperty.PARTITION_MIGRATION_INTERVAL, 0L);
    this.partitionMigrationTimeout = properties.getMillis(GroupProperty.PARTITION_MIGRATION_TIMEOUT);
    this.fragmentedMigrationEnabled = properties.getBoolean(GroupProperty.PARTITION_FRAGMENTED_MIGRATION_ENABLED);
    this.partitionStateManager = this.partitionService.getPartitionStateManager();
    ILogger migrationThreadLogger = node.getLogger(MigrationThread.class);
    String hzName = this.nodeEngine.getHazelcastInstance().getName();
    this.migrationThread = new MigrationThread(this, hzName, migrationThreadLogger, this.migrationQueue);
    long migrationPauseDelayMs = TimeUnit.SECONDS.toMillis(3L);
    InternalExecutionService internalExecutionService = this.nodeEngine.getExecutionService();
    this.delayedResumeMigrationTrigger = new CoalescingDelayedTrigger(internalExecutionService, migrationPauseDelayMs, 2L * migrationPauseDelayMs, new Object(this));
    this.memberHeartbeatTimeoutMillis = properties.getMillis(GroupProperty.MAX_NO_HEARTBEAT_SECONDS);
    this.nodeEngine.getMetricsRegistry().scanAndRegister(this.stats, "partitions");
  }
  
  @Probe(name = "migrationActive")
  private int migrationActiveProbe() { return this.migrationTasksAllowed.get() ? 1 : 0; }
  
  void pauseMigration() { this.migrationTasksAllowed.set(false); }
  
  void resumeMigration() { this.migrationTasksAllowed.set(true); }
  
  private void resumeMigrationEventually() { this.delayedResumeMigrationTrigger.executeWithDelay(); }
  
  boolean areMigrationTasksAllowed() { return this.migrationTasksAllowed.get(); }
  
  void finalizeMigration(MigrationInfo migrationInfo) {
    try {
      PartitionReplica localReplica = PartitionReplica.from(this.node.getLocalMember());
      int partitionId = migrationInfo.getPartitionId();
      boolean source = localReplica.equals(migrationInfo.getSource());
      boolean destination = localReplica.equals(migrationInfo.getDestination());
      assert migrationInfo.getStatus() == MigrationInfo.MigrationStatus.SUCCESS || migrationInfo
        .getStatus() == MigrationInfo.MigrationStatus.FAILED : "Invalid migration: " + migrationInfo;
      if (source || destination) {
        boolean success = (migrationInfo.getStatus() == MigrationInfo.MigrationStatus.SUCCESS);
        InternalMigrationListener.MigrationParticipant participant = source ? InternalMigrationListener.MigrationParticipant.SOURCE : InternalMigrationListener.MigrationParticipant.DESTINATION;
        if (success) {
          this.internalMigrationListener.onMigrationCommit(participant, migrationInfo);
        } else {
          this.internalMigrationListener.onMigrationRollback(participant, migrationInfo);
        } 
        MigrationEndpoint endpoint = source ? MigrationEndpoint.SOURCE : MigrationEndpoint.DESTINATION;
        FinalizeMigrationOperation op = new FinalizeMigrationOperation(migrationInfo, endpoint, success);
        op.setPartitionId(partitionId).setNodeEngine(this.nodeEngine).setValidateTarget(false).setService(this.partitionService);
        registerFinalizingMigration(migrationInfo);
        InternalOperationService operationService = this.nodeEngine.getOperationService();
        if (operationService.isRunAllowed(op)) {
          operationService.run(op);
        } else {
          operationService.execute(op);
        } 
        removeActiveMigration(partitionId);
      } else {
        PartitionReplica partitionOwner = this.partitionStateManager.getPartitionImpl(partitionId).getOwnerReplicaOrNull();
        if (localReplica.equals(partitionOwner)) {
          removeActiveMigration(partitionId);
          this.partitionStateManager.clearMigratingFlag(partitionId);
        } else {
          this.logger.severe("Failed to finalize migration because " + localReplica + " is not a participant of the migration: " + migrationInfo);
        } 
      } 
    } catch (Exception e) {
      this.logger.warning(e);
    } finally {
      migrationInfo.doneProcessing();
    } 
  }
  
  private void registerFinalizingMigration(MigrationInfo migration) { this.finalizingMigrationsRegistry.add(migration); }
  
  public boolean removeFinalizingMigration(MigrationInfo migration) { return this.finalizingMigrationsRegistry.remove(migration); }
  
  public boolean isFinalizingMigrationRegistered(int partitionId) {
    for (MigrationInfo migrationInfo : this.finalizingMigrationsRegistry) {
      if (partitionId == migrationInfo.getPartitionId())
        return true; 
    } 
    return false;
  }
  
  public MigrationInfo setActiveMigration(MigrationInfo migrationInfo) {
    this.partitionServiceLock.lock();
    try {
      if (this.activeMigrationInfo == null) {
        this.activeMigrationInfo = migrationInfo;
        return null;
      } 
      if (!this.activeMigrationInfo.equals(migrationInfo) && 
        this.logger.isFineEnabled())
        this.logger.fine("Active migration is not set: " + migrationInfo + ". Existing active migration: " + this.activeMigrationInfo); 
      return this.activeMigrationInfo;
    } finally {
      this.partitionServiceLock.unlock();
    } 
  }
  
  public MigrationInfo getActiveMigration() { return this.activeMigrationInfo; }
  
  public boolean acquirePromotionPermit() { return this.promotionPermit.compareAndSet(false, true); }
  
  public void releasePromotionPermit() { this.promotionPermit.set(false); }
  
  private boolean removeActiveMigration(int partitionId) {
    this.partitionServiceLock.lock();
    try {
      if (this.activeMigrationInfo != null) {
        if (this.activeMigrationInfo.getPartitionId() == partitionId) {
          this.activeMigrationInfo = null;
          return true;
        } 
        if (this.logger.isFineEnabled())
          this.logger.fine("Active migration is not removed, because it has different partitionId! partitionId=" + partitionId + ", active migration=" + this.activeMigrationInfo); 
      } 
    } finally {
      this.partitionServiceLock.unlock();
    } 
    return false;
  }
  
  void scheduleActiveMigrationFinalization(MigrationInfo migrationInfo) {
    this.partitionServiceLock.lock();
    try {
      if (migrationInfo.equals(this.activeMigrationInfo)) {
        if (this.activeMigrationInfo.startProcessing()) {
          this.activeMigrationInfo.setStatus(migrationInfo.getStatus());
          finalizeMigration(this.activeMigrationInfo);
        } else {
          this.logger.info("Scheduling finalization of " + migrationInfo + ", because migration process is currently running.");
          this.nodeEngine.getExecutionService().schedule(new Object(this, migrationInfo), 1L, TimeUnit.SECONDS);
        } 
        return;
      } 
      PartitionReplica source = migrationInfo.getSource();
      if (source != null && migrationInfo.getSourceCurrentReplicaIndex() > 0 && source
        .isIdentical(this.node.getLocalMember()))
        finalizeMigration(migrationInfo); 
    } finally {
      this.partitionServiceLock.unlock();
    } 
  }
  
  private boolean commitMigrationToDestination(MigrationInfo migration) {
    PartitionReplica destination = migration.getDestination();
    if (destination.isIdentical(this.node.getLocalMember())) {
      if (this.logger.isFinestEnabled())
        this.logger.finest("Shortcutting migration commit, since destination is master. -> " + migration); 
      return true;
    } 
    MemberImpl memberImpl = this.node.getClusterService().getMember(destination.address(), destination.uuid());
    if (memberImpl == null) {
      this.logger.warning("Cannot commit " + migration + ". Destination " + destination + " is not a member anymore");
      return false;
    } 
    try {
      MigrationCommitOperation operation;
      if (this.logger.isFinestEnabled())
        this.logger.finest("Sending migration commit operation to " + destination + " for " + migration); 
      migration.setStatus(MigrationInfo.MigrationStatus.SUCCESS);
      String destinationUuid = memberImpl.getUuid();
      if (this.nodeEngine.getClusterService().getClusterVersion().isGreaterOrEqual(Versions.V3_12)) {
        operation = new MigrationCommitOperation(migration, destinationUuid);
      } else {
        PartitionRuntimeState partitionState = this.partitionService.createMigrationCommitPartitionState(migration);
        operation = new MigrationCommitOperation(partitionState, destinationUuid);
      } 
      InternalCompletableFuture internalCompletableFuture = this.nodeEngine.getOperationService().createInvocationBuilder("hz:core:partitionService", operation, destination.address()).setTryCount(2147483647).setCallTimeout(this.memberHeartbeatTimeoutMillis).invoke();
      boolean result = ((Boolean)internalCompletableFuture.get()).booleanValue();
      if (this.logger.isFinestEnabled())
        this.logger.finest("Migration commit result " + result + " from " + destination + " for " + migration); 
      return result;
    } catch (Throwable t) {
      logMigrationCommitFailure(migration, t);
      if (t.getCause() instanceof com.hazelcast.core.OperationTimeoutException)
        return commitMigrationToDestination(migration); 
      return false;
    } 
  }
  
  private void logMigrationCommitFailure(MigrationInfo migration, Throwable t) {
    boolean memberLeft = (t instanceof com.hazelcast.core.MemberLeftException || t.getCause() instanceof com.hazelcast.spi.exception.TargetNotMemberException || t.getCause() instanceof com.hazelcast.core.HazelcastInstanceNotActiveException);
    PartitionReplica destination = migration.getDestination();
    if (memberLeft) {
      if (destination.isIdentical(this.node.getLocalMember())) {
        this.logger.fine("Migration commit failed for " + migration + " since this node is shutting down.");
        return;
      } 
      this.logger.warning("Migration commit failed for " + migration + " since destination " + destination + " left the cluster");
    } else {
      this.logger.severe("Migration commit to " + destination + " failed for " + migration, t);
    } 
  }
  
  boolean addCompletedMigration(MigrationInfo migrationInfo) {
    if (migrationInfo.getStatus() != MigrationInfo.MigrationStatus.SUCCESS && migrationInfo
      .getStatus() != MigrationInfo.MigrationStatus.FAILED)
      throw new IllegalArgumentException("Migration doesn't seem completed: " + migrationInfo); 
    if (this.node.getClusterService().getClusterVersion().isGreaterOrEqual(Versions.V3_12) && (
      migrationInfo.getInitialPartitionVersion() <= 0 || migrationInfo.getPartitionVersionIncrement() <= 0))
      throw new IllegalArgumentException("Partition state versions are not set: " + migrationInfo); 
    this.partitionServiceLock.lock();
    try {
      boolean added = this.completedMigrations.add(migrationInfo);
      if (added)
        this.stats.incrementCompletedMigrations(); 
      return added;
    } finally {
      this.partitionServiceLock.unlock();
    } 
  }
  
  void retainCompletedMigrations(Collection<MigrationInfo> migrations) {
    this.partitionServiceLock.lock();
    try {
      this.completedMigrations.retainAll(migrations);
    } finally {
      this.partitionServiceLock.unlock();
    } 
  }
  
  private void evictCompletedMigrations(MigrationInfo currentMigration) {
    this.partitionServiceLock.lock();
    try {
      assert this.completedMigrations.contains(currentMigration) : currentMigration + " to evict is not in completed migrations";
      Iterator<MigrationInfo> iter = this.completedMigrations.iterator();
      while (iter.hasNext()) {
        MigrationInfo migration = (MigrationInfo)iter.next();
        iter.remove();
        if (migration.equals(currentMigration))
          return; 
      } 
    } finally {
      this.partitionServiceLock.unlock();
    } 
  }
  
  private void evictCompletedMigrations(Collection<MigrationInfo> migrations) {
    this.partitionServiceLock.lock();
    try {
      this.completedMigrations.removeAll(migrations);
    } finally {
      this.partitionServiceLock.unlock();
    } 
  }
  
  void triggerControlTask() {
    this.migrationQueue.clear();
    if (!this.node.getClusterService().isJoined()) {
      this.logger.fine("Node is not joined, will not trigger ControlTask");
      return;
    } 
    if (!this.partitionService.isLocalMemberMaster()) {
      this.logger.fine("Node is not master, will not trigger ControlTask");
      return;
    } 
    this.migrationQueue.add(new ControlTask(this, null));
    if (this.logger.isFinestEnabled())
      this.logger.finest("Migration queue is cleared and control task is scheduled"); 
  }
  
  InternalMigrationListener getInternalMigrationListener() { return this.internalMigrationListener; }
  
  void setInternalMigrationListener(InternalMigrationListener listener) {
    Preconditions.checkNotNull(listener);
    this.internalMigrationListener = listener;
  }
  
  void resetInternalMigrationListener() { this.internalMigrationListener = new InternalMigrationListener.NopInternalMigrationListener(); }
  
  void onShutdownRequest(Member member) {
    if (!this.partitionStateManager.isInitialized()) {
      sendShutdownOperation(member.getAddress());
      return;
    } 
    ClusterState clusterState = this.node.getClusterService().getClusterState();
    if (!clusterState.isMigrationAllowed() && clusterState != ClusterState.IN_TRANSITION) {
      sendShutdownOperation(member.getAddress());
      return;
    } 
    if (this.shutdownRequestedMembers.add(member)) {
      this.logger.info("Shutdown request of " + member + " is handled");
      triggerControlTask();
    } 
  }
  
  void onMemberRemove(Member member) {
    this.shutdownRequestedMembers.remove(member);
    MigrationInfo activeMigration = this.activeMigrationInfo;
    if (activeMigration != null) {
      PartitionReplica replica = PartitionReplica.from(member);
      if (replica.equals(activeMigration.getSource()) || replica
        .equals(activeMigration.getDestination()))
        activeMigration.setStatus(MigrationInfo.MigrationStatus.INVALID); 
    } 
  }
  
  void schedule(MigrationRunnable runnable) { this.migrationQueue.add(runnable); }
  
  List<MigrationInfo> getCompletedMigrationsCopy() {
    this.partitionServiceLock.lock();
    try {
      return new ArrayList(this.completedMigrations);
    } finally {
      this.partitionServiceLock.unlock();
    } 
  }
  
  boolean hasOnGoingMigration() { return (this.activeMigrationInfo != null || this.migrationQueue.hasMigrationTasks()); }
  
  int getMigrationQueueSize() { return this.migrationQueue.migrationTaskCount(); }
  
  void reset() {
    this.migrationQueue.clear();
    this.activeMigrationInfo = null;
    this.completedMigrations.clear();
    this.shutdownRequestedMembers.clear();
    this.migrationTasksAllowed.set(true);
  }
  
  void start() { this.migrationThread.start(); }
  
  void stop() { this.migrationThread.stopNow(); }
  
  void scheduleMigration(MigrationInfo migrationInfo) { this.migrationQueue.add(new MigrateTask(this, migrationInfo)); }
  
  static void applyMigration(InternalPartitionImpl partition, MigrationInfo migrationInfo) {
    PartitionReplica[] members = (PartitionReplica[])Arrays.copyOf(partition.getReplicas(), 7);
    if (migrationInfo.getSourceCurrentReplicaIndex() > -1)
      members[migrationInfo.getSourceCurrentReplicaIndex()] = null; 
    if (migrationInfo.getDestinationCurrentReplicaIndex() > -1)
      members[migrationInfo.getDestinationCurrentReplicaIndex()] = null; 
    members[migrationInfo.getDestinationNewReplicaIndex()] = migrationInfo.getDestination();
    if (migrationInfo.getSourceNewReplicaIndex() > -1)
      members[migrationInfo.getSourceNewReplicaIndex()] = migrationInfo.getSource(); 
    partition.setReplicas(members);
  }
  
  Set<Member> getShutdownRequestedMembers() { return this.shutdownRequestedMembers; }
  
  private void sendShutdownOperation(Address address) {
    if (this.node.getThisAddress().equals(address)) {
      assert !this.node.isRunning() : "Node state: " + this.node.getState();
      this.partitionService.onShutdownResponse();
    } else {
      this.nodeEngine.getOperationService().send(new ShutdownResponseOperation(), address);
    } 
  }
  
  boolean shouldTriggerRepartitioningWhenClusterStateAllowsMigration() { return this.triggerRepartitioningWhenClusterStateAllowsMigration; }
  
  private void publishCompletedMigrations() {
    assert this.partitionService.isLocalMemberMaster();
    assert this.partitionStateManager.isInitialized();
    List<MigrationInfo> migrations = getCompletedMigrationsCopy();
    if (this.logger.isFineEnabled())
      this.logger.fine("Publishing completed migrations [" + migrations.size() + "]: " + migrations); 
    InternalOperationService internalOperationService = this.nodeEngine.getOperationService();
    ClusterServiceImpl clusterService = this.node.clusterService;
    Collection<Member> members = clusterService.getMembers();
    AtomicInteger latch = new AtomicInteger(members.size() - 1);
    for (Member member : members) {
      if (member.localMember())
        continue; 
      PublishCompletedMigrationsOperation publishCompletedMigrationsOperation = new PublishCompletedMigrationsOperation(migrations);
      InternalCompletableFuture<Boolean> f = internalOperationService.invokeOnTarget("hz:core:partitionService", publishCompletedMigrationsOperation, member.getAddress());
      f.andThen(new Object(this, member, latch, migrations));
    } 
  }
  
  public MigrationStats getStats() { return this.stats; }
  
  void onClusterVersionChange(Version newVersion) {
    if (newVersion.isEqualTo(Versions.V3_12)) {
      this.partitionServiceLock.lock();
      try {
        assert this.activeMigrationInfo == null : "Active migration: " + this.activeMigrationInfo;
        this.completedMigrations.clear();
      } finally {
        this.partitionServiceLock.unlock();
      } 
    } 
  }
}
