package com.hazelcast.internal.partition.impl;

import com.hazelcast.cluster.ClusterState;
import com.hazelcast.cluster.memberselector.MemberSelectors;
import com.hazelcast.core.HazelcastInstanceNotActiveException;
import com.hazelcast.core.Member;
import com.hazelcast.core.MigrationListener;
import com.hazelcast.instance.MemberImpl;
import com.hazelcast.instance.Node;
import com.hazelcast.internal.cluster.ClusterStateListener;
import com.hazelcast.internal.cluster.ClusterVersionListener;
import com.hazelcast.internal.cluster.Versions;
import com.hazelcast.internal.cluster.impl.ClusterServiceImpl;
import com.hazelcast.internal.cluster.impl.operations.TriggerMemberListPublishOp;
import com.hazelcast.internal.metrics.MetricsRegistry;
import com.hazelcast.internal.metrics.Probe;
import com.hazelcast.internal.partition.InternalPartition;
import com.hazelcast.internal.partition.InternalPartitionService;
import com.hazelcast.internal.partition.MigrationInfo;
import com.hazelcast.internal.partition.PartitionListener;
import com.hazelcast.internal.partition.PartitionReplica;
import com.hazelcast.internal.partition.PartitionReplicaVersionManager;
import com.hazelcast.internal.partition.PartitionRuntimeState;
import com.hazelcast.internal.partition.PartitionServiceProxy;
import com.hazelcast.internal.partition.PartitionTableView;
import com.hazelcast.internal.partition.operation.AssignPartitions;
import com.hazelcast.internal.partition.operation.PartitionStateOperation;
import com.hazelcast.internal.partition.operation.PartitionStateVersionCheckOperation;
import com.hazelcast.internal.partition.operation.ShutdownRequestOperation;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.partition.NoDataMemberInClusterException;
import com.hazelcast.partition.PartitionEvent;
import com.hazelcast.partition.PartitionEventListener;
import com.hazelcast.partition.PartitionLostListener;
import com.hazelcast.spi.EventPublishingService;
import com.hazelcast.spi.ExecutionService;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.PartitionAwareService;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.impl.operationservice.InternalOperationService;
import com.hazelcast.spi.partition.IPartition;
import com.hazelcast.spi.partition.IPartitionLostEvent;
import com.hazelcast.spi.properties.GroupProperty;
import com.hazelcast.spi.properties.HazelcastProperties;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.FutureUtil;
import com.hazelcast.util.HashUtil;
import com.hazelcast.util.MapUtil;
import com.hazelcast.util.scheduler.CoalescingDelayedTrigger;
import com.hazelcast.util.scheduler.ScheduledEntry;
import com.hazelcast.version.Version;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.logging.Level;

public class InternalPartitionServiceImpl extends Object implements InternalPartitionService, EventPublishingService<PartitionEvent, PartitionEventListener<PartitionEvent>>, PartitionAwareService, ClusterStateListener, ClusterVersionListener {
  private static final int PARTITION_OWNERSHIP_WAIT_MILLIS = 10;
  
  private static final String EXCEPTION_MSG_PARTITION_STATE_SYNC_TIMEOUT = "Partition state sync invocation timed out";
  
  private static final int PTABLE_SYNC_TIMEOUT_SECONDS = 10;
  
  private static final int SAFE_SHUTDOWN_MAX_AWAIT_STEP_MILLIS = 1000;
  
  private static final long FETCH_PARTITION_STATE_SECONDS = 5L;
  
  private static final long TRIGGER_MASTER_DELAY_MILLIS = 1000L;
  
  private final Node node;
  
  private final NodeEngineImpl nodeEngine;
  
  private final ILogger logger;
  
  private final int partitionCount;
  
  private final long partitionMigrationTimeout;
  
  private final PartitionServiceProxy proxy;
  
  private final Lock lock = new ReentrantLock();
  
  private final InternalPartitionListener partitionListener;
  
  private final PartitionStateManager partitionStateManager;
  
  private final MigrationManager migrationManager;
  
  private final PartitionReplicaManager replicaManager;
  
  private final PartitionReplicaStateChecker partitionReplicaStateChecker;
  
  private final PartitionEventManager partitionEventManager;
  
  private final FutureUtil.ExceptionHandler partitionStateSyncTimeoutHandler;
  
  private final AtomicBoolean masterTriggered = new AtomicBoolean(false);
  
  private final CoalescingDelayedTrigger masterTrigger;
  
  private final AtomicReference<CountDownLatch> shutdownLatchRef = new AtomicReference();
  
  public InternalPartitionServiceImpl(Node node) {
    HazelcastProperties properties = node.getProperties();
    this.partitionCount = properties.getInteger(GroupProperty.PARTITION_COUNT);
    this.node = node;
    this.nodeEngine = node.nodeEngine;
    this.logger = node.getLogger(InternalPartitionService.class);
    this.partitionListener = new InternalPartitionListener(node, this);
    this.partitionStateManager = new PartitionStateManager(node, this, this.partitionListener);
    this.migrationManager = new MigrationManager(node, this, this.lock);
    this.replicaManager = new PartitionReplicaManager(node, this);
    this.partitionReplicaStateChecker = new PartitionReplicaStateChecker(node, this);
    this.partitionEventManager = new PartitionEventManager(node);
    this.masterTrigger = new CoalescingDelayedTrigger(this.nodeEngine.getExecutionService(), 1000L, 2000L, new Object(this));
    this
      .partitionStateSyncTimeoutHandler = FutureUtil.logAllExceptions(this.logger, "Partition state sync invocation timed out", Level.FINEST);
    this.partitionMigrationTimeout = properties.getMillis(GroupProperty.PARTITION_MIGRATION_TIMEOUT);
    this.proxy = new PartitionServiceProxy(this.nodeEngine, this);
    MetricsRegistry metricsRegistry = this.nodeEngine.getMetricsRegistry();
    metricsRegistry.scanAndRegister(this, "partitions");
    metricsRegistry.scanAndRegister(this.partitionStateManager, "partitions");
    metricsRegistry.scanAndRegister(this.migrationManager, "partitions");
    metricsRegistry.scanAndRegister(this.replicaManager, "partitions");
  }
  
  public void init(NodeEngine nodeEngine, Properties properties) {
    int partitionTableSendInterval = this.node.getProperties().getSeconds(GroupProperty.PARTITION_TABLE_SEND_INTERVAL);
    if (partitionTableSendInterval <= 0)
      partitionTableSendInterval = 1; 
    ExecutionService executionService = nodeEngine.getExecutionService();
    executionService.scheduleWithRepetition(new PublishPartitionRuntimeStateTask(this.node, this), partitionTableSendInterval, partitionTableSendInterval, TimeUnit.SECONDS);
    this.migrationManager.start();
    this.replicaManager.scheduleReplicaVersionSync(executionService);
  }
  
  public Address getPartitionOwner(int partitionId) {
    if (!this.partitionStateManager.isInitialized())
      firstArrangement(); 
    InternalPartitionImpl internalPartitionImpl = this.partitionStateManager.getPartitionImpl(partitionId);
    if (internalPartitionImpl.getOwnerReplicaOrNull() == null && !this.node.isMaster() && 
      !isClusterFormedByOnlyLiteMembers())
      triggerMasterToAssignPartitions(); 
    return internalPartitionImpl.getOwnerOrNull();
  }
  
  public Address getPartitionOwnerOrWait(int partitionId) {
    Address owner;
    while ((owner = getPartitionOwner(partitionId)) == null) {
      if (!this.nodeEngine.isRunning())
        throw new HazelcastInstanceNotActiveException(); 
      ClusterState clusterState = this.node.getClusterService().getClusterState();
      if (!clusterState.isMigrationAllowed())
        throw new IllegalStateException("Partitions can't be assigned since cluster-state: " + clusterState); 
      if (isClusterFormedByOnlyLiteMembers())
        throw new NoDataMemberInClusterException("Partitions can't be assigned since all nodes in the cluster are lite members"); 
      try {
        Thread.sleep(10L);
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw ExceptionUtil.rethrow(e);
      } 
    } 
    return owner;
  }
  
  public PartitionRuntimeState firstArrangement() {
    if (!isLocalMemberMaster()) {
      triggerMasterToAssignPartitions();
      return null;
    } 
    this.lock.lock();
    try {
      if (!this.partitionStateManager.isInitialized()) {
        Set<Member> excludedMembers = this.migrationManager.getShutdownRequestedMembers();
        if (this.partitionStateManager.initializePartitionAssignments(excludedMembers))
          publishPartitionRuntimeState(); 
      } 
      return createPartitionStateInternal();
    } finally {
      this.lock.unlock();
    } 
  }
  
  private void triggerMasterToAssignPartitions() {
    if (!shouldTriggerMasterToAssignPartitions())
      return; 
    ClusterServiceImpl clusterService = this.node.getClusterService();
    ClusterState clusterState = clusterService.getClusterState();
    if (!clusterState.isMigrationAllowed()) {
      this.logger.warning("Partitions can't be assigned since cluster-state=" + clusterState);
      return;
    } 
    Address masterAddress = this.latestMaster;
    if (masterAddress == null || masterAddress.equals(this.node.getThisAddress()))
      return; 
    if (this.masterTriggered.compareAndSet(false, true)) {
      InternalOperationService operationService = this.nodeEngine.getOperationService();
      InternalCompletableFuture internalCompletableFuture = operationService.invokeOnTarget("hz:core:partitionService", new AssignPartitions(), masterAddress);
      internalCompletableFuture.andThen(new Object(this, masterAddress));
      this.masterTrigger.executeWithDelay();
    } 
  }
  
  private boolean shouldTriggerMasterToAssignPartitions() {
    ClusterServiceImpl clusterService = this.node.getClusterService();
    return (!this.partitionStateManager.isInitialized() && clusterService.isJoined() && this.node.getNodeExtension().isStartCompleted());
  }
  
  private void resetMasterTriggeredFlag() { this.masterTriggered.set(false); }
  
  private boolean isClusterFormedByOnlyLiteMembers() {
    ClusterServiceImpl clusterService = this.node.getClusterService();
    return clusterService.getMembers(MemberSelectors.DATA_MEMBER_SELECTOR).isEmpty();
  }
  
  public void setInitialState(PartitionTableView partitionTable) {
    this.lock.lock();
    try {
      this.partitionStateManager.setInitialState(partitionTable);
    } finally {
      this.lock.unlock();
    } 
  }
  
  public int getMemberGroupsSize() { return this.partitionStateManager.getMemberGroupsSize(); }
  
  @Probe(name = "maxBackupCount")
  public int getMaxAllowedBackupCount() { return Math.max(Math.min(getMemberGroupsSize() - 1, 6), 0); }
  
  public void updateMemberGroupSize() { this.partitionStateManager.updateMemberGroupsSize(); }
  
  public void memberAdded(Member member) {
    this.logger.fine("Adding " + member);
    this.lock.lock();
    try {
      this.latestMaster = this.node.getClusterService().getMasterAddress();
      if (!member.localMember())
        this.partitionStateManager.updateMemberGroupsSize(); 
      if (isLocalMemberMaster() && 
        this.partitionStateManager.isInitialized())
        this.migrationManager.triggerControlTask(); 
    } finally {
      this.lock.unlock();
    } 
  }
  
  public void memberRemoved(Member member) {
    this.logger.fine("Removing " + member);
    this.lock.lock();
    try {
      this.migrationManager.onMemberRemove(member);
      this.replicaManager.cancelReplicaSyncRequestsTo(member);
      Address formerMaster = this.latestMaster;
      this.latestMaster = this.node.getClusterService().getMasterAddress();
      ClusterState clusterState = this.node.getClusterService().getClusterState();
      if (clusterState.isMigrationAllowed() || clusterState.isPartitionPromotionAllowed()) {
        this.partitionStateManager.updateMemberGroupsSize();
        boolean isMaster = this.node.isMaster();
        boolean isThisNodeNewMaster = (isMaster && !this.node.getThisAddress().equals(formerMaster));
        if (isThisNodeNewMaster) {
          assert !this.shouldFetchPartitionTables;
          this.shouldFetchPartitionTables = true;
        } 
        if (isMaster)
          this.migrationManager.triggerControlTask(); 
      } 
    } finally {
      this.lock.unlock();
    } 
  }
  
  public void onClusterStateChange(ClusterState newState) {
    if (!newState.isMigrationAllowed())
      return; 
    if (!this.partitionStateManager.isInitialized())
      return; 
    if (!isLocalMemberMaster())
      return; 
    this.lock.lock();
    try {
      if (this.partitionStateManager.isInitialized() && this.migrationManager
        .shouldTriggerRepartitioningWhenClusterStateAllowsMigration())
        this.migrationManager.triggerControlTask(); 
    } finally {
      this.lock.unlock();
    } 
  }
  
  public void onClusterVersionChange(Version newVersion) {
    if (newVersion.isEqualTo(Versions.V3_12)) {
      this.lock.lock();
      try {
        if (!this.partitionStateManager.isInitialized())
          return; 
        for (int pid = 0; pid < getPartitionCount(); pid++) {
          InternalPartitionImpl partition = this.partitionStateManager.getPartitionImpl(pid);
          PartitionReplica[] replicaMembers = partition.getReplicas();
          for (PartitionReplica member : replicaMembers) {
            if (member != null)
              if ("<unknown-uuid>".equals(member.uuid()))
                throw new IllegalStateException("Unknown uuid: " + member);  
          } 
        } 
        this.migrationManager.onClusterVersionChange(newVersion);
      } finally {
        this.lock.unlock();
      } 
    } 
  }
  
  public PartitionRuntimeState createPartitionState() {
    if (!isFetchMostRecentPartitionTableTaskRequired())
      return createPartitionStateInternal(); 
    return null;
  }
  
  public PartitionRuntimeState createPartitionStateInternal() {
    this.lock.lock();
    try {
      if (!this.partitionStateManager.isInitialized())
        return null; 
      List<MigrationInfo> completedMigrations = this.migrationManager.getCompletedMigrationsCopy();
      InternalPartition[] partitions = this.partitionStateManager.getPartitions();
      PartitionRuntimeState state = new PartitionRuntimeState(partitions, completedMigrations, getPartitionStateVersion());
      state.setActiveMigration(this.migrationManager.getActiveMigration());
      return state;
    } finally {
      this.lock.unlock();
    } 
  }
  
  PartitionRuntimeState createMigrationCommitPartitionState(MigrationInfo migrationInfo) {
    this.lock.lock();
    try {
      if (!this.partitionStateManager.isInitialized())
        return null; 
      List<MigrationInfo> completedMigrations = this.migrationManager.getCompletedMigrationsCopy();
      InternalPartition[] partitions = this.partitionStateManager.getPartitionsCopy();
      int partitionId = migrationInfo.getPartitionId();
      InternalPartitionImpl partition = (InternalPartitionImpl)partitions[partitionId];
      MigrationManager.applyMigration(partition, migrationInfo);
      migrationInfo.setStatus(MigrationInfo.MigrationStatus.SUCCESS);
      completedMigrations.add(migrationInfo);
      int committedVersion = getPartitionStateVersion() + 1;
      return new PartitionRuntimeState(partitions, completedMigrations, committedVersion);
    } finally {
      this.lock.unlock();
    } 
  }
  
  PartitionRuntimeState createPromotionCommitPartitionState(Collection<MigrationInfo> migrationInfos) {
    this.lock.lock();
    try {
      if (!this.partitionStateManager.isInitialized())
        return null; 
      List<MigrationInfo> completedMigrations = this.migrationManager.getCompletedMigrationsCopy();
      InternalPartition[] partitions = this.partitionStateManager.getPartitionsCopy();
      for (MigrationInfo migrationInfo : migrationInfos) {
        int partitionId = migrationInfo.getPartitionId();
        InternalPartitionImpl partition = (InternalPartitionImpl)partitions[partitionId];
        MigrationManager.applyMigration(partition, migrationInfo);
        migrationInfo.setStatus(MigrationInfo.MigrationStatus.SUCCESS);
      } 
      int committedVersion = getPartitionStateVersion() + migrationInfos.size() * 2;
      return new PartitionRuntimeState(partitions, completedMigrations, committedVersion);
    } finally {
      this.lock.unlock();
    } 
  }
  
  void publishPartitionRuntimeState() {
    if (!this.partitionStateManager.isInitialized())
      return; 
    if (!isLocalMemberMaster())
      return; 
    if (!areMigrationTasksAllowed())
      return; 
    PartitionRuntimeState partitionState = createPartitionStateInternal();
    if (partitionState == null)
      return; 
    if (this.logger.isFineEnabled())
      this.logger.fine("Publishing partition state, version: " + partitionState.getVersion()); 
    PartitionStateOperation op = new PartitionStateOperation(partitionState, false);
    InternalOperationService internalOperationService = this.nodeEngine.getOperationService();
    Collection<Member> members = this.node.clusterService.getMembers();
    for (Member member : members) {
      if (!member.localMember())
        try {
          internalOperationService.send(op, member.getAddress());
        } catch (Exception e) {
          this.logger.finest(e);
        }  
    } 
  }
  
  void sendPartitionRuntimeState(Address target) {
    if (!isLocalMemberMaster())
      return; 
    assert this.partitionStateManager.isInitialized();
    assert areMigrationTasksAllowed();
    PartitionRuntimeState partitionState = createPartitionStateInternal();
    assert partitionState != null;
    if (this.logger.isFineEnabled())
      this.logger.fine("Sending partition state, version: " + partitionState.getVersion() + ", to " + target); 
    InternalOperationService internalOperationService = this.nodeEngine.getOperationService();
    PartitionStateOperation op = new PartitionStateOperation(partitionState, true);
    internalOperationService.invokeOnTarget("hz:core:partitionService", op, target);
  }
  
  void checkClusterPartitionRuntimeStates() {
    if (!this.partitionStateManager.isInitialized())
      return; 
    if (!isLocalMemberMaster())
      return; 
    if (!areMigrationTasksAllowed())
      return; 
    int partitionStateVersion = getPartitionStateVersion();
    if (this.logger.isFineEnabled())
      this.logger.fine("Checking partition state, version: " + partitionStateVersion); 
    InternalOperationService internalOperationService = this.nodeEngine.getOperationService();
    Collection<Member> members = this.node.clusterService.getMembers();
    for (Member member : members) {
      if (!member.localMember()) {
        PartitionStateVersionCheckOperation partitionStateVersionCheckOperation = new PartitionStateVersionCheckOperation(partitionStateVersion);
        InternalCompletableFuture internalCompletableFuture = internalOperationService.invokeOnTarget("hz:core:partitionService", partitionStateVersionCheckOperation, member.getAddress());
        internalCompletableFuture.andThen(new Object(this, member));
      } 
    } 
  }
  
  boolean syncPartitionRuntimeState() {
    assert !((ReentrantLock)this.lock).isHeldByCurrentThread();
    assert this.partitionStateManager.isInitialized();
    assert this.node.isMaster();
    PartitionRuntimeState partitionState = createPartitionStateInternal();
    assert partitionState != null;
    if (this.logger.isFineEnabled())
      this.logger.fine("Sync'ing partition state, version: " + partitionState.getVersion()); 
    InternalOperationService internalOperationService = this.nodeEngine.getOperationService();
    Collection<Member> members = this.node.clusterService.getMembers();
    Collection<Future<Boolean>> futures = new ArrayList<Future<Boolean>>(members.size());
    for (Member member : members) {
      if (!member.localMember()) {
        PartitionStateOperation op = new PartitionStateOperation(partitionState, true);
        InternalCompletableFuture<Boolean> future = internalOperationService.invokeOnTarget("hz:core:partitionService", op, member.getAddress());
        futures.add(future);
      } 
    } 
    Collection<Boolean> results = FutureUtil.returnWithDeadline(futures, 10L, TimeUnit.SECONDS, this.partitionStateSyncTimeoutHandler);
    if (futures.size() != results.size())
      return false; 
    for (Boolean result : results) {
      if (!result.booleanValue())
        return false; 
    } 
    return true;
  }
  
  public boolean processPartitionRuntimeState(PartitionRuntimeState partitionState) {
    Address sender = partitionState.getMaster();
    if (!this.node.getNodeExtension().isStartCompleted()) {
      this.logger.warning("Ignoring received partition table, startup is not completed yet. Sender: " + sender);
      return false;
    } 
    if (!validateSenderIsMaster(sender, "partition table update"))
      return false; 
    return applyNewPartitionTable(partitionState.getPartitionTable(), partitionState.getVersion(), partitionState
        .getCompletedMigrations(), sender);
  }
  
  private boolean validateSenderIsMaster(Address sender, String messageType) {
    Address thisAddress = this.node.getThisAddress();
    if (thisAddress.equals(this.latestMaster) && !thisAddress.equals(sender)) {
      this.logger.warning("This is the master node and received " + messageType + " from " + sender + ". Ignoring incoming state! ");
      return false;
    } 
    if (!isMemberMaster(sender)) {
      if (this.node.clusterService.getMember(sender) == null) {
        this.logger.severe("Received " + messageType + " from an unknown member! => Sender: " + sender + "! ");
      } else {
        this.logger.warning("Received " + messageType + ", but its sender doesn't seem to be master! => Sender: " + sender + "! (Ignore if master node has changed recently.)");
      } 
      return false;
    } 
    return true;
  }
  
  private boolean applyNewPartitionTable(PartitionReplica[][] partitionTable, int newVersion, Collection<MigrationInfo> completedMigrations, Address sender) {
    try {
      if (!this.lock.tryLock(10L, TimeUnit.SECONDS))
        return false; 
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      return false;
    } 
    try {
      int currentVersion = this.partitionStateManager.getVersion();
      if (newVersion < currentVersion) {
        if (this.logger.isFineEnabled())
          this.logger.fine("Already applied partition state change. Local version: " + currentVersion + ", Master version: " + newVersion + " Master: " + sender); 
        return false;
      } 
      if (newVersion == currentVersion) {
        if (this.logger.isFineEnabled())
          this.logger.fine("Already applied partition state change. Version: " + currentVersion + ", Master: " + sender); 
        return true;
      } 
      updatePartitionTableReplicasForCompatibility(partitionTable);
      requestMemberListUpdateIfUnknownMembersFound(sender, partitionTable);
      updatePartitionsAndFinalizeMigrations(partitionTable, newVersion, completedMigrations);
      return true;
    } finally {
      this.lock.unlock();
    } 
  }
  
  private void updatePartitionTableReplicasForCompatibility(PartitionReplica[][] partitionTable) {
    ClusterServiceImpl clusterService = this.node.getClusterService();
    Version version = clusterService.getClusterVersion();
    boolean compatibilityMode = version.isLessThan(Versions.V3_12);
    for (int partitionId = 0; partitionId < this.partitionCount; partitionId++) {
      PartitionReplica[] replicas = partitionTable[partitionId];
      if (compatibilityMode) {
        for (int ix = 0; ix < replicas.length; ix++) {
          if (replicas[ix] != null)
            if ("<unknown-uuid>".equals(replicas[ix].uuid())) {
              Address address = replicas[ix].address();
              MemberImpl memberImpl = clusterService.getMember(address);
              if (memberImpl != null)
                replicas[ix] = PartitionReplica.from(memberImpl); 
            }  
        } 
      } else {
        for (PartitionReplica replica : replicas)
          assert replica == null || !"<unknown-uuid>".equals(replica.uuid()) : "Invalid replica: " + replica; 
      } 
    } 
  }
  
  private void requestMemberListUpdateIfUnknownMembersFound(Address sender, PartitionReplica[][] partitionTable) {
    ClusterServiceImpl clusterService = this.node.clusterService;
    ClusterState clusterState = clusterService.getClusterState();
    Set<PartitionReplica> unknownReplicas = new HashSet<PartitionReplica>();
    for (PartitionReplica[] replicas : partitionTable) {
      for (int index = 0; index < 7; index++) {
        PartitionReplica replica = replicas[index];
        if (replica != null)
          if (this.node.clusterService.getMember(replica.address(), replica.uuid()) == null && (clusterState
            .isJoinAllowed() || 
            !clusterService.isMissingMember(replica.address(), replica.uuid())))
            unknownReplicas.add(replica);  
      } 
    } 
    if (!unknownReplicas.isEmpty()) {
      if (this.logger.isWarningEnabled()) {
        StringBuilder s = (new StringBuilder("Following unknown addresses are found in partition table")).append(" sent from master[").append(sender).append("].").append(" (Probably they have recently joined or left the cluster.)").append(" {");
        for (PartitionReplica replica : unknownReplicas)
          s.append("\n\t").append(replica); 
        s.append("\n}");
        this.logger.warning(s.toString());
      } 
      Address masterAddress = this.node.getClusterService().getMasterAddress();
      if (masterAddress != null && !masterAddress.equals(this.node.getThisAddress()))
        this.nodeEngine.getOperationService().send(new TriggerMemberListPublishOp(), masterAddress); 
    } 
  }
  
  private void updatePartitionsAndFinalizeMigrations(PartitionReplica[][] partitionTable, int version, Collection<MigrationInfo> completedMigrations) {
    for (int partitionId = 0; partitionId < this.partitionCount; partitionId++) {
      PartitionReplica[] replicas = partitionTable[partitionId];
      this.partitionStateManager.updateReplicas(partitionId, replicas);
    } 
    this.partitionStateManager.setVersion(version);
    for (MigrationInfo migration : completedMigrations) {
      boolean added = this.migrationManager.addCompletedMigration(migration);
      if (added)
        this.migrationManager.scheduleActiveMigrationFinalization(migration); 
    } 
    if (this.logger.isFineEnabled())
      this.logger.fine("Applied partition state update with version: " + version); 
    this.migrationManager.retainCompletedMigrations(completedMigrations);
    if (!this.partitionStateManager.setInitialized())
      this.node.getNodeExtension().onPartitionStateChange(); 
  }
  
  public boolean applyCompletedMigrations(Collection<MigrationInfo> migrations, Address sender) {
    if (!validateSenderIsMaster(sender, "completed migrations"))
      return false; 
    this.lock.lock();
    try {
      if (!this.partitionStateManager.isInitialized()) {
        if (this.logger.isFineEnabled())
          this.logger.fine("Cannot apply completed migrations until partition table is initialized. Completed migrations: " + migrations); 
        return false;
      } 
      boolean appliedAllMigrations = true;
      for (MigrationInfo migration : migrations) {
        int currentVersion = this.partitionStateManager.getVersion();
        if (migration.getFinalPartitionVersion() <= currentVersion) {
          if (this.logger.isFinestEnabled())
            this.logger.finest("Already applied migration commit. Local version: " + currentVersion + ", Commit version: " + migration
                .getFinalPartitionVersion() + " Master: " + sender); 
          continue;
        } 
        if (migration.getInitialPartitionVersion() != currentVersion) {
          this.logger.fine("Cannot apply migration commit! Expected version: " + migration.getInitialPartitionVersion() + ", current version: " + currentVersion + ", final version: " + migration
              .getFinalPartitionVersion() + ", Master: " + sender);
          appliedAllMigrations = false;
          break;
        } 
        boolean added = this.migrationManager.addCompletedMigration(migration);
        assert added : "Migration: " + migration;
        this.partitionStateManager.incrementVersion(migration.getPartitionVersionIncrement());
        if (migration.getStatus() == MigrationInfo.MigrationStatus.SUCCESS) {
          if (this.logger.isFineEnabled())
            this.logger.fine("Applying completed migration " + migration); 
          InternalPartitionImpl partition = this.partitionStateManager.getPartitionImpl(migration.getPartitionId());
          MigrationManager.applyMigration(partition, migration);
        } 
        this.migrationManager.scheduleActiveMigrationFinalization(migration);
      } 
      if (this.logger.isFineEnabled())
        this.logger.fine("Applied completed migrations with partition state version: " + this.partitionStateManager.getVersion()); 
      this.migrationManager.retainCompletedMigrations(migrations);
      this.node.getNodeExtension().onPartitionStateChange();
      return appliedAllMigrations;
    } finally {
      this.lock.unlock();
    } 
  }
  
  public IPartition[] getPartitions() {
    IPartition[] result = new IPartition[this.partitionCount];
    System.arraycopy(this.partitionStateManager.getPartitions(), 0, result, 0, this.partitionCount);
    return result;
  }
  
  public InternalPartition[] getInternalPartitions() { return this.partitionStateManager.getPartitions(); }
  
  public InternalPartition getPartition(int partitionId) { return getPartition(partitionId, true); }
  
  public InternalPartition getPartition(int partitionId, boolean triggerOwnerAssignment) {
    InternalPartitionImpl p = this.partitionStateManager.getPartitionImpl(partitionId);
    if (triggerOwnerAssignment && p.getOwnerReplicaOrNull() == null)
      getPartitionOwner(partitionId); 
    return p;
  }
  
  public boolean onShutdown(long timeout, TimeUnit unit) {
    if (!this.node.getClusterService().isJoined())
      return true; 
    if (this.node.isLiteMember())
      return true; 
    CountDownLatch latch = getShutdownLatch();
    InternalOperationService operationService = this.nodeEngine.getOperationService();
    long timeoutMillis = unit.toMillis(timeout);
    long awaitStep = Math.min(1000L, timeoutMillis);
    try {
      do {
        Address masterAddress = this.nodeEngine.getMasterAddress();
        if (masterAddress == null) {
          this.logger.warning("Safe shutdown failed, master member is not known!");
          return false;
        } 
        if (this.node.getThisAddress().equals(masterAddress)) {
          onShutdownRequest(this.node.getLocalMember());
        } else {
          operationService.send(new ShutdownRequestOperation(), masterAddress);
        } 
        if (latch.await(awaitStep, TimeUnit.MILLISECONDS))
          return true; 
        timeoutMillis -= awaitStep;
      } while (timeoutMillis > 0L);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      this.logger.info("Safe shutdown is interrupted!");
    } 
    return false;
  }
  
  private CountDownLatch getShutdownLatch() {
    CountDownLatch latch = (CountDownLatch)this.shutdownLatchRef.get();
    if (latch == null) {
      latch = new CountDownLatch(1);
      if (!this.shutdownLatchRef.compareAndSet(null, latch))
        latch = (CountDownLatch)this.shutdownLatchRef.get(); 
    } 
    return latch;
  }
  
  public void onShutdownRequest(Member member) {
    if (this.lock.tryLock())
      try {
        this.migrationManager.onShutdownRequest(member);
      } finally {
        this.lock.unlock();
      }  
  }
  
  public void onShutdownResponse() {
    CountDownLatch latch = (CountDownLatch)this.shutdownLatchRef.get();
    assert latch != null;
    latch.countDown();
  }
  
  public boolean isMemberStateSafe() { return (this.partitionReplicaStateChecker.getPartitionServiceState() == PartitionServiceState.SAFE); }
  
  public boolean hasOnGoingMigration() {
    return (hasOnGoingMigrationLocal() || (
      !isLocalMemberMaster() && this.partitionReplicaStateChecker.hasOnGoingMigrationMaster(Level.FINEST)));
  }
  
  public boolean hasOnGoingMigrationLocal() { return this.migrationManager.hasOnGoingMigration(); }
  
  public final int getPartitionId(Data key) { return HashUtil.hashToIndex(key.getPartitionHash(), this.partitionCount); }
  
  public final int getPartitionId(Object key) { return getPartitionId(this.nodeEngine.toData(key)); }
  
  public final int getPartitionCount() { return this.partitionCount; }
  
  public long getPartitionMigrationTimeout() { return this.partitionMigrationTimeout; }
  
  public PartitionReplicaVersionManager getPartitionReplicaVersionManager() { return this.replicaManager; }
  
  public Map<Address, List<Integer>> getMemberPartitionsMap() {
    Collection<Member> dataMembers = this.node.getClusterService().getMembers(MemberSelectors.DATA_MEMBER_SELECTOR);
    int dataMembersSize = dataMembers.size();
    int partitionsPerMember = (dataMembersSize > 0) ? (int)Math.ceil((this.partitionCount / dataMembersSize)) : 0;
    Map<Address, List<Integer>> memberPartitions = MapUtil.createHashMap(dataMembersSize);
    for (int partitionId = 0; partitionId < this.partitionCount; partitionId++) {
      Address owner = getPartitionOwnerOrWait(partitionId);
      List<Integer> ownedPartitions = (List)memberPartitions.get(owner);
      if (ownedPartitions == null) {
        ownedPartitions = new ArrayList<Integer>(partitionsPerMember);
        memberPartitions.put(owner, ownedPartitions);
      } 
      ownedPartitions.add(Integer.valueOf(partitionId));
    } 
    return memberPartitions;
  }
  
  public List<Integer> getMemberPartitions(Address target) {
    List<Integer> ownedPartitions = new LinkedList<Integer>();
    for (int i = 0; i < this.partitionCount; i++) {
      Address owner = getPartitionOwner(i);
      if (target.equals(owner))
        ownedPartitions.add(Integer.valueOf(i)); 
    } 
    return ownedPartitions;
  }
  
  public List<Integer> getMemberPartitionsIfAssigned(Address target) {
    if (!this.partitionStateManager.isInitialized())
      return Collections.emptyList(); 
    return getMemberPartitions(target);
  }
  
  public void reset() {
    this.lock.lock();
    try {
      this.shouldFetchPartitionTables = false;
      this.replicaManager.reset();
      this.partitionStateManager.reset();
      this.migrationManager.reset();
    } finally {
      this.lock.unlock();
    } 
  }
  
  public void pauseMigration() { this.migrationManager.pauseMigration(); }
  
  public void resumeMigration() { this.migrationManager.resumeMigration(); }
  
  public boolean areMigrationTasksAllowed() { return this.migrationManager.areMigrationTasksAllowed(); }
  
  public void shutdown(boolean terminate) {
    this.logger.finest("Shutting down the partition service");
    this.migrationManager.stop();
    reset();
  }
  
  @Probe
  public long getMigrationQueueSize() { return this.migrationManager.getMigrationQueueSize(); }
  
  public PartitionServiceProxy getPartitionServiceProxy() { return this.proxy; }
  
  public String addMigrationListener(MigrationListener listener) { return this.partitionEventManager.addMigrationListener(listener); }
  
  public boolean removeMigrationListener(String registrationId) { return this.partitionEventManager.removeMigrationListener(registrationId); }
  
  public String addPartitionLostListener(PartitionLostListener listener) { return this.partitionEventManager.addPartitionLostListener(listener); }
  
  public String addLocalPartitionLostListener(PartitionLostListener listener) { return this.partitionEventManager.addLocalPartitionLostListener(listener); }
  
  public boolean removePartitionLostListener(String registrationId) { return this.partitionEventManager.removePartitionLostListener(registrationId); }
  
  public void dispatchEvent(PartitionEvent partitionEvent, PartitionEventListener partitionEventListener) { partitionEventListener.onEvent(partitionEvent); }
  
  public void addPartitionListener(PartitionListener listener) {
    this.lock.lock();
    try {
      this.partitionListener.addChildListener(listener);
    } finally {
      this.lock.unlock();
    } 
  }
  
  public boolean isPartitionOwner(int partitionId) {
    InternalPartitionImpl internalPartitionImpl = this.partitionStateManager.getPartitionImpl(partitionId);
    return internalPartitionImpl.isLocal();
  }
  
  public int getPartitionStateVersion() { return this.partitionStateManager.getVersion(); }
  
  public void onPartitionLost(IPartitionLostEvent event) { this.partitionEventManager.onPartitionLost(event); }
  
  public void setInternalMigrationListener(InternalMigrationListener listener) { this.migrationManager.setInternalMigrationListener(listener); }
  
  public InternalMigrationListener getInternalMigrationListener() { return this.migrationManager.getInternalMigrationListener(); }
  
  public void resetInternalMigrationListener() { this.migrationManager.resetInternalMigrationListener(); }
  
  public List<ReplicaFragmentSyncInfo> getOngoingReplicaSyncRequests() { return this.replicaManager.getOngoingReplicaSyncRequests(); }
  
  public List<ScheduledEntry<ReplicaFragmentSyncInfo, Void>> getScheduledReplicaSyncRequests() { return this.replicaManager.getScheduledReplicaSyncRequests(); }
  
  public PartitionStateManager getPartitionStateManager() { return this.partitionStateManager; }
  
  public MigrationManager getMigrationManager() { return this.migrationManager; }
  
  public PartitionReplicaManager getReplicaManager() { return this.replicaManager; }
  
  public PartitionReplicaStateChecker getPartitionReplicaStateChecker() { return this.partitionReplicaStateChecker; }
  
  public PartitionEventManager getPartitionEventManager() { return this.partitionEventManager; }
  
  boolean isFetchMostRecentPartitionTableTaskRequired() { return this.shouldFetchPartitionTables; }
  
  boolean scheduleFetchMostRecentPartitionTableTaskIfRequired() {
    this.lock.lock();
    try {
      if (this.shouldFetchPartitionTables) {
        this.migrationManager.schedule(new FetchMostRecentPartitionTableTask(this, null));
        return true;
      } 
      return false;
    } finally {
      this.lock.unlock();
    } 
  }
  
  public void replaceMember(Member oldMember, Member newMember) {
    this.lock.lock();
    try {
      this.partitionStateManager.replaceMember(oldMember, newMember);
    } finally {
      this.lock.unlock();
    } 
  }
  
  public PartitionTableView createPartitionTableView() {
    this.lock.lock();
    try {
      return this.partitionStateManager.getPartitionTable();
    } finally {
      this.lock.unlock();
    } 
  }
  
  public boolean isLocalMemberMaster() { return isMemberMaster(this.node.getThisAddress()); }
  
  public boolean isMemberMaster(Address address) {
    if (address == null)
      return false; 
    Address master = this.latestMaster;
    ClusterServiceImpl clusterService = this.node.getClusterService();
    if (master == null && clusterService.getSize() == 1)
      master = clusterService.getMasterAddress(); 
    return (address.equals(master) && address.equals(clusterService.getMasterAddress()));
  }
  
  public boolean commitMigrationOnDestination(MigrationInfo migration, Address sender) {
    this.lock.lock();
    try {
      if (!validateSenderIsMaster(sender, "migration commit"))
        return false; 
      int currentVersion = this.partitionStateManager.getVersion();
      int initialVersion = migration.getInitialPartitionVersion();
      int finalVersion = migration.getFinalPartitionVersion();
      if (finalVersion == currentVersion) {
        if (this.logger.isFineEnabled())
          this.logger.fine("Already applied migration commit. Version: " + currentVersion + ", Master: " + sender); 
        return true;
      } 
      if (finalVersion < currentVersion) {
        if (this.logger.isFineEnabled())
          this.logger.fine("Already applied migration commit. Local version: " + currentVersion + ", Master version: " + finalVersion + " Master: " + sender); 
        return false;
      } 
      if (initialVersion != currentVersion)
        throw new IllegalStateException("Invalid migration commit! Expected version: " + initialVersion + ", current version: " + currentVersion + ", Master: " + sender); 
      MigrationInfo activeMigration = this.migrationManager.getActiveMigration();
      assert migration.equals(activeMigration) : "Committed migration: " + migration + ", Active migration: " + activeMigration;
      InternalPartitionImpl partition = this.partitionStateManager.getPartitionImpl(migration.getPartitionId());
      boolean added = this.migrationManager.addCompletedMigration(migration);
      assert added : "Could not add completed migration on destination: " + migration;
      MigrationManager.applyMigration(partition, migration);
      this.partitionStateManager.setVersion(finalVersion);
      activeMigration.setStatus(migration.getStatus());
      this.migrationManager.finalizeMigration(migration);
      if (this.logger.isFineEnabled())
        this.logger.fine("Committed " + migration + " on destination with partition state version: " + finalVersion); 
      return true;
    } finally {
      this.lock.unlock();
    } 
  }
  
  public String toString() {
    return "InternalPartitionService {version: " + 
      getPartitionStateVersion() + ", migrationQ: " + getMigrationQueueSize() + "}";
  }
}
