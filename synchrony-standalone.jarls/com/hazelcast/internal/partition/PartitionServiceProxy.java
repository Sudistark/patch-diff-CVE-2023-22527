package com.hazelcast.internal.partition;

import com.hazelcast.core.Member;
import com.hazelcast.core.MigrationListener;
import com.hazelcast.core.Partition;
import com.hazelcast.core.PartitionService;
import com.hazelcast.instance.MemberImpl;
import com.hazelcast.instance.NodeState;
import com.hazelcast.internal.partition.impl.InternalPartitionServiceImpl;
import com.hazelcast.internal.partition.operation.SafeStateCheckOperation;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.partition.PartitionLostListener;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.properties.GroupProperty;
import com.hazelcast.util.FutureUtil;
import com.hazelcast.util.MapUtil;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class PartitionServiceProxy implements PartitionService {
  private final NodeEngineImpl nodeEngine;
  
  private final InternalPartitionServiceImpl partitionService;
  
  private final Map<Integer, Partition> partitionMap;
  
  private final Set<Partition> partitionSet;
  
  private final Random random;
  
  private final ILogger logger;
  
  private final FutureUtil.ExceptionHandler exceptionHandler;
  
  public PartitionServiceProxy(NodeEngineImpl nodeEngine, InternalPartitionServiceImpl partitionService) {
    this.random = new Random();
    this.exceptionHandler = new Object(this);
    this.nodeEngine = nodeEngine;
    this.partitionService = partitionService;
    int partitionCount = partitionService.getPartitionCount();
    Map<Integer, Partition> map = MapUtil.createHashMap(partitionCount);
    Set<Partition> set = new TreeSet<Partition>();
    for (int i = 0; i < partitionCount; i++) {
      PartitionProxy partitionProxy = new PartitionProxy(this, i);
      set.add(partitionProxy);
      map.put(Integer.valueOf(i), partitionProxy);
    } 
    this.partitionMap = Collections.unmodifiableMap(map);
    this.partitionSet = Collections.unmodifiableSet(set);
    this.logger = nodeEngine.getLogger(PartitionServiceProxy.class);
  }
  
  public String randomPartitionKey() { return Integer.toString(this.random.nextInt(this.partitionService.getPartitionCount())); }
  
  public Set<Partition> getPartitions() { return this.partitionSet; }
  
  public Partition getPartition(Object key) {
    int partitionId = this.partitionService.getPartitionId(key);
    return (Partition)this.partitionMap.get(Integer.valueOf(partitionId));
  }
  
  public String addMigrationListener(MigrationListener migrationListener) { return this.partitionService.addMigrationListener(migrationListener); }
  
  public boolean removeMigrationListener(String registrationId) { return this.partitionService.removeMigrationListener(registrationId); }
  
  public String addPartitionLostListener(PartitionLostListener partitionLostListener) { return this.partitionService.addPartitionLostListener(partitionLostListener); }
  
  public boolean removePartitionLostListener(String registrationId) { return this.partitionService.removePartitionLostListener(registrationId); }
  
  public boolean isClusterSafe() {
    Collection<Member> members = this.nodeEngine.getClusterService().getMembers();
    if (members == null || members.isEmpty())
      return true; 
    Collection<Future<Boolean>> futures = new ArrayList<Future<Boolean>>(members.size());
    for (Member member : members) {
      Address target = member.getAddress();
      SafeStateCheckOperation safeStateCheckOperation = new SafeStateCheckOperation();
      InternalCompletableFuture internalCompletableFuture = this.nodeEngine.getOperationService().invokeOnTarget("hz:core:partitionService", safeStateCheckOperation, target);
      futures.add(internalCompletableFuture);
    } 
    int maxWaitTime = getMaxWaitTime();
    Collection<Boolean> results = FutureUtil.returnWithDeadline(futures, maxWaitTime, TimeUnit.SECONDS, this.exceptionHandler);
    if (results.size() != futures.size())
      return false; 
    for (Boolean result : results) {
      if (!result.booleanValue())
        return false; 
    } 
    return true;
  }
  
  public boolean isMemberSafe(Member member) {
    boolean safe;
    if (member == null)
      throw new NullPointerException("Parameter member should not be null"); 
    MemberImpl memberImpl = this.nodeEngine.getLocalMember();
    if (memberImpl.equals(member))
      return isLocalMemberSafe(); 
    Address target = member.getAddress();
    SafeStateCheckOperation safeStateCheckOperation = new SafeStateCheckOperation();
    InternalCompletableFuture future = this.nodeEngine.getOperationService().invokeOnTarget("hz:core:partitionService", safeStateCheckOperation, target);
    try {
      Object result = future.get(10L, TimeUnit.SECONDS);
      safe = ((Boolean)result).booleanValue();
    } catch (Throwable t) {
      safe = false;
      this.logger.warning("Error while querying member's safe state [" + member + "]", t);
    } 
    return safe;
  }
  
  public boolean isLocalMemberSafe() {
    if (!nodeActive())
      return true; 
    return this.partitionService.isMemberStateSafe();
  }
  
  public boolean forceLocalMemberToBeSafe(long timeout, TimeUnit unit) {
    if (unit == null)
      throw new NullPointerException(); 
    if (timeout < 1L)
      throw new IllegalArgumentException(); 
    if (!nodeActive())
      return true; 
    return this.partitionService.getPartitionReplicaStateChecker().triggerAndWaitForReplicaSync(timeout, unit);
  }
  
  private boolean nodeActive() { return (this.nodeEngine.getNode().getState() != NodeState.SHUT_DOWN); }
  
  private int getMaxWaitTime() { return this.nodeEngine.getProperties().getSeconds(GroupProperty.GRACEFUL_SHUTDOWN_MAX_WAIT); }
}
