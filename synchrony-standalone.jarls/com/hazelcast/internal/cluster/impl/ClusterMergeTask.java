package com.hazelcast.internal.cluster.impl;

import com.hazelcast.core.HazelcastInstanceNotActiveException;
import com.hazelcast.core.LifecycleEvent;
import com.hazelcast.instance.LifecycleServiceImpl;
import com.hazelcast.instance.Node;
import com.hazelcast.nio.Disposable;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.SplitBrainHandlerService;
import com.hazelcast.util.EmptyStatement;
import com.hazelcast.util.ExceptionUtil;
import java.util.Collection;
import java.util.LinkedList;
import java.util.concurrent.Future;

class ClusterMergeTask implements Runnable {
  private static final String MERGE_TASKS_EXECUTOR = "hz:cluster-merge";
  
  private final Node node;
  
  private final LifecycleServiceImpl lifecycleService;
  
  ClusterMergeTask(Node node) {
    this.node = node;
    this.lifecycleService = node.hazelcastInstance.getLifecycleService();
  }
  
  public void run() {
    this.lifecycleService.fireLifecycleEvent(LifecycleEvent.LifecycleState.MERGING);
    joined = false;
    try {
      resetState();
      coreTasks = collectMergeTasks(true);
      nonCoreTasks = collectMergeTasks(false);
      resetServices();
      rejoin();
      joined = isJoined();
      if (joined)
        try {
          executeMergeTasks(coreTasks);
          executeMergeTasks(nonCoreTasks);
        } finally {
          disposeTasks(new Collection[] { coreTasks, nonCoreTasks });
        }  
    } finally {
      this.lifecycleService.fireLifecycleEvent(joined ? LifecycleEvent.LifecycleState.MERGED : LifecycleEvent.LifecycleState.MERGE_FAILED);
    } 
  }
  
  private void disposeTasks(Collection... tasks) {
    for (Collection<Runnable> task : tasks) {
      for (Runnable runnable : task) {
        if (runnable instanceof Disposable)
          ((Disposable)runnable).dispose(); 
      } 
    } 
  }
  
  private boolean isJoined() { return (this.node.isRunning() && this.node.getClusterService().isJoined()); }
  
  private void resetState() {
    this.node.reset();
    this.node.getClusterService().reset();
    this.node.getNodeExtension().getInternalHotRestartService().resetService(true);
    this.node.networkingService.stop();
    this.node.nodeEngine.reset();
  }
  
  private Collection<Runnable> collectMergeTasks(boolean coreServices) {
    Collection<SplitBrainHandlerService> services = this.node.nodeEngine.getServices(SplitBrainHandlerService.class);
    Collection<Runnable> tasks = new LinkedList<Runnable>();
    for (SplitBrainHandlerService service : services) {
      if (coreServices != isCoreService(service))
        continue; 
      Runnable runnable = service.prepareMergeRunnable();
      if (runnable != null)
        tasks.add(runnable); 
    } 
    return tasks;
  }
  
  private boolean isCoreService(SplitBrainHandlerService service) { return service instanceof com.hazelcast.spi.CoreService; }
  
  private void resetServices() {
    Collection<ManagedService> managedServices = this.node.nodeEngine.getServices(ManagedService.class);
    for (ManagedService service : managedServices) {
      if (service instanceof com.hazelcast.internal.cluster.ClusterService)
        continue; 
      service.reset();
    } 
  }
  
  private void rejoin() {
    this.node.networkingService.start();
    this.node.join();
  }
  
  private void executeMergeTasks(Collection<Runnable> tasks) {
    Collection<Future> futures = new LinkedList<Future>();
    for (Runnable task : tasks) {
      Future f = this.node.nodeEngine.getExecutionService().submit("hz:cluster-merge", task);
      futures.add(f);
    } 
    for (Future f : futures) {
      try {
        waitOnFuture(f);
      } catch (HazelcastInstanceNotActiveException e) {
        EmptyStatement.ignore(e);
      } catch (Exception e) {
        this.node.getLogger(getClass()).severe("While merging...", e);
      } 
    } 
  }
  
  private <V> V waitOnFuture(Future<V> future) {
    try {
      return (V)future.get();
    } catch (Throwable t) {
      if (!this.node.isRunning()) {
        future.cancel(true);
        throw new HazelcastInstanceNotActiveException();
      } 
      throw ExceptionUtil.rethrow(t);
    } 
  }
}
