package com.hazelcast.internal.cluster.impl;

import com.hazelcast.config.ConfigAccessor;
import com.hazelcast.config.NetworkConfig;
import com.hazelcast.instance.Node;
import com.hazelcast.nio.Address;
import com.hazelcast.util.Clock;
import com.hazelcast.util.RandomPicker;
import java.util.concurrent.BlockingDeque;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class MulticastJoiner extends AbstractJoiner {
  private static final long JOIN_RETRY_INTERVAL = 1000L;
  
  private static final int PUBLISH_INTERVAL_MIN = 50;
  
  private static final int PUBLISH_INTERVAL_MAX = 200;
  
  private static final int TRY_COUNT_MAX_LAST_DIGITS = 512;
  
  private static final int TRY_COUNT_MODULO = 10;
  
  private final AtomicInteger currentTryCount = new AtomicInteger(0);
  
  private final AtomicInteger maxTryCount;
  
  private final BlockingDeque<SplitBrainJoinMessage> splitBrainJoinMessages = new LinkedBlockingDeque();
  
  public MulticastJoiner(Node node) {
    super(node);
    this.maxTryCount = new AtomicInteger(calculateTryCount());
    node.multicastService.addMulticastListener(new SplitBrainMulticastListener(node, this.splitBrainJoinMessages));
  }
  
  public void doJoin() {
    long joinStartTime = Clock.currentTimeMillis();
    long maxJoinMillis = getMaxJoinMillis();
    Address thisAddress = this.node.getThisAddress();
    while (shouldRetry() && Clock.currentTimeMillis() - joinStartTime < maxJoinMillis) {
      this.clusterService.setMasterAddressToJoin(null);
      Address masterAddress = getTargetAddress();
      if (masterAddress == null)
        masterAddress = findMasterWithMulticast(); 
      this.clusterService.setMasterAddressToJoin(masterAddress);
      if (masterAddress == null || thisAddress.equals(masterAddress)) {
        this.clusterJoinManager.setThisMemberAsMaster();
        return;
      } 
      this.logger.info("Trying to join to discovered node: " + masterAddress);
      joinMaster();
    } 
  }
  
  private void joinMaster() {
    long maxMasterJoinTime = getMaxJoinTimeToMasterNode();
    long start = Clock.currentTimeMillis();
    while (shouldRetry() && Clock.currentTimeMillis() - start < maxMasterJoinTime) {
      Address master = this.clusterService.getMasterAddress();
      if (master != null) {
        if (this.logger.isFineEnabled())
          this.logger.fine("Joining to master " + master); 
        this.clusterJoinManager.sendJoinRequest(master, true);
        try {
          Thread.sleep(1000L);
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
        } 
        if (isBlacklisted(master)) {
          this.clusterService.setMasterAddressToJoin(null);
          return;
        } 
      } 
    } 
  }
  
  public void searchForOtherClusters() {
    this.node.multicastService.send(this.node.createSplitBrainJoinMessage());
    try {
      SplitBrainJoinMessage splitBrainMsg;
      while ((splitBrainMsg = (SplitBrainJoinMessage)this.splitBrainJoinMessages.poll(3L, TimeUnit.SECONDS)) != null) {
        if (this.logger.isFineEnabled())
          this.logger.fine("Received  " + splitBrainMsg); 
        Address targetAddress = splitBrainMsg.getAddress();
        if (this.node.clusterService.getMember(targetAddress) != null) {
          if (this.logger.isFineEnabled())
            this.logger.fine("Ignoring merge join response, since " + targetAddress + " is already a member."); 
          continue;
        } 
        SplitBrainJoinMessage request = this.node.createSplitBrainJoinMessage();
        SplitBrainJoinMessage.SplitBrainMergeCheckResult result = sendSplitBrainJoinMessageAndCheckResponse(targetAddress, request);
        if (result == SplitBrainJoinMessage.SplitBrainMergeCheckResult.LOCAL_NODE_SHOULD_MERGE) {
          this.logger.warning(this.node.getThisAddress() + " is merging [multicast] to " + targetAddress);
          startClusterMerge(targetAddress, this.clusterService.getMemberListVersion());
          return;
        } 
        if (result == SplitBrainJoinMessage.SplitBrainMergeCheckResult.REMOTE_NODE_SHOULD_MERGE)
          this.node.multicastService.send(this.node.createSplitBrainJoinMessage()); 
      } 
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      this.logger.fine(e);
    } catch (Exception e) {
      this.logger.warning(e);
    } 
  }
  
  public void reset() {
    super.reset();
    this.splitBrainJoinMessages.clear();
  }
  
  public String getType() { return "multicast"; }
  
  public int getSplitBrainMessagesCount() { return this.splitBrainJoinMessages.size(); }
  
  void onReceivedJoinRequest(JoinRequest joinRequest) {
    if (joinRequest.getUuid().compareTo(this.clusterService.getThisUuid()) < 0)
      this.maxTryCount.incrementAndGet(); 
  }
  
  private Address findMasterWithMulticast() {
    try {
      if (this.logger.isFineEnabled())
        this.logger.fine("Searching for master node. Max tries: " + this.maxTryCount.get()); 
      JoinRequest joinRequest = this.node.createJoinRequest(false);
      while (this.node.isRunning() && this.currentTryCount.incrementAndGet() <= this.maxTryCount.get()) {
        joinRequest.setTryCount(this.currentTryCount.get());
        this.node.multicastService.send(joinRequest);
        Address masterAddress = this.clusterService.getMasterAddress();
        if (masterAddress == null) {
          Thread.sleep(getPublishInterval());
          continue;
        } 
        return masterAddress;
      } 
    } catch (Exception e) {
      if (this.logger != null)
        this.logger.warning(e); 
    } finally {
      this.currentTryCount.set(0);
    } 
    return null;
  }
  
  private int calculateTryCount() {
    int lastDigits;
    NetworkConfig networkConfig = ConfigAccessor.getActiveMemberNetworkConfig(this.config);
    long timeoutMillis = TimeUnit.SECONDS.toMillis(networkConfig.getJoin().getMulticastConfig().getMulticastTimeoutSeconds());
    int avgPublishInterval = 125;
    tryCount = (int)timeoutMillis / avgPublishInterval;
    String host = this.node.getThisAddress().getHost();
    try {
      lastDigits = Integer.parseInt(host.substring(host.lastIndexOf('.') + 1));
    } catch (NumberFormatException e) {
      lastDigits = RandomPicker.getInt(512);
    } 
    int portDiff = this.node.getThisAddress().getPort() - networkConfig.getPort();
    return (lastDigits + portDiff) % 10;
  }
  
  private int getPublishInterval() { return RandomPicker.getInt(50, 200); }
}
