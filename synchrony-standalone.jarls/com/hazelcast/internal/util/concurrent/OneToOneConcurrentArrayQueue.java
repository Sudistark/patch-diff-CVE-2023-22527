package com.hazelcast.internal.util.concurrent;

import com.hazelcast.util.function.Predicate;
import java.util.Collection;
import java.util.Iterator;
import java.util.concurrent.atomic.AtomicReferenceArray;

public class OneToOneConcurrentArrayQueue<E> extends AbstractConcurrentArrayQueue<E> {
  public OneToOneConcurrentArrayQueue(int requestedCapacity) { super(requestedCapacity); }
  
  public boolean offer(E e) {
    assert e != null : "Attempted to offer null to a concurrent array queue";
    int capacity = this.capacity;
    long currentTail = this.tail;
    long acquiredHead = this.headCache;
    long bufferLimit = acquiredHead + capacity;
    if (currentTail >= bufferLimit) {
      acquiredHead = this.head;
      bufferLimit = acquiredHead + capacity;
      if (currentTail >= bufferLimit)
        return false; 
      this.headCache = acquiredHead;
    } 
    int arrayIndex = seqToArrayIndex(currentTail, (capacity - 1));
    this.buffer.lazySet(arrayIndex, e);
    TAIL.lazySet(this, currentTail + 1L);
    return true;
  }
  
  public E poll() {
    AtomicReferenceArray<E> buffer = this.buffer;
    long currentHead = this.head;
    int arrayIndex = seqToArrayIndex(currentHead, (this.capacity - 1));
    E e = (E)buffer.get(arrayIndex);
    if (e != null) {
      buffer.lazySet(arrayIndex, null);
      HEAD.lazySet(this, currentHead + 1L);
    } 
    return e;
  }
  
  public int drain(Predicate<? super E> itemHandler) {
    AtomicReferenceArray<E> buffer = this.buffer;
    long mask = (this.capacity - 1);
    long acquiredHead = this.head;
    long limit = acquiredHead + mask + 1L;
    long nextSequence = acquiredHead;
    while (nextSequence < limit) {
      int arrayIndex = seqToArrayIndex(nextSequence, mask);
      E item = (E)buffer.get(arrayIndex);
      if (item == null)
        break; 
      buffer.lazySet(arrayIndex, null);
      nextSequence++;
      HEAD.lazySet(this, nextSequence);
      if (!itemHandler.test(item))
        break; 
    } 
    return (int)(nextSequence - acquiredHead);
  }
  
  public int drainTo(Collection<? super E> target, int limit) {
    if (limit <= 0)
      return 0; 
    AtomicReferenceArray<E> buffer = this.buffer;
    long mask = (this.capacity - 1);
    long nextSequence = this.head;
    int count = 0;
    while (count < limit) {
      int arrayIndex = seqToArrayIndex(nextSequence, mask);
      E item = (E)buffer.get(arrayIndex);
      if (item == null)
        break; 
      buffer.lazySet(arrayIndex, null);
      nextSequence++;
      HEAD.lazySet(this, nextSequence);
      count++;
      target.add(item);
    } 
    return count;
  }
}
