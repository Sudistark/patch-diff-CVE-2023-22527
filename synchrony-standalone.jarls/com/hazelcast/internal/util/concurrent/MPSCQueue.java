package com.hazelcast.internal.util.concurrent;

import com.hazelcast.util.Preconditions;
import com.hazelcast.util.QuickMath;
import com.hazelcast.util.concurrent.IdleStrategy;
import java.util.AbstractQueue;
import java.util.Collection;
import java.util.Iterator;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.LockSupport;

public final class MPSCQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {
  static final int INITIAL_ARRAY_SIZE = 512;
  
  static final Node BLOCKED = new Node(null);
  
  final AtomicReference<Node> putStack;
  
  private final AtomicInteger takeStackSize;
  
  private final IdleStrategy idleStrategy;
  
  private Thread consumerThread;
  
  private Object[] takeStack;
  
  private int takeStackIndex;
  
  public MPSCQueue(Thread consumerThread, IdleStrategy idleStrategy) {
    this.putStack = new AtomicReference();
    this.takeStackSize = new AtomicInteger();
    this.takeStack = new Object[512];
    this.takeStackIndex = -1;
    this.consumerThread = (Thread)Preconditions.checkNotNull(consumerThread, "consumerThread can't be null");
    this.idleStrategy = idleStrategy;
  }
  
  public MPSCQueue(IdleStrategy idleStrategy) {
    this.putStack = new AtomicReference();
    this.takeStackSize = new AtomicInteger();
    this.takeStack = new Object[512];
    this.takeStackIndex = -1;
    this.idleStrategy = idleStrategy;
  }
  
  public void setConsumerThread(Thread consumerThread) { this.consumerThread = (Thread)Preconditions.checkNotNull(consumerThread, "consumerThread can't be null"); }
  
  public void clear() { this.putStack.set(BLOCKED); }
  
  public boolean offer(E item) {
    Node oldHead;
    Preconditions.checkNotNull(item, "item can't be null");
    AtomicReference<Node> putStack = this.putStack;
    Node newHead = new Node(null);
    newHead.item = item;
    while (true) {
      oldHead = (Node)putStack.get();
      if (oldHead == null || oldHead == BLOCKED) {
        newHead.next = null;
        newHead.size = 1;
      } else {
        newHead.next = oldHead;
        oldHead.size++;
      } 
      if (!putStack.compareAndSet(oldHead, newHead))
        continue; 
      break;
    } 
    if (oldHead == BLOCKED)
      LockSupport.unpark(this.consumerThread); 
    return true;
  }
  
  public E peek() {
    E item = (E)peekNext();
    if (item != null)
      return item; 
    if (!drainPutStack())
      return null; 
    return (E)peekNext();
  }
  
  public E take() {
    E item = (E)next();
    if (item != null)
      return item; 
    takeAll();
    assert this.takeStackIndex == 0;
    assert this.takeStack[this.takeStackIndex] != null;
    return (E)next();
  }
  
  public E poll() {
    E item = (E)next();
    if (item != null)
      return item; 
    if (!drainPutStack())
      return null; 
    return (E)next();
  }
  
  private E next() {
    E item = (E)peekNext();
    if (item != null)
      dequeue(); 
    return item;
  }
  
  private E peekNext() {
    if (this.takeStackIndex == -1)
      return null; 
    if (this.takeStackIndex == this.takeStack.length) {
      this.takeStackIndex = -1;
      return null;
    } 
    E item = (E)this.takeStack[this.takeStackIndex];
    if (item == null) {
      this.takeStackIndex = -1;
      return null;
    } 
    return item;
  }
  
  private void dequeue() {
    this.takeStack[this.takeStackIndex] = null;
    this.takeStackIndex++;
    this.takeStackSize.lazySet(this.takeStackSize.get() - 1);
  }
  
  private void takeAll() {
    long iteration = 0L;
    AtomicReference<Node> putStack = this.putStack;
    while (true) {
      if (this.consumerThread.isInterrupted()) {
        putStack.compareAndSet(BLOCKED, null);
        throw new InterruptedException();
      } 
      Node currentPutStackHead = (Node)putStack.get();
      if (currentPutStackHead == null) {
        if (this.idleStrategy != null) {
          this.idleStrategy.idle(iteration);
          continue;
        } 
        if (!putStack.compareAndSet(null, BLOCKED))
          continue; 
        LockSupport.park();
      } else if (currentPutStackHead == BLOCKED) {
        LockSupport.park();
      } else {
        if (!putStack.compareAndSet(currentPutStackHead, null))
          continue; 
        copyIntoTakeStack(currentPutStackHead);
        break;
      } 
      iteration++;
    } 
  }
  
  private boolean drainPutStack() {
    Node head;
    do {
      head = (Node)this.putStack.get();
      if (head == null)
        return false; 
    } while (!this.putStack.compareAndSet(head, null));
    copyIntoTakeStack(head);
    return true;
  }
  
  private void copyIntoTakeStack(Node putStackHead) {
    int putStackSize = putStackHead.size;
    this.takeStackSize.lazySet(putStackSize);
    if (putStackSize > this.takeStack.length)
      this.takeStack = new Object[QuickMath.nextPowerOfTwo(putStackHead.size)]; 
    for (int i = putStackSize - 1; i >= 0; i--) {
      this.takeStack[i] = putStackHead.item;
      putStackHead = putStackHead.next;
    } 
    this.takeStackIndex = 0;
    assert this.takeStack[false] != null;
  }
  
  public int size() {
    Node h = (Node)this.putStack.get();
    int putStackSize = (h == null) ? 0 : h.size;
    return putStackSize + this.takeStackSize.get();
  }
  
  public boolean isEmpty() { return (size() == 0); }
  
  public void put(E e) throws InterruptedException { offer(e); }
  
  public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException {
    add(e);
    return true;
  }
  
  public E poll(long timeout, TimeUnit unit) throws InterruptedException { throw new UnsupportedOperationException(); }
  
  public int remainingCapacity() { return Integer.MAX_VALUE; }
  
  public int drainTo(Collection<? super E> c) { throw new UnsupportedOperationException(); }
  
  public int drainTo(Collection<? super E> c, int maxElements) { throw new UnsupportedOperationException(); }
  
  public Iterator<E> iterator() { throw new UnsupportedOperationException(); }
}
