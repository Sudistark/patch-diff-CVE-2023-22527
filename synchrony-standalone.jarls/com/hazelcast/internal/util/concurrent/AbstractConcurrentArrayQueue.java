package com.hazelcast.internal.util.concurrent;

import com.hazelcast.util.QuickMath;
import java.util.Collection;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.concurrent.atomic.AtomicReferenceArray;

abstract class AbstractConcurrentArrayQueue<E> extends AbstractConcurrentArrayQueuePadding3 implements QueuedPipe<E> {
  protected final int capacity;
  
  protected final AtomicReferenceArray<E> buffer;
  
  protected AbstractConcurrentArrayQueue(int requestedCapacity) {
    this.capacity = QuickMath.nextPowerOfTwo(requestedCapacity);
    this.buffer = new AtomicReferenceArray(this.capacity);
  }
  
  public long addedCount() { return this.tail; }
  
  public long removedCount() { return this.head; }
  
  public int capacity() { return this.capacity; }
  
  public int remainingCapacity() { return capacity() - size(); }
  
  public E peek() { return (E)this.buffer.get(seqToArrayIndex(this.head, (this.capacity - 1))); }
  
  public boolean add(E e) {
    if (offer(e))
      return true; 
    throw new IllegalStateException("Queue is full");
  }
  
  public E remove() {
    E e = (E)poll();
    if (e == null)
      throw new NoSuchElementException("Queue is empty"); 
    return e;
  }
  
  public E element() {
    E e = (E)peek();
    if (e == null)
      throw new NoSuchElementException("Queue is empty"); 
    return e;
  }
  
  public boolean isEmpty() { return (peek() == null); }
  
  public boolean contains(Object o) {
    if (o == null)
      return false; 
    AtomicReferenceArray<E> buffer = this.buffer;
    long mask = (this.capacity - 1);
    long i, limit;
    for (i = this.head, limit = this.tail; i < limit; i++) {
      Object e = buffer.get(seqToArrayIndex(i, mask));
      if (o.equals(e))
        return true; 
    } 
    return false;
  }
  
  public Iterator<E> iterator() { throw new UnsupportedOperationException(); }
  
  public Object[] toArray() { throw new UnsupportedOperationException(); }
  
  public <T> T[] toArray(T[] a) { throw new UnsupportedOperationException(); }
  
  public boolean remove(Object o) { throw new UnsupportedOperationException(); }
  
  public boolean containsAll(Collection<?> c) {
    for (Object o : c) {
      if (!contains(o))
        return false; 
    } 
    return true;
  }
  
  public boolean addAll(Collection<? extends E> c) {
    for (E e : c)
      add(e); 
    return true;
  }
  
  public boolean removeAll(Collection<?> c) { throw new UnsupportedOperationException(); }
  
  public boolean retainAll(Collection<?> c) { throw new UnsupportedOperationException(); }
  
  public void clear() {
    Object value;
    do {
      value = poll();
    } while (value != null);
  }
  
  public int size() {
    long currentTail, currentHeadBefore, currentHeadAfter = this.head;
    do {
      currentHeadBefore = currentHeadAfter;
      currentTail = this.tail;
      currentHeadAfter = this.head;
    } while (currentHeadAfter != currentHeadBefore);
    return (int)(currentTail - currentHeadAfter);
  }
  
  protected static int seqToArrayIndex(long sequence, long mask) { return (int)(sequence & mask); }
}
