package com.hazelcast.internal.util.iterator;

import com.hazelcast.core.HazelcastException;
import com.hazelcast.core.Member;
import com.hazelcast.internal.cluster.ClusterService;
import com.hazelcast.internal.util.futures.ChainingFuture;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicInteger;

public class RestartingMemberIterator extends Object implements Iterator<Member>, ChainingFuture.ExceptionHandler {
  private final Queue<Member> memberQueue;
  
  private final AtomicInteger retryCounter;
  
  private final ClusterService clusterService;
  
  private final int maxRetries;
  
  public RestartingMemberIterator(ClusterService clusterService, int maxRetries) {
    this.memberQueue = new ConcurrentLinkedQueue();
    this.retryCounter = new AtomicInteger();
    this.clusterService = clusterService;
    this.maxRetries = maxRetries;
    Set<Member> currentMembers = clusterService.getMembers();
    startNewRound(currentMembers);
  }
  
  private void startNewRound(Set<Member> currentMembers) {
    this.topologyChanged = false;
    this.memberQueue.addAll(currentMembers);
    this.nextMember = (Member)this.memberQueue.poll();
    this.initialMembers = currentMembers;
  }
  
  public boolean hasNext() {
    if (this.nextMember != null)
      return true; 
    return advance();
  }
  
  private boolean advance() {
    Set<Member> currentMembers = this.clusterService.getMembers();
    if (topologyChanged(currentMembers)) {
      retry(currentMembers);
      assert this.nextMember != null;
      return true;
    } 
    this.nextMember = (Member)this.memberQueue.poll();
    return (this.nextMember != null);
  }
  
  private void retry(Set<Member> currentMembers) {
    if (this.retryCounter.incrementAndGet() > this.maxRetries)
      throw new HazelcastException(String.format("Cluster topology was not stable for %d retries, invoke on stable cluster failed", new Object[] { Integer.valueOf(this.maxRetries) })); 
    this.memberQueue.clear();
    startNewRound(currentMembers);
  }
  
  private boolean topologyChanged(Set<Member> currentMembers) { return (this.topologyChanged || !currentMembers.equals(this.initialMembers)); }
  
  public Member next() {
    Member memberToReturn = this.nextMember;
    this.nextMember = null;
    if (memberToReturn != null)
      return memberToReturn; 
    if (!advance())
      throw new NoSuchElementException("no more elements"); 
    memberToReturn = this.nextMember;
    this.nextMember = null;
    return memberToReturn;
  }
  
  public void remove() { throw new UnsupportedOperationException("not implemented"); }
  
  public <T extends Throwable> void handle(T throwable) throws T {
    if (throwable instanceof com.hazelcast.internal.cluster.impl.ClusterTopologyChangedException) {
      this.topologyChanged = true;
      return;
    } 
    if (throwable instanceof com.hazelcast.core.MemberLeftException || throwable instanceof com.hazelcast.spi.exception.TargetNotMemberException || throwable instanceof com.hazelcast.core.HazelcastInstanceNotActiveException)
      return; 
    throw throwable;
  }
  
  public int getRetryCount() { return this.retryCounter.get(); }
}
