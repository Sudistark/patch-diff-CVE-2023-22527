package com.hazelcast.internal.util.hashslot.impl;

import com.hazelcast.internal.memory.MemoryAccessor;
import com.hazelcast.internal.memory.MemoryAllocator;
import com.hazelcast.internal.memory.MemoryManager;
import com.hazelcast.internal.util.hashslot.HashSlotArray;
import com.hazelcast.internal.util.hashslot.SlotAssignmentResult;
import com.hazelcast.util.HashUtil;

public abstract class HashSlotArrayBase implements HashSlotArray {
  public static final int HEADER_SIZE = 24;
  
  public static final int CAPACITY_OFFSET = -8;
  
  public static final int SIZE_OFFSET = -16;
  
  public static final int EXPAND_THRESHOLD_OFFSET = -24;
  
  protected static final int VALUE_SIZE_GRANULARITY = 8;
  
  protected static final int KEY_1_OFFSET = 0;
  
  protected static final int KEY_2_OFFSET = 8;
  
  protected final long unassignedSentinel;
  
  protected final long offsetOfUnassignedSentinel;
  
  protected final int slotLength;
  
  private MemoryAccessor mem;
  
  private MemoryAllocator malloc;
  
  private MemoryAllocator auxMalloc;
  
  private long baseAddress;
  
  private final int initialCapacity;
  
  private final int valueOffset;
  
  private final int valueLength;
  
  private final float loadFactor;
  
  private final SlotAssignmentResultImpl slotAssignmentResult;
  
  protected HashSlotArrayBase(long unassignedSentinel, long offsetOfUnassignedSentinel, MemoryManager mm, MemoryAllocator auxMalloc, int keyLength, int valueLength, int initialCapacity, float loadFactor) {
    this.baseAddress = 24L;
    this.slotAssignmentResult = new SlotAssignmentResultImpl();
    this.unassignedSentinel = unassignedSentinel;
    this.offsetOfUnassignedSentinel = offsetOfUnassignedSentinel;
    if (mm != null) {
      this.malloc = mm.getAllocator();
      this.mem = mm.getAccessor();
    } 
    this.auxMalloc = auxMalloc;
    this.valueOffset = keyLength;
    this.valueLength = valueLength;
    this.slotLength = keyLength + valueLength;
    this.initialCapacity = initialCapacity;
    this.loadFactor = loadFactor;
  }
  
  public final long address() { return this.baseAddress; }
  
  public final void gotoAddress(long address) { this.baseAddress = address; }
  
  public final long gotoNew() {
    allocateInitial();
    return address();
  }
  
  public final long size() {
    assertValid();
    return this.mem.getLong(this.baseAddress + -16L);
  }
  
  public final long capacity() {
    assertValid();
    return this.mem.getLong(this.baseAddress + -8L);
  }
  
  public final long expansionThreshold() {
    assertValid();
    return this.mem.getLong(this.baseAddress + -24L);
  }
  
  public final void clear() {
    assertValid();
    markAllUnassigned();
    setSize(0L);
  }
  
  public final boolean trimToSize() {
    long minCapacity = minCapacityForSize(size(), this.loadFactor);
    if (capacity() <= minCapacity)
      return false; 
    resizeTo(minCapacity);
    assert expansionThreshold() >= size() : String.format("trimToSize() shrunk the capacity to %,d and expandAt to %,d, which is less than the current size %,d", new Object[] { Long.valueOf(capacity()), Long.valueOf(expansionThreshold()), Long.valueOf(size()) });
    return true;
  }
  
  public final void dispose() {
    if (this.baseAddress <= 24L)
      return; 
    this.malloc.free(this.baseAddress - 24L, 24L + capacity() * this.slotLength);
    this.baseAddress = -1L;
  }
  
  public final void migrateTo(MemoryAllocator newMalloc) {
    this.baseAddress = move(this.baseAddress, capacity(), this.malloc, newMalloc);
    this.malloc = newMalloc;
    this.auxMalloc = null;
  }
  
  protected final SlotAssignmentResult ensure0(long key1, long key2) {
    assertValid();
    long size = size();
    if (size == expansionThreshold())
      resizeTo(CapacityUtil.nextCapacity(capacity())); 
    long slot = keyHash(key1, key2) & mask();
    while (isSlotAssigned(slot)) {
      if (equal(key1OfSlot(slot), key2OfSlot(slot), key1, key2)) {
        this.slotAssignmentResult.setAddress(valueAddrOfSlot(slot));
        this.slotAssignmentResult.setNew(false);
        return this.slotAssignmentResult;
      } 
      slot = slot + 1L & mask();
    } 
    setSize(size + 1L);
    putKey(this.baseAddress, slot, key1, key2);
    this.slotAssignmentResult.setAddress(valueAddrOfSlot(slot));
    this.slotAssignmentResult.setNew(true);
    return this.slotAssignmentResult;
  }
  
  protected final long get0(long key1, long key2) {
    assertValid();
    long slot = keyHash(key1, key2) & mask();
    long wrappedAround = slot;
    while (isSlotAssigned(slot)) {
      if (equal(key1OfSlot(slot), key2OfSlot(slot), key1, key2))
        return valueAddrOfSlot(slot); 
      slot = slot + 1L & mask();
      if (slot == wrappedAround)
        break; 
    } 
    return 0L;
  }
  
  protected final boolean remove0(long key1, long key2) {
    assertValid();
    long slot = keyHash(key1, key2) & mask();
    long wrappedAround = slot;
    while (isSlotAssigned(slot)) {
      if (equal(key1OfSlot(slot), key2OfSlot(slot), key1, key2)) {
        setSize(size() - 1L);
        shiftConflictingKeys(slot);
        return true;
      } 
      slot = slot + 1L & mask();
      if (slot == wrappedAround)
        break; 
    } 
    return false;
  }
  
  protected final void shiftConflictingKeys(long slotCurr) {
    long slotPrev, mask = mask();
    while (true) {
      slotCurr = (slotPrev = slotCurr) + 1L & mask;
      while (isSlotAssigned(slotCurr)) {
        long slotOther = slotHash(this.baseAddress, slotCurr) & mask;
        if ((slotPrev <= slotCurr) ? (
          slotPrev >= slotOther || slotOther > slotCurr) : (

          
          slotPrev >= slotOther && slotOther > slotCurr))
          break; 
        slotCurr = slotCurr + 1L & mask;
      } 
      if (!isSlotAssigned(slotCurr))
        break; 
      putKey(this.baseAddress, slotPrev, key1OfSlot(slotCurr), key2OfSlot(slotCurr));
      this.mem.copyMemory(valueAddrOfSlot(slotCurr), valueAddrOfSlot(slotPrev), this.valueLength);
    } 
    markUnassigned(this.baseAddress, slotPrev);
  }
  
  protected final void allocateArrayAndAdjustFields(long size, long newCapacity) {
    this.baseAddress = this.malloc.allocate(24L + newCapacity * this.slotLength) + 24L;
    setSize(size);
    setCapacity(newCapacity);
    setExpansionThreshold(maxSizeForCapacity(newCapacity, this.loadFactor));
    markAllUnassigned();
  }
  
  protected final void rehash(long oldCapacity, long oldAddress) {
    long mask = mask();
    for (long slot = oldCapacity; --slot >= 0L; ) {
      if (!isAssigned(oldAddress, slot))
        continue; 
      long newSlot = slotHash(oldAddress, slot) & mask;
      while (isSlotAssigned(newSlot))
        newSlot = newSlot + 1L & mask; 
      putKey(this.baseAddress, newSlot, key1OfSlot(oldAddress, slot), key2OfSlot(oldAddress, slot));
      long valueAddrOfOldSlot = slotBase(oldAddress, slot) + this.valueOffset;
      this.mem.copyMemory(valueAddrOfOldSlot, valueAddrOfSlot(newSlot), this.valueLength);
    } 
  }
  
  protected final void setMemMgr(MemoryManager memoryManager) {
    this.mem = memoryManager.getAccessor();
    this.malloc = memoryManager.getAllocator();
  }
  
  protected final void assertValid() { assert this.baseAddress - 24L != 0L : "This instance doesn't point to a valid hashtable. Base address = " + this.baseAddress; }
  
  protected final MemoryAllocator malloc() { return this.malloc; }
  
  protected final MemoryAccessor mem() { return this.mem; }
  
  protected final long slotBase(long baseAddr, long slot) { return baseAddr + this.slotLength * slot; }
  
  protected void resizeTo(long newCapacity) {
    long oldAddress;
    MemoryAllocator oldMalloc;
    long oldCapacity = capacity();
    long oldAllocatedSize = 24L + oldCapacity * this.slotLength;
    if (this.auxMalloc != null) {
      long size = size();
      oldAddress = move(this.baseAddress, oldCapacity, this.malloc, this.auxMalloc);
      oldMalloc = this.auxMalloc;
      auxAllocateAndAdjustFields(oldAddress, size, oldCapacity, newCapacity);
    } else {
      oldMalloc = this.malloc;
      oldAddress = this.baseAddress;
      allocateArrayAndAdjustFields(size(), newCapacity);
    } 
    rehash(oldCapacity, oldAddress);
    oldMalloc.free(oldAddress - 24L, oldAllocatedSize);
  }
  
  protected long key1OfSlot(long baseAddress, long slot) { return this.mem.getLong(slotBase(baseAddress, slot) + 0L); }
  
  protected long key2OfSlot(long baseAddress, long slot) { return this.mem.getLong(slotBase(baseAddress, slot) + 8L); }
  
  protected boolean isAssigned(long baseAddress, long slot) { return (this.mem.getLong(slotBase(baseAddress, slot) + this.offsetOfUnassignedSentinel) != this.unassignedSentinel); }
  
  protected void markUnassigned(long baseAddress, long slot) { this.mem.putLong(slotBase(baseAddress, slot) + this.offsetOfUnassignedSentinel, this.unassignedSentinel); }
  
  protected void putKey(long baseAddress, long slot, long key1, long key2) {
    long slotBase = slotBase(baseAddress, slot);
    this.mem.putLong(slotBase + 0L, key1);
    this.mem.putLong(slotBase + 8L, key2);
  }
  
  protected long keyHash(long key1, long key2) { return HashUtil.fastLongMix(HashUtil.fastLongMix(key1) + key2); }
  
  protected long slotHash(long baseAddress, long slot) { return keyHash(key1OfSlot(baseAddress, slot), key2OfSlot(baseAddress, slot)); }
  
  protected boolean equal(long key1a, long key2a, long key1b, long key2b) { return (key1a == key1b && key2a == key2b); }
  
  private void setCapacity(long capacity) {
    assertValid();
    this.mem.putLong(this.baseAddress + -8L, capacity);
  }
  
  private void setExpansionThreshold(long thresh) {
    assertValid();
    this.mem.putLong(this.baseAddress + -24L, thresh);
  }
  
  private long mask() { return capacity() - 1L; }
  
  private void setSize(long newSize) { this.mem.putLong(this.baseAddress + -16L, newSize); }
  
  private void allocateInitial() { allocateArrayAndAdjustFields(0L, CapacityUtil.roundCapacity((int)(this.initialCapacity / this.loadFactor))); }
  
  private long key1OfSlot(long slot) { return key1OfSlot(this.baseAddress, slot); }
  
  private long key2OfSlot(long slot) { return key2OfSlot(this.baseAddress, slot); }
  
  private long valueAddrOfSlot(long slot) { return slotBase(this.baseAddress, slot) + this.valueOffset; }
  
  private boolean isSlotAssigned(long slot) { return isAssigned(this.baseAddress, slot); }
  
  private void auxAllocateAndAdjustFields(long auxAddress, long size, long oldCapacity, long newCapacity) {
    try {
      allocateArrayAndAdjustFields(size, newCapacity);
    } catch (Error e) {
      try {
        this.baseAddress = move(auxAddress, oldCapacity, this.auxMalloc, this.malloc);
      } catch (Error e1) {
        this.baseAddress = 0L;
      } 
      throw e;
    } 
  }
  
  private long move(long fromBaseAddress, long capacity, MemoryAllocator fromMalloc, MemoryAllocator toMalloc) {
    long allocatedSize = 24L + capacity * this.slotLength;
    long toBaseAddress = toMalloc.allocate(allocatedSize) + 24L;
    this.mem.copyMemory(fromBaseAddress - 24L, toBaseAddress - 24L, allocatedSize);
    fromMalloc.free(fromBaseAddress - 24L, allocatedSize);
    return toBaseAddress;
  }
  
  private void markAllUnassigned() {
    long capacity = capacity();
    for (long i = 0L; i < capacity; i++)
      markUnassigned(this.baseAddress, i); 
  }
  
  private static long maxSizeForCapacity(long capacity, float loadFactor) { return Math.max(2L, (long)Math.ceil(((float)capacity * loadFactor))) - 1L; }
  
  private static long minCapacityForSize(long size, float loadFactor) { return CapacityUtil.roundCapacity((long)Math.ceil(((float)size / loadFactor))); }
}
