package com.hazelcast.internal.util.hashslot.impl;

import com.hazelcast.internal.memory.MemoryManager;
import com.hazelcast.internal.util.hashslot.HashSlotArray12byteKey;
import com.hazelcast.internal.util.hashslot.HashSlotCursor12byteKey;
import com.hazelcast.internal.util.hashslot.SlotAssignmentResult;
import com.hazelcast.util.HashUtil;
import com.hazelcast.util.QuickMath;

public final class HashSlotArray12byteKeyImpl extends HashSlotArrayBase implements HashSlotArray12byteKey {
  private static final int KEY_SIZE = 12;
  
  public HashSlotArray12byteKeyImpl(int unassignedSentinel, MemoryManager mm, int valueLength, int initialCapacity, float loadFactor) {
    this(unassignedSentinel, 12L, mm, valueLength, initialCapacity, loadFactor);
    assert valueLength > 0 : "Attempted to instantiate HashSlotArrayImpl with zero value length";
  }
  
  public HashSlotArray12byteKeyImpl(int unassignedSentinel, MemoryManager mm, int valueLength) {
    this(unassignedSentinel, mm, valueLength, 16, 0.6F);
    assert valueLength > 0 : "Attempted to instantiate HashSlotArrayImpl with zero value length";
  }
  
  private HashSlotArray12byteKeyImpl(int unassignedSentinel, long offsetOfUnassignedSentinel, MemoryManager mm, int valueLength, int initialCapacity, float loadFactor) {
    super(unassignedSentinel, offsetOfUnassignedSentinel, mm, null, 12, valueLength, initialCapacity, loadFactor);
    assert valueLength >= 4 && 
      QuickMath.modPowerOfTwo(valueLength - 4, 8) == 0 : "Value length must be 4 plus a positive multiple of 8, but was " + valueLength;
  }
  
  public SlotAssignmentResult ensure(long key1, int key2) { return ensure0(key1, key2); }
  
  public long get(long key1, int key2) { return get0(key1, key2); }
  
  public boolean remove(long key1, int key2) { return remove0(key1, key2); }
  
  public HashSlotCursor12byteKey cursor() { return new HashSlotArrayBase.CursorIntKey2(this); }
  
  protected long key2OfSlot(long baseAddress, long slot) { return mem().getInt(slotBase(baseAddress, slot) + 8L); }
  
  protected void putKey(long baseAddress, long slot, long key1, long key2) {
    mem().putLong(slotBase(baseAddress, slot) + 0L, key1);
    mem().putInt(slotBase(baseAddress, slot) + 8L, (int)key2);
  }
  
  protected void markUnassigned(long baseAddress, long slot) { mem().putInt(slotBase(baseAddress, slot) + this.offsetOfUnassignedSentinel, (int)this.unassignedSentinel); }
  
  protected boolean isAssigned(long baseAddress, long slot) { return (mem().getInt(slotBase(baseAddress, slot) + this.offsetOfUnassignedSentinel) != this.unassignedSentinel); }
  
  protected long keyHash(long key1, long key2) { return HashUtil.fastLongMix(key1 + HashUtil.fastIntMix((int)key2)); }
}
