package com.hazelcast.internal.util.futures;

import com.hazelcast.core.ICompletableFuture;
import com.hazelcast.logging.ILogger;
import com.hazelcast.spi.impl.AbstractCompletableFuture;
import java.util.Iterator;
import java.util.concurrent.Executor;

public class ChainingFuture<T> extends AbstractCompletableFuture<T> {
  private final ExceptionHandler exceptionHandler;
  
  public ChainingFuture(Iterator<ICompletableFuture<T>> futuresToChain, Executor executor, ExceptionHandler exceptionHandler, ILogger logger) {
    super(executor, logger);
    this.exceptionHandler = exceptionHandler;
    if (!futuresToChain.hasNext()) {
      setResult(null);
    } else {
      ICompletableFuture<T> future = (ICompletableFuture)futuresToChain.next();
      registerCallback(future, futuresToChain);
    } 
  }
  
  private void registerCallback(ICompletableFuture<T> future, Iterator<ICompletableFuture<T>> invocationIterator) { future.andThen(new Object(this, invocationIterator)); }
  
  private void advanceOrComplete(T response, Iterator<ICompletableFuture<T>> invocationIterator) {
    try {
      boolean hasNext = invocationIterator.hasNext();
      if (!hasNext) {
        setResult(response);
      } else {
        ICompletableFuture<T> future = (ICompletableFuture)invocationIterator.next();
        registerCallback(future, invocationIterator);
      } 
    } catch (Throwable t) {
      setResult(t);
    } 
  }
}
