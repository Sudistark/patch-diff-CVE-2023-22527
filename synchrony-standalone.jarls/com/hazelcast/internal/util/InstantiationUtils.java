package com.hazelcast.internal.util;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;

public final class InstantiationUtils {
  public static <T> T newInstanceOrNull(Class<? extends T> clazz, Object... params) {
    Constructor<T> constructor = selectMatchingConstructor(clazz, params);
    if (constructor == null)
      return null; 
    try {
      return (T)constructor.newInstance(params);
    } catch (IllegalAccessException e) {
      return null;
    } catch (InstantiationException e) {
      return null;
    } catch (InvocationTargetException e) {
      return null;
    } 
  }
  
  private static <T> Constructor<T> selectMatchingConstructor(Class<? extends T> clazz, Object[] params) {
    Constructor[] constructors = clazz.getConstructors();
    Constructor<T> selectedConstructor = null;
    for (Constructor<?> constructor : constructors) {
      if (isParamsMatching(constructor, params))
        if (selectedConstructor == null) {
          selectedConstructor = constructor;
        } else {
          throw new AmbigiousInstantiationException("Class " + clazz + " has multiple constructors matching given parameters: " + 
              Arrays.toString(params));
        }  
    } 
    return selectedConstructor;
  }
  
  private static boolean isParamsMatching(Constructor<?> constructor, Object[] params) {
    Class[] constructorParamTypes = constructor.getParameterTypes();
    if (constructorParamTypes.length != params.length)
      return false; 
    for (int i = 0; i < constructorParamTypes.length; i++) {
      Class<?> constructorParamType = constructorParamTypes[i];
      Object param = params[i];
      if (constructorParamType.isPrimitive()) {
        if (param == null)
          return false; 
        constructorParamType = toBoxedType(constructorParamType);
      } 
      if (param != null) {
        Class<?> paramType = param.getClass();
        if (!constructorParamType.isAssignableFrom(paramType))
          return false; 
      } 
    } 
    return true;
  }
  
  private static Class<?> toBoxedType(Class<?> type) {
    assert type.isPrimitive();
    assert type != void.class;
    if (type == boolean.class)
      return Boolean.class; 
    if (type == byte.class)
      return Byte.class; 
    if (type == char.class)
      return Character.class; 
    if (type == double.class)
      return Double.class; 
    if (type == float.class)
      return Float.class; 
    if (type == int.class)
      return Integer.class; 
    if (type == long.class)
      return Long.class; 
    if (type == short.class)
      return Short.class; 
    throw new IllegalArgumentException("Unknown primitive type " + type.getName());
  }
}
