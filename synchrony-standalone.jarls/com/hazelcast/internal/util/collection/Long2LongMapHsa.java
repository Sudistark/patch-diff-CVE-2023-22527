package com.hazelcast.internal.util.collection;

import com.hazelcast.internal.memory.MemoryAccessor;
import com.hazelcast.internal.memory.MemoryManager;
import com.hazelcast.internal.util.hashslot.HashSlotArray8byteKey;
import com.hazelcast.internal.util.hashslot.SlotAssignmentResult;
import com.hazelcast.internal.util.hashslot.impl.HashSlotArray8byteKeyImpl;

public class Long2LongMapHsa implements Long2LongMap {
  private final HashSlotArray8byteKey hsa;
  
  private final long nullValue;
  
  private MemoryAccessor mem;
  
  public Long2LongMapHsa(long nullValue, MemoryManager memMgr) {
    this.hsa = new HashSlotArray8byteKeyImpl(nullValue, memMgr, 8);
    this.hsa.gotoNew();
    this.mem = memMgr.getAccessor();
    this.nullValue = nullValue;
  }
  
  public long get(long key) {
    long valueAddr = this.hsa.get(key);
    return (valueAddr != 0L) ? this.mem.getLong(valueAddr) : this.nullValue;
  }
  
  public long put(long key, long value) {
    long result;
    assert value != this.nullValue : "put() called with null-sentinel value " + this.nullValue;
    SlotAssignmentResult slot = this.hsa.ensure(key);
    if (!slot.isNew()) {
      result = this.mem.getLong(slot.address());
    } else {
      result = this.nullValue;
    } 
    this.mem.putLong(slot.address(), value);
    return result;
  }
  
  public long putIfAbsent(long key, long value) {
    assert value != this.nullValue : "putIfAbsent() called with null-sentinel value " + this.nullValue;
    SlotAssignmentResult slot = this.hsa.ensure(key);
    if (slot.isNew()) {
      this.mem.putLong(slot.address(), value);
      return this.nullValue;
    } 
    return this.mem.getLong(slot.address());
  }
  
  public void putAll(Long2LongMap from) {
    for (LongLongCursor cursor = from.cursor(); cursor.advance();)
      put(cursor.key(), cursor.value()); 
  }
  
  public boolean replace(long key, long oldValue, long newValue) {
    assert oldValue != this.nullValue : "replace() called with null-sentinel oldValue " + this.nullValue;
    assert newValue != this.nullValue : "replace() called with null-sentinel newValue " + this.nullValue;
    long valueAddr = this.hsa.get(key);
    if (valueAddr == 0L)
      return false; 
    long actualValue = this.mem.getLong(valueAddr);
    if (actualValue != oldValue)
      return false; 
    this.mem.putLong(valueAddr, newValue);
    return true;
  }
  
  public long replace(long key, long value) {
    assert value != this.nullValue : "replace() called with null-sentinel value " + this.nullValue;
    long valueAddr = this.hsa.get(key);
    if (valueAddr == 0L)
      return this.nullValue; 
    long oldValue = this.mem.getLong(valueAddr);
    this.mem.putLong(valueAddr, value);
    return oldValue;
  }
  
  public long remove(long key) {
    long valueAddr = this.hsa.get(key);
    if (valueAddr == 0L)
      return this.nullValue; 
    long oldValue = this.mem.getLong(valueAddr);
    this.hsa.remove(key);
    return oldValue;
  }
  
  public boolean remove(long key, long value) {
    assert value != this.nullValue : "remove() called with null-sentinel value " + this.nullValue;
    long valueAddr = this.hsa.get(key);
    if (valueAddr == 0L)
      return false; 
    long actualValue = this.mem.getLong(valueAddr);
    if (actualValue == value) {
      this.hsa.remove(key);
      return true;
    } 
    return false;
  }
  
  public boolean containsKey(long key) { return (this.hsa.get(key) != 0L); }
  
  public long size() { return this.hsa.size(); }
  
  public boolean isEmpty() { return (this.hsa.size() == 0L); }
  
  public void clear() { this.hsa.clear(); }
  
  public void dispose() { this.hsa.dispose(); }
  
  public LongLongCursor cursor() { return new Cursor(this, this.hsa); }
}
