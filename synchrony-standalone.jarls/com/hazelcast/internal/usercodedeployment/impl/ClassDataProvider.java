package com.hazelcast.internal.usercodedeployment.impl;

import com.hazelcast.config.UserCodeDeploymentConfig;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.IOUtil;
import com.hazelcast.util.EmptyStatement;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentMap;

public final class ClassDataProvider {
  private final UserCodeDeploymentConfig.ProviderMode providerMode;
  
  private final ClassLoader parent;
  
  private final ConcurrentMap<String, ClassSource> classSourceMap;
  
  private final ConcurrentMap<String, ClassSource> clientClassSourceMap;
  
  private final ILogger logger;
  
  public ClassDataProvider(UserCodeDeploymentConfig.ProviderMode providerMode, ClassLoader parent, ConcurrentMap<String, ClassSource> classSourceMap, ConcurrentMap<String, ClassSource> clientClassSourceMap, ILogger logger) {
    this.providerMode = providerMode;
    this.parent = parent;
    this.classSourceMap = classSourceMap;
    this.clientClassSourceMap = clientClassSourceMap;
    this.logger = logger;
  }
  
  public ClassData getClassDataOrNull(String className) {
    ClassData classData = loadBytecodesFromClientCache(className);
    if (classData != null)
      return classData; 
    if (this.providerMode == UserCodeDeploymentConfig.ProviderMode.OFF)
      return null; 
    classData = loadBytecodesFromParent(className);
    if (classData == null && this.providerMode == UserCodeDeploymentConfig.ProviderMode.LOCAL_AND_CACHED_CLASSES)
      classData = loadBytecodesFromCache(className); 
    return classData;
  }
  
  private ClassData loadBytecodesFromCache(String className) {
    ClassSource classSource = (ClassSource)this.classSourceMap.get(ClassLocator.extractMainClassName(className));
    if (classSource == null)
      return null; 
    return classSource.getClassData(className);
  }
  
  private ClassData loadBytecodesFromClientCache(String className) {
    ClassSource classSource = (ClassSource)this.clientClassSourceMap.get(ClassLocator.extractMainClassName(className));
    if (classSource == null)
      return null; 
    return classSource.getClassData(className);
  }
  
  private ClassData loadBytecodesFromParent(String className) {
    byte[] mainClassDefinition = loadBytecodeFromParent(className);
    if (mainClassDefinition == null)
      return null; 
    Map<String, byte[]> innerClassDefinitions = loadInnerClasses(className);
    innerClassDefinitions = loadAnonymousClasses(className, innerClassDefinitions);
    ClassData classData = new ClassData();
    if (innerClassDefinitions != null)
      classData.setInnerClassDefinitions(innerClassDefinitions); 
    classData.setMainClassDefinition(mainClassDefinition);
    return classData;
  }
  
  private Map<String, byte[]> loadAnonymousClasses(String className, Map<String, byte[]> innerClassDefinitions) {
    int i = 1;
    try {
      while (true) {
        String innerClassName = className + "$" + i;
        this.parent.loadClass(innerClassName);
        byte[] innerByteCode = loadBytecodeFromParent(innerClassName);
        if (innerClassDefinitions == null)
          innerClassDefinitions = new HashMap<String, byte[]>(); 
        innerClassDefinitions.put(innerClassName, innerByteCode);
        i++;
      } 
    } catch (ClassNotFoundException e) {
      return innerClassDefinitions;
    } 
  }
  
  private Map<String, byte[]> loadInnerClasses(String className) {
    Map<String, byte[]> innerClassDefinitions = null;
    try {
      Class<?> aClass = this.parent.loadClass(className);
      Class[] declaredClasses = aClass.getDeclaredClasses();
      for (Class<?> declaredClass : declaredClasses) {
        String innerClassName = declaredClass.getName();
        byte[] innerByteCode = loadBytecodeFromParent(innerClassName);
        if (innerClassDefinitions == null)
          innerClassDefinitions = new HashMap<String, byte[]>(); 
        innerClassDefinitions.put(innerClassName, innerByteCode);
      } 
    } catch (ClassNotFoundException e) {
      EmptyStatement.ignore(e);
    } 
    return innerClassDefinitions;
  }
  
  private byte[] loadBytecodeFromParent(String className) {
    String resource = className.replace('.', '/').concat(".class");
    is = null;
    try {
      is = this.parent.getResourceAsStream(resource);
      if (is != null)
        try {
          return IOUtil.toByteArray(is);
        } catch (IOException e) {
          this.logger.severe(e);
        }  
    } finally {
      IOUtil.closeResource(is);
    } 
    return null;
  }
}
