package com.hazelcast.internal.ascii.memcache;

import com.hazelcast.internal.ascii.TextCommand;
import com.hazelcast.internal.ascii.TextCommandConstants;
import com.hazelcast.internal.ascii.TypeAwareCommandParser;
import com.hazelcast.nio.ascii.TextDecoder;
import java.util.StringTokenizer;

public class SetCommandParser extends TypeAwareCommandParser {
  public SetCommandParser(TextCommandConstants.TextCommandType type) { super(type); }
  
  public TextCommand parser(TextDecoder decoder, String cmd, int space) {
    int expiration, flag, valueLen;
    String key;
    StringTokenizer st = new StringTokenizer(cmd);
    st.nextToken();
    boolean noReply = false;
    if (st.hasMoreTokens()) {
      key = st.nextToken();
    } else {
      return new ErrorCommand(TextCommandConstants.TextCommandType.ERROR_CLIENT);
    } 
    if (st.hasMoreTokens()) {
      flag = Integer.parseInt(st.nextToken());
    } else {
      return new ErrorCommand(TextCommandConstants.TextCommandType.ERROR_CLIENT);
    } 
    if (st.hasMoreTokens()) {
      expiration = Integer.parseInt(st.nextToken());
    } else {
      return new ErrorCommand(TextCommandConstants.TextCommandType.ERROR_CLIENT);
    } 
    if (st.hasMoreTokens()) {
      valueLen = Integer.parseInt(st.nextToken());
    } else {
      return new ErrorCommand(TextCommandConstants.TextCommandType.ERROR_CLIENT);
    } 
    if (st.hasMoreTokens())
      noReply = "noreply".equals(st.nextToken()); 
    return new SetCommand(this.type, key, flag, expiration, valueLen, noReply);
  }
}
