package com.hazelcast.internal.ascii.rest;

import com.hazelcast.cluster.ClusterState;
import com.hazelcast.config.GroupConfig;
import com.hazelcast.config.WanReplicationConfig;
import com.hazelcast.cp.CPSubsystem;
import com.hazelcast.cp.CPSubsystemManagementService;
import com.hazelcast.instance.Node;
import com.hazelcast.internal.ascii.TextCommandService;
import com.hazelcast.internal.cluster.impl.ClusterServiceImpl;
import com.hazelcast.internal.json.Json;
import com.hazelcast.internal.management.ManagementCenterService;
import com.hazelcast.internal.management.dto.WanReplicationConfigDTO;
import com.hazelcast.internal.util.InvocationUtil;
import com.hazelcast.logging.ILogger;
import com.hazelcast.security.SecurityContext;
import com.hazelcast.security.UsernamePasswordCredentials;
import com.hazelcast.spi.properties.GroupProperty;
import com.hazelcast.spi.properties.HazelcastProperties;
import com.hazelcast.util.JsonUtil;
import com.hazelcast.util.StringUtil;
import com.hazelcast.version.Version;
import com.hazelcast.wan.AddWanConfigResult;
import com.hazelcast.wan.WanReplicationService;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import javax.security.auth.login.LoginContext;
import javax.security.auth.login.LoginException;

public class HttpPostCommandProcessor extends HttpCommandProcessor<HttpPostCommand> {
  private static final byte[] QUEUE_SIMPLE_VALUE_CONTENT_TYPE = StringUtil.stringToBytes("text/plain");
  
  private final ILogger logger;
  
  public HttpPostCommandProcessor(TextCommandService textCommandService) {
    super(textCommandService);
    this.logger = textCommandService.getNode().getLogger(HttpPostCommandProcessor.class);
  }
  
  public void handle(HttpPostCommand command) {
    boolean sendResponse = true;
    try {
      String uri = command.getURI();
      if (uri.startsWith("/hazelcast/rest/maps/")) {
        handleMap(command, uri);
      } else if (uri.startsWith("/hazelcast/rest/mancenter/changeurl")) {
        handleManagementCenterUrlChange(command);
      } else if (uri.startsWith("/hazelcast/rest/queues/")) {
        handleQueue(command, uri);
      } else if (uri.startsWith("/hazelcast/rest/management/cluster/state")) {
        handleGetClusterState(command);
      } else if (uri.startsWith("/hazelcast/rest/management/cluster/changeState")) {
        handleChangeClusterState(command);
      } else if (uri.startsWith("/hazelcast/rest/management/cluster/version")) {
        handleChangeClusterVersion(command);
      } else {
        if (uri.startsWith("/hazelcast/rest/management/cluster/clusterShutdown")) {
          handleClusterShutdown(command);
          return;
        } 
        if (uri.startsWith("/hazelcast/rest/management/cluster/forceStart")) {
          handleForceStart(command);
        } else if (uri.startsWith("/hazelcast/rest/management/cluster/hotBackupInterrupt")) {
          handleHotRestartBackupInterrupt(command);
        } else if (uri.startsWith("/hazelcast/rest/management/cluster/hotBackup")) {
          handleHotRestartBackup(command);
        } else if (uri.startsWith("/hazelcast/rest/management/cluster/partialStart")) {
          handlePartialStart(command);
        } else if (uri.startsWith("/hazelcast/rest/management/cluster/nodes")) {
          handleListNodes(command);
        } else if (uri.startsWith("/hazelcast/rest/management/cluster/memberShutdown")) {
          handleShutdownNode(command);
        } else if (uri.startsWith("/hazelcast/rest/mancenter/wan/sync/map") || uri.startsWith("/hazelcast/rest/wan/sync/map")) {
          handleWanSyncMap(command);
        } else if (uri.startsWith("/hazelcast/rest/mancenter/wan/sync/allmaps") || uri.startsWith("/hazelcast/rest/wan/sync/allmaps")) {
          handleWanSyncAllMaps(command);
        } else if (uri.startsWith("/hazelcast/rest/mancenter/wan/clearWanQueues") || uri.startsWith("/hazelcast/rest/mancenter/clearWanQueues")) {
          handleWanClearQueues(command);
        } else if (uri.startsWith("/hazelcast/rest/mancenter/wan/addWanConfig") || uri.startsWith("/hazelcast/rest/wan/addWanConfig")) {
          handleAddWanConfig(command);
        } else if (uri.startsWith("/hazelcast/rest/mancenter/wan/pausePublisher")) {
          handleWanPausePublisher(command);
        } else if (uri.startsWith("/hazelcast/rest/mancenter/wan/stopPublisher")) {
          handleWanStopPublisher(command);
        } else if (uri.startsWith("/hazelcast/rest/mancenter/wan/resumePublisher")) {
          handleWanResumePublisher(command);
        } else if (uri.startsWith("/hazelcast/rest/mancenter/wan/consistencyCheck/map")) {
          handleWanConsistencyCheck(command);
        } else if (uri.startsWith("/hazelcast/rest/mancenter/security/permissions")) {
          handleUpdatePermissions(command);
        } else if (uri.startsWith("/hazelcast/rest/cp-subsystem/members")) {
          handleCPMember(command);
          sendResponse = false;
        } else if (uri.startsWith("/hazelcast/rest/cp-subsystem/groups")) {
          handleCPGroup(command);
          sendResponse = false;
        } else if (uri.startsWith("/hazelcast/rest/cp-subsystem/restart")) {
          handleResetAndInitCPSubsystem(command);
          sendResponse = false;
        } else if (uri.startsWith("/hazelcast/rest/license")) {
          handleSetLicense(command);
        } else {
          command.send404();
        } 
      } 
    } catch (IndexOutOfBoundsException e) {
      command.send400();
    } catch (Exception e) {
      command.send500();
    } 
    if (sendResponse)
      this.textCommandService.sendResponse(command); 
  }
  
  private void handleChangeClusterState(HttpPostCommand command) {
    String res;
    byte[] data = command.getData();
    String[] strList = StringUtil.bytesToString(data).split("&");
    try {
      Node node = this.textCommandService.getNode();
      ClusterServiceImpl clusterServiceImpl = node.getClusterService();
      if (authenticate(command, strList[0], (strList.length > 1) ? strList[1] : null)) {
        String stateParam = URLDecoder.decode(strList[2], "UTF-8");
        ClusterState state = ClusterState.valueOf(StringUtil.upperCaseInternal(stateParam));
        if (!state.equals(clusterServiceImpl.getClusterState())) {
          clusterServiceImpl.changeClusterState(state);
          res = response(ResponseType.SUCCESS, new Object[] { "state", state.toString().toLowerCase(StringUtil.LOCALE_INTERNAL) });
        } else {
          res = response(ResponseType.FAIL, new Object[] { "state", state.toString().toLowerCase(StringUtil.LOCALE_INTERNAL) });
        } 
      } else {
        res = response(ResponseType.FORBIDDEN, new Object[0]);
      } 
    } catch (Throwable throwable) {
      this.logger.warning("Error occurred while changing cluster state", throwable);
      res = exceptionResponse(throwable);
    } 
    command.setResponse(HttpCommand.CONTENT_TYPE_JSON, StringUtil.stringToBytes(res));
  }
  
  private void handleGetClusterState(HttpPostCommand command) {
    String res;
    try {
      Node node = this.textCommandService.getNode();
      ClusterServiceImpl clusterServiceImpl = node.getClusterService();
      if (!checkCredentials(command)) {
        res = response(ResponseType.FORBIDDEN, new Object[0]);
      } else {
        ClusterState clusterState = clusterServiceImpl.getClusterState();
        res = response(ResponseType.SUCCESS, new Object[] { "state", StringUtil.lowerCaseInternal(clusterState.toString()) });
      } 
    } catch (Throwable throwable) {
      this.logger.warning("Error occurred while getting cluster state", throwable);
      res = exceptionResponse(throwable);
    } 
    command.setResponse(HttpCommand.CONTENT_TYPE_JSON, StringUtil.stringToBytes(res));
  }
  
  private void handleChangeClusterVersion(HttpPostCommand command) {
    String res;
    byte[] data = command.getData();
    String[] strList = StringUtil.bytesToString(data).split("&");
    try {
      Node node = this.textCommandService.getNode();
      ClusterServiceImpl clusterServiceImpl = node.getClusterService();
      if (authenticate(command, strList[0], (strList.length > 1) ? strList[1] : null)) {
        String versionParam = URLDecoder.decode(strList[2], "UTF-8");
        Version version = Version.of(versionParam);
        clusterServiceImpl.changeClusterVersion(version);
        res = response(ResponseType.SUCCESS, new Object[] { "version", clusterServiceImpl.getClusterVersion().toString() });
      } else {
        res = response(ResponseType.FORBIDDEN, new Object[0]);
      } 
    } catch (Throwable throwable) {
      this.logger.warning("Error occurred while changing cluster version", throwable);
      res = exceptionResponse(throwable);
    } 
    command.setResponse(HttpCommand.CONTENT_TYPE_JSON, StringUtil.stringToBytes(res));
  }
  
  private void handleForceStart(HttpPostCommand command) {
    String res;
    try {
      Node node = this.textCommandService.getNode();
      if (!checkCredentials(command)) {
        res = response(ResponseType.FORBIDDEN, new Object[0]);
      } else {
        boolean success = node.getNodeExtension().getInternalHotRestartService().triggerForceStart();
        res = response(success ? ResponseType.SUCCESS : ResponseType.FAIL, new Object[0]);
      } 
    } catch (Throwable throwable) {
      this.logger.warning("Error occurred while handling force start", throwable);
      res = exceptionResponse(throwable);
    } 
    sendResponse(command, res);
  }
  
  private void handlePartialStart(HttpPostCommand command) {
    String res;
    try {
      Node node = this.textCommandService.getNode();
      if (!checkCredentials(command)) {
        res = response(ResponseType.FORBIDDEN, new Object[0]);
      } else {
        boolean success = node.getNodeExtension().getInternalHotRestartService().triggerPartialStart();
        res = response(success ? ResponseType.SUCCESS : ResponseType.FAIL, new Object[0]);
      } 
    } catch (Throwable throwable) {
      this.logger.warning("Error occurred while handling partial start", throwable);
      res = exceptionResponse(throwable);
    } 
    sendResponse(command, res);
  }
  
  private void handleHotRestartBackup(HttpPostCommand command) {
    String res;
    try {
      if (checkCredentials(command)) {
        this.textCommandService.getNode().getNodeExtension().getHotRestartService().backup();
        res = response(ResponseType.SUCCESS, new Object[0]);
      } else {
        res = response(ResponseType.FORBIDDEN, new Object[0]);
      } 
    } catch (Throwable throwable) {
      this.logger.warning("Error occurred while invoking hot backup", throwable);
      res = exceptionResponse(throwable);
    } 
    sendResponse(command, res);
  }
  
  private void handleHotRestartBackupInterrupt(HttpPostCommand command) {
    String res;
    try {
      if (checkCredentials(command)) {
        this.textCommandService.getNode().getNodeExtension().getHotRestartService().interruptBackupTask();
        res = response(ResponseType.SUCCESS, new Object[0]);
      } else {
        res = response(ResponseType.FORBIDDEN, new Object[0]);
      } 
    } catch (Throwable throwable) {
      this.logger.warning("Error occurred while interrupting hot backup", throwable);
      res = exceptionResponse(throwable);
    } 
    sendResponse(command, res);
  }
  
  private void handleClusterShutdown(HttpPostCommand command) {
    String res;
    try {
      Node node = this.textCommandService.getNode();
      ClusterServiceImpl clusterServiceImpl = node.getClusterService();
      if (!checkCredentials(command)) {
        res = response(ResponseType.FORBIDDEN, new Object[0]);
      } else {
        res = response(ResponseType.SUCCESS, new Object[0]);
        sendResponse(command, res);
        clusterServiceImpl.shutdown();
        return;
      } 
    } catch (Throwable throwable) {
      this.logger.warning("Error occurred while shutting down cluster", throwable);
      res = exceptionResponse(throwable);
    } 
    sendResponse(command, res);
  }
  
  private void handleListNodes(HttpPostCommand command) {
    String res;
    try {
      Node node = this.textCommandService.getNode();
      ClusterServiceImpl clusterServiceImpl = node.getClusterService();
      if (!checkCredentials(command)) {
        res = response(ResponseType.FORBIDDEN, new Object[0]);
      } else {
        String responseTxt = clusterServiceImpl.getMembers().toString() + "\n" + node.getBuildInfo().getVersion() + "\n" + System.getProperty("java.version");
        res = response(ResponseType.SUCCESS, new Object[] { "response", responseTxt });
        sendResponse(command, res);
        return;
      } 
    } catch (Throwable throwable) {
      this.logger.warning("Error occurred while listing nodes", throwable);
      res = exceptionResponse(throwable);
    } 
    sendResponse(command, res);
  }
  
  private void handleShutdownNode(HttpPostCommand command) {
    String res;
    try {
      Node node = this.textCommandService.getNode();
      if (!checkCredentials(command)) {
        res = response(ResponseType.FORBIDDEN, new Object[0]);
      } else {
        res = response(ResponseType.SUCCESS, new Object[0]);
        sendResponse(command, res);
        node.hazelcastInstance.shutdown();
        return;
      } 
    } catch (Throwable throwable) {
      this.logger.warning("Error occurred while shutting down", throwable);
      res = exceptionResponse(throwable);
    } 
    sendResponse(command, res);
  }
  
  private void handleQueue(HttpPostCommand command, String uri) {
    byte[] contentType, data;
    String queueName, suffix, simpleValue = null;
    if (uri.endsWith("/")) {
      suffix = uri.substring("/hazelcast/rest/queues/".length(), uri.length() - 1);
    } else {
      suffix = uri.substring("/hazelcast/rest/queues/".length());
    } 
    int indexSlash = suffix.lastIndexOf('/');
    if (indexSlash == -1) {
      queueName = suffix;
    } else {
      queueName = suffix.substring(0, indexSlash);
      simpleValue = suffix.substring(indexSlash + 1);
    } 
    if (simpleValue == null) {
      data = command.getData();
      contentType = command.getContentType();
    } else {
      data = StringUtil.stringToBytes(simpleValue);
      contentType = QUEUE_SIMPLE_VALUE_CONTENT_TYPE;
    } 
    boolean offerResult = this.textCommandService.offer(queueName, new RestValue(data, contentType));
    if (offerResult) {
      command.send200();
    } else {
      command.setResponse(HttpCommand.RES_503);
    } 
  }
  
  private void handleManagementCenterUrlChange(HttpPostCommand command) {
    byte[] res;
    HazelcastProperties properties = this.textCommandService.getNode().getProperties();
    if (!properties.getBoolean(GroupProperty.MC_URL_CHANGE_ENABLED)) {
      this.logger.warning("Hazelcast property " + GroupProperty.MC_URL_CHANGE_ENABLED.getName() + " is deprecated.");
      command.setResponse(HttpCommand.RES_503);
      return;
    } 
    String[] strList = StringUtil.bytesToString(command.getData()).split("&");
    if (authenticate(command, strList[0], (strList.length > 1) ? strList[1] : null)) {
      ManagementCenterService managementCenterService = this.textCommandService.getNode().getManagementCenterService();
      if (managementCenterService != null) {
        String url = URLDecoder.decode(strList[2], "UTF-8");
        res = managementCenterService.clusterWideUpdateManagementCenterUrl(url);
      } else {
        this.logger.warning("Unable to change URL of ManagementCenter as the ManagementCenterService is not running on this member.");
        res = HttpCommand.RES_204;
      } 
    } else {
      res = HttpCommand.RES_403;
    } 
    command.setResponse(res);
  }
  
  private void handleMap(HttpPostCommand command, String uri) {
    int indexEnd = uri.indexOf('/', "/hazelcast/rest/maps/".length());
    String mapName = uri.substring("/hazelcast/rest/maps/".length(), indexEnd);
    String key = uri.substring(indexEnd + 1);
    byte[] data = command.getData();
    this.textCommandService.put(mapName, key, new RestValue(data, command.getContentType()), -1);
    command.send200();
  }
  
  private void handleWanSyncMap(HttpPostCommand command) {
    String res, params[] = decodeParams(command, 3);
    String wanRepName = params[0];
    String publisherId = params[1];
    String mapName = params[2];
    try {
      this.textCommandService.getNode().getNodeEngine().getWanReplicationService().syncMap(wanRepName, publisherId, mapName);
      res = response(ResponseType.SUCCESS, new Object[] { "message", "Sync initiated" });
    } catch (Exception ex) {
      this.logger.warning("Error occurred while syncing map", ex);
      res = exceptionResponse(ex);
    } 
    sendResponse(command, res);
  }
  
  private void handleWanSyncAllMaps(HttpPostCommand command) {
    String res, params[] = decodeParams(command, 2);
    String wanRepName = params[0];
    String publisherId = params[1];
    try {
      this.textCommandService.getNode().getNodeEngine().getWanReplicationService().syncAllMaps(wanRepName, publisherId);
      res = response(ResponseType.SUCCESS, new Object[] { "message", "Sync initiated" });
    } catch (Exception ex) {
      this.logger.warning("Error occurred while syncing maps", ex);
      res = exceptionResponse(ex);
    } 
    sendResponse(command, res);
  }
  
  private void handleWanConsistencyCheck(HttpPostCommand command) {
    String res, params[] = decodeParams(command, 3);
    String wanReplicationName = params[0];
    String publisherId = params[1];
    String mapName = params[2];
    WanReplicationService service = this.textCommandService.getNode().getNodeEngine().getWanReplicationService();
    try {
      service.consistencyCheck(wanReplicationName, publisherId, mapName);
      res = response(ResponseType.SUCCESS, new Object[] { "message", "Consistency check initiated" });
    } catch (Exception ex) {
      this.logger.warning("Error occurred while initiating consistency check", ex);
      res = exceptionResponse(ex);
    } 
    sendResponse(command, res);
  }
  
  private void handleWanClearQueues(HttpPostCommand command) {
    String res, params[] = decodeParams(command, 2);
    String wanRepName = params[0];
    String publisherId = params[1];
    try {
      this.textCommandService.getNode().getNodeEngine().getWanReplicationService().clearQueues(wanRepName, publisherId);
      res = response(ResponseType.SUCCESS, new Object[] { "message", "WAN replication queues are cleared." });
    } catch (Exception ex) {
      this.logger.warning("Error occurred while clearing queues", ex);
      res = exceptionResponse(ex);
    } 
    sendResponse(command, res);
  }
  
  private void handleAddWanConfig(HttpPostCommand command) {
    String res, params[] = decodeParams(command, 1);
    String wanConfigJson = params[0];
    try {
      WanReplicationConfigDTO dto = new WanReplicationConfigDTO(new WanReplicationConfig());
      dto.fromJson(Json.parse(wanConfigJson).asObject());
      AddWanConfigResult result = this.textCommandService.getNode().getNodeEngine().getWanReplicationService().addWanReplicationConfig(dto.getConfig());
      res = response(ResponseType.SUCCESS, new Object[] { "message", "WAN configuration added.", "addedPublisherIds", result
            
            .getAddedPublisherIds(), "ignoredPublisherIds", result
            .getIgnoredPublisherIds() });
    } catch (Exception ex) {
      this.logger.warning("Error occurred while adding WAN config", ex);
      res = exceptionResponse(ex);
    } 
    command.setResponse(HttpCommand.CONTENT_TYPE_JSON, StringUtil.stringToBytes(res));
  }
  
  private void handleWanPausePublisher(HttpPostCommand command) {
    String res, params[] = decodeParams(command, 2);
    String wanReplicationName = params[0];
    String publisherId = params[1];
    WanReplicationService service = this.textCommandService.getNode().getNodeEngine().getWanReplicationService();
    try {
      service.pause(wanReplicationName, publisherId);
      res = response(ResponseType.SUCCESS, new Object[] { "message", "WAN publisher paused" });
    } catch (Exception ex) {
      this.logger.warning("Error occurred while pausing WAN publisher", ex);
      res = exceptionResponse(ex);
    } 
    sendResponse(command, res);
  }
  
  private void handleWanStopPublisher(HttpPostCommand command) {
    String res, params[] = decodeParams(command, 2);
    String wanReplicationName = params[0];
    String publisherId = params[1];
    WanReplicationService service = this.textCommandService.getNode().getNodeEngine().getWanReplicationService();
    try {
      service.stop(wanReplicationName, publisherId);
      res = response(ResponseType.SUCCESS, new Object[] { "message", "WAN publisher stopped" });
    } catch (Exception ex) {
      this.logger.warning("Error occurred while stopping WAN publisher", ex);
      res = exceptionResponse(ex);
    } 
    sendResponse(command, res);
  }
  
  private void handleWanResumePublisher(HttpPostCommand command) {
    String res, params[] = decodeParams(command, 2);
    String wanReplicationName = params[0];
    String publisherId = params[1];
    WanReplicationService service = this.textCommandService.getNode().getNodeEngine().getWanReplicationService();
    try {
      service.resume(wanReplicationName, publisherId);
      res = response(ResponseType.SUCCESS, new Object[] { "message", "WAN publisher resumed" });
    } catch (Exception ex) {
      this.logger.warning("Error occurred while resuming WAN publisher", ex);
      res = exceptionResponse(ex);
    } 
    sendResponse(command, res);
  }
  
  private void handleUpdatePermissions(HttpPostCommand command) {
    String res = response(ResponseType.FORBIDDEN, new Object[0]);
    command.setResponse(HttpCommand.CONTENT_TYPE_JSON, StringUtil.stringToBytes(res));
  }
  
  private void handleCPMember(HttpPostCommand command) {
    if (!checkCredentials(command)) {
      command.send403();
      this.textCommandService.sendResponse(command);
      return;
    } 
    String uri = command.getURI();
    if (uri.endsWith("/remove") || uri.endsWith("/remove/")) {
      handleRemoveCPMember(command);
    } else {
      handlePromoteToCPMember(command);
    } 
  }
  
  private void handlePromoteToCPMember(HttpPostCommand command) {
    if (getCpSubsystem().getLocalCPMember() != null) {
      command.send200();
      this.textCommandService.sendResponse(command);
      return;
    } 
    getCpSubsystemManagementService().promoteToCPMember()
      .andThen(new Object(this, command));
  }
  
  private void handleRemoveCPMember(HttpPostCommand command) {
    String uri = command.getURI();
    String prefix = "/hazelcast/rest/cp-subsystem/members/";
    String cpMemberUid = uri.substring(prefix.length(), uri.indexOf('/', prefix.length())).trim();
    getCpSubsystem().getCPSubsystemManagementService()
      .removeCPMember(cpMemberUid)
      .andThen(new Object(this, command, cpMemberUid));
  }
  
  private void handleCPGroup(HttpPostCommand command) {
    if (!checkCredentials(command)) {
      command.send403();
      this.textCommandService.sendResponse(command);
      return;
    } 
    String uri = command.getURI();
    if (!uri.endsWith("/remove") && !uri.endsWith("/remove/")) {
      command.send404();
      this.textCommandService.sendResponse(command);
      return;
    } 
    if (uri.contains("/sessions")) {
      handleForceCloseCPSession(command);
    } else {
      handleForceDestroyCPGroup(command);
    } 
  }
  
  private void handleForceCloseCPSession(HttpPostCommand command) {
    String uri = command.getURI();
    String prefix = "/hazelcast/rest/cp-subsystem/groups/";
    String suffix = "/sessions/";
    int i = uri.indexOf(suffix);
    String groupName = uri.substring(prefix.length(), i).trim();
    long sessionId = Long.parseLong(uri.substring(i + suffix.length(), uri.indexOf('/', i + suffix.length())));
    getCpSubsystem().getCPSessionManagementService()
      .forceCloseSession(groupName, sessionId)
      .andThen(new Object(this, command));
  }
  
  private void handleForceDestroyCPGroup(HttpPostCommand command) {
    String uri = command.getURI();
    String prefix = "/hazelcast/rest/cp-subsystem/groups/";
    String groupName = uri.substring(prefix.length(), uri.indexOf('/', prefix.length())).trim();
    if ("METADATA".equals(groupName)) {
      command.send400();
      this.textCommandService.sendResponse(command);
      return;
    } 
    getCpSubsystem().getCPSubsystemManagementService()
      .forceDestroyCPGroup(groupName)
      .andThen(new Object(this, command, groupName));
  }
  
  private void handleResetAndInitCPSubsystem(HttpPostCommand command) {
    if (checkCredentials(command)) {
      getCpSubsystem().getCPSubsystemManagementService()
        .restart()
        .andThen(new Object(this, command));
    } else {
      command.send403();
      this.textCommandService.sendResponse(command);
    } 
  }
  
  private CPSubsystemManagementService getCpSubsystemManagementService() { return getCpSubsystem().getCPSubsystemManagementService(); }
  
  private CPSubsystem getCpSubsystem() { return this.textCommandService.getNode().getNodeEngine().getHazelcastInstance().getCPSubsystem(); }
  
  protected static String exceptionResponse(Throwable throwable) { return response(ResponseType.FAIL, new Object[] { "message", throwable.getMessage() }); }
  
  protected static String response(ResponseType type, Object... attributes) {
    StringBuilder builder = new StringBuilder("{");
    builder.append("\"status\":\"").append(type).append("\"");
    if (attributes.length > 0)
      for (int i = 0; i < attributes.length; ) {
        String key = attributes[i++].toString();
        Object value = attributes[i++];
        if (value != null)
          builder.append(String.format(",\"%s\":%s", new Object[] { key, JsonUtil.toJson(value) })); 
      }  
    return builder.append("}").toString();
  }
  
  private static String[] decodeParams(HttpPostCommand command, int paramCount) throws UnsupportedEncodingException {
    byte[] data = command.getData();
    String[] encoded = StringUtil.bytesToString(data).split("&");
    String[] decoded = new String[encoded.length];
    for (int i = 0; i < paramCount; i++)
      decoded[i] = URLDecoder.decode(encoded[i], "UTF-8"); 
    return decoded;
  }
  
  private boolean checkCredentials(HttpPostCommand command) throws UnsupportedEncodingException {
    byte[] data = command.getData();
    if (data == null)
      return false; 
    String[] strList = StringUtil.bytesToString(data).split("&", -1);
    return authenticate(command, strList[0], (strList.length > 1) ? strList[1] : null);
  }
  
  protected boolean authenticate(HttpPostCommand command, String groupName, String pass) throws UnsupportedEncodingException {
    String decodedName = URLDecoder.decode(groupName, "UTF-8");
    SecurityContext securityContext = this.textCommandService.getNode().getNodeExtension().getSecurityContext();
    if (securityContext == null) {
      GroupConfig groupConfig = this.textCommandService.getNode().getConfig().getGroupConfig();
      if (pass != null && !pass.isEmpty())
        this.logger.fine("Password was provided but the Hazelcast Security is disabled."); 
      return groupConfig.getName().equals(decodedName);
    } 
    if (pass == null) {
      this.logger.fine("Empty password is not allowed when the Hazelcast Security is enabled.");
      return false;
    } 
    String decodedPass = URLDecoder.decode(pass, "UTF-8");
    UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(groupName, decodedPass);
    try {
      LoginContext lc = securityContext.createMemberLoginContext(credentials);
      lc.login();
    } catch (LoginException e) {
      return false;
    } 
    return true;
  }
  
  protected void sendResponse(HttpPostCommand command, String value) {
    command.setResponse(HttpCommand.CONTENT_TYPE_JSON, StringUtil.stringToBytes(value));
    this.textCommandService.sendResponse(command);
  }
  
  public void handleRejection(HttpPostCommand command) { handle(command); }
  
  private void handleSetLicense(HttpPostCommand command) {
    String res;
    int retryCount = 100;
    byte[] data = command.getData();
    try {
      String[] strList = StringUtil.bytesToString(data).split("&");
      if (authenticate(command, strList[0], (strList.length > 1) ? strList[1] : null)) {
        String licenseKey = (strList.length > 2) ? URLDecoder.decode(strList[2], "UTF-8") : null;
        InvocationUtil.invokeOnStableClusterSerial((this.textCommandService.getNode()).nodeEngine, new Object(this, licenseKey), 100)



          
          .get();
        res = responseOnSetLicenseSuccess();
      } else {
        res = response(ResponseType.FORBIDDEN, new Object[0]);
      } 
    } catch (Throwable throwable) {
      this.logger.warning("Error occurred while updating the license", throwable);
      res = exceptionResponse(throwable);
    } 
    command.setResponse(HttpCommand.CONTENT_TYPE_JSON, StringUtil.stringToBytes(res));
  }
  
  protected String responseOnSetLicenseSuccess() { return response(ResponseType.SUCCESS, new Object[0]); }
}
