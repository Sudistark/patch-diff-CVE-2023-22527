package com.hazelcast.internal.ascii;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import com.hazelcast.instance.EndpointQualifier;
import com.hazelcast.instance.Node;
import com.hazelcast.internal.ascii.memcache.BulkGetCommandProcessor;
import com.hazelcast.internal.ascii.memcache.DeleteCommandProcessor;
import com.hazelcast.internal.ascii.memcache.EntryConverter;
import com.hazelcast.internal.ascii.memcache.ErrorCommandProcessor;
import com.hazelcast.internal.ascii.memcache.GetCommandProcessor;
import com.hazelcast.internal.ascii.memcache.IncrementCommandProcessor;
import com.hazelcast.internal.ascii.memcache.SetCommandProcessor;
import com.hazelcast.internal.ascii.memcache.SimpleCommandProcessor;
import com.hazelcast.internal.ascii.memcache.Stats;
import com.hazelcast.internal.ascii.memcache.StatsCommandProcessor;
import com.hazelcast.internal.ascii.memcache.TouchCommandProcessor;
import com.hazelcast.internal.ascii.memcache.VersionCommandProcessor;
import com.hazelcast.internal.ascii.rest.HttpDeleteCommandProcessor;
import com.hazelcast.internal.ascii.rest.HttpGetCommandProcessor;
import com.hazelcast.internal.ascii.rest.HttpHeadCommandProcessor;
import com.hazelcast.internal.ascii.rest.HttpPostCommandProcessor;
import com.hazelcast.internal.ascii.rest.RestValue;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.AggregateEndpointManager;
import com.hazelcast.nio.EndpointManager;
import com.hazelcast.nio.NetworkingService;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.util.Clock;
import com.hazelcast.util.ThreadUtil;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

public class TextCommandServiceImpl implements TextCommandService {
  private static final int TEXT_COMMAND_PROCESSOR_SIZE = 100;
  
  private static final int MILLIS_TO_SECONDS = 1000;
  
  private static final long WAIT_TIME = 1000L;
  
  private final TextCommandProcessor[] textCommandProcessors;
  
  private final AtomicLong sets;
  
  private final AtomicLong touches;
  
  private final AtomicLong getHits;
  
  private final AtomicLong getMisses;
  
  private final AtomicLong deleteMisses;
  
  private final AtomicLong deleteHits;
  
  private final AtomicLong incrementHits;
  
  private final AtomicLong incrementMisses;
  
  private final AtomicLong decrementHits;
  
  private final AtomicLong decrementMisses;
  
  private final long startTime;
  
  private final Node node;
  
  private final HazelcastInstance hazelcast;
  
  private final ILogger logger;
  
  private final Object mutex;
  
  public TextCommandServiceImpl(Node node) {
    this.textCommandProcessors = new TextCommandProcessor[100];
    this.sets = new AtomicLong();
    this.touches = new AtomicLong();
    this.getHits = new AtomicLong();
    this.getMisses = new AtomicLong();
    this.deleteMisses = new AtomicLong();
    this.deleteHits = new AtomicLong();
    this.incrementHits = new AtomicLong();
    this.incrementMisses = new AtomicLong();
    this.decrementHits = new AtomicLong();
    this.decrementMisses = new AtomicLong();
    this.startTime = Clock.currentTimeMillis();
    this.running = true;
    this.mutex = new Object();
    this.node = node;
    this.hazelcast = node.hazelcastInstance;
    this.logger = node.getLogger(getClass().getName());
    EntryConverter entryConverter = new EntryConverter(this, node.getLogger(EntryConverter.class));
    register(TextCommandConstants.TextCommandType.GET, new GetCommandProcessor(this, entryConverter));
    register(TextCommandConstants.TextCommandType.BULK_GET, new BulkGetCommandProcessor(this, entryConverter));
    register(TextCommandConstants.TextCommandType.SET, new SetCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.APPEND, new SetCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.PREPEND, new SetCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.ADD, new SetCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.REPLACE, new SetCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.GET_END, new NoOpCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.DELETE, new DeleteCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.QUIT, new SimpleCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.STATS, new StatsCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.UNKNOWN, new ErrorCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.VERSION, new VersionCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.TOUCH, new TouchCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.INCREMENT, new IncrementCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.DECREMENT, new IncrementCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.ERROR_CLIENT, new ErrorCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.ERROR_SERVER, new ErrorCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.HTTP_GET, new HttpGetCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.HTTP_POST, new HttpPostCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.HTTP_PUT, new HttpPostCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.HTTP_DELETE, new HttpDeleteCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.HTTP_HEAD, new HttpHeadCommandProcessor(this));
    register(TextCommandConstants.TextCommandType.NO_OP, new NoOpCommandProcessor(this));
  }
  
  protected void register(TextCommandConstants.TextCommandType type, TextCommandProcessor processor) { this.textCommandProcessors[type.getValue()] = processor; }
  
  public Node getNode() { return this.node; }
  
  public byte[] toByteArray(Object value) {
    Data data = this.node.getSerializationService().toData(value);
    return data.toByteArray();
  }
  
  public Stats getStats() {
    Stats stats = new Stats();
    stats.setUptime((int)((Clock.currentTimeMillis() - this.startTime) / 1000L));
    stats.setCmdGet(this.getMisses.get() + this.getHits.get());
    stats.setCmdSet(this.sets.get());
    stats.setCmdTouch(this.touches.get());
    stats.setGetHits(this.getHits.get());
    stats.setGetMisses(this.getMisses.get());
    stats.setDeleteHits(this.deleteHits.get());
    stats.setDeleteMisses(this.deleteMisses.get());
    stats.setIncrHits(this.incrementHits.get());
    stats.setIncrMisses(this.incrementMisses.get());
    stats.setDecrHits(this.decrementHits.get());
    stats.setDecrMisses(this.decrementMisses.get());
    NetworkingService cm = this.node.networkingService;
    EndpointManager mem = cm.getEndpointManager(EndpointQualifier.MEMCACHE);
    int totalText = (mem != null) ? mem.getActiveConnections().size() : 0;
    AggregateEndpointManager aem = cm.getAggregateEndpointManager();
    stats.setCurrConnections(totalText);
    stats.setTotalConnections(aem.getActiveConnections().size());
    return stats;
  }
  
  public long incrementDeleteHitCount(int inc) { return this.deleteHits.addAndGet(inc); }
  
  public long incrementDeleteMissCount() { return this.deleteMisses.incrementAndGet(); }
  
  public long incrementGetHitCount() { return this.getHits.incrementAndGet(); }
  
  public long incrementGetMissCount() { return this.getMisses.incrementAndGet(); }
  
  public long incrementSetCount() { return this.sets.incrementAndGet(); }
  
  public long incrementIncHitCount() { return this.incrementHits.incrementAndGet(); }
  
  public long incrementIncMissCount() { return this.incrementMisses.incrementAndGet(); }
  
  public long incrementDecrHitCount() { return this.decrementHits.incrementAndGet(); }
  
  public long incrementDecrMissCount() { return this.decrementMisses.incrementAndGet(); }
  
  public long incrementTouchCount() { return this.touches.incrementAndGet(); }
  
  public void processRequest(TextCommand command) {
    startResponseThreadIfNotRunning();
    this.node.nodeEngine.getExecutionService().execute("hz:text", new CommandExecutor(this, command));
  }
  
  private void startResponseThreadIfNotRunning() {
    if (this.responseThreadRunnable == null)
      synchronized (this.mutex) {
        if (this.responseThreadRunnable == null) {
          this.responseThreadRunnable = new ResponseThreadRunnable(this, null);
          String threadNamePrefix = ThreadUtil.createThreadName(this.hazelcast.getName(), "ascii.service.response");
          Thread thread = new Thread(this.responseThreadRunnable, threadNamePrefix);
          thread.start();
        } 
      }  
  }
  
  public Object get(String mapName, String key) { return this.hazelcast.getMap(mapName).get(key); }
  
  public Map<String, Object> getAll(String mapName, Set<String> keys) {
    IMap<String, Object> map = this.hazelcast.getMap(mapName);
    return map.getAll(keys);
  }
  
  public int getAdjustedTTLSeconds(int ttl) {
    if (ttl <= TextCommandConstants.getMonthSeconds())
      return ttl; 
    return ttl - (int)TimeUnit.MILLISECONDS.toSeconds(Clock.currentTimeMillis());
  }
  
  public byte[] getByteArray(String mapName, String key) {
    Object value = this.hazelcast.getMap(mapName).get(key);
    byte[] result = null;
    if (value != null)
      if (value instanceof RestValue) {
        RestValue restValue = (RestValue)value;
        result = restValue.getValue();
      } else if (value instanceof byte[]) {
        result = (byte[])value;
      } else {
        result = toByteArray(value);
      }  
    return result;
  }
  
  public Object put(String mapName, String key, Object value) { return this.hazelcast.getMap(mapName).put(key, value); }
  
  public Object put(String mapName, String key, Object value, int ttlSeconds) { return this.hazelcast.getMap(mapName).put(key, value, ttlSeconds, TimeUnit.SECONDS); }
  
  public Object putIfAbsent(String mapName, String key, Object value, int ttlSeconds) { return this.hazelcast.getMap(mapName).putIfAbsent(key, value, ttlSeconds, TimeUnit.SECONDS); }
  
  public Object replace(String mapName, String key, Object value) { return this.hazelcast.getMap(mapName).replace(key, value); }
  
  public void lock(String mapName, String key) throws InterruptedException {
    if (!this.hazelcast.getMap(mapName).tryLock(key, 1L, TimeUnit.MINUTES))
      throw new RuntimeException("Memcache client could not get the lock for map: " + mapName + ", key: " + key + " in 1 minute"); 
  }
  
  public void unlock(String mapName, String key) throws InterruptedException { this.hazelcast.getMap(mapName).unlock(key); }
  
  public void deleteAll(String mapName) {
    IMap<Object, Object> map = this.hazelcast.getMap(mapName);
    map.clear();
  }
  
  public Object delete(String mapName, String key) { return this.hazelcast.getMap(mapName).remove(key); }
  
  public boolean offer(String queueName, Object value) { return this.hazelcast.getQueue(queueName).offer(value); }
  
  public Object poll(String queueName, int seconds) {
    try {
      return this.hazelcast.getQueue(queueName).poll(seconds, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      return null;
    } 
  }
  
  public Object poll(String queueName) { return this.hazelcast.getQueue(queueName).poll(); }
  
  public int size(String queueName) { return this.hazelcast.getQueue(queueName).size(); }
  
  public void sendResponse(TextCommand textCommand) {
    if (!textCommand.shouldReply() || textCommand.getRequestId() == -1L)
      throw new RuntimeException("Shouldn't reply " + textCommand); 
    this.responseThreadRunnable.sendResponse(textCommand);
  }
  
  public void stop() {
    ResponseThreadRunnable rtr = this.responseThreadRunnable;
    if (rtr != null) {
      this.logger.info("Stopping text command service...");
      rtr.stop();
    } 
  }
}
