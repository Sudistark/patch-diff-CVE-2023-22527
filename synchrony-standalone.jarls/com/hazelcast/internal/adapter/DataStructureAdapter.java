package com.hazelcast.internal.adapter;

import com.hazelcast.core.ICompletableFuture;
import com.hazelcast.map.EntryProcessor;
import com.hazelcast.monitor.LocalMapStats;
import com.hazelcast.query.Predicate;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import javax.cache.expiry.ExpiryPolicy;
import javax.cache.integration.CompletionListener;
import javax.cache.processor.EntryProcessor;
import javax.cache.processor.EntryProcessorException;
import javax.cache.processor.EntryProcessorResult;

public interface DataStructureAdapter<K, V> {
  int size();
  
  V get(K paramK);
  
  ICompletableFuture<V> getAsync(K paramK);
  
  void set(K paramK, V paramV);
  
  ICompletableFuture<Void> setAsync(K paramK, V paramV);
  
  ICompletableFuture<Void> setAsync(K paramK, V paramV, long paramLong, TimeUnit paramTimeUnit);
  
  ICompletableFuture<Void> setAsync(K paramK, V paramV, ExpiryPolicy paramExpiryPolicy);
  
  V put(K paramK, V paramV);
  
  ICompletableFuture<V> putAsync(K paramK, V paramV);
  
  ICompletableFuture<V> putAsync(K paramK, V paramV, long paramLong, TimeUnit paramTimeUnit);
  
  ICompletableFuture<V> putAsync(K paramK, V paramV, ExpiryPolicy paramExpiryPolicy);
  
  void putTransient(K paramK, V paramV, long paramLong, TimeUnit paramTimeUnit);
  
  boolean putIfAbsent(K paramK, V paramV);
  
  ICompletableFuture<Boolean> putIfAbsentAsync(K paramK, V paramV);
  
  void setTtl(K paramK, long paramLong, TimeUnit paramTimeUnit);
  
  V replace(K paramK, V paramV);
  
  boolean replace(K paramK, V paramV1, V paramV2);
  
  V remove(K paramK);
  
  boolean remove(K paramK, V paramV);
  
  ICompletableFuture<V> removeAsync(K paramK);
  
  void delete(K paramK);
  
  ICompletableFuture<Boolean> deleteAsync(K paramK);
  
  boolean evict(K paramK);
  
  <T> T invoke(K paramK, EntryProcessor<K, V, T> paramEntryProcessor, Object... paramVarArgs) throws EntryProcessorException;
  
  Object executeOnKey(K paramK, EntryProcessor paramEntryProcessor);
  
  Map<K, Object> executeOnKeys(Set<K> paramSet, EntryProcessor paramEntryProcessor);
  
  Map<K, Object> executeOnEntries(EntryProcessor paramEntryProcessor);
  
  Map<K, Object> executeOnEntries(EntryProcessor paramEntryProcessor, Predicate paramPredicate);
  
  boolean containsKey(K paramK);
  
  void loadAll(boolean paramBoolean);
  
  void loadAll(Set<K> paramSet, boolean paramBoolean);
  
  void loadAll(Set<? extends K> paramSet, boolean paramBoolean, CompletionListener paramCompletionListener);
  
  Map<K, V> getAll(Set<K> paramSet);
  
  void putAll(Map<K, V> paramMap);
  
  void removeAll();
  
  void removeAll(Set<K> paramSet);
  
  void evictAll();
  
  <T> Map<K, EntryProcessorResult<T>> invokeAll(Set<? extends K> paramSet, EntryProcessor<K, V, T> paramEntryProcessor, Object... paramVarArgs);
  
  void clear();
  
  void close();
  
  void destroy();
  
  void setExpiryPolicy(Set<K> paramSet, ExpiryPolicy paramExpiryPolicy);
  
  boolean setExpiryPolicy(K paramK, ExpiryPolicy paramExpiryPolicy);
  
  LocalMapStats getLocalMapStats();
}
