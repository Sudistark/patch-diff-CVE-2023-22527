package com.hazelcast.internal.metrics.impl;

import com.hazelcast.internal.metrics.Probe;
import com.hazelcast.internal.metrics.ProbeFunction;
import com.hazelcast.util.StringUtil;
import java.lang.reflect.Method;

abstract class MethodProbe implements ProbeFunction {
  private static final Object[] EMPTY_ARGS = new Object[0];
  
  final Method method;
  
  final Probe probe;
  
  final int type;
  
  MethodProbe(Method method, Probe probe, int type) {
    this.method = method;
    this.probe = probe;
    this.type = type;
    method.setAccessible(true);
  }
  
  void register(MetricsRegistryImpl metricsRegistry, Object source, String namePrefix) {
    String name = namePrefix + '.' + getProbeOrMethodName();
    metricsRegistry.registerInternal(source, name, this.probe.level(), this);
  }
  
  void register(ProbeBuilderImpl builder, Object source) { builder
      .withTag("unit", this.probe.unit().name().toLowerCase())
      .register(source, getProbeOrMethodName(), this.probe.level(), this); }
  
  private String getProbeOrMethodName() {
    return (this.probe.name().length() != 0) ? this.probe
      .name() : 
      StringUtil.getterIntoProperty(this.method.getName());
  }
  
  static <S> MethodProbe createMethodProbe(Method method, Probe probe) {
    int type = ProbeUtils.getType(method.getReturnType());
    if (type == -1)
      throw new IllegalArgumentException(String.format("@Probe method '%s.%s() has an unsupported return type'", new Object[] { method
              .getDeclaringClass().getName(), method.getName() })); 
    if (method.getParameterTypes().length != 0)
      throw new IllegalArgumentException(String.format("@Probe method '%s.%s' can't have arguments", new Object[] { method
              .getDeclaringClass().getName(), method.getName() })); 
    if (ProbeUtils.isDouble(type))
      return new DoubleMethodProbe(method, probe, type); 
    return new LongMethodProbe(method, probe, type);
  }
}
