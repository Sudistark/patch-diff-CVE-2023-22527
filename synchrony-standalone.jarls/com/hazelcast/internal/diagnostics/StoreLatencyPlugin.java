package com.hazelcast.internal.diagnostics;

import com.hazelcast.logging.ILogger;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.properties.HazelcastProperties;
import com.hazelcast.spi.properties.HazelcastProperty;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;

public class StoreLatencyPlugin extends DiagnosticsPlugin {
  public static final HazelcastProperty PERIOD_SECONDS = new HazelcastProperty("hazelcast.diagnostics.storeLatency.period.seconds", 
      Integer.valueOf(0), TimeUnit.SECONDS);
  
  public static final HazelcastProperty RESET_PERIOD_SECONDS = new HazelcastProperty("hazelcast.diagnostics.storeLatency.reset.period.seconds", 
      Integer.valueOf(0), TimeUnit.SECONDS);
  
  private static final int LOW_WATERMARK_MICROS = 100;
  
  private static final int LATENCY_BUCKET_COUNT = 32;
  
  private static final String[] LATENCY_KEYS = new String[32];
  
  static  {
    maxDurationForBucket = 100L;
    long p = 0L;
    for (int k = 0; k < LATENCY_KEYS.length; k++) {
      LATENCY_KEYS[k] = p + ".." + (maxDurationForBucket - 1L) + "us";
      p = maxDurationForBucket;
      maxDurationForBucket *= 2L;
    } 
  }
  
  private final ConcurrentMap<String, ServiceProbes> metricsPerServiceMap = new ConcurrentHashMap();
  
  private final ConstructorFunction<String, ServiceProbes> metricsPerServiceConstructorFunction = new Object(this);
  
  private final ConstructorFunction<String, InstanceProbes> instanceProbesConstructorFunction = new Object(this);
  
  private final long periodMillis;
  
  private final long resetPeriodMillis;
  
  private final long resetFrequency;
  
  private long iteration;
  
  public StoreLatencyPlugin(NodeEngineImpl nodeEngine) { this(nodeEngine.getLogger(StoreLatencyPlugin.class), nodeEngine.getProperties()); }
  
  public StoreLatencyPlugin(ILogger logger, HazelcastProperties properties) {
    super(logger);
    this.periodMillis = properties.getMillis(PERIOD_SECONDS);
    this.resetPeriodMillis = properties.getMillis(RESET_PERIOD_SECONDS);
    if (this.periodMillis == 0L || this.resetPeriodMillis == 0L) {
      this.resetFrequency = 0L;
    } else {
      this.resetFrequency = Math.max(1L, this.resetPeriodMillis / this.periodMillis);
    } 
  }
  
  public long getPeriodMillis() { return this.periodMillis; }
  
  public void onStart() { this.logger.info("Plugin:active: period-millis:" + this.periodMillis + " resetPeriod-millis:" + this.resetPeriodMillis); }
  
  public void run(DiagnosticsLogWriter writer) {
    this.iteration++;
    render(writer);
    resetStatisticsIfNeeded();
  }
  
  private void render(DiagnosticsLogWriter writer) {
    for (ServiceProbes serviceProbes : this.metricsPerServiceMap.values())
      ServiceProbes.access$100(serviceProbes, writer); 
  }
  
  private void resetStatisticsIfNeeded() {
    if (this.resetFrequency > 0L && this.iteration % this.resetFrequency == 0L)
      for (ServiceProbes serviceProbes : this.metricsPerServiceMap.values())
        ServiceProbes.access$200(serviceProbes);  
  }
  
  public long count(String serviceName, String dataStructureName, String methodName) { return ((LatencyProbeImpl)newProbe(serviceName, dataStructureName, methodName)).stats.count; }
  
  public LatencyProbe newProbe(String serviceName, String dataStructureName, String methodName) {
    ServiceProbes serviceProbes = (ServiceProbes)ConcurrencyUtil.getOrPutIfAbsent(this.metricsPerServiceMap, serviceName, this.metricsPerServiceConstructorFunction);
    return ServiceProbes.access$300(serviceProbes, dataStructureName, methodName);
  }
}
