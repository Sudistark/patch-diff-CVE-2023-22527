package com.hazelcast.internal.serialization.impl;

import com.hazelcast.core.HazelcastInstanceNotActiveException;
import com.hazelcast.core.ManagedContext;
import com.hazelcast.core.PartitioningStrategy;
import com.hazelcast.internal.serialization.InputOutputFactory;
import com.hazelcast.internal.serialization.InternalSerializationService;
import com.hazelcast.internal.serialization.impl.bufferpool.BufferPool;
import com.hazelcast.internal.serialization.impl.bufferpool.BufferPoolThreadLocal;
import com.hazelcast.internal.usercodedeployment.impl.ClassLocator;
import com.hazelcast.logging.ILogger;
import com.hazelcast.logging.Logger;
import com.hazelcast.nio.BufferObjectDataInput;
import com.hazelcast.nio.BufferObjectDataOutput;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.nio.serialization.HazelcastSerializationException;
import com.hazelcast.nio.serialization.Serializer;
import com.hazelcast.util.Preconditions;
import java.nio.ByteOrder;
import java.util.IdentityHashMap;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicReference;

public abstract class AbstractSerializationService implements InternalSerializationService {
  protected final ManagedContext managedContext;
  
  protected final InputOutputFactory inputOutputFactory;
  
  protected final PartitioningStrategy globalPartitioningStrategy;
  
  protected final BufferPoolThreadLocal bufferPoolThreadLocal;
  
  protected SerializerAdapter dataSerializerAdapter;
  
  protected SerializerAdapter portableSerializerAdapter;
  
  protected final SerializerAdapter nullSerializerAdapter;
  
  protected SerializerAdapter javaSerializerAdapter;
  
  protected SerializerAdapter javaExternalizableAdapter;
  
  private final IdentityHashMap<Class, SerializerAdapter> constantTypesMap;
  
  private final SerializerAdapter[] constantTypeIds;
  
  private final ConcurrentMap<Class, SerializerAdapter> typeMap;
  
  private final ConcurrentMap<Integer, SerializerAdapter> idMap;
  
  private final AtomicReference<SerializerAdapter> global;
  
  private boolean overrideJavaSerialization;
  
  private final ClassLoader classLoader;
  
  private final int outputBufferSize;
  
  private final byte version;
  
  private final ILogger logger;
  
  AbstractSerializationService(Builder<?> builder) {
    this.constantTypesMap = new IdentityHashMap(28);
    this.constantTypeIds = new SerializerAdapter[28];
    this.typeMap = new ConcurrentHashMap();
    this.idMap = new ConcurrentHashMap();
    this.global = new AtomicReference();
    this.active = true;
    this.logger = Logger.getLogger(InternalSerializationService.class);
    this.inputOutputFactory = Builder.access$000(builder);
    this.version = Builder.access$100(builder);
    this.classLoader = Builder.access$200(builder);
    this.managedContext = Builder.access$300(builder);
    this.globalPartitioningStrategy = Builder.access$400(builder);
    this.outputBufferSize = Builder.access$500(builder);
    this
      .bufferPoolThreadLocal = new BufferPoolThreadLocal(this, Builder.access$600(builder), Builder.access$700(builder));
    this.nullSerializerAdapter = SerializationUtil.createSerializerAdapter(new ConstantSerializers.NullSerializer(), this);
  }
  
  public final <B extends Data> B toData(Object obj) { return (B)toData(obj, this.globalPartitioningStrategy); }
  
  public final <B extends Data> B toData(Object obj, PartitioningStrategy strategy) {
    if (obj == null)
      return null; 
    if (obj instanceof Data)
      return (B)(Data)obj; 
    byte[] bytes = toBytes(obj, 0, true, strategy);
    return (B)new HeapData(bytes);
  }
  
  public byte[] toBytes(Object obj) { return toBytes(obj, 0, true, this.globalPartitioningStrategy); }
  
  public byte[] toBytes(Object obj, int leftPadding, boolean insertPartitionHash) { return toBytes(obj, leftPadding, insertPartitionHash, this.globalPartitioningStrategy, getByteOrder()); }
  
  private byte[] toBytes(Object obj, int leftPadding, boolean writeHash, PartitioningStrategy strategy) { return toBytes(obj, leftPadding, writeHash, strategy, ByteOrder.BIG_ENDIAN); }
  
  private byte[] toBytes(Object obj, int leftPadding, boolean writeHash, PartitioningStrategy strategy, ByteOrder serializerTypeIdByteOrder) {
    Preconditions.checkNotNull(obj);
    Preconditions.checkNotNull(serializerTypeIdByteOrder);
    pool = this.bufferPoolThreadLocal.get();
    out = pool.takeOutputBuffer();
    try {
      out.position(leftPadding);
      SerializerAdapter serializer = serializerFor(obj);
      if (writeHash) {
        int partitionHash = calculatePartitionHash(obj, strategy);
        out.writeInt(partitionHash, ByteOrder.BIG_ENDIAN);
      } 
      out.writeInt(serializer.getTypeId(), serializerTypeIdByteOrder);
      serializer.write(out, obj);
      return out.toByteArray();
    } catch (Throwable e) {
      throw SerializationUtil.handleSerializeException(obj, e);
    } finally {
      pool.returnOutputBuffer(out);
    } 
  }
  
  public final <T> T toObject(Object object) {
    if (!(object instanceof Data))
      return (T)object; 
    Data data = (Data)object;
    if (SerializationUtil.isNullData(data))
      return null; 
    pool = this.bufferPoolThreadLocal.get();
    in = pool.takeInputBuffer(data);
    try {
      ClassLocator.onStartDeserialization();
      int typeId = data.getType();
      SerializerAdapter serializer = serializerFor(typeId);
      if (serializer == null) {
        if (this.active)
          throw newHazelcastSerializationException(typeId); 
        throw new HazelcastInstanceNotActiveException();
      } 
      Object obj = serializer.read(in);
      if (this.managedContext != null)
        obj = this.managedContext.initialize(obj); 
      object1 = obj;
      return (T)object1;
    } catch (Throwable e) {
      throw SerializationUtil.handleException(e);
    } finally {
      ClassLocator.onFinishDeserialization();
      pool.returnInputBuffer(in);
    } 
  }
  
  public final <T> T toObject(Object object, Class aClass) {
    if (!(object instanceof Data))
      return (T)object; 
    Data data = (Data)object;
    if (SerializationUtil.isNullData(data))
      return null; 
    pool = this.bufferPoolThreadLocal.get();
    in = pool.takeInputBuffer(data);
    try {
      ClassLocator.onStartDeserialization();
      int typeId = data.getType();
      SerializerAdapter serializer = serializerFor(typeId);
      if (serializer == null) {
        if (this.active)
          throw newHazelcastSerializationException(typeId); 
        throw new HazelcastInstanceNotActiveException();
      } 
      Object obj = serializer.read(in, aClass);
      if (this.managedContext != null)
        obj = this.managedContext.initialize(obj); 
      object1 = obj;
      return (T)object1;
    } catch (Throwable e) {
      throw SerializationUtil.handleException(e);
    } finally {
      ClassLocator.onFinishDeserialization();
      pool.returnInputBuffer(in);
    } 
  }
  
  private static HazelcastSerializationException newHazelcastSerializationException(int typeId) { return new HazelcastSerializationException("There is no suitable de-serializer for type " + typeId + ". This exception is likely to be caused by differences in the serialization configuration between members or between clients and members."); }
  
  public final void writeObject(ObjectDataOutput out, Object obj) {
    if (obj instanceof Data)
      throw new HazelcastSerializationException("Cannot write a Data instance! Use #writeData(ObjectDataOutput out, Data data) instead."); 
    try {
      SerializerAdapter serializer = serializerFor(obj);
      out.writeInt(serializer.getTypeId());
      serializer.write(out, obj);
    } catch (Throwable e) {
      throw SerializationUtil.handleSerializeException(obj, e);
    } 
  }
  
  public final <T> T readObject(ObjectDataInput in) {
    try {
      int typeId = in.readInt();
      SerializerAdapter serializer = serializerFor(typeId);
      if (serializer == null) {
        if (this.active)
          throw newHazelcastSerializationException(typeId); 
        throw new HazelcastInstanceNotActiveException();
      } 
      Object obj = serializer.read(in);
      if (this.managedContext != null)
        obj = this.managedContext.initialize(obj); 
      return (T)obj;
    } catch (Throwable e) {
      throw SerializationUtil.handleException(e);
    } 
  }
  
  public final <T> T readObject(ObjectDataInput in, Class aClass) {
    try {
      int typeId = in.readInt();
      SerializerAdapter serializer = serializerFor(typeId);
      if (serializer == null) {
        if (this.active)
          throw newHazelcastSerializationException(typeId); 
        throw new HazelcastInstanceNotActiveException();
      } 
      Object obj = serializer.read(in, aClass);
      if (this.managedContext != null)
        obj = this.managedContext.initialize(obj); 
      return (T)obj;
    } catch (Throwable e) {
      throw SerializationUtil.handleException(e);
    } 
  }
  
  public void disposeData(Data data) {}
  
  public final BufferObjectDataInput createObjectDataInput(byte[] data) { return this.inputOutputFactory.createInput(data, this); }
  
  public final BufferObjectDataInput createObjectDataInput(Data data) { return this.inputOutputFactory.createInput(data, this); }
  
  public final BufferObjectDataOutput createObjectDataOutput(int size) { return this.inputOutputFactory.createOutput(size, this); }
  
  public BufferObjectDataOutput createObjectDataOutput() { return this.inputOutputFactory.createOutput(this.outputBufferSize, this); }
  
  public final ClassLoader getClassLoader() { return this.classLoader; }
  
  public final ManagedContext getManagedContext() { return this.managedContext; }
  
  public ByteOrder getByteOrder() { return this.inputOutputFactory.getByteOrder(); }
  
  public byte getVersion() { return this.version; }
  
  public void dispose() {
    this.active = false;
    for (SerializerAdapter serializer : this.typeMap.values())
      serializer.destroy(); 
    for (SerializerAdapter serializer : this.constantTypesMap.values())
      serializer.destroy(); 
    this.typeMap.clear();
    this.idMap.clear();
    this.global.set(null);
    this.constantTypesMap.clear();
    this.bufferPoolThreadLocal.clear();
  }
  
  public final void register(Class type, Serializer serializer) {
    if (type == null)
      throw new IllegalArgumentException("Class type information is required!"); 
    if (serializer.getTypeId() <= 0)
      throw new IllegalArgumentException("Type ID must be positive! Current: " + serializer
          .getTypeId() + ", Serializer: " + serializer); 
    safeRegister(type, SerializationUtil.createSerializerAdapter(serializer, this));
  }
  
  public final void registerGlobal(Serializer serializer) { registerGlobal(serializer, false); }
  
  public final void registerGlobal(Serializer serializer, boolean overrideJavaSerialization) {
    SerializerAdapter adapter = SerializationUtil.createSerializerAdapter(serializer, this);
    if (!this.global.compareAndSet(null, adapter))
      throw new IllegalStateException("Global serializer is already registered!"); 
    this.overrideJavaSerialization = overrideJavaSerialization;
    SerializerAdapter current = (SerializerAdapter)this.idMap.putIfAbsent(Integer.valueOf(serializer.getTypeId()), adapter);
    if (current != null && current.getImpl().getClass() != adapter.getImpl().getClass()) {
      this.global.compareAndSet(adapter, null);
      this.overrideJavaSerialization = false;
      throw new IllegalStateException("Serializer [" + current
          .getImpl() + "] has been already registered for type-id: " + serializer.getTypeId());
    } 
  }
  
  protected final int calculatePartitionHash(Object obj, PartitioningStrategy strategy) {
    int partitionHash = 0;
    PartitioningStrategy partitioningStrategy = (strategy == null) ? this.globalPartitioningStrategy : strategy;
    if (partitioningStrategy != null) {
      Object pk = partitioningStrategy.getPartitionKey(obj);
      if (pk != null && pk != obj) {
        Data partitionKey = toData(pk, SerializationUtil.EMPTY_PARTITIONING_STRATEGY);
        partitionHash = (partitionKey == null) ? 0 : partitionKey.getPartitionHash();
      } 
    } 
    return partitionHash;
  }
  
  protected final boolean safeRegister(Class type, Serializer serializer) { return safeRegister(type, SerializationUtil.createSerializerAdapter(serializer, this)); }
  
  protected final boolean safeRegister(Class type, SerializerAdapter serializer) {
    if (this.constantTypesMap.containsKey(type))
      throw new IllegalArgumentException("[" + type + "] serializer cannot be overridden!"); 
    SerializerAdapter current = (SerializerAdapter)this.typeMap.putIfAbsent(type, serializer);
    if (current != null && current.getImpl().getClass() != serializer.getImpl().getClass())
      throw new IllegalStateException("Serializer[" + current
          .getImpl() + "] has been already registered for type: " + type); 
    current = (SerializerAdapter)this.idMap.putIfAbsent(Integer.valueOf(serializer.getTypeId()), serializer);
    if (current != null && current.getImpl().getClass() != serializer.getImpl().getClass())
      throw new IllegalStateException("Serializer [" + current
          .getImpl() + "] has been already registered for type-id: " + serializer.getTypeId()); 
    return (current == null);
  }
  
  protected final void registerConstant(Class type, Serializer serializer) { registerConstant(type, SerializationUtil.createSerializerAdapter(serializer, this)); }
  
  protected final void registerConstant(Class type, SerializerAdapter serializer) {
    this.constantTypesMap.put(type, serializer);
    this.constantTypeIds[SerializationUtil.indexForDefaultType(serializer.getTypeId())] = serializer;
  }
  
  private SerializerAdapter registerFromSuperType(Class type, Class superType) {
    SerializerAdapter serializer = (SerializerAdapter)this.typeMap.get(superType);
    if (serializer != null)
      safeRegister(type, serializer); 
    return serializer;
  }
  
  protected final SerializerAdapter serializerFor(int typeId) {
    if (typeId <= 0) {
      int index = SerializationUtil.indexForDefaultType(typeId);
      if (index < 28)
        return this.constantTypeIds[index]; 
    } 
    return (SerializerAdapter)this.idMap.get(Integer.valueOf(typeId));
  }
  
  protected final SerializerAdapter serializerFor(Object object) {
    if (object == null)
      return this.nullSerializerAdapter; 
    Class type = object.getClass();
    SerializerAdapter serializer = lookupDefaultSerializer(type);
    if (serializer == null)
      serializer = lookupCustomSerializer(type); 
    if (serializer == null && !this.overrideJavaSerialization)
      serializer = lookupJavaSerializer(type); 
    if (serializer == null)
      serializer = lookupGlobalSerializer(type); 
    if (serializer == null) {
      if (this.active)
        throw new HazelcastSerializationException("There is no suitable serializer for " + type); 
      throw new HazelcastInstanceNotActiveException();
    } 
    return serializer;
  }
  
  private SerializerAdapter lookupDefaultSerializer(Class type) {
    if (com.hazelcast.nio.serialization.DataSerializable.class.isAssignableFrom(type))
      return this.dataSerializerAdapter; 
    if (com.hazelcast.nio.serialization.Portable.class.isAssignableFrom(type))
      return this.portableSerializerAdapter; 
    return (SerializerAdapter)this.constantTypesMap.get(type);
  }
  
  private SerializerAdapter lookupCustomSerializer(Class type) {
    SerializerAdapter serializer = (SerializerAdapter)this.typeMap.get(type);
    if (serializer != null)
      return serializer; 
    Class typeSuperclass = type.getSuperclass();
    Set<Class> interfaces = new LinkedHashSet<Class>(5);
    SerializationUtil.getInterfaces(type, interfaces);
    while (typeSuperclass != null) {
      serializer = registerFromSuperType(type, typeSuperclass);
      if (serializer != null)
        break; 
      SerializationUtil.getInterfaces(typeSuperclass, interfaces);
      typeSuperclass = typeSuperclass.getSuperclass();
    } 
    if (serializer == null) {
      interfaces.remove(java.io.Serializable.class);
      interfaces.remove(java.io.Externalizable.class);
      for (Class typeInterface : interfaces) {
        serializer = registerFromSuperType(type, typeInterface);
        if (serializer != null)
          break; 
      } 
    } 
    return serializer;
  }
  
  private SerializerAdapter lookupGlobalSerializer(Class type) {
    SerializerAdapter serializer = (SerializerAdapter)this.global.get();
    if (serializer != null) {
      this.logger.fine("Registering global serializer for: " + type.getName());
      safeRegister(type, serializer);
    } 
    return serializer;
  }
  
  private SerializerAdapter lookupJavaSerializer(Class type) {
    if (java.io.Externalizable.class.isAssignableFrom(type)) {
      if (safeRegister(type, this.javaExternalizableAdapter) && !Throwable.class.isAssignableFrom(type))
        this.logger.info("Performance Hint: Serialization service will use java.io.Externalizable for: " + type.getName() + ". Please consider using a faster serialization option such as DataSerializable."); 
      return this.javaExternalizableAdapter;
    } 
    if (java.io.Serializable.class.isAssignableFrom(type)) {
      if (safeRegister(type, this.javaSerializerAdapter) && !Throwable.class.isAssignableFrom(type))
        this.logger.info("Performance Hint: Serialization service will use java.io.Serializable for: " + type.getName() + ". Please consider using a faster serialization option such as DataSerializable."); 
      return this.javaSerializerAdapter;
    } 
    return null;
  }
}
