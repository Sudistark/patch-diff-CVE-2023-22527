package com.hazelcast.internal.serialization.impl;

import com.hazelcast.config.SerializationConfig;
import com.hazelcast.config.SerializerConfig;
import com.hazelcast.logging.Logger;
import com.hazelcast.nio.ClassLoaderUtil;
import com.hazelcast.nio.serialization.HazelcastSerializationException;
import com.hazelcast.nio.serialization.Serializer;
import com.hazelcast.nio.serialization.SerializerHook;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.ServiceLoader;
import java.lang.reflect.Constructor;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

final class SerializerHookLoader {
  private static final String FACTORY_ID = "com.hazelcast.SerializerHook";
  
  private final boolean useDefaultConstructorOnly;
  
  private final Map<Class, Object> serializers;
  
  private final Collection<SerializerConfig> serializerConfigs;
  
  private final ClassLoader classLoader;
  
  SerializerHookLoader(SerializationConfig serializationConfig, ClassLoader classLoader) {
    this
      .useDefaultConstructorOnly = Boolean.getBoolean("hazelcast.compat.serializers.use.default.constructor.only");
    this.serializers = new HashMap();
    this.serializerConfigs = (serializationConfig != null) ? serializationConfig.getSerializerConfigs() : null;
    this.classLoader = classLoader;
    load();
  }
  
  private void load() {
    try {
      Iterator<SerializerHook> hooks = ServiceLoader.iterator(SerializerHook.class, "com.hazelcast.SerializerHook", this.classLoader);
      while (hooks.hasNext()) {
        SerializerHook hook = (SerializerHook)hooks.next();
        Class serializationType = hook.getSerializationType();
        if (serializationType != null)
          this.serializers.put(serializationType, hook); 
      } 
    } catch (Exception e) {
      throw ExceptionUtil.rethrow(e);
    } 
    if (this.serializerConfigs != null)
      for (SerializerConfig serializerConfig : this.serializerConfigs) {
        Serializer serializer = serializerConfig.getImplementation();
        Class serializationType = serializerConfig.getTypeClass();
        if (serializationType == null)
          try {
            serializationType = ClassLoaderUtil.loadClass(this.classLoader, serializerConfig.getTypeClassName());
          } catch (ClassNotFoundException e) {
            throw new HazelcastSerializationException(e);
          }  
        if (serializer == null)
          serializer = createSerializerInstance(serializerConfig, serializationType); 
        register(serializationType, serializer);
      }  
  }
  
  private Serializer createSerializerInstance(SerializerConfig serializerConfig, Class serializationType) {
    try {
      String className = serializerConfig.getClassName();
      if (this.useDefaultConstructorOnly)
        return (Serializer)ClassLoaderUtil.newInstance(this.classLoader, className); 
      return createSerializerInstanceWithFallback(serializationType, className);
    } catch (Exception e) {
      throw new HazelcastSerializationException(e);
    } 
  }
  
  private Serializer createSerializerInstanceWithFallback(Class serializationType, String className) throws Exception {
    Class<?> clazz = ClassLoaderUtil.loadClass(this.classLoader, className);
    try {
      Constructor<?> constructor = clazz.getDeclaredConstructor(new Class[] { Class.class });
      constructor.setAccessible(true);
      return (Serializer)constructor.newInstance(new Object[] { serializationType });
    } catch (NoSuchMethodException e) {
      Constructor<?> constructor = clazz.getDeclaredConstructor(new Class[0]);
      constructor.setAccessible(true);
      return (Serializer)constructor.newInstance(new Object[0]);
    } 
  }
  
  Map<Class, Object> getSerializers() { return this.serializers; }
  
  private void register(Class serializationType, Serializer serializer) {
    Object current = this.serializers.get(serializationType);
    if (current != null) {
      if (current.equals(serializer)) {
        Logger.getLogger(getClass()).warning("Serializer[" + serializationType.toString() + "] is already registered! Skipping " + serializer);
      } else if (current instanceof SerializerHook && ((SerializerHook)current).isOverwritable()) {
        this.serializers.put(serializationType, serializer);
      } else {
        throw new IllegalArgumentException("Serializer[" + serializationType.toString() + "] is already registered! " + current + " -> " + serializer);
      } 
    } else {
      this.serializers.put(serializationType, serializer);
    } 
  }
}
