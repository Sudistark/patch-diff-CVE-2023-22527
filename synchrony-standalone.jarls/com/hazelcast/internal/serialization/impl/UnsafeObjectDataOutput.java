package com.hazelcast.internal.serialization.impl;

import com.hazelcast.internal.memory.GlobalMemoryAccessorRegistry;
import com.hazelcast.internal.memory.HeapMemoryAccessor;
import com.hazelcast.internal.serialization.InternalSerializationService;
import java.io.IOException;
import java.nio.ByteOrder;

class UnsafeObjectDataOutput extends ByteArrayObjectDataOutput {
  UnsafeObjectDataOutput(int size, InternalSerializationService service) { super(size, service, ByteOrder.nativeOrder()); }
  
  public void writeChar(int v) throws IOException {
    ensureAvailable(2);
    GlobalMemoryAccessorRegistry.MEM.putChar(this.buffer, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + this.pos), (char)v);
    this.pos += 2;
  }
  
  public void writeChar(int position, int v) throws IOException {
    checkAvailable(position, 2);
    GlobalMemoryAccessorRegistry.MEM.putChar(this.buffer, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + position), (char)v);
  }
  
  public void writeDouble(double v) throws IOException {
    ensureAvailable(8);
    GlobalMemoryAccessorRegistry.MEM.putDouble(this.buffer, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + this.pos), v);
    this.pos += 8;
  }
  
  public void writeDouble(int position, double v) throws IOException {
    checkAvailable(position, 8);
    GlobalMemoryAccessorRegistry.MEM.putDouble(this.buffer, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + position), v);
  }
  
  public void writeFloat(float v) throws IOException {
    ensureAvailable(4);
    GlobalMemoryAccessorRegistry.MEM.putFloat(this.buffer, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + this.pos), v);
    this.pos += 4;
  }
  
  public void writeFloat(int position, float v) throws IOException {
    checkAvailable(position, 4);
    GlobalMemoryAccessorRegistry.MEM.putFloat(this.buffer, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + position), v);
  }
  
  public void writeInt(int v) throws IOException {
    ensureAvailable(4);
    GlobalMemoryAccessorRegistry.MEM.putInt(this.buffer, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + this.pos), v);
    this.pos += 4;
  }
  
  public void writeInt(int position, int v) throws IOException {
    checkAvailable(position, 4);
    GlobalMemoryAccessorRegistry.MEM.putInt(this.buffer, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + position), v);
  }
  
  public void writeInt(int v, ByteOrder byteOrder) throws IOException {
    if (byteOrder != ByteOrder.nativeOrder()) {
      writeInt(Integer.reverseBytes(v));
    } else {
      writeInt(v);
    } 
  }
  
  public void writeInt(int position, int v, ByteOrder byteOrder) throws IOException {
    if (byteOrder != ByteOrder.nativeOrder()) {
      writeInt(position, Integer.reverseBytes(v));
    } else {
      writeInt(position, v);
    } 
  }
  
  public void writeLong(long v) throws IOException {
    ensureAvailable(8);
    GlobalMemoryAccessorRegistry.MEM.putLong(this.buffer, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + this.pos), v);
    this.pos += 8;
  }
  
  public void writeLong(int position, long v) throws IOException {
    checkAvailable(position, 8);
    GlobalMemoryAccessorRegistry.MEM.putLong(this.buffer, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + position), v);
  }
  
  public void writeLong(long v, ByteOrder byteOrder) throws IOException {
    if (byteOrder != ByteOrder.nativeOrder()) {
      writeLong(Long.reverseBytes(v));
    } else {
      writeLong(v);
    } 
  }
  
  public void writeLong(int position, long v, ByteOrder byteOrder) throws IOException {
    if (byteOrder != ByteOrder.nativeOrder()) {
      writeLong(position, Long.reverseBytes(v));
    } else {
      writeLong(position, v);
    } 
  }
  
  public void writeShort(int v) throws IOException {
    ensureAvailable(2);
    GlobalMemoryAccessorRegistry.MEM.putShort(this.buffer, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + this.pos), (short)v);
    this.pos += 2;
  }
  
  public void writeShort(int position, int v) throws IOException {
    checkAvailable(position, 2);
    GlobalMemoryAccessorRegistry.MEM.putShort(this.buffer, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + position), (short)v);
  }
  
  public void writeShort(int v, ByteOrder byteOrder) throws IOException {
    short s = (short)v;
    if (byteOrder != ByteOrder.nativeOrder()) {
      writeShort(Short.reverseBytes(s));
    } else {
      writeShort(v);
    } 
  }
  
  public void writeShort(int position, int v, ByteOrder byteOrder) throws IOException {
    short s = (short)v;
    if (byteOrder != ByteOrder.nativeOrder()) {
      writeShort(position, Short.reverseBytes(s));
    } else {
      writeShort(position, v);
    } 
  }
  
  public void writeBooleanArray(boolean[] booleans) throws IOException {
    int len = (booleans != null) ? booleans.length : -1;
    writeInt(len);
    if (len > 0)
      memCopy(booleans, HeapMemoryAccessor.ARRAY_BOOLEAN_BASE_OFFSET, len, HeapMemoryAccessor.ARRAY_BOOLEAN_INDEX_SCALE); 
  }
  
  public void writeByteArray(byte[] bytes) throws IOException {
    int len = (bytes != null) ? bytes.length : -1;
    writeInt(len);
    if (len > 0)
      memCopy(bytes, HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET, len, HeapMemoryAccessor.ARRAY_BYTE_INDEX_SCALE); 
  }
  
  public void writeCharArray(char[] values) throws IOException {
    int len = (values != null) ? values.length : -1;
    writeInt(len);
    if (len > 0)
      memCopy(values, HeapMemoryAccessor.ARRAY_CHAR_BASE_OFFSET, len, HeapMemoryAccessor.ARRAY_CHAR_INDEX_SCALE); 
  }
  
  public void writeShortArray(short[] values) throws IOException {
    int len = (values != null) ? values.length : -1;
    writeInt(len);
    if (len > 0)
      memCopy(values, HeapMemoryAccessor.ARRAY_SHORT_BASE_OFFSET, len, HeapMemoryAccessor.ARRAY_SHORT_INDEX_SCALE); 
  }
  
  public void writeIntArray(int[] values) throws IOException {
    int len = (values != null) ? values.length : -1;
    writeInt(len);
    if (len > 0)
      memCopy(values, HeapMemoryAccessor.ARRAY_INT_BASE_OFFSET, len, HeapMemoryAccessor.ARRAY_INT_INDEX_SCALE); 
  }
  
  public void writeFloatArray(float[] values) throws IOException {
    int len = (values != null) ? values.length : -1;
    writeInt(len);
    if (len > 0)
      memCopy(values, HeapMemoryAccessor.ARRAY_FLOAT_BASE_OFFSET, len, HeapMemoryAccessor.ARRAY_FLOAT_INDEX_SCALE); 
  }
  
  public void writeLongArray(long[] values) throws IOException {
    int len = (values != null) ? values.length : -1;
    writeInt(len);
    if (len > 0)
      memCopy(values, HeapMemoryAccessor.ARRAY_LONG_BASE_OFFSET, len, HeapMemoryAccessor.ARRAY_LONG_INDEX_SCALE); 
  }
  
  public void writeDoubleArray(double[] values) throws IOException {
    int len = (values != null) ? values.length : -1;
    writeInt(len);
    if (len > 0)
      memCopy(values, HeapMemoryAccessor.ARRAY_DOUBLE_BASE_OFFSET, len, HeapMemoryAccessor.ARRAY_DOUBLE_INDEX_SCALE); 
  }
  
  private void memCopy(Object src, long srcOffset, int length, int indexScale) {
    if (length < 0)
      throw new NegativeArraySizeException("Source length is negative: " + length); 
    int remaining = indexScale * length;
    long offset = srcOffset;
    ensureAvailable(remaining);
    while (remaining > 0) {
      int chunk = Math.min(remaining, 1048576);
      GlobalMemoryAccessorRegistry.MEM.copyMemory(src, offset, this.buffer, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + this.pos), chunk);
      remaining -= chunk;
      offset += chunk;
      this.pos += chunk;
    } 
  }
  
  public ByteOrder getByteOrder() { return ByteOrder.nativeOrder(); }
  
  private void checkAvailable(int pos, int k) throws IOException {
    if (pos < 0)
      throw new IllegalArgumentException("Negative pos! -> " + pos); 
    int size = (this.buffer != null) ? this.buffer.length : 0;
    if (size - pos < k)
      throw new IOException("Cannot write " + k + " bytes!"); 
  }
  
  public String toString() {
    return "UnsafeObjectDataOutput{size=" + ((this.buffer != null) ? this.buffer.length : 0) + ", pos=" + this.pos + ", byteOrder=" + 

      
      getByteOrder() + '}';
  }
}
