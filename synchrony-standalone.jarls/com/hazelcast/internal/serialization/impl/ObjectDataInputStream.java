package com.hazelcast.internal.serialization.impl;

import com.hazelcast.internal.serialization.InternalSerializationService;
import com.hazelcast.nio.Bits;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.version.Version;
import java.io.Closeable;
import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteOrder;

public class ObjectDataInputStream extends VersionedObjectDataInput implements Closeable {
  private static final int SHORT_MASK = 65535;
  
  private final InternalSerializationService serializationService;
  
  private final DataInputStream dataInput;
  
  private final ByteOrder byteOrder;
  
  public ObjectDataInputStream(InputStream in, InternalSerializationService serializationService) {
    this.serializationService = serializationService;
    this.dataInput = new DataInputStream(in);
    this.byteOrder = serializationService.getByteOrder();
  }
  
  public int read() throws IOException { return readByte(); }
  
  public long skip(long n) throws IOException { return this.dataInput.skip(n); }
  
  public int available() throws IOException { return this.dataInput.available(); }
  
  public int read(byte[] b) throws IOException { return this.dataInput.read(b); }
  
  public int read(byte[] b, int off, int len) throws IOException { return this.dataInput.read(b, off, len); }
  
  public void readFully(byte[] b) throws IOException { this.dataInput.readFully(b); }
  
  public void readFully(byte[] b, int off, int len) throws IOException { this.dataInput.readFully(b, off, len); }
  
  public int skipBytes(int n) throws IOException { return this.dataInput.skipBytes(n); }
  
  public boolean readBoolean() throws IOException { return this.dataInput.readBoolean(); }
  
  public byte readByte() throws IOException { return this.dataInput.readByte(); }
  
  public int readUnsignedByte() throws IOException { return this.dataInput.readUnsignedByte(); }
  
  public short readShort() throws IOException {
    short v = this.dataInput.readShort();
    return bigEndian() ? v : Short.reverseBytes(v);
  }
  
  public int readUnsignedShort() throws IOException { return readShort() & 0xFFFF; }
  
  public char readChar() throws IOException {
    char v = this.dataInput.readChar();
    return bigEndian() ? v : Character.reverseBytes(v);
  }
  
  public int readInt() throws IOException {
    int v = this.dataInput.readInt();
    return bigEndian() ? v : Integer.reverseBytes(v);
  }
  
  public long readLong() throws IOException {
    long v = this.dataInput.readLong();
    return bigEndian() ? v : Long.reverseBytes(v);
  }
  
  public float readFloat() throws IOException {
    if (bigEndian())
      return this.dataInput.readFloat(); 
    return Float.intBitsToFloat(readInt());
  }
  
  public double readDouble() throws IOException {
    if (bigEndian())
      return this.dataInput.readDouble(); 
    return Double.longBitsToDouble(readLong());
  }
  
  public byte[] readByteArray() throws IOException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      byte[] b = new byte[len];
      readFully(b);
      return b;
    } 
    return new byte[0];
  }
  
  public boolean[] readBooleanArray() throws IOException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      boolean[] values = new boolean[len];
      for (int i = 0; i < len; i++)
        values[i] = readBoolean(); 
      return values;
    } 
    return new boolean[0];
  }
  
  public char[] readCharArray() throws IOException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      char[] values = new char[len];
      for (int i = 0; i < len; i++)
        values[i] = readChar(); 
      return values;
    } 
    return new char[0];
  }
  
  public int[] readIntArray() throws IOException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      int[] values = new int[len];
      for (int i = 0; i < len; i++)
        values[i] = readInt(); 
      return values;
    } 
    return new int[0];
  }
  
  public long[] readLongArray() throws IOException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      long[] values = new long[len];
      for (int i = 0; i < len; i++)
        values[i] = readLong(); 
      return values;
    } 
    return new long[0];
  }
  
  public double[] readDoubleArray() throws IOException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      double[] values = new double[len];
      for (int i = 0; i < len; i++)
        values[i] = readDouble(); 
      return values;
    } 
    return new double[0];
  }
  
  public float[] readFloatArray() throws IOException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      float[] values = new float[len];
      for (int i = 0; i < len; i++)
        values[i] = readFloat(); 
      return values;
    } 
    return new float[0];
  }
  
  public short[] readShortArray() throws IOException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      short[] values = new short[len];
      for (int i = 0; i < len; i++)
        values[i] = readShort(); 
      return values;
    } 
    return new short[0];
  }
  
  public String[] readUTFArray() throws IOException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      String[] values = new String[len];
      for (int i = 0; i < len; i++)
        values[i] = readUTF(); 
      return values;
    } 
    return new String[0];
  }
  
  @Deprecated
  public String readLine() throws IOException { return this.dataInput.readLine(); }
  
  public String readUTF() throws IOException {
    int charCount = readInt();
    if (charCount == -1)
      return null; 
    char[] charBuffer = new char[charCount];
    for (int i = 0; i < charCount; i++) {
      byte b = this.dataInput.readByte();
      if (b < 0) {
        charBuffer[i] = Bits.readUtf8Char(this.dataInput, b);
      } else {
        charBuffer[i] = (char)b;
      } 
    } 
    return new String(charBuffer, 0, charCount);
  }
  
  public void close() throws IOException { this.dataInput.close(); }
  
  public void mark(int readlimit) { this.dataInput.mark(readlimit); }
  
  public void reset() throws IOException { this.dataInput.reset(); }
  
  public boolean markSupported() throws IOException { return this.dataInput.markSupported(); }
  
  public Object readObject() throws IOException { return this.serializationService.readObject(this); }
  
  public <T> T readDataAsObject() throws IOException {
    Data data = readData();
    return (T)((data == null) ? null : this.serializationService.toObject(data));
  }
  
  public Object readObject(Class aClass) throws IOException { return this.serializationService.readObject(this, aClass); }
  
  public Data readData() throws IOException {
    byte[] bytes = readByteArray();
    return (bytes == null) ? null : new HeapData(bytes);
  }
  
  public ClassLoader getClassLoader() { return this.serializationService.getClassLoader(); }
  
  public InternalSerializationService getSerializationService() { return this.serializationService; }
  
  public ByteOrder getByteOrder() { return this.byteOrder; }
  
  private boolean bigEndian() throws IOException { return (this.byteOrder == ByteOrder.BIG_ENDIAN); }
}
