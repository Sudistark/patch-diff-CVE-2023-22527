package com.hazelcast.internal.serialization.impl;

import com.hazelcast.com.fasterxml.jackson.core.JsonFactory;
import com.hazelcast.com.fasterxml.jackson.core.JsonParser;
import com.hazelcast.internal.json.JsonReducedValueParser;
import com.hazelcast.internal.json.JsonValue;
import com.hazelcast.query.impl.getters.JsonPathCursor;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.IOException;
import java.io.StringReader;

public class StringNavigableJsonAdapter extends NavigableJsonInputAdapter {
  private final int initialOffset;
  
  private String source;
  
  private int pos;
  
  public StringNavigableJsonAdapter(String source, int initialOffset) {
    this.initialOffset = initialOffset;
    this.source = source;
    this.pos = initialOffset;
  }
  
  public void position(int position) { this.pos = this.initialOffset + position; }
  
  public int position() { return this.pos - this.initialOffset; }
  
  public void reset() { this.pos = this.initialOffset; }
  
  public boolean isAttributeName(JsonPathCursor cursor) {
    if (this.source.length() < this.pos + cursor.getCurrent().length() + 2)
      return false; 
    if (this.source.charAt(this.pos++) != '"')
      return false; 
    for (int i = 0; i < cursor.getCurrent().length() && this.pos < this.source.length(); i++) {
      if (cursor.getCurrent().charAt(i) != this.source.charAt(this.pos++))
        return false; 
    } 
    return (this.source.charAt(this.pos++) == '"');
  }
  
  @SuppressFBWarnings({"SR_NOT_CHECKED"})
  public JsonValue parseValue(JsonReducedValueParser parser, int offset) throws IOException {
    StringReader reader = new StringReader(this.source);
    if (reader.skip((this.initialOffset + offset)) != (this.initialOffset + offset))
      throw new IOException("There are not enough characters in this string"); 
    return parser.parse(reader);
  }
  
  public JsonParser createParser(JsonFactory factory) throws IOException { return factory.createParser(new StringReader(this.source)); }
}
