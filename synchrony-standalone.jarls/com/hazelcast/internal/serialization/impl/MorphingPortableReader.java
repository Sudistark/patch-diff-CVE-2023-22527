package com.hazelcast.internal.serialization.impl;

import com.hazelcast.nio.BufferObjectDataInput;
import com.hazelcast.nio.serialization.ClassDefinition;
import com.hazelcast.nio.serialization.FieldDefinition;
import com.hazelcast.nio.serialization.FieldType;
import com.hazelcast.nio.serialization.Portable;
import java.io.IOException;

public class MorphingPortableReader extends DefaultPortableReader {
  public MorphingPortableReader(PortableSerializer serializer, BufferObjectDataInput in, ClassDefinition cd) { super(serializer, in, cd); }
  
  public int readInt(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return 0; 
    switch (null.$SwitchMap$com$hazelcast$nio$serialization$FieldType[fd.getType().ordinal()]) {
      case 1:
        return super.readInt(fieldName);
      case 2:
        return super.readByte(fieldName);
      case 3:
        return super.readChar(fieldName);
      case 4:
        return super.readShort(fieldName);
    } 
    throw createIncompatibleClassChangeError(fd, FieldType.INT);
  }
  
  public long readLong(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return 0L; 
    switch (null.$SwitchMap$com$hazelcast$nio$serialization$FieldType[fd.getType().ordinal()]) {
      case 5:
        return super.readLong(fieldName);
      case 1:
        return super.readInt(fieldName);
      case 2:
        return super.readByte(fieldName);
      case 3:
        return super.readChar(fieldName);
      case 4:
        return super.readShort(fieldName);
    } 
    throw createIncompatibleClassChangeError(fd, FieldType.LONG);
  }
  
  public String readUTF(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return null; 
    validateTypeCompatibility(fd, FieldType.UTF);
    return super.readUTF(fieldName);
  }
  
  public boolean readBoolean(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return false; 
    validateTypeCompatibility(fd, FieldType.BOOLEAN);
    return super.readBoolean(fieldName);
  }
  
  public byte readByte(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return 0; 
    validateTypeCompatibility(fd, FieldType.BYTE);
    return super.readByte(fieldName);
  }
  
  public char readChar(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return Character.MIN_VALUE; 
    validateTypeCompatibility(fd, FieldType.CHAR);
    return super.readChar(fieldName);
  }
  
  public double readDouble(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return 0.0D; 
    switch (null.$SwitchMap$com$hazelcast$nio$serialization$FieldType[fd.getType().ordinal()]) {
      case 6:
        return super.readDouble(fieldName);
      case 5:
        return super.readLong(fieldName);
      case 7:
        return super.readFloat(fieldName);
      case 1:
        return super.readInt(fieldName);
      case 2:
        return super.readByte(fieldName);
      case 3:
        return super.readChar(fieldName);
      case 4:
        return super.readShort(fieldName);
    } 
    throw createIncompatibleClassChangeError(fd, FieldType.DOUBLE);
  }
  
  public float readFloat(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return 0.0F; 
    switch (null.$SwitchMap$com$hazelcast$nio$serialization$FieldType[fd.getType().ordinal()]) {
      case 7:
        return super.readFloat(fieldName);
      case 1:
        return super.readInt(fieldName);
      case 2:
        return super.readByte(fieldName);
      case 3:
        return super.readChar(fieldName);
      case 4:
        return super.readShort(fieldName);
    } 
    throw createIncompatibleClassChangeError(fd, FieldType.FLOAT);
  }
  
  public short readShort(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return 0; 
    switch (null.$SwitchMap$com$hazelcast$nio$serialization$FieldType[fd.getType().ordinal()]) {
      case 4:
        return super.readShort(fieldName);
      case 2:
        return (short)super.readByte(fieldName);
    } 
    throw createIncompatibleClassChangeError(fd, FieldType.SHORT);
  }
  
  public byte[] readByteArray(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return null; 
    validateTypeCompatibility(fd, FieldType.BYTE_ARRAY);
    return super.readByteArray(fieldName);
  }
  
  public boolean[] readBooleanArray(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return null; 
    validateTypeCompatibility(fd, FieldType.BOOLEAN_ARRAY);
    return super.readBooleanArray(fieldName);
  }
  
  public char[] readCharArray(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return null; 
    validateTypeCompatibility(fd, FieldType.CHAR_ARRAY);
    return super.readCharArray(fieldName);
  }
  
  public int[] readIntArray(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return null; 
    validateTypeCompatibility(fd, FieldType.INT_ARRAY);
    return super.readIntArray(fieldName);
  }
  
  public long[] readLongArray(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return null; 
    validateTypeCompatibility(fd, FieldType.LONG_ARRAY);
    return super.readLongArray(fieldName);
  }
  
  public double[] readDoubleArray(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return null; 
    validateTypeCompatibility(fd, FieldType.DOUBLE_ARRAY);
    return super.readDoubleArray(fieldName);
  }
  
  public float[] readFloatArray(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return null; 
    validateTypeCompatibility(fd, FieldType.FLOAT_ARRAY);
    return super.readFloatArray(fieldName);
  }
  
  public short[] readShortArray(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return null; 
    validateTypeCompatibility(fd, FieldType.SHORT_ARRAY);
    return super.readShortArray(fieldName);
  }
  
  public String[] readUTFArray(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return null; 
    validateTypeCompatibility(fd, FieldType.UTF_ARRAY);
    return super.readUTFArray(fieldName);
  }
  
  public Portable readPortable(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return null; 
    validateTypeCompatibility(fd, FieldType.PORTABLE);
    return super.readPortable(fieldName);
  }
  
  public Portable[] readPortableArray(String fieldName) throws IOException {
    FieldDefinition fd = this.cd.getField(fieldName);
    if (fd == null)
      return null; 
    validateTypeCompatibility(fd, FieldType.PORTABLE_ARRAY);
    return super.readPortableArray(fieldName);
  }
  
  private void validateTypeCompatibility(FieldDefinition fd, FieldType expectedType) {
    if (fd.getType() != expectedType)
      throw createIncompatibleClassChangeError(fd, expectedType); 
  }
  
  private IncompatibleClassChangeError createIncompatibleClassChangeError(FieldDefinition fd, FieldType expectedType) {
    return new IncompatibleClassChangeError("Incompatible to read " + expectedType + " from " + fd.getType() + " while reading field: " + fd
        .getName() + " on " + this.cd);
  }
}
