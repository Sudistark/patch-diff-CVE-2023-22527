package com.hazelcast.topic.impl;

import com.hazelcast.config.TopicConfig;
import com.hazelcast.core.DistributedObject;
import com.hazelcast.core.ITopic;
import com.hazelcast.core.MessageListener;
import com.hazelcast.instance.MemberImpl;
import com.hazelcast.internal.cluster.ClusterService;
import com.hazelcast.monitor.LocalTopicStats;
import com.hazelcast.monitor.impl.LocalTopicStatsImpl;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.EventPublishingService;
import com.hazelcast.spi.EventRegistration;
import com.hazelcast.spi.EventService;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.RemoteService;
import com.hazelcast.spi.StatisticsAwareService;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.HashUtil;
import com.hazelcast.util.MapUtil;
import java.util.Collection;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class TopicService extends Object implements ManagedService, RemoteService, EventPublishingService, StatisticsAwareService<LocalTopicStats> {
  public static final String SERVICE_NAME = "hz:impl:topicService";
  
  public static final int ORDERING_LOCKS_LENGTH = 1000;
  
  private final ConcurrentMap<String, LocalTopicStatsImpl> statsMap = new ConcurrentHashMap();
  
  private final Lock[] orderingLocks = new Lock[1000];
  
  private NodeEngine nodeEngine;
  
  private final ConstructorFunction<String, LocalTopicStatsImpl> localTopicStatsConstructorFunction = new Object(this);
  
  private EventService eventService;
  
  private final AtomicInteger counter = new AtomicInteger(0);
  
  private Address localAddress;
  
  public void init(NodeEngine nodeEngine, Properties properties) {
    this.nodeEngine = nodeEngine;
    this.localAddress = nodeEngine.getThisAddress();
    for (int i = 0; i < this.orderingLocks.length; i++)
      this.orderingLocks[i] = new ReentrantLock(); 
    this.eventService = nodeEngine.getEventService();
  }
  
  public ConcurrentMap<String, LocalTopicStatsImpl> getStatsMap() { return this.statsMap; }
  
  public void reset() { this.statsMap.clear(); }
  
  public void shutdown(boolean terminate) { reset(); }
  
  public Lock getOrderLock(String key) {
    int index = getOrderLockIndex(key);
    return this.orderingLocks[index];
  }
  
  private int getOrderLockIndex(String key) {
    int hash = key.hashCode();
    return HashUtil.hashToIndex(hash, this.orderingLocks.length);
  }
  
  public ITopic createDistributedObject(String name) {
    TopicConfig topicConfig = this.nodeEngine.getConfig().findTopicConfig(name);
    if (topicConfig.isGlobalOrderingEnabled())
      return new TotalOrderedTopicProxy(name, this.nodeEngine, this); 
    return new TopicProxy(name, this.nodeEngine, this);
  }
  
  public void destroyDistributedObject(String objectId) {
    this.statsMap.remove(objectId);
    this.nodeEngine.getEventService().deregisterAllListeners("hz:impl:topicService", objectId);
  }
  
  public void dispatchEvent(Object event, Object listener) {
    TopicEvent topicEvent = (TopicEvent)event;
    ClusterService clusterService = this.nodeEngine.getClusterService();
    MemberImpl member = clusterService.getMember(topicEvent.publisherAddress);
    if (member == null)
      member = (new MemberImpl.Builder(topicEvent.publisherAddress)).version(this.nodeEngine.getVersion()).build(); 
    DataAwareMessage dataAwareMessage = new DataAwareMessage(topicEvent.name, topicEvent.data, topicEvent.publishTime, member, this.nodeEngine.getSerializationService());
    incrementReceivedMessages(topicEvent.name);
    MessageListener messageListener = (MessageListener)listener;
    messageListener.onMessage(dataAwareMessage);
  }
  
  public LocalTopicStatsImpl getLocalTopicStats(String name) { return (LocalTopicStatsImpl)ConcurrencyUtil.getOrPutSynchronized(this.statsMap, name, this.statsMap, this.localTopicStatsConstructorFunction); }
  
  public void incrementPublishes(String topicName) { getLocalTopicStats(topicName).incrementPublishes(); }
  
  public void incrementReceivedMessages(String topicName) { getLocalTopicStats(topicName).incrementReceives(); }
  
  public void publishMessage(String topicName, Object payload, boolean multithreaded) {
    Collection<EventRegistration> registrations = this.eventService.getRegistrations("hz:impl:topicService", topicName);
    if (!registrations.isEmpty()) {
      Data payloadData = this.nodeEngine.toData(payload);
      TopicEvent topicEvent = new TopicEvent(topicName, payloadData, this.localAddress);
      int partitionId = multithreaded ? this.counter.incrementAndGet() : topicName.hashCode();
      this.eventService.publishEvent("hz:impl:topicService", registrations, topicEvent, partitionId);
    } 
  }
  
  public String addMessageListener(String name, MessageListener listener, boolean localOnly) {
    EventRegistration eventRegistration;
    if (localOnly) {
      eventRegistration = this.eventService.registerLocalListener("hz:impl:topicService", name, listener);
    } else {
      eventRegistration = this.eventService.registerListener("hz:impl:topicService", name, listener);
    } 
    return eventRegistration.getId();
  }
  
  public boolean removeMessageListener(String name, String registrationId) { return this.eventService.deregisterListener("hz:impl:topicService", name, registrationId); }
  
  public Map<String, LocalTopicStats> getStats() {
    Map<String, LocalTopicStats> topicStats = MapUtil.createHashMap(this.statsMap.size());
    for (Map.Entry<String, LocalTopicStatsImpl> queueStat : this.statsMap.entrySet())
      topicStats.put(queueStat.getKey(), queueStat.getValue()); 
    return topicStats;
  }
}
