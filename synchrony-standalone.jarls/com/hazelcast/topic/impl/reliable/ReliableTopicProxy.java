package com.hazelcast.topic.impl.reliable;

import com.hazelcast.config.ListenerConfig;
import com.hazelcast.config.ReliableTopicConfig;
import com.hazelcast.core.HazelcastException;
import com.hazelcast.core.HazelcastInstanceAware;
import com.hazelcast.core.ITopic;
import com.hazelcast.core.MessageListener;
import com.hazelcast.monitor.LocalTopicStats;
import com.hazelcast.monitor.impl.LocalTopicStatsImpl;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.ClassLoaderUtil;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.ringbuffer.OverflowPolicy;
import com.hazelcast.ringbuffer.Ringbuffer;
import com.hazelcast.spi.AbstractDistributedObject;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.topic.ReliableMessageListener;
import com.hazelcast.topic.TopicOverloadException;
import com.hazelcast.topic.TopicOverloadPolicy;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.UuidUtil;
import com.hazelcast.util.executor.ManagedExecutorService;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

public class ReliableTopicProxy<E> extends AbstractDistributedObject<ReliableTopicService> implements ITopic<E> {
  public static final int MAX_BACKOFF = 2000;
  
  public static final int INITIAL_BACKOFF_MS = 100;
  
  final Ringbuffer<ReliableTopicMessage> ringbuffer;
  
  final Executor executor;
  
  final ConcurrentMap<String, MessageRunner<E>> runnersMap = new ConcurrentHashMap();
  
  final LocalTopicStatsImpl localTopicStats;
  
  final ReliableTopicConfig topicConfig;
  
  final TopicOverloadPolicy overloadPolicy;
  
  private final NodeEngine nodeEngine;
  
  private final Address thisAddress;
  
  private final String name;
  
  public ReliableTopicProxy(String name, NodeEngine nodeEngine, ReliableTopicService service, ReliableTopicConfig topicConfig) {
    super(nodeEngine, service);
    this.name = name;
    this.topicConfig = topicConfig;
    this.nodeEngine = nodeEngine;
    this.ringbuffer = nodeEngine.getHazelcastInstance().getRingbuffer("_hz_rb_" + name);
    this.executor = initExecutor(nodeEngine, topicConfig);
    this.thisAddress = nodeEngine.getThisAddress();
    this.overloadPolicy = topicConfig.getTopicOverloadPolicy();
    this.localTopicStats = service.getLocalTopicStats(name);
    for (ListenerConfig listenerConfig : topicConfig.getMessageListenerConfigs())
      addMessageListener(listenerConfig); 
  }
  
  public String getServiceName() { return "hz:impl:reliableTopicService"; }
  
  public String getName() { return this.name; }
  
  private void addMessageListener(ListenerConfig listenerConfig) {
    NodeEngine nodeEngine = getNodeEngine();
    MessageListener listener = loadListener(listenerConfig);
    if (listener == null)
      return; 
    if (listener instanceof HazelcastInstanceAware) {
      HazelcastInstanceAware hazelcastInstanceAware = (HazelcastInstanceAware)listener;
      hazelcastInstanceAware.setHazelcastInstance(nodeEngine.getHazelcastInstance());
    } 
    addMessageListener(listener);
  }
  
  private MessageListener loadListener(ListenerConfig listenerConfig) {
    try {
      MessageListener listener = (MessageListener)listenerConfig.getImplementation();
      if (listener != null)
        return listener; 
      if (listenerConfig.getClassName() != null) {
        Object object = ClassLoaderUtil.newInstance(this.nodeEngine.getConfigClassLoader(), listenerConfig.getClassName());
        if (!(object instanceof MessageListener))
          throw new HazelcastException("class '" + listenerConfig
              .getClassName() + "' is not an instance of " + MessageListener.class
              .getName()); 
        listener = (MessageListener)object;
      } 
      return listener;
    } catch (Exception e) {
      throw ExceptionUtil.rethrow(e);
    } 
  }
  
  private Executor initExecutor(NodeEngine nodeEngine, ReliableTopicConfig topicConfig) {
    ManagedExecutorService managedExecutorService = topicConfig.getExecutor();
    if (managedExecutorService == null)
      managedExecutorService = nodeEngine.getExecutionService().getExecutor("hz:async"); 
    return managedExecutorService;
  }
  
  public void publish(E payload) {
    try {
      Data data = this.nodeEngine.toData(payload);
      ReliableTopicMessage message = new ReliableTopicMessage(data, this.thisAddress);
      switch (null.$SwitchMap$com$hazelcast$topic$TopicOverloadPolicy[this.overloadPolicy.ordinal()]) {
        case 1:
          addOrFail(message);
          break;
        case 2:
          addOrOverwrite(message);
          break;
        case 3:
          this.ringbuffer.addAsync(message, OverflowPolicy.FAIL).get();
          break;
        case 4:
          addWithBackoff(message);
          break;
        default:
          throw new IllegalArgumentException("Unknown overloadPolicy:" + this.overloadPolicy);
      } 
      this.localTopicStats.incrementPublishes();
    } catch (Exception e) {
      throw (RuntimeException)ExceptionUtil.peel(e, null, "Failed to publish message: " + payload + " to topic:" + 
          getName());
    } 
  }
  
  private Long addOrOverwrite(ReliableTopicMessage message) throws Exception { return (Long)this.ringbuffer.addAsync(message, OverflowPolicy.OVERWRITE).get(); }
  
  private void addOrFail(ReliableTopicMessage message) throws Exception {
    long sequenceId = ((Long)this.ringbuffer.addAsync(message, OverflowPolicy.FAIL).get()).longValue();
    if (sequenceId == -1L)
      throw new TopicOverloadException("Failed to publish message: " + message + " on topic:" + getName()); 
  }
  
  private void addWithBackoff(ReliableTopicMessage message) throws Exception {
    long timeoutMs = 100L;
    while (true) {
      long result = ((Long)this.ringbuffer.addAsync(message, OverflowPolicy.FAIL).get()).longValue();
      if (result != -1L)
        break; 
      TimeUnit.MILLISECONDS.sleep(timeoutMs);
      timeoutMs *= 2L;
      if (timeoutMs > 2000L)
        timeoutMs = 2000L; 
    } 
  }
  
  public String addMessageListener(MessageListener<E> listener) {
    ReliableMessageListenerAdapter reliableMessageListenerAdapter;
    Preconditions.checkNotNull(listener, "listener can't be null");
    String id = UuidUtil.newUnsecureUuidString();
    if (listener instanceof ReliableMessageListener) {
      reliableMessageListenerAdapter = (ReliableMessageListener)listener;
    } else {
      reliableMessageListenerAdapter = new ReliableMessageListenerAdapter(listener);
    } 
    ReliableMessageRunner reliableMessageRunner = new ReliableMessageRunner(id, reliableMessageListenerAdapter, this.nodeEngine.getSerializationService(), this.executor, this.nodeEngine.getLogger(getClass()), this.nodeEngine.getClusterService(), this);
    this.runnersMap.put(id, reliableMessageRunner);
    reliableMessageRunner.next();
    return id;
  }
  
  public boolean removeMessageListener(String registrationId) {
    Preconditions.checkNotNull(registrationId, "registrationId can't be null");
    MessageRunner runner = (MessageRunner)this.runnersMap.get(registrationId);
    if (runner == null)
      return false; 
    runner.cancel();
    return true;
  }
  
  protected void postDestroy() { this.ringbuffer.destroy(); }
  
  public LocalTopicStats getLocalTopicStats() { return this.localTopicStats; }
}
