package com.hazelcast.durableexecutor.impl;

import com.hazelcast.logging.ILogger;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.impl.executionservice.InternalExecutionService;
import java.util.concurrent.Callable;

public class DurableExecutorContainer {
  private final String name;
  
  private final NodeEngineImpl nodeEngine;
  
  private final InternalExecutionService executionService;
  
  private final ILogger logger;
  
  private final int partitionId;
  
  private final int durability;
  
  private final TaskRingBuffer ringBuffer;
  
  public DurableExecutorContainer(NodeEngineImpl nodeEngine, String name, int partitionId, int durability, TaskRingBuffer ringBuffer) {
    this.name = name;
    this.nodeEngine = nodeEngine;
    this.executionService = nodeEngine.getExecutionService();
    this.partitionId = partitionId;
    this.logger = nodeEngine.getLogger(DurableExecutorContainer.class);
    this.durability = durability;
    this.ringBuffer = ringBuffer;
  }
  
  public int execute(Callable callable) {
    int sequence = this.ringBuffer.add(callable);
    TaskProcessor processor = new TaskProcessor(this, sequence, callable, null);
    this.executionService.executeDurable(this.name, processor);
    return sequence;
  }
  
  public void putBackup(int sequence, Callable callable) { this.ringBuffer.putBackup(sequence, callable); }
  
  public Object retrieveResult(int sequence) { return this.ringBuffer.retrieve(sequence); }
  
  public void disposeResult(int sequence) { this.ringBuffer.dispose(sequence); }
  
  public Object retrieveAndDisposeResult(int sequence) { return this.ringBuffer.retrieveAndDispose(sequence); }
  
  public void putResult(int sequence, Object result) { this.ringBuffer.replaceTaskWithResult(sequence, result); }
  
  public boolean shouldWait(int sequence) { return this.ringBuffer.isTask(sequence); }
  
  void executeAll() {
    TaskRingBuffer.DurableIterator iterator = this.ringBuffer.iterator();
    while (iterator.hasNext()) {
      Object item = iterator.next();
      boolean isCallable = iterator.isTask();
      if (!isCallable)
        continue; 
      Callable callable = (Callable)item;
      int sequence = iterator.getSequence();
      TaskProcessor processor = new TaskProcessor(this, sequence, callable, null);
      this.executionService.executeDurable(this.name, processor);
    } 
  }
  
  public TaskRingBuffer getRingBuffer() { return this.ringBuffer; }
  
  public int getDurability() { return this.durability; }
  
  public String getName() { return this.name; }
}
