package com.hazelcast.wan.merkletree;

import com.hazelcast.util.JVMUtil;
import com.hazelcast.util.collection.OAHashSet;
import com.hazelcast.util.function.Consumer;
import java.util.Arrays;

public class ArrayMerkleTree extends AbstractMerkleTreeView implements MerkleTree {
  private final OAHashSet<Object>[] leafKeys;
  
  private final int leafLevel;
  
  public ArrayMerkleTree(int depth) {
    super(depth);
    this.leafLevel = depth - 1;
    int leaves = MerkleTreeUtil.getNodesOnLevel(this.leafLevel);
    this.leafKeys = new OAHashSet[leaves];
    for (int i = 0; i < leaves; i++)
      this.leafKeys[i] = new OAHashSet(1); 
    initializeFootprint();
  }
  
  public void updateAdd(Object key, Object value) {
    int keyHash = key.hashCode();
    int valueHash = value.hashCode();
    int leafOrder = MerkleTreeUtil.getLeafOrderForHash(keyHash, this.leafLevel);
    int leafCurrentHash = getNodeHash(leafOrder);
    int leafNewHash = MerkleTreeUtil.addHash(leafCurrentHash, valueHash);
    setNodeHash(leafOrder, leafNewHash);
    addKeyToLeaf(leafOrder, keyHash, key);
    updateBranch(leafOrder);
  }
  
  public void updateReplace(Object key, Object oldValue, Object newValue) {
    int keyHash = key.hashCode();
    int oldValueHash = oldValue.hashCode();
    int newValueHash = newValue.hashCode();
    int leafOrder = MerkleTreeUtil.getLeafOrderForHash(keyHash, this.leafLevel);
    int leafCurrentHash = getNodeHash(leafOrder);
    int leafNewHash = MerkleTreeUtil.removeHash(leafCurrentHash, oldValueHash);
    leafNewHash = MerkleTreeUtil.addHash(leafNewHash, newValueHash);
    setNodeHash(leafOrder, leafNewHash);
    updateBranch(leafOrder);
  }
  
  public void updateRemove(Object key, Object removedValue) {
    int keyHash = key.hashCode();
    int removedValueHash = removedValue.hashCode();
    int leafOrder = MerkleTreeUtil.getLeafOrderForHash(keyHash, this.leafLevel);
    int leafCurrentHash = getNodeHash(leafOrder);
    int leafNewHash = MerkleTreeUtil.removeHash(leafCurrentHash, removedValueHash);
    setNodeHash(leafOrder, leafNewHash);
    removeKeyFromLeaf(leafOrder, keyHash, key);
    updateBranch(leafOrder);
  }
  
  public int getNodeHash(int nodeOrder) { return this.tree[nodeOrder]; }
  
  public void forEachKeyOfNode(int nodeOrder, Consumer<Object> consumer) {
    if (MerkleTreeUtil.isLeaf(nodeOrder, this.depth)) {
      forEachKeyOfLeaf(nodeOrder, consumer);
    } else {
      forEachKeyOfNonLeaf(nodeOrder, consumer);
    } 
  }
  
  private void forEachKeyOfLeaf(int nodeOrder, Consumer<Object> consumer) {
    int relativeLeafOrder = nodeOrder - this.leafLevelOrder;
    for (Object key : this.leafKeys[relativeLeafOrder])
      consumer.accept(key); 
  }
  
  private void forEachKeyOfNonLeaf(int nodeOrder, Consumer<Object> consumer) {
    int leftMostLeaf = MerkleTreeUtil.getLeftMostLeafUnderNode(nodeOrder, this.depth);
    int rightMostLeaf = MerkleTreeUtil.getRightMostLeafUnderNode(nodeOrder, this.depth);
    for (int leafOrder = leftMostLeaf; leafOrder <= rightMostLeaf; leafOrder++) {
      int relativeLeafOrder = leafOrder - this.leafLevelOrder;
      for (Object key : this.leafKeys[relativeLeafOrder])
        consumer.accept(key); 
    } 
  }
  
  public int getNodeKeyCount(int nodeOrder) {
    if (MerkleTreeUtil.isLeaf(nodeOrder, this.depth))
      return getLeafKeyCount(nodeOrder); 
    return getNonLeafKeyCount(nodeOrder);
  }
  
  private int getLeafKeyCount(int nodeOrder) {
    int relativeLeafOrder = nodeOrder - this.leafLevelOrder;
    return this.leafKeys[relativeLeafOrder].size();
  }
  
  private int getNonLeafKeyCount(int nodeOrder) {
    int leftMostLeaf = MerkleTreeUtil.getLeftMostLeafUnderNode(nodeOrder, this.depth);
    int rightMostLeaf = MerkleTreeUtil.getRightMostLeafUnderNode(nodeOrder, this.depth);
    int count = 0;
    for (int leafOrder = leftMostLeaf; leafOrder <= rightMostLeaf; leafOrder++) {
      int relativeLeafOrder = leafOrder - this.leafLevelOrder;
      count += this.leafKeys[relativeLeafOrder].size();
    } 
    return count;
  }
  
  public long footprint() { return this.footprint; }
  
  public void clear() {
    Arrays.fill(this.tree, 0);
    for (OAHashSet<Object> leafKeysSet : this.leafKeys)
      leafKeysSet.clear(); 
  }
  
  private void updateBranch(int leafOrder) {
    int nodeOrder = MerkleTreeUtil.getParentOrder(leafOrder);
    for (int level = this.leafLevel; level > 0; level--) {
      int leftChildOrder = MerkleTreeUtil.getLeftChildOrder(nodeOrder);
      int rightChildOrder = MerkleTreeUtil.getRightChildOrder(nodeOrder);
      int leftChildHash = getNodeHash(leftChildOrder);
      int rightChildHash = getNodeHash(rightChildOrder);
      int newNodeHash = MerkleTreeUtil.sumHash(leftChildHash, rightChildHash);
      setNodeHash(nodeOrder, newNodeHash);
      nodeOrder = MerkleTreeUtil.getParentOrder(nodeOrder);
    } 
  }
  
  private void addKeyToLeaf(int leafOrder, int keyHash, Object key) {
    int relativeLeafOrder = leafOrder - this.leafLevelOrder;
    OAHashSet<Object> leafKeySet = this.leafKeys[relativeLeafOrder];
    long leafKeysFootprintBefore = leafKeySet.footprint();
    leafKeySet.add(key, keyHash);
    adjustFootprintWithLeafKeySetChange(leafKeySet.footprint(), leafKeysFootprintBefore);
  }
  
  private void removeKeyFromLeaf(int leafOrder, int keyHash, Object key) {
    int relativeLeafOrder = leafOrder - this.leafLevelOrder;
    OAHashSet<Object> leafKeySet = this.leafKeys[relativeLeafOrder];
    long leafKeysFootprintBefore = leafKeySet.footprint();
    leafKeySet.remove(key, keyHash);
    adjustFootprintWithLeafKeySetChange(leafKeySet.footprint(), leafKeysFootprintBefore);
  }
  
  private void adjustFootprintWithLeafKeySetChange(long currentFootprint, long footprintBeforeUpdate) {
    long footprintDelta = currentFootprint - footprintBeforeUpdate;
    if (footprintDelta != 0L)
      this.footprint += footprintDelta; 
  }
  
  private void initializeFootprint() {
    long leafKeysSetsFootprint = 0L;
    for (OAHashSet leafKeysSet : this.leafKeys)
      leafKeysSetsFootprint += leafKeysSet.footprint(); 
    this.footprint = leafKeysSetsFootprint + (4 * this.tree.length) + (JVMUtil.REFERENCE_COST_IN_BYTES * this.leafKeys.length) + JVMUtil.REFERENCE_COST_IN_BYTES + JVMUtil.REFERENCE_COST_IN_BYTES + 4L + 4L + 4L + 8L;
  }
}
