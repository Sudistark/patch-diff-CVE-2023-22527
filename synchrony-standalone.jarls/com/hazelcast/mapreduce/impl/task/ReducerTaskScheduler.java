package com.hazelcast.mapreduce.impl.task;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.atomic.AtomicReference;

class ReducerTaskScheduler {
  private final AtomicReference<State> state;
  
  private final ExecutorService executorService;
  
  private final Runnable task;
  
  ReducerTaskScheduler(ExecutorService executorService, Runnable task) {
    this.state = new AtomicReference(State.INACTIVE);
    this.executorService = executorService;
    this.task = task;
  }
  
  private void scheduleExecution() { this.executorService.submit(this.task); }
  
  void requestExecution() {
    while (true) {
      State currentState = (State)this.state.get();
      switch (null.$SwitchMap$com$hazelcast$mapreduce$impl$task$ReducerTaskScheduler$State[currentState.ordinal()]) {
        case 1:
          if (this.state.compareAndSet(State.INACTIVE, State.RUNNING)) {
            scheduleExecution();
            return;
          } 
          continue;
        case 2:
          if (this.state.compareAndSet(State.RUNNING, State.REQUESTED))
            return; 
          continue;
      } 
      break;
    } 
  }
  
  void afterExecution() {
    while (true) {
      State currentState = (State)this.state.get();
      switch (null.$SwitchMap$com$hazelcast$mapreduce$impl$task$ReducerTaskScheduler$State[currentState.ordinal()]) {
        case 3:
          this.state.set(State.RUNNING);
          scheduleExecution();
          return;
        case 2:
          if (this.state.compareAndSet(State.RUNNING, State.INACTIVE))
            return; 
          continue;
      } 
      break;
    } 
    throw new IllegalStateException("Inactive state is illegal here.");
  }
}
