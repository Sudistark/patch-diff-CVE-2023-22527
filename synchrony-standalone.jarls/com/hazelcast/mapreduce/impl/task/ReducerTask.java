package com.hazelcast.mapreduce.impl.task;

import com.hazelcast.mapreduce.Reducer;
import com.hazelcast.mapreduce.impl.MapReduceService;
import com.hazelcast.mapreduce.impl.MapReduceUtil;
import com.hazelcast.mapreduce.impl.notification.ReducingFinishedNotification;
import com.hazelcast.nio.Address;
import com.hazelcast.util.ExceptionUtil;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.atomic.AtomicBoolean;

public class ReducerTask<Key, Chunk> extends Object implements Runnable {
  private final AtomicBoolean cancelled;
  
  private final JobSupervisor supervisor;
  
  private final Queue<ReducerChunk<Key, Chunk>> reducerQueue;
  
  private final String name;
  
  private final String jobId;
  
  private final ReducerTaskScheduler scheduler;
  
  public ReducerTask(String name, String jobId, JobSupervisor supervisor) {
    this.cancelled = new AtomicBoolean();
    this.name = name;
    this.jobId = jobId;
    this.supervisor = supervisor;
    this.reducerQueue = new ConcurrentLinkedQueue();
    this.scheduler = new ReducerTaskScheduler(getExecutorService(), this);
  }
  
  public String getName() { return this.name; }
  
  public String getJobId() { return this.jobId; }
  
  public void cancel() { this.cancelled.set(true); }
  
  public void processChunk(Map<Key, Chunk> chunk) { processChunk(-1, null, chunk); }
  
  public void processChunk(int partitionId, Address sender, Map<Key, Chunk> chunk) {
    if (this.cancelled.get())
      return; 
    this.reducerQueue.offer(new ReducerChunk(chunk, partitionId, sender));
    this.scheduler.requestExecution();
  }
  
  private ExecutorService getExecutorService() {
    MapReduceService mapReduceService = this.supervisor.getMapReduceService();
    return mapReduceService.getExecutorService(this.name);
  }
  
  public void run() {
    visibility = this.visibility;
    try {
      ReducerChunk<Key, Chunk> reducerChunk;
      while ((reducerChunk = (ReducerChunk)this.reducerQueue.poll()) != null) {
        if (this.cancelled.get())
          return; 
        reduceChunk(reducerChunk.chunk);
        processProcessedState(reducerChunk);
      } 
    } catch (Throwable t) {
      MapReduceUtil.notifyRemoteException(this.supervisor, t);
      if (t instanceof Error)
        ExceptionUtil.sneakyThrow(t); 
    } finally {
      this.visibility = !visibility;
      this.scheduler.afterExecution();
    } 
  }
  
  private void reduceChunk(Map<Key, Chunk> chunk) {
    for (Map.Entry<Key, Chunk> entry : chunk.entrySet()) {
      Reducer reducer = this.supervisor.getReducerByKey(entry.getKey());
      if (reducer != null) {
        Chunk chunkValue = (Chunk)entry.getValue();
        if (chunkValue instanceof com.hazelcast.mapreduce.impl.CombinerResultList) {
          for (Object value : (List)chunkValue)
            reducer.reduce(value); 
          continue;
        } 
        reducer.reduce(chunkValue);
      } 
    } 
  }
  
  private void processProcessedState(ReducerChunk<Key, Chunk> reducerChunk) {
    if (reducerChunk.partitionId != -1) {
      MapReduceService mapReduceService = this.supervisor.getMapReduceService();
      ReducingFinishedNotification notification = new ReducingFinishedNotification(mapReduceService.getLocalAddress(), this.name, this.jobId, reducerChunk.partitionId);
      mapReduceService.sendNotification(reducerChunk.sender, notification);
    } 
  }
}
