package com.hazelcast.mapreduce.impl.task;

import com.hazelcast.mapreduce.JobPartitionState;
import com.hazelcast.mapreduce.JobProcessInformation;
import com.hazelcast.mapreduce.JobTracker;
import com.hazelcast.mapreduce.Reducer;
import com.hazelcast.mapreduce.impl.AbstractJobTracker;
import com.hazelcast.mapreduce.impl.MapReduceService;
import com.hazelcast.mapreduce.impl.MapReduceUtil;
import com.hazelcast.mapreduce.impl.notification.IntermediateChunkNotification;
import com.hazelcast.mapreduce.impl.notification.LastChunkNotification;
import com.hazelcast.mapreduce.impl.notification.MapReduceNotification;
import com.hazelcast.mapreduce.impl.notification.ReducingFinishedNotification;
import com.hazelcast.mapreduce.impl.operation.GetResultOperationFactory;
import com.hazelcast.mapreduce.impl.operation.RequestPartitionProcessed;
import com.hazelcast.mapreduce.impl.operation.RequestPartitionResult;
import com.hazelcast.nio.Address;
import com.hazelcast.spi.ExecutionService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.TaskScheduler;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.MapUtil;
import com.hazelcast.util.executor.ManagedExecutorService;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.atomic.AtomicReference;

public class JobSupervisor {
  private final ConcurrentMap<Object, Reducer> reducers;
  
  private final ConcurrentMap<Integer, Set<Address>> remoteReducers;
  
  private final AtomicReference<DefaultContext> context;
  
  private final ConcurrentMap<Object, Address> keyAssignments;
  
  private final Address jobOwner;
  
  private final boolean ownerNode;
  
  private final AbstractJobTracker jobTracker;
  
  private final JobTaskConfiguration configuration;
  
  private final MapReduceService mapReduceService;
  
  private final ExecutorService executorService;
  
  private final JobProcessInformationImpl jobProcessInformation;
  
  public JobSupervisor(JobTaskConfiguration configuration, AbstractJobTracker jobTracker, boolean ownerNode, MapReduceService mapReduceService) {
    this.reducers = new ConcurrentHashMap();
    this.remoteReducers = new ConcurrentHashMap();
    this.context = new AtomicReference();
    this.keyAssignments = new ConcurrentHashMap();
    this.jobTracker = jobTracker;
    this.ownerNode = ownerNode;
    this.configuration = configuration;
    this.mapReduceService = mapReduceService;
    this.jobOwner = configuration.getJobOwner();
    this.executorService = mapReduceService.getExecutorService(configuration.getName());
    this.jobProcessInformation = MapReduceUtil.createJobProcessInformation(configuration, this);
    String name = configuration.getName();
    String jobId = configuration.getJobId();
    jobTracker.registerReducerTask(new ReducerTask(name, jobId, this));
  }
  
  public MapReduceService getMapReduceService() { return this.mapReduceService; }
  
  public JobTracker getJobTracker() { return this.jobTracker; }
  
  public void startTasks(MappingPhase mappingPhase) { this.jobTracker.registerMapCombineTask(new MapCombineTask(this.configuration, this, mappingPhase)); }
  
  public void onNotification(MapReduceNotification notification) {
    if (notification instanceof IntermediateChunkNotification) {
      IntermediateChunkNotification icn = (IntermediateChunkNotification)notification;
      ReducerTask reducerTask = this.jobTracker.getReducerTask(icn.getJobId());
      reducerTask.processChunk(icn.getChunk());
    } else if (notification instanceof LastChunkNotification) {
      LastChunkNotification lcn = (LastChunkNotification)notification;
      ReducerTask reducerTask = this.jobTracker.getReducerTask(lcn.getJobId());
      reducerTask.processChunk(lcn.getPartitionId(), lcn.getSender(), lcn.getChunk());
    } else if (notification instanceof ReducingFinishedNotification) {
      ReducingFinishedNotification rfn = (ReducingFinishedNotification)notification;
      this.executorService.submit(new Object(this, rfn));
    } 
  }
  
  public void notifyRemoteException(Address remoteAddress, Throwable throwable) {
    this.jobProcessInformation.cancelPartitionState();
    Set<Address> addresses = collectRemoteAddresses();
    TrackableJobFuture future = cancel();
    asyncCancelRemoteOperations(addresses);
    if (future != null) {
      ExceptionUtil.fixAsyncStackTrace(throwable, Thread.currentThread().getStackTrace(), "Operation failed on node: " + remoteAddress);
      future.setResult(throwable);
    } 
  }
  
  public boolean cancelAndNotify(Exception exception) {
    this.jobProcessInformation.cancelPartitionState();
    Set<Address> addresses = collectRemoteAddresses();
    TrackableJobFuture future = cancel();
    asyncCancelRemoteOperations(addresses);
    if (future != null)
      future.setResult(exception); 
    return true;
  }
  
  public TrackableJobFuture cancel() {
    String jobId = getConfiguration().getJobId();
    TrackableJobFuture future = this.jobTracker.unregisterTrackableJob(jobId);
    MapCombineTask mapCombineTask = this.jobTracker.unregisterMapCombineTask(jobId);
    if (mapCombineTask != null)
      mapCombineTask.cancel(); 
    ReducerTask reducerTask = this.jobTracker.unregisterReducerTask(jobId);
    if (reducerTask != null)
      reducerTask.cancel(); 
    this.mapReduceService.destroyJobSupervisor(this);
    return future;
  }
  
  public Map<Object, Object> getJobResults() {
    Map<Object, Object> result;
    DefaultContext currentContext = (DefaultContext)this.context.get();
    if (this.configuration.getReducerFactory() != null) {
      int mapSize = MapReduceUtil.mapSize(this.reducers.size());
      result = MapUtil.createHashMapAdapter(mapSize);
      for (Map.Entry<Object, Reducer> entry : this.reducers.entrySet()) {
        Object reducedResults = ((Reducer)entry.getValue()).finalizeReduce();
        if (reducedResults != null)
          result.put(entry.getKey(), reducedResults); 
      } 
    } else {
      result = currentContext.requestChunk();
    } 
    currentContext.finalizeCombiners();
    return result;
  }
  
  public <KeyIn, ValueIn, ValueOut> Reducer<ValueIn, ValueOut> getReducerByKey(Object key) {
    Reducer reducer = (Reducer)this.reducers.get(key);
    if (reducer == null && this.configuration.getReducerFactory() != null) {
      reducer = this.configuration.getReducerFactory().newReducer(key);
      Reducer oldReducer = (Reducer)this.reducers.putIfAbsent(key, reducer);
      if (oldReducer != null) {
        reducer = oldReducer;
      } else {
        reducer.beginReduce();
      } 
    } 
    return reducer;
  }
  
  public Address getReducerAddressByKey(Object key) {
    Address address = (Address)this.keyAssignments.get(key);
    if (address != null)
      return address; 
    return null;
  }
  
  public Address assignKeyReducerAddress(Object key) {
    Address address = (Address)this.keyAssignments.get(key);
    if (address == null) {
      address = this.mapReduceService.getKeyMember(key);
      Address oldAddress = (Address)this.keyAssignments.putIfAbsent(key, address);
      if (oldAddress != null)
        address = oldAddress; 
    } 
    return address;
  }
  
  public boolean checkAssignedMembersAvailable() { return this.mapReduceService.checkAssignedMembersAvailable(this.keyAssignments.values()); }
  
  public boolean assignKeyReducerAddress(Object key, Address address) {
    Address oldAssignment = (Address)this.keyAssignments.putIfAbsent(key, address);
    return (oldAssignment == null || oldAssignment.equals(address));
  }
  
  public void checkFullyProcessed(JobProcessInformation processInformation) {
    if (isOwnerNode()) {
      JobPartitionState[] partitionStates = processInformation.getPartitionStates();
      for (JobPartitionState partitionState : partitionStates) {
        if (partitionState == null || partitionState.getState() != JobPartitionState.State.PROCESSED)
          return; 
      } 
      String name = this.configuration.getName();
      String jobId = this.configuration.getJobId();
      NodeEngine nodeEngine = this.configuration.getNodeEngine();
      GetResultOperationFactory operationFactory = new GetResultOperationFactory(name, jobId);
      TrackableJobFuture future = this.jobTracker.unregisterTrackableJob(jobId);
      if (future == null)
        return; 
      JobSupervisor jobSupervisor = this;
      GetResultsRunnable getResultsRunnable = new GetResultsRunnable(this, nodeEngine, operationFactory, jobId, jobSupervisor, future);
      ExecutionService executionService = nodeEngine.getExecutionService();
      ManagedExecutorService executor = executionService.getExecutor("hz:async");
      executor.submit(getResultsRunnable);
    } 
  }
  
  public <K, V> DefaultContext<K, V> getOrCreateContext(MapCombineTask mapCombineTask) {
    DefaultContext<K, V> newContext = new DefaultContext<K, V>(this.configuration.getCombinerFactory(), mapCombineTask);
    if (this.context.compareAndSet(null, newContext))
      return newContext; 
    return (DefaultContext)this.context.get();
  }
  
  public void registerReducerEventInterests(int partitionId, Set<Address> remoteReducers) {
    Set<Address> addresses = (Set)this.remoteReducers.get(Integer.valueOf(partitionId));
    if (addresses == null) {
      addresses = new CopyOnWriteArraySet<Address>();
      Set<Address> oldSet = (Set)this.remoteReducers.putIfAbsent(Integer.valueOf(partitionId), addresses);
      if (oldSet != null)
        addresses = oldSet; 
    } 
    addresses.addAll(remoteReducers);
  }
  
  public Collection<Address> getReducerEventInterests(int partitionId) { return (Collection)this.remoteReducers.get(Integer.valueOf(partitionId)); }
  
  public JobProcessInformationImpl getJobProcessInformation() { return this.jobProcessInformation; }
  
  public Address getJobOwner() { return this.jobOwner; }
  
  public boolean isOwnerNode() { return this.ownerNode; }
  
  public JobTaskConfiguration getConfiguration() { return this.configuration; }
  
  private void collectResults(boolean reducedResult, Map<Object, Object> mergedResults, Map.Entry entry) {
    if (reducedResult) {
      mergedResults.put(entry.getKey(), entry.getValue());
    } else {
      List<Object> list = (List)mergedResults.get(entry.getKey());
      if (list == null) {
        list = new ArrayList<Object>();
        mergedResults.put(entry.getKey(), list);
      } 
      for (Object value : (List)entry.getValue())
        list.add(value); 
    } 
  }
  
  private Set<Address> collectRemoteAddresses() {
    Set<Address> addresses = new HashSet<Address>();
    for (Set<Address> remoteReducerAddresses : this.remoteReducers.values())
      addAllFilterJobOwner(addresses, remoteReducerAddresses); 
    for (JobPartitionState partitionState : this.jobProcessInformation.getPartitionStates()) {
      if (partitionState != null && partitionState.getOwner() != null && 
        !partitionState.getOwner().equals(this.jobOwner))
        addresses.add(partitionState.getOwner()); 
    } 
    return addresses;
  }
  
  private void asyncCancelRemoteOperations(Set<Address> addresses) {
    NodeEngine nodeEngine = this.mapReduceService.getNodeEngine();
    TaskScheduler taskScheduler = nodeEngine.getExecutionService().getGlobalTaskScheduler();
    taskScheduler.execute(new Object(this, addresses, nodeEngine));
  }
  
  private void addAllFilterJobOwner(Set<Address> target, Set<Address> source) {
    for (Address address : source) {
      if (this.jobOwner.equals(address))
        continue; 
      target.add(address);
    } 
  }
  
  private void processReducerFinished0(ReducingFinishedNotification notification) {
    String name = this.configuration.getName();
    String jobId = this.configuration.getJobId();
    int partitionId = notification.getPartitionId();
    Address reducerAddress = notification.getAddress();
    if (checkPartitionReductionCompleted(partitionId, reducerAddress))
      try {
        RequestPartitionResult result = (RequestPartitionResult)this.mapReduceService.processRequest(this.jobOwner, new RequestPartitionProcessed(name, jobId, partitionId, JobPartitionState.State.REDUCING));
        if (result.getResultState() != RequestPartitionResult.ResultState.SUCCESSFUL)
          throw new RuntimeException("Could not finalize processing for partitionId " + partitionId); 
      } catch (Throwable t) {
        MapReduceUtil.notifyRemoteException(this, t);
        if (t instanceof Error)
          ExceptionUtil.sneakyThrow(t); 
      }  
  }
  
  private boolean checkPartitionReductionCompleted(int partitionId, Address reducerAddress) {
    Set<Address> remoteAddresses = (Set)this.remoteReducers.get(Integer.valueOf(partitionId));
    if (remoteAddresses == null)
      throw new RuntimeException("Reducer for partition " + partitionId + " not registered"); 
    remoteAddresses.remove(reducerAddress);
    if (remoteAddresses.size() == 0 && 
      this.remoteReducers.remove(Integer.valueOf(partitionId)) != null)
      return true; 
    return false;
  }
}
