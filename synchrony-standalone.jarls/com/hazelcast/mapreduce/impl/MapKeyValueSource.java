package com.hazelcast.mapreduce.impl;

import com.hazelcast.internal.partition.InternalPartitionService;
import com.hazelcast.map.impl.MapService;
import com.hazelcast.map.impl.record.Record;
import com.hazelcast.map.impl.recordstore.RecordStore;
import com.hazelcast.mapreduce.KeyValueSource;
import com.hazelcast.mapreduce.PartitionIdAware;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.BinaryInterface;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.nio.serialization.IdentifiedDataSerializable;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.serialization.SerializationService;
import java.io.IOException;
import java.util.Iterator;
import java.util.Map;

@BinaryInterface
public class MapKeyValueSource<K, V> extends KeyValueSource<K, V> implements IdentifiedDataSerializable, PartitionIdAware {
  private final MapReduceSimpleEntry<K, V> cachedEntry = new MapReduceSimpleEntry();
  
  private String mapName;
  
  private int partitionId;
  
  private SerializationService ss;
  
  private Iterator<Record> iterator;
  
  private Record currentRecord;
  
  MapKeyValueSource() {}
  
  public MapKeyValueSource(String mapName) { this.mapName = mapName; }
  
  public String getMapName() { return this.mapName; }
  
  public boolean open(NodeEngine nodeEngine) {
    NodeEngineImpl nei = (NodeEngineImpl)nodeEngine;
    InternalPartitionService internalPartitionService = nei.getPartitionService();
    MapService mapService = (MapService)nei.getService("hz:impl:mapService");
    this.ss = nei.getSerializationService();
    Address partitionOwner = internalPartitionService.getPartitionOwner(this.partitionId);
    if (partitionOwner == null)
      return false; 
    RecordStore recordStore = mapService.getMapServiceContext().getRecordStore(this.partitionId, this.mapName);
    this.iterator = recordStore.iterator();
    return true;
  }
  
  public void close() {}
  
  public boolean hasNext() {
    boolean hasNext = this.iterator.hasNext();
    this.currentRecord = hasNext ? (Record)this.iterator.next() : null;
    return hasNext;
  }
  
  public K key() {
    if (this.currentRecord == null)
      throw new IllegalStateException("no more elements"); 
    Data keyData = this.currentRecord.getKey();
    K key = (K)this.ss.toObject(keyData);
    this.cachedEntry.setKeyData(keyData);
    this.cachedEntry.setKey(key);
    return key;
  }
  
  public Map.Entry<K, V> element() {
    if (this.currentRecord == null)
      throw new IllegalStateException("no more elements"); 
    if (!this.currentRecord.getKey().equals(this.cachedEntry.getKeyData()))
      this.cachedEntry.setKey(this.ss.toObject(this.currentRecord.getKey())); 
    this.cachedEntry.setValue(this.ss.toObject(this.currentRecord.getValue()));
    return this.cachedEntry;
  }
  
  public boolean reset() {
    this.iterator = null;
    this.currentRecord = null;
    return true;
  }
  
  public void setPartitionId(int partitionId) { this.partitionId = partitionId; }
  
  public void writeData(ObjectDataOutput out) throws IOException { out.writeUTF(this.mapName); }
  
  public void readData(ObjectDataInput in) throws IOException { this.mapName = in.readUTF(); }
  
  public int getFactoryId() { return MapReduceDataSerializerHook.F_ID; }
  
  public int getId() { return 0; }
}
