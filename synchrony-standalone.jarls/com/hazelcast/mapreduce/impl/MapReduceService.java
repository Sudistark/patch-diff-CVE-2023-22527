package com.hazelcast.mapreduce.impl;

import com.hazelcast.config.Config;
import com.hazelcast.core.DistributedObject;
import com.hazelcast.core.Member;
import com.hazelcast.internal.cluster.ClusterService;
import com.hazelcast.logging.ILogger;
import com.hazelcast.logging.Logger;
import com.hazelcast.mapreduce.JobTracker;
import com.hazelcast.mapreduce.impl.notification.MapReduceNotification;
import com.hazelcast.mapreduce.impl.operation.CancelJobSupervisorOperation;
import com.hazelcast.mapreduce.impl.operation.FireNotificationOperation;
import com.hazelcast.mapreduce.impl.operation.ProcessingOperation;
import com.hazelcast.mapreduce.impl.task.JobSupervisor;
import com.hazelcast.mapreduce.impl.task.JobTaskConfiguration;
import com.hazelcast.nio.Address;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.InvocationBuilder;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.RemoteService;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;

public class MapReduceService implements ManagedService, RemoteService {
  public static final String SERVICE_NAME = "hz:impl:mapReduceService";
  
  private static final ILogger LOGGER = Logger.getLogger(MapReduceService.class);
  
  private final ConstructorFunction<String, NodeJobTracker> constructor;
  
  private final ConcurrentMap<String, NodeJobTracker> jobTrackers;
  
  private final ConcurrentMap<JobSupervisorKey, JobSupervisor> jobSupervisors;
  
  private final IPartitionService partitionService;
  
  private final ClusterService clusterService;
  
  private final NodeEngineImpl nodeEngine;
  
  private final Config config;
  
  public MapReduceService(NodeEngine nodeEngine) {
    this.constructor = new Object(this);
    this.config = nodeEngine.getConfig();
    this.nodeEngine = (NodeEngineImpl)nodeEngine;
    this.clusterService = nodeEngine.getClusterService();
    this.partitionService = nodeEngine.getPartitionService();
    this.jobTrackers = new ConcurrentHashMap();
    this.jobSupervisors = new ConcurrentHashMap();
  }
  
  public JobTracker getJobTracker(String name) { return (JobTracker)createDistributedObject(name); }
  
  public JobSupervisor getJobSupervisor(String name, String jobId) {
    JobSupervisorKey key = new JobSupervisorKey(name, jobId, null);
    return (JobSupervisor)this.jobSupervisors.get(key);
  }
  
  public boolean registerJobSupervisorCancellation(String name, String jobId, Address jobOwner) {
    NodeJobTracker jobTracker = (NodeJobTracker)createDistributedObject(name);
    if (jobTracker.registerJobSupervisorCancellation(jobId) && getLocalAddress().equals(jobOwner)) {
      for (Member member : this.clusterService.getMembers()) {
        if (!member.getAddress().equals(jobOwner))
          try {
            CancelJobSupervisorOperation cancelJobSupervisorOperation = new CancelJobSupervisorOperation(name, jobId);
            processRequest(member.getAddress(), cancelJobSupervisorOperation);
          } catch (Exception ignore) {
            LOGGER.finest("Member might be already unavailable", ignore);
          }  
      } 
      return true;
    } 
    return false;
  }
  
  public boolean unregisterJobSupervisorCancellation(String name, String jobId) {
    NodeJobTracker jobTracker = (NodeJobTracker)createDistributedObject(name);
    return jobTracker.unregisterJobSupervisorCancellation(jobId);
  }
  
  public JobSupervisor createJobSupervisor(JobTaskConfiguration configuration) {
    NodeJobTracker jobTracker = (NodeJobTracker)createDistributedObject(configuration.getName());
    if (jobTracker.unregisterJobSupervisorCancellation(configuration.getJobId()))
      return null; 
    JobSupervisorKey key = new JobSupervisorKey(configuration.getName(), configuration.getJobId(), null);
    boolean ownerNode = this.nodeEngine.getThisAddress().equals(configuration.getJobOwner());
    JobSupervisor jobSupervisor = new JobSupervisor(configuration, jobTracker, ownerNode, this);
    JobSupervisor oldSupervisor = (JobSupervisor)this.jobSupervisors.putIfAbsent(key, jobSupervisor);
    return (oldSupervisor != null) ? oldSupervisor : jobSupervisor;
  }
  
  public boolean destroyJobSupervisor(JobSupervisor supervisor) {
    String name = supervisor.getConfiguration().getName();
    String jobId = supervisor.getConfiguration().getJobId();
    NodeJobTracker jobTracker = (NodeJobTracker)createDistributedObject(name);
    if (jobTracker != null)
      jobTracker.unregisterJobSupervisorCancellation(jobId); 
    JobSupervisorKey key = new JobSupervisorKey(supervisor, null);
    return (this.jobSupervisors.remove(key) == supervisor);
  }
  
  public ExecutorService getExecutorService(String name) { return this.nodeEngine.getExecutionService().getExecutor(MapReduceUtil.buildExecutorName(name)); }
  
  public void init(NodeEngine nodeEngine, Properties properties) {}
  
  public void reset() {}
  
  public void shutdown(boolean terminate) {
    for (JobTracker jobTracker : this.jobTrackers.values())
      jobTracker.destroy(); 
    this.jobTrackers.clear();
  }
  
  public DistributedObject createDistributedObject(String objectName) { return (DistributedObject)ConcurrencyUtil.getOrPutSynchronized(this.jobTrackers, objectName, this.jobTrackers, this.constructor); }
  
  public void destroyDistributedObject(String objectName) {
    JobTracker jobTracker = (JobTracker)this.jobTrackers.remove(objectName);
    if (jobTracker != null)
      jobTracker.destroy(); 
  }
  
  public Address getKeyMember(Object key) {
    int partitionId = this.partitionService.getPartitionId(key);
    return this.partitionService.getPartitionOwnerOrWait(partitionId);
  }
  
  public boolean checkAssignedMembersAvailable(Collection<Address> assignedMembers) {
    Collection<Member> members = this.clusterService.getMembers();
    List<Address> addresses = new ArrayList<Address>(members.size());
    for (Member member : members)
      addresses.add(member.getAddress()); 
    for (Address address : assignedMembers) {
      if (!addresses.contains(address))
        return false; 
    } 
    return true;
  }
  
  public <R> R processRequest(Address address, ProcessingOperation processingOperation) throws ExecutionException, InterruptedException {
    InvocationBuilder invocation = this.nodeEngine.getOperationService().createInvocationBuilder("hz:impl:mapReduceService", processingOperation, address);
    InternalCompletableFuture internalCompletableFuture = invocation.invoke();
    return (R)internalCompletableFuture.get();
  }
  
  public void sendNotification(Address address, MapReduceNotification notification) {
    try {
      FireNotificationOperation fireNotificationOperation = new FireNotificationOperation(notification);
      processRequest(address, fireNotificationOperation);
    } catch (Exception e) {
      throw new RuntimeException(e);
    } 
  }
  
  public final Address getLocalAddress() { return this.nodeEngine.getThisAddress(); }
  
  public NodeEngine getNodeEngine() { return this.nodeEngine; }
  
  public void dispatchEvent(MapReduceNotification notification) {
    String name = notification.getName();
    String jobId = notification.getJobId();
    JobSupervisor supervisor = getJobSupervisor(name, jobId);
    if (supervisor == null)
      throw new NullPointerException("JobSupervisor name=" + name + ", jobId=" + jobId + " not found"); 
    supervisor.onNotification(notification);
  }
}
