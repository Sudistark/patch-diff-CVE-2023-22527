package com.hazelcast.cardinality.impl;

import com.hazelcast.cardinality.impl.operations.ReplicationOperation;
import com.hazelcast.core.DistributedObject;
import com.hazelcast.partition.strategy.StringPartitioningStrategy;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.MigrationAwareService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.PartitionMigrationEvent;
import com.hazelcast.spi.PartitionReplicationEvent;
import com.hazelcast.spi.QuorumAwareService;
import com.hazelcast.spi.RemoteService;
import com.hazelcast.spi.SplitBrainHandlerService;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.spi.partition.MigrationEndpoint;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.ContextMutexFactory;
import com.hazelcast.util.MapUtil;
import com.hazelcast.util.Preconditions;
import java.util.Iterator;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class CardinalityEstimatorService implements ManagedService, RemoteService, MigrationAwareService, QuorumAwareService, SplitBrainHandlerService {
  public static final String SERVICE_NAME = "hz:impl:cardinalityEstimatorService";
  
  private static final double SIZING_FUDGE_FACTOR = 1.3D;
  
  private static final Object NULL_OBJECT = new Object();
  
  private NodeEngine nodeEngine;
  
  private final ConcurrentMap<String, CardinalityEstimatorContainer> containers = new ConcurrentHashMap();
  
  private final ConstructorFunction<String, CardinalityEstimatorContainer> cardinalityEstimatorContainerConstructorFunction = new Object(this);
  
  private final ConcurrentMap<String, Object> quorumConfigCache = new ConcurrentHashMap();
  
  private final ContextMutexFactory quorumConfigCacheMutexFactory = new ContextMutexFactory();
  
  private final ConstructorFunction<String, Object> quorumConfigConstructor = new Object(this);
  
  public void addCardinalityEstimator(String name, CardinalityEstimatorContainer container) {
    Preconditions.checkNotNull(name, "Name can't be null");
    Preconditions.checkNotNull(container, "Container can't be null");
    this.containers.put(name, container);
  }
  
  public CardinalityEstimatorContainer getCardinalityEstimatorContainer(String name) { return (CardinalityEstimatorContainer)ConcurrencyUtil.getOrPutIfAbsent(this.containers, name, this.cardinalityEstimatorContainerConstructorFunction); }
  
  public void init(NodeEngine nodeEngine, Properties properties) { this.nodeEngine = nodeEngine; }
  
  public void reset() { this.containers.clear(); }
  
  public void shutdown(boolean terminate) { reset(); }
  
  public CardinalityEstimatorProxy createDistributedObject(String objectName) { return new CardinalityEstimatorProxy(objectName, this.nodeEngine, this); }
  
  public void destroyDistributedObject(String objectName) {
    this.containers.remove(objectName);
    this.quorumConfigCache.remove(objectName);
  }
  
  public void beforeMigration(PartitionMigrationEvent event) {}
  
  public Operation prepareReplicationOperation(PartitionReplicationEvent event) {
    IPartitionService partitionService = this.nodeEngine.getPartitionService();
    int roughSize = (int)(this.containers.size() * 1.3D / partitionService.getPartitionCount());
    Map<String, CardinalityEstimatorContainer> data = MapUtil.createHashMap(roughSize);
    int partitionId = event.getPartitionId();
    for (Map.Entry<String, CardinalityEstimatorContainer> containerEntry : this.containers.entrySet()) {
      String name = (String)containerEntry.getKey();
      CardinalityEstimatorContainer container = (CardinalityEstimatorContainer)containerEntry.getValue();
      if (partitionId == getPartitionId(name) && event.getReplicaIndex() <= container.getTotalBackupCount())
        data.put(name, containerEntry.getValue()); 
    } 
    return data.isEmpty() ? null : new ReplicationOperation(data);
  }
  
  public void commitMigration(PartitionMigrationEvent event) {
    if (event.getMigrationEndpoint() == MigrationEndpoint.SOURCE)
      clearPartitionReplica(event.getPartitionId(), event.getNewReplicaIndex()); 
  }
  
  public void rollbackMigration(PartitionMigrationEvent event) {
    if (event.getMigrationEndpoint() == MigrationEndpoint.DESTINATION)
      clearPartitionReplica(event.getPartitionId(), event.getCurrentReplicaIndex()); 
  }
  
  private void clearPartitionReplica(int partitionId, int durabilityThreshold) {
    Iterator<Map.Entry<String, CardinalityEstimatorContainer>> iterator = this.containers.entrySet().iterator();
    while (iterator.hasNext()) {
      Map.Entry<String, CardinalityEstimatorContainer> entry = (Map.Entry)iterator.next();
      if (getPartitionId((String)entry.getKey()) == partitionId && (durabilityThreshold == -1 || durabilityThreshold > ((CardinalityEstimatorContainer)entry
        .getValue()).getTotalBackupCount()))
        iterator.remove(); 
    } 
  }
  
  private int getPartitionId(String name) {
    IPartitionService partitionService = this.nodeEngine.getPartitionService();
    String partitionKey = StringPartitioningStrategy.getPartitionKey(name);
    return partitionService.getPartitionId(partitionKey);
  }
  
  public String getQuorumName(String name) {
    Object quorumName = ConcurrencyUtil.getOrPutSynchronized(this.quorumConfigCache, name, this.quorumConfigCacheMutexFactory, this.quorumConfigConstructor);
    return (quorumName == NULL_OBJECT) ? null : (String)quorumName;
  }
  
  public Runnable prepareMergeRunnable() {
    CardinalityEstimatorContainerCollector collector = new CardinalityEstimatorContainerCollector(this.nodeEngine, this.containers);
    collector.run();
    return new Merger(this, collector);
  }
}
