package com.hazelcast.cardinality.impl.hyperloglog.impl;

import com.hazelcast.cardinality.impl.CardinalityEstimatorDataSerializerHook;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.impl.Versioned;
import java.io.IOException;
import java.util.Arrays;

public class SparseHyperLogLogEncoder implements HyperLogLogEncoder, Versioned {
  private static final int P_PRIME = 25;
  
  private static final int P_PRIME_MASK = 33554431;
  
  private static final long P_PRIME_FENCE_MASK = 274877906944L;
  
  private static final int DEFAULT_TEMP_CAPACITY = 200;
  
  private int p;
  
  private int pMask;
  
  private int pFenseMask;
  
  private long pDiffMask;
  
  private VariableLengthDiffArray register;
  
  private int[] temp;
  
  private int mPrime;
  
  private int tempIdx;
  
  public SparseHyperLogLogEncoder() {}
  
  SparseHyperLogLogEncoder(int p) { init(p, new VariableLengthDiffArray()); }
  
  public void init(int p, VariableLengthDiffArray register) {
    this.p = p;
    this.pMask = (1 << p) - 1;
    this.pFenseMask = 1 << 64 - p - 1;
    this.pDiffMask = (0x1FFFFFF ^ this.pMask);
    this.mPrime = 33554432;
    this.temp = new int[200];
    this.register = register;
  }
  
  public boolean add(long hash) {
    int encoded = encodeHash(hash);
    this.temp[this.tempIdx++] = encoded;
    boolean isTempAtCapacity = (this.tempIdx == 200);
    if (isTempAtCapacity)
      mergeAndResetTmp(); 
    return true;
  }
  
  public long estimate() {
    mergeAndResetTmp();
    return linearCounting(this.mPrime, this.mPrime - VariableLengthDiffArray.access$000(this.register));
  }
  
  public HyperLogLogEncoder merge(HyperLogLogEncoder encoder) {
    HyperLogLogEncoder dense = asDense();
    return dense.merge(encoder);
  }
  
  public int getFactoryId() { return CardinalityEstimatorDataSerializerHook.F_ID; }
  
  public int getId() { return 7; }
  
  public void writeData(ObjectDataOutput out) throws IOException {
    mergeAndResetTmp();
    out.writeInt(this.p);
    out.writeInt(VariableLengthDiffArray.access$000(this.register));
    out.writeInt(VariableLengthDiffArray.access$100(this.register));
    out.writeInt(VariableLengthDiffArray.access$200(this.register));
    out.writeByteArray(VariableLengthDiffArray.access$300(this.register));
  }
  
  public void readData(ObjectDataInput in) throws IOException {
    int p = in.readInt();
    int total = in.readInt();
    int mark = in.readInt();
    int prev = in.readInt();
    byte[] bytes = in.readByteArray();
    init(p, new VariableLengthDiffArray(bytes, total, mark, prev));
  }
  
  public HyperLogLogEncoding getEncodingType() { return HyperLogLogEncoding.SPARSE; }
  
  public int getMemoryFootprint() { return VariableLengthDiffArray.access$100(this.register) + 800; }
  
  HyperLogLogEncoder asDense() {
    mergeAndResetTmp();
    byte[] dense = new byte[1 << this.p];
    for (int hash : this.register.explode()) {
      int index = decodeHashPIndex(hash);
      dense[index] = (byte)Math.max(dense[index], decodeHashRunOfZeros(hash));
    } 
    return new DenseHyperLogLogEncoder(this.p, dense);
  }
  
  private int encodeHash(long hash) {
    if ((hash & this.pDiffMask) == 0L) {
      int newHash = (int)(hash & 0x1FFFFFFL) << 7;
      return newHash | Long.numberOfTrailingZeros(hash >>> 25 | 0x4000000000L) + 1 << 1 | true;
    } 
    return (int)(hash & 0x1FFFFFFL) << 1;
  }
  
  private int decodeHashPPrimeIndex(int hash) {
    if (!hasRunOfZerosEncoded(hash))
      return hash >> 1 & 0x1FFFFFF & this.mPrime - 1; 
    return hash >> 7 & 0x1FFFFFF & this.mPrime - 1;
  }
  
  private int decodeHashPIndex(long hash) {
    if (!hasRunOfZerosEncoded(hash))
      return (int)(hash >>> true) & this.pMask; 
    return (int)(hash >>> 7) & this.pMask;
  }
  
  private byte decodeHashRunOfZeros(int hash) {
    int stripedZeroFlag = hash >>> 1;
    if (!hasRunOfZerosEncoded(hash))
      return (byte)(Long.numberOfTrailingZeros((stripedZeroFlag >>> this.p | this.pFenseMask)) + 1); 
    int pW = stripedZeroFlag & 0x3F;
    return (byte)(pW + 25 - this.p);
  }
  
  private boolean hasRunOfZerosEncoded(long hash) { return ((hash & 0x1L) == 1L); }
  
  private long linearCounting(int total, int empty) { return (long)(total * Math.log(total / empty)); }
  
  private void mergeAndResetTmp() {
    if (this.tempIdx == 0)
      return; 
    int[] old = this.register.explode();
    int[] all = Arrays.copyOf(old, old.length + this.tempIdx);
    System.arraycopy(this.temp, 0, all, old.length, this.tempIdx);
    Arrays.sort(all);
    this.register.clear();
    int previousHash = all[0];
    for (int i = 1; i < all.length; i++) {
      int hash = all[i];
      boolean conflictingIndex = (decodeHashPPrimeIndex(hash) == decodeHashPPrimeIndex(previousHash));
      if (!conflictingIndex)
        this.register.add(previousHash); 
      previousHash = hash;
    } 
    this.register.add(previousHash);
    Arrays.fill(this.temp, 0);
    this.tempIdx = 0;
  }
}
