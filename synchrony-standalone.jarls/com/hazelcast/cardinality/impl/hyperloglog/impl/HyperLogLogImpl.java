package com.hazelcast.cardinality.impl.hyperloglog.impl;

import com.hazelcast.cardinality.impl.CardinalityEstimatorDataSerializerHook;
import com.hazelcast.cardinality.impl.hyperloglog.HyperLogLog;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.impl.Versioned;
import java.io.IOException;

public class HyperLogLogImpl implements HyperLogLog, Versioned {
  private static final int LOWER_P_BOUND = 4;
  
  private static final int UPPER_P_BOUND = 16;
  
  private static final int DEFAULT_P = 14;
  
  private int m;
  
  private HyperLogLogEncoder encoder;
  
  private Long cachedEstimate;
  
  public HyperLogLogImpl() { this(14); }
  
  public HyperLogLogImpl(int p) {
    if (p < 4 || p > 16)
      throw new IllegalArgumentException("Precision (p) outside valid range [4..16]."); 
    this.m = 1 << p;
    this.encoder = new SparseHyperLogLogEncoder(p);
  }
  
  public long estimate() {
    if (this.cachedEstimate == null)
      this.cachedEstimate = Long.valueOf(this.encoder.estimate()); 
    return this.cachedEstimate.longValue();
  }
  
  public void add(long hash) {
    convertToDenseIfNeeded();
    boolean changed = this.encoder.add(hash);
    if (changed)
      this.cachedEstimate = null; 
  }
  
  public void addAll(long[] hashes) {
    for (long hash : hashes)
      add(hash); 
  }
  
  public void merge(HyperLogLog other) {
    if (!(other instanceof HyperLogLogImpl))
      throw new IllegalStateException("Can't merge " + other + " into " + this); 
    this.encoder = this.encoder.merge(((HyperLogLogImpl)other).encoder);
    this.cachedEstimate = null;
  }
  
  public int getFactoryId() { return CardinalityEstimatorDataSerializerHook.F_ID; }
  
  public int getId() { return 5; }
  
  public void writeData(ObjectDataOutput out) throws IOException {
    out.writeObject(this.encoder);
    out.writeInt(this.m);
  }
  
  public void readData(ObjectDataInput in) throws IOException {
    this.encoder = (HyperLogLogEncoder)in.readObject();
    this.m = in.readInt();
  }
  
  private void convertToDenseIfNeeded() {
    boolean shouldConvertToDense = (HyperLogLogEncoding.SPARSE.equals(this.encoder.getEncodingType()) && this.encoder.getMemoryFootprint() >= this.m);
    if (shouldConvertToDense)
      this.encoder = ((SparseHyperLogLogEncoder)this.encoder).asDense(); 
  }
}
