package com.hazelcast.cardinality.impl.hyperloglog.impl;

import com.hazelcast.cardinality.impl.CardinalityEstimatorDataSerializerHook;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import java.io.IOException;
import java.util.Iterator;
import java.util.Map;
import java.util.NavigableMap;
import java.util.TreeMap;

public class DenseHyperLogLogEncoder implements HyperLogLogEncoder {
  private int p;
  
  private byte[] register;
  
  private int numOfEmptyRegs;
  
  private double[] invPowLookup;
  
  private int m;
  
  private long pFenseMask;
  
  public DenseHyperLogLogEncoder() {}
  
  public DenseHyperLogLogEncoder(int p) { this(p, null); }
  
  public DenseHyperLogLogEncoder(int p, byte[] register) { init(p, register); }
  
  private void init(int p, byte[] register) {
    this.p = p;
    this.m = 1 << p;
    this.numOfEmptyRegs = this.m;
    this.register = (register != null) ? register : new byte[this.m];
    this.invPowLookup = new double[64 - p + 1];
    this.pFenseMask = (1 << 64 - p - 1);
    prePopulateInvPowLookup();
  }
  
  public boolean add(long hash) {
    int index = (int)hash & this.register.length - 1;
    int value = Long.numberOfTrailingZeros(hash >>> this.p | this.pFenseMask) + 1;
    assert index < this.register.length;
    assert value <= 255;
    assert value <= 64 - this.p;
    if (value > this.register[index]) {
      this.register[index] = (byte)value;
      return true;
    } 
    return false;
  }
  
  public long estimate() {
    double raw = 1.0D / computeE() * alpha() * this.m * this.m;
    return applyRangeCorrection(raw);
  }
  
  public HyperLogLogEncoder merge(HyperLogLogEncoder encoder) {
    DenseHyperLogLogEncoder otherDense;
    if (HyperLogLogEncoding.SPARSE.equals(encoder.getEncodingType())) {
      otherDense = (DenseHyperLogLogEncoder)((SparseHyperLogLogEncoder)encoder).asDense();
    } else {
      otherDense = (DenseHyperLogLogEncoder)encoder;
    } 
    for (int i = 0; i < this.register.length; i++)
      this.register[i] = (byte)Math.max(this.register[i], otherDense.register[i]); 
    return this;
  }
  
  public int getFactoryId() { return CardinalityEstimatorDataSerializerHook.F_ID; }
  
  public int getId() { return 6; }
  
  public void writeData(ObjectDataOutput out) throws IOException {
    out.writeInt(this.p);
    out.writeByteArray(this.register);
  }
  
  public void readData(ObjectDataInput in) throws IOException {
    init(in.readInt(), null);
    this.register = in.readByteArray();
  }
  
  public int getMemoryFootprint() { return this.m; }
  
  public HyperLogLogEncoding getEncodingType() { return HyperLogLogEncoding.DENSE; }
  
  private double alpha() {
    assert this.m >= 16;
    if (this.m >= 128)
      return 0.7213D / (1.0D + 1.079D / this.m); 
    if (this.m == 64)
      return 0.709D; 
    if (this.m == 32)
      return 0.697D; 
    if (this.m == 16)
      return 0.673D; 
    return -1.0D;
  }
  
  private long applyRangeCorrection(double e) {
    double ePrime = (e <= (this.m * 5)) ? (e - estimateBias(e)) : e;
    double h = (this.numOfEmptyRegs != 0) ? linearCounting(this.m, this.numOfEmptyRegs) : ePrime;
    return (long)(exceedsThreshold(h) ? ePrime : h);
  }
  
  private double computeE() {
    double e = 0.0D;
    this.numOfEmptyRegs = 0;
    for (byte r : this.register) {
      if (r > 0) {
        e += invPow(r);
      } else {
        this.numOfEmptyRegs++;
      } 
    } 
    return e + this.numOfEmptyRegs;
  }
  
  private long estimateBias(double e) {
    int i = 0;
    double[] rawEstimates = DenseHyperLogLogConstants.RAW_ESTIMATE_DATA[this.p - 4];
    double closestToZero = Math.abs(e - rawEstimates[0]);
    NavigableMap<Double, Integer> distances = new TreeMap<Double, Integer>();
    for (double est : rawEstimates) {
      double distance = e - est;
      distances.put(Double.valueOf(distance), Integer.valueOf(i++));
      if (Math.abs(distance) < closestToZero)
        closestToZero = distance; 
    } 
    int kNN = 6;
    double sum = 0.0D;
    Iterator<Map.Entry<Double, Integer>> firstX = distances.descendingMap().tailMap(Double.valueOf(closestToZero)).entrySet().iterator();
    Iterator<Map.Entry<Double, Integer>> lastX = distances.tailMap(Double.valueOf(closestToZero)).entrySet().iterator();
    int kNNLeft = kNN;
    while (kNNLeft-- > kNN / 2 && firstX.hasNext())
      sum += DenseHyperLogLogConstants.BIAS_DATA[this.p - 4][((Integer)((Map.Entry)firstX.next()).getValue()).intValue()]; 
    while (kNNLeft-- >= 0 && lastX.hasNext())
      sum += DenseHyperLogLogConstants.BIAS_DATA[this.p - 4][((Integer)((Map.Entry)lastX.next()).getValue()).intValue()]; 
    return (long)(sum / kNN);
  }
  
  private boolean exceedsThreshold(double e) { return (e >= DenseHyperLogLogConstants.THRESHOLD[this.p - 4]); }
  
  private double invPow(int index) {
    assert index <= 64 - this.p;
    return this.invPowLookup[index];
  }
  
  private long linearCounting(int total, int empty) { return (long)(total * Math.log(total / empty)); }
  
  private void prePopulateInvPowLookup() {
    this.invPowLookup[0] = 1.0D;
    for (int i = 1; i <= 64 - this.p; i++)
      this.invPowLookup[i] = Math.pow(2.0D, -i); 
  }
}
