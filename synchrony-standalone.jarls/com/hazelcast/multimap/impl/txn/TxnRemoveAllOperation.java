package com.hazelcast.multimap.impl.txn;

import com.hazelcast.core.EntryEventType;
import com.hazelcast.multimap.impl.MultiMapContainer;
import com.hazelcast.multimap.impl.MultiMapRecord;
import com.hazelcast.multimap.impl.MultiMapService;
import com.hazelcast.multimap.impl.MultiMapValue;
import com.hazelcast.multimap.impl.operations.AbstractKeyBasedMultiMapOperation;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.BackupAwareOperation;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.impl.MutatingOperation;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedList;

public class TxnRemoveAllOperation extends AbstractKeyBasedMultiMapOperation implements BackupAwareOperation, MutatingOperation {
  private Collection<Long> recordIds;
  
  private long startTimeNanos;
  
  private Collection<MultiMapRecord> removed;
  
  public TxnRemoveAllOperation() {}
  
  public TxnRemoveAllOperation(String name, Data dataKey, Collection<MultiMapRecord> records) {
    super(name, dataKey);
    this.recordIds = new ArrayList();
    for (MultiMapRecord record : records)
      this.recordIds.add(Long.valueOf(record.getRecordId())); 
  }
  
  public void run() {
    this.startTimeNanos = System.nanoTime();
    MultiMapContainer container = getOrCreateContainer();
    MultiMapValue multiMapValue = container.getOrCreateMultiMapValue(this.dataKey);
    for (Long recordId : this.recordIds) {
      if (!multiMapValue.containsRecordId(recordId.longValue())) {
        this.response = Boolean.valueOf(false);
        return;
      } 
    } 
    this.response = Boolean.valueOf(true);
    container.update();
    Collection<MultiMapRecord> coll = multiMapValue.getCollection(false);
    this.removed = new LinkedList();
    for (Long recordId : this.recordIds) {
      Iterator<MultiMapRecord> iter = coll.iterator();
      while (iter.hasNext()) {
        MultiMapRecord record = (MultiMapRecord)iter.next();
        if (record.getRecordId() == recordId.longValue()) {
          iter.remove();
          this.removed.add(record);
        } 
      } 
    } 
    if (coll.isEmpty())
      container.delete(this.dataKey); 
  }
  
  public void afterRun() {
    long elapsed = Math.max(0L, System.nanoTime() - this.startTimeNanos);
    MultiMapService service = (MultiMapService)getService();
    service.getLocalMultiMapStatsImpl(this.name).incrementRemoveLatencyNanos(elapsed);
    if (this.removed != null)
      for (MultiMapRecord record : this.removed)
        publishEvent(EntryEventType.REMOVED, this.dataKey, null, record.getObject());  
  }
  
  public boolean shouldBackup() { return Boolean.TRUE.equals(this.response); }
  
  public Operation getBackupOperation() { return new TxnRemoveAllBackupOperation(this.name, this.dataKey, this.recordIds); }
  
  public Collection<Long> getRecordIds() { return this.recordIds; }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException {
    super.writeInternal(out);
    out.writeInt(this.recordIds.size());
    for (Long recordId : this.recordIds)
      out.writeLong(recordId.longValue()); 
  }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    super.readInternal(in);
    int size = in.readInt();
    this.recordIds = new ArrayList();
    for (int i = 0; i < size; i++)
      this.recordIds.add(Long.valueOf(in.readLong())); 
  }
  
  public int getId() { return 37; }
}
