package com.hazelcast.multimap.impl.txn;

import com.hazelcast.multimap.impl.MultiMapContainer;
import com.hazelcast.multimap.impl.MultiMapRecord;
import com.hazelcast.multimap.impl.MultiMapValue;
import com.hazelcast.multimap.impl.operations.AbstractKeyBasedMultiMapOperation;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.BackupOperation;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class TxnRemoveAllBackupOperation extends AbstractKeyBasedMultiMapOperation implements BackupOperation {
  private Collection<Long> recordIds;
  
  public TxnRemoveAllBackupOperation() {}
  
  public TxnRemoveAllBackupOperation(String name, Data dataKey, Collection<Long> recordIds) {
    super(name, dataKey);
    this.recordIds = recordIds;
  }
  
  public void run() {
    MultiMapContainer container = getOrCreateContainerWithoutAccess();
    MultiMapValue multiMapValue = container.getOrCreateMultiMapValue(this.dataKey);
    for (Long recordId : this.recordIds) {
      if (!multiMapValue.containsRecordId(recordId.longValue())) {
        this.response = Boolean.valueOf(false);
        return;
      } 
    } 
    this.response = Boolean.valueOf(true);
    Collection<MultiMapRecord> coll = multiMapValue.getCollection(false);
    for (Long recordId : this.recordIds) {
      Iterator<MultiMapRecord> iterator = coll.iterator();
      while (iterator.hasNext()) {
        MultiMapRecord record = (MultiMapRecord)iterator.next();
        if (record.getRecordId() == recordId.longValue())
          iterator.remove(); 
      } 
    } 
    if (coll.isEmpty())
      container.delete(this.dataKey); 
  }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException {
    super.writeInternal(out);
    out.writeInt(this.recordIds.size());
    for (Long recordId : this.recordIds)
      out.writeLong(recordId.longValue()); 
  }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    super.readInternal(in);
    int size = in.readInt();
    this.recordIds = new ArrayList();
    for (int i = 0; i < size; i++)
      this.recordIds.add(Long.valueOf(in.readLong())); 
  }
  
  public int getId() { return 38; }
}
