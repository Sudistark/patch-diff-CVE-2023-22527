package com.hazelcast.multimap.impl;

import com.hazelcast.concurrent.lock.LockService;
import com.hazelcast.config.MultiMapConfig;
import com.hazelcast.core.DistributedObject;
import com.hazelcast.core.EntryEventType;
import com.hazelcast.core.EntryListener;
import com.hazelcast.internal.cluster.ClusterService;
import com.hazelcast.internal.config.ConfigValidator;
import com.hazelcast.map.impl.event.EventData;
import com.hazelcast.monitor.LocalMultiMapStats;
import com.hazelcast.monitor.impl.LocalMultiMapStatsImpl;
import com.hazelcast.multimap.impl.operations.MultiMapReplicationOperation;
import com.hazelcast.multimap.impl.txn.TransactionalMultiMapProxy;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.quorum.QuorumService;
import com.hazelcast.quorum.QuorumType;
import com.hazelcast.spi.EventPublishingService;
import com.hazelcast.spi.EventRegistration;
import com.hazelcast.spi.EventService;
import com.hazelcast.spi.FragmentedMigrationAwareService;
import com.hazelcast.spi.LockInterceptorService;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.ObjectNamespace;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.PartitionMigrationEvent;
import com.hazelcast.spi.PartitionReplicationEvent;
import com.hazelcast.spi.QuorumAwareService;
import com.hazelcast.spi.RemoteService;
import com.hazelcast.spi.ServiceNamespace;
import com.hazelcast.spi.SplitBrainHandlerService;
import com.hazelcast.spi.StatisticsAwareService;
import com.hazelcast.spi.TransactionalService;
import com.hazelcast.spi.partition.IPartition;
import com.hazelcast.spi.partition.MigrationEndpoint;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.transaction.impl.Transaction;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.ContextMutexFactory;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.MapUtil;
import java.util.Collection;
import java.util.EventListener;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class MultiMapService extends Object implements ManagedService, RemoteService, FragmentedMigrationAwareService, EventPublishingService<EventData, EntryListener>, TransactionalService, StatisticsAwareService<LocalMultiMapStats>, QuorumAwareService, SplitBrainHandlerService, LockInterceptorService<Data> {
  public static final String SERVICE_NAME = "hz:impl:multiMapService";
  
  private static final Object NULL_OBJECT = new Object();
  
  private static final int STATS_MAP_INITIAL_CAPACITY = 1000;
  
  private static final int REPLICA_ADDRESS_TRY_COUNT = 3;
  
  private static final int REPLICA_ADDRESS_SLEEP_WAIT_MILLIS = 1000;
  
  private final NodeEngine nodeEngine;
  
  private final MultiMapPartitionContainer[] partitionContainers;
  
  private final ConcurrentMap<String, LocalMultiMapStatsImpl> statsMap;
  
  private final ConstructorFunction<String, LocalMultiMapStatsImpl> localMultiMapStatsConstructorFunction;
  
  private final MultiMapEventsDispatcher dispatcher;
  
  private final MultiMapEventsPublisher publisher;
  
  private final QuorumService quorumService;
  
  private final ConcurrentMap<String, Object> quorumConfigCache;
  
  private final ContextMutexFactory quorumConfigCacheMutexFactory;
  
  private final ConstructorFunction<String, Object> quorumConfigConstructor;
  
  public MultiMapService(NodeEngine nodeEngine) {
    this.statsMap = MapUtil.createConcurrentHashMap(1000);
    this.localMultiMapStatsConstructorFunction = new Object(this);
    this.quorumConfigCache = new ConcurrentHashMap();
    this.quorumConfigCacheMutexFactory = new ContextMutexFactory();
    this.quorumConfigConstructor = new Object(this);
    this.nodeEngine = nodeEngine;
    int partitionCount = nodeEngine.getPartitionService().getPartitionCount();
    this.partitionContainers = new MultiMapPartitionContainer[partitionCount];
    this.dispatcher = new MultiMapEventsDispatcher(this, nodeEngine.getClusterService());
    this.publisher = new MultiMapEventsPublisher(nodeEngine);
    this.quorumService = nodeEngine.getQuorumService();
  }
  
  public void init(NodeEngine nodeEngine, Properties properties) {
    int partitionCount = nodeEngine.getPartitionService().getPartitionCount();
    for (int partition = 0; partition < partitionCount; partition++)
      this.partitionContainers[partition] = new MultiMapPartitionContainer(this, partition); 
    LockService lockService = (LockService)nodeEngine.getSharedService("hz:impl:lockService");
    if (lockService != null)
      lockService.registerLockStoreConstructor("hz:impl:multiMapService", new Object(this, nodeEngine)); 
  }
  
  public void reset() {
    for (MultiMapPartitionContainer container : this.partitionContainers) {
      if (container != null)
        container.destroy(); 
    } 
  }
  
  public void shutdown(boolean terminate) {
    reset();
    for (int i = 0; i < this.partitionContainers.length; i++)
      this.partitionContainers[i] = null; 
  }
  
  public MultiMapContainer getOrCreateCollectionContainer(int partitionId, String name) { return this.partitionContainers[partitionId].getOrCreateMultiMapContainer(name); }
  
  public MultiMapContainer getOrCreateCollectionContainerWithoutAccess(int partitionId, String name) { return this.partitionContainers[partitionId].getOrCreateMultiMapContainer(name, false); }
  
  public MultiMapPartitionContainer getPartitionContainer(int partitionId) { return this.partitionContainers[partitionId]; }
  
  public DistributedObject createDistributedObject(String name) {
    MultiMapConfig multiMapConfig = this.nodeEngine.getConfig().findMultiMapConfig(name);
    ConfigValidator.checkMultiMapConfig(multiMapConfig, this.nodeEngine.getSplitBrainMergePolicyProvider());
    return new ObjectMultiMapProxy(multiMapConfig, this, this.nodeEngine, name);
  }
  
  public void destroyDistributedObject(String name) {
    for (MultiMapPartitionContainer container : this.partitionContainers) {
      if (container != null)
        container.destroyMultiMap(name); 
    } 
    this.nodeEngine.getEventService().deregisterAllListeners("hz:impl:multiMapService", name);
    this.quorumConfigCache.remove(name);
  }
  
  public Set<Data> localKeySet(String name) {
    Set<Data> keySet = new HashSet<Data>();
    for (int i = 0; i < this.nodeEngine.getPartitionService().getPartitionCount(); i++) {
      MultiMapContainer multiMapContainer;
      IPartition partition = this.nodeEngine.getPartitionService().getPartition(i);
      boolean isLocalPartition = partition.isLocal();
      MultiMapPartitionContainer partitionContainer = getPartitionContainer(i);
      if (isLocalPartition) {
        multiMapContainer = partitionContainer.getMultiMapContainer(name);
      } else {
        multiMapContainer = partitionContainer.getMultiMapContainerWithoutAccess(name);
      } 
      if (multiMapContainer != null)
        if (isLocalPartition)
          keySet.addAll(multiMapContainer.keySet());  
    } 
    getLocalMultiMapStatsImpl(name).incrementOtherOperations();
    return keySet;
  }
  
  public SerializationService getSerializationService() { return this.nodeEngine.getSerializationService(); }
  
  public NodeEngine getNodeEngine() { return this.nodeEngine; }
  
  public void publishMultiMapEvent(String mapName, EntryEventType eventType, int numberOfEntriesAffected) { this.publisher.publishMultiMapEvent(mapName, eventType, numberOfEntriesAffected); }
  
  public final void publishEntryEvent(String multiMapName, EntryEventType eventType, Data key, Object newValue, Object oldValue) { this.publisher.publishEntryEvent(multiMapName, eventType, key, newValue, oldValue); }
  
  public String addListener(String name, EventListener listener, Data key, boolean includeValue, boolean local) {
    EventRegistration registration;
    EventService eventService = this.nodeEngine.getEventService();
    MultiMapEventFilter filter = new MultiMapEventFilter(includeValue, key);
    if (local) {
      registration = eventService.registerLocalListener("hz:impl:multiMapService", name, filter, listener);
    } else {
      registration = eventService.registerListener("hz:impl:multiMapService", name, filter, listener);
    } 
    return registration.getId();
  }
  
  public boolean removeListener(String name, String registrationId) {
    EventService eventService = this.nodeEngine.getEventService();
    return eventService.deregisterListener("hz:impl:multiMapService", name, registrationId);
  }
  
  public Collection<ServiceNamespace> getAllServiceNamespaces(PartitionReplicationEvent event) {
    MultiMapPartitionContainer partitionContainer = this.partitionContainers[event.getPartitionId()];
    if (partitionContainer == null)
      return null; 
    return partitionContainer.getAllNamespaces(event.getReplicaIndex());
  }
  
  public boolean isKnownServiceNamespace(ServiceNamespace namespace) { return (namespace instanceof ObjectNamespace && "hz:impl:multiMapService".equals(namespace.getServiceName())); }
  
  public void beforeMigration(PartitionMigrationEvent partitionMigrationEvent) {}
  
  public Operation prepareReplicationOperation(PartitionReplicationEvent event) {
    MultiMapPartitionContainer partitionContainer = this.partitionContainers[event.getPartitionId()];
    if (partitionContainer == null)
      return null; 
    return prepareReplicationOperation(event, partitionContainer.getAllNamespaces(event.getReplicaIndex()));
  }
  
  public Operation prepareReplicationOperation(PartitionReplicationEvent event, Collection<ServiceNamespace> namespaces) {
    MultiMapPartitionContainer partitionContainer = this.partitionContainers[event.getPartitionId()];
    if (partitionContainer == null)
      return null; 
    int replicaIndex = event.getReplicaIndex();
    Map<String, Map<Data, MultiMapValue>> map = MapUtil.createHashMap(namespaces.size());
    for (ServiceNamespace namespace : namespaces) {
      assert isKnownServiceNamespace(namespace) : namespace + " is not a MultiMapService namespace!";
      ObjectNamespace ns = (ObjectNamespace)namespace;
      MultiMapContainer container = (MultiMapContainer)partitionContainer.containerMap.get(ns.getObjectName());
      if (container == null)
        continue; 
      if (container.getConfig().getTotalBackupCount() < replicaIndex)
        continue; 
      map.put(ns.getObjectName(), container.getMultiMapValues());
    } 
    return map.isEmpty() ? null : new MultiMapReplicationOperation(map);
  }
  
  public void insertMigratedData(int partitionId, Map<String, Map<Data, MultiMapValue>> map) {
    for (Map.Entry<String, Map<Data, MultiMapValue>> entry : map.entrySet()) {
      String name = (String)entry.getKey();
      MultiMapContainer container = getOrCreateCollectionContainerWithoutAccess(partitionId, name);
      Map<Data, MultiMapValue> collections = (Map)entry.getValue();
      long maxRecordId = -1L;
      for (Map.Entry<Data, MultiMapValue> multiMapValueEntry : collections.entrySet()) {
        MultiMapValue multiMapValue = (MultiMapValue)multiMapValueEntry.getValue();
        container.getMultiMapValues().put(multiMapValueEntry.getKey(), multiMapValue);
        long recordId = getMaxRecordId(multiMapValue);
        maxRecordId = Math.max(maxRecordId, recordId);
      } 
      container.setId(maxRecordId);
    } 
  }
  
  private long getMaxRecordId(MultiMapValue multiMapValue) {
    long maxRecordId = -1L;
    for (MultiMapRecord record : multiMapValue.getCollection(false))
      maxRecordId = Math.max(maxRecordId, record.getRecordId()); 
    return maxRecordId;
  }
  
  public void commitMigration(PartitionMigrationEvent event) {
    if (event.getMigrationEndpoint() == MigrationEndpoint.SOURCE)
      clearMapsHavingLesserBackupCountThan(event.getPartitionId(), event.getNewReplicaIndex()); 
  }
  
  public void rollbackMigration(PartitionMigrationEvent event) {
    if (event.getMigrationEndpoint() == MigrationEndpoint.DESTINATION)
      clearMapsHavingLesserBackupCountThan(event.getPartitionId(), event.getCurrentReplicaIndex()); 
  }
  
  private void clearMapsHavingLesserBackupCountThan(int partitionId, int thresholdReplicaIndex) {
    MultiMapPartitionContainer partitionContainer = this.partitionContainers[partitionId];
    if (partitionContainer == null)
      return; 
    ConcurrentMap<String, MultiMapContainer> containerMap = partitionContainer.containerMap;
    if (thresholdReplicaIndex < 0) {
      for (MultiMapContainer container : containerMap.values())
        container.destroy(); 
      containerMap.clear();
      return;
    } 
    Iterator<MultiMapContainer> iterator = containerMap.values().iterator();
    while (iterator.hasNext()) {
      MultiMapContainer container = (MultiMapContainer)iterator.next();
      if (thresholdReplicaIndex > container.getConfig().getTotalBackupCount()) {
        container.destroy();
        iterator.remove();
      } 
    } 
  }
  
  public LocalMultiMapStats createStats(String name) {
    LocalMultiMapStatsImpl stats = getLocalMultiMapStatsImpl(name);
    long ownedEntryCount = 0L;
    long backupEntryCount = 0L;
    long hits = 0L;
    long lockedEntryCount = 0L;
    long lastAccessTime = 0L;
    long lastUpdateTime = 0L;
    ClusterService clusterService = this.nodeEngine.getClusterService();
    MultiMapConfig config = this.nodeEngine.getConfig().findMultiMapConfig(name);
    int backupCount = config.getTotalBackupCount();
    Address thisAddress = clusterService.getThisAddress();
    for (int partitionId = 0; partitionId < this.nodeEngine.getPartitionService().getPartitionCount(); partitionId++) {
      IPartition partition = this.nodeEngine.getPartitionService().getPartition(partitionId, false);
      MultiMapPartitionContainer partitionContainer = getPartitionContainer(partitionId);
      MultiMapContainer multiMapContainer = partitionContainer.getMultiMapContainerWithoutAccess(name);
      if (multiMapContainer != null) {
        Address owner = partition.getOwnerOrNull();
        if (owner != null)
          if (owner.equals(thisAddress)) {
            lockedEntryCount += multiMapContainer.getLockedCount();
            lastAccessTime = Math.max(lastAccessTime, multiMapContainer.getLastAccessTime());
            lastUpdateTime = Math.max(lastUpdateTime, multiMapContainer.getLastUpdateTime());
            for (MultiMapValue multiMapValue : multiMapContainer.getMultiMapValues().values()) {
              hits += multiMapValue.getHits();
              ownedEntryCount += multiMapValue.getCollection(false).size();
            } 
          } else {
            for (int j = 1; j <= backupCount; j++) {
              Address replicaAddress = getReplicaAddress(partition, backupCount, j);
              if (replicaAddress != null && replicaAddress.equals(thisAddress))
                for (MultiMapValue multiMapValue : multiMapContainer.getMultiMapValues().values())
                  backupEntryCount += multiMapValue.getCollection(false).size();  
            } 
          }  
      } 
    } 
    stats.setOwnedEntryCount(ownedEntryCount);
    stats.setBackupEntryCount(backupEntryCount);
    stats.setHits(hits);
    stats.setLockedEntryCount(lockedEntryCount);
    stats.setBackupCount(backupCount);
    stats.setLastAccessTime(lastAccessTime);
    stats.setLastUpdateTime(lastUpdateTime);
    return stats;
  }
  
  public LocalMultiMapStatsImpl getLocalMultiMapStatsImpl(String name) { return (LocalMultiMapStatsImpl)ConcurrencyUtil.getOrPutIfAbsent(this.statsMap, name, this.localMultiMapStatsConstructorFunction); }
  
  public <T extends com.hazelcast.transaction.TransactionalObject> T createTransactionalObject(String name, Transaction transaction) { return (T)new TransactionalMultiMapProxy(this.nodeEngine, this, name, transaction); }
  
  public void rollbackTransaction(String transactionId) {}
  
  public void dispatchEvent(EventData event, EntryListener listener) { this.dispatcher.dispatchEvent(event, listener); }
  
  public Map<String, LocalMultiMapStats> getStats() {
    Map<String, LocalMultiMapStats> multiMapStats = new HashMap<String, LocalMultiMapStats>();
    for (MultiMapPartitionContainer partitionContainer : this.partitionContainers) {
      if (partitionContainer != null)
        for (String name : partitionContainer.containerMap.keySet()) {
          if (!multiMapStats.containsKey(name))
            multiMapStats.put(name, createStats(name)); 
        }  
    } 
    return multiMapStats;
  }
  
  private Address getReplicaAddress(IPartition partition, int backupCount, int replicaIndex) {
    Address replicaAddress = partition.getReplicaAddress(replicaIndex);
    int tryCount = 3;
    int maxAllowedBackupCount = Math.min(backupCount, this.nodeEngine.getPartitionService().getMaxAllowedBackupCount());
    while (maxAllowedBackupCount > replicaIndex && replicaAddress == null && tryCount-- > 0) {
      try {
        Thread.sleep(1000L);
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw ExceptionUtil.rethrow(e);
      } 
      replicaAddress = partition.getReplicaAddress(replicaIndex);
    } 
    return replicaAddress;
  }
  
  public String getQuorumName(String name) {
    Object quorumName = ConcurrencyUtil.getOrPutSynchronized(this.quorumConfigCache, name, this.quorumConfigCacheMutexFactory, this.quorumConfigConstructor);
    return (quorumName == NULL_OBJECT) ? null : (String)quorumName;
  }
  
  public void ensureQuorumPresent(String distributedObjectName, QuorumType requiredQuorumPermissionType) { this.quorumService.ensureQuorumPresent(getQuorumName(distributedObjectName), requiredQuorumPermissionType); }
  
  public Runnable prepareMergeRunnable() {
    MultiMapContainerCollector collector = new MultiMapContainerCollector(this.nodeEngine, this.partitionContainers);
    collector.run();
    return new Merger(this, collector);
  }
  
  public void onBeforeLock(String distributedObjectName, Data key) {
    int partitionId = this.nodeEngine.getPartitionService().getPartitionId(key);
    MultiMapPartitionContainer partitionContainer = getPartitionContainer(partitionId);
    partitionContainer.getOrCreateMultiMapContainer(distributedObjectName);
  }
}
