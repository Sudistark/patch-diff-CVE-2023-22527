package com.hazelcast.crdt.pncounter;

import com.hazelcast.cluster.impl.VectorClock;
import com.hazelcast.core.ConsistencyLostException;
import com.hazelcast.crdt.CRDT;
import com.hazelcast.crdt.CRDTDataSerializerHook;
import com.hazelcast.crdt.MutationDisallowedException;
import com.hazelcast.crdt.pncounter.operations.CRDTTimestampedLong;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.IdentifiedDataSerializable;
import com.hazelcast.util.MapUtil;
import java.io.IOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class PNCounterImpl extends Object implements CRDT<PNCounterImpl>, IdentifiedDataSerializable {
  private String localReplicaId;
  
  private String name;
  
  private Map<String, long[]> state;
  
  private VectorClock stateVectorClock;
  
  private final ReadWriteLock stateReadWriteLock;
  
  private final Lock stateReadLock;
  
  private final Lock stateWriteLock;
  
  PNCounterImpl(String localReplicaId, String name) {
    this.state = new ConcurrentHashMap();
    this.stateVectorClock = new VectorClock();
    this.stateReadWriteLock = new ReentrantReadWriteLock();
    this.stateReadLock = this.stateReadWriteLock.readLock();
    this.stateWriteLock = this.stateReadWriteLock.writeLock();
    this.localReplicaId = localReplicaId;
    this.stateVectorClock.setReplicaTimestamp(localReplicaId, Float.MIN_VALUE);
    this.name = name;
  }
  
  public PNCounterImpl() {
    this.state = new ConcurrentHashMap();
    this.stateVectorClock = new VectorClock();
    this.stateReadWriteLock = new ReentrantReadWriteLock();
    this.stateReadLock = this.stateReadWriteLock.readLock();
    this.stateWriteLock = this.stateReadWriteLock.writeLock();
  }
  
  public CRDTTimestampedLong get(VectorClock observedTimestamps) {
    checkSessionConsistency(observedTimestamps);
    this.stateReadLock.lock();
    try {
      long value = 0L;
      for (long[] pnValue : this.state.values()) {
        value += pnValue[0];
        value -= pnValue[1];
      } 
      return new CRDTTimestampedLong(value, new VectorClock(this.stateVectorClock));
    } finally {
      this.stateReadLock.unlock();
    } 
  }
  
  public CRDTTimestampedLong getAndAdd(long delta, VectorClock observedTimestamps) {
    checkSessionConsistency(observedTimestamps);
    this.stateWriteLock.lock();
    try {
      checkNotMigrated();
      if (delta < 0L)
        return getAndSubtract(-delta, observedTimestamps); 
      return getAndUpdate(delta, observedTimestamps, true);
    } finally {
      this.stateWriteLock.unlock();
    } 
  }
  
  public CRDTTimestampedLong addAndGet(long delta, VectorClock observedTimestamps) {
    checkSessionConsistency(observedTimestamps);
    this.stateWriteLock.lock();
    try {
      checkNotMigrated();
      if (delta < 0L)
        return subtractAndGet(-delta, observedTimestamps); 
      return updateAndGet(delta, observedTimestamps, true);
    } finally {
      this.stateWriteLock.unlock();
    } 
  }
  
  public CRDTTimestampedLong getAndSubtract(long delta, VectorClock observedTimestamps) {
    checkSessionConsistency(observedTimestamps);
    this.stateWriteLock.lock();
    try {
      checkNotMigrated();
      if (delta < 0L)
        return getAndAdd(-delta, observedTimestamps); 
      return getAndUpdate(delta, observedTimestamps, false);
    } finally {
      this.stateWriteLock.unlock();
    } 
  }
  
  public CRDTTimestampedLong subtractAndGet(long delta, VectorClock observedTimestamps) {
    checkSessionConsistency(observedTimestamps);
    this.stateWriteLock.lock();
    try {
      checkNotMigrated();
      if (delta < 0L)
        return addAndGet(-delta, observedTimestamps); 
      return updateAndGet(delta, observedTimestamps, false);
    } finally {
      this.stateWriteLock.unlock();
    } 
  }
  
  private void checkSessionConsistency(VectorClock lastReadVectorClock) {
    if (lastReadVectorClock != null && lastReadVectorClock.isAfter(this.stateVectorClock))
      throw new ConsistencyLostException("This replica cannot provide the session guarantees for the PN counter since it's state is stale"); 
  }
  
  private CRDTTimestampedLong updateAndGet(long delta, VectorClock observedTimestamps, boolean isAddition) {
    if (delta < 0L)
      throw new IllegalArgumentException("Delta must be greater than or equal to 0"); 
    long nextTimestamp = this.stateVectorClock.getTimestampForReplica(this.localReplicaId).longValue() + 1L;
    new long[2][0] = 0L;
    new long[2][1] = 0L;
    long[] pnValues = this.state.containsKey(this.localReplicaId) ? (long[])this.state.get(this.localReplicaId) : new long[2];
    pnValues[isAddition ? 0 : 1] = pnValues[isAddition ? 0 : 1] + delta;
    this.state.put(this.localReplicaId, pnValues);
    this.stateVectorClock.setReplicaTimestamp(this.localReplicaId, nextTimestamp);
    return get(observedTimestamps);
  }
  
  private CRDTTimestampedLong getAndUpdate(long delta, VectorClock observedTimestamps, boolean isAddition) {
    if (delta < 0L)
      throw new IllegalArgumentException("Delta must be greater than or equal to 0"); 
    long nextTimestamp = this.stateVectorClock.getTimestampForReplica(this.localReplicaId).longValue() + 1L;
    new long[2][0] = 0L;
    new long[2][1] = 0L;
    long[] pnValues = this.state.containsKey(this.localReplicaId) ? (long[])this.state.get(this.localReplicaId) : new long[2];
    pnValues[isAddition ? 0 : 1] = pnValues[isAddition ? 0 : 1] + delta;
    this.state.put(this.localReplicaId, pnValues);
    this.stateVectorClock.setReplicaTimestamp(this.localReplicaId, nextTimestamp);
    CRDTTimestampedLong current = get(observedTimestamps);
    current.setValue(isAddition ? (current.getValue() - delta) : (current.getValue() + delta));
    return current;
  }
  
  public void merge(PNCounterImpl other) {
    this.stateWriteLock.lock();
    try {
      checkNotMigrated();
      for (Map.Entry<String, long[]> pnCounterEntry : other.state.entrySet()) {
        String replicaId = (String)pnCounterEntry.getKey();
        long[] pnOtherValues = (long[])pnCounterEntry.getValue();
        new long[2][0] = 0L;
        new long[2][1] = 0L;
        long[] pnValues = this.state.containsKey(replicaId) ? (long[])this.state.get(replicaId) : new long[2];
        pnValues[0] = Math.max(pnValues[0], pnOtherValues[0]);
        pnValues[1] = Math.max(pnValues[1], pnOtherValues[1]);
        this.state.put(replicaId, pnValues);
      } 
      this.stateVectorClock.merge(other.stateVectorClock);
    } finally {
      this.stateWriteLock.unlock();
    } 
  }
  
  public VectorClock getCurrentVectorClock() { return new VectorClock(this.stateVectorClock); }
  
  public int getFactoryId() { return CRDTDataSerializerHook.F_ID; }
  
  public int getId() { return 2; }
  
  public void writeData(ObjectDataOutput out) throws IOException {
    this.stateReadLock.lock();
    try {
      out.writeObject(this.stateVectorClock);
      out.writeInt(this.state.size());
      for (Map.Entry<String, long[]> replicaState : this.state.entrySet()) {
        String replicaID = (String)replicaState.getKey();
        long[] replicaCounts = (long[])replicaState.getValue();
        out.writeUTF(replicaID);
        out.writeLong(replicaCounts[0]);
        out.writeLong(replicaCounts[1]);
      } 
    } finally {
      this.stateReadLock.unlock();
    } 
  }
  
  public void readData(ObjectDataInput in) throws IOException {
    this.stateWriteLock.lock();
    try {
      this.stateVectorClock = (VectorClock)in.readObject();
      int stateSize = in.readInt();
      this.state = MapUtil.createHashMap(stateSize);
      for (int i = 0; i < stateSize; i++) {
        String replicaID = in.readUTF();
        long[] replicaCounts = { in.readLong(), in.readLong() };
        this.state.put(replicaID, replicaCounts);
      } 
    } finally {
      this.stateWriteLock.unlock();
    } 
  }
  
  public boolean markMigrated(VectorClock vectorClock) {
    this.stateWriteLock.lock();
    try {
      if (this.stateVectorClock.equals(vectorClock))
        this.migrated = true; 
      return this.migrated;
    } finally {
      this.stateWriteLock.unlock();
    } 
  }
  
  public void markMigrated() {
    this.stateWriteLock.lock();
    try {
      this.migrated = true;
    } finally {
      this.stateWriteLock.unlock();
    } 
  }
  
  private void checkNotMigrated() {
    if (this.migrated)
      throw new MutationDisallowedException("The CRDT state for the " + this.name + " + PN counter has already been migrated and cannot be updated"); 
  }
}
