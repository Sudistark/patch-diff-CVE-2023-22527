package com.hazelcast.collection.impl.collection;

import com.hazelcast.collection.impl.common.DataAwareItemEvent;
import com.hazelcast.collection.impl.txncollection.operations.CollectionTransactionRollbackOperation;
import com.hazelcast.core.ItemEventType;
import com.hazelcast.core.ItemListener;
import com.hazelcast.instance.MemberImpl;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.partition.strategy.StringPartitioningStrategy;
import com.hazelcast.spi.EventPublishingService;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.MigrationAwareService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.OperationService;
import com.hazelcast.spi.PartitionMigrationEvent;
import com.hazelcast.spi.PartitionReplicationEvent;
import com.hazelcast.spi.QuorumAwareService;
import com.hazelcast.spi.RemoteService;
import com.hazelcast.spi.SplitBrainHandlerService;
import com.hazelcast.spi.TransactionalService;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.spi.partition.MigrationEndpoint;
import com.hazelcast.spi.serialization.SerializationService;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentMap;

public abstract class CollectionService extends Object implements ManagedService, RemoteService, EventPublishingService<CollectionEvent, ItemListener<Data>>, TransactionalService, MigrationAwareService, QuorumAwareService, SplitBrainHandlerService {
  protected final NodeEngine nodeEngine;
  
  protected final SerializationService serializationService;
  
  protected final IPartitionService partitionService;
  
  private final ILogger logger;
  
  protected CollectionService(NodeEngine nodeEngine) {
    this.nodeEngine = nodeEngine;
    this.serializationService = nodeEngine.getSerializationService();
    this.partitionService = nodeEngine.getPartitionService();
    this.logger = nodeEngine.getLogger(getClass());
  }
  
  public void init(NodeEngine nodeEngine, Properties properties) {}
  
  public void reset() { getContainerMap().clear(); }
  
  public void shutdown(boolean terminate) { reset(); }
  
  public void destroyDistributedObject(String name) {
    CollectionContainer container = (CollectionContainer)getContainerMap().remove(name);
    if (container != null)
      container.destroy(); 
    this.nodeEngine.getEventService().deregisterAllListeners(getServiceName(), name);
  }
  
  public void dispatchEvent(CollectionEvent event, ItemListener<Data> listener) {
    MemberImpl member = this.nodeEngine.getClusterService().getMember(event.getCaller());
    DataAwareItemEvent dataAwareItemEvent = new DataAwareItemEvent(event.getName(), event.getEventType(), event.getData(), member, this.serializationService);
    if (member == null) {
      if (this.logger.isInfoEnabled())
        this.logger.info("Dropping event " + dataAwareItemEvent + " from unknown address:" + event.getCaller()); 
      return;
    } 
    if (event.getEventType().equals(ItemEventType.ADDED)) {
      listener.itemAdded(dataAwareItemEvent);
    } else {
      listener.itemRemoved(dataAwareItemEvent);
    } 
  }
  
  public void rollbackTransaction(String transactionId) {
    Set<String> collectionNames = getContainerMap().keySet();
    OperationService operationService = this.nodeEngine.getOperationService();
    for (String name : collectionNames) {
      int partitionId = this.partitionService.getPartitionId(StringPartitioningStrategy.getPartitionKey(name));
      Operation operation = (new CollectionTransactionRollbackOperation(name, transactionId)).setPartitionId(partitionId).setService(this).setNodeEngine(this.nodeEngine);
      operationService.invokeOnPartition(operation);
    } 
  }
  
  public void beforeMigration(PartitionMigrationEvent event) {}
  
  protected Map<String, CollectionContainer> getMigrationData(PartitionReplicationEvent event) {
    Map<String, CollectionContainer> migrationData = new HashMap<String, CollectionContainer>();
    for (Map.Entry<String, ? extends CollectionContainer> entry : getContainerMap().entrySet()) {
      String name = (String)entry.getKey();
      int partitionId = this.partitionService.getPartitionId(StringPartitioningStrategy.getPartitionKey(name));
      CollectionContainer container = (CollectionContainer)entry.getValue();
      if (partitionId == event.getPartitionId() && container.getConfig().getTotalBackupCount() >= event.getReplicaIndex())
        migrationData.put(name, container); 
    } 
    return migrationData;
  }
  
  public void commitMigration(PartitionMigrationEvent event) {
    if (event.getMigrationEndpoint() == MigrationEndpoint.SOURCE)
      clearCollectionsHavingLesserBackupCountThan(event.getPartitionId(), event.getNewReplicaIndex()); 
  }
  
  public void rollbackMigration(PartitionMigrationEvent event) {
    if (event.getMigrationEndpoint() == MigrationEndpoint.DESTINATION)
      clearCollectionsHavingLesserBackupCountThan(event.getPartitionId(), event.getCurrentReplicaIndex()); 
  }
  
  private void clearCollectionsHavingLesserBackupCountThan(int partitionId, int thresholdReplicaIndex) {
    Set<? extends Map.Entry<String, ? extends CollectionContainer>> entrySet = getContainerMap().entrySet();
    Iterator<? extends Map.Entry<String, ? extends CollectionContainer>> iterator = entrySet.iterator();
    while (iterator.hasNext()) {
      Map.Entry<String, ? extends CollectionContainer> entry = (Map.Entry)iterator.next();
      String name = (String)entry.getKey();
      CollectionContainer container = (CollectionContainer)entry.getValue();
      int containerPartitionId = this.partitionService.getPartitionId(StringPartitioningStrategy.getPartitionKey(name));
      if (containerPartitionId != partitionId)
        continue; 
      if (thresholdReplicaIndex < 0 || thresholdReplicaIndex > container.getConfig().getTotalBackupCount()) {
        container.destroy();
        iterator.remove();
      } 
    } 
  }
  
  public void addContainer(String name, CollectionContainer container) { getRawContainerMap().put(name, container); }
  
  private ConcurrentMap<String, CollectionContainer> getRawContainerMap() { return getContainerMap(); }
  
  public Runnable prepareMergeRunnable() {
    CollectionContainerCollector collector = new CollectionContainerCollector(this.nodeEngine, getRawContainerMap());
    collector.run();
    return new Merger(this, collector);
  }
  
  public abstract CollectionContainer getOrCreateContainer(String paramString, boolean paramBoolean);
  
  public abstract ConcurrentMap<String, ? extends CollectionContainer> getContainerMap();
  
  public abstract String getServiceName();
}
