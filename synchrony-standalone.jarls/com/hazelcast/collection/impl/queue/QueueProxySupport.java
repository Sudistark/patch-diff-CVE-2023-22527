package com.hazelcast.collection.impl.queue;

import com.hazelcast.collection.impl.queue.operations.AddAllOperation;
import com.hazelcast.collection.impl.queue.operations.ClearOperation;
import com.hazelcast.collection.impl.queue.operations.CompareAndRemoveOperation;
import com.hazelcast.collection.impl.queue.operations.ContainsOperation;
import com.hazelcast.collection.impl.queue.operations.DrainOperation;
import com.hazelcast.collection.impl.queue.operations.IsEmptyOperation;
import com.hazelcast.collection.impl.queue.operations.IteratorOperation;
import com.hazelcast.collection.impl.queue.operations.OfferOperation;
import com.hazelcast.collection.impl.queue.operations.PeekOperation;
import com.hazelcast.collection.impl.queue.operations.PollOperation;
import com.hazelcast.collection.impl.queue.operations.QueueOperation;
import com.hazelcast.collection.impl.queue.operations.RemainingCapacityOperation;
import com.hazelcast.collection.impl.queue.operations.RemoveOperation;
import com.hazelcast.collection.impl.queue.operations.SizeOperation;
import com.hazelcast.config.ItemListenerConfig;
import com.hazelcast.config.QueueConfig;
import com.hazelcast.core.HazelcastInstanceAware;
import com.hazelcast.core.ItemListener;
import com.hazelcast.nio.ClassLoaderUtil;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.AbstractDistributedObject;
import com.hazelcast.spi.InitializingObject;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.OperationService;
import com.hazelcast.spi.impl.SerializableList;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.Preconditions;
import java.util.Collection;
import java.util.List;

abstract class QueueProxySupport extends AbstractDistributedObject<QueueService> implements InitializingObject {
  final String name;
  
  final int partitionId;
  
  final QueueConfig config;
  
  QueueProxySupport(String name, QueueService queueService, NodeEngine nodeEngine, QueueConfig config) {
    super(nodeEngine, queueService);
    this.name = name;
    this.partitionId = nodeEngine.getPartitionService().getPartitionId(getNameAsPartitionAwareData());
    this.config = config;
  }
  
  public void initialize() {
    NodeEngine nodeEngine = getNodeEngine();
    List<ItemListenerConfig> itemListenerConfigs = this.config.getItemListenerConfigs();
    for (ItemListenerConfig itemListenerConfig : itemListenerConfigs) {
      ItemListener listener = itemListenerConfig.getImplementation();
      if (listener == null && itemListenerConfig.getClassName() != null)
        try {
          listener = (ItemListener)ClassLoaderUtil.newInstance(nodeEngine.getConfigClassLoader(), itemListenerConfig
              .getClassName());
        } catch (Exception e) {
          throw ExceptionUtil.rethrow(e);
        }  
      if (listener != null) {
        if (listener instanceof HazelcastInstanceAware)
          ((HazelcastInstanceAware)listener).setHazelcastInstance(nodeEngine.getHazelcastInstance()); 
        addItemListener(listener, itemListenerConfig.isIncludeValue());
      } 
    } 
  }
  
  public int getPartitionId() { return this.partitionId; }
  
  boolean offerInternal(Data data, long timeout) throws InterruptedException {
    checkObjectNotNull(data);
    OfferOperation operation = new OfferOperation(this.name, timeout, data);
    return ((Boolean)invokeAndGet(operation, InterruptedException.class)).booleanValue();
  }
  
  public boolean isEmpty() {
    IsEmptyOperation operation = new IsEmptyOperation(this.name);
    return ((Boolean)invokeAndGet(operation)).booleanValue();
  }
  
  public int size() {
    SizeOperation operation = new SizeOperation(this.name);
    return ((Integer)invokeAndGet(operation)).intValue();
  }
  
  public int remainingCapacity() {
    RemainingCapacityOperation operation = new RemainingCapacityOperation(this.name);
    return ((Integer)invokeAndGet(operation)).intValue();
  }
  
  public void clear() {
    ClearOperation operation = new ClearOperation(this.name);
    invokeAndGet(operation);
  }
  
  Object peekInternal() {
    PeekOperation operation = new PeekOperation(this.name);
    return invokeAndGetData(operation);
  }
  
  Object pollInternal(long timeout) throws InterruptedException {
    PollOperation operation = new PollOperation(this.name, timeout);
    return invokeAndGet(operation, InterruptedException.class);
  }
  
  boolean removeInternal(Data data) {
    checkObjectNotNull(data);
    RemoveOperation operation = new RemoveOperation(this.name, data);
    return ((Boolean)invokeAndGet(operation)).booleanValue();
  }
  
  boolean containsInternal(Collection<Data> dataList) {
    ContainsOperation operation = new ContainsOperation(this.name, dataList);
    return ((Boolean)invokeAndGet(operation)).booleanValue();
  }
  
  List<Data> listInternal() {
    IteratorOperation operation = new IteratorOperation(this.name);
    SerializableList collectionContainer = (SerializableList)invokeAndGet(operation);
    return collectionContainer.getCollection();
  }
  
  Collection<Data> drainInternal(int maxSize) {
    DrainOperation operation = new DrainOperation(this.name, maxSize);
    SerializableList collectionContainer = (SerializableList)invokeAndGet(operation);
    return collectionContainer.getCollection();
  }
  
  boolean addAllInternal(Collection<Data> dataList) {
    AddAllOperation operation = new AddAllOperation(this.name, dataList);
    return ((Boolean)invokeAndGet(operation)).booleanValue();
  }
  
  boolean compareAndRemove(Collection<Data> dataList, boolean retain) {
    CompareAndRemoveOperation operation = new CompareAndRemoveOperation(this.name, dataList, retain);
    return ((Boolean)invokeAndGet(operation)).booleanValue();
  }
  
  protected void checkObjectNotNull(Object o) { Preconditions.checkNotNull(o, "Object is null"); }
  
  private <T> T invokeAndGet(QueueOperation operation) { return (T)invokeAndGet(operation, RuntimeException.class); }
  
  private <T, E extends Throwable> T invokeAndGet(QueueOperation operation, Class<E> allowedException) throws E {
    NodeEngine nodeEngine = getNodeEngine();
    try {
      InternalCompletableFuture internalCompletableFuture = invoke(operation);
      return (T)nodeEngine.toObject(internalCompletableFuture.get());
    } catch (Throwable throwable) {
      throw ExceptionUtil.rethrow(throwable, allowedException);
    } 
  }
  
  private InternalCompletableFuture invoke(Operation operation) {
    NodeEngine nodeEngine = getNodeEngine();
    OperationService operationService = nodeEngine.getOperationService();
    return operationService.invokeOnPartition("hz:impl:queueService", operation, getPartitionId());
  }
  
  private Object invokeAndGetData(QueueOperation operation) {
    NodeEngine nodeEngine = getNodeEngine();
    try {
      OperationService operationService = nodeEngine.getOperationService();
      InternalCompletableFuture internalCompletableFuture = operationService.invokeOnPartition("hz:impl:queueService", operation, this.partitionId);
      return internalCompletableFuture.get();
    } catch (Throwable throwable) {
      throw ExceptionUtil.rethrow(throwable);
    } 
  }
  
  public final String getServiceName() { return "hz:impl:queueService"; }
  
  public final String getName() { return this.name; }
  
  public String addItemListener(ItemListener listener, boolean includeValue) { return ((QueueService)getService()).addItemListener(this.name, listener, includeValue, false); }
  
  public boolean removeItemListener(String registrationId) { return ((QueueService)getService()).removeItemListener(this.name, registrationId); }
}
