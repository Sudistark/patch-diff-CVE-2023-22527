package com.hazelcast.collection.impl.queue.operations;

import com.hazelcast.collection.impl.queue.QueueContainer;
import com.hazelcast.collection.impl.queue.QueueDataSerializerHook;
import com.hazelcast.collection.impl.queue.QueueService;
import com.hazelcast.config.Config;
import com.hazelcast.config.QueueConfig;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.IdentifiedDataSerializable;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.util.MapUtil;
import java.io.IOException;
import java.util.Map;

public class QueueReplicationOperation extends Operation implements IdentifiedDataSerializable {
  private Map<String, QueueContainer> migrationData;
  
  public QueueReplicationOperation() {}
  
  public QueueReplicationOperation(Map<String, QueueContainer> migrationData, int partitionId, int replicaIndex) {
    setPartitionId(partitionId).setReplicaIndex(replicaIndex);
    this.migrationData = migrationData;
  }
  
  public void run() {
    QueueService service = (QueueService)getService();
    NodeEngine nodeEngine = getNodeEngine();
    Config config = nodeEngine.getConfig();
    for (Map.Entry<String, QueueContainer> entry : this.migrationData.entrySet()) {
      String name = (String)entry.getKey();
      QueueContainer container = (QueueContainer)entry.getValue();
      QueueConfig conf = config.findQueueConfig(name);
      container.setConfig(conf, nodeEngine, service);
      service.addContainer(name, container);
    } 
  }
  
  public String getServiceName() { return "hz:impl:queueService"; }
  
  public int getFactoryId() { return QueueDataSerializerHook.F_ID; }
  
  public int getId() { return 18; }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException {
    out.writeInt(this.migrationData.size());
    for (Map.Entry<String, QueueContainer> entry : this.migrationData.entrySet()) {
      out.writeUTF((String)entry.getKey());
      QueueContainer container = (QueueContainer)entry.getValue();
      container.writeData(out);
    } 
  }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    int mapSize = in.readInt();
    this.migrationData = MapUtil.createHashMap(mapSize);
    for (int i = 0; i < mapSize; i++) {
      String name = in.readUTF();
      QueueContainer container = new QueueContainer(name);
      container.readData(in);
      this.migrationData.put(name, container);
    } 
  }
}
