package com.hazelcast.collection.impl.queue;

import com.hazelcast.collection.impl.txnqueue.TxQueueItem;
import com.hazelcast.config.QueueConfig;
import com.hazelcast.config.QueueStoreConfig;
import com.hazelcast.core.HazelcastException;
import com.hazelcast.logging.ILogger;
import com.hazelcast.monitor.impl.LocalQueueStatsImpl;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.nio.serialization.IdentifiedDataSerializable;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.transaction.TransactionException;
import com.hazelcast.util.Clock;
import com.hazelcast.util.MapUtil;
import com.hazelcast.util.SetUtil;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

public class QueueContainer implements IdentifiedDataSerializable {
  private final Map<Long, TxQueueItem> txMap = new HashMap();
  
  private final Map<Long, Data> dataMap = new HashMap();
  
  private QueueWaitNotifyKey pollWaitNotifyKey;
  
  private QueueWaitNotifyKey offerWaitNotifyKey;
  
  private LinkedList<QueueItem> itemQueue;
  
  private Map<Long, QueueItem> backupMap;
  
  private QueueConfig config;
  
  private QueueStoreWrapper store;
  
  private NodeEngine nodeEngine;
  
  private QueueService service;
  
  private ILogger logger;
  
  private long idGenerator;
  
  private String name;
  
  private long minAge = Float.MAX_VALUE;
  
  private long maxAge = Float.MIN_VALUE;
  
  private long totalAge;
  
  private long totalAgedCount;
  
  private boolean isEvictionScheduled;
  
  private long lastIdLoaded;
  
  public QueueContainer() {}
  
  public QueueContainer(String name) {
    this.name = name;
    this.pollWaitNotifyKey = new QueueWaitNotifyKey(name, "poll");
    this.offerWaitNotifyKey = new QueueWaitNotifyKey(name, "offer");
  }
  
  public QueueContainer(String name, QueueConfig config, NodeEngine nodeEngine, QueueService service) {
    this(name);
    setConfig(config, nodeEngine, service);
  }
  
  public void init(boolean fromBackup) {
    if (!fromBackup && this.store.isEnabled()) {
      Set<Long> keys = this.store.loadAllKeys();
      if (keys != null) {
        long maxId = -1L;
        for (Long key : keys) {
          QueueItem item = new QueueItem(this, key.longValue(), null);
          getItemQueue().offer(item);
          maxId = Math.max(maxId, key.longValue());
        } 
        this.idGenerator = maxId + 1L;
      } 
    } 
  }
  
  public QueueStoreWrapper getStore() { return this.store; }
  
  public String getName() { return this.name; }
  
  public boolean txnCheckReserve(long itemId) {
    if (this.txMap.get(Long.valueOf(itemId)) == null)
      throw new TransactionException("No reserve for itemId: " + itemId); 
    return true;
  }
  
  public void txnEnsureBackupReserve(long itemId, String transactionId, boolean pollOperation) {
    if (this.txMap.get(Long.valueOf(itemId)) == null)
      if (pollOperation) {
        txnPollBackupReserve(itemId, transactionId);
      } else {
        txnOfferBackupReserve(itemId, transactionId);
      }  
  }
  
  public QueueItem txnPollReserve(long reservedOfferId, String transactionId) {
    item = (QueueItem)getItemQueue().peek();
    if (item == null) {
      TxQueueItem txItem = (TxQueueItem)this.txMap.remove(Long.valueOf(reservedOfferId));
      if (txItem == null)
        return null; 
      return new QueueItem(this, txItem.getItemId(), txItem.getData());
    } 
    if (this.store.isEnabled() && item.getData() == null)
      try {
        load(item);
      } catch (Exception e) {
        throw new HazelcastException(e);
      }  
    getItemQueue().poll();
    this.txMap.put(Long.valueOf(item.getItemId()), (new TxQueueItem(item)).setPollOperation(true).setTransactionId(transactionId));
    return item;
  }
  
  public void txnPollBackupReserve(long itemId, String transactionId) {
    QueueItem item = (QueueItem)getBackupMap().remove(Long.valueOf(itemId));
    if (item != null) {
      this.txMap.put(Long.valueOf(itemId), (new TxQueueItem(item)).setPollOperation(true).setTransactionId(transactionId));
      return;
    } 
    if (this.txMap.remove(Long.valueOf(itemId)) == null)
      this.logger.warning("Poll backup reserve failed, itemId: " + itemId + " is not found"); 
  }
  
  public Data txnCommitPoll(long itemId) {
    Data result = txnCommitPollBackup(itemId);
    scheduleEvictionIfEmpty();
    return result;
  }
  
  public Data txnCommitPollBackup(long itemId) {
    TxQueueItem item = (TxQueueItem)this.txMap.remove(Long.valueOf(itemId));
    if (item == null) {
      this.logger.warning("txnCommitPoll operation-> No txn item for itemId: " + itemId);
      return null;
    } 
    if (this.store.isEnabled())
      try {
        this.store.delete(Long.valueOf(item.getItemId()));
      } catch (Exception e) {
        this.logger.severe("Error during store delete: " + item.getItemId(), e);
      }  
    return item.getData();
  }
  
  public boolean txnRollbackPoll(long itemId, boolean backup) {
    TxQueueItem item = (TxQueueItem)this.txMap.remove(Long.valueOf(itemId));
    if (item == null)
      return false; 
    if (backup) {
      getBackupMap().put(Long.valueOf(itemId), item);
    } else {
      addTxItemOrdered(item);
    } 
    cancelEvictionIfExists();
    return true;
  }
  
  private void addTxItemOrdered(TxQueueItem txQueueItem) {
    ListIterator<QueueItem> iterator = ((List)getItemQueue()).listIterator();
    while (iterator.hasNext()) {
      QueueItem queueItem = (QueueItem)iterator.next();
      if (txQueueItem.itemId < queueItem.itemId) {
        iterator.previous();
        break;
      } 
    } 
    iterator.add(txQueueItem);
  }
  
  public long txnOfferReserve(String transactionId) {
    long itemId = nextId();
    txnOfferReserveInternal(itemId, transactionId);
    return itemId;
  }
  
  public void txnOfferBackupReserve(long itemId, String transactionId) {
    TxQueueItem o = txnOfferReserveInternal(itemId, transactionId);
    if (o != null)
      this.logger.severe("txnOfferBackupReserve operation-> Item exists already at txMap for itemId: " + itemId); 
  }
  
  private TxQueueItem txnOfferReserveInternal(long itemId, String transactionId) {
    TxQueueItem item = (new TxQueueItem(this, itemId, null)).setTransactionId(transactionId).setPollOperation(false);
    return (TxQueueItem)this.txMap.put(Long.valueOf(itemId), item);
  }
  
  public boolean txnCommitOffer(long itemId, Data data, boolean backup) {
    QueueItem item = (QueueItem)this.txMap.remove(Long.valueOf(itemId));
    if (item == null && !backup)
      throw new TransactionException("No reserve: " + itemId); 
    if (item == null)
      item = new QueueItem(this, itemId, data); 
    item.setData(data);
    if (!backup) {
      getItemQueue().offer(item);
      cancelEvictionIfExists();
    } else {
      getBackupMap().put(Long.valueOf(itemId), item);
    } 
    if (this.store.isEnabled() && !backup)
      try {
        this.store.store(Long.valueOf(item.getItemId()), data);
      } catch (Exception e) {
        this.logger.warning("Exception during store", e);
      }  
    return true;
  }
  
  public boolean txnRollbackOffer(long itemId) {
    boolean result = txnRollbackOfferBackup(itemId);
    scheduleEvictionIfEmpty();
    return result;
  }
  
  public boolean txnRollbackOfferBackup(long itemId) {
    QueueItem item = (QueueItem)this.txMap.remove(Long.valueOf(itemId));
    if (item == null) {
      this.logger.warning("txnRollbackOffer operation-> No txn item for itemId: " + itemId);
      return false;
    } 
    return true;
  }
  
  public QueueItem txnPeek(long offerId, String transactionId) {
    item = (QueueItem)getItemQueue().peek();
    if (item == null) {
      if (offerId == -1L)
        return null; 
      TxQueueItem txItem = (TxQueueItem)this.txMap.get(Long.valueOf(offerId));
      if (txItem == null)
        return null; 
      return new QueueItem(this, txItem.getItemId(), txItem.getData());
    } 
    if (this.store.isEnabled() && item.getData() == null)
      try {
        load(item);
      } catch (Exception e) {
        throw new HazelcastException(e);
      }  
    return item;
  }
  
  public long offer(Data data) {
    QueueItem item = new QueueItem(this, nextId(), null);
    if (this.store.isEnabled())
      try {
        this.store.store(Long.valueOf(item.getItemId()), data);
      } catch (Exception e) {
        throw new HazelcastException(e);
      }  
    if (!this.store.isEnabled() || this.store.getMemoryLimit() > getItemQueue().size())
      item.setData(data); 
    getItemQueue().offer(item);
    cancelEvictionIfExists();
    return item.getItemId();
  }
  
  public void offerBackup(Data data, long itemId) {
    QueueItem item = new QueueItem(this, itemId, null);
    if (!this.store.isEnabled() || this.store.getMemoryLimit() > getItemQueue().size())
      item.setData(data); 
    getBackupMap().put(Long.valueOf(itemId), item);
  }
  
  public Map<Long, Data> addAll(Collection<Data> dataList) {
    Map<Long, Data> map = MapUtil.createHashMap(dataList.size());
    List<QueueItem> list = new ArrayList<QueueItem>(dataList.size());
    for (Data data : dataList) {
      QueueItem item = new QueueItem(this, nextId(), null);
      if (!this.store.isEnabled() || this.store.getMemoryLimit() > getItemQueue().size())
        item.setData(data); 
      map.put(Long.valueOf(item.getItemId()), data);
      list.add(item);
    } 
    if (this.store.isEnabled() && !map.isEmpty())
      try {
        this.store.storeAll(map);
      } catch (Exception e) {
        throw new HazelcastException(e);
      }  
    if (!list.isEmpty()) {
      getItemQueue().addAll(list);
      cancelEvictionIfExists();
    } 
    return map;
  }
  
  public void addAllBackup(Map<Long, Data> dataMap) {
    for (Map.Entry<Long, Data> entry : dataMap.entrySet()) {
      QueueItem item = new QueueItem(this, ((Long)entry.getKey()).longValue(), null);
      if (!this.store.isEnabled() || this.store.getMemoryLimit() > getItemQueue().size())
        item.setData((Data)entry.getValue()); 
      getBackupMap().put(Long.valueOf(item.getItemId()), item);
    } 
  }
  
  public QueueItem peek() {
    QueueItem item = (QueueItem)getItemQueue().peek();
    if (item == null)
      return null; 
    if (this.store.isEnabled() && item.getData() == null)
      try {
        load(item);
      } catch (Exception e) {
        throw new HazelcastException(e);
      }  
    return item;
  }
  
  public QueueItem poll() {
    QueueItem item = peek();
    if (item == null)
      return null; 
    if (this.store.isEnabled())
      try {
        this.store.delete(Long.valueOf(item.getItemId()));
      } catch (Exception e) {
        throw new HazelcastException(e);
      }  
    getItemQueue().poll();
    age(item, Clock.currentTimeMillis());
    scheduleEvictionIfEmpty();
    return item;
  }
  
  public void pollBackup(long itemId) {
    QueueItem item = (QueueItem)getBackupMap().remove(Long.valueOf(itemId));
    if (item != null)
      age(item, Clock.currentTimeMillis()); 
  }
  
  public Map<Long, Data> drain(int maxSize) {
    int maxSizeParam = maxSize;
    if (maxSizeParam < 0 || maxSizeParam > getItemQueue().size())
      maxSizeParam = getItemQueue().size(); 
    Map<Long, Data> map = MapUtil.createLinkedHashMap(maxSizeParam);
    mapDrainIterator(maxSizeParam, map);
    if (this.store.isEnabled() && maxSizeParam != 0)
      try {
        this.store.deleteAll(map.keySet());
      } catch (Exception e) {
        throw new HazelcastException(e);
      }  
    long current = Clock.currentTimeMillis();
    for (int i = 0; i < maxSizeParam; i++) {
      QueueItem item = (QueueItem)getItemQueue().poll();
      age(item, current);
    } 
    if (maxSizeParam != 0)
      scheduleEvictionIfEmpty(); 
    return map;
  }
  
  public void mapDrainIterator(int maxSize, Map<Long, Data> map) {
    Iterator<QueueItem> iterator = getItemQueue().iterator();
    for (int i = 0; i < maxSize; i++) {
      QueueItem item = (QueueItem)iterator.next();
      if (this.store.isEnabled() && item.getData() == null)
        try {
          load(item);
        } catch (Exception e) {
          throw new HazelcastException(e);
        }  
      map.put(Long.valueOf(item.getItemId()), item.getData());
    } 
  }
  
  public void drainFromBackup(Set<Long> itemIdSet) {
    for (Long itemId : itemIdSet)
      pollBackup(itemId.longValue()); 
    this.dataMap.clear();
  }
  
  public int size() { return Math.min(this.config.getMaxSize(), getItemQueue().size()); }
  
  public int txMapSize() { return this.txMap.size(); }
  
  public int backupSize() { return getBackupMap().size(); }
  
  public Map<Long, Data> clear() {
    long current = Clock.currentTimeMillis();
    Map<Long, Data> map = MapUtil.createLinkedHashMap(getItemQueue().size());
    for (QueueItem item : getItemQueue()) {
      map.put(Long.valueOf(item.getItemId()), item.getData());
      age(item, current);
    } 
    if (this.store.isEnabled() && !map.isEmpty())
      try {
        this.store.deleteAll(map.keySet());
      } catch (Exception e) {
        throw new HazelcastException(e);
      }  
    getItemQueue().clear();
    this.dataMap.clear();
    scheduleEvictionIfEmpty();
    return map;
  }
  
  public void clearBackup(Set<Long> itemIdSet) { drainFromBackup(itemIdSet); }
  
  public long remove(Data data) {
    Iterator<QueueItem> iterator = getItemQueue().iterator();
    while (iterator.hasNext()) {
      QueueItem item = (QueueItem)iterator.next();
      if (data.equals(item.getData())) {
        if (this.store.isEnabled())
          try {
            this.store.delete(Long.valueOf(item.getItemId()));
          } catch (Exception e) {
            throw new HazelcastException(e);
          }  
        iterator.remove();
        age(item, Clock.currentTimeMillis());
        scheduleEvictionIfEmpty();
        return item.getItemId();
      } 
    } 
    return -1L;
  }
  
  public void removeBackup(long itemId) { getBackupMap().remove(Long.valueOf(itemId)); }
  
  public boolean contains(Collection<Data> dataSet) {
    for (Data data : dataSet) {
      boolean contains = false;
      for (QueueItem item : getItemQueue()) {
        if (item.getData() != null && item.getData().equals(data)) {
          contains = true;
          break;
        } 
      } 
      if (!contains)
        return false; 
    } 
    return true;
  }
  
  public List<Data> getAsDataList() {
    List<Data> dataList = new ArrayList<Data>(getItemQueue().size());
    for (QueueItem item : getItemQueue()) {
      if (this.store.isEnabled() && item.getData() == null)
        try {
          load(item);
        } catch (Exception e) {
          throw new HazelcastException(e);
        }  
      dataList.add(item.getData());
    } 
    return dataList;
  }
  
  public Map<Long, Data> compareAndRemove(Collection<Data> dataList, boolean retain) {
    LinkedHashMap<Long, Data> map = new LinkedHashMap<Long, Data>();
    for (QueueItem item : getItemQueue()) {
      if (item.getData() == null && this.store.isEnabled())
        try {
          load(item);
        } catch (Exception e) {
          throw new HazelcastException(e);
        }  
      boolean contains = dataList.contains(item.getData());
      if ((retain && !contains) || (!retain && contains))
        map.put(Long.valueOf(item.getItemId()), item.getData()); 
    } 
    mapIterateAndRemove(map);
    return map;
  }
  
  public void mapIterateAndRemove(Map<Long, Data> map) {
    if (map.size() <= 0)
      return; 
    if (this.store.isEnabled())
      try {
        this.store.deleteAll(map.keySet());
      } catch (Exception e) {
        throw new HazelcastException(e);
      }  
    Iterator<QueueItem> iterator = getItemQueue().iterator();
    while (iterator.hasNext()) {
      QueueItem item = (QueueItem)iterator.next();
      if (map.containsKey(Long.valueOf(item.getItemId()))) {
        iterator.remove();
        age(item, Clock.currentTimeMillis());
      } 
    } 
    scheduleEvictionIfEmpty();
  }
  
  public void compareAndRemoveBackup(Set<Long> itemIdSet) { drainFromBackup(itemIdSet); }
  
  private void load(QueueItem item) throws Exception {
    int bulkLoad = this.store.getBulkLoad();
    bulkLoad = Math.min(getItemQueue().size(), bulkLoad);
    if (bulkLoad == 1) {
      item.setData(this.store.load(Long.valueOf(item.getItemId())));
    } else if (bulkLoad > 1) {
      long maxIdToLoad = -1L;
      Iterator<QueueItem> iterator = getItemQueue().iterator();
      Set<Long> keySet = SetUtil.createHashSet(bulkLoad);
      keySet.add(Long.valueOf(item.getItemId()));
      while (keySet.size() < bulkLoad && iterator.hasNext()) {
        long itemId = ((QueueItem)iterator.next()).getItemId();
        if (itemId > this.lastIdLoaded) {
          keySet.add(Long.valueOf(itemId));
          maxIdToLoad = Math.max(itemId, maxIdToLoad);
        } 
      } 
      Map<Long, Data> values = this.store.loadAll(keySet);
      this.lastIdLoaded = maxIdToLoad;
      this.dataMap.putAll(values);
      item.setData(getDataFromMap(item.getItemId()));
    } 
  }
  
  public boolean hasEnoughCapacity() { return hasEnoughCapacity(1); }
  
  public boolean hasEnoughCapacity(int delta) { return (getItemQueue().size() + delta <= this.config.getMaxSize()); }
  
  public Deque<QueueItem> getItemQueue() {
    if (this.itemQueue == null) {
      this.itemQueue = new LinkedList();
      if (this.backupMap != null && !this.backupMap.isEmpty()) {
        List<QueueItem> values = new ArrayList<QueueItem>(this.backupMap.values());
        Collections.sort(values);
        this.itemQueue.addAll(values);
        QueueItem lastItem = (QueueItem)this.itemQueue.peekLast();
        if (lastItem != null)
          setId(lastItem.itemId + 100000L); 
        this.backupMap.clear();
        this.backupMap = null;
      } 
      if (!this.txMap.isEmpty()) {
        long maxItemId = Float.MIN_VALUE;
        for (TxQueueItem item : this.txMap.values())
          maxItemId = Math.max(maxItemId, item.itemId); 
        setId(maxItemId + 100000L);
      } 
    } 
    return this.itemQueue;
  }
  
  public Map<Long, QueueItem> getBackupMap() {
    if (this.backupMap == null)
      if (this.itemQueue != null) {
        this.backupMap = MapUtil.createHashMap(this.itemQueue.size());
        for (QueueItem item : this.itemQueue)
          this.backupMap.put(Long.valueOf(item.getItemId()), item); 
        this.itemQueue.clear();
        this.itemQueue = null;
      } else {
        this.backupMap = new HashMap();
      }  
    return this.backupMap;
  }
  
  public Data getDataFromMap(long itemId) { return (Data)this.dataMap.remove(Long.valueOf(itemId)); }
  
  public void setConfig(QueueConfig config, NodeEngine nodeEngine, QueueService service) {
    this.nodeEngine = nodeEngine;
    this.service = service;
    this.logger = nodeEngine.getLogger(QueueContainer.class);
    this.config = new QueueConfig(config);
    QueueStoreConfig storeConfig = config.getQueueStoreConfig();
    SerializationService serializationService = nodeEngine.getSerializationService();
    ClassLoader classLoader = nodeEngine.getConfigClassLoader();
    this.store = QueueStoreWrapper.create(this.name, storeConfig, serializationService, classLoader);
  }
  
  private long nextId() { return ++this.idGenerator; }
  
  public long getCurrentId() { return this.idGenerator; }
  
  public QueueWaitNotifyKey getPollWaitNotifyKey() { return this.pollWaitNotifyKey; }
  
  public QueueWaitNotifyKey getOfferWaitNotifyKey() { return this.offerWaitNotifyKey; }
  
  public QueueConfig getConfig() { return this.config; }
  
  private void age(QueueItem item, long currentTime) {
    long elapsed = currentTime - item.getCreationTime();
    if (elapsed <= 0L)
      return; 
    this.totalAgedCount++;
    this.totalAge += elapsed;
    this.minAge = Math.min(this.minAge, elapsed);
    this.maxAge = Math.max(this.maxAge, elapsed);
  }
  
  public void setStats(LocalQueueStatsImpl stats) {
    stats.setMinAge(this.minAge);
    stats.setMaxAge(this.maxAge);
    long totalAgedCountVal = Math.max(this.totalAgedCount, 1L);
    stats.setAveAge(this.totalAge / totalAgedCountVal);
  }
  
  private void scheduleEvictionIfEmpty() {
    int emptyQueueTtl = this.config.getEmptyQueueTtl();
    if (emptyQueueTtl < 0)
      return; 
    if (getItemQueue().isEmpty() && this.txMap.isEmpty() && !this.isEvictionScheduled)
      if (emptyQueueTtl == 0) {
        this.nodeEngine.getProxyService().destroyDistributedObject("hz:impl:queueService", this.name);
      } else {
        this.service.scheduleEviction(this.name, TimeUnit.SECONDS.toMillis(emptyQueueTtl));
        this.isEvictionScheduled = true;
      }  
  }
  
  public void cancelEvictionIfExists() {
    if (this.isEvictionScheduled) {
      this.service.cancelEviction(this.name);
      this.isEvictionScheduled = false;
    } 
  }
  
  public boolean isEvictable() { return (getItemQueue().isEmpty() && this.txMap.isEmpty()); }
  
  public void rollbackTransaction(String transactionId) {
    Iterator<TxQueueItem> iterator = this.txMap.values().iterator();
    while (iterator.hasNext()) {
      TxQueueItem item = (TxQueueItem)iterator.next();
      if (transactionId.equals(item.getTransactionId())) {
        iterator.remove();
        if (item.isPollOperation()) {
          getItemQueue().offerFirst(item);
          cancelEvictionIfExists();
        } 
      } 
    } 
  }
  
  public void writeData(ObjectDataOutput out) throws IOException {
    out.writeUTF(this.name);
    out.writeInt(getItemQueue().size());
    for (QueueItem item : getItemQueue())
      out.writeObject(item); 
    out.writeInt(this.txMap.size());
    for (TxQueueItem item : this.txMap.values())
      item.writeData(out); 
  }
  
  public void readData(ObjectDataInput in) throws IOException {
    this.name = in.readUTF();
    this.pollWaitNotifyKey = new QueueWaitNotifyKey(this.name, "poll");
    this.offerWaitNotifyKey = new QueueWaitNotifyKey(this.name, "offer");
    int size = in.readInt();
    for (int j = 0; j < size; j++) {
      QueueItem item = (QueueItem)in.readObject();
      getItemQueue().offer(item);
      setId(item.getItemId());
    } 
    int txSize = in.readInt();
    for (int j = 0; j < txSize; j++) {
      TxQueueItem item = new TxQueueItem(this, -1L, null);
      item.readData(in);
      this.txMap.put(Long.valueOf(item.getItemId()), item);
      setId(item.getItemId());
    } 
  }
  
  public void destroy() {
    if (this.itemQueue != null)
      this.itemQueue.clear(); 
    if (this.backupMap != null)
      this.backupMap.clear(); 
    this.txMap.clear();
    this.dataMap.clear();
  }
  
  public int getFactoryId() { return QueueDataSerializerHook.F_ID; }
  
  public int getId() { return 38; }
  
  void setId(long itemId) { this.idGenerator = Math.max(itemId + 1L, this.idGenerator); }
}
