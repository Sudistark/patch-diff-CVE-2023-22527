package com.hazelcast.collection.impl.queue;

import com.hazelcast.config.QueueConfig;
import com.hazelcast.core.IQueue;
import com.hazelcast.core.ItemListener;
import com.hazelcast.monitor.LocalQueueStats;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.InitializingObject;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.util.Preconditions;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.concurrent.TimeUnit;

public class QueueProxyImpl<E> extends QueueProxySupport implements IQueue<E>, InitializingObject {
  public QueueProxyImpl(String name, QueueService queueService, NodeEngine nodeEngine, QueueConfig config) { super(name, queueService, nodeEngine, config); }
  
  public LocalQueueStats getLocalQueueStats() { return ((QueueService)getService()).createLocalQueueStats(this.name, this.partitionId); }
  
  public boolean add(E e) {
    if (offer(e))
      return true; 
    throw new IllegalStateException("Queue is full!");
  }
  
  public boolean offer(E e) {
    try {
      return offer(e, 0L, TimeUnit.SECONDS);
    } catch (InterruptedException ex) {
      Thread.currentThread().interrupt();
      return false;
    } 
  }
  
  public void put(E e) throws InterruptedException { offer(e, -1L, TimeUnit.MILLISECONDS); }
  
  public boolean offer(E e, long timeout, TimeUnit timeUnit) throws InterruptedException {
    NodeEngine nodeEngine = getNodeEngine();
    Data data = nodeEngine.toData(e);
    return offerInternal(data, timeUnit.toMillis(timeout));
  }
  
  public E take() throws InterruptedException { return (E)poll(-1L, TimeUnit.MILLISECONDS); }
  
  public E poll(long timeout, TimeUnit timeUnit) throws InterruptedException {
    NodeEngine nodeEngine = getNodeEngine();
    Object data = pollInternal(timeUnit.toMillis(timeout));
    return (E)nodeEngine.toObject(data);
  }
  
  public boolean remove(Object o) {
    NodeEngine nodeEngine = getNodeEngine();
    Data data = nodeEngine.toData(o);
    return removeInternal(data);
  }
  
  public boolean contains(Object o) {
    NodeEngine nodeEngine = getNodeEngine();
    Data data = nodeEngine.toData(o);
    List<Data> dataSet = new ArrayList<Data>(1);
    dataSet.add(data);
    return containsInternal(dataSet);
  }
  
  public int drainTo(Collection<? super E> objects) { return drainTo(objects, -1); }
  
  public int drainTo(Collection<? super E> objects, int i) {
    Preconditions.checkNotNull(objects, "Collection is null");
    Preconditions.checkFalse(equals(objects), "Can not drain to same Queue");
    NodeEngine nodeEngine = getNodeEngine();
    Collection<Data> dataList = drainInternal(i);
    for (Data data : dataList) {
      E e = (E)nodeEngine.toObject(data);
      objects.add(e);
    } 
    return dataList.size();
  }
  
  public E remove() throws InterruptedException {
    E res = (E)poll();
    if (res == null)
      throw new NoSuchElementException("Queue is empty!"); 
    return res;
  }
  
  public E poll() throws InterruptedException {
    try {
      return (E)poll(0L, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      return null;
    } 
  }
  
  public E element() throws InterruptedException {
    E res = (E)peek();
    if (res == null)
      throw new NoSuchElementException("Queue is empty!"); 
    return res;
  }
  
  public E peek() throws InterruptedException {
    NodeEngine nodeEngine = getNodeEngine();
    Object data = peekInternal();
    return (E)nodeEngine.toObject(data);
  }
  
  public Iterator<E> iterator() {
    NodeEngine nodeEngine = getNodeEngine();
    return new QueueIterator(listInternal().iterator(), nodeEngine.getSerializationService(), false);
  }
  
  public Object[] toArray() {
    NodeEngine nodeEngine = getNodeEngine();
    List<Data> list = listInternal();
    int size = list.size();
    Object[] array = new Object[size];
    for (int i = 0; i < size; i++)
      array[i] = nodeEngine.toObject(list.get(i)); 
    return array;
  }
  
  public <T> T[] toArray(T[] ts) {
    T[] tsParam = ts;
    NodeEngine nodeEngine = getNodeEngine();
    List<Data> list = listInternal();
    int size = list.size();
    if (tsParam.length < size)
      tsParam = (T[])(Object[])Array.newInstance(tsParam.getClass().getComponentType(), size); 
    for (int i = 0; i < size; i++)
      tsParam[i] = nodeEngine.toObject(list.get(i)); 
    return tsParam;
  }
  
  public boolean containsAll(Collection<?> objects) { return containsInternal(getDataList(objects)); }
  
  public boolean addAll(Collection<? extends E> es) { return addAllInternal(toDataList(es)); }
  
  public boolean removeAll(Collection<?> objects) { return compareAndRemove(getDataList(objects), false); }
  
  public boolean retainAll(Collection<?> objects) { return compareAndRemove(getDataList(objects), true); }
  
  private List<Data> getDataList(Collection<?> objects) {
    NodeEngine nodeEngine = getNodeEngine();
    List<Data> dataList = new ArrayList<Data>(objects.size());
    for (Object o : objects)
      dataList.add(nodeEngine.toData(o)); 
    return dataList;
  }
  
  private List<Data> toDataList(Collection<?> objects) {
    NodeEngine nodeEngine = getNodeEngine();
    List<Data> dataList = new ArrayList<Data>(objects.size());
    for (Object o : objects) {
      Preconditions.checkNotNull(o, "Object is null");
      dataList.add(nodeEngine.toData(o));
    } 
    return dataList;
  }
  
  public String toString() { return "IQueue{name='" + this.name + '\'' + '}'; }
}
