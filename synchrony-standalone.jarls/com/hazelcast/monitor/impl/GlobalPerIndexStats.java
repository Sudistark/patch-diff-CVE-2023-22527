package com.hazelcast.monitor.impl;

import com.hazelcast.internal.memory.MemoryAllocator;
import com.hazelcast.query.impl.Index;
import com.hazelcast.query.impl.IndexHeapMemoryCostUtil;
import com.hazelcast.util.Clock;
import java.util.concurrent.atomic.AtomicLongFieldUpdater;

public class GlobalPerIndexStats implements PerIndexStats {
  private static final long PRECISION_SCALE = 7L;
  
  private static final long PRECISION = 128L;
  
  private static final AtomicLongFieldUpdater<GlobalPerIndexStats> ENTRY_COUNT = AtomicLongFieldUpdater.newUpdater(GlobalPerIndexStats.class, "entryCount");
  
  private static final AtomicLongFieldUpdater<GlobalPerIndexStats> QUERY_COUNT = AtomicLongFieldUpdater.newUpdater(GlobalPerIndexStats.class, "queryCount");
  
  private static final AtomicLongFieldUpdater<GlobalPerIndexStats> HIT_COUNT = AtomicLongFieldUpdater.newUpdater(GlobalPerIndexStats.class, "hitCount");
  
  private static final AtomicLongFieldUpdater<GlobalPerIndexStats> TOTAL_HIT_LATENCY = AtomicLongFieldUpdater.newUpdater(GlobalPerIndexStats.class, "totalHitLatency");
  
  private static final AtomicLongFieldUpdater<GlobalPerIndexStats> TOTAL_NORMALIZED_HIT_CARDINALITY = AtomicLongFieldUpdater.newUpdater(GlobalPerIndexStats.class, "totalNormalizedHitCardinality");
  
  private static final AtomicLongFieldUpdater<GlobalPerIndexStats> INSERT_COUNT = AtomicLongFieldUpdater.newUpdater(GlobalPerIndexStats.class, "insertCount");
  
  private static final AtomicLongFieldUpdater<GlobalPerIndexStats> TOTAL_INSERT_LATENCY = AtomicLongFieldUpdater.newUpdater(GlobalPerIndexStats.class, "totalInsertLatency");
  
  private static final AtomicLongFieldUpdater<GlobalPerIndexStats> UPDATE_COUNT = AtomicLongFieldUpdater.newUpdater(GlobalPerIndexStats.class, "updateCount");
  
  private static final AtomicLongFieldUpdater<GlobalPerIndexStats> TOTAL_UPDATE_LATENCY = AtomicLongFieldUpdater.newUpdater(GlobalPerIndexStats.class, "totalUpdateLatency");
  
  private static final AtomicLongFieldUpdater<GlobalPerIndexStats> REMOVE_COUNT = AtomicLongFieldUpdater.newUpdater(GlobalPerIndexStats.class, "removeCount");
  
  private static final AtomicLongFieldUpdater<GlobalPerIndexStats> TOTAL_REMOVE_LATENCY = AtomicLongFieldUpdater.newUpdater(GlobalPerIndexStats.class, "totalRemoveLatency");
  
  private static final AtomicLongFieldUpdater<GlobalPerIndexStats> VALUES_MEMORY_COST = AtomicLongFieldUpdater.newUpdater(GlobalPerIndexStats.class, "valuesMemoryCost");
  
  private final boolean ordered;
  
  private final boolean usesCachedQueryableEntries;
  
  private final long creationTime;
  
  public GlobalPerIndexStats(boolean ordered, boolean usesCachedQueryableEntries) {
    this.ordered = ordered;
    this.usesCachedQueryableEntries = usesCachedQueryableEntries;
    this.creationTime = Clock.currentTimeMillis();
  }
  
  public long makeTimestamp() { return System.nanoTime(); }
  
  public long getCreationTime() { return this.creationTime; }
  
  public long getQueryCount() { return this.queryCount; }
  
  public void incrementQueryCount() { QUERY_COUNT.incrementAndGet(this); }
  
  public long getHitCount() { return this.hitCount; }
  
  public long getTotalHitLatency() { return this.totalHitLatency; }
  
  public double getTotalNormalizedHitCardinality() { return this.totalNormalizedHitCardinality / 128.0D; }
  
  public long getInsertCount() { return this.insertCount; }
  
  public long getTotalInsertLatency() { return this.totalInsertLatency; }
  
  public long getUpdateCount() { return this.updateCount; }
  
  public long getTotalUpdateLatency() { return this.totalUpdateLatency; }
  
  public long getRemoveCount() { return this.removeCount; }
  
  public long getTotalRemoveLatency() { return this.totalRemoveLatency; }
  
  public long getMemoryCost() { return IndexHeapMemoryCostUtil.estimateMapCost(this.entryCount, this.ordered, this.usesCachedQueryableEntries) + this.valuesMemoryCost; }
  
  public void onInsert(long timestamp, IndexOperationStats operationStats, Index.OperationSource operationSource) {
    if (operationStats.getEntryCountDelta() == 0L)
      return; 
    if (operationSource == Index.OperationSource.USER) {
      TOTAL_INSERT_LATENCY.addAndGet(this, System.nanoTime() - timestamp);
      INSERT_COUNT.incrementAndGet(this);
    } 
    ENTRY_COUNT.incrementAndGet(this);
    VALUES_MEMORY_COST.addAndGet(this, operationStats.getMemoryCostDelta());
  }
  
  public void onUpdate(long timestamp, IndexOperationStats operationStats, Index.OperationSource operationSource) {
    if (operationSource == Index.OperationSource.USER) {
      TOTAL_UPDATE_LATENCY.addAndGet(this, System.nanoTime() - timestamp);
      UPDATE_COUNT.incrementAndGet(this);
    } 
    VALUES_MEMORY_COST.addAndGet(this, operationStats.getMemoryCostDelta());
  }
  
  public void onRemove(long timestamp, IndexOperationStats operationStats, Index.OperationSource operationSource) {
    if (operationStats.getEntryCountDelta() == 0L)
      return; 
    if (operationSource == Index.OperationSource.USER) {
      TOTAL_REMOVE_LATENCY.addAndGet(this, System.nanoTime() - timestamp);
      REMOVE_COUNT.incrementAndGet(this);
    } 
    ENTRY_COUNT.decrementAndGet(this);
    VALUES_MEMORY_COST.addAndGet(this, operationStats.getMemoryCostDelta());
  }
  
  public void onClear() {
    this.entryCount = 0L;
    this.valuesMemoryCost = 0L;
  }
  
  public void onIndexHit(long timestamp, long hitCardinality) {
    long localEntryCount = this.entryCount;
    if (localEntryCount == 0L)
      return; 
    TOTAL_HIT_LATENCY.addAndGet(this, System.nanoTime() - timestamp);
    HIT_COUNT.incrementAndGet(this);
    long adjustedHitCardinality = Math.min(hitCardinality, localEntryCount);
    long scaledHitCardinality = adjustedHitCardinality << 7;
    long normalizedHitCardinality = scaledHitCardinality / localEntryCount;
    TOTAL_NORMALIZED_HIT_CARDINALITY.addAndGet(this, normalizedHitCardinality);
  }
  
  public void resetPerQueryStats() {}
  
  public MemoryAllocator wrapMemoryAllocator(MemoryAllocator memoryAllocator) { throw new UnsupportedOperationException("global indexes are not supposed to use native memory allocators"); }
  
  public IndexOperationStats createOperationStats() { return new GlobalIndexOperationStats(); }
}
