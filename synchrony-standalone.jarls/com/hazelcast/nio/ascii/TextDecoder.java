package com.hazelcast.nio.ascii;

import com.hazelcast.internal.ascii.CommandParser;
import com.hazelcast.internal.ascii.TextCommand;
import com.hazelcast.internal.ascii.TextCommandConstants;
import com.hazelcast.internal.ascii.TextCommandService;
import com.hazelcast.internal.ascii.memcache.ErrorCommand;
import com.hazelcast.internal.networking.HandlerStatus;
import com.hazelcast.internal.networking.InboundHandler;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.ConnectionType;
import com.hazelcast.nio.IOService;
import com.hazelcast.nio.IOUtil;
import com.hazelcast.nio.tcp.TcpIpConnection;
import com.hazelcast.spi.annotation.PrivateApi;
import com.hazelcast.util.StringUtil;
import java.io.IOException;
import java.nio.ByteBuffer;

@PrivateApi
public abstract class TextDecoder extends InboundHandler<ByteBuffer, Void> {
  private static final int INITIAL_CAPACITY = 256;
  
  private static final int MAX_CAPACITY = 65536;
  
  private ByteBuffer commandLineBuffer = ByteBuffer.allocate(256);
  
  private boolean commandLineRead;
  
  private TextCommand command;
  
  private final TextCommandService textCommandService;
  
  private final TextEncoder encoder;
  
  private final TcpIpConnection connection;
  
  private boolean connectionTypeSet;
  
  private long requestIdGen;
  
  private final TextProtocolFilter textProtocolFilter;
  
  private final ILogger logger;
  
  private final TextParsers textParsers;
  
  private final boolean rootDecoder;
  
  public TextDecoder(TcpIpConnection connection, TextEncoder encoder, TextProtocolFilter textProtocolFilter, TextParsers textParsers, boolean rootDecoder) {
    IOService ioService = connection.getEndpointManager().getNetworkingService().getIoService();
    this.textCommandService = ioService.getTextCommandService();
    this.encoder = encoder;
    this.connection = connection;
    this.textProtocolFilter = textProtocolFilter;
    this.textParsers = textParsers;
    this.logger = ioService.getLoggingService().getLogger(getClass());
    this.rootDecoder = rootDecoder;
  }
  
  public void sendResponse(TextCommand command) { this.encoder.enqueue(command); }
  
  public void handlerAdded() {
    if (this.rootDecoder)
      initSrcBuffer(); 
  }
  
  public HandlerStatus onRead() throws Exception {
    ((ByteBuffer)this.src).flip();
    try {
      while (((ByteBuffer)this.src).hasRemaining())
        doRead((ByteBuffer)this.src); 
      return HandlerStatus.CLEAN;
    } finally {
      IOUtil.compactOrClear((ByteBuffer)this.src);
    } 
  }
  
  private void doRead(ByteBuffer bb) throws IOException {
    while (!this.commandLineRead && bb.hasRemaining()) {
      byte b = bb.get();
      char c = (char)b;
      if (c == '\n') {
        this.commandLineRead = true;
        continue;
      } 
      if (c != '\r')
        appendToBuffer(b); 
    } 
    if (this.commandLineRead) {
      if (this.command == null) {
        String commandLine = toStringAndClear(this.commandLineBuffer);
        this.textProtocolFilter.filterConnection(commandLine, this.connection);
        if (!this.connection.isAlive()) {
          reset();
          return;
        } 
        processCmd(commandLine);
      } 
      if (this.command != null) {
        boolean complete = this.command.readFrom(bb);
        if (complete) {
          publishRequest(this.command);
          reset();
        } 
      } else {
        reset();
      } 
    } 
  }
  
  private void appendToBuffer(byte b) throws IOException {
    if (!this.commandLineBuffer.hasRemaining())
      expandBuffer(); 
    this.commandLineBuffer.put(b);
  }
  
  private void expandBuffer() {
    if (this.commandLineBuffer.capacity() == 65536)
      throw new IOException("Max command size capacity [65536] has been reached!"); 
    int capacity = this.commandLineBuffer.capacity() << 1;
    if (this.logger.isFineEnabled())
      this.logger.fine("Expanding buffer capacity to " + capacity); 
    ByteBuffer newBuffer = ByteBuffer.allocate(capacity);
    this.commandLineBuffer.flip();
    newBuffer.put(this.commandLineBuffer);
    this.commandLineBuffer = newBuffer;
  }
  
  private void reset() {
    this.command = null;
    this.commandLineBuffer.clear();
    this.commandLineRead = false;
  }
  
  private static String toStringAndClear(ByteBuffer bb) {
    String result;
    if (bb == null)
      return ""; 
    if (bb.position() == 0) {
      result = "";
    } else {
      result = StringUtil.bytesToString(bb.array(), 0, bb.position());
    } 
    bb.clear();
    return result;
  }
  
  public void publishRequest(TextCommand command) {
    if (!isCommandTypeEnabled(command))
      return; 
    long requestId = command.shouldReply() ? this.requestIdGen++ : -1L;
    command.init(this, requestId);
    this.textCommandService.processRequest(command);
  }
  
  private boolean isCommandTypeEnabled(TextCommand command) {
    if (!this.connectionTypeSet) {
      if (command instanceof com.hazelcast.internal.ascii.rest.HttpCommand) {
        this.connection.setType(ConnectionType.REST_CLIENT);
      } else {
        this.connection.setType(ConnectionType.MEMCACHE_CLIENT);
      } 
      this.connectionTypeSet = true;
    } 
    return true;
  }
  
  private void processCmd(String cmd) {
    try {
      int space = cmd.indexOf(' ');
      String operation = (space == -1) ? cmd : cmd.substring(0, space);
      CommandParser commandParser = this.textParsers.getParser(operation);
      if (commandParser != null) {
        this.command = commandParser.parser(this, cmd, space);
      } else {
        this.command = new ErrorCommand(TextCommandConstants.TextCommandType.UNKNOWN);
      } 
    } catch (Throwable t) {
      this.logger.finest(t);
      this.command = new ErrorCommand(TextCommandConstants.TextCommandType.ERROR_CLIENT, "Invalid command: " + cmd);
    } 
  }
  
  public TextEncoder getEncoder() { return this.encoder; }
  
  public void closeConnection() { this.connection.close(null, null); }
}
