package com.hazelcast.nio.ascii;

import com.hazelcast.internal.ascii.TextCommand;
import com.hazelcast.internal.networking.HandlerStatus;
import com.hazelcast.internal.networking.OutboundHandler;
import com.hazelcast.nio.IOUtil;
import com.hazelcast.nio.tcp.TcpIpConnection;
import com.hazelcast.spi.annotation.PrivateApi;
import com.hazelcast.util.function.Supplier;
import java.nio.ByteBuffer;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@PrivateApi
public class TextEncoder extends OutboundHandler<Supplier<TextCommand>, ByteBuffer> {
  public static final String TEXT_ENCODER = "textencoder";
  
  private final TcpIpConnection connection;
  
  private final Map<Long, TextCommand> responses;
  
  private long currentRequestId;
  
  private TextCommand command;
  
  public TextEncoder(TcpIpConnection connection) {
    this.responses = new ConcurrentHashMap(100);
    this.connection = connection;
  }
  
  public void handlerAdded() { initDstBuffer(); }
  
  public void enqueue(TextCommand response) {
    long requestId = response.getRequestId();
    if (requestId == -1L) {
      this.connection.write(response);
    } else if (this.currentRequestId == requestId) {
      this.connection.write(response);
      this.currentRequestId++;
      processWaitingResponses();
    } else {
      this.responses.put(Long.valueOf(requestId), response);
    } 
  }
  
  private void processWaitingResponses() {
    TextCommand response = (TextCommand)this.responses.remove(Long.valueOf(this.currentRequestId));
    while (response != null) {
      this.connection.write(response);
      this.currentRequestId++;
      response = (TextCommand)this.responses.remove(Long.valueOf(this.currentRequestId));
    } 
  }
  
  public HandlerStatus onWrite() {
    IOUtil.compactOrClear((ByteBuffer)this.dst);
    try {
      while (true) {
        if (this.command == null) {
          this.command = (TextCommand)((Supplier)this.src).get();
          if (this.command == null)
            return HandlerStatus.CLEAN; 
        } 
        if (this.command.writeTo((ByteBuffer)this.dst)) {
          this.command = null;
          continue;
        } 
        break;
      } 
      return HandlerStatus.DIRTY;
    } finally {
      ((ByteBuffer)this.dst).flip();
    } 
  }
}
