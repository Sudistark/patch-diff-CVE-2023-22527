package com.hazelcast.nio.tcp;

import com.hazelcast.internal.networking.HandlerStatus;
import com.hazelcast.internal.networking.OutboundHandler;
import com.hazelcast.nio.ConnectionType;
import com.hazelcast.nio.IOUtil;
import com.hazelcast.util.StringUtil;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.nio.ByteBuffer;

public class MemberProtocolEncoder extends OutboundHandler<Void, ByteBuffer> {
  private final OutboundHandler[] outboundHandlers;
  
  private boolean clusterProtocolBuffered;
  
  @SuppressFBWarnings({"EI_EXPOSE_REP2"})
  public MemberProtocolEncoder(OutboundHandler[] next) { this.outboundHandlers = next; }
  
  public void handlerAdded() {
    initDstBuffer(3);
    if (this.channel.isClientMode())
      this.mustWriteProtocol = true; 
  }
  
  public HandlerStatus onWrite() {
    IOUtil.compactOrClear((ByteBuffer)this.dst);
    try {
      if (!this.mustWriteProtocol)
        return HandlerStatus.CLEAN; 
      if (!this.clusterProtocolBuffered) {
        this.clusterProtocolBuffered = true;
        ((ByteBuffer)this.dst).put(StringUtil.stringToBytes("HZC"));
        return HandlerStatus.DIRTY;
      } 
      if (!isProtocolBufferDrained())
        return HandlerStatus.DIRTY; 
      TcpIpConnection connection = (TcpIpConnection)this.channel.attributeMap().get(TcpIpConnection.class);
      connection.setType(ConnectionType.MEMBER);
      this.channel.outboundPipeline().replace(this, this.outboundHandlers);
      return HandlerStatus.CLEAN;
    } finally {
      ((ByteBuffer)this.dst).flip();
    } 
  }
  
  public void signalProtocolLoaded() {
    assert !this.channel.isClientMode() : "Signal protocol should only be made on channel in serverMode";
    this.mustWriteProtocol = true;
    this.channel.outboundPipeline().wakeup();
  }
  
  private boolean isProtocolBufferDrained() { return (((ByteBuffer)this.dst).position() == 0); }
}
