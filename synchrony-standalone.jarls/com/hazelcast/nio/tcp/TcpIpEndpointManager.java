package com.hazelcast.nio.tcp;

import com.hazelcast.config.EndpointConfig;
import com.hazelcast.instance.EndpointQualifier;
import com.hazelcast.instance.ProtocolType;
import com.hazelcast.internal.metrics.MetricsRegistry;
import com.hazelcast.internal.metrics.Probe;
import com.hazelcast.internal.metrics.ProbeLevel;
import com.hazelcast.internal.networking.Channel;
import com.hazelcast.internal.networking.ChannelInitializerProvider;
import com.hazelcast.internal.networking.Networking;
import com.hazelcast.internal.util.counters.MwCounter;
import com.hazelcast.logging.ILogger;
import com.hazelcast.logging.LoggingService;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.Connection;
import com.hazelcast.nio.ConnectionListener;
import com.hazelcast.nio.EndpointManager;
import com.hazelcast.nio.IOService;
import com.hazelcast.nio.IOUtil;
import com.hazelcast.nio.NetworkingService;
import com.hazelcast.nio.Packet;
import com.hazelcast.spi.properties.GroupProperty;
import com.hazelcast.spi.properties.HazelcastProperties;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.function.Consumer;
import java.io.IOException;
import java.nio.channels.SocketChannel;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class TcpIpEndpointManager extends Object implements EndpointManager<TcpIpConnection>, Consumer<Packet> {
  private static final int RETRY_NUMBER = 5;
  
  private static final long DELAY_FACTOR = 100L;
  
  @Probe(name = "inProgressCount")
  final Set<Address> connectionsInProgress;
  
  @Probe(name = "count", level = ProbeLevel.MANDATORY)
  final ConcurrentHashMap<Address, TcpIpConnection> connectionsMap;
  
  @Probe(name = "activeCount", level = ProbeLevel.MANDATORY)
  final Set<TcpIpConnection> activeConnections;
  
  private final ILogger logger;
  
  private final IOService ioService;
  
  private final EndpointConfig endpointConfig;
  
  private final EndpointQualifier endpointQualifier;
  
  private final ChannelInitializerProvider channelInitializerProvider;
  
  private final NetworkingService networkingService;
  
  private final TcpIpConnector connector;
  
  private final BindHandler bindHandler;
  
  @Probe(name = "connectionListenerCount")
  private final Set<ConnectionListener> connectionListeners;
  
  private final ConstructorFunction<Address, TcpIpConnectionErrorHandler> monitorConstructor;
  
  @Probe(name = "monitorCount")
  private final ConcurrentHashMap<Address, TcpIpConnectionErrorHandler> monitors;
  
  private final AtomicInteger connectionIdGen;
  
  @Probe
  private final MwCounter openedCount;
  
  @Probe
  private final MwCounter closedCount;
  
  private final BytesTransceivedCounter bytesReceived;
  
  private final BytesTransceivedCounter bytesSent;
  
  @Probe(name = "acceptedSocketCount", level = ProbeLevel.MANDATORY)
  private final Set<Channel> acceptedChannels;
  
  private final EndpointConnectionLifecycleListener connectionLifecycleListener;
  
  TcpIpEndpointManager(NetworkingService networkingService, EndpointConfig endpointConfig, ChannelInitializerProvider channelInitializerProvider, IOService ioService, LoggingService loggingService, MetricsRegistry metricsRegistry, HazelcastProperties properties, Set<ProtocolType> supportedProtocolTypes) {
    this
      .connectionsInProgress = Collections.newSetFromMap(new ConcurrentHashMap());
    this.connectionsMap = new ConcurrentHashMap(100);
    this
      .activeConnections = Collections.newSetFromMap(new ConcurrentHashMap());
    this.connectionListeners = new CopyOnWriteArraySet();
    this.monitorConstructor = new Object(this);
    this.monitors = new ConcurrentHashMap(100);
    this.connectionIdGen = new AtomicInteger();
    this
      .openedCount = MwCounter.newMwCounter();
    this
      .closedCount = MwCounter.newMwCounter();
    this.bytesReceived = new BytesTransceivedCounter(this, new Object(this));
    this.bytesSent = new BytesTransceivedCounter(this, new Object(this));
    this
      .acceptedChannels = Collections.newSetFromMap(new ConcurrentHashMap());
    this.connectionLifecycleListener = new EndpointConnectionLifecycleListener(this);
    this.networkingService = networkingService;
    this.endpointConfig = endpointConfig;
    this.endpointQualifier = (endpointConfig != null) ? endpointConfig.getQualifier() : null;
    this.channelInitializerProvider = channelInitializerProvider;
    this.ioService = ioService;
    this.logger = loggingService.getLogger(TcpIpEndpointManager.class);
    this.connector = new TcpIpConnector(this);
    boolean spoofingChecks = (properties != null && properties.getBoolean(GroupProperty.BIND_SPOOFING_CHECKS));
    this.bindHandler = new BindHandler(this, ioService, this.logger, spoofingChecks, supportedProtocolTypes);
    if (this.endpointQualifier == null) {
      metricsRegistry.scanAndRegister(this, "tcp.connection");
    } else {
      metricsRegistry.scanAndRegister(this, this.endpointQualifier.toMetricsPrefixString() + ".tcp.connection");
    } 
  }
  
  public NetworkingService getNetworkingService() { return this.networkingService; }
  
  public EndpointQualifier getEndpointQualifier() { return this.endpointQualifier; }
  
  public Collection<TcpIpConnection> getActiveConnections() { return Collections.unmodifiableSet(this.activeConnections); }
  
  public Collection<TcpIpConnection> getConnections() { return Collections.unmodifiableCollection(new HashSet(this.connectionsMap.values())); }
  
  public void addConnectionListener(ConnectionListener listener) {
    Preconditions.checkNotNull(listener, "listener can't be null");
    this.connectionListeners.add(listener);
  }
  
  public void accept(Packet packet) { this.bindHandler.process(packet); }
  
  public TcpIpConnection getConnection(Address address) { return (TcpIpConnection)this.connectionsMap.get(address); }
  
  public TcpIpConnection getOrConnect(Address address) { return getOrConnect(address, false); }
  
  public TcpIpConnection getOrConnect(Address address, boolean silent) {
    TcpIpConnection connection = (TcpIpConnection)this.connectionsMap.get(address);
    if (connection == null && this.networkingService.isLive() && 
      this.connectionsInProgress.add(address))
      this.connector.asyncConnect(address, silent); 
    return connection;
  }
  
  public boolean registerConnection(Address remoteEndPoint, TcpIpConnection connection) {
    try {
      if (remoteEndPoint.equals(this.ioService.getThisAddress()))
        return false; 
      if (!connection.isAlive()) {
        if (this.logger.isFinestEnabled())
          this.logger.finest(connection + " to " + remoteEndPoint + " is not registered since connection is not active."); 
        return false;
      } 
      Address currentEndPoint = connection.getEndPoint();
      if (currentEndPoint != null && !currentEndPoint.equals(remoteEndPoint))
        throw new IllegalArgumentException(connection + " has already a different endpoint than: " + remoteEndPoint); 
      connection.setEndPoint(remoteEndPoint);
      if (!connection.isClient()) {
        TcpIpConnectionErrorHandler connectionMonitor = getErrorHandler(remoteEndPoint, true);
        connection.setErrorHandler(connectionMonitor);
      } 
      this.connectionsMap.put(remoteEndPoint, connection);
      this.ioService.getEventService().executeEventCallback(new Object(this, connection, remoteEndPoint));
      return true;
    } finally {
      this.connectionsInProgress.remove(remoteEndPoint);
    } 
  }
  
  private void fireConnectionRemovedEvent(Connection connection, Address endPoint) {
    if (this.networkingService.isLive())
      this.ioService.getEventService().executeEventCallback(new Object(this, connection, endPoint)); 
  }
  
  public void reset(boolean cleanListeners) {
    for (Channel socketChannel : this.acceptedChannels)
      IOUtil.closeResource(socketChannel); 
    for (Connection conn : this.connectionsMap.values())
      IOUtil.close(conn, "EndpointManager is stopping"); 
    for (Connection conn : this.activeConnections)
      IOUtil.close(conn, "EndpointManager is stopping"); 
    this.acceptedChannels.clear();
    this.connectionsInProgress.clear();
    this.connectionsMap.clear();
    this.monitors.clear();
    this.activeConnections.clear();
    if (cleanListeners)
      this.connectionListeners.clear(); 
  }
  
  public boolean transmit(Packet packet, TcpIpConnection connection) {
    Preconditions.checkNotNull(packet, "Packet can't be null");
    if (connection == null)
      return false; 
    return connection.write(packet);
  }
  
  public boolean transmit(Packet packet, Address target) {
    Preconditions.checkNotNull(packet, "Packet can't be null");
    Preconditions.checkNotNull(target, "target can't be null");
    return send(packet, target, null);
  }
  
  long calculateBytesReceived() { return this.bytesReceived.calculate(); }
  
  long calculateBytesSent() { return this.bytesSent.calculate(); }
  
  private TcpIpConnectionErrorHandler getErrorHandler(Address endpoint, boolean reset) {
    TcpIpConnectionErrorHandler monitor = (TcpIpConnectionErrorHandler)ConcurrencyUtil.getOrPutIfAbsent(this.monitors, endpoint, this.monitorConstructor);
    if (reset)
      monitor.reset(); 
    return monitor;
  }
  
  Channel newChannel(SocketChannel socketChannel, boolean clientMode) throws IOException {
    Networking networking = getNetworkingService().getNetworking();
    Channel channel = networking.register(this.endpointQualifier, this.channelInitializerProvider, socketChannel, clientMode);
    if (this.endpointConfig != null)
      IOUtil.setChannelOptions(channel, this.endpointConfig); 
    if (this.endpointQualifier != null)
      channel.attributeMap().put(ProtocolType.class, this.endpointQualifier.getType()); 
    this.acceptedChannels.add(channel);
    return channel;
  }
  
  void removeAcceptedChannel(Channel channel) { this.acceptedChannels.remove(channel); }
  
  void failedConnection(Address address, Throwable t, boolean silent) {
    this.connectionsInProgress.remove(address);
    this.ioService.onFailedConnection(address);
    if (!silent)
      getErrorHandler(address, false).onError(t); 
  }
  
  TcpIpConnection newConnection(Channel channel, Address endpoint) {
    try {
      if (!this.networkingService.isLive())
        throw new IllegalStateException("connection manager is not live!"); 
      TcpIpConnection connection = new TcpIpConnection(this, this.connectionLifecycleListener, this.connectionIdGen.incrementAndGet(), channel);
      connection.setEndPoint(endpoint);
      this.activeConnections.add(connection);
      if (this.logger.isFineEnabled())
        this.logger.fine("Established socket connection between " + channel.localSocketAddress() + " and " + channel
            .remoteSocketAddress()); 
      this.openedCount.inc();
      channel.start();
      return connection;
    } finally {
      this.acceptedChannels.remove(channel);
    } 
  }
  
  private boolean send(Packet packet, Address target, SendTask sendTask) {
    TcpIpConnection tcpIpConnection = getConnection(target);
    if (tcpIpConnection != null)
      return tcpIpConnection.write(packet); 
    if (sendTask == null)
      sendTask = new SendTask(this, packet, target, null); 
    int retries = SendTask.access$200(sendTask);
    if (retries < 5 && this.ioService.isActive()) {
      getOrConnect(target, true);
      try {
        this.networkingService.scheduleDeferred(sendTask, (retries + 1) * 100L, TimeUnit.MILLISECONDS);
        return true;
      } catch (RejectedExecutionException e) {
        if (this.networkingService.isLive())
          throw e; 
        if (this.logger.isFinestEnabled())
          this.logger.finest("Packet send task is rejected. Packet cannot be sent to " + target); 
      } 
    } 
    return false;
  }
  
  public String toString() { return "TcpIpEndpointManager{endpointQualifier=" + this.endpointQualifier + ", connectionsMap=" + this.connectionsMap + '}'; }
  
  int getAcceptedChannelsSize() { return this.acceptedChannels.size(); }
  
  int getConnectionListenersCount() { return this.connectionListeners.size(); }
}
