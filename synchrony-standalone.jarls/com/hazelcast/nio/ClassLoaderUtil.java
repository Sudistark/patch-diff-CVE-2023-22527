package com.hazelcast.nio;

import com.hazelcast.spi.annotation.PrivateApi;
import com.hazelcast.util.EmptyStatement;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.Preconditions;
import java.lang.reflect.Constructor;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

@PrivateApi
public final class ClassLoaderUtil {
  public static final String HAZELCAST_BASE_PACKAGE = "com.hazelcast.";
  
  public static final String HAZELCAST_ARRAY = "[Lcom.hazelcast.";
  
  private static final boolean CLASS_CACHE_DISABLED = Boolean.getBoolean("hazelcast.compat.classloading.cache.disabled");
  
  private static final Map<String, Class> PRIMITIVE_CLASSES;
  
  private static final int MAX_PRIM_CLASS_NAME_LENGTH = 7;
  
  private static final ClassLoaderWeakCache<Constructor> CONSTRUCTOR_CACHE = new ClassLoaderWeakCache(null);
  
  private static final ClassLoaderWeakCache<Class> CLASS_CACHE = new ClassLoaderWeakCache(null);
  
  private static final Constructor<?> IRRESOLVABLE_CONSTRUCTOR;
  
  static  {
    try {
      IRRESOLVABLE_CONSTRUCTOR = IrresolvableConstructor.class.getConstructor(new Class[0]);
    } catch (NoSuchMethodException primitives) {
      throw new Error("Couldn't initialize irresolvable constructor.", e);
    } 
    primitives = new HashMap(10, 1.0F);
    primitives.put("boolean", boolean.class);
    primitives.put("byte", byte.class);
    primitives.put("int", int.class);
    primitives.put("long", long.class);
    primitives.put("short", short.class);
    primitives.put("float", float.class);
    primitives.put("double", double.class);
    primitives.put("char", char.class);
    primitives.put("void", void.class);
    PRIMITIVE_CLASSES = Collections.unmodifiableMap(primitives);
  }
  
  public static <T> T getOrCreate(T instance, ClassLoader classLoader, String className) {
    if (instance != null)
      return instance; 
    if (className != null)
      try {
        return (T)newInstance(classLoader, className);
      } catch (Exception e) {
        throw ExceptionUtil.rethrow(e);
      }  
    return null;
  }
  
  public static <T> T newInstance(ClassLoader classLoaderHint, String className) throws Exception {
    Preconditions.isNotNull(className, "className");
    Class primitiveClass = tryPrimitiveClass(className);
    if (primitiveClass != null)
      return (T)primitiveClass.newInstance(); 
    ClassLoader cl1 = classLoaderHint;
    if (cl1 == null)
      cl1 = ClassLoaderUtil.class.getClassLoader(); 
    if (cl1 == null)
      cl1 = Thread.currentThread().getContextClassLoader(); 
    ClassLoader cl2 = null;
    if ((className.startsWith("com.hazelcast.") || className.startsWith("[Lcom.hazelcast.")) && cl1 != ClassLoaderUtil.class
      .getClassLoader())
      cl2 = ClassLoaderUtil.class.getClassLoader(); 
    if (cl2 == null)
      cl2 = Thread.currentThread().getContextClassLoader(); 
    if (cl1 == cl2)
      cl2 = null; 
    if (cl1 == null && cl2 != null) {
      cl1 = cl2;
      cl2 = null;
    } 
    if (cl1 != null) {
      Constructor<T> constructor = (Constructor)CONSTRUCTOR_CACHE.get(cl1, className);
      if (constructor == IRRESOLVABLE_CONSTRUCTOR && cl2 != null)
        constructor = (Constructor)CONSTRUCTOR_CACHE.get(cl2, className); 
      if (constructor != null && constructor != IRRESOLVABLE_CONSTRUCTOR)
        return (T)constructor.newInstance(new Object[0]); 
    } 
    try {
      return (T)newInstance0(cl1, className);
    } catch (ClassNotFoundException e1) {
      if (cl2 != null) {
        ClassLoaderWeakCache.access$100(CONSTRUCTOR_CACHE, cl1, className, IRRESOLVABLE_CONSTRUCTOR);
        try {
          return (T)newInstance0(cl2, className);
        } catch (ClassNotFoundException e2) {
          EmptyStatement.ignore(e2);
        } 
      } 
      throw e1;
    } 
  }
  
  private static <T> T newInstance0(ClassLoader classLoader, String className) throws Exception {
    Class klass = (classLoader == null) ? Class.forName(className) : tryLoadClass(className, classLoader);
    Constructor constructor = klass.getDeclaredConstructor(new Class[0]);
    if (!constructor.isAccessible())
      constructor.setAccessible(true); 
    if (!shouldBypassCache(klass) && classLoader != null)
      ClassLoaderWeakCache.access$100(CONSTRUCTOR_CACHE, classLoader, className, constructor); 
    return (T)constructor.newInstance(new Object[0]);
  }
  
  public static Class<?> loadClass(ClassLoader classLoaderHint, String className) throws ClassNotFoundException {
    Preconditions.isNotNull(className, "className");
    Class<?> primitiveClass = tryPrimitiveClass(className);
    if (primitiveClass != null)
      return primitiveClass; 
    ClassLoader theClassLoader = classLoaderHint;
    if (theClassLoader == null)
      theClassLoader = Thread.currentThread().getContextClassLoader(); 
    if (theClassLoader != null)
      try {
        return tryLoadClass(className, theClassLoader);
      } catch (ClassNotFoundException ignore) {
        theClassLoader = null;
      }  
    if (className.startsWith("com.hazelcast.") || className.startsWith("[Lcom.hazelcast."))
      theClassLoader = ClassLoaderUtil.class.getClassLoader(); 
    if (theClassLoader == null)
      theClassLoader = Thread.currentThread().getContextClassLoader(); 
    if (theClassLoader != null)
      return tryLoadClass(className, theClassLoader); 
    return Class.forName(className);
  }
  
  private static Class<?> tryPrimitiveClass(String className) {
    if (className.length() <= 7 && Character.isLowerCase(className.charAt(0))) {
      Class primitiveClass = (Class)PRIMITIVE_CLASSES.get(className);
      if (primitiveClass != null)
        return primitiveClass; 
    } 
    return null;
  }
  
  public static boolean isClassAvailable(ClassLoader classLoader, String className) {
    try {
      Class<?> clazz = loadClass(classLoader, className);
      return (clazz != null);
    } catch (ClassNotFoundException e) {
      return false;
    } 
  }
  
  private static Class<?> tryLoadClass(String className, ClassLoader classLoader) throws ClassNotFoundException {
    Class<?> clazz;
    if (!CLASS_CACHE_DISABLED) {
      clazz = (Class)CLASS_CACHE.get(classLoader, className);
      if (clazz != null)
        return clazz; 
    } 
    if (className.startsWith("[")) {
      clazz = Class.forName(className, false, classLoader);
    } else {
      clazz = classLoader.loadClass(className);
    } 
    if (!CLASS_CACHE_DISABLED && 
      !shouldBypassCache(clazz))
      ClassLoaderWeakCache.access$100(CLASS_CACHE, classLoader, className, clazz); 
    return clazz;
  }
  
  public static boolean isInternalType(Class type) {
    String name = type.getName();
    ClassLoader classLoader = ClassLoaderUtil.class.getClassLoader();
    return (type.getClassLoader() == classLoader && name.startsWith("com.hazelcast."));
  }
  
  public static Class<?> tryLoadClass(String className) {
    try {
      return Class.forName(className);
    } catch (ClassNotFoundException e) {
      ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
      return contextClassLoader.loadClass(className);
    } 
  }
  
  public static boolean isClassDefined(String className) {
    try {
      tryLoadClass(className);
      return true;
    } catch (ClassNotFoundException e) {
      return false;
    } 
  }
  
  public static boolean implementsInterfaceWithSameName(Class<?> clazz, Class<?> iface) {
    Class[] interfaces = getAllInterfaces(clazz);
    for (Class implementedInterface : interfaces) {
      if (implementedInterface.getName().equals(iface.getName()))
        return true; 
    } 
    return false;
  }
  
  public static Class<?>[] getAllInterfaces(Class<?> clazz) {
    Collection<Class<?>> interfaces = new HashSet<Class<?>>();
    addOwnInterfaces(clazz, interfaces);
    addInterfacesOfSuperclasses(clazz, interfaces);
    return (Class[])interfaces.toArray(new Class[0]);
  }
  
  private static void addOwnInterfaces(Class<?> clazz, Collection<Class<?>> allInterfaces) {
    Class[] interfaces = clazz.getInterfaces();
    Collections.addAll(allInterfaces, interfaces);
    for (Class cl : interfaces)
      addOwnInterfaces(cl, allInterfaces); 
  }
  
  private static void addInterfacesOfSuperclasses(Class<?> clazz, Collection<Class<?>> interfaces) {
    Class<?> superClass = clazz.getSuperclass();
    while (superClass != null) {
      addOwnInterfaces(superClass, interfaces);
      superClass = superClass.getSuperclass();
    } 
  }
  
  private static boolean shouldBypassCache(Class clazz) { return clazz.getClassLoader() instanceof com.hazelcast.internal.usercodedeployment.impl.ClassSource; }
}
