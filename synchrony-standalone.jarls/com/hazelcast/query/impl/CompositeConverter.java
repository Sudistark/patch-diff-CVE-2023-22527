package com.hazelcast.query.impl;

import com.hazelcast.core.TypeConverter;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

public class CompositeConverter implements TypeConverter {
  private final TypeConverter[] converters;
  
  private final boolean isTransient;
  
  @SuppressFBWarnings({"EI_EXPOSE_REP2"})
  public CompositeConverter(TypeConverter[] converters) {
    this.converters = converters;
    boolean isTransient = false;
    for (TypeConverter converter : converters) {
      assert converter != null;
      if (converter == TypeConverters.NULL_CONVERTER) {
        isTransient = true;
        break;
      } 
    } 
    this.isTransient = isTransient;
  }
  
  public boolean isTransient() { return this.isTransient; }
  
  public TypeConverter getComponentConverter(int component) { return this.converters[component]; }
  
  public Comparable convert(Comparable value) {
    if (!(value instanceof CompositeValue))
      throw new IllegalArgumentException("Cannot convert [" + value + "] to composite"); 
    CompositeValue compositeValue = (CompositeValue)value;
    Comparable[] components = compositeValue.getComponents();
    Comparable[] converted = new Comparable[components.length];
    for (int i = 0; i < components.length; i++) {
      Comparable component = components[i];
      if (component == AbstractIndex.NULL || component == CompositeValue.NEGATIVE_INFINITY || component == CompositeValue.POSITIVE_INFINITY) {
        converted[i] = component;
      } else {
        converted[i] = this.converters[i].convert(component);
      } 
    } 
    return new CompositeValue(converted);
  }
}
