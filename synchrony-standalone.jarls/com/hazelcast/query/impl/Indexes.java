package com.hazelcast.query.impl;

import com.hazelcast.core.TypeConverter;
import com.hazelcast.internal.serialization.InternalSerializationService;
import com.hazelcast.monitor.impl.GlobalIndexesStats;
import com.hazelcast.monitor.impl.IndexesStats;
import com.hazelcast.monitor.impl.PartitionIndexesStats;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.query.IndexAwarePredicate;
import com.hazelcast.query.Predicate;
import com.hazelcast.query.impl.getters.Extractors;
import com.hazelcast.spi.serialization.SerializationService;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class Indexes {
  public static final int SKIP_PARTITIONS_COUNT_CHECK = -1;
  
  private static final InternalIndex[] EMPTY_INDEXES = new InternalIndex[0];
  
  private final boolean global;
  
  private final boolean usesCachedQueryableEntries;
  
  private final IndexesStats stats;
  
  private final Extractors extractors;
  
  private final IndexProvider indexProvider;
  
  private final IndexCopyBehavior indexCopyBehavior;
  
  private final QueryContextProvider queryContextProvider;
  
  private final InternalSerializationService serializationService;
  
  private final Map<String, InternalIndex> indexesByName;
  
  private final AttributeIndexRegistry attributeIndexRegistry;
  
  private final AttributeIndexRegistry evaluateOnlyAttributeIndexRegistry;
  
  private final ConverterCache converterCache;
  
  private final ConcurrentMap<String, Boolean> definitions;
  
  private Indexes(InternalSerializationService serializationService, IndexCopyBehavior indexCopyBehavior, Extractors extractors, IndexProvider indexProvider, boolean usesCachedQueryableEntries, boolean statisticsEnabled, boolean global) {
    this.indexesByName = new ConcurrentHashMap(3);
    this.attributeIndexRegistry = new AttributeIndexRegistry();
    this.evaluateOnlyAttributeIndexRegistry = new AttributeIndexRegistry();
    this.converterCache = new ConverterCache(this);
    this.definitions = new ConcurrentHashMap();
    this.indexes = EMPTY_INDEXES;
    this.compositeIndexes = EMPTY_INDEXES;
    this.global = global;
    this.indexCopyBehavior = indexCopyBehavior;
    this.serializationService = serializationService;
    this.usesCachedQueryableEntries = usesCachedQueryableEntries;
    this.stats = createStats(global, statisticsEnabled);
    this.extractors = (extractors == null) ? Extractors.newBuilder(serializationService).build() : extractors;
    this.indexProvider = (indexProvider == null) ? new DefaultIndexProvider() : indexProvider;
    this.queryContextProvider = createQueryContextProvider(this, global, statisticsEnabled);
  }
  
  public static void markPartitionAsIndexed(int partitionId, InternalIndex[] indexes) {
    for (InternalIndex index : indexes)
      index.markPartitionAsIndexed(partitionId); 
  }
  
  public static void markPartitionAsUnindexed(int partitionId, InternalIndex[] indexes) {
    for (InternalIndex index : indexes)
      index.markPartitionAsUnindexed(partitionId); 
  }
  
  public static Builder newBuilder(SerializationService ss, IndexCopyBehavior indexCopyBehavior) { return new Builder(ss, indexCopyBehavior); }
  
  public InternalIndex addOrGetIndex(String name, boolean ordered) {
    InternalIndex index = (InternalIndex)this.indexesByName.get(name);
    if (index != null)
      return index; 
    IndexDefinition definition = IndexDefinition.parse(name, ordered);
    index = (InternalIndex)this.indexesByName.get(definition.getName());
    if (index != null)
      return index; 
    index = this.indexProvider.createIndex(definition, this.extractors, this.serializationService, this.indexCopyBehavior, this.stats
        .createPerIndexStats(ordered, this.usesCachedQueryableEntries));
    this.indexesByName.put(definition.getName(), index);
    if (index.isEvaluateOnly()) {
      this.evaluateOnlyAttributeIndexRegistry.register(index);
    } else {
      this.attributeIndexRegistry.register(index);
    } 
    this.converterCache.invalidate(index);
    this.indexes = (InternalIndex[])this.indexesByName.values().toArray(EMPTY_INDEXES);
    if (definition.getComponents().length > 1) {
      InternalIndex[] oldCompositeIndexes = this.compositeIndexes;
      InternalIndex[] newCompositeIndexes = (InternalIndex[])Arrays.copyOf(oldCompositeIndexes, oldCompositeIndexes.length + 1);
      newCompositeIndexes[oldCompositeIndexes.length] = index;
      this.compositeIndexes = newCompositeIndexes;
    } 
    return index;
  }
  
  public void recordIndexDefinition(String name, boolean ordered) {
    if (this.definitions.containsKey(name) || this.indexesByName.containsKey(name))
      return; 
    IndexDefinition definition = IndexDefinition.parse(name, ordered);
    if (this.definitions.containsKey(definition.getName()) || this.indexesByName.containsKey(definition.getName()))
      return; 
    this.definitions.put(name, Boolean.valueOf(ordered));
  }
  
  public void createIndexesFromRecordedDefinitions() {
    for (Map.Entry<String, Boolean> definition : this.definitions.entrySet()) {
      addOrGetIndex((String)definition.getKey(), ((Boolean)definition.getValue()).booleanValue());
      this.definitions.remove(definition.getKey(), definition.getValue());
    } 
  }
  
  public Collection<IndexInfo> getIndexDefinitions() {
    Collection<IndexInfo> indexInfos = new ArrayList<IndexInfo>(this.definitions.size());
    for (Map.Entry<String, Boolean> definition : this.definitions.entrySet())
      indexInfos.add(new IndexInfo((String)definition.getKey(), ((Boolean)definition.getValue()).booleanValue())); 
    return indexInfos;
  }
  
  @SuppressFBWarnings({"EI_EXPOSE_REP"})
  public InternalIndex[] getIndexes() { return this.indexes; }
  
  @SuppressFBWarnings({"EI_EXPOSE_REP"})
  public InternalIndex[] getCompositeIndexes() { return this.compositeIndexes; }
  
  public void destroyIndexes() {
    InternalIndex[] indexesSnapshot = getIndexes();
    this.indexes = EMPTY_INDEXES;
    this.compositeIndexes = EMPTY_INDEXES;
    this.indexesByName.clear();
    this.attributeIndexRegistry.clear();
    this.evaluateOnlyAttributeIndexRegistry.clear();
    this.converterCache.clear();
    for (InternalIndex index : indexesSnapshot)
      index.destroy(); 
  }
  
  public void clearAll() {
    InternalIndex[] indexesSnapshot = getIndexes();
    for (InternalIndex index : indexesSnapshot)
      index.clear(); 
  }
  
  public boolean haveAtLeastOneIndex() { return (this.indexes != EMPTY_INDEXES); }
  
  public boolean haveAtLeastOneIndexOrDefinition() {
    boolean haveAtLeastOneIndexOrDefinition = (haveAtLeastOneIndex() || !this.definitions.isEmpty());
    assert isGlobal() || !haveAtLeastOneIndexOrDefinition || !haveAtLeastOneIndex() || this.definitions.isEmpty();
    return haveAtLeastOneIndexOrDefinition;
  }
  
  public void putEntry(QueryableEntry queryableEntry, Object oldValue, Index.OperationSource operationSource) {
    InternalIndex[] indexes = getIndexes();
    for (InternalIndex index : indexes)
      index.putEntry(queryableEntry, oldValue, operationSource); 
  }
  
  public void removeEntry(Data key, Object value, Index.OperationSource operationSource) {
    InternalIndex[] indexes = getIndexes();
    for (InternalIndex index : indexes)
      index.removeEntry(key, value, operationSource); 
  }
  
  public boolean isGlobal() { return this.global; }
  
  public InternalIndex getIndex(String name) { return (InternalIndex)this.indexesByName.get(name); }
  
  public Set<QueryableEntry> query(Predicate predicate, int ownedPartitionCount) {
    this.stats.incrementQueryCount();
    if (!haveAtLeastOneIndex() || !(predicate instanceof IndexAwarePredicate))
      return null; 
    IndexAwarePredicate indexAwarePredicate = (IndexAwarePredicate)predicate;
    QueryContext queryContext = this.queryContextProvider.obtainContextFor(this, ownedPartitionCount);
    if (!indexAwarePredicate.isIndexed(queryContext))
      return null; 
    Set<QueryableEntry> result = indexAwarePredicate.filter(queryContext);
    if (result != null) {
      this.stats.incrementIndexedQueryCount();
      queryContext.applyPerQueryStats();
    } 
    return result;
  }
  
  public InternalIndex matchIndex(String pattern, QueryContext.IndexMatchHint matchHint, int ownedPartitionCount) {
    InternalIndex index;
    if (matchHint == QueryContext.IndexMatchHint.EXACT_NAME) {
      index = (InternalIndex)this.indexesByName.get(pattern);
    } else {
      index = this.attributeIndexRegistry.match(pattern, matchHint);
    } 
    if (index == null || !index.allPartitionsIndexed(ownedPartitionCount))
      return null; 
    return index;
  }
  
  public InternalIndex matchIndex(String pattern, Class<? extends Predicate> predicateClass, QueryContext.IndexMatchHint matchHint, int ownedPartitionCount) {
    InternalIndex index;
    if (matchHint == QueryContext.IndexMatchHint.EXACT_NAME) {
      index = (InternalIndex)this.indexesByName.get(pattern);
    } else {
      index = this.evaluateOnlyAttributeIndexRegistry.match(pattern, matchHint);
      if (index == null)
        index = this.attributeIndexRegistry.match(pattern, matchHint); 
    } 
    if (index == null)
      return null; 
    if (!index.canEvaluate(predicateClass))
      return null; 
    if (!index.allPartitionsIndexed(ownedPartitionCount))
      return null; 
    return index;
  }
  
  public TypeConverter getConverter(String attribute) { return this.converterCache.get(attribute); }
  
  public IndexesStats getIndexesStats() { return this.stats; }
  
  private static QueryContextProvider createQueryContextProvider(Indexes indexes, boolean global, boolean statisticsEnabled) {
    if (statisticsEnabled)
      return global ? new GlobalQueryContextProviderWithStats() : new PartitionQueryContextProviderWithStats(indexes); 
    return global ? new GlobalQueryContextProvider() : new PartitionQueryContextProvider(indexes);
  }
  
  private static IndexesStats createStats(boolean global, boolean statisticsEnabled) {
    if (statisticsEnabled)
      return global ? new GlobalIndexesStats() : new PartitionIndexesStats(); 
    return IndexesStats.EMPTY;
  }
}
