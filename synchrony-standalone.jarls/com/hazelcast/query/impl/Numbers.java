package com.hazelcast.query.impl;

public final class Numbers {
  public static boolean equal(Number lhs, Number rhs) {
    Class lhsClass = lhs.getClass();
    Class rhsClass = rhs.getClass();
    assert lhsClass != rhsClass;
    if (isDoubleRepresentable(lhsClass)) {
      if (isDoubleRepresentable(rhsClass))
        return equalDoubles(lhs.doubleValue(), rhs.doubleValue()); 
      if (isLongRepresentable(rhsClass))
        return equalLongAndDouble(rhs.longValue(), lhs.doubleValue()); 
    } else if (isLongRepresentable(lhsClass)) {
      if (isDoubleRepresentable(rhsClass))
        return equalLongAndDouble(lhs.longValue(), rhs.doubleValue()); 
      if (isLongRepresentable(rhsClass))
        return (lhs.longValue() == rhs.longValue()); 
    } 
    return lhs.equals(rhs);
  }
  
  public static int compare(Comparable lhs, Comparable rhs) {
    Class lhsClass = lhs.getClass();
    Class rhsClass = rhs.getClass();
    assert lhsClass != rhsClass;
    assert lhs instanceof Number;
    assert rhs instanceof Number;
    Number lhsNumber = (Number)lhs;
    Number rhsNumber = (Number)rhs;
    if (isDoubleRepresentable(lhsClass)) {
      if (isDoubleRepresentable(rhsClass))
        return Double.compare(lhsNumber.doubleValue(), rhsNumber.doubleValue()); 
      if (isLongRepresentable(rhsClass))
        return -Integer.signum(compareLongWithDouble(rhsNumber.longValue(), lhsNumber.doubleValue())); 
    } else if (isLongRepresentable(lhsClass)) {
      if (isDoubleRepresentable(rhsClass))
        return compareLongWithDouble(lhsNumber.longValue(), rhsNumber.doubleValue()); 
      if (isLongRepresentable(rhsClass))
        return compareLongs(lhsNumber.longValue(), rhsNumber.longValue()); 
    } 
    return lhs.compareTo(rhs);
  }
  
  public static Comparable canonicalizeForHashLookup(Comparable value) {
    Class clazz = value.getClass();
    assert value instanceof Number;
    Number number = (Number)value;
    if (isDoubleRepresentable(clazz)) {
      double doubleValue = number.doubleValue();
      long longValue = number.longValue();
      if (equalDoubles(doubleValue, longValue))
        return Long.valueOf(longValue); 
      if (clazz == Float.class)
        return Double.valueOf(doubleValue); 
    } else if (isLongRepresentableExceptLong(clazz)) {
      return Long.valueOf(number.longValue());
    } 
    return value;
  }
  
  public static boolean equalDoubles(double lhs, double rhs) { return (Double.doubleToLongBits(lhs) == Double.doubleToLongBits(rhs)); }
  
  public static boolean equalFloats(float lhs, float rhs) { return (Float.floatToIntBits(lhs) == Float.floatToIntBits(rhs)); }
  
  public static double asDoubleExactly(Number number) {
    Class clazz = number.getClass();
    if (isDoubleRepresentable(clazz) || isLongRepresentableExceptLong(clazz))
      return number.doubleValue(); 
    if (clazz == Long.class) {
      double doubleValue = number.doubleValue();
      if (number.longValue() == (long)doubleValue)
        return doubleValue; 
    } 
    throw new IllegalArgumentException("Can't represent " + number + " as double exactly");
  }
  
  public static long asLongExactly(Number number) {
    Class clazz = number.getClass();
    if (isLongRepresentable(clazz))
      return number.longValue(); 
    if (isDoubleRepresentable(clazz)) {
      long longValue = number.longValue();
      if (equalDoubles(number.doubleValue(), longValue))
        return longValue; 
    } 
    throw new IllegalArgumentException("Can't represent " + number + " as long exactly");
  }
  
  public static int asIntExactly(Number number) {
    Class clazz = number.getClass();
    if (isLongRepresentableExceptLong(clazz))
      return number.intValue(); 
    if (clazz == Long.class) {
      int intValue = number.intValue();
      if (number.longValue() == intValue)
        return intValue; 
    } else if (isDoubleRepresentable(clazz)) {
      int intValue = number.intValue();
      if (equalDoubles(number.doubleValue(), intValue))
        return intValue; 
    } 
    throw new IllegalArgumentException("Can't represent " + number + " as int exactly");
  }
  
  public static boolean isDoubleRepresentable(Class clazz) { return (clazz == Double.class || clazz == Float.class); }
  
  public static boolean isLongRepresentable(Class clazz) { return (clazz == Long.class || clazz == Integer.class || clazz == Short.class || clazz == Byte.class); }
  
  public static boolean equalLongAndDouble(long l, double d) {
    if (d > -9.007199254740992E15D && d < 9.007199254740992E15D)
      return equalDoubles(l, d); 
    if (d <= -9.223372036854776E18D)
      return false; 
    if (d >= 9.223372036854776E18D)
      return false; 
    if (Double.isNaN(d))
      return false; 
    return (l == (long)d);
  }
  
  public static int compareLongs(long lhs, long rhs) { return (lhs < rhs) ? -1 : ((lhs == rhs) ? 0 : 1); }
  
  private static boolean isLongRepresentableExceptLong(Class clazz) { return (clazz == Integer.class || clazz == Short.class || clazz == Byte.class); }
  
  private static int compareLongWithDouble(long l, double d) {
    if (d > -9.007199254740992E15D && d < 9.007199254740992E15D)
      return Double.compare(l, d); 
    if (d <= -9.223372036854776E18D)
      return 1; 
    if (d >= 9.223372036854776E18D)
      return -1; 
    if (Double.isNaN(d))
      return -1; 
    return compareLongs(l, (long)d);
  }
}
