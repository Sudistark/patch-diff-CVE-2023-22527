package com.hazelcast.query.impl;

import com.hazelcast.core.TypeConverter;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.query.Predicate;
import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentSkipListMap;

public class OrderedIndexStore extends BaseSingleValueIndexStore {
  private final ConcurrentSkipListMap<Comparable, Map<Data, QueryableEntry>> recordMap = new ConcurrentSkipListMap(Comparables.COMPARATOR);
  
  private final BaseIndexStore.IndexFunctor<Comparable, QueryableEntry> addFunctor;
  
  private final BaseIndexStore.IndexFunctor<Comparable, Data> removeFunctor;
  
  public OrderedIndexStore(IndexCopyBehavior copyOn) {
    super(copyOn);
    assert copyOn != null;
    if (copyOn == IndexCopyBehavior.COPY_ON_WRITE) {
      this.addFunctor = new CopyOnWriteAddFunctor(this, null);
      this.removeFunctor = new CopyOnWriteRemoveFunctor(this, null);
      this.recordsWithNullValue = Collections.emptyMap();
    } else {
      this.addFunctor = new AddFunctor(this, null);
      this.removeFunctor = new RemoveFunctor(this, null);
      this.recordsWithNullValue = new ConcurrentHashMap();
    } 
  }
  
  Object insertInternal(Comparable value, QueryableEntry record) { return this.addFunctor.invoke(value, record); }
  
  Object removeInternal(Comparable value, Data recordKey) { return this.removeFunctor.invoke(value, recordKey); }
  
  public Comparable canonicalizeQueryArgumentScalar(Comparable value) { return Comparables.canonicalizeForHashLookup(value); }
  
  public Comparable canonicalizeScalarForStorage(Comparable value) { return value; }
  
  public void clear() {
    takeWriteLock();
    try {
      this.recordsWithNullValue.clear();
      this.recordMap.clear();
    } finally {
      releaseWriteLock();
    } 
  }
  
  public boolean isEvaluateOnly() { return false; }
  
  public boolean canEvaluate(Class<? extends Predicate> predicateClass) { return false; }
  
  public Set<QueryableEntry> evaluate(Predicate predicate, TypeConverter converter) { throw new UnsupportedOperationException(); }
  
  public Set<QueryableEntry> getRecords(Comparable value) {
    takeReadLock();
    try {
      if (value == AbstractIndex.NULL)
        return toSingleResultSet(this.recordsWithNullValue); 
      return toSingleResultSet((Map)this.recordMap.get(value));
    } finally {
      releaseReadLock();
    } 
  }
  
  public Set<QueryableEntry> getRecords(Set<Comparable> values) {
    takeReadLock();
    try {
      MultiResultSet results = createMultiResultSet();
      for (Comparable value : values) {
        Map<Data, QueryableEntry> records;
        if (value == AbstractIndex.NULL) {
          records = this.recordsWithNullValue;
        } else {
          records = (Map)this.recordMap.get(value);
        } 
        if (records != null)
          copyToMultiResultSet(results, records); 
      } 
      return results;
    } finally {
      releaseReadLock();
    } 
  }
  
  public Set<QueryableEntry> getRecords(Comparison comparison, Comparable searchedValue) {
    takeReadLock();
    try {
      SortedMap<Comparable, Map<Data, QueryableEntry>> subMap, subMap, subMap, subMap;
      MultiResultSet results = createMultiResultSet();
      switch (null.$SwitchMap$com$hazelcast$query$impl$Comparison[comparison.ordinal()]) {
        case 1:
          subMap = this.recordMap.headMap(searchedValue, false);
          break;
        case 2:
          subMap = this.recordMap.headMap(searchedValue, true);
          break;
        case 3:
          subMap = this.recordMap.tailMap(searchedValue, false);
          break;
        case 4:
          subMap = this.recordMap.tailMap(searchedValue, true);
          break;
        case 5:
          for (Map.Entry<Comparable, Map<Data, QueryableEntry>> entry : this.recordMap.entrySet()) {
            if (Comparables.compare(searchedValue, (Comparable)entry.getKey()) != 0)
              copyToMultiResultSet(results, (Map)entry.getValue()); 
          } 
          return results;
        default:
          throw new IllegalArgumentException("Unrecognized comparison: " + comparison);
      } 
      for (Map<Data, QueryableEntry> value : subMap.values())
        copyToMultiResultSet(results, value); 
      return results;
    } finally {
      releaseReadLock();
    } 
  }
  
  public Set<QueryableEntry> getRecords(Comparable from, boolean fromInclusive, Comparable to, boolean toInclusive) {
    takeReadLock();
    try {
      int order = Comparables.compare(from, to);
      if (order == 0) {
        if (!fromInclusive || !toInclusive)
          return Collections.emptySet(); 
        return toSingleResultSet((Map)this.recordMap.get(from));
      } 
      if (order > 0)
        return Collections.emptySet(); 
      MultiResultSet results = createMultiResultSet();
      SortedMap<Comparable, Map<Data, QueryableEntry>> subMap = this.recordMap.subMap(from, fromInclusive, to, toInclusive);
      for (Map<Data, QueryableEntry> value : subMap.values())
        copyToMultiResultSet(results, value); 
      return results;
    } finally {
      releaseReadLock();
    } 
  }
}
