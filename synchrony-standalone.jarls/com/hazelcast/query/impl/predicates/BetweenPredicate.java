package com.hazelcast.query.impl.predicates;

import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.BinaryInterface;
import com.hazelcast.query.Predicate;
import com.hazelcast.query.VisitablePredicate;
import com.hazelcast.query.impl.Comparables;
import com.hazelcast.query.impl.Index;
import com.hazelcast.query.impl.Indexes;
import com.hazelcast.query.impl.QueryContext;
import com.hazelcast.query.impl.QueryableEntry;
import java.io.IOException;
import java.util.Set;

@BinaryInterface
public class BetweenPredicate extends AbstractIndexAwarePredicate implements VisitablePredicate, RangePredicate {
  private static final long serialVersionUID = 1L;
  
  Comparable to;
  
  Comparable from;
  
  public BetweenPredicate() {}
  
  public BetweenPredicate(String attribute, Comparable from, Comparable to) {
    super(attribute);
    if (from == null || to == null)
      throw new NullPointerException("Arguments can't be null"); 
    this.from = from;
    this.to = to;
  }
  
  protected boolean applyForSingleAttributeValue(Comparable attributeValue) {
    if (attributeValue == null)
      return false; 
    Comparable fromConvertedValue = convert(attributeValue, this.from);
    Comparable toConvertedValue = convert(attributeValue, this.to);
    if (fromConvertedValue == null || toConvertedValue == null)
      return false; 
    attributeValue = (Comparable)convertEnumValue(attributeValue);
    return (Comparables.compare(attributeValue, fromConvertedValue) >= 0 && 
      Comparables.compare(attributeValue, toConvertedValue) <= 0);
  }
  
  public Set<QueryableEntry> filter(QueryContext queryContext) {
    Index index = matchIndex(queryContext, QueryContext.IndexMatchHint.PREFER_ORDERED);
    if (index == null)
      return null; 
    return index.getRecords(this.from, true, this.to, true);
  }
  
  public void writeData(ObjectDataOutput out) throws IOException {
    super.writeData(out);
    out.writeObject(this.to);
    out.writeObject(this.from);
  }
  
  public void readData(ObjectDataInput in) throws IOException {
    super.readData(in);
    this.to = (Comparable)in.readObject();
    this.from = (Comparable)in.readObject();
  }
  
  public String toString() { return this.attributeName + " BETWEEN " + this.from + " AND " + this.to; }
  
  public int getId() { return 2; }
  
  public boolean equals(Object o) {
    if (this == o)
      return true; 
    if (!super.equals(o))
      return false; 
    if (!(o instanceof BetweenPredicate))
      return false; 
    BetweenPredicate that = (BetweenPredicate)o;
    if (!that.canEqual(this))
      return false; 
    if ((this.to != null) ? !this.to.equals(that.to) : (that.to != null))
      return false; 
    return (this.from != null) ? this.from.equals(that.from) : ((that.from == null) ? 1 : 0);
  }
  
  public boolean canEqual(Object other) { return other instanceof BetweenPredicate; }
  
  public int hashCode() {
    result = super.hashCode();
    result = 31 * result + ((this.to != null) ? this.to.hashCode() : 0);
    return 31 * result + ((this.from != null) ? this.from.hashCode() : 0);
  }
  
  public Predicate accept(Visitor visitor, Indexes indexes) { return visitor.visit(this, indexes); }
  
  public String getAttribute() { return this.attributeName; }
  
  public Comparable getFrom() { return this.from; }
  
  public boolean isFromInclusive() { return true; }
  
  public Comparable getTo() { return this.to; }
  
  public boolean isToInclusive() { return true; }
}
