package com.hazelcast.query.impl;

import com.hazelcast.core.TypeConverter;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.query.Predicate;
import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class UnorderedIndexStore extends BaseSingleValueIndexStore {
  private final ConcurrentMap<Comparable, Map<Data, QueryableEntry>> recordMap = new ConcurrentHashMap(1000);
  
  private final BaseIndexStore.IndexFunctor<Comparable, QueryableEntry> addFunctor;
  
  private final BaseIndexStore.IndexFunctor<Comparable, Data> removeFunctor;
  
  public UnorderedIndexStore(IndexCopyBehavior copyOn) {
    super(copyOn);
    if (copyOn == IndexCopyBehavior.COPY_ON_WRITE) {
      this.addFunctor = new CopyOnWriteAddFunctor(this, null);
      this.removeFunctor = new CopyOnWriteRemoveFunctor(this, null);
      this.recordsWithNullValue = Collections.emptyMap();
    } else {
      this.addFunctor = new AddFunctor(this, null);
      this.removeFunctor = new RemoveFunctor(this, null);
      this.recordsWithNullValue = new ConcurrentHashMap();
    } 
  }
  
  Object insertInternal(Comparable value, QueryableEntry record) { return this.addFunctor.invoke(value, record); }
  
  Object removeInternal(Comparable value, Data recordKey) { return this.removeFunctor.invoke(value, recordKey); }
  
  public Comparable canonicalizeQueryArgumentScalar(Comparable value) { return canonicalizeScalarForStorage(value); }
  
  public Comparable canonicalizeScalarForStorage(Comparable value) {
    if (!(value instanceof Number))
      return value; 
    Class clazz = value.getClass();
    Number number = (Number)value;
    if (clazz == Double.class) {
      double doubleValue = number.doubleValue();
      long longValue = number.longValue();
      if (Numbers.equalDoubles(doubleValue, longValue))
        return canonicalizeLongRepresentable(longValue); 
      float floatValue = number.floatValue();
      if (doubleValue == floatValue)
        return Float.valueOf(floatValue); 
    } else if (clazz == Float.class) {
      float floatValue = number.floatValue();
      long longValue = number.longValue();
      if (Numbers.equalFloats(floatValue, (float)longValue))
        return canonicalizeLongRepresentable(longValue); 
    } else if (Numbers.isLongRepresentable(clazz)) {
      return canonicalizeLongRepresentable(number.longValue());
    } 
    return value;
  }
  
  public void clear() {
    takeWriteLock();
    try {
      this.recordsWithNullValue.clear();
      this.recordMap.clear();
    } finally {
      releaseWriteLock();
    } 
  }
  
  public boolean isEvaluateOnly() { return false; }
  
  public boolean canEvaluate(Class<? extends Predicate> predicateClass) { return false; }
  
  public Set<QueryableEntry> evaluate(Predicate predicate, TypeConverter converter) { throw new UnsupportedOperationException(); }
  
  public Set<QueryableEntry> getRecords(Comparable value) {
    takeReadLock();
    try {
      if (value == AbstractIndex.NULL)
        return toSingleResultSet(this.recordsWithNullValue); 
      return toSingleResultSet((Map)this.recordMap.get(canonicalize(value)));
    } finally {
      releaseReadLock();
    } 
  }
  
  public Set<QueryableEntry> getRecords(Set<Comparable> values) {
    takeReadLock();
    try {
      MultiResultSet results = createMultiResultSet();
      for (Comparable value : values) {
        Map<Data, QueryableEntry> records;
        if (value == AbstractIndex.NULL) {
          records = this.recordsWithNullValue;
        } else {
          records = (Map)this.recordMap.get(value);
        } 
        if (records != null)
          copyToMultiResultSet(results, records); 
      } 
      return results;
    } finally {
      releaseReadLock();
    } 
  }
  
  public Set<QueryableEntry> getRecords(Comparison comparison, Comparable value) {
    takeReadLock();
    try {
      MultiResultSet results = createMultiResultSet();
      for (Map.Entry<Comparable, Map<Data, QueryableEntry>> recordMapEntry : this.recordMap.entrySet()) {
        boolean valid, valid, valid, valid, valid;
        Comparable indexedValue = (Comparable)recordMapEntry.getKey();
        int result = Comparables.compare(value, indexedValue);
        switch (null.$SwitchMap$com$hazelcast$query$impl$Comparison[comparison.ordinal()]) {
          case 1:
            valid = (result > 0);
            break;
          case 2:
            valid = (result >= 0);
            break;
          case 3:
            valid = (result < 0);
            break;
          case 4:
            valid = (result <= 0);
            break;
          case 5:
            valid = (result != 0);
            break;
          default:
            throw new IllegalStateException("Unrecognized comparison: " + comparison);
        } 
        if (valid) {
          Map<Data, QueryableEntry> records = (Map)recordMapEntry.getValue();
          if (records != null)
            copyToMultiResultSet(results, records); 
        } 
      } 
      return results;
    } finally {
      releaseReadLock();
    } 
  }
  
  public Set<QueryableEntry> getRecords(Comparable from, boolean fromInclusive, Comparable to, boolean toInclusive) {
    takeReadLock();
    try {
      MultiResultSet results = createMultiResultSet();
      if (Comparables.compare(from, to) == 0) {
        if (!fromInclusive || !toInclusive)
          return results; 
        Map<Data, QueryableEntry> records = (Map)this.recordMap.get(canonicalize(from));
        if (records != null)
          copyToMultiResultSet(results, records); 
        return results;
      } 
      int fromBound = fromInclusive ? 0 : 1;
      int toBound = toInclusive ? 0 : -1;
      for (Map.Entry<Comparable, Map<Data, QueryableEntry>> recordMapEntry : this.recordMap.entrySet()) {
        Comparable value = (Comparable)recordMapEntry.getKey();
        if (Comparables.compare(value, from) >= fromBound && Comparables.compare(value, to) <= toBound) {
          Map<Data, QueryableEntry> records = (Map)recordMapEntry.getValue();
          if (records != null)
            copyToMultiResultSet(results, records); 
        } 
      } 
      return results;
    } finally {
      releaseReadLock();
    } 
  }
  
  private Comparable canonicalize(Comparable value) {
    if (value instanceof CompositeValue) {
      Comparable[] components = ((CompositeValue)value).getComponents();
      for (int i = 0; i < components.length; i++)
        components[i] = canonicalizeScalarForStorage(components[i]); 
      return value;
    } 
    return canonicalizeScalarForStorage(value);
  }
  
  private static Comparable canonicalizeLongRepresentable(long value) {
    if (value == (int)value)
      return Integer.valueOf((int)value); 
    return Long.valueOf(value);
  }
}
