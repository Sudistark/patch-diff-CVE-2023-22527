package com.hazelcast.query.impl.getters;

import com.hazelcast.com.fasterxml.jackson.core.JsonParser;
import com.hazelcast.com.fasterxml.jackson.core.JsonToken;
import com.hazelcast.core.HazelcastException;
import com.hazelcast.internal.json.JsonValue;
import com.hazelcast.internal.json.NonTerminalJsonValue;
import com.hazelcast.internal.serialization.impl.NavigableJsonInputAdapter;
import com.hazelcast.json.internal.JsonPattern;
import com.hazelcast.json.internal.JsonSchemaHelper;
import com.hazelcast.json.internal.JsonSchemaNode;
import com.hazelcast.util.collection.WeightedEvictableList;
import java.io.IOException;
import java.util.List;

public abstract class AbstractJsonGetter extends Getter {
  private static final int QUERY_CONTEXT_CACHE_MAX_SIZE = 40;
  
  private static final int QUERY_CONTEXT_CACHE_CLEANUP_SIZE = 3;
  
  private static final int PATTERN_TRY_COUNT = 2;
  
  private final JsonGetterContextCache contextCache = new JsonGetterContextCache(40, 3);
  
  AbstractJsonGetter(Getter parent) { super(parent); }
  
  public static JsonPathCursor getPath(String attributePath) { return JsonPathCursor.createCursor(attributePath); }
  
  public static Object convertFromJsonValue(JsonValue value) {
    if (value == null)
      return null; 
    if (value.isNumber()) {
      if (value.toString().contains("."))
        return Double.valueOf(value.asDouble()); 
      return Long.valueOf(value.asLong());
    } 
    if (value.isBoolean())
      return Boolean.valueOf(value.asBoolean()); 
    if (value.isNull())
      return null; 
    if (value.isString())
      return value.asString(); 
    if (value == NonTerminalJsonValue.INSTANCE)
      return value; 
    throw new IllegalArgumentException("Unknown Json type: " + value);
  }
  
  abstract JsonParser createParser(Object paramObject) throws IOException;
  
  Object getValue(Object obj) { throw new HazelcastException("Path agnostic value extraction is not supported"); }
  
  Object getValue(Object obj, String attributePath) throws Exception {
    JsonPathCursor pathCursor = getPath(attributePath);
    parser = createParser(obj);
    try {
      parser.nextToken();
      while (pathCursor.getNext() != null) {
        if (pathCursor.isArray()) {
          if (pathCursor.isAny())
            return getMultiValue(parser, pathCursor); 
          JsonToken token = parser.currentToken();
          if (token != JsonToken.START_ARRAY)
            return null; 
          token = parser.nextToken();
          int arrayIndex = pathCursor.getArrayIndex();
          for (int j = 0; j < arrayIndex; j++) {
            if (token == JsonToken.END_ARRAY)
              return null; 
            parser.skipChildren();
            token = parser.nextToken();
          } 
          continue;
        } 
        if (!findAttribute(parser, pathCursor, false))
          return null; 
      } 
      return convertJsonTokenToValue(parser);
    } catch (IOException e) {
      return null;
    } finally {
      parser.close();
    } 
  }
  
  Object getValue(Object obj, String attributePath, Object metadata) throws Exception {
    if (metadata == null)
      return getValue(obj, attributePath); 
    JsonSchemaNode schemaNode = (JsonSchemaNode)metadata;
    NavigableJsonInputAdapter adapter = annotate(obj);
    JsonGetterContext queryContext = this.contextCache.getContext(attributePath);
    List<WeightedEvictableList.WeightedItem<JsonPattern>> patternsSnapshot = queryContext.getPatternListSnapshot();
    JsonPathCursor pathCursor = queryContext.newJsonPathCursor();
    for (int i = 0; i < 2 && i < patternsSnapshot.size(); i++) {
      WeightedEvictableList.WeightedItem<JsonPattern> patternWeightedItem = (WeightedEvictableList.WeightedItem)patternsSnapshot.get(i);
      JsonPattern knownPattern = (JsonPattern)patternWeightedItem.getItem();
      JsonValue value = JsonSchemaHelper.findValueWithPattern(adapter, schemaNode, knownPattern, pathCursor);
      pathCursor.reset();
      if (value != null) {
        queryContext.voteFor(patternWeightedItem);
        return convertFromJsonValue(value);
      } 
    } 
    JsonPattern knownPattern = JsonSchemaHelper.createPattern(adapter, schemaNode, pathCursor);
    pathCursor.reset();
    if (knownPattern != null) {
      if (knownPattern.hasAny())
        return getValue(obj, attributePath); 
      queryContext.addOrVoteForPattern(knownPattern);
      return convertFromJsonValue(JsonSchemaHelper.findValueWithPattern(adapter, schemaNode, knownPattern, pathCursor));
    } 
    return null;
  }
  
  Class getReturnType() { throw new IllegalArgumentException("Non applicable for Json getters"); }
  
  boolean isCacheable() { return false; }
  
  int getContextCacheSize() { return this.contextCache.getCacheSize(); }
  
  protected abstract NavigableJsonInputAdapter annotate(Object paramObject);
  
  private boolean findAttribute(JsonParser parser, JsonPathCursor pathCursor, boolean multiValue) throws IOException {
    JsonToken token = parser.getCurrentToken();
    if (token != JsonToken.START_OBJECT)
      return false; 
    while (true) {
      token = parser.nextToken();
      if (token == JsonToken.END_OBJECT)
        return false; 
      if (pathCursor.getCurrent().equals(parser.getCurrentName())) {
        parser.nextToken();
        return true;
      } 
      if (multiValue) {
        parser.nextToken();
        continue;
      } 
      parser.nextToken();
      parser.skipChildren();
    } 
  }
  
  private MultiResult getMultiValue(JsonParser parser, JsonPathCursor pathCursor) throws IOException {
    pathCursor.getNext();
    MultiResult<Object> multiResult = new MultiResult<Object>();
    JsonToken currentToken = parser.currentToken();
    if (currentToken != JsonToken.START_ARRAY)
      return null; 
    while (true) {
      currentToken = parser.nextToken();
      if (currentToken == JsonToken.END_ARRAY)
        break; 
      if (pathCursor.getCurrent() == null) {
        if (currentToken.isScalarValue()) {
          multiResult.add(convertJsonTokenToValue(parser));
          continue;
        } 
        parser.skipChildren();
        continue;
      } 
      if (currentToken == JsonToken.START_OBJECT) {
        label25: while (findAttribute(parser, pathCursor, true)) {
          if (parser.currentToken() == JsonToken.START_OBJECT || pathCursor.hasNext()) {
            if (pathCursor
              .getNext() == null)
              addToMultiResult(multiResult, parser); 
            continue;
          } 
          break label25;
        } 
        continue;
      } 
      if (currentToken == JsonToken.START_ARRAY)
        parser.skipChildren(); 
    } 
    return multiResult;
  }
  
  private static void addToMultiResult(MultiResult<Object> multiResult, JsonParser parser) throws IOException {
    if (parser.currentToken().isScalarValue())
      multiResult.add(convertJsonTokenToValue(parser)); 
    while (parser.getCurrentToken() != JsonToken.END_OBJECT) {
      if (parser.currentToken().isStructStart())
        parser.skipChildren(); 
      parser.nextToken();
    } 
  }
  
  private static Object convertJsonTokenToValue(JsonParser parser) throws IOException {
    int token = parser.currentTokenId();
    switch (token) {
      case 6:
        return parser.getValueAsString();
      case 7:
        return Long.valueOf(parser.getLongValue());
      case 8:
        return Double.valueOf(parser.getValueAsDouble());
      case 9:
        return Boolean.valueOf(true);
      case 10:
        return Boolean.valueOf(false);
      case 11:
        return null;
    } 
    return NonTerminalJsonValue.INSTANCE;
  }
}
