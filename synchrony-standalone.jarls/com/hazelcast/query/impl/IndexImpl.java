package com.hazelcast.query.impl;

import com.hazelcast.internal.serialization.InternalSerializationService;
import com.hazelcast.monitor.impl.PerIndexStats;
import com.hazelcast.query.impl.getters.Extractors;
import java.util.Collections;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

public class IndexImpl extends AbstractIndex {
  private final Set<Integer> indexedPartitions = Collections.newSetFromMap(new ConcurrentHashMap());
  
  public IndexImpl(IndexDefinition definition, InternalSerializationService ss, Extractors extractors, IndexCopyBehavior copyBehavior, PerIndexStats stats) { super(definition, ss, extractors, copyBehavior, stats); }
  
  protected IndexStore createIndexStore(IndexDefinition definition, PerIndexStats stats) {
    if (definition.getUniqueKey() == null)
      return definition.isOrdered() ? new OrderedIndexStore(this.copyBehavior) : new UnorderedIndexStore(this.copyBehavior); 
    return new BitmapIndexStore(definition, this.ss, this.extractors);
  }
  
  public void clear() {
    super.clear();
    this.indexedPartitions.clear();
  }
  
  public boolean hasPartitionIndexed(int partitionId) { return this.indexedPartitions.contains(Integer.valueOf(partitionId)); }
  
  public boolean allPartitionsIndexed(int ownedPartitionCount) { return (ownedPartitionCount < 0 || this.indexedPartitions.size() == ownedPartitionCount); }
  
  public void markPartitionAsIndexed(int partitionId) {
    assert !this.indexedPartitions.contains(Integer.valueOf(partitionId));
    this.indexedPartitions.add(Integer.valueOf(partitionId));
  }
  
  public void markPartitionAsUnindexed(int partitionId) { this.indexedPartitions.remove(Integer.valueOf(partitionId)); }
}
