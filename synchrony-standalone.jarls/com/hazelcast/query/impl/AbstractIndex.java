package com.hazelcast.query.impl;

import com.hazelcast.core.TypeConverter;
import com.hazelcast.internal.serialization.InternalSerializationService;
import com.hazelcast.monitor.impl.IndexOperationStats;
import com.hazelcast.monitor.impl.PerIndexStats;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.query.Predicate;
import com.hazelcast.query.impl.getters.Extractors;
import com.hazelcast.util.SetUtil;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.Collections;
import java.util.Set;

public abstract class AbstractIndex implements InternalIndex {
  public static final ComparableIdentifiedDataSerializable NULL = new NullObject(null);
  
  protected final InternalSerializationService ss;
  
  protected final Extractors extractors;
  
  protected final IndexStore indexStore;
  
  protected final IndexCopyBehavior copyBehavior;
  
  private final String name;
  
  private final String[] components;
  
  private final boolean ordered;
  
  private final String uniqueKey;
  
  private final PerIndexStats stats;
  
  @SuppressFBWarnings({"EI_EXPOSE_REP2"})
  public AbstractIndex(IndexDefinition definition, InternalSerializationService ss, Extractors extractors, IndexCopyBehavior copyBehavior, PerIndexStats stats) {
    this.name = definition.getName();
    this.components = definition.getComponents();
    this.ordered = definition.isOrdered();
    this.uniqueKey = definition.getUniqueKey();
    this.ss = ss;
    this.extractors = extractors;
    this.copyBehavior = copyBehavior;
    this.indexStore = createIndexStore(definition, stats);
    this.stats = stats;
  }
  
  protected abstract IndexStore createIndexStore(IndexDefinition paramIndexDefinition, PerIndexStats paramPerIndexStats);
  
  public String getName() { return this.name; }
  
  @SuppressFBWarnings({"EI_EXPOSE_REP"})
  public String[] getComponents() { return this.components; }
  
  public boolean isOrdered() { return this.ordered; }
  
  public String getUniqueKey() { return this.uniqueKey; }
  
  public TypeConverter getConverter() { return this.converter; }
  
  public void putEntry(QueryableEntry entry, Object oldValue, Index.OperationSource operationSource) {
    long timestamp = this.stats.makeTimestamp();
    IndexOperationStats operationStats = this.stats.createOperationStats();
    if (converterIsUnassignedOrTransient(this.converter))
      this.converter = obtainConverter(entry); 
    Object newAttributeValue = extractAttributeValue(entry.getKeyData(), entry.getTargetObject(false));
    if (oldValue == null) {
      this.indexStore.insert(newAttributeValue, entry, operationStats);
      this.stats.onInsert(timestamp, operationStats, operationSource);
    } else {
      Object oldAttributeValue = extractAttributeValue(entry.getKeyData(), oldValue);
      this.indexStore.update(oldAttributeValue, newAttributeValue, entry, operationStats);
      this.stats.onUpdate(timestamp, operationStats, operationSource);
    } 
  }
  
  public void removeEntry(Data key, Object value, Index.OperationSource operationSource) {
    long timestamp = this.stats.makeTimestamp();
    IndexOperationStats operationStats = this.stats.createOperationStats();
    Object attributeValue = extractAttributeValue(key, value);
    this.indexStore.remove(attributeValue, key, value, operationStats);
    this.stats.onRemove(timestamp, operationStats, operationSource);
  }
  
  public boolean isEvaluateOnly() { return this.indexStore.isEvaluateOnly(); }
  
  public boolean canEvaluate(Class<? extends Predicate> predicateClass) { return this.indexStore.canEvaluate(predicateClass); }
  
  public Set<QueryableEntry> evaluate(Predicate predicate) {
    assert this.converter != null;
    return this.indexStore.evaluate(predicate, this.converter);
  }
  
  public Set<QueryableEntry> getRecords(Comparable value) {
    long timestamp = this.stats.makeTimestamp();
    if (this.converter == null) {
      this.stats.onIndexHit(timestamp, 0L);
      return Collections.emptySet();
    } 
    Set<QueryableEntry> result = this.indexStore.getRecords(convert(value));
    this.stats.onIndexHit(timestamp, result.size());
    return result;
  }
  
  public Set<QueryableEntry> getRecords(Comparable[] values) {
    if (values.length == 1)
      return getRecords(values[0]); 
    long timestamp = this.stats.makeTimestamp();
    if (this.converter == null || values.length == 0) {
      this.stats.onIndexHit(timestamp, 0L);
      return Collections.emptySet();
    } 
    Set<Comparable> convertedValues = SetUtil.createHashSet(values.length);
    for (Comparable value : values) {
      Comparable converted = convert(value);
      convertedValues.add(canonicalizeQueryArgumentScalar(converted));
    } 
    Set<QueryableEntry> result = this.indexStore.getRecords(convertedValues);
    this.stats.onIndexHit(timestamp, result.size());
    return result;
  }
  
  public Set<QueryableEntry> getRecords(Comparable from, boolean fromInclusive, Comparable to, boolean toInclusive) {
    long timestamp = this.stats.makeTimestamp();
    if (this.converter == null) {
      this.stats.onIndexHit(timestamp, 0L);
      return Collections.emptySet();
    } 
    Set<QueryableEntry> result = this.indexStore.getRecords(convert(from), fromInclusive, convert(to), toInclusive);
    this.stats.onIndexHit(timestamp, result.size());
    return result;
  }
  
  public Set<QueryableEntry> getRecords(Comparison comparison, Comparable value) {
    long timestamp = this.stats.makeTimestamp();
    if (this.converter == null) {
      this.stats.onIndexHit(timestamp, 0L);
      return Collections.emptySet();
    } 
    Set<QueryableEntry> result = this.indexStore.getRecords(comparison, convert(value));
    this.stats.onIndexHit(timestamp, result.size());
    return result;
  }
  
  public void clear() {
    this.indexStore.clear();
    this.converter = null;
    this.stats.onClear();
  }
  
  public void destroy() { this.stats.onClear(); }
  
  public final Comparable canonicalizeQueryArgumentScalar(Comparable value) { return this.indexStore.canonicalizeQueryArgumentScalar(value); }
  
  public PerIndexStats getPerIndexStats() { return this.stats; }
  
  private Object extractAttributeValue(Data key, Object value) {
    if (this.components.length == 1)
      return QueryableEntry.extractAttributeValue(this.extractors, this.ss, this.components[0], key, value, null); 
    Comparable[] valueComponents = new Comparable[this.components.length];
    for (int i = 0; i < this.components.length; i++) {
      Object extractedValue = QueryableEntry.extractAttributeValue(this.extractors, this.ss, this.components[i], key, value, null);
      if (extractedValue instanceof com.hazelcast.query.impl.getters.MultiResult)
        throw new IllegalStateException("Collection/array attributes are not supported by composite indexes: " + this.components[i]); 
      if (extractedValue == null || extractedValue instanceof Comparable) {
        valueComponents[i] = (Comparable)extractedValue;
      } else {
        throw new IllegalStateException("Unsupported non-comparable value type: " + extractedValue.getClass());
      } 
    } 
    return new CompositeValue(valueComponents);
  }
  
  private Comparable convert(Comparable value) { return this.converter.convert(value); }
  
  private TypeConverter obtainConverter(QueryableEntry entry) {
    if (this.components.length == 1)
      return entry.getConverter(this.components[0]); 
    CompositeConverter existingConverter = (CompositeConverter)this.converter;
    TypeConverter[] converters = new TypeConverter[this.components.length];
    for (int i = 0; i < this.components.length; i++) {
      TypeConverter existingComponentConverter = getNonTransientComponentConverter(existingConverter, i);
      if (existingComponentConverter == null) {
        converters[i] = entry.getConverter(this.components[i]);
        assert converters[i] != null;
      } else {
        converters[i] = existingComponentConverter;
      } 
    } 
    return new CompositeConverter(converters);
  }
  
  private static boolean converterIsUnassignedOrTransient(TypeConverter converter) {
    if (converter == null)
      return true; 
    if (converter == TypeConverters.NULL_CONVERTER)
      return true; 
    if (!(converter instanceof CompositeConverter))
      return false; 
    CompositeConverter compositeConverter = (CompositeConverter)converter;
    return compositeConverter.isTransient();
  }
  
  private static TypeConverter getNonTransientComponentConverter(CompositeConverter converter, int index) {
    if (converter == null)
      return null; 
    TypeConverter componentConverter = converter.getComponentConverter(index);
    return (componentConverter == TypeConverters.NULL_CONVERTER) ? null : componentConverter;
  }
}
