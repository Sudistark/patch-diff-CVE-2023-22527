package com.hazelcast.query;

import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.BinaryInterface;
import com.hazelcast.nio.serialization.IdentifiedDataSerializable;
import com.hazelcast.query.impl.Indexes;
import com.hazelcast.query.impl.QueryContext;
import com.hazelcast.query.impl.QueryableEntry;
import com.hazelcast.query.impl.SkipIndexPredicate;
import com.hazelcast.query.impl.predicates.CompoundPredicate;
import com.hazelcast.query.impl.predicates.Visitor;
import com.hazelcast.util.collection.ArrayUtils;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

@BinaryInterface
public class SqlPredicate implements IndexAwarePredicate, VisitablePredicate, IdentifiedDataSerializable {
  private static final boolean SKIP_INDEX_ENABLED = !Boolean.getBoolean("hazelcast.query.disableSkipIndex");
  
  private static final long serialVersionUID = 1L;
  
  private static final ComparisonPredicateFactory EQUAL_FACTORY = new Object();
  
  private static final ComparisonPredicateFactory NOT_EQUAL_FACTORY = new Object();
  
  private static final ComparisonPredicateFactory GREATER_THAN_FACTORY = new Object();
  
  private static final ComparisonPredicateFactory GREATER_EQUAL_FACTORY = new Object();
  
  private static final ComparisonPredicateFactory LESS_EQUAL_FACTORY = new Object();
  
  private static final ComparisonPredicateFactory LESS_THAN_FACTORY = new Object();
  
  Predicate predicate;
  
  private String sql;
  
  public SqlPredicate(String sql) {
    this.sql = sql;
    this.predicate = createPredicate(sql);
  }
  
  public SqlPredicate() {}
  
  public boolean apply(Map.Entry mapEntry) { return this.predicate.apply(mapEntry); }
  
  public boolean isIndexed(QueryContext queryContext) {
    if (this.predicate instanceof IndexAwarePredicate)
      return ((IndexAwarePredicate)this.predicate).isIndexed(queryContext); 
    return false;
  }
  
  public Set<QueryableEntry> filter(QueryContext queryContext) { return ((IndexAwarePredicate)this.predicate).filter(queryContext); }
  
  public void writeData(ObjectDataOutput out) throws IOException { out.writeUTF(this.sql); }
  
  public void readData(ObjectDataInput in) throws IOException {
    this.sql = in.readUTF();
    this.predicate = createPredicate(this.sql);
  }
  
  private int getApostropheIndex(String str, int start) { return str.indexOf('\'', start); }
  
  private int getApostropheIndexIgnoringDoubles(String str, int start) {
    int i = str.indexOf('\'', start);
    int j = str.indexOf('\'', i + 1);
    while (i == j - 1) {
      i = str.indexOf('\'', j + 1);
      j = str.indexOf('\'', i + 1);
    } 
    return i;
  }
  
  private String removeEscapes(String phrase) { return (phrase.length() > 2) ? phrase.replace("''", "'") : phrase; }
  
  private Predicate createPredicate(String sql) {
    String paramSql = sql;
    Map<String, String> mapPhrases = new HashMap<String, String>();
    int apoIndex = getApostropheIndex(paramSql, 0);
    if (apoIndex != -1) {
      int phraseId = 0;
      StringBuilder newSql = new StringBuilder();
      while (apoIndex != -1) {
        phraseId++;
        int start = apoIndex + 1;
        int end = getApostropheIndexIgnoringDoubles(paramSql, apoIndex + 1);
        if (end == -1)
          throw new RuntimeException("Missing ' in sql"); 
        String phrase = removeEscapes(paramSql.substring(start, end));
        String key = "$" + phraseId;
        mapPhrases.put(key, phrase);
        String before = paramSql.substring(0, apoIndex);
        paramSql = paramSql.substring(end + 1);
        newSql.append(before);
        newSql.append(key);
        apoIndex = getApostropheIndex(paramSql, 0);
      } 
      newSql.append(paramSql);
      paramSql = newSql.toString();
    } 
    Parser parser = new Parser();
    List<String> sqlTokens = parser.toPrefix(paramSql);
    List<Object> tokens = new ArrayList<Object>(sqlTokens);
    if (tokens.size() == 0)
      throw new RuntimeException("Invalid SQL: [" + paramSql + "]"); 
    if (tokens.size() == 1)
      return eval(tokens.get(0)); 
    label95: while (tokens.size() > 1) {
      boolean foundOperand = false;
      for (int i = 0; i < tokens.size(); i++) {
        Object tokenObj = tokens.get(i);
        if (tokenObj instanceof String && parser.isOperand((String)tokenObj)) {
          String token = (String)tokenObj;
          if ("=".equals(token) || "==".equals(token)) {
            createComparison(mapPhrases, tokens, i, EQUAL_FACTORY);
            continue label95;
          } 
          if ("!=".equals(token) || "<>".equals(token)) {
            createComparison(mapPhrases, tokens, i, NOT_EQUAL_FACTORY);
            continue label95;
          } 
          if (">".equals(token)) {
            createComparison(mapPhrases, tokens, i, GREATER_THAN_FACTORY);
            continue label95;
          } 
          if (">=".equals(token)) {
            createComparison(mapPhrases, tokens, i, GREATER_EQUAL_FACTORY);
            continue label95;
          } 
          if ("<=".equals(token)) {
            createComparison(mapPhrases, tokens, i, LESS_EQUAL_FACTORY);
            continue label95;
          } 
          if ("<".equals(token)) {
            createComparison(mapPhrases, tokens, i, LESS_THAN_FACTORY);
            continue label95;
          } 
          if ("LIKE".equalsIgnoreCase(token)) {
            int position = i - 2;
            validateOperandPosition(position);
            Object first = toValue(tokens.remove(position), mapPhrases);
            Object second = toValue(tokens.remove(position), mapPhrases);
            setOrAdd(tokens, position, Predicates.like((String)first, (String)second));
            continue label95;
          } 
          if ("ILIKE".equalsIgnoreCase(token)) {
            int position = i - 2;
            validateOperandPosition(position);
            Object first = toValue(tokens.remove(position), mapPhrases);
            Object second = toValue(tokens.remove(position), mapPhrases);
            setOrAdd(tokens, position, Predicates.ilike((String)first, (String)second));
            continue label95;
          } 
          if ("REGEX".equalsIgnoreCase(token)) {
            int position = i - 2;
            validateOperandPosition(position);
            Object first = toValue(tokens.remove(position), mapPhrases);
            Object second = toValue(tokens.remove(position), mapPhrases);
            setOrAdd(tokens, position, Predicates.regex((String)first, (String)second));
            continue label95;
          } 
          if ("IN".equalsIgnoreCase(token)) {
            int position = i - 2;
            validateOperandPosition(position);
            String exp = (String)toValue(tokens.remove(position), mapPhrases);
            String[] values = toValue(((String)tokens.remove(position)).split(","), mapPhrases);
            if (skipIndex(exp)) {
              exp = exp.substring(1);
              setOrAdd(tokens, position, new SkipIndexPredicate(Predicates.in(exp, values)));
              continue label95;
            } 
            setOrAdd(tokens, position, Predicates.in(exp, values));
            continue label95;
          } 
          if ("NOT".equalsIgnoreCase(token)) {
            int position = i - 1;
            validateOperandPosition(position);
            Object exp = toValue(tokens.remove(position), mapPhrases);
            setOrAdd(tokens, position, Predicates.not(eval(exp)));
            continue label95;
          } 
          if ("BETWEEN".equalsIgnoreCase(token)) {
            int position = i - 3;
            validateOperandPosition(position);
            Object expression = tokens.remove(position);
            Object from = toValue(tokens.remove(position), mapPhrases);
            Object to = toValue(tokens.remove(position), mapPhrases);
            setOrAdd(tokens, position, Predicates.between((String)expression, (Comparable)from, (Comparable)to));
            continue label95;
          } 
          if ("AND".equalsIgnoreCase(token)) {
            int position = i - 2;
            validateOperandPosition(position);
            Object first = toValue(tokens.remove(position), mapPhrases);
            Object second = toValue(tokens.remove(position), mapPhrases);
            setOrAdd(tokens, position, (Predicate)flattenCompound(eval(first), eval(second), com.hazelcast.query.impl.predicates.AndPredicate.class));
            continue label95;
          } 
          if ("OR".equalsIgnoreCase(token)) {
            int position = i - 2;
            validateOperandPosition(position);
            Object first = toValue(tokens.remove(position), mapPhrases);
            Object second = toValue(tokens.remove(position), mapPhrases);
            setOrAdd(tokens, position, (Predicate)flattenCompound(eval(first), eval(second), com.hazelcast.query.impl.predicates.OrPredicate.class));
            continue label95;
          } 
          throw new RuntimeException("Unknown token " + token);
        } 
      } 
      if (!foundOperand)
        throw new RuntimeException("Invalid SQL: [" + paramSql + "]"); 
    } 
    return (Predicate)tokens.get(0);
  }
  
  private void createComparison(Map<String, String> mapPhrases, List<Object> tokens, int i, ComparisonPredicateFactory factory) {
    int position = i - 2;
    validateOperandPosition(position);
    String first = (String)toValue(tokens.remove(position), mapPhrases);
    Comparable second = (Comparable)toValue(tokens.remove(position), mapPhrases);
    if (skipIndex(first)) {
      first = first.substring(1);
      setOrAdd(tokens, position, new SkipIndexPredicate(factory.create(first, second)));
    } else {
      setOrAdd(tokens, position, factory.create(first, second));
    } 
  }
  
  private boolean skipIndex(String first) { return (SKIP_INDEX_ENABLED && first.startsWith("%")); }
  
  private void validateOperandPosition(int pos) {
    if (pos < 0)
      throw new RuntimeException("Invalid SQL: [" + this.sql + "]"); 
  }
  
  private Object toValue(Object key, Map<String, String> phrases) {
    String value = (String)phrases.get(key);
    if (value != null)
      return value; 
    if (key instanceof String && "null".equalsIgnoreCase((String)key))
      return null; 
    return key;
  }
  
  private String[] toValue(String[] keys, Map<String, String> phrases) {
    for (int i = 0; i < keys.length; i++) {
      String value = (String)phrases.get(keys[i]);
      if (value != null)
        keys[i] = value; 
    } 
    return keys;
  }
  
  private void setOrAdd(List tokens, int position, Predicate predicate) {
    if (tokens.size() == 0) {
      tokens.add(predicate);
    } else {
      tokens.set(position, predicate);
    } 
  }
  
  private Predicate eval(Object statement) {
    if (statement instanceof String)
      return Predicates.equal((String)statement, "true"); 
    return (Predicate)statement;
  }
  
  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { this.predicate = createPredicate(this.sql); }
  
  static <T extends CompoundPredicate> T flattenCompound(Predicate predicateLeft, Predicate predicateRight, Class<T> klass) {
    Predicate[] predicates;
    if (klass.isInstance(predicateLeft) || klass.isInstance(predicateRight)) {
      Predicate[] left = getSubPredicatesIfClass(predicateLeft, klass);
      Predicate[] right = getSubPredicatesIfClass(predicateRight, klass);
      predicates = new Predicate[left.length + right.length];
      ArrayUtils.concat(left, right, predicates);
    } else {
      predicates = new Predicate[] { predicateLeft, predicateRight };
    } 
    try {
      CompoundPredicate compoundPredicate = (CompoundPredicate)klass.newInstance();
      compoundPredicate.setPredicates(predicates);
      return (T)compoundPredicate;
    } catch (InstantiationException e) {
      throw new RuntimeException(String.format("%s should have a public default constructor", new Object[] { klass.getName() }));
    } catch (IllegalAccessException e) {
      throw new RuntimeException(String.format("%s should have a public default constructor", new Object[] { klass.getName() }));
    } 
  }
  
  private static <T extends CompoundPredicate> Predicate[] getSubPredicatesIfClass(Predicate predicate, Class<T> klass) {
    if (klass.isInstance(predicate))
      return ((CompoundPredicate)predicate).getPredicates(); 
    return new Predicate[] { predicate };
  }
  
  public String toString() { return this.predicate.toString(); }
  
  public boolean equals(Object o) {
    if (this == o)
      return true; 
    if (!(o instanceof SqlPredicate))
      return false; 
    SqlPredicate that = (SqlPredicate)o;
    return this.sql.equals(that.sql);
  }
  
  public int hashCode() { return this.sql.hashCode(); }
  
  public Predicate accept(Visitor visitor, Indexes indexes) {
    Predicate target = this.predicate;
    if (this.predicate instanceof VisitablePredicate)
      target = ((VisitablePredicate)this.predicate).accept(visitor, indexes); 
    return target;
  }
  
  public Predicate getPredicate() { return this.predicate; }
  
  public int getFactoryId() { return -32; }
  
  public int getId() { return 0; }
}
