package com.hazelcast.query;

import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.BinaryInterface;
import com.hazelcast.nio.serialization.IdentifiedDataSerializable;
import com.hazelcast.query.impl.Indexes;
import com.hazelcast.query.impl.QueryContext;
import com.hazelcast.query.impl.QueryableEntry;
import com.hazelcast.query.impl.predicates.Visitor;
import com.hazelcast.util.IterationType;
import com.hazelcast.util.SortingUtil;
import java.io.IOException;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

@BinaryInterface
public class PagingPredicate<K, V> extends Object implements IndexAwarePredicate<K, V>, VisitablePredicate, IdentifiedDataSerializable {
  private static final Map.Entry<Integer, Map.Entry> NULL_ANCHOR = new AbstractMap.SimpleImmutableEntry(Integer.valueOf(-1), null);
  
  private List<Map.Entry<Integer, Map.Entry<K, V>>> anchorList;
  
  private Predicate<K, V> predicate;
  
  private Comparator<Map.Entry<K, V>> comparator;
  
  private int pageSize;
  
  private int page;
  
  private IterationType iterationType;
  
  public PagingPredicate() {}
  
  public PagingPredicate(int pageSize) {
    if (pageSize <= 0)
      throw new IllegalArgumentException("pageSize should be greater than 0!"); 
    this.pageSize = pageSize;
    this.anchorList = new ArrayList();
  }
  
  public PagingPredicate(Predicate predicate, int pageSize) {
    this(pageSize);
    setInnerPredicate(predicate);
  }
  
  public PagingPredicate(Comparator<Map.Entry<K, V>> comparator, int pageSize) {
    this(pageSize);
    this.comparator = comparator;
  }
  
  public PagingPredicate(Predicate<K, V> predicate, Comparator<Map.Entry<K, V>> comparator, int pageSize) {
    this(pageSize);
    setInnerPredicate(predicate);
    this.comparator = comparator;
  }
  
  private PagingPredicate(PagingPredicate originalPagingPredicate, Predicate predicateReplacement) {
    this.anchorList = originalPagingPredicate.anchorList;
    this.comparator = originalPagingPredicate.comparator;
    this.pageSize = originalPagingPredicate.pageSize;
    this.page = originalPagingPredicate.page;
    this.iterationType = originalPagingPredicate.iterationType;
    setInnerPredicate(predicateReplacement);
  }
  
  public Predicate accept(Visitor visitor, Indexes indexes) {
    if (this.predicate instanceof VisitablePredicate) {
      Predicate transformed = ((VisitablePredicate)this.predicate).accept(visitor, indexes);
      return (transformed == this.predicate) ? this : new PagingPredicate(this, transformed);
    } 
    return this;
  }
  
  private void setInnerPredicate(Predicate<K, V> predicate) {
    if (predicate instanceof PagingPredicate)
      throw new IllegalArgumentException("Nested PagingPredicate is not supported!"); 
    this.predicate = predicate;
  }
  
  public Set<QueryableEntry<K, V>> filter(QueryContext queryContext) {
    if (!(this.predicate instanceof IndexAwarePredicate))
      return null; 
    Set<QueryableEntry<K, V>> set = ((IndexAwarePredicate)this.predicate).filter(queryContext);
    if (set == null || set.isEmpty())
      return set; 
    List<QueryableEntry<K, V>> resultList = new ArrayList<QueryableEntry<K, V>>();
    Map.Entry<Integer, Map.Entry> nearestAnchorEntry = getNearestAnchorEntry();
    for (QueryableEntry<K, V> queryableEntry : set) {
      if (SortingUtil.compareAnchor(this, queryableEntry, nearestAnchorEntry))
        resultList.add(queryableEntry); 
    } 
    List<QueryableEntry<K, V>> sortedSubList = SortingUtil.getSortedSubList(resultList, this, nearestAnchorEntry);
    return new LinkedHashSet(sortedSubList);
  }
  
  public boolean isIndexed(QueryContext queryContext) {
    if (this.predicate instanceof IndexAwarePredicate)
      return ((IndexAwarePredicate)this.predicate).isIndexed(queryContext); 
    return false;
  }
  
  public boolean apply(Map.Entry mapEntry) {
    if (this.predicate != null)
      return this.predicate.apply(mapEntry); 
    return true;
  }
  
  public void reset() {
    this.iterationType = null;
    this.anchorList.clear();
    this.page = 0;
  }
  
  public void nextPage() { this.page++; }
  
  public void previousPage() {
    if (this.page != 0)
      this.page--; 
  }
  
  public IterationType getIterationType() { return this.iterationType; }
  
  public void setIterationType(IterationType iterationType) { this.iterationType = iterationType; }
  
  public int getPage() { return this.page; }
  
  public void setPage(int page) { this.page = page; }
  
  public int getPageSize() { return this.pageSize; }
  
  public Predicate<K, V> getPredicate() { return this.predicate; }
  
  public Comparator<Map.Entry<K, V>> getComparator() { return this.comparator; }
  
  public Map.Entry<K, V> getAnchor() {
    Map.Entry<Integer, Map.Entry<K, V>> anchorEntry = (Map.Entry)this.anchorList.get(this.page);
    return (anchorEntry == null) ? null : (Map.Entry)anchorEntry.getValue();
  }
  
  void setAnchor(int page, Map.Entry anchor) {
    AbstractMap.SimpleImmutableEntry anchorEntry = new AbstractMap.SimpleImmutableEntry(Integer.valueOf(page), anchor);
    int anchorCount = this.anchorList.size();
    if (page < anchorCount) {
      this.anchorList.set(page, anchorEntry);
    } else if (page == anchorCount) {
      this.anchorList.add(anchorEntry);
    } else {
      throw new IllegalArgumentException("Anchor index is not correct, expected: " + page + " found: " + anchorCount);
    } 
  }
  
  Map.Entry<Integer, Map.Entry> getNearestAnchorEntry() {
    Map.Entry anchoredEntry;
    int anchorCount = this.anchorList.size();
    if (this.page == 0 || anchorCount == 0)
      return NULL_ANCHOR; 
    if (this.page < anchorCount) {
      anchoredEntry = (Map.Entry)this.anchorList.get(this.page - 1);
    } else {
      anchoredEntry = (Map.Entry)this.anchorList.get(anchorCount - 1);
    } 
    return anchoredEntry;
  }
  
  public void writeData(ObjectDataOutput out) throws IOException {
    out.writeObject(this.predicate);
    out.writeObject(this.comparator);
    out.writeInt(this.page);
    out.writeInt(this.pageSize);
    out.writeUTF(this.iterationType.name());
    out.writeInt(this.anchorList.size());
    for (Map.Entry<Integer, Map.Entry<K, V>> anchor : this.anchorList) {
      out.writeInt(((Integer)anchor.getKey()).intValue());
      Map.Entry<K, V> anchorEntry = (Map.Entry)anchor.getValue();
      out.writeObject(anchorEntry.getKey());
      out.writeObject(anchorEntry.getValue());
    } 
  }
  
  public void readData(ObjectDataInput in) throws IOException {
    this.predicate = (Predicate)in.readObject();
    this.comparator = (Comparator)in.readObject();
    this.page = in.readInt();
    this.pageSize = in.readInt();
    this.iterationType = IterationType.valueOf(in.readUTF());
    int size = in.readInt();
    this.anchorList = new ArrayList(size);
    for (int i = 0; i < size; i++) {
      int anchorPage = in.readInt();
      Object anchorKey = in.readObject();
      Object anchorValue = in.readObject();
      Map.Entry anchorEntry = new AbstractMap.SimpleImmutableEntry(anchorKey, anchorValue);
      this.anchorList.add(new AbstractMap.SimpleImmutableEntry(Integer.valueOf(anchorPage), anchorEntry));
    } 
  }
  
  public int getFactoryId() { return -32; }
  
  public int getId() { return 15; }
}
