package com.hazelcast.concurrent.lock.operations;

import com.hazelcast.concurrent.lock.ConditionKey;
import com.hazelcast.concurrent.lock.LockStoreImpl;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.BackupAwareOperation;
import com.hazelcast.spi.BlockingOperation;
import com.hazelcast.spi.ObjectNamespace;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.WaitNotifyKey;
import com.hazelcast.spi.impl.MutatingOperation;
import java.io.IOException;

public class AwaitOperation extends AbstractLockOperation implements BlockingOperation, BackupAwareOperation, MutatingOperation {
  private String conditionId;
  
  private boolean expired;
  
  public AwaitOperation() {}
  
  public AwaitOperation(ObjectNamespace namespace, Data key, long threadId, long timeout, String conditionId) {
    super(namespace, key, threadId, timeout);
    this.conditionId = conditionId;
  }
  
  public AwaitOperation(ObjectNamespace namespace, Data key, long threadId, long timeout, String conditionId, long referenceId) {
    super(namespace, key, threadId, timeout);
    this.conditionId = conditionId;
    setReferenceCallId(referenceId);
  }
  
  public void run() {
    LockStoreImpl lockStore = getLockStore();
    if (!lockStore.lock(this.key, getCallerUuid(), this.threadId, getReferenceCallId(), this.leaseTime))
      throw new IllegalMonitorStateException("Current thread is not owner of the lock! -> " + lockStore
          .getOwnerInfo(this.key)); 
    if (this.expired) {
      this.response = Boolean.valueOf(false);
    } else {
      lockStore.removeSignalKey(getWaitKey());
      lockStore.removeAwait(this.key, this.conditionId, getCallerUuid(), this.threadId);
      this.response = Boolean.valueOf(true);
    } 
  }
  
  void runExpired() {
    LockStoreImpl lockStore = getLockStore();
    boolean locked = lockStore.lock(this.key, getCallerUuid(), this.threadId, getReferenceCallId(), this.leaseTime);
    assert locked : "Expired await operation should have acquired the lock!";
    sendResponse(Boolean.valueOf(false));
  }
  
  public ConditionKey getWaitKey() { return new ConditionKey(this.namespace.getObjectName(), this.key, this.conditionId, getCallerUuid(), this.threadId); }
  
  public boolean shouldWait() {
    LockStoreImpl lockStore = getLockStore();
    boolean canAcquireLock = lockStore.canAcquireLock(this.key, getCallerUuid(), this.threadId);
    if (!canAcquireLock)
      return true; 
    return !lockStore.hasSignalKey(getWaitKey());
  }
  
  public boolean shouldBackup() { return true; }
  
  public Operation getBackupOperation() { return new AwaitBackupOperation(this.namespace, this.key, this.threadId, this.conditionId, getCallerUuid()); }
  
  public void onWaitExpire() {
    this.expired = true;
    LockStoreImpl lockStore = getLockStore();
    lockStore.removeSignalKey(getWaitKey());
    lockStore.removeAwait(this.key, this.conditionId, getCallerUuid(), this.threadId);
    boolean locked = lockStore.lock(this.key, getCallerUuid(), this.threadId, getReferenceCallId(), this.leaseTime);
    if (locked) {
      sendResponse(Boolean.valueOf(false));
    } else {
      lockStore.registerExpiredAwaitOp(this);
    } 
  }
  
  public int getId() { return 4; }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException {
    super.writeInternal(out);
    out.writeUTF(this.conditionId);
  }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    super.readInternal(in);
    this.conditionId = in.readUTF();
  }
}
