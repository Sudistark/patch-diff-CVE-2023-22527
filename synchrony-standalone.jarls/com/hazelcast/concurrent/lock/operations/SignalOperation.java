package com.hazelcast.concurrent.lock.operations;

import com.hazelcast.concurrent.lock.LockStoreImpl;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.BackupAwareOperation;
import com.hazelcast.spi.ObjectNamespace;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.impl.MutatingOperation;

public class SignalOperation extends BaseSignalOperation implements BackupAwareOperation, MutatingOperation {
  public SignalOperation() {}
  
  public SignalOperation(ObjectNamespace namespace, Data key, long threadId, String conditionId, boolean all) { super(namespace, key, threadId, conditionId, all); }
  
  public void beforeRun() {
    LockStoreImpl lockStore = getLockStore();
    boolean isLockOwner = lockStore.isLockedBy(this.key, getCallerUuid(), this.threadId);
    ensureLockOwner(lockStore, isLockOwner);
  }
  
  private void ensureLockOwner(LockStoreImpl lockStore, boolean isLockOwner) {
    if (!isLockOwner) {
      String ownerInfo = lockStore.getOwnerInfo(this.key);
      throw new IllegalMonitorStateException("Current thread is not owner of the lock! -> " + ownerInfo);
    } 
  }
  
  public boolean shouldBackup() { return (this.awaitCount > 0); }
  
  public Operation getBackupOperation() { return new SignalBackupOperation(this.namespace, this.key, this.threadId, this.conditionId, this.all); }
  
  public int getId() { return 14; }
}
