package com.hazelcast.concurrent.lock;

import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.ObjectNamespace;
import com.hazelcast.spi.ServiceNamespace;
import com.hazelcast.spi.TaskScheduler;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.scheduler.EntryTaskScheduler;
import com.hazelcast.util.scheduler.EntryTaskSchedulerFactory;
import com.hazelcast.util.scheduler.ScheduleType;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public final class LockStoreContainer {
  private final LockServiceImpl lockService;
  
  private final int partitionId;
  
  private final ConcurrentMap<ObjectNamespace, LockStoreImpl> lockStores;
  
  private final ConstructorFunction<ObjectNamespace, LockStoreImpl> lockStoreConstructor;
  
  public LockStoreContainer(LockServiceImpl lockService, int partitionId) {
    this.lockStores = new ConcurrentHashMap();
    this.lockStoreConstructor = new Object(this);
    this.lockService = lockService;
    this.partitionId = partitionId;
  }
  
  void clearLockStore(ObjectNamespace namespace) {
    LockStoreImpl lockStore = (LockStoreImpl)this.lockStores.remove(namespace);
    if (lockStore != null)
      lockStore.clear(); 
  }
  
  LockStoreImpl getOrCreateLockStore(ObjectNamespace namespace) { return (LockStoreImpl)ConcurrencyUtil.getOrPutIfAbsent(this.lockStores, namespace, this.lockStoreConstructor); }
  
  public LockStoreImpl getLockStore(ObjectNamespace namespace) { return (LockStoreImpl)this.lockStores.get(namespace); }
  
  public Collection<LockStoreImpl> getLockStores() { return Collections.unmodifiableCollection(this.lockStores.values()); }
  
  void clear() {
    for (LockStoreImpl lockStore : this.lockStores.values())
      lockStore.clear(); 
    this.lockStores.clear();
  }
  
  int getPartitionId() { return this.partitionId; }
  
  public void put(LockStoreImpl ls) {
    ls.setLockService(this.lockService);
    ls.setEntryTaskScheduler(createScheduler(ls.getNamespace()));
    this.lockStores.put(ls.getNamespace(), ls);
  }
  
  private EntryTaskScheduler<Data, Integer> createScheduler(ObjectNamespace namespace) {
    NodeEngine nodeEngine = this.lockService.getNodeEngine();
    LockEvictionProcessor entryProcessor = new LockEvictionProcessor(nodeEngine, namespace);
    TaskScheduler globalScheduler = nodeEngine.getExecutionService().getGlobalTaskScheduler();
    return EntryTaskSchedulerFactory.newScheduler(globalScheduler, entryProcessor, ScheduleType.FOR_EACH);
  }
  
  public Collection<ServiceNamespace> getAllNamespaces(int replicaIndex) {
    Set<ServiceNamespace> namespaces = new HashSet<ServiceNamespace>();
    for (LockStoreImpl lockStore : this.lockStores.values()) {
      if (lockStore.getTotalBackupCount() < replicaIndex)
        continue; 
      namespaces.add(lockStore.getNamespace());
    } 
    return namespaces;
  }
}
