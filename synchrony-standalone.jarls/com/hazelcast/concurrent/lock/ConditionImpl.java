package com.hazelcast.concurrent.lock;

import com.hazelcast.concurrent.lock.operations.AwaitOperation;
import com.hazelcast.concurrent.lock.operations.BeforeAwaitOperation;
import com.hazelcast.concurrent.lock.operations.SignalOperation;
import com.hazelcast.core.ICondition;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.ObjectNamespace;
import com.hazelcast.spi.Operation;
import com.hazelcast.util.Clock;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.ThreadUtil;
import java.util.Date;
import java.util.concurrent.TimeUnit;

final class ConditionImpl implements ICondition {
  private final LockProxy lockProxy;
  
  private final int partitionId;
  
  private final ObjectNamespace namespace;
  
  private final String conditionId;
  
  public ConditionImpl(LockProxy lockProxy, String id) {
    this.lockProxy = lockProxy;
    this.partitionId = lockProxy.getPartitionId();
    this.namespace = lockProxy.getNamespace();
    this.conditionId = id;
  }
  
  public void await() throws InterruptedException { await(Float.MAX_VALUE, TimeUnit.MILLISECONDS); }
  
  public void awaitUninterruptibly() throws InterruptedException {
    try {
      await(Float.MAX_VALUE, TimeUnit.MILLISECONDS);
    } catch (InterruptedException e) {
      ExceptionUtil.sneakyThrow(e);
    } 
  }
  
  public long awaitNanos(long nanosTimeout) throws InterruptedException {
    long start = System.nanoTime();
    await(nanosTimeout, TimeUnit.NANOSECONDS);
    long end = System.nanoTime();
    return nanosTimeout - end - start;
  }
  
  public boolean await(long time, TimeUnit unit) throws InterruptedException {
    long threadId = ThreadUtil.getThreadId();
    beforeAwait(threadId);
    return doAwait(time, unit, threadId);
  }
  
  private boolean doAwait(long time, TimeUnit unit, long threadId) throws InterruptedException {
    try {
      long timeout = unit.toMillis(time);
      Data key = this.lockProxy.getKeyData();
      AwaitOperation op = new AwaitOperation(this.namespace, key, threadId, timeout, this.conditionId);
      InternalCompletableFuture internalCompletableFuture = invoke(op);
      return Boolean.TRUE.equals(internalCompletableFuture.get());
    } catch (Throwable t) {
      throw ExceptionUtil.rethrowAllowInterrupted(t);
    } 
  }
  
  private void beforeAwait(long threadId) {
    Data key = this.lockProxy.getKeyData();
    BeforeAwaitOperation op = new BeforeAwaitOperation(this.namespace, key, threadId, this.conditionId);
    InternalCompletableFuture f = invoke(op);
    f.join();
  }
  
  private InternalCompletableFuture invoke(Operation op) {
    NodeEngine nodeEngine = this.lockProxy.getNodeEngine();
    return nodeEngine.getOperationService().invokeOnPartition("hz:impl:lockService", op, this.partitionId);
  }
  
  public boolean awaitUntil(Date deadline) throws InterruptedException {
    long until = deadline.getTime();
    long durationMs = until - Clock.currentTimeMillis();
    if (durationMs <= 0L)
      return false; 
    return await(durationMs, TimeUnit.MILLISECONDS);
  }
  
  public void signal() throws InterruptedException { signal(false); }
  
  private void signal(boolean all) {
    long threadId = ThreadUtil.getThreadId();
    Data key = this.lockProxy.getKeyData();
    SignalOperation op = new SignalOperation(this.namespace, key, threadId, this.conditionId, all);
    InternalCompletableFuture f = invoke(op);
    f.join();
  }
  
  public void signalAll() throws InterruptedException { signal(true); }
}
