package com.hazelcast.concurrent.lock;

import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.ObjectNamespace;
import java.util.Collections;
import java.util.Set;

public final class LockStoreProxy implements LockStore {
  static final String NOT_LOCKED = "<not-locked>";
  
  private final LockStoreContainer container;
  
  private final ObjectNamespace namespace;
  
  public LockStoreProxy(LockStoreContainer container, ObjectNamespace namespace) {
    this.container = container;
    this.namespace = namespace;
  }
  
  public boolean lock(Data key, String caller, long threadId, long referenceId, long leaseTime) {
    LockStore lockStore = getOrCreateLockStore();
    return (lockStore != null && lockStore.lock(key, caller, threadId, referenceId, leaseTime));
  }
  
  public boolean localLock(Data key, String caller, long threadId, long referenceId, long leaseTime) {
    LockStore lockStore = getOrCreateLockStore();
    return (lockStore != null && lockStore.localLock(key, caller, threadId, referenceId, leaseTime));
  }
  
  public boolean txnLock(Data key, String caller, long threadId, long referenceId, long leaseTime, boolean blockReads) {
    LockStore lockStore = getOrCreateLockStore();
    return (lockStore != null && lockStore.txnLock(key, caller, threadId, referenceId, leaseTime, blockReads));
  }
  
  public boolean extendLeaseTime(Data key, String caller, long threadId, long leaseTime) {
    LockStore lockStore = getLockStoreOrNull();
    return (lockStore != null && lockStore.extendLeaseTime(key, caller, threadId, leaseTime));
  }
  
  public boolean unlock(Data key, String caller, long threadId, long referenceId) {
    LockStore lockStore = getLockStoreOrNull();
    return (lockStore != null && lockStore.unlock(key, caller, threadId, referenceId));
  }
  
  public boolean isLocked(Data key) {
    LockStore lockStore = getLockStoreOrNull();
    return (lockStore != null && lockStore.isLocked(key));
  }
  
  public boolean isLockedBy(Data key, String caller, long threadId) {
    LockStore lockStore = getLockStoreOrNull();
    return (lockStore != null && lockStore.isLockedBy(key, caller, threadId));
  }
  
  public int getLockCount(Data key) {
    LockStore lockStore = getLockStoreOrNull();
    if (lockStore == null)
      return 0; 
    return lockStore.getLockCount(key);
  }
  
  public int getLockedEntryCount() {
    LockStore lockStore = getLockStoreOrNull();
    if (lockStore == null)
      return 0; 
    return lockStore.getLockedEntryCount();
  }
  
  public long getRemainingLeaseTime(Data key) {
    LockStore lockStore = getLockStoreOrNull();
    if (lockStore == null)
      return 0L; 
    return lockStore.getRemainingLeaseTime(key);
  }
  
  public boolean canAcquireLock(Data key, String caller, long threadId) {
    LockStore lockStore = getLockStoreOrNull();
    return (lockStore == null || lockStore.canAcquireLock(key, caller, threadId));
  }
  
  public boolean shouldBlockReads(Data key) {
    LockStore lockStore = getLockStoreOrNull();
    return (lockStore != null && lockStore.shouldBlockReads(key));
  }
  
  public Set<Data> getLockedKeys() {
    LockStore lockStore = getLockStoreOrNull();
    if (lockStore == null)
      return Collections.emptySet(); 
    return lockStore.getLockedKeys();
  }
  
  public boolean forceUnlock(Data key) {
    LockStore lockStore = getLockStoreOrNull();
    return (lockStore != null && lockStore.forceUnlock(key));
  }
  
  public String getOwnerInfo(Data dataKey) {
    LockStore lockStore = getLockStoreOrNull();
    if (lockStore == null)
      return "<not-locked>"; 
    return lockStore.getOwnerInfo(dataKey);
  }
  
  private LockStore getOrCreateLockStore() { return this.container.getOrCreateLockStore(this.namespace); }
  
  private LockStore getLockStoreOrNull() { return this.container.getLockStore(this.namespace); }
}
