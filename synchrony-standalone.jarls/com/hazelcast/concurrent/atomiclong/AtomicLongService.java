package com.hazelcast.concurrent.atomiclong;

import com.hazelcast.concurrent.atomiclong.operations.AtomicLongReplicationOperation;
import com.hazelcast.config.AtomicLongConfig;
import com.hazelcast.core.DistributedObject;
import com.hazelcast.internal.config.ConfigValidator;
import com.hazelcast.partition.strategy.StringPartitioningStrategy;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.MigrationAwareService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.PartitionMigrationEvent;
import com.hazelcast.spi.PartitionReplicationEvent;
import com.hazelcast.spi.QuorumAwareService;
import com.hazelcast.spi.RemoteService;
import com.hazelcast.spi.SplitBrainHandlerService;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.spi.partition.MigrationEndpoint;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.ContextMutexFactory;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class AtomicLongService implements ManagedService, RemoteService, MigrationAwareService, QuorumAwareService, SplitBrainHandlerService {
  public static final String SERVICE_NAME = "hz:impl:atomicLongService";
  
  private static final Object NULL_OBJECT = new Object();
  
  private final ConcurrentMap<String, AtomicLongContainer> containers = new ConcurrentHashMap();
  
  private final ConstructorFunction<String, AtomicLongContainer> atomicLongConstructorFunction = new Object(this);
  
  private final ConcurrentMap<String, Object> quorumConfigCache = new ConcurrentHashMap();
  
  private final ContextMutexFactory quorumConfigCacheMutexFactory = new ContextMutexFactory();
  
  private final ConstructorFunction<String, Object> quorumConfigConstructor = new Object(this);
  
  private NodeEngine nodeEngine;
  
  public AtomicLongContainer getLongContainer(String name) { return (AtomicLongContainer)ConcurrencyUtil.getOrPutIfAbsent(this.containers, name, this.atomicLongConstructorFunction); }
  
  public boolean containsAtomicLong(String name) { return this.containers.containsKey(name); }
  
  public void init(NodeEngine nodeEngine, Properties properties) { this.nodeEngine = nodeEngine; }
  
  public void reset() { this.containers.clear(); }
  
  public void shutdown(boolean terminate) { reset(); }
  
  public AtomicLongProxy createDistributedObject(String name) {
    AtomicLongConfig atomicLongConfig = this.nodeEngine.getConfig().findAtomicLongConfig(name);
    ConfigValidator.checkBasicConfig(atomicLongConfig, this.nodeEngine.getSplitBrainMergePolicyProvider());
    return new AtomicLongProxy(name, this.nodeEngine, this);
  }
  
  public void destroyDistributedObject(String name) {
    this.containers.remove(name);
    this.quorumConfigCache.remove(name);
  }
  
  public void beforeMigration(PartitionMigrationEvent partitionMigrationEvent) {}
  
  public Operation prepareReplicationOperation(PartitionReplicationEvent event) {
    if (event.getReplicaIndex() > 1)
      return null; 
    Map<String, Long> data = new HashMap<String, Long>();
    int partitionId = event.getPartitionId();
    for (Map.Entry<String, AtomicLongContainer> containerEntry : this.containers.entrySet()) {
      String name = (String)containerEntry.getKey();
      if (partitionId == getPartitionId(name)) {
        AtomicLongContainer container = (AtomicLongContainer)containerEntry.getValue();
        data.put(name, Long.valueOf(container.get()));
      } 
    } 
    return data.isEmpty() ? null : new AtomicLongReplicationOperation(data);
  }
  
  private int getPartitionId(String name) {
    IPartitionService partitionService = this.nodeEngine.getPartitionService();
    String partitionKey = StringPartitioningStrategy.getPartitionKey(name);
    return partitionService.getPartitionId(partitionKey);
  }
  
  public void commitMigration(PartitionMigrationEvent event) {
    if (event.getMigrationEndpoint() == MigrationEndpoint.SOURCE) {
      int thresholdReplicaIndex = event.getNewReplicaIndex();
      if (thresholdReplicaIndex == -1 || thresholdReplicaIndex > 1)
        clearPartitionReplica(event.getPartitionId()); 
    } 
  }
  
  public void rollbackMigration(PartitionMigrationEvent event) {
    if (event.getMigrationEndpoint() == MigrationEndpoint.DESTINATION) {
      int thresholdReplicaIndex = event.getCurrentReplicaIndex();
      if (thresholdReplicaIndex == -1 || thresholdReplicaIndex > 1)
        clearPartitionReplica(event.getPartitionId()); 
    } 
  }
  
  private void clearPartitionReplica(int partitionId) {
    Iterator<String> iterator = this.containers.keySet().iterator();
    while (iterator.hasNext()) {
      String name = (String)iterator.next();
      if (getPartitionId(name) == partitionId)
        iterator.remove(); 
    } 
  }
  
  public String getQuorumName(String name) {
    Object quorumName = ConcurrencyUtil.getOrPutSynchronized(this.quorumConfigCache, name, this.quorumConfigCacheMutexFactory, this.quorumConfigConstructor);
    return (quorumName == NULL_OBJECT) ? null : (String)quorumName;
  }
  
  public Runnable prepareMergeRunnable() {
    AtomicLongContainerCollector collector = new AtomicLongContainerCollector(this.nodeEngine, this.containers);
    collector.run();
    return new Merger(this, collector);
  }
}
