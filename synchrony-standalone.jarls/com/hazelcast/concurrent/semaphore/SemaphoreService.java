package com.hazelcast.concurrent.semaphore;

import com.hazelcast.concurrent.semaphore.operations.SemaphoreDetachMemberOperation;
import com.hazelcast.concurrent.semaphore.operations.SemaphoreReplicationOperation;
import com.hazelcast.core.DistributedObject;
import com.hazelcast.spi.ClientAwareService;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.MemberAttributeServiceEvent;
import com.hazelcast.spi.MembershipAwareService;
import com.hazelcast.spi.MembershipServiceEvent;
import com.hazelcast.spi.MigrationAwareService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.OperationService;
import com.hazelcast.spi.PartitionMigrationEvent;
import com.hazelcast.spi.PartitionReplicationEvent;
import com.hazelcast.spi.QuorumAwareService;
import com.hazelcast.spi.RemoteService;
import com.hazelcast.spi.partition.MigrationEndpoint;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.ContextMutexFactory;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class SemaphoreService implements ManagedService, MigrationAwareService, MembershipAwareService, RemoteService, ClientAwareService, QuorumAwareService {
  public static final String SERVICE_NAME = "hz:impl:semaphoreService";
  
  private static final Object NULL_OBJECT = new Object();
  
  private final ConcurrentMap<String, SemaphoreContainer> containers;
  
  private final ConcurrentMap<String, Object> quorumConfigCache;
  
  private final ContextMutexFactory quorumConfigCacheMutexFactory;
  
  private final ConstructorFunction<String, Object> quorumConfigConstructor;
  
  private final ConstructorFunction<String, SemaphoreContainer> containerConstructor;
  
  private final NodeEngine nodeEngine;
  
  public SemaphoreService(NodeEngine nodeEngine) {
    this.containers = new ConcurrentHashMap();
    this.quorumConfigCache = new ConcurrentHashMap();
    this.quorumConfigCacheMutexFactory = new ContextMutexFactory();
    this.quorumConfigConstructor = new Object(this);
    this.containerConstructor = new Object(this);
    this.nodeEngine = nodeEngine;
  }
  
  public SemaphoreContainer getSemaphoreContainer(String name) { return (SemaphoreContainer)ConcurrencyUtil.getOrPutIfAbsent(this.containers, name, this.containerConstructor); }
  
  public boolean containsSemaphore(String name) { return this.containers.containsKey(name); }
  
  public void init(NodeEngine nodeEngine, Properties properties) {}
  
  public void reset() { this.containers.clear(); }
  
  public void shutdown(boolean terminate) { this.containers.clear(); }
  
  public void memberAdded(MembershipServiceEvent event) {}
  
  public void memberRemoved(MembershipServiceEvent event) { onOwnerDisconnected(event.getMember().getUuid()); }
  
  public void memberAttributeChanged(MemberAttributeServiceEvent event) {}
  
  private void onOwnerDisconnected(String owner) {
    OperationService operationService = this.nodeEngine.getOperationService();
    for (Map.Entry<String, SemaphoreContainer> entry : this.containers.entrySet()) {
      String name = (String)entry.getKey();
      SemaphoreContainer container = (SemaphoreContainer)entry.getValue();
      Operation op = (new SemaphoreDetachMemberOperation(name, owner)).setPartitionId(container.getPartitionId()).setValidateTarget(false).setService(this).setNodeEngine(this.nodeEngine).setServiceName("hz:impl:semaphoreService");
      operationService.invokeOnTarget("hz:impl:semaphoreService", op, this.nodeEngine.getThisAddress());
    } 
  }
  
  public SemaphoreProxy createDistributedObject(String objectId) { return new SemaphoreProxy(objectId, this, this.nodeEngine); }
  
  public void destroyDistributedObject(String objectId) {
    this.containers.remove(objectId);
    this.quorumConfigCache.remove(objectId);
  }
  
  public void beforeMigration(PartitionMigrationEvent partitionMigrationEvent) {}
  
  public Operation prepareReplicationOperation(PartitionReplicationEvent event) {
    Map<String, SemaphoreContainer> migrationData = new HashMap<String, SemaphoreContainer>();
    for (Map.Entry<String, SemaphoreContainer> entry : this.containers.entrySet()) {
      String name = (String)entry.getKey();
      SemaphoreContainer semaphoreContainer = (SemaphoreContainer)entry.getValue();
      if (semaphoreContainer.getPartitionId() == event.getPartitionId() && semaphoreContainer
        .getTotalBackupCount() >= event.getReplicaIndex())
        migrationData.put(name, semaphoreContainer); 
    } 
    if (migrationData.isEmpty())
      return null; 
    return new SemaphoreReplicationOperation(migrationData);
  }
  
  public void insertMigrationData(Map<String, SemaphoreContainer> migrationData) { this.containers.putAll(migrationData); }
  
  public void commitMigration(PartitionMigrationEvent event) {
    if (event.getMigrationEndpoint() == MigrationEndpoint.SOURCE)
      clearSemaphoresHavingLesserBackupCountThan(event.getPartitionId(), event.getNewReplicaIndex()); 
  }
  
  public void rollbackMigration(PartitionMigrationEvent event) {
    if (event.getMigrationEndpoint() == MigrationEndpoint.DESTINATION)
      clearSemaphoresHavingLesserBackupCountThan(event.getPartitionId(), event.getCurrentReplicaIndex()); 
  }
  
  private void clearSemaphoresHavingLesserBackupCountThan(int partitionId, int thresholdReplicaIndex) {
    Iterator<SemaphoreContainer> it = this.containers.values().iterator();
    while (it.hasNext()) {
      SemaphoreContainer semaphoreContainer = (SemaphoreContainer)it.next();
      if (semaphoreContainer.getPartitionId() != partitionId)
        continue; 
      if (thresholdReplicaIndex < 0 || thresholdReplicaIndex > semaphoreContainer.getTotalBackupCount())
        it.remove(); 
    } 
  }
  
  public void clientDisconnected(String clientUuid) { onOwnerDisconnected(clientUuid); }
  
  public String getQuorumName(String name) {
    Object quorumName = ConcurrencyUtil.getOrPutSynchronized(this.quorumConfigCache, name, this.quorumConfigCacheMutexFactory, this.quorumConfigConstructor);
    return (quorumName == NULL_OBJECT) ? null : (String)quorumName;
  }
}
