package com.hazelcast.concurrent.idgen;

import com.hazelcast.core.IAtomicLong;
import com.hazelcast.core.IdGenerator;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.atomic.AtomicLongFieldUpdater;

public class IdGeneratorImpl implements IdGenerator {
  public static final int BLOCK_SIZE = 10000;
  
  private static final AtomicIntegerFieldUpdater<IdGeneratorImpl> RESIDUE = AtomicIntegerFieldUpdater.newUpdater(IdGeneratorImpl.class, "residue");
  
  private static final AtomicLongFieldUpdater<IdGeneratorImpl> LOCAL = AtomicLongFieldUpdater.newUpdater(IdGeneratorImpl.class, "local");
  
  private final IAtomicLong blockGenerator;
  
  public IdGeneratorImpl(IAtomicLong blockGenerator) {
    this.residue = 10000;
    this.local = -1L;
    this.blockGenerator = blockGenerator;
  }
  
  public boolean init(long id) {
    if (id < 0L)
      return false; 
    long step = id / 10000L;
    synchronized (this) {
      boolean init = this.blockGenerator.compareAndSet(0L, step + 1L);
      if (init) {
        LOCAL.set(this, step);
        RESIDUE.set(this, (int)(id % 10000L) + 1);
      } 
      return init;
    } 
  }
  
  public long newId() {
    long block = this.local;
    int value = RESIDUE.getAndIncrement(this);
    if (this.local != block)
      return newId(); 
    if (value < 10000)
      return block * 10000L + value; 
    synchronized (this) {
      value = this.residue;
      if (value >= 10000) {
        LOCAL.set(this, this.blockGenerator.getAndIncrement());
        RESIDUE.set(this, 0);
      } 
    } 
    return newId();
  }
  
  public String getPartitionKey() { return null; }
  
  public String getName() { return null; }
  
  public String getServiceName() { return null; }
  
  public void destroy() {
    synchronized (this) {
      this.blockGenerator.destroy();
      LOCAL.set(this, -1L);
      RESIDUE.set(this, 10000);
    } 
  }
}
