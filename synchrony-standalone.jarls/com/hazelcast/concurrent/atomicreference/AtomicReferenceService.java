package com.hazelcast.concurrent.atomicreference;

import com.hazelcast.concurrent.atomicreference.operations.AtomicReferenceReplicationOperation;
import com.hazelcast.config.AtomicReferenceConfig;
import com.hazelcast.core.DistributedObject;
import com.hazelcast.internal.config.ConfigValidator;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.partition.strategy.StringPartitioningStrategy;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.MigrationAwareService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.PartitionMigrationEvent;
import com.hazelcast.spi.PartitionReplicationEvent;
import com.hazelcast.spi.QuorumAwareService;
import com.hazelcast.spi.RemoteService;
import com.hazelcast.spi.SplitBrainHandlerService;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.spi.partition.MigrationEndpoint;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.ContextMutexFactory;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class AtomicReferenceService implements ManagedService, RemoteService, MigrationAwareService, QuorumAwareService, SplitBrainHandlerService {
  public static final String SERVICE_NAME = "hz:impl:atomicReferenceService";
  
  private static final Object NULL_OBJECT = new Object();
  
  private final ConcurrentMap<String, AtomicReferenceContainer> containers = new ConcurrentHashMap();
  
  private final ConstructorFunction<String, AtomicReferenceContainer> atomicReferenceConstructorFunction = new Object(this);
  
  private final ConcurrentMap<String, Object> quorumConfigCache = new ConcurrentHashMap();
  
  private final ContextMutexFactory quorumConfigCacheMutexFactory = new ContextMutexFactory();
  
  private final ConstructorFunction<String, Object> quorumConfigConstructor = new Object(this);
  
  private NodeEngine nodeEngine;
  
  public AtomicReferenceContainer getReferenceContainer(String name) { return (AtomicReferenceContainer)ConcurrencyUtil.getOrPutIfAbsent(this.containers, name, this.atomicReferenceConstructorFunction); }
  
  public boolean containsReferenceContainer(String name) { return this.containers.containsKey(name); }
  
  public void init(NodeEngine nodeEngine, Properties properties) { this.nodeEngine = nodeEngine; }
  
  public void reset() { this.containers.clear(); }
  
  public void shutdown(boolean terminate) { reset(); }
  
  public AtomicReferenceProxy createDistributedObject(String name) {
    AtomicReferenceConfig atomicReferenceConfig = this.nodeEngine.getConfig().findAtomicReferenceConfig(name);
    ConfigValidator.checkBasicConfig(atomicReferenceConfig, this.nodeEngine.getSplitBrainMergePolicyProvider());
    return new AtomicReferenceProxy(name, this.nodeEngine, this);
  }
  
  public void destroyDistributedObject(String name) {
    this.containers.remove(name);
    this.quorumConfigCache.remove(name);
  }
  
  public void beforeMigration(PartitionMigrationEvent partitionMigrationEvent) {}
  
  public Operation prepareReplicationOperation(PartitionReplicationEvent event) {
    if (event.getReplicaIndex() > 1)
      return null; 
    Map<String, Data> data = new HashMap<String, Data>();
    int partitionId = event.getPartitionId();
    for (Map.Entry<String, AtomicReferenceContainer> containerEntry : this.containers.entrySet()) {
      String name = (String)containerEntry.getKey();
      if (partitionId == getPartitionId(name)) {
        AtomicReferenceContainer atomicReferenceContainer = (AtomicReferenceContainer)containerEntry.getValue();
        Data value = atomicReferenceContainer.get();
        data.put(name, value);
      } 
    } 
    return data.isEmpty() ? null : new AtomicReferenceReplicationOperation(data);
  }
  
  public void commitMigration(PartitionMigrationEvent event) {
    if (event.getMigrationEndpoint() == MigrationEndpoint.SOURCE) {
      int thresholdReplicaIndex = event.getNewReplicaIndex();
      if (thresholdReplicaIndex == -1 || thresholdReplicaIndex > 1)
        clearPartitionReplica(event.getPartitionId()); 
    } 
  }
  
  public void rollbackMigration(PartitionMigrationEvent event) {
    if (event.getMigrationEndpoint() == MigrationEndpoint.DESTINATION) {
      int thresholdReplicaIndex = event.getCurrentReplicaIndex();
      if (thresholdReplicaIndex == -1 || thresholdReplicaIndex > 1)
        clearPartitionReplica(event.getPartitionId()); 
    } 
  }
  
  private void clearPartitionReplica(int partitionId) {
    Iterator<String> iterator = this.containers.keySet().iterator();
    while (iterator.hasNext()) {
      String name = (String)iterator.next();
      if (getPartitionId(name) == partitionId)
        iterator.remove(); 
    } 
  }
  
  private int getPartitionId(String name) {
    IPartitionService partitionService = this.nodeEngine.getPartitionService();
    String partitionKey = StringPartitioningStrategy.getPartitionKey(name);
    return partitionService.getPartitionId(partitionKey);
  }
  
  public String getQuorumName(String name) {
    Object quorumName = ConcurrencyUtil.getOrPutSynchronized(this.quorumConfigCache, name, this.quorumConfigCacheMutexFactory, this.quorumConfigConstructor);
    return (quorumName == NULL_OBJECT) ? null : (String)quorumName;
  }
  
  public Runnable prepareMergeRunnable() {
    AtomicReferenceContainerCollector collector = new AtomicReferenceContainerCollector(this.nodeEngine, this.containers);
    collector.run();
    return new Merger(this, collector);
  }
}
