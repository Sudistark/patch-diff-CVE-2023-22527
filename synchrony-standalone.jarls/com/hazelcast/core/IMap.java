package com.hazelcast.core;

import com.hazelcast.aggregation.Aggregator;
import com.hazelcast.map.EntryProcessor;
import com.hazelcast.map.MapInterceptor;
import com.hazelcast.map.QueryCache;
import com.hazelcast.map.impl.LegacyAsyncMap;
import com.hazelcast.map.listener.MapListener;
import com.hazelcast.map.listener.MapPartitionLostListener;
import com.hazelcast.mapreduce.JobTracker;
import com.hazelcast.mapreduce.aggregation.Aggregation;
import com.hazelcast.mapreduce.aggregation.Supplier;
import com.hazelcast.monitor.LocalMapStats;
import com.hazelcast.projection.Projection;
import com.hazelcast.query.Predicate;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public interface IMap<K, V> extends ConcurrentMap<K, V>, LegacyAsyncMap<K, V> {
  void putAll(Map<? extends K, ? extends V> paramMap);
  
  boolean containsKey(Object paramObject);
  
  boolean containsValue(Object paramObject);
  
  V get(Object paramObject);
  
  V put(K paramK, V paramV);
  
  V remove(Object paramObject);
  
  boolean remove(Object paramObject1, Object paramObject2);
  
  void removeAll(Predicate<K, V> paramPredicate);
  
  void delete(Object paramObject);
  
  void flush();
  
  Map<K, V> getAll(Set<K> paramSet);
  
  void loadAll(boolean paramBoolean);
  
  void loadAll(Set<K> paramSet, boolean paramBoolean);
  
  void clear();
  
  ICompletableFuture<V> getAsync(K paramK);
  
  ICompletableFuture<V> putAsync(K paramK, V paramV);
  
  ICompletableFuture<V> putAsync(K paramK, V paramV, long paramLong, TimeUnit paramTimeUnit);
  
  ICompletableFuture<V> putAsync(K paramK, V paramV, long paramLong1, TimeUnit paramTimeUnit1, long paramLong2, TimeUnit paramTimeUnit2);
  
  ICompletableFuture<Void> setAsync(K paramK, V paramV);
  
  ICompletableFuture<Void> setAsync(K paramK, V paramV, long paramLong, TimeUnit paramTimeUnit);
  
  ICompletableFuture<Void> setAsync(K paramK, V paramV, long paramLong1, TimeUnit paramTimeUnit1, long paramLong2, TimeUnit paramTimeUnit2);
  
  ICompletableFuture<V> removeAsync(K paramK);
  
  boolean tryRemove(K paramK, long paramLong, TimeUnit paramTimeUnit);
  
  boolean tryPut(K paramK, V paramV, long paramLong, TimeUnit paramTimeUnit);
  
  V put(K paramK, V paramV, long paramLong, TimeUnit paramTimeUnit);
  
  V put(K paramK, V paramV, long paramLong1, TimeUnit paramTimeUnit1, long paramLong2, TimeUnit paramTimeUnit2);
  
  void putTransient(K paramK, V paramV, long paramLong, TimeUnit paramTimeUnit);
  
  void putTransient(K paramK, V paramV, long paramLong1, TimeUnit paramTimeUnit1, long paramLong2, TimeUnit paramTimeUnit2);
  
  V putIfAbsent(K paramK, V paramV);
  
  V putIfAbsent(K paramK, V paramV, long paramLong, TimeUnit paramTimeUnit);
  
  V putIfAbsent(K paramK, V paramV, long paramLong1, TimeUnit paramTimeUnit1, long paramLong2, TimeUnit paramTimeUnit2);
  
  boolean replace(K paramK, V paramV1, V paramV2);
  
  V replace(K paramK, V paramV);
  
  void set(K paramK, V paramV);
  
  void set(K paramK, V paramV, long paramLong, TimeUnit paramTimeUnit);
  
  void set(K paramK, V paramV, long paramLong1, TimeUnit paramTimeUnit1, long paramLong2, TimeUnit paramTimeUnit2);
  
  void lock(K paramK);
  
  void lock(K paramK, long paramLong, TimeUnit paramTimeUnit);
  
  boolean isLocked(K paramK);
  
  boolean tryLock(K paramK);
  
  boolean tryLock(K paramK, long paramLong, TimeUnit paramTimeUnit);
  
  boolean tryLock(K paramK, long paramLong1, TimeUnit paramTimeUnit1, long paramLong2, TimeUnit paramTimeUnit2) throws InterruptedException;
  
  void unlock(K paramK);
  
  void forceUnlock(K paramK);
  
  String addLocalEntryListener(MapListener paramMapListener);
  
  String addLocalEntryListener(EntryListener paramEntryListener);
  
  String addLocalEntryListener(MapListener paramMapListener, Predicate<K, V> paramPredicate, boolean paramBoolean);
  
  String addLocalEntryListener(EntryListener paramEntryListener, Predicate<K, V> paramPredicate, boolean paramBoolean);
  
  String addLocalEntryListener(MapListener paramMapListener, Predicate<K, V> paramPredicate, K paramK, boolean paramBoolean);
  
  String addLocalEntryListener(EntryListener paramEntryListener, Predicate<K, V> paramPredicate, K paramK, boolean paramBoolean);
  
  String addInterceptor(MapInterceptor paramMapInterceptor);
  
  void removeInterceptor(String paramString);
  
  String addEntryListener(MapListener paramMapListener, boolean paramBoolean);
  
  String addEntryListener(EntryListener paramEntryListener, boolean paramBoolean);
  
  boolean removeEntryListener(String paramString);
  
  String addPartitionLostListener(MapPartitionLostListener paramMapPartitionLostListener);
  
  boolean removePartitionLostListener(String paramString);
  
  String addEntryListener(MapListener paramMapListener, K paramK, boolean paramBoolean);
  
  String addEntryListener(EntryListener paramEntryListener, K paramK, boolean paramBoolean);
  
  String addEntryListener(MapListener paramMapListener, Predicate<K, V> paramPredicate, boolean paramBoolean);
  
  String addEntryListener(EntryListener paramEntryListener, Predicate<K, V> paramPredicate, boolean paramBoolean);
  
  String addEntryListener(MapListener paramMapListener, Predicate<K, V> paramPredicate, K paramK, boolean paramBoolean);
  
  String addEntryListener(EntryListener paramEntryListener, Predicate<K, V> paramPredicate, K paramK, boolean paramBoolean);
  
  EntryView<K, V> getEntryView(K paramK);
  
  boolean evict(K paramK);
  
  void evictAll();
  
  Set<K> keySet();
  
  Collection<V> values();
  
  Set<Map.Entry<K, V>> entrySet();
  
  Set<K> keySet(Predicate paramPredicate);
  
  Set<Map.Entry<K, V>> entrySet(Predicate paramPredicate);
  
  Collection<V> values(Predicate paramPredicate);
  
  Set<K> localKeySet();
  
  Set<K> localKeySet(Predicate paramPredicate);
  
  void addIndex(String paramString, boolean paramBoolean);
  
  LocalMapStats getLocalMapStats();
  
  Object executeOnKey(K paramK, EntryProcessor paramEntryProcessor);
  
  Map<K, Object> executeOnKeys(Set<K> paramSet, EntryProcessor paramEntryProcessor);
  
  void submitToKey(K paramK, EntryProcessor paramEntryProcessor, ExecutionCallback paramExecutionCallback);
  
  ICompletableFuture submitToKey(K paramK, EntryProcessor paramEntryProcessor);
  
  Map<K, Object> executeOnEntries(EntryProcessor paramEntryProcessor);
  
  Map<K, Object> executeOnEntries(EntryProcessor paramEntryProcessor, Predicate paramPredicate);
  
  <R> R aggregate(Aggregator<Map.Entry<K, V>, R> paramAggregator);
  
  <R> R aggregate(Aggregator<Map.Entry<K, V>, R> paramAggregator, Predicate<K, V> paramPredicate);
  
  <R> Collection<R> project(Projection<Map.Entry<K, V>, R> paramProjection);
  
  <R> Collection<R> project(Projection<Map.Entry<K, V>, R> paramProjection, Predicate<K, V> paramPredicate);
  
  @Deprecated
  <SuppliedValue, Result> Result aggregate(Supplier<K, V, SuppliedValue> paramSupplier, Aggregation<K, SuppliedValue, Result> paramAggregation);
  
  @Deprecated
  <SuppliedValue, Result> Result aggregate(Supplier<K, V, SuppliedValue> paramSupplier, Aggregation<K, SuppliedValue, Result> paramAggregation, JobTracker paramJobTracker);
  
  QueryCache<K, V> getQueryCache(String paramString);
  
  QueryCache<K, V> getQueryCache(String paramString, Predicate<K, V> paramPredicate, boolean paramBoolean);
  
  QueryCache<K, V> getQueryCache(String paramString, MapListener paramMapListener, Predicate<K, V> paramPredicate, boolean paramBoolean);
  
  boolean setTtl(K paramK, long paramLong, TimeUnit paramTimeUnit);
}
