package com.hazelcast.util;

import com.hazelcast.internal.memory.impl.UnsafeUtil;
import com.hazelcast.logging.Logger;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.lang.management.ManagementFactory;
import javax.management.MBeanServer;
import javax.management.ObjectName;
import javax.management.openmbean.CompositeDataSupport;

public final class JVMUtil {
  public static final int REFERENCE_COST_IN_BYTES = (is32bitJVM() || isCompressedOops()) ? 4 : 8;
  
  static boolean is32bitJVM() {
    architecture = System.getProperty("sun.arch.data.model");
    return (architecture != null && architecture.equals("32"));
  }
  
  static boolean isCompressedOops() {
    enabled = isHotSpotCompressedOopsOrNull();
    if (enabled != null)
      return enabled.booleanValue(); 
    enabled = isObjectLayoutCompressedOopsOrNull();
    if (enabled != null)
      return enabled.booleanValue(); 
    Logger.getLogger(JVMUtil.class).info("Could not determine memory cost of reference; setting to default of 4 bytes.");
    return true;
  }
  
  @SuppressFBWarnings({"NP_BOOLEAN_RETURN_NULL"})
  static Boolean isHotSpotCompressedOopsOrNull() {
    try {
      server = ManagementFactory.getPlatformMBeanServer();
      ObjectName mbean = new ObjectName("com.sun.management:type=HotSpotDiagnostic");
      Object[] objects = { "UseCompressedOops" };
      String[] strings = { "java.lang.String" };
      String operation = "getVMOption";
      CompositeDataSupport compressedOopsValue = (CompositeDataSupport)server.invoke(mbean, operation, objects, strings);
      return Boolean.valueOf(compressedOopsValue.get("value").toString());
    } catch (Exception e) {
      Logger.getLogger(JVMUtil.class).fine("Failed to read HotSpot specific configuration: " + e.getMessage());
      return null;
    } 
  }
  
  @SuppressFBWarnings({"NP_BOOLEAN_RETURN_NULL"})
  static Boolean isObjectLayoutCompressedOopsOrNull() {
    if (!UnsafeUtil.UNSAFE_AVAILABLE)
      return null; 
    referenceSize = ReferenceSizeEstimator.getReferenceSizeOrNull();
    if (referenceSize == null)
      return null; 
    return Boolean.valueOf((referenceSize.intValue() != UnsafeUtil.UNSAFE.addressSize()));
  }
}
