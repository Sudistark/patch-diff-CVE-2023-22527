package com.hazelcast.util.executor;

import com.hazelcast.spi.NodeEngine;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.RunnableFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLongFieldUpdater;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public final class CachedExecutorServiceDelegate implements ExecutorService, ManagedExecutorService {
  public static final long TIME = 250L;
  
  private static final AtomicLongFieldUpdater<CachedExecutorServiceDelegate> EXECUTED_COUNT = AtomicLongFieldUpdater.newUpdater(CachedExecutorServiceDelegate.class, "executedCount");
  
  private final String name;
  
  private final int maxPoolSize;
  
  private final ExecutorService cachedExecutor;
  
  private final NodeEngine nodeEngine;
  
  private final BlockingQueue<Runnable> taskQ;
  
  private final Lock lock = new ReentrantLock();
  
  private final AtomicBoolean shutdown = new AtomicBoolean(false);
  
  public CachedExecutorServiceDelegate(NodeEngine nodeEngine, String name, ExecutorService cachedExecutor, int maxPoolSize, int queueCapacity) {
    if (maxPoolSize <= 0)
      throw new IllegalArgumentException("Max pool size must be positive!"); 
    if (queueCapacity <= 0)
      throw new IllegalArgumentException("Queue capacity must be positive!"); 
    this.name = name;
    this.maxPoolSize = maxPoolSize;
    this.cachedExecutor = cachedExecutor;
    this.taskQ = new LinkedBlockingQueue(queueCapacity);
    this.nodeEngine = nodeEngine;
  }
  
  public String getName() { return this.name; }
  
  public long getCompletedTaskCount() { return this.executedCount; }
  
  public int getMaximumPoolSize() { return this.maxPoolSize; }
  
  public int getPoolSize() { return this.size; }
  
  public int getQueueSize() { return this.taskQ.size(); }
  
  public int getRemainingQueueCapacity() { return this.taskQ.remainingCapacity(); }
  
  public void execute(Runnable command) {
    if (this.shutdown.get())
      throw new RejectedExecutionException(); 
    if (!this.taskQ.offer(command))
      throw new RejectedExecutionException("Executor[" + this.name + "] is overloaded!"); 
    addNewWorkerIfRequired();
  }
  
  public <T> Future<T> submit(Callable<T> task) {
    CompletableFutureTask completableFutureTask = new CompletableFutureTask(task, getAsyncExecutor());
    execute(completableFutureTask);
    return completableFutureTask;
  }
  
  public <T> Future<T> submit(Runnable task, T result) {
    CompletableFutureTask completableFutureTask = new CompletableFutureTask(task, result, getAsyncExecutor());
    execute(completableFutureTask);
    return completableFutureTask;
  }
  
  public Future<?> submit(Runnable task) { return submit(task, null); }
  
  @SuppressFBWarnings({"VO_VOLATILE_INCREMENT"})
  private void addNewWorkerIfRequired() {
    if (this.size < this.maxPoolSize)
      try {
        this.lock.lockInterruptibly();
        try {
          if (this.size < this.maxPoolSize && getQueueSize() > 0) {
            this.size++;
            this.cachedExecutor.execute(new Worker(this, null));
          } 
        } finally {
          this.lock.unlock();
        } 
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
      }  
  }
  
  public void shutdown() { this.shutdown.set(true); }
  
  public List<Runnable> shutdownNow() {
    if (!this.shutdown.compareAndSet(false, true))
      return Collections.emptyList(); 
    List<Runnable> tasks = new LinkedList<Runnable>();
    this.taskQ.drainTo(tasks);
    for (Runnable task : tasks) {
      if (task instanceof RunnableFuture)
        ((RunnableFuture)task).cancel(false); 
    } 
    return tasks;
  }
  
  public boolean isShutdown() { return this.shutdown.get(); }
  
  public boolean isTerminated() { return (this.shutdown.get() && this.taskQ.isEmpty()); }
  
  public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException { throw new UnsupportedOperationException(); }
  
  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException { throw new UnsupportedOperationException(); }
  
  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException { throw new UnsupportedOperationException(); }
  
  public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException { throw new UnsupportedOperationException(); }
  
  public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException { throw new UnsupportedOperationException(); }
  
  private ExecutorService getAsyncExecutor() { return this.nodeEngine.getExecutionService().getExecutor("hz:async"); }
}
