package com.hazelcast.util.executor;

import com.hazelcast.core.ExecutionCallback;
import com.hazelcast.core.ICompletableFuture;
import com.hazelcast.internal.serialization.InternalSerializationService;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.serialization.SerializationService;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

public class DelegatingFuture<V> extends Object implements InternalCompletableFuture<V> {
  private static final AtomicReferenceFieldUpdater<DelegatingFuture, Object> DESERIALIZED_VALUE = AtomicReferenceFieldUpdater.newUpdater(DelegatingFuture.class, Object.class, "deserializedValue");
  
  private static final Object VOID = new Object();
  
  private final InternalCompletableFuture future;
  
  private final InternalSerializationService serializationService;
  
  private final Object result;
  
  public DelegatingFuture(InternalCompletableFuture future, SerializationService serializationService) { this(future, serializationService, null); }
  
  public DelegatingFuture(InternalCompletableFuture future, SerializationService serializationService, V result) {
    this.deserializedValue = VOID;
    this.future = future;
    this.serializationService = (InternalSerializationService)serializationService;
    this.result = result;
  }
  
  public final V get() throws InterruptedException, ExecutionException { return (V)resolve(this.future.get()); }
  
  public final V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException { return (V)resolve(this.future.get(timeout, unit)); }
  
  private V resolve(Object object) {
    if (this.result != null)
      return (V)this.result; 
    if (this.deserializedValue != VOID)
      return (V)this.deserializedValue; 
    if (object instanceof Data) {
      Data data = (Data)object;
      object = this.serializationService.toObject(data);
      this.serializationService.disposeData(data);
      do {
        Object current = this.deserializedValue;
        if (current != VOID) {
          object = current;
          break;
        } 
      } while (!DESERIALIZED_VALUE.compareAndSet(this, VOID, object));
    } 
    return (V)object;
  }
  
  public boolean cancel(boolean mayInterruptIfRunning) { return this.future.cancel(mayInterruptIfRunning); }
  
  public boolean isCancelled() { return this.future.isCancelled(); }
  
  public final boolean isDone() { return this.future.isDone(); }
  
  public boolean complete(Object value) { return this.future.complete(value); }
  
  protected void setError(Throwable error) { this.future.complete(error); }
  
  protected ICompletableFuture getFuture() { return this.future; }
  
  public V join() throws InterruptedException, ExecutionException { return (V)resolve(this.future.join()); }
  
  public void andThen(ExecutionCallback<V> callback) { this.future.andThen(new DelegatingExecutionCallback(this, callback)); }
  
  public void andThen(ExecutionCallback<V> callback, Executor executor) { this.future.andThen(new DelegatingExecutionCallback(this, callback), executor); }
}
