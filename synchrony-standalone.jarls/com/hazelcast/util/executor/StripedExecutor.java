package com.hazelcast.util.executor;

import com.hazelcast.logging.ILogger;
import com.hazelcast.util.HashUtil;
import com.hazelcast.util.Preconditions;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.atomic.AtomicLong;

public final class StripedExecutor implements Executor {
  public static final AtomicLong THREAD_ID_GENERATOR = new AtomicLong();
  
  private final int size;
  
  private final ILogger logger;
  
  private final Worker[] workers;
  
  private final Random rand;
  
  public StripedExecutor(ILogger logger, String threadNamePrefix, int threadCount, int queueCapacity) { this(logger, threadNamePrefix, threadCount, queueCapacity, false); }
  
  public StripedExecutor(ILogger logger, String threadNamePrefix, int threadCount, int queueCapacity, boolean lazyThreads) {
    this.rand = new Random();
    this.live = true;
    Preconditions.checkPositive(threadCount, "threadCount should be positive but found " + threadCount);
    Preconditions.checkPositive(queueCapacity, "queueCapacity should be positive but found " + queueCapacity);
    this.logger = logger;
    this.size = threadCount;
    this.workers = new Worker[threadCount];
    int perThreadMaxQueueCapacity = (int)Math.ceil(1.0D * queueCapacity / threadCount);
    for (int i = 0; i < threadCount; i++) {
      Worker worker = new Worker(this, threadNamePrefix, perThreadMaxQueueCapacity, null);
      if (!lazyThreads) {
        Worker.access$100(worker).set(true);
        worker.start();
      } 
      this.workers[i] = worker;
    } 
  }
  
  public int getWorkQueueSize() {
    int size = 0;
    for (Worker worker : this.workers)
      size += Worker.access$200(worker).size(); 
    return size;
  }
  
  public long processedCount() {
    long size = 0L;
    for (Worker worker : this.workers)
      size += Worker.access$300(worker).inc(); 
    return size;
  }
  
  public void shutdown() {
    this.live = false;
    for (Worker worker : this.workers)
      Worker.access$400(worker); 
  }
  
  public boolean isLive() { return this.live; }
  
  public void execute(Runnable task) {
    Preconditions.checkNotNull(task, "task can't be null");
    if (!this.live)
      throw new RejectedExecutionException("Executor is terminated!"); 
    Worker worker = getWorker(task);
    Worker.access$500(worker, task);
  }
  
  private Worker getWorker(Runnable task) {
    int key;
    if (task instanceof StripedRunnable) {
      key = ((StripedRunnable)task).getKey();
    } else {
      key = this.rand.nextInt();
    } 
    int index = HashUtil.hashToIndex(key, this.size);
    return this.workers[index];
  }
  
  public List<BlockingQueue<Runnable>> getTaskQueues() {
    List<BlockingQueue<Runnable>> taskQueues = new ArrayList<BlockingQueue<Runnable>>(this.workers.length);
    for (Worker worker : this.workers)
      taskQueues.add(Worker.access$200(worker)); 
    return taskQueues;
  }
  
  Worker[] getWorkers() { return this.workers; }
}
