package com.hazelcast.util.executor;

import com.hazelcast.core.ExecutionCallback;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.ExceptionUtil;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public final class CompletedFuture<V> extends Object implements InternalCompletableFuture<V> {
  private final SerializationService serializationService;
  
  private final Executor userExecutor;
  
  private final Object value;
  
  public CompletedFuture(SerializationService serializationService, Object value, Executor userExecutor) {
    this.serializationService = serializationService;
    this.userExecutor = userExecutor;
    this.value = value;
  }
  
  public V get() throws InterruptedException, ExecutionException {
    Object object = this.value;
    if (object instanceof com.hazelcast.nio.serialization.Data)
      object = this.serializationService.toObject(object); 
    if (object instanceof Throwable) {
      if (object instanceof ExecutionException)
        throw (ExecutionException)object; 
      if (object instanceof InterruptedException)
        throw (InterruptedException)object; 
      throw new ExecutionException((Throwable)object);
    } 
    return (V)object;
  }
  
  public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException { return (V)get(); }
  
  public V join() throws InterruptedException, ExecutionException {
    try {
      return (V)get();
    } catch (Throwable throwable) {
      throw ExceptionUtil.rethrow(throwable);
    } 
  }
  
  public boolean complete(Object value) { return false; }
  
  public boolean cancel(boolean mayInterruptIfRunning) { return false; }
  
  public boolean isCancelled() { return false; }
  
  public boolean isDone() { return true; }
  
  public void andThen(ExecutionCallback<V> callback) { andThen(callback, this.userExecutor); }
  
  public void andThen(ExecutionCallback<V> callback, Executor executor) { executor.execute(new Object(this, callback)); }
}
