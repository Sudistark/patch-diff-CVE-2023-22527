package com.hazelcast.util;

import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicLongFieldUpdater;

public final class ConcurrencyUtil {
  public static final Executor CALLER_RUNS = new Object();
  
  public static <E> void setMax(E obj, AtomicLongFieldUpdater<E> updater, long value) {
    long current;
    do {
      current = updater.get(obj);
      if (current >= value)
        return; 
    } while (!updater.compareAndSet(obj, current, value));
  }
  
  public static boolean setIfEqualOrGreaterThan(AtomicLong oldValue, long newValue) {
    long local;
    do {
      local = oldValue.get();
      if (newValue < local)
        return false; 
    } while (!oldValue.compareAndSet(local, newValue));
    return true;
  }
  
  public static <K, V> V getOrPutSynchronized(ConcurrentMap<K, V> map, K key, Object mutex, ConstructorFunction<K, V> func) {
    if (mutex == null)
      throw new NullPointerException(); 
    V value = (V)map.get(key);
    if (value == null)
      synchronized (mutex) {
        value = (V)map.get(key);
        if (value == null) {
          value = (V)func.createNew(key);
          map.put(key, value);
        } 
      }  
    return value;
  }
  
  public static <K, V> V getOrPutSynchronized(ConcurrentMap<K, V> map, K key, ContextMutexFactory contextMutexFactory, ConstructorFunction<K, V> func) {
    if (contextMutexFactory == null)
      throw new NullPointerException(); 
    V value = (V)map.get(key);
    if (value == null) {
      mutex = contextMutexFactory.mutexFor(key);
      try {
        synchronized (mutex) {
          value = (V)map.get(key);
          if (value == null) {
            value = (V)func.createNew(key);
            map.put(key, value);
          } 
        } 
      } finally {
        mutex.close();
      } 
    } 
    return value;
  }
  
  public static <K, V> V getOrPutIfAbsent(ConcurrentMap<K, V> map, K key, ConstructorFunction<K, V> func) {
    V value = (V)map.get(key);
    if (value == null) {
      value = (V)func.createNew(key);
      V current = (V)map.putIfAbsent(key, value);
      value = (current == null) ? value : current;
    } 
    return value;
  }
}
