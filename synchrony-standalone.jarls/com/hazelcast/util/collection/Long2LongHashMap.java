package com.hazelcast.util.collection;

import com.hazelcast.util.QuickMath;
import com.hazelcast.util.function.BiConsumer;
import com.hazelcast.util.function.LongLongConsumer;
import java.util.Arrays;
import java.util.Collection;
import java.util.Map;
import java.util.Set;

public class Long2LongHashMap extends Object implements Map<Long, Long> {
  public static final double DEFAULT_LOAD_FACTOR = 0.6D;
  
  public static final int DEFAULT_INITIAL_CAPACITY = 8;
  
  private static final int CURSOR_BEFORE_FIRST_INDEX = -2;
  
  private final Set<Long> keySet;
  
  private final LongIterator valueIterator;
  
  private final Collection<Long> values;
  
  private final Set<Map.Entry<Long, Long>> entrySet;
  
  private final double loadFactor;
  
  private final long missingValue;
  
  private long[] entries;
  
  private int capacity;
  
  private int mask;
  
  private int resizeThreshold;
  
  private int size;
  
  public Long2LongHashMap(int initialCapacity, double loadFactor, long missingValue) {
    this(loadFactor, missingValue);
    capacity(QuickMath.nextPowerOfTwo(initialCapacity));
  }
  
  public Long2LongHashMap(long missingValue) { this(8, 0.6D, missingValue); }
  
  public Long2LongHashMap(Long2LongHashMap that) {
    this(that.loadFactor, that.missingValue);
    this.entries = Arrays.copyOf(that.entries, that.entries.length);
    this.capacity = that.capacity;
    this.mask = that.mask;
    this.resizeThreshold = that.resizeThreshold;
    this.size = that.size;
  }
  
  private Long2LongHashMap(double loadFactor, long missingValue) {
    this.entrySet = entrySetSingleton();
    this.keySet = keySetSingleton();
    this.values = valuesSingleton();
    this.valueIterator = new LongIterator(this, 1, null);
    this.loadFactor = loadFactor;
    this.missingValue = missingValue;
  }
  
  public int size() { return this.size; }
  
  public boolean isEmpty() { return (size() == 0); }
  
  public long get(long key) {
    long[] entries = this.entries;
    int index = Hashing.evenLongHash(key, this.mask);
    long candidateKey;
    while ((candidateKey = entries[index]) != this.missingValue) {
      if (candidateKey == key)
        return entries[index + 1]; 
      index = next(index);
    } 
    return this.missingValue;
  }
  
  public long put(long key, long value) {
    assert key != this.missingValue : "Invalid key " + key;
    assert value != this.missingValue : "Invalid value " + value;
    long oldValue = this.missingValue;
    int index = Hashing.evenLongHash(key, this.mask);
    long candidateKey;
    while ((candidateKey = this.entries[index]) != this.missingValue) {
      if (candidateKey == key) {
        oldValue = this.entries[index + 1];
        break;
      } 
      index = next(index);
    } 
    if (oldValue == this.missingValue) {
      this.size++;
      this.entries[index] = key;
    } 
    this.entries[index + 1] = value;
    checkResize();
    return oldValue;
  }
  
  private void checkResize() {
    if (this.size > this.resizeThreshold) {
      int newCapacity = this.capacity << 1;
      if (newCapacity < 0)
        throw new IllegalStateException("Max capacity reached at size=" + this.size); 
      rehash(newCapacity);
    } 
  }
  
  private void rehash(int newCapacity) {
    long[] oldEntries = this.entries;
    capacity(newCapacity);
    for (int i = 0; i < oldEntries.length; i += 2) {
      long key = oldEntries[i];
      if (key != this.missingValue)
        put(key, oldEntries[i + 1]); 
    } 
  }
  
  public void longForEach(LongLongConsumer consumer) {
    long[] entries = this.entries;
    for (int i = 0; i < entries.length; i += 2) {
      long key = entries[i];
      if (key != this.missingValue)
        consumer.accept(entries[i], entries[i + 1]); 
    } 
  }
  
  public LongLongCursor cursor() { return new LongLongCursor(this); }
  
  public boolean containsKey(long key) { return (get(key) != this.missingValue); }
  
  public boolean containsValue(long value) {
    long[] entries = this.entries;
    for (int i = 1; i < entries.length; i += 2) {
      long entryValue = entries[i];
      if (entryValue == value)
        return true; 
    } 
    return false;
  }
  
  public void clear() {
    Arrays.fill(this.entries, this.missingValue);
    this.size = 0;
  }
  
  public Long get(Object key) { return Long.valueOf(get(((Long)key).longValue())); }
  
  public Long put(Long key, Long value) { return Long.valueOf(put(key.longValue(), value.longValue())); }
  
  public void forEach(BiConsumer<? super Long, ? super Long> action) { longForEach(new UnboxingBiConsumer(action)); }
  
  public boolean containsKey(Object key) { return containsKey(((Long)key).longValue()); }
  
  public boolean containsValue(Object value) { return containsValue(((Long)value).longValue()); }
  
  public void putAll(Map<? extends Long, ? extends Long> map) {
    for (Map.Entry<? extends Long, ? extends Long> entry : map.entrySet())
      put((Long)entry.getKey(), (Long)entry.getValue()); 
  }
  
  public Set<Long> keySet() { return this.keySet; }
  
  public Collection<Long> values() { return this.values; }
  
  public Set<Map.Entry<Long, Long>> entrySet() { return this.entrySet; }
  
  public Long remove(Object key) { return Long.valueOf(remove(((Long)key).longValue())); }
  
  public long remove(long key) {
    long[] entries = this.entries;
    int index = Hashing.evenLongHash(key, this.mask);
    long candidateKey;
    while ((candidateKey = entries[index]) != this.missingValue) {
      if (candidateKey == key) {
        int valueIndex = index + 1;
        long oldValue = entries[valueIndex];
        entries[index] = this.missingValue;
        entries[valueIndex] = this.missingValue;
        this.size--;
        compactChain(index);
        return oldValue;
      } 
      index = next(index);
    } 
    return this.missingValue;
  }
  
  public String toString() {
    StringBuilder b = new StringBuilder(size() * 8);
    b.append('{');
    longForEach(new Object(this, b));
    return b.append('}').toString();
  }
  
  private void compactChain(int deleteIndex) {
    long[] entries = this.entries;
    int index = deleteIndex;
    while (true) {
      index = next(index);
      if (entries[index] == this.missingValue)
        return; 
      int hash = Hashing.evenLongHash(entries[index], this.mask);
      if ((index < hash && (hash <= deleteIndex || deleteIndex <= index)) || (hash <= deleteIndex && deleteIndex <= index)) {
        entries[deleteIndex] = entries[index];
        entries[deleteIndex + 1] = entries[index + 1];
        entries[index] = this.missingValue;
        entries[index + 1] = this.missingValue;
        deleteIndex = index;
      } 
    } 
  }
  
  private int next(int index) { return index + 2 & this.mask; }
  
  private void capacity(int newCapacity) {
    this.capacity = newCapacity;
    this.resizeThreshold = (int)(newCapacity * this.loadFactor);
    this.mask = newCapacity * 2 - 1;
    this.entries = new long[newCapacity * 2];
    this.size = 0;
    Arrays.fill(this.entries, this.missingValue);
  }
  
  private MapDelegatingSet<Map.Entry<Long, Long>> entrySetSingleton() { return new MapDelegatingSet(this, new EntryIteratorSupplier(new EntryIterator(this, null)), new Object(this)); }
  
  private MapDelegatingSet<Long> keySetSingleton() { return new MapDelegatingSet(this, new IteratorSupplier(new LongIterator(this, 0, null)), new Object(this)); }
  
  private MapDelegatingSet<Long> valuesSingleton() { return new MapDelegatingSet(this, new Object(this), new Object(this)); }
}
