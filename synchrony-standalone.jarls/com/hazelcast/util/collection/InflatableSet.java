package com.hazelcast.util.collection;

import com.hazelcast.nio.serialization.SerializableByConvention;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.Serializable;
import java.util.AbstractSet;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

@SerializableByConvention
public final class InflatableSet<T> extends AbstractSet<T> implements Set<T>, Serializable, Cloneable {
  private static final long serialVersionUID = 0L;
  
  private final List<T> compactList;
  
  private Set<T> inflatedSet;
  
  private State state;
  
  private InflatableSet(List<T> compactList) {
    this.state = State.COMPACT;
    this.compactList = compactList;
  }
  
  private InflatableSet(InflatableSet<T> other) {
    this.compactList = new ArrayList(other.compactList.size());
    this.compactList.addAll(other.compactList);
    if (other.inflatedSet != null)
      this.inflatedSet = new HashSet(other.inflatedSet); 
    this.state = other.state;
  }
  
  public static <T> Builder<T> newBuilder(int initialCapacity) { return new Builder(initialCapacity, null); }
  
  public static <T> Builder<T> newBuilder(List<T> list) { return new Builder(list, null); }
  
  public int size() {
    if (this.state == State.INFLATED)
      return this.inflatedSet.size(); 
    return this.compactList.size();
  }
  
  public boolean isEmpty() {
    if (this.state == State.INFLATED)
      return this.inflatedSet.isEmpty(); 
    return this.compactList.isEmpty();
  }
  
  public boolean contains(Object o) {
    if (this.state == State.COMPACT)
      toHybridState(); 
    return this.inflatedSet.contains(o);
  }
  
  public Iterator<T> iterator() {
    if (this.state == State.INFLATED)
      return this.inflatedSet.iterator(); 
    return new HybridIterator(this);
  }
  
  public boolean add(T t) {
    toInflatedState();
    return this.inflatedSet.add(t);
  }
  
  public boolean remove(Object o) {
    switch (null.$SwitchMap$com$hazelcast$util$collection$InflatableSet$State[this.state.ordinal()]) {
      case 1:
        this.compactList.remove(o);
        return this.inflatedSet.remove(o);
      case 2:
        return this.inflatedSet.remove(o);
    } 
    return this.compactList.remove(o);
  }
  
  public void clear() {
    switch (null.$SwitchMap$com$hazelcast$util$collection$InflatableSet$State[this.state.ordinal()]) {
      case 1:
        this.inflatedSet.clear();
        this.compactList.clear();
        return;
      case 2:
        this.inflatedSet.clear();
        return;
    } 
    this.compactList.clear();
  }
  
  @SuppressFBWarnings(value = {"CN_IDIOM"}, justification = "Deliberate, documented contract violation")
  protected Object clone() { return new InflatableSet(this); }
  
  private void inflateIfNeeded() {
    if (this.inflatedSet == null)
      this.inflatedSet = new HashSet(this.compactList); 
  }
  
  private void toHybridState() {
    if (this.state == State.HYBRID)
      return; 
    this.state = State.HYBRID;
    inflateIfNeeded();
  }
  
  private void toInflatedState() {
    if (this.state == State.INFLATED)
      return; 
    this.state = State.INFLATED;
    inflateIfNeeded();
    invalidateIterators();
  }
  
  private void invalidateIterators() {
    if (this.compactList.size() == 0) {
      this.compactList.clear();
    } else {
      this.compactList.remove(0);
    } 
  }
}
