package com.hazelcast.util;

import com.hazelcast.core.IBiFunction;
import com.hazelcast.core.IFunction;
import com.hazelcast.nio.serialization.SerializableByConvention;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.AbstractMap;
import java.util.Collection;
import java.util.EnumSet;
import java.util.Enumeration;
import java.util.Map;
import java.util.Set;

@SerializableByConvention
public class ConcurrentReferenceHashMap<K, V> extends AbstractMap<K, V> implements IConcurrentMap<K, V>, Serializable {
  static final ReferenceType DEFAULT_KEY_TYPE = ReferenceType.WEAK;
  
  static final ReferenceType DEFAULT_VALUE_TYPE = ReferenceType.STRONG;
  
  static final int DEFAULT_INITIAL_CAPACITY = 16;
  
  static final float DEFAULT_LOAD_FACTOR = 0.75F;
  
  static final int DEFAULT_CONCURRENCY_LEVEL = 16;
  
  static final int MAXIMUM_CAPACITY = 1073741824;
  
  static final int MAX_SEGMENTS = 65536;
  
  static final int RETRIES_BEFORE_LOCK = 2;
  
  private static final long serialVersionUID = 7249069246763182397L;
  
  final int segmentMask;
  
  final int segmentShift;
  
  final Segment<K, V>[] segments;
  
  boolean identityComparisons;
  
  Set<K> keySet;
  
  Set<Map.Entry<K, V>> entrySet;
  
  Collection<V> values;
  
  private static int hash(int h) {
    h += (h << 15 ^ 0xFFFFCD7D);
    h ^= h >>> 10;
    h += (h << 3);
    h ^= h >>> 6;
    h += (h << 2) + (h << 14);
    return h ^ h >>> 16;
  }
  
  final Segment<K, V> segmentFor(int hash) { return this.segments[hash >>> this.segmentShift & this.segmentMask]; }
  
  private int hashOf(Object key) { return hash(this.identityComparisons ? System.identityHashCode(key) : key.hashCode()); }
  
  public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType keyType, ReferenceType valueType, EnumSet<Option> options) {
    if (loadFactor <= 0.0F || initialCapacity < 0 || concurrencyLevel <= 0)
      throw new IllegalArgumentException(); 
    if (concurrencyLevel > 65536)
      concurrencyLevel = 65536; 
    int sshift = 0;
    int ssize = 1;
    while (ssize < concurrencyLevel) {
      sshift++;
      ssize <<= 1;
    } 
    this.segmentShift = 32 - sshift;
    this.segmentMask = ssize - 1;
    this.segments = Segment.newArray(ssize);
    if (initialCapacity > 1073741824)
      initialCapacity = 1073741824; 
    int c = initialCapacity / ssize;
    if (c * ssize < initialCapacity)
      c++; 
    int cap = 1;
    while (cap < c)
      cap <<= 1; 
    this.identityComparisons = (options != null && options.contains(Option.IDENTITY_COMPARISONS));
    for (int i = 0; i < this.segments.length; i++)
      this.segments[i] = new Segment(cap, loadFactor, keyType, valueType, this.identityComparisons); 
  }
  
  public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_KEY_TYPE, DEFAULT_VALUE_TYPE, null); }
  
  public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) { this(initialCapacity, loadFactor, 16); }
  
  public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType keyType, ReferenceType valueType) { this(initialCapacity, 0.75F, 16, keyType, valueType, null); }
  
  public ConcurrentReferenceHashMap(ReferenceType keyType, ReferenceType valueType) { this(16, 0.75F, 16, keyType, valueType, null); }
  
  public ConcurrentReferenceHashMap(ReferenceType keyType, ReferenceType valueType, EnumSet<Option> options) { this(16, 0.75F, 16, keyType, valueType, options); }
  
  public ConcurrentReferenceHashMap(int initialCapacity) { this(initialCapacity, 0.75F, 16); }
  
  public ConcurrentReferenceHashMap() { this(16, 0.75F, 16); }
  
  public ConcurrentReferenceHashMap(Map<? extends K, ? extends V> m) {
    this(Math.max((int)(m.size() / 0.75F) + 1, 16), 0.75F, 16);
    putAll(m);
  }
  
  public boolean isEmpty() {
    Segment[] arrayOfSegment = this.segments;
    int[] mc = new int[arrayOfSegment.length];
    int mcsum = 0;
    for (int i = 0; i < arrayOfSegment.length; i++) {
      if ((arrayOfSegment[i]).count != 0)
        return false; 
      mc[i] = (arrayOfSegment[i]).modCount;
      mcsum += (arrayOfSegment[i]).modCount;
    } 
    if (mcsum != 0)
      for (int i = 0; i < arrayOfSegment.length; i++) {
        if ((arrayOfSegment[i]).count != 0 || mc[i] != (arrayOfSegment[i]).modCount)
          return false; 
      }  
    return true;
  }
  
  public int size() {
    Segment[] arrayOfSegment = this.segments;
    long sum = 0L;
    long check = 0L;
    int[] mc = new int[arrayOfSegment.length];
    for (int k = 0; k < 2; k++) {
      check = 0L;
      sum = 0L;
      int mcsum = 0;
      for (int i = 0; i < arrayOfSegment.length; i++) {
        sum += (arrayOfSegment[i]).count;
        mc[i] = (arrayOfSegment[i]).modCount;
        mcsum += (arrayOfSegment[i]).modCount;
      } 
      if (mcsum != 0)
        for (int i = 0; i < arrayOfSegment.length; i++) {
          check += (arrayOfSegment[i]).count;
          if (mc[i] != (arrayOfSegment[i]).modCount) {
            check = -1L;
            break;
          } 
        }  
      if (check == sum)
        break; 
    } 
    if (check != sum) {
      sum = 0L;
      for (int i = 0; i < arrayOfSegment.length; i++)
        arrayOfSegment[i].lock(); 
      for (int i = 0; i < arrayOfSegment.length; i++)
        sum += (arrayOfSegment[i]).count; 
      for (int i = 0; i < arrayOfSegment.length; i++)
        arrayOfSegment[i].unlock(); 
    } 
    return (sum > 2147483647L) ? Integer.MAX_VALUE : (int)sum;
  }
  
  public V get(Object key) {
    int hash = hashOf(key);
    return (V)segmentFor(hash).get(key, hash);
  }
  
  public boolean containsKey(Object key) {
    int hash = hashOf(key);
    return segmentFor(hash).containsKey(key, hash);
  }
  
  public boolean containsValue(Object value) {
    if (value == null)
      throw new NullPointerException(); 
    arrayOfSegment = this.segments;
    int[] mc = new int[arrayOfSegment.length];
    for (int k = 0; k < 2; k++) {
      int sum = 0;
      int mcsum = 0;
      for (int i = 0; i < arrayOfSegment.length; i++) {
        int c = (arrayOfSegment[i]).count;
        mc[i] = (arrayOfSegment[i]).modCount;
        mcsum += (arrayOfSegment[i]).modCount;
        if (arrayOfSegment[i].containsValue(value))
          return true; 
      } 
      boolean cleanSweep = true;
      if (mcsum != 0)
        for (int i = 0; i < arrayOfSegment.length; i++) {
          int c = (arrayOfSegment[i]).count;
          if (mc[i] != (arrayOfSegment[i]).modCount) {
            cleanSweep = false;
            break;
          } 
        }  
      if (cleanSweep)
        return false; 
    } 
    for (int i = 0; i < arrayOfSegment.length; i++)
      arrayOfSegment[i].lock(); 
    boolean found = false;
    try {
      for (int i = 0; i < arrayOfSegment.length; i++) {
        if (arrayOfSegment[i].containsValue(value)) {
          found = true;
          break;
        } 
      } 
    } finally {
      for (int i = 0; i < arrayOfSegment.length; i++)
        arrayOfSegment[i].unlock(); 
    } 
    return found;
  }
  
  public boolean contains(Object value) { return containsValue(value); }
  
  public V put(K key, V value) {
    if (value == null)
      throw new NullPointerException(); 
    int hash = hashOf(key);
    return (V)segmentFor(hash).put(key, hash, value, null, false);
  }
  
  public V putIfAbsent(K key, V value) {
    if (value == null)
      throw new NullPointerException(); 
    int hash = hashOf(key);
    return (V)segmentFor(hash).put(key, hash, value, null, true);
  }
  
  public V applyIfAbsent(K key, IFunction<? super K, ? extends V> mappingFunction) {
    Preconditions.checkNotNull(key);
    Preconditions.checkNotNull(mappingFunction);
    int hash = hashOf(key);
    Segment<K, V> segment = segmentFor(hash);
    V v = (V)segment.get(key, hash);
    return (V)((v == null) ? segment.put(key, hash, null, mappingFunction, true) : v);
  }
  
  public V applyIfPresent(K key, IBiFunction<? super K, ? super V, ? extends V> remappingFunction) {
    Preconditions.checkNotNull(key);
    Preconditions.checkNotNull(remappingFunction);
    int hash = hashOf(key);
    Segment<K, V> segment = segmentFor(hash);
    V v = (V)segment.get(key, hash);
    if (v == null)
      return null; 
    return (V)segmentFor(hash).applyIfPresent(key, hash, remappingFunction);
  }
  
  public void putAll(Map<? extends K, ? extends V> m) {
    for (Map.Entry<? extends K, ? extends V> e : m.entrySet())
      put(e.getKey(), e.getValue()); 
  }
  
  public V remove(Object key) {
    int hash = hashOf(key);
    return (V)segmentFor(hash).remove(key, hash, null, false);
  }
  
  public boolean remove(Object key, Object value) {
    int hash = hashOf(key);
    if (value == null)
      return false; 
    return (segmentFor(hash).remove(key, hash, value, false) != null);
  }
  
  public boolean replace(K key, V oldValue, V newValue) {
    if (oldValue == null || newValue == null)
      throw new NullPointerException(); 
    int hash = hashOf(key);
    return segmentFor(hash).replace(key, hash, oldValue, newValue);
  }
  
  public V replace(K key, V value) {
    if (value == null)
      throw new NullPointerException(); 
    int hash = hashOf(key);
    return (V)segmentFor(hash).replace(key, hash, value);
  }
  
  public void clear() {
    for (int i = 0; i < this.segments.length; i++)
      this.segments[i].clear(); 
  }
  
  public void purgeStaleEntries() {
    for (int i = 0; i < this.segments.length; i++)
      this.segments[i].removeStale(); 
  }
  
  public Set<K> keySet() {
    Set<K> ks = this.keySet;
    return (ks != null) ? ks : (this.keySet = new KeySet(this));
  }
  
  public Collection<V> values() {
    Collection<V> vs = this.values;
    return (vs != null) ? vs : (this.values = new Values(this));
  }
  
  public Set<Map.Entry<K, V>> entrySet() {
    Set<Map.Entry<K, V>> es = this.entrySet;
    return (es != null) ? es : (this.entrySet = new EntrySet(this));
  }
  
  public Enumeration<K> keys() { return new KeyIterator(this); }
  
  public Enumeration<V> elements() { return new ValueIterator(this); }
  
  private void writeObject(ObjectOutputStream s) throws IOException {
    s.defaultWriteObject();
    for (int k = 0; k < this.segments.length; k++) {
      Segment<K, V> seg = this.segments[k];
      seg.lock();
    } 
    s.writeObject(null);
    s.writeObject(null);
  }
  
  private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
    s.defaultReadObject();
    for (int i = 0; i < this.segments.length; i++)
      this.segments[i].setTable(new HashEntry[1]); 
    while (true) {
      K key = (K)s.readObject();
      V value = (V)s.readObject();
      if (key == null)
        break; 
      put(key, value);
    } 
  }
}
