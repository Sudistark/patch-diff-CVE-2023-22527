package com.hazelcast.util;

import com.hazelcast.internal.util.ResultSet;
import com.hazelcast.query.PagingPredicate;
import com.hazelcast.query.PagingPredicateAccessor;
import com.hazelcast.query.impl.QueryableEntry;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;

public final class SortingUtil {
  public static int compare(Comparator<Map.Entry> comparator, IterationType iterationType, Map.Entry entry1, Map.Entry entry2) {
    Object comparable2, comparable2, comparable2, comparable1, comparable1, comparable1;
    if (comparator != null) {
      int result = comparator.compare(entry1, entry2);
      if (result != 0)
        return result; 
      return compareIntegers(entry1.getKey().hashCode(), entry2.getKey().hashCode());
    } 
    switch (null.$SwitchMap$com$hazelcast$util$IterationType[iterationType.ordinal()]) {
      case 1:
        comparable1 = entry1.getKey();
        comparable2 = entry2.getKey();
        break;
      case 2:
        comparable1 = entry1.getValue();
        comparable2 = entry2.getValue();
        break;
      default:
        if (entry1 instanceof Comparable && entry2 instanceof Comparable) {
          Object comparable1 = entry1;
          Object comparable2 = entry2;
          break;
        } 
        comparable1 = entry1.getKey();
        comparable2 = entry2.getKey();
        break;
    } 
    checkIfComparable(comparable1);
    checkIfComparable(comparable2);
    int result = ((Comparable)comparable1).compareTo(comparable2);
    if (result != 0)
      return result; 
    return compareIntegers(entry1.getKey().hashCode(), entry2.getKey().hashCode());
  }
  
  private static void checkIfComparable(Object comparable) {
    if (comparable instanceof Comparable)
      return; 
    throw new IllegalArgumentException("Not comparable " + comparable);
  }
  
  private static int compareIntegers(int i1, int i2) {
    if (i1 > i2)
      return 1; 
    if (i2 > i1)
      return -1; 
    return 0;
  }
  
  public static Comparator<Map.Entry> newComparator(Comparator<Map.Entry> comparator, IterationType iterationType) { return new Object(comparator, iterationType); }
  
  private static Comparator<QueryableEntry> newComparator(PagingPredicate pagingPredicate) { return new Object(pagingPredicate); }
  
  public static List<QueryableEntry> getSortedSubList(List<QueryableEntry> list, PagingPredicate pagingPredicate, Map.Entry<Integer, Map.Entry> nearestAnchorEntry) {
    if (pagingPredicate == null || list.isEmpty())
      return list; 
    Comparator<QueryableEntry> comparator = newComparator(pagingPredicate);
    Collections.sort(list, comparator);
    int nearestPage = ((Integer)nearestAnchorEntry.getKey()).intValue();
    int pageSize = pagingPredicate.getPageSize();
    int page = pagingPredicate.getPage();
    long totalSize = pageSize * (page - nearestPage);
    if (list.size() > totalSize)
      list = list.subList(0, (int)totalSize); 
    return list;
  }
  
  public static ResultSet getSortedQueryResultSet(List<Map.Entry> list, PagingPredicate pagingPredicate, IterationType iterationType) {
    if (list.isEmpty())
      return new ResultSet(); 
    Comparator<Map.Entry> comparator = newComparator(pagingPredicate.getComparator(), iterationType);
    Collections.sort(list, comparator);
    Map.Entry<Integer, Map.Entry> nearestAnchorEntry = PagingPredicateAccessor.getNearestAnchorEntry(pagingPredicate);
    int nearestPage = ((Integer)nearestAnchorEntry.getKey()).intValue();
    int page = pagingPredicate.getPage();
    int pageSize = pagingPredicate.getPageSize();
    long begin = pageSize * (page - nearestPage - 1L);
    int size = list.size();
    if (begin > size)
      return new ResultSet(); 
    long end = begin + pageSize;
    if (end > size)
      end = size; 
    setAnchor(list, pagingPredicate, nearestPage);
    List<Map.Entry> subList = list.subList((int)begin, (int)end);
    return new ResultSet(subList, iterationType);
  }
  
  public static boolean compareAnchor(PagingPredicate pagingPredicate, QueryableEntry queryEntry, Map.Entry<Integer, Map.Entry> nearestAnchorEntry) {
    if (pagingPredicate == null)
      return true; 
    Map.Entry anchor = (Map.Entry)nearestAnchorEntry.getValue();
    if (anchor == null)
      return true; 
    Comparator<Map.Entry> comparator = pagingPredicate.getComparator();
    IterationType iterationType = pagingPredicate.getIterationType();
    return (compare(comparator, iterationType, anchor, queryEntry) < 0);
  }
  
  private static void setAnchor(List<Map.Entry> list, PagingPredicate pagingPredicate, int nearestPage) {
    if (list.isEmpty())
      return; 
    int size = list.size();
    int pageSize = pagingPredicate.getPageSize();
    int page = pagingPredicate.getPage();
    int i;
    for (i = pageSize; i <= size && nearestPage < page; i += pageSize) {
      Map.Entry anchor = (Map.Entry)list.get(i - 1);
      nearestPage++;
      PagingPredicateAccessor.setAnchor(pagingPredicate, nearestPage, anchor);
    } 
  }
}
