package com.hazelcast.util;

import java.io.IOException;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Deque;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Set;

public final class AddressUtil {
  private static final int NUMBER_OF_ADDRESSES = 255;
  
  private static final int IPV4_LENGTH = 4;
  
  private static final int IPV6_LENGTH = 8;
  
  private static final int IPV6_MAX_THRESHOLD = 65535;
  
  private static final int IPV4_MAX_THRESHOLD = 255;
  
  private static final int HEXADECIMAL_RADIX = 16;
  
  private static final int DECIMAL_RADIX = 10;
  
  public static boolean matchAnyInterface(String address, Collection<String> interfaces) {
    if (interfaces == null || interfaces.size() == 0)
      return false; 
    for (String interfaceMask : interfaces) {
      if (matchInterface(address, interfaceMask))
        return true; 
    } 
    return false;
  }
  
  public static boolean matchInterface(String address, String interfaceMask) {
    AddressMatcher mask;
    try {
      mask = getAddressMatcher(interfaceMask);
    } catch (Exception e) {
      return false;
    } 
    return mask.match(address);
  }
  
  public static boolean matchAnyDomain(String name, Collection<String> patterns) {
    if (patterns == null || patterns.size() == 0)
      return false; 
    for (String pattern : patterns) {
      if (matchDomain(name, pattern))
        return true; 
    } 
    return false;
  }
  
  public static boolean matchDomain(String name, String pattern) {
    int index = pattern.indexOf('*');
    if (index == -1)
      return name.equals(pattern); 
    String[] names = name.split("\\.");
    String[] patterns = pattern.split("\\.");
    if (patterns.length > names.length)
      return false; 
    int nameIndexDiff = names.length - patterns.length;
    for (int i = patterns.length - 1; i > -1; i--) {
      if (!"*".equals(patterns[i]))
        if (!patterns[i].equals(names[i + nameIndexDiff]))
          return false;  
    } 
    return true;
  }
  
  public static AddressHolder getAddressHolder(String address) { return getAddressHolder(address, -1); }
  
  public static AddressHolder getAddressHolder(String address, int defaultPort) {
    String host;
    int indexBracketStart = address.indexOf('[');
    int indexBracketEnd = address.indexOf(']', indexBracketStart);
    int indexColon = address.indexOf(':');
    int lastIndexColon = address.lastIndexOf(':');
    int port = defaultPort;
    String scopeId = null;
    if (indexColon > -1 && lastIndexColon > indexColon) {
      if (indexBracketStart == 0 && indexBracketEnd > indexBracketStart) {
        host = address.substring(indexBracketStart + 1, indexBracketEnd);
        if (lastIndexColon == indexBracketEnd + 1)
          port = Integer.parseInt(address.substring(lastIndexColon + 1)); 
      } else {
        host = address;
      } 
      int indexPercent = host.indexOf('%');
      if (indexPercent != -1) {
        scopeId = host.substring(indexPercent + 1);
        host = host.substring(0, indexPercent);
      } 
    } else if (indexColon > 0 && indexColon == lastIndexColon) {
      host = address.substring(0, indexColon);
      port = Integer.parseInt(address.substring(indexColon + 1));
    } else {
      host = address;
    } 
    return new AddressHolder(host, port, scopeId);
  }
  
  public static boolean isIpAddress(String address) {
    try {
      getAddressMatcher(address);
      return true;
    } catch (InvalidAddressException e) {
      return false;
    } 
  }
  
  public static InetAddress fixScopeIdAndGetInetAddress(InetAddress inetAddress) throws SocketException {
    if (!(inetAddress instanceof Inet6Address))
      return inetAddress; 
    if (!inetAddress.isLinkLocalAddress() && !inetAddress.isSiteLocalAddress())
      return inetAddress; 
    Inet6Address inet6Address = (Inet6Address)inetAddress;
    if (inet6Address.getScopeId() > 0 || inet6Address.getScopedInterface() != null)
      return inetAddress; 
    Inet6Address resultInetAddress = findRealInet6Address(inet6Address);
    return (resultInetAddress == null) ? inetAddress : resultInetAddress;
  }
  
  private static Inet6Address findRealInet6Address(Inet6Address inet6Address) throws SocketException {
    Inet6Address resultInetAddress = null;
    Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();
    while (interfaces.hasMoreElements()) {
      NetworkInterface ni = (NetworkInterface)interfaces.nextElement();
      Enumeration<InetAddress> addresses = ni.getInetAddresses();
      while (addresses.hasMoreElements()) {
        InetAddress address = (InetAddress)addresses.nextElement();
        if (!isInet6Compatible(address, inet6Address))
          continue; 
        if (resultInetAddress != null)
          throw new IllegalArgumentException("This address " + inet6Address + " is bound to more than one network interface!"); 
        resultInetAddress = (Inet6Address)address;
      } 
    } 
    return resultInetAddress;
  }
  
  private static boolean isInet6Compatible(InetAddress address, Inet6Address inet6Address) {
    if (!(address instanceof Inet6Address))
      return false; 
    if (!Arrays.equals(address.getAddress(), inet6Address.getAddress()))
      return false; 
    return true;
  }
  
  public static Inet6Address getInetAddressFor(Inet6Address inetAddress, String scope) throws UnknownHostException, SocketException {
    if (inetAddress.isLinkLocalAddress() || inetAddress.isSiteLocalAddress()) {
      char[] chars = scope.toCharArray();
      boolean numeric = true;
      for (char c : chars) {
        if (!Character.isDigit(c)) {
          numeric = false;
          break;
        } 
      } 
      if (numeric)
        return Inet6Address.getByAddress(null, inetAddress.getAddress(), Integer.parseInt(scope)); 
      return Inet6Address.getByAddress(null, inetAddress.getAddress(), NetworkInterface.getByName(scope));
    } 
    return inetAddress;
  }
  
  public static Collection<Inet6Address> getPossibleInetAddressesFor(Inet6Address inet6Address) {
    if ((!inet6Address.isSiteLocalAddress() && !inet6Address.isLinkLocalAddress()) || inet6Address
      .getScopeId() > 0 || inet6Address.getScopedInterface() != null)
      return Collections.singleton(inet6Address); 
    LinkedList<Inet6Address> possibleAddresses = new LinkedList<Inet6Address>();
    try {
      Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();
      while (interfaces.hasMoreElements()) {
        NetworkInterface ni = (NetworkInterface)interfaces.nextElement();
        addPossibleAddress(inet6Address, possibleAddresses, ni);
      } 
    } catch (IOException ignored) {
      EmptyStatement.ignore(ignored);
    } 
    if (possibleAddresses.isEmpty())
      throw new IllegalArgumentException("Could not find a proper network interface to connect to " + inet6Address); 
    return possibleAddresses;
  }
  
  private static void addPossibleAddress(Inet6Address inet6Address, Deque<Inet6Address> possibleAddresses, NetworkInterface ni) throws UnknownHostException {
    Enumeration<InetAddress> addresses = ni.getInetAddresses();
    while (addresses.hasMoreElements()) {
      InetAddress address = (InetAddress)addresses.nextElement();
      if (address instanceof java.net.Inet4Address)
        continue; 
      if ((inet6Address.isLinkLocalAddress() && address.isLinkLocalAddress()) || (inet6Address
        .isSiteLocalAddress() && address.isSiteLocalAddress())) {
        Inet6Address newAddress = Inet6Address.getByAddress(null, inet6Address.getAddress(), ((Inet6Address)address)
            .getScopeId());
        possibleAddresses.addFirst(newAddress);
      } 
    } 
  }
  
  public static Collection<String> getMatchingIpv4Addresses(AddressMatcher addressMatcher) {
    if (addressMatcher.isIPv6())
      throw new IllegalArgumentException("Cannot wildcard matching for IPv6: " + addressMatcher); 
    Collection<String> addresses = new HashSet<String>();
    String first3 = addressMatcher.address[0] + '.' + addressMatcher.address[1] + '.' + addressMatcher.address[2];
    String lastPart = addressMatcher.address[3];
    if ("*".equals(lastPart)) {
      for (int j = 0; j <= 255; j++)
        addresses.add(first3 + '.' + j); 
    } else if (lastPart.indexOf('-') > 0) {
      int dashPos = lastPart.indexOf('-');
      int start = Integer.parseInt(lastPart.substring(0, dashPos));
      int end = Integer.parseInt(lastPart.substring(dashPos + 1));
      for (int j = start; j <= end; j++)
        addresses.add(first3 + '.' + j); 
    } else {
      addresses.add(addressMatcher.getAddress());
    } 
    return addresses;
  }
  
  public static AddressMatcher getAddressMatcher(String address) {
    Ip4AddressMatcher ip4AddressMatcher;
    int indexColon = address.indexOf(':');
    int lastIndexColon = address.lastIndexOf(':');
    int indexDot = address.indexOf('.');
    int lastIndexDot = address.lastIndexOf('.');
    if (indexColon > -1 && lastIndexColon > indexColon) {
      if (indexDot == -1) {
        ip4AddressMatcher = new Ip6AddressMatcher();
        parseIpv6(ip4AddressMatcher, address);
      } else {
        if (indexDot >= lastIndexDot)
          throw new InvalidAddressException(address); 
        int lastIndexColon2 = address.lastIndexOf(':');
        String host2 = address.substring(lastIndexColon2 + 1);
        ip4AddressMatcher = new Ip4AddressMatcher();
        parseIpv4(ip4AddressMatcher, host2);
      } 
    } else if (indexDot > -1 && lastIndexDot > indexDot && indexColon == -1) {
      ip4AddressMatcher = new Ip4AddressMatcher();
      parseIpv4(ip4AddressMatcher, address);
    } else {
      throw new InvalidAddressException(address);
    } 
    return ip4AddressMatcher;
  }
  
  public static Collection<Integer> getOutboundPorts(Collection<Integer> ports, Collection<String> portDefinitions) {
    if (ports == null)
      ports = Collections.emptySet(); 
    if (portDefinitions == null)
      portDefinitions = Collections.emptySet(); 
    if (portDefinitions.isEmpty() && ports.isEmpty())
      return Collections.emptySet(); 
    if (portDefinitions.contains("*") || portDefinitions.contains("0"))
      return Collections.emptySet(); 
    Set<Integer> selectedPorts = new HashSet<Integer>(ports);
    transformPortDefinitionsToPorts(portDefinitions, selectedPorts);
    if (selectedPorts.contains(Integer.valueOf(0)))
      return Collections.emptySet(); 
    return selectedPorts;
  }
  
  private static void transformPortDefinitionsToPorts(Collection<String> portDefinitions, Set<Integer> ports) {
    for (String portDef : portDefinitions) {
      String[] portDefs = portDef.split("[,; ]");
      for (String def : portDefs) {
        def = def.trim();
        if (!def.isEmpty()) {
          int dashPos = def.indexOf('-');
          if (dashPos > 0) {
            int start = Integer.parseInt(def.substring(0, dashPos));
            int end = Integer.parseInt(def.substring(dashPos + 1));
            for (int port = start; port <= end; port++)
              ports.add(Integer.valueOf(port)); 
          } else {
            ports.add(Integer.valueOf(Integer.parseInt(def)));
          } 
        } 
      } 
    } 
  }
  
  private static void parseIpv4(AddressMatcher matcher, String address) {
    String[] parts = address.split("\\.");
    if (parts.length != 4)
      throw new InvalidAddressException(address); 
    for (String part : parts) {
      if (!isValidIpAddressPart(part, false))
        throw new InvalidAddressException(address); 
    } 
    matcher.setAddress(parts);
  }
  
  private static boolean isValidIpAddressPart(String part, boolean ipv6) {
    String[] subParts;
    boolean isValid = true;
    if (part.length() == 1 && "*".equals(part))
      return true; 
    int rangeIndex = part.indexOf('-');
    if (rangeIndex > -1 && (rangeIndex != part
      .lastIndexOf('-') || rangeIndex == part.length() - 1))
      return false; 
    if (rangeIndex > -1) {
      subParts = part.split("\\-");
    } else {
      subParts = new String[] { part };
    } 
    try {
      for (String subPart : subParts) {
        if (ipv6) {
          int num = Integer.parseInt(subPart, 16);
          if (num > 65535) {
            isValid = false;
            break;
          } 
        } else {
          int num = Integer.parseInt(subPart);
          if (num > 255) {
            isValid = false;
            break;
          } 
        } 
      } 
    } catch (NumberFormatException e) {
      isValid = false;
    } 
    return isValid;
  }
  
  private static void parseIpv6(AddressMatcher matcher, String addrs) {
    String address = addrs;
    if (address.indexOf('%') > -1) {
      String[] parts = address.split("\\%");
      address = parts[0];
    } 
    String[] parts = address.split("((?<=:)|(?=:))");
    Collection<String> ipString = parseIPV6parts(parts, address);
    if (ipString.size() != 8)
      throw new InvalidAddressException(address); 
    String[] addressParts = (String[])ipString.toArray(new String[0]);
    checkIfAddressPartsAreValid(addressParts, address);
    matcher.setAddress(addressParts);
  }
  
  private static Collection<String> parseIPV6parts(String[] parts, String address) {
    LinkedList<String> ipString = new LinkedList<String>();
    int count = 0;
    int mark = -1;
    for (int i = 0; i < parts.length; i++) {
      String part = parts[i];
      String nextPart = (i < parts.length - 1) ? parts[i + 1] : null;
      if (!"".equals(part))
        if (":".equals(part) && ":".equals(nextPart)) {
          if (mark != -1)
            throw new InvalidAddressException(address); 
          mark = count;
        } else if (!":".equals(part)) {
          count++;
          ipString.add(part);
        }  
    } 
    if (mark > -1) {
      int remaining = 8 - count;
      for (int i = 0; i < remaining; i++)
        ipString.add(i + mark, "0"); 
    } 
    return ipString;
  }
  
  private static void checkIfAddressPartsAreValid(String[] addressParts, String address) {
    for (String part : addressParts) {
      if (!isValidIpAddressPart(part, true))
        throw new InvalidAddressException(address); 
    } 
  }
}
