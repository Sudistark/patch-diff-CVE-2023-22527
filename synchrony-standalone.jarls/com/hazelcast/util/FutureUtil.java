package com.hazelcast.util;

import com.hazelcast.logging.ILogger;
import com.hazelcast.logging.Logger;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.annotation.PrivateApi;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.logging.Level;

public final class FutureUtil {
  public static final ExceptionHandler RETHROW_EVERYTHING = new Object();
  
  public static final ExceptionHandler IGNORE_ALL_EXCEPTIONS = new Object();
  
  public static final ExceptionHandler IGNORE_ALL_EXCEPT_LOG_MEMBER_LEFT = new Object();
  
  public static final ExceptionHandler RETHROW_EXECUTION_EXCEPTION = new Object();
  
  public static final ExceptionHandler RETHROW_ALL_EXCEPT_MEMBER_LEFT = new Object();
  
  public static final ExceptionHandler RETHROW_TRANSACTION_EXCEPTION = new Object();
  
  private static final ILogger LOGGER = Logger.getLogger(FutureUtil.class);
  
  @PrivateApi
  public static ExceptionHandler logAllExceptions(ILogger logger, String message, Level level) {
    if (logger.isLoggable(level))
      return new Object(logger, level, message); 
    return IGNORE_ALL_EXCEPTIONS;
  }
  
  @PrivateApi
  public static ExceptionHandler logAllExceptions(String message, Level level) {
    if (LOGGER.isLoggable(level))
      return new Object(level, message); 
    return IGNORE_ALL_EXCEPTIONS;
  }
  
  @PrivateApi
  public static ExceptionHandler logAllExceptions(ILogger logger, Level level) {
    if (logger.isLoggable(level))
      return new Object(logger, level); 
    return IGNORE_ALL_EXCEPTIONS;
  }
  
  @PrivateApi
  public static ExceptionHandler logAllExceptions(Level level) {
    if (LOGGER.isLoggable(level))
      return new Object(level); 
    return IGNORE_ALL_EXCEPTIONS;
  }
  
  @PrivateApi
  public static <V> Collection<V> returnWithDeadline(Collection<Future<V>> futures, long timeout, TimeUnit timeUnit) { return returnWithDeadline(futures, timeout, timeUnit, IGNORE_ALL_EXCEPT_LOG_MEMBER_LEFT); }
  
  @PrivateApi
  public static <V> Collection<V> returnWithDeadline(Collection<Future<V>> futures, long timeout, TimeUnit timeUnit, ExceptionHandler exceptionHandler) { return returnWithDeadline(futures, timeout, timeUnit, timeout, timeUnit, exceptionHandler); }
  
  @PrivateApi
  public static <V> Collection<V> returnWithDeadline(Collection<Future<V>> futures, long overallTimeout, TimeUnit overallTimeUnit, long perFutureTimeout, TimeUnit perFutureTimeUnit) { return returnWithDeadline(futures, overallTimeout, overallTimeUnit, perFutureTimeout, perFutureTimeUnit, IGNORE_ALL_EXCEPT_LOG_MEMBER_LEFT); }
  
  @PrivateApi
  public static <V> Collection<V> returnWithDeadline(Collection<Future<V>> futures, long overallTimeout, TimeUnit overallTimeUnit, long perFutureTimeout, TimeUnit perFutureTimeUnit, ExceptionHandler exceptionHandler) {
    long overallTimeoutNanos = calculateTimeout(overallTimeout, overallTimeUnit);
    long perFutureTimeoutNanos = calculateTimeout(perFutureTimeout, perFutureTimeUnit);
    long deadline = System.nanoTime() + overallTimeoutNanos;
    List<V> results = new ArrayList<V>(futures.size());
    for (Future<V> future : futures) {
      try {
        long timeoutNanos = calculateFutureTimeout(perFutureTimeoutNanos, deadline);
        V value = (V)executeWithDeadline(future, timeoutNanos);
        if (value != null)
          results.add(value); 
      } catch (Exception e) {
        exceptionHandler.handleException(e);
      } 
    } 
    return results;
  }
  
  @PrivateApi
  public static void waitForever(Collection<? extends Future> futuresToWaitFor, ExceptionHandler exceptionHandler) {
    Collection<Future> futures = new ArrayList<Future>(futuresToWaitFor);
    do {
      Iterator<Future> it = futures.iterator();
      while (it.hasNext()) {
        Future future = (Future)it.next();
        try {
          future.get();
        } catch (Exception e) {
          exceptionHandler.handleException(e);
        } 
        if (future.isDone() || future.isCancelled())
          it.remove(); 
      } 
    } while (!futures.isEmpty());
  }
  
  @PrivateApi
  public static void waitForever(Collection<? extends Future> futures) { waitForever(futures, IGNORE_ALL_EXCEPT_LOG_MEMBER_LEFT); }
  
  @PrivateApi
  public static void waitWithDeadline(Collection<? extends Future> futures, long timeout, TimeUnit timeUnit) { waitWithDeadline(futures, timeout, timeUnit, IGNORE_ALL_EXCEPT_LOG_MEMBER_LEFT); }
  
  @PrivateApi
  public static void waitUntilAllRespondedWithDeadline(Collection<? extends Future> futures, long timeout, TimeUnit timeUnit, ExceptionHandler exceptionHandler) {
    CollectAllExceptionHandler collector = new CollectAllExceptionHandler(futures.size(), null);
    waitWithDeadline(futures, timeout, timeUnit, collector);
    List<Throwable> throwables = collector.getThrowables();
    synchronized (throwables) {
      for (Throwable t : throwables)
        exceptionHandler.handleException(t); 
    } 
  }
  
  @PrivateApi
  public static List<Throwable> waitUntilAllResponded(Collection<? extends Future> futures) {
    CollectAllExceptionHandler collector = new CollectAllExceptionHandler(futures.size(), null);
    waitForever(futures, collector);
    return collector.getThrowables();
  }
  
  @PrivateApi
  public static void waitWithDeadline(Collection<? extends Future> futures, long timeout, TimeUnit timeUnit, ExceptionHandler exceptionHandler) { waitWithDeadline(futures, timeout, timeUnit, timeout, timeUnit, exceptionHandler); }
  
  @PrivateApi
  public static void waitWithDeadline(Collection<? extends Future> futures, long overallTimeout, TimeUnit overallTimeUnit, long perFutureTimeout, TimeUnit perFutureTimeUnit) { waitWithDeadline(futures, overallTimeout, overallTimeUnit, perFutureTimeout, perFutureTimeUnit, IGNORE_ALL_EXCEPT_LOG_MEMBER_LEFT); }
  
  @PrivateApi
  public static void waitWithDeadline(Collection<? extends Future> futures, long overallTimeout, TimeUnit overallTimeUnit, long perFutureTimeout, TimeUnit perFutureTimeUnit, ExceptionHandler exceptionHandler) {
    long overallTimeoutNanos = calculateTimeout(overallTimeout, overallTimeUnit);
    long perFutureTimeoutNanos = calculateTimeout(perFutureTimeout, perFutureTimeUnit);
    long deadline = System.nanoTime() + overallTimeoutNanos;
    for (Future future : futures) {
      try {
        long timeoutNanos = calculateFutureTimeout(perFutureTimeoutNanos, deadline);
        executeWithDeadline(future, timeoutNanos);
      } catch (Throwable e) {
        exceptionHandler.handleException(e);
      } 
    } 
  }
  
  private static <V> V executeWithDeadline(Future<V> future, long timeoutNanos) throws Exception {
    if (timeoutNanos <= 0L) {
      if (future.isDone() || future.isCancelled())
        return (V)retrieveValue(future); 
      throw new TimeoutException();
    } 
    return (V)future.get(timeoutNanos, TimeUnit.NANOSECONDS);
  }
  
  private static <V> V retrieveValue(Future<V> future) throws ExecutionException, InterruptedException {
    if (future instanceof InternalCompletableFuture)
      return (V)((InternalCompletableFuture)future).join(); 
    return (V)future.get();
  }
  
  private static long calculateTimeout(long timeout, TimeUnit timeUnit) {
    timeUnit = (timeUnit == null) ? TimeUnit.SECONDS : timeUnit;
    return timeUnit.toNanos(timeout);
  }
  
  private static long calculateFutureTimeout(long perFutureTimeoutNanos, long deadline) {
    long remainingNanos = deadline - System.nanoTime();
    return Math.min(remainingNanos, perFutureTimeoutNanos);
  }
  
  public static boolean allDone(Collection<Future> futures) {
    for (Future f : futures) {
      if (!f.isDone())
        return false; 
    } 
    return true;
  }
  
  public static void checkAllDone(Collection<Future> futures) throws Exception {
    for (Future f : futures) {
      if (f.isDone())
        f.get(); 
    } 
  }
  
  public static List<Future> getAllDone(Collection<Future> futures) {
    List<Future> doneFutures = new ArrayList<Future>();
    for (Future f : futures) {
      if (f.isDone())
        doneFutures.add(f); 
    } 
    return doneFutures;
  }
}
