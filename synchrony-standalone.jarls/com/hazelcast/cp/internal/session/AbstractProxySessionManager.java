package com.hazelcast.cp.internal.session;

import com.hazelcast.core.ICompletableFuture;
import com.hazelcast.cp.internal.RaftGroupId;
import com.hazelcast.cp.internal.util.Tuple2;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.ThreadUtil;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public abstract class AbstractProxySessionManager {
  public static final long NO_SESSION_ID = -1L;
  
  private final ConcurrentMap<RaftGroupId, Object> mutexes = new ConcurrentHashMap();
  
  private final ConcurrentMap<RaftGroupId, SessionState> sessions = new ConcurrentHashMap();
  
  private final ConcurrentMap<Tuple2<RaftGroupId, Long>, Long> threadIds = new ConcurrentHashMap();
  
  private final AtomicBoolean scheduleHeartbeat = new AtomicBoolean(false);
  
  private final ReadWriteLock lock = new ReentrantReadWriteLock();
  
  private boolean running = true;
  
  protected final void resetInternalState() {
    this.lock.writeLock().lock();
    try {
      this.mutexes.clear();
      this.sessions.clear();
      this.threadIds.clear();
    } finally {
      this.lock.writeLock().unlock();
    } 
  }
  
  public final Long getOrCreateUniqueThreadId(RaftGroupId groupId) {
    this.lock.readLock().lock();
    try {
      Tuple2<RaftGroupId, Long> key = Tuple2.of(groupId, Long.valueOf(ThreadUtil.getThreadId()));
      Long globalThreadId = (Long)this.threadIds.get(key);
      if (globalThreadId != null)
        return globalThreadId; 
      globalThreadId = Long.valueOf(generateThreadId(groupId));
      Long existing = (Long)this.threadIds.putIfAbsent(key, globalThreadId);
      return (existing != null) ? existing : globalThreadId;
    } finally {
      this.lock.readLock().unlock();
    } 
  }
  
  public final long acquireSession(RaftGroupId groupId) { return getOrCreateSession(groupId).acquire(1); }
  
  public final long acquireSession(RaftGroupId groupId, int count) { return getOrCreateSession(groupId).acquire(count); }
  
  public final void releaseSession(RaftGroupId groupId, long id) { releaseSession(groupId, id, 1); }
  
  public final void releaseSession(RaftGroupId groupId, long id, int count) {
    SessionState session = (SessionState)this.sessions.get(groupId);
    if (session != null && SessionState.access$000(session) == id)
      session.release(count); 
  }
  
  public final void invalidateSession(RaftGroupId groupId, long id) {
    SessionState session = (SessionState)this.sessions.get(groupId);
    if (session != null && SessionState.access$000(session) == id)
      this.sessions.remove(groupId, session); 
  }
  
  public final long getSession(RaftGroupId groupId) {
    SessionState session = (SessionState)this.sessions.get(groupId);
    return (session != null) ? SessionState.access$000(session) : -1L;
  }
  
  public Map<RaftGroupId, ICompletableFuture<Object>> shutdown() {
    this.lock.writeLock().lock();
    try {
      Map<RaftGroupId, ICompletableFuture<Object>> futures = new HashMap<RaftGroupId, ICompletableFuture<Object>>();
      for (Map.Entry<RaftGroupId, SessionState> e : this.sessions.entrySet()) {
        RaftGroupId groupId = (RaftGroupId)e.getKey();
        long sessionId = SessionState.access$000((SessionState)e.getValue());
        ICompletableFuture<Object> f = closeSession(groupId, Long.valueOf(sessionId));
        futures.put(groupId, f);
      } 
      this.sessions.clear();
      this.running = false;
      return futures;
    } finally {
      this.lock.writeLock().unlock();
    } 
  }
  
  private SessionState getOrCreateSession(RaftGroupId groupId) {
    this.lock.readLock().lock();
    try {
      Preconditions.checkState(this.running, "Session manager is already shut down!");
      SessionState session = (SessionState)this.sessions.get(groupId);
      if (session == null || !session.isValid())
        synchronized (mutex(groupId)) {
          session = (SessionState)this.sessions.get(groupId);
          if (session == null || !session.isValid())
            session = createNewSession(groupId); 
        }  
      return session;
    } finally {
      this.lock.readLock().unlock();
    } 
  }
  
  private SessionState createNewSession(RaftGroupId groupId) {
    synchronized (mutex(groupId)) {
      SessionResponse response = requestNewSession(groupId);
      SessionState session = new SessionState(response.getSessionId(), response.getTtlMillis());
      this.sessions.put(groupId, session);
      scheduleHeartbeatTask(response.getHeartbeatMillis());
      return session;
    } 
  }
  
  private Object mutex(RaftGroupId groupId) {
    Object mutex = this.mutexes.get(groupId);
    if (mutex != null)
      return mutex; 
    mutex = new Object();
    Object current = this.mutexes.putIfAbsent(groupId, mutex);
    return (current != null) ? current : mutex;
  }
  
  private void scheduleHeartbeatTask(long heartbeatMillis) {
    if (this.scheduleHeartbeat.compareAndSet(false, true))
      scheduleWithRepetition(new HeartbeatTask(this, null), heartbeatMillis, TimeUnit.MILLISECONDS); 
  }
  
  public final long getSessionAcquireCount(RaftGroupId groupId, long sessionId) {
    SessionState session = (SessionState)this.sessions.get(groupId);
    return (session != null && SessionState.access$000(session) == sessionId) ? SessionState.access$200(session).get() : 0L;
  }
  
  protected abstract long generateThreadId(RaftGroupId paramRaftGroupId);
  
  protected abstract SessionResponse requestNewSession(RaftGroupId paramRaftGroupId);
  
  protected abstract ICompletableFuture<Object> heartbeat(RaftGroupId paramRaftGroupId, long paramLong);
  
  protected abstract ICompletableFuture<Object> closeSession(RaftGroupId paramRaftGroupId, Long paramLong);
  
  protected abstract ScheduledFuture<?> scheduleWithRepetition(Runnable paramRunnable, long paramLong, TimeUnit paramTimeUnit);
}
