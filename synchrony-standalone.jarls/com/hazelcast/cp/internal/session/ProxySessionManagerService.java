package com.hazelcast.cp.internal.session;

import com.hazelcast.core.ICompletableFuture;
import com.hazelcast.cp.internal.RaftGroupId;
import com.hazelcast.cp.internal.RaftInvocationManager;
import com.hazelcast.cp.internal.RaftService;
import com.hazelcast.cp.internal.datastructures.spi.RaftManagedService;
import com.hazelcast.cp.internal.session.operation.CloseSessionOp;
import com.hazelcast.cp.internal.session.operation.CreateSessionOp;
import com.hazelcast.cp.internal.session.operation.GenerateThreadIdOp;
import com.hazelcast.cp.internal.session.operation.HeartbeatSessionOp;
import com.hazelcast.cp.session.CPSession;
import com.hazelcast.logging.ILogger;
import com.hazelcast.spi.GracefulShutdownAwareService;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.util.ExceptionUtil;
import java.util.Iterator;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

public class ProxySessionManagerService extends AbstractProxySessionManager implements GracefulShutdownAwareService, RaftManagedService {
  public static final String SERVICE_NAME = "hz:raft:proxySessionManagerService";
  
  private static final long SHUTDOWN_TASK_PERIOD_IN_MILLIS = TimeUnit.SECONDS.toMillis(1L);
  
  private final NodeEngine nodeEngine;
  
  public ProxySessionManagerService(NodeEngine nodeEngine) { this.nodeEngine = nodeEngine; }
  
  protected long generateThreadId(RaftGroupId groupId) { return ((Long)getInvocationManager().invoke(groupId, new GenerateThreadIdOp()).join()).longValue(); }
  
  protected SessionResponse requestNewSession(RaftGroupId groupId) {
    String instanceName = this.nodeEngine.getConfig().getInstanceName();
    CreateSessionOp createSessionOp = new CreateSessionOp(this.nodeEngine.getThisAddress(), instanceName, CPSession.CPSessionOwnerType.SERVER);
    InternalCompletableFuture internalCompletableFuture = getInvocationManager().invoke(groupId, createSessionOp);
    try {
      return (SessionResponse)internalCompletableFuture.get();
    } catch (Exception e) {
      throw ExceptionUtil.rethrow(e);
    } 
  }
  
  protected ICompletableFuture<Object> heartbeat(RaftGroupId groupId, long sessionId) { return getInvocationManager().invoke(groupId, new HeartbeatSessionOp(sessionId)); }
  
  protected ICompletableFuture<Object> closeSession(RaftGroupId groupId, Long sessionId) { return getInvocationManager().invoke(groupId, new CloseSessionOp(sessionId.longValue())); }
  
  protected ScheduledFuture<?> scheduleWithRepetition(Runnable task, long period, TimeUnit unit) { return this.nodeEngine.getExecutionService().scheduleWithRepetition(task, period, period, unit); }
  
  public boolean onShutdown(long timeout, TimeUnit unit) {
    ILogger logger = this.nodeEngine.getLogger(getClass());
    Map<RaftGroupId, ICompletableFuture<Object>> futures = shutdown();
    long remainingTimeNanos = unit.toNanos(timeout);
    boolean successful = true;
    while (remainingTimeNanos > 0L && futures.size() > 0) {
      Iterator<Map.Entry<RaftGroupId, ICompletableFuture<Object>>> it = futures.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry<RaftGroupId, ICompletableFuture<Object>> entry = (Map.Entry)it.next();
        RaftGroupId groupId = (RaftGroupId)entry.getKey();
        ICompletableFuture<Object> f = (ICompletableFuture)entry.getValue();
        if (f.isDone()) {
          it.remove();
          try {
            f.get();
            logger.fine("Session closed for " + groupId);
          } catch (Exception e) {
            logger.warning("Close session failed for " + groupId, e);
            successful = false;
          } 
        } 
      } 
      try {
        Thread.sleep(SHUTDOWN_TASK_PERIOD_IN_MILLIS);
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return false;
      } 
      remainingTimeNanos -= TimeUnit.MILLISECONDS.toNanos(SHUTDOWN_TASK_PERIOD_IN_MILLIS);
    } 
    return (successful && futures.isEmpty());
  }
  
  private RaftInvocationManager getInvocationManager() {
    RaftService raftService = (RaftService)this.nodeEngine.getService("hz:core:raft");
    return raftService.getInvocationManager();
  }
  
  public void init(NodeEngine nodeEngine, Properties properties) {}
  
  public void reset() {}
  
  public void shutdown(boolean terminate) {}
  
  public void onCPSubsystemRestart() { resetInternalState(); }
}
