package com.hazelcast.cp.internal.datastructures.spi.blocking;

import com.hazelcast.cp.internal.datastructures.RaftDataServiceDataSerializerHook;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.IdentifiedDataSerializable;
import com.hazelcast.util.Preconditions;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.UUID;

public class WaitKeyContainer<W extends WaitKey> extends Object implements IdentifiedDataSerializable {
  private W key;
  
  private List<W> keys;
  
  public WaitKeyContainer() {}
  
  WaitKeyContainer(W key) { this.key = key; }
  
  public W key() { return (W)this.key; }
  
  public Collection<W> retries() { return (this.keys != null) ? this.keys.subList(1, this.keys.size()) : Collections.emptyList(); }
  
  public Collection<W> keyAndRetries() {
    if (this.keys == null)
      return Collections.singletonList(this.key); 
    return this.keys;
  }
  
  public int retryCount() { return (this.keys != null) ? (this.keys.size() - 1) : 0; }
  
  public long sessionId() { return this.key.sessionId(); }
  
  public UUID invocationUid() { return this.key.invocationUid(); }
  
  void addRetry(W retry) {
    Preconditions.checkTrue((sessionId() == this.key.sessionId()), this.key + " and its retry: " + retry + " has different session ids!");
    Preconditions.checkTrue(this.key.invocationUid().equals(retry.invocationUid()), this.key + " and its retry: " + retry + " has different invocation uids!");
    if (this.keys == null) {
      this.keys = new ArrayList(3);
      this.keys.add(this.key);
    } 
    this.keys.add(retry);
  }
  
  public int getFactoryId() { return RaftDataServiceDataSerializerHook.F_ID; }
  
  public int getId() { return 1; }
  
  public void writeData(ObjectDataOutput out) throws IOException {
    out.writeObject(this.key);
    Collection<W> retries = retries();
    out.writeInt(retries.size());
    for (Iterator iterator = retries.iterator(); iterator.hasNext(); ) {
      W retry = (W)(WaitKey)iterator.next();
      out.writeObject(retry);
    } 
  }
  
  public void readData(ObjectDataInput in) throws IOException {
    this.key = (WaitKey)in.readObject();
    int retryCount = in.readInt();
    if (retryCount > 0) {
      this.keys = new ArrayList(retryCount + 1);
      this.keys.add(this.key);
      for (int i = 0; i < retryCount; i++) {
        W retry = (W)(WaitKey)in.readObject();
        this.keys.add(retry);
      } 
    } 
  }
  
  public String toString() { return "WaitKeyContainer{key=" + this.key + ", retries=" + retries() + '}'; }
}
