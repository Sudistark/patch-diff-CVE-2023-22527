package com.hazelcast.cp.internal.datastructures.lock.proxy;

import com.hazelcast.cp.CPGroupId;
import com.hazelcast.cp.internal.RaftGroupId;
import com.hazelcast.cp.internal.datastructures.exception.WaitKeyCancelledException;
import com.hazelcast.cp.internal.datastructures.lock.RaftLockOwnershipState;
import com.hazelcast.cp.internal.session.AbstractProxySessionManager;
import com.hazelcast.cp.internal.session.SessionAwareProxy;
import com.hazelcast.cp.internal.session.SessionExpiredException;
import com.hazelcast.cp.lock.FencedLock;
import com.hazelcast.cp.lock.exception.LockAcquireLimitReachedException;
import com.hazelcast.cp.lock.exception.LockOwnershipLostException;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.util.Clock;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.ThreadUtil;
import com.hazelcast.util.UuidUtil;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import javax.annotation.Nonnull;

public abstract class AbstractRaftFencedLockProxy extends SessionAwareProxy implements FencedLock {
  protected final String proxyName;
  
  protected final String objectName;
  
  private final Map<Long, Long> lockedSessionIds = new ConcurrentHashMap();
  
  public AbstractRaftFencedLockProxy(AbstractProxySessionManager sessionManager, RaftGroupId groupId, String proxyName, String objectName) {
    super(sessionManager, groupId);
    this.proxyName = proxyName;
    this.objectName = objectName;
  }
  
  public void lock() { lockAndGetFence(); }
  
  public void lockInterruptibly() {
    long threadId = ThreadUtil.getThreadId();
    UUID invocationUid = UuidUtil.newUnsecureUUID();
    while (true) {
      long sessionId = acquireSession();
      verifyLockedSessionIdIfPresent(threadId, sessionId, true);
      try {
        long fence = ((Long)doLock(sessionId, threadId, invocationUid).get()).longValue();
        if (fence != 0L) {
          this.lockedSessionIds.put(Long.valueOf(threadId), Long.valueOf(sessionId));
          return;
        } 
        throw new LockAcquireLimitReachedException("Lock[" + this.proxyName + "] reentrant lock limit is already reached!");
      } catch (SessionExpiredException e) {
        invalidateSession(sessionId);
        verifyNoLockedSessionIdPresent(threadId);
      } catch (WaitKeyCancelledException e) {
        releaseSession(sessionId);
        throw new IllegalMonitorStateException("Lock[" + this.proxyName + "] not acquired because its wait is cancelled!");
      } catch (Throwable t) {
        releaseSession(sessionId);
        break;
      } 
    } 
    if (t instanceof InterruptedException)
      throw (InterruptedException)t; 
    throw ExceptionUtil.rethrow(t);
  }
  
  public final long lockAndGetFence() {
    long threadId = ThreadUtil.getThreadId();
    UUID invocationUid = UuidUtil.newUnsecureUUID();
    while (true) {
      long sessionId = acquireSession();
      verifyLockedSessionIdIfPresent(threadId, sessionId, true);
      try {
        long fence = ((Long)doLock(sessionId, threadId, invocationUid).join()).longValue();
        if (fence != 0L) {
          this.lockedSessionIds.put(Long.valueOf(threadId), Long.valueOf(sessionId));
          return fence;
        } 
        throw new LockAcquireLimitReachedException("Lock[" + this.proxyName + "] reentrant lock limit is already reached!");
      } catch (SessionExpiredException e) {
        invalidateSession(sessionId);
        verifyNoLockedSessionIdPresent(threadId);
      } catch (WaitKeyCancelledException e) {
        releaseSession(sessionId);
        throw new IllegalMonitorStateException("Lock[" + this.proxyName + "] not acquired because its wait is cancelled!");
      } catch (Throwable t) {
        releaseSession(sessionId);
        throw ExceptionUtil.rethrow(t);
      } 
    } 
  }
  
  public boolean tryLock() { return (tryLockAndGetFence() != 0L); }
  
  public final long tryLockAndGetFence() { return tryLockAndGetFence(0L, TimeUnit.MILLISECONDS); }
  
  public boolean tryLock(long time, @Nonnull TimeUnit unit) { return (tryLockAndGetFence(time, unit) != 0L); }
  
  public final long tryLockAndGetFence(long time, @Nonnull TimeUnit unit) {
    Preconditions.checkNotNull(unit);
    long threadId = ThreadUtil.getThreadId();
    UUID invocationUid = UuidUtil.newUnsecureUUID();
    long timeoutMillis = Math.max(0L, unit.toMillis(time));
    while (true) {
      long start = Clock.currentTimeMillis();
      long sessionId = acquireSession();
      verifyLockedSessionIdIfPresent(threadId, sessionId, true);
      try {
        long fence = ((Long)doTryLock(sessionId, threadId, invocationUid, timeoutMillis).join()).longValue();
        if (fence != 0L) {
          this.lockedSessionIds.put(Long.valueOf(threadId), Long.valueOf(sessionId));
        } else {
          releaseSession(sessionId);
        } 
        return fence;
      } catch (WaitKeyCancelledException e) {
        releaseSession(sessionId);
        return 0L;
      } catch (SessionExpiredException e) {
        invalidateSession(sessionId);
        verifyNoLockedSessionIdPresent(threadId);
        timeoutMillis -= Clock.currentTimeMillis() - start;
        if (timeoutMillis <= 0L)
          return 0L; 
      } catch (Throwable t) {
        releaseSession(sessionId);
        throw ExceptionUtil.rethrow(t);
      } 
    } 
  }
  
  @SuppressFBWarnings({"IMSE_DONT_CATCH_IMSE"})
  public final void unlock() {
    long threadId = ThreadUtil.getThreadId();
    long sessionId = getSession();
    verifyLockedSessionIdIfPresent(threadId, sessionId, false);
    if (sessionId == -1L) {
      this.lockedSessionIds.remove(Long.valueOf(threadId));
      throw newIllegalMonitorStateException();
    } 
    try {
      boolean stillLockedByCurrentThread = ((Boolean)doUnlock(sessionId, threadId, UuidUtil.newUnsecureUUID()).join()).booleanValue();
      if (stillLockedByCurrentThread) {
        this.lockedSessionIds.put(Long.valueOf(threadId), Long.valueOf(sessionId));
      } else {
        this.lockedSessionIds.remove(Long.valueOf(threadId));
      } 
      releaseSession(sessionId);
    } catch (SessionExpiredException e) {
      invalidateSession(sessionId);
      this.lockedSessionIds.remove(Long.valueOf(threadId));
      throw newLockOwnershipLostException(sessionId);
    } catch (IllegalMonitorStateException e) {
      this.lockedSessionIds.remove(Long.valueOf(threadId));
      throw e;
    } 
  }
  
  public final Condition newCondition() { throw new UnsupportedOperationException(); }
  
  public final long getFence() {
    long threadId = ThreadUtil.getThreadId();
    long sessionId = getSession();
    verifyLockedSessionIdIfPresent(threadId, sessionId, false);
    if (sessionId == -1L) {
      this.lockedSessionIds.remove(Long.valueOf(threadId));
      throw newIllegalMonitorStateException();
    } 
    RaftLockOwnershipState ownership = (RaftLockOwnershipState)doGetLockOwnershipState().join();
    if (ownership.isLockedBy(sessionId, threadId)) {
      this.lockedSessionIds.put(Long.valueOf(threadId), Long.valueOf(sessionId));
      return ownership.getFence();
    } 
    verifyNoLockedSessionIdPresent(threadId);
    throw newIllegalMonitorStateException();
  }
  
  public final boolean isLocked() {
    long threadId = ThreadUtil.getThreadId();
    long sessionId = getSession();
    verifyLockedSessionIdIfPresent(threadId, sessionId, false);
    RaftLockOwnershipState ownership = (RaftLockOwnershipState)doGetLockOwnershipState().join();
    if (ownership.isLockedBy(sessionId, threadId)) {
      this.lockedSessionIds.put(Long.valueOf(threadId), Long.valueOf(sessionId));
      return true;
    } 
    verifyNoLockedSessionIdPresent(threadId);
    return ownership.isLocked();
  }
  
  public final boolean isLockedByCurrentThread() {
    long threadId = ThreadUtil.getThreadId();
    long sessionId = getSession();
    verifyLockedSessionIdIfPresent(threadId, sessionId, false);
    RaftLockOwnershipState ownership = (RaftLockOwnershipState)doGetLockOwnershipState().join();
    boolean lockedByCurrentThread = ownership.isLockedBy(sessionId, threadId);
    if (lockedByCurrentThread) {
      this.lockedSessionIds.put(Long.valueOf(threadId), Long.valueOf(sessionId));
    } else {
      verifyNoLockedSessionIdPresent(threadId);
    } 
    return lockedByCurrentThread;
  }
  
  public final int getLockCount() {
    long threadId = ThreadUtil.getThreadId();
    long sessionId = getSession();
    verifyLockedSessionIdIfPresent(threadId, sessionId, false);
    RaftLockOwnershipState ownership = (RaftLockOwnershipState)doGetLockOwnershipState().join();
    if (ownership.isLockedBy(sessionId, threadId)) {
      this.lockedSessionIds.put(Long.valueOf(threadId), Long.valueOf(sessionId));
    } else {
      verifyNoLockedSessionIdPresent(threadId);
    } 
    return ownership.getLockCount();
  }
  
  public void destroy() { this.lockedSessionIds.clear(); }
  
  public final String getName() { return this.proxyName; }
  
  public String getObjectName() { return this.objectName; }
  
  public String getPartitionKey() { throw new UnsupportedOperationException(); }
  
  public String getServiceName() { return "hz:raft:lockService"; }
  
  public Long getLockedSessionId(long threadId) { return (Long)this.lockedSessionIds.get(Long.valueOf(threadId)); }
  
  private void verifyLockedSessionIdIfPresent(long threadId, long sessionId, boolean releaseSession) {
    Long lockedSessionId = (Long)this.lockedSessionIds.get(Long.valueOf(threadId));
    if (lockedSessionId != null && lockedSessionId.longValue() != sessionId) {
      this.lockedSessionIds.remove(Long.valueOf(threadId));
      if (releaseSession)
        releaseSession(sessionId); 
      throw newLockOwnershipLostException(lockedSessionId.longValue());
    } 
  }
  
  private void verifyNoLockedSessionIdPresent(long threadId) {
    Long lockedSessionId = (Long)this.lockedSessionIds.remove(Long.valueOf(threadId));
    if (lockedSessionId != null) {
      this.lockedSessionIds.remove(Long.valueOf(threadId));
      throw newLockOwnershipLostException(lockedSessionId.longValue());
    } 
  }
  
  private IllegalMonitorStateException newIllegalMonitorStateException() { return new IllegalMonitorStateException("Current thread is not owner of the Lock[" + this.proxyName + "]"); }
  
  private LockOwnershipLostException newLockOwnershipLostException(long sessionId) { return new LockOwnershipLostException("Current thread is not owner of the Lock[" + this.proxyName + "] because its Session[" + sessionId + "] is closed by server!"); }
  
  protected abstract InternalCompletableFuture<Long> doLock(long paramLong1, long paramLong2, UUID paramUUID);
  
  protected abstract InternalCompletableFuture<Long> doTryLock(long paramLong1, long paramLong2, UUID paramUUID, long paramLong3);
  
  protected abstract InternalCompletableFuture<Boolean> doUnlock(long paramLong1, long paramLong2, UUID paramUUID);
  
  protected abstract InternalCompletableFuture<RaftLockOwnershipState> doGetLockOwnershipState();
}
