package com.hazelcast.cp.internal.datastructures.lock;

import com.hazelcast.core.DistributedObject;
import com.hazelcast.cp.CPGroupId;
import com.hazelcast.cp.internal.RaftGroupId;
import com.hazelcast.cp.internal.RaftService;
import com.hazelcast.cp.internal.datastructures.exception.WaitKeyCancelledException;
import com.hazelcast.cp.internal.datastructures.lock.proxy.RaftFencedLockProxy;
import com.hazelcast.cp.internal.datastructures.spi.blocking.AbstractBlockingService;
import com.hazelcast.cp.internal.datastructures.spi.blocking.ResourceRegistry;
import com.hazelcast.cp.lock.FencedLock;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.Preconditions;
import java.util.Collection;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class RaftLockService extends AbstractBlockingService<LockInvocationKey, RaftLock, RaftLockRegistry> {
  public static final String SERVICE_NAME = "hz:raft:lockService";
  
  private final ConcurrentMap<String, RaftFencedLockProxy> proxies = new ConcurrentHashMap();
  
  public RaftLockService(NodeEngine nodeEngine) { super(nodeEngine); }
  
  protected void initImpl() { super.initImpl(); }
  
  public AcquireResult acquire(CPGroupId groupId, String name, LockInvocationKey key, long timeoutMs) {
    heartbeatSession(groupId, key.sessionId());
    RaftLockRegistry registry = (RaftLockRegistry)getOrInitRegistry(groupId);
    AcquireResult result = registry.acquire(name, key, timeoutMs);
    if (this.logger.isFineEnabled())
      if (result.status() == AcquireResult.AcquireStatus.SUCCESSFUL) {
        this.logger.fine("Lock[" + name + "] in " + groupId + " acquired by <" + key.endpoint() + ", " + key.invocationUid() + "> at commit index: " + key
            .commitIndex() + ". new lock state: " + registry
            .getLockOwnershipState(name));
      } else if (result.status() == AcquireResult.AcquireStatus.WAIT_KEY_ADDED) {
        this.logger.fine("Lock[" + name + "] in " + groupId + " wait key added for <" + key.endpoint() + ", " + key
            .invocationUid() + "> at commit index: " + key.commitIndex() + ". lock state: " + registry
            .getLockOwnershipState(name));
      } else if (result.status() == AcquireResult.AcquireStatus.FAILED) {
        this.logger.fine("Lock[" + name + "] in " + groupId + " acquire failed for <" + key.endpoint() + ", " + key
            .invocationUid() + "> at commit index: " + key.commitIndex() + ". lock state: " + registry
            .getLockOwnershipState(name));
      }  
    if (result.status() == AcquireResult.AcquireStatus.WAIT_KEY_ADDED)
      scheduleTimeout(groupId, name, key.invocationUid(), timeoutMs); 
    notifyCancelledWaitKeys(groupId, name, result.cancelledWaitKeys());
    return result;
  }
  
  public boolean release(CPGroupId groupId, long commitIndex, String name, LockEndpoint endpoint, UUID invocationUid) {
    heartbeatSession(groupId, endpoint.sessionId());
    RaftLockRegistry registry = getLockRegistryOrFail(groupId, name);
    ReleaseResult result = registry.release(name, endpoint, invocationUid);
    if (this.logger.isFineEnabled())
      if (result.success()) {
        this.logger.fine("Lock[" + name + "] in " + groupId + " released by <" + endpoint + ", " + invocationUid + "> at commit index: " + commitIndex + ". new lock state: " + result
            .ownership());
      } else {
        this.logger.fine("Lock[" + name + "] in " + groupId + " not released by <" + endpoint + ", " + invocationUid + "> at commit index: " + commitIndex + ". lock state: " + registry
            .getLockOwnershipState(name));
      }  
    if (result.success()) {
      notifyWaitKeys(groupId, name, result.completedWaitKeys(), Long.valueOf(result.ownership().getFence()));
      return result.ownership().isLockedBy(endpoint.sessionId(), endpoint.threadId());
    } 
    notifyCancelledWaitKeys(groupId, name, result.completedWaitKeys());
    throw new IllegalMonitorStateException("Current thread is not owner of the lock!");
  }
  
  private void notifyCancelledWaitKeys(CPGroupId groupId, String name, Collection<LockInvocationKey> keys) {
    if (keys.isEmpty())
      return; 
    notifyWaitKeys(groupId, name, keys, new WaitKeyCancelledException());
  }
  
  public RaftLockOwnershipState getLockOwnershipState(CPGroupId groupId, String name) {
    Preconditions.checkNotNull(groupId);
    Preconditions.checkNotNull(name);
    RaftLockRegistry registry = (RaftLockRegistry)getRegistryOrNull(groupId);
    return (registry != null) ? registry.getLockOwnershipState(name) : RaftLockOwnershipState.NOT_LOCKED;
  }
  
  private RaftLockRegistry getLockRegistryOrFail(CPGroupId groupId, String name) {
    Preconditions.checkNotNull(groupId);
    RaftLockRegistry registry = (RaftLockRegistry)getRegistryOrNull(groupId);
    if (registry == null)
      throw new IllegalMonitorStateException("Lock registry of " + groupId + " not found for Lock[" + name + "]"); 
    return registry;
  }
  
  protected RaftLockRegistry createNewRegistry(CPGroupId groupId) { return new RaftLockRegistry(this.nodeEngine.getConfig().getCPSubsystemConfig(), groupId); }
  
  protected Object expiredWaitKeyResponse() { return Long.valueOf(0L); }
  
  protected void onRegistryRestored(RaftLockRegistry registry) { registry.setCpSubsystemConfig(this.nodeEngine.getConfig().getCPSubsystemConfig()); }
  
  protected String serviceName() { return "hz:raft:lockService"; }
  
  public FencedLock createProxy(String proxyName) {
    RaftFencedLockProxy existing, proxy;
    proxyName = RaftService.withoutDefaultGroupName(proxyName);
    do {
      proxy = (RaftFencedLockProxy)this.proxies.get(proxyName);
      if (proxy != null) {
        RaftGroupId raftGroupId = this.raftService.createRaftGroupForProxy(proxyName);
        if (!proxy.getGroupId().equals(raftGroupId)) {
          this.proxies.remove(proxyName, proxy);
        } else {
          return proxy;
        } 
      } 
      proxy = doCreateProxy(proxyName);
      existing = (RaftFencedLockProxy)this.proxies.putIfAbsent(proxyName, proxy);
    } while (existing != null);
    return proxy;
  }
  
  public void onCPSubsystemRestart() {
    super.onCPSubsystemRestart();
    this.proxies.clear();
  }
  
  private RaftFencedLockProxy doCreateProxy(String proxyName) {
    try {
      RaftGroupId groupId = this.raftService.createRaftGroupForProxy(proxyName);
      return new RaftFencedLockProxy(this.nodeEngine, groupId, proxyName, RaftService.getObjectNameForProxy(proxyName));
    } catch (Exception e) {
      throw ExceptionUtil.rethrow(e);
    } 
  }
}
