package com.hazelcast.cp.internal.datastructures.lock.operation;

import com.hazelcast.cp.CPGroupId;
import com.hazelcast.cp.internal.CallerAware;
import com.hazelcast.cp.internal.IndeterminateOperationStateAware;
import com.hazelcast.cp.internal.datastructures.lock.AcquireResult;
import com.hazelcast.cp.internal.datastructures.lock.LockInvocationKey;
import com.hazelcast.cp.internal.datastructures.lock.RaftLockService;
import com.hazelcast.cp.internal.raft.impl.util.PostponedResponse;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import java.io.IOException;
import java.util.UUID;

public class TryLockOp extends AbstractLockOp implements CallerAware, IndeterminateOperationStateAware {
  private long timeoutMs;
  
  private Address callerAddress;
  
  private long callId;
  
  public TryLockOp() {}
  
  public TryLockOp(String name, long sessionId, long threadId, UUID invUid, long timeoutMs) {
    super(name, sessionId, threadId, invUid);
    this.timeoutMs = timeoutMs;
  }
  
  public Object run(CPGroupId groupId, long commitIndex) {
    RaftLockService service = (RaftLockService)getService();
    LockInvocationKey key = new LockInvocationKey(commitIndex, this.invocationUid, this.callerAddress, this.callId, getLockEndpoint());
    AcquireResult result = service.acquire(groupId, this.name, key, this.timeoutMs);
    if (result.status() == AcquireResult.AcquireStatus.WAIT_KEY_ADDED)
      return PostponedResponse.INSTANCE; 
    return Long.valueOf(result.fence());
  }
  
  public void setCaller(Address callerAddress, long callId) {
    this.callerAddress = callerAddress;
    this.callId = callId;
  }
  
  public boolean isRetryableOnIndeterminateOperationState() { return true; }
  
  public void writeData(ObjectDataOutput out) throws IOException {
    super.writeData(out);
    out.writeLong(this.timeoutMs);
    out.writeObject(this.callerAddress);
    out.writeLong(this.callId);
  }
  
  public void readData(ObjectDataInput in) throws IOException {
    super.readData(in);
    this.timeoutMs = in.readLong();
    this.callerAddress = (Address)in.readObject();
    this.callId = in.readLong();
  }
  
  public int getId() { return 7; }
  
  protected void toString(StringBuilder sb) {
    super.toString(sb);
    sb.append(", timeoutMs=").append(this.timeoutMs);
    sb.append(", callerAddress=").append(this.callerAddress);
    sb.append(", callId=").append(this.callId);
  }
}
