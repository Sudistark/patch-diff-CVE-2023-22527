package com.hazelcast.cp.internal.datastructures.semaphore.proxy;

import com.hazelcast.core.ISemaphore;
import com.hazelcast.cp.internal.RaftGroupId;
import com.hazelcast.cp.internal.RaftInvocationManager;
import com.hazelcast.cp.internal.RaftService;
import com.hazelcast.cp.internal.datastructures.semaphore.operation.AcquirePermitsOp;
import com.hazelcast.cp.internal.datastructures.semaphore.operation.AvailablePermitsOp;
import com.hazelcast.cp.internal.datastructures.semaphore.operation.ChangePermitsOp;
import com.hazelcast.cp.internal.datastructures.semaphore.operation.DrainPermitsOp;
import com.hazelcast.cp.internal.datastructures.semaphore.operation.InitSemaphoreOp;
import com.hazelcast.cp.internal.datastructures.semaphore.operation.ReleasePermitsOp;
import com.hazelcast.cp.internal.datastructures.spi.operation.DestroyRaftObjectOp;
import com.hazelcast.cp.internal.session.ProxySessionManagerService;
import com.hazelcast.cp.internal.session.SessionAwareProxy;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.UuidUtil;
import java.util.concurrent.TimeUnit;

public class RaftSessionlessSemaphoreProxy extends SessionAwareProxy implements ISemaphore {
  private final RaftInvocationManager invocationManager;
  
  private final String proxyName;
  
  private final String objectName;
  
  public RaftSessionlessSemaphoreProxy(NodeEngine nodeEngine, RaftGroupId groupId, String proxyName, String objectName) {
    super((ProxySessionManagerService)nodeEngine.getService("hz:raft:proxySessionManagerService"), groupId);
    RaftService service = (RaftService)nodeEngine.getService("hz:core:raft");
    this.invocationManager = service.getInvocationManager();
    this.proxyName = proxyName;
    this.objectName = objectName;
  }
  
  public boolean init(int permits) {
    Preconditions.checkNotNegative(permits, "Permits must be non-negative!");
    return ((Boolean)this.invocationManager.invoke(this.groupId, new InitSemaphoreOp(this.objectName, permits)).join()).booleanValue();
  }
  
  public void acquire() { acquire(1); }
  
  public void acquire(int permits) {
    Preconditions.checkPositive(permits, "Permits must be positive!");
    long clusterWideThreadId = getOrCreateUniqueThreadId(this.groupId).longValue();
    AcquirePermitsOp acquirePermitsOp = new AcquirePermitsOp(this.objectName, -1L, clusterWideThreadId, UuidUtil.newUnsecureUUID(), permits, -1L);
    this.invocationManager.invoke(this.groupId, acquirePermitsOp).join();
  }
  
  public boolean tryAcquire() { return tryAcquire(1); }
  
  public boolean tryAcquire(int permits) { return tryAcquire(permits, 0L, TimeUnit.MILLISECONDS); }
  
  public boolean tryAcquire(long timeout, TimeUnit unit) { return tryAcquire(1, timeout, unit); }
  
  public boolean tryAcquire(int permits, long timeout, TimeUnit unit) {
    Preconditions.checkPositive(permits, "Permits must be positive!");
    long clusterWideThreadId = getOrCreateUniqueThreadId(this.groupId).longValue();
    long timeoutMs = Math.max(0L, unit.toMillis(timeout));
    AcquirePermitsOp acquirePermitsOp = new AcquirePermitsOp(this.objectName, -1L, clusterWideThreadId, UuidUtil.newUnsecureUUID(), permits, timeoutMs);
    return ((Boolean)this.invocationManager.invoke(this.groupId, acquirePermitsOp).join()).booleanValue();
  }
  
  public void release() { release(1); }
  
  public void release(int permits) {
    Preconditions.checkPositive(permits, "Permits must be positive!");
    long clusterWideThreadId = getOrCreateUniqueThreadId(this.groupId).longValue();
    ReleasePermitsOp releasePermitsOp = new ReleasePermitsOp(this.objectName, -1L, clusterWideThreadId, UuidUtil.newUnsecureUUID(), permits);
    this.invocationManager.invoke(this.groupId, releasePermitsOp).join();
  }
  
  public int availablePermits() { return ((Integer)this.invocationManager.invoke(this.groupId, new AvailablePermitsOp(this.objectName)).join()).intValue(); }
  
  public int drainPermits() {
    long clusterWideThreadId = getOrCreateUniqueThreadId(this.groupId).longValue();
    DrainPermitsOp drainPermitsOp = new DrainPermitsOp(this.objectName, -1L, clusterWideThreadId, UuidUtil.newUnsecureUUID());
    return ((Integer)this.invocationManager.invoke(this.groupId, drainPermitsOp).join()).intValue();
  }
  
  public void reducePermits(int reduction) {
    Preconditions.checkNotNegative(reduction, "Reduction must be non-negative!");
    if (reduction == 0)
      return; 
    long clusterWideThreadId = getOrCreateUniqueThreadId(this.groupId).longValue();
    ChangePermitsOp changePermitsOp = new ChangePermitsOp(this.objectName, -1L, clusterWideThreadId, UuidUtil.newUnsecureUUID(), -reduction);
    this.invocationManager.invoke(this.groupId, changePermitsOp).join();
  }
  
  public void increasePermits(int increase) {
    Preconditions.checkNotNegative(increase, "Increase must be non-negative!");
    if (increase == 0)
      return; 
    long clusterWideThreadId = getOrCreateUniqueThreadId(this.groupId).longValue();
    ChangePermitsOp changePermitsOp = new ChangePermitsOp(this.objectName, -1L, clusterWideThreadId, UuidUtil.newUnsecureUUID(), increase);
    this.invocationManager.invoke(this.groupId, changePermitsOp).join();
  }
  
  public String getName() { return this.proxyName; }
  
  public String getPartitionKey() { throw new UnsupportedOperationException(); }
  
  public String getServiceName() { return "hz:raft:semaphoreService"; }
  
  public void destroy() { this.invocationManager.invoke(this.groupId, new DestroyRaftObjectOp(getServiceName(), this.objectName)).join(); }
}
