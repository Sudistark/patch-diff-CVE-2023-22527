package com.hazelcast.cp.internal.raft.impl;

import com.hazelcast.config.cp.RaftAlgorithmConfig;
import com.hazelcast.core.Endpoint;
import com.hazelcast.core.ICompletableFuture;
import com.hazelcast.cp.CPGroupId;
import com.hazelcast.cp.exception.LeaderDemotedException;
import com.hazelcast.cp.exception.StaleAppendRequestException;
import com.hazelcast.cp.internal.raft.MembershipChangeMode;
import com.hazelcast.cp.internal.raft.QueryPolicy;
import com.hazelcast.cp.internal.raft.impl.command.UpdateRaftGroupMembersCmd;
import com.hazelcast.cp.internal.raft.impl.dto.AppendFailureResponse;
import com.hazelcast.cp.internal.raft.impl.dto.AppendRequest;
import com.hazelcast.cp.internal.raft.impl.dto.AppendSuccessResponse;
import com.hazelcast.cp.internal.raft.impl.dto.InstallSnapshot;
import com.hazelcast.cp.internal.raft.impl.dto.PreVoteRequest;
import com.hazelcast.cp.internal.raft.impl.dto.PreVoteResponse;
import com.hazelcast.cp.internal.raft.impl.dto.VoteRequest;
import com.hazelcast.cp.internal.raft.impl.dto.VoteResponse;
import com.hazelcast.cp.internal.raft.impl.handler.AppendFailureResponseHandlerTask;
import com.hazelcast.cp.internal.raft.impl.handler.AppendRequestHandlerTask;
import com.hazelcast.cp.internal.raft.impl.handler.AppendSuccessResponseHandlerTask;
import com.hazelcast.cp.internal.raft.impl.handler.InstallSnapshotHandlerTask;
import com.hazelcast.cp.internal.raft.impl.handler.PreVoteRequestHandlerTask;
import com.hazelcast.cp.internal.raft.impl.handler.PreVoteResponseHandlerTask;
import com.hazelcast.cp.internal.raft.impl.handler.VoteRequestHandlerTask;
import com.hazelcast.cp.internal.raft.impl.handler.VoteResponseHandlerTask;
import com.hazelcast.cp.internal.raft.impl.log.LogEntry;
import com.hazelcast.cp.internal.raft.impl.log.RaftLog;
import com.hazelcast.cp.internal.raft.impl.log.SnapshotEntry;
import com.hazelcast.cp.internal.raft.impl.state.FollowerState;
import com.hazelcast.cp.internal.raft.impl.state.LeaderState;
import com.hazelcast.cp.internal.raft.impl.state.RaftGroupMembers;
import com.hazelcast.cp.internal.raft.impl.state.RaftState;
import com.hazelcast.cp.internal.raft.impl.task.MembershipChangeTask;
import com.hazelcast.cp.internal.raft.impl.task.PreVoteTask;
import com.hazelcast.cp.internal.raft.impl.task.QueryTask;
import com.hazelcast.cp.internal.raft.impl.task.ReplicateTask;
import com.hazelcast.cp.internal.raft.impl.util.PostponedResponse;
import com.hazelcast.internal.util.SimpleCompletableFuture;
import com.hazelcast.logging.ILogger;
import com.hazelcast.util.Clock;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.RandomPicker;
import com.hazelcast.util.collection.Long2ObjectHashMap;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.concurrent.TimeUnit;

public class RaftNodeImpl implements RaftNode {
  private static final int LEADER_ELECTION_TIMEOUT_RANGE = 1000;
  
  private static final long RAFT_NODE_INIT_DELAY_MILLIS = 500L;
  
  private static final float RATIO_TO_KEEP_LOGS_AFTER_SNAPSHOT = 0.1F;
  
  private final CPGroupId groupId;
  
  private final ILogger logger;
  
  private final RaftState state;
  
  private final RaftIntegration raftIntegration;
  
  private final Endpoint localMember;
  
  private final Long2ObjectHashMap<SimpleCompletableFuture> futures;
  
  private final long heartbeatPeriodInMillis;
  
  private final int leaderElectionTimeout;
  
  private final int maxUncommittedEntryCount;
  
  private final int appendRequestMaxEntryCount;
  
  private final int commitIndexAdvanceCountToSnapshot;
  
  private final int maxMissedLeaderHeartbeatCount;
  
  private final long appendRequestBackoffTimeoutInMillis;
  
  private final int maxNumberOfLogsToKeepAfterSnapshot;
  
  private final Runnable appendRequestBackoffResetTask;
  
  private long lastAppendEntriesTimestamp;
  
  private boolean appendRequestBackoffResetTaskScheduled;
  
  public RaftNodeImpl(CPGroupId groupId, Endpoint localMember, Collection<Endpoint> members, RaftAlgorithmConfig raftAlgorithmConfig, RaftIntegration raftIntegration) {
    this.futures = new Long2ObjectHashMap();
    this.status = RaftNodeStatus.ACTIVE;
    Preconditions.checkNotNull(groupId);
    Preconditions.checkNotNull(localMember);
    Preconditions.checkNotNull(members);
    this.groupId = groupId;
    this.raftIntegration = raftIntegration;
    this.localMember = localMember;
    this.maxUncommittedEntryCount = raftAlgorithmConfig.getUncommittedEntryCountToRejectNewAppends();
    this.appendRequestMaxEntryCount = raftAlgorithmConfig.getAppendRequestMaxEntryCount();
    this.commitIndexAdvanceCountToSnapshot = raftAlgorithmConfig.getCommitIndexAdvanceCountToSnapshot();
    this.leaderElectionTimeout = (int)raftAlgorithmConfig.getLeaderElectionTimeoutInMillis();
    this.heartbeatPeriodInMillis = raftAlgorithmConfig.getLeaderHeartbeatPeriodInMillis();
    this.maxMissedLeaderHeartbeatCount = raftAlgorithmConfig.getMaxMissedLeaderHeartbeatCount();
    this.maxNumberOfLogsToKeepAfterSnapshot = (int)(this.commitIndexAdvanceCountToSnapshot * 0.1F);
    this.appendRequestBackoffTimeoutInMillis = raftAlgorithmConfig.getAppendRequestBackoffTimeoutInMillis();
    int logCapacity = this.commitIndexAdvanceCountToSnapshot + this.maxUncommittedEntryCount + this.maxNumberOfLogsToKeepAfterSnapshot;
    this.state = new RaftState(groupId, localMember, members, logCapacity);
    this.logger = getLogger(RaftNode.class);
    this.appendRequestBackoffResetTask = new AppendRequestBackoffResetTask(this);
  }
  
  public ILogger getLogger(Class clazz) {
    String name = this.state.name();
    return this.raftIntegration.getLogger(clazz.getName() + "(" + name + ")");
  }
  
  public CPGroupId getGroupId() { return this.groupId; }
  
  public Endpoint getLocalMember() { return this.localMember; }
  
  public Endpoint getLeader() { return this.state.leader(); }
  
  public RaftNodeStatus getStatus() { return this.status; }
  
  public Collection<Endpoint> getInitialMembers() { return this.state.initialMembers(); }
  
  public Collection<Endpoint> getCommittedMembers() { return this.state.committedGroupMembers().members(); }
  
  public Collection<Endpoint> getAppliedMembers() { return this.state.lastGroupMembers().members(); }
  
  public void forceSetTerminatedStatus() { execute(new Object(this)); }
  
  public void start() {
    if (!this.raftIntegration.isReady()) {
      this.raftIntegration.schedule(new Object(this), 500L, TimeUnit.MILLISECONDS);
      return;
    } 
    if (this.logger.isFineEnabled())
      this.logger.fine("Starting raft node: " + this.localMember + " for " + this.groupId + " with " + this.state
          .memberCount() + " members: " + this.state.members()); 
    this.raftIntegration.execute(new PreVoteTask(this, 0));
    scheduleLeaderFailureDetection();
  }
  
  public void handlePreVoteRequest(PreVoteRequest request) { execute(new PreVoteRequestHandlerTask(this, request)); }
  
  public void handlePreVoteResponse(PreVoteResponse response) { execute(new PreVoteResponseHandlerTask(this, response)); }
  
  public void handleVoteRequest(VoteRequest request) { execute(new VoteRequestHandlerTask(this, request)); }
  
  public void handleVoteResponse(VoteResponse response) { execute(new VoteResponseHandlerTask(this, response)); }
  
  public void handleAppendRequest(AppendRequest request) { execute(new AppendRequestHandlerTask(this, request)); }
  
  public void handleAppendResponse(AppendSuccessResponse response) { execute(new AppendSuccessResponseHandlerTask(this, response)); }
  
  public void handleAppendResponse(AppendFailureResponse response) { execute(new AppendFailureResponseHandlerTask(this, response)); }
  
  public void handleInstallSnapshot(InstallSnapshot request) { execute(new InstallSnapshotHandlerTask(this, request)); }
  
  public ICompletableFuture replicate(Object operation) {
    SimpleCompletableFuture resultFuture = this.raftIntegration.newCompletableFuture();
    this.raftIntegration.execute(new ReplicateTask(this, operation, resultFuture));
    return resultFuture;
  }
  
  public ICompletableFuture replicateMembershipChange(Endpoint member, MembershipChangeMode mode) {
    SimpleCompletableFuture resultFuture = this.raftIntegration.newCompletableFuture();
    this.raftIntegration.execute(new MembershipChangeTask(this, resultFuture, member, mode));
    return resultFuture;
  }
  
  public ICompletableFuture replicateMembershipChange(Endpoint member, MembershipChangeMode mode, long groupMembersCommitIndex) {
    SimpleCompletableFuture resultFuture = this.raftIntegration.newCompletableFuture();
    this.raftIntegration.execute(new MembershipChangeTask(this, resultFuture, member, mode, Long.valueOf(groupMembersCommitIndex)));
    return resultFuture;
  }
  
  public ICompletableFuture query(Object operation, QueryPolicy queryPolicy) {
    SimpleCompletableFuture resultFuture = this.raftIntegration.newCompletableFuture();
    this.raftIntegration.execute(new QueryTask(this, operation, queryPolicy, resultFuture));
    return resultFuture;
  }
  
  public boolean isTerminatedOrSteppedDown() { return (this.status == RaftNodeStatus.TERMINATED || this.status == RaftNodeStatus.STEPPED_DOWN); }
  
  public void setStatus(RaftNodeStatus newStatus) {
    if (this.status == RaftNodeStatus.TERMINATED || this.status == RaftNodeStatus.STEPPED_DOWN)
      throw new IllegalStateException("Cannot set status: " + newStatus + " since already " + this.status); 
    RaftNodeStatus prevStatus = this.status;
    this.status = newStatus;
    if (prevStatus != newStatus)
      if (newStatus == RaftNodeStatus.ACTIVE) {
        this.logger.info("Status is set to: " + newStatus);
      } else {
        this.logger.warning("Status is set to: " + newStatus);
      }  
    this.raftIntegration.onNodeStatusChange(newStatus);
  }
  
  public long getLeaderElectionTimeoutInMillis() { return RandomPicker.getInt(this.leaderElectionTimeout, this.leaderElectionTimeout + 1000); }
  
  public Object getAppendedEntryOnLeaderElection() { return this.raftIntegration.getAppendedEntryOnLeaderElection(); }
  
  public boolean canReplicateNewEntry(Object operation) {
    if (isTerminatedOrSteppedDown())
      return false; 
    RaftLog log = this.state.log();
    long lastLogIndex = log.lastLogOrSnapshotIndex();
    long commitIndex = this.state.commitIndex();
    if (lastLogIndex - commitIndex >= this.maxUncommittedEntryCount)
      return false; 
    if (this.status == RaftNodeStatus.TERMINATING)
      return false; 
    if (this.status == RaftNodeStatus.UPDATING_GROUP_MEMBER_LIST)
      return (this.state.lastGroupMembers().isKnownMember(getLocalMember()) && !(operation instanceof com.hazelcast.cp.internal.raft.command.RaftGroupCmd)); 
    if (operation instanceof UpdateRaftGroupMembersCmd) {
      SnapshotEntry snapshotEntry = (commitIndex == log.snapshotIndex()) ? log.snapshot() : log.getLogEntry(commitIndex);
      assert snapshotEntry != null;
      return (snapshotEntry.term() == this.state.term());
    } 
    return true;
  }
  
  private void scheduleLeaderFailureDetection() { schedule(new LeaderFailureDetectionTask(this), getLeaderElectionTimeoutInMillis()); }
  
  public void scheduleHeartbeat() {
    broadcastAppendRequest();
    schedule(new HeartbeatTask(this), this.heartbeatPeriodInMillis);
  }
  
  public void send(PreVoteRequest request, Endpoint target) { this.raftIntegration.send(request, target); }
  
  public void send(PreVoteResponse response, Endpoint target) { this.raftIntegration.send(response, target); }
  
  public void send(VoteRequest request, Endpoint target) { this.raftIntegration.send(request, target); }
  
  public void send(VoteResponse response, Endpoint target) { this.raftIntegration.send(response, target); }
  
  public void send(AppendRequest request, Endpoint target) { this.raftIntegration.send(request, target); }
  
  public void send(AppendSuccessResponse response, Endpoint target) { this.raftIntegration.send(response, target); }
  
  public void send(AppendFailureResponse response, Endpoint target) { this.raftIntegration.send(response, target); }
  
  public void broadcastAppendRequest() {
    for (Endpoint follower : this.state.remoteMembers())
      sendAppendRequest(follower); 
    updateLastAppendEntriesTimestamp();
  }
  
  public void sendAppendRequest(Endpoint follower) {
    LogEntry[] entries;
    if (!this.raftIntegration.isReachable(follower))
      return; 
    RaftLog raftLog = this.state.log();
    LeaderState leaderState = this.state.leaderState();
    FollowerState followerState = leaderState.getFollowerState(follower);
    if (followerState.isAppendRequestBackoffSet())
      return; 
    long nextIndex = followerState.nextIndex();
    if (nextIndex <= raftLog.snapshotIndex() && (
      !raftLog.containsLogEntry(nextIndex) || (nextIndex > 1L && !raftLog.containsLogEntry(nextIndex - 1L)))) {
      InstallSnapshot installSnapshot = new InstallSnapshot(this.localMember, this.state.term(), raftLog.snapshot());
      if (this.logger.isFineEnabled())
        this.logger.fine("Sending " + installSnapshot + " to " + follower + " since next index: " + nextIndex + " <= snapshot index: " + raftLog
            .snapshotIndex()); 
      followerState.setMaxAppendRequestBackoff();
      scheduleAppendAckResetTask();
      this.raftIntegration.send(installSnapshot, follower);
      return;
    } 
    int prevEntryTerm = 0;
    long prevEntryIndex = 0L;
    boolean setAppendRequestBackoff = true;
    if (nextIndex > 1L) {
      prevEntryIndex = nextIndex - 1L;
      SnapshotEntry snapshotEntry = (raftLog.snapshotIndex() == prevEntryIndex) ? raftLog.snapshot() : raftLog.getLogEntry(prevEntryIndex);
      assert snapshotEntry != null : "Prev entry index: " + prevEntryIndex + ", snapshot: " + raftLog.snapshotIndex();
      prevEntryTerm = snapshotEntry.term();
      long matchIndex = followerState.matchIndex();
      if (matchIndex == 0L) {
        entries = new LogEntry[0];
      } else if (nextIndex <= raftLog.lastLogOrSnapshotIndex()) {
        long end = Math.min(nextIndex + this.appendRequestMaxEntryCount, raftLog.lastLogOrSnapshotIndex());
        entries = raftLog.getEntriesBetween(nextIndex, end);
      } else {
        entries = new LogEntry[0];
        setAppendRequestBackoff = false;
      } 
    } else if (nextIndex == 1L && raftLog.lastLogOrSnapshotIndex() > 0L) {
      long end = Math.min(nextIndex + this.appendRequestMaxEntryCount, raftLog.lastLogOrSnapshotIndex());
      entries = raftLog.getEntriesBetween(nextIndex, end);
    } else {
      entries = new LogEntry[0];
      setAppendRequestBackoff = false;
    } 
    AppendRequest request = new AppendRequest(getLocalMember(), this.state.term(), prevEntryTerm, prevEntryIndex, this.state.commitIndex(), entries);
    if (this.logger.isFineEnabled())
      this.logger.fine("Sending " + request + " to " + follower + " with next index: " + nextIndex); 
    if (setAppendRequestBackoff) {
      followerState.setAppendRequestBackoff();
      scheduleAppendAckResetTask();
    } 
    send(request, follower);
  }
  
  public void applyLogEntries() {
    long commitIndex = this.state.commitIndex();
    long lastApplied = this.state.lastApplied();
    if (commitIndex == lastApplied)
      return; 
    assert commitIndex > lastApplied : "commit index: " + commitIndex + " cannot be smaller than last applied: " + lastApplied;
    RaftLog raftLog = this.state.log();
    long idx;
    for (idx = this.state.lastApplied() + 1L; idx <= commitIndex; idx++) {
      LogEntry entry = raftLog.getLogEntry(idx);
      if (entry == null) {
        String msg = "Failed to get log entry at index: " + idx;
        this.logger.severe(msg);
        throw new AssertionError(msg);
      } 
      applyLogEntry(entry);
      this.state.lastApplied(idx);
    } 
    assert this.status != RaftNodeStatus.TERMINATED || commitIndex == raftLog.lastLogOrSnapshotIndex() : "commit index: " + commitIndex + " must be equal to " + raftLog
      .lastLogOrSnapshotIndex() + " on termination.";
    if (this.state.role() == RaftRole.LEADER || this.state.role() == RaftRole.FOLLOWER)
      takeSnapshotIfCommitIndexAdvanced(); 
  }
  
  private void applyLogEntry(LogEntry entry) {
    if (this.logger.isFineEnabled())
      this.logger.fine("Processing " + entry); 
    Object response = null;
    Object operation = entry.operation();
    if (operation instanceof com.hazelcast.cp.internal.raft.command.RaftGroupCmd) {
      if (operation instanceof com.hazelcast.cp.internal.raft.command.DestroyRaftGroupCmd) {
        setStatus(RaftNodeStatus.TERMINATED);
      } else if (operation instanceof UpdateRaftGroupMembersCmd) {
        if (this.state.lastGroupMembers().index() < entry.index()) {
          setStatus(RaftNodeStatus.UPDATING_GROUP_MEMBER_LIST);
          UpdateRaftGroupMembersCmd op = (UpdateRaftGroupMembersCmd)operation;
          updateGroupMembers(entry.index(), op.getMembers());
        } 
        assert this.status == RaftNodeStatus.UPDATING_GROUP_MEMBER_LIST : "STATUS: " + this.status;
        assert this.state.lastGroupMembers().index() == entry.index();
        this.state.commitGroupMembers();
        UpdateRaftGroupMembersCmd cmd = (UpdateRaftGroupMembersCmd)operation;
        if (cmd.getMember().equals(this.localMember) && cmd.getMode() == MembershipChangeMode.REMOVE) {
          setStatus(RaftNodeStatus.STEPPED_DOWN);
          invalidateFuturesUntil(entry.index() - 1L, new LeaderDemotedException(this.localMember, null));
        } else {
          setStatus(RaftNodeStatus.ACTIVE);
        } 
        response = Long.valueOf(entry.index());
      } else {
        response = new IllegalArgumentException("Invalid command: " + operation);
      } 
    } else {
      response = this.raftIntegration.runOperation(operation, entry.index());
    } 
    if (response == PostponedResponse.INSTANCE)
      return; 
    completeFuture(entry.index(), response);
  }
  
  public void updateLastAppendEntriesTimestamp() { this.lastAppendEntriesTimestamp = Clock.currentTimeMillis(); }
  
  public long lastAppendEntriesTimestamp() { return this.lastAppendEntriesTimestamp; }
  
  public RaftState state() { return this.state; }
  
  public void runQueryOperation(Object operation, SimpleCompletableFuture resultFuture) {
    long commitIndex = this.state.commitIndex();
    Object result = this.raftIntegration.runOperation(operation, commitIndex);
    resultFuture.setResult(result);
  }
  
  public void execute(Runnable task) { this.raftIntegration.execute(task); }
  
  public void schedule(Runnable task, long delayInMillis) {
    if (isTerminatedOrSteppedDown())
      return; 
    this.raftIntegration.schedule(task, delayInMillis, TimeUnit.MILLISECONDS);
  }
  
  public void registerFuture(long entryIndex, SimpleCompletableFuture future) {
    SimpleCompletableFuture f = (SimpleCompletableFuture)this.futures.put(entryIndex, future);
    assert f == null : "Future object is already registered for entry index: " + entryIndex;
  }
  
  public void completeFuture(long entryIndex, Object response) {
    SimpleCompletableFuture f = (SimpleCompletableFuture)this.futures.remove(entryIndex);
    if (f != null)
      f.setResult(response); 
  }
  
  public void invalidateFuturesFrom(long entryIndex) {
    int count = 0;
    Iterator<Map.Entry<Long, SimpleCompletableFuture>> iterator = this.futures.entrySet().iterator();
    while (iterator.hasNext()) {
      Map.Entry<Long, SimpleCompletableFuture> entry = (Map.Entry)iterator.next();
      long index = ((Long)entry.getKey()).longValue();
      if (index >= entryIndex) {
        ((SimpleCompletableFuture)entry.getValue()).setResult(new LeaderDemotedException(this.localMember, this.state.leader()));
        iterator.remove();
        count++;
      } 
    } 
    if (count > 0)
      this.logger.warning("Invalidated " + count + " futures from log index: " + entryIndex); 
  }
  
  private void invalidateFuturesUntil(long entryIndex, Object response) {
    int count = 0;
    Iterator<Map.Entry<Long, SimpleCompletableFuture>> iterator = this.futures.entrySet().iterator();
    while (iterator.hasNext()) {
      Map.Entry<Long, SimpleCompletableFuture> entry = (Map.Entry)iterator.next();
      long index = ((Long)entry.getKey()).longValue();
      if (index <= entryIndex) {
        ((SimpleCompletableFuture)entry.getValue()).setResult(response);
        iterator.remove();
        count++;
      } 
    } 
    if (count > 0)
      this.logger.warning("Invalidated " + count + " futures until log index: " + entryIndex); 
  }
  
  private void takeSnapshotIfCommitIndexAdvanced() {
    long commitIndex = this.state.commitIndex();
    if (commitIndex - this.state.log().snapshotIndex() < this.commitIndexAdvanceCountToSnapshot)
      return; 
    if (isTerminatedOrSteppedDown())
      return; 
    RaftLog log = this.state.log();
    Object snapshot = this.raftIntegration.takeSnapshot(commitIndex);
    if (snapshot instanceof Throwable) {
      Throwable t = (Throwable)snapshot;
      this.logger.severe("Could not take snapshot at commit index: " + commitIndex, t);
      return;
    } 
    int snapshotTerm = log.getLogEntry(commitIndex).term();
    RaftGroupMembers members = this.state.committedGroupMembers();
    SnapshotEntry snapshotEntry = new SnapshotEntry(snapshotTerm, commitIndex, snapshot, members.index(), members.members());
    long highestLogIndexToTruncate = commitIndex - this.maxNumberOfLogsToKeepAfterSnapshot;
    LeaderState leaderState = this.state.leaderState();
    if (leaderState != null) {
      long[] matchIndices = leaderState.matchIndices();
      boolean allMatchIndicesKnown = true;
      for (int i = 0; i < matchIndices.length - 1; i++)
        allMatchIndicesKnown &= ((matchIndices[i] > 0L)); 
      if (allMatchIndicesKnown) {
        highestLogIndexToTruncate = commitIndex;
        for (long matchIndex : matchIndices) {
          if (matchIndex > commitIndex - this.maxNumberOfLogsToKeepAfterSnapshot && matchIndex < highestLogIndexToTruncate)
            highestLogIndexToTruncate = matchIndex; 
        } 
        highestLogIndexToTruncate--;
      } 
    } 
    int truncatedEntryCount = log.setSnapshot(snapshotEntry, highestLogIndexToTruncate);
    if (this.logger.isFineEnabled())
      this.logger.fine(snapshotEntry + " is taken, " + truncatedEntryCount + " entries are truncated."); 
  }
  
  public boolean installSnapshot(SnapshotEntry snapshot) {
    long commitIndex = this.state.commitIndex();
    if (commitIndex > snapshot.index()) {
      this.logger.info("Ignored stale " + snapshot + ", commit index at: " + commitIndex);
      return false;
    } 
    if (commitIndex == snapshot.index()) {
      this.logger.info("Ignored " + snapshot + " since commit index is same.");
      return true;
    } 
    this.state.commitIndex(snapshot.index());
    int truncated = this.state.log().setSnapshot(snapshot);
    if (truncated > 0)
      this.logger.info(truncated + " entries are truncated to install " + snapshot); 
    this.raftIntegration.restoreSnapshot(snapshot.operation(), snapshot.index());
    setStatus(RaftNodeStatus.ACTIVE);
    this.state.restoreGroupMembers(snapshot.groupMembersLogIndex(), snapshot.groupMembers());
    printMemberState();
    this.state.lastApplied(snapshot.index());
    invalidateFuturesUntil(snapshot.index(), new StaleAppendRequestException(this.state.leader()));
    this.logger.info(snapshot + " is installed.");
    return true;
  }
  
  public void printMemberState() {
    CPGroupId groupId = this.state.groupId();
    StringBuilder sb = (new StringBuilder("\n\nCP Group Members {")).append("groupId: ").append(groupId.name()).append("(").append(groupId.id()).append(")").append(", size:").append(this.state.memberCount()).append(", term:").append(this.state.term()).append(", logIndex:").append(this.state.membersLogIndex()).append("} [");
    for (Endpoint member : this.state.members()) {
      sb.append("\n\t").append(member);
      if (this.localMember.equals(member)) {
        sb.append(" - ").append(this.state.role()).append(" this");
        continue;
      } 
      if (member.equals(this.state.leader()))
        sb.append(" - ").append(RaftRole.LEADER); 
    } 
    sb.append("\n]\n");
    this.logger.info(sb.toString());
  }
  
  public void updateGroupMembers(long logIndex, Collection<Endpoint> members) {
    this.state.updateGroupMembers(logIndex, members);
    printMemberState();
  }
  
  public void resetGroupMembers() {
    this.state.resetGroupMembers();
    printMemberState();
  }
  
  private void scheduleAppendAckResetTask() {
    if (this.appendRequestBackoffResetTaskScheduled)
      return; 
    this.appendRequestBackoffResetTaskScheduled = true;
    schedule(this.appendRequestBackoffResetTask, this.appendRequestBackoffTimeoutInMillis);
  }
  
  private boolean isHeartbeatTimedOut(long timestamp) {
    long missedHeartbeatThreshold = this.maxMissedLeaderHeartbeatCount * this.heartbeatPeriodInMillis;
    return (timestamp + missedHeartbeatThreshold < Clock.currentTimeMillis());
  }
}
