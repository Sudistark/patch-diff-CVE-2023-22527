package instaparse.gll;

import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.Numbers;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;

public final class Segment implements CharSequence, IType {
  public final Object s;
  
  public final int offset;
  
  public final int count;
  
  public Segment(Object paramObject, int paramInt1, int paramInt2) { this.s = paramObject;
    this.offset = paramInt1;
    this.count = paramInt2; }
  
  public static IPersistentVector getBasis() { return Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "CharSequence") })), ((IObj)Symbol.intern(null, "offset")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "int") })), ((IObj)Symbol.intern(null, "count")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "int") }))); }
  
  public String toString() {
    Object G__19587 = new StringBuilder(this.count);
    ((StringBuilder)G__19587)







      
      .append((CharSequence)this.s, this.offset, RT.intCast(Numbers.add(this.offset, this.count)));
    G__19587 = null;
    return (String)((StringBuilder)G__19587).toString();
  }
  
  public char charAt(int index) {
    this = null;
    return ((CharSequence)this.s).charAt(RT.intCast(Numbers.add(this.offset, index)));
  }
  
  public CharSequence subSequence(int start, int end) {
    return (CharSequence)new Segment(this.s, RT.intCast(Numbers.add(this.offset, start)), RT.intCast(Numbers.minus(end, start)));
  }
  
  public int length() { return this.count; }
  
  static  {
  
  }
}
