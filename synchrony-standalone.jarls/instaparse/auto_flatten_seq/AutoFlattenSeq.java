package instaparse.auto_flatten_seq;

import clojure.lang.APersistentVector;
import clojure.lang.Counted;
import clojure.lang.IFn;
import clojure.lang.IHashEq;
import clojure.lang.ILookup;
import clojure.lang.IMeta;
import clojure.lang.IObj;
import clojure.lang.IPersistentCollection;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.ISeq;
import clojure.lang.IType;
import clojure.lang.Keyword;
import clojure.lang.Numbers;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Seqable;
import clojure.lang.Sequential;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Util;
import clojure.lang.Var;
import java.util.Collection;
import java.util.Iterator;

public final class AutoFlattenSeq implements ISeq, ConjFlat, Collection, ILookup, IHashEq, IObj, IMeta, Counted, Sequential, Seqable, IType {
  public final Object v;
  
  public final int premix_hashcode;
  
  public final int hashcode;
  
  public final int cnt;
  
  public final boolean dirty;
  
  Object cached_seq;
  
  public static final Var const__1 = (Var)RT.var("clojure.core", "hash");
  
  public static final Var const__5 = (Var)RT.var("clojure.core", "seq");
  
  public static final Var const__6 = (Var)RT.var("clojure.core", "with-meta");
  
  public static final Var const__7 = (Var)RT.var("instaparse.auto-flatten-seq", "EMPTY");
  
  public static final Var const__8 = (Var)RT.var("clojure.core", "meta");
  
  public static final Var const__9 = (Var)RT.var("clojure.core", "first");
  
  public static final Var const__10 = (Var)RT.var("clojure.core", "next");
  
  public static final Var const__11 = (Var)RT.var("clojure.core", "rest");
  
  public static final Var const__12 = (Var)RT.var("clojure.core", "cons");
  
  public static final Var const__15 = (Var)RT.var("instaparse.auto-flatten-seq", "flat-seq");
  
  public static final Var const__17 = (Var)RT.var("instaparse.auto-flatten-seq", "afs?");
  
  public static final Var const__21 = (Var)RT.var("instaparse.auto-flatten-seq", "hash-cat");
  
  public static final Var const__23 = (Var)RT.var("clojure.core", "into");
  
  public static final Var const__25 = (Var)RT.var("clojure.core", "mix-collection-hash");
  
  public static final Keyword const__26 = (Keyword)RT.keyword(null, "else");
  
  public static final Var const__27 = (Var)RT.var("clojure.core", "conj");
  
  public AutoFlattenSeq(Object paramObject1, int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, Object paramObject2) { this.v = paramObject1;
    this.premix_hashcode = paramInt1;
    this.hashcode = paramInt2;
    this.cnt = paramInt3;
    this.dirty = paramBoolean;
    this.cached_seq = paramObject2; }
  
  public static IPersistentVector getBasis() { return Tuple.create(((IObj)Symbol.intern(null, "v")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "PersistentVector") })), ((IObj)Symbol.intern(null, "premix-hashcode")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "int") })), ((IObj)Symbol.intern(null, "hashcode")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "int") })), ((IObj)Symbol.intern(null, "cnt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "int") })), ((IObj)Symbol.intern(null, "dirty")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "boolean") })), ((IObj)Symbol.intern(null, "cached-seq")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.ISeq"), RT.keyword(null, "unsynchronized-mutable"), Boolean.TRUE }))); }
  
  public Object cached_QMARK_() { return this.cached_seq; }
  
  public Object conj_flat(Object obj) { // Byte code:
    //   0: aload_1
    //   1: aconst_null
    //   2: invokestatic identical : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   5: ifeq -> 13
    //   8: aload_0
    //   9: goto -> 441
    //   12: athrow
    //   13: getstatic instaparse/auto_flatten_seq/AutoFlattenSeq.const__17 : Lclojure/lang/Var;
    //   16: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   19: checkcast clojure/lang/IFn
    //   22: aload_1
    //   23: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   28: dup
    //   29: ifnull -> 321
    //   32: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   35: if_acmpeq -> 322
    //   38: aload_0
    //   39: getfield cnt : I
    //   42: i2l
    //   43: lconst_0
    //   44: lcmp
    //   45: ifne -> 55
    //   48: aload_1
    //   49: aconst_null
    //   50: astore_1
    //   51: goto -> 318
    //   54: athrow
    //   55: aload_1
    //   56: invokestatic count : (Ljava/lang/Object;)I
    //   59: i2l
    //   60: ldc2_w 32
    //   63: lcmp
    //   64: ifgt -> 193
    //   67: getstatic instaparse/auto_flatten_seq/AutoFlattenSeq.const__21 : Lclojure/lang/Var;
    //   70: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   73: checkcast clojure/lang/IFn
    //   76: aload_0
    //   77: aload_1
    //   78: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   83: astore_2
    //   84: aload_0
    //   85: getfield cnt : I
    //   88: i2l
    //   89: aload_1
    //   90: invokestatic count : (Ljava/lang/Object;)I
    //   93: i2l
    //   94: invokestatic add : (JJ)J
    //   97: lstore_3
    //   98: new instaparse/auto_flatten_seq/AutoFlattenSeq
    //   101: dup
    //   102: getstatic instaparse/auto_flatten_seq/AutoFlattenSeq.const__23 : Lclojure/lang/Var;
    //   105: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   108: checkcast clojure/lang/IFn
    //   111: aload_0
    //   112: getfield v : Ljava/lang/Object;
    //   115: aload_1
    //   116: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   121: aload_2
    //   122: checkcast java/lang/Number
    //   125: invokestatic intCast : (Ljava/lang/Object;)I
    //   128: getstatic instaparse/auto_flatten_seq/AutoFlattenSeq.const__25 : Lclojure/lang/Var;
    //   131: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   134: checkcast clojure/lang/IFn$LLL
    //   137: aload_2
    //   138: aconst_null
    //   139: astore_2
    //   140: checkcast java/lang/Number
    //   143: invokestatic longCast : (Ljava/lang/Object;)J
    //   146: lload_3
    //   147: invokeinterface invokePrim : (JJ)J
    //   152: invokestatic intCast : (J)I
    //   155: lload_3
    //   156: invokestatic intCast : (J)I
    //   159: aload_0
    //   160: getfield dirty : Z
    //   163: istore #5
    //   165: iload #5
    //   167: ifeq -> 176
    //   170: iload #5
    //   172: goto -> 185
    //   175: athrow
    //   176: aload_1
    //   177: aconst_null
    //   178: astore_1
    //   179: checkcast instaparse/auto_flatten_seq/AutoFlattenSeq
    //   182: getfield dirty : Z
    //   185: aconst_null
    //   186: invokespecial <init> : (Ljava/lang/Object;IIIZLjava/lang/Object;)V
    //   189: goto -> 318
    //   192: athrow
    //   193: getstatic instaparse/auto_flatten_seq/AutoFlattenSeq.const__26 : Lclojure/lang/Keyword;
    //   196: dup
    //   197: ifnull -> 316
    //   200: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   203: if_acmpeq -> 317
    //   206: getstatic instaparse/auto_flatten_seq/AutoFlattenSeq.const__21 : Lclojure/lang/Var;
    //   209: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   212: checkcast clojure/lang/IFn
    //   215: aload_0
    //   216: aload_1
    //   217: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   222: astore_2
    //   223: aload_0
    //   224: getfield cnt : I
    //   227: i2l
    //   228: aload_1
    //   229: invokestatic count : (Ljava/lang/Object;)I
    //   232: i2l
    //   233: invokestatic add : (JJ)J
    //   236: lstore_3
    //   237: new instaparse/auto_flatten_seq/AutoFlattenSeq
    //   240: dup
    //   241: getstatic instaparse/auto_flatten_seq/AutoFlattenSeq.const__27 : Lclojure/lang/Var;
    //   244: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   247: checkcast clojure/lang/IFn
    //   250: aload_0
    //   251: getfield v : Ljava/lang/Object;
    //   254: aload_1
    //   255: aconst_null
    //   256: astore_1
    //   257: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   262: aload_2
    //   263: checkcast java/lang/Number
    //   266: invokestatic intCast : (Ljava/lang/Object;)I
    //   269: getstatic instaparse/auto_flatten_seq/AutoFlattenSeq.const__25 : Lclojure/lang/Var;
    //   272: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   275: checkcast clojure/lang/IFn$LLL
    //   278: aload_2
    //   279: aconst_null
    //   280: astore_2
    //   281: checkcast java/lang/Number
    //   284: invokestatic longCast : (Ljava/lang/Object;)J
    //   287: lload_3
    //   288: invokeinterface invokePrim : (JJ)J
    //   293: invokestatic intCast : (J)I
    //   296: lload_3
    //   297: invokestatic intCast : (J)I
    //   300: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   303: checkcast java/lang/Boolean
    //   306: invokevirtual booleanValue : ()Z
    //   309: aconst_null
    //   310: invokespecial <init> : (Ljava/lang/Object;IIIZLjava/lang/Object;)V
    //   313: goto -> 318
    //   316: pop
    //   317: aconst_null
    //   318: goto -> 441
    //   321: pop
    //   322: getstatic instaparse/auto_flatten_seq/AutoFlattenSeq.const__26 : Lclojure/lang/Keyword;
    //   325: dup
    //   326: ifnull -> 439
    //   329: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   332: if_acmpeq -> 440
    //   335: ldc2_w 31
    //   338: invokestatic intCast : (J)I
    //   341: aload_0
    //   342: getfield premix_hashcode : I
    //   345: imul
    //   346: getstatic instaparse/auto_flatten_seq/AutoFlattenSeq.const__1 : Lclojure/lang/Var;
    //   349: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   352: checkcast clojure/lang/IFn
    //   355: aload_1
    //   356: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   361: checkcast java/lang/Number
    //   364: invokestatic intCast : (Ljava/lang/Object;)I
    //   367: iadd
    //   368: istore_2
    //   369: aload_0
    //   370: getfield cnt : I
    //   373: i2l
    //   374: invokestatic inc : (J)J
    //   377: lstore_3
    //   378: new instaparse/auto_flatten_seq/AutoFlattenSeq
    //   381: dup
    //   382: getstatic instaparse/auto_flatten_seq/AutoFlattenSeq.const__27 : Lclojure/lang/Var;
    //   385: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   388: checkcast clojure/lang/IFn
    //   391: aload_0
    //   392: getfield v : Ljava/lang/Object;
    //   395: aload_1
    //   396: aconst_null
    //   397: astore_1
    //   398: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   403: iload_2
    //   404: getstatic instaparse/auto_flatten_seq/AutoFlattenSeq.const__25 : Lclojure/lang/Var;
    //   407: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   410: checkcast clojure/lang/IFn$LLL
    //   413: iload_2
    //   414: i2l
    //   415: lload_3
    //   416: invokeinterface invokePrim : (JJ)J
    //   421: invokestatic intCast : (J)I
    //   424: lload_3
    //   425: invokestatic intCast : (J)I
    //   428: aload_0
    //   429: getfield dirty : Z
    //   432: aconst_null
    //   433: invokespecial <init> : (Ljava/lang/Object;IIIZLjava/lang/Object;)V
    //   436: goto -> 441
    //   439: pop
    //   440: aconst_null
    //   441: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #87	-> 0
    //   #127	-> 0
    //   #128	-> 2
    //   #127	-> 13
    //   #129	-> 19
    //   #129	-> 23
    //   #130	-> 38
    //   #131	-> 38
    //   #130	-> 55
    //   #132	-> 55
    //   #132	-> 56
    //   #133	-> 73
    //   #133	-> 78
    //   #134	-> 90
    //   #134	-> 94
    //   #135	-> 108
    //   #135	-> 116
    //   #5175	-> 147
    //   #136	-> 165
    //   #136	-> 179
    //   #130	-> 193
    //   #138	-> 212
    //   #138	-> 217
    //   #139	-> 229
    //   #139	-> 233
    //   #140	-> 247
    //   #140	-> 257
    //   #5175	-> 288
    //   #127	-> 322
    //   #143	-> 345
    //   #143	-> 352
    //   #143	-> 356
    //   #143	-> 367
    //   #144	-> 374
    //   #145	-> 388
    //   #145	-> 398
    //   #5175	-> 416
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   165	20	5	or__5516__auto__19305	Z
    //   84	105	2	phc	Ljava/lang/Object;
    //   98	91	3	new_cnt	J
    //   223	90	2	phc	Ljava/lang/Object;
    //   237	76	3	new_cnt	J
    //   369	67	2	phc	I
    //   378	58	3	new_cnt	J
    //   0	441	0	this	Linstaparse/auto_flatten_seq/AutoFlattenSeq;
    //   0	441	1	obj	Ljava/lang/Object; }
  
  public ISeq seq() {
    if (this.cached_seq != null) {
      if (this.cached_seq != Boolean.FALSE);
    } else {
      this.cached_seq;
    } 
    this
      
      .cached_seq = this.dirty ? ((IFn)const__15.getRawRoot()).invoke(this.v) : ((IFn)const__5.getRawRoot()).invoke(this.v);
    return (ISeq)this.cached_seq;
  }
  
  public int count() { return this.cnt; }
  
  public IPersistentMap meta() { this = null;
    return (IPersistentMap)((IFn)const__8.getRawRoot()).invoke(this.v); }
  
  public IObj withMeta(IPersistentMap metamap) { metamap = null;
    return (IObj)new AutoFlattenSeq(((IFn)const__6.getRawRoot()).invoke(this.v, metamap), this.premix_hashcode, this.hashcode, this.cnt, this.dirty, null); }
  
  public int hasheq() { return this.hashcode; }
  
  public Object valAt(Object key, Object not_found) { key = null;
    not_found = null;
    return ((APersistentVector)this.v).valAt(key, not_found); }
  
  public Object valAt(Object key) { key = null;
    return ((APersistentVector)this.v).valAt(key); }
  
  public Object[] toArray() {
    Object s = ((IFn)const__5.getRawRoot()).invoke(this);
    s = null;
    return (Object[])((Collection)s).toArray();
  }
  
  public int size() { return this.cnt; }
  
  public Iterator iterator() {
    Object temp__5733__auto__19306 = ((IFn)const__5.getRawRoot()).invoke(this);
    if (temp__5733__auto__19306 != null) {
      if (temp__5733__auto__19306 != Boolean.FALSE) {
        Object s = temp__5733__auto__19306 = null;
        s = null;
      } 
    } else {
      temp__5733__auto__19306;
    } 
    Object e = PersistentList.EMPTY;
    e = null;
    return (Iterator)((Collection)e).iterator();
  }
  
  public boolean equals(Object other) {
    boolean and__5514__auto__19310 = other instanceof AutoFlattenSeq;
    boolean and__5514__auto__19309 = Numbers.equiv(this.hashcode, ((AutoFlattenSeq)other).hashcode);
    boolean and__5514__auto__19308 = Numbers.equiv(this.cnt, ((AutoFlattenSeq)other).cnt);
    boolean and__5514__auto__19307 = Util.equiv(this.dirty, ((AutoFlattenSeq)other).dirty);
    other = null;
    return and__5514__auto__19310 ? (and__5514__auto__19309 ? (and__5514__auto__19308 ? (and__5514__auto__19307 ? Util.equiv(this.v, ((AutoFlattenSeq)other).v) : and__5514__auto__19307) : and__5514__auto__19308) : and__5514__auto__19309) : and__5514__auto__19310;
  }
  
  public int hashCode() { return this.hashcode; }
  
  public String toString() {
    return (String)((IFn)const__5.getRawRoot()).invoke(this).toString();
  }
  
  public ISeq cons(Object obj) { obj = null;
    this = null;
    return (ISeq)((IFn)const__12.getRawRoot()).invoke(obj, this); }
  
  public ISeq more() { this = null;
    return (ISeq)((IFn)const__11.getRawRoot()).invoke(((IFn)const__5.getRawRoot()).invoke(this)); }
  
  public ISeq next() { this = null;
    return (ISeq)((IFn)const__10.getRawRoot()).invoke(((IFn)const__5.getRawRoot()).invoke(this)); }
  
  public Object first() { this = null;
    return ((IFn)const__9.getRawRoot()).invoke(((IFn)const__5.getRawRoot()).invoke(this)); }
  
  public IPersistentCollection empty() { this = null;
    return (IPersistentCollection)((IFn)const__6.getRawRoot()).invoke(const__7.getRawRoot(), ((IFn)const__8.getRawRoot()).invoke(this)); }
  
  public boolean equiv(Object other) {
    boolean and__5514__auto__19313 = Numbers.equiv(this.hashcode, ((IFn)const__1.getRawRoot()).invoke(other));
    boolean and__5514__auto__19312 = Numbers.equiv(this.cnt, RT.count(other));
    boolean or__5516__auto__19311 = Numbers.equiv(this.cnt, 0L);
    other = null;
    return and__5514__auto__19313 ? (and__5514__auto__19312 ? (or__5516__auto__19311 ? or__5516__auto__19311 : Util.equiv(((IFn)const__5.getRawRoot()).invoke(this), other)) : and__5514__auto__19312) : and__5514__auto__19313;
  }
}
