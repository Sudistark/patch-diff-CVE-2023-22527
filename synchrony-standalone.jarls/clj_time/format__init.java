package clj_time;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentArrayMap;
import clojure.lang.PersistentHashSet;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.Locale;
import java.util.concurrent.Callable;
import org.joda.time.format.ISODateTimeFormat;

public class format__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Keyword const__2;
  
  public static final AFn const__3;
  
  public static final AFn const__4;
  
  public static final Var const__5;
  
  public static final AFn const__12;
  
  public static final Var const__13;
  
  public static final AFn const__19;
  
  public static final Var const__20;
  
  public static final AFn const__24;
  
  public static final Var const__25;
  
  public static final AFn const__28;
  
  public static final Var const__29;
  
  public static final AFn const__32;
  
  public static final Var const__33;
  
  public static final AFn const__36;
  
  public static final Var const__37;
  
  public static final AFn const__40;
  
  public static final Var const__41;
  
  public static final AFn const__44;
  
  public static final AFn const__46;
  
  public static final Var const__47;
  
  public static final Var const__48;
  
  public static final Keyword const__49;
  
  public static final Keyword const__50;
  
  public static final Keyword const__51;
  
  public static final Keyword const__52;
  
  public static final Keyword const__53;
  
  public static final Keyword const__54;
  
  public static final Keyword const__55;
  
  public static final Keyword const__56;
  
  public static final Keyword const__57;
  
  public static final Keyword const__58;
  
  public static final Keyword const__59;
  
  public static final Keyword const__60;
  
  public static final Keyword const__61;
  
  public static final Keyword const__62;
  
  public static final Keyword const__63;
  
  public static final Keyword const__64;
  
  public static final Keyword const__65;
  
  public static final Keyword const__66;
  
  public static final Keyword const__67;
  
  public static final Keyword const__68;
  
  public static final Keyword const__69;
  
  public static final Keyword const__70;
  
  public static final Keyword const__71;
  
  public static final Keyword const__72;
  
  public static final Keyword const__73;
  
  public static final Keyword const__74;
  
  public static final Keyword const__75;
  
  public static final Keyword const__76;
  
  public static final Keyword const__77;
  
  public static final Keyword const__78;
  
  public static final Keyword const__79;
  
  public static final Keyword const__80;
  
  public static final Keyword const__81;
  
  public static final Keyword const__82;
  
  public static final Keyword const__83;
  
  public static final Keyword const__84;
  
  public static final Keyword const__85;
  
  public static final Keyword const__86;
  
  public static final Keyword const__87;
  
  public static final Keyword const__88;
  
  public static final Keyword const__89;
  
  public static final Keyword const__90;
  
  public static final Keyword const__91;
  
  public static final Keyword const__92;
  
  public static final Keyword const__93;
  
  public static final Keyword const__94;
  
  public static final Keyword const__95;
  
  public static final Keyword const__96;
  
  public static final Keyword const__97;
  
  public static final Keyword const__98;
  
  public static final Keyword const__99;
  
  public static final Keyword const__100;
  
  public static final Keyword const__101;
  
  public static final Var const__102;
  
  public static final AFn const__105;
  
  public static final AFn const__106;
  
  public static final Var const__107;
  
  public static final AFn const__109;
  
  public static final Var const__110;
  
  public static final Var const__111;
  
  public static final Var const__112;
  
  public static final Var const__113;
  
  public static final Object const__114;
  
  public static final AFn const__117;
  
  public static final Var const__118;
  
  public static final AFn const__122;
  
  public static final Var const__123;
  
  public static final AFn const__127;
  
  public static final Var const__128;
  
  public static final AFn const__132;
  
  public static final Var const__133;
  
  public static final AFn const__136;
  
  public static final Var const__137;
  
  public static final AFn const__140;
  
  public static final Var const__141;
  
  public static final AFn const__144;
  
  public static final Var const__145;
  
  public static final AFn const__148;
  
  public static final Var const__149;
  
  public static final AFn const__152;
  
  public static final Object const__153;
  
  public static final Var const__154;
  
  public static final Var const__155;
  
  public static final Var const__156;
  
  public static final Var const__157;
  
  public static final ISeq const__158;
  
  public static final Var const__159;
  
  public static final Var const__160;
  
  public static final AFn const__164;
  
  public static final Keyword const__165;
  
  public static final AFn const__166;
  
  public static final Keyword const__167;
  
  public static final Keyword const__168;
  
  public static final Keyword const__169;
  
  public static final AFn const__170;
  
  public static final Keyword const__171;
  
  public static final Var const__172;
  
  public static final Var const__173;
  
  public static final Var const__174;
  
  public static final AFn const__175;
  
  public static final AFn const__176;
  
  public static final Keyword const__177;
  
  public static final Var const__178;
  
  public static final AFn const__179;
  
  public static final Var const__180;
  
  public static final AFn const__183;
  
  public static final Var const__184;
  
  public static final Object const__185;
  
  public static final Object const__186;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new format.fn__19091());
    const__5.setMeta((IPersistentMap)const__12);
    const__13.setMeta((IPersistentMap)const__19);
    const__13.bindRoot(new format.formatter());
    const__20.setMeta((IPersistentMap)const__24);
    const__20.bindRoot(new format.formatter_local());
    const__25.setMeta((IPersistentMap)const__28);
    const__25.bindRoot(new format.with_chronology());
    const__29.setMeta((IPersistentMap)const__32);
    const__29.bindRoot(new format.with_locale());
    const__33.setMeta((IPersistentMap)const__36);
    const__33.bindRoot(new format.with_pivot_year());
    const__37.setMeta((IPersistentMap)const__40);
    const__37.bindRoot(new format.with_zone());
    const__41.setMeta((IPersistentMap)const__44);
    const__41.bindRoot(new format.with_default_year());
    const__5.setMeta((IPersistentMap)const__46);
    const__5

























































































      
      .bindRoot(((IFn)const__47.getRawRoot()).invoke(PersistentArrayMap.EMPTY, ((IFn)const__48.getRawRoot()).invoke(new format.fn__19104(), 








            
            RT.mapUniqueKeys(new Object[] { 
                const__49, ISODateTimeFormat.dateElementParser(), const__50, 










                
                ISODateTimeFormat.hourMinute(), const__51, 












                
                ISODateTimeFormat.tTime(), const__52, ISODateTimeFormat.basicOrdinalDate(), const__53, ISODateTimeFormat.date(), 
                const__54, ISODateTimeFormat.hour(), const__55, ISODateTimeFormat.timeNoMillis(), const__56, ISODateTimeFormat.weekyearWeekDay(), const__57, ISODateTimeFormat.weekDateTime(), const__58, ISODateTimeFormat.dateHourMinuteSecondFraction(), 
                const__59, ISODateTimeFormat.basicDateTime(), const__60, ISODateTimeFormat.dateTime(), const__61, ISODateTimeFormat.basicTimeNoMillis(), const__62, ISODateTimeFormat.dateParser(), const__63, ISODateTimeFormat.basicWeekDate(), 
                const__64, ISODateTimeFormat.basicTTimeNoMillis(), const__65, ISODateTimeFormat.localTimeParser(), const__66, ISODateTimeFormat.dateTimeNoMillis(), const__67, ISODateTimeFormat.yearMonthDay(), const__68, ISODateTimeFormat.dateOptionalTimeParser(), 
                const__69, ((IFn)const__29.getRawRoot()).invoke(((IFn)const__13.getRawRoot()).invoke("EEE, dd MMM yyyy HH:mm:ss Z"), Locale.US), const__70, ISODateTimeFormat.dateHourMinuteSecondMillis(), const__71, ISODateTimeFormat.basicOrdinalDateTime(), const__72, ISODateTimeFormat.ordinalDate(), const__73, ISODateTimeFormat.hourMinuteSecondFraction(), 
                const__74, ISODateTimeFormat.dateHourMinute(), const__75, ISODateTimeFormat.time(), const__76, ISODateTimeFormat.basicWeekDateTime(), const__77, ISODateTimeFormat.weekyear(), const__78, ISODateTimeFormat.basicTime(), 
                const__79, ISODateTimeFormat.hourMinuteSecond(), const__80, ISODateTimeFormat.ordinalDateTime(), const__81, ISODateTimeFormat.ordinalDateTimeNoMillis(), const__82, ISODateTimeFormat.hourMinuteSecondMillis(), const__83, ISODateTimeFormat.timeParser(), 
                const__84, ISODateTimeFormat.dateTimeParser(), const__85, ISODateTimeFormat.year(), const__86, ISODateTimeFormat.tTimeNoMillis(), const__87, ISODateTimeFormat.basicWeekDateTimeNoMillis(), const__88, ISODateTimeFormat.basicDate(), 
                const__89, ISODateTimeFormat.weekyearWeek(), const__90, ISODateTimeFormat.localDateParser(), const__91, ISODateTimeFormat.basicOrdinalDateTimeNoMillis(), const__92, ISODateTimeFormat.yearMonth(), const__93, ISODateTimeFormat.localDateOptionalTimeParser(), 
                const__94, ISODateTimeFormat.weekDate(), const__95, ISODateTimeFormat.dateHour(), const__96, ISODateTimeFormat.timeElementParser(), const__97, ISODateTimeFormat.dateHourMinuteSecond(), const__98, ISODateTimeFormat.weekDateTimeNoMillis(), 
                const__99, ISODateTimeFormat.basicDateTimeNoMillis(), const__100, ((IFn)const__13.getRawRoot()).invoke("yyyy-MM-dd HH:mm:ss"), const__101, ISODateTimeFormat.basicTTime() }))));
    const__102.setMeta((IPersistentMap)const__105);
    const__102.bindRoot(const__106);
    const__107.setMeta((IPersistentMap)const__109);
    const__107.bindRoot(((IFn)const__110.getRawRoot()).invoke(((IFn)const__111.getRawRoot()).invoke(((IFn)const__112.getRawRoot()).invoke(const__5.getRawRoot())), const__102.getRawRoot()));
    const__113.setMeta((IPersistentMap)const__117);
    const__113.bindRoot(new format.parse());
    const__118.setMeta((IPersistentMap)const__122);
    const__118.bindRoot(new format.parse_local());
    const__123.setMeta((IPersistentMap)const__127);
    const__123.bindRoot(new format.parse_local_date());
    const__128.setMeta((IPersistentMap)const__132);
    const__128.bindRoot(new format.parse_local_time());
    const__133.setMeta((IPersistentMap)const__136);
    const__133.bindRoot(new format.unparse());
    const__137.setMeta((IPersistentMap)const__140);
    const__137.bindRoot(new format.unparse_local());
    const__141.setMeta((IPersistentMap)const__144);
    const__141.bindRoot(new format.unparse_local_date());
    const__145.setMeta((IPersistentMap)const__148);
    const__145.bindRoot(new format.unparse_local_time());
    const__149.setMeta((IPersistentMap)const__152);
    const__149.bindRoot(new format.show_formatters());
    const__180.setMeta((IPersistentMap)const__183);
    const__180.bindRoot(new format.to_map());
    new Object[2][0] = const__169;
    new Object[2][1] = new format.fn__19217();
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clj-time.format")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Utilities for parsing and unparsing DateTimes as Strings.\n\n   Parsing and printing are controlled by formatters. You can either use one\n   of the built in ISO 8601 and a single RFC 822 formatters or define your own, e.g.:\n\n     (def built-in-formatter (formatters :basic-date-time))\n     (def custom-formatter (formatter \"yyyyMMdd\"))\n\n   To see a list of available built-in formatters and an example of a date-time\n   printed in their format:\n\n    (show-formatters)\n\n   Once you have a formatter, parsing and printing are straightforward:\n\n     => (parse custom-formatter \"20100311\")\n     #<DateTime 2010-03-11T00:00:00.000Z>\n\n     => (unparse custom-formatter (date-time 2010 10 3))\n     \"20101003\"\n\n   By default the parse function always returns a DateTime instance with a UTC\n   time zone, and the unparse function always represents a given DateTime\n   instance in UTC. A formatter can be modified to different timezones, locales,\n   etc with the functions with-zone, with-locale, with-chronology,\n   with-default-year and with-pivot-year." }));
    const__2 = (Keyword)RT.keyword(null, "doc");
    const__3 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Utilities for parsing and unparsing DateTimes as Strings.\n\n   Parsing and printing are controlled by formatters. You can either use one\n   of the built in ISO 8601 and a single RFC 822 formatters or define your own, e.g.:\n\n     (def built-in-formatter (formatters :basic-date-time))\n     (def custom-formatter (formatter \"yyyyMMdd\"))\n\n   To see a list of available built-in formatters and an example of a date-time\n   printed in their format:\n\n    (show-formatters)\n\n   Once you have a formatter, parsing and printing are straightforward:\n\n     => (parse custom-formatter \"20100311\")\n     #<DateTime 2010-03-11T00:00:00.000Z>\n\n     => (unparse custom-formatter (date-time 2010 10 3))\n     \"20101003\"\n\n   By default the parse function always returns a DateTime instance with a UTC\n   time zone, and the unparse function always represents a given DateTime\n   instance in UTC. A formatter can be modified to different timezones, locales,\n   etc with the functions with-zone, with-locale, with-chronology,\n   with-default-year and with-pivot-year." });
    const__4 = (AFn)Symbol.intern(null, "clojure.core");
    const__5 = (Var)RT.var("clj-time.format", "formatters");
    const__12 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(38), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/format.clj" });
    const__13 = (Var)RT.var("clj-time.format", "formatter");
    const__19 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.format.DateTimeFormatter"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fmts")), Tuple.create(Symbol.intern(null, "fmts"), ((IObj)Symbol.intern(null, "dtz")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeZone") }))), Tuple.create(((IObj)Symbol.intern(null, "dtz")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeZone") })), Symbol.intern(null, "fmts"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) })), RT.keyword(null, "doc"), "Returns a custom formatter for the given date-time pattern or keyword.", RT.keyword(null, "line"), Integer.valueOf(41), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/format.clj" });
    const__20 = (Var)RT.var("clj-time.format", "formatter-local");
    const__24 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.format.DateTimeFormat"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "fmt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))) })), RT.keyword(null, "doc"), "Returns a custom formatter with no time zone info.", RT.keyword(null, "line"), Integer.valueOf(59), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/format.clj" });
    const__25 = (Var)RT.var("clj-time.format", "with-chronology");
    const__28 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.format.DateTimeFormatter"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "f")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter") })), ((IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Chronology") }))) })), RT.keyword(null, "doc"), "Return a copy of a formatter that uses the given Chronology.", RT.keyword(null, "line"), Integer.valueOf(64), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/format.clj" });
    const__29 = (Var)RT.var("clj-time.format", "with-locale");
    const__32 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.format.DateTimeFormatter"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "f")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter") })), ((IObj)Symbol.intern(null, "l")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Locale") }))) })), RT.keyword(null, "doc"), "Return a copy of a formatter that uses the given Locale.", RT.keyword(null, "line"), Integer.valueOf(69), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/format.clj" });
    const__33 = (Var)RT.var("clj-time.format", "with-pivot-year");
    const__36 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.format.DateTimeFormatter"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "f")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter") })), ((IObj)Symbol.intern(null, "pivot-year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Long") }))) })), RT.keyword(null, "doc"), "Return a copy of a formatter that uses the given pivot year.", RT.keyword(null, "line"), Integer.valueOf(74), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/format.clj" });
    const__37 = (Var)RT.var("clj-time.format", "with-zone");
    const__40 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.format.DateTimeFormatter"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "f")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter") })), ((IObj)Symbol.intern(null, "dtz")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeZone") }))) })), RT.keyword(null, "doc"), "Return a copy of a formatter that uses the given DateTimeZone.", RT.keyword(null, "line"), Integer.valueOf(79), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/format.clj" });
    const__41 = (Var)RT.var("clj-time.format", "with-default-year");
    const__44 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.format.DateTimeFormatter"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "f")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter") })), ((IObj)Symbol.intern(null, "default-year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") }))) })), RT.keyword(null, "doc"), "Return a copy of a formatter that uses the given default year.", RT.keyword(null, "line"), Integer.valueOf(84), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/format.clj" });
    const__46 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Map of ISO 8601 and a single RFC 822 formatters that can be used for parsing and, in most\n             cases, printing.", RT.keyword(null, "line"), Integer.valueOf(89), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/format.clj" });
    const__47 = (Var)RT.var("clojure.core", "into");
    const__48 = (Var)RT.var("clojure.core", "map");
    const__49 = (Keyword)RT.keyword(null, "date-element-parser");
    const__50 = (Keyword)RT.keyword(null, "hour-minute");
    const__51 = (Keyword)RT.keyword(null, "t-time");
    const__52 = (Keyword)RT.keyword(null, "basic-ordinal-date");
    const__53 = (Keyword)RT.keyword(null, "date");
    const__54 = (Keyword)RT.keyword(null, "hour");
    const__55 = (Keyword)RT.keyword(null, "time-no-ms");
    const__56 = (Keyword)RT.keyword(null, "weekyear-week-day");
    const__57 = (Keyword)RT.keyword(null, "week-date-time");
    const__58 = (Keyword)RT.keyword(null, "date-hour-minute-second-fraction");
    const__59 = (Keyword)RT.keyword(null, "basic-date-time");
    const__60 = (Keyword)RT.keyword(null, "date-time");
    const__61 = (Keyword)RT.keyword(null, "basic-time-no-ms");
    const__62 = (Keyword)RT.keyword(null, "date-parser");
    const__63 = (Keyword)RT.keyword(null, "basic-week-date");
    const__64 = (Keyword)RT.keyword(null, "basic-t-time-no-ms");
    const__65 = (Keyword)RT.keyword(null, "local-time");
    const__66 = (Keyword)RT.keyword(null, "date-time-no-ms");
    const__67 = (Keyword)RT.keyword(null, "year-month-day");
    const__68 = (Keyword)RT.keyword(null, "date-opt-time");
    const__69 = (Keyword)RT.keyword(null, "rfc822");
    const__70 = (Keyword)RT.keyword(null, "date-hour-minute-second-ms");
    const__71 = (Keyword)RT.keyword(null, "basic-ordinal-date-time");
    const__72 = (Keyword)RT.keyword(null, "ordinal-date");
    const__73 = (Keyword)RT.keyword(null, "hour-minute-second-fraction");
    const__74 = (Keyword)RT.keyword(null, "date-hour-minute");
    const__75 = (Keyword)RT.keyword(null, "time");
    const__76 = (Keyword)RT.keyword(null, "basic-week-date-time");
    const__77 = (Keyword)RT.keyword(null, "weekyear");
    const__78 = (Keyword)RT.keyword(null, "basic-time");
    const__79 = (Keyword)RT.keyword(null, "hour-minute-second");
    const__80 = (Keyword)RT.keyword(null, "ordinal-date-time");
    const__81 = (Keyword)RT.keyword(null, "ordinal-date-time-no-ms");
    const__82 = (Keyword)RT.keyword(null, "hour-minute-second-ms");
    const__83 = (Keyword)RT.keyword(null, "time-parser");
    const__84 = (Keyword)RT.keyword(null, "date-time-parser");
    const__85 = (Keyword)RT.keyword(null, "year");
    const__86 = (Keyword)RT.keyword(null, "t-time-no-ms");
    const__87 = (Keyword)RT.keyword(null, "basic-week-date-time-no-ms");
    const__88 = (Keyword)RT.keyword(null, "basic-date");
    const__89 = (Keyword)RT.keyword(null, "weekyear-week");
    const__90 = (Keyword)RT.keyword(null, "local-date");
    const__91 = (Keyword)RT.keyword(null, "basic-ordinal-date-time-no-ms");
    const__92 = (Keyword)RT.keyword(null, "year-month");
    const__93 = (Keyword)RT.keyword(null, "local-date-opt-time");
    const__94 = (Keyword)RT.keyword(null, "week-date");
    const__95 = (Keyword)RT.keyword(null, "date-hour");
    const__96 = (Keyword)RT.keyword(null, "time-element-parser");
    const__97 = (Keyword)RT.keyword(null, "date-hour-minute-second");
    const__98 = (Keyword)RT.keyword(null, "week-date-time-no-ms");
    const__99 = (Keyword)RT.keyword(null, "basic-date-time-no-ms");
  }
  
  public static void __init1() {
    const__100 = (Keyword)RT.keyword(null, "mysql");
    const__101 = (Keyword)RT.keyword(null, "basic-t-time");
    const__102 = (Var)RT.var("clj-time.format", "parsers");
    const__105 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(148), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/format.clj" });
    const__106 = (AFn)PersistentHashSet.create(new Object[] { RT.keyword(null, "date-element-parser"), RT.keyword(null, "date-parser"), RT.keyword(null, "local-time"), RT.keyword(null, "date-opt-time"), RT.keyword(null, "time-parser"), RT.keyword(null, "date-time-parser"), RT.keyword(null, "local-date"), RT.keyword(null, "local-date-opt-time"), RT.keyword(null, "time-element-parser") });
    const__107 = (Var)RT.var("clj-time.format", "printers");
    const__109 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(153), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/format.clj" });
    const__110 = (Var)RT.var("clojure.set", "difference");
    const__111 = (Var)RT.var("clojure.core", "set");
    const__112 = (Var)RT.var("clojure.core", "keys");
    const__113 = (Var)RT.var("clj-time.format", "parse");
    const__114 = RT.classForName("org.joda.time.DateTime");
    const__117 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.DateTime"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "fmt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter") })), ((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))), Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))) })), RT.keyword(null, "doc"), "Returns a DateTime instance in the UTC time zone obtained by parsing the\n   given string according to the given formatter.", RT.keyword(null, "line"), Integer.valueOf(156), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/format.clj" });
    const__118 = (Var)RT.var("clj-time.format", "parse-local");
    const__122 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.LocalDateTime"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "fmt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter") })), ((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))), Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))) })), RT.keyword(null, "doc"), "Returns a LocalDateTime instance obtained by parsing the\n   given string according to the given formatter.", RT.keyword(null, "line"), Integer.valueOf(167), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/format.clj" });
    const__123 = (Var)RT.var("clj-time.format", "parse-local-date");
    const__127 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.LocalDate"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "fmt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter") })), ((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))), Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))) })), RT.keyword(null, "doc"), "Returns a LocalDate instance obtained by parsing the\n   given string according to the given formatter.", RT.keyword(null, "line"), Integer.valueOf(178), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/format.clj" });
    const__128 = (Var)RT.var("clj-time.format", "parse-local-time");
    const__132 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.LocalTime"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "fmt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter") })), ((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))), Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))) })), RT.keyword(null, "doc"), "Returns a LocalTime instance obtained by parsing the\n  given string according to the given formatter.", RT.keyword(null, "line"), Integer.valueOf(189), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/format.clj" });
    const__133 = (Var)RT.var("clj-time.format", "unparse");
    const__136 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "fmt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter") })), ((IObj)Symbol.intern(null, "dt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTime") }))) })), RT.keyword(null, "doc"), "Returns a string representing the given DateTime instance in UTC and in the\n  form determined by the given formatter.", RT.keyword(null, "line"), Integer.valueOf(200), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/format.clj" });
    const__137 = (Var)RT.var("clj-time.format", "unparse-local");
    const__140 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "fmt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter") })), ((IObj)Symbol.intern(null, "dt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "LocalDateTime") }))) })), RT.keyword(null, "doc"), "Returns a string representing the given LocalDateTime instance in the\n  form determined by the given formatter.", RT.keyword(null, "line"), Integer.valueOf(206), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/format.clj" });
    const__141 = (Var)RT.var("clj-time.format", "unparse-local-date");
    const__144 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "fmt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter") })), ((IObj)Symbol.intern(null, "ld")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "LocalDate") }))) })), RT.keyword(null, "doc"), "Returns a string representing the given LocalDate instance in the form\n  determined by the given formatter.", RT.keyword(null, "line"), Integer.valueOf(212), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/format.clj" });
    const__145 = (Var)RT.var("clj-time.format", "unparse-local-time");
    const__148 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "fmt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter") })), ((IObj)Symbol.intern(null, "lt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "LocalTime") }))) })), RT.keyword(null, "doc"), "Returns a string representing the given LocalTime instance in the form\n  determined by the given formatter.", RT.keyword(null, "line"), Integer.valueOf(218), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/format.clj" });
    const__149 = (Var)RT.var("clj-time.format", "show-formatters");
    const__152 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(((IObj)Symbol.intern(null, "dt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTime") }))) })), RT.keyword(null, "doc"), "Shows how a given DateTime, or by default the current time, would be\n  formatted with each of the available printing formatters.", RT.keyword(null, "line"), Integer.valueOf(225), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/format.clj" });
    const__153 = RT.classForName("clj_time.format.Mappable");
    const__154 = (Var)RT.var("clojure.core", "alter-meta!");
    const__155 = (Var)RT.var("clj-time.format", "Mappable");
    const__156 = (Var)RT.var("clojure.core", "assoc");
    const__157 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__158 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "instant->map")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns a map representation of the given instant.\n                          It will contain the following keys: :years, :months,\n                          :days, :hours, :minutes and :seconds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "instant")) })) })) }));
    const__159 = (Var)RT.var("clojure.core", "alter-var-root");
    const__160 = (Var)RT.var("clojure.core", "merge");
    const__164 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clj_time.format.Mappable"), RT.keyword(null, "on-interface"), RT.classForName("clj_time.format.Mappable") });
    const__165 = (Keyword)RT.keyword(null, "sigs");
    const__166 = (AFn)RT.map(new Object[] { RT.keyword(null, "instant->map"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "instant->map")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns a map representation of the given instant.\n                          It will contain the following keys: :years, :months,\n                          :days, :hours, :minutes and :seconds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "instant")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "instant")) })), RT.keyword(null, "doc"), "Returns a map representation of the given instant.\n                          It will contain the following keys: :years, :months,\n                          :days, :hours, :minutes and :seconds." }) });
    const__167 = (Keyword)RT.keyword(null, "var");
    const__168 = (Keyword)RT.keyword(null, "method-map");
    const__169 = (Keyword)RT.keyword(null, "instant->map");
    const__170 = (AFn)RT.map(new Object[] { RT.keyword(null, "instant->map"), RT.keyword(null, "instant->map") });
    const__171 = (Keyword)RT.keyword(null, "method-builders");
    const__172 = (Var)RT.var("clojure.core", "intern");
    const__173 = (Var)RT.var("clojure.core", "*ns*");
    const__174 = (Var)RT.var("clojure.core", "with-meta");
    const__175 = (AFn)((IObj)Symbol.intern(null, "instant->map")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns a map representation of the given instant.\n                          It will contain the following keys: :years, :months,\n                          :days, :hours, :minutes and :seconds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "instant")) })) }));
    const__176 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "instant->map")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns a map representation of the given instant.\n                          It will contain the following keys: :years, :months,\n                          :days, :hours, :minutes and :seconds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "instant")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "instant")) })), RT.keyword(null, "doc"), "Returns a map representation of the given instant.\n                          It will contain the following keys: :years, :months,\n                          :days, :hours, :minutes and :seconds." });
    const__177 = (Keyword)RT.keyword(null, "protocol");
    const__178 = (Var)RT.var("clojure.core", "-reset-methods");
    const__179 = (AFn)Symbol.intern(null, "Mappable");
    const__180 = (Var)RT.var("clj-time.format", "to-map");
    const__183 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "years"), Symbol.intern(null, "months"), Symbol.intern(null, "days"), Symbol.intern(null, "hours"), Symbol.intern(null, "minutes"), Symbol.intern(null, "seconds")) })), RT.keyword(null, "line"), Integer.valueOf(239), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/format.clj" });
    const__184 = (Var)RT.var("clojure.core", "extend");
    const__185 = RT.classForName("org.joda.time.Period");
    const__186 = RT.classForName("org.joda.time.Interval");
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("clj_time.format__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
