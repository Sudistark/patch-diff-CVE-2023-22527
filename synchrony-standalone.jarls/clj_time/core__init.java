package clj_time;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;
import org.joda.time.DateTimeZone;

public class core__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Keyword const__2;
  
  public static final AFn const__3;
  
  public static final AFn const__4;
  
  public static final Var const__5;
  
  public static final AFn const__13;
  
  public static final Object const__14;
  
  public static final Var const__15;
  
  public static final Var const__16;
  
  public static final Var const__17;
  
  public static final Var const__18;
  
  public static final ISeq const__19;
  
  public static final Var const__20;
  
  public static final Var const__21;
  
  public static final AFn const__25;
  
  public static final Keyword const__26;
  
  public static final AFn const__27;
  
  public static final Keyword const__28;
  
  public static final Keyword const__29;
  
  public static final Keyword const__30;
  
  public static final Keyword const__31;
  
  public static final Keyword const__32;
  
  public static final Keyword const__33;
  
  public static final Keyword const__34;
  
  public static final Keyword const__35;
  
  public static final Keyword const__36;
  
  public static final Keyword const__37;
  
  public static final Keyword const__38;
  
  public static final Keyword const__39;
  
  public static final Keyword const__40;
  
  public static final Keyword const__41;
  
  public static final Keyword const__42;
  
  public static final Keyword const__43;
  
  public static final Keyword const__44;
  
  public static final Keyword const__45;
  
  public static final Keyword const__46;
  
  public static final Keyword const__47;
  
  public static final AFn const__48;
  
  public static final Keyword const__49;
  
  public static final Var const__50;
  
  public static final Var const__51;
  
  public static final Var const__52;
  
  public static final AFn const__53;
  
  public static final AFn const__54;
  
  public static final Keyword const__55;
  
  public static final AFn const__56;
  
  public static final AFn const__57;
  
  public static final AFn const__58;
  
  public static final AFn const__59;
  
  public static final AFn const__60;
  
  public static final AFn const__61;
  
  public static final AFn const__62;
  
  public static final AFn const__63;
  
  public static final AFn const__64;
  
  public static final AFn const__65;
  
  public static final AFn const__66;
  
  public static final AFn const__67;
  
  public static final AFn const__68;
  
  public static final AFn const__69;
  
  public static final AFn const__70;
  
  public static final AFn const__71;
  
  public static final AFn const__72;
  
  public static final AFn const__73;
  
  public static final AFn const__74;
  
  public static final AFn const__75;
  
  public static final AFn const__76;
  
  public static final AFn const__77;
  
  public static final AFn const__78;
  
  public static final AFn const__79;
  
  public static final AFn const__80;
  
  public static final AFn const__81;
  
  public static final AFn const__82;
  
  public static final AFn const__83;
  
  public static final AFn const__84;
  
  public static final AFn const__85;
  
  public static final AFn const__86;
  
  public static final AFn const__87;
  
  public static final AFn const__88;
  
  public static final AFn const__89;
  
  public static final Var const__90;
  
  public static final AFn const__91;
  
  public static final Object const__92;
  
  public static final Var const__93;
  
  public static final ISeq const__94;
  
  public static final AFn const__96;
  
  public static final AFn const__97;
  
  public static final Keyword const__98;
  
  public static final Keyword const__99;
  
  public static final Keyword const__100;
  
  public static final Keyword const__101;
  
  public static final Keyword const__102;
  
  public static final Keyword const__103;
  
  public static final Keyword const__104;
  
  public static final Keyword const__105;
  
  public static final AFn const__106;
  
  public static final AFn const__107;
  
  public static final AFn const__108;
  
  public static final AFn const__109;
  
  public static final AFn const__110;
  
  public static final AFn const__111;
  
  public static final AFn const__112;
  
  public static final AFn const__113;
  
  public static final AFn const__114;
  
  public static final AFn const__115;
  
  public static final AFn const__116;
  
  public static final AFn const__117;
  
  public static final AFn const__118;
  
  public static final AFn const__119;
  
  public static final AFn const__120;
  
  public static final AFn const__121;
  
  public static final AFn const__122;
  
  public static final AFn const__123;
  
  public static final Var const__124;
  
  public static final Object const__125;
  
  public static final Object const__126;
  
  public static final Object const__127;
  
  public static final Object const__128;
  
  public static final Object const__129;
  
  public static final Object const__130;
  
  public static final Var const__131;
  
  public static final AFn const__133;
  
  public static final Var const__134;
  
  public static final AFn const__137;
  
  public static final Var const__138;
  
  public static final AFn const__141;
  
  public static final Var const__142;
  
  public static final AFn const__146;
  
  public static final Var const__147;
  
  public static final AFn const__151;
  
  public static final Var const__152;
  
  public static final AFn const__155;
  
  public static final Var const__156;
  
  public static final AFn const__159;
  
  public static final Var const__160;
  
  public static final AFn const__163;
  
  public static final Var const__164;
  
  public static final AFn const__167;
  
  public static final Var const__168;
  
  public static final AFn const__171;
  
  public static final Var const__172;
  
  public static final AFn const__175;
  
  public static final Var const__176;
  
  public static final AFn const__179;
  
  public static final Var const__180;
  
  public static final AFn const__183;
  
  public static final Var const__184;
  
  public static final AFn const__187;
  
  public static final Var const__188;
  
  public static final AFn const__191;
  
  public static final Var const__192;
  
  public static final AFn const__195;
  
  public static final Var const__196;
  
  public static final AFn const__199;
  
  public static final Var const__200;
  
  public static final AFn const__203;
  
  public static final Var const__204;
  
  public static final AFn const__207;
  
  public static final Var const__208;
  
  public static final AFn const__211;
  
  public static final Var const__212;
  
  public static final AFn const__215;
  
  public static final Var const__216;
  
  public static final AFn const__219;
  
  public static final Var const__220;
  
  public static final AFn const__223;
  
  public static final Var const__224;
  
  public static final AFn const__227;
  
  public static final Var const__228;
  
  public static final AFn const__231;
  
  public static final Var const__232;
  
  public static final AFn const__235;
  
  public static final Var const__236;
  
  public static final AFn const__239;
  
  public static final Var const__240;
  
  public static final AFn const__243;
  
  public static final Object const__244;
  
  public static final Object const__245;
  
  public static final Var const__246;
  
  public static final AFn const__249;
  
  public static final Var const__250;
  
  public static final AFn const__253;
  
  public static final Var const__254;
  
  public static final AFn const__257;
  
  public static final Var const__258;
  
  public static final AFn const__261;
  
  public static final Var const__262;
  
  public static final AFn const__265;
  
  public static final Var const__266;
  
  public static final AFn const__269;
  
  public static final Var const__270;
  
  public static final AFn const__273;
  
  public static final Var const__274;
  
  public static final AFn const__277;
  
  public static final Var const__278;
  
  public static final AFn const__281;
  
  public static final Var const__282;
  
  public static final AFn const__285;
  
  public static final Var const__286;
  
  public static final AFn const__289;
  
  public static final Var const__290;
  
  public static final AFn const__293;
  
  public static final Var const__294;
  
  public static final AFn const__297;
  
  public static final Var const__298;
  
  public static final AFn const__301;
  
  public static final Var const__302;
  
  public static final AFn const__305;
  
  public static final Var const__306;
  
  public static final AFn const__309;
  
  public static final Var const__310;
  
  public static final AFn const__313;
  
  public static final Var const__314;
  
  public static final AFn const__317;
  
  public static final Var const__318;
  
  public static final AFn const__321;
  
  public static final Var const__322;
  
  public static final AFn const__325;
  
  public static final Var const__326;
  
  public static final AFn const__329;
  
  public static final Var const__330;
  
  public static final AFn const__333;
  
  public static final Var const__334;
  
  public static final AFn const__337;
  
  public static final Var const__338;
  
  public static final AFn const__341;
  
  public static final Var const__342;
  
  public static final AFn const__345;
  
  public static final Var const__346;
  
  public static final AFn const__349;
  
  public static final Var const__350;
  
  public static final AFn const__353;
  
  public static final Var const__354;
  
  public static final AFn const__357;
  
  public static final Var const__358;
  
  public static final AFn const__361;
  
  public static final Var const__362;
  
  public static final AFn const__365;
  
  public static final Var const__366;
  
  public static final AFn const__369;
  
  public static final Var const__370;
  
  public static final AFn const__373;
  
  public static final Var const__374;
  
  public static final AFn const__377;
  
  public static final Var const__378;
  
  public static final AFn const__381;
  
  public static final Var const__382;
  
  public static final AFn const__385;
  
  public static final Var const__386;
  
  public static final AFn const__389;
  
  public static final Var const__390;
  
  public static final AFn const__393;
  
  public static final Var const__394;
  
  public static final AFn const__398;
  
  public static final Object const__399;
  
  public static final Var const__400;
  
  public static final Keyword const__401;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new core.fn__18442());
    const__5.setMeta((IPersistentMap)const__13);
    const__5.bindRoot(new core.deprecated());
    const__131.setMeta((IPersistentMap)const__133);
    const__131






















































































































      
      .bindRoot(DateTimeZone.UTC);
    const__134.setMeta((IPersistentMap)const__137);
    const__134.bindRoot(new core.now());
    const__138.setMeta((IPersistentMap)const__141);
    const__138.bindRoot(new core.time_now());
    const__142.setMeta((IPersistentMap)const__146);
    const__142.bindRoot(new core.today_at_midnight());
    const__147.setMeta((IPersistentMap)const__151);
    const__147.bindRoot(new core.with_time_at_start_of_day());
    const__152.setMeta((IPersistentMap)const__155);
    const__152.bindRoot(new core.epoch());
    const__156.setMeta((IPersistentMap)const__159);
    const__156.bindRoot(new core.date_midnight());
    const__160.setMeta((IPersistentMap)const__163);
    const__160.bindRoot(new core.min_date());
    const__164.setMeta((IPersistentMap)const__167);
    const__164.bindRoot(new core.max_date());
    const__168.setMeta((IPersistentMap)const__171);
    const__168.bindRoot(new core.date_time());
    const__172.setMeta((IPersistentMap)const__175);
    const__172.bindRoot(new core.local_date_time());
    const__176.setMeta((IPersistentMap)const__179);
    const__176.bindRoot(new core.year_month());
    const__180.setMeta((IPersistentMap)const__183);
    const__180.bindRoot(new core.local_date());
    const__184.setMeta((IPersistentMap)const__187);
    const__184.bindRoot(new core.local_time());
    const__188.setMeta((IPersistentMap)const__191);
    const__188.bindRoot(new core.today());
    const__192.setMeta((IPersistentMap)const__195);
    const__192.bindRoot(new core.time_zone_for_offset());
    const__196.setMeta((IPersistentMap)const__199);
    const__196.bindRoot(new core.time_zone_for_id());
    const__200.setMeta((IPersistentMap)const__203);
    const__200.bindRoot(new core.available_ids());
    const__204.setMeta((IPersistentMap)const__207);
    const__204.bindRoot(new core.default_time_zone());
    const__208.setMeta((IPersistentMap)const__211);
    const__208.bindRoot(new core.to_time_zone());
    const__212.setMeta((IPersistentMap)const__215);
    const__212.bindRoot(new core.from_time_zone());
    const__216.setMeta((IPersistentMap)const__219);
    const__216.bindRoot(new core.years());
    const__220.setMeta((IPersistentMap)const__223);
    const__220.bindRoot(new core.months());
    const__224.setMeta((IPersistentMap)const__227);
    const__224.bindRoot(new core.weeks());
    const__228.setMeta((IPersistentMap)const__231);
    const__228.bindRoot(new core.days());
    const__232.setMeta((IPersistentMap)const__235);
    const__232.bindRoot(new core.hours());
    const__236.setMeta((IPersistentMap)const__239);
    const__236.bindRoot(new core.minutes());
    const__240.setMeta((IPersistentMap)const__243);
    const__240.bindRoot(new core.seconds());
    const__246.setMeta((IPersistentMap)const__249);
    const__246.bindRoot(new core.in_msecs());
    const__250.setMeta((IPersistentMap)const__253);
    const__250.bindRoot(new core.in_secs());
    const__254.setMeta((IPersistentMap)const__257);
    const__254.bindRoot(new core.secs());
    const__258.setMeta((IPersistentMap)const__261);
    const__258.bindRoot(new core.millis());
    const__262.setMeta((IPersistentMap)const__265);
    const__262.bindRoot(new core.plus());
    const__266.setMeta((IPersistentMap)const__269);
    const__266.bindRoot(new core.minus());
    const__270.setMeta((IPersistentMap)const__273);
    const__270.bindRoot(new core.ago());
    const__274.setMeta((IPersistentMap)const__277);
    const__274.bindRoot(new core.yesterday());
    const__278.setMeta((IPersistentMap)const__281);
    const__278.bindRoot(new core.from_now());
    const__282.setMeta((IPersistentMap)const__285);
    const__282.bindRoot(new core.earliest());
    const__286.setMeta((IPersistentMap)const__289);
    const__286.bindRoot(new core.latest());
    const__290.setMeta((IPersistentMap)const__293);
    const__290.bindRoot(new core.interval());
    const__294.setMeta((IPersistentMap)const__297);
    const__294.bindRoot(new core.start());
    const__298.setMeta((IPersistentMap)const__301);
    const__298.bindRoot(new core.end());
    const__302.setMeta((IPersistentMap)const__305);
    const__302.bindRoot(new core.extend());
    const__306.setMeta((IPersistentMap)const__309);
    const__306.bindRoot(new core.adjust());
    const__310.setMeta((IPersistentMap)const__313);
    const__310.bindRoot(new core.within_QMARK_());
    const__314.setMeta((IPersistentMap)const__317);
    const__314.bindRoot(new core.overlaps_QMARK_());
    const__318.setMeta((IPersistentMap)const__321);
    const__318.bindRoot(new core.overlap());
    const__322.setMeta((IPersistentMap)const__325);
    const__322.bindRoot(new core.abuts_QMARK_());
    const__326.setMeta((IPersistentMap)const__329);
    const__326.bindRoot(new core.years_QMARK_());
    const__330.setMeta((IPersistentMap)const__333);
    const__330.bindRoot(new core.months_QMARK_());
    const__334.setMeta((IPersistentMap)const__337);
    const__334.bindRoot(new core.weeks_QMARK_());
    const__338.setMeta((IPersistentMap)const__341);
    const__338.bindRoot(new core.days_QMARK_());
    const__342.setMeta((IPersistentMap)const__345);
    const__342.bindRoot(new core.hours_QMARK_());
    const__346.setMeta((IPersistentMap)const__349);
    const__346.bindRoot(new core.minutes_QMARK_());
    const__350.setMeta((IPersistentMap)const__353);
    const__350.bindRoot(new core.seconds_QMARK_());
    const__354.setMeta((IPersistentMap)const__357);
    const__354.bindRoot(new core.secs_QMARK_());
    const__358.setMeta((IPersistentMap)const__361);
    const__358.bindRoot(new core.mins_ago());
    const__362.setMeta((IPersistentMap)const__365);
    const__362.bindRoot(new core.first_day_of_the_month());
    const__366.setMeta((IPersistentMap)const__369);
    const__366.bindRoot(new core.last_day_of_the_month());
    const__370.setMeta((IPersistentMap)const__373);
    const__370.bindRoot(new core.number_of_days_in_the_month());
    const__374.setMeta((IPersistentMap)const__377);
    const__374.bindRoot(new core.nth_day_of_the_month());
    const__378.setMeta((IPersistentMap)const__381);
    const__378.bindRoot(new core.today_at());
    const__382.setMeta((IPersistentMap)const__385);
    const__382.bindRoot(new core.do_at_STAR_());
    const__386.setMeta((IPersistentMap)const__389);
    const__386.bindRoot(new core.do_at());
    ((Var)const__386)




























































































































































































































































































      
      .setMacro();
    const__390.setMeta((IPersistentMap)const__393);
    const__390.bindRoot(new core.floor());
    const__394.setMeta((IPersistentMap)const__398);
    const__394.bindRoot(new core.when_available());
    ((Var)const__394)



















      
      .setMacro();
    new Object[2][0] = const__401;
    new Object[2][1] = new core.fn__19087();
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clj-time.core")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The core namespace for date-time operations in the clj-time library.\n\n   Create a DateTime instance with date-time (or a LocalDateTime instance with local-date-time),\n   specifying the year, month, day, hour, minute, second, and millisecond:\n\n     => (date-time 1986 10 14 4 3 27 456)\n     #<DateTime 1986-10-14T04:03:27.456Z>\n\n     => (local-date-time 1986 10 14 4 3 27 456)\n     #<LocalDateTime 1986-10-14T04:03:27.456>\n\n   Less-significant fields can be omitted:\n\n     => (date-time 1986 10 14)\n     #<DateTime 1986-10-14T00:00:00.000Z>\n\n     => (local-date-time 1986 10 14)\n     #<LocalDateTime 1986-10-14T00:00:00.000>\n\n   Get the current time with (now) and the start of the Unix epoch with (epoch).\n\n   Once you have a date-time, use accessors like hour and second to access the\n   corresponding fields:\n\n     => (hour (date-time 1986 10 14 22))\n     22\n\n     => (hour (local-date-time 1986 10 14 22))\n     22\n\n   The date-time constructor always returns times in the UTC time zone. If you\n   want a time with the specified fields in a different time zone, use\n   from-time-zone:\n\n     => (from-time-zone (date-time 1986 10 22) (time-zone-for-offset -2))\n     #<DateTime 1986-10-22T00:00:00.000-02:00>\n\n   If on the other hand you want a given absolute instant in time in a\n   different time zone, use to-time-zone:\n\n     => (to-time-zone (date-time 1986 10 22) (time-zone-for-offset -2))\n     #<DateTime 1986-10-21T22:00:00.000-02:00>\n\n   In addition to time-zone-for-offset, you can use the time-zone-for-id and\n   default-time-zone functions and the utc Var to construct or get DateTimeZone\n   instances.\n\n   The functions after? and before? determine the relative position of two\n   DateTime instances:\n\n     => (after? (date-time 1986 10) (date-time 1986 9))\n     true\n\n     => (after? (local-date-time 1986 10) (local-date-time 1986 9))\n     true\n\n   Often you will want to find a date some amount of time from a given date. For\n   example, to find the time 1 month and 3 weeks from a given date-time:\n\n     => (plus (date-time 1986 10 14) (months 1) (weeks 3))\n     #<DateTime 1986-12-05T00:00:00.000Z>\n\n     => (plus (local-date-time 1986 10 14) (months 1) (weeks 3))\n     #<LocalDateTime 1986-12-05T00:00:00.000Z>\n\n   An Interval is used to represent the span of time between two DateTime\n   instances. Construct one using interval, then query them using within?,\n   overlaps?, and abuts?\n\n     => (within? (interval (date-time 1986) (date-time 1990))\n                 (date-time 1987))\n     true\n\n   To find the amount of time encompassed by an interval, use in-seconds and\n   in-minutes:\n\n     => (in-minutes (interval (date-time 1986 10 2) (date-time 1986 10 14)))\n     17280\n\n   The overlap function can be used to get an Interval representing the\n   overlap between two intervals:\n\n     => (overlap (t/interval (t/date-time 1986) (t/date-time 1990))\n                             (t/interval (t/date-time 1987) (t/date-time 1991)))\n     #<Interval 1987-01-01T00:00:00.000Z/1990-01-01T00:00:00.000Z>\n\n   Note that all functions in this namespace work with Joda objects or ints. If\n   you need to print or parse date-times, see clj-time.format. If you need to\n   coerce date-times to or from other types, see clj-time.coerce." }));
    const__2 = (Keyword)RT.keyword(null, "doc");
    const__3 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "The core namespace for date-time operations in the clj-time library.\n\n   Create a DateTime instance with date-time (or a LocalDateTime instance with local-date-time),\n   specifying the year, month, day, hour, minute, second, and millisecond:\n\n     => (date-time 1986 10 14 4 3 27 456)\n     #<DateTime 1986-10-14T04:03:27.456Z>\n\n     => (local-date-time 1986 10 14 4 3 27 456)\n     #<LocalDateTime 1986-10-14T04:03:27.456>\n\n   Less-significant fields can be omitted:\n\n     => (date-time 1986 10 14)\n     #<DateTime 1986-10-14T00:00:00.000Z>\n\n     => (local-date-time 1986 10 14)\n     #<LocalDateTime 1986-10-14T00:00:00.000>\n\n   Get the current time with (now) and the start of the Unix epoch with (epoch).\n\n   Once you have a date-time, use accessors like hour and second to access the\n   corresponding fields:\n\n     => (hour (date-time 1986 10 14 22))\n     22\n\n     => (hour (local-date-time 1986 10 14 22))\n     22\n\n   The date-time constructor always returns times in the UTC time zone. If you\n   want a time with the specified fields in a different time zone, use\n   from-time-zone:\n\n     => (from-time-zone (date-time 1986 10 22) (time-zone-for-offset -2))\n     #<DateTime 1986-10-22T00:00:00.000-02:00>\n\n   If on the other hand you want a given absolute instant in time in a\n   different time zone, use to-time-zone:\n\n     => (to-time-zone (date-time 1986 10 22) (time-zone-for-offset -2))\n     #<DateTime 1986-10-21T22:00:00.000-02:00>\n\n   In addition to time-zone-for-offset, you can use the time-zone-for-id and\n   default-time-zone functions and the utc Var to construct or get DateTimeZone\n   instances.\n\n   The functions after? and before? determine the relative position of two\n   DateTime instances:\n\n     => (after? (date-time 1986 10) (date-time 1986 9))\n     true\n\n     => (after? (local-date-time 1986 10) (local-date-time 1986 9))\n     true\n\n   Often you will want to find a date some amount of time from a given date. For\n   example, to find the time 1 month and 3 weeks from a given date-time:\n\n     => (plus (date-time 1986 10 14) (months 1) (weeks 3))\n     #<DateTime 1986-12-05T00:00:00.000Z>\n\n     => (plus (local-date-time 1986 10 14) (months 1) (weeks 3))\n     #<LocalDateTime 1986-12-05T00:00:00.000Z>\n\n   An Interval is used to represent the span of time between two DateTime\n   instances. Construct one using interval, then query them using within?,\n   overlaps?, and abuts?\n\n     => (within? (interval (date-time 1986) (date-time 1990))\n                 (date-time 1987))\n     true\n\n   To find the amount of time encompassed by an interval, use in-seconds and\n   in-minutes:\n\n     => (in-minutes (interval (date-time 1986 10 2) (date-time 1986 10 14)))\n     17280\n\n   The overlap function can be used to get an Interval representing the\n   overlap between two intervals:\n\n     => (overlap (t/interval (t/date-time 1986) (t/date-time 1990))\n                             (t/interval (t/date-time 1987) (t/date-time 1991)))\n     #<Interval 1987-01-01T00:00:00.000Z/1990-01-01T00:00:00.000Z>\n\n   Note that all functions in this namespace work with Joda objects or ints. If\n   you need to print or parse date-times, see clj-time.format. If you need to\n   coerce date-times to or from other types, see clj-time.coerce." });
    const__4 = (AFn)Symbol.intern(null, "clojure.core");
    const__5 = (Var)RT.var("clj-time.core", "deprecated");
    const__13 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "message")) })), RT.keyword(null, "line"), Integer.valueOf(99), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__14 = RT.classForName("clj_time.core.DateTimeProtocol");
    const__15 = (Var)RT.var("clojure.core", "alter-meta!");
    const__16 = (Var)RT.var("clj-time.core", "DateTimeProtocol");
    const__17 = (Var)RT.var("clojure.core", "assoc");
    const__18 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__19 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { 
            ((IObj)Symbol.intern(null, "after?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns true if ReadableDateTime 'this' is strictly after date/time 'that'.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "that")) })) })), ((IObj)Symbol.intern(null, "day")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the day of month component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "hour")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the hour of day component of the given date/time. A time of 12:01am will have an hour component of 0.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "second")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the second of minute component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "day-of-week")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the day of week component of the given date/time. Monday is 1 and Sunday is 7", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "plus-")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns a new date/time corresponding to the given date/time moved forwards by the given Period(s).", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), ((IObj)Symbol.intern(null, "period")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePeriod") }))) })) })), ((IObj)Symbol.intern(null, "last-day-of-the-month-")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the last day of the month", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "month")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the month component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "week-year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the the week based year of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "equal?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns true if ReadableDateTime 'this' is strictly equal to date/time 'that'.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "that")) })) })), 
            ((IObj)Symbol.intern(null, "before?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns true if ReadableDateTime 'this' is strictly before date/time 'that'.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "that")) })) })), ((IObj)Symbol.intern(null, "year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the year component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "week-number-of-year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the week of the week based year of the given date/time", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "minus-")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns a new date/time corresponding to the given date/time moved backwards by the given Period(s).", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), ((IObj)Symbol.intern(null, "period")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePeriod") }))) })) })), ((IObj)Symbol.intern(null, "sec")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the second of minute component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "first-day-of-the-month-")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the first day of the month", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "milli")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the millisecond of second component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "minute")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the minute of hour component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })) }));
    const__20 = (Var)RT.var("clojure.core", "alter-var-root");
    const__21 = (Var)RT.var("clojure.core", "merge");
    const__25 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clj_time.core.DateTimeProtocol"), RT.keyword(null, "on-interface"), RT.classForName("clj_time.core.DateTimeProtocol"), RT.keyword(null, "doc"), "Interface for various date time functions" });
    const__26 = (Keyword)RT.keyword(null, "sigs");
    const__27 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "after?"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "after?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns true if ReadableDateTime 'this' is strictly after date/time 'that'.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "that")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "that")) })), RT.keyword(null, "doc"), "Returns true if ReadableDateTime 'this' is strictly after date/time 'that'." }), RT.keyword(null, "day"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "day")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the day of month component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the day of month component of the given date/time." }), RT.keyword(null, "hour"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "hour")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the hour of day component of the given date/time. A time of 12:01am will have an hour component of 0.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the hour of day component of the given date/time. A time of 12:01am will have an hour component of 0." }), RT.keyword(null, "second"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "second")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the second of minute component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the second of minute component of the given date/time." }), RT.keyword(null, "day-of-week"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "day-of-week")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the day of week component of the given date/time. Monday is 1 and Sunday is 7", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the day of week component of the given date/time. Monday is 1 and Sunday is 7" }), 
          RT.keyword(null, "plus-"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "plus-")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns a new date/time corresponding to the given date/time moved forwards by the given Period(s).", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), ((IObj)Symbol.intern(null, "period")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePeriod") }))) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), ((IObj)Symbol.intern(null, "period")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePeriod") }))) })), RT.keyword(null, "doc"), "Returns a new date/time corresponding to the given date/time moved forwards by the given Period(s)." }), RT.keyword(null, "last-day-of-the-month-"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "last-day-of-the-month-")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the last day of the month", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Returns the last day of the month" }), RT.keyword(null, "month"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "month")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the month component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the month component of the given date/time." }), RT.keyword(null, "week-year"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "week-year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the the week based year of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Returns the the week based year of the given date/time." }), RT.keyword(null, "equal?"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "equal?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns true if ReadableDateTime 'this' is strictly equal to date/time 'that'.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "that")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "that")) })), RT.keyword(null, "doc"), "Returns true if ReadableDateTime 'this' is strictly equal to date/time 'that'." }), 
          RT.keyword(null, "before?"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "before?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns true if ReadableDateTime 'this' is strictly before date/time 'that'.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "that")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "that")) })), RT.keyword(null, "doc"), "Returns true if ReadableDateTime 'this' is strictly before date/time 'that'." }), RT.keyword(null, "year"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the year component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the year component of the given date/time." }), RT.keyword(null, "week-number-of-year"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "week-number-of-year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the week of the week based year of the given date/time", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Returns the week of the week based year of the given date/time" }), RT.keyword(null, "minus-"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "minus-")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns a new date/time corresponding to the given date/time moved backwards by the given Period(s).", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), ((IObj)Symbol.intern(null, "period")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePeriod") }))) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), ((IObj)Symbol.intern(null, "period")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePeriod") }))) })), RT.keyword(null, "doc"), "Returns a new date/time corresponding to the given date/time moved backwards by the given Period(s)." }), RT.keyword(null, "sec"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "sec")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the second of minute component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the second of minute component of the given date/time." }), 
          RT.keyword(null, "first-day-of-the-month-"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "first-day-of-the-month-")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the first day of the month", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Returns the first day of the month" }), RT.keyword(null, "milli"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "milli")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the millisecond of second component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the millisecond of second component of the given date/time." }), RT.keyword(null, "minute"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "minute")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the minute of hour component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the minute of hour component of the given date/time." }) });
    const__28 = (Keyword)RT.keyword(null, "var");
    const__29 = (Keyword)RT.keyword(null, "method-map");
    const__30 = (Keyword)RT.keyword(null, "after?");
    const__31 = (Keyword)RT.keyword(null, "day");
    const__32 = (Keyword)RT.keyword(null, "hour");
    const__33 = (Keyword)RT.keyword(null, "second");
    const__34 = (Keyword)RT.keyword(null, "day-of-week");
    const__35 = (Keyword)RT.keyword(null, "plus-");
    const__36 = (Keyword)RT.keyword(null, "last-day-of-the-month-");
    const__37 = (Keyword)RT.keyword(null, "month");
    const__38 = (Keyword)RT.keyword(null, "week-year");
    const__39 = (Keyword)RT.keyword(null, "equal?");
    const__40 = (Keyword)RT.keyword(null, "before?");
    const__41 = (Keyword)RT.keyword(null, "year");
    const__42 = (Keyword)RT.keyword(null, "week-number-of-year");
    const__43 = (Keyword)RT.keyword(null, "minus-");
    const__44 = (Keyword)RT.keyword(null, "sec");
    const__45 = (Keyword)RT.keyword(null, "first-day-of-the-month-");
    const__46 = (Keyword)RT.keyword(null, "milli");
    const__47 = (Keyword)RT.keyword(null, "minute");
    const__48 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "after?"), RT.keyword(null, "after?"), RT.keyword(null, "day"), RT.keyword(null, "day"), RT.keyword(null, "hour"), RT.keyword(null, "hour"), RT.keyword(null, "second"), RT.keyword(null, "second"), RT.keyword(null, "day-of-week"), RT.keyword(null, "day-of-week"), 
          RT.keyword(null, "plus-"), RT.keyword(null, "plus-"), RT.keyword(null, "last-day-of-the-month-"), RT.keyword(null, "last-day-of-the-month-"), RT.keyword(null, "month"), RT.keyword(null, "month"), RT.keyword(null, "week-year"), RT.keyword(null, "week-year"), RT.keyword(null, "equal?"), RT.keyword(null, "equal?"), 
          RT.keyword(null, "before?"), RT.keyword(null, "before?"), RT.keyword(null, "year"), RT.keyword(null, "year"), RT.keyword(null, "week-number-of-year"), RT.keyword(null, "week-number-of-year"), RT.keyword(null, "minus-"), RT.keyword(null, "minus-"), RT.keyword(null, "sec"), RT.keyword(null, "sec"), 
          RT.keyword(null, "first-day-of-the-month-"), RT.keyword(null, "first-day-of-the-month-"), RT.keyword(null, "milli"), RT.keyword(null, "milli"), RT.keyword(null, "minute"), RT.keyword(null, "minute") });
    const__49 = (Keyword)RT.keyword(null, "method-builders");
    const__50 = (Var)RT.var("clojure.core", "intern");
    const__51 = (Var)RT.var("clojure.core", "*ns*");
    const__52 = (Var)RT.var("clojure.core", "with-meta");
    const__53 = (AFn)((IObj)Symbol.intern(null, "year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the year component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__54 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the year component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the year component of the given date/time." });
    const__55 = (Keyword)RT.keyword(null, "protocol");
    const__56 = (AFn)((IObj)Symbol.intern(null, "milli")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the millisecond of second component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__57 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "milli")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the millisecond of second component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the millisecond of second component of the given date/time." });
    const__58 = (AFn)((IObj)Symbol.intern(null, "day")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the day of month component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__59 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "day")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the day of month component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the day of month component of the given date/time." });
    const__60 = (AFn)((IObj)Symbol.intern(null, "month")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the month component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__61 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "month")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the month component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the month component of the given date/time." });
    const__62 = (AFn)((IObj)Symbol.intern(null, "week-year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the the week based year of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__63 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "week-year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the the week based year of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Returns the the week based year of the given date/time." });
    const__64 = (AFn)((IObj)Symbol.intern(null, "before?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns true if ReadableDateTime 'this' is strictly before date/time 'that'.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "that")) })) }));
    const__65 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "before?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns true if ReadableDateTime 'this' is strictly before date/time 'that'.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "that")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "that")) })), RT.keyword(null, "doc"), "Returns true if ReadableDateTime 'this' is strictly before date/time 'that'." });
    const__66 = (AFn)((IObj)Symbol.intern(null, "minute")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the minute of hour component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__67 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "minute")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the minute of hour component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the minute of hour component of the given date/time." });
    const__68 = (AFn)((IObj)Symbol.intern(null, "equal?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns true if ReadableDateTime 'this' is strictly equal to date/time 'that'.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "that")) })) }));
    const__69 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "equal?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns true if ReadableDateTime 'this' is strictly equal to date/time 'that'.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "that")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "that")) })), RT.keyword(null, "doc"), "Returns true if ReadableDateTime 'this' is strictly equal to date/time 'that'." });
    const__70 = (AFn)((IObj)Symbol.intern(null, "after?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns true if ReadableDateTime 'this' is strictly after date/time 'that'.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "that")) })) }));
    const__71 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "after?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns true if ReadableDateTime 'this' is strictly after date/time 'that'.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "that")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "that")) })), RT.keyword(null, "doc"), "Returns true if ReadableDateTime 'this' is strictly after date/time 'that'." });
    const__72 = (AFn)((IObj)Symbol.intern(null, "first-day-of-the-month-")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the first day of the month", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__73 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "first-day-of-the-month-")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the first day of the month", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Returns the first day of the month" });
    const__74 = (AFn)((IObj)Symbol.intern(null, "minus-")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns a new date/time corresponding to the given date/time moved backwards by the given Period(s).", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), ((IObj)Symbol.intern(null, "period")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePeriod") }))) })) }));
    const__75 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "minus-")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns a new date/time corresponding to the given date/time moved backwards by the given Period(s).", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), ((IObj)Symbol.intern(null, "period")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePeriod") }))) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), ((IObj)Symbol.intern(null, "period")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePeriod") }))) })), RT.keyword(null, "doc"), "Returns a new date/time corresponding to the given date/time moved backwards by the given Period(s)." });
    const__76 = (AFn)((IObj)Symbol.intern(null, "last-day-of-the-month-")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the last day of the month", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__77 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "last-day-of-the-month-")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the last day of the month", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Returns the last day of the month" });
    const__78 = (AFn)((IObj)Symbol.intern(null, "day-of-week")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the day of week component of the given date/time. Monday is 1 and Sunday is 7", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__79 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "day-of-week")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the day of week component of the given date/time. Monday is 1 and Sunday is 7", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the day of week component of the given date/time. Monday is 1 and Sunday is 7" });
    const__80 = (AFn)((IObj)Symbol.intern(null, "plus-")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns a new date/time corresponding to the given date/time moved forwards by the given Period(s).", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), ((IObj)Symbol.intern(null, "period")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePeriod") }))) })) }));
    const__81 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "plus-")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns a new date/time corresponding to the given date/time moved forwards by the given Period(s).", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), ((IObj)Symbol.intern(null, "period")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePeriod") }))) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), ((IObj)Symbol.intern(null, "period")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePeriod") }))) })), RT.keyword(null, "doc"), "Returns a new date/time corresponding to the given date/time moved forwards by the given Period(s)." });
    const__82 = (AFn)((IObj)Symbol.intern(null, "second")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the second of minute component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__83 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "second")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the second of minute component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the second of minute component of the given date/time." });
    const__84 = (AFn)((IObj)Symbol.intern(null, "hour")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the hour of day component of the given date/time. A time of 12:01am will have an hour component of 0.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__85 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "hour")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the hour of day component of the given date/time. A time of 12:01am will have an hour component of 0.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the hour of day component of the given date/time. A time of 12:01am will have an hour component of 0." });
    const__86 = (AFn)((IObj)Symbol.intern(null, "week-number-of-year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the week of the week based year of the given date/time", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__87 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "week-number-of-year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the week of the week based year of the given date/time", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Returns the week of the week based year of the given date/time" });
    const__88 = (AFn)((IObj)Symbol.intern(null, "sec")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the second of minute component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__89 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "sec")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the second of minute component of the given date/time.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the second of minute component of the given date/time." });
    const__90 = (Var)RT.var("clojure.core", "-reset-methods");
    const__91 = (AFn)Symbol.intern(null, "DateTimeProtocol");
    const__92 = RT.classForName("clj_time.core.InTimeUnitProtocol");
    const__93 = (Var)RT.var("clj-time.core", "InTimeUnitProtocol");
    const__94 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "in-millis")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in milliseconds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "in-seconds")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in seconds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "in-minutes")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in minutes.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "in-hours")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in hours.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "in-days")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in days.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "in-weeks")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in weeks", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "in-months")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in months", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), ((IObj)Symbol.intern(null, "in-years")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in years", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })) }));
    const__96 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clj_time.core.InTimeUnitProtocol"), RT.keyword(null, "on-interface"), RT.classForName("clj_time.core.InTimeUnitProtocol"), RT.keyword(null, "doc"), "Interface for in-<time unit> functions" });
    const__97 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "in-millis"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "in-millis")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in milliseconds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the time in milliseconds." }), RT.keyword(null, "in-seconds"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "in-seconds")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in seconds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the time in seconds." }), RT.keyword(null, "in-minutes"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "in-minutes")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in minutes.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the time in minutes." }), RT.keyword(null, "in-hours"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "in-hours")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in hours.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the time in hours." }), RT.keyword(null, "in-days"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "in-days")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in days.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the time in days." }), 
          RT.keyword(null, "in-weeks"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "in-weeks")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in weeks", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the time in weeks" }), RT.keyword(null, "in-months"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "in-months")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in months", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the time in months" }), RT.keyword(null, "in-years"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "in-years")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in years", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the time in years" }) });
    const__98 = (Keyword)RT.keyword(null, "in-seconds");
    const__99 = (Keyword)RT.keyword(null, "in-minutes");
  }
  
  public static void __init1() {
    const__100 = (Keyword)RT.keyword(null, "in-days");
    const__101 = (Keyword)RT.keyword(null, "in-hours");
    const__102 = (Keyword)RT.keyword(null, "in-years");
    const__103 = (Keyword)RT.keyword(null, "in-millis");
    const__104 = (Keyword)RT.keyword(null, "in-months");
    const__105 = (Keyword)RT.keyword(null, "in-weeks");
    const__106 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "in-seconds"), RT.keyword(null, "in-seconds"), RT.keyword(null, "in-minutes"), RT.keyword(null, "in-minutes"), RT.keyword(null, "in-days"), RT.keyword(null, "in-days"), RT.keyword(null, "in-hours"), RT.keyword(null, "in-hours"), RT.keyword(null, "in-years"), RT.keyword(null, "in-years"), 
          RT.keyword(null, "in-millis"), RT.keyword(null, "in-millis"), RT.keyword(null, "in-months"), RT.keyword(null, "in-months"), RT.keyword(null, "in-weeks"), RT.keyword(null, "in-weeks") });
    const__107 = (AFn)((IObj)Symbol.intern(null, "in-weeks")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in weeks", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__108 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "in-weeks")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in weeks", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the time in weeks" });
    const__109 = (AFn)((IObj)Symbol.intern(null, "in-months")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in months", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__110 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "in-months")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in months", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the time in months" });
    const__111 = (AFn)((IObj)Symbol.intern(null, "in-days")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in days.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__112 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "in-days")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in days.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the time in days." });
    const__113 = (AFn)((IObj)Symbol.intern(null, "in-minutes")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in minutes.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__114 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "in-minutes")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in minutes.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the time in minutes." });
    const__115 = (AFn)((IObj)Symbol.intern(null, "in-hours")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in hours.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__116 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "in-hours")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in hours.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the time in hours." });
    const__117 = (AFn)((IObj)Symbol.intern(null, "in-millis")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in milliseconds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__118 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "in-millis")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in milliseconds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the time in milliseconds." });
    const__119 = (AFn)((IObj)Symbol.intern(null, "in-years")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in years", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__120 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "in-years")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in years", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the time in years" });
    const__121 = (AFn)((IObj)Symbol.intern(null, "in-seconds")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in seconds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) }));
    const__122 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "in-seconds")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the time in seconds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this")) })), RT.keyword(null, "doc"), "Return the time in seconds." });
    const__123 = (AFn)Symbol.intern(null, "InTimeUnitProtocol");
    const__124 = (Var)RT.var("clojure.core", "extend");
    const__125 = RT.classForName("org.joda.time.DateTime");
    const__126 = RT.classForName("org.joda.time.DateMidnight");
    const__127 = RT.classForName("org.joda.time.LocalDateTime");
    const__128 = RT.classForName("org.joda.time.YearMonth");
    const__129 = RT.classForName("org.joda.time.LocalDate");
    const__130 = RT.classForName("org.joda.time.LocalTime");
    const__131 = (Var)RT.var("clj-time.core", "utc");
    const__133 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "DateTimeZone for UTC.", RT.keyword(null, "line"), Integer.valueOf(254), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__134 = (Var)RT.var("clj-time.core", "now");
    const__137 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Returns a DateTime for the current instant in the UTC time zone.", RT.keyword(null, "line"), Integer.valueOf(258), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__138 = (Var)RT.var("clj-time.core", "time-now");
    const__141 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Returns a LocalTime for the current instant without date or time zone\n  using ISOChronology in the current time zone.", RT.keyword(null, "line"), Integer.valueOf(263), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__142 = (Var)RT.var("clj-time.core", "today-at-midnight");
    const__146 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "deprecated"), "0.12.0", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(((IObj)Symbol.intern(null, "tz")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeZone") }))) })), RT.keyword(null, "doc"), "DEPRECATED: Please use with-time-at-start-of-day instead. See http://goo.gl/nQCmKd\n  Returns a DateMidnight for today at midnight in the UTC time zone.", RT.keyword(null, "line"), Integer.valueOf(269), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/core.clj" });
    const__147 = (Var)RT.var("clj-time.core", "with-time-at-start-of-day");
    const__151 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.DateTime"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "dt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTime") }))) })), RT.keyword(null, "doc"), "Returns a DateTime representing the start of the day. Normally midnight,\n  but not always true, as in some time zones with daylight savings.", RT.keyword(null, "line"), Integer.valueOf(277), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/core.clj" });
    const__152 = (Var)RT.var("clj-time.core", "epoch");
    const__155 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Returns a DateTime for the beginning of the Unix epoch in the UTC time zone.", RT.keyword(null, "line"), Integer.valueOf(283), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__156 = (Var)RT.var("clj-time.core", "date-midnight");
    const__159 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "year")), Tuple.create(((IObj)Symbol.intern(null, "year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "month")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") }))), Tuple.create(((IObj)Symbol.intern(null, "year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Long") })), ((IObj)Symbol.intern(null, "month")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Long") })), ((IObj)Symbol.intern(null, "day")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Long") }))) })), RT.keyword(null, "doc"), "Constructs and returns a new DateMidnight in UTC.\n   Specify the year, month of year, day of month. Note that month and day are\n   1-indexed. Any number of least-significant components can be ommited, in which case\n   they will default to 1.", RT.keyword(null, "line"), Integer.valueOf(288), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__160 = (Var)RT.var("clj-time.core", "min-date");
    const__163 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "dt"), Symbol.intern(null, "&"), Symbol.intern(null, "dts")) })), RT.keyword(null, "doc"), "Minimum of the provided DateTimes.", RT.keyword(null, "line"), Integer.valueOf(300), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__164 = (Var)RT.var("clj-time.core", "max-date");
    const__167 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "dt"), Symbol.intern(null, "&"), Symbol.intern(null, "dts")) })), RT.keyword(null, "doc"), "Maximum of the provided DateTimes.", RT.keyword(null, "line"), Integer.valueOf(305), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__168 = (Var)RT.var("clj-time.core", "date-time");
    const__171 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.DateTime"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "year")), Tuple.create(Symbol.intern(null, "year"), Symbol.intern(null, "month")), Tuple.create(Symbol.intern(null, "year"), Symbol.intern(null, "month"), Symbol.intern(null, "day")), Tuple.create(Symbol.intern(null, "year"), Symbol.intern(null, "month"), Symbol.intern(null, "day"), Symbol.intern(null, "hour")), Tuple.create(Symbol.intern(null, "year"), Symbol.intern(null, "month"), Symbol.intern(null, "day"), Symbol.intern(null, "hour"), Symbol.intern(null, "minute")), Tuple.create(Symbol.intern(null, "year"), Symbol.intern(null, "month"), Symbol.intern(null, "day"), Symbol.intern(null, "hour"), Symbol.intern(null, "minute"), Symbol.intern(null, "second")), RT.vector(new Object[] { ((IObj)Symbol.intern(null, "year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })), ((IObj)Symbol.intern(null, "month")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })), ((IObj)Symbol.intern(null, "day")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })), ((IObj)Symbol.intern(null, "hour")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })), ((IObj)Symbol.intern(null, "minute")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })), ((IObj)Symbol.intern(null, "second")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })), ((IObj)Symbol.intern(null, "millis")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })) }) })), RT.keyword(null, "doc"), "Constructs and returns a new DateTime in UTC.\n   Specify the year, month of year, day of month, hour of day, minute of hour,\n   second of minute, and millisecond of second. Note that month and day are\n   1-indexed while hour, second, minute, and millis are 0-indexed.\n   Any number of least-significant components can be ommited, in which case\n   they will default to 1 or 0 as appropriate.", RT.keyword(null, "line"), Integer.valueOf(310), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/core.clj" });
    const__172 = (Var)RT.var("clj-time.core", "local-date-time");
    const__175 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.LocalDateTime"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "year")), Tuple.create(Symbol.intern(null, "year"), Symbol.intern(null, "month")), Tuple.create(Symbol.intern(null, "year"), Symbol.intern(null, "month"), Symbol.intern(null, "day")), Tuple.create(Symbol.intern(null, "year"), Symbol.intern(null, "month"), Symbol.intern(null, "day"), Symbol.intern(null, "hour")), Tuple.create(Symbol.intern(null, "year"), Symbol.intern(null, "month"), Symbol.intern(null, "day"), Symbol.intern(null, "hour"), Symbol.intern(null, "minute")), Tuple.create(Symbol.intern(null, "year"), Symbol.intern(null, "month"), Symbol.intern(null, "day"), Symbol.intern(null, "hour"), Symbol.intern(null, "minute"), Symbol.intern(null, "second")), RT.vector(new Object[] { ((IObj)Symbol.intern(null, "year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })), ((IObj)Symbol.intern(null, "month")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })), ((IObj)Symbol.intern(null, "day")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })), ((IObj)Symbol.intern(null, "hour")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })), ((IObj)Symbol.intern(null, "minute")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })), ((IObj)Symbol.intern(null, "second")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })), ((IObj)Symbol.intern(null, "millis")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })) }) })), RT.keyword(null, "doc"), "Constructs and returns a new LocalDateTime.\n   Specify the year, month of year, day of month, hour of day, minute of hour,\n   second of minute, and millisecond of second. Note that month and day are\n   1-indexed while hour, second, minute, and millis are 0-indexed.\n   Any number of least-significant components can be ommited, in which case\n   they will default to 1 or 0 as appropriate.", RT.keyword(null, "line"), Integer.valueOf(333), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/core.clj" });
    const__176 = (Var)RT.var("clj-time.core", "year-month");
    const__179 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.YearMonth"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "year")), Tuple.create(((IObj)Symbol.intern(null, "year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })), ((IObj)Symbol.intern(null, "month")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") }))) })), RT.keyword(null, "doc"), "Constructs and returns a new YearMonth.\n   Specify the year and month of year. Month is 1-indexed and defaults\n   to January (1).", RT.keyword(null, "line"), Integer.valueOf(356), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/core.clj" });
    const__180 = (Var)RT.var("clj-time.core", "local-date");
    const__183 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.LocalDate"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })), ((IObj)Symbol.intern(null, "month")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })), ((IObj)Symbol.intern(null, "day")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") }))) })), RT.keyword(null, "doc"), "Constructs and returns a new LocalDate.\n   Specify the year, month, and day. Does not deal with timezones.", RT.keyword(null, "line"), Integer.valueOf(365), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/core.clj" });
    const__184 = (Var)RT.var("clj-time.core", "local-time");
    const__187 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.LocalTime"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "hour")), Tuple.create(Symbol.intern(null, "hour"), Symbol.intern(null, "minute")), Tuple.create(Symbol.intern(null, "hour"), Symbol.intern(null, "minute"), Symbol.intern(null, "second")), Tuple.create(((IObj)Symbol.intern(null, "hour")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })), ((IObj)Symbol.intern(null, "minute")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })), ((IObj)Symbol.intern(null, "second")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") })), ((IObj)Symbol.intern(null, "millis")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") }))) })), RT.keyword(null, "doc"), "Constructs and returns a new LocalTime.\n   Specify the hour of day, minute of hour, second of minute, and millisecond of second.\n   Any number of least-significant components can be ommited, in which case\n   they will default to 1 or 0 as appropriate.", RT.keyword(null, "line"), Integer.valueOf(371), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/core.clj" });
    const__188 = (Var)RT.var("clj-time.core", "today");
    const__191 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.LocalDate"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Constructs and returns a new LocalDate representing today's date.\n   LocalDate objects do not deal with timezones at all.", RT.keyword(null, "line"), Integer.valueOf(386), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/core.clj" });
    const__192 = (Var)RT.var("clj-time.core", "time-zone-for-offset");
    const__195 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "hours")), Tuple.create(Symbol.intern(null, "hours"), Symbol.intern(null, "minutes")) })), RT.keyword(null, "doc"), "Returns a DateTimeZone for the given offset, specified either in hours or\n   hours and minutes.", RT.keyword(null, "line"), Integer.valueOf(392), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__196 = (Var)RT.var("clj-time.core", "time-zone-for-id");
    const__199 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "id")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))) })), RT.keyword(null, "doc"), "Returns a DateTimeZone for the given ID, which must be in long form, e.g.\n   'America/Matamoros'.", RT.keyword(null, "line"), Integer.valueOf(400), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
  }
  
  public static void __init2() {
    const__200 = (Var)RT.var("clj-time.core", "available-ids");
    const__203 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Returns a set of available IDs for use with time-zone-for-id.", RT.keyword(null, "line"), Integer.valueOf(406), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__204 = (Var)RT.var("clj-time.core", "default-time-zone");
    const__207 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Returns the default DateTimeZone for the current environment.", RT.keyword(null, "line"), Integer.valueOf(411), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__208 = (Var)RT.var("clj-time.core", "to-time-zone");
    const__211 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.DateTime"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "dt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTime") })), ((IObj)Symbol.intern(null, "tz")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeZone") }))) })), RT.keyword(null, "doc"), "Returns a new ReadableDateTime corresponding to the same absolute instant in time as\n   the given ReadableDateTime, but with calendar fields corresponding to the given\n   TimeZone.", RT.keyword(null, "line"), Integer.valueOf(416), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/core.clj" });
    const__212 = (Var)RT.var("clj-time.core", "from-time-zone");
    const__215 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.DateTime"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "dt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTime") })), ((IObj)Symbol.intern(null, "tz")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeZone") }))) })), RT.keyword(null, "doc"), "Returns a new ReadableDateTime corresponding to the same point in calendar time as\n   the given ReadableDateTime, but for a correspondingly different absolute instant in\n   time.", RT.keyword(null, "line"), Integer.valueOf(424), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/core.clj" });
    const__216 = (Var)RT.var("clj-time.core", "years");
    const__219 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(((IObj)Symbol.intern(null, "n")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") }))) })), RT.keyword(null, "doc"), "Given a number, returns a Period representing that many years.\n   Without an argument, returns a PeriodType representing only years.", RT.keyword(null, "line"), Integer.valueOf(432), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__220 = (Var)RT.var("clj-time.core", "months");
    const__223 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(((IObj)Symbol.intern(null, "n")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") }))) })), RT.keyword(null, "doc"), "Given a number, returns a Period representing that many months.\n   Without an argument, returns a PeriodType representing only months.", RT.keyword(null, "line"), Integer.valueOf(440), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__224 = (Var)RT.var("clj-time.core", "weeks");
    const__227 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(((IObj)Symbol.intern(null, "n")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") }))) })), RT.keyword(null, "doc"), "Given a number, returns a Period representing that many weeks.\n   Without an argument, returns a PeriodType representing only weeks.", RT.keyword(null, "line"), Integer.valueOf(448), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__228 = (Var)RT.var("clj-time.core", "days");
    const__231 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(((IObj)Symbol.intern(null, "n")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") }))) })), RT.keyword(null, "doc"), "Given a number, returns a Period representing that many days.\n   Without an argument, returns a PeriodType representing only days.", RT.keyword(null, "line"), Integer.valueOf(456), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__232 = (Var)RT.var("clj-time.core", "hours");
    const__235 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(((IObj)Symbol.intern(null, "n")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") }))) })), RT.keyword(null, "doc"), "Given a number, returns a Period representing that many hours.\n   Without an argument, returns a PeriodType representing only hours.", RT.keyword(null, "line"), Integer.valueOf(464), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__236 = (Var)RT.var("clj-time.core", "minutes");
    const__239 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(((IObj)Symbol.intern(null, "n")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") }))) })), RT.keyword(null, "doc"), "Given a number, returns a Period representing that many minutes.\n   Without an argument, returns a PeriodType representing only minutes.", RT.keyword(null, "line"), Integer.valueOf(472), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__240 = (Var)RT.var("clj-time.core", "seconds");
    const__243 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(((IObj)Symbol.intern(null, "n")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") }))) })), RT.keyword(null, "doc"), "Given a number, returns a Period representing that many seconds.\n   Without an argument, returns a PeriodType representing only seconds.", RT.keyword(null, "line"), Integer.valueOf(480), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__244 = RT.classForName("org.joda.time.Interval");
    const__245 = RT.classForName("org.joda.time.ReadablePeriod");
    const__246 = (Var)RT.var("clj-time.core", "in-msecs");
    const__249 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "in")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Interval") }))) })), RT.keyword(null, "doc"), "DEPRECATED: Returns the number of milliseconds in the given Interval.", RT.keyword(null, "deprecated"), "0.6.0", RT.keyword(null, "line"), Integer.valueOf(520), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/core.clj" });
    const__250 = (Var)RT.var("clj-time.core", "in-secs");
    const__253 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "in")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Interval") }))) })), RT.keyword(null, "doc"), "DEPRECATED: Returns the number of standard seconds in the given Interval.", RT.keyword(null, "deprecated"), "0.6.0", RT.keyword(null, "line"), Integer.valueOf(527), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/core.clj" });
    const__254 = (Var)RT.var("clj-time.core", "secs");
    const__257 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(((IObj)Symbol.intern(null, "n")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") }))) })), RT.keyword(null, "doc"), "DEPRECATED", RT.keyword(null, "deprecated"), "0.6.0", RT.keyword(null, "line"), Integer.valueOf(534), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/core.clj" });
    const__258 = (Var)RT.var("clj-time.core", "millis");
    const__261 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(((IObj)Symbol.intern(null, "n")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Integer") }))) })), RT.keyword(null, "doc"), "Given a number, returns a Period representing that many milliseconds.\n   Without an argument, returns a PeriodType representing only milliseconds.", RT.keyword(null, "line"), Integer.valueOf(544), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__262 = (Var)RT.var("clj-time.core", "plus");
    const__265 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "dt"), ((IObj)Symbol.intern(null, "p")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePeriod") }))), Tuple.create(Symbol.intern(null, "dt"), Symbol.intern(null, "p"), Symbol.intern(null, "&"), Symbol.intern(null, "ps")) })), RT.keyword(null, "doc"), "Returns a new date/time corresponding to the given date/time moved forwards by\n   the given Period(s).", RT.keyword(null, "line"), Integer.valueOf(552), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__266 = (Var)RT.var("clj-time.core", "minus");
    const__269 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "dt"), ((IObj)Symbol.intern(null, "p")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePeriod") }))), Tuple.create(Symbol.intern(null, "dt"), Symbol.intern(null, "p"), Symbol.intern(null, "&"), Symbol.intern(null, "ps")) })), RT.keyword(null, "doc"), "Returns a new date/time object corresponding to the given date/time moved backwards by\n   the given Period(s).", RT.keyword(null, "line"), Integer.valueOf(560), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__270 = (Var)RT.var("clj-time.core", "ago");
    const__273 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "period")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Period") }))) })), RT.keyword(null, "doc"), "Returns a DateTime a supplied period before the present.\n  e.g. (-> 5 years ago)", RT.keyword(null, "line"), Integer.valueOf(568), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__274 = (Var)RT.var("clj-time.core", "yesterday");
    const__277 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Returns a DateTime for yesterday relative to now", RT.keyword(null, "line"), Integer.valueOf(574), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__278 = (Var)RT.var("clj-time.core", "from-now");
    const__281 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "period")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Period") }))) })), RT.keyword(null, "doc"), "Returns a DateTime a supplied period after the present.\n  e.g. (-> 30 minutes from-now)", RT.keyword(null, "line"), Integer.valueOf(579), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__282 = (Var)RT.var("clj-time.core", "earliest");
    const__285 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "dt1")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadableInstant") })), ((IObj)Symbol.intern(null, "dt2")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadableInstant") }))), Tuple.create(Symbol.intern(null, "dts")) })), RT.keyword(null, "doc"), "Returns the earliest of the supplied DateTimes", RT.keyword(null, "line"), Integer.valueOf(585), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__286 = (Var)RT.var("clj-time.core", "latest");
    const__289 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "dt1")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadableInstant") })), ((IObj)Symbol.intern(null, "dt2")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadableInstant") }))), Tuple.create(Symbol.intern(null, "dts")) })), RT.keyword(null, "doc"), "Returns the latest of the supplied DateTimes", RT.keyword(null, "line"), Integer.valueOf(593), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__290 = (Var)RT.var("clj-time.core", "interval");
    const__293 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "dt-a")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadableDateTime") })), ((IObj)Symbol.intern(null, "dt-b")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadableDateTime") }))) })), RT.keyword(null, "doc"), "Returns an interval representing the span between the two given ReadableDateTimes.\n   Note that intervals are closed on the left and open on the right.", RT.keyword(null, "line"), Integer.valueOf(601), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__294 = (Var)RT.var("clj-time.core", "start");
    const__297 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "in")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Interval") }))) })), RT.keyword(null, "doc"), "Returns the start DateTime of an Interval.", RT.keyword(null, "line"), Integer.valueOf(607), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__298 = (Var)RT.var("clj-time.core", "end");
  }
  
  public static void __init3() {
    const__301 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "in")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Interval") }))) })), RT.keyword(null, "doc"), "Returns the end DateTime of an Interval.", RT.keyword(null, "line"), Integer.valueOf(612), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__302 = (Var)RT.var("clj-time.core", "extend");
    const__305 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "in")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Interval") })), Symbol.intern(null, "&"), Symbol.intern(null, "by")) })), RT.keyword(null, "doc"), "Returns an Interval with an end ReadableDateTime the specified Period after the end\n   of the given Interval", RT.keyword(null, "line"), Integer.valueOf(617), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__306 = (Var)RT.var("clj-time.core", "adjust");
    const__309 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "in")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Interval") })), Symbol.intern(null, "&"), Symbol.intern(null, "by")) })), RT.keyword(null, "doc"), "Returns an Interval with the start and end adjusted by the specified Periods.", RT.keyword(null, "line"), Integer.valueOf(623), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__310 = (Var)RT.var("clj-time.core", "within?");
    const__313 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "i")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Interval") })), ((IObj)Symbol.intern(null, "dt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadableDateTime") }))), Tuple.create(((IObj)Symbol.intern(null, "start")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePartial") })), ((IObj)Symbol.intern(null, "end")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePartial") })), ((IObj)Symbol.intern(null, "test")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePartial") }))) })), RT.keyword(null, "doc"), "With 2 arguments: Returns true if the given Interval contains the given\n   ReadableDateTime. Note that if the ReadableDateTime is exactly equal to the\n   end of the interval, this function returns false.\n   With 3 arguments: Returns true if the start ReadablePartial is\n   equal to or before and the end ReadablePartial is equal to or after the test\n   ReadablePartial.", RT.keyword(null, "line"), Integer.valueOf(634), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__314 = (Var)RT.var("clj-time.core", "overlaps?");
    const__317 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "i-a")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Interval") })), ((IObj)Symbol.intern(null, "i-b")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Interval") }))), Tuple.create(((IObj)Symbol.intern(null, "start-a")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePartial") })), ((IObj)Symbol.intern(null, "end-a")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePartial") })), ((IObj)Symbol.intern(null, "start-b")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePartial") })), ((IObj)Symbol.intern(null, "end-b")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReadablePartial") }))) })), RT.keyword(null, "doc"), "With 2 arguments: Returns true of the two given Intervals overlap.\n   Note that intervals that satisfy abuts? do not satisfy overlaps?\n   With 4 arguments: Returns true if the range specified by start-a and end-a\n   overlaps with the range specified by start-b and end-b.", RT.keyword(null, "line"), Integer.valueOf(648), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__318 = (Var)RT.var("clj-time.core", "overlap");
    const__321 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "i-a")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Interval") })), ((IObj)Symbol.intern(null, "i-b")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Interval") }))) })), RT.keyword(null, "doc"), "Returns an Interval representing the overlap of the specified Intervals.\n   Returns nil if the Intervals do not overlap.\n   The first argument must not be nil.\n   If the second argument is nil then the overlap of the first argument\n   and a zero duration interval with both start and end times equal to the\n   current time is returned.", RT.keyword(null, "line"), Integer.valueOf(661), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__322 = (Var)RT.var("clj-time.core", "abuts?");
    const__325 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "i-a")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Interval") })), ((IObj)Symbol.intern(null, "i-b")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Interval") }))) })), RT.keyword(null, "doc"), "Returns true if Interval i-a abuts i-b, i.e. then end of i-a is exactly the\n   beginning of i-b.", RT.keyword(null, "line"), Integer.valueOf(676), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__326 = (Var)RT.var("clj-time.core", "years?");
    const__329 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "Returns true if the given value is an instance of Years", RT.keyword(null, "line"), Integer.valueOf(682), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__330 = (Var)RT.var("clj-time.core", "months?");
    const__333 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "Returns true if the given value is an instance of Months", RT.keyword(null, "line"), Integer.valueOf(687), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__334 = (Var)RT.var("clj-time.core", "weeks?");
    const__337 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "Returns true if the given value is an instance of Weeks", RT.keyword(null, "line"), Integer.valueOf(692), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__338 = (Var)RT.var("clj-time.core", "days?");
    const__341 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "Returns true if the given value is an instance of Days", RT.keyword(null, "line"), Integer.valueOf(697), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__342 = (Var)RT.var("clj-time.core", "hours?");
    const__345 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "Returns true if the given value is an instance of Hours", RT.keyword(null, "line"), Integer.valueOf(702), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__346 = (Var)RT.var("clj-time.core", "minutes?");
    const__349 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "Returns true if the given value is an instance of Minutes", RT.keyword(null, "line"), Integer.valueOf(707), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__350 = (Var)RT.var("clj-time.core", "seconds?");
    const__353 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "Returns true if the given value is an instance of Seconds", RT.keyword(null, "line"), Integer.valueOf(712), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__354 = (Var)RT.var("clj-time.core", "secs?");
    const__357 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "DEPRECATED", RT.keyword(null, "deprecated"), "0.6.0", RT.keyword(null, "line"), Integer.valueOf(717), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/core.clj" });
    const__358 = (Var)RT.var("clj-time.core", "mins-ago");
    const__361 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "d")) })), RT.keyword(null, "line"), Integer.valueOf(724), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__362 = (Var)RT.var("clj-time.core", "first-day-of-the-month");
    const__365 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "month")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") }))), Tuple.create(Symbol.intern(null, "dt")) })), RT.keyword(null, "line"), Integer.valueOf(728), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__366 = (Var)RT.var("clj-time.core", "last-day-of-the-month");
    const__369 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "month")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") }))), Tuple.create(Symbol.intern(null, "dt")) })), RT.keyword(null, "line"), Integer.valueOf(734), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__370 = (Var)RT.var("clj-time.core", "number-of-days-in-the-month");
    const__373 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(((IObj)Symbol.intern(null, "dt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTime") })))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Tuple.create(((IObj)Symbol.intern(null, "year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "month")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })) })), RT.keyword(null, "line"), Integer.valueOf(740), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__374 = (Var)RT.var("clj-time.core", "nth-day-of-the-month");
    const__377 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "year")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "month")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "n")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") }))), Tuple.create(((IObj)Symbol.intern(null, "dt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTime") })), ((IObj)Symbol.intern(null, "n")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") }))) })), RT.keyword(null, "doc"), "Returns the nth day of the month.", RT.keyword(null, "line"), Integer.valueOf(746), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__378 = (Var)RT.var("clj-time.core", "today-at");
    const__381 = (AFn)RT.map(new Object[] { RT.keyword(null, "tag"), RT.classForName("org.joda.time.DateTime"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "hours")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "minutes")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "seconds")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "millis")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") }))), Tuple.create(((IObj)Symbol.intern(null, "hours")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "minutes")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "seconds")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") }))), Tuple.create(((IObj)Symbol.intern(null, "hours")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "minutes")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") }))) })), RT.keyword(null, "line"), Integer.valueOf(754), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__382 = (Var)RT.var("clj-time.core", "do-at*");
    const__385 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "base-date-time")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "BaseDateTime") })), Symbol.intern(null, "body-fn")) })), RT.keyword(null, "line"), Integer.valueOf(767), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__386 = (Var)RT.var("clj-time.core", "do-at");
    const__389 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "base-date-time")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "BaseDateTime") })), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Like clojure.core/do except evalautes the expression at the given date-time", RT.keyword(null, "line"), Integer.valueOf(774), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__390 = (Var)RT.var("clj-time.core", "floor");
    const__393 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("org.joda.time.DateTime"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "dt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DateTime") })), Symbol.intern(null, "dt-fn")) })), RT.keyword(null, "doc"), "Floors the given date-time dt to the given time unit dt-fn,\n  e.g. (floor (now) hour) returns (now) for all units\n  up to and including the hour", RT.keyword(null, "line"), Integer.valueOf(780), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clj_time/core.clj" });
    const__394 = (Var)RT.var("clj-time.core", "when-available");
    const__398 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sym"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "line"), Integer.valueOf(795), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clj_time/core.clj" });
    const__399 = RT.classForName("org.joda.time.ReadableInstant");
  }
  
  public static void __init4() {
    const__400 = (Var)RT.var("clojure.core", "Inst");
    const__401 = (Keyword)RT.keyword(null, "inst-ms*");
  }
  
  static  {
    __init0();
    __init1();
    __init2();
    __init3();
    __init4();
    Compiler.pushNSandLoader(RT.classForName("clj_time.core__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
