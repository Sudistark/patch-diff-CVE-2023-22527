package org.bouncycastle.crypto.engines;

import java.math.BigInteger;
import java.security.SecureRandom;
import org.bouncycastle.crypto.AsymmetricBlockCipher;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.CryptoServicesRegistrar;
import org.bouncycastle.crypto.params.ParametersWithRandom;
import org.bouncycastle.crypto.params.RSAKeyParameters;
import org.bouncycastle.crypto.params.RSAPrivateCrtKeyParameters;
import org.bouncycastle.util.BigIntegers;

public class RSABlindedEngine implements AsymmetricBlockCipher {
  private static final BigInteger ONE = BigInteger.valueOf(1L);
  
  private RSACoreEngine core = new RSACoreEngine();
  
  private RSAKeyParameters key;
  
  private SecureRandom random;
  
  public void init(boolean forEncryption, CipherParameters param) {
    this.core.init(forEncryption, param);
    if (param instanceof ParametersWithRandom) {
      ParametersWithRandom rParam = (ParametersWithRandom)param;
      this.key = (RSAKeyParameters)rParam.getParameters();
      if (this.key instanceof RSAPrivateCrtKeyParameters) {
        this.random = rParam.getRandom();
      } else {
        this.random = null;
      } 
    } else {
      this.key = (RSAKeyParameters)param;
      if (this.key instanceof RSAPrivateCrtKeyParameters) {
        this.random = CryptoServicesRegistrar.getSecureRandom();
      } else {
        this.random = null;
      } 
    } 
  }
  
  public int getInputBlockSize() { return this.core.getInputBlockSize(); }
  
  public int getOutputBlockSize() { return this.core.getOutputBlockSize(); }
  
  public byte[] processBlock(byte[] in, int inOff, int inLen) {
    BigInteger result;
    if (this.key == null)
      throw new IllegalStateException("RSA engine not initialised"); 
    BigInteger input = this.core.convertInput(in, inOff, inLen);
    if (this.key instanceof RSAPrivateCrtKeyParameters) {
      RSAPrivateCrtKeyParameters k = (RSAPrivateCrtKeyParameters)this.key;
      BigInteger e = k.getPublicExponent();
      if (e != null) {
        BigInteger m = k.getModulus();
        BigInteger r = BigIntegers.createRandomInRange(ONE, m.subtract(ONE), this.random);
        BigInteger blindedInput = r.modPow(e, m).multiply(input).mod(m);
        BigInteger blindedResult = this.core.processBlock(blindedInput);
        BigInteger rInv = BigIntegers.modOddInverse(m, r);
        result = blindedResult.multiply(rInv).mod(m);
        if (!input.equals(result.modPow(e, m)))
          throw new IllegalStateException("RSA engine faulty decryption/signing detected"); 
      } else {
        result = this.core.processBlock(input);
      } 
    } else {
      result = this.core.processBlock(input);
    } 
    return this.core.convertOutput(result);
  }
}
