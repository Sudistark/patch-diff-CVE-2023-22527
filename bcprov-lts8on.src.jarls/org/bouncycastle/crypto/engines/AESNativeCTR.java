package org.bouncycastle.crypto.engines;

import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.MultiBlockCipher;
import org.bouncycastle.crypto.SkippingStreamCipher;
import org.bouncycastle.crypto.StreamCipher;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.ParametersWithIV;

public class AESNativeCTR implements StreamCipher, SkippingStreamCipher, MultiBlockCipher {
  private CTRRefWrapper referenceWrapper = null;
  
  private int keyLen;
  
  public int getBlockSize() { return 16; }
  
  public int processBlock(byte[] in, int inOff, byte[] out, int outOff) throws DataLengthException, IllegalStateException {
    if (this.referenceWrapper == null)
      throw new IllegalStateException("not initialized"); 
    return processBytes(this.referenceWrapper.getReference(), in, inOff, getBlockSize(), out, outOff);
  }
  
  public int getMultiBlockSize() { return getMultiBlockSize(this.referenceWrapper.getReference()); }
  
  public int processBlocks(byte[] in, int inOff, int blockCount, byte[] out, int outOff) throws DataLengthException, IllegalStateException {
    int extent = getBlockSize() * blockCount;
    if (this.referenceWrapper == null)
      throw new IllegalStateException("not initialized"); 
    return processBytes(this.referenceWrapper.getReference(), in, inOff, extent, out, outOff);
  }
  
  public long skip(long numberOfBytes) {
    if (this.referenceWrapper == null)
      throw new IllegalStateException("not initialized"); 
    return skip(this.referenceWrapper.getReference(), numberOfBytes);
  }
  
  public long seekTo(long position) {
    if (this.referenceWrapper == null)
      throw new IllegalStateException("not initialized"); 
    return seekTo(this.referenceWrapper.getReference(), position);
  }
  
  public long getPosition() {
    if (this.referenceWrapper == null)
      throw new IllegalStateException("not initialized"); 
    return getPosition(this.referenceWrapper.getReference());
  }
  
  public void init(boolean forEncryption, CipherParameters params) throws IllegalArgumentException {
    if (params instanceof ParametersWithIV) {
      ParametersWithIV ivParam = (ParametersWithIV)params;
      byte[] iv = ivParam.getIV();
      int blockSize = getBlockSize();
      int maxCounterSize = (8 > blockSize / 2) ? (blockSize / 2) : 8;
      if (blockSize - iv.length > maxCounterSize)
        throw new IllegalArgumentException("CTR mode requires IV of at least: " + (blockSize - maxCounterSize) + " bytes."); 
      if (this.referenceWrapper == null)
        this.referenceWrapper = new CTRRefWrapper(makeCTRInstance()); 
      if (ivParam.getParameters() == null) {
        init(this.referenceWrapper.getReference(), null, iv);
      } else {
        byte[] key = ((KeyParameter)ivParam.getParameters()).getKey();
        switch (key.length) {
          case 16:
          case 24:
          case 32:
            break;
          default:
            throw new IllegalArgumentException("invalid key length, key must be 16,24 or 32 bytes");
        } 
        init(this.referenceWrapper.getReference(), key, iv);
        this.keyLen = key.length * 8;
      } 
      reset();
    } else {
      throw new IllegalArgumentException("CTR mode requires ParametersWithIV");
    } 
  }
  
  static native long makeCTRInstance();
  
  public String getAlgorithmName() { return "AES/CTR"; }
  
  public byte returnByte(byte in) {
    if (this.referenceWrapper == null)
      throw new IllegalStateException("not initialized"); 
    return returnByte(this.referenceWrapper.getReference(), in);
  }
  
  public int processBytes(byte[] in, int inOff, int len, byte[] out, int outOff) throws DataLengthException, IllegalStateException {
    if (this.referenceWrapper == null)
      throw new IllegalStateException("not initialized"); 
    return processBytes(this.referenceWrapper.getReference(), in, inOff, len, out, outOff);
  }
  
  public void reset() {
    if (this.referenceWrapper == null)
      return; 
    reset(this.referenceWrapper.getReference());
  }
  
  private static native long getPosition(long paramLong);
  
  private static native int getMultiBlockSize(long paramLong);
  
  private static native long skip(long paramLong1, long paramLong2);
  
  private static native long seekTo(long paramLong1, long paramLong2);
  
  static native void init(long paramLong, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2);
  
  private static native byte returnByte(long paramLong, byte paramByte);
  
  private static native int processBytes(long paramLong, byte[] paramArrayOfByte1, int paramInt1, int paramInt2, byte[] paramArrayOfByte2, int paramInt3);
  
  private static native void reset(long paramLong);
  
  static native void dispose(long paramLong);
  
  public String toString() {
    if (this.keyLen > 0)
      return "CTR[Native](CTR[Native](" + this.keyLen + "))"; 
    return "CTR[Native](AES[Native](not initialized))";
  }
}
