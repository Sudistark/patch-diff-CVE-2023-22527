package org.bouncycastle.crypto.engines;

import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.CryptoServicesRegistrar;
import org.bouncycastle.crypto.constraints.DefaultServiceProperties;
import org.bouncycastle.crypto.params.RC5Parameters;

public class RC564Engine implements BlockCipher {
  private static final int wordSize = 64;
  
  private static final int bytesPerWord = 8;
  
  private int _noRounds = 12;
  
  private long[] _S = null;
  
  private static final long P64 = -5196783011329398165L;
  
  private static final long Q64 = -7046029254386353131L;
  
  private boolean forEncryption;
  
  public String getAlgorithmName() { return "RC5-64"; }
  
  public int getBlockSize() { return 16; }
  
  public void init(boolean forEncryption, CipherParameters params) {
    if (!(params instanceof RC5Parameters))
      throw new IllegalArgumentException("invalid parameter passed to RC564 init - " + params.getClass().getName()); 
    RC5Parameters p = (RC5Parameters)params;
    this.forEncryption = forEncryption;
    this._noRounds = p.getRounds();
    byte[] key = p.getKey();
    setKey(key);
    CryptoServicesRegistrar.checkConstraints(new DefaultServiceProperties(getAlgorithmName(), key.length * 8, params, Utils.getPurpose(forEncryption)));
  }
  
  public int processBlock(byte[] in, int inOff, byte[] out, int outOff) { return this.forEncryption ? encryptBlock(in, inOff, out, outOff) : 
      decryptBlock(in, inOff, out, outOff); }
  
  public void reset() {}
  
  private void setKey(byte[] key) {
    long[] L = new long[(key.length + 7) / 8];
    for (int i = 0; i != key.length; i++)
      L[i / 8] = L[i / 8] + ((key[i] & 0xFF) << 8 * i % 8); 
    this._S = new long[2 * (this._noRounds + 1)];
    this._S[0] = -5196783011329398165L;
    int iter;
    for (iter = 1; iter < this._S.length; iter++)
      this._S[iter] = this._S[iter - 1] + -7046029254386353131L; 
    if (L.length > this._S.length) {
      int iter = 3 * L.length;
    } else {
      iter = 3 * this._S.length;
    } 
    long A = 0L, B = 0L;
    int i = 0, j = 0;
    for (int k = 0; k < iter; k++) {
      A = this._S[i] = rotateLeft(this._S[i] + A + B, 3L);
      B = L[j] = rotateLeft(L[j] + A + B, A + B);
      i = (i + 1) % this._S.length;
      j = (j + 1) % L.length;
    } 
  }
  
  private int encryptBlock(byte[] in, int inOff, byte[] out, int outOff) {
    long A = bytesToWord(in, inOff) + this._S[0];
    long B = bytesToWord(in, inOff + 8) + this._S[1];
    for (int i = 1; i <= this._noRounds; i++) {
      A = rotateLeft(A ^ B, B) + this._S[2 * i];
      B = rotateLeft(B ^ A, A) + this._S[2 * i + 1];
    } 
    wordToBytes(A, out, outOff);
    wordToBytes(B, out, outOff + 8);
    return 16;
  }
  
  private int decryptBlock(byte[] in, int inOff, byte[] out, int outOff) {
    long A = bytesToWord(in, inOff);
    long B = bytesToWord(in, inOff + 8);
    for (int i = this._noRounds; i >= 1; i--) {
      B = rotateRight(B - this._S[2 * i + 1], A) ^ A;
      A = rotateRight(A - this._S[2 * i], B) ^ B;
    } 
    wordToBytes(A - this._S[0], out, outOff);
    wordToBytes(B - this._S[1], out, outOff + 8);
    return 16;
  }
  
  private long rotateLeft(long x, long y) { return x << (int)(y & 0x3FL) | x >>> (int)(64L - (y & 0x3FL)); }
  
  private long rotateRight(long x, long y) { return x >>> (int)(y & 0x3FL) | x << (int)(64L - (y & 0x3FL)); }
  
  private long bytesToWord(byte[] src, int srcOff) {
    long word = 0L;
    for (int i = 7; i >= 0; i--)
      word = (word << 8) + (src[i + srcOff] & 0xFF); 
    return word;
  }
  
  private void wordToBytes(long word, byte[] dst, int dstOff) {
    for (int i = 0; i < 8; i++) {
      dst[i + dstOff] = (byte)(int)word;
      word >>>= 8;
    } 
  }
}
