package org.bouncycastle.crypto.hpke;

import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.crypto.engines.AESEngine;
import org.bouncycastle.crypto.modes.AEADCipher;
import org.bouncycastle.crypto.modes.ChaCha20Poly1305;
import org.bouncycastle.crypto.modes.GCMBlockCipher;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.ParametersWithIV;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Pack;

public class AEAD {
  private final short aeadId;
  
  private final byte[] key;
  
  private final byte[] baseNonce;
  
  private long seq;
  
  private AEADCipher cipher;
  
  public AEAD(short aeadId, byte[] key, byte[] baseNonce) {
    this.seq = 0L;
    this.key = key;
    this.baseNonce = baseNonce;
    this.aeadId = aeadId;
    this.seq = 0L;
    switch (aeadId) {
      case 1:
      case 2:
        this.cipher = GCMBlockCipher.newInstance(AESEngine.newInstance());
        break;
      case 3:
        this.cipher = new ChaCha20Poly1305();
        break;
    } 
  }
  
  public byte[] seal(byte[] aad, byte[] pt) throws InvalidCipherTextException {
    int len;
    byte[] ct;
    ParametersWithIV parametersWithIV;
    switch (this.aeadId) {
      case 1:
      case 2:
      case 3:
        parametersWithIV = new ParametersWithIV(new KeyParameter(this.key), ComputeNonce());
        this.cipher.init(true, parametersWithIV);
        this.cipher.processAADBytes(aad, 0, aad.length);
        ct = new byte[this.cipher.getOutputSize(pt.length)];
        len = this.cipher.processBytes(pt, 0, pt.length, ct, 0);
        this.cipher.doFinal(ct, len);
        this.seq++;
        return ct;
    } 
    throw new IllegalStateException("Export only mode, cannot be used to seal/open");
  }
  
  public byte[] open(byte[] aad, byte[] ct) throws InvalidCipherTextException {
    int len;
    byte[] pt;
    ParametersWithIV parametersWithIV;
    switch (this.aeadId) {
      case 1:
      case 2:
      case 3:
        parametersWithIV = new ParametersWithIV(new KeyParameter(this.key), ComputeNonce());
        this.cipher.init(false, parametersWithIV);
        this.cipher.processAADBytes(aad, 0, aad.length);
        pt = new byte[this.cipher.getOutputSize(ct.length)];
        len = this.cipher.processBytes(ct, 0, ct.length, pt, 0);
        len += this.cipher.doFinal(pt, len);
        this.seq++;
        return pt;
    } 
    throw new IllegalStateException("Export only mode, cannot be used to seal/open");
  }
  
  private byte[] ComputeNonce() {
    byte[] seq_bytes = Pack.longToBigEndian(this.seq);
    int Nn = this.baseNonce.length;
    byte[] nonce = Arrays.clone(this.baseNonce);
    for (int i = 0; i < 8; i++)
      nonce[Nn - 8 + i] = (byte)(nonce[Nn - 8 + i] ^ seq_bytes[i]); 
    return nonce;
  }
}
