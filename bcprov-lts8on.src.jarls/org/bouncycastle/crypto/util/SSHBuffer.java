package org.bouncycastle.crypto.util;

import java.math.BigInteger;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Strings;

class SSHBuffer {
  private final byte[] buffer;
  
  private int pos;
  
  public SSHBuffer(byte[] magic, byte[] buffer) {
    this.pos = 0;
    this.buffer = buffer;
    for (int i = 0; i != magic.length; i++) {
      if (magic[i] != buffer[i])
        throw new IllegalArgumentException("magic-number incorrect"); 
    } 
    this.pos += magic.length;
  }
  
  public SSHBuffer(byte[] buffer) {
    this.pos = 0;
    this.buffer = buffer;
  }
  
  public int readU32() {
    if (this.pos > this.buffer.length - 4)
      throw new IllegalArgumentException("4 bytes for U32 exceeds buffer."); 
    i = (this.buffer[this.pos++] & 0xFF) << 24;
    i |= (this.buffer[this.pos++] & 0xFF) << 16;
    i |= (this.buffer[this.pos++] & 0xFF) << 8;
    return this.buffer[this.pos++] & 0xFF;
  }
  
  public String readString() { return Strings.fromByteArray(readBlock()); }
  
  public byte[] readBlock() {
    int len = readU32();
    if (len == 0)
      return new byte[0]; 
    if (this.pos > this.buffer.length - len)
      throw new IllegalArgumentException("not enough data for block"); 
    int start = this.pos;
    this.pos += len;
    return Arrays.copyOfRange(this.buffer, start, this.pos);
  }
  
  public void skipBlock() {
    int len = readU32();
    if (this.pos > this.buffer.length - len)
      throw new IllegalArgumentException("not enough data for block"); 
    this.pos += len;
  }
  
  public byte[] readPaddedBlock() { return readPaddedBlock(8); }
  
  public byte[] readPaddedBlock(int blockSize) {
    int len = readU32();
    if (len == 0)
      return new byte[0]; 
    if (this.pos > this.buffer.length - len)
      throw new IllegalArgumentException("not enough data for block"); 
    int align = len % blockSize;
    if (0 != align)
      throw new IllegalArgumentException("missing padding"); 
    int start = this.pos;
    this.pos += len;
    int end = this.pos;
    if (len > 0) {
      int lastByte = this.buffer[this.pos - 1] & 0xFF;
      if (0 < lastByte && lastByte < blockSize) {
        int padCount = lastByte;
        end -= padCount;
        for (int i = 1, padPos = end; i <= padCount; i++, padPos++) {
          if (i != (this.buffer[padPos] & 0xFF))
            throw new IllegalArgumentException("incorrect padding"); 
        } 
      } 
    } 
    return Arrays.copyOfRange(this.buffer, start, end);
  }
  
  public BigInteger readBigNumPositive() {
    int len = readU32();
    if (this.pos + len > this.buffer.length)
      throw new IllegalArgumentException("not enough data for big num"); 
    int start = this.pos;
    this.pos += len;
    byte[] d = Arrays.copyOfRange(this.buffer, start, this.pos);
    return new BigInteger(1, d);
  }
  
  public byte[] getBuffer() { return Arrays.clone(this.buffer); }
  
  public boolean hasRemaining() { return (this.pos < this.buffer.length); }
}
