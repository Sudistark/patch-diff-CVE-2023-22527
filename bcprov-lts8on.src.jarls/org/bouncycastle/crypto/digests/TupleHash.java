package org.bouncycastle.crypto.digests;

import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.Digest;
import org.bouncycastle.crypto.Xof;
import org.bouncycastle.util.Strings;

public class TupleHash implements Xof, Digest {
  private static final byte[] N_TUPLE_HASH = Strings.toByteArray("TupleHash");
  
  private final CSHAKEDigest cshake;
  
  private final int bitLength;
  
  private final int outputLength;
  
  private boolean firstOutput;
  
  public TupleHash(int bitLength, byte[] S) { this(bitLength, S, bitLength * 2); }
  
  public TupleHash(int bitLength, byte[] S, int outputSize) {
    this.cshake = new CSHAKEDigest(bitLength, N_TUPLE_HASH, S);
    this.bitLength = bitLength;
    this.outputLength = (outputSize + 7) / 8;
    reset();
  }
  
  public TupleHash(TupleHash original) {
    this.cshake = new CSHAKEDigest(original.cshake);
    this.bitLength = this.cshake.fixedOutputLength;
    this.outputLength = this.bitLength * 2 / 8;
    this.firstOutput = original.firstOutput;
  }
  
  public String getAlgorithmName() { return "TupleHash" + this.cshake.getAlgorithmName().substring(6); }
  
  public int getByteLength() { return this.cshake.getByteLength(); }
  
  public int getDigestSize() { return this.outputLength; }
  
  public void update(byte in) throws IllegalStateException {
    byte[] bytes = XofUtils.encode(in);
    this.cshake.update(bytes, 0, bytes.length);
  }
  
  public void update(byte[] in, int inOff, int len) throws DataLengthException, IllegalStateException {
    byte[] bytes = XofUtils.encode(in, inOff, len);
    this.cshake.update(bytes, 0, bytes.length);
  }
  
  private void wrapUp(int outputSize) {
    byte[] encOut = XofUtils.rightEncode(outputSize * 8L);
    this.cshake.update(encOut, 0, encOut.length);
    this.firstOutput = false;
  }
  
  public int doFinal(byte[] out, int outOff) throws DataLengthException, IllegalStateException {
    if (this.firstOutput)
      wrapUp(getDigestSize()); 
    int rv = this.cshake.doFinal(out, outOff, getDigestSize());
    reset();
    return rv;
  }
  
  public int doFinal(byte[] out, int outOff, int outLen) {
    if (this.firstOutput)
      wrapUp(getDigestSize()); 
    int rv = this.cshake.doFinal(out, outOff, outLen);
    reset();
    return rv;
  }
  
  public int doOutput(byte[] out, int outOff, int outLen) {
    if (this.firstOutput)
      wrapUp(0); 
    return this.cshake.doOutput(out, outOff, outLen);
  }
  
  public void reset() {
    this.cshake.reset();
    this.firstOutput = true;
  }
}
