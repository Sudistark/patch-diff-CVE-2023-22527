package org.bouncycastle.crypto.macs;

import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.Mac;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.util.Pack;

public class SipHash implements Mac {
  protected final int c;
  
  protected final int d;
  
  protected long k0;
  
  protected long k1;
  
  protected long v0;
  
  protected long v1;
  
  protected long v2;
  
  protected long v3;
  
  protected long m = 0L;
  
  protected int wordPos = 0;
  
  protected int wordCount = 0;
  
  public SipHash() {
    this.c = 2;
    this.d = 4;
  }
  
  public SipHash(int c, int d) {
    this.c = c;
    this.d = d;
  }
  
  public String getAlgorithmName() { return "SipHash-" + this.c + "-" + this.d; }
  
  public int getMacSize() { return 8; }
  
  public void init(CipherParameters params) throws IllegalArgumentException {
    if (!(params instanceof KeyParameter))
      throw new IllegalArgumentException("'params' must be an instance of KeyParameter"); 
    KeyParameter keyParameter = (KeyParameter)params;
    byte[] key = keyParameter.getKey();
    if (key.length != 16)
      throw new IllegalArgumentException("'params' must be a 128-bit key"); 
    this.k0 = Pack.littleEndianToLong(key, 0);
    this.k1 = Pack.littleEndianToLong(key, 8);
    reset();
  }
  
  public void update(byte input) throws IllegalStateException {
    this.m >>>= 8;
    this.m |= (input & 0xFFL) << 56;
    if (++this.wordPos == 8) {
      processMessageWord();
      this.wordPos = 0;
    } 
  }
  
  public void update(byte[] input, int offset, int length) throws DataLengthException, IllegalStateException {
    int i = 0, fullWords = length & 0xFFFFFFF8;
    if (this.wordPos == 0) {
      for (; i < fullWords; i += 8) {
        this.m = Pack.littleEndianToLong(input, offset + i);
        processMessageWord();
      } 
      for (; i < length; i++) {
        this.m >>>= 8;
        this.m |= (input[offset + i] & 0xFFL) << 56;
      } 
      this.wordPos = length - fullWords;
    } else {
      int bits = this.wordPos << 3;
      for (; i < fullWords; i += 8) {
        long n = Pack.littleEndianToLong(input, offset + i);
        this.m = n << bits | this.m >>> -bits;
        processMessageWord();
        this.m = n;
      } 
      for (; i < length; i++) {
        this.m >>>= 8;
        this.m |= (input[offset + i] & 0xFFL) << 56;
        if (++this.wordPos == 8) {
          processMessageWord();
          this.wordPos = 0;
        } 
      } 
    } 
  }
  
  public long doFinal() throws DataLengthException, IllegalStateException {
    this.m >>>= 7 - this.wordPos << 3;
    this.m >>>= 8;
    this.m |= (((this.wordCount << 3) + this.wordPos) & 0xFFL) << 56;
    processMessageWord();
    this.v2 ^= 0xFFL;
    applySipRounds(this.d);
    long result = this.v0 ^ this.v1 ^ this.v2 ^ this.v3;
    reset();
    return result;
  }
  
  public int doFinal(byte[] out, int outOff) throws DataLengthException, IllegalStateException {
    long result = doFinal();
    Pack.longToLittleEndian(result, out, outOff);
    return 8;
  }
  
  public void reset() {
    this.v0 = this.k0 ^ 0x736F6D6570736575L;
    this.v1 = this.k1 ^ 0x646F72616E646F6DL;
    this.v2 = this.k0 ^ 0x6C7967656E657261L;
    this.v3 = this.k1 ^ 0x7465646279746573L;
    this.m = 0L;
    this.wordPos = 0;
    this.wordCount = 0;
  }
  
  protected void processMessageWord() {
    this.wordCount++;
    this.v3 ^= this.m;
    applySipRounds(this.c);
    this.v0 ^= this.m;
  }
  
  protected void applySipRounds(int n) {
    long r0 = this.v0, r1 = this.v1, r2 = this.v2, r3 = this.v3;
    for (int r = 0; r < n; r++) {
      r0 += r1;
      r2 += r3;
      r1 = rotateLeft(r1, 13);
      r3 = rotateLeft(r3, 16);
      r1 ^= r0;
      r3 ^= r2;
      r0 = rotateLeft(r0, 32);
      r2 += r1;
      r0 += r3;
      r1 = rotateLeft(r1, 17);
      r3 = rotateLeft(r3, 21);
      r1 ^= r2;
      r3 ^= r0;
      r2 = rotateLeft(r2, 32);
    } 
    this.v0 = r0;
    this.v1 = r1;
    this.v2 = r2;
    this.v3 = r3;
  }
  
  protected static long rotateLeft(long x, int n) { return x << n | x >>> -n; }
}
