package org.bouncycastle.crypto.signers;

import java.math.BigInteger;
import java.security.SecureRandom;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.CryptoServicesRegistrar;
import org.bouncycastle.crypto.DSAExt;
import org.bouncycastle.crypto.params.ECDomainParameters;
import org.bouncycastle.crypto.params.ECKeyParameters;
import org.bouncycastle.crypto.params.ECPrivateKeyParameters;
import org.bouncycastle.crypto.params.ECPublicKeyParameters;
import org.bouncycastle.crypto.params.ParametersWithRandom;
import org.bouncycastle.math.ec.ECAlgorithms;
import org.bouncycastle.math.ec.ECConstants;
import org.bouncycastle.math.ec.ECCurve;
import org.bouncycastle.math.ec.ECFieldElement;
import org.bouncycastle.math.ec.ECMultiplier;
import org.bouncycastle.math.ec.ECPoint;
import org.bouncycastle.math.ec.FixedPointCombMultiplier;
import org.bouncycastle.util.BigIntegers;

public class ECDSASigner implements ECConstants, DSAExt {
  private final DSAKCalculator kCalculator;
  
  private ECKeyParameters key;
  
  private SecureRandom random;
  
  public ECDSASigner() { this.kCalculator = new RandomDSAKCalculator(); }
  
  public ECDSASigner(DSAKCalculator kCalculator) { this.kCalculator = kCalculator; }
  
  public void init(boolean forSigning, CipherParameters param) {
    SecureRandom providedRandom = null;
    if (forSigning) {
      if (param instanceof ParametersWithRandom) {
        ParametersWithRandom rParam = (ParametersWithRandom)param;
        this.key = (ECPrivateKeyParameters)rParam.getParameters();
        providedRandom = rParam.getRandom();
      } else {
        this.key = (ECPrivateKeyParameters)param;
      } 
    } else {
      this.key = (ECPublicKeyParameters)param;
    } 
    CryptoServicesRegistrar.checkConstraints(Utils.getDefaultProperties("ECDSA", this.key, forSigning));
    this.random = initSecureRandom((forSigning && !this.kCalculator.isDeterministic()), providedRandom);
  }
  
  public BigInteger getOrder() { return this.key.getParameters().getN(); }
  
  public BigInteger[] generateSignature(byte[] message) {
    BigInteger s, r;
    ECDomainParameters ec = this.key.getParameters();
    BigInteger n = ec.getN();
    BigInteger e = calculateE(n, message);
    BigInteger d = ((ECPrivateKeyParameters)this.key).getD();
    if (this.kCalculator.isDeterministic()) {
      this.kCalculator.init(n, d, message);
    } else {
      this.kCalculator.init(n, this.random);
    } 
    ECMultiplier basePointMultiplier = createBasePointMultiplier();
    while (true) {
      BigInteger k = this.kCalculator.nextK();
      ECPoint p = basePointMultiplier.multiply(ec.getG(), k).normalize();
      r = p.getAffineXCoord().toBigInteger().mod(n);
      if (!r.equals(ZERO)) {
        s = BigIntegers.modOddInverse(n, k).multiply(e.add(d.multiply(r))).mod(n);
        if (!s.equals(ZERO))
          break; 
      } 
    } 
    return new BigInteger[] { r, s };
  }
  
  public boolean verifySignature(byte[] message, BigInteger r, BigInteger s) {
    ECDomainParameters ec = this.key.getParameters();
    BigInteger n = ec.getN();
    BigInteger e = calculateE(n, message);
    if (r.compareTo(ONE) < 0 || r.compareTo(n) >= 0)
      return false; 
    if (s.compareTo(ONE) < 0 || s.compareTo(n) >= 0)
      return false; 
    BigInteger c = BigIntegers.modOddInverseVar(n, s);
    BigInteger u1 = e.multiply(c).mod(n);
    BigInteger u2 = r.multiply(c).mod(n);
    ECPoint G = ec.getG();
    ECPoint Q = ((ECPublicKeyParameters)this.key).getQ();
    ECPoint point = ECAlgorithms.sumOfTwoMultiplies(G, u1, Q, u2);
    if (point.isInfinity())
      return false; 
    ECCurve curve = point.getCurve();
    if (curve != null) {
      BigInteger cofactor = curve.getCofactor();
      if (cofactor != null && cofactor.compareTo(EIGHT) <= 0) {
        ECFieldElement D = getDenominator(curve.getCoordinateSystem(), point);
        if (D != null && !D.isZero()) {
          ECFieldElement X = point.getXCoord();
          while (curve.isValidFieldElement(r)) {
            ECFieldElement R = curve.fromBigInteger(r).multiply(D);
            if (R.equals(X))
              return true; 
            r = r.add(n);
          } 
          return false;
        } 
      } 
    } 
    BigInteger v = point.normalize().getAffineXCoord().toBigInteger().mod(n);
    return v.equals(r);
  }
  
  protected BigInteger calculateE(BigInteger n, byte[] message) {
    int log2n = n.bitLength();
    int messageBitLength = message.length * 8;
    BigInteger e = new BigInteger(1, message);
    if (log2n < messageBitLength)
      e = e.shiftRight(messageBitLength - log2n); 
    return e;
  }
  
  protected ECMultiplier createBasePointMultiplier() { return new FixedPointCombMultiplier(); }
  
  protected ECFieldElement getDenominator(int coordinateSystem, ECPoint p) {
    switch (coordinateSystem) {
      case 1:
      case 6:
      case 7:
        return p.getZCoord(0);
      case 2:
      case 3:
      case 4:
        return p.getZCoord(0).square();
    } 
    return null;
  }
  
  protected SecureRandom initSecureRandom(boolean needed, SecureRandom provided) { return needed ? CryptoServicesRegistrar.getSecureRandom(provided) : null; }
}
