package org.bouncycastle.crypto.modes;

import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.NativeBlockCipherProvider;
import org.bouncycastle.crypto.OutputLengthException;
import org.bouncycastle.crypto.SkippingStreamCipher;
import org.bouncycastle.crypto.StreamBlockCipher;
import org.bouncycastle.crypto.StreamCipher;
import org.bouncycastle.crypto.params.ParametersWithIV;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Pack;

public class SICBlockCipher extends StreamBlockCipher implements SkippingStreamCipher {
  private final BlockCipher cipher;
  
  private final int blockSize;
  
  private byte[] IV;
  
  private byte[] counter;
  
  private byte[] counterOut;
  
  private int byteCount;
  
  public static StreamCipher newInstance(BlockCipher cipher) {
    if (cipher instanceof NativeBlockCipherProvider)
      return ((NativeBlockCipherProvider)cipher).createCTR(); 
    return new SICBlockCipher(cipher);
  }
  
  public SICBlockCipher(BlockCipher c) {
    super(c);
    this.cipher = c;
    this.blockSize = this.cipher.getBlockSize();
    this.IV = new byte[this.blockSize];
    this.counter = new byte[this.blockSize];
    this.counterOut = new byte[this.blockSize];
    this.byteCount = 0;
  }
  
  public void init(boolean forEncryption, CipherParameters params) throws IllegalArgumentException {
    if (params instanceof ParametersWithIV) {
      ParametersWithIV ivParam = (ParametersWithIV)params;
      this.IV = Arrays.clone(ivParam.getIV());
      if (this.blockSize < this.IV.length)
        throw new IllegalArgumentException("CTR/SIC mode requires IV no greater than: " + this.blockSize + " bytes."); 
      int maxCounterSize = (8 > this.blockSize / 2) ? (this.blockSize / 2) : 8;
      if (this.blockSize - this.IV.length > maxCounterSize)
        throw new IllegalArgumentException("CTR/SIC mode requires IV of at least: " + (this.blockSize - maxCounterSize) + " bytes."); 
      if (ivParam.getParameters() != null)
        this.cipher.init(true, ivParam.getParameters()); 
      reset();
    } else {
      throw new IllegalArgumentException("CTR/SIC mode requires ParametersWithIV");
    } 
  }
  
  public String getAlgorithmName() { return this.cipher.getAlgorithmName() + "/SIC"; }
  
  public int getBlockSize() { return this.cipher.getBlockSize(); }
  
  public int processBlock(byte[] in, int inOff, byte[] out, int outOff) throws DataLengthException, IllegalStateException {
    if (this.byteCount != 0) {
      processBytes(in, inOff, this.blockSize, out, outOff);
      return this.blockSize;
    } 
    if (inOff + this.blockSize > in.length)
      throw new DataLengthException("input buffer too small"); 
    if (outOff + this.blockSize > out.length)
      throw new OutputLengthException("output buffer too short"); 
    this.cipher.processBlock(this.counter, 0, this.counterOut, 0);
    for (int i = 0; i < this.blockSize; i++)
      out[outOff + i] = (byte)(in[inOff + i] ^ this.counterOut[i]); 
    incrementCounter();
    return this.blockSize;
  }
  
  public int processBytes(byte[] in, int inOff, int len, byte[] out, int outOff) throws DataLengthException {
    if (inOff + len > in.length)
      throw new DataLengthException("input buffer too small"); 
    if (outOff + len > out.length)
      throw new OutputLengthException("output buffer too short"); 
    for (int i = 0; i < len; i++) {
      byte next;
      if (this.byteCount == 0) {
        checkLastIncrement();
        this.cipher.processBlock(this.counter, 0, this.counterOut, 0);
        next = (byte)(in[inOff + i] ^ this.counterOut[this.byteCount++]);
      } else {
        next = (byte)(in[inOff + i] ^ this.counterOut[this.byteCount++]);
        if (this.byteCount == this.counter.length) {
          this.byteCount = 0;
          incrementCounter();
        } 
      } 
      out[outOff + i] = next;
    } 
    return len;
  }
  
  protected byte calculateByte(byte in) throws DataLengthException, IllegalStateException {
    if (this.byteCount == 0) {
      checkLastIncrement();
      this.cipher.processBlock(this.counter, 0, this.counterOut, 0);
      return (byte)(this.counterOut[this.byteCount++] ^ in);
    } 
    byte rv = (byte)(this.counterOut[this.byteCount++] ^ in);
    if (this.byteCount == this.counter.length) {
      this.byteCount = 0;
      incrementCounter();
    } 
    return rv;
  }
  
  private void checkCounter() {
    if (this.IV.length < this.blockSize)
      for (int i = this.IV.length - 1; i >= 0; i--) {
        if (this.counter[i] != this.IV[i])
          throw new IllegalStateException("Counter in CTR/SIC mode out of range."); 
      }  
  }
  
  private void checkLastIncrement() {
    if (this.IV.length < this.blockSize)
      if (this.counter[this.IV.length - 1] != this.IV[this.IV.length - 1])
        throw new IllegalStateException("Counter in CTR/SIC mode out of range.");  
  }
  
  private void incrementCounter() {
    int i = this.counter.length;
    while (--i >= 0) {
      this.counter[i] = (byte)(this.counter[i] + 1);
      if ((byte)(this.counter[i] + 1) != 0)
        break; 
    } 
  }
  
  private void incrementCounterAt(int pos) {
    int i = this.counter.length - pos;
    while (--i >= 0) {
      this.counter[i] = (byte)(this.counter[i] + 1);
      if ((byte)(this.counter[i] + 1) != 0)
        break; 
    } 
  }
  
  private void incrementCounter(int offSet) {
    byte old = this.counter[this.counter.length - 1];
    this.counter[this.counter.length - 1] = (byte)(this.counter[this.counter.length - 1] + offSet);
    if (old != 0 && this.counter[this.counter.length - 1] < old)
      incrementCounterAt(1); 
  }
  
  private void decrementCounterAt(int pos) {
    int i = this.counter.length - pos;
    while (--i >= 0) {
      this.counter[i] = (byte)(this.counter[i] - 1);
      if ((byte)(this.counter[i] - 1) != -1)
        return; 
    } 
  }
  
  private void adjustCounter(long n) {
    if (n >= 0L) {
      long numBlocks = (n + this.byteCount) / this.blockSize;
      long rem = numBlocks;
      if (rem > 255L)
        for (int i = 5; i >= 1; i--) {
          long diff = 1L << 8 * i;
          while (rem >= diff) {
            incrementCounterAt(i);
            rem -= diff;
          } 
        }  
      incrementCounter((int)rem);
      this.byteCount = (int)(n + this.byteCount - this.blockSize * numBlocks);
    } else {
      long numBlocks = (-n - this.byteCount) / this.blockSize;
      long rem = numBlocks;
      if (rem > 255L)
        for (int i = 5; i >= 1; i--) {
          long diff = 1L << 8 * i;
          while (rem > diff) {
            decrementCounterAt(i);
            rem -= diff;
          } 
        }  
      long i;
      for (i = 0L; i != rem; i++)
        decrementCounterAt(0); 
      int gap = (int)(this.byteCount + n + this.blockSize * numBlocks);
      if (gap >= 0) {
        this.byteCount = 0;
      } else {
        decrementCounterAt(0);
        this.byteCount = this.blockSize + gap;
      } 
    } 
  }
  
  public void reset() {
    Arrays.fill(this.counter, (byte)0);
    System.arraycopy(this.IV, 0, this.counter, 0, this.IV.length);
    this.cipher.reset();
    this.byteCount = 0;
  }
  
  public long skip(long numberOfBytes) {
    adjustCounter(numberOfBytes);
    checkCounter();
    this.cipher.processBlock(this.counter, 0, this.counterOut, 0);
    return numberOfBytes;
  }
  
  public long seekTo(long position) {
    reset();
    return skip(position);
  }
  
  public long getPosition() {
    byte[] res = new byte[this.counter.length];
    System.arraycopy(this.counter, 0, res, 0, res.length);
    for (int i = res.length - 1; i >= 1; i--) {
      int v;
      if (i < this.IV.length) {
        v = (res[i] & 0xFF) - (this.IV[i] & 0xFF);
      } else {
        v = res[i] & 0xFF;
      } 
      if (v < 0) {
        res[i - 1] = (byte)(res[i - 1] - 1);
        v += 256;
      } 
      res[i] = (byte)v;
    } 
    return Pack.bigEndianToLong(res, res.length - 8) * this.blockSize + this.byteCount;
  }
}
