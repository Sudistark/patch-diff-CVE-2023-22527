package org.bouncycastle.asn1;

import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.SimpleTimeZone;
import java.util.TimeZone;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Strings;

public class ASN1GeneralizedTime extends ASN1Primitive {
  static final ASN1UniversalType TYPE = new Object(ASN1GeneralizedTime.class, 24);
  
  final byte[] contents;
  
  public static ASN1GeneralizedTime getInstance(Object obj) {
    if (obj == null || obj instanceof ASN1GeneralizedTime)
      return (ASN1GeneralizedTime)obj; 
    if (obj instanceof ASN1Encodable) {
      ASN1Primitive primitive = ((ASN1Encodable)obj).toASN1Primitive();
      if (primitive instanceof ASN1GeneralizedTime)
        return (ASN1GeneralizedTime)primitive; 
    } 
    if (obj instanceof byte[])
      try {
        return (ASN1GeneralizedTime)TYPE.fromByteArray((byte[])obj);
      } catch (Exception e) {
        throw new IllegalArgumentException("encoding error in getInstance: " + e.toString());
      }  
    throw new IllegalArgumentException("illegal object in getInstance: " + obj.getClass().getName());
  }
  
  public static ASN1GeneralizedTime getInstance(ASN1TaggedObject taggedObject, boolean explicit) { return (ASN1GeneralizedTime)TYPE.getContextInstance(taggedObject, explicit); }
  
  public ASN1GeneralizedTime(String time) {
    this.contents = Strings.toByteArray(time);
    try {
      getDate();
    } catch (ParseException e) {
      throw new IllegalArgumentException("invalid date string: " + e.getMessage());
    } 
  }
  
  public ASN1GeneralizedTime(Date time) {
    SimpleDateFormat dateF = new SimpleDateFormat("yyyyMMddHHmmss'Z'", LocaleUtil.EN_Locale);
    dateF.setTimeZone(new SimpleTimeZone(0, "Z"));
    this.contents = Strings.toByteArray(dateF.format(time));
  }
  
  public ASN1GeneralizedTime(Date time, Locale locale) {
    SimpleDateFormat dateF = new SimpleDateFormat("yyyyMMddHHmmss'Z'", locale);
    dateF.setTimeZone(new SimpleTimeZone(0, "Z"));
    this.contents = Strings.toByteArray(dateF.format(time));
  }
  
  ASN1GeneralizedTime(byte[] bytes) {
    if (bytes.length < 4)
      throw new IllegalArgumentException("GeneralizedTime string too short"); 
    this.contents = bytes;
    if (!isDigit(0) || !isDigit(1) || !isDigit(2) || !isDigit(3))
      throw new IllegalArgumentException("illegal characters in GeneralizedTime string"); 
  }
  
  public String getTimeString() { return Strings.fromByteArray(this.contents); }
  
  public String getTime() {
    String stime = Strings.fromByteArray(this.contents);
    if (stime.charAt(stime.length() - 1) == 'Z')
      return stime.substring(0, stime.length() - 1) + "GMT+00:00"; 
    int signPos = stime.length() - 6;
    char sign = stime.charAt(signPos);
    if ((sign == '-' || sign == '+') && stime.indexOf("GMT") == signPos - 3)
      return stime; 
    signPos = stime.length() - 5;
    sign = stime.charAt(signPos);
    if (sign == '-' || sign == '+')
      return stime.substring(0, signPos) + "GMT" + stime
        
        .substring(signPos, signPos + 3) + ":" + stime
        
        .substring(signPos + 3); 
    signPos = stime.length() - 3;
    sign = stime.charAt(signPos);
    if (sign == '-' || sign == '+')
      return stime.substring(0, signPos) + "GMT" + stime
        
        .substring(signPos) + ":00"; 
    return stime + calculateGMTOffset(stime);
  }
  
  private String calculateGMTOffset(String stime) {
    String sign = "+";
    TimeZone timeZone = TimeZone.getDefault();
    int offset = timeZone.getRawOffset();
    if (offset < 0) {
      sign = "-";
      offset = -offset;
    } 
    int hours = offset / 3600000;
    int minutes = (offset - hours * 60 * 60 * 1000) / 60000;
    try {
      if (timeZone.useDaylightTime()) {
        if (hasFractionalSeconds())
          stime = pruneFractionalSeconds(stime); 
        SimpleDateFormat dateF = calculateGMTDateFormat();
        if (timeZone.inDaylightTime(dateF
            .parse(stime + "GMT" + sign + convert(hours) + ":" + convert(minutes))))
          hours += (sign.equals("+") ? 1 : -1); 
      } 
    } catch (ParseException parseException) {}
    return "GMT" + sign + convert(hours) + ":" + convert(minutes);
  }
  
  private SimpleDateFormat calculateGMTDateFormat() {
    SimpleDateFormat dateF;
    if (hasFractionalSeconds()) {
      dateF = new SimpleDateFormat("yyyyMMddHHmmss.SSSz");
    } else if (hasSeconds()) {
      dateF = new SimpleDateFormat("yyyyMMddHHmmssz");
    } else if (hasMinutes()) {
      dateF = new SimpleDateFormat("yyyyMMddHHmmz");
    } else {
      dateF = new SimpleDateFormat("yyyyMMddHHz");
    } 
    dateF.setTimeZone(new SimpleTimeZone(0, "Z"));
    return dateF;
  }
  
  private String pruneFractionalSeconds(String origTime) {
    String frac = origTime.substring(14);
    int index;
    for (index = 1; index < frac.length(); index++) {
      char ch = frac.charAt(index);
      if ('0' > ch || ch > '9')
        break; 
    } 
    if (index - 1 > 3) {
      frac = frac.substring(0, 4) + frac.substring(index);
      origTime = origTime.substring(0, 14) + frac;
    } else if (index - 1 == 1) {
      frac = frac.substring(0, index) + "00" + frac.substring(index);
      origTime = origTime.substring(0, 14) + frac;
    } else if (index - 1 == 2) {
      frac = frac.substring(0, index) + "0" + frac.substring(index);
      origTime = origTime.substring(0, 14) + frac;
    } 
    return origTime;
  }
  
  private String convert(int time) {
    if (time < 10)
      return "0" + time; 
    return Integer.toString(time);
  }
  
  public Date getDate() throws ParseException {
    SimpleDateFormat dateF;
    String stime = Strings.fromByteArray(this.contents);
    String d = stime;
    if (stime.endsWith("Z")) {
      if (hasFractionalSeconds()) {
        dateF = new SimpleDateFormat("yyyyMMddHHmmss.SSS'Z'", LocaleUtil.EN_Locale);
      } else if (hasSeconds()) {
        dateF = new SimpleDateFormat("yyyyMMddHHmmss'Z'", LocaleUtil.EN_Locale);
      } else if (hasMinutes()) {
        dateF = new SimpleDateFormat("yyyyMMddHHmm'Z'", LocaleUtil.EN_Locale);
      } else {
        dateF = new SimpleDateFormat("yyyyMMddHH'Z'", LocaleUtil.EN_Locale);
      } 
      dateF.setTimeZone(new SimpleTimeZone(0, "Z"));
    } else if (stime.indexOf('-') > 0 || stime.indexOf('+') > 0) {
      d = getTime();
      dateF = calculateGMTDateFormat();
    } else {
      if (hasFractionalSeconds()) {
        dateF = new SimpleDateFormat("yyyyMMddHHmmss.SSS");
      } else if (hasSeconds()) {
        dateF = new SimpleDateFormat("yyyyMMddHHmmss");
      } else if (hasMinutes()) {
        dateF = new SimpleDateFormat("yyyyMMddHHmm");
      } else {
        dateF = new SimpleDateFormat("yyyyMMddHH");
      } 
      dateF.setTimeZone(new SimpleTimeZone(0, TimeZone.getDefault().getID()));
    } 
    if (hasFractionalSeconds())
      d = pruneFractionalSeconds(d); 
    return dateF.parse(d);
  }
  
  protected boolean hasFractionalSeconds() {
    for (int i = 0; i != this.contents.length; i++) {
      if (this.contents[i] == 46)
        if (i == 14)
          return true;  
    } 
    return false;
  }
  
  protected boolean hasSeconds() { return (isDigit(12) && isDigit(13)); }
  
  protected boolean hasMinutes() { return (isDigit(10) && isDigit(11)); }
  
  private boolean isDigit(int pos) { return (this.contents.length > pos && this.contents[pos] >= 48 && this.contents[pos] <= 57); }
  
  final boolean encodeConstructed() { return false; }
  
  int encodedLength(boolean withTag) { return ASN1OutputStream.getLengthOfEncodingDL(withTag, this.contents.length); }
  
  void encode(ASN1OutputStream out, boolean withTag) throws IOException { out.writeEncodingDL(withTag, 24, this.contents); }
  
  ASN1Primitive toDERObject() { return new DERGeneralizedTime(this.contents); }
  
  boolean asn1Equals(ASN1Primitive o) {
    if (!(o instanceof ASN1GeneralizedTime))
      return false; 
    return Arrays.areEqual(this.contents, ((ASN1GeneralizedTime)o).contents);
  }
  
  public int hashCode() { return Arrays.hashCode(this.contents); }
  
  static ASN1GeneralizedTime createPrimitive(byte[] contents) { return new ASN1GeneralizedTime(contents); }
}
