package org.bouncycastle.jcajce.provider.symmetric;

import org.bouncycastle.crypto.Mac;
import org.bouncycastle.crypto.macs.HMac;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.util.DigestFactory;
import org.bouncycastle.jcajce.spec.TLSKeyMaterialSpec;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Strings;

public class TLSKDF {
  private static byte[] PRF_legacy(TLSKeyMaterialSpec parameters) {
    HMac hMac1 = new HMac(DigestFactory.createMD5());
    HMac hMac2 = new HMac(DigestFactory.createSHA1());
    byte[] label = Strings.toByteArray(parameters.getLabel());
    byte[] labelSeed = Arrays.concatenate(label, parameters.getSeed());
    byte[] secret = parameters.getSecret();
    int s_half = (secret.length + 1) / 2;
    byte[] s1 = new byte[s_half];
    byte[] s2 = new byte[s_half];
    System.arraycopy(secret, 0, s1, 0, s_half);
    System.arraycopy(secret, secret.length - s_half, s2, 0, s_half);
    int size = parameters.getLength();
    byte[] b1 = new byte[size];
    byte[] b2 = new byte[size];
    hmac_hash(hMac1, s1, labelSeed, b1);
    hmac_hash(hMac2, s2, labelSeed, b2);
    for (int i = 0; i < size; i++)
      b1[i] = (byte)(b1[i] ^ b2[i]); 
    return b1;
  }
  
  private static void hmac_hash(Mac mac, byte[] secret, byte[] seed, byte[] out) {
    mac.init(new KeyParameter(secret));
    byte[] a = seed;
    int size = mac.getMacSize();
    int iterations = (out.length + size - 1) / size;
    byte[] buf = new byte[mac.getMacSize()];
    byte[] buf2 = new byte[mac.getMacSize()];
    for (int i = 0; i < iterations; i++) {
      mac.update(a, 0, a.length);
      mac.doFinal(buf, 0);
      a = buf;
      mac.update(a, 0, a.length);
      mac.update(seed, 0, seed.length);
      mac.doFinal(buf2, 0);
      System.arraycopy(buf2, 0, out, size * i, Math.min(size, out.length - size * i));
    } 
  }
}
