package org.bouncycastle.jcajce.provider.asymmetric.ecgost;

import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.AlgorithmParameterSpec;
import org.bouncycastle.asn1.x9.X9IntegerConverter;
import org.bouncycastle.crypto.DerivationFunction;
import org.bouncycastle.crypto.agreement.ECVKOAgreement;
import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
import org.bouncycastle.crypto.params.ECDomainParameters;
import org.bouncycastle.crypto.params.ECPrivateKeyParameters;
import org.bouncycastle.crypto.params.ParametersWithUKM;
import org.bouncycastle.jcajce.provider.asymmetric.util.BaseAgreementSpi;
import org.bouncycastle.jcajce.provider.asymmetric.util.ECUtil;
import org.bouncycastle.jcajce.spec.UserKeyingMaterialSpec;

public class KeyAgreementSpi extends BaseAgreementSpi {
  private static final X9IntegerConverter converter = new X9IntegerConverter();
  
  private String kaAlgorithm;
  
  private ECDomainParameters parameters;
  
  private ECVKOAgreement agreement;
  
  private byte[] result;
  
  protected KeyAgreementSpi(String kaAlgorithm, ECVKOAgreement agreement, DerivationFunction kdf) {
    super(kaAlgorithm, kdf);
    this.kaAlgorithm = kaAlgorithm;
    this.agreement = agreement;
  }
  
  protected Key engineDoPhase(Key key, boolean lastPhase) throws InvalidKeyException, IllegalStateException {
    if (this.parameters == null)
      throw new IllegalStateException(this.kaAlgorithm + " not initialised."); 
    if (!lastPhase)
      throw new IllegalStateException(this.kaAlgorithm + " can only be between two parties."); 
    if (!(key instanceof PublicKey))
      throw new InvalidKeyException(this.kaAlgorithm + " key agreement requires " + 
          getSimpleName(org.bouncycastle.jce.interfaces.ECPublicKey.class) + " for doPhase"); 
    AsymmetricKeyParameter asymmetricKeyParameter = generatePublicKeyParameter((PublicKey)key);
    try {
      this.result = this.agreement.calculateAgreement(asymmetricKeyParameter);
    } catch (Exception e) {
      throw new Object(this, "calculation failed: " + e.getMessage(), e);
    } 
    return null;
  }
  
  protected void doInitFromKey(Key key, AlgorithmParameterSpec parameterSpec, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException {
    if (!(key instanceof PrivateKey))
      throw new InvalidKeyException(this.kaAlgorithm + " key agreement requires " + 
          getSimpleName(org.bouncycastle.jce.interfaces.ECPrivateKey.class) + " for initialisation"); 
    if (parameterSpec != null && !(parameterSpec instanceof UserKeyingMaterialSpec))
      throw new InvalidAlgorithmParameterException("No algorithm parameters supported"); 
    ECPrivateKeyParameters privKey = (ECPrivateKeyParameters)ECUtil.generatePrivateKeyParameter((PrivateKey)key);
    this.parameters = privKey.getParameters();
    this.ukmParameters = (parameterSpec instanceof UserKeyingMaterialSpec) ? ((UserKeyingMaterialSpec)parameterSpec).getUserKeyingMaterial() : null;
    this.agreement.init(new ParametersWithUKM(privKey, this.ukmParameters));
  }
  
  private static String getSimpleName(Class clazz) {
    String fullName = clazz.getName();
    return fullName.substring(fullName.lastIndexOf('.') + 1);
  }
  
  protected byte[] doCalcSecret() { return this.result; }
  
  static AsymmetricKeyParameter generatePublicKeyParameter(PublicKey key) throws InvalidKeyException { return (key instanceof org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey) ? ((BCECGOST3410PublicKey)key).engineGetKeyParameters() : ECUtil.generatePublicKeyParameter(key); }
}
