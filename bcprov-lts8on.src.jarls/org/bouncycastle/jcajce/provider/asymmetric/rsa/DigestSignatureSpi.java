package org.bouncycastle.jcajce.provider.asymmetric.rsa;

import java.io.IOException;
import java.security.AlgorithmParameters;
import java.security.InvalidKeyException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SignatureException;
import java.security.SignatureSpi;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.AlgorithmParameterSpec;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.DERNull;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.asn1.x509.DigestInfo;
import org.bouncycastle.crypto.AsymmetricBlockCipher;
import org.bouncycastle.crypto.Digest;
import org.bouncycastle.crypto.params.RSAKeyParameters;
import org.bouncycastle.util.Arrays;

public class DigestSignatureSpi extends SignatureSpi {
  private Digest digest;
  
  private AsymmetricBlockCipher cipher;
  
  private AlgorithmIdentifier algId;
  
  protected DigestSignatureSpi(Digest digest, AsymmetricBlockCipher cipher) {
    this.digest = digest;
    this.cipher = cipher;
    this.algId = null;
  }
  
  protected DigestSignatureSpi(ASN1ObjectIdentifier objId, Digest digest, AsymmetricBlockCipher cipher) {
    this.digest = digest;
    this.cipher = cipher;
    this.algId = new AlgorithmIdentifier(objId, DERNull.INSTANCE);
  }
  
  protected void engineInitVerify(PublicKey publicKey) throws InvalidKeyException {
    if (!(publicKey instanceof RSAPublicKey))
      throw new InvalidKeyException("Supplied key (" + getType(publicKey) + ") is not a RSAPublicKey instance"); 
    RSAKeyParameters rSAKeyParameters = RSAUtil.generatePublicKeyParameter((RSAPublicKey)publicKey);
    this.digest.reset();
    this.cipher.init(false, rSAKeyParameters);
  }
  
  protected void engineInitSign(PrivateKey privateKey) throws InvalidKeyException {
    if (!(privateKey instanceof RSAPrivateKey))
      throw new InvalidKeyException("Supplied key (" + getType(privateKey) + ") is not a RSAPrivateKey instance"); 
    RSAKeyParameters rSAKeyParameters = RSAUtil.generatePrivateKeyParameter((RSAPrivateKey)privateKey);
    this.digest.reset();
    this.cipher.init(true, rSAKeyParameters);
  }
  
  private String getType(Object o) {
    if (o == null)
      return null; 
    return o.getClass().getName();
  }
  
  protected void engineUpdate(byte b) throws SignatureException { this.digest.update(b); }
  
  protected void engineUpdate(byte[] b, int off, int len) throws SignatureException { this.digest.update(b, off, len); }
  
  protected byte[] engineSign() throws SignatureException {
    byte[] hash = new byte[this.digest.getDigestSize()];
    this.digest.doFinal(hash, 0);
    try {
      byte[] bytes = derEncode(hash);
      return this.cipher.processBlock(bytes, 0, bytes.length);
    } catch (ArrayIndexOutOfBoundsException e) {
      throw new SignatureException("key too small for signature type");
    } catch (Exception e) {
      throw new SignatureException(e.toString());
    } 
  }
  
  protected boolean engineVerify(byte[] sigBytes) throws SignatureException {
    byte[] expected, sig, hash = new byte[this.digest.getDigestSize()];
    this.digest.doFinal(hash, 0);
    try {
      sig = this.cipher.processBlock(sigBytes, 0, sigBytes.length);
      expected = derEncode(hash);
    } catch (Exception e) {
      return false;
    } 
    if (sig.length == expected.length)
      return Arrays.constantTimeAreEqual(sig, expected); 
    if (sig.length == expected.length - 2) {
      expected[1] = (byte)(expected[1] - 2);
      expected[3] = (byte)(expected[3] - 2);
      int sigOffset = 4 + expected[3];
      int expectedOffset = sigOffset + 2;
      int nonEqual = 0;
      for (int i = 0; i < expected.length - expectedOffset; i++)
        nonEqual |= sig[sigOffset + i] ^ expected[expectedOffset + i]; 
      for (int i = 0; i < sigOffset; i++)
        nonEqual |= sig[i] ^ expected[i]; 
      return (nonEqual == 0);
    } 
    Arrays.constantTimeAreEqual(expected, expected);
    return false;
  }
  
  protected void engineSetParameter(AlgorithmParameterSpec params) { throw new UnsupportedOperationException("engineSetParameter unsupported"); }
  
  protected void engineSetParameter(String param, Object value) { throw new UnsupportedOperationException("engineSetParameter unsupported"); }
  
  protected Object engineGetParameter(String param) { return null; }
  
  protected AlgorithmParameters engineGetParameters() { return null; }
  
  private byte[] derEncode(byte[] hash) throws IOException {
    if (this.algId == null)
      return hash; 
    DigestInfo dInfo = new DigestInfo(this.algId, hash);
    return dInfo.getEncoded("DER");
  }
}
