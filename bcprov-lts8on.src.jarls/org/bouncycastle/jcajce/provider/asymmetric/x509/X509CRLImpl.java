package org.bouncycastle.jcajce.provider.asymmetric.x509;

import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.Principal;
import java.security.Provider;
import java.security.PublicKey;
import java.security.Signature;
import java.security.SignatureException;
import java.security.cert.CRLException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.X509CRL;
import java.security.cert.X509CRLEntry;
import java.security.cert.X509Certificate;
import java.util.Collections;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import javax.security.auth.x500.X500Principal;
import org.bouncycastle.asn1.ASN1BitString;
import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1InputStream;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.ASN1OctetString;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.util.ASN1Dump;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.asn1.x509.CRLDistPoint;
import org.bouncycastle.asn1.x509.CRLNumber;
import org.bouncycastle.asn1.x509.Certificate;
import org.bouncycastle.asn1.x509.CertificateList;
import org.bouncycastle.asn1.x509.Extension;
import org.bouncycastle.asn1.x509.Extensions;
import org.bouncycastle.asn1.x509.GeneralNames;
import org.bouncycastle.asn1.x509.IssuingDistributionPoint;
import org.bouncycastle.asn1.x509.TBSCertList;
import org.bouncycastle.asn1.x509.Time;
import org.bouncycastle.jcajce.CompositePublicKey;
import org.bouncycastle.jcajce.io.OutputStreamFactory;
import org.bouncycastle.jcajce.util.JcaJceHelper;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Strings;

abstract class X509CRLImpl extends X509CRL {
  protected JcaJceHelper bcHelper;
  
  protected CertificateList c;
  
  protected String sigAlgName;
  
  protected byte[] sigAlgParams;
  
  protected boolean isIndirect;
  
  X509CRLImpl(JcaJceHelper bcHelper, CertificateList c, String sigAlgName, byte[] sigAlgParams, boolean isIndirect) {
    this.bcHelper = bcHelper;
    this.c = c;
    this.sigAlgName = sigAlgName;
    this.sigAlgParams = sigAlgParams;
    this.isIndirect = isIndirect;
  }
  
  public boolean hasUnsupportedCriticalExtension() {
    Set extns = getCriticalExtensionOIDs();
    if (extns == null)
      return false; 
    extns.remove(Extension.issuingDistributionPoint.getId());
    extns.remove(Extension.deltaCRLIndicator.getId());
    return !extns.isEmpty();
  }
  
  private Set getExtensionOIDs(boolean critical) {
    if (getVersion() == 2) {
      Extensions extensions = this.c.getTBSCertList().getExtensions();
      if (extensions != null) {
        Set set = new HashSet();
        Enumeration e = extensions.oids();
        while (e.hasMoreElements()) {
          ASN1ObjectIdentifier oid = (ASN1ObjectIdentifier)e.nextElement();
          Extension ext = extensions.getExtension(oid);
          if (critical == ext.isCritical())
            set.add(oid.getId()); 
        } 
        return set;
      } 
    } 
    return null;
  }
  
  public Set getCriticalExtensionOIDs() { return getExtensionOIDs(true); }
  
  public Set getNonCriticalExtensionOIDs() { return getExtensionOIDs(false); }
  
  public byte[] getExtensionValue(String oid) {
    ASN1OctetString extValue = getExtensionValue(this.c, oid);
    if (null != extValue)
      try {
        return extValue.getEncoded();
      } catch (Exception e) {
        throw new IllegalStateException("error parsing " + e.toString());
      }  
    return null;
  }
  
  public void verify(PublicKey key) throws CRLException, NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException { doVerify(key, new Object(this)); }
  
  public void verify(PublicKey key, String sigProvider) throws CRLException, NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException { doVerify(key, new Object(this, sigProvider)); }
  
  public void verify(PublicKey key, Provider sigProvider) throws CRLException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
    try {
      doVerify(key, new Object(this, sigProvider));
    } catch (NoSuchProviderException e) {
      throw new NoSuchAlgorithmException("provider issue: " + e.getMessage());
    } 
  }
  
  private void doVerify(PublicKey key, SignatureCreator sigCreator) throws CRLException, NoSuchAlgorithmException, InvalidKeyException, SignatureException, NoSuchProviderException {
    if (!this.c.getSignatureAlgorithm().equals(this.c.getTBSCertList().getSignature()))
      throw new CRLException("Signature algorithm on CertificateList does not match TBSCertList."); 
    if (key instanceof CompositePublicKey && X509SignatureUtil.isCompositeAlgorithm(this.c.getSignatureAlgorithm())) {
      List<PublicKey> pubKeys = ((CompositePublicKey)key).getPublicKeys();
      ASN1Sequence keySeq = ASN1Sequence.getInstance(this.c.getSignatureAlgorithm().getParameters());
      ASN1Sequence sigSeq = ASN1Sequence.getInstance(ASN1BitString.getInstance(this.c.getSignature()).getBytes());
      boolean success = false;
      for (int i = 0; i != pubKeys.size(); i++) {
        if (pubKeys.get(i) != null) {
          AlgorithmIdentifier sigAlg = AlgorithmIdentifier.getInstance(keySeq.getObjectAt(i));
          String sigName = X509SignatureUtil.getSignatureName(sigAlg);
          Signature signature = sigCreator.createSignature(sigName);
          SignatureException sigExc = null;
          try {
            checkSignature((PublicKey)pubKeys
                .get(i), signature, sigAlg
                .getParameters(), 
                ASN1BitString.getInstance(sigSeq.getObjectAt(i)).getBytes());
            success = true;
          } catch (SignatureException e) {
            sigExc = e;
          } 
          if (sigExc != null)
            throw sigExc; 
        } 
      } 
      if (!success)
        throw new InvalidKeyException("no matching key found"); 
    } else if (X509SignatureUtil.isCompositeAlgorithm(this.c.getSignatureAlgorithm())) {
      ASN1Sequence keySeq = ASN1Sequence.getInstance(this.c.getSignatureAlgorithm().getParameters());
      ASN1Sequence sigSeq = ASN1Sequence.getInstance(ASN1BitString.getInstance(this.c.getSignature()).getBytes());
      boolean success = false;
      for (int i = 0; i != sigSeq.size(); i++) {
        AlgorithmIdentifier sigAlg = AlgorithmIdentifier.getInstance(keySeq.getObjectAt(i));
        String sigName = X509SignatureUtil.getSignatureName(sigAlg);
        SignatureException sigExc = null;
        try {
          Signature signature = sigCreator.createSignature(sigName);
          checkSignature(key, signature, sigAlg
              
              .getParameters(), 
              ASN1BitString.getInstance(sigSeq.getObjectAt(i)).getBytes());
          success = true;
        } catch (InvalidKeyException invalidKeyException) {
        
        } catch (NoSuchAlgorithmException noSuchAlgorithmException) {
        
        } catch (SignatureException e) {
          sigExc = e;
        } 
        if (sigExc != null)
          throw sigExc; 
      } 
      if (!success)
        throw new InvalidKeyException("no matching key found"); 
    } else {
      Signature sig = sigCreator.createSignature(getSigAlgName());
      if (this.sigAlgParams == null) {
        checkSignature(key, sig, null, getSignature());
      } else {
        try {
          checkSignature(key, sig, ASN1Primitive.fromByteArray(this.sigAlgParams), getSignature());
        } catch (IOException e) {
          throw new SignatureException("cannot decode signature parameters: " + e.getMessage());
        } 
      } 
    } 
  }
  
  private void checkSignature(PublicKey key, Signature sig, ASN1Encodable sigAlgParams, byte[] encSig) throws NoSuchAlgorithmException, SignatureException, InvalidKeyException, CRLException {
    if (sigAlgParams != null)
      X509SignatureUtil.setSignatureParameters(sig, sigAlgParams); 
    sig.initVerify(key);
    try {
      OutputStream sigOut = new BufferedOutputStream(OutputStreamFactory.createStream(sig), 512);
      this.c.getTBSCertList().encodeTo(sigOut, "DER");
      sigOut.close();
    } catch (IOException e) {
      throw new CRLException(e.toString());
    } 
    if (!sig.verify(encSig))
      throw new SignatureException("CRL does not verify with supplied public key."); 
  }
  
  public int getVersion() { return this.c.getVersionNumber(); }
  
  public Principal getIssuerDN() { return getIssuerX500Principal(); }
  
  public X500Principal getIssuerX500Principal() {
    try {
      return new X500Principal(this.c.getIssuer().getEncoded());
    } catch (IOException e) {
      throw new IllegalStateException("can't encode issuer DN");
    } 
  }
  
  public Date getThisUpdate() { return this.c.getThisUpdate().getDate(); }
  
  public Date getNextUpdate() {
    Time nextUpdate = this.c.getNextUpdate();
    return (null == nextUpdate) ? null : nextUpdate.getDate();
  }
  
  private Set loadCRLEntries() {
    Set entrySet = new HashSet();
    Enumeration certs = this.c.getRevokedCertificateEnumeration();
    X500Name previousCertificateIssuer = null;
    while (certs.hasMoreElements()) {
      TBSCertList.CRLEntry entry = (TBSCertList.CRLEntry)certs.nextElement();
      X509CRLEntryObject crlEntry = new X509CRLEntryObject(entry, this.isIndirect, previousCertificateIssuer);
      entrySet.add(crlEntry);
      if (this.isIndirect && entry.hasExtensions()) {
        Extension currentCaName = entry.getExtensions().getExtension(Extension.certificateIssuer);
        if (currentCaName != null)
          previousCertificateIssuer = X500Name.getInstance(GeneralNames.getInstance(currentCaName.getParsedValue()).getNames()[0].getName()); 
      } 
    } 
    return entrySet;
  }
  
  public X509CRLEntry getRevokedCertificate(BigInteger serialNumber) {
    Enumeration certs = this.c.getRevokedCertificateEnumeration();
    X500Name previousCertificateIssuer = null;
    while (certs.hasMoreElements()) {
      TBSCertList.CRLEntry entry = (TBSCertList.CRLEntry)certs.nextElement();
      if (entry.getUserCertificate().hasValue(serialNumber))
        return new X509CRLEntryObject(entry, this.isIndirect, previousCertificateIssuer); 
      if (this.isIndirect && entry.hasExtensions()) {
        Extension currentCaName = entry.getExtensions().getExtension(Extension.certificateIssuer);
        if (currentCaName != null)
          previousCertificateIssuer = X500Name.getInstance(GeneralNames.getInstance(currentCaName.getParsedValue()).getNames()[0].getName()); 
      } 
    } 
    return null;
  }
  
  public Set getRevokedCertificates() {
    Set entrySet = loadCRLEntries();
    if (!entrySet.isEmpty())
      return Collections.unmodifiableSet(entrySet); 
    return null;
  }
  
  public byte[] getTBSCertList() throws CRLException {
    try {
      return this.c.getTBSCertList().getEncoded("DER");
    } catch (IOException e) {
      throw new CRLException(e.toString());
    } 
  }
  
  public byte[] getSignature() throws CRLException { return this.c.getSignature().getOctets(); }
  
  public String getSigAlgName() { return this.sigAlgName; }
  
  public String getSigAlgOID() { return this.c.getSignatureAlgorithm().getAlgorithm().getId(); }
  
  public byte[] getSigAlgParams() throws CRLException { return Arrays.clone(this.sigAlgParams); }
  
  public String toString() {
    StringBuffer buf = new StringBuffer();
    String nl = Strings.lineSeparator();
    buf.append("              Version: ").append(getVersion()).append(nl);
    buf.append("             IssuerDN: ").append(getIssuerDN())
      .append(nl);
    buf.append("          This update: ").append(getThisUpdate())
      .append(nl);
    buf.append("          Next update: ").append(getNextUpdate())
      .append(nl);
    buf.append("  Signature Algorithm: ").append(getSigAlgName())
      .append(nl);
    X509SignatureUtil.prettyPrintSignature(getSignature(), buf, nl);
    Extensions extensions = this.c.getTBSCertList().getExtensions();
    if (extensions != null) {
      Enumeration e = extensions.oids();
      if (e.hasMoreElements())
        buf.append("           Extensions: ").append(nl); 
      while (e.hasMoreElements()) {
        ASN1ObjectIdentifier oid = (ASN1ObjectIdentifier)e.nextElement();
        Extension ext = extensions.getExtension(oid);
        if (ext.getExtnValue() != null) {
          byte[] octs = ext.getExtnValue().getOctets();
          ASN1InputStream dIn = new ASN1InputStream(octs);
          buf.append("                       critical(").append(ext
              .isCritical()).append(") ");
          try {
            if (oid.equals(Extension.cRLNumber)) {
              buf.append(new CRLNumber(
                    ASN1Integer.getInstance(dIn
                      .readObject()).getPositiveValue()))
                .append(nl);
              continue;
            } 
            if (oid.equals(Extension.deltaCRLIndicator)) {
              buf.append("Base CRL: " + new CRLNumber(
                    
                    ASN1Integer.getInstance(dIn
                      .readObject()).getPositiveValue()))
                .append(nl);
              continue;
            } 
            if (oid
              .equals(Extension.issuingDistributionPoint)) {
              buf.append(
                  IssuingDistributionPoint.getInstance(dIn.readObject())).append(nl);
              continue;
            } 
            if (oid
              .equals(Extension.cRLDistributionPoints)) {
              buf.append(
                  CRLDistPoint.getInstance(dIn.readObject())).append(nl);
              continue;
            } 
            if (oid.equals(Extension.freshestCRL)) {
              buf.append(
                  CRLDistPoint.getInstance(dIn.readObject())).append(nl);
              continue;
            } 
            buf.append(oid.getId());
            buf.append(" value = ").append(
                ASN1Dump.dumpAsString(dIn.readObject()))
              .append(nl);
            continue;
          } catch (Exception ex) {
            buf.append(oid.getId());
            buf.append(" value = ").append("*****").append(nl);
            continue;
          } 
        } 
        buf.append(nl);
      } 
    } 
    Set set = getRevokedCertificates();
    if (set != null) {
      Iterator it = set.iterator();
      while (it.hasNext()) {
        buf.append(it.next());
        buf.append(nl);
      } 
    } 
    return buf.toString();
  }
  
  public boolean isRevoked(Certificate cert) {
    if (!cert.getType().equals("X.509"))
      throw new IllegalArgumentException("X.509 CRL used with non X.509 Cert"); 
    Enumeration certs = this.c.getRevokedCertificateEnumeration();
    X500Name caName = this.c.getIssuer();
    if (certs.hasMoreElements()) {
      BigInteger serial = ((X509Certificate)cert).getSerialNumber();
      while (certs.hasMoreElements()) {
        TBSCertList.CRLEntry entry = TBSCertList.CRLEntry.getInstance(certs.nextElement());
        if (this.isIndirect && entry.hasExtensions()) {
          Extension currentCaName = entry.getExtensions().getExtension(Extension.certificateIssuer);
          if (currentCaName != null)
            caName = X500Name.getInstance(GeneralNames.getInstance(currentCaName.getParsedValue()).getNames()[0].getName()); 
        } 
        if (entry.getUserCertificate().hasValue(serial)) {
          X500Name issuer;
          if (cert instanceof X509Certificate) {
            issuer = X500Name.getInstance(((X509Certificate)cert).getIssuerX500Principal().getEncoded());
          } else {
            try {
              issuer = Certificate.getInstance(cert.getEncoded()).getIssuer();
            } catch (CertificateEncodingException e) {
              throw new IllegalArgumentException("Cannot process certificate: " + e.getMessage());
            } 
          } 
          if (!caName.equals(issuer))
            return false; 
          return true;
        } 
      } 
    } 
    return false;
  }
  
  protected static byte[] getExtensionOctets(CertificateList c, String oid) {
    ASN1OctetString extValue = getExtensionValue(c, oid);
    if (null != extValue)
      return extValue.getOctets(); 
    return null;
  }
  
  protected static ASN1OctetString getExtensionValue(CertificateList c, String oid) {
    Extensions exts = c.getTBSCertList().getExtensions();
    if (null != exts) {
      Extension ext = exts.getExtension(new ASN1ObjectIdentifier(oid));
      if (null != ext)
        return ext.getExtnValue(); 
    } 
    return null;
  }
}
