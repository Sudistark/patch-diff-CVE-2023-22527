package org.bouncycastle.jcajce.provider.asymmetric.x509;

import java.io.IOException;
import java.security.PublicKey;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateExpiredException;
import java.security.cert.CertificateNotYetValidException;
import java.security.cert.CertificateParsingException;
import java.util.Date;
import java.util.Enumeration;
import javax.security.auth.x500.X500Principal;
import org.bouncycastle.asn1.ASN1BitString;
import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.x509.BasicConstraints;
import org.bouncycastle.asn1.x509.Certificate;
import org.bouncycastle.jcajce.provider.asymmetric.util.PKCS12BagAttributeCarrierImpl;
import org.bouncycastle.jcajce.util.JcaJceHelper;
import org.bouncycastle.jce.interfaces.PKCS12BagAttributeCarrier;
import org.bouncycastle.util.Arrays;

class X509CertificateObject extends X509CertificateImpl implements PKCS12BagAttributeCarrier {
  private final Object cacheLock = new Object();
  
  private X509CertificateInternal internalCertificateValue;
  
  private X500Principal issuerValue;
  
  private PublicKey publicKeyValue;
  
  private X500Principal subjectValue;
  
  private long[] validityValues;
  
  private PKCS12BagAttributeCarrier attrCarrier = new PKCS12BagAttributeCarrierImpl();
  
  X509CertificateObject(JcaJceHelper bcHelper, Certificate c) throws CertificateParsingException { super(bcHelper, c, createBasicConstraints(c), createKeyUsage(c), createSigAlgName(c), createSigAlgParams(c)); }
  
  public void checkValidity(Date date) throws CertificateExpiredException, CertificateNotYetValidException {
    long checkTime = date.getTime();
    long[] validityValues = getValidityValues();
    if (checkTime > validityValues[1])
      throw new CertificateExpiredException("certificate expired on " + this.c.getEndDate().getTime()); 
    if (checkTime < validityValues[0])
      throw new CertificateNotYetValidException("certificate not valid till " + this.c.getStartDate().getTime()); 
  }
  
  public X500Principal getIssuerX500Principal() {
    synchronized (this.cacheLock) {
      if (null != this.issuerValue)
        return this.issuerValue; 
    } 
    X500Principal temp = super.getIssuerX500Principal();
    synchronized (this.cacheLock) {
      if (null == this.issuerValue)
        this.issuerValue = temp; 
      return this.issuerValue;
    } 
  }
  
  public PublicKey getPublicKey() {
    synchronized (this.cacheLock) {
      if (null != this.publicKeyValue)
        return this.publicKeyValue; 
    } 
    PublicKey temp = super.getPublicKey();
    if (null == temp)
      return null; 
    synchronized (this.cacheLock) {
      if (null == this.publicKeyValue)
        this.publicKeyValue = temp; 
      return this.publicKeyValue;
    } 
  }
  
  public X500Principal getSubjectX500Principal() {
    synchronized (this.cacheLock) {
      if (null != this.subjectValue)
        return this.subjectValue; 
    } 
    X500Principal temp = super.getSubjectX500Principal();
    synchronized (this.cacheLock) {
      if (null == this.subjectValue)
        this.subjectValue = temp; 
      return this.subjectValue;
    } 
  }
  
  public long[] getValidityValues() {
    synchronized (this.cacheLock) {
      if (null != this.validityValues)
        return this.validityValues; 
    } 
    long[] temp = { getNotBefore().getTime(), getNotAfter().getTime() };
    synchronized (this.cacheLock) {
      if (null == this.validityValues)
        this.validityValues = temp; 
      return this.validityValues;
    } 
  }
  
  public byte[] getEncoded() throws CertificateEncodingException { return Arrays.clone(getInternalCertificate().getEncoded()); }
  
  public boolean equals(Object other) {
    if (other == this)
      return true; 
    if (other instanceof X509CertificateObject) {
      X509CertificateObject otherBC = (X509CertificateObject)other;
      if (this.hashValueSet && otherBC.hashValueSet) {
        if (this.hashValue != otherBC.hashValue)
          return false; 
      } else if (null == this.internalCertificateValue || null == otherBC.internalCertificateValue) {
        ASN1BitString signature = this.c.getSignature();
        if (null != signature && !signature.equals(otherBC.c.getSignature()))
          return false; 
      } 
      return getInternalCertificate().equals(otherBC.getInternalCertificate());
    } 
    return getInternalCertificate().equals(other);
  }
  
  public int hashCode() {
    if (!this.hashValueSet) {
      this.hashValue = getInternalCertificate().hashCode();
      this.hashValueSet = true;
    } 
    return this.hashValue;
  }
  
  public int originalHashCode() {
    try {
      int hashCode = 0;
      byte[] certData = getInternalCertificate().getEncoded();
      for (int i = 1; i < certData.length; i++)
        hashCode += certData[i] * i; 
      return hashCode;
    } catch (CertificateEncodingException e) {
      return 0;
    } 
  }
  
  public void setBagAttribute(ASN1ObjectIdentifier oid, ASN1Encodable attribute) { this.attrCarrier.setBagAttribute(oid, attribute); }
  
  public ASN1Encodable getBagAttribute(ASN1ObjectIdentifier oid) { return this.attrCarrier.getBagAttribute(oid); }
  
  public Enumeration getBagAttributeKeys() { return this.attrCarrier.getBagAttributeKeys(); }
  
  private X509CertificateInternal getInternalCertificate() {
    synchronized (this.cacheLock) {
      if (null != this.internalCertificateValue)
        return this.internalCertificateValue; 
    } 
    byte[] encoding = null;
    X509CertificateEncodingException x509CertificateEncodingException = null;
    try {
      encoding = this.c.getEncoded("DER");
    } catch (IOException e) {
      x509CertificateEncodingException = new X509CertificateEncodingException(e);
    } 
    X509CertificateInternal temp = new X509CertificateInternal(this.bcHelper, this.c, this.basicConstraints, this.keyUsage, this.sigAlgName, this.sigAlgParams, encoding, x509CertificateEncodingException);
    synchronized (this.cacheLock) {
      if (null == this.internalCertificateValue)
        this.internalCertificateValue = temp; 
      return this.internalCertificateValue;
    } 
  }
  
  private static BasicConstraints createBasicConstraints(Certificate c) throws CertificateParsingException {
    try {
      byte[] extOctets = getExtensionOctets(c, "2.5.29.19");
      if (null == extOctets)
        return null; 
      return BasicConstraints.getInstance(ASN1Primitive.fromByteArray(extOctets));
    } catch (Exception e) {
      throw new CertificateParsingException("cannot construct BasicConstraints: " + e);
    } 
  }
  
  private static boolean[] createKeyUsage(Certificate c) throws CertificateParsingException {
    try {
      byte[] extOctets = getExtensionOctets(c, "2.5.29.15");
      if (null == extOctets)
        return null; 
      ASN1BitString bits = ASN1BitString.getInstance(ASN1Primitive.fromByteArray(extOctets));
      byte[] bytes = bits.getBytes();
      int length = bytes.length * 8 - bits.getPadBits();
      boolean[] keyUsage = new boolean[(length < 9) ? 9 : length];
      for (int i = 0; i != length; i++)
        keyUsage[i] = ((bytes[i / 8] & 128 >>> i % 8) != 0); 
      return keyUsage;
    } catch (Exception e) {
      throw new CertificateParsingException("cannot construct KeyUsage: " + e);
    } 
  }
  
  private static String createSigAlgName(Certificate c) throws CertificateParsingException {
    try {
      return X509SignatureUtil.getSignatureName(c.getSignatureAlgorithm());
    } catch (Exception e) {
      throw new CertificateParsingException("cannot construct SigAlgName: " + e);
    } 
  }
  
  private static byte[] createSigAlgParams(Certificate c) throws CertificateParsingException {
    try {
      ASN1Encodable parameters = c.getSignatureAlgorithm().getParameters();
      if (null == parameters)
        return null; 
      return parameters.toASN1Primitive().getEncoded("DER");
    } catch (Exception e) {
      throw new CertificateParsingException("cannot construct SigAlgParams: " + e);
    } 
  }
}
