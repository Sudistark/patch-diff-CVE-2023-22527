package org.bouncycastle.jcajce.provider.asymmetric.ec;

import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.CipherSpi;
import javax.crypto.NoSuchPaddingException;
import org.bouncycastle.crypto.CryptoServicesRegistrar;
import org.bouncycastle.crypto.engines.SM2Engine;
import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
import org.bouncycastle.crypto.params.ParametersWithRandom;
import org.bouncycastle.jcajce.provider.asymmetric.util.ECUtil;
import org.bouncycastle.jcajce.provider.util.BadBlockException;
import org.bouncycastle.jcajce.util.BCJcaJceHelper;
import org.bouncycastle.jcajce.util.JcaJceHelper;
import org.bouncycastle.jce.interfaces.ECKey;
import org.bouncycastle.util.Strings;

public class GMCipherSpi extends CipherSpi {
  private final JcaJceHelper helper;
  
  private SM2Engine engine;
  
  private int state;
  
  private ErasableOutputStream buffer;
  
  private AsymmetricKeyParameter key;
  
  private SecureRandom random;
  
  public GMCipherSpi(SM2Engine engine) {
    this.helper = new BCJcaJceHelper();
    this.state = -1;
    this.buffer = new ErasableOutputStream();
    this.engine = engine;
  }
  
  public int engineGetBlockSize() { return 0; }
  
  public int engineGetKeySize(Key key) {
    if (key instanceof ECKey)
      return ((ECKey)key).getParameters().getCurve().getFieldSize(); 
    throw new IllegalArgumentException("not an EC key");
  }
  
  public byte[] engineGetIV() { return null; }
  
  public AlgorithmParameters engineGetParameters() { return null; }
  
  public void engineSetMode(String mode) throws NoSuchAlgorithmException {
    String modeName = Strings.toUpperCase(mode);
    if (!modeName.equals("NONE"))
      throw new IllegalArgumentException("can't support mode " + mode); 
  }
  
  public int engineGetOutputSize(int inputLen) {
    if (this.state == 1 || this.state == 3)
      return this.engine.getOutputSize(inputLen); 
    if (this.state == 2 || this.state == 4)
      return this.engine.getOutputSize(inputLen); 
    throw new IllegalStateException("cipher not initialised");
  }
  
  public void engineSetPadding(String padding) throws NoSuchAlgorithmException {
    String paddingName = Strings.toUpperCase(padding);
    if (!paddingName.equals("NOPADDING"))
      throw new NoSuchPaddingException("padding not available with IESCipher"); 
  }
  
  public void engineInit(int opmode, Key key, AlgorithmParameters params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException {
    AlgorithmParameterSpec paramSpec = null;
    if (params != null)
      throw new InvalidAlgorithmParameterException("cannot recognise parameters: " + params.getClass().getName()); 
    engineInit(opmode, key, paramSpec, random);
  }
  
  public void engineInit(int opmode, Key key, AlgorithmParameterSpec engineSpec, SecureRandom random) throws InvalidAlgorithmParameterException, InvalidKeyException {
    if (opmode == 1 || opmode == 3) {
      if (key instanceof PublicKey) {
        this.key = ECUtils.generatePublicKeyParameter((PublicKey)key);
      } else {
        throw new InvalidKeyException("must be passed public EC key for encryption");
      } 
    } else if (opmode == 2 || opmode == 4) {
      if (key instanceof PrivateKey) {
        this.key = ECUtil.generatePrivateKeyParameter((PrivateKey)key);
      } else {
        throw new InvalidKeyException("must be passed private EC key for decryption");
      } 
    } else {
      throw new InvalidKeyException("must be passed EC key");
    } 
    if (random != null) {
      this.random = random;
    } else {
      this.random = CryptoServicesRegistrar.getSecureRandom();
    } 
    this.state = opmode;
    this.buffer.reset();
  }
  
  public void engineInit(int opmode, Key key, SecureRandom random) throws InvalidKeyException {
    try {
      engineInit(opmode, key, (AlgorithmParameterSpec)null, random);
    } catch (InvalidAlgorithmParameterException e) {
      throw new IllegalArgumentException("cannot handle supplied parameter spec: " + e.getMessage());
    } 
  }
  
  public byte[] engineUpdate(byte[] input, int inputOffset, int inputLen) {
    this.buffer.write(input, inputOffset, inputLen);
    return null;
  }
  
  public int engineUpdate(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) {
    this.buffer.write(input, inputOffset, inputLen);
    return 0;
  }
  
  public byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen) {
    if (inputLen != 0)
      this.buffer.write(input, inputOffset, inputLen); 
    try {
      if (this.state == 1 || this.state == 3)
        try {
          this.engine.init(true, new ParametersWithRandom(this.key, this.random));
          return this.engine.processBlock(this.buffer.getBuf(), 0, this.buffer.size());
        } catch (Exception e) {
          throw new BadBlockException("unable to process block", e);
        }  
      if (this.state == 2 || this.state == 4)
        try {
          this.engine.init(false, this.key);
          return this.engine.processBlock(this.buffer.getBuf(), 0, this.buffer.size());
        } catch (Exception e) {
          throw new BadBlockException("unable to process block", e);
        }  
      throw new IllegalStateException("cipher not initialised");
    } finally {
      this.buffer.erase();
    } 
  }
  
  public int engineDoFinal(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset) {
    byte[] buf = engineDoFinal(input, inputOffset, inputLength);
    System.arraycopy(buf, 0, output, outputOffset, buf.length);
    return buf.length;
  }
}
