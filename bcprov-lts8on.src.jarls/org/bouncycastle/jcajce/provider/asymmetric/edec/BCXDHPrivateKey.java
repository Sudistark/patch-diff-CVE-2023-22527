package org.bouncycastle.jcajce.provider.asymmetric.edec;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.security.PrivateKey;
import org.bouncycastle.asn1.ASN1OctetString;
import org.bouncycastle.asn1.ASN1Set;
import org.bouncycastle.asn1.edec.EdECObjectIdentifiers;
import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
import org.bouncycastle.crypto.params.X25519PrivateKeyParameters;
import org.bouncycastle.crypto.params.X25519PublicKeyParameters;
import org.bouncycastle.crypto.params.X448PrivateKeyParameters;
import org.bouncycastle.crypto.params.X448PublicKeyParameters;
import org.bouncycastle.crypto.util.PrivateKeyInfoFactory;
import org.bouncycastle.jcajce.interfaces.XDHPrivateKey;
import org.bouncycastle.jcajce.interfaces.XDHPublicKey;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Properties;

public class BCXDHPrivateKey implements XDHPrivateKey {
  static final long serialVersionUID = 1L;
  
  AsymmetricKeyParameter xdhPrivateKey;
  
  AsymmetricKeyParameter xdhPublicKey;
  
  int hashCode;
  
  private final boolean hasPublicKey;
  
  private final byte[] attributes;
  
  BCXDHPrivateKey(AsymmetricKeyParameter privKey) {
    this.hasPublicKey = true;
    this.attributes = null;
    this.xdhPrivateKey = privKey;
    if (this.xdhPrivateKey instanceof X448PrivateKeyParameters) {
      this.xdhPublicKey = ((X448PrivateKeyParameters)this.xdhPrivateKey).generatePublicKey();
    } else {
      this.xdhPublicKey = ((X25519PrivateKeyParameters)this.xdhPrivateKey).generatePublicKey();
    } 
    this.hashCode = calculateHashCode();
  }
  
  BCXDHPrivateKey(PrivateKeyInfo keyInfo) throws IOException {
    this.hasPublicKey = keyInfo.hasPublicKey();
    this.attributes = (keyInfo.getAttributes() != null) ? keyInfo.getAttributes().getEncoded() : null;
    populateFromPrivateKeyInfo(keyInfo);
  }
  
  private void populateFromPrivateKeyInfo(PrivateKeyInfo keyInfo) throws IOException {
    byte[] encoding = keyInfo.getPrivateKey().getOctets();
    if (encoding.length != 32 && encoding.length != 56)
      encoding = ASN1OctetString.getInstance(keyInfo.parsePrivateKey()).getOctets(); 
    if (EdECObjectIdentifiers.id_X448.equals(keyInfo.getPrivateKeyAlgorithm().getAlgorithm())) {
      this.xdhPrivateKey = new X448PrivateKeyParameters(encoding);
      this.xdhPublicKey = ((X448PrivateKeyParameters)this.xdhPrivateKey).generatePublicKey();
    } else {
      this.xdhPrivateKey = new X25519PrivateKeyParameters(encoding);
      this.xdhPublicKey = ((X25519PrivateKeyParameters)this.xdhPrivateKey).generatePublicKey();
    } 
    this.hashCode = calculateHashCode();
  }
  
  public String getAlgorithm() {
    if (Properties.isOverrideSet("org.bouncycastle.emulate.oracle"))
      return "XDH"; 
    return (this.xdhPrivateKey instanceof X448PrivateKeyParameters) ? "X448" : "X25519";
  }
  
  public String getFormat() { return "PKCS#8"; }
  
  public byte[] getEncoded() {
    try {
      PrivateKeyInfo privateKeyInfo = getPrivateKeyInfo();
      if (privateKeyInfo == null)
        return null; 
      return privateKeyInfo.getEncoded();
    } catch (IOException e) {
      return null;
    } 
  }
  
  private PrivateKeyInfo getPrivateKeyInfo() {
    try {
      ASN1Set attrSet = ASN1Set.getInstance(this.attributes);
      PrivateKeyInfo privInfo = PrivateKeyInfoFactory.createPrivateKeyInfo(this.xdhPrivateKey, attrSet);
      if (this.hasPublicKey && !Properties.isOverrideSet("org.bouncycastle.pkcs8.v1_info_only"))
        return privInfo; 
      return new PrivateKeyInfo(privInfo.getPrivateKeyAlgorithm(), privInfo.parsePrivateKey(), attrSet);
    } catch (IOException e) {
      return null;
    } 
  }
  
  public XDHPublicKey getPublicKey() { return new BCXDHPublicKey(this.xdhPublicKey); }
  
  AsymmetricKeyParameter engineGetKeyParameters() { return this.xdhPrivateKey; }
  
  public String toString() { return Utils.keyToString("Private Key", getAlgorithm(), this.xdhPublicKey); }
  
  public boolean equals(Object o) {
    if (o == this)
      return true; 
    if (!(o instanceof PrivateKey))
      return false; 
    PrivateKey other = (PrivateKey)o;
    PrivateKeyInfo info = getPrivateKeyInfo();
    PrivateKeyInfo otherInfo = (other instanceof BCXDHPrivateKey) ? ((BCXDHPrivateKey)other).getPrivateKeyInfo() : PrivateKeyInfo.getInstance(other.getEncoded());
    if (info == null || otherInfo == null)
      return false; 
    try {
      boolean algEquals = Arrays.constantTimeAreEqual(info.getPrivateKeyAlgorithm().getEncoded(), otherInfo.getPrivateKeyAlgorithm().getEncoded());
      boolean keyEquals = Arrays.constantTimeAreEqual(info.getPrivateKey().getEncoded(), otherInfo.getPrivateKey().getEncoded());
      return algEquals & keyEquals;
    } catch (IOException e) {
      return false;
    } 
  }
  
  public int hashCode() { return this.hashCode; }
  
  private int calculateHashCode() {
    byte[] publicData;
    if (this.xdhPublicKey instanceof X448PublicKeyParameters) {
      publicData = ((X448PublicKeyParameters)this.xdhPublicKey).getEncoded();
    } else {
      publicData = ((X25519PublicKeyParameters)this.xdhPublicKey).getEncoded();
    } 
    result = getAlgorithm().hashCode();
    return 31 * result + Arrays.hashCode(publicData);
  }
  
  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
    in.defaultReadObject();
    byte[] enc = (byte[])in.readObject();
    populateFromPrivateKeyInfo(PrivateKeyInfo.getInstance(enc));
  }
  
  private void writeObject(ObjectOutputStream out) throws IOException {
    out.defaultWriteObject();
    out.writeObject(getEncoded());
  }
}
