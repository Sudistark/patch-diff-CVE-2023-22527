package org.bouncycastle.jcajce.provider.keystore.util;

import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.Key;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.KeyStoreSpi;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.UnrecoverableKeyException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.util.Date;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Map;
import org.bouncycastle.crypto.Digest;
import org.bouncycastle.jcajce.BCLoadStoreParameter;
import org.bouncycastle.jcajce.provider.util.DigestFactory;
import org.bouncycastle.jcajce.util.JcaJceHelper;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Strings;
import org.bouncycastle.util.io.Streams;

public class JKSKeyStoreSpi extends KeyStoreSpi {
  private static final String NOT_IMPLEMENTED_MESSAGE = "BC JKS store is read-only and only supports certificate entries";
  
  private final Hashtable<String, BCJKSTrustedCertEntry> certificateEntries;
  
  private final JcaJceHelper helper;
  
  public JKSKeyStoreSpi(JcaJceHelper helper) {
    this.certificateEntries = new Hashtable();
    this.helper = helper;
  }
  
  public boolean engineProbe(InputStream stream) throws IOException {
    DataInputStream storeStream;
    if (stream instanceof DataInputStream) {
      storeStream = (DataInputStream)stream;
    } else {
      storeStream = new DataInputStream(stream);
    } 
    int magic = storeStream.readInt();
    int storeVersion = storeStream.readInt();
    return (magic == -17957139 && (storeVersion == 1 || storeVersion == 2));
  }
  
  public Key engineGetKey(String alias, char[] password) throws NoSuchAlgorithmException, UnrecoverableKeyException { return null; }
  
  public Certificate[] engineGetCertificateChain(String alias) { return null; }
  
  public Certificate engineGetCertificate(String alias) {
    synchronized (this.certificateEntries) {
      BCJKSTrustedCertEntry ent = (BCJKSTrustedCertEntry)this.certificateEntries.get(alias);
      if (ent != null)
        return ent.cert; 
    } 
    return null;
  }
  
  public Date engineGetCreationDate(String alias) {
    synchronized (this.certificateEntries) {
      BCJKSTrustedCertEntry ent = (BCJKSTrustedCertEntry)this.certificateEntries.get(alias);
      if (ent != null)
        return ent.date; 
    } 
    return null;
  }
  
  public void engineSetKeyEntry(String alias, Key key, char[] password, Certificate[] chain) throws KeyStoreException { throw new KeyStoreException("BC JKS store is read-only and only supports certificate entries"); }
  
  public void engineSetKeyEntry(String alias, byte[] key, Certificate[] chain) throws KeyStoreException { throw new KeyStoreException("BC JKS store is read-only and only supports certificate entries"); }
  
  public void engineSetCertificateEntry(String alias, Certificate cert) throws KeyStoreException { throw new KeyStoreException("BC JKS store is read-only and only supports certificate entries"); }
  
  public void engineDeleteEntry(String alias) throws KeyStoreException { throw new KeyStoreException("BC JKS store is read-only and only supports certificate entries"); }
  
  public Enumeration<String> engineAliases() {
    synchronized (this.certificateEntries) {
      return this.certificateEntries.keys();
    } 
  }
  
  public boolean engineContainsAlias(String alias) {
    if (alias == null)
      throw new NullPointerException("alias value is null"); 
    synchronized (this.certificateEntries) {
      return this.certificateEntries.containsKey(alias);
    } 
  }
  
  public int engineSize() { return this.certificateEntries.size(); }
  
  public boolean engineIsKeyEntry(String alias) { return false; }
  
  public boolean engineIsCertificateEntry(String alias) {
    synchronized (this.certificateEntries) {
      return this.certificateEntries.containsKey(alias);
    } 
  }
  
  public String engineGetCertificateAlias(Certificate cert) {
    synchronized (this.certificateEntries) {
      for (Iterator<Map.Entry<String, BCJKSTrustedCertEntry>> it = this.certificateEntries.entrySet().iterator(); it.hasNext(); ) {
        Map.Entry<String, BCJKSTrustedCertEntry> entry = (Map.Entry)it.next();
        if (((BCJKSTrustedCertEntry)entry.getValue()).cert.equals(cert))
          return (String)entry.getKey(); 
      } 
      return null;
    } 
  }
  
  public void engineStore(OutputStream stream, char[] password) throws IOException, NoSuchAlgorithmException, CertificateException { throw new IOException("BC JKS store is read-only and only supports certificate entries"); }
  
  public void engineLoad(KeyStore.LoadStoreParameter loadStoreParameter) throws IOException, NoSuchAlgorithmException, CertificateException {
    if (loadStoreParameter == null) {
      engineLoad(null, null);
    } else if (loadStoreParameter instanceof BCLoadStoreParameter) {
      BCLoadStoreParameter bcParam = (BCLoadStoreParameter)loadStoreParameter;
      engineLoad(bcParam.getInputStream(), ParameterUtil.extractPassword(loadStoreParameter));
    } else {
      throw new IllegalArgumentException("no support for 'param' of type " + loadStoreParameter
          .getClass().getName());
    } 
  }
  
  public void engineLoad(InputStream stream, char[] password) throws IOException, NoSuchAlgorithmException, CertificateException {
    if (stream == null)
      return; 
    storeStream = validateStream(stream, password);
    synchronized (this.certificateEntries) {
      try {
        DataInputStream dIn = new DataInputStream(storeStream);
        int magic = dIn.readInt();
        int storeVersion = dIn.readInt();
        if (magic == -17957139) {
          CertificateFactory certFact = null;
          Hashtable certFactories = null;
          switch (storeVersion) {
            case 1:
              certFact = createCertFactory("X.509");
              break;
            case 2:
              certFactories = new Hashtable();
              break;
            default:
              throw new IllegalStateException("unable to discern store version");
          } 
          int numEntries = dIn.readInt();
          for (int t = 0; t < numEntries; t++) {
            Certificate cert;
            byte[] certData;
            int l;
            Date date;
            String alias;
            int tag = dIn.readInt();
            switch (tag) {
              case 1:
                throw new IOException("BC JKS store is read-only and only supports certificate entries");
              case 2:
                alias = dIn.readUTF();
                date = new Date(dIn.readLong());
                if (storeVersion == 2) {
                  String certFormat = dIn.readUTF();
                  if (certFactories.containsKey(certFormat)) {
                    certFact = (CertificateFactory)certFactories.get(certFormat);
                  } else {
                    certFact = createCertFactory(certFormat);
                    certFactories.put(certFormat, certFact);
                  } 
                } 
                l = dIn.readInt();
                certData = new byte[l];
                dIn.readFully(certData);
                certStream = new ErasableByteStream(certData, 0, certData.length);
                try {
                  cert = certFact.generateCertificate(certStream);
                  if (certStream.available() != 0)
                    throw new IOException("password incorrect or store tampered with"); 
                } finally {
                  certStream.erase();
                } 
                this.certificateEntries.put(alias, new BCJKSTrustedCertEntry(date, cert));
                break;
              default:
                throw new IllegalStateException("unable to discern entry type");
            } 
          } 
        } 
        if (storeStream.available() != 0)
          throw new IOException("password incorrect or store tampered with"); 
      } finally {
        storeStream.erase();
      } 
    } 
  }
  
  private CertificateFactory createCertFactory(String certFormat) throws CertificateException {
    if (this.helper != null)
      try {
        return this.helper.createCertificateFactory(certFormat);
      } catch (NoSuchProviderException e) {
        throw new CertificateException(e.toString());
      }  
    return CertificateFactory.getInstance(certFormat);
  }
  
  private void addPassword(Digest digest, char[] password) throws IOException {
    for (int i = 0; i < password.length; i++) {
      digest.update((byte)(password[i] >> '\b'));
      digest.update((byte)password[i]);
    } 
    digest.update(Strings.toByteArray("Mighty Aphrodite"), 0, 16);
  }
  
  private ErasableByteStream validateStream(InputStream inputStream, char[] password) throws IOException {
    Digest checksumCalculator = DigestFactory.getDigest("SHA-1");
    byte[] rawStore = Streams.readAll(inputStream);
    if (password != null) {
      addPassword(checksumCalculator, password);
      checksumCalculator.update(rawStore, 0, rawStore.length - checksumCalculator.getDigestSize());
      byte[] checksum = new byte[checksumCalculator.getDigestSize()];
      checksumCalculator.doFinal(checksum, 0);
      byte[] streamChecksum = new byte[checksum.length];
      System.arraycopy(rawStore, rawStore.length - checksum.length, streamChecksum, 0, checksum.length);
      if (!Arrays.constantTimeAreEqual(checksum, streamChecksum)) {
        Arrays.fill(rawStore, (byte)0);
        throw new IOException("password incorrect or store tampered with");
      } 
      return new ErasableByteStream(rawStore, 0, rawStore.length - checksum.length);
    } 
    return new ErasableByteStream(rawStore, 0, rawStore.length - checksumCalculator.getDigestSize());
  }
}
