package org.bouncycastle.jce.provider;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.ref.WeakReference;
import java.net.HttpURLConnection;
import java.net.URI;
import java.security.cert.CRLException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509CRL;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Map;
import java.util.WeakHashMap;
import javax.naming.NamingException;
import javax.naming.directory.Attribute;
import javax.naming.directory.Attributes;
import javax.naming.directory.DirContext;
import javax.naming.directory.InitialDirContext;
import org.bouncycastle.jcajce.PKIXCRLStore;
import org.bouncycastle.util.CollectionStore;

class CrlCache {
  private static final int DEFAULT_TIMEOUT = 15000;
  
  private static Map<URI, WeakReference<PKIXCRLStore>> cache = Collections.synchronizedMap(new WeakHashMap());
  
  static PKIXCRLStore getCrl(CertificateFactory certFact, Date validDate, URI distributionPoint) throws IOException, CRLException {
    Collection crls;
    PKIXCRLStore crlStore = null;
    WeakReference<PKIXCRLStore> markerRef = (WeakReference)cache.get(distributionPoint);
    if (markerRef != null)
      crlStore = (PKIXCRLStore)markerRef.get(); 
    if (crlStore != null) {
      boolean isExpired = false;
      for (Iterator it = crlStore.getMatches(null).iterator(); it.hasNext(); ) {
        X509CRL crl = (X509CRL)it.next();
        Date nextUpdate = crl.getNextUpdate();
        if (nextUpdate != null && nextUpdate.before(validDate)) {
          isExpired = true;
          break;
        } 
      } 
      if (!isExpired)
        return crlStore; 
    } 
    if (distributionPoint.getScheme().equals("ldap")) {
      crls = getCrlsFromLDAP(certFact, distributionPoint);
    } else {
      crls = getCrls(certFact, distributionPoint);
    } 
    LocalCRLStore localCRLStore = new LocalCRLStore(new CollectionStore(crls));
    cache.put(distributionPoint, new WeakReference(localCRLStore));
    return localCRLStore;
  }
  
  private static Collection getCrlsFromLDAP(CertificateFactory certFact, URI distributionPoint) throws IOException, CRLException {
    Map<String, String> env = new Hashtable<String, String>();
    env.put("java.naming.factory.initial", "com.sun.jndi.ldap.LdapCtxFactory");
    env.put("java.naming.provider.url", distributionPoint.toString());
    byte[] val = null;
    try {
      DirContext ctx = new InitialDirContext((Hashtable)env);
      Attributes avals = ctx.getAttributes("");
      Attribute aval = avals.get("certificateRevocationList;binary");
      val = (byte[])aval.get();
    } catch (NamingException e) {
      throw new CRLException("issue connecting to: " + distributionPoint.toString(), e);
    } 
    if (val == null || val.length == 0)
      throw new CRLException("no CRL returned from: " + distributionPoint); 
    return certFact.generateCRLs(new ByteArrayInputStream(val));
  }
  
  private static Collection getCrls(CertificateFactory certFact, URI distributionPoint) throws IOException, CRLException {
    HttpURLConnection crlCon = (HttpURLConnection)distributionPoint.toURL().openConnection();
    crlCon.setConnectTimeout(15000);
    crlCon.setReadTimeout(15000);
    InputStream crlIn = crlCon.getInputStream();
    Collection crls = certFact.generateCRLs(crlIn);
    crlIn.close();
    return crls;
  }
}
