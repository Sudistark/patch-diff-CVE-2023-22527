package org.bouncycastle.math.ec;

import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.Hashtable;
import org.bouncycastle.math.ec.endo.ECEndomorphism;
import org.bouncycastle.math.ec.endo.GLVEndomorphism;
import org.bouncycastle.math.field.FiniteField;
import org.bouncycastle.util.BigIntegers;
import org.bouncycastle.util.Integers;

public abstract class ECCurve {
  public static final int COORD_AFFINE = 0;
  
  public static final int COORD_HOMOGENEOUS = 1;
  
  public static final int COORD_JACOBIAN = 2;
  
  public static final int COORD_JACOBIAN_CHUDNOVSKY = 3;
  
  public static final int COORD_JACOBIAN_MODIFIED = 4;
  
  public static final int COORD_LAMBDA_AFFINE = 5;
  
  public static final int COORD_LAMBDA_PROJECTIVE = 6;
  
  public static final int COORD_SKEWED = 7;
  
  protected FiniteField field;
  
  protected ECFieldElement a;
  
  protected ECFieldElement b;
  
  protected BigInteger order;
  
  protected BigInteger cofactor;
  
  protected int coord;
  
  protected ECEndomorphism endomorphism;
  
  protected ECMultiplier multiplier;
  
  public static int[] getAllCoordinateSystems() { return new int[] { 0, 1, 2, 3, 4, 5, 6, 7 }; }
  
  protected ECCurve(FiniteField field) {
    this.coord = 0;
    this.endomorphism = null;
    this.multiplier = null;
    this.field = field;
  }
  
  public Config configure() { return new Config(this, this.coord, this.endomorphism, this.multiplier); }
  
  public ECPoint validatePoint(BigInteger x, BigInteger y) {
    ECPoint p = createPoint(x, y);
    if (!p.isValid())
      throw new IllegalArgumentException("Invalid point coordinates"); 
    return p;
  }
  
  public ECPoint createPoint(BigInteger x, BigInteger y) { return createRawPoint(fromBigInteger(x), fromBigInteger(y)); }
  
  protected ECMultiplier createDefaultMultiplier() {
    if (this.endomorphism instanceof GLVEndomorphism)
      return new GLVMultiplier(this, (GLVEndomorphism)this.endomorphism); 
    return new WNafL2RMultiplier();
  }
  
  public boolean supportsCoordinateSystem(int coord) { return (coord == 0); }
  
  public PreCompInfo getPreCompInfo(ECPoint point, String name) {
    Hashtable table;
    checkPoint(point);
    synchronized (point) {
      table = point.preCompTable;
    } 
    if (null == table)
      return null; 
    synchronized (table) {
      return (PreCompInfo)table.get(name);
    } 
  }
  
  public PreCompInfo precompute(ECPoint point, String name, PreCompCallback callback) {
    Hashtable table;
    checkPoint(point);
    synchronized (point) {
      table = point.preCompTable;
      if (null == table)
        point.preCompTable = table = new Hashtable(4); 
    } 
    synchronized (table) {
      PreCompInfo existing = (PreCompInfo)table.get(name);
      PreCompInfo result = callback.precompute(existing);
      if (result != existing)
        table.put(name, result); 
      return result;
    } 
  }
  
  public ECPoint importPoint(ECPoint p) {
    if (this == p.getCurve())
      return p; 
    if (p.isInfinity())
      return getInfinity(); 
    p = p.normalize();
    return createPoint(p.getXCoord().toBigInteger(), p.getYCoord().toBigInteger());
  }
  
  public void normalizeAll(ECPoint[] points) { normalizeAll(points, 0, points.length, null); }
  
  public void normalizeAll(ECPoint[] points, int off, int len, ECFieldElement iso) {
    checkPoints(points, off, len);
    switch (getCoordinateSystem()) {
      case 0:
      case 5:
        if (iso != null)
          throw new IllegalArgumentException("'iso' not valid for affine coordinates"); 
        return;
    } 
    ECFieldElement[] zs = new ECFieldElement[len];
    int[] indices = new int[len];
    int count = 0;
    for (int i = 0; i < len; i++) {
      ECPoint p = points[off + i];
      if (null != p && (iso != null || !p.isNormalized())) {
        zs[count] = p.getZCoord(0);
        indices[count++] = off + i;
      } 
    } 
    if (count == 0)
      return; 
    ECAlgorithms.montgomeryTrick(zs, 0, count, iso);
    for (int j = 0; j < count; j++) {
      int index = indices[j];
      points[index] = points[index].normalize(zs[j]);
    } 
  }
  
  public FiniteField getField() { return this.field; }
  
  public ECFieldElement getA() { return this.a; }
  
  public ECFieldElement getB() { return this.b; }
  
  public BigInteger getOrder() { return this.order; }
  
  public BigInteger getCofactor() { return this.cofactor; }
  
  public int getCoordinateSystem() { return this.coord; }
  
  public ECEndomorphism getEndomorphism() { return this.endomorphism; }
  
  public ECMultiplier getMultiplier() {
    if (this.multiplier == null)
      this.multiplier = createDefaultMultiplier(); 
    return this.multiplier;
  }
  
  public ECPoint decodePoint(byte[] encoded) {
    BigInteger Y, X, Y;
    int yTilde;
    BigInteger X, X;
    ECPoint p = null;
    int expectedLength = (getFieldSize() + 7) / 8;
    byte type = encoded[0];
    switch (type) {
      case 0:
        if (encoded.length != 1)
          throw new IllegalArgumentException("Incorrect length for infinity encoding"); 
        p = getInfinity();
        break;
      case 2:
      case 3:
        if (encoded.length != expectedLength + 1)
          throw new IllegalArgumentException("Incorrect length for compressed encoding"); 
        yTilde = type & true;
        X = BigIntegers.fromUnsignedByteArray(encoded, 1, expectedLength);
        p = decompressPoint(yTilde, X);
        if (!p.implIsValid(true, true))
          throw new IllegalArgumentException("Invalid point"); 
        break;
      case 4:
        if (encoded.length != 2 * expectedLength + 1)
          throw new IllegalArgumentException("Incorrect length for uncompressed encoding"); 
        X = BigIntegers.fromUnsignedByteArray(encoded, 1, expectedLength);
        Y = BigIntegers.fromUnsignedByteArray(encoded, 1 + expectedLength, expectedLength);
        p = validatePoint(X, Y);
        break;
      case 6:
      case 7:
        if (encoded.length != 2 * expectedLength + 1)
          throw new IllegalArgumentException("Incorrect length for hybrid encoding"); 
        X = BigIntegers.fromUnsignedByteArray(encoded, 1, expectedLength);
        Y = BigIntegers.fromUnsignedByteArray(encoded, 1 + expectedLength, expectedLength);
        if (Y.testBit(0) != ((type == 7)))
          throw new IllegalArgumentException("Inconsistent Y coordinate in hybrid encoding"); 
        p = validatePoint(X, Y);
        break;
      default:
        throw new IllegalArgumentException("Invalid point encoding 0x" + Integer.toString(type, 16));
    } 
    if (type != 0 && p.isInfinity())
      throw new IllegalArgumentException("Invalid infinity encoding"); 
    return p;
  }
  
  public ECLookupTable createCacheSafeLookupTable(ECPoint[] points, int off, int len) {
    int FE_BYTES = getFieldSize() + 7 >>> 3;
    byte[] table = new byte[len * FE_BYTES * 2];
    int pos = 0;
    for (int i = 0; i < len; i++) {
      ECPoint p = points[off + i];
      byte[] px = p.getRawXCoord().toBigInteger().toByteArray();
      byte[] py = p.getRawYCoord().toBigInteger().toByteArray();
      int pxStart = (px.length > FE_BYTES) ? 1 : 0, pxLen = px.length - pxStart;
      int pyStart = (py.length > FE_BYTES) ? 1 : 0, pyLen = py.length - pyStart;
      System.arraycopy(px, pxStart, table, pos + FE_BYTES - pxLen, pxLen);
      pos += FE_BYTES;
      System.arraycopy(py, pyStart, table, pos + FE_BYTES - pyLen, pyLen);
      pos += FE_BYTES;
    } 
    return new Object(this, len, FE_BYTES, table);
  }
  
  protected void checkPoint(ECPoint point) {
    if (null == point || this != point.getCurve())
      throw new IllegalArgumentException("'point' must be non-null and on this curve"); 
  }
  
  protected void checkPoints(ECPoint[] points) { checkPoints(points, 0, points.length); }
  
  protected void checkPoints(ECPoint[] points, int off, int len) {
    if (points == null)
      throw new IllegalArgumentException("'points' cannot be null"); 
    if (off < 0 || len < 0 || off > points.length - len)
      throw new IllegalArgumentException("invalid range specified for 'points'"); 
    for (int i = 0; i < len; i++) {
      ECPoint point = points[off + i];
      if (null != point && this != point.getCurve())
        throw new IllegalArgumentException("'points' entries must be null or on this curve"); 
    } 
  }
  
  public boolean equals(ECCurve other) {
    return (this == other || (null != other && 
      
      getField().equals(other.getField()) && 
      getA().toBigInteger().equals(other.getA().toBigInteger()) && 
      getB().toBigInteger().equals(other.getB().toBigInteger())));
  }
  
  public boolean equals(Object obj) { return (this == obj || (obj instanceof ECCurve && equals((ECCurve)obj))); }
  
  public int hashCode() { return getField().hashCode() ^ 
      Integers.rotateLeft(getA().toBigInteger().hashCode(), 8) ^ 
      Integers.rotateLeft(getB().toBigInteger().hashCode(), 16); }
  
  private static int getNumberOfIterations(int bits, int certainty) {
    if (bits >= 1536)
      return (certainty <= 100) ? 3 : ((certainty <= 128) ? 4 : (4 + (certainty - 128 + 1) / 2)); 
    if (bits >= 1024)
      return (certainty <= 100) ? 4 : ((certainty <= 112) ? 5 : (5 + (certainty - 112 + 1) / 2)); 
    if (bits >= 512)
      return (certainty <= 80) ? 5 : ((certainty <= 100) ? 7 : (7 + (certainty - 100 + 1) / 2)); 
    return (certainty <= 80) ? 40 : (40 + (certainty - 80 + 1) / 2);
  }
  
  public abstract int getFieldSize();
  
  public abstract ECFieldElement fromBigInteger(BigInteger paramBigInteger);
  
  public abstract boolean isValidFieldElement(BigInteger paramBigInteger);
  
  public abstract ECFieldElement randomFieldElement(SecureRandom paramSecureRandom);
  
  public abstract ECFieldElement randomFieldElementMult(SecureRandom paramSecureRandom);
  
  protected abstract ECCurve cloneCurve();
  
  protected abstract ECPoint createRawPoint(ECFieldElement paramECFieldElement1, ECFieldElement paramECFieldElement2);
  
  protected abstract ECPoint createRawPoint(ECFieldElement paramECFieldElement1, ECFieldElement paramECFieldElement2, ECFieldElement[] paramArrayOfECFieldElement);
  
  public abstract ECPoint getInfinity();
  
  protected abstract ECPoint decompressPoint(int paramInt, BigInteger paramBigInteger);
}
