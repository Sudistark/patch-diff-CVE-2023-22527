package org.bouncycastle.crypto;

public class DefaultBufferedMultiBlockCipher implements BufferedBlockCipher {
  protected byte[] buf;
  
  protected int bufOff;
  
  protected boolean forEncryption;
  
  protected MultiBlockCipher cipher;
  
  protected boolean partialBlockOkay;
  
  protected boolean pgpCFB;
  
  protected int blockSize;
  
  public DefaultBufferedMultiBlockCipher(MultiBlockCipher cipher) {
    this.cipher = cipher;
    this.blockSize = cipher.getBlockSize();
    String name = cipher.getAlgorithmName();
    int idx = name.indexOf('/') + 1;
    this.pgpCFB = (idx > 0 && name.startsWith("PGP", idx));
    if (this.pgpCFB || cipher instanceof StreamCipher) {
      this.partialBlockOkay = true;
    } else {
      this.partialBlockOkay = (idx > 0 && name.startsWith("OpenPGP", idx));
    } 
  }
  
  public BlockCipher getUnderlyingCipher() { return this.cipher; }
  
  public void init(boolean forEncryption, CipherParameters params) throws IllegalArgumentException {
    this.forEncryption = forEncryption;
    reset();
    this.cipher.init(forEncryption, params);
    this.buf = new byte[this.cipher.getMultiBlockSize()];
    this.bufOff = 0;
  }
  
  public int getBlockSize() { return this.blockSize; }
  
  public int getUpdateOutputSize(int len) {
    int leftOver, total = len + this.bufOff;
    if (this.pgpCFB) {
      if (this.forEncryption) {
        leftOver = total % this.buf.length - this.blockSize + 2;
      } else {
        leftOver = total % this.buf.length;
      } 
    } else {
      leftOver = this.partialBlockOkay ? 0 : (total % this.buf.length);
    } 
    return total - leftOver;
  }
  
  public int getOutputSize(int length) {
    int xcess = this.bufOff % this.blockSize;
    int nblocks = this.bufOff / this.blockSize;
    if (this.pgpCFB && this.forEncryption)
      return length + nblocks * this.blockSize + xcess + this.cipher.getBlockSize() + 2; 
    return length + nblocks * this.blockSize + xcess;
  }
  
  public int processByte(byte in, byte[] out, int outOff) throws DataLengthException {
    int resultLen = 0;
    this.buf[this.bufOff++] = in;
    if (this.bufOff == this.buf.length) {
      resultLen += this.cipher.processBlocks(this.buf, 0, this.buf.length / this.blockSize, out, outOff);
      this.bufOff = 0;
    } 
    return resultLen;
  }
  
  public int processBytes(byte[] in, int inOff, int len, byte[] out, int outOff) throws DataLengthException, IllegalStateException {
    if (len < 0)
      throw new IllegalArgumentException("Can't have a negative input length!"); 
    int length = getUpdateOutputSize(len);
    if (length > 0)
      if (outOff + length > out.length)
        throw new OutputLengthException("output buffer too short");  
    int resultLen = 0;
    int gapLen = this.buf.length - this.bufOff;
    if (len > gapLen) {
      if (this.bufOff != 0) {
        System.arraycopy(in, inOff, this.buf, this.bufOff, gapLen);
        resultLen += this.cipher.processBlocks(this.buf, 0, this.buf.length / this.blockSize, out, outOff);
        this.bufOff = 0;
        len -= gapLen;
        inOff += gapLen;
      } 
      int blockCount = len / this.cipher.getMultiBlockSize() * this.cipher.getMultiBlockSize() / this.blockSize;
      if (blockCount > 0) {
        resultLen += this.cipher.processBlocks(in, inOff, blockCount, out, outOff + resultLen);
        int processed = blockCount * this.blockSize;
        len -= processed;
        inOff += processed;
      } 
    } 
    System.arraycopy(in, inOff, this.buf, this.bufOff, len);
    this.bufOff += len;
    if (this.bufOff == this.buf.length) {
      resultLen += this.cipher.processBlocks(this.buf, 0, this.buf.length / this.blockSize, out, outOff + resultLen);
      this.bufOff = 0;
    } 
    return resultLen;
  }
  
  public int doFinal(byte[] out, int outOff) throws DataLengthException, IllegalStateException, InvalidCipherTextException {
    try {
      int resultLen = 0;
      if (outOff + this.bufOff > out.length)
        throw new OutputLengthException("output buffer too short for doFinal()"); 
      if (this.bufOff != 0) {
        if (!this.partialBlockOkay && this.bufOff % this.blockSize != 0)
          throw new DataLengthException("data not block size aligned"); 
        this.cipher.processBlocks(this.buf, 0, (this.bufOff + this.blockSize - 1) / this.blockSize, this.buf, 0);
        resultLen = this.bufOff;
        this.bufOff = 0;
        System.arraycopy(this.buf, 0, out, outOff, resultLen);
      } 
      return resultLen;
    } finally {
      reset();
    } 
  }
  
  public void reset() {
    if (this.buf != null)
      for (int i = 0; i < this.buf.length; i++)
        this.buf[i] = 0;  
    this.bufOff = 0;
    this.cipher.reset();
  }
  
  public String toString() { return "DefaultBufferedMultiBlockCipher(" + this.cipher.toString() + ")"; }
}
