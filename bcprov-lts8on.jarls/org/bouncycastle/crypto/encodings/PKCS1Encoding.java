package org.bouncycastle.crypto.encodings;

import java.security.SecureRandom;
import org.bouncycastle.crypto.AsymmetricBlockCipher;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.CryptoServicesRegistrar;
import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
import org.bouncycastle.crypto.params.ParametersWithRandom;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Properties;

public class PKCS1Encoding implements AsymmetricBlockCipher {
  private static final String STRICT_LENGTH_ENABLED_PROPERTY = "org.bouncycastle.pkcs1.strict";
  
  public static final String NOT_STRICT_LENGTH_ENABLED_PROPERTY = "org.bouncycastle.pkcs1.not_strict";
  
  private static final int HEADER_LENGTH = 10;
  
  private SecureRandom random;
  
  private AsymmetricBlockCipher engine;
  
  private boolean forEncryption;
  
  private boolean forPrivateKey;
  
  private boolean useStrictLength;
  
  private int pLen;
  
  private byte[] fallback;
  
  private byte[] blockBuffer;
  
  public PKCS1Encoding(AsymmetricBlockCipher cipher) {
    this.pLen = -1;
    this.fallback = null;
    this.engine = cipher;
    this.useStrictLength = useStrict();
  }
  
  public PKCS1Encoding(AsymmetricBlockCipher cipher, int pLen) {
    this.pLen = -1;
    this.fallback = null;
    this.engine = cipher;
    this.useStrictLength = useStrict();
    this.pLen = pLen;
  }
  
  public PKCS1Encoding(AsymmetricBlockCipher cipher, byte[] fallback) {
    this.pLen = -1;
    this.fallback = null;
    this.engine = cipher;
    this.useStrictLength = useStrict();
    this.fallback = fallback;
    this.pLen = fallback.length;
  }
  
  private boolean useStrict() {
    if (Properties.isOverrideSetTo("org.bouncycastle.pkcs1.not_strict", true))
      return false; 
    return !Properties.isOverrideSetTo("org.bouncycastle.pkcs1.strict", false);
  }
  
  public AsymmetricBlockCipher getUnderlyingCipher() { return this.engine; }
  
  public void init(boolean forEncryption, CipherParameters param) {
    AsymmetricKeyParameter kParam;
    if (param instanceof ParametersWithRandom) {
      ParametersWithRandom rParam = (ParametersWithRandom)param;
      this.random = rParam.getRandom();
      kParam = (AsymmetricKeyParameter)rParam.getParameters();
    } else {
      kParam = (AsymmetricKeyParameter)param;
      if (!kParam.isPrivate() && forEncryption)
        this.random = CryptoServicesRegistrar.getSecureRandom(); 
    } 
    this.engine.init(forEncryption, param);
    this.forPrivateKey = kParam.isPrivate();
    this.forEncryption = forEncryption;
    this.blockBuffer = new byte[this.engine.getOutputBlockSize()];
    if (this.pLen > 0 && this.fallback == null && this.random == null)
      throw new IllegalArgumentException("encoder requires random"); 
  }
  
  public int getInputBlockSize() {
    int baseBlockSize = this.engine.getInputBlockSize();
    if (this.forEncryption)
      return baseBlockSize - 10; 
    return baseBlockSize;
  }
  
  public int getOutputBlockSize() {
    int baseBlockSize = this.engine.getOutputBlockSize();
    if (this.forEncryption)
      return baseBlockSize; 
    return baseBlockSize - 10;
  }
  
  public byte[] processBlock(byte[] in, int inOff, int inLen) throws InvalidCipherTextException {
    if (this.forEncryption)
      return encodeBlock(in, inOff, inLen); 
    return decodeBlock(in, inOff, inLen);
  }
  
  private byte[] encodeBlock(byte[] in, int inOff, int inLen) throws InvalidCipherTextException {
    if (inLen > getInputBlockSize())
      throw new IllegalArgumentException("input data too large"); 
    byte[] block = new byte[this.engine.getInputBlockSize()];
    if (this.forPrivateKey) {
      block[0] = 1;
      for (int i = 1; i != block.length - inLen - 1; i++)
        block[i] = -1; 
    } else {
      this.random.nextBytes(block);
      block[0] = 2;
      for (int i = 1; i != block.length - inLen - 1; i++) {
        while (block[i] == 0)
          block[i] = (byte)this.random.nextInt(); 
      } 
    } 
    block[block.length - inLen - 1] = 0;
    System.arraycopy(in, inOff, block, block.length - inLen, inLen);
    return this.engine.processBlock(block, 0, block.length);
  }
  
  private static int checkPkcs1Encoding(byte[] encoded, int pLen) {
    int correct = 0;
    correct |= encoded[0] ^ 0x2;
    int plen = encoded.length - pLen + 1;
    for (int i = 1; i < plen; i++) {
      int tmp = encoded[i];
      tmp |= tmp >> 1;
      tmp |= tmp >> 2;
      tmp |= tmp >> 4;
      correct |= (tmp & true) - 1;
    } 
    correct |= encoded[encoded.length - pLen + 1];
    correct |= correct >> 1;
    correct |= correct >> 2;
    correct |= correct >> 4;
    return (correct & true) - 1 ^ 0xFFFFFFFF;
  }
  
  private byte[] decodeBlockOrRandom(byte[] in, int inOff, int inLen) throws InvalidCipherTextException {
    byte[] random;
    if (!this.forPrivateKey)
      throw new InvalidCipherTextException("sorry, this method is only for decryption, not for signing"); 
    byte[] block = this.engine.processBlock(in, inOff, inLen);
    if (this.fallback == null) {
      random = new byte[this.pLen];
      this.random.nextBytes(random);
    } else {
      random = this.fallback;
    } 
    byte[] data = (this.useStrictLength & ((block.length != this.engine.getOutputBlockSize()) ? 1 : 0)) ? this.blockBuffer : block;
    int correct = checkPkcs1Encoding(data, this.pLen);
    byte[] result = new byte[this.pLen];
    for (int i = 0; i < this.pLen; i++)
      result[i] = (byte)(data[i + data.length - this.pLen] & (correct ^ 0xFFFFFFFF) | random[i] & correct); 
    Arrays.fill(data, (byte)0);
    return result;
  }
  
  private byte[] decodeBlock(byte[] in, int inOff, int inLen) throws InvalidCipherTextException {
    boolean badType;
    byte[] data;
    if (this.pLen != -1)
      return decodeBlockOrRandom(in, inOff, inLen); 
    byte[] block = this.engine.processBlock(in, inOff, inLen);
    boolean incorrectLength = this.useStrictLength & ((block.length != this.engine.getOutputBlockSize()) ? 1 : 0);
    if (block.length < getOutputBlockSize()) {
      data = this.blockBuffer;
    } else {
      data = block;
    } 
    byte type = data[0];
    if (this.forPrivateKey) {
      badType = (type != 2);
    } else {
      badType = (type != 1);
    } 
    int start = findStart(type, data);
    start++;
    if (badType | ((start < 10) ? 1 : 0)) {
      Arrays.fill(data, (byte)0);
      throw new InvalidCipherTextException("block incorrect");
    } 
    if (incorrectLength) {
      Arrays.fill(data, (byte)0);
      throw new InvalidCipherTextException("block incorrect size");
    } 
    byte[] result = new byte[data.length - start];
    System.arraycopy(data, start, result, 0, result.length);
    return result;
  }
  
  private int findStart(byte type, byte[] block) throws InvalidCipherTextException {
    int start = -1;
    boolean padErr = false;
    for (int i = 1; i != block.length; i++) {
      byte pad = block[i];
      if (((pad == 0) ? 1 : 0) & ((start < 0) ? 1 : 0))
        start = i; 
      padErr |= ((type == 1) ? 1 : 0) & ((start < 0) ? 1 : 0) & ((pad != -1) ? 1 : 0);
    } 
    if (padErr)
      return -1; 
    return start;
  }
}
