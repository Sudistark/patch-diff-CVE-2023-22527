package org.bouncycastle.crypto.macs;

import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.Mac;
import org.bouncycastle.crypto.engines.Zuc128CoreEngine;

public final class Zuc128Mac implements Mac {
  private static final int TOPBIT = 128;
  
  private final InternalZuc128Engine theEngine = new InternalZuc128Engine(null);
  
  private int theMac;
  
  private final int[] theKeyStream = new int[2];
  
  private Zuc128CoreEngine theState;
  
  private int theWordIndex;
  
  private int theByteIndex;
  
  public String getAlgorithmName() { return "Zuc128Mac"; }
  
  public int getMacSize() { return 4; }
  
  public void init(CipherParameters pParams) {
    this.theEngine.init(true, pParams);
    this.theState = (Zuc128CoreEngine)this.theEngine.copy();
    initKeyStream();
  }
  
  private void initKeyStream() {
    this.theMac = 0;
    for (int i = 0; i < this.theKeyStream.length - 1; i++)
      this.theKeyStream[i] = this.theEngine.createKeyStreamWord(); 
    this.theWordIndex = this.theKeyStream.length - 1;
    this.theByteIndex = 3;
  }
  
  public void update(byte in) {
    shift4NextByte();
    int bitBase = this.theByteIndex * 8;
    for (int bitMask = 128, bitNo = 0; bitMask > 0; bitMask >>= 1, bitNo++) {
      if ((in & bitMask) != 0)
        updateMac(bitBase + bitNo); 
    } 
  }
  
  private void shift4NextByte() {
    this.theByteIndex = (this.theByteIndex + 1) % 4;
    if (this.theByteIndex == 0) {
      this.theKeyStream[this.theWordIndex] = this.theEngine.createKeyStreamWord();
      this.theWordIndex = (this.theWordIndex + 1) % this.theKeyStream.length;
    } 
  }
  
  private void updateMac(int bitNo) { this.theMac ^= getKeyStreamWord(bitNo); }
  
  private int getKeyStreamWord(int bitNo) {
    int myFirst = this.theKeyStream[this.theWordIndex];
    if (bitNo == 0)
      return myFirst; 
    int mySecond = this.theKeyStream[(this.theWordIndex + 1) % this.theKeyStream.length];
    return myFirst << bitNo | mySecond >>> 32 - bitNo;
  }
  
  public void update(byte[] in, int inOff, int len) {
    for (int byteNo = 0; byteNo < len; byteNo++)
      update(in[inOff + byteNo]); 
  }
  
  private int getFinalWord() {
    if (this.theByteIndex != 0)
      return this.theEngine.createKeyStreamWord(); 
    this.theWordIndex = (this.theWordIndex + 1) % this.theKeyStream.length;
    return this.theKeyStream[this.theWordIndex];
  }
  
  public int doFinal(byte[] out, int outOff) {
    shift4NextByte();
    this.theMac ^= getKeyStreamWord(this.theByteIndex * 8);
    this.theMac ^= getFinalWord();
    Zuc128CoreEngine.encode32be(this.theMac, out, outOff);
    reset();
    return getMacSize();
  }
  
  public void reset() {
    if (this.theState != null)
      this.theEngine.reset(this.theState); 
    initKeyStream();
  }
}
