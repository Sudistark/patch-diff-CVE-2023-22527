package org.bouncycastle.crypto.macs;

import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.Mac;
import org.bouncycastle.crypto.engines.Zuc256CoreEngine;

public final class Zuc256Mac implements Mac {
  private static final int TOPBIT = 128;
  
  private final InternalZuc256Engine theEngine;
  
  private final int theMacLength;
  
  private final int[] theMac;
  
  private final int[] theKeyStream;
  
  private Zuc256CoreEngine theState;
  
  private int theWordIndex;
  
  private int theByteIndex;
  
  public Zuc256Mac(int pLength) {
    this.theEngine = new InternalZuc256Engine(pLength);
    this.theMacLength = pLength;
    int numWords = pLength / 32;
    this.theMac = new int[numWords];
    this.theKeyStream = new int[numWords + 1];
  }
  
  public String getAlgorithmName() { return "Zuc256Mac-" + this.theMacLength; }
  
  public int getMacSize() { return this.theMacLength / 8; }
  
  public void init(CipherParameters pParams) {
    this.theEngine.init(true, pParams);
    this.theState = (Zuc256CoreEngine)this.theEngine.copy();
    initKeyStream();
  }
  
  private void initKeyStream() {
    for (int i = 0; i < this.theMac.length; i++)
      this.theMac[i] = this.theEngine.createKeyStreamWord(); 
    for (int i = 0; i < this.theKeyStream.length - 1; i++)
      this.theKeyStream[i] = this.theEngine.createKeyStreamWord(); 
    this.theWordIndex = this.theKeyStream.length - 1;
    this.theByteIndex = 3;
  }
  
  public void update(byte in) {
    shift4NextByte();
    int bitBase = this.theByteIndex * 8;
    for (int bitMask = 128, bitNo = 0; bitMask > 0; bitMask >>= 1, bitNo++) {
      if ((in & bitMask) != 0)
        updateMac(bitBase + bitNo); 
    } 
  }
  
  private void shift4NextByte() {
    this.theByteIndex = (this.theByteIndex + 1) % 4;
    if (this.theByteIndex == 0) {
      this.theKeyStream[this.theWordIndex] = this.theEngine.createKeyStreamWord();
      this.theWordIndex = (this.theWordIndex + 1) % this.theKeyStream.length;
    } 
  }
  
  private void shift4Final() {
    this.theByteIndex = (this.theByteIndex + 1) % 4;
    if (this.theByteIndex == 0)
      this.theWordIndex = (this.theWordIndex + 1) % this.theKeyStream.length; 
  }
  
  private void updateMac(int bitNo) {
    for (int wordNo = 0; wordNo < this.theMac.length; wordNo++)
      this.theMac[wordNo] = this.theMac[wordNo] ^ getKeyStreamWord(wordNo, bitNo); 
  }
  
  private int getKeyStreamWord(int wordNo, int bitNo) {
    int myFirst = this.theKeyStream[(this.theWordIndex + wordNo) % this.theKeyStream.length];
    if (bitNo == 0)
      return myFirst; 
    int mySecond = this.theKeyStream[(this.theWordIndex + wordNo + 1) % this.theKeyStream.length];
    return myFirst << bitNo | mySecond >>> 32 - bitNo;
  }
  
  public void update(byte[] in, int inOff, int len) {
    for (int byteNo = 0; byteNo < len; byteNo++)
      update(in[inOff + byteNo]); 
  }
  
  public int doFinal(byte[] out, int outOff) {
    shift4Final();
    updateMac(this.theByteIndex * 8);
    for (int i = 0; i < this.theMac.length; i++)
      Zuc256CoreEngine.encode32be(this.theMac[i], out, outOff + i * 4); 
    reset();
    return getMacSize();
  }
  
  public void reset() {
    if (this.theState != null)
      this.theEngine.reset(this.theState); 
    initKeyStream();
  }
}
