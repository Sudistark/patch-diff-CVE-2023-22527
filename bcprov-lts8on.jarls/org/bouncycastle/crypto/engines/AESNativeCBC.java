package org.bouncycastle.crypto.engines;

import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.MultiBlockCipher;
import org.bouncycastle.crypto.modes.CBCModeCipher;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.ParametersWithIV;
import org.bouncycastle.util.Arrays;

class AESNativeCBC implements CBCModeCipher {
  private CBCRefWrapper referenceWrapper;
  
  byte[] IV = new byte[16];
  
  byte[] oldKey;
  
  int keySize;
  
  private boolean encrypting;
  
  public void init(boolean forEncryption, CipherParameters params) throws IllegalArgumentException {
    boolean oldEncrypting = this.encrypting;
    this.encrypting = forEncryption;
    if (params instanceof ParametersWithIV) {
      ParametersWithIV ivParam = (ParametersWithIV)params;
      byte[] iv = ivParam.getIV();
      if (iv.length != getBlockSize())
        throw new IllegalArgumentException("initialisation vector must be the same length as block size"); 
      System.arraycopy(iv, 0, this.IV, 0, iv.length);
      reset();
      if (ivParam.getParameters() != null) {
        init((KeyParameter)ivParam.getParameters());
      } else {
        if (oldEncrypting != this.encrypting)
          throw new IllegalArgumentException("cannot change encrypting state without providing key"); 
        if (this.oldKey == null)
          throw new IllegalStateException("IV change attempted but not previously initialized with a key"); 
        init(new KeyParameter(this.oldKey));
      } 
    } else {
      reset();
      if (params != null) {
        init((KeyParameter)params);
      } else {
        if (oldEncrypting != this.encrypting)
          throw new IllegalArgumentException("cannot change encrypting state without providing key."); 
        if (this.oldKey == null)
          throw new IllegalStateException("IV change attempted but not previously initialized with a key"); 
        init(new KeyParameter(this.oldKey));
      } 
    } 
  }
  
  private void init(KeyParameter parameters) {
    byte[] key = parameters.getKey();
    switch (key.length) {
      case 16:
      case 24:
      case 32:
        break;
      default:
        throw new IllegalArgumentException("key must be only 16,24,or 32 bytes long.");
    } 
    this.referenceWrapper = new CBCRefWrapper(this, makeNative(key.length, this.encrypting));
    if (this.referenceWrapper.getReference() == 0L)
      throw new IllegalStateException("Native CBC native instance returned a null pointer."); 
    this.oldKey = Arrays.clone(key);
    init(this.referenceWrapper.getReference(), key, this.IV);
    this.keySize = key.length * 8;
  }
  
  public String getAlgorithmName() { return "AES/CBC"; }
  
  public int getBlockSize() { return getBlockSize(0L); }
  
  public int processBlock(byte[] in, int inOff, byte[] out, int outOff) throws DataLengthException, IllegalStateException {
    if (this.referenceWrapper == null)
      throw new IllegalStateException("not initialized"); 
    return process(this.referenceWrapper.getReference(), in, inOff, 1, out, outOff);
  }
  
  public void reset() {
    if (this.referenceWrapper == null)
      return; 
    reset(this.referenceWrapper.getReference());
  }
  
  public int getMultiBlockSize() { return getMultiBlockSize(0L); }
  
  public int processBlocks(byte[] in, int inOff, int blockCount, byte[] out, int outOff) throws DataLengthException, IllegalStateException {
    if (this.referenceWrapper == null)
      throw new IllegalStateException("not initialized"); 
    return process(this.referenceWrapper.getReference(), in, inOff, blockCount, out, outOff);
  }
  
  private static native int process(long paramLong, byte[] paramArrayOfByte1, int paramInt1, int paramInt2, byte[] paramArrayOfByte2, int paramInt3);
  
  private static native int getMultiBlockSize(long paramLong);
  
  private static native int getBlockSize(long paramLong);
  
  static native long makeNative(int paramInt, boolean paramBoolean);
  
  native void init(long paramLong, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2);
  
  static native void dispose(long paramLong);
  
  private static native void reset(long paramLong);
  
  public BlockCipher getUnderlyingCipher() {
    MultiBlockCipher eng = AESEngine.newInstance();
    eng.init(this.encrypting, new KeyParameter(this.oldKey));
    return eng;
  }
  
  public String toString() { return "CBC[Native](AES[Native](" + this.keySize + ")"; }
}
