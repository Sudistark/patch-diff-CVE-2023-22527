package org.bouncycastle.crypto.engines;

import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.crypto.MultiBlockCipher;
import org.bouncycastle.crypto.modes.GCMModeCipher;
import org.bouncycastle.crypto.params.AEADParameters;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.ParametersWithIV;
import org.bouncycastle.util.Arrays;

class AESNativeGCM implements GCMModeCipher {
  private GCMRefWrapper refWrapper;
  
  private int macSize = 0;
  
  private byte[] nonce;
  
  private byte[] lastKey;
  
  private byte[] initialAssociatedText;
  
  private boolean forEncryption = false;
  
  private boolean initialised = false;
  
  private byte[] keptMac = null;
  
  private boolean finalCalled = false;
  
  public BlockCipher getUnderlyingCipher() {
    MultiBlockCipher multiBlockCipher = AESEngine.newInstance();
    if (this.lastKey != null)
      multiBlockCipher.init(true, new KeyParameter(this.lastKey)); 
    return multiBlockCipher;
  }
  
  public void init(boolean forEncryption, CipherParameters params) throws IllegalArgumentException {
    KeyParameter keyParam;
    this.forEncryption = forEncryption;
    byte[] newNonce = null;
    this.keptMac = null;
    if (params instanceof AEADParameters) {
      AEADParameters param = (AEADParameters)params;
      newNonce = param.getNonce();
      this.initialAssociatedText = param.getAssociatedText();
      int macSizeBits = param.getMacSize();
      if (macSizeBits < 32 || macSizeBits > 128 || macSizeBits % 8 != 0)
        throw new IllegalArgumentException("invalid value for MAC size: " + macSizeBits); 
      this.macSize = macSizeBits;
      keyParam = param.getKey();
    } else if (params instanceof ParametersWithIV) {
      ParametersWithIV param = (ParametersWithIV)params;
      newNonce = param.getIV();
      this.initialAssociatedText = null;
      this.macSize = 128;
      keyParam = (KeyParameter)param.getParameters();
    } else {
      throw new IllegalArgumentException("invalid parameters passed to GCM");
    } 
    if (newNonce == null || newNonce.length < 12)
      throw new IllegalArgumentException("IV must be at least 12 bytes"); 
    if (forEncryption)
      if (this.nonce != null && Arrays.areEqual(this.nonce, newNonce)) {
        if (keyParam == null)
          throw new IllegalArgumentException("cannot reuse nonce for GCM encryption"); 
        if (this.lastKey != null && Arrays.areEqual(this.lastKey, keyParam.getKey()))
          throw new IllegalArgumentException("cannot reuse nonce for GCM encryption"); 
      }  
    this.nonce = newNonce;
    if (keyParam != null)
      this.lastKey = keyParam.getKey(); 
    switch (this.lastKey.length) {
      case 16:
      case 24:
      case 32:
        break;
      default:
        throw new IllegalStateException("key must be only 16,24,or 32 bytes long.");
    } 
    initRef(this.lastKey.length);
    initNative(this.refWrapper
        .getReference(), forEncryption, this.lastKey, this.nonce, this.initialAssociatedText, this.macSize);
    this.finalCalled = false;
    this.initialised = true;
  }
  
  private void initRef(int keySize) { this.refWrapper = new GCMRefWrapper(makeInstance(keySize, this.forEncryption)); }
  
  public String getAlgorithmName() { return "AES/GCM"; }
  
  public void processAADByte(byte in) { processAADByte(this.refWrapper.getReference(), in); }
  
  public void processAADBytes(byte[] in, int inOff, int len) {
    if (this.refWrapper == null)
      throw new IllegalStateException("GCM is uninitialized"); 
    processAADBytes(this.refWrapper.getReference(), in, inOff, len);
  }
  
  public int processByte(byte in, byte[] out, int outOff) throws DataLengthException {
    if (this.refWrapper == null)
      throw new IllegalStateException("GCM is uninitialized"); 
    return processByte(this.refWrapper.getReference(), in, out, outOff);
  }
  
  public int processBytes(byte[] in, int inOff, int len, byte[] out, int outOff) throws DataLengthException {
    if (this.refWrapper == null)
      throw new IllegalStateException("GCM is uninitialized"); 
    return processBytes(this.refWrapper.getReference(), in, inOff, len, out, outOff);
  }
  
  public int doFinal(byte[] out, int outOff) throws IllegalStateException, InvalidCipherTextException {
    checkStatus();
    int len = doFinal(this.refWrapper.getReference(), out, outOff);
    resetKeepMac();
    return len;
  }
  
  public byte[] getMac() {
    if (this.keptMac != null)
      return Arrays.clone(this.keptMac); 
    return getMac(this.refWrapper.getReference());
  }
  
  public int getUpdateOutputSize(int len) { return getUpdateOutputSize(this.refWrapper.getReference(), len); }
  
  public int getOutputSize(int len) { return getOutputSize(this.refWrapper.getReference(), len); }
  
  public void reset() {
    if (this.refWrapper == null)
      return; 
    reset(this.refWrapper.getReference());
    this.initialised = false;
  }
  
  private void resetKeepMac() {
    if (this.refWrapper == null)
      return; 
    this.keptMac = getMac();
    reset(this.refWrapper.getReference());
    this.initialised = false;
  }
  
  private void checkStatus() {
    if (!this.initialised) {
      if (this.forEncryption)
        throw new IllegalStateException("GCM cipher cannot be reused for encryption"); 
      throw new IllegalStateException("GCM cipher needs to be initialised");
    } 
  }
  
  private native void reset(long paramLong);
  
  static native void initNative(long paramLong, boolean paramBoolean, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, byte[] paramArrayOfByte3, int paramInt);
  
  static native long makeInstance(int paramInt, boolean paramBoolean);
  
  static native void dispose(long paramLong);
  
  private static native void processAADByte(long paramLong, byte paramByte);
  
  private static native void processAADBytes(long paramLong, byte[] paramArrayOfByte, int paramInt1, int paramInt2);
  
  private static native int processByte(long paramLong, byte paramByte, byte[] paramArrayOfByte, int paramInt);
  
  private static native int processBytes(long paramLong, byte[] paramArrayOfByte1, int paramInt1, int paramInt2, byte[] paramArrayOfByte2, int paramInt3);
  
  private static native int doFinal(long paramLong, byte[] paramArrayOfByte, int paramInt);
  
  private static native int getUpdateOutputSize(long paramLong, int paramInt);
  
  private static native int getOutputSize(long paramLong, int paramInt);
  
  public static native byte[] getMac(long paramLong);
  
  void setBlocksRemainingDown(long value) { setBlocksRemainingDown(this.refWrapper.getReference(), value); }
  
  private native void setBlocksRemainingDown(long paramLong1, long paramLong2);
  
  public String toString() {
    if (this.lastKey != null)
      return "GCM[Native](AES[Native](" + (this.lastKey.length * 8) + "))"; 
    return "GCM[Native](AES[Native](not initialized))";
  }
}
