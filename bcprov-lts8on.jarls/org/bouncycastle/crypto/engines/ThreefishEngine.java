package org.bouncycastle.crypto.engines;

import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.CryptoServicesRegistrar;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.OutputLengthException;
import org.bouncycastle.crypto.constraints.DefaultServiceProperties;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.TweakableBlockCipherParameters;
import org.bouncycastle.util.Pack;

public class ThreefishEngine implements BlockCipher {
  public static final int BLOCKSIZE_256 = 256;
  
  public static final int BLOCKSIZE_512 = 512;
  
  public static final int BLOCKSIZE_1024 = 1024;
  
  private static final int TWEAK_SIZE_BYTES = 16;
  
  private static final int TWEAK_SIZE_WORDS = 2;
  
  private static final int ROUNDS_256 = 72;
  
  private static final int ROUNDS_512 = 72;
  
  private static final int ROUNDS_1024 = 80;
  
  private static final int MAX_ROUNDS = 80;
  
  private static final long C_240 = 2004413935125273122L;
  
  private static int[] MOD9 = new int[80];
  
  private static int[] MOD17 = new int[MOD9.length];
  
  private static int[] MOD5 = new int[MOD9.length];
  
  private static int[] MOD3 = new int[MOD9.length];
  
  private int blocksizeBytes;
  
  private int blocksizeWords;
  
  private long[] currentBlock;
  
  private long[] t;
  
  private long[] kw;
  
  private ThreefishCipher cipher;
  
  private boolean forEncryption;
  
  static  {
    for (i = 0; i < MOD9.length; i++) {
      MOD17[i] = i % 17;
      MOD9[i] = i % 9;
      MOD5[i] = i % 5;
      MOD3[i] = i % 3;
    } 
  }
  
  public ThreefishEngine(int blocksizeBits) {
    this.t = new long[5];
    this.blocksizeBytes = blocksizeBits / 8;
    this.blocksizeWords = this.blocksizeBytes / 8;
    this.currentBlock = new long[this.blocksizeWords];
    this.kw = new long[2 * this.blocksizeWords + 1];
    switch (blocksizeBits) {
      case 256:
        this.cipher = new Threefish256Cipher(this.kw, this.t);
        return;
      case 512:
        this.cipher = new Threefish512Cipher(this.kw, this.t);
        return;
      case 1024:
        this.cipher = new Threefish1024Cipher(this.kw, this.t);
        return;
    } 
    throw new IllegalArgumentException("Invalid blocksize - Threefish is defined with block size of 256, 512, or 1024 bits");
  }
  
  public void init(boolean forEncryption, CipherParameters params) throws IllegalArgumentException {
    byte[] tweakBytes, keyBytes;
    if (params instanceof TweakableBlockCipherParameters) {
      TweakableBlockCipherParameters tParams = (TweakableBlockCipherParameters)params;
      keyBytes = tParams.getKey().getKey();
      tweakBytes = tParams.getTweak();
    } else if (params instanceof KeyParameter) {
      keyBytes = ((KeyParameter)params).getKey();
      tweakBytes = null;
    } else {
      throw new IllegalArgumentException("Invalid parameter passed to Threefish init - " + params
          .getClass().getName());
    } 
    long[] keyWords = null;
    long[] tweakWords = null;
    if (keyBytes != null) {
      if (keyBytes.length != this.blocksizeBytes)
        throw new IllegalArgumentException("Threefish key must be same size as block (" + this.blocksizeBytes + " bytes)"); 
      keyWords = new long[this.blocksizeWords];
      Pack.littleEndianToLong(keyBytes, 0, keyWords);
    } 
    if (tweakBytes != null) {
      if (tweakBytes.length != 16)
        throw new IllegalArgumentException("Threefish tweak must be 16 bytes"); 
      tweakWords = new long[2];
      Pack.littleEndianToLong(tweakBytes, 0, tweakWords);
    } 
    init(forEncryption, keyWords, tweakWords);
    CryptoServicesRegistrar.checkConstraints(new DefaultServiceProperties(
          getAlgorithmName(), 256, params, Utils.getPurpose(forEncryption)));
  }
  
  public void init(boolean forEncryption, long[] key, long[] tweak) {
    this.forEncryption = forEncryption;
    if (key != null)
      setKey(key); 
    if (tweak != null)
      setTweak(tweak); 
  }
  
  private void setKey(long[] key) {
    if (key.length != this.blocksizeWords)
      throw new IllegalArgumentException("Threefish key must be same size as block (" + this.blocksizeWords + " words)"); 
    long knw = 2004413935125273122L;
    for (int i = 0; i < this.blocksizeWords; i++) {
      this.kw[i] = key[i];
      knw ^= this.kw[i];
    } 
    this.kw[this.blocksizeWords] = knw;
    System.arraycopy(this.kw, 0, this.kw, this.blocksizeWords + 1, this.blocksizeWords);
  }
  
  private void setTweak(long[] tweak) {
    if (tweak.length != 2)
      throw new IllegalArgumentException("Tweak must be 2 words."); 
    this.t[0] = tweak[0];
    this.t[1] = tweak[1];
    this.t[2] = this.t[0] ^ this.t[1];
    this.t[3] = this.t[0];
    this.t[4] = this.t[1];
  }
  
  public String getAlgorithmName() { return "Threefish-" + (this.blocksizeBytes * 8); }
  
  public int getBlockSize() { return this.blocksizeBytes; }
  
  public void reset() {}
  
  public int processBlock(byte[] in, int inOff, byte[] out, int outOff) throws DataLengthException, IllegalStateException {
    if (inOff + this.blocksizeBytes > in.length)
      throw new DataLengthException("Input buffer too short"); 
    if (outOff + this.blocksizeBytes > out.length)
      throw new OutputLengthException("Output buffer too short"); 
    Pack.littleEndianToLong(in, inOff, this.currentBlock);
    processBlock(this.currentBlock, this.currentBlock);
    Pack.longToLittleEndian(this.currentBlock, out, outOff);
    return this.blocksizeBytes;
  }
  
  public int processBlock(long[] in, long[] out) throws DataLengthException, IllegalStateException {
    if (this.kw[this.blocksizeWords] == 0L)
      throw new IllegalStateException("Threefish engine not initialised"); 
    if (in.length != this.blocksizeWords)
      throw new DataLengthException("Input buffer too short"); 
    if (out.length != this.blocksizeWords)
      throw new OutputLengthException("Output buffer too short"); 
    if (this.forEncryption) {
      this.cipher.encryptBlock(in, out);
    } else {
      this.cipher.decryptBlock(in, out);
    } 
    return this.blocksizeWords;
  }
  
  static long rotlXor(long x, int n, long xor) { return (x << n | x >>> -n) ^ xor; }
  
  static long xorRotr(long x, int n, long xor) {
    long xored = x ^ xor;
    return xored >>> n | xored << -n;
  }
}
