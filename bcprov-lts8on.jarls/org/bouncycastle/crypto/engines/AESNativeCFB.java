package org.bouncycastle.crypto.engines;

import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.modes.CFBModeCipher;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.ParametersWithIV;
import org.bouncycastle.util.Arrays;

class AESNativeCFB implements CFBModeCipher {
  private final int bitSize;
  
  private CFBRefWrapper referenceWrapper;
  
  private byte[] oldKey;
  
  private byte[] oldIv;
  
  private boolean encrypting;
  
  public AESNativeCFB() { this(128); }
  
  public AESNativeCFB(int bitSize) {
    this.bitSize = bitSize;
    switch (bitSize) {
      case 128:
        return;
    } 
    throw new IllegalArgumentException("native feedback bit size can only be 128");
  }
  
  public void init(boolean forEncryption, CipherParameters params) throws IllegalArgumentException {
    boolean oldEncrypting = this.encrypting;
    this.encrypting = forEncryption;
    byte[] key = null;
    byte[] iv = null;
    if (params instanceof ParametersWithIV) {
      ParametersWithIV ivParam = (ParametersWithIV)params;
      iv = ivParam.getIV();
      if (iv.length > getBlockSize() || iv.length < 1)
        throw new IllegalArgumentException("initialisation vector must be between one and block size length"); 
      if (iv.length < getBlockSize()) {
        byte[] newIv = new byte[getBlockSize()];
        System.arraycopy(iv, 0, newIv, newIv.length - iv.length, iv.length);
        iv = newIv;
      } 
      this.oldIv = Arrays.clone(iv);
      if (ivParam.getParameters() != null)
        key = ((KeyParameter)ivParam.getParameters()).getKey(); 
      if (key != null) {
        oldEncrypting = this.encrypting;
        this.oldKey = Arrays.clone(key);
      } else {
        key = this.oldKey;
      } 
    } else if (params instanceof KeyParameter) {
      key = ((KeyParameter)params).getKey();
      this.oldKey = Arrays.clone(key);
      iv = this.oldIv;
    } 
    if (key == null && oldEncrypting != this.encrypting)
      throw new IllegalArgumentException("cannot change encrypting state without providing key."); 
    if (iv == null)
      throw new IllegalArgumentException("iv is null"); 
    switch (key.length) {
      case 16:
      case 24:
      case 32:
        break;
      default:
        throw new IllegalStateException("key must be only 16,24,or 32 bytes long.");
    } 
    this.referenceWrapper = new CFBRefWrapper(makeNative(this.encrypting, key.length));
    init(this.referenceWrapper.getReference(), key, iv);
  }
  
  public String getAlgorithmName() { return "AES/CFB"; }
  
  public byte returnByte(byte in) { return processByte(this.referenceWrapper.getReference(), in); }
  
  public int processBytes(byte[] in, int inOff, int len, byte[] out, int outOff) throws DataLengthException {
    if (this.referenceWrapper == null)
      throw new IllegalStateException("not initialized"); 
    return processBytes(this.referenceWrapper.getReference(), in, inOff, len, out, outOff);
  }
  
  public int getBlockSize() { return this.bitSize / 8; }
  
  public int processBlock(byte[] in, int inOff, byte[] out, int outOff) throws DataLengthException, IllegalStateException {
    if (this.referenceWrapper == null)
      throw new IllegalStateException("not initialized"); 
    return processBytes(this.referenceWrapper.getReference(), in, inOff, getBlockSize(), out, outOff);
  }
  
  public void reset() {
    if (this.referenceWrapper == null)
      return; 
    reset(this.referenceWrapper.getReference());
  }
  
  public int getMultiBlockSize() { return getNativeMultiBlockSize(); }
  
  public int processBlocks(byte[] in, int inOff, int blockCount, byte[] out, int outOff) throws DataLengthException {
    if (this.referenceWrapper == null)
      throw new IllegalStateException("CFB engine not initialized"); 
    return processBytes(in, inOff, blockCount * getBlockSize(), out, outOff);
  }
  
  private static native byte processByte(long paramLong, byte paramByte);
  
  private static native int processBytes(long paramLong, byte[] paramArrayOfByte1, int paramInt1, int paramInt2, byte[] paramArrayOfByte2, int paramInt3) throws DataLengthException;
  
  static native long makeNative(boolean paramBoolean, int paramInt);
  
  native void init(long paramLong, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2);
  
  static native void dispose(long paramLong);
  
  static native int getNativeMultiBlockSize();
  
  private static native void reset(long paramLong);
  
  public String toString() {
    if (this.oldKey != null)
      return "CFB[Native](AES[Native](" + (this.oldKey.length * 8) + "))"; 
    return "CFB[Native](AES[Native](not initialized))";
  }
}
