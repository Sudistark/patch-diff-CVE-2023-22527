package org.bouncycastle.crypto.engines;

import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.CryptoServicesRegistrar;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.OutputLengthException;
import org.bouncycastle.crypto.StreamCipher;
import org.bouncycastle.crypto.constraints.DefaultServiceProperties;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.ParametersWithIV;

public class HC128Engine implements StreamCipher {
  private int[] p = new int[512];
  
  private int[] q = new int[512];
  
  private int cnt = 0;
  
  private byte[] key;
  
  private byte[] iv;
  
  private boolean initialised;
  
  private static int f1(int x) { return rotateRight(x, 7) ^ rotateRight(x, 18) ^ x >>> 3; }
  
  private static int f2(int x) { return rotateRight(x, 17) ^ rotateRight(x, 19) ^ x >>> 10; }
  
  private int g1(int x, int y, int z) {
    return (rotateRight(x, 10) ^ rotateRight(z, 23)) + 
      rotateRight(y, 8);
  }
  
  private int g2(int x, int y, int z) { return (rotateLeft(x, 10) ^ rotateLeft(z, 23)) + rotateLeft(y, 8); }
  
  private static int rotateLeft(int x, int bits) { return x << bits | x >>> -bits; }
  
  private static int rotateRight(int x, int bits) { return x >>> bits | x << -bits; }
  
  private int h1(int x) { return this.q[x & 0xFF] + this.q[(x >> 16 & 0xFF) + 256]; }
  
  private int h2(int x) { return this.p[x & 0xFF] + this.p[(x >> 16 & 0xFF) + 256]; }
  
  private static int mod1024(int x) { return x & 0x3FF; }
  
  private static int mod512(int x) { return x & 0x1FF; }
  
  private static int dim(int x, int y) { return mod512(x - y); }
  
  private int step() {
    int ret, j = mod512(this.cnt);
    if (this.cnt < 512) {
      this.p[j] = this.p[j] + g1(this.p[dim(j, 3)], this.p[dim(j, 10)], this.p[dim(j, 511)]);
      ret = h1(this.p[dim(j, 12)]) ^ this.p[j];
    } else {
      this.q[j] = this.q[j] + g2(this.q[dim(j, 3)], this.q[dim(j, 10)], this.q[dim(j, 511)]);
      ret = h2(this.q[dim(j, 12)]) ^ this.q[j];
    } 
    this.cnt = mod1024(this.cnt + 1);
    return ret;
  }
  
  private void init() {
    if (this.key.length != 16)
      throw new IllegalArgumentException("The key must be 128 bits long"); 
    if (this.iv.length != 16)
      throw new IllegalArgumentException("The IV must be 128 bits long"); 
    this.idx = 0;
    this.cnt = 0;
    int[] w = new int[1280];
    for (int i = 0; i < 16; i++)
      w[i >> 2] = w[i >> 2] | (this.key[i] & 0xFF) << 8 * (i & 0x3); 
    System.arraycopy(w, 0, w, 4, 4);
    for (int i = 0; i < this.iv.length && i < 16; i++)
      w[(i >> 2) + 8] = w[(i >> 2) + 8] | (this.iv[i] & 0xFF) << 8 * (i & 0x3); 
    System.arraycopy(w, 8, w, 12, 4);
    for (int i = 16; i < 1280; i++)
      w[i] = f2(w[i - 2]) + w[i - 7] + f1(w[i - 15]) + w[i - 16] + i; 
    System.arraycopy(w, 256, this.p, 0, 512);
    System.arraycopy(w, 768, this.q, 0, 512);
    for (int i = 0; i < 512; i++)
      this.p[i] = step(); 
    for (int i = 0; i < 512; i++)
      this.q[i] = step(); 
    this.cnt = 0;
  }
  
  public String getAlgorithmName() { return "HC-128"; }
  
  public void init(boolean forEncryption, CipherParameters params) throws IllegalArgumentException {
    CipherParameters keyParam;
    if (params instanceof ParametersWithIV) {
      this.iv = ((ParametersWithIV)params).getIV();
      keyParam = ((ParametersWithIV)params).getParameters();
    } else {
      throw new IllegalArgumentException("no IV passed");
    } 
    if (keyParam instanceof KeyParameter) {
      this.key = ((KeyParameter)keyParam).getKey();
      init();
      CryptoServicesRegistrar.checkConstraints(new DefaultServiceProperties(
            getAlgorithmName(), 128, params, Utils.getPurpose(forEncryption)));
    } else {
      throw new IllegalArgumentException("Invalid parameter passed to HC128 init - " + params
          
          .getClass().getName());
    } 
    this.initialised = true;
  }
  
  private byte[] buf = new byte[4];
  
  private int idx = 0;
  
  private byte getByte() {
    if (this.idx == 0) {
      int step = step();
      this.buf[0] = (byte)(step & 0xFF);
      step >>= 8;
      this.buf[1] = (byte)(step & 0xFF);
      step >>= 8;
      this.buf[2] = (byte)(step & 0xFF);
      step >>= 8;
      this.buf[3] = (byte)(step & 0xFF);
    } 
    byte ret = this.buf[this.idx];
    this.idx = this.idx + 1 & 0x3;
    return ret;
  }
  
  public int processBytes(byte[] in, int inOff, int len, byte[] out, int outOff) throws DataLengthException {
    if (!this.initialised)
      throw new IllegalStateException(getAlgorithmName() + " not initialised"); 
    if (inOff + len > in.length)
      throw new DataLengthException("input buffer too short"); 
    if (outOff + len > out.length)
      throw new OutputLengthException("output buffer too short"); 
    for (int i = 0; i < len; i++)
      out[outOff + i] = (byte)(in[inOff + i] ^ getByte()); 
    return len;
  }
  
  public void reset() { init(); }
  
  public byte returnByte(byte in) { return (byte)(in ^ getByte()); }
}
