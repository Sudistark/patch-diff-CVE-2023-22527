package org.bouncycastle.crypto.engines;

import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.CryptoServicePurpose;
import org.bouncycastle.crypto.CryptoServicesRegistrar;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.DefaultMultiBlockCipher;
import org.bouncycastle.crypto.NativeBlockCipherProvider;
import org.bouncycastle.crypto.SkippingStreamCipher;
import org.bouncycastle.crypto.constraints.DefaultServiceProperties;
import org.bouncycastle.crypto.modes.CBCBlockCipher;
import org.bouncycastle.crypto.modes.CBCModeCipher;
import org.bouncycastle.crypto.modes.CFBBlockCipher;
import org.bouncycastle.crypto.modes.CFBModeCipher;
import org.bouncycastle.crypto.modes.GCMBlockCipher;
import org.bouncycastle.crypto.modes.GCMModeCipher;
import org.bouncycastle.crypto.modes.SICBlockCipher;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.util.dispose.NativeReference;

class AESNativeEngine extends DefaultMultiBlockCipher implements NativeBlockCipherProvider {
  protected NativeReference wrapper;
  
  private int keyLen;
  
  AESNativeEngine() {
    this.wrapper = null;
    this.keyLen = 0;
    CryptoServicesRegistrar.checkConstraints(new DefaultServiceProperties(getAlgorithmName(), 256));
  }
  
  public void init(boolean forEncryption, CipherParameters params) throws IllegalArgumentException {
    if (params instanceof KeyParameter) {
      byte[] key = ((KeyParameter)params).getKey();
      switch (key.length) {
        case 16:
        case 24:
        case 32:
          this.wrapper = new ECBNativeRef(makeInstance(key.length, forEncryption));
          break;
        default:
          throw new IllegalArgumentException("key must be 16, 24 or 32 bytes");
      } 
      CryptoServicesRegistrar.checkConstraints(new DefaultServiceProperties(
            
            getAlgorithmName(), key.length * 8, params, forEncryption ? CryptoServicePurpose.ENCRYPTION : CryptoServicePurpose.DECRYPTION));
      init(this.wrapper.getReference(), key);
      this.keyLen = key.length * 8;
      return;
    } 
    throw new IllegalArgumentException("invalid parameter passed to AES init - " + params.getClass().getName());
  }
  
  public String getAlgorithmName() { return "AES"; }
  
  public int getBlockSize() { return getBlockSize(0L); }
  
  public int processBlock(byte[] in, int inOff, byte[] out, int outOff) throws DataLengthException, IllegalStateException {
    if (this.wrapper == null)
      throw new IllegalStateException("not initialized"); 
    return process(this.wrapper.getReference(), in, inOff, 1, out, outOff);
  }
  
  public int getMultiBlockSize() { return getMultiBlockSize(0L); }
  
  public int processBlocks(byte[] in, int inOff, int blockCount, byte[] out, int outOff) throws DataLengthException, IllegalStateException {
    if (this.wrapper == null)
      throw new IllegalStateException("not initialized"); 
    return process(this.wrapper.getReference(), in, inOff, blockCount, out, outOff);
  }
  
  public void reset() {
    if (this.wrapper == null)
      return; 
    reset(this.wrapper.getReference());
  }
  
  private static native void reset(long paramLong);
  
  private static native int process(long paramLong, byte[] paramArrayOfByte1, int paramInt1, int paramInt2, byte[] paramArrayOfByte2, int paramInt3);
  
  private static native int getMultiBlockSize(long paramLong);
  
  private static native int getBlockSize(long paramLong);
  
  static native long makeInstance(int paramInt, boolean paramBoolean);
  
  static native void dispose(long paramLong);
  
  static native void init(long paramLong, byte[] paramArrayOfByte);
  
  public GCMModeCipher createGCM() {
    if (CryptoServicesRegistrar.hasEnabledService("AES/GCM"))
      return new AESNativeGCM(); 
    return new GCMBlockCipher(new AESEngine());
  }
  
  public CBCModeCipher createCBC() {
    if (CryptoServicesRegistrar.hasEnabledService("AES/CBC"))
      return new AESNativeCBC(); 
    return new CBCBlockCipher(new AESNativeEngine());
  }
  
  public CFBModeCipher createCFB(int bitSize) {
    if (bitSize % 8 != 0 || bitSize == 0 || bitSize > 128)
      throw new IllegalArgumentException("invalid CFB bitsize: " + bitSize); 
    if (CryptoServicesRegistrar.hasEnabledService("AES/CFB"))
      return new AESNativeCFB(bitSize); 
    return new CFBBlockCipher(new AESNativeEngine(), bitSize);
  }
  
  public SkippingStreamCipher createCTR() {
    if (CryptoServicesRegistrar.hasEnabledService("AES/CTR"))
      return new AESNativeCTR(); 
    return new SICBlockCipher(AESEngine.newInstance());
  }
  
  public String toString() { return "AES[Native](" + this.keyLen + ")"; }
}
