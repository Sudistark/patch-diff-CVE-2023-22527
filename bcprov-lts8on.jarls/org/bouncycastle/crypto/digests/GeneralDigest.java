package org.bouncycastle.crypto.digests;

import org.bouncycastle.crypto.CryptoServiceProperties;
import org.bouncycastle.crypto.CryptoServicePurpose;
import org.bouncycastle.crypto.ExtendedDigest;
import org.bouncycastle.util.Memoable;
import org.bouncycastle.util.Pack;

public abstract class GeneralDigest implements ExtendedDigest, Memoable {
  private static final int BYTE_LENGTH = 64;
  
  protected final CryptoServicePurpose purpose;
  
  private final byte[] xBuf;
  
  private int xBufOff;
  
  private long byteCount;
  
  protected GeneralDigest() { this(CryptoServicePurpose.ANY); }
  
  protected GeneralDigest(CryptoServicePurpose purpose) {
    this.xBuf = new byte[4];
    this.purpose = purpose;
    this.xBufOff = 0;
  }
  
  protected GeneralDigest(GeneralDigest t) {
    this.xBuf = new byte[4];
    this.purpose = t.purpose;
    copyIn(t);
  }
  
  protected GeneralDigest(byte[] encodedState) {
    this.xBuf = new byte[4];
    CryptoServicePurpose[] values = CryptoServicePurpose.values();
    this.purpose = values[encodedState[encodedState.length - 1]];
    System.arraycopy(encodedState, 0, this.xBuf, 0, this.xBuf.length);
    this.xBufOff = Pack.bigEndianToInt(encodedState, 4);
    this.byteCount = Pack.bigEndianToLong(encodedState, 8);
  }
  
  protected void copyIn(GeneralDigest t) {
    System.arraycopy(t.xBuf, 0, this.xBuf, 0, t.xBuf.length);
    this.xBufOff = t.xBufOff;
    this.byteCount = t.byteCount;
  }
  
  public void update(byte in) {
    this.xBuf[this.xBufOff++] = in;
    if (this.xBufOff == this.xBuf.length) {
      processWord(this.xBuf, 0);
      this.xBufOff = 0;
    } 
    this.byteCount++;
  }
  
  public void update(byte[] in, int inOff, int len) {
    len = Math.max(0, len);
    int i = 0;
    if (this.xBufOff != 0)
      while (i < len) {
        this.xBuf[this.xBufOff++] = in[inOff + i++];
        if (this.xBufOff == 4) {
          processWord(this.xBuf, 0);
          this.xBufOff = 0;
          break;
        } 
      }  
    int limit = len - 3;
    for (; i < limit; i += 4)
      processWord(in, inOff + i); 
    while (i < len)
      this.xBuf[this.xBufOff++] = in[inOff + i++]; 
    this.byteCount += len;
  }
  
  public void finish() {
    long bitLength = this.byteCount << 3;
    update(-128);
    while (this.xBufOff != 0)
      update((byte)0); 
    processLength(bitLength);
    processBlock();
  }
  
  public void reset() {
    this.byteCount = 0L;
    this.xBufOff = 0;
    for (int i = 0; i < this.xBuf.length; i++)
      this.xBuf[i] = 0; 
  }
  
  protected void populateState(byte[] state) {
    System.arraycopy(this.xBuf, 0, state, 0, this.xBufOff);
    Pack.intToBigEndian(this.xBufOff, state, 4);
    Pack.longToBigEndian(this.byteCount, state, 8);
  }
  
  public int getByteLength() { return 64; }
  
  protected abstract void processWord(byte[] paramArrayOfByte, int paramInt);
  
  protected abstract void processLength(long paramLong);
  
  protected abstract void processBlock();
  
  protected abstract CryptoServiceProperties cryptoServiceProperties();
}
