package org.bouncycastle.crypto.generators;

import org.bouncycastle.crypto.digests.SHA256Digest;
import org.bouncycastle.crypto.engines.Salsa20Engine;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Integers;
import org.bouncycastle.util.Pack;

public class SCrypt {
  public static byte[] generate(byte[] P, byte[] S, int N, int r, int p, int dkLen) {
    if (P == null)
      throw new IllegalArgumentException("Passphrase P must be provided."); 
    if (S == null)
      throw new IllegalArgumentException("Salt S must be provided."); 
    if (N <= 1 || !isPowerOf2(N))
      throw new IllegalArgumentException("Cost parameter N must be > 1 and a power of 2"); 
    if (r == 1 && N >= 65536)
      throw new IllegalArgumentException("Cost parameter N must be > 1 and < 65536."); 
    if (r < 1)
      throw new IllegalArgumentException("Block size r must be >= 1."); 
    int maxParallel = Integer.MAX_VALUE / 128 * r * 8;
    if (p < 1 || p > maxParallel)
      throw new IllegalArgumentException("Parallelisation parameter p must be >= 1 and <= " + maxParallel + " (based on block size r of " + r + ")"); 
    if (dkLen < 1)
      throw new IllegalArgumentException("Generated key length dkLen must be >= 1."); 
    return MFcrypt(P, S, N, r, p, dkLen);
  }
  
  private static byte[] MFcrypt(byte[] P, byte[] S, int N, int r, int p, int dkLen) {
    int MFLenBytes = r * 128;
    bytes = SingleIterationPBKDF2(P, S, p * MFLenBytes);
    B = null;
    try {
      int BLen = bytes.length >>> 2;
      B = new int[BLen];
      Pack.littleEndianToInt(bytes, 0, B);
      int d = 0, total = N * r;
      while (N - d > 2 && total > 1024) {
        d++;
        total >>>= 1;
      } 
      int MFLenWords = MFLenBytes >>> 2;
      int BOff;
      for (BOff = 0; BOff < BLen; BOff += MFLenWords)
        SMix(B, BOff, N, d, r); 
      Pack.intToLittleEndian(B, bytes, 0);
      return SingleIterationPBKDF2(P, bytes, dkLen);
    } finally {
      Clear(bytes);
      Clear(B);
    } 
  }
  
  private static byte[] SingleIterationPBKDF2(byte[] P, byte[] S, int dkLen) {
    PKCS5S2ParametersGenerator pKCS5S2ParametersGenerator = new PKCS5S2ParametersGenerator(SHA256Digest.newInstance());
    pKCS5S2ParametersGenerator.init(P, S, 1);
    KeyParameter key = (KeyParameter)pKCS5S2ParametersGenerator.generateDerivedMacParameters(dkLen * 8);
    return key.getKey();
  }
  
  private static void SMix(int[] B, int BOff, int N, int d, int r) {
    int powN = Integers.numberOfTrailingZeros(N);
    int blocksPerChunk = N >>> d;
    int chunkCount = 1 << d, chunkMask = blocksPerChunk - 1, chunkPow = powN - d;
    int BCount = r * 32;
    blockX1 = new int[16];
    blockX2 = new int[16];
    blockY = new int[BCount];
    X = new int[BCount];
    VV = new int[chunkCount][];
    try {
      System.arraycopy(B, BOff, X, 0, BCount);
      for (int c = 0; c < chunkCount; c++) {
        int[] V = new int[blocksPerChunk * BCount];
        VV[c] = V;
        int off = 0;
        for (int i = 0; i < blocksPerChunk; i += 2) {
          System.arraycopy(X, 0, V, off, BCount);
          off += BCount;
          BlockMix(X, blockX1, blockX2, blockY, r);
          System.arraycopy(blockY, 0, V, off, BCount);
          off += BCount;
          BlockMix(blockY, blockX1, blockX2, X, r);
        } 
      } 
      int mask = N - 1;
      for (int i = 0; i < N; i++) {
        int j = X[BCount - 16] & mask;
        int[] V = VV[j >>> chunkPow];
        int VOff = (j & chunkMask) * BCount;
        System.arraycopy(V, VOff, blockY, 0, BCount);
        Xor(blockY, X, 0, blockY);
        BlockMix(blockY, blockX1, blockX2, X, r);
      } 
      System.arraycopy(X, 0, B, BOff, BCount);
    } finally {
      ClearAll(VV);
      ClearAll(new int[][] { X, blockX1, blockX2, blockY });
    } 
  }
  
  private static void BlockMix(int[] B, int[] X1, int[] X2, int[] Y, int r) {
    System.arraycopy(B, B.length - 16, X1, 0, 16);
    int BOff = 0, YOff = 0, halfLen = B.length >>> 1;
    for (int i = 2 * r; i > 0; i--) {
      Xor(X1, B, BOff, X2);
      Salsa20Engine.salsaCore(8, X2, X1);
      System.arraycopy(X1, 0, Y, YOff, 16);
      YOff = halfLen + BOff - YOff;
      BOff += 16;
    } 
  }
  
  private static void Xor(int[] a, int[] b, int bOff, int[] output) {
    for (int i = output.length - 1; i >= 0; i--)
      output[i] = a[i] ^ b[bOff + i]; 
  }
  
  private static void Clear(byte[] array) {
    if (array != null)
      Arrays.fill(array, (byte)0); 
  }
  
  private static void Clear(int[] array) {
    if (array != null)
      Arrays.fill(array, 0); 
  }
  
  private static void ClearAll(int[][] arrays) {
    for (int i = 0; i < arrays.length; i++)
      Clear(arrays[i]); 
  }
  
  private static boolean isPowerOf2(int x) { return ((x & x - 1) == 0); }
}
