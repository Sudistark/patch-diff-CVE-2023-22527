package org.bouncycastle.crypto.generators;

import org.bouncycastle.crypto.Digest;
import org.bouncycastle.crypto.digests.Blake2bDigest;
import org.bouncycastle.crypto.params.Argon2Parameters;
import org.bouncycastle.util.Longs;
import org.bouncycastle.util.Pack;

public class Argon2BytesGenerator {
  private static final int ARGON2_BLOCK_SIZE = 1024;
  
  private static final int ARGON2_QWORDS_IN_BLOCK = 128;
  
  private static final int ARGON2_ADDRESSES_IN_BLOCK = 128;
  
  private static final int ARGON2_PREHASH_DIGEST_LENGTH = 64;
  
  private static final int ARGON2_PREHASH_SEED_LENGTH = 72;
  
  private static final int ARGON2_SYNC_POINTS = 4;
  
  private static final int MIN_PARALLELISM = 1;
  
  private static final int MAX_PARALLELISM = 16777216;
  
  private static final int MIN_OUTLEN = 4;
  
  private static final int MIN_ITERATIONS = 1;
  
  private static final long M32L = 4294967295L;
  
  private static final byte[] ZERO_BYTES = new byte[4];
  
  private Argon2Parameters parameters;
  
  private Block[] memory;
  
  private int segmentLength;
  
  private int laneLength;
  
  public void init(Argon2Parameters parameters) {
    this.parameters = parameters;
    if (parameters.getLanes() < 1)
      throw new IllegalStateException("lanes must be greater than 1"); 
    if (parameters.getLanes() > 16777216)
      throw new IllegalStateException("lanes must be less than 16777216"); 
    if (parameters.getMemory() < 2 * parameters.getLanes())
      throw new IllegalStateException("memory is less than: " + (2 * parameters.getLanes()) + " expected " + (2 * parameters.getLanes())); 
    if (parameters.getIterations() < 1)
      throw new IllegalStateException("iterations is less than: 1"); 
    doInit(parameters);
  }
  
  public int generateBytes(char[] password, byte[] out) { return generateBytes(this.parameters.getCharToByteConverter().convert(password), out); }
  
  public int generateBytes(char[] password, byte[] out, int outOff, int outLen) { return generateBytes(this.parameters.getCharToByteConverter().convert(password), out, outOff, outLen); }
  
  public int generateBytes(byte[] password, byte[] out) { return generateBytes(password, out, 0, out.length); }
  
  public int generateBytes(byte[] password, byte[] out, int outOff, int outLen) {
    if (outLen < 4)
      throw new IllegalStateException("output length less than 4"); 
    byte[] tmpBlockBytes = new byte[1024];
    initialize(tmpBlockBytes, password, outLen);
    fillMemoryBlocks();
    digest(tmpBlockBytes, out, outOff, outLen);
    reset();
    return outLen;
  }
  
  private void reset() {
    if (null != this.memory)
      for (int i = 0; i < this.memory.length; i++) {
        Block b = this.memory[i];
        if (null != b)
          b.clear(); 
      }  
  }
  
  private void doInit(Argon2Parameters parameters) {
    int memoryBlocks = parameters.getMemory();
    if (memoryBlocks < 8 * parameters.getLanes())
      memoryBlocks = 8 * parameters.getLanes(); 
    this.segmentLength = memoryBlocks / parameters.getLanes() * 4;
    this.laneLength = this.segmentLength * 4;
    memoryBlocks = this.segmentLength * parameters.getLanes() * 4;
    initMemory(memoryBlocks);
  }
  
  private void initMemory(int memoryBlocks) {
    this.memory = new Block[memoryBlocks];
    for (int i = 0; i < this.memory.length; i++)
      this.memory[i] = new Block(null); 
  }
  
  private void fillMemoryBlocks() {
    FillBlock filler = new FillBlock(null);
    Position position = new Position();
    for (int pass = 0; pass < this.parameters.getIterations(); pass++) {
      position.pass = pass;
      for (int slice = 0; slice < 4; slice++) {
        position.slice = slice;
        for (int lane = 0; lane < this.parameters.getLanes(); lane++) {
          position.lane = lane;
          fillSegment(filler, position);
        } 
      } 
    } 
  }
  
  private void fillSegment(FillBlock filler, Position position) {
    Block addressBlock = null, inputBlock = null;
    boolean dataIndependentAddressing = isDataIndependentAddressing(position);
    int startingIndex = getStartingIndex(position);
    int currentOffset = position.lane * this.laneLength + position.slice * this.segmentLength + startingIndex;
    int prevOffset = getPrevOffset(currentOffset);
    if (dataIndependentAddressing) {
      addressBlock = filler.addressBlock.clear();
      inputBlock = filler.inputBlock.clear();
      initAddressBlocks(filler, position, inputBlock, addressBlock);
    } 
    boolean withXor = isWithXor(position);
    for (int index = startingIndex; index < this.segmentLength; index++) {
      long pseudoRandom = getPseudoRandom(filler, index, addressBlock, inputBlock, prevOffset, dataIndependentAddressing);
      int refLane = getRefLane(position, pseudoRandom);
      int refColumn = getRefColumn(position, index, pseudoRandom, (refLane == position.lane));
      Block prevBlock = this.memory[prevOffset];
      Block refBlock = this.memory[this.laneLength * refLane + refColumn];
      Block currentBlock = this.memory[currentOffset];
      if (withXor) {
        FillBlock.access$200(filler, prevBlock, refBlock, currentBlock);
      } else {
        FillBlock.access$300(filler, prevBlock, refBlock, currentBlock);
      } 
      prevOffset = currentOffset;
      currentOffset++;
    } 
  }
  
  private boolean isDataIndependentAddressing(Position position) {
    return (this.parameters.getType() == 1 || (this.parameters
      .getType() == 2 && position.pass == 0 && position.slice < 2));
  }
  
  private void initAddressBlocks(FillBlock filler, Position position, Block inputBlock, Block addressBlock) {
    Block.access$400(inputBlock)[0] = intToLong(position.pass);
    Block.access$400(inputBlock)[1] = intToLong(position.lane);
    Block.access$400(inputBlock)[2] = intToLong(position.slice);
    Block.access$400(inputBlock)[3] = intToLong(this.memory.length);
    Block.access$400(inputBlock)[4] = intToLong(this.parameters.getIterations());
    Block.access$400(inputBlock)[5] = intToLong(this.parameters.getType());
    if (position.pass == 0 && position.slice == 0)
      nextAddresses(filler, inputBlock, addressBlock); 
  }
  
  private boolean isWithXor(Position position) { return (position.pass != 0 && this.parameters.getVersion() != 16); }
  
  private int getPrevOffset(int currentOffset) {
    if (currentOffset % this.laneLength == 0)
      return currentOffset + this.laneLength - 1; 
    return currentOffset - 1;
  }
  
  private static int getStartingIndex(Position position) {
    if (position.pass == 0 && position.slice == 0)
      return 2; 
    return 0;
  }
  
  private void nextAddresses(FillBlock filler, Block inputBlock, Block addressBlock) {
    Block.access$400(inputBlock)[6] = Block.access$400(inputBlock)[6] + 1L;
    FillBlock.access$500(filler, inputBlock, addressBlock);
    FillBlock.access$500(filler, addressBlock, addressBlock);
  }
  
  private long getPseudoRandom(FillBlock filler, int index, Block addressBlock, Block inputBlock, int prevOffset, boolean dataIndependentAddressing) {
    if (dataIndependentAddressing) {
      int addressIndex = index % 128;
      if (addressIndex == 0)
        nextAddresses(filler, inputBlock, addressBlock); 
      return Block.access$400(addressBlock)[addressIndex];
    } 
    return Block.access$400(this.memory[prevOffset])[0];
  }
  
  private int getRefLane(Position position, long pseudoRandom) {
    int refLane = (int)((pseudoRandom >>> 32) % this.parameters.getLanes());
    if (position.pass == 0 && position.slice == 0)
      refLane = position.lane; 
    return refLane;
  }
  
  private int getRefColumn(Position position, int index, long pseudoRandom, boolean sameLane) {
    int startPosition, referenceAreaSize;
    if (position.pass == 0) {
      startPosition = 0;
      if (sameLane) {
        referenceAreaSize = position.slice * this.segmentLength + index - 1;
      } else {
        referenceAreaSize = position.slice * this.segmentLength + ((index == 0) ? -1 : 0);
      } 
    } else {
      startPosition = (position.slice + 1) * this.segmentLength % this.laneLength;
      if (sameLane) {
        referenceAreaSize = this.laneLength - this.segmentLength + index - 1;
      } else {
        referenceAreaSize = this.laneLength - this.segmentLength + ((index == 0) ? -1 : 0);
      } 
    } 
    long relativePosition = pseudoRandom & 0xFFFFFFFFL;
    relativePosition = relativePosition * relativePosition >>> 32;
    relativePosition = (referenceAreaSize - 1) - (referenceAreaSize * relativePosition >>> 32);
    return (int)(startPosition + relativePosition) % this.laneLength;
  }
  
  private void digest(byte[] tmpBlockBytes, byte[] out, int outOff, int outLen) {
    Block finalBlock = this.memory[this.laneLength - 1];
    for (int i = 1; i < this.parameters.getLanes(); i++) {
      int lastBlockInLane = i * this.laneLength + this.laneLength - 1;
      Block.access$600(finalBlock, this.memory[lastBlockInLane]);
    } 
    finalBlock.toBytes(tmpBlockBytes);
    hash(tmpBlockBytes, out, outOff, outLen);
  }
  
  private void hash(byte[] input, byte[] out, int outOff, int outLen) {
    byte[] outLenBytes = new byte[4];
    Pack.intToLittleEndian(outLen, outLenBytes, 0);
    int blake2bLength = 64;
    if (outLen <= blake2bLength) {
      Blake2bDigest blake = new Blake2bDigest(outLen * 8);
      blake.update(outLenBytes, 0, outLenBytes.length);
      blake.update(input, 0, input.length);
      blake.doFinal(out, outOff);
    } else {
      Blake2bDigest digest = new Blake2bDigest(blake2bLength * 8);
      byte[] outBuffer = new byte[blake2bLength];
      digest.update(outLenBytes, 0, outLenBytes.length);
      digest.update(input, 0, input.length);
      digest.doFinal(outBuffer, 0);
      int halfLen = blake2bLength / 2, outPos = outOff;
      System.arraycopy(outBuffer, 0, out, outPos, halfLen);
      outPos += halfLen;
      int r = (outLen + 31) / 32 - 2;
      for (int i = 2; i <= r; i++, outPos += halfLen) {
        digest.update(outBuffer, 0, outBuffer.length);
        digest.doFinal(outBuffer, 0);
        System.arraycopy(outBuffer, 0, out, outPos, halfLen);
      } 
      int lastLength = outLen - 32 * r;
      digest = new Blake2bDigest(lastLength * 8);
      digest.update(outBuffer, 0, outBuffer.length);
      digest.doFinal(out, outPos);
    } 
  }
  
  private static void roundFunction(Block block, int v0, int v1, int v2, int v3, int v4, int v5, int v6, int v7, int v8, int v9, int v10, int v11, int v12, int v13, int v14, int v15) {
    long[] v = Block.access$400(block);
    F(v, v0, v4, v8, v12);
    F(v, v1, v5, v9, v13);
    F(v, v2, v6, v10, v14);
    F(v, v3, v7, v11, v15);
    F(v, v0, v5, v10, v15);
    F(v, v1, v6, v11, v12);
    F(v, v2, v7, v8, v13);
    F(v, v3, v4, v9, v14);
  }
  
  private static void F(long[] v, int a, int b, int c, int d) {
    quarterRound(v, a, b, d, 32);
    quarterRound(v, c, d, b, 24);
    quarterRound(v, a, b, d, 16);
    quarterRound(v, c, d, b, 63);
  }
  
  private static void quarterRound(long[] v, int x, int y, int z, int s) {
    long a = v[x], b = v[y], c = v[z];
    a += b + 2L * (a & 0xFFFFFFFFL) * (b & 0xFFFFFFFFL);
    c = Longs.rotateRight(c ^ a, s);
    v[x] = a;
    v[z] = c;
  }
  
  private void initialize(byte[] tmpBlockBytes, byte[] password, int outputLength) {
    Blake2bDigest blake = new Blake2bDigest(512);
    int[] values = { this.parameters.getLanes(), outputLength, this.parameters.getMemory(), this.parameters.getIterations(), this.parameters.getVersion(), this.parameters.getType() };
    Pack.intToLittleEndian(values, tmpBlockBytes, 0);
    blake.update(tmpBlockBytes, 0, values.length * 4);
    addByteString(tmpBlockBytes, blake, password);
    addByteString(tmpBlockBytes, blake, this.parameters.getSalt());
    addByteString(tmpBlockBytes, blake, this.parameters.getSecret());
    addByteString(tmpBlockBytes, blake, this.parameters.getAdditional());
    byte[] initialHashWithZeros = new byte[72];
    blake.doFinal(initialHashWithZeros, 0);
    fillFirstBlocks(tmpBlockBytes, initialHashWithZeros);
  }
  
  private static void addByteString(byte[] tmpBlockBytes, Digest digest, byte[] octets) {
    if (null == octets) {
      digest.update(ZERO_BYTES, 0, 4);
      return;
    } 
    Pack.intToLittleEndian(octets.length, tmpBlockBytes, 0);
    digest.update(tmpBlockBytes, 0, 4);
    digest.update(octets, 0, octets.length);
  }
  
  private void fillFirstBlocks(byte[] tmpBlockBytes, byte[] initialHashWithZeros) {
    byte[] initialHashWithOnes = new byte[72];
    System.arraycopy(initialHashWithZeros, 0, initialHashWithOnes, 0, 64);
    initialHashWithOnes[64] = 1;
    for (int i = 0; i < this.parameters.getLanes(); i++) {
      Pack.intToLittleEndian(i, initialHashWithZeros, 68);
      Pack.intToLittleEndian(i, initialHashWithOnes, 68);
      hash(initialHashWithZeros, tmpBlockBytes, 0, 1024);
      this.memory[i * this.laneLength + 0].fromBytes(tmpBlockBytes);
      hash(initialHashWithOnes, tmpBlockBytes, 0, 1024);
      this.memory[i * this.laneLength + 1].fromBytes(tmpBlockBytes);
    } 
  }
  
  private long intToLong(int x) { return x & 0xFFFFFFFFL; }
}
