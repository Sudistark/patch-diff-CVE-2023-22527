package org.bouncycastle.math.raw;

import java.util.Random;
import org.bouncycastle.util.Integers;

public abstract class Mod {
  private static final int M30 = 1073741823;
  
  private static final long M32L = 4294967295L;
  
  public static void checkedModOddInverse(int[] m, int[] x, int[] z) {
    if (0 == modOddInverse(m, x, z))
      throw new ArithmeticException("Inverse does not exist."); 
  }
  
  public static void checkedModOddInverseVar(int[] m, int[] x, int[] z) {
    if (!modOddInverseVar(m, x, z))
      throw new ArithmeticException("Inverse does not exist."); 
  }
  
  public static int inverse32(int d) {
    x = d;
    x *= (2 - d * x);
    x *= (2 - d * x);
    x *= (2 - d * x);
    return 2 - d * x;
  }
  
  public static int modOddInverse(int[] m, int[] x, int[] z) {
    int len32 = m.length;
    int bits = (len32 << 5) - Integers.numberOfLeadingZeros(m[len32 - 1]);
    int len30 = (bits + 29) / 30;
    int[] t = new int[4];
    int[] D = new int[len30];
    int[] E = new int[len30];
    int[] F = new int[len30];
    int[] G = new int[len30];
    int[] M = new int[len30];
    E[0] = 1;
    encode30(bits, x, 0, G, 0);
    encode30(bits, m, 0, M, 0);
    System.arraycopy(M, 0, F, 0, len30);
    int delta = 0;
    int m0Inv32 = inverse32(M[0]);
    int maxDivsteps = getMaximumDivsteps(bits);
    for (int divSteps = 0; divSteps < maxDivsteps; divSteps += 30) {
      delta = divsteps30(delta, F[0], G[0], t);
      updateDE30(len30, D, E, t, m0Inv32, M);
      updateFG30(len30, F, G, t);
    } 
    int signF = F[len30 - 1] >> 31;
    cnegate30(len30, signF, F);
    cnormalize30(len30, signF, D, M);
    decode30(bits, D, 0, z, 0);
    return Nat.equalTo(len30, F, 1) & Nat.equalToZero(len30, G);
  }
  
  public static boolean modOddInverseVar(int[] m, int[] x, int[] z) {
    int len32 = m.length;
    int bits = (len32 << 5) - Integers.numberOfLeadingZeros(m[len32 - 1]);
    int len30 = (bits + 29) / 30;
    int[] t = new int[4];
    int[] D = new int[len30];
    int[] E = new int[len30];
    int[] F = new int[len30];
    int[] G = new int[len30];
    int[] M = new int[len30];
    E[0] = 1;
    encode30(bits, x, 0, G, 0);
    encode30(bits, m, 0, M, 0);
    System.arraycopy(M, 0, F, 0, len30);
    int clzG = Integers.numberOfLeadingZeros(G[len30 - 1] | true) - len30 * 30 + 2 - bits;
    int eta = -1 - clzG;
    int lenDE = len30, lenFG = len30;
    int m0Inv32 = inverse32(M[0]);
    int maxDivsteps = getMaximumDivsteps(bits);
    int divsteps = 0;
    while (!Nat.isZero(lenFG, G)) {
      if (divsteps >= maxDivsteps)
        return false; 
      divsteps += 30;
      eta = divsteps30Var(eta, F[0], G[0], t);
      updateDE30(lenDE, D, E, t, m0Inv32, M);
      updateFG30(lenFG, F, G, t);
      int fn = F[lenFG - 1];
      int gn = G[lenFG - 1];
      int cond = lenFG - 2 >> 31;
      cond |= fn ^ fn >> 31;
      cond |= gn ^ gn >> 31;
      if (cond == 0) {
        F[lenFG - 2] = F[lenFG - 2] | fn << 30;
        G[lenFG - 2] = G[lenFG - 2] | gn << 30;
        lenFG--;
      } 
    } 
    int signF = F[lenFG - 1] >> 31;
    int signD = D[lenDE - 1] >> 31;
    if (signD < 0)
      signD = add30(lenDE, D, M); 
    if (signF < 0) {
      signD = negate30(lenDE, D);
      signF = negate30(lenFG, F);
    } 
    if (!Nat.isOne(lenFG, F))
      return false; 
    if (signD < 0)
      signD = add30(lenDE, D, M); 
    decode30(bits, D, 0, z, 0);
    return true;
  }
  
  public static int[] random(int[] p) {
    int len = p.length;
    Random rand = new Random();
    int[] s = Nat.create(len);
    int m = p[len - 1];
    m |= m >>> 1;
    m |= m >>> 2;
    m |= m >>> 4;
    m |= m >>> 8;
    m |= m >>> 16;
    do {
      for (int i = 0; i != len; i++)
        s[i] = rand.nextInt(); 
      s[len - 1] = s[len - 1] & m;
    } while (Nat.gte(len, s, p));
    return s;
  }
  
  private static int add30(int len30, int[] D, int[] M) {
    c = 0;
    int last = len30 - 1;
    for (int i = 0; i < last; i++) {
      c += D[i] + M[i];
      D[i] = c & 0x3FFFFFFF;
      c >>= 30;
    } 
    c += D[last] + M[last];
    D[last] = c;
    return 30;
  }
  
  private static void cnegate30(int len30, int cond, int[] D) {
    int c = 0, last = len30 - 1;
    for (int i = 0; i < last; i++) {
      c += (D[i] ^ cond) - cond;
      D[i] = c & 0x3FFFFFFF;
      c >>= 30;
    } 
    c += (D[last] ^ cond) - cond;
    D[last] = c;
  }
  
  private static void cnormalize30(int len30, int condNegate, int[] D, int[] M) {
    int last = len30 - 1;
    int c = 0, condAdd = D[last] >> 31;
    for (int i = 0; i < last; i++) {
      int di = D[i] + (M[i] & condAdd);
      di = (di ^ condNegate) - condNegate;
      c += di;
      D[i] = c & 0x3FFFFFFF;
      c >>= 30;
    } 
    int di = D[last] + (M[last] & condAdd);
    di = (di ^ condNegate) - condNegate;
    c += di;
    D[last] = c;
    int c = 0, condAdd = D[last] >> 31;
    for (int i = 0; i < last; i++) {
      int di = D[i] + (M[i] & condAdd);
      c += di;
      D[i] = c & 0x3FFFFFFF;
      c >>= 30;
    } 
    int di = D[last] + (M[last] & condAdd);
    c += di;
    D[last] = c;
  }
  
  private static void decode30(int bits, int[] x, int xOff, int[] z, int zOff) {
    int avail = 0;
    long data = 0L;
    while (bits > 0) {
      while (avail < Math.min(32, bits)) {
        data |= x[xOff++] << avail;
        avail += 30;
      } 
      z[zOff++] = (int)data;
      data >>>= 32;
      avail -= 32;
      bits -= 32;
    } 
  }
  
  private static int divsteps30(int delta, int f0, int g0, int[] t) {
    int u = 1073741824, v = 0, q = 0, r = 1073741824;
    int f = f0, g = g0;
    for (int i = 0; i < 30; i++) {
      int c1 = delta >> 31;
      int c2 = -(g & true);
      int x = f ^ c1;
      int y = u ^ c1;
      int z = v ^ c1;
      g -= (x & c2);
      q -= (y & c2);
      r -= (z & c2);
      c2 &= (c1 ^ 0xFFFFFFFF);
      delta = (delta ^ c2) - c2 - 1;
      f += (g & c2);
      u += (q & c2);
      v += (r & c2);
      g >>= 1;
      q >>= 1;
      r >>= 1;
    } 
    t[0] = u;
    t[1] = v;
    t[2] = q;
    t[3] = r;
    return delta;
  }
  
  private static int divsteps30Var(int eta, int f0, int g0, int[] t) {
    int u = 1, v = 0, q = 0, r = 1;
    int f = f0, g = g0;
    int i = 30;
    while (true) {
      int w, zeros = Integers.numberOfTrailingZeros(g | -1 << i);
      g >>= zeros;
      u <<= zeros;
      v <<= zeros;
      eta -= zeros;
      i -= zeros;
      if (i <= 0)
        break; 
      if (eta < 0) {
        eta = -eta;
        int x = f;
        f = g;
        g = -x;
        int y = u;
        u = q;
        q = -y;
        int z = v;
        v = r;
        r = -z;
        int limit = (eta + 1 > i) ? i : (eta + 1);
        int m = -1 >>> 32 - limit & 0x3F;
        w = f * g * (f * f - 2) & m;
      } else {
        int limit = (eta + 1 > i) ? i : (eta + 1);
        int m = -1 >>> 32 - limit & 0xF;
        w = f + ((f + 1 & 0x4) << 1);
        w = -w * g & m;
      } 
      g += f * w;
      q += u * w;
      r += v * w;
    } 
    t[0] = u;
    t[1] = v;
    t[2] = q;
    t[3] = r;
    return eta;
  }
  
  private static void encode30(int bits, int[] x, int xOff, int[] z, int zOff) {
    int avail = 0;
    long data = 0L;
    while (bits > 0) {
      if (avail < Math.min(30, bits)) {
        data |= (x[xOff++] & 0xFFFFFFFFL) << avail;
        avail += 32;
      } 
      z[zOff++] = (int)data & 0x3FFFFFFF;
      data >>>= 30;
      avail -= 30;
      bits -= 30;
    } 
  }
  
  private static int getMaximumDivsteps(int bits) { return (49 * bits + ((bits < 46) ? 80 : 47)) / 17; }
  
  private static int negate30(int len30, int[] D) {
    c = 0;
    int last = len30 - 1;
    for (int i = 0; i < last; i++) {
      c -= D[i];
      D[i] = c & 0x3FFFFFFF;
      c >>= 30;
    } 
    c -= D[last];
    D[last] = c;
    return 30;
  }
  
  private static void updateDE30(int len30, int[] D, int[] E, int[] t, int m0Inv32, int[] M) {
    int u = t[0], v = t[1], q = t[2], r = t[3];
    int sd = D[len30 - 1] >> 31;
    int se = E[len30 - 1] >> 31;
    int md = (u & sd) + (v & se);
    int me = (q & sd) + (r & se);
    int mi = M[0];
    int di = D[0];
    int ei = E[0];
    long cd = u * di + v * ei;
    long ce = q * di + r * ei;
    md -= (m0Inv32 * (int)cd + md & 0x3FFFFFFF);
    me -= (m0Inv32 * (int)ce + me & 0x3FFFFFFF);
    cd += mi * md;
    ce += mi * me;
    cd >>= 30;
    ce >>= 30;
    for (int i = 1; i < len30; i++) {
      mi = M[i];
      di = D[i];
      ei = E[i];
      cd += u * di + v * ei + mi * md;
      ce += q * di + r * ei + mi * me;
      D[i - 1] = (int)cd & 0x3FFFFFFF;
      cd >>= 30;
      E[i - 1] = (int)ce & 0x3FFFFFFF;
      ce >>= 30;
    } 
    D[len30 - 1] = (int)cd;
    E[len30 - 1] = (int)ce;
  }
  
  private static void updateFG30(int len30, int[] F, int[] G, int[] t) {
    int u = t[0], v = t[1], q = t[2], r = t[3];
    int fi = F[0];
    int gi = G[0];
    long cf = u * fi + v * gi;
    long cg = q * fi + r * gi;
    cf >>= 30;
    cg >>= 30;
    for (int i = 1; i < len30; i++) {
      fi = F[i];
      gi = G[i];
      cf += u * fi + v * gi;
      cg += q * fi + r * gi;
      F[i - 1] = (int)cf & 0x3FFFFFFF;
      cf >>= 30;
      G[i - 1] = (int)cg & 0x3FFFFFFF;
      cg >>= 30;
    } 
    F[len30 - 1] = (int)cf;
    G[len30 - 1] = (int)cg;
  }
}
