package org.bouncycastle.math.raw;

public abstract class Mont256 {
  private static final long M = 4294967295L;
  
  public static int inverse32(int x) {
    z = x;
    z *= (2 - x * z);
    z *= (2 - x * z);
    z *= (2 - x * z);
    return 2 - x * z;
  }
  
  public static void multAdd(int[] x, int[] y, int[] z, int[] m, int mInv32) {
    int z_8 = 0;
    long y_0 = y[0] & 0xFFFFFFFFL;
    for (int i = 0; i < 8; i++) {
      long z_0 = z[0] & 0xFFFFFFFFL;
      long x_i = x[i] & 0xFFFFFFFFL;
      long prod1 = x_i * y_0;
      long carry = (prod1 & 0xFFFFFFFFL) + z_0;
      long t = ((int)carry * mInv32) & 0xFFFFFFFFL;
      long prod2 = t * (m[0] & 0xFFFFFFFFL);
      carry += (prod2 & 0xFFFFFFFFL);
      carry = (carry >>> 32) + (prod1 >>> 32) + (prod2 >>> 32);
      for (int j = 1; j < 8; j++) {
        prod1 = x_i * (y[j] & 0xFFFFFFFFL);
        prod2 = t * (m[j] & 0xFFFFFFFFL);
        carry += (prod1 & 0xFFFFFFFFL) + (prod2 & 0xFFFFFFFFL) + (z[j] & 0xFFFFFFFFL);
        z[j - 1] = (int)carry;
        carry = (carry >>> 32) + (prod1 >>> 32) + (prod2 >>> 32);
      } 
      carry += (z_8 & 0xFFFFFFFFL);
      z[7] = (int)carry;
      z_8 = (int)(carry >>> 32);
    } 
    if (z_8 != 0 || Nat256.gte(z, m))
      Nat256.sub(z, m, z); 
  }
  
  public static void multAddXF(int[] x, int[] y, int[] z, int[] m) {
    int z_8 = 0;
    long y_0 = y[0] & 0xFFFFFFFFL;
    for (int i = 0; i < 8; i++) {
      long x_i = x[i] & 0xFFFFFFFFL;
      long carry = x_i * y_0 + (z[0] & 0xFFFFFFFFL);
      long t = carry & 0xFFFFFFFFL;
      carry = (carry >>> 32) + t;
      for (int j = 1; j < 8; j++) {
        long prod1 = x_i * (y[j] & 0xFFFFFFFFL);
        long prod2 = t * (m[j] & 0xFFFFFFFFL);
        carry += (prod1 & 0xFFFFFFFFL) + (prod2 & 0xFFFFFFFFL) + (z[j] & 0xFFFFFFFFL);
        z[j - 1] = (int)carry;
        carry = (carry >>> 32) + (prod1 >>> 32) + (prod2 >>> 32);
      } 
      carry += (z_8 & 0xFFFFFFFFL);
      z[7] = (int)carry;
      z_8 = (int)(carry >>> 32);
    } 
    if (z_8 != 0 || Nat256.gte(z, m))
      Nat256.sub(z, m, z); 
  }
  
  public static void reduce(int[] z, int[] m, int mInv32) {
    for (int i = 0; i < 8; i++) {
      int z_0 = z[0];
      long t = (z_0 * mInv32) & 0xFFFFFFFFL;
      long carry = t * (m[0] & 0xFFFFFFFFL) + (z_0 & 0xFFFFFFFFL);
      carry >>>= 32;
      for (int j = 1; j < 8; j++) {
        carry += t * (m[j] & 0xFFFFFFFFL) + (z[j] & 0xFFFFFFFFL);
        z[j - 1] = (int)carry;
        carry >>>= 32;
      } 
      z[7] = (int)carry;
    } 
    if (Nat256.gte(z, m))
      Nat256.sub(z, m, z); 
  }
  
  public static void reduceXF(int[] z, int[] m) {
    for (int i = 0; i < 8; i++) {
      int z_0 = z[0];
      long t = z_0 & 0xFFFFFFFFL;
      long carry = t;
      for (int j = 1; j < 8; j++) {
        carry += t * (m[j] & 0xFFFFFFFFL) + (z[j] & 0xFFFFFFFFL);
        z[j - 1] = (int)carry;
        carry >>>= 32;
      } 
      z[7] = (int)carry;
    } 
    if (Nat256.gte(z, m))
      Nat256.sub(z, m, z); 
  }
}
