package org.bouncycastle.math.ec;

import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.Hashtable;
import org.bouncycastle.crypto.CryptoServicesRegistrar;

public abstract class ECPoint {
  protected static final ECFieldElement[] EMPTY_ZS = new ECFieldElement[0];
  
  protected ECCurve curve;
  
  protected ECFieldElement x;
  
  protected ECFieldElement y;
  
  protected ECFieldElement[] zs;
  
  protected Hashtable preCompTable;
  
  protected static ECFieldElement[] getInitialZCoords(ECCurve curve) {
    int coord = (null == curve) ? 0 : curve.getCoordinateSystem();
    switch (coord) {
      case 0:
      case 5:
        return EMPTY_ZS;
    } 
    ECFieldElement one = curve.fromBigInteger(ECConstants.ONE);
    switch (coord) {
      case 1:
      case 2:
      case 6:
        return new ECFieldElement[] { one };
      case 3:
        return new ECFieldElement[] { one, one, one };
      case 4:
        return new ECFieldElement[] { one, curve.getA() };
    } 
    throw new IllegalArgumentException("unknown coordinate system");
  }
  
  protected ECPoint(ECCurve curve, ECFieldElement x, ECFieldElement y) { this(curve, x, y, getInitialZCoords(curve)); }
  
  protected ECPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs) {
    this.preCompTable = null;
    this.curve = curve;
    this.x = x;
    this.y = y;
    this.zs = zs;
  }
  
  protected abstract boolean satisfiesCurveEquation();
  
  protected boolean satisfiesOrder() {
    if (ECConstants.ONE.equals(this.curve.getCofactor()))
      return true; 
    BigInteger n = this.curve.getOrder();
    return (n == null || ECAlgorithms.referenceMultiply(this, n).isInfinity());
  }
  
  public final ECPoint getDetachedPoint() { return normalize().detach(); }
  
  public ECCurve getCurve() { return this.curve; }
  
  protected abstract ECPoint detach();
  
  protected int getCurveCoordinateSystem() { return (null == this.curve) ? 0 : this.curve.getCoordinateSystem(); }
  
  public ECFieldElement getAffineXCoord() {
    checkNormalized();
    return getXCoord();
  }
  
  public ECFieldElement getAffineYCoord() {
    checkNormalized();
    return getYCoord();
  }
  
  public ECFieldElement getXCoord() { return this.x; }
  
  public ECFieldElement getYCoord() { return this.y; }
  
  public ECFieldElement getZCoord(int index) { return (index < 0 || index >= this.zs.length) ? null : this.zs[index]; }
  
  public ECFieldElement[] getZCoords() {
    int zsLen = this.zs.length;
    if (zsLen == 0)
      return EMPTY_ZS; 
    ECFieldElement[] copy = new ECFieldElement[zsLen];
    System.arraycopy(this.zs, 0, copy, 0, zsLen);
    return copy;
  }
  
  public final ECFieldElement getRawXCoord() { return this.x; }
  
  public final ECFieldElement getRawYCoord() { return this.y; }
  
  protected final ECFieldElement[] getRawZCoords() { return this.zs; }
  
  protected void checkNormalized() {
    if (!isNormalized())
      throw new IllegalStateException("point not in normal form"); 
  }
  
  public boolean isNormalized() {
    int coord = getCurveCoordinateSystem();
    return (coord == 0 || coord == 5 || 
      
      isInfinity() || this.zs[0]
      .isOne());
  }
  
  public ECPoint normalize() {
    if (isInfinity())
      return this; 
    switch (getCurveCoordinateSystem()) {
      case 0:
      case 5:
        return this;
    } 
    ECFieldElement z = getZCoord(0);
    if (z.isOne())
      return this; 
    if (null == this.curve)
      throw new IllegalStateException("Detached points must be in affine coordinates"); 
    SecureRandom r = CryptoServicesRegistrar.getSecureRandom();
    ECFieldElement b = this.curve.randomFieldElementMult(r);
    ECFieldElement zInv = z.multiply(b).invert().multiply(b);
    return normalize(zInv);
  }
  
  ECPoint normalize(ECFieldElement zInv) {
    ECFieldElement zInv3;
    ECFieldElement zInv2;
    switch (getCurveCoordinateSystem()) {
      case 1:
      case 6:
        return createScaledPoint(zInv, zInv);
      case 2:
      case 3:
      case 4:
        zInv2 = zInv.square();
        zInv3 = zInv2.multiply(zInv);
        return createScaledPoint(zInv2, zInv3);
    } 
    throw new IllegalStateException("not a projective coordinate system");
  }
  
  protected ECPoint createScaledPoint(ECFieldElement sx, ECFieldElement sy) { return getCurve().createRawPoint(getRawXCoord().multiply(sx), getRawYCoord().multiply(sy)); }
  
  public boolean isInfinity() { return (this.x == null || this.y == null || (this.zs.length > 0 && this.zs[0].isZero())); }
  
  public boolean isValid() { return implIsValid(false, true); }
  
  boolean isValidPartial() { return implIsValid(false, false); }
  
  boolean implIsValid(boolean decompressed, boolean checkOrder) {
    if (isInfinity())
      return true; 
    ValidityPrecompInfo validity = (ValidityPrecompInfo)getCurve().precompute(this, "bc_validity", new Object(this, decompressed, checkOrder));
    return !validity.hasFailed();
  }
  
  public ECPoint scaleX(ECFieldElement scale) {
    return isInfinity() ? this : 
      
      getCurve().createRawPoint(getRawXCoord().multiply(scale), getRawYCoord(), getRawZCoords());
  }
  
  public ECPoint scaleXNegateY(ECFieldElement scale) {
    return isInfinity() ? this : 
      
      getCurve().createRawPoint(getRawXCoord().multiply(scale), getRawYCoord().negate(), getRawZCoords());
  }
  
  public ECPoint scaleY(ECFieldElement scale) {
    return isInfinity() ? this : 
      
      getCurve().createRawPoint(getRawXCoord(), getRawYCoord().multiply(scale), getRawZCoords());
  }
  
  public ECPoint scaleYNegateX(ECFieldElement scale) {
    return isInfinity() ? this : 
      
      getCurve().createRawPoint(getRawXCoord().negate(), getRawYCoord().multiply(scale), getRawZCoords());
  }
  
  public boolean equals(ECPoint other) {
    if (null == other)
      return false; 
    ECCurve c1 = getCurve(), c2 = other.getCurve();
    boolean n1 = (null == c1), n2 = (null == c2);
    boolean i1 = isInfinity(), i2 = other.isInfinity();
    if (i1 || i2)
      return (i1 && i2 && (n1 || n2 || c1.equals(c2))); 
    ECPoint p1 = this, p2 = other;
    if (!n1 || !n2)
      if (n1) {
        p2 = p2.normalize();
      } else if (n2) {
        p1 = p1.normalize();
      } else {
        if (!c1.equals(c2))
          return false; 
        ECPoint[] points = { this, c1.importPoint(p2) };
        c1.normalizeAll(points);
        p1 = points[0];
        p2 = points[1];
      }  
    return (p1.getXCoord().equals(p2.getXCoord()) && p1.getYCoord().equals(p2.getYCoord()));
  }
  
  public boolean equals(Object other) {
    if (other == this)
      return true; 
    if (!(other instanceof ECPoint))
      return false; 
    return equals((ECPoint)other);
  }
  
  public int hashCode() {
    ECCurve c = getCurve();
    int hc = (null == c) ? 0 : (c.hashCode() ^ 0xFFFFFFFF);
    if (!isInfinity()) {
      ECPoint p = normalize();
      hc ^= p.getXCoord().hashCode() * 17;
      hc ^= p.getYCoord().hashCode() * 257;
    } 
    return hc;
  }
  
  public String toString() {
    if (isInfinity())
      return "INF"; 
    StringBuffer sb = new StringBuffer();
    sb.append('(');
    sb.append(getRawXCoord());
    sb.append(',');
    sb.append(getRawYCoord());
    for (int i = 0; i < this.zs.length; i++) {
      sb.append(',');
      sb.append(this.zs[i]);
    } 
    sb.append(')');
    return sb.toString();
  }
  
  public byte[] getEncoded(boolean compressed) {
    if (isInfinity())
      return new byte[1]; 
    ECPoint normed = normalize();
    byte[] X = normed.getXCoord().getEncoded();
    if (compressed) {
      byte[] PO = new byte[X.length + 1];
      PO[0] = (byte)(normed.getCompressionYTilde() ? 3 : 2);
      System.arraycopy(X, 0, PO, 1, X.length);
      return PO;
    } 
    byte[] Y = normed.getYCoord().getEncoded();
    byte[] PO = new byte[X.length + Y.length + 1];
    PO[0] = 4;
    System.arraycopy(X, 0, PO, 1, X.length);
    System.arraycopy(Y, 0, PO, X.length + 1, Y.length);
    return PO;
  }
  
  protected abstract boolean getCompressionYTilde();
  
  public abstract ECPoint add(ECPoint paramECPoint);
  
  public abstract ECPoint negate();
  
  public abstract ECPoint subtract(ECPoint paramECPoint);
  
  public ECPoint timesPow2(int e) {
    if (e < 0)
      throw new IllegalArgumentException("'e' cannot be negative"); 
    ECPoint p = this;
    while (--e >= 0)
      p = p.twice(); 
    return p;
  }
  
  public abstract ECPoint twice();
  
  public ECPoint twicePlus(ECPoint b) { return twice().add(b); }
  
  public ECPoint threeTimes() { return twicePlus(this); }
  
  public ECPoint multiply(BigInteger k) { return getCurve().getMultiplier().multiply(this, k); }
}
