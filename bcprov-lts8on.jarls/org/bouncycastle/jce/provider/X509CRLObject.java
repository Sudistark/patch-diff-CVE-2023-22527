package org.bouncycastle.jce.provider;

import java.io.IOException;
import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.Principal;
import java.security.Provider;
import java.security.PublicKey;
import java.security.Signature;
import java.security.SignatureException;
import java.security.cert.CRLException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.X509CRL;
import java.security.cert.X509CRLEntry;
import java.security.cert.X509Certificate;
import java.util.Collections;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import javax.security.auth.x500.X500Principal;
import org.bouncycastle.asn1.ASN1InputStream;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.ASN1OctetString;
import org.bouncycastle.asn1.util.ASN1Dump;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x509.CRLDistPoint;
import org.bouncycastle.asn1.x509.CRLNumber;
import org.bouncycastle.asn1.x509.Certificate;
import org.bouncycastle.asn1.x509.CertificateList;
import org.bouncycastle.asn1.x509.Extension;
import org.bouncycastle.asn1.x509.Extensions;
import org.bouncycastle.asn1.x509.GeneralNames;
import org.bouncycastle.asn1.x509.IssuingDistributionPoint;
import org.bouncycastle.asn1.x509.TBSCertList;
import org.bouncycastle.util.Strings;
import org.bouncycastle.util.encoders.Hex;

public class X509CRLObject extends X509CRL {
  private CertificateList c;
  
  private String sigAlgName;
  
  private byte[] sigAlgParams;
  
  private boolean isIndirect;
  
  private boolean isHashCodeSet;
  
  private int hashCodeValue;
  
  public static boolean isIndirectCRL(X509CRL crl) throws CRLException {
    try {
      byte[] idp = crl.getExtensionValue(Extension.issuingDistributionPoint.getId());
      return (idp != null && 
        IssuingDistributionPoint.getInstance(ASN1OctetString.getInstance(idp).getOctets()).isIndirectCRL());
    } catch (Exception e) {
      throw new ExtCRLException("Exception reading IssuingDistributionPoint", e);
    } 
  }
  
  public X509CRLObject(CertificateList c) throws CRLException {
    this.isHashCodeSet = false;
    this.c = c;
    try {
      this.sigAlgName = X509SignatureUtil.getSignatureName(c.getSignatureAlgorithm());
      if (c.getSignatureAlgorithm().getParameters() != null) {
        this.sigAlgParams = c.getSignatureAlgorithm().getParameters().toASN1Primitive().getEncoded("DER");
      } else {
        this.sigAlgParams = null;
      } 
      this.isIndirect = isIndirectCRL(this);
    } catch (Exception e) {
      throw new CRLException("CRL contents invalid: " + e);
    } 
  }
  
  public boolean hasUnsupportedCriticalExtension() {
    Set extns = getCriticalExtensionOIDs();
    if (extns == null)
      return false; 
    extns.remove(RFC3280CertPathUtilities.ISSUING_DISTRIBUTION_POINT);
    extns.remove(RFC3280CertPathUtilities.DELTA_CRL_INDICATOR);
    return !extns.isEmpty();
  }
  
  private Set getExtensionOIDs(boolean critical) {
    if (getVersion() == 2) {
      Extensions extensions = this.c.getTBSCertList().getExtensions();
      if (extensions != null) {
        Set set = new HashSet();
        Enumeration e = extensions.oids();
        while (e.hasMoreElements()) {
          ASN1ObjectIdentifier oid = (ASN1ObjectIdentifier)e.nextElement();
          Extension ext = extensions.getExtension(oid);
          if (critical == ext.isCritical())
            set.add(oid.getId()); 
        } 
        return set;
      } 
    } 
    return null;
  }
  
  public Set getCriticalExtensionOIDs() { return getExtensionOIDs(true); }
  
  public Set getNonCriticalExtensionOIDs() { return getExtensionOIDs(false); }
  
  public byte[] getExtensionValue(String oid) {
    Extensions exts = this.c.getTBSCertList().getExtensions();
    if (exts != null) {
      Extension ext = exts.getExtension(new ASN1ObjectIdentifier(oid));
      if (ext != null)
        try {
          return ext.getExtnValue().getEncoded();
        } catch (Exception e) {
          throw new IllegalStateException("error parsing " + e.toString());
        }  
    } 
    return null;
  }
  
  public byte[] getEncoded() throws CRLException {
    try {
      return this.c.getEncoded("DER");
    } catch (IOException e) {
      throw new CRLException(e.toString());
    } 
  }
  
  public void verify(PublicKey key) throws CRLException, NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException {
    Signature sig;
    try {
      sig = Signature.getInstance(getSigAlgName(), "BC");
    } catch (Exception e) {
      sig = Signature.getInstance(getSigAlgName());
    } 
    doVerify(key, sig);
  }
  
  public void verify(PublicKey key, String sigProvider) throws CRLException, NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException {
    Signature sig;
    if (sigProvider != null) {
      sig = Signature.getInstance(getSigAlgName(), sigProvider);
    } else {
      sig = Signature.getInstance(getSigAlgName());
    } 
    doVerify(key, sig);
  }
  
  public void verify(PublicKey key, Provider sigProvider) throws CRLException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
    Signature sig;
    if (sigProvider != null) {
      sig = Signature.getInstance(getSigAlgName(), sigProvider);
    } else {
      sig = Signature.getInstance(getSigAlgName());
    } 
    doVerify(key, sig);
  }
  
  private void doVerify(PublicKey key, Signature sig) throws CRLException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
    if (!this.c.getSignatureAlgorithm().equals(this.c.getTBSCertList().getSignature()))
      throw new CRLException("Signature algorithm on CertificateList does not match TBSCertList."); 
    sig.initVerify(key);
    sig.update(getTBSCertList());
    if (!sig.verify(getSignature()))
      throw new SignatureException("CRL does not verify with supplied public key."); 
  }
  
  public int getVersion() { return this.c.getVersionNumber(); }
  
  public Principal getIssuerDN() { return getIssuerX500Principal(); }
  
  public X500Principal getIssuerX500Principal() {
    try {
      return new X500Principal(this.c.getIssuer().getEncoded());
    } catch (IOException e) {
      throw new IllegalStateException("can't encode issuer DN");
    } 
  }
  
  public Date getThisUpdate() { return this.c.getThisUpdate().getDate(); }
  
  public Date getNextUpdate() {
    if (this.c.getNextUpdate() != null)
      return this.c.getNextUpdate().getDate(); 
    return null;
  }
  
  private Set loadCRLEntries() {
    Set entrySet = new HashSet();
    Enumeration certs = this.c.getRevokedCertificateEnumeration();
    X500Name previousCertificateIssuer = null;
    while (certs.hasMoreElements()) {
      TBSCertList.CRLEntry entry = (TBSCertList.CRLEntry)certs.nextElement();
      X509CRLEntryObject crlEntry = new X509CRLEntryObject(entry, this.isIndirect, previousCertificateIssuer);
      entrySet.add(crlEntry);
      if (this.isIndirect && entry.hasExtensions()) {
        Extension currentCaName = entry.getExtensions().getExtension(Extension.certificateIssuer);
        if (currentCaName != null)
          previousCertificateIssuer = X500Name.getInstance(GeneralNames.getInstance(currentCaName.getParsedValue()).getNames()[0].getName()); 
      } 
    } 
    return entrySet;
  }
  
  public X509CRLEntry getRevokedCertificate(BigInteger serialNumber) {
    Enumeration certs = this.c.getRevokedCertificateEnumeration();
    X500Name previousCertificateIssuer = null;
    while (certs.hasMoreElements()) {
      TBSCertList.CRLEntry entry = (TBSCertList.CRLEntry)certs.nextElement();
      if (entry.getUserCertificate().hasValue(serialNumber))
        return new X509CRLEntryObject(entry, this.isIndirect, previousCertificateIssuer); 
      if (this.isIndirect && entry.hasExtensions()) {
        Extension currentCaName = entry.getExtensions().getExtension(Extension.certificateIssuer);
        if (currentCaName != null)
          previousCertificateIssuer = X500Name.getInstance(GeneralNames.getInstance(currentCaName.getParsedValue()).getNames()[0].getName()); 
      } 
    } 
    return null;
  }
  
  public Set getRevokedCertificates() {
    Set entrySet = loadCRLEntries();
    if (!entrySet.isEmpty())
      return Collections.unmodifiableSet(entrySet); 
    return null;
  }
  
  public byte[] getTBSCertList() throws CRLException {
    try {
      return this.c.getTBSCertList().getEncoded("DER");
    } catch (IOException e) {
      throw new CRLException(e.toString());
    } 
  }
  
  public byte[] getSignature() throws CRLException { return this.c.getSignature().getOctets(); }
  
  public String getSigAlgName() { return this.sigAlgName; }
  
  public String getSigAlgOID() { return this.c.getSignatureAlgorithm().getAlgorithm().getId(); }
  
  public byte[] getSigAlgParams() throws CRLException {
    if (this.sigAlgParams != null) {
      byte[] tmp = new byte[this.sigAlgParams.length];
      System.arraycopy(this.sigAlgParams, 0, tmp, 0, tmp.length);
      return tmp;
    } 
    return null;
  }
  
  public String toString() {
    StringBuffer buf = new StringBuffer();
    String nl = Strings.lineSeparator();
    buf.append("              Version: ").append(getVersion()).append(nl);
    buf.append("             IssuerDN: ").append(getIssuerDN())
      .append(nl);
    buf.append("          This update: ").append(getThisUpdate())
      .append(nl);
    buf.append("          Next update: ").append(getNextUpdate())
      .append(nl);
    buf.append("  Signature Algorithm: ").append(getSigAlgName())
      .append(nl);
    byte[] sig = getSignature();
    buf.append("            Signature: ").append(new String(
          Hex.encode(sig, 0, 20))).append(nl);
    for (int i = 20; i < sig.length; i += 20) {
      if (i < sig.length - 20) {
        buf.append("                       ").append(new String(
              Hex.encode(sig, i, 20))).append(nl);
      } else {
        buf.append("                       ").append(new String(
              Hex.encode(sig, i, sig.length - i))).append(nl);
      } 
    } 
    Extensions extensions = this.c.getTBSCertList().getExtensions();
    if (extensions != null) {
      Enumeration e = extensions.oids();
      if (e.hasMoreElements())
        buf.append("           Extensions: ").append(nl); 
      while (e.hasMoreElements()) {
        ASN1ObjectIdentifier oid = (ASN1ObjectIdentifier)e.nextElement();
        Extension ext = extensions.getExtension(oid);
        if (ext.getExtnValue() != null) {
          byte[] octs = ext.getExtnValue().getOctets();
          ASN1InputStream dIn = new ASN1InputStream(octs);
          buf.append("                       critical(").append(ext
              .isCritical()).append(") ");
          try {
            if (oid.equals(Extension.cRLNumber)) {
              buf.append(new CRLNumber(
                    ASN1Integer.getInstance(dIn
                      .readObject()).getPositiveValue()))
                .append(nl);
              continue;
            } 
            if (oid.equals(Extension.deltaCRLIndicator)) {
              buf.append("Base CRL: " + new CRLNumber(
                    
                    ASN1Integer.getInstance(dIn
                      .readObject()).getPositiveValue()))
                .append(nl);
              continue;
            } 
            if (oid
              .equals(Extension.issuingDistributionPoint)) {
              buf.append(
                  IssuingDistributionPoint.getInstance(dIn.readObject())).append(nl);
              continue;
            } 
            if (oid
              .equals(Extension.cRLDistributionPoints)) {
              buf.append(
                  CRLDistPoint.getInstance(dIn.readObject())).append(nl);
              continue;
            } 
            if (oid.equals(Extension.freshestCRL)) {
              buf.append(
                  CRLDistPoint.getInstance(dIn.readObject())).append(nl);
              continue;
            } 
            buf.append(oid.getId());
            buf.append(" value = ").append(
                ASN1Dump.dumpAsString(dIn.readObject()))
              .append(nl);
            continue;
          } catch (Exception ex) {
            buf.append(oid.getId());
            buf.append(" value = ").append("*****").append(nl);
            continue;
          } 
        } 
        buf.append(nl);
      } 
    } 
    Set set = getRevokedCertificates();
    if (set != null) {
      Iterator it = set.iterator();
      while (it.hasNext()) {
        buf.append(it.next());
        buf.append(nl);
      } 
    } 
    return buf.toString();
  }
  
  public boolean isRevoked(Certificate cert) {
    if (!cert.getType().equals("X.509"))
      throw new RuntimeException("X.509 CRL used with non X.509 Cert"); 
    Enumeration certs = this.c.getRevokedCertificateEnumeration();
    X500Name caName = this.c.getIssuer();
    if (certs != null) {
      BigInteger serial = ((X509Certificate)cert).getSerialNumber();
      while (certs.hasMoreElements()) {
        TBSCertList.CRLEntry entry = TBSCertList.CRLEntry.getInstance(certs.nextElement());
        if (this.isIndirect && entry.hasExtensions()) {
          Extension currentCaName = entry.getExtensions().getExtension(Extension.certificateIssuer);
          if (currentCaName != null)
            caName = X500Name.getInstance(GeneralNames.getInstance(currentCaName.getParsedValue()).getNames()[0].getName()); 
        } 
        if (entry.getUserCertificate().hasValue(serial)) {
          X500Name issuer;
          if (cert instanceof X509Certificate) {
            issuer = X500Name.getInstance(((X509Certificate)cert).getIssuerX500Principal().getEncoded());
          } else {
            try {
              issuer = Certificate.getInstance(cert.getEncoded()).getIssuer();
            } catch (CertificateEncodingException e) {
              throw new RuntimeException("Cannot process certificate");
            } 
          } 
          if (!caName.equals(issuer))
            return false; 
          return true;
        } 
      } 
    } 
    return false;
  }
  
  public boolean equals(Object other) {
    if (this == other)
      return true; 
    if (!(other instanceof X509CRL))
      return false; 
    if (other instanceof X509CRLObject) {
      X509CRLObject crlObject = (X509CRLObject)other;
      if (this.isHashCodeSet) {
        boolean otherIsHashCodeSet = crlObject.isHashCodeSet;
        if (otherIsHashCodeSet)
          if (crlObject.hashCodeValue != this.hashCodeValue)
            return false;  
      } 
      return this.c.equals(crlObject.c);
    } 
    return super.equals(other);
  }
  
  public int hashCode() {
    if (!this.isHashCodeSet) {
      this.isHashCodeSet = true;
      this.hashCodeValue = super.hashCode();
    } 
    return this.hashCodeValue;
  }
}
