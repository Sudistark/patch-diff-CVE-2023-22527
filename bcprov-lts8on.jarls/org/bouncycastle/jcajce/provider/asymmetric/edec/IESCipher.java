package org.bouncycastle.jcajce.provider.asymmetric.edec;

import java.io.ByteArrayOutputStream;
import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.NoSuchPaddingException;
import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.crypto.KeyGenerationParameters;
import org.bouncycastle.crypto.engines.IESEngine;
import org.bouncycastle.crypto.generators.EphemeralKeyPairGenerator;
import org.bouncycastle.crypto.generators.X25519KeyPairGenerator;
import org.bouncycastle.crypto.generators.X448KeyPairGenerator;
import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
import org.bouncycastle.crypto.params.ECKeyParameters;
import org.bouncycastle.crypto.params.IESWithCipherParameters;
import org.bouncycastle.crypto.params.ParametersWithIV;
import org.bouncycastle.crypto.parsers.XIESPublicKeyParser;
import org.bouncycastle.jcajce.interfaces.XDHKey;
import org.bouncycastle.jcajce.provider.asymmetric.util.BaseCipherSpi;
import org.bouncycastle.jcajce.provider.util.BadBlockException;
import org.bouncycastle.jcajce.util.BCJcaJceHelper;
import org.bouncycastle.jcajce.util.JcaJceHelper;
import org.bouncycastle.jce.spec.IESParameterSpec;
import org.bouncycastle.math.ec.ECCurve;
import org.bouncycastle.util.Strings;

public class IESCipher extends BaseCipherSpi {
  private final JcaJceHelper helper;
  
  private int ivLength;
  
  private IESEngine engine;
  
  private int state;
  
  private ByteArrayOutputStream buffer;
  
  private AlgorithmParameters engineParam;
  
  private IESParameterSpec engineSpec;
  
  private AsymmetricKeyParameter key;
  
  private SecureRandom random;
  
  private boolean dhaesMode;
  
  private AsymmetricKeyParameter otherKeyParameter;
  
  public IESCipher(IESEngine engine) {
    this.helper = new BCJcaJceHelper();
    this.state = -1;
    this.buffer = new ByteArrayOutputStream();
    this.engineParam = null;
    this.engineSpec = null;
    this.dhaesMode = false;
    this.otherKeyParameter = null;
    this.engine = engine;
    this.ivLength = 0;
  }
  
  public IESCipher(IESEngine engine, int ivLength) {
    this.helper = new BCJcaJceHelper();
    this.state = -1;
    this.buffer = new ByteArrayOutputStream();
    this.engineParam = null;
    this.engineSpec = null;
    this.dhaesMode = false;
    this.otherKeyParameter = null;
    this.engine = engine;
    this.ivLength = ivLength;
  }
  
  public int engineGetBlockSize() {
    if (this.engine.getCipher() != null)
      return this.engine.getCipher().getBlockSize(); 
    return 0;
  }
  
  public int engineGetKeySize(Key key) {
    if (key instanceof XDHKey) {
      String algorithm = ((XDHKey)key).getAlgorithm();
      if ("X25519".equalsIgnoreCase(algorithm))
        return 256; 
      if ("X448".equalsIgnoreCase(algorithm))
        return 448; 
      throw new IllegalArgumentException("unknown XDH key algorithm " + algorithm);
    } 
    throw new IllegalArgumentException("not an XDH key");
  }
  
  public byte[] engineGetIV() {
    if (this.engineSpec != null)
      return this.engineSpec.getNonce(); 
    return null;
  }
  
  public AlgorithmParameters engineGetParameters() {
    if (this.engineParam == null && this.engineSpec != null)
      try {
        this.engineParam = this.helper.createAlgorithmParameters("IES");
        this.engineParam.init(this.engineSpec);
      } catch (Exception e) {
        throw new RuntimeException(e.toString());
      }  
    return this.engineParam;
  }
  
  public void engineSetMode(String mode) throws NoSuchAlgorithmException {
    String modeName = Strings.toUpperCase(mode);
    if (modeName.equals("NONE")) {
      this.dhaesMode = false;
    } else if (modeName.equals("DHAES")) {
      this.dhaesMode = true;
    } else {
      throw new IllegalArgumentException("can't support mode " + mode);
    } 
  }
  
  public int engineGetOutputSize(int inputLen) {
    int len3, len2;
    if (this.key == null)
      throw new IllegalStateException("cipher not initialised"); 
    int len1 = this.engine.getMac().getMacSize();
    if (this.otherKeyParameter == null) {
      ECCurve c = ((ECKeyParameters)this.key).getParameters().getCurve();
      int feSize = (c.getFieldSize() + 7) / 8;
      len2 = 2 * feSize;
    } else {
      len2 = 0;
    } 
    int inLen = this.buffer.size() + inputLen;
    if (this.engine.getCipher() == null) {
      len3 = inLen;
    } else if (this.state == 1 || this.state == 3) {
      len3 = this.engine.getCipher().getOutputSize(inLen);
    } else if (this.state == 2 || this.state == 4) {
      len3 = this.engine.getCipher().getOutputSize(inLen - len1 - len2);
    } else {
      throw new IllegalStateException("cipher not initialised");
    } 
    if (this.state == 1 || this.state == 3)
      return len1 + len2 + len3; 
    if (this.state == 2 || this.state == 4)
      return len3; 
    throw new IllegalStateException("cipher not initialised");
  }
  
  public void engineSetPadding(String padding) throws NoSuchAlgorithmException {
    String paddingName = Strings.toUpperCase(padding);
    if (!paddingName.equals("NOPADDING"))
      if (!paddingName.equals("PKCS5PADDING") && !paddingName.equals("PKCS7PADDING"))
        throw new NoSuchPaddingException("padding not available with IESCipher");  
  }
  
  public void engineInit(int opmode, Key key, AlgorithmParameters params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException {
    AlgorithmParameterSpec paramSpec = null;
    if (params != null)
      try {
        paramSpec = params.getParameterSpec(IESParameterSpec.class);
      } catch (Exception e) {
        throw new InvalidAlgorithmParameterException("cannot recognise parameters: " + e.toString());
      }  
    this.engineParam = params;
    engineInit(opmode, key, paramSpec, random);
  }
  
  public void engineInit(int opmode, Key key, AlgorithmParameterSpec engineSpec, SecureRandom random) throws InvalidAlgorithmParameterException, InvalidKeyException {
    this.otherKeyParameter = null;
    if (engineSpec instanceof IESParameterSpec) {
      this.engineSpec = (IESParameterSpec)engineSpec;
    } else {
      throw new InvalidAlgorithmParameterException("must be passed IES parameters");
    } 
    byte[] nonce = this.engineSpec.getNonce();
    if (this.ivLength != 0 && (nonce == null || nonce.length != this.ivLength))
      throw new InvalidAlgorithmParameterException("NONCE in IES Parameters needs to be " + this.ivLength + " bytes long"); 
    if (opmode == 1 || opmode == 3) {
      if (key instanceof PublicKey) {
        this.key = EdECUtil.generatePublicKeyParameter((PublicKey)key);
      } else {
        throw new InvalidKeyException("must be passed recipient's public XDH key for encryption");
      } 
    } else if (opmode == 2 || opmode == 4) {
      if (key instanceof PrivateKey) {
        this.key = EdECUtil.generatePrivateKeyParameter((PrivateKey)key);
      } else {
        throw new InvalidKeyException("must be passed recipient's private XDH key for decryption");
      } 
    } else {
      throw new InvalidKeyException("must be passed XDH key");
    } 
    this.random = random;
    this.state = opmode;
    this.buffer.reset();
  }
  
  public void engineInit(int opmode, Key key, SecureRandom random) throws InvalidKeyException {
    try {
      engineInit(opmode, key, (AlgorithmParameterSpec)null, random);
    } catch (InvalidAlgorithmParameterException e) {
      throw new IllegalArgumentException("cannot handle supplied parameter spec: " + e.getMessage());
    } 
  }
  
  public byte[] engineUpdate(byte[] input, int inputOffset, int inputLen) {
    this.buffer.write(input, inputOffset, inputLen);
    return null;
  }
  
  public int engineUpdate(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) {
    this.buffer.write(input, inputOffset, inputLen);
    return 0;
  }
  
  public byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen) {
    if (inputLen != 0)
      this.buffer.write(input, inputOffset, inputLen); 
    byte[] in = this.buffer.toByteArray();
    this.buffer.reset();
    ParametersWithIV parametersWithIV = new IESWithCipherParameters(this.engineSpec.getDerivationV(), this.engineSpec.getEncodingV(), this.engineSpec.getMacKeySize(), this.engineSpec.getCipherKeySize());
    if (this.engineSpec.getNonce() != null)
      parametersWithIV = new ParametersWithIV(parametersWithIV, this.engineSpec.getNonce()); 
    if (this.otherKeyParameter != null)
      try {
        if (this.state == 1 || this.state == 3) {
          this.engine.init(true, this.otherKeyParameter, this.key, parametersWithIV);
        } else {
          this.engine.init(false, this.key, this.otherKeyParameter, parametersWithIV);
        } 
        return this.engine.processBlock(in, 0, in.length);
      } catch (Exception e) {
        throw new BadBlockException("unable to process block", e);
      }  
    boolean isX25519 = (this.key instanceof org.bouncycastle.crypto.params.X25519PublicKeyParameters || this.key instanceof org.bouncycastle.crypto.params.X25519PrivateKeyParameters);
    int fieldSize = isX25519 ? 256 : 448;
    if (this.state == 1 || this.state == 3) {
      X25519KeyPairGenerator x25519KeyPairGenerator = isX25519 ? new X25519KeyPairGenerator() : new X448KeyPairGenerator();
      x25519KeyPairGenerator.init(new KeyGenerationParameters(this.random, fieldSize));
      EphemeralKeyPairGenerator epKpGen = new EphemeralKeyPairGenerator(x25519KeyPairGenerator, new Object(this, isX25519));
      try {
        this.engine.init(this.key, parametersWithIV, epKpGen);
        return this.engine.processBlock(in, 0, in.length);
      } catch (Exception e) {
        throw new BadBlockException("unable to process block", e);
      } 
    } 
    if (this.state == 2 || this.state == 4)
      try {
        this.engine.init(this.key, parametersWithIV, new XIESPublicKeyParser(isX25519));
        return this.engine.processBlock(in, 0, in.length);
      } catch (InvalidCipherTextException e) {
        throw new BadBlockException("unable to process block", e);
      }  
    throw new IllegalStateException("cipher not initialised");
  }
  
  public int engineDoFinal(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset) {
    byte[] buf = engineDoFinal(input, inputOffset, inputLength);
    System.arraycopy(buf, 0, output, outputOffset, buf.length);
    return buf.length;
  }
}
