package org.bouncycastle.jcajce.provider.symmetric.util;

import java.util.concurrent.atomic.AtomicBoolean;
import javax.crypto.interfaces.PBEKey;
import javax.crypto.spec.PBEKeySpec;
import javax.security.auth.Destroyable;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.PBEParametersGenerator;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.ParametersWithIV;
import org.bouncycastle.util.Arrays;

public class BCPBEKey implements PBEKey, Destroyable {
  private final AtomicBoolean hasBeenDestroyed;
  
  String algorithm;
  
  ASN1ObjectIdentifier oid;
  
  int type;
  
  int digest;
  
  int keySize;
  
  int ivSize;
  
  private final char[] password;
  
  private final byte[] salt;
  
  private final int iterationCount;
  
  private final CipherParameters param;
  
  boolean tryWrong;
  
  public BCPBEKey(String algorithm, ASN1ObjectIdentifier oid, int type, int digest, int keySize, int ivSize, PBEKeySpec pbeKeySpec, CipherParameters param) {
    this.hasBeenDestroyed = new AtomicBoolean(false);
    this.tryWrong = false;
    this.algorithm = algorithm;
    this.oid = oid;
    this.type = type;
    this.digest = digest;
    this.keySize = keySize;
    this.ivSize = ivSize;
    this.password = pbeKeySpec.getPassword();
    this.iterationCount = pbeKeySpec.getIterationCount();
    this.salt = pbeKeySpec.getSalt();
    this.param = param;
  }
  
  public BCPBEKey(String algName, CipherParameters param) {
    this.hasBeenDestroyed = new AtomicBoolean(false);
    this.tryWrong = false;
    this.algorithm = algName;
    this.param = param;
    this.password = null;
    this.iterationCount = -1;
    this.salt = null;
  }
  
  public String getAlgorithm() {
    String rv = this.algorithm;
    checkDestroyed(this);
    return rv;
  }
  
  public String getFormat() {
    checkDestroyed(this);
    return "RAW";
  }
  
  public byte[] getEncoded() {
    byte[] enc;
    if (this.param != null) {
      KeyParameter kParam;
      if (this.param instanceof ParametersWithIV) {
        kParam = (KeyParameter)((ParametersWithIV)this.param).getParameters();
      } else {
        kParam = (KeyParameter)this.param;
      } 
      enc = kParam.getKey();
    } else if (this.type == 2) {
      enc = PBEParametersGenerator.PKCS12PasswordToBytes(this.password);
    } else if (this.type == 5) {
      enc = PBEParametersGenerator.PKCS5PasswordToUTF8Bytes(this.password);
    } else {
      enc = PBEParametersGenerator.PKCS5PasswordToBytes(this.password);
    } 
    checkDestroyed(this);
    return enc;
  }
  
  int getType() {
    int rv = this.type;
    checkDestroyed(this);
    return rv;
  }
  
  int getDigest() {
    int rv = this.digest;
    checkDestroyed(this);
    return rv;
  }
  
  int getKeySize() {
    int rv = this.keySize;
    checkDestroyed(this);
    return rv;
  }
  
  public int getIvSize() {
    int rv = this.ivSize;
    checkDestroyed(this);
    return rv;
  }
  
  public CipherParameters getParam() {
    CipherParameters rv = this.param;
    checkDestroyed(this);
    return rv;
  }
  
  public char[] getPassword() {
    char[] clone = Arrays.clone(this.password);
    checkDestroyed(this);
    if (clone == null)
      throw new IllegalStateException("no password available"); 
    return clone;
  }
  
  public byte[] getSalt() {
    byte[] clone = Arrays.clone(this.salt);
    checkDestroyed(this);
    return clone;
  }
  
  public int getIterationCount() {
    int rv = this.iterationCount;
    checkDestroyed(this);
    return rv;
  }
  
  public ASN1ObjectIdentifier getOID() {
    ASN1ObjectIdentifier rv = this.oid;
    checkDestroyed(this);
    return rv;
  }
  
  public void setTryWrongPKCS12Zero(boolean tryWrong) { this.tryWrong = tryWrong; }
  
  boolean shouldTryWrongPKCS12() { return this.tryWrong; }
  
  public void destroy() {
    if (!this.hasBeenDestroyed.getAndSet(true)) {
      if (this.password != null)
        Arrays.fill(this.password, false); 
      if (this.salt != null)
        Arrays.fill(this.salt, (byte)0); 
    } 
  }
  
  public boolean isDestroyed() { return this.hasBeenDestroyed.get(); }
  
  static void checkDestroyed(Destroyable destroyable) {
    if (destroyable.isDestroyed())
      throw new IllegalStateException("key has been destroyed"); 
  }
}
