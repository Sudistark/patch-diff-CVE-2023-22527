package org.joda.time.format;

import java.util.Locale;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicReferenceArray;
import org.joda.time.DateTime;

public class DateTimeFormat {
  static final int FULL = 0;
  
  static final int LONG = 1;
  
  static final int MEDIUM = 2;
  
  static final int SHORT = 3;
  
  static final int NONE = 4;
  
  static final int DATE = 0;
  
  static final int TIME = 1;
  
  static final int DATETIME = 2;
  
  private static final int PATTERN_CACHE_SIZE = 500;
  
  private static final ConcurrentHashMap<String, DateTimeFormatter> cPatternCache = new ConcurrentHashMap();
  
  private static final AtomicReferenceArray<DateTimeFormatter> cStyleCache = new AtomicReferenceArray(25);
  
  public static DateTimeFormatter forPattern(String paramString) { return createFormatterForPattern(paramString); }
  
  public static DateTimeFormatter forStyle(String paramString) { return createFormatterForStyle(paramString); }
  
  public static String patternForStyle(String paramString, Locale paramLocale) {
    DateTimeFormatter dateTimeFormatter = createFormatterForStyle(paramString);
    if (paramLocale == null)
      paramLocale = Locale.getDefault(); 
    return ((StyleFormatter)dateTimeFormatter.getPrinter0()).getPattern(paramLocale);
  }
  
  public static DateTimeFormatter shortDate() { return createFormatterForStyleIndex(3, 4); }
  
  public static DateTimeFormatter shortTime() { return createFormatterForStyleIndex(4, 3); }
  
  public static DateTimeFormatter shortDateTime() { return createFormatterForStyleIndex(3, 3); }
  
  public static DateTimeFormatter mediumDate() { return createFormatterForStyleIndex(2, 4); }
  
  public static DateTimeFormatter mediumTime() { return createFormatterForStyleIndex(4, 2); }
  
  public static DateTimeFormatter mediumDateTime() { return createFormatterForStyleIndex(2, 2); }
  
  public static DateTimeFormatter longDate() { return createFormatterForStyleIndex(1, 4); }
  
  public static DateTimeFormatter longTime() { return createFormatterForStyleIndex(4, 1); }
  
  public static DateTimeFormatter longDateTime() { return createFormatterForStyleIndex(1, 1); }
  
  public static DateTimeFormatter fullDate() { return createFormatterForStyleIndex(0, 4); }
  
  public static DateTimeFormatter fullTime() { return createFormatterForStyleIndex(4, 0); }
  
  public static DateTimeFormatter fullDateTime() { return createFormatterForStyleIndex(0, 0); }
  
  static void appendPatternTo(DateTimeFormatterBuilder paramDateTimeFormatterBuilder, String paramString) { parsePatternTo(paramDateTimeFormatterBuilder, paramString); }
  
  private static void parsePatternTo(DateTimeFormatterBuilder paramDateTimeFormatterBuilder, String paramString) {
    int i = paramString.length();
    int[] arrayOfInt = new int[1];
    for (int j = 0; j < i; j++) {
      int m;
      String str2;
      arrayOfInt[0] = j;
      String str1 = parseToken(paramString, arrayOfInt);
      j = arrayOfInt[0];
      int k = str1.length();
      if (k == 0)
        break; 
      char c = str1.charAt(0);
      switch (c) {
        case 'G':
          paramDateTimeFormatterBuilder.appendEraText();
          break;
        case 'C':
          paramDateTimeFormatterBuilder.appendCenturyOfEra(k, k);
          break;
        case 'Y':
        case 'x':
        case 'y':
          if (k == 2) {
            boolean bool = true;
            if (j + 1 < i) {
              arrayOfInt[0] = arrayOfInt[0] + 1;
              if (isNumericToken(parseToken(paramString, arrayOfInt)))
                bool = false; 
              arrayOfInt[0] = arrayOfInt[0] - 1;
            } 
            switch (c) {
              case 'x':
                paramDateTimeFormatterBuilder
                  .appendTwoDigitWeekyear((new DateTime()).getWeekyear() - 30, bool);
                break;
            } 
            paramDateTimeFormatterBuilder.appendTwoDigitYear((new DateTime()).getYear() - 30, bool);
            break;
          } 
          m = 9;
          if (j + 1 < i) {
            arrayOfInt[0] = arrayOfInt[0] + 1;
            if (isNumericToken(parseToken(paramString, arrayOfInt)))
              m = k; 
            arrayOfInt[0] = arrayOfInt[0] - 1;
          } 
          switch (c) {
            case 'x':
              paramDateTimeFormatterBuilder.appendWeekyear(k, m);
              break;
            case 'y':
              paramDateTimeFormatterBuilder.appendYear(k, m);
              break;
            case 'Y':
              paramDateTimeFormatterBuilder.appendYearOfEra(k, m);
              break;
          } 
          break;
        case 'M':
          if (k >= 3) {
            if (k >= 4) {
              paramDateTimeFormatterBuilder.appendMonthOfYearText();
              break;
            } 
            paramDateTimeFormatterBuilder.appendMonthOfYearShortText();
            break;
          } 
          paramDateTimeFormatterBuilder.appendMonthOfYear(k);
          break;
        case 'd':
          paramDateTimeFormatterBuilder.appendDayOfMonth(k);
          break;
        case 'a':
          paramDateTimeFormatterBuilder.appendHalfdayOfDayText();
          break;
        case 'h':
          paramDateTimeFormatterBuilder.appendClockhourOfHalfday(k);
          break;
        case 'H':
          paramDateTimeFormatterBuilder.appendHourOfDay(k);
          break;
        case 'k':
          paramDateTimeFormatterBuilder.appendClockhourOfDay(k);
          break;
        case 'K':
          paramDateTimeFormatterBuilder.appendHourOfHalfday(k);
          break;
        case 'm':
          paramDateTimeFormatterBuilder.appendMinuteOfHour(k);
          break;
        case 's':
          paramDateTimeFormatterBuilder.appendSecondOfMinute(k);
          break;
        case 'S':
          paramDateTimeFormatterBuilder.appendFractionOfSecond(k, k);
          break;
        case 'e':
          paramDateTimeFormatterBuilder.appendDayOfWeek(k);
          break;
        case 'E':
          if (k >= 4) {
            paramDateTimeFormatterBuilder.appendDayOfWeekText();
            break;
          } 
          paramDateTimeFormatterBuilder.appendDayOfWeekShortText();
          break;
        case 'D':
          paramDateTimeFormatterBuilder.appendDayOfYear(k);
          break;
        case 'w':
          paramDateTimeFormatterBuilder.appendWeekOfWeekyear(k);
          break;
        case 'z':
          if (k >= 4) {
            paramDateTimeFormatterBuilder.appendTimeZoneName();
            break;
          } 
          paramDateTimeFormatterBuilder.appendTimeZoneShortName(null);
          break;
        case 'Z':
          if (k == 1) {
            paramDateTimeFormatterBuilder.appendTimeZoneOffset(null, "Z", false, 2, 2);
            break;
          } 
          if (k == 2) {
            paramDateTimeFormatterBuilder.appendTimeZoneOffset(null, "Z", true, 2, 2);
            break;
          } 
          paramDateTimeFormatterBuilder.appendTimeZoneId();
          break;
        case '\'':
          str2 = str1.substring(1);
          if (str2.length() == 1) {
            paramDateTimeFormatterBuilder.appendLiteral(str2.charAt(0));
            break;
          } 
          paramDateTimeFormatterBuilder.appendLiteral(new String(str2));
          break;
        default:
          throw new IllegalArgumentException("Illegal pattern component: " + str1);
      } 
    } 
  }
  
  private static String parseToken(String paramString, int[] paramArrayOfInt) {
    StringBuilder stringBuilder = new StringBuilder();
    int i = paramArrayOfInt[0];
    int j = paramString.length();
    char c = paramString.charAt(i);
    if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
      stringBuilder.append(c);
      while (i + 1 < j) {
        char c1 = paramString.charAt(i + 1);
        if (c1 == c) {
          stringBuilder.append(c);
          i++;
        } 
      } 
    } else {
      stringBuilder.append('\'');
      boolean bool = false;
      for (; i < j; i++) {
        c = paramString.charAt(i);
        if (c == '\'') {
          if (i + 1 < j && paramString.charAt(i + 1) == '\'') {
            i++;
            stringBuilder.append(c);
          } else {
            bool = !bool ? 1 : 0;
          } 
        } else {
          if (!bool && ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))) {
            i--;
            break;
          } 
          stringBuilder.append(c);
        } 
      } 
    } 
    paramArrayOfInt[0] = i;
    return stringBuilder.toString();
  }
  
  private static boolean isNumericToken(String paramString) {
    int i = paramString.length();
    if (i > 0) {
      char c = paramString.charAt(0);
      switch (c) {
        case 'C':
        case 'D':
        case 'F':
        case 'H':
        case 'K':
        case 'S':
        case 'W':
        case 'Y':
        case 'c':
        case 'd':
        case 'e':
        case 'h':
        case 'k':
        case 'm':
        case 's':
        case 'w':
        case 'x':
        case 'y':
          return true;
        case 'M':
          if (i <= 2)
            return true; 
          break;
      } 
    } 
    return false;
  }
  
  private static DateTimeFormatter createFormatterForPattern(String paramString) {
    if (paramString == null || paramString.length() == 0)
      throw new IllegalArgumentException("Invalid pattern specification"); 
    DateTimeFormatter dateTimeFormatter = (DateTimeFormatter)cPatternCache.get(paramString);
    if (dateTimeFormatter == null) {
      DateTimeFormatterBuilder dateTimeFormatterBuilder = new DateTimeFormatterBuilder();
      parsePatternTo(dateTimeFormatterBuilder, paramString);
      dateTimeFormatter = dateTimeFormatterBuilder.toFormatter();
      if (cPatternCache.size() < 500) {
        DateTimeFormatter dateTimeFormatter1 = (DateTimeFormatter)cPatternCache.putIfAbsent(paramString, dateTimeFormatter);
        if (dateTimeFormatter1 != null)
          dateTimeFormatter = dateTimeFormatter1; 
      } 
    } 
    return dateTimeFormatter;
  }
  
  private static DateTimeFormatter createFormatterForStyle(String paramString) {
    if (paramString == null || paramString.length() != 2)
      throw new IllegalArgumentException("Invalid style specification: " + paramString); 
    int i = selectStyle(paramString.charAt(0));
    int j = selectStyle(paramString.charAt(1));
    if (i == 4 && j == 4)
      throw new IllegalArgumentException("Style '--' is invalid"); 
    return createFormatterForStyleIndex(i, j);
  }
  
  private static DateTimeFormatter createFormatterForStyleIndex(int paramInt1, int paramInt2) {
    int i = (paramInt1 << 2) + paramInt1 + paramInt2;
    if (i >= cStyleCache.length())
      return createDateTimeFormatter(paramInt1, paramInt2); 
    DateTimeFormatter dateTimeFormatter = (DateTimeFormatter)cStyleCache.get(i);
    if (dateTimeFormatter == null) {
      dateTimeFormatter = createDateTimeFormatter(paramInt1, paramInt2);
      if (!cStyleCache.compareAndSet(i, null, dateTimeFormatter))
        dateTimeFormatter = (DateTimeFormatter)cStyleCache.get(i); 
    } 
    return dateTimeFormatter;
  }
  
  private static DateTimeFormatter createDateTimeFormatter(int paramInt1, int paramInt2) {
    byte b = 2;
    if (paramInt1 == 4) {
      b = 1;
    } else if (paramInt2 == 4) {
      b = 0;
    } 
    StyleFormatter styleFormatter = new StyleFormatter(paramInt1, paramInt2, b);
    return new DateTimeFormatter(styleFormatter, styleFormatter);
  }
  
  private static int selectStyle(char paramChar) {
    switch (paramChar) {
      case 'S':
        return 3;
      case 'M':
        return 2;
      case 'L':
        return 1;
      case 'F':
        return 0;
      case '-':
        return 4;
    } 
    throw new IllegalArgumentException("Invalid style character: " + paramChar);
  }
}
