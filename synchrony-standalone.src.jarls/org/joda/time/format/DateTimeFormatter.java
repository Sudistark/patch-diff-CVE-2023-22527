package org.joda.time.format;

import java.io.IOException;
import java.io.Writer;
import java.util.Locale;
import org.joda.time.Chronology;
import org.joda.time.DateTime;
import org.joda.time.DateTimeUtils;
import org.joda.time.DateTimeZone;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import org.joda.time.LocalTime;
import org.joda.time.MutableDateTime;
import org.joda.time.ReadWritableInstant;
import org.joda.time.ReadableInstant;
import org.joda.time.ReadablePartial;

public class DateTimeFormatter {
  private final InternalPrinter iPrinter;
  
  private final InternalParser iParser;
  
  private final Locale iLocale;
  
  private final boolean iOffsetParsed;
  
  private final Chronology iChrono;
  
  private final DateTimeZone iZone;
  
  private final Integer iPivotYear;
  
  private final int iDefaultYear;
  
  public DateTimeFormatter(DateTimePrinter paramDateTimePrinter, DateTimeParser paramDateTimeParser) { this(DateTimePrinterInternalPrinter.of(paramDateTimePrinter), DateTimeParserInternalParser.of(paramDateTimeParser)); }
  
  DateTimeFormatter(InternalPrinter paramInternalPrinter, InternalParser paramInternalParser) {
    this.iPrinter = paramInternalPrinter;
    this.iParser = paramInternalParser;
    this.iLocale = null;
    this.iOffsetParsed = false;
    this.iChrono = null;
    this.iZone = null;
    this.iPivotYear = null;
    this.iDefaultYear = 2000;
  }
  
  private DateTimeFormatter(InternalPrinter paramInternalPrinter, InternalParser paramInternalParser, Locale paramLocale, boolean paramBoolean, Chronology paramChronology, DateTimeZone paramDateTimeZone, Integer paramInteger, int paramInt) {
    this.iPrinter = paramInternalPrinter;
    this.iParser = paramInternalParser;
    this.iLocale = paramLocale;
    this.iOffsetParsed = paramBoolean;
    this.iChrono = paramChronology;
    this.iZone = paramDateTimeZone;
    this.iPivotYear = paramInteger;
    this.iDefaultYear = paramInt;
  }
  
  public boolean isPrinter() { return (this.iPrinter != null); }
  
  public DateTimePrinter getPrinter() { return InternalPrinterDateTimePrinter.of(this.iPrinter); }
  
  InternalPrinter getPrinter0() { return this.iPrinter; }
  
  public boolean isParser() { return (this.iParser != null); }
  
  public DateTimeParser getParser() { return InternalParserDateTimeParser.of(this.iParser); }
  
  InternalParser getParser0() { return this.iParser; }
  
  public DateTimeFormatter withLocale(Locale paramLocale) {
    if (paramLocale == getLocale() || (paramLocale != null && paramLocale.equals(getLocale())))
      return this; 
    return new DateTimeFormatter(this.iPrinter, this.iParser, paramLocale, this.iOffsetParsed, this.iChrono, this.iZone, this.iPivotYear, this.iDefaultYear);
  }
  
  public Locale getLocale() { return this.iLocale; }
  
  public DateTimeFormatter withOffsetParsed() {
    if (this.iOffsetParsed == true)
      return this; 
    return new DateTimeFormatter(this.iPrinter, this.iParser, this.iLocale, true, this.iChrono, null, this.iPivotYear, this.iDefaultYear);
  }
  
  public boolean isOffsetParsed() { return this.iOffsetParsed; }
  
  public DateTimeFormatter withChronology(Chronology paramChronology) {
    if (this.iChrono == paramChronology)
      return this; 
    return new DateTimeFormatter(this.iPrinter, this.iParser, this.iLocale, this.iOffsetParsed, paramChronology, this.iZone, this.iPivotYear, this.iDefaultYear);
  }
  
  public Chronology getChronology() { return this.iChrono; }
  
  @Deprecated
  public Chronology getChronolgy() { return this.iChrono; }
  
  public DateTimeFormatter withZoneUTC() { return withZone(DateTimeZone.UTC); }
  
  public DateTimeFormatter withZone(DateTimeZone paramDateTimeZone) {
    if (this.iZone == paramDateTimeZone)
      return this; 
    return new DateTimeFormatter(this.iPrinter, this.iParser, this.iLocale, false, this.iChrono, paramDateTimeZone, this.iPivotYear, this.iDefaultYear);
  }
  
  public DateTimeZone getZone() { return this.iZone; }
  
  public DateTimeFormatter withPivotYear(Integer paramInteger) {
    if (this.iPivotYear == paramInteger || (this.iPivotYear != null && this.iPivotYear.equals(paramInteger)))
      return this; 
    return new DateTimeFormatter(this.iPrinter, this.iParser, this.iLocale, this.iOffsetParsed, this.iChrono, this.iZone, paramInteger, this.iDefaultYear);
  }
  
  public DateTimeFormatter withPivotYear(int paramInt) { return withPivotYear(Integer.valueOf(paramInt)); }
  
  public Integer getPivotYear() { return this.iPivotYear; }
  
  public DateTimeFormatter withDefaultYear(int paramInt) { return new DateTimeFormatter(this.iPrinter, this.iParser, this.iLocale, this.iOffsetParsed, this.iChrono, this.iZone, this.iPivotYear, paramInt); }
  
  public int getDefaultYear() { return this.iDefaultYear; }
  
  public void printTo(StringBuffer paramStringBuffer, ReadableInstant paramReadableInstant) {
    try {
      printTo(paramStringBuffer, paramReadableInstant);
    } catch (IOException iOException) {}
  }
  
  public void printTo(StringBuilder paramStringBuilder, ReadableInstant paramReadableInstant) {
    try {
      printTo(paramStringBuilder, paramReadableInstant);
    } catch (IOException iOException) {}
  }
  
  public void printTo(Writer paramWriter, ReadableInstant paramReadableInstant) throws IOException { printTo(paramWriter, paramReadableInstant); }
  
  public void printTo(Appendable paramAppendable, ReadableInstant paramReadableInstant) throws IOException {
    long l = DateTimeUtils.getInstantMillis(paramReadableInstant);
    Chronology chronology = DateTimeUtils.getInstantChronology(paramReadableInstant);
    printTo(paramAppendable, l, chronology);
  }
  
  public void printTo(StringBuffer paramStringBuffer, long paramLong) {
    try {
      printTo(paramStringBuffer, paramLong);
    } catch (IOException iOException) {}
  }
  
  public void printTo(StringBuilder paramStringBuilder, long paramLong) {
    try {
      printTo(paramStringBuilder, paramLong);
    } catch (IOException iOException) {}
  }
  
  public void printTo(Writer paramWriter, long paramLong) throws IOException { printTo(paramWriter, paramLong); }
  
  public void printTo(Appendable paramAppendable, long paramLong) throws IOException { printTo(paramAppendable, paramLong, null); }
  
  public void printTo(StringBuffer paramStringBuffer, ReadablePartial paramReadablePartial) {
    try {
      printTo(paramStringBuffer, paramReadablePartial);
    } catch (IOException iOException) {}
  }
  
  public void printTo(StringBuilder paramStringBuilder, ReadablePartial paramReadablePartial) {
    try {
      printTo(paramStringBuilder, paramReadablePartial);
    } catch (IOException iOException) {}
  }
  
  public void printTo(Writer paramWriter, ReadablePartial paramReadablePartial) throws IOException { printTo(paramWriter, paramReadablePartial); }
  
  public void printTo(Appendable paramAppendable, ReadablePartial paramReadablePartial) throws IOException {
    InternalPrinter internalPrinter = requirePrinter();
    if (paramReadablePartial == null)
      throw new IllegalArgumentException("The partial must not be null"); 
    internalPrinter.printTo(paramAppendable, paramReadablePartial, this.iLocale);
  }
  
  public String print(ReadableInstant paramReadableInstant) {
    StringBuilder stringBuilder = new StringBuilder(requirePrinter().estimatePrintedLength());
    try {
      printTo(stringBuilder, paramReadableInstant);
    } catch (IOException iOException) {}
    return stringBuilder.toString();
  }
  
  public String print(long paramLong) {
    StringBuilder stringBuilder = new StringBuilder(requirePrinter().estimatePrintedLength());
    try {
      printTo(stringBuilder, paramLong);
    } catch (IOException iOException) {}
    return stringBuilder.toString();
  }
  
  public String print(ReadablePartial paramReadablePartial) {
    StringBuilder stringBuilder = new StringBuilder(requirePrinter().estimatePrintedLength());
    try {
      printTo(stringBuilder, paramReadablePartial);
    } catch (IOException iOException) {}
    return stringBuilder.toString();
  }
  
  private void printTo(Appendable paramAppendable, long paramLong, Chronology paramChronology) throws IOException {
    InternalPrinter internalPrinter = requirePrinter();
    paramChronology = selectChronology(paramChronology);
    DateTimeZone dateTimeZone = paramChronology.getZone();
    int i = dateTimeZone.getOffset(paramLong);
    long l = paramLong + i;
    if ((paramLong ^ l) < 0L && (paramLong ^ i) >= 0L) {
      dateTimeZone = DateTimeZone.UTC;
      i = 0;
      l = paramLong;
    } 
    internalPrinter.printTo(paramAppendable, l, paramChronology.withUTC(), i, dateTimeZone, this.iLocale);
  }
  
  private InternalPrinter requirePrinter() {
    InternalPrinter internalPrinter = this.iPrinter;
    if (internalPrinter == null)
      throw new UnsupportedOperationException("Printing not supported"); 
    return internalPrinter;
  }
  
  public int parseInto(ReadWritableInstant paramReadWritableInstant, String paramString, int paramInt) {
    InternalParser internalParser = requireParser();
    if (paramReadWritableInstant == null)
      throw new IllegalArgumentException("Instant must not be null"); 
    long l1 = paramReadWritableInstant.getMillis();
    Chronology chronology = paramReadWritableInstant.getChronology();
    int i = DateTimeUtils.getChronology(chronology).year().get(l1);
    long l2 = l1 + chronology.getZone().getOffset(l1);
    chronology = selectChronology(chronology);
    DateTimeParserBucket dateTimeParserBucket = new DateTimeParserBucket(l2, chronology, this.iLocale, this.iPivotYear, i);
    int j = internalParser.parseInto(dateTimeParserBucket, paramString, paramInt);
    paramReadWritableInstant.setMillis(dateTimeParserBucket.computeMillis(false, paramString));
    if (this.iOffsetParsed && dateTimeParserBucket.getOffsetInteger() != null) {
      int k = dateTimeParserBucket.getOffsetInteger().intValue();
      DateTimeZone dateTimeZone = DateTimeZone.forOffsetMillis(k);
      chronology = chronology.withZone(dateTimeZone);
    } else if (dateTimeParserBucket.getZone() != null) {
      chronology = chronology.withZone(dateTimeParserBucket.getZone());
    } 
    paramReadWritableInstant.setChronology(chronology);
    if (this.iZone != null)
      paramReadWritableInstant.setZone(this.iZone); 
    return j;
  }
  
  public long parseMillis(String paramString) {
    InternalParser internalParser = requireParser();
    Chronology chronology = selectChronology(this.iChrono);
    DateTimeParserBucket dateTimeParserBucket = new DateTimeParserBucket(0L, chronology, this.iLocale, this.iPivotYear, this.iDefaultYear);
    return dateTimeParserBucket.doParseMillis(internalParser, paramString);
  }
  
  public LocalDate parseLocalDate(String paramString) { return parseLocalDateTime(paramString).toLocalDate(); }
  
  public LocalTime parseLocalTime(String paramString) { return parseLocalDateTime(paramString).toLocalTime(); }
  
  public LocalDateTime parseLocalDateTime(String paramString) {
    InternalParser internalParser = requireParser();
    Chronology chronology = selectChronology(null).withUTC();
    DateTimeParserBucket dateTimeParserBucket = new DateTimeParserBucket(0L, chronology, this.iLocale, this.iPivotYear, this.iDefaultYear);
    int i = internalParser.parseInto(dateTimeParserBucket, paramString, 0);
    if (i >= 0) {
      if (i >= paramString.length()) {
        long l = dateTimeParserBucket.computeMillis(true, paramString);
        if (dateTimeParserBucket.getOffsetInteger() != null) {
          int j = dateTimeParserBucket.getOffsetInteger().intValue();
          DateTimeZone dateTimeZone = DateTimeZone.forOffsetMillis(j);
          chronology = chronology.withZone(dateTimeZone);
        } else if (dateTimeParserBucket.getZone() != null) {
          chronology = chronology.withZone(dateTimeParserBucket.getZone());
        } 
        return new LocalDateTime(l, chronology);
      } 
    } else {
      i ^= 0xFFFFFFFF;
    } 
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(paramString, i));
  }
  
  public DateTime parseDateTime(String paramString) {
    InternalParser internalParser = requireParser();
    Chronology chronology = selectChronology(null);
    DateTimeParserBucket dateTimeParserBucket = new DateTimeParserBucket(0L, chronology, this.iLocale, this.iPivotYear, this.iDefaultYear);
    int i = internalParser.parseInto(dateTimeParserBucket, paramString, 0);
    if (i >= 0) {
      if (i >= paramString.length()) {
        long l = dateTimeParserBucket.computeMillis(true, paramString);
        if (this.iOffsetParsed && dateTimeParserBucket.getOffsetInteger() != null) {
          int j = dateTimeParserBucket.getOffsetInteger().intValue();
          DateTimeZone dateTimeZone = DateTimeZone.forOffsetMillis(j);
          chronology = chronology.withZone(dateTimeZone);
        } else if (dateTimeParserBucket.getZone() != null) {
          chronology = chronology.withZone(dateTimeParserBucket.getZone());
        } 
        DateTime dateTime = new DateTime(l, chronology);
        if (this.iZone != null)
          dateTime = dateTime.withZone(this.iZone); 
        return dateTime;
      } 
    } else {
      i ^= 0xFFFFFFFF;
    } 
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(paramString, i));
  }
  
  public MutableDateTime parseMutableDateTime(String paramString) {
    InternalParser internalParser = requireParser();
    Chronology chronology = selectChronology(null);
    DateTimeParserBucket dateTimeParserBucket = new DateTimeParserBucket(0L, chronology, this.iLocale, this.iPivotYear, this.iDefaultYear);
    int i = internalParser.parseInto(dateTimeParserBucket, paramString, 0);
    if (i >= 0) {
      if (i >= paramString.length()) {
        long l = dateTimeParserBucket.computeMillis(true, paramString);
        if (this.iOffsetParsed && dateTimeParserBucket.getOffsetInteger() != null) {
          int j = dateTimeParserBucket.getOffsetInteger().intValue();
          DateTimeZone dateTimeZone = DateTimeZone.forOffsetMillis(j);
          chronology = chronology.withZone(dateTimeZone);
        } else if (dateTimeParserBucket.getZone() != null) {
          chronology = chronology.withZone(dateTimeParserBucket.getZone());
        } 
        MutableDateTime mutableDateTime = new MutableDateTime(l, chronology);
        if (this.iZone != null)
          mutableDateTime.setZone(this.iZone); 
        return mutableDateTime;
      } 
    } else {
      i ^= 0xFFFFFFFF;
    } 
    throw new IllegalArgumentException(FormatUtils.createErrorMessage(paramString, i));
  }
  
  private InternalParser requireParser() {
    InternalParser internalParser = this.iParser;
    if (internalParser == null)
      throw new UnsupportedOperationException("Parsing not supported"); 
    return internalParser;
  }
  
  private Chronology selectChronology(Chronology paramChronology) {
    paramChronology = DateTimeUtils.getChronology(paramChronology);
    if (this.iChrono != null)
      paramChronology = this.iChrono; 
    if (this.iZone != null)
      paramChronology = paramChronology.withZone(this.iZone); 
    return paramChronology;
  }
}
