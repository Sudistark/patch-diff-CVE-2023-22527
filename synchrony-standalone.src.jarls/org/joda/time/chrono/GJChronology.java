package org.joda.time.chrono;

import java.util.concurrent.ConcurrentHashMap;
import org.joda.time.Chronology;
import org.joda.time.DateTimeUtils;
import org.joda.time.DateTimeZone;
import org.joda.time.IllegalFieldValueException;
import org.joda.time.Instant;
import org.joda.time.LocalDate;
import org.joda.time.ReadableInstant;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.ISODateTimeFormat;

public final class GJChronology extends AssembledChronology {
  private static final long serialVersionUID = -2545574827706931671L;
  
  private static long convertByYear(long paramLong, Chronology paramChronology1, Chronology paramChronology2) {
    return paramChronology2
      .getDateTimeMillis(paramChronology1.year().get(paramLong), paramChronology1
        .monthOfYear().get(paramLong), paramChronology1
        .dayOfMonth().get(paramLong), paramChronology1
        .millisOfDay().get(paramLong));
  }
  
  private static long convertByWeekyear(long paramLong, Chronology paramChronology1, Chronology paramChronology2) {
    null = paramChronology2.weekyear().set(0L, paramChronology1.weekyear().get(paramLong));
    null = paramChronology2.weekOfWeekyear().set(null, paramChronology1.weekOfWeekyear().get(paramLong));
    null = paramChronology2.dayOfWeek().set(null, paramChronology1.dayOfWeek().get(paramLong));
    return paramChronology2.millisOfDay().set(null, paramChronology1.millisOfDay().get(paramLong));
  }
  
  static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L);
  
  private static final ConcurrentHashMap<GJCacheKey, GJChronology> cCache = new ConcurrentHashMap();
  
  private JulianChronology iJulianChronology;
  
  private GregorianChronology iGregorianChronology;
  
  private Instant iCutoverInstant;
  
  private long iCutoverMillis;
  
  private long iGapDuration;
  
  public static GJChronology getInstanceUTC() { return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4); }
  
  public static GJChronology getInstance() { return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, 4); }
  
  public static GJChronology getInstance(DateTimeZone paramDateTimeZone) { return getInstance(paramDateTimeZone, DEFAULT_CUTOVER, 4); }
  
  public static GJChronology getInstance(DateTimeZone paramDateTimeZone, ReadableInstant paramReadableInstant) { return getInstance(paramDateTimeZone, paramReadableInstant, 4); }
  
  public static GJChronology getInstance(DateTimeZone paramDateTimeZone, ReadableInstant paramReadableInstant, int paramInt) {
    Instant instant;
    paramDateTimeZone = DateTimeUtils.getZone(paramDateTimeZone);
    if (paramReadableInstant == null) {
      instant = DEFAULT_CUTOVER;
    } else {
      instant = paramReadableInstant.toInstant();
      LocalDate localDate = new LocalDate(instant.getMillis(), GregorianChronology.getInstance(paramDateTimeZone));
      if (localDate.getYear() <= 0)
        throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); 
    } 
    GJCacheKey gJCacheKey = new GJCacheKey(paramDateTimeZone, instant, paramInt);
    GJChronology gJChronology = (GJChronology)cCache.get(gJCacheKey);
    if (gJChronology == null) {
      if (paramDateTimeZone == DateTimeZone.UTC) {
        gJChronology = new GJChronology(JulianChronology.getInstance(paramDateTimeZone, paramInt), GregorianChronology.getInstance(paramDateTimeZone, paramInt), instant);
      } else {
        gJChronology = getInstance(DateTimeZone.UTC, instant, paramInt);
        gJChronology = new GJChronology(ZonedChronology.getInstance(gJChronology, paramDateTimeZone), gJChronology.iJulianChronology, gJChronology.iGregorianChronology, gJChronology.iCutoverInstant);
      } 
      GJChronology gJChronology1 = (GJChronology)cCache.putIfAbsent(gJCacheKey, gJChronology);
      if (gJChronology1 != null)
        gJChronology = gJChronology1; 
    } 
    return gJChronology;
  }
  
  public static GJChronology getInstance(DateTimeZone paramDateTimeZone, long paramLong, int paramInt) {
    Instant instant;
    if (paramLong == DEFAULT_CUTOVER.getMillis()) {
      instant = null;
    } else {
      instant = new Instant(paramLong);
    } 
    return getInstance(paramDateTimeZone, instant, paramInt);
  }
  
  private GJChronology(JulianChronology paramJulianChronology, GregorianChronology paramGregorianChronology, Instant paramInstant) { super(null, new Object[] { paramJulianChronology, paramGregorianChronology, paramInstant }); }
  
  private GJChronology(Chronology paramChronology, JulianChronology paramJulianChronology, GregorianChronology paramGregorianChronology, Instant paramInstant) { super(paramChronology, new Object[] { paramJulianChronology, paramGregorianChronology, paramInstant }); }
  
  private Object readResolve() { return getInstance(getZone(), this.iCutoverInstant, getMinimumDaysInFirstWeek()); }
  
  public DateTimeZone getZone() {
    Chronology chronology;
    if ((chronology = getBase()) != null)
      return chronology.getZone(); 
    return DateTimeZone.UTC;
  }
  
  public Chronology withUTC() { return withZone(DateTimeZone.UTC); }
  
  public Chronology withZone(DateTimeZone paramDateTimeZone) {
    if (paramDateTimeZone == null)
      paramDateTimeZone = DateTimeZone.getDefault(); 
    if (paramDateTimeZone == getZone())
      return this; 
    return getInstance(paramDateTimeZone, this.iCutoverInstant, getMinimumDaysInFirstWeek());
  }
  
  public long getDateTimeMillis(int paramInt1, int paramInt2, int paramInt3, int paramInt4) throws IllegalArgumentException {
    Chronology chronology;
    if ((chronology = getBase()) != null)
      return chronology.getDateTimeMillis(paramInt1, paramInt2, paramInt3, paramInt4); 
    long l = this.iGregorianChronology.getDateTimeMillis(paramInt1, paramInt2, paramInt3, paramInt4);
    if (l < this.iCutoverMillis) {
      l = this.iJulianChronology.getDateTimeMillis(paramInt1, paramInt2, paramInt3, paramInt4);
      if (l >= this.iCutoverMillis)
        throw new IllegalArgumentException("Specified date does not exist"); 
    } 
    return l;
  }
  
  public long getDateTimeMillis(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6, int paramInt7) throws IllegalArgumentException {
    long l;
    Chronology chronology;
    if ((chronology = getBase()) != null)
      return chronology
        .getDateTimeMillis(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7); 
    try {
      l = this.iGregorianChronology.getDateTimeMillis(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7);
    } catch (IllegalFieldValueException illegalFieldValueException) {
      if (paramInt2 != 2 || paramInt3 != 29)
        throw illegalFieldValueException; 
      l = this.iGregorianChronology.getDateTimeMillis(paramInt1, paramInt2, 28, paramInt4, paramInt5, paramInt6, paramInt7);
      if (l >= this.iCutoverMillis)
        throw illegalFieldValueException; 
    } 
    if (l < this.iCutoverMillis) {
      l = this.iJulianChronology.getDateTimeMillis(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5, paramInt6, paramInt7);
      if (l >= this.iCutoverMillis)
        throw new IllegalArgumentException("Specified date does not exist"); 
    } 
    return l;
  }
  
  public Instant getGregorianCutover() { return this.iCutoverInstant; }
  
  public int getMinimumDaysInFirstWeek() { return this.iGregorianChronology.getMinimumDaysInFirstWeek(); }
  
  public boolean equals(Object paramObject) {
    if (this == paramObject)
      return true; 
    if (paramObject instanceof GJChronology) {
      GJChronology gJChronology = (GJChronology)paramObject;
      return (this.iCutoverMillis == gJChronology.iCutoverMillis && 
        getMinimumDaysInFirstWeek() == gJChronology.getMinimumDaysInFirstWeek() && 
        getZone().equals(gJChronology.getZone()));
    } 
    return false;
  }
  
  public int hashCode() { return "GJ".hashCode() * 11 + getZone().hashCode() + 
      getMinimumDaysInFirstWeek() + this.iCutoverInstant.hashCode(); }
  
  public String toString() {
    StringBuffer stringBuffer = new StringBuffer(60);
    stringBuffer.append("GJChronology");
    stringBuffer.append('[');
    stringBuffer.append(getZone().getID());
    if (this.iCutoverMillis != DEFAULT_CUTOVER.getMillis()) {
      DateTimeFormatter dateTimeFormatter;
      stringBuffer.append(",cutover=");
      if (withUTC().dayOfYear().remainder(this.iCutoverMillis) == 0L) {
        dateTimeFormatter = ISODateTimeFormat.date();
      } else {
        dateTimeFormatter = ISODateTimeFormat.dateTime();
      } 
      dateTimeFormatter.withChronology(withUTC()).printTo(stringBuffer, this.iCutoverMillis);
    } 
    if (getMinimumDaysInFirstWeek() != 4) {
      stringBuffer.append(",mdfw=");
      stringBuffer.append(getMinimumDaysInFirstWeek());
    } 
    stringBuffer.append(']');
    return stringBuffer.toString();
  }
  
  protected void assemble(AssembledChronology.Fields paramFields) {
    Object[] arrayOfObject = (Object[])getParam();
    JulianChronology julianChronology = (JulianChronology)arrayOfObject[0];
    GregorianChronology gregorianChronology = (GregorianChronology)arrayOfObject[1];
    Instant instant = (Instant)arrayOfObject[2];
    this.iCutoverMillis = instant.getMillis();
    this.iJulianChronology = julianChronology;
    this.iGregorianChronology = gregorianChronology;
    this.iCutoverInstant = instant;
    if (getBase() != null)
      return; 
    if (julianChronology.getMinimumDaysInFirstWeek() != gregorianChronology.getMinimumDaysInFirstWeek())
      throw new IllegalArgumentException(); 
    this.iGapDuration = this.iCutoverMillis - julianToGregorianByYear(this.iCutoverMillis);
    paramFields.copyFieldsFrom(gregorianChronology);
    if (gregorianChronology.millisOfDay().get(this.iCutoverMillis) == 0) {
      paramFields.millisOfSecond = new CutoverField(this, julianChronology.millisOfSecond(), paramFields.millisOfSecond, this.iCutoverMillis);
      paramFields.millisOfDay = new CutoverField(this, julianChronology.millisOfDay(), paramFields.millisOfDay, this.iCutoverMillis);
      paramFields.secondOfMinute = new CutoverField(this, julianChronology.secondOfMinute(), paramFields.secondOfMinute, this.iCutoverMillis);
      paramFields.secondOfDay = new CutoverField(this, julianChronology.secondOfDay(), paramFields.secondOfDay, this.iCutoverMillis);
      paramFields.minuteOfHour = new CutoverField(this, julianChronology.minuteOfHour(), paramFields.minuteOfHour, this.iCutoverMillis);
      paramFields.minuteOfDay = new CutoverField(this, julianChronology.minuteOfDay(), paramFields.minuteOfDay, this.iCutoverMillis);
      paramFields.hourOfDay = new CutoverField(this, julianChronology.hourOfDay(), paramFields.hourOfDay, this.iCutoverMillis);
      paramFields.hourOfHalfday = new CutoverField(this, julianChronology.hourOfHalfday(), paramFields.hourOfHalfday, this.iCutoverMillis);
      paramFields.clockhourOfDay = new CutoverField(this, julianChronology.clockhourOfDay(), paramFields.clockhourOfDay, this.iCutoverMillis);
      paramFields.clockhourOfHalfday = new CutoverField(this, julianChronology.clockhourOfHalfday(), paramFields.clockhourOfHalfday, this.iCutoverMillis);
      paramFields.halfdayOfDay = new CutoverField(this, julianChronology.halfdayOfDay(), paramFields.halfdayOfDay, this.iCutoverMillis);
    } 
    paramFields.era = new CutoverField(this, julianChronology.era(), paramFields.era, this.iCutoverMillis);
    paramFields
      .year = new ImpreciseCutoverField(this, julianChronology.year(), paramFields.year, this.iCutoverMillis);
    paramFields.years = paramFields.year.getDurationField();
    paramFields
      .yearOfEra = new ImpreciseCutoverField(this, julianChronology.yearOfEra(), paramFields.yearOfEra, paramFields.years, this.iCutoverMillis);
    paramFields
      .centuryOfEra = new ImpreciseCutoverField(this, julianChronology.centuryOfEra(), paramFields.centuryOfEra, this.iCutoverMillis);
    paramFields.centuries = paramFields.centuryOfEra.getDurationField();
    paramFields
      .yearOfCentury = new ImpreciseCutoverField(this, julianChronology.yearOfCentury(), paramFields.yearOfCentury, paramFields.years, paramFields.centuries, this.iCutoverMillis);
    paramFields
      .monthOfYear = new ImpreciseCutoverField(this, julianChronology.monthOfYear(), paramFields.monthOfYear, null, paramFields.years, this.iCutoverMillis);
    paramFields.months = paramFields.monthOfYear.getDurationField();
    paramFields
      .weekyear = new ImpreciseCutoverField(this, julianChronology.weekyear(), paramFields.weekyear, null, this.iCutoverMillis, true);
    paramFields.weekyears = paramFields.weekyear.getDurationField();
    paramFields
      .weekyearOfCentury = new ImpreciseCutoverField(this, julianChronology.weekyearOfCentury(), paramFields.weekyearOfCentury, paramFields.weekyears, paramFields.centuries, this.iCutoverMillis);
    long l = gregorianChronology.year().roundCeiling(this.iCutoverMillis);
    paramFields
      .dayOfYear = new CutoverField(this, julianChronology.dayOfYear(), paramFields.dayOfYear, paramFields.years, l, false);
    l = gregorianChronology.weekyear().roundCeiling(this.iCutoverMillis);
    paramFields
      .weekOfWeekyear = new CutoverField(this, julianChronology.weekOfWeekyear(), paramFields.weekOfWeekyear, paramFields.weekyears, l, true);
    CutoverField cutoverField = new CutoverField(this, julianChronology.dayOfMonth(), paramFields.dayOfMonth, this.iCutoverMillis);
    cutoverField.iRangeDurationField = paramFields.months;
    paramFields.dayOfMonth = cutoverField;
  }
  
  long julianToGregorianByYear(long paramLong) { return convertByYear(paramLong, this.iJulianChronology, this.iGregorianChronology); }
  
  long gregorianToJulianByYear(long paramLong) { return convertByYear(paramLong, this.iGregorianChronology, this.iJulianChronology); }
  
  long julianToGregorianByWeekyear(long paramLong) { return convertByWeekyear(paramLong, this.iJulianChronology, this.iGregorianChronology); }
  
  long gregorianToJulianByWeekyear(long paramLong) { return convertByWeekyear(paramLong, this.iGregorianChronology, this.iJulianChronology); }
}
