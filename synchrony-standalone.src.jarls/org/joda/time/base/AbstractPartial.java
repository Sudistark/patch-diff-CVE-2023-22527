package org.joda.time.base;

import org.joda.time.Chronology;
import org.joda.time.DateTime;
import org.joda.time.DateTimeField;
import org.joda.time.DateTimeFieldType;
import org.joda.time.DateTimeUtils;
import org.joda.time.DurationFieldType;
import org.joda.time.ReadableInstant;
import org.joda.time.ReadablePartial;
import org.joda.time.field.FieldUtils;
import org.joda.time.format.DateTimeFormatter;

public abstract class AbstractPartial extends Object implements ReadablePartial, Comparable<ReadablePartial> {
  public DateTimeFieldType getFieldType(int paramInt) { return getField(paramInt, getChronology()).getType(); }
  
  public DateTimeFieldType[] getFieldTypes() {
    DateTimeFieldType[] arrayOfDateTimeFieldType = new DateTimeFieldType[size()];
    for (byte b = 0; b < arrayOfDateTimeFieldType.length; b++)
      arrayOfDateTimeFieldType[b] = getFieldType(b); 
    return arrayOfDateTimeFieldType;
  }
  
  public DateTimeField getField(int paramInt) { return getField(paramInt, getChronology()); }
  
  public DateTimeField[] getFields() {
    DateTimeField[] arrayOfDateTimeField = new DateTimeField[size()];
    for (byte b = 0; b < arrayOfDateTimeField.length; b++)
      arrayOfDateTimeField[b] = getField(b); 
    return arrayOfDateTimeField;
  }
  
  public int[] getValues() {
    int[] arrayOfInt = new int[size()];
    for (byte b = 0; b < arrayOfInt.length; b++)
      arrayOfInt[b] = getValue(b); 
    return arrayOfInt;
  }
  
  public int get(DateTimeFieldType paramDateTimeFieldType) { return getValue(indexOfSupported(paramDateTimeFieldType)); }
  
  public boolean isSupported(DateTimeFieldType paramDateTimeFieldType) { return (indexOf(paramDateTimeFieldType) != -1); }
  
  public int indexOf(DateTimeFieldType paramDateTimeFieldType) {
    byte b;
    int i;
    for (b = 0, i = size(); b < i; b++) {
      if (getFieldType(b) == paramDateTimeFieldType)
        return b; 
    } 
    return -1;
  }
  
  protected int indexOfSupported(DateTimeFieldType paramDateTimeFieldType) {
    int i = indexOf(paramDateTimeFieldType);
    if (i == -1)
      throw new IllegalArgumentException("Field '" + paramDateTimeFieldType + "' is not supported"); 
    return i;
  }
  
  protected int indexOf(DurationFieldType paramDurationFieldType) {
    byte b;
    int i;
    for (b = 0, i = size(); b < i; b++) {
      if (getFieldType(b).getDurationType() == paramDurationFieldType)
        return b; 
    } 
    return -1;
  }
  
  protected int indexOfSupported(DurationFieldType paramDurationFieldType) {
    int i = indexOf(paramDurationFieldType);
    if (i == -1)
      throw new IllegalArgumentException("Field '" + paramDurationFieldType + "' is not supported"); 
    return i;
  }
  
  public DateTime toDateTime(ReadableInstant paramReadableInstant) {
    Chronology chronology = DateTimeUtils.getInstantChronology(paramReadableInstant);
    long l1 = DateTimeUtils.getInstantMillis(paramReadableInstant);
    long l2 = chronology.set(this, l1);
    return new DateTime(l2, chronology);
  }
  
  public boolean equals(Object paramObject) {
    if (this == paramObject)
      return true; 
    if (!(paramObject instanceof ReadablePartial))
      return false; 
    ReadablePartial readablePartial = (ReadablePartial)paramObject;
    if (size() != readablePartial.size())
      return false; 
    byte b;
    int i;
    for (b = 0, i = size(); b < i; b++) {
      if (getValue(b) != readablePartial.getValue(b) || getFieldType(b) != readablePartial.getFieldType(b))
        return false; 
    } 
    return FieldUtils.equals(getChronology(), readablePartial.getChronology());
  }
  
  public int hashCode() {
    null = 157;
    byte b;
    int i;
    for (b = 0, i = size(); b < i; b++) {
      null = '\027' * null + getValue(b);
      null = 23 * null + getFieldType(b).hashCode();
    } 
    return getChronology().hashCode();
  }
  
  public int compareTo(ReadablePartial paramReadablePartial) {
    if (this == paramReadablePartial)
      return 0; 
    if (size() != paramReadablePartial.size())
      throw new ClassCastException("ReadablePartial objects must have matching field types"); 
    byte b;
    int i;
    for (b = 0, i = size(); b < i; b++) {
      if (getFieldType(b) != paramReadablePartial.getFieldType(b))
        throw new ClassCastException("ReadablePartial objects must have matching field types"); 
    } 
    for (b = 0, i = size(); b < i; b++) {
      if (getValue(b) > paramReadablePartial.getValue(b))
        return 1; 
      if (getValue(b) < paramReadablePartial.getValue(b))
        return -1; 
    } 
    return 0;
  }
  
  public boolean isAfter(ReadablePartial paramReadablePartial) {
    if (paramReadablePartial == null)
      throw new IllegalArgumentException("Partial cannot be null"); 
    return (compareTo(paramReadablePartial) > 0);
  }
  
  public boolean isBefore(ReadablePartial paramReadablePartial) {
    if (paramReadablePartial == null)
      throw new IllegalArgumentException("Partial cannot be null"); 
    return (compareTo(paramReadablePartial) < 0);
  }
  
  public boolean isEqual(ReadablePartial paramReadablePartial) {
    if (paramReadablePartial == null)
      throw new IllegalArgumentException("Partial cannot be null"); 
    return (compareTo(paramReadablePartial) == 0);
  }
  
  public String toString(DateTimeFormatter paramDateTimeFormatter) {
    if (paramDateTimeFormatter == null)
      return toString(); 
    return paramDateTimeFormatter.print(this);
  }
  
  protected abstract DateTimeField getField(int paramInt, Chronology paramChronology);
}
