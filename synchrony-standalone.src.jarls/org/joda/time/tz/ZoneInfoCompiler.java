package org.joda.time.tz;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.TreeMap;
import org.joda.time.Chronology;
import org.joda.time.DateTime;
import org.joda.time.DateTimeField;
import org.joda.time.DateTimeZone;
import org.joda.time.MutableDateTime;
import org.joda.time.chrono.ISOChronology;
import org.joda.time.chrono.LenientChronology;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.ISODateTimeFormat;

public class ZoneInfoCompiler {
  static DateTimeOfYear cStartOfYear;
  
  static Chronology cLenientISO;
  
  public static void main(String[] paramArrayOfString) throws Exception {
    if (paramArrayOfString.length == 0) {
      printUsage();
      return;
    } 
    File file1 = null;
    File file2 = null;
    boolean bool = false;
    int i;
    for (i = 0; i < paramArrayOfString.length; i++) {
      try {
        if ("-src".equals(paramArrayOfString[i])) {
          file1 = new File(paramArrayOfString[++i]);
        } else if ("-dst".equals(paramArrayOfString[i])) {
          file2 = new File(paramArrayOfString[++i]);
        } else if ("-verbose".equals(paramArrayOfString[i])) {
          bool = true;
        } else {
          if ("-?".equals(paramArrayOfString[i])) {
            printUsage();
            return;
          } 
          break;
        } 
      } catch (IndexOutOfBoundsException indexOutOfBoundsException) {
        printUsage();
        return;
      } 
    } 
    if (i >= paramArrayOfString.length) {
      printUsage();
      return;
    } 
    File[] arrayOfFile = new File[paramArrayOfString.length - i];
    for (byte b = 0; i < paramArrayOfString.length; i++, b++)
      arrayOfFile[b] = (file1 == null) ? new File(paramArrayOfString[i]) : new File(file1, paramArrayOfString[i]); 
    ZoneInfoLogger.set(bool);
    ZoneInfoCompiler zoneInfoCompiler = new ZoneInfoCompiler();
    zoneInfoCompiler.compile(file2, arrayOfFile);
  }
  
  private static void printUsage() {
    System.out.println("Usage: java org.joda.time.tz.ZoneInfoCompiler <options> <source files>");
    System.out.println("where possible options include:");
    System.out.println("  -src <directory>    Specify where to read source files");
    System.out.println("  -dst <directory>    Specify where to write generated files");
    System.out.println("  -verbose            Output verbosely (default false)");
  }
  
  static DateTimeOfYear getStartOfYear() {
    if (cStartOfYear == null)
      cStartOfYear = new DateTimeOfYear(); 
    return cStartOfYear;
  }
  
  static Chronology getLenientISOChronology() {
    if (cLenientISO == null)
      cLenientISO = LenientChronology.getInstance(ISOChronology.getInstanceUTC()); 
    return cLenientISO;
  }
  
  static void writeZoneInfoMap(DataOutputStream paramDataOutputStream, Map<String, DateTimeZone> paramMap) throws IOException {
    if (paramDataOutputStream == null)
      throw new IllegalArgumentException("DataOutputStream must not be null."); 
    HashMap hashMap = new HashMap(paramMap.size());
    TreeMap treeMap = new TreeMap();
    short s = 0;
    for (Map.Entry entry : paramMap.entrySet()) {
      String str = (String)entry.getKey();
      if (!hashMap.containsKey(str)) {
        Short short = Short.valueOf(s);
        hashMap.put(str, short);
        treeMap.put(short, str);
        s = (short)(s + 1);
        if (s == 0)
          throw new InternalError("Too many time zone ids"); 
      } 
      str = ((DateTimeZone)entry.getValue()).getID();
      if (!hashMap.containsKey(str)) {
        Short short = Short.valueOf(s);
        hashMap.put(str, short);
        treeMap.put(short, str);
        s = (short)(s + 1);
        if (s == 0)
          throw new InternalError("Too many time zone ids"); 
      } 
    } 
    paramDataOutputStream.writeShort(treeMap.size());
    for (String str : treeMap.values())
      paramDataOutputStream.writeUTF(str); 
    paramDataOutputStream.writeShort(paramMap.size());
    for (Map.Entry entry : paramMap.entrySet()) {
      String str = (String)entry.getKey();
      paramDataOutputStream.writeShort(((Short)hashMap.get(str)).shortValue());
      str = ((DateTimeZone)entry.getValue()).getID();
      paramDataOutputStream.writeShort(((Short)hashMap.get(str)).shortValue());
    } 
  }
  
  static int parseYear(String paramString, int paramInt) {
    paramString = paramString.toLowerCase(Locale.ENGLISH);
    if (paramString.equals("minimum") || paramString.equals("min"))
      return Integer.MIN_VALUE; 
    if (paramString.equals("maximum") || paramString.equals("max"))
      return Integer.MAX_VALUE; 
    if (paramString.equals("only"))
      return paramInt; 
    return Integer.parseInt(paramString);
  }
  
  static int parseMonth(String paramString) {
    DateTimeField dateTimeField = ISOChronology.getInstanceUTC().monthOfYear();
    return dateTimeField.get(dateTimeField.set(0L, paramString, Locale.ENGLISH));
  }
  
  static int parseDayOfWeek(String paramString) {
    DateTimeField dateTimeField = ISOChronology.getInstanceUTC().dayOfWeek();
    return dateTimeField.get(dateTimeField.set(0L, paramString, Locale.ENGLISH));
  }
  
  static String parseOptional(String paramString) { return paramString.equals("-") ? null : paramString; }
  
  static int parseTime(String paramString) {
    DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.hourMinuteSecondFraction();
    MutableDateTime mutableDateTime = new MutableDateTime(0L, getLenientISOChronology());
    byte b = 0;
    if (paramString.startsWith("-"))
      b = 1; 
    int i = dateTimeFormatter.parseInto(mutableDateTime, paramString, b);
    if (i == (b ^ 0xFFFFFFFF))
      throw new IllegalArgumentException(paramString); 
    int j = (int)mutableDateTime.getMillis();
    if (b == 1)
      j = -j; 
    return j;
  }
  
  static char parseZoneChar(char paramChar) {
    switch (paramChar) {
      case 'S':
      case 's':
        return 's';
      case 'G':
      case 'U':
      case 'Z':
      case 'g':
      case 'u':
      case 'z':
        return 'u';
    } 
    return 'w';
  }
  
  static boolean test(String paramString, DateTimeZone paramDateTimeZone) {
    if (!paramString.equals(paramDateTimeZone.getID()))
      return true; 
    long l1 = ISOChronology.getInstanceUTC().year().set(0L, 1850);
    long l2 = ISOChronology.getInstanceUTC().year().set(0L, 2050);
    int i = paramDateTimeZone.getOffset(l1);
    int j = paramDateTimeZone.getStandardOffset(l1);
    String str = paramDateTimeZone.getNameKey(l1);
    ArrayList arrayList = new ArrayList();
    while (true) {
      long l = paramDateTimeZone.nextTransition(l1);
      if (l == l1 || l > l2)
        break; 
      l1 = l;
      int m = paramDateTimeZone.getOffset(l1);
      int n = paramDateTimeZone.getStandardOffset(l1);
      String str1 = paramDateTimeZone.getNameKey(l1);
      if (i == m && j == n && str.equals(str1)) {
        System.out.println("*d* Error in " + paramDateTimeZone.getID() + " " + new DateTime(l1, 
              
              ISOChronology.getInstanceUTC()));
        return false;
      } 
      if (str1 == null || (str1.length() < 3 && !"??".equals(str1))) {
        System.out.println("*s* Error in " + paramDateTimeZone.getID() + " " + new DateTime(l1, 
              
              ISOChronology.getInstanceUTC()) + ", nameKey=" + str1);
        return false;
      } 
      arrayList.add(Long.valueOf(l1));
      i = m;
      str = str1;
    } 
    l1 = ISOChronology.getInstanceUTC().year().set(0L, 2050);
    l2 = ISOChronology.getInstanceUTC().year().set(0L, 1850);
    for (int k = arrayList.size(); --k >= 0; ) {
      long l3 = paramDateTimeZone.previousTransition(l1);
      if (l3 == l1 || l3 < l2)
        break; 
      l1 = l3;
      long l4 = ((Long)arrayList.get(k)).longValue();
      if (l4 - 1L != l1) {
        System.out.println("*r* Error in " + paramDateTimeZone.getID() + " " + new DateTime(l1, 
              
              ISOChronology.getInstanceUTC()) + " != " + new DateTime(l4 - 1L, 
              
              ISOChronology.getInstanceUTC()));
        return false;
      } 
    } 
    return true;
  }
  
  private Map<String, RuleSet> iRuleSets = new HashMap();
  
  private List<Zone> iZones = new ArrayList();
  
  private List<String> iGoodLinks = new ArrayList();
  
  private List<String> iBackLinks = new ArrayList();
  
  public Map<String, DateTimeZone> compile(File paramFile, File[] paramArrayOfFile) throws IOException {
    if (paramArrayOfFile != null)
      for (byte b1 = 0; b1 < paramArrayOfFile.length; b1++)
        BufferedReader bufferedReader = null;  
    if (paramFile != null) {
      if (!paramFile.exists() && !paramFile.mkdirs())
        throw new IOException("Destination directory doesn't exist and cannot be created: " + paramFile); 
      if (!paramFile.isDirectory())
        throw new IOException("Destination is not a directory: " + paramFile); 
    } 
    TreeMap treeMap1 = new TreeMap();
    TreeMap treeMap2 = new TreeMap();
    System.out.println("Writing zoneinfo files");
    byte b;
    for (b = 0; b < this.iZones.size(); b++) {
      Zone zone = (Zone)this.iZones.get(b);
      DateTimeZoneBuilder dateTimeZoneBuilder = new DateTimeZoneBuilder();
      zone.addToBuilder(dateTimeZoneBuilder, this.iRuleSets);
      DateTimeZone dateTimeZone = dateTimeZoneBuilder.toDateTimeZone(zone.iName, true);
      if (test(dateTimeZone.getID(), dateTimeZone)) {
        treeMap1.put(dateTimeZone.getID(), dateTimeZone);
        treeMap2.put(dateTimeZone.getID(), zone);
        if (paramFile != null)
          writeZone(paramFile, dateTimeZoneBuilder, dateTimeZone); 
      } 
    } 
    for (b = 0; b < this.iGoodLinks.size(); b += 2) {
      String str1 = (String)this.iGoodLinks.get(b);
      String str2 = (String)this.iGoodLinks.get(b + 1);
      Zone zone = (Zone)treeMap2.get(str1);
      if (zone == null) {
        System.out.println("Cannot find source zone '" + str1 + "' to link alias '" + str2 + "' to");
      } else {
        DateTimeZoneBuilder dateTimeZoneBuilder = new DateTimeZoneBuilder();
        zone.addToBuilder(dateTimeZoneBuilder, this.iRuleSets);
        DateTimeZone dateTimeZone = dateTimeZoneBuilder.toDateTimeZone(str2, true);
        if (test(dateTimeZone.getID(), dateTimeZone)) {
          treeMap1.put(dateTimeZone.getID(), dateTimeZone);
          if (paramFile != null)
            writeZone(paramFile, dateTimeZoneBuilder, dateTimeZone); 
        } 
        treeMap1.put(dateTimeZone.getID(), dateTimeZone);
        if (ZoneInfoLogger.verbose())
          System.out.println("Good link: " + str2 + " -> " + str1 + " revived"); 
      } 
    } 
    for (b = 0; b < 2; b++) {
      for (byte b1 = 0; b1 < this.iBackLinks.size(); b1 += 2) {
        String str1 = (String)this.iBackLinks.get(b1);
        String str2 = (String)this.iBackLinks.get(b1 + 1);
        DateTimeZone dateTimeZone = (DateTimeZone)treeMap1.get(str1);
        if (dateTimeZone == null) {
          if (b > 0)
            System.out.println("Cannot find time zone '" + str1 + "' to link alias '" + str2 + "' to"); 
        } else {
          treeMap1.put(str2, dateTimeZone);
          if (ZoneInfoLogger.verbose())
            System.out.println("Back link: " + str2 + " -> " + dateTimeZone.getID()); 
        } 
      } 
    } 
    if (paramFile != null) {
      System.out.println("Writing ZoneInfoMap");
      File file = new File(paramFile, "ZoneInfoMap");
      if (!file.getParentFile().exists())
        file.getParentFile().mkdirs(); 
      FileOutputStream fileOutputStream = new FileOutputStream(file);
      dataOutputStream = new DataOutputStream(fileOutputStream);
      try {
        TreeMap treeMap = new TreeMap(String.CASE_INSENSITIVE_ORDER);
        treeMap.putAll(treeMap1);
        writeZoneInfoMap(dataOutputStream, treeMap);
      } finally {
        dataOutputStream.close();
      } 
    } 
    return treeMap1;
  }
  
  private void writeZone(File paramFile, DateTimeZoneBuilder paramDateTimeZoneBuilder, DateTimeZone paramDateTimeZone) throws IOException {
    if (ZoneInfoLogger.verbose())
      System.out.println("Writing " + paramDateTimeZone.getID()); 
    File file = new File(paramFile, paramDateTimeZone.getID());
    if (!file.getParentFile().exists())
      file.getParentFile().mkdirs(); 
    fileOutputStream = new FileOutputStream(file);
    try {
      paramDateTimeZoneBuilder.writeTo(paramDateTimeZone.getID(), fileOutputStream);
    } finally {
      fileOutputStream.close();
    } 
    FileInputStream fileInputStream = new FileInputStream(file);
    DateTimeZone dateTimeZone = DateTimeZoneBuilder.readFrom(fileInputStream, paramDateTimeZone.getID());
    fileInputStream.close();
    if (!paramDateTimeZone.equals(dateTimeZone))
      System.out.println("*e* Error in " + paramDateTimeZone.getID() + ": Didn't read properly from file"); 
  }
  
  public void parseDataFile(BufferedReader paramBufferedReader, boolean paramBoolean) throws IOException {
    Zone zone = null;
    String str;
    while ((str = paramBufferedReader.readLine()) != null) {
      String str1 = str.trim();
      if (str1.length() == 0 || str1.charAt(0) == '#')
        continue; 
      int i = str.indexOf('#');
      if (i >= 0)
        str = str.substring(0, i); 
      StringTokenizer stringTokenizer = new StringTokenizer(str, " \t");
      if (Character.isWhitespace(str.charAt(0)) && stringTokenizer.hasMoreTokens()) {
        if (zone != null)
          zone.chain(stringTokenizer); 
        continue;
      } 
      if (zone != null)
        this.iZones.add(zone); 
      zone = null;
      if (stringTokenizer.hasMoreTokens()) {
        String str2 = stringTokenizer.nextToken();
        if (str2.equalsIgnoreCase("Rule")) {
          Rule rule = new Rule(stringTokenizer);
          RuleSet ruleSet = (RuleSet)this.iRuleSets.get(rule.iName);
          if (ruleSet == null) {
            ruleSet = new RuleSet(rule);
            this.iRuleSets.put(rule.iName, ruleSet);
            continue;
          } 
          ruleSet.addRule(rule);
          continue;
        } 
        if (str2.equalsIgnoreCase("Zone")) {
          if (stringTokenizer.countTokens() < 4)
            throw new IllegalArgumentException("Attempting to create a Zone from an incomplete tokenizer"); 
          zone = new Zone(stringTokenizer);
          continue;
        } 
        if (str2.equalsIgnoreCase("Link")) {
          String str3 = stringTokenizer.nextToken();
          String str4 = stringTokenizer.nextToken();
          if (paramBoolean || str4.equals("US/Pacific-New") || str4.startsWith("Etc/") || str4.equals("GMT")) {
            this.iBackLinks.add(str3);
            this.iBackLinks.add(str4);
            continue;
          } 
          this.iGoodLinks.add(str3);
          this.iGoodLinks.add(str4);
          continue;
        } 
        System.out.println("Unknown line: " + str);
      } 
    } 
    if (zone != null)
      this.iZones.add(zone); 
  }
}
