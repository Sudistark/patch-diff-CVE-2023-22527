package org.joda.time.convert;

import org.joda.time.Chronology;
import org.joda.time.DateTime;
import org.joda.time.Period;
import org.joda.time.ReadWritableInterval;
import org.joda.time.ReadWritablePeriod;
import org.joda.time.ReadablePartial;
import org.joda.time.field.FieldUtils;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.ISODateTimeFormat;
import org.joda.time.format.ISOPeriodFormat;
import org.joda.time.format.PeriodFormatter;

class StringConverter extends AbstractConverter implements InstantConverter, PartialConverter, DurationConverter, PeriodConverter, IntervalConverter {
  static final StringConverter INSTANCE = new StringConverter();
  
  public long getInstantMillis(Object paramObject, Chronology paramChronology) {
    String str = (String)paramObject;
    DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.dateTimeParser();
    return dateTimeFormatter.withChronology(paramChronology).parseMillis(str);
  }
  
  public int[] getPartialValues(ReadablePartial paramReadablePartial, Object paramObject, Chronology paramChronology, DateTimeFormatter paramDateTimeFormatter) {
    if (paramDateTimeFormatter.getZone() != null)
      paramChronology = paramChronology.withZone(paramDateTimeFormatter.getZone()); 
    long l = paramDateTimeFormatter.withChronology(paramChronology).parseMillis((String)paramObject);
    return paramChronology.get(paramReadablePartial, l);
  }
  
  public long getDurationMillis(Object paramObject) {
    String str1 = (String)paramObject;
    String str2 = str1;
    int i = str2.length();
    if (i >= 4 && (str2
      .charAt(0) == 'P' || str2.charAt(0) == 'p') && (str2
      .charAt(1) == 'T' || str2.charAt(1) == 't') && (str2
      .charAt(i - 1) == 'S' || str2.charAt(i - 1) == 's')) {
      str2 = str2.substring(2, i - 1);
      byte b1 = -1;
      boolean bool = false;
      for (byte b2 = 0; b2 < str2.length(); b2++) {
        if (str2.charAt(b2) < '0' || str2.charAt(b2) > '9')
          if (b2 == 0 && str2.charAt(0) == '-') {
            bool = true;
          } else if (b2 > (bool ? 1 : 0) && str2.charAt(b2) == '.' && b1 == -1) {
            b1 = b2;
          } else {
            throw new IllegalArgumentException("Invalid format: \"" + str1 + '"');
          }  
      } 
      long l1 = 0L, l2 = 0L;
      byte b = bool ? 1 : 0;
      if (b1 > 0) {
        l2 = Long.parseLong(str2.substring(b, b1));
        str2 = str2.substring(b1 + 1);
        if (str2.length() != 3)
          str2 = (str2 + "000").substring(0, 3); 
        l1 = Integer.parseInt(str2);
      } else if (bool) {
        l2 = Long.parseLong(str2.substring(b, str2.length()));
      } else {
        l2 = Long.parseLong(str2);
      } 
      if (bool)
        return FieldUtils.safeAdd(FieldUtils.safeMultiply(-l2, 1000), -l1); 
      return FieldUtils.safeAdd(FieldUtils.safeMultiply(l2, 1000), l1);
    } 
    throw new IllegalArgumentException("Invalid format: \"" + str1 + '"');
  }
  
  public void setInto(ReadWritablePeriod paramReadWritablePeriod, Object paramObject, Chronology paramChronology) {
    String str = (String)paramObject;
    PeriodFormatter periodFormatter = ISOPeriodFormat.standard();
    paramReadWritablePeriod.clear();
    int i = periodFormatter.parseInto(paramReadWritablePeriod, str, 0);
    if (i < str.length()) {
      if (i < 0)
        periodFormatter.withParseType(paramReadWritablePeriod.getPeriodType()).parseMutablePeriod(str); 
      throw new IllegalArgumentException("Invalid format: \"" + str + '"');
    } 
  }
  
  public void setInto(ReadWritableInterval paramReadWritableInterval, Object paramObject, Chronology paramChronology) {
    String str1 = (String)paramObject;
    int i = str1.indexOf('/');
    if (i < 0)
      throw new IllegalArgumentException("Format requires a '/' separator: " + str1); 
    String str2 = str1.substring(0, i);
    if (str2.length() <= 0)
      throw new IllegalArgumentException("Format invalid: " + str1); 
    String str3 = str1.substring(i + 1);
    if (str3.length() <= 0)
      throw new IllegalArgumentException("Format invalid: " + str1); 
    DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.dateTimeParser();
    dateTimeFormatter = dateTimeFormatter.withChronology(paramChronology);
    PeriodFormatter periodFormatter = ISOPeriodFormat.standard();
    long l1 = 0L, l2 = 0L;
    Period period = null;
    Chronology chronology = null;
    char c = str2.charAt(0);
    if (c == 'P' || c == 'p') {
      period = periodFormatter.withParseType(getPeriodType(str2)).parsePeriod(str2);
    } else {
      DateTime dateTime = dateTimeFormatter.parseDateTime(str2);
      l1 = dateTime.getMillis();
      chronology = dateTime.getChronology();
    } 
    c = str3.charAt(0);
    if (c == 'P' || c == 'p') {
      if (period != null)
        throw new IllegalArgumentException("Interval composed of two durations: " + str1); 
      period = periodFormatter.withParseType(getPeriodType(str3)).parsePeriod(str3);
      paramChronology = (paramChronology != null) ? paramChronology : chronology;
      l2 = paramChronology.add(period, l1, 1);
    } else {
      DateTime dateTime = dateTimeFormatter.parseDateTime(str3);
      l2 = dateTime.getMillis();
      chronology = (chronology != null) ? chronology : dateTime.getChronology();
      paramChronology = (paramChronology != null) ? paramChronology : chronology;
      if (period != null)
        l1 = paramChronology.add(period, l2, -1); 
    } 
    paramReadWritableInterval.setInterval(l1, l2);
    paramReadWritableInterval.setChronology(paramChronology);
  }
  
  public Class<?> getSupportedType() { return String.class; }
}
