package org.joda.time.convert;

import org.joda.time.Chronology;
import org.joda.time.DateTimeUtils;
import org.joda.time.ReadWritableInterval;
import org.joda.time.ReadWritablePeriod;
import org.joda.time.ReadableInterval;

class ReadableIntervalConverter extends AbstractConverter implements IntervalConverter, DurationConverter, PeriodConverter {
  static final ReadableIntervalConverter INSTANCE = new ReadableIntervalConverter();
  
  public long getDurationMillis(Object paramObject) { return ((ReadableInterval)paramObject).toDurationMillis(); }
  
  public void setInto(ReadWritablePeriod paramReadWritablePeriod, Object paramObject, Chronology paramChronology) {
    ReadableInterval readableInterval = (ReadableInterval)paramObject;
    paramChronology = (paramChronology != null) ? paramChronology : DateTimeUtils.getIntervalChronology(readableInterval);
    long l1 = readableInterval.getStartMillis();
    long l2 = readableInterval.getEndMillis();
    int[] arrayOfInt = paramChronology.get(paramReadWritablePeriod, l1, l2);
    for (byte b = 0; b < arrayOfInt.length; b++)
      paramReadWritablePeriod.setValue(b, arrayOfInt[b]); 
  }
  
  public boolean isReadableInterval(Object paramObject, Chronology paramChronology) { return true; }
  
  public void setInto(ReadWritableInterval paramReadWritableInterval, Object paramObject, Chronology paramChronology) {
    ReadableInterval readableInterval = (ReadableInterval)paramObject;
    paramReadWritableInterval.setInterval(readableInterval);
    if (paramChronology != null) {
      paramReadWritableInterval.setChronology(paramChronology);
    } else {
      paramReadWritableInterval.setChronology(readableInterval.getChronology());
    } 
  }
  
  public Class<?> getSupportedType() { return ReadableInterval.class; }
}
