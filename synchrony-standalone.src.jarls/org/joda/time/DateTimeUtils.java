package org.joda.time;

import java.lang.reflect.Method;
import java.text.DateFormatSymbols;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.atomic.AtomicReference;
import org.joda.time.chrono.ISOChronology;

public class DateTimeUtils {
  public static final MillisProvider SYSTEM_MILLIS_PROVIDER = new SystemMillisProvider();
  
  private static final AtomicReference<Map<String, DateTimeZone>> cZoneNames = new AtomicReference();
  
  public static final long currentTimeMillis() { return cMillisProvider.getMillis(); }
  
  public static final void setCurrentMillisSystem() {
    checkPermission();
    cMillisProvider = SYSTEM_MILLIS_PROVIDER;
  }
  
  public static final void setCurrentMillisFixed(long paramLong) throws SecurityException {
    checkPermission();
    cMillisProvider = new FixedMillisProvider(paramLong);
  }
  
  public static final void setCurrentMillisOffset(long paramLong) throws SecurityException {
    checkPermission();
    if (paramLong == 0L) {
      cMillisProvider = SYSTEM_MILLIS_PROVIDER;
    } else {
      cMillisProvider = new OffsetMillisProvider(paramLong);
    } 
  }
  
  public static final void setCurrentMillisProvider(MillisProvider paramMillisProvider) throws SecurityException {
    if (paramMillisProvider == null)
      throw new IllegalArgumentException("The MillisProvider must not be null"); 
    checkPermission();
    cMillisProvider = paramMillisProvider;
  }
  
  private static void checkPermission() {
    SecurityManager securityManager = System.getSecurityManager();
    if (securityManager != null)
      securityManager.checkPermission(new JodaTimePermission("CurrentTime.setProvider")); 
  }
  
  public static final long getInstantMillis(ReadableInstant paramReadableInstant) {
    if (paramReadableInstant == null)
      return currentTimeMillis(); 
    return paramReadableInstant.getMillis();
  }
  
  public static final Chronology getInstantChronology(ReadableInstant paramReadableInstant) {
    if (paramReadableInstant == null)
      return ISOChronology.getInstance(); 
    Chronology chronology = paramReadableInstant.getChronology();
    if (chronology == null)
      return ISOChronology.getInstance(); 
    return chronology;
  }
  
  public static final Chronology getIntervalChronology(ReadableInstant paramReadableInstant1, ReadableInstant paramReadableInstant2) {
    ISOChronology iSOChronology = null;
    if (paramReadableInstant1 != null) {
      iSOChronology = paramReadableInstant1.getChronology();
    } else if (paramReadableInstant2 != null) {
      iSOChronology = paramReadableInstant2.getChronology();
    } 
    if (iSOChronology == null)
      iSOChronology = ISOChronology.getInstance(); 
    return iSOChronology;
  }
  
  public static final Chronology getIntervalChronology(ReadableInterval paramReadableInterval) {
    if (paramReadableInterval == null)
      return ISOChronology.getInstance(); 
    Chronology chronology = paramReadableInterval.getChronology();
    if (chronology == null)
      return ISOChronology.getInstance(); 
    return chronology;
  }
  
  public static final ReadableInterval getReadableInterval(ReadableInterval paramReadableInterval) {
    Interval interval;
    if (paramReadableInterval == null) {
      long l = currentTimeMillis();
      interval = new Interval(l, l);
    } 
    return interval;
  }
  
  public static final Chronology getChronology(Chronology paramChronology) {
    if (paramChronology == null)
      return ISOChronology.getInstance(); 
    return paramChronology;
  }
  
  public static final DateTimeZone getZone(DateTimeZone paramDateTimeZone) {
    if (paramDateTimeZone == null)
      return DateTimeZone.getDefault(); 
    return paramDateTimeZone;
  }
  
  public static final PeriodType getPeriodType(PeriodType paramPeriodType) {
    if (paramPeriodType == null)
      return PeriodType.standard(); 
    return paramPeriodType;
  }
  
  public static final long getDurationMillis(ReadableDuration paramReadableDuration) {
    if (paramReadableDuration == null)
      return 0L; 
    return paramReadableDuration.getMillis();
  }
  
  public static final boolean isContiguous(ReadablePartial paramReadablePartial) {
    if (paramReadablePartial == null)
      throw new IllegalArgumentException("Partial must not be null"); 
    DurationFieldType durationFieldType = null;
    for (byte b = 0; b < paramReadablePartial.size(); b++) {
      DateTimeField dateTimeField = paramReadablePartial.getField(b);
      if (b > 0 && (
        dateTimeField.getRangeDurationField() == null || dateTimeField.getRangeDurationField().getType() != durationFieldType))
        return false; 
      durationFieldType = dateTimeField.getDurationField().getType();
    } 
    return true;
  }
  
  public static final DateFormatSymbols getDateFormatSymbols(Locale paramLocale) {
    try {
      Method method = DateFormatSymbols.class.getMethod("getInstance", new Class[] { Locale.class });
      return (DateFormatSymbols)method.invoke(null, new Object[] { paramLocale });
    } catch (Exception exception) {
      return new DateFormatSymbols(paramLocale);
    } 
  }
  
  public static final Map<String, DateTimeZone> getDefaultTimeZoneNames() {
    Map map = (Map)cZoneNames.get();
    if (map == null) {
      map = buildDefaultTimeZoneNames();
      if (!cZoneNames.compareAndSet(null, map))
        map = (Map)cZoneNames.get(); 
    } 
    return map;
  }
  
  public static final void setDefaultTimeZoneNames(Map<String, DateTimeZone> paramMap) { cZoneNames.set(Collections.unmodifiableMap(new HashMap(paramMap))); }
  
  private static Map<String, DateTimeZone> buildDefaultTimeZoneNames() {
    LinkedHashMap linkedHashMap = new LinkedHashMap();
    linkedHashMap.put("UT", DateTimeZone.UTC);
    linkedHashMap.put("UTC", DateTimeZone.UTC);
    linkedHashMap.put("GMT", DateTimeZone.UTC);
    put(linkedHashMap, "EST", "America/New_York");
    put(linkedHashMap, "EDT", "America/New_York");
    put(linkedHashMap, "CST", "America/Chicago");
    put(linkedHashMap, "CDT", "America/Chicago");
    put(linkedHashMap, "MST", "America/Denver");
    put(linkedHashMap, "MDT", "America/Denver");
    put(linkedHashMap, "PST", "America/Los_Angeles");
    put(linkedHashMap, "PDT", "America/Los_Angeles");
    return Collections.unmodifiableMap(linkedHashMap);
  }
  
  private static void put(Map<String, DateTimeZone> paramMap, String paramString1, String paramString2) {
    try {
      paramMap.put(paramString1, DateTimeZone.forID(paramString2));
    } catch (RuntimeException runtimeException) {}
  }
  
  public static final double toJulianDay(long paramLong) {
    double d = paramLong / 8.64E7D;
    return d + 2440587.5D;
  }
  
  public static final long toJulianDayNumber(long paramLong) { return (long)Math.floor(toJulianDay(paramLong) + 0.5D); }
  
  public static final long fromJulianDay(double paramDouble) {
    double d = paramDouble - 2440587.5D;
    return (long)(d * 8.64E7D);
  }
}
