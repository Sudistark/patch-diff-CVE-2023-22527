package org.msgpack.jackson.dataformat;

import com.fasterxml.jackson.core.Base64Variant;
import com.fasterxml.jackson.core.JsonLocation;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.JsonStreamContext;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.core.ObjectCodec;
import com.fasterxml.jackson.core.Version;
import com.fasterxml.jackson.core.base.ParserMinimalBase;
import com.fasterxml.jackson.core.io.IOContext;
import com.fasterxml.jackson.core.io.JsonEOFException;
import com.fasterxml.jackson.core.json.DupDetector;
import com.fasterxml.jackson.core.json.JsonReadContext;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.LinkedList;
import org.msgpack.core.ExtensionTypeHeader;
import org.msgpack.core.MessageFormat;
import org.msgpack.core.MessagePack;
import org.msgpack.core.MessageUnpacker;
import org.msgpack.core.buffer.ArrayBufferInput;
import org.msgpack.core.buffer.InputStreamBufferInput;
import org.msgpack.core.buffer.MessageBufferInput;
import org.msgpack.value.ValueType;

public class MessagePackParser extends ParserMinimalBase {
  private static final ThreadLocal<Tuple<Object, MessageUnpacker>> messageUnpackerHolder = new ThreadLocal();
  
  private final MessageUnpacker messageUnpacker;
  
  private static final BigInteger LONG_MIN = BigInteger.valueOf(Float.MIN_VALUE);
  
  private static final BigInteger LONG_MAX = BigInteger.valueOf(Float.MAX_VALUE);
  
  private ObjectCodec codec;
  
  private JsonReadContext parsingContext;
  
  private final LinkedList<StackItem> stack = new LinkedList();
  
  private boolean isClosed;
  
  private long tokenPosition;
  
  private long currentPosition;
  
  private final IOContext ioContext;
  
  private ExtensionTypeCustomDeserializers extTypeCustomDesers;
  
  private Type type;
  
  private int intValue;
  
  private long longValue;
  
  private double doubleValue;
  
  private byte[] bytesValue;
  
  private String stringValue;
  
  private BigInteger biValue;
  
  private MessagePackExtensionType extensionTypeValue;
  
  private boolean reuseResourceInParser;
  
  public MessagePackParser(IOContext paramIOContext, int paramInt, ObjectCodec paramObjectCodec, InputStream paramInputStream) throws IOException { this(paramIOContext, paramInt, paramObjectCodec, paramInputStream, true); }
  
  public MessagePackParser(IOContext paramIOContext, int paramInt, ObjectCodec paramObjectCodec, InputStream paramInputStream, boolean paramBoolean) throws IOException { this(paramIOContext, paramInt, new InputStreamBufferInput(paramInputStream), paramObjectCodec, paramInputStream, paramBoolean); }
  
  public MessagePackParser(IOContext paramIOContext, int paramInt, ObjectCodec paramObjectCodec, byte[] paramArrayOfByte) throws IOException { this(paramIOContext, paramInt, paramObjectCodec, paramArrayOfByte, true); }
  
  public MessagePackParser(IOContext paramIOContext, int paramInt, ObjectCodec paramObjectCodec, byte[] paramArrayOfByte, boolean paramBoolean) throws IOException { this(paramIOContext, paramInt, new ArrayBufferInput(paramArrayOfByte), paramObjectCodec, paramArrayOfByte, paramBoolean); }
  
  private MessagePackParser(IOContext paramIOContext, int paramInt, MessageBufferInput paramMessageBufferInput, ObjectCodec paramObjectCodec, Object paramObject, boolean paramBoolean) throws IOException {
    super(paramInt);
    this.codec = paramObjectCodec;
    this.ioContext = paramIOContext;
    DupDetector dupDetector = JsonParser.Feature.STRICT_DUPLICATE_DETECTION.enabledIn(paramInt) ? DupDetector.rootDetector(this) : null;
    this.parsingContext = JsonReadContext.createRootContext(dupDetector);
    this.reuseResourceInParser = paramBoolean;
    if (!paramBoolean) {
      this.messageUnpacker = MessagePack.newDefaultUnpacker(paramMessageBufferInput);
      return;
    } 
    this.messageUnpacker = null;
    Tuple tuple = (Tuple)messageUnpackerHolder.get();
    if (tuple == null) {
      messageUnpacker1 = MessagePack.newDefaultUnpacker(paramMessageBufferInput);
    } else {
      if (isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE) || tuple.first() != paramObject)
        ((MessageUnpacker)tuple.second()).reset(paramMessageBufferInput); 
      messageUnpacker1 = (MessageUnpacker)tuple.second();
    } 
    messageUnpackerHolder.set(new Tuple(paramObject, messageUnpacker1));
  }
  
  public void setExtensionTypeCustomDeserializers(ExtensionTypeCustomDeserializers paramExtensionTypeCustomDeserializers) { this.extTypeCustomDesers = paramExtensionTypeCustomDeserializers; }
  
  public ObjectCodec getCodec() { return this.codec; }
  
  public void setCodec(ObjectCodec paramObjectCodec) { this.codec = paramObjectCodec; }
  
  public Version version() { return null; }
  
  public JsonToken nextToken() throws IOException, JsonParseException {
    ExtensionTypeHeader extensionTypeHeader;
    long l;
    int i;
    BigInteger bigInteger2;
    Long long;
    BigInteger bigInteger1;
    boolean bool;
    StackItemForObject stackItemForObject;
    MessageUnpacker messageUnpacker1 = getMessageUnpacker();
    this.tokenPosition = messageUnpacker1.getTotalReadBytes();
    JsonToken jsonToken = null;
    if ((this.parsingContext.inObject() || this.parsingContext.inArray()) && (
      (StackItem)this.stack.getFirst()).isEmpty()) {
      this.stack.pop();
      this._currToken = this.parsingContext.inObject() ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;
      this.parsingContext = this.parsingContext.getParent();
      return this._currToken;
    } 
    if (!messageUnpacker1.hasNext())
      throw new JsonEOFException(this, null, "Unexpected EOF"); 
    MessageFormat messageFormat = messageUnpacker1.getNextFormat();
    ValueType valueType = messageUnpacker1.getNextFormat().getValueType();
    StackItemForArray stackItemForArray = null;
    switch (null.$SwitchMap$org$msgpack$value$ValueType[valueType.ordinal()]) {
      case 1:
        messageUnpacker1.unpackNil();
        jsonToken = JsonToken.VALUE_NULL;
        break;
      case 2:
        bool = messageUnpacker1.unpackBoolean();
        if (this.parsingContext.inObject() && this._currToken != JsonToken.FIELD_NAME) {
          this.parsingContext.setCurrentName(Boolean.toString(bool));
          jsonToken = JsonToken.FIELD_NAME;
          break;
        } 
        jsonToken = bool ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE;
        break;
      case 3:
        switch (null.$SwitchMap$org$msgpack$core$MessageFormat[messageFormat.ordinal()]) {
          case 1:
            bigInteger2 = messageUnpacker1.unpackBigInteger();
            if (0 <= bigInteger2.compareTo(LONG_MIN) && bigInteger2.compareTo(LONG_MAX) <= 0) {
              this.type = Type.LONG;
              this.longValue = bigInteger2.longValue();
              Long long1 = Long.valueOf(this.longValue);
              break;
            } 
            this.type = Type.BIG_INT;
            this.biValue = bigInteger2;
            bigInteger1 = this.biValue;
            break;
          default:
            l = messageUnpacker1.unpackLong();
            if (-2147483648L <= l && l <= 2147483647L) {
              this.type = Type.INT;
              this.intValue = (int)l;
              Integer integer = Integer.valueOf(this.intValue);
              break;
            } 
            this.type = Type.LONG;
            this.longValue = l;
            long = Long.valueOf(this.longValue);
            break;
        } 
        if (this.parsingContext.inObject() && this._currToken != JsonToken.FIELD_NAME) {
          this.parsingContext.setCurrentName(String.valueOf(long));
          jsonToken = JsonToken.FIELD_NAME;
          break;
        } 
        jsonToken = JsonToken.VALUE_NUMBER_INT;
        break;
      case 4:
        this.type = Type.DOUBLE;
        this.doubleValue = messageUnpacker1.unpackDouble();
        if (this.parsingContext.inObject() && this._currToken != JsonToken.FIELD_NAME) {
          this.parsingContext.setCurrentName(String.valueOf(this.doubleValue));
          jsonToken = JsonToken.FIELD_NAME;
          break;
        } 
        jsonToken = JsonToken.VALUE_NUMBER_FLOAT;
        break;
      case 5:
        this.type = Type.STRING;
        this.stringValue = messageUnpacker1.unpackString();
        if (this.parsingContext.inObject() && this._currToken != JsonToken.FIELD_NAME) {
          this.parsingContext.setCurrentName(this.stringValue);
          jsonToken = JsonToken.FIELD_NAME;
          break;
        } 
        jsonToken = JsonToken.VALUE_STRING;
        break;
      case 6:
        this.type = Type.BYTES;
        i = messageUnpacker1.unpackBinaryHeader();
        this.bytesValue = messageUnpacker1.readPayload(i);
        if (this.parsingContext.inObject() && this._currToken != JsonToken.FIELD_NAME) {
          this.parsingContext.setCurrentName(new String(this.bytesValue, MessagePack.UTF8));
          jsonToken = JsonToken.FIELD_NAME;
          break;
        } 
        jsonToken = JsonToken.VALUE_EMBEDDED_OBJECT;
        break;
      case 7:
        stackItemForArray = new StackItemForArray(messageUnpacker1.unpackArrayHeader());
        break;
      case 8:
        stackItemForObject = new StackItemForObject(messageUnpacker1.unpackMapHeader());
        break;
      case 9:
        this.type = Type.EXT;
        extensionTypeHeader = messageUnpacker1.unpackExtensionTypeHeader();
        this.extensionTypeValue = new MessagePackExtensionType(extensionTypeHeader.getType(), messageUnpacker1.readPayload(extensionTypeHeader.getLength()));
        if (this.parsingContext.inObject() && this._currToken != JsonToken.FIELD_NAME) {
          this.parsingContext.setCurrentName(deserializedExtensionTypeValue().toString());
          jsonToken = JsonToken.FIELD_NAME;
          break;
        } 
        jsonToken = JsonToken.VALUE_EMBEDDED_OBJECT;
        break;
      default:
        throw new IllegalStateException("Shouldn't reach here");
    } 
    this.currentPosition = messageUnpacker1.getTotalReadBytes();
    if ((this.parsingContext.inObject() && jsonToken != JsonToken.FIELD_NAME) || this.parsingContext.inArray())
      ((StackItem)this.stack.getFirst()).consume(); 
    if (stackItemForObject != null) {
      this.stack.push(stackItemForObject);
      if (stackItemForObject instanceof StackItemForArray) {
        jsonToken = JsonToken.START_ARRAY;
        this.parsingContext = this.parsingContext.createChildArrayContext(-1, -1);
      } else if (stackItemForObject instanceof StackItemForObject) {
        jsonToken = JsonToken.START_OBJECT;
        this.parsingContext = this.parsingContext.createChildObjectContext(-1, -1);
      } 
    } 
    this._currToken = jsonToken;
    return jsonToken;
  }
  
  protected void _handleEOF() throws JsonParseException {}
  
  public String getText() throws IOException, JsonParseException {
    switch (null.$SwitchMap$org$msgpack$jackson$dataformat$MessagePackParser$Type[this.type.ordinal()]) {
      case 1:
        return this.stringValue;
      case 2:
        return new String(this.bytesValue, MessagePack.UTF8);
      case 3:
        return String.valueOf(this.intValue);
      case 4:
        return String.valueOf(this.longValue);
      case 5:
        return String.valueOf(this.doubleValue);
      case 6:
        return String.valueOf(this.biValue);
      case 7:
        return deserializedExtensionTypeValue().toString();
    } 
    throw new IllegalStateException("Invalid type=" + this.type);
  }
  
  public char[] getTextCharacters() throws IOException, JsonParseException { return getText().toCharArray(); }
  
  public boolean hasTextCharacters() { return false; }
  
  public int getTextLength() throws IOException, JsonParseException { return getText().length(); }
  
  public int getTextOffset() throws IOException, JsonParseException { return 0; }
  
  public byte[] getBinaryValue(Base64Variant paramBase64Variant) throws IOException, JsonParseException {
    switch (null.$SwitchMap$org$msgpack$jackson$dataformat$MessagePackParser$Type[this.type.ordinal()]) {
      case 2:
        return this.bytesValue;
      case 1:
        return this.stringValue.getBytes(MessagePack.UTF8);
      case 7:
        return this.extensionTypeValue.getData();
    } 
    throw new IllegalStateException("Invalid type=" + this.type);
  }
  
  public Number getNumberValue() throws IOException, JsonParseException {
    switch (null.$SwitchMap$org$msgpack$jackson$dataformat$MessagePackParser$Type[this.type.ordinal()]) {
      case 3:
        return Integer.valueOf(this.intValue);
      case 4:
        return Long.valueOf(this.longValue);
      case 5:
        return Double.valueOf(this.doubleValue);
      case 6:
        return this.biValue;
    } 
    throw new IllegalStateException("Invalid type=" + this.type);
  }
  
  public int getIntValue() throws IOException, JsonParseException {
    switch (null.$SwitchMap$org$msgpack$jackson$dataformat$MessagePackParser$Type[this.type.ordinal()]) {
      case 3:
        return this.intValue;
      case 4:
        return (int)this.longValue;
      case 5:
        return (int)this.doubleValue;
      case 6:
        return this.biValue.intValue();
    } 
    throw new IllegalStateException("Invalid type=" + this.type);
  }
  
  public long getLongValue() throws IOException, JsonParseException {
    switch (null.$SwitchMap$org$msgpack$jackson$dataformat$MessagePackParser$Type[this.type.ordinal()]) {
      case 3:
        return this.intValue;
      case 4:
        return this.longValue;
      case 5:
        return (long)this.doubleValue;
      case 6:
        return this.biValue.longValue();
    } 
    throw new IllegalStateException("Invalid type=" + this.type);
  }
  
  public BigInteger getBigIntegerValue() throws IOException, JsonParseException {
    switch (null.$SwitchMap$org$msgpack$jackson$dataformat$MessagePackParser$Type[this.type.ordinal()]) {
      case 3:
        return BigInteger.valueOf(this.intValue);
      case 4:
        return BigInteger.valueOf(this.longValue);
      case 5:
        return BigInteger.valueOf((long)this.doubleValue);
      case 6:
        return this.biValue;
    } 
    throw new IllegalStateException("Invalid type=" + this.type);
  }
  
  public float getFloatValue() throws IOException, JsonParseException {
    switch (null.$SwitchMap$org$msgpack$jackson$dataformat$MessagePackParser$Type[this.type.ordinal()]) {
      case 3:
        return this.intValue;
      case 4:
        return (float)this.longValue;
      case 5:
        return (float)this.doubleValue;
      case 6:
        return this.biValue.floatValue();
    } 
    throw new IllegalStateException("Invalid type=" + this.type);
  }
  
  public double getDoubleValue() throws IOException, JsonParseException {
    switch (null.$SwitchMap$org$msgpack$jackson$dataformat$MessagePackParser$Type[this.type.ordinal()]) {
      case 3:
        return this.intValue;
      case 4:
        return this.longValue;
      case 5:
        return this.doubleValue;
      case 6:
        return this.biValue.doubleValue();
    } 
    throw new IllegalStateException("Invalid type=" + this.type);
  }
  
  public BigDecimal getDecimalValue() throws IOException {
    switch (null.$SwitchMap$org$msgpack$jackson$dataformat$MessagePackParser$Type[this.type.ordinal()]) {
      case 3:
        return BigDecimal.valueOf(this.intValue);
      case 4:
        return BigDecimal.valueOf(this.longValue);
      case 5:
        return BigDecimal.valueOf(this.doubleValue);
      case 6:
        return new BigDecimal(this.biValue);
    } 
    throw new IllegalStateException("Invalid type=" + this.type);
  }
  
  private Object deserializedExtensionTypeValue() throws IOException {
    if (this.extTypeCustomDesers != null) {
      ExtensionTypeCustomDeserializers.Deser deser = this.extTypeCustomDesers.getDeser(this.extensionTypeValue.getType());
      if (deser != null)
        return deser.deserialize(this.extensionTypeValue.getData()); 
    } 
    return this.extensionTypeValue;
  }
  
  public Object getEmbeddedObject() throws IOException {
    switch (null.$SwitchMap$org$msgpack$jackson$dataformat$MessagePackParser$Type[this.type.ordinal()]) {
      case 2:
        return this.bytesValue;
      case 7:
        return deserializedExtensionTypeValue();
    } 
    throw new IllegalStateException("Invalid type=" + this.type);
  }
  
  public JsonParser.NumberType getNumberType() throws IOException, JsonParseException {
    switch (null.$SwitchMap$org$msgpack$jackson$dataformat$MessagePackParser$Type[this.type.ordinal()]) {
      case 3:
        return JsonParser.NumberType.INT;
      case 4:
        return JsonParser.NumberType.LONG;
      case 5:
        return JsonParser.NumberType.DOUBLE;
      case 6:
        return JsonParser.NumberType.BIG_INTEGER;
    } 
    throw new IllegalStateException("Invalid type=" + this.type);
  }
  
  public void close() throws JsonParseException {
    try {
      if (isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)) {
        MessageUnpacker messageUnpacker1 = getMessageUnpacker();
        messageUnpacker1.close();
      } 
    } finally {
      this.isClosed = true;
    } 
  }
  
  public boolean isClosed() { return this.isClosed; }
  
  public JsonStreamContext getParsingContext() { return this.parsingContext; }
  
  public JsonLocation getTokenLocation() { return new JsonLocation(this.ioContext.getSourceReference(), this.tokenPosition, -1L, -1, (int)this.tokenPosition); }
  
  public JsonLocation getCurrentLocation() { return new JsonLocation(this.ioContext.getSourceReference(), this.currentPosition, -1L, -1, (int)this.currentPosition); }
  
  public void overrideCurrentName(String paramString) {
    try {
      if (this._currToken == JsonToken.START_OBJECT || this._currToken == JsonToken.START_ARRAY) {
        JsonReadContext jsonReadContext = this.parsingContext.getParent();
        jsonReadContext.setCurrentName(paramString);
      } else {
        this.parsingContext.setCurrentName(paramString);
      } 
    } catch (JsonProcessingException jsonProcessingException) {
      throw new IllegalStateException(jsonProcessingException);
    } 
  }
  
  public String getCurrentName() throws IOException, JsonParseException {
    if (this._currToken == JsonToken.START_OBJECT || this._currToken == JsonToken.START_ARRAY) {
      JsonReadContext jsonReadContext = this.parsingContext.getParent();
      return jsonReadContext.getCurrentName();
    } 
    return this.parsingContext.getCurrentName();
  }
  
  private MessageUnpacker getMessageUnpacker() {
    if (!this.reuseResourceInParser)
      return this.messageUnpacker; 
    Tuple tuple = (Tuple)messageUnpackerHolder.get();
    if (tuple == null)
      throw new IllegalStateException("messageUnpacker is null"); 
    return (MessageUnpacker)tuple.second();
  }
}
