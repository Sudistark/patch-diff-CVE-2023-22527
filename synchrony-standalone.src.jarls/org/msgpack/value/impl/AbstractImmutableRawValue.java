package org.msgpack.value.impl;

import java.nio.ByteBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CodingErrorAction;
import java.util.Arrays;
import org.msgpack.core.MessagePack;
import org.msgpack.core.MessageStringCodingException;
import org.msgpack.value.ImmutableArrayValue;
import org.msgpack.value.ImmutableBinaryValue;
import org.msgpack.value.ImmutableBooleanValue;
import org.msgpack.value.ImmutableExtensionValue;
import org.msgpack.value.ImmutableFloatValue;
import org.msgpack.value.ImmutableIntegerValue;
import org.msgpack.value.ImmutableMapValue;
import org.msgpack.value.ImmutableNilValue;
import org.msgpack.value.ImmutableNumberValue;
import org.msgpack.value.ImmutableRawValue;
import org.msgpack.value.ImmutableStringValue;
import org.msgpack.value.ImmutableTimestampValue;
import org.msgpack.value.RawValue;

public abstract class AbstractImmutableRawValue extends AbstractImmutableValue implements ImmutableRawValue {
  protected final byte[] data;
  
  public AbstractImmutableRawValue(byte[] paramArrayOfByte) { this.data = paramArrayOfByte; }
  
  public AbstractImmutableRawValue(String paramString) {
    this.decodedStringCache = paramString;
    this.data = paramString.getBytes(MessagePack.UTF8);
  }
  
  public ImmutableRawValue asRawValue() { return this; }
  
  public byte[] asByteArray() { return Arrays.copyOf(this.data, this.data.length); }
  
  public ByteBuffer asByteBuffer() { return ByteBuffer.wrap(this.data).asReadOnlyBuffer(); }
  
  public String asString() {
    if (this.decodedStringCache == null)
      decodeString(); 
    if (this.codingException != null)
      throw new MessageStringCodingException(this.codingException); 
    return this.decodedStringCache;
  }
  
  public String toJson() {
    StringBuilder stringBuilder = new StringBuilder();
    appendJsonString(stringBuilder, toString());
    return stringBuilder.toString();
  }
  
  private void decodeString() {
    synchronized (this.data) {
      if (this.decodedStringCache != null)
        return; 
      try {
        CharsetDecoder charsetDecoder = MessagePack.UTF8.newDecoder().onMalformedInput(CodingErrorAction.REPORT).onUnmappableCharacter(CodingErrorAction.REPORT);
        this.decodedStringCache = charsetDecoder.decode(asByteBuffer()).toString();
      } catch (CharacterCodingException characterCodingException) {
        try {
          CharsetDecoder charsetDecoder = MessagePack.UTF8.newDecoder().onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE);
          this.decodedStringCache = charsetDecoder.decode(asByteBuffer()).toString();
        } catch (CharacterCodingException characterCodingException1) {
          throw new MessageStringCodingException(characterCodingException1);
        } 
        this.codingException = characterCodingException;
      } 
    } 
  }
  
  public String toString() {
    if (this.decodedStringCache == null)
      decodeString(); 
    return this.decodedStringCache;
  }
  
  static void appendJsonString(StringBuilder paramStringBuilder, String paramString) {
    paramStringBuilder.append("\"");
    for (byte b = 0; b < paramString.length(); b++) {
      char c = paramString.charAt(b);
      if (c < ' ') {
        switch (c) {
          case '\n':
            paramStringBuilder.append("\\n");
            break;
          case '\r':
            paramStringBuilder.append("\\r");
            break;
          case '\t':
            paramStringBuilder.append("\\t");
            break;
          case '\f':
            paramStringBuilder.append("\\f");
            break;
          case '\b':
            paramStringBuilder.append("\\b");
            break;
          default:
            escapeChar(paramStringBuilder, c);
            break;
        } 
      } else if (c <= '') {
        switch (c) {
          case '\\':
            paramStringBuilder.append("\\\\");
            break;
          case '"':
            paramStringBuilder.append("\\\"");
            break;
          default:
            paramStringBuilder.append(c);
            break;
        } 
      } else if (c >= '?' && c <= '?') {
        escapeChar(paramStringBuilder, c);
      } else {
        paramStringBuilder.append(c);
      } 
    } 
    paramStringBuilder.append("\"");
  }
  
  private static final char[] HEX_TABLE = "0123456789ABCDEF".toCharArray();
  
  private static void escapeChar(StringBuilder paramStringBuilder, int paramInt) {
    paramStringBuilder.append("\\u");
    paramStringBuilder.append(HEX_TABLE[paramInt >> 12 & 0xF]);
    paramStringBuilder.append(HEX_TABLE[paramInt >> 8 & 0xF]);
    paramStringBuilder.append(HEX_TABLE[paramInt >> 4 & 0xF]);
    paramStringBuilder.append(HEX_TABLE[paramInt & 0xF]);
  }
}
