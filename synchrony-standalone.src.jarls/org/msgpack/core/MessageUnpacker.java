package org.msgpack.core;

import java.io.Closeable;
import java.io.IOException;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CoderResult;
import java.nio.charset.CodingErrorAction;
import java.time.Instant;
import org.msgpack.core.buffer.MessageBuffer;
import org.msgpack.core.buffer.MessageBufferInput;
import org.msgpack.value.ImmutableValue;
import org.msgpack.value.Value;
import org.msgpack.value.ValueFactory;
import org.msgpack.value.Variable;

public class MessageUnpacker implements Closeable {
  private static final MessageBuffer EMPTY_BUFFER = MessageBuffer.wrap(new byte[0]);
  
  private final boolean allowReadingStringAsBinary;
  
  private final boolean allowReadingBinaryAsString;
  
  private final CodingErrorAction actionOnMalformedString;
  
  private final CodingErrorAction actionOnUnmappableString;
  
  private final int stringSizeLimit;
  
  private final int stringDecoderBufferSize;
  
  private MessageBufferInput in;
  
  private MessageBuffer buffer;
  
  private int position;
  
  private long totalReadBytes;
  
  private final MessageBuffer numberBuffer;
  
  private int nextReadPosition;
  
  private StringBuilder decodeStringBuffer;
  
  private CharsetDecoder decoder;
  
  private CharBuffer decodeBuffer;
  
  private static final String EMPTY_STRING = "";
  
  protected MessageUnpacker(MessageBufferInput paramMessageBufferInput, MessagePack.UnpackerConfig paramUnpackerConfig) {
    this.buffer = EMPTY_BUFFER;
    this.numberBuffer = MessageBuffer.allocate(8);
    this.in = (MessageBufferInput)Preconditions.checkNotNull(paramMessageBufferInput, "MessageBufferInput is null");
    this.allowReadingStringAsBinary = paramUnpackerConfig.getAllowReadingStringAsBinary();
    this.allowReadingBinaryAsString = paramUnpackerConfig.getAllowReadingBinaryAsString();
    this.actionOnMalformedString = paramUnpackerConfig.getActionOnMalformedString();
    this.actionOnUnmappableString = paramUnpackerConfig.getActionOnUnmappableString();
    this.stringSizeLimit = paramUnpackerConfig.getStringSizeLimit();
    this.stringDecoderBufferSize = paramUnpackerConfig.getStringDecoderBufferSize();
  }
  
  public MessageBufferInput reset(MessageBufferInput paramMessageBufferInput) throws IOException {
    MessageBufferInput messageBufferInput1 = (MessageBufferInput)Preconditions.checkNotNull(paramMessageBufferInput, "MessageBufferInput is null");
    MessageBufferInput messageBufferInput2 = this.in;
    this.in = messageBufferInput1;
    this.buffer = EMPTY_BUFFER;
    this.position = 0;
    this.totalReadBytes = 0L;
    return messageBufferInput2;
  }
  
  public long getTotalReadBytes() { return this.totalReadBytes + this.position; }
  
  private MessageBuffer getNextBuffer() throws IOException {
    MessageBuffer messageBuffer = this.in.next();
    if (messageBuffer == null)
      throw new MessageInsufficientBufferException(); 
    assert this.buffer != null;
    this.totalReadBytes += this.buffer.size();
    return messageBuffer;
  }
  
  private void nextBuffer() throws IOException {
    this.buffer = getNextBuffer();
    this.position = 0;
  }
  
  private MessageBuffer prepareNumberBuffer(int paramInt) throws IOException {
    int i = this.buffer.size() - this.position;
    if (i >= paramInt) {
      this.nextReadPosition = this.position;
      this.position += paramInt;
      return this.buffer;
    } 
    int j = 0;
    if (i > 0) {
      this.numberBuffer.putMessageBuffer(0, this.buffer, this.position, i);
      paramInt -= i;
      j += i;
    } 
    while (true) {
      nextBuffer();
      int k = this.buffer.size();
      if (k >= paramInt) {
        this.numberBuffer.putMessageBuffer(j, this.buffer, 0, paramInt);
        this.position = paramInt;
        break;
      } 
      this.numberBuffer.putMessageBuffer(j, this.buffer, 0, k);
      paramInt -= k;
      j += k;
    } 
    this.nextReadPosition = 0;
    return this.numberBuffer;
  }
  
  private static int utf8MultibyteCharacterSize(byte paramByte) { return Integer.numberOfLeadingZeros((paramByte & 0xFF ^ 0xFFFFFFFF) << 24); }
  
  public boolean hasNext() throws IOException { return ensureBuffer(); }
  
  private boolean ensureBuffer() throws IOException {
    while (this.buffer.size() <= this.position) {
      MessageBuffer messageBuffer = this.in.next();
      if (messageBuffer == null)
        return false; 
      this.totalReadBytes += this.buffer.size();
      this.buffer = messageBuffer;
      this.position = 0;
    } 
    return true;
  }
  
  public MessageFormat getNextFormat() throws IOException {
    if (!ensureBuffer())
      throw new MessageInsufficientBufferException(); 
    byte b = this.buffer.getByte(this.position);
    return MessageFormat.valueOf(b);
  }
  
  private byte readByte() throws IOException {
    if (this.buffer.size() > this.position) {
      byte b = this.buffer.getByte(this.position);
      this.position++;
      return b;
    } 
    nextBuffer();
    if (this.buffer.size() > 0) {
      byte b = this.buffer.getByte(0);
      this.position = 1;
      return b;
    } 
    return readByte();
  }
  
  private short readShort() throws IOException {
    MessageBuffer messageBuffer = prepareNumberBuffer(2);
    return messageBuffer.getShort(this.nextReadPosition);
  }
  
  private int readInt() throws IOException {
    MessageBuffer messageBuffer = prepareNumberBuffer(4);
    return messageBuffer.getInt(this.nextReadPosition);
  }
  
  private long readLong() {
    MessageBuffer messageBuffer = prepareNumberBuffer(8);
    return messageBuffer.getLong(this.nextReadPosition);
  }
  
  private float readFloat() throws IOException {
    MessageBuffer messageBuffer = prepareNumberBuffer(4);
    return messageBuffer.getFloat(this.nextReadPosition);
  }
  
  private double readDouble() throws IOException {
    MessageBuffer messageBuffer = prepareNumberBuffer(8);
    return messageBuffer.getDouble(this.nextReadPosition);
  }
  
  public void skipValue() throws IOException { skipValue(1); }
  
  public void skipValue(int paramInt) throws IOException {
    while (paramInt > 0) {
      int i;
      byte b2, b1 = readByte();
      MessageFormat messageFormat = MessageFormat.valueOf(b1);
      switch (null.$SwitchMap$org$msgpack$core$MessageFormat[messageFormat.ordinal()]) {
        case 5:
          b2 = b1 & 0xF;
          paramInt += b2 * 2;
          break;
        case 6:
          b2 = b1 & 0xF;
          paramInt += b2;
          break;
        case 7:
          b2 = b1 & 0x1F;
          skipPayload(b2);
          break;
        case 8:
        case 9:
          skipPayload(1);
          break;
        case 10:
        case 11:
          skipPayload(2);
          break;
        case 12:
        case 13:
        case 14:
          skipPayload(4);
          break;
        case 15:
        case 16:
        case 17:
          skipPayload(8);
          break;
        case 18:
        case 19:
          skipPayload(readNextLength8());
          break;
        case 20:
        case 21:
          skipPayload(readNextLength16());
          break;
        case 22:
        case 23:
          skipPayload(readNextLength32());
          break;
        case 24:
          skipPayload(2);
          break;
        case 25:
          skipPayload(3);
          break;
        case 26:
          skipPayload(5);
          break;
        case 27:
          skipPayload(9);
          break;
        case 28:
          skipPayload(17);
          break;
        case 29:
          skipPayload(readNextLength8() + 1);
          break;
        case 30:
          skipPayload(readNextLength16() + 1);
          break;
        case 31:
          i = readNextLength32();
          skipPayload(1);
          skipPayload(i);
          break;
        case 32:
          paramInt += readNextLength16();
          break;
        case 33:
          paramInt += readNextLength32();
          break;
        case 34:
          paramInt += readNextLength16() * 2;
          break;
        case 35:
          paramInt += readNextLength32() * 2;
          break;
        case 36:
          throw new MessageNeverUsedFormatException("Encountered 0xC1 \"NEVER_USED\" byte");
      } 
      paramInt--;
    } 
  }
  
  private static MessagePackException unexpected(String paramString, byte paramByte) {
    MessageFormat messageFormat = MessageFormat.valueOf(paramByte);
    if (messageFormat == MessageFormat.NEVER_USED)
      return new MessageNeverUsedFormatException(String.format("Expected %s, but encountered 0xC1 \"NEVER_USED\" byte", new Object[] { paramString })); 
    String str1 = messageFormat.getValueType().name();
    String str2 = str1.substring(0, 1) + str1.substring(1).toLowerCase();
    return new MessageTypeException(String.format("Expected %s, but got %s (%02x)", new Object[] { paramString, str2, Byte.valueOf(paramByte) }));
  }
  
  private static MessagePackException unexpectedExtension(String paramString, int paramInt1, int paramInt2) {
    return new MessageTypeException(String.format("Expected extension type %s (%d), but got extension type %d", new Object[] { paramString, 
            Integer.valueOf(paramInt1), Integer.valueOf(paramInt2) }));
  }
  
  public ImmutableValue unpackValue() throws IOException {
    byte b;
    Value[] arrayOfValue;
    int i;
    ExtensionTypeHeader extensionTypeHeader;
    MessageFormat messageFormat = getNextFormat();
    switch (null.$SwitchMap$org$msgpack$value$ValueType[messageFormat.getValueType().ordinal()]) {
      case 1:
        readByte();
        return ValueFactory.newNil();
      case 2:
        return ValueFactory.newBoolean(unpackBoolean());
      case 3:
        if (messageFormat == MessageFormat.UINT64)
          return ValueFactory.newInteger(unpackBigInteger()); 
        return ValueFactory.newInteger(unpackLong());
      case 4:
        return ValueFactory.newFloat(unpackDouble());
      case 5:
        i = unpackRawStringHeader();
        if (i > this.stringSizeLimit)
          throw new MessageSizeException(String.format("cannot unpack a String of size larger than %,d: %,d", new Object[] { Integer.valueOf(this.stringSizeLimit), Integer.valueOf(i) }), i); 
        return ValueFactory.newString(readPayload(i), true);
      case 6:
        i = unpackBinaryHeader();
        return ValueFactory.newBinary(readPayload(i), true);
      case 7:
        i = unpackArrayHeader();
        arrayOfValue = new Value[i];
        for (b = 0; b < i; b++)
          arrayOfValue[b] = unpackValue(); 
        return ValueFactory.newArray(arrayOfValue, true);
      case 8:
        i = unpackMapHeader();
        arrayOfValue = new Value[i * 2];
        for (b = 0; b < i * 2; ) {
          arrayOfValue[b] = unpackValue();
          b++;
          arrayOfValue[b] = unpackValue();
          b++;
        } 
        return ValueFactory.newMap(arrayOfValue, true);
      case 9:
        extensionTypeHeader = unpackExtensionTypeHeader();
        switch (extensionTypeHeader.getType()) {
          case -1:
            return ValueFactory.newTimestamp(unpackTimestamp(extensionTypeHeader));
        } 
        return ValueFactory.newExtension(extensionTypeHeader.getType(), readPayload(extensionTypeHeader.getLength()));
    } 
    throw new MessageNeverUsedFormatException("Unknown value type");
  }
  
  public Variable unpackValue(Variable paramVariable) throws IOException {
    byte b;
    Value[] arrayOfValue;
    int i;
    ExtensionTypeHeader extensionTypeHeader;
    MessageFormat messageFormat = getNextFormat();
    switch (null.$SwitchMap$org$msgpack$value$ValueType[messageFormat.getValueType().ordinal()]) {
      case 1:
        readByte();
        paramVariable.setNilValue();
        return paramVariable;
      case 2:
        paramVariable.setBooleanValue(unpackBoolean());
        return paramVariable;
      case 3:
        switch (null.$SwitchMap$org$msgpack$core$MessageFormat[messageFormat.ordinal()]) {
          case 16:
            paramVariable.setIntegerValue(unpackBigInteger());
            return paramVariable;
        } 
        paramVariable.setIntegerValue(unpackLong());
        return paramVariable;
      case 4:
        paramVariable.setFloatValue(unpackDouble());
        return paramVariable;
      case 5:
        i = unpackRawStringHeader();
        if (i > this.stringSizeLimit)
          throw new MessageSizeException(String.format("cannot unpack a String of size larger than %,d: %,d", new Object[] { Integer.valueOf(this.stringSizeLimit), Integer.valueOf(i) }), i); 
        paramVariable.setStringValue(readPayload(i));
        return paramVariable;
      case 6:
        i = unpackBinaryHeader();
        paramVariable.setBinaryValue(readPayload(i));
        return paramVariable;
      case 7:
        i = unpackArrayHeader();
        arrayOfValue = new Value[i];
        for (b = 0; b < i; b++)
          arrayOfValue[b] = unpackValue(); 
        paramVariable.setArrayValue(arrayOfValue);
        return paramVariable;
      case 8:
        i = unpackMapHeader();
        arrayOfValue = new Value[i * 2];
        for (b = 0; b < i * 2; ) {
          arrayOfValue[b] = unpackValue();
          b++;
          arrayOfValue[b] = unpackValue();
          b++;
        } 
        paramVariable.setMapValue(arrayOfValue);
        return paramVariable;
      case 9:
        extensionTypeHeader = unpackExtensionTypeHeader();
        switch (extensionTypeHeader.getType()) {
          case -1:
            paramVariable.setTimestampValue(unpackTimestamp(extensionTypeHeader));
            return paramVariable;
        } 
        paramVariable.setExtensionValue(extensionTypeHeader.getType(), readPayload(extensionTypeHeader.getLength()));
        return paramVariable;
    } 
    throw new MessageFormatException("Unknown value type");
  }
  
  public void unpackNil() throws IOException {
    byte b = readByte();
    if (b == -64)
      return; 
    throw unexpected("Nil", b);
  }
  
  public boolean tryUnpackNil() throws IOException {
    if (!ensureBuffer())
      throw new MessageInsufficientBufferException(); 
    byte b = this.buffer.getByte(this.position);
    if (b == -64) {
      readByte();
      return true;
    } 
    return false;
  }
  
  public boolean unpackBoolean() throws IOException {
    byte b = readByte();
    if (b == -62)
      return false; 
    if (b == -61)
      return true; 
    throw unexpected("boolean", b);
  }
  
  public byte unpackByte() throws IOException {
    long l2;
    int j;
    short s2;
    long l1;
    int i;
    short s1;
    byte b2, b1 = readByte();
    if (MessagePack.Code.isFixInt(b1))
      return b1; 
    switch (b1) {
      case -52:
        b2 = readByte();
        if (b2 < 0)
          throw overflowU8(b2); 
        return b2;
      case -51:
        s1 = readShort();
        if (s1 < 0 || s1 > 127)
          throw overflowU16(s1); 
        return (byte)s1;
      case -50:
        i = readInt();
        if (i < 0 || i > 127)
          throw overflowU32(i); 
        return (byte)i;
      case -49:
        l1 = readLong();
        if (l1 < 0L || l1 > 127L)
          throw overflowU64(l1); 
        return (byte)(int)l1;
      case -48:
        return readByte();
      case -47:
        s2 = readShort();
        if (s2 < -128 || s2 > 127)
          throw overflowI16(s2); 
        return (byte)s2;
      case -46:
        j = readInt();
        if (j < -128 || j > 127)
          throw overflowI32(j); 
        return (byte)j;
      case -45:
        l2 = readLong();
        if (l2 < -128L || l2 > 127L)
          throw overflowI64(l2); 
        return (byte)(int)l2;
    } 
    throw unexpected("Integer", b1);
  }
  
  public short unpackShort() throws IOException {
    long l2;
    int j;
    byte b3;
    long l1;
    int i;
    short s;
    byte b2, b1 = readByte();
    if (MessagePack.Code.isFixInt(b1))
      return (short)b1; 
    switch (b1) {
      case -52:
        b2 = readByte();
        return (short)(b2 & 0xFF);
      case -51:
        s = readShort();
        if (s < 0)
          throw overflowU16(s); 
        return s;
      case -50:
        i = readInt();
        if (i < 0 || i > 32767)
          throw overflowU32(i); 
        return (short)i;
      case -49:
        l1 = readLong();
        if (l1 < 0L || l1 > 32767L)
          throw overflowU64(l1); 
        return (short)(int)l1;
      case -48:
        b3 = readByte();
        return (short)b3;
      case -47:
        return readShort();
      case -46:
        j = readInt();
        if (j < -32768 || j > 32767)
          throw overflowI32(j); 
        return (short)j;
      case -45:
        l2 = readLong();
        if (l2 < -32768L || l2 > 32767L)
          throw overflowI64(l2); 
        return (short)(int)l2;
    } 
    throw unexpected("Integer", b1);
  }
  
  public int unpackInt() throws IOException {
    long l2, l1;
    int i;
    short s;
    byte b2, b1 = readByte();
    if (MessagePack.Code.isFixInt(b1))
      return b1; 
    switch (b1) {
      case -52:
        b2 = readByte();
        return b2 & 0xFF;
      case -51:
        s = readShort();
        return s & 0xFFFF;
      case -50:
        i = readInt();
        if (i < 0)
          throw overflowU32(i); 
        return i;
      case -49:
        l1 = readLong();
        if (l1 < 0L || l1 > 2147483647L)
          throw overflowU64(l1); 
        return (int)l1;
      case -48:
        return readByte();
      case -47:
        return readShort();
      case -46:
        return readInt();
      case -45:
        l2 = readLong();
        if (l2 < -2147483648L || l2 > 2147483647L)
          throw overflowI64(l2); 
        return (int)l2;
    } 
    throw unexpected("Integer", b1);
  }
  
  public long unpackLong() {
    int j;
    short s2;
    byte b3;
    long l;
    int i;
    short s1;
    byte b2, b1 = readByte();
    if (MessagePack.Code.isFixInt(b1))
      return b1; 
    switch (b1) {
      case -52:
        b2 = readByte();
        return (b2 & 0xFF);
      case -51:
        s1 = readShort();
        return (s1 & 0xFFFF);
      case -50:
        i = readInt();
        if (i < 0)
          return (i & 0x7FFFFFFF) + 2147483648L; 
        return i;
      case -49:
        l = readLong();
        if (l < 0L)
          throw overflowU64(l); 
        return l;
      case -48:
        b3 = readByte();
        return b3;
      case -47:
        s2 = readShort();
        return s2;
      case -46:
        j = readInt();
        return j;
      case -45:
        return readLong();
    } 
    throw unexpected("Integer", b1);
  }
  
  public BigInteger unpackBigInteger() throws IOException {
    long l2;
    int j;
    short s2;
    byte b3;
    long l1;
    int i;
    short s1;
    byte b2, b1 = readByte();
    if (MessagePack.Code.isFixInt(b1))
      return BigInteger.valueOf(b1); 
    switch (b1) {
      case -52:
        b2 = readByte();
        return BigInteger.valueOf((b2 & 0xFF));
      case -51:
        s1 = readShort();
        return BigInteger.valueOf((s1 & 0xFFFF));
      case -50:
        i = readInt();
        if (i < 0)
          return BigInteger.valueOf((i & 0x7FFFFFFF) + 2147483648L); 
        return BigInteger.valueOf(i);
      case -49:
        l1 = readLong();
        if (l1 < 0L)
          return BigInteger.valueOf(l1 + Float.MAX_VALUE + 1L).setBit(63); 
        return BigInteger.valueOf(l1);
      case -48:
        b3 = readByte();
        return BigInteger.valueOf(b3);
      case -47:
        s2 = readShort();
        return BigInteger.valueOf(s2);
      case -46:
        j = readInt();
        return BigInteger.valueOf(j);
      case -45:
        l2 = readLong();
        return BigInteger.valueOf(l2);
    } 
    throw unexpected("Integer", b1);
  }
  
  public float unpackFloat() throws IOException {
    double d;
    byte b = readByte();
    switch (b) {
      case -54:
        return readFloat();
      case -53:
        d = readDouble();
        return (float)d;
    } 
    throw unexpected("Float", b);
  }
  
  public double unpackDouble() throws IOException {
    float f;
    byte b = readByte();
    switch (b) {
      case -54:
        f = readFloat();
        return f;
      case -53:
        return readDouble();
    } 
    throw unexpected("Float", b);
  }
  
  private void resetDecoder() throws IOException {
    if (this.decoder == null) {
      this.decodeBuffer = CharBuffer.allocate(this.stringDecoderBufferSize);
      this
        
        .decoder = MessagePack.UTF8.newDecoder().onMalformedInput(this.actionOnMalformedString).onUnmappableCharacter(this.actionOnUnmappableString);
    } else {
      this.decoder.reset();
    } 
    if (this.decodeStringBuffer == null) {
      this.decodeStringBuffer = new StringBuilder();
    } else {
      this.decodeStringBuffer.setLength(0);
    } 
  }
  
  public String unpackString() throws IOException {
    int i = unpackRawStringHeader();
    if (i == 0)
      return ""; 
    if (i > this.stringSizeLimit)
      throw new MessageSizeException(String.format("cannot unpack a String of size larger than %,d: %,d", new Object[] { Integer.valueOf(this.stringSizeLimit), Integer.valueOf(i) }), i); 
    resetDecoder();
    if (this.buffer.size() - this.position >= i)
      return decodeStringFastPath(i); 
    try {
      int j = i;
      while (j > 0) {
        int k = this.buffer.size() - this.position;
        if (k >= j) {
          this.decodeStringBuffer.append(decodeStringFastPath(j));
          break;
        } 
        if (k == 0) {
          nextBuffer();
          continue;
        } 
        ByteBuffer byteBuffer = this.buffer.sliceAsByteBuffer(this.position, k);
        int m = byteBuffer.position();
        this.decodeBuffer.clear();
        CoderResult coderResult = this.decoder.decode(byteBuffer, this.decodeBuffer, false);
        int n = byteBuffer.position() - m;
        this.position += n;
        j -= n;
        this.decodeStringBuffer.append(this.decodeBuffer.flip());
        if (coderResult.isError())
          handleCoderError(coderResult); 
        if (coderResult.isUnderflow() && n < k) {
          int i1 = utf8MultibyteCharacterSize(this.buffer.getByte(this.position));
          ByteBuffer byteBuffer1 = ByteBuffer.allocate(i1);
          this.buffer.getBytes(this.position, this.buffer.size() - this.position, byteBuffer1);
          while (true) {
            nextBuffer();
            int i2 = byteBuffer1.remaining();
            if (this.buffer.size() >= i2) {
              this.buffer.getBytes(0, i2, byteBuffer1);
              this.position = i2;
              break;
            } 
            this.buffer.getBytes(0, this.buffer.size(), byteBuffer1);
            this.position = this.buffer.size();
          } 
          byteBuffer1.position(0);
          this.decodeBuffer.clear();
          coderResult = this.decoder.decode(byteBuffer1, this.decodeBuffer, false);
          if (coderResult.isError())
            handleCoderError(coderResult); 
          if (coderResult.isOverflow() || (coderResult.isUnderflow() && byteBuffer1.position() < byteBuffer1.limit()))
            try {
              coderResult.throwException();
              throw new MessageFormatException("Unexpected UTF-8 multibyte sequence");
            } catch (Exception exception) {
              throw new MessageFormatException("Unexpected UTF-8 multibyte sequence", exception);
            }  
          j -= byteBuffer1.limit();
          this.decodeStringBuffer.append(this.decodeBuffer.flip());
        } 
      } 
      return this.decodeStringBuffer.toString();
    } catch (CharacterCodingException characterCodingException) {
      throw new MessageStringCodingException(characterCodingException);
    } 
  }
  
  private void handleCoderError(CoderResult paramCoderResult) throws CharacterCodingException {
    if ((paramCoderResult.isMalformed() && this.actionOnMalformedString == CodingErrorAction.REPORT) || (paramCoderResult
      .isUnmappable() && this.actionOnUnmappableString == CodingErrorAction.REPORT))
      paramCoderResult.throwException(); 
  }
  
  private String decodeStringFastPath(int paramInt) {
    CharBuffer charBuffer;
    if (this.actionOnMalformedString == CodingErrorAction.REPLACE && this.actionOnUnmappableString == CodingErrorAction.REPLACE && this.buffer
      
      .hasArray()) {
      String str = new String(this.buffer.array(), this.buffer.arrayOffset() + this.position, paramInt, MessagePack.UTF8);
      this.position += paramInt;
      return str;
    } 
    ByteBuffer byteBuffer = this.buffer.sliceAsByteBuffer(this.position, paramInt);
    try {
      charBuffer = this.decoder.decode(byteBuffer);
    } catch (CharacterCodingException characterCodingException) {
      throw new MessageStringCodingException(characterCodingException);
    } 
    this.position += paramInt;
    return charBuffer.toString();
  }
  
  public Instant unpackTimestamp() throws IOException {
    ExtensionTypeHeader extensionTypeHeader = unpackExtensionTypeHeader();
    return unpackTimestamp(extensionTypeHeader);
  }
  
  public Instant unpackTimestamp(ExtensionTypeHeader paramExtensionTypeHeader) throws IOException {
    long l3;
    int i;
    long l2;
    long l1;
    if (paramExtensionTypeHeader.getType() != -1)
      throw unexpectedExtension("Timestamp", -1, paramExtensionTypeHeader.getType()); 
    switch (paramExtensionTypeHeader.getLength()) {
      case 4:
        l1 = readInt() & 0xFFFFFFFFL;
        return Instant.ofEpochSecond(l1);
      case 8:
        l1 = readLong();
        i = (int)(l1 >>> 34);
        l3 = l1 & 0x3FFFFFFFFL;
        return Instant.ofEpochSecond(l3, i);
      case 12:
        l1 = readInt() & 0xFFFFFFFFL;
        l2 = readLong();
        return Instant.ofEpochSecond(l2, l1);
    } 
    throw new MessageFormatException(String.format("Timestamp extension type (%d) expects 4, 8, or 12 bytes of payload but got %d bytes", new Object[] { Byte.valueOf((byte)-1), Integer.valueOf(paramExtensionTypeHeader.getLength()) }));
  }
  
  public int unpackArrayHeader() throws IOException {
    byte b = readByte();
    if (MessagePack.Code.isFixedArray(b))
      return b & 0xF; 
    switch (b) {
      case -36:
        return readNextLength16();
      case -35:
        return readNextLength32();
    } 
    throw unexpected("Array", b);
  }
  
  public int unpackMapHeader() throws IOException {
    byte b = readByte();
    if (MessagePack.Code.isFixedMap(b))
      return b & 0xF; 
    switch (b) {
      case -34:
        return readNextLength16();
      case -33:
        return readNextLength32();
    } 
    throw unexpected("Map", b);
  }
  
  public ExtensionTypeHeader unpackExtensionTypeHeader() throws IOException {
    byte b5, b4;
    short s2;
    int j, i;
    short s1;
    byte b3, b2;
    MessageBuffer messageBuffer;
    byte b1 = readByte();
    switch (b1) {
      case -44:
        b2 = readByte();
        return new ExtensionTypeHeader(b2, 1);
      case -43:
        b2 = readByte();
        return new ExtensionTypeHeader(b2, 2);
      case -42:
        b2 = readByte();
        return new ExtensionTypeHeader(b2, 4);
      case -41:
        b2 = readByte();
        return new ExtensionTypeHeader(b2, 8);
      case -40:
        b2 = readByte();
        return new ExtensionTypeHeader(b2, 16);
      case -57:
        messageBuffer = prepareNumberBuffer(2);
        b3 = messageBuffer.getByte(this.nextReadPosition);
        b4 = b3 & 0xFF;
        b5 = messageBuffer.getByte(this.nextReadPosition + 1);
        return new ExtensionTypeHeader(b5, b4);
      case -56:
        messageBuffer = prepareNumberBuffer(3);
        s1 = messageBuffer.getShort(this.nextReadPosition);
        s2 = s1 & 0xFFFF;
        b5 = messageBuffer.getByte(this.nextReadPosition + 2);
        return new ExtensionTypeHeader(b5, s2);
      case -55:
        messageBuffer = prepareNumberBuffer(5);
        i = messageBuffer.getInt(this.nextReadPosition);
        if (i < 0)
          throw overflowU32Size(i); 
        j = i;
        b5 = messageBuffer.getByte(this.nextReadPosition + 4);
        return new ExtensionTypeHeader(b5, j);
    } 
    throw unexpected("Ext", b1);
  }
  
  private int tryReadStringHeader(byte paramByte) {
    switch (paramByte) {
      case -39:
        return readNextLength8();
      case -38:
        return readNextLength16();
      case -37:
        return readNextLength32();
    } 
    return -1;
  }
  
  private int tryReadBinaryHeader(byte paramByte) {
    switch (paramByte) {
      case -60:
        return readNextLength8();
      case -59:
        return readNextLength16();
      case -58:
        return readNextLength32();
    } 
    return -1;
  }
  
  public int unpackRawStringHeader() throws IOException {
    byte b = readByte();
    if (MessagePack.Code.isFixedRaw(b))
      return b & 0x1F; 
    int i = tryReadStringHeader(b);
    if (i >= 0)
      return i; 
    if (this.allowReadingBinaryAsString) {
      i = tryReadBinaryHeader(b);
      if (i >= 0)
        return i; 
    } 
    throw unexpected("String", b);
  }
  
  public int unpackBinaryHeader() throws IOException {
    byte b = readByte();
    if (MessagePack.Code.isFixedRaw(b))
      return b & 0x1F; 
    int i = tryReadBinaryHeader(b);
    if (i >= 0)
      return i; 
    if (this.allowReadingStringAsBinary) {
      i = tryReadStringHeader(b);
      if (i >= 0)
        return i; 
    } 
    throw unexpected("Binary", b);
  }
  
  private void skipPayload(int paramInt) throws IOException {
    if (paramInt < 0)
      throw new IllegalArgumentException("payload size must be >= 0: " + paramInt); 
    while (true) {
      int i = this.buffer.size() - this.position;
      if (i >= paramInt) {
        this.position += paramInt;
        return;
      } 
      this.position += i;
      paramInt -= i;
      nextBuffer();
    } 
  }
  
  public void readPayload(ByteBuffer paramByteBuffer) throws IOException {
    while (true) {
      int i = paramByteBuffer.remaining();
      int j = this.buffer.size() - this.position;
      if (j >= i) {
        this.buffer.getBytes(this.position, i, paramByteBuffer);
        this.position += i;
        return;
      } 
      this.buffer.getBytes(this.position, j, paramByteBuffer);
      this.position += j;
      nextBuffer();
    } 
  }
  
  public void readPayload(MessageBuffer paramMessageBuffer, int paramInt1, int paramInt2) throws IOException {
    while (true) {
      int i = this.buffer.size() - this.position;
      if (i >= paramInt2) {
        paramMessageBuffer.putMessageBuffer(paramInt1, this.buffer, this.position, paramInt2);
        this.position += paramInt2;
        return;
      } 
      paramMessageBuffer.putMessageBuffer(paramInt1, this.buffer, this.position, i);
      paramInt1 += i;
      paramInt2 -= i;
      this.position += i;
      nextBuffer();
    } 
  }
  
  public void readPayload(byte[] paramArrayOfByte) throws IOException { readPayload(paramArrayOfByte, 0, paramArrayOfByte.length); }
  
  public byte[] readPayload(int paramInt) throws IOException {
    byte[] arrayOfByte = new byte[paramInt];
    readPayload(arrayOfByte);
    return arrayOfByte;
  }
  
  public void readPayload(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException {
    while (true) {
      int i = this.buffer.size() - this.position;
      if (i >= paramInt2) {
        this.buffer.getBytes(this.position, paramArrayOfByte, paramInt1, paramInt2);
        this.position += paramInt2;
        return;
      } 
      this.buffer.getBytes(this.position, paramArrayOfByte, paramInt1, i);
      paramInt1 += i;
      paramInt2 -= i;
      this.position += i;
      nextBuffer();
    } 
  }
  
  public MessageBuffer readPayloadAsReference(int paramInt) throws IOException {
    int i = this.buffer.size() - this.position;
    if (i >= paramInt) {
      MessageBuffer messageBuffer1 = this.buffer.slice(this.position, paramInt);
      this.position += paramInt;
      return messageBuffer1;
    } 
    MessageBuffer messageBuffer = MessageBuffer.allocate(paramInt);
    readPayload(messageBuffer, 0, paramInt);
    return messageBuffer;
  }
  
  private int readNextLength8() throws IOException {
    byte b = readByte();
    return b & 0xFF;
  }
  
  private int readNextLength16() throws IOException {
    short s = readShort();
    return s & 0xFFFF;
  }
  
  private int readNextLength32() throws IOException {
    int i = readInt();
    if (i < 0)
      throw overflowU32Size(i); 
    return i;
  }
  
  public void close() throws IOException {
    this.totalReadBytes += this.position;
    this.buffer = EMPTY_BUFFER;
    this.position = 0;
    this.in.close();
  }
  
  private static MessageIntegerOverflowException overflowU8(byte paramByte) {
    BigInteger bigInteger = BigInteger.valueOf((paramByte & 0xFF));
    return new MessageIntegerOverflowException(bigInteger);
  }
  
  private static MessageIntegerOverflowException overflowU16(short paramShort) {
    BigInteger bigInteger = BigInteger.valueOf((paramShort & 0xFFFF));
    return new MessageIntegerOverflowException(bigInteger);
  }
  
  private static MessageIntegerOverflowException overflowU32(int paramInt) {
    BigInteger bigInteger = BigInteger.valueOf((paramInt & 0x7FFFFFFF) + 2147483648L);
    return new MessageIntegerOverflowException(bigInteger);
  }
  
  private static MessageIntegerOverflowException overflowU64(long paramLong) {
    BigInteger bigInteger = BigInteger.valueOf(paramLong + Float.MAX_VALUE + 1L).setBit(63);
    return new MessageIntegerOverflowException(bigInteger);
  }
  
  private static MessageIntegerOverflowException overflowI16(short paramShort) {
    BigInteger bigInteger = BigInteger.valueOf(paramShort);
    return new MessageIntegerOverflowException(bigInteger);
  }
  
  private static MessageIntegerOverflowException overflowI32(int paramInt) {
    BigInteger bigInteger = BigInteger.valueOf(paramInt);
    return new MessageIntegerOverflowException(bigInteger);
  }
  
  private static MessageIntegerOverflowException overflowI64(long paramLong) {
    BigInteger bigInteger = BigInteger.valueOf(paramLong);
    return new MessageIntegerOverflowException(bigInteger);
  }
  
  private static MessageSizeException overflowU32Size(int paramInt) {
    long l = (paramInt & 0x7FFFFFFF) + 2147483648L;
    return new MessageSizeException(l);
  }
}
