package org.msgpack.core;

import java.io.Closeable;
import java.io.Flushable;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.CoderResult;
import java.nio.charset.CodingErrorAction;
import java.time.Instant;
import org.msgpack.core.buffer.MessageBuffer;
import org.msgpack.core.buffer.MessageBufferOutput;
import org.msgpack.value.Value;

public class MessagePacker implements Closeable, Flushable {
  private static final boolean CORRUPTED_CHARSET_ENCODER;
  
  private final int smallStringOptimizationThreshold;
  
  private final int bufferFlushThreshold;
  
  private final boolean str8FormatSupport;
  
  protected MessageBufferOutput out;
  
  private MessageBuffer buffer;
  
  private int position;
  
  private long totalFlushBytes;
  
  private CharsetEncoder encoder;
  
  private static final int UTF_8_MAX_CHAR_SIZE = 6;
  
  private static final long NANOS_PER_SECOND = 1000000000L;
  
  static  {
    boolean bool = false;
    try {
      Class clazz = Class.forName("android.os.Build$VERSION");
      Constructor constructor = clazz.getConstructor(new Class[0]);
      Object object = constructor.newInstance(new Object[0]);
      Field field = clazz.getField("SDK_INT");
      int i = field.getInt(object);
      if (i >= 14 && i < 21)
        bool = true; 
    } catch (ClassNotFoundException classNotFoundException) {
    
    } catch (NoSuchMethodException noSuchMethodException) {
      noSuchMethodException.printStackTrace();
    } catch (IllegalAccessException illegalAccessException) {
      illegalAccessException.printStackTrace();
    } catch (InstantiationException instantiationException) {
      instantiationException.printStackTrace();
    } catch (InvocationTargetException invocationTargetException) {
      invocationTargetException.printStackTrace();
    } catch (NoSuchFieldException noSuchFieldException) {
      noSuchFieldException.printStackTrace();
    } 
    CORRUPTED_CHARSET_ENCODER = bool;
  }
  
  protected MessagePacker(MessageBufferOutput paramMessageBufferOutput, MessagePack.PackerConfig paramPackerConfig) {
    this.out = (MessageBufferOutput)Preconditions.checkNotNull(paramMessageBufferOutput, "MessageBufferOutput is null");
    this.smallStringOptimizationThreshold = paramPackerConfig.getSmallStringOptimizationThreshold();
    this.bufferFlushThreshold = paramPackerConfig.getBufferFlushThreshold();
    this.str8FormatSupport = paramPackerConfig.isStr8FormatSupport();
    this.position = 0;
    this.totalFlushBytes = 0L;
  }
  
  public MessageBufferOutput reset(MessageBufferOutput paramMessageBufferOutput) throws IOException {
    MessageBufferOutput messageBufferOutput1 = (MessageBufferOutput)Preconditions.checkNotNull(paramMessageBufferOutput, "MessageBufferOutput is null");
    flush();
    MessageBufferOutput messageBufferOutput2 = this.out;
    this.out = messageBufferOutput1;
    this.totalFlushBytes = 0L;
    return messageBufferOutput2;
  }
  
  public long getTotalWrittenBytes() { return this.totalFlushBytes + this.position; }
  
  public void clear() { this.position = 0; }
  
  public void flush() {
    if (this.position > 0)
      flushBuffer(); 
    this.out.flush();
  }
  
  public void close() {
    try {
      flush();
    } finally {
      this.out.close();
    } 
  }
  
  private void flushBuffer() {
    this.out.writeBuffer(this.position);
    this.buffer = null;
    this.totalFlushBytes += this.position;
    this.position = 0;
  }
  
  private void ensureCapacity(int paramInt) throws IOException {
    if (this.buffer == null) {
      this.buffer = this.out.next(paramInt);
    } else if (this.position + paramInt >= this.buffer.size()) {
      flushBuffer();
      this.buffer = this.out.next(paramInt);
    } 
  }
  
  private void writeByte(byte paramByte) throws IOException {
    ensureCapacity(1);
    this.buffer.putByte(this.position++, paramByte);
  }
  
  private void writeByteAndByte(byte paramByte1, byte paramByte2) throws IOException {
    ensureCapacity(2);
    this.buffer.putByte(this.position++, paramByte1);
    this.buffer.putByte(this.position++, paramByte2);
  }
  
  private void writeByteAndShort(byte paramByte, short paramShort) throws IOException {
    ensureCapacity(3);
    this.buffer.putByte(this.position++, paramByte);
    this.buffer.putShort(this.position, paramShort);
    this.position += 2;
  }
  
  private void writeByteAndInt(byte paramByte, int paramInt) throws IOException {
    ensureCapacity(5);
    this.buffer.putByte(this.position++, paramByte);
    this.buffer.putInt(this.position, paramInt);
    this.position += 4;
  }
  
  private void writeByteAndFloat(byte paramByte, float paramFloat) throws IOException {
    ensureCapacity(5);
    this.buffer.putByte(this.position++, paramByte);
    this.buffer.putFloat(this.position, paramFloat);
    this.position += 4;
  }
  
  private void writeByteAndDouble(byte paramByte, double paramDouble) throws IOException {
    ensureCapacity(9);
    this.buffer.putByte(this.position++, paramByte);
    this.buffer.putDouble(this.position, paramDouble);
    this.position += 8;
  }
  
  private void writeByteAndLong(byte paramByte, long paramLong) throws IOException {
    ensureCapacity(9);
    this.buffer.putByte(this.position++, paramByte);
    this.buffer.putLong(this.position, paramLong);
    this.position += 8;
  }
  
  private void writeShort(short paramShort) throws IOException {
    ensureCapacity(2);
    this.buffer.putShort(this.position, paramShort);
    this.position += 2;
  }
  
  private void writeInt(int paramInt) throws IOException {
    ensureCapacity(4);
    this.buffer.putInt(this.position, paramInt);
    this.position += 4;
  }
  
  private void writeLong(long paramLong) throws IOException {
    ensureCapacity(8);
    this.buffer.putLong(this.position, paramLong);
    this.position += 8;
  }
  
  public MessagePacker packNil() throws IOException {
    writeByte((byte)-64);
    return this;
  }
  
  public MessagePacker packBoolean(boolean paramBoolean) throws IOException {
    writeByte(paramBoolean ? -61 : -62);
    return this;
  }
  
  public MessagePacker packByte(byte paramByte) throws IOException {
    if (paramByte < -32) {
      writeByteAndByte((byte)-48, paramByte);
    } else {
      writeByte(paramByte);
    } 
    return this;
  }
  
  public MessagePacker packShort(short paramShort) throws IOException {
    if (paramShort < -32) {
      if (paramShort < -128) {
        writeByteAndShort((byte)-47, paramShort);
      } else {
        writeByteAndByte((byte)-48, (byte)paramShort);
      } 
    } else if (paramShort < 128) {
      writeByte((byte)paramShort);
    } else if (paramShort < 256) {
      writeByteAndByte((byte)-52, (byte)paramShort);
    } else {
      writeByteAndShort((byte)-51, paramShort);
    } 
    return this;
  }
  
  public MessagePacker packInt(int paramInt) throws IOException {
    if (paramInt < -32) {
      if (paramInt < -32768) {
        writeByteAndInt((byte)-46, paramInt);
      } else if (paramInt < -128) {
        writeByteAndShort((byte)-47, (short)paramInt);
      } else {
        writeByteAndByte((byte)-48, (byte)paramInt);
      } 
    } else if (paramInt < 128) {
      writeByte((byte)paramInt);
    } else if (paramInt < 256) {
      writeByteAndByte((byte)-52, (byte)paramInt);
    } else if (paramInt < 65536) {
      writeByteAndShort((byte)-51, (short)paramInt);
    } else {
      writeByteAndInt((byte)-50, paramInt);
    } 
    return this;
  }
  
  public MessagePacker packLong(long paramLong) throws IOException {
    if (paramLong < -32L) {
      if (paramLong < -32768L) {
        if (paramLong < -2147483648L) {
          writeByteAndLong((byte)-45, paramLong);
        } else {
          writeByteAndInt((byte)-46, (int)paramLong);
        } 
      } else if (paramLong < -128L) {
        writeByteAndShort((byte)-47, (short)(int)paramLong);
      } else {
        writeByteAndByte((byte)-48, (byte)(int)paramLong);
      } 
    } else if (paramLong < 128L) {
      writeByte((byte)(int)paramLong);
    } else if (paramLong < 65536L) {
      if (paramLong < 256L) {
        writeByteAndByte((byte)-52, (byte)(int)paramLong);
      } else {
        writeByteAndShort((byte)-51, (short)(int)paramLong);
      } 
    } else if (paramLong < 4294967296L) {
      writeByteAndInt((byte)-50, (int)paramLong);
    } else {
      writeByteAndLong((byte)-49, paramLong);
    } 
    return this;
  }
  
  public MessagePacker packBigInteger(BigInteger paramBigInteger) throws IOException {
    if (paramBigInteger.bitLength() <= 63) {
      packLong(paramBigInteger.longValue());
    } else if (paramBigInteger.bitLength() == 64 && paramBigInteger.signum() == 1) {
      writeByteAndLong((byte)-49, paramBigInteger.longValue());
    } else {
      throw new IllegalArgumentException("MessagePack cannot serialize BigInteger larger than 2^64-1");
    } 
    return this;
  }
  
  public MessagePacker packFloat(float paramFloat) throws IOException {
    writeByteAndFloat((byte)-54, paramFloat);
    return this;
  }
  
  public MessagePacker packDouble(double paramDouble) throws IOException {
    writeByteAndDouble((byte)-53, paramDouble);
    return this;
  }
  
  private void packStringWithGetBytes(String paramString) throws IOException {
    byte[] arrayOfByte = paramString.getBytes(MessagePack.UTF8);
    packRawStringHeader(arrayOfByte.length);
    addPayload(arrayOfByte);
  }
  
  private void prepareEncoder() {
    if (this.encoder == null)
      this
        
        .encoder = MessagePack.UTF8.newEncoder().onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE); 
    this.encoder.reset();
  }
  
  private int encodeStringToBufferAt(int paramInt, String paramString) {
    prepareEncoder();
    ByteBuffer byteBuffer = this.buffer.sliceAsByteBuffer(paramInt, this.buffer.size() - paramInt);
    int i = byteBuffer.position();
    CharBuffer charBuffer = CharBuffer.wrap(paramString);
    CoderResult coderResult = this.encoder.encode(charBuffer, byteBuffer, true);
    if (coderResult.isError())
      try {
        coderResult.throwException();
      } catch (CharacterCodingException characterCodingException) {
        throw new MessageStringCodingException(characterCodingException);
      }  
    if (!coderResult.isUnderflow() || coderResult.isOverflow())
      return -1; 
    coderResult = this.encoder.flush(byteBuffer);
    if (!coderResult.isUnderflow())
      return -1; 
    return byteBuffer.position() - i;
  }
  
  public MessagePacker packString(String paramString) throws IOException {
    if (paramString.length() <= 0) {
      packRawStringHeader(0);
      return this;
    } 
    if (CORRUPTED_CHARSET_ENCODER || paramString.length() < this.smallStringOptimizationThreshold) {
      packStringWithGetBytes(paramString);
      return this;
    } 
    if (paramString.length() < 256) {
      ensureCapacity(2 + paramString.length() * 6 + 1);
      int i = encodeStringToBufferAt(this.position + 2, paramString);
      if (i >= 0) {
        if (this.str8FormatSupport && i < 256) {
          this.buffer.putByte(this.position++, (byte)-39);
          this.buffer.putByte(this.position++, (byte)i);
          this.position += i;
        } else {
          if (i >= 65536)
            throw new IllegalArgumentException("Unexpected UTF-8 encoder state"); 
          this.buffer.putMessageBuffer(this.position + 3, this.buffer, this.position + 2, i);
          this.buffer.putByte(this.position++, (byte)-38);
          this.buffer.putShort(this.position, (short)i);
          this.position += 2;
          this.position += i;
        } 
        return this;
      } 
    } else if (paramString.length() < 65536) {
      ensureCapacity(3 + paramString.length() * 6 + 2);
      int i = encodeStringToBufferAt(this.position + 3, paramString);
      if (i >= 0) {
        if (i < 65536) {
          this.buffer.putByte(this.position++, (byte)-38);
          this.buffer.putShort(this.position, (short)i);
          this.position += 2;
          this.position += i;
        } else {
          if (i >= 4294967296L)
            throw new IllegalArgumentException("Unexpected UTF-8 encoder state"); 
          this.buffer.putMessageBuffer(this.position + 5, this.buffer, this.position + 3, i);
          this.buffer.putByte(this.position++, (byte)-37);
          this.buffer.putInt(this.position, i);
          this.position += 4;
          this.position += i;
        } 
        return this;
      } 
    } 
    packStringWithGetBytes(paramString);
    return this;
  }
  
  public MessagePacker packTimestamp(Instant paramInstant) throws IOException { return packTimestamp(paramInstant.getEpochSecond(), paramInstant.getNano()); }
  
  public MessagePacker packTimestamp(long paramLong) throws IOException { return packTimestamp(Instant.ofEpochMilli(paramLong)); }
  
  public MessagePacker packTimestamp(long paramLong, int paramInt) throws IOException, ArithmeticException {
    long l1 = Math.addExact(paramLong, Math.floorDiv(paramInt, 1000000000L));
    long l2 = Math.floorMod(paramInt, 1000000000L);
    if (l1 >>> 34 == 0L) {
      long l = l2 << 34 | l1;
      if ((l & 0xFFFFFFFF00000000L) == 0L) {
        writeTimestamp32((int)l1);
      } else {
        writeTimestamp64(l);
      } 
    } else {
      writeTimestamp96(l1, (int)l2);
    } 
    return this;
  }
  
  private void writeTimestamp32(int paramInt) throws IOException {
    ensureCapacity(6);
    this.buffer.putByte(this.position++, (byte)-42);
    this.buffer.putByte(this.position++, (byte)-1);
    this.buffer.putInt(this.position, paramInt);
    this.position += 4;
  }
  
  private void writeTimestamp64(long paramLong) throws IOException {
    ensureCapacity(10);
    this.buffer.putByte(this.position++, (byte)-41);
    this.buffer.putByte(this.position++, (byte)-1);
    this.buffer.putLong(this.position, paramLong);
    this.position += 8;
  }
  
  private void writeTimestamp96(long paramLong, int paramInt) throws IOException {
    ensureCapacity(15);
    this.buffer.putByte(this.position++, (byte)-57);
    this.buffer.putByte(this.position++, (byte)12);
    this.buffer.putByte(this.position++, (byte)-1);
    this.buffer.putInt(this.position, paramInt);
    this.position += 4;
    this.buffer.putLong(this.position, paramLong);
    this.position += 8;
  }
  
  public MessagePacker packArrayHeader(int paramInt) throws IOException {
    if (paramInt < 0)
      throw new IllegalArgumentException("array size must be >= 0"); 
    if (paramInt < 16) {
      writeByte((byte)(0xFFFFFF90 | paramInt));
    } else if (paramInt < 65536) {
      writeByteAndShort((byte)-36, (short)paramInt);
    } else {
      writeByteAndInt((byte)-35, paramInt);
    } 
    return this;
  }
  
  public MessagePacker packMapHeader(int paramInt) throws IOException {
    if (paramInt < 0)
      throw new IllegalArgumentException("map size must be >= 0"); 
    if (paramInt < 16) {
      writeByte((byte)(0xFFFFFF80 | paramInt));
    } else if (paramInt < 65536) {
      writeByteAndShort((byte)-34, (short)paramInt);
    } else {
      writeByteAndInt((byte)-33, paramInt);
    } 
    return this;
  }
  
  public MessagePacker packValue(Value paramValue) throws IOException {
    paramValue.writeTo(this);
    return this;
  }
  
  public MessagePacker packExtensionTypeHeader(byte paramByte, int paramInt) throws IOException {
    if (paramInt < 256) {
      if (paramInt > 0 && (paramInt & paramInt - 1) == 0) {
        if (paramInt == 1) {
          writeByteAndByte((byte)-44, paramByte);
        } else if (paramInt == 2) {
          writeByteAndByte((byte)-43, paramByte);
        } else if (paramInt == 4) {
          writeByteAndByte((byte)-42, paramByte);
        } else if (paramInt == 8) {
          writeByteAndByte((byte)-41, paramByte);
        } else if (paramInt == 16) {
          writeByteAndByte((byte)-40, paramByte);
        } else {
          writeByteAndByte((byte)-57, (byte)paramInt);
          writeByte(paramByte);
        } 
      } else {
        writeByteAndByte((byte)-57, (byte)paramInt);
        writeByte(paramByte);
      } 
    } else if (paramInt < 65536) {
      writeByteAndShort((byte)-56, (short)paramInt);
      writeByte(paramByte);
    } else {
      writeByteAndInt((byte)-55, paramInt);
      writeByte(paramByte);
    } 
    return this;
  }
  
  public MessagePacker packBinaryHeader(int paramInt) throws IOException {
    if (paramInt < 256) {
      writeByteAndByte((byte)-60, (byte)paramInt);
    } else if (paramInt < 65536) {
      writeByteAndShort((byte)-59, (short)paramInt);
    } else {
      writeByteAndInt((byte)-58, paramInt);
    } 
    return this;
  }
  
  public MessagePacker packRawStringHeader(int paramInt) throws IOException {
    if (paramInt < 32) {
      writeByte((byte)(0xFFFFFFA0 | paramInt));
    } else if (this.str8FormatSupport && paramInt < 256) {
      writeByteAndByte((byte)-39, (byte)paramInt);
    } else if (paramInt < 65536) {
      writeByteAndShort((byte)-38, (short)paramInt);
    } else {
      writeByteAndInt((byte)-37, paramInt);
    } 
    return this;
  }
  
  public MessagePacker writePayload(byte[] paramArrayOfByte) throws IOException { return writePayload(paramArrayOfByte, 0, paramArrayOfByte.length); }
  
  public MessagePacker writePayload(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException {
    if (this.buffer == null || this.buffer.size() - this.position < paramInt2 || paramInt2 > this.bufferFlushThreshold) {
      flush();
      this.out.write(paramArrayOfByte, paramInt1, paramInt2);
      this.totalFlushBytes += paramInt2;
    } else {
      this.buffer.putBytes(this.position, paramArrayOfByte, paramInt1, paramInt2);
      this.position += paramInt2;
    } 
    return this;
  }
  
  public MessagePacker addPayload(byte[] paramArrayOfByte) throws IOException { return addPayload(paramArrayOfByte, 0, paramArrayOfByte.length); }
  
  public MessagePacker addPayload(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException {
    if (this.buffer == null || this.buffer.size() - this.position < paramInt2 || paramInt2 > this.bufferFlushThreshold) {
      flush();
      this.out.add(paramArrayOfByte, paramInt1, paramInt2);
      this.totalFlushBytes += paramInt2;
    } else {
      this.buffer.putBytes(this.position, paramArrayOfByte, paramInt1, paramInt2);
      this.position += paramInt2;
    } 
    return this;
  }
}
