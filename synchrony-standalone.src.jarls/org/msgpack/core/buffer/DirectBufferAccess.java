package org.msgpack.core.buffer;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.security.AccessController;
import sun.nio.ch.DirectBuffer;

class DirectBufferAccess {
  static Method mCleaner;
  
  static Method mClean;
  
  static Method mInvokeCleaner;
  
  static Constructor<?> byteBufferConstructor;
  
  static Class<?> directByteBufferClass;
  
  static DirectBufferConstructorType directBufferConstructorType;
  
  static Method memoryBlockWrapFromJni;
  
  static  {
    try {
      ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1);
      directByteBufferClass = byteBuffer.getClass();
      Constructor constructor = null;
      DirectBufferConstructorType directBufferConstructorType1 = null;
      Method method = null;
      try {
        constructor = directByteBufferClass.getDeclaredConstructor(new Class[] { long.class, long.class });
        directBufferConstructorType1 = DirectBufferConstructorType.ARGS_LONG_LONG;
      } catch (NoSuchMethodException noSuchMethodException) {
        try {
          constructor = directByteBufferClass.getDeclaredConstructor(new Class[] { long.class, int.class, Object.class });
          directBufferConstructorType1 = DirectBufferConstructorType.ARGS_LONG_INT_REF;
        } catch (NoSuchMethodException noSuchMethodException1) {
          try {
            constructor = directByteBufferClass.getDeclaredConstructor(new Class[] { long.class, int.class });
            directBufferConstructorType1 = DirectBufferConstructorType.ARGS_LONG_INT;
          } catch (NoSuchMethodException noSuchMethodException2) {
            try {
              constructor = directByteBufferClass.getDeclaredConstructor(new Class[] { int.class, int.class });
              directBufferConstructorType1 = DirectBufferConstructorType.ARGS_INT_INT;
            } catch (NoSuchMethodException noSuchMethodException3) {
              Class clazz = Class.forName("java.nio.MemoryBlock");
              method = clazz.getDeclaredMethod("wrapFromJni", new Class[] { int.class, long.class });
              method.setAccessible(true);
              constructor = directByteBufferClass.getDeclaredConstructor(new Class[] { clazz, int.class, int.class });
              directBufferConstructorType1 = DirectBufferConstructorType.ARGS_MB_INT_INT;
            } 
          } 
        } 
      } 
      byteBufferConstructor = constructor;
      directBufferConstructorType = directBufferConstructorType1;
      memoryBlockWrapFromJni = method;
      if (byteBufferConstructor == null)
        throw new RuntimeException("Constructor of DirectByteBuffer is not found"); 
      try {
        byteBufferConstructor.setAccessible(true);
      } catch (RuntimeException runtimeException) {
        if ("java.lang.reflect.InaccessibleObjectException".equals(runtimeException.getClass().getName())) {
          byteBufferConstructor = null;
        } else {
          throw runtimeException;
        } 
      } 
      if (MessageBuffer.javaVersion <= 8) {
        setupCleanerJava6(byteBuffer);
      } else {
        setupCleanerJava9(byteBuffer);
      } 
    } catch (Exception exception) {
      throw new RuntimeException(exception);
    } 
  }
  
  private static void setupCleanerJava6(ByteBuffer paramByteBuffer) {
    Object object = AccessController.doPrivileged(new Object(paramByteBuffer));
    if (object instanceof Throwable)
      throw new RuntimeException((Throwable)object); 
    mCleaner = (Method)object;
    object = AccessController.doPrivileged(new Object(paramByteBuffer));
    if (object instanceof Throwable)
      throw new RuntimeException((Throwable)object); 
    mClean = (Method)object;
  }
  
  private static void setupCleanerJava9(ByteBuffer paramByteBuffer) {
    Object object = AccessController.doPrivileged(new Object(paramByteBuffer));
    if (object instanceof Throwable)
      throw new RuntimeException((Throwable)object); 
    mInvokeCleaner = (Method)object;
  }
  
  private static Object getCleanerMethod(ByteBuffer paramByteBuffer) {
    try {
      Method method = paramByteBuffer.getClass().getDeclaredMethod("cleaner", new Class[0]);
      method.setAccessible(true);
      method.invoke(paramByteBuffer, new Object[0]);
      return method;
    } catch (NoSuchMethodException noSuchMethodException) {
      return noSuchMethodException;
    } catch (InvocationTargetException invocationTargetException) {
      return invocationTargetException;
    } catch (IllegalAccessException illegalAccessException) {
      return illegalAccessException;
    } 
  }
  
  private static Object getCleanMethod(ByteBuffer paramByteBuffer, Method paramMethod) {
    try {
      Method method = paramMethod.getReturnType().getDeclaredMethod("clean", new Class[0]);
      Object object = paramMethod.invoke(paramByteBuffer, new Object[0]);
      method.setAccessible(true);
      method.invoke(object, new Object[0]);
      return method;
    } catch (NoSuchMethodException noSuchMethodException) {
      return noSuchMethodException;
    } catch (InvocationTargetException invocationTargetException) {
      return invocationTargetException;
    } catch (IllegalAccessException illegalAccessException) {
      return illegalAccessException;
    } 
  }
  
  private static Object getInvokeCleanerMethod(ByteBuffer paramByteBuffer) {
    try {
      Method method = MessageBuffer.unsafe.getClass().getDeclaredMethod("invokeCleaner", new Class[] { ByteBuffer.class });
      method.invoke(MessageBuffer.unsafe, new Object[] { paramByteBuffer });
      return method;
    } catch (NoSuchMethodException noSuchMethodException) {
      return noSuchMethodException;
    } catch (InvocationTargetException invocationTargetException) {
      return invocationTargetException;
    } catch (IllegalAccessException illegalAccessException) {
      return illegalAccessException;
    } 
  }
  
  static long getAddress(Buffer paramBuffer) { return ((DirectBuffer)paramBuffer).address(); }
  
  static void clean(Object paramObject) {
    try {
      if (MessageBuffer.javaVersion <= 8) {
        Object object = mCleaner.invoke(paramObject, new Object[0]);
        mClean.invoke(object, new Object[0]);
      } else {
        mInvokeCleaner.invoke(MessageBuffer.unsafe, new Object[] { paramObject });
      } 
    } catch (Throwable throwable) {
      throw new RuntimeException(throwable);
    } 
  }
  
  static boolean isDirectByteBufferInstance(Object paramObject) { return directByteBufferClass.isInstance(paramObject); }
  
  static ByteBuffer newByteBuffer(long paramLong, int paramInt1, int paramInt2, ByteBuffer paramByteBuffer) {
    if (byteBufferConstructor == null)
      throw new IllegalStateException("Can't create a new DirectByteBuffer. In JDK17+, two JVM options needs to be set: --add-opens=java.base/java.nio=ALL-UNNAMED and --add-opens=java.base/sun.nio.ch=ALL-UNNAMED"); 
    try {
      switch (null.$SwitchMap$org$msgpack$core$buffer$DirectBufferAccess$DirectBufferConstructorType[directBufferConstructorType.ordinal()]) {
        case 1:
          return (ByteBuffer)byteBufferConstructor.newInstance(new Object[] { Long.valueOf(paramLong + paramInt1), Long.valueOf(paramInt2) });
        case 2:
          return (ByteBuffer)byteBufferConstructor.newInstance(new Object[] { Long.valueOf(paramLong + paramInt1), Integer.valueOf(paramInt2), paramByteBuffer });
        case 3:
          return (ByteBuffer)byteBufferConstructor.newInstance(new Object[] { Long.valueOf(paramLong + paramInt1), Integer.valueOf(paramInt2) });
        case 4:
          return (ByteBuffer)byteBufferConstructor.newInstance(new Object[] { Integer.valueOf((int)paramLong + paramInt1), Integer.valueOf(paramInt2) });
        case 5:
          return (ByteBuffer)byteBufferConstructor.newInstance(new Object[] { memoryBlockWrapFromJni
                .invoke(null, new Object[] { Long.valueOf(paramLong + paramInt1), Integer.valueOf(paramInt2) }), Integer.valueOf(paramInt2), Integer.valueOf(0) });
      } 
      throw new IllegalStateException("Unexpected value");
    } catch (Throwable throwable) {
      throw new RuntimeException(throwable);
    } 
  }
}
