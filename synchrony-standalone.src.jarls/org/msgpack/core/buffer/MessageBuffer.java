package org.msgpack.core.buffer;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.nio.BufferOverflowException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import org.msgpack.core.Preconditions;
import sun.misc.Unsafe;

public class MessageBuffer {
  static final boolean isUniversalBuffer;
  
  static final Unsafe unsafe;
  
  static final int javaVersion = getJavaVersion();
  
  private static final Constructor<?> mbArrConstructor;
  
  private static final Constructor<?> mbBBConstructor;
  
  static final int ARRAY_BYTE_BASE_OFFSET;
  
  private static final String UNIVERSAL_MESSAGE_BUFFER = "org.msgpack.core.buffer.MessageBufferU";
  
  private static final String BIGENDIAN_MESSAGE_BUFFER = "org.msgpack.core.buffer.MessageBufferBE";
  
  private static final String DEFAULT_MESSAGE_BUFFER = "org.msgpack.core.buffer.MessageBuffer";
  
  protected final Object base;
  
  protected final long address;
  
  protected final int size;
  
  protected final ByteBuffer reference;
  
  static  {
    bool = false;
    unsafe1 = null;
    i = 16;
    try {
      boolean bool1 = false;
      try {
        bool1 = (Class.forName("sun.misc.Unsafe") != null) ? 1 : 0;
      } catch (Exception exception) {}
      bool2 = System.getProperty("java.runtime.name", "").toLowerCase().contains("android");
      boolean bool3 = (System.getProperty("com.google.appengine.runtime.version") != null) ? 1 : 0;
      bool = (Boolean.parseBoolean(System.getProperty("msgpack.universal-buffer", "false")) || bool2 || bool3 || javaVersion < 7 || !bool1) ? 1 : 0;
      if (!bool) {
        Field field = Unsafe.class.getDeclaredField("theUnsafe");
        field.setAccessible(true);
        unsafe1 = (Unsafe)field.get(null);
        if (unsafe1 == null)
          throw new RuntimeException("Unsafe is unavailable"); 
        i = unsafe1.arrayBaseOffset(byte[].class);
        int j = unsafe1.arrayIndexScale(byte[].class);
        if (j != 1)
          throw new IllegalStateException("Byte array index scale must be 1, but is " + j); 
      } 
    } catch (Exception null) {
      str.printStackTrace(System.err);
      bool = true;
    } finally {
      String str;
      unsafe = unsafe1;
      ARRAY_BYTE_BASE_OFFSET = i;
      isUniversalBuffer = bool;
      if (isUniversalBuffer) {
        str = "org.msgpack.core.buffer.MessageBufferU";
      } else {
        boolean bool1 = (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) ? 1 : 0;
        str = bool1 ? "org.msgpack.core.buffer.MessageBuffer" : "org.msgpack.core.buffer.MessageBufferBE";
      } 
      if ("org.msgpack.core.buffer.MessageBuffer".equals(str)) {
        mbArrConstructor = null;
        mbBBConstructor = null;
      } else {
        try {
          Class clazz = Class.forName(str);
          Constructor constructor1 = clazz.getDeclaredConstructor(new Class[] { byte[].class, int.class, int.class });
          constructor1.setAccessible(true);
          mbArrConstructor = constructor1;
          Constructor constructor2 = clazz.getDeclaredConstructor(new Class[] { ByteBuffer.class });
          constructor2.setAccessible(true);
          mbBBConstructor = constructor2;
        } catch (Exception exception) {
          exception.printStackTrace(System.err);
          throw new RuntimeException(exception);
        } 
      } 
    } 
  }
  
  private static int getJavaVersion() {
    String str = System.getProperty("java.specification.version", "");
    int i = str.indexOf('.');
    if (i != -1) {
      try {
        int j = Integer.parseInt(str.substring(0, i));
        int k = Integer.parseInt(str.substring(i + 1));
        return (j > 1) ? j : k;
      } catch (NumberFormatException numberFormatException) {
        numberFormatException.printStackTrace(System.err);
      } 
    } else {
      try {
        return Integer.parseInt(str);
      } catch (NumberFormatException numberFormatException) {
        numberFormatException.printStackTrace(System.err);
      } 
    } 
    return 6;
  }
  
  public static MessageBuffer allocate(int paramInt) {
    if (paramInt < 0)
      throw new IllegalArgumentException("size must not be negative"); 
    return wrap(new byte[paramInt]);
  }
  
  public static MessageBuffer wrap(byte[] paramArrayOfByte) { return newMessageBuffer(paramArrayOfByte, 0, paramArrayOfByte.length); }
  
  public static MessageBuffer wrap(byte[] paramArrayOfByte, int paramInt1, int paramInt2) { return newMessageBuffer(paramArrayOfByte, paramInt1, paramInt2); }
  
  public static MessageBuffer wrap(ByteBuffer paramByteBuffer) { return newMessageBuffer(paramByteBuffer); }
  
  private static MessageBuffer newMessageBuffer(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    Preconditions.checkNotNull(paramArrayOfByte);
    if (mbArrConstructor != null)
      return newInstance(mbArrConstructor, new Object[] { paramArrayOfByte, Integer.valueOf(paramInt1), Integer.valueOf(paramInt2) }); 
    return new MessageBuffer(paramArrayOfByte, paramInt1, paramInt2);
  }
  
  private static MessageBuffer newMessageBuffer(ByteBuffer paramByteBuffer) {
    Preconditions.checkNotNull(paramByteBuffer);
    if (mbBBConstructor != null)
      return newInstance(mbBBConstructor, new Object[] { paramByteBuffer }); 
    return new MessageBuffer(paramByteBuffer);
  }
  
  private static MessageBuffer newInstance(Constructor<?> paramConstructor, Object... paramVarArgs) {
    try {
      return (MessageBuffer)paramConstructor.newInstance(paramVarArgs);
    } catch (InstantiationException instantiationException) {
      throw new IllegalStateException(instantiationException);
    } catch (IllegalAccessException illegalAccessException) {
      throw new IllegalStateException(illegalAccessException);
    } catch (InvocationTargetException invocationTargetException) {
      if (invocationTargetException.getCause() instanceof RuntimeException)
        throw (RuntimeException)invocationTargetException.getCause(); 
      if (invocationTargetException.getCause() instanceof Error)
        throw (Error)invocationTargetException.getCause(); 
      throw new IllegalStateException(invocationTargetException.getCause());
    } 
  }
  
  public static void releaseBuffer(MessageBuffer paramMessageBuffer) {
    if (!isUniversalBuffer && !paramMessageBuffer.hasArray())
      if (DirectBufferAccess.isDirectByteBufferInstance(paramMessageBuffer.reference)) {
        DirectBufferAccess.clean(paramMessageBuffer.reference);
      } else {
        unsafe.freeMemory(paramMessageBuffer.address);
      }  
  }
  
  MessageBuffer(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    this.base = paramArrayOfByte;
    this.address = (ARRAY_BYTE_BASE_OFFSET + paramInt1);
    this.size = paramInt2;
    this.reference = null;
  }
  
  MessageBuffer(ByteBuffer paramByteBuffer) {
    if (paramByteBuffer.isDirect()) {
      if (isUniversalBuffer) {
        this.base = null;
        this.address = 0L;
        this.size = paramByteBuffer.remaining();
        this.reference = null;
        return;
      } 
      this.base = null;
      this.address = DirectBufferAccess.getAddress(paramByteBuffer) + paramByteBuffer.position();
      this.size = paramByteBuffer.remaining();
      this.reference = paramByteBuffer;
    } else if (paramByteBuffer.hasArray()) {
      this.base = paramByteBuffer.array();
      this.address = (ARRAY_BYTE_BASE_OFFSET + paramByteBuffer.arrayOffset() + paramByteBuffer.position());
      this.size = paramByteBuffer.remaining();
      this.reference = null;
    } else {
      throw new IllegalArgumentException("Only the array-backed ByteBuffer or DirectBuffer is supported");
    } 
  }
  
  protected MessageBuffer(Object paramObject, long paramLong, int paramInt) {
    this.base = paramObject;
    this.address = paramLong;
    this.size = paramInt;
    this.reference = null;
  }
  
  public int size() { return this.size; }
  
  public MessageBuffer slice(int paramInt1, int paramInt2) {
    if (paramInt1 == 0 && paramInt2 == size())
      return this; 
    Preconditions.checkArgument((paramInt1 + paramInt2 <= size()));
    return new MessageBuffer(this.base, this.address + paramInt1, paramInt2);
  }
  
  public byte getByte(int paramInt) { return unsafe.getByte(this.base, this.address + paramInt); }
  
  public boolean getBoolean(int paramInt) { return unsafe.getBoolean(this.base, this.address + paramInt); }
  
  public short getShort(int paramInt) {
    short s = unsafe.getShort(this.base, this.address + paramInt);
    return Short.reverseBytes(s);
  }
  
  public int getInt(int paramInt) {
    int i = unsafe.getInt(this.base, this.address + paramInt);
    return Integer.reverseBytes(i);
  }
  
  public float getFloat(int paramInt) { return Float.intBitsToFloat(getInt(paramInt)); }
  
  public long getLong(int paramInt) {
    long l = unsafe.getLong(this.base, this.address + paramInt);
    return Long.reverseBytes(l);
  }
  
  public double getDouble(int paramInt) { return Double.longBitsToDouble(getLong(paramInt)); }
  
  public void getBytes(int paramInt1, byte[] paramArrayOfByte, int paramInt2, int paramInt3) { unsafe.copyMemory(this.base, this.address + paramInt1, paramArrayOfByte, (ARRAY_BYTE_BASE_OFFSET + paramInt2), paramInt3); }
  
  public void getBytes(int paramInt1, int paramInt2, ByteBuffer paramByteBuffer) {
    if (paramByteBuffer.remaining() < paramInt2)
      throw new BufferOverflowException(); 
    ByteBuffer byteBuffer = sliceAsByteBuffer(paramInt1, paramInt2);
    paramByteBuffer.put(byteBuffer);
  }
  
  public void putByte(int paramInt, byte paramByte) { unsafe.putByte(this.base, this.address + paramInt, paramByte); }
  
  public void putBoolean(int paramInt, boolean paramBoolean) { unsafe.putBoolean(this.base, this.address + paramInt, paramBoolean); }
  
  public void putShort(int paramInt, short paramShort) {
    paramShort = Short.reverseBytes(paramShort);
    unsafe.putShort(this.base, this.address + paramInt, paramShort);
  }
  
  public void putInt(int paramInt1, int paramInt2) {
    paramInt2 = Integer.reverseBytes(paramInt2);
    unsafe.putInt(this.base, this.address + paramInt1, paramInt2);
  }
  
  public void putFloat(int paramInt, float paramFloat) { putInt(paramInt, Float.floatToRawIntBits(paramFloat)); }
  
  public void putLong(int paramInt, long paramLong) {
    paramLong = Long.reverseBytes(paramLong);
    unsafe.putLong(this.base, this.address + paramInt, paramLong);
  }
  
  public void putDouble(int paramInt, double paramDouble) { putLong(paramInt, Double.doubleToRawLongBits(paramDouble)); }
  
  public void putBytes(int paramInt1, byte[] paramArrayOfByte, int paramInt2, int paramInt3) { unsafe.copyMemory(paramArrayOfByte, (ARRAY_BYTE_BASE_OFFSET + paramInt2), this.base, this.address + paramInt1, paramInt3); }
  
  public void putByteBuffer(int paramInt1, ByteBuffer paramByteBuffer, int paramInt2) {
    assert paramInt2 <= paramByteBuffer.remaining();
    assert !isUniversalBuffer;
    if (paramByteBuffer.isDirect()) {
      unsafe.copyMemory(null, DirectBufferAccess.getAddress(paramByteBuffer) + paramByteBuffer.position(), this.base, this.address + paramInt1, paramInt2);
      paramByteBuffer.position(paramByteBuffer.position() + paramInt2);
    } else if (paramByteBuffer.hasArray()) {
      byte[] arrayOfByte = paramByteBuffer.array();
      unsafe.copyMemory(arrayOfByte, (ARRAY_BYTE_BASE_OFFSET + paramByteBuffer.position()), this.base, this.address + paramInt1, paramInt2);
      paramByteBuffer.position(paramByteBuffer.position() + paramInt2);
    } else if (hasArray()) {
      paramByteBuffer.get((byte[])this.base, paramInt1, paramInt2);
    } else {
      for (byte b = 0; b < paramInt2; b++)
        unsafe.putByte(this.base, this.address + paramInt1, paramByteBuffer.get()); 
    } 
  }
  
  public void putMessageBuffer(int paramInt1, MessageBuffer paramMessageBuffer, int paramInt2, int paramInt3) { unsafe.copyMemory(paramMessageBuffer.base, paramMessageBuffer.address + paramInt2, this.base, this.address + paramInt1, paramInt3); }
  
  public ByteBuffer sliceAsByteBuffer(int paramInt1, int paramInt2) {
    if (hasArray())
      return ByteBuffer.wrap((byte[])this.base, (int)(this.address - ARRAY_BYTE_BASE_OFFSET + paramInt1), paramInt2); 
    assert !isUniversalBuffer;
    return DirectBufferAccess.newByteBuffer(this.address, paramInt1, paramInt2, this.reference);
  }
  
  public ByteBuffer sliceAsByteBuffer() { return sliceAsByteBuffer(0, size()); }
  
  public boolean hasArray() { return (this.base != null); }
  
  public byte[] toByteArray() {
    byte[] arrayOfByte = new byte[size()];
    unsafe.copyMemory(this.base, this.address, arrayOfByte, ARRAY_BYTE_BASE_OFFSET, size());
    return arrayOfByte;
  }
  
  public byte[] array() { return (byte[])this.base; }
  
  public int arrayOffset() { return (int)this.address - ARRAY_BYTE_BASE_OFFSET; }
  
  public void copyTo(int paramInt1, MessageBuffer paramMessageBuffer, int paramInt2, int paramInt3) { unsafe.copyMemory(this.base, this.address + paramInt1, paramMessageBuffer.base, paramMessageBuffer.address + paramInt2, paramInt3); }
  
  public String toHexString(int paramInt1, int paramInt2) {
    StringBuilder stringBuilder = new StringBuilder();
    for (int i = paramInt1; i < paramInt2; i++) {
      if (i != paramInt1)
        stringBuilder.append(" "); 
      stringBuilder.append(String.format("%02x", new Object[] { Byte.valueOf(getByte(i)) }));
    } 
    return stringBuilder.toString();
  }
}
