package org.xerial.snappy;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;

public class SnappyInputStream extends InputStream {
  private boolean finishedReading;
  
  protected final InputStream in;
  
  private byte[] compressed;
  
  private byte[] uncompressed;
  
  private int uncompressedCursor;
  
  private int uncompressedLimit;
  
  private byte[] header;
  
  public SnappyInputStream(InputStream paramInputStream) throws IOException {
    this.finishedReading = false;
    this.uncompressedCursor = 0;
    this.uncompressedLimit = 0;
    this.header = new byte[SnappyCodec.headerSize()];
    this.in = paramInputStream;
    readHeader();
  }
  
  public void close() throws IOException {
    this.compressed = null;
    this.uncompressed = null;
    if (this.in != null)
      this.in.close(); 
  }
  
  protected void readHeader() throws IOException {
    int i = 0;
    while (i < this.header.length) {
      int j = this.in.read(this.header, i, this.header.length - i);
      if (j == -1)
        break; 
      i += j;
    } 
    if (i == 0)
      throw new SnappyIOException(SnappyErrorCode.EMPTY_INPUT, "Cannot decompress empty stream"); 
    if (i < this.header.length || !SnappyCodec.hasMagicHeaderPrefix(this.header)) {
      readFully(this.header, i);
      return;
    } 
  }
  
  private static boolean isValidHeader(byte[] paramArrayOfByte) throws IOException {
    SnappyCodec snappyCodec = SnappyCodec.readHeader(new ByteArrayInputStream(paramArrayOfByte));
    if (snappyCodec.isValidMagicHeader()) {
      if (snappyCodec.version < 1)
        throw new SnappyIOException(SnappyErrorCode.INCOMPATIBLE_VERSION, String.format("Compressed with an incompatible codec version %d. At least version %d is required", new Object[] { Integer.valueOf(snappyCodec.version), Integer.valueOf(1) })); 
      return true;
    } 
    return false;
  }
  
  protected void readFully(byte[] paramArrayOfByte, int paramInt) throws IOException {
    if (paramInt == 0) {
      this.finishedReading = true;
      return;
    } 
    this.compressed = new byte[Math.max(8192, paramInt)];
    System.arraycopy(paramArrayOfByte, 0, this.compressed, 0, paramInt);
    int i = paramInt;
    int j;
    for (j = 0; (j = this.in.read(this.compressed, i, this.compressed.length - i)) != -1; ) {
      i += j;
      if (i >= this.compressed.length) {
        byte[] arrayOfByte = new byte[this.compressed.length * 2];
        System.arraycopy(this.compressed, 0, arrayOfByte, 0, this.compressed.length);
        this.compressed = arrayOfByte;
      } 
    } 
    this.finishedReading = true;
    j = Snappy.uncompressedLength(this.compressed, 0, i);
    this.uncompressed = new byte[j];
    Snappy.uncompress(this.compressed, 0, i, this.uncompressed, 0);
    this.uncompressedCursor = 0;
    this.uncompressedLimit = j;
  }
  
  public int read(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException {
    int i = 0;
    while (i < paramInt2) {
      if (this.uncompressedCursor >= this.uncompressedLimit) {
        if (hasNextChunk())
          continue; 
        return !i ? -1 : i;
      } 
      int j = Math.min(this.uncompressedLimit - this.uncompressedCursor, paramInt2 - i);
      System.arraycopy(this.uncompressed, this.uncompressedCursor, paramArrayOfByte, paramInt1 + i, j);
      i += j;
      this.uncompressedCursor += j;
    } 
    return i;
  }
  
  public int rawRead(Object paramObject, int paramInt1, int paramInt2) throws IOException {
    int i = 0;
    while (i < paramInt2) {
      if (this.uncompressedCursor >= this.uncompressedLimit) {
        if (hasNextChunk())
          continue; 
        return !i ? -1 : i;
      } 
      int j = Math.min(this.uncompressedLimit - this.uncompressedCursor, paramInt2 - i);
      Snappy.arrayCopy(this.uncompressed, this.uncompressedCursor, j, paramObject, paramInt1 + i);
      i += j;
      this.uncompressedCursor += j;
    } 
    return i;
  }
  
  public int read(long[] paramArrayOfLong, int paramInt1, int paramInt2) throws IOException { return rawRead(paramArrayOfLong, paramInt1 * 8, paramInt2 * 8); }
  
  public int read(long[] paramArrayOfLong) throws IOException { return read(paramArrayOfLong, 0, paramArrayOfLong.length); }
  
  public int read(double[] paramArrayOfDouble, int paramInt1, int paramInt2) throws IOException { return rawRead(paramArrayOfDouble, paramInt1 * 8, paramInt2 * 8); }
  
  public int read(double[] paramArrayOfDouble) throws IOException { return read(paramArrayOfDouble, 0, paramArrayOfDouble.length); }
  
  public int read(int[] paramArrayOfInt) throws IOException { return read(paramArrayOfInt, 0, paramArrayOfInt.length); }
  
  public int read(int[] paramArrayOfInt, int paramInt1, int paramInt2) throws IOException { return rawRead(paramArrayOfInt, paramInt1 * 4, paramInt2 * 4); }
  
  public int read(float[] paramArrayOfFloat, int paramInt1, int paramInt2) throws IOException { return rawRead(paramArrayOfFloat, paramInt1 * 4, paramInt2 * 4); }
  
  public int read(float[] paramArrayOfFloat) throws IOException { return read(paramArrayOfFloat, 0, paramArrayOfFloat.length); }
  
  public int read(short[] paramArrayOfShort, int paramInt1, int paramInt2) throws IOException { return rawRead(paramArrayOfShort, paramInt1 * 2, paramInt2 * 2); }
  
  public int read(short[] paramArrayOfShort) throws IOException { return read(paramArrayOfShort, 0, paramArrayOfShort.length); }
  
  private int readNext(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException {
    int i = 0;
    while (i < paramInt2) {
      int j = this.in.read(paramArrayOfByte, i + paramInt1, paramInt2 - i);
      if (j == -1) {
        this.finishedReading = true;
        return i;
      } 
      i += j;
    } 
    return i;
  }
  
  protected boolean hasNextChunk() throws IOException {
    if (this.finishedReading)
      return false; 
    this.uncompressedCursor = 0;
    this.uncompressedLimit = 0;
    int i = readNext(this.header, 0, 4);
    if (i < 4)
      return false; 
    int j = SnappyOutputStream.readInt(this.header, 0);
    if (j == SnappyCodec.MAGIC_HEADER_HEAD) {
      int n = SnappyCodec.headerSize() - 4;
      i = readNext(this.header, 4, n);
      if (i < n)
        throw new SnappyIOException(SnappyErrorCode.FAILED_TO_UNCOMPRESS, String.format("Insufficient header size in a concatenated block", new Object[0])); 
      if (isValidHeader(this.header))
        return hasNextChunk(); 
      return false;
    } 
    if (this.compressed == null || j > this.compressed.length)
      this.compressed = new byte[j]; 
    i = 0;
    while (i < j) {
      int n = this.in.read(this.compressed, i, j - i);
      if (n == -1)
        break; 
      i += n;
    } 
    if (i < j)
      throw new IOException("failed to read chunk"); 
    int k = Snappy.uncompressedLength(this.compressed, 0, j);
    if (this.uncompressed == null || k > this.uncompressed.length)
      this.uncompressed = new byte[k]; 
    int m = Snappy.uncompress(this.compressed, 0, j, this.uncompressed, 0);
    if (k != m)
      throw new SnappyIOException(SnappyErrorCode.INVALID_CHUNK_SIZE, String.format("expected %,d bytes, but decompressed chunk has %,d bytes", new Object[] { Integer.valueOf(k), Integer.valueOf(m) })); 
    this.uncompressedLimit = m;
    return true;
  }
  
  public int read() throws IOException {
    if (this.uncompressedCursor < this.uncompressedLimit)
      return this.uncompressed[this.uncompressedCursor++] & 0xFF; 
    if (hasNextChunk())
      return read(); 
    return -1;
  }
  
  public int available() throws IOException {
    if (this.uncompressedCursor < this.uncompressedLimit)
      return this.uncompressedLimit - this.uncompressedCursor; 
    if (hasNextChunk())
      return this.uncompressedLimit - this.uncompressedCursor; 
    return 0;
  }
}
