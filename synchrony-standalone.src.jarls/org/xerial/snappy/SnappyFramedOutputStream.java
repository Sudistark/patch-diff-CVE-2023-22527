package org.xerial.snappy;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.Channels;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.WritableByteChannel;
import java.util.zip.Checksum;
import org.xerial.snappy.pool.BufferPool;
import org.xerial.snappy.pool.DefaultPoolFactory;

public final class SnappyFramedOutputStream extends OutputStream implements WritableByteChannel {
  public static final int MAX_BLOCK_SIZE = 65536;
  
  public static final int DEFAULT_BLOCK_SIZE = 65536;
  
  public static final double DEFAULT_MIN_COMPRESSION_RATIO = 0.85D;
  
  private final Checksum crc32 = SnappyFramed.getCRC32C();
  
  private final ByteBuffer headerBuffer = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN);
  
  private final BufferPool bufferPool;
  
  private final int blockSize;
  
  private final ByteBuffer buffer;
  
  private final ByteBuffer directInputBuffer;
  
  private final ByteBuffer outputBuffer;
  
  private final double minCompressionRatio;
  
  private final WritableByteChannel out;
  
  private boolean closed;
  
  public SnappyFramedOutputStream(OutputStream paramOutputStream) throws IOException { this(paramOutputStream, 65536, 0.85D, DefaultPoolFactory.getDefaultPool()); }
  
  public SnappyFramedOutputStream(OutputStream paramOutputStream, BufferPool paramBufferPool) throws IOException { this(paramOutputStream, 65536, 0.85D, paramBufferPool); }
  
  public SnappyFramedOutputStream(OutputStream paramOutputStream, int paramInt, double paramDouble) throws IOException { this(Channels.newChannel(paramOutputStream), paramInt, paramDouble, DefaultPoolFactory.getDefaultPool()); }
  
  public SnappyFramedOutputStream(OutputStream paramOutputStream, int paramInt, double paramDouble, BufferPool paramBufferPool) throws IOException { this(Channels.newChannel(paramOutputStream), paramInt, paramDouble, paramBufferPool); }
  
  public SnappyFramedOutputStream(WritableByteChannel paramWritableByteChannel) throws IOException { this(paramWritableByteChannel, 65536, 0.85D, DefaultPoolFactory.getDefaultPool()); }
  
  public SnappyFramedOutputStream(WritableByteChannel paramWritableByteChannel, BufferPool paramBufferPool) throws IOException { this(paramWritableByteChannel, 65536, 0.85D, paramBufferPool); }
  
  public SnappyFramedOutputStream(WritableByteChannel paramWritableByteChannel, int paramInt, double paramDouble) throws IOException { this(paramWritableByteChannel, paramInt, paramDouble, DefaultPoolFactory.getDefaultPool()); }
  
  public SnappyFramedOutputStream(WritableByteChannel paramWritableByteChannel, int paramInt, double paramDouble, BufferPool paramBufferPool) throws IOException {
    if (paramWritableByteChannel == null)
      throw new NullPointerException("out is null"); 
    if (paramBufferPool == null)
      throw new NullPointerException("buffer pool is null"); 
    if (paramDouble <= 0.0D || paramDouble > 1.0D)
      throw new IllegalArgumentException("minCompressionRatio " + paramDouble + " must be in (0,1.0]"); 
    if (paramInt <= 0 || paramInt > 65536)
      throw new IllegalArgumentException("block size " + paramInt + " must be in (0, 65536]"); 
    this.blockSize = paramInt;
    this.out = paramWritableByteChannel;
    this.minCompressionRatio = paramDouble;
    this.bufferPool = paramBufferPool;
    this.buffer = ByteBuffer.wrap(paramBufferPool.allocateArray(paramInt), 0, paramInt);
    this.directInputBuffer = paramBufferPool.allocateDirect(paramInt);
    this.outputBuffer = paramBufferPool.allocateDirect(
        Snappy.maxCompressedLength(paramInt));
    writeHeader(paramWritableByteChannel);
  }
  
  private void writeHeader(WritableByteChannel paramWritableByteChannel) throws IOException { paramWritableByteChannel.write(ByteBuffer.wrap(SnappyFramed.HEADER_BYTES)); }
  
  public boolean isOpen() { return !this.closed; }
  
  public void write(int paramInt) throws IOException {
    if (this.closed)
      throw new IOException("Stream is closed"); 
    if (this.buffer.remaining() <= 0)
      flushBuffer(); 
    this.buffer.put((byte)paramInt);
  }
  
  public void write(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws IOException {
    if (this.closed)
      throw new IOException("Stream is closed"); 
    if (paramArrayOfByte == null)
      throw new NullPointerException(); 
    if (paramInt1 < 0 || paramInt1 > paramArrayOfByte.length || paramInt2 < 0 || paramInt1 + paramInt2 > paramArrayOfByte.length || paramInt1 + paramInt2 < 0)
      throw new IndexOutOfBoundsException(); 
    while (paramInt2 > 0) {
      if (this.buffer.remaining() <= 0)
        flushBuffer(); 
      int i = Math.min(paramInt2, this.buffer.remaining());
      this.buffer.put(paramArrayOfByte, paramInt1, i);
      paramInt1 += i;
      paramInt2 -= i;
    } 
  }
  
  public int write(ByteBuffer paramByteBuffer) throws IOException {
    if (this.closed)
      throw new ClosedChannelException(); 
    if (this.buffer.remaining() <= 0)
      flushBuffer(); 
    int i = paramByteBuffer.remaining();
    if (this.buffer.remaining() >= paramByteBuffer.remaining()) {
      this.buffer.put(paramByteBuffer);
      return i;
    } 
    int j = paramByteBuffer.position() + paramByteBuffer.remaining();
    while (paramByteBuffer.position() + this.buffer.remaining() <= j) {
      paramByteBuffer.limit(paramByteBuffer.position() + this.buffer.remaining());
      this.buffer.put(paramByteBuffer);
      flushBuffer();
    } 
    paramByteBuffer.limit(j);
    this.buffer.put(paramByteBuffer);
    return i;
  }
  
  public long transferFrom(InputStream paramInputStream) throws IOException {
    if (this.closed)
      throw new ClosedChannelException(); 
    if (paramInputStream == null)
      throw new NullPointerException(); 
    if (this.buffer.remaining() == 0)
      flushBuffer(); 
    assert this.buffer.hasArray();
    byte[] arrayOfByte = this.buffer.array();
    int i = this.buffer.arrayOffset();
    long l = 0L;
    while (true) {
      int j;
      if ((j = paramInputStream.read(arrayOfByte, i + this.buffer.position(), this.buffer
          .remaining())) != -1) {
        this.buffer.position(this.buffer.position() + j);
        if (this.buffer.remaining() == 0)
          flushBuffer(); 
        l += j;
        continue;
      } 
      break;
    } 
    return l;
  }
  
  public long transferFrom(ReadableByteChannel paramReadableByteChannel) throws IOException {
    if (this.closed)
      throw new ClosedChannelException(); 
    if (paramReadableByteChannel == null)
      throw new NullPointerException(); 
    if (this.buffer.remaining() == 0)
      flushBuffer(); 
    long l = 0L;
    int i;
    while ((i = paramReadableByteChannel.read(this.buffer)) != -1) {
      if (this.buffer.remaining() == 0)
        flushBuffer(); 
      l += i;
    } 
    return l;
  }
  
  public final void flush() throws IOException {
    if (this.closed)
      throw new IOException("Stream is closed"); 
    flushBuffer();
  }
  
  public final void close() throws IOException {
    if (this.closed)
      return; 
    try {
      flush();
      this.out.close();
    } finally {
      this.closed = true;
      this.bufferPool.releaseArray(this.buffer.array());
      this.bufferPool.releaseDirect(this.directInputBuffer);
      this.bufferPool.releaseDirect(this.outputBuffer);
    } 
  }
  
  private void flushBuffer() throws IOException {
    if (this.buffer.position() > 0) {
      this.buffer.flip();
      writeCompressed(this.buffer);
      this.buffer.clear();
      this.buffer.limit(this.blockSize);
    } 
  }
  
  private void writeCompressed(ByteBuffer paramByteBuffer) throws IOException {
    byte[] arrayOfByte = paramByteBuffer.array();
    int i = paramByteBuffer.remaining();
    int j = SnappyFramed.maskedCrc32c(this.crc32, arrayOfByte, 0, i);
    this.directInputBuffer.clear();
    this.directInputBuffer.put(paramByteBuffer);
    this.directInputBuffer.flip();
    this.outputBuffer.clear();
    Snappy.compress(this.directInputBuffer, this.outputBuffer);
    int k = this.outputBuffer.remaining();
    if (k / i <= this.minCompressionRatio) {
      writeBlock(this.out, this.outputBuffer, true, j);
    } else {
      paramByteBuffer.flip();
      writeBlock(this.out, paramByteBuffer, false, j);
    } 
  }
  
  private void writeBlock(WritableByteChannel paramWritableByteChannel, ByteBuffer paramByteBuffer, boolean paramBoolean, int paramInt) throws IOException {
    this.headerBuffer.clear();
    this.headerBuffer.put((byte)(paramBoolean ? 0 : 1));
    int i = paramByteBuffer.remaining() + 4;
    this.headerBuffer.put((byte)i);
    this.headerBuffer.put((byte)(i >>> 8));
    this.headerBuffer.put((byte)(i >>> 16));
    this.headerBuffer.putInt(paramInt);
    this.headerBuffer.flip();
    paramWritableByteChannel.write(this.headerBuffer);
    paramWritableByteChannel.write(paramByteBuffer);
  }
}
