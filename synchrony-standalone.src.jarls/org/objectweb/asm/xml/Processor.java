package org.objectweb.asm.xml;

import java.io.BufferedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;
import javax.xml.transform.Source;
import javax.xml.transform.Templates;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.sax.SAXTransformerFactory;
import javax.xml.transform.stream.StreamSource;
import org.objectweb.asm.ClassReader;
import org.xml.sax.ContentHandler;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.AttributesImpl;
import org.xml.sax.helpers.XMLReaderFactory;

public class Processor {
  public static final int BYTECODE = 1;
  
  public static final int MULTI_XML = 2;
  
  public static final int SINGLE_XML = 3;
  
  private static final String SINGLE_XML_NAME = "classes.xml";
  
  private final int inRepresentation;
  
  private final int outRepresentation;
  
  private final InputStream input;
  
  private final OutputStream output;
  
  private final Source xslt;
  
  private int n = 0;
  
  public Processor(int paramInt1, int paramInt2, InputStream paramInputStream, OutputStream paramOutputStream, Source paramSource) {
    this.inRepresentation = paramInt1;
    this.outRepresentation = paramInt2;
    this.input = paramInputStream;
    this.output = paramOutputStream;
    this.xslt = paramSource;
  }
  
  public int process() throws TransformerException, IOException, SAXException {
    InputSlicingHandler inputSlicingHandler;
    SAXWriter sAXWriter;
    ZipInputStream zipInputStream = new ZipInputStream(this.input);
    ZipOutputStream zipOutputStream = new ZipOutputStream(this.output);
    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(zipOutputStream);
    Thread.currentThread().setContextClassLoader(getClass().getClassLoader());
    TransformerFactory transformerFactory = TransformerFactory.newInstance();
    if (!transformerFactory.getFeature("http://javax.xml.transform.sax.SAXSource/feature") || !transformerFactory.getFeature("http://javax.xml.transform.sax.SAXResult/feature"))
      return 0; 
    SAXTransformerFactory sAXTransformerFactory = (SAXTransformerFactory)transformerFactory;
    Templates templates = null;
    if (this.xslt != null)
      templates = sAXTransformerFactory.newTemplates(this.xslt); 
    EntryElement entryElement = getEntryElement(zipOutputStream);
    OutputSlicingHandler outputSlicingHandler = null;
    switch (this.outRepresentation) {
      case 1:
        outputSlicingHandler = new OutputSlicingHandler(new ASMContentHandlerFactory(zipOutputStream), entryElement, false);
        break;
      case 2:
        outputSlicingHandler = new OutputSlicingHandler(new SAXWriterFactory(outputStreamWriter, true), entryElement, true);
        break;
      case 3:
        inputSlicingHandler = new ZipEntry("classes.xml");
        zipOutputStream.putNextEntry(inputSlicingHandler);
        sAXWriter = new SAXWriter(outputStreamWriter, false);
        break;
    } 
    if (templates == null) {
      SAXWriter sAXWriter1 = sAXWriter;
    } else {
      inputSlicingHandler = new InputSlicingHandler("class", sAXWriter, new TransformerHandlerFactory(sAXTransformerFactory, templates, sAXWriter));
    } 
    SubdocumentHandlerFactory subdocumentHandlerFactory = new SubdocumentHandlerFactory(inputSlicingHandler);
    if (inputSlicingHandler != null && this.inRepresentation != 3) {
      inputSlicingHandler.startDocument();
      inputSlicingHandler.startElement("", "classes", "classes", new AttributesImpl());
    } 
    byte b;
    ZipEntry zipEntry;
    for (b = 0; (zipEntry = zipInputStream.getNextEntry()) != null; b++) {
      update(zipEntry.getName(), this.n++);
      if (isClassEntry(zipEntry)) {
        processEntry(zipInputStream, zipEntry, subdocumentHandlerFactory);
      } else {
        OutputStream outputStream = entryElement.openEntry(getName(zipEntry));
        copyEntry(zipInputStream, outputStream);
        entryElement.closeEntry();
      } 
    } 
    if (inputSlicingHandler != null && this.inRepresentation != 3) {
      inputSlicingHandler.endElement("", "classes", "classes");
      inputSlicingHandler.endDocument();
    } 
    if (this.outRepresentation == 3)
      zipOutputStream.closeEntry(); 
    zipOutputStream.flush();
    zipOutputStream.close();
    return b;
  }
  
  private void copyEntry(InputStream paramInputStream, OutputStream paramOutputStream) throws IOException {
    if (this.outRepresentation == 3)
      return; 
    byte[] arrayOfByte = new byte[2048];
    int i;
    while ((i = paramInputStream.read(arrayOfByte)) != -1)
      paramOutputStream.write(arrayOfByte, 0, i); 
  }
  
  private boolean isClassEntry(ZipEntry paramZipEntry) {
    String str = paramZipEntry.getName();
    return ((this.inRepresentation == 3 && str.equals("classes.xml")) || str.endsWith(".class") || str.endsWith(".class.xml"));
  }
  
  private void processEntry(ZipInputStream paramZipInputStream, ZipEntry paramZipEntry, ContentHandlerFactory paramContentHandlerFactory) {
    ContentHandler contentHandler = paramContentHandlerFactory.createContentHandler();
    try {
      boolean bool = (this.inRepresentation == 3);
      if (this.inRepresentation == 1) {
        ClassReader classReader = new ClassReader(readEntry(paramZipInputStream, paramZipEntry));
        classReader.accept(new SAXClassAdapter(contentHandler, bool), 0);
      } else {
        XMLReader xMLReader = XMLReaderFactory.createXMLReader();
        xMLReader.setContentHandler(contentHandler);
        xMLReader.parse(new InputSource(bool ? new ProtectedInputStream(paramZipInputStream) : new ByteArrayInputStream(readEntry(paramZipInputStream, paramZipEntry))));
      } 
    } catch (Exception exception) {
      update(paramZipEntry.getName(), 0);
      update(exception, 0);
    } 
  }
  
  private EntryElement getEntryElement(ZipOutputStream paramZipOutputStream) { return (this.outRepresentation == 3) ? new SingleDocElement(paramZipOutputStream) : new ZipEntryElement(paramZipOutputStream); }
  
  private String getName(ZipEntry paramZipEntry) {
    String str = paramZipEntry.getName();
    if (isClassEntry(paramZipEntry))
      if (this.inRepresentation != 1 && this.outRepresentation == 1) {
        str = str.substring(0, str.length() - 4);
      } else if (this.inRepresentation == 1 && this.outRepresentation != 1) {
        str = str + ".xml";
      }  
    return str;
  }
  
  private static byte[] readEntry(InputStream paramInputStream, ZipEntry paramZipEntry) throws IOException {
    long l = paramZipEntry.getSize();
    if (l > -1L) {
      byte[] arrayOfByte1 = new byte[(int)l];
      int j;
      int k;
      for (j = 0; (k = paramInputStream.read(arrayOfByte1, j, arrayOfByte1.length - j)) > 0; j += k);
      return arrayOfByte1;
    } 
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
    byte[] arrayOfByte = new byte[4096];
    int i;
    while ((i = paramInputStream.read(arrayOfByte)) != -1)
      byteArrayOutputStream.write(arrayOfByte, 0, i); 
    return byteArrayOutputStream.toByteArray();
  }
  
  protected void update(Object paramObject, int paramInt) {
    if (paramObject instanceof Throwable) {
      ((Throwable)paramObject).printStackTrace();
    } else if (paramInt % 100 == 0) {
      System.err.println(paramInt + " " + paramObject);
    } 
  }
  
  public static void main(String[] paramArrayOfString) throws Exception {
    if (paramArrayOfString.length < 2) {
      showUsage();
      return;
    } 
    int i = getRepresentation(paramArrayOfString[0]);
    int j = getRepresentation(paramArrayOfString[1]);
    InputStream inputStream = System.in;
    BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(System.out);
    StreamSource streamSource = null;
    for (byte b = 2; b < paramArrayOfString.length; b++) {
      if ("-in".equals(paramArrayOfString[b])) {
        inputStream = new FileInputStream(paramArrayOfString[++b]);
      } else if ("-out".equals(paramArrayOfString[b])) {
        bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(paramArrayOfString[++b]));
      } else if ("-xslt".equals(paramArrayOfString[b])) {
        streamSource = new StreamSource(new FileInputStream(paramArrayOfString[++b]));
      } else {
        showUsage();
        return;
      } 
    } 
    if (i == 0 || j == 0) {
      showUsage();
      return;
    } 
    Processor processor = new Processor(i, j, inputStream, bufferedOutputStream, streamSource);
    long l1 = System.currentTimeMillis();
    int k = processor.process();
    long l2 = System.currentTimeMillis();
    System.err.println(k);
    System.err.println((l2 - l1) + "ms  " + (1000.0F * k / (float)(l2 - l1)) + " resources/sec");
  }
  
  private static int getRepresentation(String paramString) { return "code".equals(paramString) ? 1 : ("xml".equals(paramString) ? 2 : ("singlexml".equals(paramString) ? 3 : 0)); }
  
  private static void showUsage() {
    System.err.println("Usage: Main <in format> <out format> [-in <input jar>] [-out <output jar>] [-xslt <xslt fiel>]");
    System.err.println("  when -in or -out is omitted sysin and sysout would be used");
    System.err.println("  <in format> and <out format> - code | xml | singlexml");
  }
}
