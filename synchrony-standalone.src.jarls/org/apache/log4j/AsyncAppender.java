package org.apache.log4j;

import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.log4j.helpers.AppenderAttachableImpl;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.AppenderAttachable;
import org.apache.log4j.spi.LoggingEvent;

public class AsyncAppender extends AppenderSkeleton implements AppenderAttachable {
  public static final int DEFAULT_BUFFER_SIZE = 128;
  
  private final List buffer;
  
  private final Map discardMap;
  
  private int bufferSize;
  
  AppenderAttachableImpl aai;
  
  private final AppenderAttachableImpl appenders;
  
  private final Thread dispatcher;
  
  private boolean locationInfo;
  
  private boolean blocking;
  
  public AsyncAppender() {
    this.buffer = new ArrayList();
    this.discardMap = new HashMap();
    this.bufferSize = 128;
    this.locationInfo = false;
    this.blocking = true;
    this.appenders = new AppenderAttachableImpl();
    this.aai = this.appenders;
    this.dispatcher = new Thread(new Dispatcher(this, this.buffer, this.discardMap, this.appenders));
    this.dispatcher.setDaemon(true);
    this.dispatcher.setName("AsyncAppender-Dispatcher-" + this.dispatcher.getName());
    this.dispatcher.start();
  }
  
  public void addAppender(Appender newAppender) {
    synchronized (this.appenders) {
      this.appenders.addAppender(newAppender);
    } 
  }
  
  public void append(LoggingEvent event) {
    if (this.dispatcher == null || !this.dispatcher.isAlive() || this.bufferSize <= 0) {
      synchronized (this.appenders) {
        this.appenders.appendLoopOnAppenders(event);
      } 
      return;
    } 
    event.getNDC();
    event.getThreadName();
    event.getMDCCopy();
    if (this.locationInfo)
      event.getLocationInformation(); 
    event.getRenderedMessage();
    event.getThrowableStrRep();
    synchronized (this.buffer) {
      while (true) {
        int previousSize = this.buffer.size();
        if (previousSize < this.bufferSize) {
          this.buffer.add(event);
          if (previousSize == 0)
            this.buffer.notifyAll(); 
          break;
        } 
        boolean discard = true;
        if (this.blocking && !Thread.interrupted() && Thread.currentThread() != this.dispatcher)
          try {
            this.buffer.wait();
            discard = false;
          } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
          }  
        if (discard) {
          String loggerName = event.getLoggerName();
          DiscardSummary summary = (DiscardSummary)this.discardMap.get(loggerName);
          if (summary == null) {
            summary = new DiscardSummary(event);
            this.discardMap.put(loggerName, summary);
            break;
          } 
          summary.add(event);
          break;
        } 
      } 
    } 
  }
  
  public void close() {
    synchronized (this.buffer) {
      this.closed = true;
      this.buffer.notifyAll();
    } 
    try {
      this.dispatcher.join();
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      LogLog.error("Got an InterruptedException while waiting for the dispatcher to finish.", e);
    } 
    synchronized (this.appenders) {
      Enumeration iter = this.appenders.getAllAppenders();
      if (iter != null)
        while (iter.hasMoreElements()) {
          Object next = iter.nextElement();
          if (next instanceof Appender)
            ((Appender)next).close(); 
        }  
    } 
  }
  
  public Enumeration getAllAppenders() {
    synchronized (this.appenders) {
      return this.appenders.getAllAppenders();
    } 
  }
  
  public Appender getAppender(String name) {
    synchronized (this.appenders) {
      return this.appenders.getAppender(name);
    } 
  }
  
  public boolean getLocationInfo() { return this.locationInfo; }
  
  public boolean isAttached(Appender appender) {
    synchronized (this.appenders) {
      return this.appenders.isAttached(appender);
    } 
  }
  
  public boolean requiresLayout() { return false; }
  
  public void removeAllAppenders() {
    synchronized (this.appenders) {
      this.appenders.removeAllAppenders();
    } 
  }
  
  public void removeAppender(Appender appender) {
    synchronized (this.appenders) {
      this.appenders.removeAppender(appender);
    } 
  }
  
  public void removeAppender(String name) {
    synchronized (this.appenders) {
      this.appenders.removeAppender(name);
    } 
  }
  
  public void setLocationInfo(boolean flag) { this.locationInfo = flag; }
  
  public void setBufferSize(int size) {
    if (size < 0)
      throw new NegativeArraySizeException("size"); 
    synchronized (this.buffer) {
      this.bufferSize = (size < 1) ? 1 : size;
      this.buffer.notifyAll();
    } 
  }
  
  public int getBufferSize() { return this.bufferSize; }
  
  public void setBlocking(boolean value) {
    synchronized (this.buffer) {
      this.blocking = value;
      this.buffer.notifyAll();
    } 
  }
  
  public boolean getBlocking() { return this.blocking; }
}
