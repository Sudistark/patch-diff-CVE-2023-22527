package org.apache.commons.compress.archivers.zip;

import java.io.Closeable;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Path;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import org.apache.commons.compress.parallel.FileBasedScatterGatherBackingStore;
import org.apache.commons.compress.parallel.ScatterGatherBackingStore;
import org.apache.commons.compress.utils.BoundedInputStream;

public class ScatterZipOutputStream implements Closeable {
  private final Queue<CompressedEntry> items;
  
  private final ScatterGatherBackingStore backingStore;
  
  private final StreamCompressor streamCompressor;
  
  private final AtomicBoolean isClosed;
  
  private ZipEntryWriter zipEntryWriter;
  
  public static ScatterZipOutputStream fileBased(File file) throws FileNotFoundException { return pathBased(file.toPath(), -1); }
  
  public static ScatterZipOutputStream fileBased(File file, int compressionLevel) throws FileNotFoundException { return pathBased(file.toPath(), compressionLevel); }
  
  public static ScatterZipOutputStream pathBased(Path path) throws FileNotFoundException { return pathBased(path, -1); }
  
  public static ScatterZipOutputStream pathBased(Path path, int compressionLevel) throws FileNotFoundException {
    FileBasedScatterGatherBackingStore fileBasedScatterGatherBackingStore = new FileBasedScatterGatherBackingStore(path);
    StreamCompressor sc = StreamCompressor.create(compressionLevel, fileBasedScatterGatherBackingStore);
    return new ScatterZipOutputStream(fileBasedScatterGatherBackingStore, sc);
  }
  
  public ScatterZipOutputStream(ScatterGatherBackingStore backingStore, StreamCompressor streamCompressor) {
    this.items = new ConcurrentLinkedQueue();
    this.isClosed = new AtomicBoolean();
    this.backingStore = backingStore;
    this.streamCompressor = streamCompressor;
  }
  
  public void addArchiveEntry(ZipArchiveEntryRequest zipArchiveEntryRequest) throws IOException {
    InputStream payloadStream = zipArchiveEntryRequest.getPayloadStream();
    try {
      this.streamCompressor.deflate(payloadStream, zipArchiveEntryRequest.getMethod());
      if (payloadStream != null)
        payloadStream.close(); 
    } catch (Throwable throwable) {
      if (payloadStream != null)
        try {
          payloadStream.close();
        } catch (Throwable throwable1) {
          throwable.addSuppressed(throwable1);
        }  
      throw throwable;
    } 
    this.items.add(new CompressedEntry(zipArchiveEntryRequest, this.streamCompressor.getCrc32(), this.streamCompressor
          .getBytesWrittenForLastEntry(), this.streamCompressor.getBytesRead()));
  }
  
  public void close() throws IOException {
    if (!this.isClosed.compareAndSet(false, true))
      return; 
    try {
      if (this.zipEntryWriter != null)
        this.zipEntryWriter.close(); 
      this.backingStore.close();
    } finally {
      this.streamCompressor.close();
    } 
  }
  
  public void writeTo(ZipArchiveOutputStream target) throws IOException {
    this.backingStore.closeForWriting();
    InputStream data = this.backingStore.getInputStream();
    try {
      for (CompressedEntry compressedEntry : this.items) {
        BoundedInputStream rawStream = new BoundedInputStream(data, compressedEntry.compressedSize);
        try {
          target.addRawArchiveEntry(compressedEntry.transferToArchiveEntry(), rawStream);
          rawStream.close();
        } catch (Throwable throwable) {
          try {
            rawStream.close();
          } catch (Throwable throwable1) {
            throwable.addSuppressed(throwable1);
          } 
          throw throwable;
        } 
      } 
      if (data != null)
        data.close(); 
    } catch (Throwable throwable) {
      if (data != null)
        try {
          data.close();
        } catch (Throwable throwable1) {
          throwable.addSuppressed(throwable1);
        }  
      throw throwable;
    } 
  }
  
  public ZipEntryWriter zipEntryWriter() throws IOException {
    if (this.zipEntryWriter == null)
      this.zipEntryWriter = new ZipEntryWriter(this); 
    return this.zipEntryWriter;
  }
}
