package org.apache.commons.compress.archivers.zip;

import java.io.IOException;
import java.math.BigInteger;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.zip.CRC32;

public abstract class ZipUtil {
  private static final long DOSTIME_BEFORE_1980 = 2162688L;
  
  private static final long UPPER_DOSTIME_BOUND = 4036608000000L;
  
  public static long adjustToLong(int i) {
    if (i < 0)
      return 4294967296L + i; 
    return i;
  }
  
  static long bigToLong(BigInteger big) {
    if (big.bitLength() <= 63)
      return big.longValue(); 
    throw new NumberFormatException("The BigInteger cannot fit inside a 64 bit java long: [" + big + "]");
  }
  
  static boolean canHandleEntryData(ZipArchiveEntry entry) { return (supportsEncryptionOf(entry) && supportsMethodOf(entry)); }
  
  static void checkRequestedFeatures(ZipArchiveEntry ze) throws UnsupportedZipFeatureException {
    if (!supportsEncryptionOf(ze))
      throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.ENCRYPTION, ze); 
    if (!supportsMethodOf(ze)) {
      ZipMethod m = ZipMethod.getMethodByCode(ze.getMethod());
      if (m == null)
        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.METHOD, ze); 
      throw new UnsupportedZipFeatureException(m, ze);
    } 
  }
  
  static byte[] copy(byte[] from) {
    if (from != null)
      return Arrays.copyOf(from, from.length); 
    return null;
  }
  
  static void copy(byte[] from, byte[] to, int offset) {
    if (from != null)
      System.arraycopy(from, 0, to, offset, from.length); 
  }
  
  private static Date dosToJavaDate(long dosTime) {
    Calendar cal = Calendar.getInstance();
    cal.set(1, (int)(dosTime >> 25 & 0x7FL) + 1980);
    cal.set(2, (int)(dosTime >> 21 & 0xFL) - 1);
    cal.set(5, (int)(dosTime >> 16) & 0x1F);
    cal.set(11, (int)(dosTime >> 11) & 0x1F);
    cal.set(12, (int)(dosTime >> 5) & 0x3F);
    cal.set(13, (int)(dosTime << true) & 0x3E);
    cal.set(14, 0);
    return cal.getTime();
  }
  
  public static long dosToJavaTime(long dosTime) { return dosToJavaDate(dosTime).getTime(); }
  
  public static Date fromDosTime(ZipLong zipDosTime) {
    long dosTime = zipDosTime.getValue();
    return dosToJavaDate(dosTime);
  }
  
  private static String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig) {
    if (f != null) {
      CRC32 crc32 = new CRC32();
      crc32.update(orig);
      long origCRC32 = crc32.getValue();
      if (origCRC32 == f.getNameCRC32())
        try {
          return ZipEncodingHelper.UTF8_ZIP_ENCODING
            .decode(f.getUnicodeName());
        } catch (IOException iOException) {} 
    } 
    return null;
  }
  
  public static boolean isDosTime(long time) { return (time <= 4036608000000L && javaToDosTime(time) != 2162688L); }
  
  private static LocalDateTime javaEpochToLocalDateTime(long time) {
    Instant instant = Instant.ofEpochMilli(time);
    return LocalDateTime.ofInstant(instant, ZoneId.systemDefault());
  }
  
  private static long javaToDosTime(long t) {
    LocalDateTime ldt = javaEpochToLocalDateTime(t);
    if (ldt.getYear() < 1980)
      return 2162688L; 
    return (ldt.getYear() - 1980 << 25 | ldt
      .getMonthValue() << 21 | ldt
      .getDayOfMonth() << 16 | ldt
      .getHour() << 11 | ldt
      .getMinute() << 5 | ldt
      .getSecond() >> 1) & 0xFFFFFFFFL;
  }
  
  static BigInteger longToBig(long l) {
    if (l < -2147483648L)
      throw new IllegalArgumentException("Negative longs < -2^31 not permitted: [" + l + "]"); 
    if (l < 0L && l >= -2147483648L)
      l = adjustToLong((int)l); 
    return BigInteger.valueOf(l);
  }
  
  public static byte[] reverse(byte[] array) {
    int z = array.length - 1;
    for (int i = 0; i < array.length / 2; i++) {
      byte x = array[i];
      array[i] = array[z - i];
      array[z - i] = x;
    } 
    return array;
  }
  
  static void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, byte[] originalNameBytes, byte[] commentBytes) {
    ZipExtraField nameCandidate = ze.getExtraField(UnicodePathExtraField.UPATH_ID);
    UnicodePathExtraField name = (nameCandidate instanceof UnicodePathExtraField) ? (UnicodePathExtraField)nameCandidate : null;
    String newName = getUnicodeStringIfOriginalMatches(name, originalNameBytes);
    if (newName != null) {
      ze.setName(newName);
      ze.setNameSource(ZipArchiveEntry.NameSource.UNICODE_EXTRA_FIELD);
    } 
    if (commentBytes != null && commentBytes.length > 0) {
      ZipExtraField cmtCandidate = ze.getExtraField(UnicodeCommentExtraField.UCOM_ID);
      UnicodeCommentExtraField cmt = (cmtCandidate instanceof UnicodeCommentExtraField) ? (UnicodeCommentExtraField)cmtCandidate : null;
      String newComment = getUnicodeStringIfOriginalMatches(cmt, commentBytes);
      if (newComment != null) {
        ze.setComment(newComment);
        ze.setCommentSource(ZipArchiveEntry.CommentSource.UNICODE_EXTRA_FIELD);
      } 
    } 
  }
  
  public static int signedByteToUnsignedInt(byte b) {
    if (b >= 0)
      return b; 
    return 'Ä€' + b;
  }
  
  private static boolean supportsEncryptionOf(ZipArchiveEntry entry) { return !entry.getGeneralPurposeBit().usesEncryption(); }
  
  private static boolean supportsMethodOf(ZipArchiveEntry entry) {
    return (entry.getMethod() == 0 || entry
      .getMethod() == ZipMethod.UNSHRINKING.getCode() || entry
      .getMethod() == ZipMethod.IMPLODING.getCode() || entry
      .getMethod() == 8 || entry
      .getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || entry
      .getMethod() == ZipMethod.BZIP2.getCode());
  }
  
  public static ZipLong toDosTime(Date time) { return new ZipLong(toDosTime(time.getTime())); }
  
  public static byte[] toDosTime(long t) {
    byte[] result = new byte[4];
    toDosTime(t, result, 0);
    return result;
  }
  
  public static void toDosTime(long t, byte[] buf, int offset) { ZipLong.putLong(javaToDosTime(t), buf, offset); }
  
  public static byte unsignedIntToSignedByte(int i) {
    if (i > 255 || i < 0)
      throw new IllegalArgumentException("Can only convert non-negative integers between [0,255] to byte: [" + i + "]"); 
    if (i < 128)
      return (byte)i; 
    return (byte)(i - 256);
  }
}
