package org.apache.commons.compress.archivers.zip;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.nio.channels.SeekableByteChannel;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.OpenOption;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.zip.Deflater;
import java.util.zip.ZipException;
import org.apache.commons.compress.archivers.ArchiveEntry;
import org.apache.commons.compress.archivers.ArchiveOutputStream;
import org.apache.commons.compress.utils.ByteUtils;
import org.apache.commons.compress.utils.IOUtils;

public class ZipArchiveOutputStream extends ArchiveOutputStream {
  static final int BUFFER_SIZE = 512;
  
  private static final int LFH_SIG_OFFSET = 0;
  
  private static final int LFH_VERSION_NEEDED_OFFSET = 4;
  
  private static final int LFH_GPB_OFFSET = 6;
  
  private static final int LFH_METHOD_OFFSET = 8;
  
  private static final int LFH_TIME_OFFSET = 10;
  
  private static final int LFH_CRC_OFFSET = 14;
  
  private static final int LFH_COMPRESSED_SIZE_OFFSET = 18;
  
  private static final int LFH_ORIGINAL_SIZE_OFFSET = 22;
  
  private static final int LFH_FILENAME_LENGTH_OFFSET = 26;
  
  private static final int LFH_EXTRA_LENGTH_OFFSET = 28;
  
  private static final int LFH_FILENAME_OFFSET = 30;
  
  private static final int CFH_SIG_OFFSET = 0;
  
  private static final int CFH_VERSION_MADE_BY_OFFSET = 4;
  
  private static final int CFH_VERSION_NEEDED_OFFSET = 6;
  
  private static final int CFH_GPB_OFFSET = 8;
  
  private static final int CFH_METHOD_OFFSET = 10;
  
  private static final int CFH_TIME_OFFSET = 12;
  
  private static final int CFH_CRC_OFFSET = 16;
  
  private static final int CFH_COMPRESSED_SIZE_OFFSET = 20;
  
  private static final int CFH_ORIGINAL_SIZE_OFFSET = 24;
  
  private static final int CFH_FILENAME_LENGTH_OFFSET = 28;
  
  private static final int CFH_EXTRA_LENGTH_OFFSET = 30;
  
  private static final int CFH_COMMENT_LENGTH_OFFSET = 32;
  
  private static final int CFH_DISK_NUMBER_OFFSET = 34;
  
  private static final int CFH_INTERNAL_ATTRIBUTES_OFFSET = 36;
  
  private static final int CFH_EXTERNAL_ATTRIBUTES_OFFSET = 38;
  
  private static final int CFH_LFH_OFFSET = 42;
  
  private static final int CFH_FILENAME_OFFSET = 46;
  
  public static final int DEFLATED = 8;
  
  public static final int DEFAULT_COMPRESSION = -1;
  
  public static final int STORED = 0;
  
  static final String DEFAULT_ENCODING = "UTF8";
  
  @Deprecated
  public static final int EFS_FLAG = 2048;
  
  private static final byte[] ZERO = { 0, 0 };
  
  private static final byte[] LZERO = { 0, 0, 0, 0 };
  
  private static final byte[] ONE = ZipLong.getBytes(1L);
  
  static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes();
  
  static final byte[] DD_SIG = ZipLong.DD_SIG.getBytes();
  
  static final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes();
  
  static final byte[] EOCD_SIG = ZipLong.getBytes(101010256L);
  
  static final byte[] ZIP64_EOCD_SIG = ZipLong.getBytes(101075792L);
  
  static final byte[] ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(117853008L);
  
  protected boolean finished;
  
  private CurrentEntry entry;
  
  private String comment;
  
  private int level;
  
  private boolean hasCompressionLevelChanged;
  
  private int method;
  
  private final List<ZipArchiveEntry> entries;
  
  private final StreamCompressor streamCompressor;
  
  private long cdOffset;
  
  private long cdLength;
  
  private long cdDiskNumberStart;
  
  private long eocdLength;
  
  private final Map<ZipArchiveEntry, EntryMetaData> metaData;
  
  private String encoding;
  
  private ZipEncoding zipEncoding;
  
  protected final Deflater def;
  
  private final SeekableByteChannel channel;
  
  private final OutputStream outputStream;
  
  private boolean useUTF8Flag;
  
  private boolean fallbackToUTF8;
  
  private UnicodeExtraFieldPolicy createUnicodeExtraFields;
  
  private boolean hasUsedZip64;
  
  private Zip64Mode zip64Mode;
  
  private final byte[] copyBuffer;
  
  private final boolean isSplitZip;
  
  private final Map<Integer, Integer> numberOfCDInDiskData;
  
  public ZipArchiveOutputStream(File file) throws IOException { this(file.toPath(), new OpenOption[0]); }
  
  public ZipArchiveOutputStream(File file, long zipSplitSize) throws IOException { this(file.toPath(), zipSplitSize); }
  
  public ZipArchiveOutputStream(OutputStream out) {
    this.comment = "";
    this.level = -1;
    this.method = 8;
    this.entries = new LinkedList();
    this.metaData = new HashMap();
    this.encoding = "UTF8";
    this.zipEncoding = ZipEncodingHelper.getZipEncoding("UTF8");
    this.useUTF8Flag = true;
    this.createUnicodeExtraFields = UnicodeExtraFieldPolicy.NEVER;
    this.zip64Mode = Zip64Mode.AsNeeded;
    this.copyBuffer = new byte[32768];
    this.numberOfCDInDiskData = new HashMap();
    this.outputStream = out;
    this.channel = null;
    this.def = new Deflater(this.level, true);
    this.streamCompressor = StreamCompressor.create(out, this.def);
    this.isSplitZip = false;
  }
  
  public ZipArchiveOutputStream(Path path, long zipSplitSize) throws IOException {
    this.comment = "";
    this.level = -1;
    this.method = 8;
    this.entries = new LinkedList();
    this.metaData = new HashMap();
    this.encoding = "UTF8";
    this.zipEncoding = ZipEncodingHelper.getZipEncoding("UTF8");
    this.useUTF8Flag = true;
    this.createUnicodeExtraFields = UnicodeExtraFieldPolicy.NEVER;
    this.zip64Mode = Zip64Mode.AsNeeded;
    this.copyBuffer = new byte[32768];
    this.numberOfCDInDiskData = new HashMap();
    this.def = new Deflater(this.level, true);
    this.outputStream = new ZipSplitOutputStream(path, zipSplitSize);
    this.streamCompressor = StreamCompressor.create(this.outputStream, this.def);
    this.channel = null;
    this.isSplitZip = true;
  }
  
  public ZipArchiveOutputStream(Path file, OpenOption... options) throws IOException {
    this.comment = "";
    this.level = -1;
    this.method = 8;
    this.entries = new LinkedList();
    this.metaData = new HashMap();
    this.encoding = "UTF8";
    this.zipEncoding = ZipEncodingHelper.getZipEncoding("UTF8");
    this.useUTF8Flag = true;
    this.createUnicodeExtraFields = UnicodeExtraFieldPolicy.NEVER;
    this.zip64Mode = Zip64Mode.AsNeeded;
    this.copyBuffer = new byte[32768];
    this.numberOfCDInDiskData = new HashMap();
    this.def = new Deflater(this.level, true);
    OutputStream outputStream = null;
    SeekableByteChannel channel = null;
    try {
      channel = Files.newByteChannel(file, 
          EnumSet.of(StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.TRUNCATE_EXISTING), new java.nio.file.attribute.FileAttribute[0]);
      streamCompressor = StreamCompressor.create(channel, this.def);
    } catch (IOException e) {
      IOUtils.closeQuietly(channel);
      channel = null;
      outputStream = Files.newOutputStream(file, options);
      streamCompressor = StreamCompressor.create(outputStream, this.def);
    } 
    this.outputStream = outputStream;
    this.channel = channel;
    this.streamCompressor = streamCompressor;
    this.isSplitZip = false;
  }
  
  public ZipArchiveOutputStream(SeekableByteChannel channel) {
    this.comment = "";
    this.level = -1;
    this.method = 8;
    this.entries = new LinkedList();
    this.metaData = new HashMap();
    this.encoding = "UTF8";
    this.zipEncoding = ZipEncodingHelper.getZipEncoding("UTF8");
    this.useUTF8Flag = true;
    this.createUnicodeExtraFields = UnicodeExtraFieldPolicy.NEVER;
    this.zip64Mode = Zip64Mode.AsNeeded;
    this.copyBuffer = new byte[32768];
    this.numberOfCDInDiskData = new HashMap();
    this.channel = channel;
    this.def = new Deflater(this.level, true);
    this.streamCompressor = StreamCompressor.create(channel, this.def);
    this.outputStream = null;
    this.isSplitZip = false;
  }
  
  public void addRawArchiveEntry(ZipArchiveEntry entry, InputStream rawStream) throws IOException {
    ZipArchiveEntry ae = new ZipArchiveEntry(entry);
    if (hasZip64Extra(ae))
      ae.removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID); 
    boolean is2PhaseSource = (ae.getCrc() != -1L && ae.getSize() != -1L && ae.getCompressedSize() != -1L);
    putArchiveEntry(ae, is2PhaseSource);
    copyFromZipInputStream(rawStream);
    closeCopiedEntry(is2PhaseSource);
  }
  
  private void addUnicodeExtraFields(ZipArchiveEntry ze, boolean encodable, ByteBuffer name) throws IOException {
    if (this.createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS || !encodable)
      ze.addExtraField(new UnicodePathExtraField(ze.getName(), name
            .array(), name
            .arrayOffset(), name
            .limit() - name
            .position())); 
    String comm = ze.getComment();
    if (comm != null && !comm.isEmpty()) {
      boolean commentEncodable = this.zipEncoding.canEncode(comm);
      if (this.createUnicodeExtraFields == UnicodeExtraFieldPolicy.ALWAYS || !commentEncodable) {
        ByteBuffer commentB = getEntryEncoding(ze).encode(comm);
        ze.addExtraField(new UnicodeCommentExtraField(comm, commentB
              .array(), commentB
              .arrayOffset(), commentB
              .limit() - commentB
              .position()));
      } 
    } 
  }
  
  public boolean canWriteEntryData(ArchiveEntry ae) {
    if (ae instanceof ZipArchiveEntry) {
      ZipArchiveEntry zae = (ZipArchiveEntry)ae;
      return (zae.getMethod() != ZipMethod.IMPLODING.getCode() && zae
        .getMethod() != ZipMethod.UNSHRINKING.getCode() && 
        ZipUtil.canHandleEntryData(zae));
    } 
    return false;
  }
  
  private boolean checkIfNeedsZip64(Zip64Mode effectiveMode) throws ZipException {
    boolean actuallyNeedsZip64 = isZip64Required(CurrentEntry.access$000(this.entry), effectiveMode);
    if (actuallyNeedsZip64 && effectiveMode == Zip64Mode.Never)
      throw new Zip64RequiredException(Zip64RequiredException.getEntryTooBigMessage(CurrentEntry.access$000(this.entry))); 
    return actuallyNeedsZip64;
  }
  
  public void close() throws IOException {
    try {
      if (!this.finished)
        finish(); 
    } finally {
      destroy();
    } 
  }
  
  public void closeArchiveEntry() throws IOException {
    preClose();
    flushDeflater();
    long bytesWritten = this.streamCompressor.getTotalBytesWritten() - CurrentEntry.access$100(this.entry);
    long realCrc = this.streamCompressor.getCrc32();
    CurrentEntry.access$202(this.entry, this.streamCompressor.getBytesRead());
    Zip64Mode effectiveMode = getEffectiveZip64Mode(CurrentEntry.access$000(this.entry));
    boolean actuallyNeedsZip64 = handleSizesAndCrc(bytesWritten, realCrc, effectiveMode);
    closeEntry(actuallyNeedsZip64, false);
    this.streamCompressor.reset();
  }
  
  private void closeCopiedEntry(boolean phased) throws IOException {
    preClose();
    CurrentEntry.access$202(this.entry, CurrentEntry.access$000(this.entry).getSize());
    Zip64Mode effectiveMode = getEffectiveZip64Mode(CurrentEntry.access$000(this.entry));
    boolean actuallyNeedsZip64 = checkIfNeedsZip64(effectiveMode);
    closeEntry(actuallyNeedsZip64, phased);
  }
  
  private void closeEntry(boolean actuallyNeedsZip64, boolean phased) throws IOException {
    if (!phased && this.channel != null)
      rewriteSizesAndCrc(actuallyNeedsZip64); 
    if (!phased)
      writeDataDescriptor(CurrentEntry.access$000(this.entry)); 
    this.entry = null;
  }
  
  private void copyFromZipInputStream(InputStream src) throws IOException {
    if (this.entry == null)
      throw new IllegalStateException("No current entry"); 
    ZipUtil.checkRequestedFeatures(CurrentEntry.access$000(this.entry));
    CurrentEntry.access$302(this.entry, true);
    int length;
    while ((length = src.read(this.copyBuffer)) >= 0) {
      this.streamCompressor.writeCounted(this.copyBuffer, 0, length);
      count(length);
    } 
  }
  
  public ArchiveEntry createArchiveEntry(File inputFile, String entryName) throws IOException {
    if (this.finished)
      throw new IOException("Stream has already been finished"); 
    return new ZipArchiveEntry(inputFile, entryName);
  }
  
  public ArchiveEntry createArchiveEntry(Path inputPath, String entryName, LinkOption... options) throws IOException {
    if (this.finished)
      throw new IOException("Stream has already been finished"); 
    return new ZipArchiveEntry(inputPath, entryName, new LinkOption[0]);
  }
  
  private byte[] createCentralFileHeader(ZipArchiveEntry ze) throws IOException {
    EntryMetaData entryMetaData = (EntryMetaData)this.metaData.get(ze);
    boolean needsZip64Extra = (hasZip64Extra(ze) || ze.getCompressedSize() >= 4294967295L || ze.getSize() >= 4294967295L || EntryMetaData.access$400(entryMetaData) >= 4294967295L || ze.getDiskNumberStart() >= 65535L || this.zip64Mode == Zip64Mode.Always || this.zip64Mode == Zip64Mode.AlwaysWithCompatibility);
    if (needsZip64Extra && this.zip64Mode == Zip64Mode.Never)
      throw new Zip64RequiredException("Archive's size exceeds the limit of 4GByte."); 
    handleZip64Extra(ze, EntryMetaData.access$400(entryMetaData), needsZip64Extra);
    return createCentralFileHeader(ze, getName(ze), entryMetaData, needsZip64Extra);
  }
  
  private byte[] createCentralFileHeader(ZipArchiveEntry ze, ByteBuffer name, EntryMetaData entryMetaData, boolean needsZip64Extra) throws IOException {
    if (this.isSplitZip) {
      int currentSplitSegment = ((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex();
      if (this.numberOfCDInDiskData.get(Integer.valueOf(currentSplitSegment)) == null) {
        this.numberOfCDInDiskData.put(Integer.valueOf(currentSplitSegment), Integer.valueOf(1));
      } else {
        int originalNumberOfCD = ((Integer)this.numberOfCDInDiskData.get(Integer.valueOf(currentSplitSegment))).intValue();
        this.numberOfCDInDiskData.put(Integer.valueOf(currentSplitSegment), Integer.valueOf(originalNumberOfCD + 1));
      } 
    } 
    byte[] extra = ze.getCentralDirectoryExtra();
    int extraLength = extra.length;
    String comm = ze.getComment();
    if (comm == null)
      comm = ""; 
    ByteBuffer commentB = getEntryEncoding(ze).encode(comm);
    int nameLen = name.limit() - name.position();
    int commentLen = commentB.limit() - commentB.position();
    int len = 46 + nameLen + extraLength + commentLen;
    byte[] buf = new byte[len];
    System.arraycopy(CFH_SIG, 0, buf, 0, 4);
    ZipShort.putShort(ze.getPlatform() << 8 | (!this.hasUsedZip64 ? 20 : 45), buf, 4);
    int zipMethod = ze.getMethod();
    boolean encodable = this.zipEncoding.canEncode(ze.getName());
    ZipShort.putShort(versionNeededToExtract(zipMethod, needsZip64Extra, EntryMetaData.access$500(entryMetaData)), buf, 6);
    getGeneralPurposeBits((!encodable && this.fallbackToUTF8), EntryMetaData.access$500(entryMetaData)).encode(buf, 8);
    ZipShort.putShort(zipMethod, buf, 10);
    ZipUtil.toDosTime(ze.getTime(), buf, 12);
    ZipLong.putLong(ze.getCrc(), buf, 16);
    if (ze.getCompressedSize() >= 4294967295L || ze
      .getSize() >= 4294967295L || this.zip64Mode == Zip64Mode.Always || this.zip64Mode == Zip64Mode.AlwaysWithCompatibility) {
      ZipLong.ZIP64_MAGIC.putLong(buf, 20);
      ZipLong.ZIP64_MAGIC.putLong(buf, 24);
    } else {
      ZipLong.putLong(ze.getCompressedSize(), buf, 20);
      ZipLong.putLong(ze.getSize(), buf, 24);
    } 
    ZipShort.putShort(nameLen, buf, 28);
    ZipShort.putShort(extraLength, buf, 30);
    ZipShort.putShort(commentLen, buf, 32);
    if (this.isSplitZip) {
      if (ze.getDiskNumberStart() >= 65535L || this.zip64Mode == Zip64Mode.Always) {
        ZipShort.putShort(65535, buf, 34);
      } else {
        ZipShort.putShort((int)ze.getDiskNumberStart(), buf, 34);
      } 
    } else {
      System.arraycopy(ZERO, 0, buf, 34, 2);
    } 
    ZipShort.putShort(ze.getInternalAttributes(), buf, 36);
    ZipLong.putLong(ze.getExternalAttributes(), buf, 38);
    if (EntryMetaData.access$400(entryMetaData) >= 4294967295L || this.zip64Mode == Zip64Mode.Always) {
      ZipLong.putLong(4294967295L, buf, 42);
    } else {
      ZipLong.putLong(Math.min(EntryMetaData.access$400(entryMetaData), 4294967295L), buf, 42);
    } 
    System.arraycopy(name.array(), name.arrayOffset(), buf, 46, nameLen);
    int extraStart = 46 + nameLen;
    System.arraycopy(extra, 0, buf, extraStart, extraLength);
    int commentStart = extraStart + extraLength;
    System.arraycopy(commentB.array(), commentB.arrayOffset(), buf, commentStart, commentLen);
    return buf;
  }
  
  private byte[] createLocalFileHeader(ZipArchiveEntry ze, ByteBuffer name, boolean encodable, boolean phased, long archiveOffset) {
    ZipExtraField oldEx = ze.getExtraField(ResourceAlignmentExtraField.ID);
    if (oldEx != null)
      ze.removeExtraField(ResourceAlignmentExtraField.ID); 
    ResourceAlignmentExtraField oldAlignmentEx = (oldEx instanceof ResourceAlignmentExtraField) ? (ResourceAlignmentExtraField)oldEx : null;
    int alignment = ze.getAlignment();
    if (alignment <= 0 && oldAlignmentEx != null)
      alignment = oldAlignmentEx.getAlignment(); 
    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {
      int oldLength = 30 + name.limit() - name.position() + ze.getLocalFileDataExtra().length;
      int padding = (int)(-archiveOffset - oldLength - 4L - 2L & (alignment - 1));
      ze.addExtraField(new ResourceAlignmentExtraField(alignment, (oldAlignmentEx != null && oldAlignmentEx
            .allowMethodChange()), padding));
    } 
    byte[] extra = ze.getLocalFileDataExtra();
    int nameLen = name.limit() - name.position();
    int len = 30 + nameLen + extra.length;
    byte[] buf = new byte[len];
    System.arraycopy(LFH_SIG, 0, buf, 0, 4);
    int zipMethod = ze.getMethod();
    boolean dataDescriptor = usesDataDescriptor(zipMethod, phased);
    ZipShort.putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, 4);
    GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits((!encodable && this.fallbackToUTF8), dataDescriptor);
    generalPurposeBit.encode(buf, 6);
    ZipShort.putShort(zipMethod, buf, 8);
    ZipUtil.toDosTime(ze.getTime(), buf, 10);
    if (phased || (zipMethod != 8 && this.channel == null)) {
      ZipLong.putLong(ze.getCrc(), buf, 14);
    } else {
      System.arraycopy(LZERO, 0, buf, 14, 4);
    } 
    if (hasZip64Extra(CurrentEntry.access$000(this.entry))) {
      ZipLong.ZIP64_MAGIC.putLong(buf, 18);
      ZipLong.ZIP64_MAGIC.putLong(buf, 22);
    } else if (phased) {
      ZipLong.putLong(ze.getCompressedSize(), buf, 18);
      ZipLong.putLong(ze.getSize(), buf, 22);
    } else if (zipMethod == 8 || this.channel != null) {
      System.arraycopy(LZERO, 0, buf, 18, 4);
      System.arraycopy(LZERO, 0, buf, 22, 4);
    } else {
      ZipLong.putLong(ze.getSize(), buf, 18);
      ZipLong.putLong(ze.getSize(), buf, 22);
    } 
    ZipShort.putShort(nameLen, buf, 26);
    ZipShort.putShort(extra.length, buf, 28);
    System.arraycopy(name.array(), name.arrayOffset(), buf, 30, nameLen);
    System.arraycopy(extra, 0, buf, 30 + nameLen, extra.length);
    return buf;
  }
  
  protected final void deflate() throws IOException { this.streamCompressor.deflate(); }
  
  void destroy() throws IOException {
    try {
      if (this.channel != null)
        this.channel.close(); 
    } finally {
      if (this.outputStream != null)
        this.outputStream.close(); 
    } 
  }
  
  public void finish() throws IOException {
    if (this.finished)
      throw new IOException("This archive has already been finished"); 
    if (this.entry != null)
      throw new IOException("This archive contains unclosed entries."); 
    long cdOverallOffset = this.streamCompressor.getTotalBytesWritten();
    this.cdOffset = cdOverallOffset;
    if (this.isSplitZip) {
      ZipSplitOutputStream zipSplitOutputStream = (ZipSplitOutputStream)this.outputStream;
      this.cdOffset = zipSplitOutputStream.getCurrentSplitSegmentBytesWritten();
      this.cdDiskNumberStart = zipSplitOutputStream.getCurrentSplitSegmentIndex();
    } 
    writeCentralDirectoryInChunks();
    this.cdLength = this.streamCompressor.getTotalBytesWritten() - cdOverallOffset;
    ByteBuffer commentData = this.zipEncoding.encode(this.comment);
    long commentLength = commentData.limit() - commentData.position();
    this.eocdLength = 22L + commentLength;
    writeZip64CentralDirectory();
    writeCentralDirectoryEnd();
    this.metaData.clear();
    this.entries.clear();
    this.streamCompressor.close();
    if (this.isSplitZip)
      this.outputStream.close(); 
    this.finished = true;
  }
  
  public void flush() throws IOException {
    if (this.outputStream != null)
      this.outputStream.flush(); 
  }
  
  private void flushDeflater() throws IOException {
    if (CurrentEntry.access$000(this.entry).getMethod() == 8)
      this.streamCompressor.flushDeflater(); 
  }
  
  public long getBytesWritten() { return this.streamCompressor.getTotalBytesWritten(); }
  
  private Zip64Mode getEffectiveZip64Mode(ZipArchiveEntry ze) {
    if (this.zip64Mode != Zip64Mode.AsNeeded || this.channel != null || ze
      
      .getMethod() != 8 || ze
      .getSize() != -1L)
      return this.zip64Mode; 
    return Zip64Mode.Never;
  }
  
  public String getEncoding() { return this.encoding; }
  
  private ZipEncoding getEntryEncoding(ZipArchiveEntry ze) {
    boolean encodable = this.zipEncoding.canEncode(ze.getName());
    return (!encodable && this.fallbackToUTF8) ? 
      ZipEncodingHelper.UTF8_ZIP_ENCODING : this.zipEncoding;
  }
  
  private GeneralPurposeBit getGeneralPurposeBits(boolean utfFallback, boolean usesDataDescriptor) {
    GeneralPurposeBit b = new GeneralPurposeBit();
    b.useUTF8ForNames((this.useUTF8Flag || utfFallback));
    if (usesDataDescriptor)
      b.useDataDescriptor(true); 
    return b;
  }
  
  private ByteBuffer getName(ZipArchiveEntry ze) throws IOException { return getEntryEncoding(ze).encode(ze.getName()); }
  
  private Zip64ExtendedInformationExtraField getZip64Extra(ZipArchiveEntry ze) {
    if (this.entry != null)
      CurrentEntry.access$602(this.entry, !this.hasUsedZip64); 
    this.hasUsedZip64 = true;
    ZipExtraField extra = ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);
    Zip64ExtendedInformationExtraField z64 = (extra instanceof Zip64ExtendedInformationExtraField) ? (Zip64ExtendedInformationExtraField)extra : null;
    if (z64 == null)
      z64 = new Zip64ExtendedInformationExtraField(); 
    ze.addAsFirstExtraField(z64);
    return z64;
  }
  
  private boolean handleSizesAndCrc(long bytesWritten, long crc, Zip64Mode effectiveMode) throws ZipException {
    if (CurrentEntry.access$000(this.entry).getMethod() == 8) {
      CurrentEntry.access$000(this.entry).setSize(CurrentEntry.access$200(this.entry));
      CurrentEntry.access$000(this.entry).setCompressedSize(bytesWritten);
      CurrentEntry.access$000(this.entry).setCrc(crc);
    } else if (this.channel == null) {
      if (CurrentEntry.access$000(this.entry).getCrc() != crc)
        throw new ZipException("Bad CRC checksum for entry " + 
            CurrentEntry.access$000(this.entry).getName() + ": " + 
            Long.toHexString(CurrentEntry.access$000(this.entry).getCrc()) + " instead of " + 
            
            Long.toHexString(crc)); 
      if (CurrentEntry.access$000(this.entry).getSize() != bytesWritten)
        throw new ZipException("Bad size for entry " + 
            CurrentEntry.access$000(this.entry).getName() + ": " + 
            CurrentEntry.access$000(this.entry).getSize() + " instead of " + bytesWritten); 
    } else {
      CurrentEntry.access$000(this.entry).setSize(bytesWritten);
      CurrentEntry.access$000(this.entry).setCompressedSize(bytesWritten);
      CurrentEntry.access$000(this.entry).setCrc(crc);
    } 
    return checkIfNeedsZip64(effectiveMode);
  }
  
  private void handleZip64Extra(ZipArchiveEntry ze, long lfhOffset, boolean needsZip64Extra) {
    if (needsZip64Extra) {
      Zip64ExtendedInformationExtraField z64 = getZip64Extra(ze);
      if (ze.getCompressedSize() >= 4294967295L || ze
        .getSize() >= 4294967295L || this.zip64Mode == Zip64Mode.Always || this.zip64Mode == Zip64Mode.AlwaysWithCompatibility) {
        z64.setCompressedSize(new ZipEightByteInteger(ze.getCompressedSize()));
        z64.setSize(new ZipEightByteInteger(ze.getSize()));
      } else {
        z64.setCompressedSize(null);
        z64.setSize(null);
      } 
      boolean needsToEncodeLfhOffset = (lfhOffset >= 4294967295L || this.zip64Mode == Zip64Mode.Always);
      boolean needsToEncodeDiskNumberStart = (ze.getDiskNumberStart() >= 65535L || this.zip64Mode == Zip64Mode.Always);
      if (needsToEncodeLfhOffset || needsToEncodeDiskNumberStart)
        z64.setRelativeHeaderOffset(new ZipEightByteInteger(lfhOffset)); 
      if (needsToEncodeDiskNumberStart)
        z64.setDiskStartNumber(new ZipLong(ze.getDiskNumberStart())); 
      ze.setExtra();
    } 
  }
  
  private boolean hasZip64Extra(ZipArchiveEntry ze) { return ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID) instanceof Zip64ExtendedInformationExtraField; }
  
  public boolean isSeekable() { return (this.channel != null); }
  
  private boolean isTooLargeForZip32(ZipArchiveEntry zipArchiveEntry) { return (zipArchiveEntry.getSize() >= 4294967295L || zipArchiveEntry.getCompressedSize() >= 4294967295L); }
  
  private boolean isZip64Required(ZipArchiveEntry entry1, Zip64Mode requestedMode) {
    return (requestedMode == Zip64Mode.Always || requestedMode == Zip64Mode.AlwaysWithCompatibility || 
      isTooLargeForZip32(entry1));
  }
  
  private void preClose() throws IOException {
    if (this.finished)
      throw new IOException("Stream has already been finished"); 
    if (this.entry == null)
      throw new IOException("No current entry to close"); 
    if (!CurrentEntry.access$300(this.entry))
      write(ByteUtils.EMPTY_BYTE_ARRAY, 0, 0); 
  }
  
  public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException { putArchiveEntry((ZipArchiveEntry)archiveEntry, false); }
  
  private void putArchiveEntry(ZipArchiveEntry archiveEntry, boolean phased) throws IOException {
    if (this.finished)
      throw new IOException("Stream has already been finished"); 
    if (this.entry != null)
      closeArchiveEntry(); 
    this.entry = new CurrentEntry(archiveEntry, null);
    this.entries.add(CurrentEntry.access$000(this.entry));
    setDefaults(CurrentEntry.access$000(this.entry));
    Zip64Mode effectiveMode = getEffectiveZip64Mode(CurrentEntry.access$000(this.entry));
    validateSizeInformation(effectiveMode);
    if (shouldAddZip64Extra(CurrentEntry.access$000(this.entry), effectiveMode)) {
      ZipEightByteInteger compressedSize, size;
      Zip64ExtendedInformationExtraField z64 = getZip64Extra(CurrentEntry.access$000(this.entry));
      if (phased) {
        size = new ZipEightByteInteger(CurrentEntry.access$000(this.entry).getSize());
        compressedSize = new ZipEightByteInteger(CurrentEntry.access$000(this.entry).getCompressedSize());
      } else if (CurrentEntry.access$000(this.entry).getMethod() == 0 && 
        CurrentEntry.access$000(this.entry).getSize() != -1L) {
        compressedSize = size = new ZipEightByteInteger(CurrentEntry.access$000(this.entry).getSize());
      } else {
        compressedSize = size = ZipEightByteInteger.ZERO;
      } 
      z64.setSize(size);
      z64.setCompressedSize(compressedSize);
      CurrentEntry.access$000(this.entry).setExtra();
    } 
    if (CurrentEntry.access$000(this.entry).getMethod() == 8 && this.hasCompressionLevelChanged) {
      this.def.setLevel(this.level);
      this.hasCompressionLevelChanged = false;
    } 
    writeLocalFileHeader(archiveEntry, phased);
  }
  
  private void rewriteSizesAndCrc(boolean actuallyNeedsZip64) throws IOException {
    long save = this.channel.position();
    this.channel.position(CurrentEntry.access$800(this.entry));
    writeOut(ZipLong.getBytes(CurrentEntry.access$000(this.entry).getCrc()));
    if (!hasZip64Extra(CurrentEntry.access$000(this.entry)) || !actuallyNeedsZip64) {
      writeOut(ZipLong.getBytes(CurrentEntry.access$000(this.entry).getCompressedSize()));
      writeOut(ZipLong.getBytes(CurrentEntry.access$000(this.entry).getSize()));
    } else {
      writeOut(ZipLong.ZIP64_MAGIC.getBytes());
      writeOut(ZipLong.ZIP64_MAGIC.getBytes());
    } 
    if (hasZip64Extra(CurrentEntry.access$000(this.entry))) {
      ByteBuffer name = getName(CurrentEntry.access$000(this.entry));
      int nameLen = name.limit() - name.position();
      this.channel.position(CurrentEntry.access$800(this.entry) + 12L + 4L + nameLen + 4L);
      writeOut(ZipEightByteInteger.getBytes(CurrentEntry.access$000(this.entry).getSize()));
      writeOut(ZipEightByteInteger.getBytes(CurrentEntry.access$000(this.entry).getCompressedSize()));
      if (!actuallyNeedsZip64) {
        this.channel.position(CurrentEntry.access$800(this.entry) - 10L);
        writeOut(ZipShort.getBytes(versionNeededToExtract(CurrentEntry.access$000(this.entry).getMethod(), false, false)));
        CurrentEntry.access$000(this.entry).removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);
        CurrentEntry.access$000(this.entry).setExtra();
        if (CurrentEntry.access$600(this.entry))
          this.hasUsedZip64 = false; 
      } 
    } 
    this.channel.position(save);
  }
  
  public void setComment(String comment) { this.comment = comment; }
  
  public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) { this.createUnicodeExtraFields = b; }
  
  private void setDefaults(ZipArchiveEntry entry) {
    if (entry.getMethod() == -1)
      entry.setMethod(this.method); 
    if (entry.getTime() == -1L)
      entry.setTime(System.currentTimeMillis()); 
  }
  
  public void setEncoding(String encoding) {
    this.encoding = encoding;
    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);
    if (this.useUTF8Flag && !ZipEncodingHelper.isUTF8(encoding))
      this.useUTF8Flag = false; 
  }
  
  public void setFallbackToUTF8(boolean b) throws IOException { this.fallbackToUTF8 = b; }
  
  public void setLevel(int level) {
    if (level < -1 || level > 9)
      throw new IllegalArgumentException("Invalid compression level: " + level); 
    if (this.level == level)
      return; 
    this.hasCompressionLevelChanged = true;
    this.level = level;
  }
  
  public void setMethod(int method) { this.method = method; }
  
  public void setUseLanguageEncodingFlag(boolean b) throws IOException { this.useUTF8Flag = (b && ZipEncodingHelper.isUTF8(this.encoding)); }
  
  public void setUseZip64(Zip64Mode mode) { this.zip64Mode = mode; }
  
  private boolean shouldAddZip64Extra(ZipArchiveEntry entry, Zip64Mode mode) {
    return (mode == Zip64Mode.Always || mode == Zip64Mode.AlwaysWithCompatibility || entry
      
      .getSize() >= 4294967295L || entry
      .getCompressedSize() >= 4294967295L || (entry
      .getSize() == -1L && this.channel != null && mode != Zip64Mode.Never));
  }
  
  private boolean shouldUseZip64EOCD() {
    int numberOfThisDisk = 0;
    if (this.isSplitZip)
      numberOfThisDisk = ((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex(); 
    int numOfEntriesOnThisDisk = ((Integer)this.numberOfCDInDiskData.getOrDefault(Integer.valueOf(numberOfThisDisk), Integer.valueOf(0))).intValue();
    return (numberOfThisDisk >= 65535 || this.cdDiskNumberStart >= 65535L || numOfEntriesOnThisDisk >= 65535 || this.entries

      
      .size() >= 65535 || this.cdLength >= 4294967295L || this.cdOffset >= 4294967295L);
  }
  
  private boolean usesDataDescriptor(int zipMethod, boolean phased) { return (!phased && zipMethod == 8 && this.channel == null); }
  
  private void validateIfZip64IsNeededInEOCD() throws IOException {
    if (this.zip64Mode != Zip64Mode.Never)
      return; 
    int numberOfThisDisk = 0;
    if (this.isSplitZip)
      numberOfThisDisk = ((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex(); 
    if (numberOfThisDisk >= 65535)
      throw new Zip64RequiredException("Number of the disk of End Of Central Directory exceeds the limit of 65535."); 
    if (this.cdDiskNumberStart >= 65535L)
      throw new Zip64RequiredException("Number of the disk with the start of Central Directory exceeds the limit of 65535."); 
    int numOfEntriesOnThisDisk = ((Integer)this.numberOfCDInDiskData.getOrDefault(Integer.valueOf(numberOfThisDisk), Integer.valueOf(0))).intValue();
    if (numOfEntriesOnThisDisk >= 65535)
      throw new Zip64RequiredException("Number of entries on this disk exceeds the limit of 65535."); 
    if (this.entries.size() >= 65535)
      throw new Zip64RequiredException("Archive contains more than 65535 entries."); 
    if (this.cdLength >= 4294967295L)
      throw new Zip64RequiredException("The size of the entire central directory exceeds the limit of 4GByte."); 
    if (this.cdOffset >= 4294967295L)
      throw new Zip64RequiredException("Archive's size exceeds the limit of 4GByte."); 
  }
  
  private void validateSizeInformation(Zip64Mode effectiveMode) {
    if (CurrentEntry.access$000(this.entry).getMethod() == 0 && this.channel == null) {
      if (CurrentEntry.access$000(this.entry).getSize() == -1L)
        throw new ZipException("Uncompressed size is required for STORED method when not writing to a file"); 
      if (CurrentEntry.access$000(this.entry).getCrc() == -1L)
        throw new ZipException("CRC checksum is required for STORED method when not writing to a file"); 
      CurrentEntry.access$000(this.entry).setCompressedSize(CurrentEntry.access$000(this.entry).getSize());
    } 
    if ((CurrentEntry.access$000(this.entry).getSize() >= 4294967295L || 
      CurrentEntry.access$000(this.entry).getCompressedSize() >= 4294967295L) && effectiveMode == Zip64Mode.Never)
      throw new Zip64RequiredException(
          Zip64RequiredException.getEntryTooBigMessage(CurrentEntry.access$000(this.entry))); 
  }
  
  private int versionNeededToExtract(int zipMethod, boolean zip64, boolean usedDataDescriptor) {
    if (zip64)
      return 45; 
    if (usedDataDescriptor)
      return 20; 
    return versionNeededToExtractMethod(zipMethod);
  }
  
  private int versionNeededToExtractMethod(int zipMethod) { return (zipMethod == 8) ? 20 : 10; }
  
  public void write(byte[] b, int offset, int length) throws IOException {
    if (this.entry == null)
      throw new IllegalStateException("No current entry"); 
    ZipUtil.checkRequestedFeatures(CurrentEntry.access$000(this.entry));
    long writtenThisTime = this.streamCompressor.write(b, offset, length, CurrentEntry.access$000(this.entry).getMethod());
    count(writtenThisTime);
  }
  
  protected void writeCentralDirectoryEnd() throws IOException {
    if (!this.hasUsedZip64 && this.isSplitZip)
      ((ZipSplitOutputStream)this.outputStream).prepareToWriteUnsplittableContent(this.eocdLength); 
    validateIfZip64IsNeededInEOCD();
    writeCounted(EOCD_SIG);
    int numberOfThisDisk = 0;
    if (this.isSplitZip)
      numberOfThisDisk = ((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex(); 
    writeCounted(ZipShort.getBytes(numberOfThisDisk));
    writeCounted(ZipShort.getBytes((int)this.cdDiskNumberStart));
    int numberOfEntries = this.entries.size();
    int numOfEntriesOnThisDisk = this.isSplitZip ? ((Integer)this.numberOfCDInDiskData.getOrDefault(Integer.valueOf(numberOfThisDisk), Integer.valueOf(0))).intValue() : numberOfEntries;
    byte[] numOfEntriesOnThisDiskData = ZipShort.getBytes(Math.min(numOfEntriesOnThisDisk, 65535));
    writeCounted(numOfEntriesOnThisDiskData);
    byte[] num = ZipShort.getBytes(Math.min(numberOfEntries, 65535));
    writeCounted(num);
    writeCounted(ZipLong.getBytes(Math.min(this.cdLength, 4294967295L)));
    writeCounted(ZipLong.getBytes(Math.min(this.cdOffset, 4294967295L)));
    ByteBuffer data = this.zipEncoding.encode(this.comment);
    int dataLen = data.limit() - data.position();
    writeCounted(ZipShort.getBytes(dataLen));
    this.streamCompressor.writeCounted(data.array(), data.arrayOffset(), dataLen);
  }
  
  private void writeCentralDirectoryInChunks() throws IOException {
    int NUM_PER_WRITE = 1000;
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(70000);
    int count = 0;
    for (ZipArchiveEntry ze : this.entries) {
      byteArrayOutputStream.write(createCentralFileHeader(ze));
      if (++count > 1000) {
        writeCounted(byteArrayOutputStream.toByteArray());
        byteArrayOutputStream.reset();
        count = 0;
      } 
    } 
    writeCounted(byteArrayOutputStream.toByteArray());
  }
  
  protected void writeCentralFileHeader(ZipArchiveEntry ze) {
    byte[] centralFileHeader = createCentralFileHeader(ze);
    writeCounted(centralFileHeader);
  }
  
  private void writeCounted(byte[] data) throws IOException { this.streamCompressor.writeCounted(data); }
  
  protected void writeDataDescriptor(ZipArchiveEntry ze) {
    if (!usesDataDescriptor(ze.getMethod(), false))
      return; 
    writeCounted(DD_SIG);
    writeCounted(ZipLong.getBytes(ze.getCrc()));
    if (!hasZip64Extra(ze)) {
      writeCounted(ZipLong.getBytes(ze.getCompressedSize()));
      writeCounted(ZipLong.getBytes(ze.getSize()));
    } else {
      writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));
      writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));
    } 
  }
  
  protected void writeLocalFileHeader(ZipArchiveEntry ze) { writeLocalFileHeader(ze, false); }
  
  private void writeLocalFileHeader(ZipArchiveEntry ze, boolean phased) throws IOException {
    boolean encodable = this.zipEncoding.canEncode(ze.getName());
    ByteBuffer name = getName(ze);
    if (this.createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER)
      addUnicodeExtraFields(ze, encodable, name); 
    long localHeaderStart = this.streamCompressor.getTotalBytesWritten();
    if (this.isSplitZip) {
      ZipSplitOutputStream splitOutputStream = (ZipSplitOutputStream)this.outputStream;
      ze.setDiskNumberStart(splitOutputStream.getCurrentSplitSegmentIndex());
      localHeaderStart = splitOutputStream.getCurrentSplitSegmentBytesWritten();
    } 
    byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);
    this.metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod(), phased), null));
    CurrentEntry.access$802(this.entry, localHeaderStart + 14L);
    writeCounted(localHeader);
    CurrentEntry.access$102(this.entry, this.streamCompressor.getTotalBytesWritten());
  }
  
  protected final void writeOut(byte[] data) throws IOException { this.streamCompressor.writeOut(data, 0, data.length); }
  
  protected final void writeOut(byte[] data, int offset, int length) throws IOException { this.streamCompressor.writeOut(data, offset, length); }
  
  public void writePreamble(byte[] preamble) throws IOException { writePreamble(preamble, 0, preamble.length); }
  
  public void writePreamble(byte[] preamble, int offset, int length) throws IOException {
    if (this.entry != null)
      throw new IllegalStateException("Preamble must be written before creating an entry"); 
    this.streamCompressor.writeCounted(preamble, offset, length);
  }
  
  protected void writeZip64CentralDirectory() throws IOException {
    if (this.zip64Mode == Zip64Mode.Never)
      return; 
    if (!this.hasUsedZip64 && shouldUseZip64EOCD())
      this.hasUsedZip64 = true; 
    if (!this.hasUsedZip64)
      return; 
    long offset = this.streamCompressor.getTotalBytesWritten();
    long diskNumberStart = 0L;
    if (this.isSplitZip) {
      ZipSplitOutputStream zipSplitOutputStream = (ZipSplitOutputStream)this.outputStream;
      offset = zipSplitOutputStream.getCurrentSplitSegmentBytesWritten();
      diskNumberStart = zipSplitOutputStream.getCurrentSplitSegmentIndex();
    } 
    writeOut(ZIP64_EOCD_SIG);
    writeOut(
        ZipEightByteInteger.getBytes(44L));
    writeOut(ZipShort.getBytes(45));
    writeOut(ZipShort.getBytes(45));
    int numberOfThisDisk = 0;
    if (this.isSplitZip)
      numberOfThisDisk = ((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex(); 
    writeOut(ZipLong.getBytes(numberOfThisDisk));
    writeOut(ZipLong.getBytes(this.cdDiskNumberStart));
    int numOfEntriesOnThisDisk = this.isSplitZip ? ((Integer)this.numberOfCDInDiskData.getOrDefault(Integer.valueOf(numberOfThisDisk), Integer.valueOf(0))).intValue() : this.entries.size();
    byte[] numOfEntriesOnThisDiskData = ZipEightByteInteger.getBytes(numOfEntriesOnThisDisk);
    writeOut(numOfEntriesOnThisDiskData);
    byte[] num = ZipEightByteInteger.getBytes(this.entries.size());
    writeOut(num);
    writeOut(ZipEightByteInteger.getBytes(this.cdLength));
    writeOut(ZipEightByteInteger.getBytes(this.cdOffset));
    if (this.isSplitZip) {
      int zip64EOCDLOCLength = 20;
      long unsplittableContentSize = 20L + this.eocdLength;
      ((ZipSplitOutputStream)this.outputStream).prepareToWriteUnsplittableContent(unsplittableContentSize);
    } 
    writeOut(ZIP64_EOCD_LOC_SIG);
    writeOut(ZipLong.getBytes(diskNumberStart));
    writeOut(ZipEightByteInteger.getBytes(offset));
    if (this.isSplitZip) {
      int totalNumberOfDisks = ((ZipSplitOutputStream)this.outputStream).getCurrentSplitSegmentIndex() + 1;
      writeOut(ZipLong.getBytes(totalNumberOfDisks));
    } else {
      writeOut(ONE);
    } 
  }
}
