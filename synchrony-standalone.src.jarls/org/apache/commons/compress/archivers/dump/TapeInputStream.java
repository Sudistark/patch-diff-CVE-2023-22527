package org.apache.commons.compress.archivers.dump;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.zip.DataFormatException;
import java.util.zip.Inflater;
import org.apache.commons.compress.utils.ExactMath;
import org.apache.commons.compress.utils.IOUtils;

class TapeInputStream extends FilterInputStream {
  private static final int RECORD_SIZE = 1024;
  
  private byte[] blockBuffer = new byte[1024];
  
  private int currBlkIdx = -1;
  
  private int blockSize = 1024;
  
  private int readOffset = 1024;
  
  private boolean isCompressed;
  
  private long bytesRead;
  
  public TapeInputStream(InputStream in) { super(in); }
  
  public int available() throws IOException {
    if (this.readOffset < this.blockSize)
      return this.blockSize - this.readOffset; 
    return this.in.available();
  }
  
  public void close() throws IOException {
    if (this.in != null && this.in != System.in)
      this.in.close(); 
  }
  
  public long getBytesRead() { return this.bytesRead; }
  
  public byte[] peek() throws IOException {
    if (this.readOffset == this.blockSize)
      try {
        readBlock(true);
      } catch (ShortFileException sfe) {
        return null;
      }  
    byte[] b = new byte[1024];
    System.arraycopy(this.blockBuffer, this.readOffset, b, 0, b.length);
    return b;
  }
  
  public int read() throws IOException { throw new IllegalArgumentException("All reads must be multiple of record size (1024 bytes."); }
  
  public int read(byte[] b, int off, int len) throws IOException {
    if (len == 0)
      return 0; 
    if (len % 1024 != 0)
      throw new IllegalArgumentException("All reads must be multiple of record size (1024 bytes."); 
    int bytes = 0;
    while (bytes < len) {
      if (this.readOffset == this.blockSize)
        try {
          readBlock(true);
        } catch (ShortFileException sfe) {
          return -1;
        }  
      int n = 0;
      if (this.readOffset + len - bytes <= this.blockSize) {
        n = len - bytes;
      } else {
        n = this.blockSize - this.readOffset;
      } 
      System.arraycopy(this.blockBuffer, this.readOffset, b, off, n);
      this.readOffset += n;
      bytes += n;
      off += n;
    } 
    return bytes;
  }
  
  private void readBlock(boolean decompress) throws IOException {
    if (this.in == null)
      throw new IOException("Input buffer is closed"); 
    if (!this.isCompressed || this.currBlkIdx == -1) {
      readFully(this.blockBuffer, 0, this.blockSize);
      this.bytesRead += this.blockSize;
    } else {
      readFully(this.blockBuffer, 0, 4);
      this.bytesRead += 4L;
      int h = DumpArchiveUtil.convert32(this.blockBuffer, 0);
      boolean compressed = ((h & true) == 1);
      if (!compressed) {
        readFully(this.blockBuffer, 0, this.blockSize);
        this.bytesRead += this.blockSize;
      } else {
        int flags = h >> 1 & 0x7;
        int length = h >> 4 & 0xFFFFFFF;
        byte[] compBuffer = readRange(length);
        this.bytesRead += length;
        if (!decompress) {
          Arrays.fill(this.blockBuffer, (byte)0);
        } else {
          switch (null.$SwitchMap$org$apache$commons$compress$archivers$dump$DumpArchiveConstants$COMPRESSION_TYPE[DumpArchiveConstants.COMPRESSION_TYPE.find(flags & 0x3).ordinal()]) {
            case 1:
              inflator = new Inflater();
              try {
                inflator.setInput(compBuffer, 0, compBuffer.length);
                length = inflator.inflate(this.blockBuffer);
                if (length != this.blockSize)
                  throw new ShortFileException(); 
              } catch (DataFormatException e) {
                throw new DumpArchiveException("Bad data", e);
              } finally {
                inflator.end();
              } 
              break;
            case 2:
              throw new UnsupportedCompressionAlgorithmException("BZLIB2");
            case 3:
              throw new UnsupportedCompressionAlgorithmException("LZO");
            default:
              throw new UnsupportedCompressionAlgorithmException();
          } 
        } 
      } 
    } 
    this.currBlkIdx++;
    this.readOffset = 0;
  }
  
  private void readFully(byte[] b, int off, int len) throws IOException {
    int count = IOUtils.readFully(this.in, b, off, len);
    if (count < len)
      throw new ShortFileException(); 
  }
  
  private byte[] readRange(int len) throws IOException {
    byte[] ret = IOUtils.readRange(this.in, len);
    if (ret.length < len)
      throw new ShortFileException(); 
    return ret;
  }
  
  public byte[] readRecord() throws IOException {
    byte[] result = new byte[1024];
    if (-1 == read(result, 0, result.length))
      throw new ShortFileException(); 
    return result;
  }
  
  public void resetBlockSize(int recsPerBlock, boolean isCompressed) throws IOException {
    this.isCompressed = isCompressed;
    if (recsPerBlock < 1)
      throw new IOException("Block with " + recsPerBlock + " records found, must be at least 1"); 
    this.blockSize = 1024 * recsPerBlock;
    byte[] oldBuffer = this.blockBuffer;
    this.blockBuffer = new byte[this.blockSize];
    System.arraycopy(oldBuffer, 0, this.blockBuffer, 0, 1024);
    readFully(this.blockBuffer, 1024, this.blockSize - 1024);
    this.currBlkIdx = 0;
    this.readOffset = 1024;
  }
  
  public long skip(long len) throws IOException {
    if (len % 1024L != 0L)
      throw new IllegalArgumentException("All reads must be multiple of record size (1024 bytes."); 
    long bytes = 0L;
    while (bytes < len) {
      if (this.readOffset == this.blockSize)
        try {
          readBlock((len - bytes < this.blockSize));
        } catch (ShortFileException sfe) {
          return -1L;
        }  
      long n = 0L;
      if (this.readOffset + len - bytes <= this.blockSize) {
        n = len - bytes;
      } else {
        n = this.blockSize - this.readOffset;
      } 
      this.readOffset = ExactMath.add(this.readOffset, n);
      bytes += n;
    } 
    return bytes;
  }
}
