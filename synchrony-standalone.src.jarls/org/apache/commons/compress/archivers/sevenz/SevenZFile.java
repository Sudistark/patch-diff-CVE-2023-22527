package org.apache.commons.compress.archivers.sevenz;

import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.Closeable;
import java.io.DataInputStream;
import java.io.EOFException;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.Channels;
import java.nio.channels.SeekableByteChannel;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.zip.CRC32;
import java.util.zip.CheckedInputStream;
import org.apache.commons.compress.utils.BoundedInputStream;
import org.apache.commons.compress.utils.ByteUtils;
import org.apache.commons.compress.utils.CRC32VerifyingInputStream;
import org.apache.commons.compress.utils.IOUtils;
import org.apache.commons.compress.utils.InputStreamStatistics;

public class SevenZFile implements Closeable {
  static final int SIGNATURE_HEADER_SIZE = 32;
  
  private static final String DEFAULT_FILE_NAME = "unknown archive";
  
  static final byte[] sevenZSignature = { 55, 122, -68, -81, 39, 28 };
  
  private final String fileName;
  
  private SeekableByteChannel channel;
  
  private final Archive archive;
  
  private int currentEntryIndex;
  
  private int currentFolderIndex;
  
  private InputStream currentFolderInputStream;
  
  private byte[] password;
  
  private final SevenZFileOptions options;
  
  private long compressedBytesReadFromCurrentEntry;
  
  private long uncompressedBytesReadFromCurrentEntry;
  
  private final ArrayList<InputStream> deferredBlockStreams;
  
  private static int assertFitsIntoNonNegativeInt(String what, long value) throws IOException {
    if (value > 2147483647L || value < 0L)
      throw new IOException(String.format("Cannot handle % %,d", new Object[] { what, Long.valueOf(value) })); 
    return (int)value;
  }
  
  private static ByteBuffer checkEndOfFile(ByteBuffer buf, int expectRemaining) throws EOFException {
    int remaining = buf.remaining();
    if (remaining < expectRemaining)
      throw new EOFException(String.format("remaining %,d < expectRemaining %,d", new Object[] { Integer.valueOf(remaining), Integer.valueOf(expectRemaining) })); 
    return buf;
  }
  
  private static void get(ByteBuffer buf, byte[] to) throws EOFException { checkEndOfFile(buf, to.length).get(to); }
  
  private static char getChar(ByteBuffer buf) throws EOFException { return checkEndOfFile(buf, 2).getChar(); }
  
  private static int getInt(ByteBuffer buf) throws EOFException { return checkEndOfFile(buf, 4).getInt(); }
  
  private static long getLong(ByteBuffer buf) throws EOFException { return checkEndOfFile(buf, 8).getLong(); }
  
  private static int getUnsignedByte(ByteBuffer buf) throws EOFException {
    if (!buf.hasRemaining())
      throw new EOFException(); 
    return buf.get() & 0xFF;
  }
  
  public static boolean matches(byte[] signature, int length) {
    if (length < sevenZSignature.length)
      return false; 
    for (int i = 0; i < sevenZSignature.length; i++) {
      if (signature[i] != sevenZSignature[i])
        return false; 
    } 
    return true;
  }
  
  private static long readUint64(ByteBuffer in) throws EOFException {
    long firstByte = getUnsignedByte(in);
    int mask = 128;
    long value = 0L;
    for (int i = 0; i < 8; i++) {
      if ((firstByte & mask) == 0L)
        return value | (firstByte & (mask - 1)) << 8 * i; 
      long nextByte = getUnsignedByte(in);
      value |= nextByte << 8 * i;
      mask >>>= 1;
    } 
    return value;
  }
  
  private static long skipBytesFully(ByteBuffer input, long bytesToSkip) {
    if (bytesToSkip < 1L)
      return 0L; 
    int current = input.position();
    int maxSkip = input.remaining();
    if (maxSkip < bytesToSkip)
      bytesToSkip = maxSkip; 
    input.position(current + (int)bytesToSkip);
    return bytesToSkip;
  }
  
  public SevenZFile(File fileName) throws IOException { this(fileName, SevenZFileOptions.DEFAULT); }
  
  @Deprecated
  public SevenZFile(File fileName, byte[] password) throws IOException {
    this(Files.newByteChannel(fileName.toPath(), EnumSet.of(StandardOpenOption.READ), new java.nio.file.attribute.FileAttribute[0]), fileName
        .getAbsolutePath(), password, true, SevenZFileOptions.DEFAULT);
  }
  
  public SevenZFile(File fileName, char[] password) throws IOException { this(fileName, password, SevenZFileOptions.DEFAULT); }
  
  public SevenZFile(File fileName, char[] password, SevenZFileOptions options) throws IOException {
    this(Files.newByteChannel(fileName.toPath(), EnumSet.of(StandardOpenOption.READ), new java.nio.file.attribute.FileAttribute[0]), fileName
        .getAbsolutePath(), AES256SHA256Decoder.utf16Decode(password), true, options);
  }
  
  public SevenZFile(File fileName, SevenZFileOptions options) throws IOException { this(fileName, null, options); }
  
  public SevenZFile(SeekableByteChannel channel) throws IOException { this(channel, SevenZFileOptions.DEFAULT); }
  
  @Deprecated
  public SevenZFile(SeekableByteChannel channel, byte[] password) throws IOException { this(channel, "unknown archive", password); }
  
  public SevenZFile(SeekableByteChannel channel, char[] password) throws IOException { this(channel, password, SevenZFileOptions.DEFAULT); }
  
  public SevenZFile(SeekableByteChannel channel, char[] password, SevenZFileOptions options) throws IOException { this(channel, "unknown archive", password, options); }
  
  public SevenZFile(SeekableByteChannel channel, SevenZFileOptions options) throws IOException { this(channel, "unknown archive", null, options); }
  
  public SevenZFile(SeekableByteChannel channel, String fileName) throws IOException { this(channel, fileName, SevenZFileOptions.DEFAULT); }
  
  @Deprecated
  public SevenZFile(SeekableByteChannel channel, String fileName, byte[] password) throws IOException { this(channel, fileName, password, false, SevenZFileOptions.DEFAULT); }
  
  private SevenZFile(SeekableByteChannel channel, String filename, byte[] password, boolean closeOnError, SevenZFileOptions options) throws IOException {
    this.currentEntryIndex = -1;
    this.currentFolderIndex = -1;
    this.deferredBlockStreams = new ArrayList();
    succeeded = false;
    this.channel = channel;
    this.fileName = filename;
    this.options = options;
    try {
      this.archive = readHeaders(password);
      if (password != null) {
        this.password = Arrays.copyOf(password, password.length);
      } else {
        this.password = null;
      } 
      succeeded = true;
    } finally {
      if (!succeeded && closeOnError)
        this.channel.close(); 
    } 
  }
  
  public SevenZFile(SeekableByteChannel channel, String fileName, char[] password) throws IOException { this(channel, fileName, password, SevenZFileOptions.DEFAULT); }
  
  public SevenZFile(SeekableByteChannel channel, String fileName, char[] password, SevenZFileOptions options) throws IOException { this(channel, fileName, AES256SHA256Decoder.utf16Decode(password), false, options); }
  
  public SevenZFile(SeekableByteChannel channel, String fileName, SevenZFileOptions options) throws IOException { this(channel, fileName, null, false, options); }
  
  private InputStream buildDecoderStack(Folder folder, long folderOffset, int firstPackStreamIndex, SevenZArchiveEntry entry) throws IOException {
    this.channel.position(folderOffset);
    Object object = new Object(this, new BufferedInputStream(new BoundedSeekableByteChannelInputStream(this.channel, this.archive.packSizes[firstPackStreamIndex])));
    LinkedList<SevenZMethodConfiguration> methods = new LinkedList<SevenZMethodConfiguration>();
    for (Coder coder : folder.getOrderedCoders()) {
      if (coder.numInStreams != 1L || coder.numOutStreams != 1L)
        throw new IOException("Multi input/output stream coders are not yet supported"); 
      SevenZMethod method = SevenZMethod.byId(coder.decompressionMethodId);
      object = Coders.addDecoder(this.fileName, object, folder
          .getUnpackSizeForCoder(coder), coder, this.password, this.options.getMaxMemoryLimitInKb());
      methods.addFirst(new SevenZMethodConfiguration(method, 
            Coders.findByMethod(method).getOptionsFromCoder(coder, object)));
    } 
    entry.setContentMethods(methods);
    if (folder.hasCrc)
      return new CRC32VerifyingInputStream(object, folder
          .getUnpackSize(), folder.crc); 
    return object;
  }
  
  private void buildDecodingStream(int entryIndex, boolean isRandomAccess) throws IOException {
    if (this.archive.streamMap == null)
      throw new IOException("Archive doesn't contain stream information to read entries"); 
    int folderIndex = this.archive.streamMap.fileFolderIndex[entryIndex];
    if (folderIndex < 0) {
      this.deferredBlockStreams.clear();
      return;
    } 
    SevenZArchiveEntry file = this.archive.files[entryIndex];
    boolean isInSameFolder = false;
    if (this.currentFolderIndex == folderIndex) {
      if (entryIndex > 0)
        file.setContentMethods(this.archive.files[entryIndex - 1].getContentMethods()); 
      if (isRandomAccess && file.getContentMethods() == null) {
        int folderFirstFileIndex = this.archive.streamMap.folderFirstFileIndex[folderIndex];
        SevenZArchiveEntry folderFirstFile = this.archive.files[folderFirstFileIndex];
        file.setContentMethods(folderFirstFile.getContentMethods());
      } 
      isInSameFolder = true;
    } else {
      this.currentFolderIndex = folderIndex;
      reopenFolderInputStream(folderIndex, file);
    } 
    boolean haveSkippedEntries = false;
    if (isRandomAccess)
      haveSkippedEntries = skipEntriesWhenNeeded(entryIndex, isInSameFolder, folderIndex); 
    if (isRandomAccess && this.currentEntryIndex == entryIndex && !haveSkippedEntries)
      return; 
    CRC32VerifyingInputStream cRC32VerifyingInputStream = new BoundedInputStream(this.currentFolderInputStream, file.getSize());
    if (file.getHasCrc())
      cRC32VerifyingInputStream = new CRC32VerifyingInputStream(cRC32VerifyingInputStream, file.getSize(), file.getCrcValue()); 
    this.deferredBlockStreams.add(cRC32VerifyingInputStream);
  }
  
  private void calculateStreamMap(Archive archive) throws IOException {
    StreamMap streamMap = new StreamMap();
    int nextFolderPackStreamIndex = 0;
    int numFolders = (archive.folders != null) ? archive.folders.length : 0;
    streamMap.folderFirstPackStreamIndex = new int[numFolders];
    for (int i = 0; i < numFolders; i++) {
      streamMap.folderFirstPackStreamIndex[i] = nextFolderPackStreamIndex;
      nextFolderPackStreamIndex += (archive.folders[i]).packedStreams.length;
    } 
    long nextPackStreamOffset = 0L;
    int numPackSizes = archive.packSizes.length;
    streamMap.packStreamOffsets = new long[numPackSizes];
    for (int i = 0; i < numPackSizes; i++) {
      streamMap.packStreamOffsets[i] = nextPackStreamOffset;
      nextPackStreamOffset += archive.packSizes[i];
    } 
    streamMap.folderFirstFileIndex = new int[numFolders];
    streamMap.fileFolderIndex = new int[archive.files.length];
    int nextFolderIndex = 0;
    int nextFolderUnpackStreamIndex = 0;
    for (int i = 0; i < archive.files.length; i++) {
      if (!archive.files[i].hasStream() && nextFolderUnpackStreamIndex == 0) {
        streamMap.fileFolderIndex[i] = -1;
      } else {
        if (nextFolderUnpackStreamIndex == 0) {
          for (; nextFolderIndex < archive.folders.length; nextFolderIndex++) {
            streamMap.folderFirstFileIndex[nextFolderIndex] = i;
            if ((archive.folders[nextFolderIndex]).numUnpackSubStreams > 0)
              break; 
          } 
          if (nextFolderIndex >= archive.folders.length)
            throw new IOException("Too few folders in archive"); 
        } 
        streamMap.fileFolderIndex[i] = nextFolderIndex;
        if (archive.files[i].hasStream()) {
          nextFolderUnpackStreamIndex++;
          if (nextFolderUnpackStreamIndex >= (archive.folders[nextFolderIndex]).numUnpackSubStreams) {
            nextFolderIndex++;
            nextFolderUnpackStreamIndex = 0;
          } 
        } 
      } 
    } 
    archive.streamMap = streamMap;
  }
  
  private void checkEntryIsInitialized(Map<Integer, SevenZArchiveEntry> archiveEntries, int index) { archiveEntries.computeIfAbsent(Integer.valueOf(index), i -> new SevenZArchiveEntry()); }
  
  public void close() throws IOException {
    if (this.channel != null)
      try {
        this.channel.close();
      } finally {
        this.channel = null;
        if (this.password != null)
          Arrays.fill(this.password, (byte)0); 
        this.password = null;
      }  
  }
  
  private InputStream getCurrentStream() throws IOException {
    if (this.archive.files[this.currentEntryIndex].getSize() == 0L)
      return new ByteArrayInputStream(ByteUtils.EMPTY_BYTE_ARRAY); 
    if (this.deferredBlockStreams.isEmpty())
      throw new IllegalStateException("No current 7z entry (call getNextEntry() first)."); 
    while (this.deferredBlockStreams.size() > 1) {
      InputStream stream = (InputStream)this.deferredBlockStreams.remove(0);
      try {
        IOUtils.skip(stream, Float.MAX_VALUE);
        if (stream != null)
          stream.close(); 
      } catch (Throwable throwable) {
        if (stream != null)
          try {
            stream.close();
          } catch (Throwable throwable1) {
            throwable.addSuppressed(throwable1);
          }  
        throw throwable;
      } 
      this.compressedBytesReadFromCurrentEntry = 0L;
    } 
    return (InputStream)this.deferredBlockStreams.get(0);
  }
  
  public String getDefaultName() {
    if ("unknown archive".equals(this.fileName) || this.fileName == null)
      return null; 
    String lastSegment = (new File(this.fileName)).getName();
    int dotPos = lastSegment.lastIndexOf(".");
    if (dotPos > 0)
      return lastSegment.substring(0, dotPos); 
    return lastSegment + "~";
  }
  
  public Iterable<SevenZArchiveEntry> getEntries() { return new ArrayList(Arrays.asList(this.archive.files)); }
  
  public InputStream getInputStream(SevenZArchiveEntry entry) throws IOException {
    int entryIndex = -1;
    for (int i = 0; i < this.archive.files.length; i++) {
      if (entry == this.archive.files[i]) {
        entryIndex = i;
        break;
      } 
    } 
    if (entryIndex < 0)
      throw new IllegalArgumentException("Can not find " + entry.getName() + " in " + this.fileName); 
    buildDecodingStream(entryIndex, true);
    this.currentEntryIndex = entryIndex;
    this.currentFolderIndex = this.archive.streamMap.fileFolderIndex[entryIndex];
    return getCurrentStream();
  }
  
  public SevenZArchiveEntry getNextEntry() throws IOException {
    if (this.currentEntryIndex >= this.archive.files.length - 1)
      return null; 
    this.currentEntryIndex++;
    SevenZArchiveEntry entry = this.archive.files[this.currentEntryIndex];
    if (entry.getName() == null && this.options.getUseDefaultNameForUnnamedEntries())
      entry.setName(getDefaultName()); 
    buildDecodingStream(this.currentEntryIndex, false);
    this.uncompressedBytesReadFromCurrentEntry = this.compressedBytesReadFromCurrentEntry = 0L;
    return entry;
  }
  
  public InputStreamStatistics getStatisticsForCurrentEntry() { return new Object(this); }
  
  private boolean hasCurrentEntryBeenRead() {
    boolean hasCurrentEntryBeenRead = false;
    if (!this.deferredBlockStreams.isEmpty()) {
      InputStream currentEntryInputStream = (InputStream)this.deferredBlockStreams.get(this.deferredBlockStreams.size() - 1);
      if (currentEntryInputStream instanceof CRC32VerifyingInputStream)
        hasCurrentEntryBeenRead = (((CRC32VerifyingInputStream)currentEntryInputStream).getBytesRemaining() != this.archive.files[this.currentEntryIndex].getSize()); 
      if (currentEntryInputStream instanceof BoundedInputStream)
        hasCurrentEntryBeenRead = (((BoundedInputStream)currentEntryInputStream).getBytesRemaining() != this.archive.files[this.currentEntryIndex].getSize()); 
    } 
    return hasCurrentEntryBeenRead;
  }
  
  private Archive initializeArchive(StartHeader startHeader, byte[] password, boolean verifyCrc) throws IOException {
    assertFitsIntoNonNegativeInt("nextHeaderSize", startHeader.nextHeaderSize);
    int nextHeaderSizeInt = (int)startHeader.nextHeaderSize;
    this.channel.position(32L + startHeader.nextHeaderOffset);
    if (verifyCrc) {
      long position = this.channel.position();
      CheckedInputStream cis = new CheckedInputStream(Channels.newInputStream(this.channel), new CRC32());
      if (cis.skip(nextHeaderSizeInt) != nextHeaderSizeInt)
        throw new IOException("Problem computing NextHeader CRC-32"); 
      if (startHeader.nextHeaderCrc != cis.getChecksum().getValue())
        throw new IOException("NextHeader CRC-32 mismatch"); 
      this.channel.position(position);
    } 
    Archive archive = new Archive();
    ByteBuffer buf = ByteBuffer.allocate(nextHeaderSizeInt).order(ByteOrder.LITTLE_ENDIAN);
    readFully(buf);
    int nid = getUnsignedByte(buf);
    if (nid == 23) {
      buf = readEncodedHeader(buf, archive, password);
      archive = new Archive();
      nid = getUnsignedByte(buf);
    } 
    if (nid != 1)
      throw new IOException("Broken or unsupported archive: no Header"); 
    readHeader(buf, archive);
    archive.subStreamsInfo = null;
    return archive;
  }
  
  public int read() throws IOException {
    int b = getCurrentStream().read();
    if (b >= 0)
      this.uncompressedBytesReadFromCurrentEntry++; 
    return b;
  }
  
  public int read(byte[] b) throws IOException { return read(b, 0, b.length); }
  
  public int read(byte[] b, int off, int len) throws IOException {
    if (len == 0)
      return 0; 
    int cnt = getCurrentStream().read(b, off, len);
    if (cnt > 0)
      this.uncompressedBytesReadFromCurrentEntry += cnt; 
    return cnt;
  }
  
  private BitSet readAllOrBits(ByteBuffer header, int size) throws IOException {
    BitSet bits;
    int areAllDefined = getUnsignedByte(header);
    if (areAllDefined != 0) {
      bits = new BitSet(size);
      for (int i = 0; i < size; i++)
        bits.set(i, true); 
    } else {
      bits = readBits(header, size);
    } 
    return bits;
  }
  
  private void readArchiveProperties(ByteBuffer input) throws IOException {
    int nid = getUnsignedByte(input);
    while (nid != 0) {
      long propertySize = readUint64(input);
      byte[] property = new byte[(int)propertySize];
      get(input, property);
      nid = getUnsignedByte(input);
    } 
  }
  
  private BitSet readBits(ByteBuffer header, int size) throws IOException {
    BitSet bits = new BitSet(size);
    int mask = 0;
    int cache = 0;
    for (int i = 0; i < size; i++) {
      if (mask == 0) {
        mask = 128;
        cache = getUnsignedByte(header);
      } 
      bits.set(i, ((cache & mask) != 0));
      mask >>>= 1;
    } 
    return bits;
  }
  
  private ByteBuffer readEncodedHeader(ByteBuffer header, Archive archive, byte[] password) throws IOException {
    int pos = header.position();
    ArchiveStatistics stats = new ArchiveStatistics(null);
    sanityCheckStreamsInfo(header, stats);
    stats.assertValidity(this.options.getMaxMemoryLimitInKb());
    header.position(pos);
    readStreamsInfo(header, archive);
    if (archive.folders == null || archive.folders.length == 0)
      throw new IOException("no folders, can't read encoded header"); 
    if (archive.packSizes == null || archive.packSizes.length == 0)
      throw new IOException("no packed streams, can't read encoded header"); 
    Folder folder = archive.folders[0];
    int firstPackStreamIndex = 0;
    long folderOffset = 32L + archive.packPos + 0L;
    this.channel.position(folderOffset);
    CRC32VerifyingInputStream cRC32VerifyingInputStream = new BoundedSeekableByteChannelInputStream(this.channel, archive.packSizes[0]);
    for (Coder coder : folder.getOrderedCoders()) {
      if (coder.numInStreams != 1L || coder.numOutStreams != 1L)
        throw new IOException("Multi input/output stream coders are not yet supported"); 
      cRC32VerifyingInputStream = Coders.addDecoder(this.fileName, cRC32VerifyingInputStream, folder
          .getUnpackSizeForCoder(coder), coder, password, this.options.getMaxMemoryLimitInKb());
    } 
    if (folder.hasCrc)
      cRC32VerifyingInputStream = new CRC32VerifyingInputStream(cRC32VerifyingInputStream, folder.getUnpackSize(), folder.crc); 
    int unpackSize = assertFitsIntoNonNegativeInt("unpackSize", folder.getUnpackSize());
    byte[] nextHeader = IOUtils.readRange(cRC32VerifyingInputStream, unpackSize);
    if (nextHeader.length < unpackSize)
      throw new IOException("premature end of stream"); 
    cRC32VerifyingInputStream.close();
    return ByteBuffer.wrap(nextHeader).order(ByteOrder.LITTLE_ENDIAN);
  }
  
  private void readFilesInfo(ByteBuffer header, Archive archive) throws IOException {
    int numFilesInt = (int)readUint64(header);
    Map<Integer, SevenZArchiveEntry> fileMap = new LinkedHashMap<Integer, SevenZArchiveEntry>();
    BitSet isEmptyStream = null;
    BitSet isEmptyFile = null;
    BitSet isAnti = null;
    while (true) {
      int i, nextName, nextFile, i, namesLength, i, i, i;
      BitSet attributesDefined, timesDefined, timesDefined, timesDefined;
      byte[] names;
      int propertyType = getUnsignedByte(header);
      if (propertyType == 0)
        break; 
      long size = readUint64(header);
      switch (propertyType) {
        case 14:
          isEmptyStream = readBits(header, numFilesInt);
          continue;
        case 15:
          isEmptyFile = readBits(header, isEmptyStream.cardinality());
          continue;
        case 16:
          isAnti = readBits(header, isEmptyStream.cardinality());
          continue;
        case 17:
          getUnsignedByte(header);
          names = new byte[(int)(size - 1L)];
          namesLength = names.length;
          get(header, names);
          nextFile = 0;
          nextName = 0;
          for (i = 0; i < namesLength; i += 2) {
            if (names[i] == 0 && names[i + 1] == 0) {
              checkEntryIsInitialized(fileMap, nextFile);
              ((SevenZArchiveEntry)fileMap.get(Integer.valueOf(nextFile))).setName(new String(names, nextName, i - nextName, StandardCharsets.UTF_16LE));
              nextName = i + 2;
              nextFile++;
            } 
          } 
          if (nextName != namesLength || nextFile != numFilesInt)
            throw new IOException("Error parsing file names"); 
          continue;
        case 18:
          timesDefined = readAllOrBits(header, numFilesInt);
          getUnsignedByte(header);
          for (i = 0; i < numFilesInt; i++) {
            checkEntryIsInitialized(fileMap, i);
            SevenZArchiveEntry entryAtIndex = (SevenZArchiveEntry)fileMap.get(Integer.valueOf(i));
            entryAtIndex.setHasCreationDate(timesDefined.get(i));
            if (entryAtIndex.getHasCreationDate())
              entryAtIndex.setCreationDate(getLong(header)); 
          } 
          continue;
        case 19:
          timesDefined = readAllOrBits(header, numFilesInt);
          getUnsignedByte(header);
          for (i = 0; i < numFilesInt; i++) {
            checkEntryIsInitialized(fileMap, i);
            SevenZArchiveEntry entryAtIndex = (SevenZArchiveEntry)fileMap.get(Integer.valueOf(i));
            entryAtIndex.setHasAccessDate(timesDefined.get(i));
            if (entryAtIndex.getHasAccessDate())
              entryAtIndex.setAccessDate(getLong(header)); 
          } 
          continue;
        case 20:
          timesDefined = readAllOrBits(header, numFilesInt);
          getUnsignedByte(header);
          for (i = 0; i < numFilesInt; i++) {
            checkEntryIsInitialized(fileMap, i);
            SevenZArchiveEntry entryAtIndex = (SevenZArchiveEntry)fileMap.get(Integer.valueOf(i));
            entryAtIndex.setHasLastModifiedDate(timesDefined.get(i));
            if (entryAtIndex.getHasLastModifiedDate())
              entryAtIndex.setLastModifiedDate(getLong(header)); 
          } 
          continue;
        case 21:
          attributesDefined = readAllOrBits(header, numFilesInt);
          getUnsignedByte(header);
          for (i = 0; i < numFilesInt; i++) {
            checkEntryIsInitialized(fileMap, i);
            SevenZArchiveEntry entryAtIndex = (SevenZArchiveEntry)fileMap.get(Integer.valueOf(i));
            entryAtIndex.setHasWindowsAttributes(attributesDefined.get(i));
            if (entryAtIndex.getHasWindowsAttributes())
              entryAtIndex.setWindowsAttributes(getInt(header)); 
          } 
          continue;
        case 25:
          skipBytesFully(header, size);
          continue;
      } 
      skipBytesFully(header, size);
    } 
    int nonEmptyFileCounter = 0;
    int emptyFileCounter = 0;
    for (int i = 0; i < numFilesInt; i++) {
      SevenZArchiveEntry entryAtIndex = (SevenZArchiveEntry)fileMap.get(Integer.valueOf(i));
      if (entryAtIndex != null) {
        entryAtIndex.setHasStream((isEmptyStream == null || !isEmptyStream.get(i)));
        if (entryAtIndex.hasStream()) {
          if (archive.subStreamsInfo == null)
            throw new IOException("Archive contains file with streams but no subStreamsInfo"); 
          entryAtIndex.setDirectory(false);
          entryAtIndex.setAntiItem(false);
          entryAtIndex.setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));
          entryAtIndex.setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);
          entryAtIndex.setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);
          if (entryAtIndex.getSize() < 0L)
            throw new IOException("broken archive, entry with negative size"); 
          nonEmptyFileCounter++;
        } else {
          entryAtIndex.setDirectory((isEmptyFile == null || !isEmptyFile.get(emptyFileCounter)));
          entryAtIndex.setAntiItem((isAnti != null && isAnti.get(emptyFileCounter)));
          entryAtIndex.setHasCrc(false);
          entryAtIndex.setSize(0L);
          emptyFileCounter++;
        } 
      } 
    } 
    archive.files = (SevenZArchiveEntry[])fileMap.values().stream().filter(Objects::nonNull).toArray(x$0 -> new SevenZArchiveEntry[x$0]);
    calculateStreamMap(archive);
  }
  
  private Folder readFolder(ByteBuffer header) throws IOException {
    Folder folder = new Folder();
    long numCoders = readUint64(header);
    Coder[] coders = new Coder[(int)numCoders];
    long totalInStreams = 0L;
    long totalOutStreams = 0L;
    for (int i = 0; i < coders.length; i++) {
      coders[i] = new Coder();
      int bits = getUnsignedByte(header);
      int idSize = bits & 0xF;
      boolean isSimple = ((bits & 0x10) == 0);
      boolean hasAttributes = ((bits & 0x20) != 0);
      boolean moreAlternativeMethods = ((bits & 0x80) != 0);
      (coders[i]).decompressionMethodId = new byte[idSize];
      get(header, (coders[i]).decompressionMethodId);
      if (isSimple) {
        (coders[i]).numInStreams = 1L;
        (coders[i]).numOutStreams = 1L;
      } else {
        (coders[i]).numInStreams = readUint64(header);
        (coders[i]).numOutStreams = readUint64(header);
      } 
      totalInStreams += (coders[i]).numInStreams;
      totalOutStreams += (coders[i]).numOutStreams;
      if (hasAttributes) {
        long propertiesSize = readUint64(header);
        (coders[i]).properties = new byte[(int)propertiesSize];
        get(header, (coders[i]).properties);
      } 
      if (moreAlternativeMethods)
        throw new IOException("Alternative methods are unsupported, please report. The reference implementation doesn't support them either."); 
    } 
    folder.coders = coders;
    folder.totalInputStreams = totalInStreams;
    folder.totalOutputStreams = totalOutStreams;
    long numBindPairs = totalOutStreams - 1L;
    BindPair[] bindPairs = new BindPair[(int)numBindPairs];
    for (int i = 0; i < bindPairs.length; i++) {
      bindPairs[i] = new BindPair();
      (bindPairs[i]).inIndex = readUint64(header);
      (bindPairs[i]).outIndex = readUint64(header);
    } 
    folder.bindPairs = bindPairs;
    long numPackedStreams = totalInStreams - numBindPairs;
    long[] packedStreams = new long[(int)numPackedStreams];
    if (numPackedStreams == 1L) {
      int i;
      for (i = 0; i < (int)totalInStreams && 
        folder.findBindPairForInStream(i) >= 0; i++);
      packedStreams[0] = i;
    } else {
      for (int i = 0; i < (int)numPackedStreams; i++)
        packedStreams[i] = readUint64(header); 
    } 
    folder.packedStreams = packedStreams;
    return folder;
  }
  
  private void readFully(ByteBuffer buf) throws IOException {
    buf.rewind();
    IOUtils.readFully(this.channel, buf);
    buf.flip();
  }
  
  private void readHeader(ByteBuffer header, Archive archive) throws IOException {
    int pos = header.position();
    ArchiveStatistics stats = sanityCheckAndCollectStatistics(header);
    stats.assertValidity(this.options.getMaxMemoryLimitInKb());
    header.position(pos);
    int nid = getUnsignedByte(header);
    if (nid == 2) {
      readArchiveProperties(header);
      nid = getUnsignedByte(header);
    } 
    if (nid == 3)
      throw new IOException("Additional streams unsupported"); 
    if (nid == 4) {
      readStreamsInfo(header, archive);
      nid = getUnsignedByte(header);
    } 
    if (nid == 5) {
      readFilesInfo(header, archive);
      nid = getUnsignedByte(header);
    } 
  }
  
  private Archive readHeaders(byte[] password) throws IOException {
    ByteBuffer buf = ByteBuffer.allocate(12).order(ByteOrder.LITTLE_ENDIAN);
    readFully(buf);
    byte[] signature = new byte[6];
    buf.get(signature);
    if (!Arrays.equals(signature, sevenZSignature))
      throw new IOException("Bad 7z signature"); 
    byte archiveVersionMajor = buf.get();
    byte archiveVersionMinor = buf.get();
    if (archiveVersionMajor != 0)
      throw new IOException(String.format("Unsupported 7z version (%d,%d)", new Object[] { Byte.valueOf(archiveVersionMajor), Byte.valueOf(archiveVersionMinor) })); 
    boolean headerLooksValid = false;
    long startHeaderCrc = 0xFFFFFFFFL & buf.getInt();
    if (startHeaderCrc == 0L) {
      long currentPosition = this.channel.position();
      ByteBuffer peekBuf = ByteBuffer.allocate(20);
      readFully(peekBuf);
      this.channel.position(currentPosition);
      while (peekBuf.hasRemaining()) {
        if (peekBuf.get() != 0) {
          headerLooksValid = true;
          break;
        } 
      } 
    } else {
      headerLooksValid = true;
    } 
    if (headerLooksValid)
      return initializeArchive(readStartHeader(startHeaderCrc), password, true); 
    if (this.options.getTryToRecoverBrokenArchives())
      return tryToLocateEndHeader(password); 
    throw new IOException("archive seems to be invalid.\nYou may want to retry and enable the tryToRecoverBrokenArchives if the archive could be a multi volume archive that has been closed prematurely.");
  }
  
  private void readPackInfo(ByteBuffer header, Archive archive) throws IOException {
    archive.packPos = readUint64(header);
    int numPackStreamsInt = (int)readUint64(header);
    int nid = getUnsignedByte(header);
    if (nid == 9) {
      archive.packSizes = new long[numPackStreamsInt];
      for (int i = 0; i < archive.packSizes.length; i++)
        archive.packSizes[i] = readUint64(header); 
      nid = getUnsignedByte(header);
    } 
    if (nid == 10) {
      archive.packCrcsDefined = readAllOrBits(header, numPackStreamsInt);
      archive.packCrcs = new long[numPackStreamsInt];
      for (int i = 0; i < numPackStreamsInt; i++) {
        if (archive.packCrcsDefined.get(i))
          archive.packCrcs[i] = 0xFFFFFFFFL & getInt(header); 
      } 
      nid = getUnsignedByte(header);
    } 
  }
  
  private StartHeader readStartHeader(long startHeaderCrc) throws IOException {
    StartHeader startHeader = new StartHeader();
    DataInputStream dataInputStream = new DataInputStream(new CRC32VerifyingInputStream(new BoundedSeekableByteChannelInputStream(this.channel, 20L), 20L, startHeaderCrc));
    try {
      startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());
      if (startHeader.nextHeaderOffset < 0L || startHeader.nextHeaderOffset + 32L > this.channel
        .size())
        throw new IOException("nextHeaderOffset is out of bounds"); 
      startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());
      long nextHeaderEnd = startHeader.nextHeaderOffset + startHeader.nextHeaderSize;
      if (nextHeaderEnd < startHeader.nextHeaderOffset || nextHeaderEnd + 32L > this.channel
        .size())
        throw new IOException("nextHeaderSize is out of bounds"); 
      startHeader.nextHeaderCrc = 0xFFFFFFFFL & Integer.reverseBytes(dataInputStream.readInt());
      StartHeader startHeader1 = startHeader;
      dataInputStream.close();
      return startHeader1;
    } catch (Throwable throwable) {
      try {
        dataInputStream.close();
      } catch (Throwable throwable1) {
        throwable.addSuppressed(throwable1);
      } 
      throw throwable;
    } 
  }
  
  private void readStreamsInfo(ByteBuffer header, Archive archive) throws IOException {
    int nid = getUnsignedByte(header);
    if (nid == 6) {
      readPackInfo(header, archive);
      nid = getUnsignedByte(header);
    } 
    if (nid == 7) {
      readUnpackInfo(header, archive);
      nid = getUnsignedByte(header);
    } else {
      archive.folders = Folder.EMPTY_FOLDER_ARRAY;
    } 
    if (nid == 8) {
      readSubStreamsInfo(header, archive);
      nid = getUnsignedByte(header);
    } 
  }
  
  private void readSubStreamsInfo(ByteBuffer header, Archive archive) throws IOException {
    for (Folder folder : archive.folders)
      folder.numUnpackSubStreams = 1; 
    long unpackStreamsCount = archive.folders.length;
    int nid = getUnsignedByte(header);
    if (nid == 13) {
      unpackStreamsCount = 0L;
      for (Folder folder : archive.folders) {
        long numStreams = readUint64(header);
        folder.numUnpackSubStreams = (int)numStreams;
        unpackStreamsCount += numStreams;
      } 
      nid = getUnsignedByte(header);
    } 
    int totalUnpackStreams = (int)unpackStreamsCount;
    SubStreamsInfo subStreamsInfo = new SubStreamsInfo();
    subStreamsInfo.unpackSizes = new long[totalUnpackStreams];
    subStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);
    subStreamsInfo.crcs = new long[totalUnpackStreams];
    int nextUnpackStream = 0;
    for (Folder folder : archive.folders) {
      if (folder.numUnpackSubStreams != 0) {
        long sum = 0L;
        if (nid == 9)
          for (int i = 0; i < folder.numUnpackSubStreams - 1; i++) {
            long size = readUint64(header);
            subStreamsInfo.unpackSizes[nextUnpackStream++] = size;
            sum += size;
          }  
        if (sum > folder.getUnpackSize())
          throw new IOException("sum of unpack sizes of folder exceeds total unpack size"); 
        subStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;
      } 
    } 
    if (nid == 9)
      nid = getUnsignedByte(header); 
    int numDigests = 0;
    for (Folder folder : archive.folders) {
      if (folder.numUnpackSubStreams != 1 || !folder.hasCrc)
        numDigests += folder.numUnpackSubStreams; 
    } 
    if (nid == 10) {
      BitSet hasMissingCrc = readAllOrBits(header, numDigests);
      long[] missingCrcs = new long[numDigests];
      for (int i = 0; i < numDigests; i++) {
        if (hasMissingCrc.get(i))
          missingCrcs[i] = 0xFFFFFFFFL & getInt(header); 
      } 
      int nextCrc = 0;
      int nextMissingCrc = 0;
      for (Folder folder : archive.folders) {
        if (folder.numUnpackSubStreams == 1 && folder.hasCrc) {
          subStreamsInfo.hasCrc.set(nextCrc, true);
          subStreamsInfo.crcs[nextCrc] = folder.crc;
          nextCrc++;
        } else {
          for (int i = 0; i < folder.numUnpackSubStreams; i++) {
            subStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));
            subStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];
            nextCrc++;
            nextMissingCrc++;
          } 
        } 
      } 
      nid = getUnsignedByte(header);
    } 
    archive.subStreamsInfo = subStreamsInfo;
  }
  
  private void readUnpackInfo(ByteBuffer header, Archive archive) throws IOException {
    int nid = getUnsignedByte(header);
    int numFoldersInt = (int)readUint64(header);
    Folder[] folders = new Folder[numFoldersInt];
    archive.folders = folders;
    getUnsignedByte(header);
    for (int i = 0; i < numFoldersInt; i++)
      folders[i] = readFolder(header); 
    nid = getUnsignedByte(header);
    for (Folder folder : folders) {
      assertFitsIntoNonNegativeInt("totalOutputStreams", folder.totalOutputStreams);
      folder.unpackSizes = new long[(int)folder.totalOutputStreams];
      for (int i = 0; i < folder.totalOutputStreams; i++)
        folder.unpackSizes[i] = readUint64(header); 
    } 
    nid = getUnsignedByte(header);
    if (nid == 10) {
      BitSet crcsDefined = readAllOrBits(header, numFoldersInt);
      for (int i = 0; i < numFoldersInt; i++) {
        if (crcsDefined.get(i)) {
          (folders[i]).hasCrc = true;
          (folders[i]).crc = 0xFFFFFFFFL & getInt(header);
        } else {
          (folders[i]).hasCrc = false;
        } 
      } 
      nid = getUnsignedByte(header);
    } 
  }
  
  private void reopenFolderInputStream(int folderIndex, SevenZArchiveEntry file) throws IOException {
    this.deferredBlockStreams.clear();
    if (this.currentFolderInputStream != null) {
      this.currentFolderInputStream.close();
      this.currentFolderInputStream = null;
    } 
    Folder folder = this.archive.folders[folderIndex];
    int firstPackStreamIndex = this.archive.streamMap.folderFirstPackStreamIndex[folderIndex];
    long folderOffset = 32L + this.archive.packPos + this.archive.streamMap.packStreamOffsets[firstPackStreamIndex];
    this.currentFolderInputStream = buildDecoderStack(folder, folderOffset, firstPackStreamIndex, file);
  }
  
  private ArchiveStatistics sanityCheckAndCollectStatistics(ByteBuffer header) throws IOException {
    ArchiveStatistics stats = new ArchiveStatistics(null);
    int nid = getUnsignedByte(header);
    if (nid == 2) {
      sanityCheckArchiveProperties(header);
      nid = getUnsignedByte(header);
    } 
    if (nid == 3)
      throw new IOException("Additional streams unsupported"); 
    if (nid == 4) {
      sanityCheckStreamsInfo(header, stats);
      nid = getUnsignedByte(header);
    } 
    if (nid == 5) {
      sanityCheckFilesInfo(header, stats);
      nid = getUnsignedByte(header);
    } 
    if (nid != 0)
      throw new IOException("Badly terminated header, found " + nid); 
    return stats;
  }
  
  private void sanityCheckArchiveProperties(ByteBuffer header) throws IOException {
    int nid = getUnsignedByte(header);
    while (nid != 0) {
      int propertySize = assertFitsIntoNonNegativeInt("propertySize", readUint64(header));
      if (skipBytesFully(header, propertySize) < propertySize)
        throw new IOException("invalid property size"); 
      nid = getUnsignedByte(header);
    } 
  }
  
  private void sanityCheckFilesInfo(ByteBuffer header, ArchiveStatistics stats) throws IOException {
    ArchiveStatistics.access$302(stats, assertFitsIntoNonNegativeInt("numFiles", readUint64(header)));
    int emptyStreams = -1;
    while (true) {
      int i, filesSeen, external, external, external, namesLength, external, attributesDefined, timesDefined, timesDefined, external, timesDefined, propertyType = getUnsignedByte(header);
      if (propertyType == 0)
        break; 
      long size = readUint64(header);
      switch (propertyType) {
        case 14:
          emptyStreams = readBits(header, ArchiveStatistics.access$300(stats)).cardinality();
          continue;
        case 15:
          if (emptyStreams == -1)
            throw new IOException("Header format error: kEmptyStream must appear before kEmptyFile"); 
          readBits(header, emptyStreams);
          continue;
        case 16:
          if (emptyStreams == -1)
            throw new IOException("Header format error: kEmptyStream must appear before kAnti"); 
          readBits(header, emptyStreams);
          continue;
        case 17:
          external = getUnsignedByte(header);
          if (external != 0)
            throw new IOException("Not implemented"); 
          namesLength = assertFitsIntoNonNegativeInt("file names length", size - 1L);
          if ((namesLength & true) != 0)
            throw new IOException("File names length invalid"); 
          filesSeen = 0;
          for (i = 0; i < namesLength; i += 2) {
            char c = getChar(header);
            if (c == '\000')
              filesSeen++; 
          } 
          if (filesSeen != ArchiveStatistics.access$300(stats))
            throw new IOException("Invalid number of file names (" + filesSeen + " instead of " + 
                ArchiveStatistics.access$300(stats) + ")"); 
          continue;
        case 18:
          timesDefined = readAllOrBits(header, ArchiveStatistics.access$300(stats)).cardinality();
          external = getUnsignedByte(header);
          if (external != 0)
            throw new IOException("Not implemented"); 
          if (skipBytesFully(header, (8 * timesDefined)) < (8 * timesDefined))
            throw new IOException("invalid creation dates size"); 
          continue;
        case 19:
          timesDefined = readAllOrBits(header, ArchiveStatistics.access$300(stats)).cardinality();
          external = getUnsignedByte(header);
          if (external != 0)
            throw new IOException("Not implemented"); 
          if (skipBytesFully(header, (8 * timesDefined)) < (8 * timesDefined))
            throw new IOException("invalid access dates size"); 
          continue;
        case 20:
          timesDefined = readAllOrBits(header, ArchiveStatistics.access$300(stats)).cardinality();
          external = getUnsignedByte(header);
          if (external != 0)
            throw new IOException("Not implemented"); 
          if (skipBytesFully(header, (8 * timesDefined)) < (8 * timesDefined))
            throw new IOException("invalid modification dates size"); 
          continue;
        case 21:
          attributesDefined = readAllOrBits(header, ArchiveStatistics.access$300(stats)).cardinality();
          external = getUnsignedByte(header);
          if (external != 0)
            throw new IOException("Not implemented"); 
          if (skipBytesFully(header, (4 * attributesDefined)) < (4 * attributesDefined))
            throw new IOException("invalid windows attributes size"); 
          continue;
        case 24:
          throw new IOException("kStartPos is unsupported, please report");
        case 25:
          if (skipBytesFully(header, size) < size)
            throw new IOException("Incomplete kDummy property"); 
          continue;
      } 
      if (skipBytesFully(header, size) < size)
        throw new IOException("Incomplete property of type " + propertyType); 
    } 
    ArchiveStatistics.access$402(stats, ArchiveStatistics.access$300(stats) - Math.max(emptyStreams, 0));
  }
  
  private int sanityCheckFolder(ByteBuffer header, ArchiveStatistics stats) throws IOException {
    int numCoders = assertFitsIntoNonNegativeInt("numCoders", readUint64(header));
    if (numCoders == 0)
      throw new IOException("Folder without coders"); 
    ArchiveStatistics.access$514(stats, numCoders);
    long totalOutStreams = 0L;
    long totalInStreams = 0L;
    for (int i = 0; i < numCoders; i++) {
      int bits = getUnsignedByte(header);
      int idSize = bits & 0xF;
      get(header, new byte[idSize]);
      boolean isSimple = ((bits & 0x10) == 0);
      boolean hasAttributes = ((bits & 0x20) != 0);
      boolean moreAlternativeMethods = ((bits & 0x80) != 0);
      if (moreAlternativeMethods)
        throw new IOException("Alternative methods are unsupported, please report. The reference implementation doesn't support them either."); 
      if (isSimple) {
        totalInStreams++;
        totalOutStreams++;
      } else {
        totalInStreams += 
          assertFitsIntoNonNegativeInt("numInStreams", readUint64(header));
        totalOutStreams += 
          assertFitsIntoNonNegativeInt("numOutStreams", readUint64(header));
      } 
      if (hasAttributes) {
        int propertiesSize = assertFitsIntoNonNegativeInt("propertiesSize", readUint64(header));
        if (skipBytesFully(header, propertiesSize) < propertiesSize)
          throw new IOException("invalid propertiesSize in folder"); 
      } 
    } 
    assertFitsIntoNonNegativeInt("totalInStreams", totalInStreams);
    assertFitsIntoNonNegativeInt("totalOutStreams", totalOutStreams);
    ArchiveStatistics.access$614(stats, totalOutStreams);
    ArchiveStatistics.access$714(stats, totalInStreams);
    if (totalOutStreams == 0L)
      throw new IOException("Total output streams can't be 0"); 
    int numBindPairs = assertFitsIntoNonNegativeInt("numBindPairs", totalOutStreams - 1L);
    if (totalInStreams < numBindPairs)
      throw new IOException("Total input streams can't be less than the number of bind pairs"); 
    BitSet inStreamsBound = new BitSet((int)totalInStreams);
    for (int i = 0; i < numBindPairs; i++) {
      int inIndex = assertFitsIntoNonNegativeInt("inIndex", readUint64(header));
      if (totalInStreams <= inIndex)
        throw new IOException("inIndex is bigger than number of inStreams"); 
      inStreamsBound.set(inIndex);
      int outIndex = assertFitsIntoNonNegativeInt("outIndex", readUint64(header));
      if (totalOutStreams <= outIndex)
        throw new IOException("outIndex is bigger than number of outStreams"); 
    } 
    int numPackedStreams = assertFitsIntoNonNegativeInt("numPackedStreams", totalInStreams - numBindPairs);
    if (numPackedStreams == 1) {
      if (inStreamsBound.nextClearBit(0) == -1)
        throw new IOException("Couldn't find stream's bind pair index"); 
    } else {
      for (int i = 0; i < numPackedStreams; i++) {
        int packedStreamIndex = assertFitsIntoNonNegativeInt("packedStreamIndex", readUint64(header));
        if (packedStreamIndex >= totalInStreams)
          throw new IOException("packedStreamIndex is bigger than number of totalInStreams"); 
      } 
    } 
    return (int)totalOutStreams;
  }
  
  private void sanityCheckPackInfo(ByteBuffer header, ArchiveStatistics stats) throws IOException {
    long packPos = readUint64(header);
    if (packPos < 0L || 32L + packPos > this.channel.size() || 32L + packPos < 0L)
      throw new IOException("packPos (" + packPos + ") is out of range"); 
    long numPackStreams = readUint64(header);
    ArchiveStatistics.access$802(stats, assertFitsIntoNonNegativeInt("numPackStreams", numPackStreams));
    int nid = getUnsignedByte(header);
    if (nid == 9) {
      long totalPackSizes = 0L;
      for (int i = 0; i < ArchiveStatistics.access$800(stats); i++) {
        long packSize = readUint64(header);
        totalPackSizes += packSize;
        long endOfPackStreams = 32L + packPos + totalPackSizes;
        if (packSize < 0L || endOfPackStreams > this.channel
          .size() || endOfPackStreams < packPos)
          throw new IOException("packSize (" + packSize + ") is out of range"); 
      } 
      nid = getUnsignedByte(header);
    } 
    if (nid == 10) {
      int crcsDefined = readAllOrBits(header, ArchiveStatistics.access$800(stats)).cardinality();
      if (skipBytesFully(header, (4 * crcsDefined)) < (4 * crcsDefined))
        throw new IOException("invalid number of CRCs in PackInfo"); 
      nid = getUnsignedByte(header);
    } 
    if (nid != 0)
      throw new IOException("Badly terminated PackInfo (" + nid + ")"); 
  }
  
  private void sanityCheckStreamsInfo(ByteBuffer header, ArchiveStatistics stats) throws IOException {
    int nid = getUnsignedByte(header);
    if (nid == 6) {
      sanityCheckPackInfo(header, stats);
      nid = getUnsignedByte(header);
    } 
    if (nid == 7) {
      sanityCheckUnpackInfo(header, stats);
      nid = getUnsignedByte(header);
    } 
    if (nid == 8) {
      sanityCheckSubStreamsInfo(header, stats);
      nid = getUnsignedByte(header);
    } 
    if (nid != 0)
      throw new IOException("Badly terminated StreamsInfo"); 
  }
  
  private void sanityCheckSubStreamsInfo(ByteBuffer header, ArchiveStatistics stats) throws IOException {
    int nid = getUnsignedByte(header);
    List<Integer> numUnpackSubStreamsPerFolder = new LinkedList<Integer>();
    if (nid == 13) {
      for (int i = 0; i < ArchiveStatistics.access$900(stats); i++)
        numUnpackSubStreamsPerFolder.add(Integer.valueOf(assertFitsIntoNonNegativeInt("numStreams", readUint64(header)))); 
      ArchiveStatistics.access$1002(stats, numUnpackSubStreamsPerFolder.stream().mapToLong(Integer::longValue).sum());
      nid = getUnsignedByte(header);
    } else {
      ArchiveStatistics.access$1002(stats, ArchiveStatistics.access$900(stats));
    } 
    assertFitsIntoNonNegativeInt("totalUnpackStreams", ArchiveStatistics.access$1000(stats));
    if (nid == 9) {
      for (Iterator iterator = numUnpackSubStreamsPerFolder.iterator(); iterator.hasNext(); ) {
        int numUnpackSubStreams = ((Integer)iterator.next()).intValue();
        if (numUnpackSubStreams == 0)
          continue; 
        for (int i = 0; i < numUnpackSubStreams - 1; i++) {
          long size = readUint64(header);
          if (size < 0L)
            throw new IOException("negative unpackSize"); 
        } 
      } 
      nid = getUnsignedByte(header);
    } 
    int numDigests = 0;
    if (numUnpackSubStreamsPerFolder.isEmpty()) {
      numDigests = (ArchiveStatistics.access$1100(stats) == null) ? ArchiveStatistics.access$900(stats) : (ArchiveStatistics.access$900(stats) - ArchiveStatistics.access$1100(stats).cardinality());
    } else {
      int folderIdx = 0;
      for (Iterator iterator = numUnpackSubStreamsPerFolder.iterator(); iterator.hasNext(); ) {
        int numUnpackSubStreams = ((Integer)iterator.next()).intValue();
        if (numUnpackSubStreams != 1 || ArchiveStatistics.access$1100(stats) == null || 
          !ArchiveStatistics.access$1100(stats).get(folderIdx++))
          numDigests += numUnpackSubStreams; 
      } 
    } 
    if (nid == 10) {
      assertFitsIntoNonNegativeInt("numDigests", numDigests);
      int missingCrcs = readAllOrBits(header, numDigests).cardinality();
      if (skipBytesFully(header, (4 * missingCrcs)) < (4 * missingCrcs))
        throw new IOException("invalid number of missing CRCs in SubStreamInfo"); 
      nid = getUnsignedByte(header);
    } 
    if (nid != 0)
      throw new IOException("Badly terminated SubStreamsInfo"); 
  }
  
  private void sanityCheckUnpackInfo(ByteBuffer header, ArchiveStatistics stats) throws IOException {
    int nid = getUnsignedByte(header);
    if (nid != 11)
      throw new IOException("Expected kFolder, got " + nid); 
    long numFolders = readUint64(header);
    ArchiveStatistics.access$902(stats, assertFitsIntoNonNegativeInt("numFolders", numFolders));
    int external = getUnsignedByte(header);
    if (external != 0)
      throw new IOException("External unsupported"); 
    List<Integer> numberOfOutputStreamsPerFolder = new LinkedList<Integer>();
    for (int i = 0; i < ArchiveStatistics.access$900(stats); i++)
      numberOfOutputStreamsPerFolder.add(Integer.valueOf(sanityCheckFolder(header, stats))); 
    long totalNumberOfBindPairs = ArchiveStatistics.access$600(stats) - ArchiveStatistics.access$900(stats);
    long packedStreamsRequiredByFolders = ArchiveStatistics.access$700(stats) - totalNumberOfBindPairs;
    if (packedStreamsRequiredByFolders < ArchiveStatistics.access$800(stats))
      throw new IOException("archive doesn't contain enough packed streams"); 
    nid = getUnsignedByte(header);
    if (nid != 12)
      throw new IOException("Expected kCodersUnpackSize, got " + nid); 
    for (Iterator iterator = numberOfOutputStreamsPerFolder.iterator(); iterator.hasNext(); ) {
      int numberOfOutputStreams = ((Integer)iterator.next()).intValue();
      for (int i = 0; i < numberOfOutputStreams; i++) {
        long unpackSize = readUint64(header);
        if (unpackSize < 0L)
          throw new IllegalArgumentException("negative unpackSize"); 
      } 
    } 
    nid = getUnsignedByte(header);
    if (nid == 10) {
      ArchiveStatistics.access$1102(stats, readAllOrBits(header, ArchiveStatistics.access$900(stats)));
      int crcsDefined = ArchiveStatistics.access$1100(stats).cardinality();
      if (skipBytesFully(header, (4 * crcsDefined)) < (4 * crcsDefined))
        throw new IOException("invalid number of CRCs in UnpackInfo"); 
      nid = getUnsignedByte(header);
    } 
    if (nid != 0)
      throw new IOException("Badly terminated UnpackInfo"); 
  }
  
  private boolean skipEntriesWhenNeeded(int entryIndex, boolean isInSameFolder, int folderIndex) throws IOException {
    SevenZArchiveEntry file = this.archive.files[entryIndex];
    if (this.currentEntryIndex == entryIndex && !hasCurrentEntryBeenRead())
      return false; 
    int filesToSkipStartIndex = this.archive.streamMap.folderFirstFileIndex[this.currentFolderIndex];
    if (isInSameFolder)
      if (this.currentEntryIndex < entryIndex) {
        filesToSkipStartIndex = this.currentEntryIndex + 1;
      } else {
        reopenFolderInputStream(folderIndex, file);
      }  
    for (int i = filesToSkipStartIndex; i < entryIndex; i++) {
      SevenZArchiveEntry fileToSkip = this.archive.files[i];
      CRC32VerifyingInputStream cRC32VerifyingInputStream = new BoundedInputStream(this.currentFolderInputStream, fileToSkip.getSize());
      if (fileToSkip.getHasCrc())
        cRC32VerifyingInputStream = new CRC32VerifyingInputStream(cRC32VerifyingInputStream, fileToSkip.getSize(), fileToSkip.getCrcValue()); 
      this.deferredBlockStreams.add(cRC32VerifyingInputStream);
      fileToSkip.setContentMethods(file.getContentMethods());
    } 
    return true;
  }
  
  public String toString() { return this.archive.toString(); }
  
  private Archive tryToLocateEndHeader(byte[] password) throws IOException {
    long minPos;
    ByteBuffer nidBuf = ByteBuffer.allocate(1);
    long searchLimit = 1048576L;
    long previousDataSize = this.channel.position() + 20L;
    if (this.channel.position() + 1048576L > this.channel.size()) {
      minPos = this.channel.position();
    } else {
      minPos = this.channel.size() - 1048576L;
    } 
    long pos = this.channel.size() - 1L;
    while (pos > minPos) {
      pos--;
      this.channel.position(pos);
      nidBuf.rewind();
      if (this.channel.read(nidBuf) < 1)
        throw new EOFException(); 
      int nid = nidBuf.array()[0];
      if (nid == 23 || nid == 1)
        try {
          StartHeader startHeader = new StartHeader();
          startHeader.nextHeaderOffset = pos - previousDataSize;
          startHeader.nextHeaderSize = this.channel.size() - pos;
          Archive result = initializeArchive(startHeader, password, false);
          if (result.packSizes.length > 0 && result.files.length > 0)
            return result; 
        } catch (Exception exception) {} 
    } 
    throw new IOException("Start header corrupt and unable to guess end header");
  }
}
