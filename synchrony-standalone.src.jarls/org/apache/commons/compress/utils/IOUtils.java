package org.apache.commons.compress.utils;

import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.EOFException;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.nio.channels.ReadableByteChannel;
import java.nio.file.Files;
import java.nio.file.LinkOption;

public final class IOUtils {
  private static final int COPY_BUF_SIZE = 8024;
  
  private static final int SKIP_BUF_SIZE = 4096;
  
  public static final LinkOption[] EMPTY_LINK_OPTIONS = new LinkOption[0];
  
  private static final byte[] SKIP_BUF = new byte[4096];
  
  public static void closeQuietly(Closeable c) {
    if (c != null)
      try {
        c.close();
      } catch (IOException iOException) {} 
  }
  
  public static void copy(File sourceFile, OutputStream outputStream) throws IOException { Files.copy(sourceFile.toPath(), outputStream); }
  
  public static long copy(InputStream input, OutputStream output) throws IOException { return copy(input, output, 8024); }
  
  public static long copy(InputStream input, OutputStream output, int buffersize) throws IOException {
    if (buffersize < 1)
      throw new IllegalArgumentException("buffersize must be bigger than 0"); 
    byte[] buffer = new byte[buffersize];
    int n = 0;
    long count = 0L;
    while (-1 != (n = input.read(buffer))) {
      if (output != null)
        output.write(buffer, 0, n); 
      count += n;
    } 
    return count;
  }
  
  public static long copyRange(InputStream input, long len, OutputStream output) throws IOException { return copyRange(input, len, output, 8024); }
  
  public static long copyRange(InputStream input, long len, OutputStream output, int buffersize) throws IOException {
    if (buffersize < 1)
      throw new IllegalArgumentException("buffersize must be bigger than 0"); 
    byte[] buffer = new byte[(int)Math.min(buffersize, len)];
    int n = 0;
    long count = 0L;
    while (count < len && -1 != (n = input.read(buffer, 0, (int)Math.min(len - count, buffer.length)))) {
      if (output != null)
        output.write(buffer, 0, n); 
      count += n;
    } 
    return count;
  }
  
  public static int read(File file, byte[] array) throws IOException {
    InputStream inputStream = Files.newInputStream(file.toPath(), new java.nio.file.OpenOption[0]);
    try {
      int i = readFully(inputStream, array, 0, array.length);
      if (inputStream != null)
        inputStream.close(); 
      return i;
    } catch (Throwable throwable) {
      if (inputStream != null)
        try {
          inputStream.close();
        } catch (Throwable throwable1) {
          throwable.addSuppressed(throwable1);
        }  
      throw throwable;
    } 
  }
  
  public static int readFully(InputStream input, byte[] array) throws IOException { return readFully(input, array, 0, array.length); }
  
  public static int readFully(InputStream input, byte[] array, int offset, int len) throws IOException {
    if (len < 0 || offset < 0 || len + offset > array.length || len + offset < 0)
      throw new IndexOutOfBoundsException(); 
    int count = 0, x = 0;
    while (count != len) {
      x = input.read(array, offset + count, len - count);
      if (x == -1)
        break; 
      count += x;
    } 
    return count;
  }
  
  public static void readFully(ReadableByteChannel channel, ByteBuffer byteBuffer) throws IOException {
    int expectedLength = byteBuffer.remaining();
    int read = 0;
    while (read < expectedLength) {
      int readNow = channel.read(byteBuffer);
      if (readNow <= 0)
        break; 
      read += readNow;
    } 
    if (read < expectedLength)
      throw new EOFException(); 
  }
  
  public static byte[] readRange(InputStream input, int len) throws IOException {
    ByteArrayOutputStream output = new ByteArrayOutputStream();
    copyRange(input, len, output);
    return output.toByteArray();
  }
  
  public static byte[] readRange(ReadableByteChannel input, int len) throws IOException {
    ByteArrayOutputStream output = new ByteArrayOutputStream();
    ByteBuffer b = ByteBuffer.allocate(Math.min(len, 8024));
    int read = 0;
    while (read < len) {
      b.limit(Math.min(len - read, b.capacity()));
      int readNow = input.read(b);
      if (readNow <= 0)
        break; 
      output.write(b.array(), 0, readNow);
      b.rewind();
      read += readNow;
    } 
    return output.toByteArray();
  }
  
  public static long skip(InputStream input, long numToSkip) throws IOException {
    long available = numToSkip;
    while (numToSkip > 0L) {
      long skipped = input.skip(numToSkip);
      if (skipped == 0L)
        break; 
      numToSkip -= skipped;
    } 
    while (numToSkip > 0L) {
      int read = readFully(input, SKIP_BUF, 0, 
          (int)Math.min(numToSkip, 4096L));
      if (read < 1)
        break; 
      numToSkip -= read;
    } 
    return available - numToSkip;
  }
  
  public static byte[] toByteArray(InputStream input) throws IOException {
    ByteArrayOutputStream output = new ByteArrayOutputStream();
    copy(input, output);
    return output.toByteArray();
  }
}
