package org.apache.commons.compress.compressors.lzw;

import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteOrder;
import org.apache.commons.compress.MemoryLimitException;
import org.apache.commons.compress.compressors.CompressorInputStream;
import org.apache.commons.compress.utils.BitInputStream;
import org.apache.commons.compress.utils.InputStreamStatistics;

public abstract class LZWInputStream extends CompressorInputStream implements InputStreamStatistics {
  protected static final int DEFAULT_CODE_SIZE = 9;
  
  protected static final int UNUSED_PREFIX = -1;
  
  private final byte[] oneByte;
  
  protected final BitInputStream in;
  
  private int clearCode;
  
  private int codeSize;
  
  private byte previousCodeFirstChar;
  
  private int previousCode;
  
  private int tableSize;
  
  private int[] prefixes;
  
  private byte[] characters;
  
  private byte[] outputStack;
  
  private int outputStackLocation;
  
  protected LZWInputStream(InputStream inputStream, ByteOrder byteOrder) {
    this.oneByte = new byte[1];
    this.clearCode = -1;
    this.codeSize = 9;
    this.previousCode = -1;
    this.in = new BitInputStream(inputStream, byteOrder);
  }
  
  protected abstract int addEntry(int paramInt, byte paramByte) throws IOException;
  
  protected int addEntry(int previousCode, byte character, int maxTableSize) {
    if (this.tableSize < maxTableSize) {
      this.prefixes[this.tableSize] = previousCode;
      this.characters[this.tableSize] = character;
      return this.tableSize++;
    } 
    return -1;
  }
  
  protected int addRepeatOfPreviousCode() throws IOException {
    if (this.previousCode == -1)
      throw new IOException("The first code can't be a reference to its preceding code"); 
    return addEntry(this.previousCode, this.previousCodeFirstChar);
  }
  
  public void close() throws IOException { this.in.close(); }
  
  protected abstract int decompressNextSymbol() throws IOException;
  
  protected int expandCodeToOutputStack(int code, boolean addedUnfinishedEntry) throws IOException {
    for (int entry = code; entry >= 0; entry = this.prefixes[entry])
      this.outputStack[--this.outputStackLocation] = this.characters[entry]; 
    if (this.previousCode != -1 && !addedUnfinishedEntry)
      addEntry(this.previousCode, this.outputStack[this.outputStackLocation]); 
    this.previousCode = code;
    this.previousCodeFirstChar = this.outputStack[this.outputStackLocation];
    return this.outputStackLocation;
  }
  
  protected int getClearCode() throws IOException { return this.clearCode; }
  
  protected int getCodeSize() throws IOException { return this.codeSize; }
  
  public long getCompressedCount() { return this.in.getBytesRead(); }
  
  protected int getPrefix(int offset) { return this.prefixes[offset]; }
  
  protected int getPrefixesLength() throws IOException { return this.prefixes.length; }
  
  protected int getTableSize() throws IOException { return this.tableSize; }
  
  protected void incrementCodeSize() throws IOException { this.codeSize++; }
  
  protected void initializeTables(int maxCodeSize) {
    if (maxCodeSize <= 0)
      throw new IllegalArgumentException("maxCodeSize is " + maxCodeSize + ", must be bigger than 0"); 
    int maxTableSize = 1 << maxCodeSize;
    this.prefixes = new int[maxTableSize];
    this.characters = new byte[maxTableSize];
    this.outputStack = new byte[maxTableSize];
    this.outputStackLocation = maxTableSize;
    int max = 256;
    for (int i = 0; i < 256; i++) {
      this.prefixes[i] = -1;
      this.characters[i] = (byte)i;
    } 
  }
  
  protected void initializeTables(int maxCodeSize, int memoryLimitInKb) throws MemoryLimitException {
    if (maxCodeSize <= 0)
      throw new IllegalArgumentException("maxCodeSize is " + maxCodeSize + ", must be bigger than 0"); 
    if (memoryLimitInKb > -1) {
      int maxTableSize = 1 << maxCodeSize;
      long memoryUsageInBytes = maxTableSize * 6L;
      long memoryUsageInKb = memoryUsageInBytes >> 10;
      if (memoryUsageInKb > memoryLimitInKb)
        throw new MemoryLimitException(memoryUsageInKb, memoryLimitInKb); 
    } 
    initializeTables(maxCodeSize);
  }
  
  public int read() throws IOException {
    int ret = read(this.oneByte);
    if (ret < 0)
      return ret; 
    return 0xFF & this.oneByte[0];
  }
  
  public int read(byte[] b, int off, int len) throws IOException {
    if (len == 0)
      return 0; 
    int bytesRead = readFromStack(b, off, len);
    while (len - bytesRead > 0) {
      int result = decompressNextSymbol();
      if (result < 0) {
        if (bytesRead > 0) {
          count(bytesRead);
          return bytesRead;
        } 
        return result;
      } 
      bytesRead += readFromStack(b, off + bytesRead, len - bytesRead);
    } 
    count(bytesRead);
    return bytesRead;
  }
  
  private int readFromStack(byte[] b, int off, int len) throws IOException {
    int remainingInStack = this.outputStack.length - this.outputStackLocation;
    if (remainingInStack > 0) {
      int maxLength = Math.min(remainingInStack, len);
      System.arraycopy(this.outputStack, this.outputStackLocation, b, off, maxLength);
      this.outputStackLocation += maxLength;
      return maxLength;
    } 
    return 0;
  }
  
  protected int readNextCode() throws IOException {
    if (this.codeSize > 31)
      throw new IllegalArgumentException("Code size must not be bigger than 31"); 
    return (int)this.in.readBits(this.codeSize);
  }
  
  protected void resetCodeSize() throws IOException { setCodeSize(9); }
  
  protected void resetPreviousCode() throws IOException { this.previousCode = -1; }
  
  protected void setClearCode(int codeSize) { this.clearCode = 1 << codeSize - 1; }
  
  protected void setCodeSize(int cs) { this.codeSize = cs; }
  
  protected void setPrefix(int offset, int value) throws MemoryLimitException { this.prefixes[offset] = value; }
  
  protected void setTableSize(int newSize) { this.tableSize = newSize; }
}
