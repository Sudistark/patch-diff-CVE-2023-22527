package org.apache.commons.compress.compressors.snappy;

import java.io.IOException;
import java.io.InputStream;
import org.apache.commons.compress.compressors.lz77support.AbstractLZ77CompressorInputStream;
import org.apache.commons.compress.utils.ByteUtils;

public class SnappyCompressorInputStream extends AbstractLZ77CompressorInputStream {
  private static final int TAG_MASK = 3;
  
  public static final int DEFAULT_BLOCK_SIZE = 32768;
  
  private final int size;
  
  private int uncompressedBytesRemaining;
  
  private State state = State.NO_BLOCK;
  
  private boolean endReached;
  
  public SnappyCompressorInputStream(InputStream is) throws IOException { this(is, 32768); }
  
  public SnappyCompressorInputStream(InputStream is, int blockSize) throws IOException {
    super(is, blockSize);
    this.uncompressedBytesRemaining = this.size = (int)readSize();
  }
  
  private void fill() throws IOException {
    if (this.uncompressedBytesRemaining == 0) {
      this.endReached = true;
      return;
    } 
    int b = readOneByte();
    if (b == -1)
      throw new IOException("Premature end of stream reading block start"); 
    int length = 0;
    int offset = 0;
    switch (b & 0x3) {
      case 0:
        length = readLiteralLength(b);
        if (length < 0)
          throw new IOException("Illegal block with a negative literal size found"); 
        this.uncompressedBytesRemaining -= length;
        startLiteral(length);
        this.state = State.IN_LITERAL;
        break;
      case 1:
        length = 4 + (b >> 2 & 0x7);
        this.uncompressedBytesRemaining -= length;
        offset = (b & 0xE0) << 3;
        b = readOneByte();
        if (b == -1)
          throw new IOException("Premature end of stream reading back-reference length"); 
        offset |= b;
        try {
          startBackReference(offset, length);
        } catch (IllegalArgumentException ex) {
          throw new IOException("Illegal block with bad offset found", ex);
        } 
        this.state = State.IN_BACK_REFERENCE;
        break;
      case 2:
        length = (b >> 2) + 1;
        if (length < 0)
          throw new IOException("Illegal block with a negative match length found"); 
        this.uncompressedBytesRemaining -= length;
        offset = (int)ByteUtils.fromLittleEndian(this.supplier, 2);
        try {
          startBackReference(offset, length);
        } catch (IllegalArgumentException ex) {
          throw new IOException("Illegal block with bad offset found", ex);
        } 
        this.state = State.IN_BACK_REFERENCE;
        break;
      case 3:
        length = (b >> 2) + 1;
        if (length < 0)
          throw new IOException("Illegal block with a negative match length found"); 
        this.uncompressedBytesRemaining -= length;
        offset = (int)ByteUtils.fromLittleEndian(this.supplier, 4) & 0x7FFFFFFF;
        try {
          startBackReference(offset, length);
        } catch (IllegalArgumentException ex) {
          throw new IOException("Illegal block with bad offset found", ex);
        } 
        this.state = State.IN_BACK_REFERENCE;
        break;
    } 
  }
  
  public int getSize() { return this.size; }
  
  public int read(byte[] b, int off, int len) throws IOException {
    int backReferenceLen;
    int litLen;
    if (len == 0)
      return 0; 
    if (this.endReached)
      return -1; 
    switch (null.$SwitchMap$org$apache$commons$compress$compressors$snappy$SnappyCompressorInputStream$State[this.state.ordinal()]) {
      case 1:
        fill();
        return read(b, off, len);
      case 2:
        litLen = readLiteral(b, off, len);
        if (!hasMoreDataInBlock())
          this.state = State.NO_BLOCK; 
        return (litLen > 0) ? litLen : read(b, off, len);
      case 3:
        backReferenceLen = readBackReference(b, off, len);
        if (!hasMoreDataInBlock())
          this.state = State.NO_BLOCK; 
        return (backReferenceLen > 0) ? backReferenceLen : read(b, off, len);
    } 
    throw new IOException("Unknown stream state " + this.state);
  }
  
  private int readLiteralLength(int b) throws IOException {
    int length, length, length, length;
    switch (b >> 2) {
      case 60:
        length = readOneByte();
        if (length == -1)
          throw new IOException("Premature end of stream reading literal length"); 
        return length + 1;
      case 61:
        length = (int)ByteUtils.fromLittleEndian(this.supplier, 2);
        return length + 1;
      case 62:
        length = (int)ByteUtils.fromLittleEndian(this.supplier, 3);
        return length + 1;
      case 63:
        length = (int)ByteUtils.fromLittleEndian(this.supplier, 4);
        return length + 1;
    } 
    int length = b >> 2;
    return length + 1;
  }
  
  private long readSize() throws IOException {
    int index = 0;
    long sz = 0L;
    int b = 0;
    do {
      b = readOneByte();
      if (b == -1)
        throw new IOException("Premature end of stream reading size"); 
      sz |= ((b & 0x7F) << index++ * 7);
    } while (0 != (b & 0x80));
    return sz;
  }
}
