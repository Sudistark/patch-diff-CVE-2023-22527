package org.apache.commons.compress.compressors.bzip2;

import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteOrder;
import java.util.Arrays;
import org.apache.commons.compress.compressors.CompressorInputStream;
import org.apache.commons.compress.utils.BitInputStream;
import org.apache.commons.compress.utils.CloseShieldFilterInputStream;
import org.apache.commons.compress.utils.InputStreamStatistics;

public class BZip2CompressorInputStream extends CompressorInputStream implements BZip2Constants, InputStreamStatistics {
  private static final int EOF = 0;
  
  private static final int START_BLOCK_STATE = 1;
  
  private static final int RAND_PART_A_STATE = 2;
  
  private static final int RAND_PART_B_STATE = 3;
  
  private static final int RAND_PART_C_STATE = 4;
  
  private static final int NO_RAND_PART_A_STATE = 5;
  
  private static final int NO_RAND_PART_B_STATE = 6;
  
  private static final int NO_RAND_PART_C_STATE = 7;
  
  private int last;
  
  private int origPtr;
  
  private int blockSize100k;
  
  private boolean blockRandomised;
  
  private final CRC crc;
  
  private int nInUse;
  
  private BitInputStream bin;
  
  private final boolean decompressConcatenated;
  
  private int currentState;
  
  private int storedBlockCRC;
  
  private int storedCombinedCRC;
  
  private int computedBlockCRC;
  
  private int computedCombinedCRC;
  
  private int su_count;
  
  private int su_ch2;
  
  private int su_chPrev;
  
  private int su_i2;
  
  private int su_j2;
  
  private int su_rNToGo;
  
  private int su_rTPos;
  
  private int su_tPos;
  
  private char su_z;
  
  private Data data;
  
  private static boolean bsGetBit(BitInputStream bin) throws IOException { return (bsR(bin, 1) != 0); }
  
  private static int bsGetInt(BitInputStream bin) throws IOException { return bsR(bin, 32); }
  
  private static char bsGetUByte(BitInputStream bin) throws IOException { return (char)bsR(bin, 8); }
  
  private static int bsR(BitInputStream bin, int n) throws IOException {
    long thech = bin.readBits(n);
    if (thech < 0L)
      throw new IOException("Unexpected end of stream"); 
    return (int)thech;
  }
  
  private static void checkBounds(int checkVal, int limitExclusive, String name) throws IOException {
    if (checkVal < 0)
      throw new IOException("Corrupted input, " + name + " value negative"); 
    if (checkVal >= limitExclusive)
      throw new IOException("Corrupted input, " + name + " value too big"); 
  }
  
  private static void hbCreateDecodeTables(int[] limit, int[] base, int[] perm, char[] length, int minLen, int maxLen, int alphaSize) throws IOException {
    for (int i = minLen, pp = 0; i <= maxLen; i++) {
      for (int j = 0; j < alphaSize; j++) {
        if (length[j] == i)
          perm[pp++] = j; 
      } 
    } 
    for (int i = 23; --i > 0; ) {
      base[i] = 0;
      limit[i] = 0;
    } 
    for (int i = 0; i < alphaSize; i++) {
      int l = length[i];
      checkBounds(l, 258, "length");
      base[l + 1] = base[l + 1] + 1;
    } 
    for (int i = 1, b = base[0]; i < 23; i++) {
      b += base[i];
      base[i] = b;
    } 
    for (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) {
      int nb = base[i + 1];
      vec += nb - b;
      b = nb;
      limit[i] = vec - 1;
      vec <<= 1;
    } 
    for (int i = minLen + 1; i <= maxLen; i++)
      base[i] = (limit[i - 1] + 1 << 1) - base[i]; 
  }
  
  public static boolean matches(byte[] signature, int length) { return (length >= 3 && signature[0] == 66 && signature[1] == 90 && signature[2] == 104); }
  
  public BZip2CompressorInputStream(InputStream in) throws IOException { this(in, false); }
  
  public BZip2CompressorInputStream(InputStream in, boolean decompressConcatenated) throws IOException {
    this.crc = new CRC();
    this.currentState = 1;
    this.bin = new BitInputStream((in == System.in) ? new CloseShieldFilterInputStream(in) : in, ByteOrder.BIG_ENDIAN);
    this.decompressConcatenated = decompressConcatenated;
    init(true);
    initBlock();
  }
  
  public void close() throws IOException {
    BitInputStream inShadow = this.bin;
    if (inShadow != null)
      try {
        inShadow.close();
      } finally {
        this.data = null;
        this.bin = null;
      }  
  }
  
  private boolean complete() throws IOException {
    this.storedCombinedCRC = bsGetInt(this.bin);
    this.currentState = 0;
    this.data = null;
    if (this.storedCombinedCRC != this.computedCombinedCRC)
      throw new IOException("BZip2 CRC error"); 
    return (!this.decompressConcatenated || !init(false));
  }
  
  private void createHuffmanDecodingTables(int alphaSize, int nGroups) throws IOException {
    Data dataShadow = this.data;
    char[][] len = dataShadow.temp_charArray2d;
    int[] minLens = dataShadow.minLens;
    int[][] limit = dataShadow.limit;
    int[][] base = dataShadow.base;
    int[][] perm = dataShadow.perm;
    for (int t = 0; t < nGroups; t++) {
      char c1 = ' ';
      char c2 = Character.MIN_VALUE;
      char[] len_t = len[t];
      for (int i = alphaSize; --i >= 0; ) {
        char lent = len_t[i];
        if (lent > c2)
          c2 = lent; 
        if (lent < c1)
          c1 = lent; 
      } 
      hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], c1, c2, alphaSize);
      minLens[t] = c1;
    } 
  }
  
  private void endBlock() throws IOException {
    this.computedBlockCRC = this.crc.getFinalCRC();
    if (this.storedBlockCRC != this.computedBlockCRC) {
      this.computedCombinedCRC = this.storedCombinedCRC << 1 | this.storedCombinedCRC >>> 31;
      this.computedCombinedCRC ^= this.storedBlockCRC;
      throw new IOException("BZip2 CRC error");
    } 
    this.computedCombinedCRC = this.computedCombinedCRC << 1 | this.computedCombinedCRC >>> 31;
    this.computedCombinedCRC ^= this.computedBlockCRC;
  }
  
  private void getAndMoveToFrontDecode() throws IOException {
    BitInputStream bin = this.bin;
    this.origPtr = bsR(bin, 24);
    recvDecodingTables();
    Data dataShadow = this.data;
    byte[] ll8 = dataShadow.ll8;
    int[] unzftab = dataShadow.unzftab;
    byte[] selector = dataShadow.selector;
    byte[] seqToUnseq = dataShadow.seqToUnseq;
    char[] yy = dataShadow.getAndMoveToFrontDecode_yy;
    int[] minLens = dataShadow.minLens;
    int[][] limit = dataShadow.limit;
    int[][] base = dataShadow.base;
    int[][] perm = dataShadow.perm;
    int limitLast = this.blockSize100k * 100000;
    for (int i = 256; --i >= 0; ) {
      yy[i] = (char)i;
      unzftab[i] = 0;
    } 
    int groupNo = 0;
    int groupPos = 49;
    int eob = this.nInUse + 1;
    int nextSym = getAndMoveToFrontDecode0();
    int lastShadow = -1;
    int zt = selector[groupNo] & 0xFF;
    checkBounds(zt, 6, "zt");
    int[] base_zt = base[zt];
    int[] limit_zt = limit[zt];
    int[] perm_zt = perm[zt];
    int minLens_zt = minLens[zt];
    while (nextSym != eob) {
      if (nextSym == 0 || nextSym == 1) {
        int s = -1;
        int n;
        for (n = 1;; n <<= 1) {
          if (nextSym == 0) {
            s += n;
          } else if (nextSym == 1) {
            s += (n << 1);
          } else {
            break;
          } 
          if (groupPos == 0) {
            groupPos = 49;
            checkBounds(++groupNo, 18002, "groupNo");
            zt = selector[groupNo] & 0xFF;
            checkBounds(zt, 6, "zt");
            base_zt = base[zt];
            limit_zt = limit[zt];
            perm_zt = perm[zt];
            minLens_zt = minLens[zt];
          } else {
            groupPos--;
          } 
          int zn = minLens_zt;
          checkBounds(zn, 258, "zn");
          int zvec = bsR(bin, zn);
          while (zvec > limit_zt[zn]) {
            checkBounds(++zn, 258, "zn");
            zvec = zvec << 1 | bsR(bin, 1);
          } 
          int tmp = zvec - base_zt[zn];
          checkBounds(tmp, 258, "zvec");
          nextSym = perm_zt[tmp];
        } 
        checkBounds(s, this.data.ll8.length, "s");
        int yy0 = yy[0];
        checkBounds(yy0, 256, "yy");
        byte ch = seqToUnseq[yy0];
        unzftab[ch & 0xFF] = unzftab[ch & 0xFF] + s + 1;
        int from = ++lastShadow;
        lastShadow += s;
        checkBounds(lastShadow, this.data.ll8.length, "lastShadow");
        Arrays.fill(ll8, from, lastShadow + 1, ch);
        if (lastShadow >= limitLast)
          throw new IOException("Block overrun while expanding RLE in MTF, " + lastShadow + " exceeds " + limitLast); 
        continue;
      } 
      if (++lastShadow >= limitLast)
        throw new IOException("Block overrun in MTF, " + lastShadow + " exceeds " + limitLast); 
      checkBounds(nextSym, 257, "nextSym");
      char tmp = yy[nextSym - 1];
      checkBounds(tmp, 256, "yy");
      unzftab[seqToUnseq[tmp] & 0xFF] = unzftab[seqToUnseq[tmp] & 0xFF] + 1;
      ll8[lastShadow] = seqToUnseq[tmp];
      if (nextSym <= 16) {
        for (int j = nextSym - 1; j > 0;)
          yy[j] = yy[--j]; 
      } else {
        System.arraycopy(yy, 0, yy, 1, nextSym - 1);
      } 
      yy[0] = tmp;
      if (groupPos == 0) {
        groupPos = 49;
        checkBounds(++groupNo, 18002, "groupNo");
        zt = selector[groupNo] & 0xFF;
        checkBounds(zt, 6, "zt");
        base_zt = base[zt];
        limit_zt = limit[zt];
        perm_zt = perm[zt];
        minLens_zt = minLens[zt];
      } else {
        groupPos--;
      } 
      int zn = minLens_zt;
      checkBounds(zn, 258, "zn");
      int zvec = bsR(bin, zn);
      while (zvec > limit_zt[zn]) {
        checkBounds(++zn, 258, "zn");
        zvec = zvec << 1 | bsR(bin, 1);
      } 
      int idx = zvec - base_zt[zn];
      checkBounds(idx, 258, "zvec");
      nextSym = perm_zt[idx];
    } 
    this.last = lastShadow;
  }
  
  private int getAndMoveToFrontDecode0() throws IOException {
    Data dataShadow = this.data;
    int zt = dataShadow.selector[0] & 0xFF;
    checkBounds(zt, 6, "zt");
    int[] limit_zt = dataShadow.limit[zt];
    int zn = dataShadow.minLens[zt];
    checkBounds(zn, 258, "zn");
    int zvec = bsR(this.bin, zn);
    while (zvec > limit_zt[zn]) {
      checkBounds(++zn, 258, "zn");
      zvec = zvec << 1 | bsR(this.bin, 1);
    } 
    int tmp = zvec - dataShadow.base[zt][zn];
    checkBounds(tmp, 258, "zvec");
    return dataShadow.perm[zt][tmp];
  }
  
  public long getCompressedCount() { return this.bin.getBytesRead(); }
  
  private boolean init(boolean isFirstStream) throws IOException {
    if (null == this.bin)
      throw new IOException("No InputStream"); 
    if (!isFirstStream)
      this.bin.clearBitCache(); 
    int magic0 = readNextByte(this.bin);
    if (magic0 == -1 && !isFirstStream)
      return false; 
    int magic1 = readNextByte(this.bin);
    int magic2 = readNextByte(this.bin);
    if (magic0 != 66 || magic1 != 90 || magic2 != 104)
      throw new IOException(isFirstStream ? 
          "Stream is not in the BZip2 format" : 
          "Garbage after a valid BZip2 stream"); 
    int blockSize = readNextByte(this.bin);
    if (blockSize < 49 || blockSize > 57)
      throw new IOException("BZip2 block size is invalid"); 
    this.blockSize100k = blockSize - 48;
    this.computedCombinedCRC = 0;
    return true;
  }
  
  private void initBlock() throws IOException {
    char magic5, magic4, magic3, magic2, magic1, magic0;
    BitInputStream bin = this.bin;
    while (true) {
      magic0 = bsGetUByte(bin);
      magic1 = bsGetUByte(bin);
      magic2 = bsGetUByte(bin);
      magic3 = bsGetUByte(bin);
      magic4 = bsGetUByte(bin);
      magic5 = bsGetUByte(bin);
      if (magic0 != '\027' || magic1 != 'r' || magic2 != 'E' || magic3 != '8' || magic4 != 'P' || magic5 != '¬ê')
        break; 
      if (complete())
        return; 
    } 
    if (magic0 != '1' || magic1 != 'A' || magic2 != 'Y' || magic3 != '&' || magic4 != 'S' || magic5 != 'Y') {
      this.currentState = 0;
      throw new IOException("Bad block header");
    } 
    this.storedBlockCRC = bsGetInt(bin);
    this.blockRandomised = (bsR(bin, 1) == 1);
    if (this.data == null)
      this.data = new Data(this.blockSize100k); 
    getAndMoveToFrontDecode();
    this.crc.initializeCRC();
    this.currentState = 1;
  }
  
  private void makeMaps() throws IOException {
    boolean[] inUse = this.data.inUse;
    byte[] seqToUnseq = this.data.seqToUnseq;
    int nInUseShadow = 0;
    for (int i = 0; i < 256; i++) {
      if (inUse[i])
        seqToUnseq[nInUseShadow++] = (byte)i; 
    } 
    this.nInUse = nInUseShadow;
  }
  
  public int read() throws IOException {
    if (this.bin != null) {
      int r = read0();
      count((r < 0) ? -1 : 1);
      return r;
    } 
    throw new IOException("Stream closed");
  }
  
  public int read(byte[] dest, int offs, int len) throws IOException {
    if (offs < 0)
      throw new IndexOutOfBoundsException("offs(" + offs + ") < 0."); 
    if (len < 0)
      throw new IndexOutOfBoundsException("len(" + len + ") < 0."); 
    if (offs + len > dest.length)
      throw new IndexOutOfBoundsException("offs(" + offs + ") + len(" + len + ") > dest.length(" + dest.length + ")."); 
    if (this.bin == null)
      throw new IOException("Stream closed"); 
    if (len == 0)
      return 0; 
    int hi = offs + len;
    int destOffs = offs;
    int b;
    while (destOffs < hi && (b = read0()) >= 0) {
      dest[destOffs++] = (byte)b;
      count(1);
    } 
    return (destOffs == offs) ? -1 : (destOffs - offs);
  }
  
  private int read0() throws IOException {
    switch (this.currentState) {
      case 0:
        return -1;
      case 1:
        return setupBlock();
      case 2:
        throw new IllegalStateException();
      case 3:
        return setupRandPartB();
      case 4:
        return setupRandPartC();
      case 5:
        throw new IllegalStateException();
      case 6:
        return setupNoRandPartB();
      case 7:
        return setupNoRandPartC();
    } 
    throw new IllegalStateException();
  }
  
  private int readNextByte(BitInputStream in) throws IOException {
    long b = in.readBits(8);
    return (int)b;
  }
  
  private void recvDecodingTables() throws IOException {
    BitInputStream bin = this.bin;
    Data dataShadow = this.data;
    boolean[] inUse = dataShadow.inUse;
    byte[] pos = dataShadow.recvDecodingTables_pos;
    byte[] selector = dataShadow.selector;
    byte[] selectorMtf = dataShadow.selectorMtf;
    int inUse16 = 0;
    for (int i = 0; i < 16; i++) {
      if (bsGetBit(bin))
        inUse16 |= 1 << i; 
    } 
    Arrays.fill(inUse, false);
    for (int i = 0; i < 16; i++) {
      if ((inUse16 & 1 << i) != 0) {
        int i16 = i << 4;
        for (int j = 0; j < 16; j++) {
          if (bsGetBit(bin))
            inUse[i16 + j] = true; 
        } 
      } 
    } 
    makeMaps();
    int alphaSize = this.nInUse + 2;
    int nGroups = bsR(bin, 3);
    int selectors = bsR(bin, 15);
    if (selectors < 0)
      throw new IOException("Corrupted input, nSelectors value negative"); 
    checkBounds(alphaSize, 259, "alphaSize");
    checkBounds(nGroups, 7, "nGroups");
    for (int i = 0; i < selectors; i++) {
      int j = 0;
      while (bsGetBit(bin))
        j++; 
      if (i < 18002)
        selectorMtf[i] = (byte)j; 
    } 
    int nSelectors = Math.min(selectors, 18002);
    for (int v = nGroups; --v >= 0;)
      pos[v] = (byte)v; 
    for (int i = 0; i < nSelectors; i++) {
      int v = selectorMtf[i] & 0xFF;
      checkBounds(v, 6, "selectorMtf");
      byte tmp = pos[v];
      while (v > 0) {
        pos[v] = pos[v - 1];
        v--;
      } 
      pos[0] = tmp;
      selector[i] = tmp;
    } 
    char[][] len = dataShadow.temp_charArray2d;
    for (int t = 0; t < nGroups; t++) {
      int curr = bsR(bin, 5);
      char[] len_t = len[t];
      for (int i = 0; i < alphaSize; i++) {
        while (bsGetBit(bin))
          curr += (bsGetBit(bin) ? -1 : 1); 
        len_t[i] = (char)curr;
      } 
    } 
    createHuffmanDecodingTables(alphaSize, nGroups);
  }
  
  private int setupBlock() throws IOException {
    if (this.currentState == 0 || this.data == null)
      return -1; 
    int[] cftab = this.data.cftab;
    int ttLen = this.last + 1;
    int[] tt = this.data.initTT(ttLen);
    byte[] ll8 = this.data.ll8;
    cftab[0] = 0;
    System.arraycopy(this.data.unzftab, 0, cftab, 1, 256);
    for (int i = 1, c = cftab[0]; i <= 256; i++) {
      c += cftab[i];
      cftab[i] = c;
    } 
    for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) {
      cftab[ll8[i] & 0xFF] = cftab[ll8[i] & 0xFF] + 1;
      int tmp = cftab[ll8[i] & 0xFF];
      checkBounds(tmp, ttLen, "tt index");
      tt[tmp] = i;
    } 
    if (this.origPtr < 0 || this.origPtr >= tt.length)
      throw new IOException("Stream corrupted"); 
    this.su_tPos = tt[this.origPtr];
    this.su_count = 0;
    this.su_i2 = 0;
    this.su_ch2 = 256;
    if (this.blockRandomised) {
      this.su_rNToGo = 0;
      this.su_rTPos = 0;
      return setupRandPartA();
    } 
    return setupNoRandPartA();
  }
  
  private int setupNoRandPartA() throws IOException {
    if (this.su_i2 <= this.last) {
      this.su_chPrev = this.su_ch2;
      int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xFF;
      this.su_ch2 = su_ch2Shadow;
      checkBounds(this.su_tPos, this.data.tt.length, "su_tPos");
      this.su_tPos = this.data.tt[this.su_tPos];
      this.su_i2++;
      this.currentState = 6;
      this.crc.updateCRC(su_ch2Shadow);
      return su_ch2Shadow;
    } 
    this.currentState = 5;
    endBlock();
    initBlock();
    return setupBlock();
  }
  
  private int setupNoRandPartB() throws IOException {
    if (this.su_ch2 != this.su_chPrev) {
      this.su_count = 1;
      return setupNoRandPartA();
    } 
    if (++this.su_count >= 4) {
      checkBounds(this.su_tPos, this.data.ll8.length, "su_tPos");
      this.su_z = (char)(this.data.ll8[this.su_tPos] & 0xFF);
      this.su_tPos = this.data.tt[this.su_tPos];
      this.su_j2 = 0;
      return setupNoRandPartC();
    } 
    return setupNoRandPartA();
  }
  
  private int setupNoRandPartC() throws IOException {
    if (this.su_j2 < this.su_z) {
      int su_ch2Shadow = this.su_ch2;
      this.crc.updateCRC(su_ch2Shadow);
      this.su_j2++;
      this.currentState = 7;
      return su_ch2Shadow;
    } 
    this.su_i2++;
    this.su_count = 0;
    return setupNoRandPartA();
  }
  
  private int setupRandPartA() throws IOException {
    if (this.su_i2 <= this.last) {
      this.su_chPrev = this.su_ch2;
      int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xFF;
      checkBounds(this.su_tPos, this.data.tt.length, "su_tPos");
      this.su_tPos = this.data.tt[this.su_tPos];
      if (this.su_rNToGo == 0) {
        this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1;
        if (++this.su_rTPos == 512)
          this.su_rTPos = 0; 
      } else {
        this.su_rNToGo--;
      } 
      this.su_ch2 = su_ch2Shadow ^= ((this.su_rNToGo == 1) ? 1 : 0);
      this.su_i2++;
      this.currentState = 3;
      this.crc.updateCRC(su_ch2Shadow);
      return su_ch2Shadow;
    } 
    endBlock();
    initBlock();
    return setupBlock();
  }
  
  private int setupRandPartB() throws IOException {
    if (this.su_ch2 != this.su_chPrev) {
      this.currentState = 2;
      this.su_count = 1;
      return setupRandPartA();
    } 
    if (++this.su_count < 4) {
      this.currentState = 2;
      return setupRandPartA();
    } 
    this.su_z = (char)(this.data.ll8[this.su_tPos] & 0xFF);
    checkBounds(this.su_tPos, this.data.tt.length, "su_tPos");
    this.su_tPos = this.data.tt[this.su_tPos];
    if (this.su_rNToGo == 0) {
      this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1;
      if (++this.su_rTPos == 512)
        this.su_rTPos = 0; 
    } else {
      this.su_rNToGo--;
    } 
    this.su_j2 = 0;
    this.currentState = 4;
    if (this.su_rNToGo == 1)
      this.su_z = (char)(this.su_z ^ true); 
    return setupRandPartC();
  }
  
  private int setupRandPartC() throws IOException {
    if (this.su_j2 < this.su_z) {
      this.crc.updateCRC(this.su_ch2);
      this.su_j2++;
      return this.su_ch2;
    } 
    this.currentState = 2;
    this.su_i2++;
    this.su_count = 0;
    return setupRandPartA();
  }
}
