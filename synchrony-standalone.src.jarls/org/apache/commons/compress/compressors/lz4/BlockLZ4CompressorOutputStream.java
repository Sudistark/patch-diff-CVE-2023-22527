package org.apache.commons.compress.compressors.lz4;

import java.io.IOException;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.Deque;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Objects;
import org.apache.commons.compress.compressors.CompressorOutputStream;
import org.apache.commons.compress.compressors.lz77support.LZ77Compressor;
import org.apache.commons.compress.compressors.lz77support.Parameters;

public class BlockLZ4CompressorOutputStream extends CompressorOutputStream {
  private static final int MIN_BACK_REFERENCE_LENGTH = 4;
  
  private static final int MIN_OFFSET_OF_LAST_BACK_REFERENCE = 12;
  
  private final LZ77Compressor compressor;
  
  private final OutputStream os;
  
  private final byte[] oneByte;
  
  private boolean finished;
  
  private final Deque<Pair> pairs;
  
  private final Deque<byte[]> expandedBlocks;
  
  public static Parameters.Builder createParameterBuilder() {
    maxLen = 65535;
    return Parameters.builder(65536)
      .withMinBackReferenceLength(4)
      .withMaxBackReferenceLength(65535)
      .withMaxOffset(65535)
      .withMaxLiteralLength(65535);
  }
  
  public BlockLZ4CompressorOutputStream(OutputStream os) { this(os, createParameterBuilder().build()); }
  
  public BlockLZ4CompressorOutputStream(OutputStream os, Parameters params) {
    this.oneByte = new byte[1];
    this.pairs = new LinkedList();
    this.expandedBlocks = new LinkedList();
    this.os = os;
    this.compressor = new LZ77Compressor(params, block -> {
          switch (null.$SwitchMap$org$apache$commons$compress$compressors$lz77support$LZ77Compressor$Block$BlockType[block.getType().ordinal()]) {
            case 1:
              addLiteralBlock((LZ77Compressor.LiteralBlock)block);
              break;
            case 2:
              addBackReference((LZ77Compressor.BackReference)block);
              break;
            case 3:
              writeFinalLiteralBlock();
              break;
          } 
        });
  }
  
  private void addBackReference(LZ77Compressor.BackReference block) throws IOException {
    Pair last = writeBlocksAndReturnUnfinishedPair(block.getLength());
    last.setBackReference(block);
    recordBackReference(block);
    clearUnusedBlocksAndPairs();
  }
  
  private void addLiteralBlock(LZ77Compressor.LiteralBlock block) throws IOException {
    Pair last = writeBlocksAndReturnUnfinishedPair(block.getLength());
    recordLiteral(last.addLiteral(block));
    clearUnusedBlocksAndPairs();
  }
  
  private void clearUnusedBlocks() {
    int blockLengths = 0;
    int blocksToKeep = 0;
    for (byte[] b : this.expandedBlocks) {
      blocksToKeep++;
      blockLengths += b.length;
      if (blockLengths >= 65536)
        break; 
    } 
    int size = this.expandedBlocks.size();
    for (int i = blocksToKeep; i < size; i++)
      this.expandedBlocks.removeLast(); 
  }
  
  private void clearUnusedBlocksAndPairs() {
    clearUnusedBlocks();
    clearUnusedPairs();
  }
  
  private void clearUnusedPairs() {
    int pairLengths = 0;
    int pairsToKeep = 0;
    for (Iterator<Pair> it = this.pairs.descendingIterator(); it.hasNext(); ) {
      Pair p = (Pair)it.next();
      pairsToKeep++;
      pairLengths += p.length();
      if (pairLengths >= 65536)
        break; 
    } 
    int size = this.pairs.size();
    for (int i = pairsToKeep; i < size; i++) {
      Pair p = (Pair)this.pairs.peekFirst();
      if (!Pair.access$000(p))
        break; 
      this.pairs.removeFirst();
    } 
  }
  
  public void close() {
    try {
      finish();
    } finally {
      this.os.close();
    } 
  }
  
  private byte[] expand(int offset, int length) {
    byte[] expanded = new byte[length];
    if (offset == 1) {
      byte[] block = (byte[])this.expandedBlocks.peekFirst();
      byte b = block[block.length - 1];
      if (b != 0)
        Arrays.fill(expanded, b); 
    } else {
      expandFromList(expanded, offset, length);
    } 
    return expanded;
  }
  
  private void expandFromList(byte[] expanded, int offset, int length) {
    int offsetRemaining = offset;
    int lengthRemaining = length;
    int writeOffset = 0;
    while (lengthRemaining > 0) {
      int copyOffset, copyLen;
      byte[] block = null;
      if (offsetRemaining > 0) {
        int blockOffset = 0;
        for (byte[] b : this.expandedBlocks) {
          if (b.length + blockOffset >= offsetRemaining) {
            block = b;
            break;
          } 
          blockOffset += b.length;
        } 
        if (block == null)
          throw new IllegalStateException("Failed to find a block containing offset " + offset); 
        copyOffset = blockOffset + block.length - offsetRemaining;
        copyLen = Math.min(lengthRemaining, block.length - copyOffset);
      } else {
        block = expanded;
        copyOffset = -offsetRemaining;
        copyLen = Math.min(lengthRemaining, writeOffset + offsetRemaining);
      } 
      System.arraycopy(block, copyOffset, expanded, writeOffset, copyLen);
      offsetRemaining -= copyLen;
      lengthRemaining -= copyLen;
      writeOffset += copyLen;
    } 
  }
  
  public void finish() {
    if (!this.finished) {
      this.compressor.finish();
      this.finished = true;
    } 
  }
  
  public void prefill(byte[] data, int off, int len) {
    if (len > 0) {
      byte[] b = Arrays.copyOfRange(data, off, off + len);
      this.compressor.prefill(b);
      recordLiteral(b);
    } 
  }
  
  private void recordBackReference(LZ77Compressor.BackReference block) throws IOException { this.expandedBlocks.addFirst(expand(block.getOffset(), block.getLength())); }
  
  private void recordLiteral(byte[] b) { this.expandedBlocks.addFirst(b); }
  
  private void rewriteLastPairs() {
    LinkedList<Pair> lastPairs = new LinkedList<Pair>();
    LinkedList<Integer> pairLength = new LinkedList<Integer>();
    int offset = 0;
    for (Iterator<Pair> it = this.pairs.descendingIterator(); it.hasNext(); ) {
      Pair p = (Pair)it.next();
      if (Pair.access$000(p))
        break; 
      int len = p.length();
      pairLength.addFirst(Integer.valueOf(len));
      lastPairs.addFirst(p);
      offset += len;
      if (offset >= 12)
        break; 
    } 
    Objects.requireNonNull(this.pairs);
    lastPairs.forEach(this.pairs::remove);
    int lastPairsSize = lastPairs.size();
    int toExpand = 0;
    for (int i = 1; i < lastPairsSize; i++)
      toExpand += ((Integer)pairLength.get(i)).intValue(); 
    Pair replacement = new Pair();
    if (toExpand > 0)
      Pair.access$100(replacement, expand(toExpand, toExpand)); 
    Pair splitCandidate = (Pair)lastPairs.get(0);
    int stillNeeded = 12 - toExpand;
    int brLen = splitCandidate.hasBackReference() ? Pair.access$200(splitCandidate) : 0;
    if (splitCandidate.hasBackReference() && brLen >= 4 + stillNeeded) {
      Pair.access$100(replacement, expand(toExpand + stillNeeded, stillNeeded));
      this.pairs.add(Pair.access$300(splitCandidate, brLen - stillNeeded));
    } else {
      if (splitCandidate.hasBackReference())
        Pair.access$100(replacement, expand(toExpand + brLen, brLen)); 
      Pair.access$400(splitCandidate, replacement);
    } 
    this.pairs.add(replacement);
  }
  
  public void write(byte[] data, int off, int len) { this.compressor.compress(data, off, len); }
  
  public void write(int b) throws IOException {
    this.oneByte[0] = (byte)(b & 0xFF);
    write(this.oneByte);
  }
  
  private Pair writeBlocksAndReturnUnfinishedPair(int length) throws IOException {
    writeWritablePairs(length);
    Pair last = (Pair)this.pairs.peekLast();
    if (last == null || last.hasBackReference()) {
      last = new Pair();
      this.pairs.addLast(last);
    } 
    return last;
  }
  
  private void writeFinalLiteralBlock() {
    rewriteLastPairs();
    for (Pair p : this.pairs) {
      if (!Pair.access$000(p))
        p.writeTo(this.os); 
    } 
    this.pairs.clear();
  }
  
  private void writeWritablePairs(int lengthOfBlocksAfterLastPair) throws IOException {
    int unwrittenLength = lengthOfBlocksAfterLastPair;
    Iterator<Pair> it;
    for (it = this.pairs.descendingIterator(); it.hasNext(); ) {
      Pair p = (Pair)it.next();
      if (Pair.access$000(p))
        break; 
      unwrittenLength += p.length();
    } 
    for (it = this.pairs.iterator(); it.hasNext(); ) {
      Pair p = (Pair)it.next();
      if (Pair.access$000(p))
        continue; 
      unwrittenLength -= p.length();
      if (!p.canBeWritten(unwrittenLength))
        break; 
      p.writeTo(this.os);
    } 
  }
}
