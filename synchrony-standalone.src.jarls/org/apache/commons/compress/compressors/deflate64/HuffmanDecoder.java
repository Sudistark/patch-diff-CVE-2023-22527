package org.apache.commons.compress.compressors.deflate64;

import java.io.Closeable;
import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteOrder;
import java.util.Arrays;
import org.apache.commons.compress.utils.BitInputStream;

class HuffmanDecoder implements Closeable {
  private static final short[] RUN_LENGTH_TABLE = { 
      96, 128, 160, 192, 224, 256, 288, 320, 353, 417, 
      481, 545, 610, 738, 866, 994, 1123, 1379, 1635, 1891, 
      2148, 2660, 3172, 3684, 4197, 5221, 6245, 7269, 112 };
  
  private static final int[] DISTANCE_TABLE = { 
      16, 32, 48, 64, 81, 113, 146, 210, 275, 403, 
      532, 788, 1045, 1557, 2070, 3094, 4119, 6167, 8216, 12312, 
      16409, 24601, 32794, 49178, 65563, 98331, 131100, 196636, 262173, 393245, 
      524318, 786462 };
  
  private static final int[] CODE_LENGTHS_ORDER = { 
      16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 
      11, 4, 12, 3, 13, 2, 14, 1, 15 };
  
  private static final int[] FIXED_LITERALS = new int[288];
  
  private static final int[] FIXED_DISTANCE;
  
  private boolean finalBlock;
  
  private DecoderState state;
  
  private BitInputStream reader;
  
  private final InputStream in;
  
  private final DecodingMemory memory;
  
  static  {
    Arrays.fill(FIXED_LITERALS, 0, 144, 8);
    Arrays.fill(FIXED_LITERALS, 144, 256, 9);
    Arrays.fill(FIXED_LITERALS, 256, 280, 7);
    Arrays.fill(FIXED_LITERALS, 280, 288, 8);
    FIXED_DISTANCE = new int[32];
    Arrays.fill(FIXED_DISTANCE, 5);
  }
  
  private static BinaryTreeNode buildTree(int[] litTable) {
    int[] literalCodes = getCodes(litTable);
    BinaryTreeNode root = new BinaryTreeNode(0, null);
    for (int i = 0; i < litTable.length; i++) {
      int len = litTable[i];
      if (len != 0) {
        BinaryTreeNode node = root;
        int lit = literalCodes[len - 1];
        for (int p = len - 1; p >= 0; p--) {
          int bit = lit & 1 << p;
          node = (bit == 0) ? node.left() : node.right();
          if (node == null)
            throw new IllegalStateException("node doesn't exist in Huffman tree"); 
        } 
        node.leaf(i);
        literalCodes[len - 1] = literalCodes[len - 1] + 1;
      } 
    } 
    return root;
  }
  
  private static int[] getCodes(int[] litTable) {
    int max = 0;
    int[] blCount = new int[65];
    for (int aLitTable : litTable) {
      if (aLitTable < 0 || aLitTable > 64)
        throw new IllegalArgumentException("Invalid code " + aLitTable + " in literal table"); 
      max = Math.max(max, aLitTable);
      blCount[aLitTable] = blCount[aLitTable] + 1;
    } 
    blCount = Arrays.copyOf(blCount, max + 1);
    int code = 0;
    int[] nextCode = new int[max + 1];
    for (int i = 0; i <= max; i++) {
      code = code + blCount[i] << 1;
      nextCode[i] = code;
    } 
    return nextCode;
  }
  
  private static int nextSymbol(BitInputStream reader, BinaryTreeNode tree) throws IOException {
    BinaryTreeNode node = tree;
    while (node != null && node.literal == -1) {
      long bit = readBits(reader, 1);
      node = (bit == 0L) ? node.leftNode : node.rightNode;
    } 
    return (node != null) ? node.literal : -1;
  }
  
  private static void populateDynamicTables(BitInputStream reader, int[] literals, int[] distances) throws IOException {
    int codeLengths = (int)(readBits(reader, 4) + 4L);
    int[] codeLengthValues = new int[19];
    for (int cLen = 0; cLen < codeLengths; cLen++)
      codeLengthValues[CODE_LENGTHS_ORDER[cLen]] = (int)readBits(reader, 3); 
    BinaryTreeNode codeLengthTree = buildTree(codeLengthValues);
    int[] auxBuffer = new int[literals.length + distances.length];
    int value = -1;
    int length = 0;
    int off = 0;
    while (off < auxBuffer.length) {
      if (length > 0) {
        auxBuffer[off++] = value;
        length--;
        continue;
      } 
      int symbol = nextSymbol(reader, codeLengthTree);
      if (symbol < 16) {
        value = symbol;
        auxBuffer[off++] = value;
        continue;
      } 
      switch (symbol) {
        case 16:
          length = (int)(readBits(reader, 2) + 3L);
        case 17:
          value = 0;
          length = (int)(readBits(reader, 3) + 3L);
        case 18:
          value = 0;
          length = (int)(readBits(reader, 7) + 11L);
      } 
    } 
    System.arraycopy(auxBuffer, 0, literals, 0, literals.length);
    System.arraycopy(auxBuffer, literals.length, distances, 0, distances.length);
  }
  
  private static long readBits(BitInputStream reader, int numBits) throws IOException {
    long r = reader.readBits(numBits);
    if (r == -1L)
      throw new EOFException("Truncated Deflate64 Stream"); 
    return r;
  }
  
  HuffmanDecoder(InputStream in) {
    this.memory = new DecodingMemory(null);
    this.reader = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);
    this.in = in;
    this.state = new InitialState(null);
  }
  
  int available() throws IOException { return this.state.available(); }
  
  public void close() {
    this.state = new InitialState(null);
    this.reader = null;
  }
  
  public int decode(byte[] b) throws IOException { return decode(b, 0, b.length); }
  
  public int decode(byte[] b, int off, int len) throws IOException {
    while (!this.finalBlock || this.state.hasData()) {
      if (this.state.state() == HuffmanState.INITIAL) {
        int[][] tables;
        this.finalBlock = (readBits(1) == 1L);
        int mode = (int)readBits(2);
        switch (mode) {
          case 0:
            switchToUncompressedState();
            continue;
          case 1:
            this.state = new HuffmanCodes(this, HuffmanState.FIXED_CODES, FIXED_LITERALS, FIXED_DISTANCE);
            continue;
          case 2:
            tables = readDynamicTables();
            this.state = new HuffmanCodes(this, HuffmanState.DYNAMIC_CODES, tables[0], tables[1]);
            continue;
        } 
        throw new IllegalStateException("Unsupported compression: " + mode);
      } 
      int r = this.state.read(b, off, len);
      if (r != 0)
        return r; 
    } 
    return -1;
  }
  
  long getBytesRead() { return this.reader.getBytesRead(); }
  
  private long readBits(int numBits) throws IOException { return readBits(this.reader, numBits); }
  
  private int[][] readDynamicTables() throws IOException {
    int[][] result = new int[2][];
    int literals = (int)(readBits(5) + 257L);
    result[0] = new int[literals];
    int distances = (int)(readBits(5) + 1L);
    result[1] = new int[distances];
    populateDynamicTables(this.reader, result[0], result[1]);
    return result;
  }
  
  private void switchToUncompressedState() {
    this.reader.alignWithByteBoundary();
    long bLen = readBits(16);
    long bNLen = readBits(16);
    if (((bLen ^ 0xFFFFL) & 0xFFFFL) != bNLen)
      throw new IllegalStateException("Illegal LEN / NLEN values"); 
    this.state = new UncompressedState(this, bLen, null);
  }
}
