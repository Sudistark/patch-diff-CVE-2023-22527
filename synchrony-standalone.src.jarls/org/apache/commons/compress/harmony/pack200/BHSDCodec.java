package org.apache.commons.compress.harmony.pack200;

import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.apache.commons.compress.utils.ExactMath;

public final class BHSDCodec extends Codec {
  private final int b;
  
  private final int d;
  
  private final int h;
  
  private final int l;
  
  private final int s;
  
  private long cardinality;
  
  private final long smallest;
  
  private final long largest;
  
  private final long[] powers;
  
  public BHSDCodec(int b, int h) { this(b, h, 0, 0); }
  
  public BHSDCodec(int b, int h, int s) { this(b, h, s, 0); }
  
  public BHSDCodec(int b, int h, int s, int d) {
    if (b < 1 || b > 5)
      throw new IllegalArgumentException("1<=b<=5"); 
    if (h < 1 || h > 256)
      throw new IllegalArgumentException("1<=h<=256"); 
    if (s < 0 || s > 2)
      throw new IllegalArgumentException("0<=s<=2"); 
    if (d < 0 || d > 1)
      throw new IllegalArgumentException("0<=d<=1"); 
    if (b == 1 && h != 256)
      throw new IllegalArgumentException("b=1 -> h=256"); 
    if (h == 256 && b == 5)
      throw new IllegalArgumentException("h=256 -> b!=5"); 
    this.b = b;
    this.h = h;
    this.s = s;
    this.d = d;
    this.l = 256 - h;
    if (h == 1) {
      this.cardinality = (b * 255 + 1);
    } else {
      this.cardinality = (long)((long)(this.l * (1.0D - Math.pow(h, b)) / (1 - h)) + Math.pow(h, b));
    } 
    this.smallest = calculateSmallest();
    this.largest = calculateLargest();
    this.powers = new long[b];
    Arrays.setAll(this.powers, c -> (long)Math.pow(h, c));
  }
  
  private long calculateLargest() {
    long result;
    long result;
    long result;
    if (this.d == 1) {
      BHSDCodec bh0 = new BHSDCodec(this.b, this.h);
      return bh0.largest();
    } 
    switch (this.s) {
      case 0:
        result = cardinality() - 1L;
        break;
      case 1:
        result = cardinality() / 2L - 1L;
        break;
      case 2:
        result = 3L * cardinality() / 4L - 1L;
        break;
      default:
        throw new Error("Unknown s value");
    } 
    return Math.min(((this.s == 0) ? 4294967294L : 2147483647L) - 1L, result);
  }
  
  private long calculateSmallest() {
    long result;
    if (this.d == 1 || !isSigned()) {
      if (this.cardinality >= 4294967296L) {
        result = -2147483648L;
      } else {
        result = 0L;
      } 
    } else {
      result = Math.max(-2147483648L, -cardinality() / (1 << this.s));
    } 
    return result;
  }
  
  public long cardinality() { return this.cardinality; }
  
  public int decode(InputStream in) throws IOException, Pack200Exception {
    if (this.d != 0)
      throw new Pack200Exception("Delta encoding used without passing in last value; this is a coding error"); 
    return decode(in, 0L);
  }
  
  public int decode(InputStream in, long last) throws IOException, Pack200Exception {
    int n = 0;
    long z = 0L;
    long x = 0L;
    do {
      x = in.read();
      this.lastBandLength++;
      z += x * this.powers[n];
      n++;
    } while (x >= this.l && n < this.b);
    if (x == -1L)
      throw new EOFException("End of stream reached whilst decoding"); 
    if (isSigned()) {
      int u = (1 << this.s) - 1;
      if ((z & u) == u) {
        z = z >>> this.s ^ 0xFFFFFFFFFFFFFFFFL;
      } else {
        z -= (z >>> this.s);
      } 
    } 
    if (isDelta())
      z += last; 
    return (int)z;
  }
  
  public int[] decodeInts(int n, InputStream in) throws IOException, Pack200Exception {
    int[] band = super.decodeInts(n, in);
    if (isDelta())
      for (int i = 0; i < band.length; i++) {
        while (band[i] > this.largest)
          band[i] = (int)(band[i] - this.cardinality); 
        while (band[i] < this.smallest)
          band[i] = ExactMath.add(band[i], this.cardinality); 
      }  
    return band;
  }
  
  public int[] decodeInts(int n, InputStream in, int firstValue) throws IOException, Pack200Exception {
    int[] band = super.decodeInts(n, in, firstValue);
    if (isDelta())
      for (int i = 0; i < band.length; i++) {
        while (band[i] > this.largest)
          band[i] = (int)(band[i] - this.cardinality); 
        while (band[i] < this.smallest)
          band[i] = ExactMath.add(band[i], this.cardinality); 
      }  
    return band;
  }
  
  public byte[] encode(int value) throws Pack200Exception { return encode(value, 0); }
  
  public byte[] encode(int value, int last) throws Pack200Exception {
    if (!encodes(value))
      throw new Pack200Exception("The codec " + this + " does not encode the value " + value); 
    long z = value;
    if (isDelta())
      z -= last; 
    if (isSigned()) {
      if (z < -2147483648L) {
        z += 4294967296L;
      } else if (z > 2147483647L) {
        z -= 4294967296L;
      } 
      if (z < 0L) {
        z = (-z << this.s) - 1L;
      } else if (this.s == 1) {
        z <<= this.s;
      } else {
        z += (z - z % 3L) / 3L;
      } 
    } else if (z < 0L) {
      z += Math.min(this.cardinality, 4294967296L);
    } 
    if (z < 0L)
      throw new Pack200Exception("unable to encode"); 
    List<Byte> byteList = new ArrayList<Byte>();
    for (int n = 0; n < this.b; n++) {
      long byteN;
      if (z < this.l) {
        byteN = z;
      } else {
        byteN = z % this.h;
        while (byteN < this.l)
          byteN += this.h; 
      } 
      byteList.add(Byte.valueOf((byte)(int)byteN));
      if (byteN < this.l)
        break; 
      z -= byteN;
      z /= this.h;
    } 
    byte[] bytes = new byte[byteList.size()];
    for (int i = 0; i < bytes.length; i++)
      bytes[i] = ((Byte)byteList.get(i)).byteValue(); 
    return bytes;
  }
  
  public boolean encodes(long value) { return (value >= this.smallest && value <= this.largest); }
  
  public boolean equals(Object o) {
    if (o instanceof BHSDCodec) {
      BHSDCodec codec = (BHSDCodec)o;
      return (codec.b == this.b && codec.h == this.h && codec.s == this.s && codec.d == this.d);
    } 
    return false;
  }
  
  public int getB() { return this.b; }
  
  public int getH() { return this.h; }
  
  public int getL() { return this.l; }
  
  public int getS() { return this.s; }
  
  public int hashCode() { return ((this.b * 37 + this.h) * 37 + this.s) * 37 + this.d; }
  
  public boolean isDelta() { return (this.d != 0); }
  
  public boolean isSigned() { return (this.s != 0); }
  
  public long largest() { return this.largest; }
  
  public long smallest() { return this.smallest; }
  
  public String toString() {
    StringBuilder buffer = new StringBuilder(11);
    buffer.append('(');
    buffer.append(this.b);
    buffer.append(',');
    buffer.append(this.h);
    if (this.s != 0 || this.d != 0) {
      buffer.append(',');
      buffer.append(this.s);
    } 
    if (this.d != 0) {
      buffer.append(',');
      buffer.append(this.d);
    } 
    buffer.append(')');
    return buffer.toString();
  }
}
