package org.apache.commons.compress.harmony.pack200;

import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import org.objectweb.asm.Type;

public class CpBands extends BandSet {
  private final Set<String> defaultAttributeNames = new HashSet();
  
  private final Set<CPUTF8> cp_Utf8 = new TreeSet();
  
  private final Set<CPInt> cp_Int = new TreeSet();
  
  private final Set<CPFloat> cp_Float = new TreeSet();
  
  private final Set<CPLong> cp_Long = new TreeSet();
  
  private final Set<CPDouble> cp_Double = new TreeSet();
  
  private final Set<CPString> cp_String = new TreeSet();
  
  private final Set<CPClass> cp_Class = new TreeSet();
  
  private final Set<CPSignature> cp_Signature = new TreeSet();
  
  private final Set<CPNameAndType> cp_Descr = new TreeSet();
  
  private final Set<CPMethodOrField> cp_Field = new TreeSet();
  
  private final Set<CPMethodOrField> cp_Method = new TreeSet();
  
  private final Set<CPMethodOrField> cp_Imethod = new TreeSet();
  
  private final Map<String, CPUTF8> stringsToCpUtf8 = new HashMap();
  
  private final Map<String, CPNameAndType> stringsToCpNameAndType = new HashMap();
  
  private final Map<String, CPClass> stringsToCpClass = new HashMap();
  
  private final Map<String, CPSignature> stringsToCpSignature = new HashMap();
  
  private final Map<String, CPMethodOrField> stringsToCpMethod = new HashMap();
  
  private final Map<String, CPMethodOrField> stringsToCpField = new HashMap();
  
  private final Map<String, CPMethodOrField> stringsToCpIMethod = new HashMap();
  
  private final Map<Object, CPConstant<?>> objectsToCPConstant = new HashMap();
  
  private final Segment segment;
  
  public CpBands(Segment segment, int effort) {
    super(effort, segment.getSegmentHeader());
    this.segment = segment;
    this.defaultAttributeNames.add("AnnotationDefault");
    this.defaultAttributeNames.add("RuntimeVisibleAnnotations");
    this.defaultAttributeNames.add("RuntimeInvisibleAnnotations");
    this.defaultAttributeNames.add("RuntimeVisibleParameterAnnotations");
    this.defaultAttributeNames.add("RuntimeInvisibleParameterAnnotations");
    this.defaultAttributeNames.add("Code");
    this.defaultAttributeNames.add("LineNumberTable");
    this.defaultAttributeNames.add("LocalVariableTable");
    this.defaultAttributeNames.add("LocalVariableTypeTable");
    this.defaultAttributeNames.add("ConstantValue");
    this.defaultAttributeNames.add("Deprecated");
    this.defaultAttributeNames.add("EnclosingMethod");
    this.defaultAttributeNames.add("Exceptions");
    this.defaultAttributeNames.add("InnerClasses");
    this.defaultAttributeNames.add("Signature");
    this.defaultAttributeNames.add("SourceFile");
  }
  
  private void addCharacters(List<Character> chars, char[] charArray) {
    for (char element : charArray)
      chars.add(Character.valueOf(element)); 
  }
  
  public void addCPClass(String className) { getCPClass(className); }
  
  void addCPUtf8(String utf8) { getCPUtf8(utf8); }
  
  private void addIndices() {
    for (Set<? extends ConstantPoolEntry> set : Arrays.asList(new Set[] { 
          this.cp_Utf8, this.cp_Int, this.cp_Float, this.cp_Long, this.cp_Double, this.cp_String, this.cp_Class, this.cp_Signature, this.cp_Descr, this.cp_Field, 
          this.cp_Method, this.cp_Imethod })) {
      int j = 0;
      for (ConstantPoolEntry entry : set) {
        entry.setIndex(j);
        j++;
      } 
    } 
    Map<CPClass, Integer> classNameToIndex = new HashMap<CPClass, Integer>();
    this.cp_Field.forEach(mOrF -> {
          CPClass cpClassName = mOrF.getClassName();
          Integer index = (Integer)classNameToIndex.get(cpClassName);
          if (index == null) {
            classNameToIndex.put(cpClassName, Integer.valueOf(1));
            mOrF.setIndexInClass(0);
          } else {
            int theIndex = index.intValue();
            mOrF.setIndexInClass(theIndex);
            classNameToIndex.put(cpClassName, Integer.valueOf(theIndex + 1));
          } 
        });
    classNameToIndex.clear();
    Map<CPClass, Integer> classNameToConstructorIndex = new HashMap<CPClass, Integer>();
    this.cp_Method.forEach(mOrF -> {
          CPClass cpClassName = mOrF.getClassName();
          Integer index = (Integer)classNameToIndex.get(cpClassName);
          if (index == null) {
            classNameToIndex.put(cpClassName, Integer.valueOf(1));
            mOrF.setIndexInClass(0);
          } else {
            int theIndex = index.intValue();
            mOrF.setIndexInClass(theIndex);
            classNameToIndex.put(cpClassName, Integer.valueOf(theIndex + 1));
          } 
          if (mOrF.getDesc().getName().equals("<init>")) {
            Integer constructorIndex = (Integer)classNameToConstructorIndex.get(cpClassName);
            if (constructorIndex == null) {
              classNameToConstructorIndex.put(cpClassName, Integer.valueOf(1));
              mOrF.setIndexInClassForConstructor(0);
            } else {
              int theIndex = constructorIndex.intValue();
              mOrF.setIndexInClassForConstructor(theIndex);
              classNameToConstructorIndex.put(cpClassName, Integer.valueOf(theIndex + 1));
            } 
          } 
        });
  }
  
  public boolean existsCpClass(String className) { return this.stringsToCpClass.containsKey(className); }
  
  public void finaliseBands() {
    addCPUtf8("");
    removeSignaturesFromCpUTF8();
    addIndices();
    this.segmentHeader.setCp_Utf8_count(this.cp_Utf8.size());
    this.segmentHeader.setCp_Int_count(this.cp_Int.size());
    this.segmentHeader.setCp_Float_count(this.cp_Float.size());
    this.segmentHeader.setCp_Long_count(this.cp_Long.size());
    this.segmentHeader.setCp_Double_count(this.cp_Double.size());
    this.segmentHeader.setCp_String_count(this.cp_String.size());
    this.segmentHeader.setCp_Class_count(this.cp_Class.size());
    this.segmentHeader.setCp_Signature_count(this.cp_Signature.size());
    this.segmentHeader.setCp_Descr_count(this.cp_Descr.size());
    this.segmentHeader.setCp_Field_count(this.cp_Field.size());
    this.segmentHeader.setCp_Method_count(this.cp_Method.size());
    this.segmentHeader.setCp_Imethod_count(this.cp_Imethod.size());
  }
  
  public CPConstant<?> getConstant(Object value) {
    CPClass cPClass = (CPConstant)this.objectsToCPConstant.get(value);
    if (cPClass == null) {
      if (value instanceof Integer) {
        cPClass = new CPInt(((Integer)value).intValue());
        this.cp_Int.add((CPInt)cPClass);
      } else if (value instanceof Long) {
        cPClass = new CPLong(((Long)value).longValue());
        this.cp_Long.add((CPLong)cPClass);
      } else if (value instanceof Float) {
        cPClass = new CPFloat(((Float)value).floatValue());
        this.cp_Float.add((CPFloat)cPClass);
      } else if (value instanceof Double) {
        cPClass = new CPDouble(((Double)value).doubleValue());
        this.cp_Double.add((CPDouble)cPClass);
      } else if (value instanceof String) {
        cPClass = new CPString(getCPUtf8((String)value));
        this.cp_String.add((CPString)cPClass);
      } else if (value instanceof Type) {
        String className = ((Type)value).getClassName();
        if (className.endsWith("[]")) {
          className = "[L" + className.substring(0, className.length() - 2);
          while (className.endsWith("[]"))
            className = "[" + className.substring(0, className.length() - 2); 
          className = className + ";";
        } 
        cPClass = getCPClass(className);
      } 
      this.objectsToCPConstant.put(value, cPClass);
    } 
    return cPClass;
  }
  
  public CPClass getCPClass(String className) {
    if (className == null)
      return null; 
    className = className.replace('.', '/');
    CPClass cpClass = (CPClass)this.stringsToCpClass.get(className);
    if (cpClass == null) {
      CPUTF8 cpUtf8 = getCPUtf8(className);
      cpClass = new CPClass(cpUtf8);
      this.cp_Class.add(cpClass);
      this.stringsToCpClass.put(className, cpClass);
    } 
    if (cpClass.isInnerClass())
      this.segment.getClassBands().currentClassReferencesInnerClass(cpClass); 
    return cpClass;
  }
  
  public CPMethodOrField getCPField(CPClass cpClass, String name, String desc) {
    String key = cpClass.toString() + ":" + name + ":" + desc;
    CPMethodOrField cpF = (CPMethodOrField)this.stringsToCpField.get(key);
    if (cpF == null) {
      CPNameAndType nAndT = getCPNameAndType(name, desc);
      cpF = new CPMethodOrField(cpClass, nAndT);
      this.cp_Field.add(cpF);
      this.stringsToCpField.put(key, cpF);
    } 
    return cpF;
  }
  
  public CPMethodOrField getCPField(String owner, String name, String desc) { return getCPField(getCPClass(owner), name, desc); }
  
  public CPMethodOrField getCPIMethod(CPClass cpClass, String name, String desc) {
    String key = cpClass.toString() + ":" + name + ":" + desc;
    CPMethodOrField cpIM = (CPMethodOrField)this.stringsToCpIMethod.get(key);
    if (cpIM == null) {
      CPNameAndType nAndT = getCPNameAndType(name, desc);
      cpIM = new CPMethodOrField(cpClass, nAndT);
      this.cp_Imethod.add(cpIM);
      this.stringsToCpIMethod.put(key, cpIM);
    } 
    return cpIM;
  }
  
  public CPMethodOrField getCPIMethod(String owner, String name, String desc) { return getCPIMethod(getCPClass(owner), name, desc); }
  
  public CPMethodOrField getCPMethod(CPClass cpClass, String name, String desc) {
    String key = cpClass.toString() + ":" + name + ":" + desc;
    CPMethodOrField cpM = (CPMethodOrField)this.stringsToCpMethod.get(key);
    if (cpM == null) {
      CPNameAndType nAndT = getCPNameAndType(name, desc);
      cpM = new CPMethodOrField(cpClass, nAndT);
      this.cp_Method.add(cpM);
      this.stringsToCpMethod.put(key, cpM);
    } 
    return cpM;
  }
  
  public CPMethodOrField getCPMethod(String owner, String name, String desc) { return getCPMethod(getCPClass(owner), name, desc); }
  
  public CPNameAndType getCPNameAndType(String name, String signature) {
    String descr = name + ":" + signature;
    CPNameAndType nameAndType = (CPNameAndType)this.stringsToCpNameAndType.get(descr);
    if (nameAndType == null) {
      nameAndType = new CPNameAndType(getCPUtf8(name), getCPSignature(signature));
      this.stringsToCpNameAndType.put(descr, nameAndType);
      this.cp_Descr.add(nameAndType);
    } 
    return nameAndType;
  }
  
  public CPSignature getCPSignature(String signature) {
    if (signature == null)
      return null; 
    CPSignature cpS = (CPSignature)this.stringsToCpSignature.get(signature);
    if (cpS == null) {
      CPUTF8 signatureUTF8;
      List<CPClass> cpClasses = new ArrayList<CPClass>();
      if (signature.length() > 1 && signature.indexOf('L') != -1) {
        List<String> classes = new ArrayList<String>();
        char[] chars = signature.toCharArray();
        StringBuilder signatureString = new StringBuilder();
        for (int i = 0; i < chars.length; i++) {
          signatureString.append(chars[i]);
          if (chars[i] == 'L') {
            StringBuilder className = new StringBuilder();
            for (int j = i + 1; j < chars.length; j++) {
              char c = chars[j];
              if (!Character.isLetter(c) && !Character.isDigit(c) && c != '/' && c != '$' && c != '_') {
                classes.add(className.toString());
                i = j - 1;
                break;
              } 
              className.append(c);
            } 
          } 
        } 
        removeCpUtf8(signature);
        for (String className : classes) {
          CPClass cpClass = null;
          if (className != null) {
            className = className.replace('.', '/');
            cpClass = (CPClass)this.stringsToCpClass.get(className);
            if (cpClass == null) {
              CPUTF8 cpUtf8 = getCPUtf8(className);
              cpClass = new CPClass(cpUtf8);
              this.cp_Class.add(cpClass);
              this.stringsToCpClass.put(className, cpClass);
            } 
          } 
          cpClasses.add(cpClass);
        } 
        signatureUTF8 = getCPUtf8(signatureString.toString());
      } else {
        signatureUTF8 = getCPUtf8(signature);
      } 
      cpS = new CPSignature(signature, signatureUTF8, cpClasses);
      this.cp_Signature.add(cpS);
      this.stringsToCpSignature.put(signature, cpS);
    } 
    return cpS;
  }
  
  public CPUTF8 getCPUtf8(String utf8) {
    if (utf8 == null)
      return null; 
    CPUTF8 cpUtf8 = (CPUTF8)this.stringsToCpUtf8.get(utf8);
    if (cpUtf8 == null) {
      cpUtf8 = new CPUTF8(utf8);
      this.cp_Utf8.add(cpUtf8);
      this.stringsToCpUtf8.put(utf8, cpUtf8);
    } 
    return cpUtf8;
  }
  
  public void pack(OutputStream out) throws IOException, Pack200Exception {
    PackingUtils.log("Writing constant pool bands...");
    writeCpUtf8(out);
    writeCpInt(out);
    writeCpFloat(out);
    writeCpLong(out);
    writeCpDouble(out);
    writeCpString(out);
    writeCpClass(out);
    writeCpSignature(out);
    writeCpDescr(out);
    writeCpMethodOrField(this.cp_Field, out, "cp_Field");
    writeCpMethodOrField(this.cp_Method, out, "cp_Method");
    writeCpMethodOrField(this.cp_Imethod, out, "cp_Imethod");
  }
  
  private void removeCpUtf8(String string) {
    CPUTF8 utf8 = (CPUTF8)this.stringsToCpUtf8.get(string);
    if (utf8 != null && this.stringsToCpClass.get(string) == null) {
      this.stringsToCpUtf8.remove(string);
      this.cp_Utf8.remove(utf8);
    } 
  }
  
  private void removeSignaturesFromCpUTF8() {
    this.cp_Signature.forEach(signature -> {
          String sigStr = signature.getUnderlyingString();
          CPUTF8 utf8 = signature.getSignatureForm();
          String form = utf8.getUnderlyingString();
          if (!sigStr.equals(form))
            removeCpUtf8(sigStr); 
        });
  }
  
  private void writeCpClass(OutputStream out) throws IOException, Pack200Exception {
    PackingUtils.log("Writing " + this.cp_Class.size() + " Class entries...");
    int[] cpClass = new int[this.cp_Class.size()];
    int i = 0;
    for (CPClass cpCl : this.cp_Class) {
      cpClass[i] = cpCl.getIndexInCpUtf8();
      i++;
    } 
    byte[] encodedBand = encodeBandInt("cpClass", cpClass, Codec.UDELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from cpClass[" + cpClass.length + "]");
  }
  
  private void writeCpDescr(OutputStream out) throws IOException, Pack200Exception {
    PackingUtils.log("Writing " + this.cp_Descr.size() + " Descriptor entries...");
    int[] cpDescrName = new int[this.cp_Descr.size()];
    int[] cpDescrType = new int[this.cp_Descr.size()];
    int i = 0;
    for (CPNameAndType nameAndType : this.cp_Descr) {
      cpDescrName[i] = nameAndType.getNameIndex();
      cpDescrType[i] = nameAndType.getTypeIndex();
      i++;
    } 
    byte[] encodedBand = encodeBandInt("cp_Descr_Name", cpDescrName, Codec.DELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from cp_Descr_Name[" + cpDescrName.length + "]");
    encodedBand = encodeBandInt("cp_Descr_Type", cpDescrType, Codec.UDELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from cp_Descr_Type[" + cpDescrType.length + "]");
  }
  
  private void writeCpDouble(OutputStream out) throws IOException, Pack200Exception {
    PackingUtils.log("Writing " + this.cp_Double.size() + " Double entries...");
    int[] highBits = new int[this.cp_Double.size()];
    int[] loBits = new int[this.cp_Double.size()];
    int i = 0;
    for (CPDouble dbl : this.cp_Double) {
      long l = Double.doubleToLongBits(dbl.getDouble());
      highBits[i] = (int)(l >> 32);
      loBits[i] = (int)l;
      i++;
    } 
    byte[] encodedBand = encodeBandInt("cp_Double_hi", highBits, Codec.UDELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from cp_Double_hi[" + highBits.length + "]");
    encodedBand = encodeBandInt("cp_Double_lo", loBits, Codec.DELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from cp_Double_lo[" + loBits.length + "]");
  }
  
  private void writeCpFloat(OutputStream out) throws IOException, Pack200Exception {
    PackingUtils.log("Writing " + this.cp_Float.size() + " Float entries...");
    int[] cpFloat = new int[this.cp_Float.size()];
    int i = 0;
    for (CPFloat fl : this.cp_Float) {
      cpFloat[i] = Float.floatToIntBits(fl.getFloat());
      i++;
    } 
    byte[] encodedBand = encodeBandInt("cp_Float", cpFloat, Codec.UDELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from cp_Float[" + cpFloat.length + "]");
  }
  
  private void writeCpInt(OutputStream out) throws IOException, Pack200Exception {
    PackingUtils.log("Writing " + this.cp_Int.size() + " Integer entries...");
    int[] cpInt = new int[this.cp_Int.size()];
    int i = 0;
    for (CPInt integer : this.cp_Int) {
      cpInt[i] = integer.getInt();
      i++;
    } 
    byte[] encodedBand = encodeBandInt("cp_Int", cpInt, Codec.UDELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from cp_Int[" + cpInt.length + "]");
  }
  
  private void writeCpLong(OutputStream out) throws IOException, Pack200Exception {
    PackingUtils.log("Writing " + this.cp_Long.size() + " Long entries...");
    int[] highBits = new int[this.cp_Long.size()];
    int[] loBits = new int[this.cp_Long.size()];
    int i = 0;
    for (CPLong lng : this.cp_Long) {
      long l = lng.getLong();
      highBits[i] = (int)(l >> 32);
      loBits[i] = (int)l;
      i++;
    } 
    byte[] encodedBand = encodeBandInt("cp_Long_hi", highBits, Codec.UDELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from cp_Long_hi[" + highBits.length + "]");
    encodedBand = encodeBandInt("cp_Long_lo", loBits, Codec.DELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from cp_Long_lo[" + loBits.length + "]");
  }
  
  private void writeCpMethodOrField(Set<CPMethodOrField> cp, OutputStream out, String name) throws IOException, Pack200Exception {
    PackingUtils.log("Writing " + cp.size() + " Method and Field entries...");
    int[] cp_methodOrField_class = new int[cp.size()];
    int[] cp_methodOrField_desc = new int[cp.size()];
    int i = 0;
    for (CPMethodOrField mOrF : cp) {
      cp_methodOrField_class[i] = mOrF.getClassIndex();
      cp_methodOrField_desc[i] = mOrF.getDescIndex();
      i++;
    } 
    byte[] encodedBand = encodeBandInt(name + "_class", cp_methodOrField_class, Codec.DELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from " + name + "_class[" + cp_methodOrField_class.length + "]");
    encodedBand = encodeBandInt(name + "_desc", cp_methodOrField_desc, Codec.UDELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from " + name + "_desc[" + cp_methodOrField_desc.length + "]");
  }
  
  private void writeCpSignature(OutputStream out) throws IOException, Pack200Exception {
    PackingUtils.log("Writing " + this.cp_Signature.size() + " Signature entries...");
    int[] cpSignatureForm = new int[this.cp_Signature.size()];
    List<CPClass> classes = new ArrayList<CPClass>();
    int i = 0;
    for (CPSignature cpS : this.cp_Signature) {
      classes.addAll(cpS.getClasses());
      cpSignatureForm[i] = cpS.getIndexInCpUtf8();
      i++;
    } 
    int[] cpSignatureClasses = new int[classes.size()];
    Arrays.setAll(cpSignatureClasses, j -> ((CPClass)classes.get(j)).getIndex());
    byte[] encodedBand = encodeBandInt("cpSignatureForm", cpSignatureForm, Codec.DELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from cpSignatureForm[" + cpSignatureForm.length + "]");
    encodedBand = encodeBandInt("cpSignatureClasses", cpSignatureClasses, Codec.UDELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from cpSignatureClasses[" + cpSignatureClasses.length + "]");
  }
  
  private void writeCpString(OutputStream out) throws IOException, Pack200Exception {
    PackingUtils.log("Writing " + this.cp_String.size() + " String entries...");
    int[] cpString = new int[this.cp_String.size()];
    int i = 0;
    for (CPString cpStr : this.cp_String) {
      cpString[i] = cpStr.getIndexInCpUtf8();
      i++;
    } 
    byte[] encodedBand = encodeBandInt("cpString", cpString, Codec.UDELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from cpString[" + cpString.length + "]");
  }
  
  private void writeCpUtf8(OutputStream out) throws IOException, Pack200Exception {
    PackingUtils.log("Writing " + this.cp_Utf8.size() + " UTF8 entries...");
    int[] cpUtf8Prefix = new int[this.cp_Utf8.size() - 2];
    int[] cpUtf8Suffix = new int[this.cp_Utf8.size() - 1];
    List<Character> chars = new ArrayList<Character>();
    List<Integer> bigSuffix = new ArrayList<Integer>();
    List<Character> bigChars = new ArrayList<Character>();
    Object[] cpUtf8Array = this.cp_Utf8.toArray();
    String first = ((CPUTF8)cpUtf8Array[1]).getUnderlyingString();
    cpUtf8Suffix[0] = first.length();
    addCharacters(chars, first.toCharArray());
    for (int i = 2; i < cpUtf8Array.length; i++) {
      char[] previous = ((CPUTF8)cpUtf8Array[i - 1]).getUnderlyingString().toCharArray();
      String currentStr = ((CPUTF8)cpUtf8Array[i]).getUnderlyingString();
      char[] current = currentStr.toCharArray();
      int prefix = 0;
      for (int j = 0; j < previous.length && 
        previous[j] == current[j]; j++)
        prefix++; 
      cpUtf8Prefix[i - 2] = prefix;
      currentStr = currentStr.substring(prefix);
      char[] suffix = currentStr.toCharArray();
      if (suffix.length > 1000) {
        cpUtf8Suffix[i - 1] = 0;
        bigSuffix.add(Integer.valueOf(suffix.length));
        addCharacters(bigChars, suffix);
      } else {
        cpUtf8Suffix[i - 1] = suffix.length;
        addCharacters(chars, suffix);
      } 
    } 
    int[] cpUtf8Chars = new int[chars.size()];
    int[] cpUtf8BigSuffix = new int[bigSuffix.size()];
    int[][] cpUtf8BigChars = new int[bigSuffix.size()][];
    Arrays.setAll(cpUtf8Chars, i -> ((Character)chars.get(i)).charValue());
    for (int i = 0; i < cpUtf8BigSuffix.length; i++) {
      int numBigChars = ((Integer)bigSuffix.get(i)).intValue();
      cpUtf8BigSuffix[i] = numBigChars;
      cpUtf8BigChars[i] = new int[numBigChars];
      Arrays.setAll(cpUtf8BigChars[i], j -> ((Character)bigChars.remove(0)).charValue());
    } 
    byte[] encodedBand = encodeBandInt("cpUtf8Prefix", cpUtf8Prefix, Codec.DELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from cpUtf8Prefix[" + cpUtf8Prefix.length + "]");
    encodedBand = encodeBandInt("cpUtf8Suffix", cpUtf8Suffix, Codec.UNSIGNED5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from cpUtf8Suffix[" + cpUtf8Suffix.length + "]");
    encodedBand = encodeBandInt("cpUtf8Chars", cpUtf8Chars, Codec.CHAR3);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from cpUtf8Chars[" + cpUtf8Chars.length + "]");
    encodedBand = encodeBandInt("cpUtf8BigSuffix", cpUtf8BigSuffix, Codec.DELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from cpUtf8BigSuffix[" + cpUtf8BigSuffix.length + "]");
    for (int i = 0; i < cpUtf8BigChars.length; i++) {
      encodedBand = encodeBandInt("cpUtf8BigChars " + i, cpUtf8BigChars[i], Codec.DELTA5);
      out.write(encodedBand);
      PackingUtils.log("Wrote " + encodedBand.length + " bytes from cpUtf8BigChars" + i + "[" + cpUtf8BigChars[i].length + "]");
    } 
  }
}
