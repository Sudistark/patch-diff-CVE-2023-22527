package org.apache.commons.compress.harmony.pack200;

import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import org.objectweb.asm.Label;

public class BcBands extends BandSet {
  private static final int MULTIANEWARRAY = 197;
  
  private static final int ALOAD_0 = 42;
  
  private static final int WIDE = 196;
  
  private static final int INVOKEINTERFACE = 185;
  
  private static final int TABLESWITCH = 170;
  
  private static final int IINC = 132;
  
  private static final int LOOKUPSWITCH = 171;
  
  private static final int endMarker = 255;
  
  private final CpBands cpBands;
  
  private final Segment segment;
  
  private final IntList bcCodes = new IntList();
  
  private final IntList bcCaseCount = new IntList();
  
  private final IntList bcCaseValue = new IntList();
  
  private final IntList bcByte = new IntList();
  
  private final IntList bcShort = new IntList();
  
  private final IntList bcLocal = new IntList();
  
  private final List bcLabel = new ArrayList();
  
  private final List<CPInt> bcIntref = new ArrayList();
  
  private final List<CPFloat> bcFloatRef = new ArrayList();
  
  private final List<CPLong> bcLongRef = new ArrayList();
  
  private final List<CPDouble> bcDoubleRef = new ArrayList();
  
  private final List<CPString> bcStringRef = new ArrayList();
  
  private final List<CPClass> bcClassRef = new ArrayList();
  
  private final List<CPMethodOrField> bcFieldRef = new ArrayList();
  
  private final List<CPMethodOrField> bcMethodRef = new ArrayList();
  
  private final List<CPMethodOrField> bcIMethodRef = new ArrayList();
  
  private List bcThisField = new ArrayList();
  
  private final List bcSuperField = new ArrayList();
  
  private List bcThisMethod = new ArrayList();
  
  private List bcSuperMethod = new ArrayList();
  
  private List bcInitRef = new ArrayList();
  
  private String currentClass;
  
  private String superClass;
  
  private String currentNewClass;
  
  private final IntList bciRenumbering = new IntList();
  
  private final Map<Label, Integer> labelsToOffsets = new HashMap();
  
  private int byteCodeOffset;
  
  private int renumberedOffset;
  
  private final IntList bcLabelRelativeOffsets = new IntList();
  
  public BcBands(CpBands cpBands, Segment segment, int effort) {
    super(effort, segment.getSegmentHeader());
    this.cpBands = cpBands;
    this.segment = segment;
  }
  
  public void finaliseBands() {
    this.bcThisField = getIndexInClass(this.bcThisField);
    this.bcThisMethod = getIndexInClass(this.bcThisMethod);
    this.bcSuperMethod = getIndexInClass(this.bcSuperMethod);
    this.bcInitRef = getIndexInClassForConstructor(this.bcInitRef);
  }
  
  private List<Integer> getIndexInClass(List<CPMethodOrField> cPMethodOrFieldList) { return (List)cPMethodOrFieldList.stream().collect(Collectors.mapping(CPMethodOrField::getIndexInClass, Collectors.toList())); }
  
  private List<Integer> getIndexInClassForConstructor(List<CPMethodOrField> cPMethodList) { return (List)cPMethodList.stream().collect(Collectors.mapping(CPMethodOrField::getIndexInClassForConstructor, Collectors.toList())); }
  
  public void pack(OutputStream out) throws IOException, Pack200Exception {
    PackingUtils.log("Writing byte code bands...");
    byte[] encodedBand = encodeBandInt("bcCodes", this.bcCodes.toArray(), Codec.BYTE1);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcCodes[" + this.bcCodes.size() + "]");
    encodedBand = encodeBandInt("bcCaseCount", this.bcCaseCount.toArray(), Codec.UNSIGNED5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcCaseCount[" + this.bcCaseCount.size() + "]");
    encodedBand = encodeBandInt("bcCaseValue", this.bcCaseValue.toArray(), Codec.DELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcCaseValue[" + this.bcCaseValue.size() + "]");
    encodedBand = encodeBandInt("bcByte", this.bcByte.toArray(), Codec.BYTE1);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcByte[" + this.bcByte.size() + "]");
    encodedBand = encodeBandInt("bcShort", this.bcShort.toArray(), Codec.DELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcShort[" + this.bcShort.size() + "]");
    encodedBand = encodeBandInt("bcLocal", this.bcLocal.toArray(), Codec.UNSIGNED5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcLocal[" + this.bcLocal.size() + "]");
    encodedBand = encodeBandInt("bcLabel", integerListToArray(this.bcLabel), Codec.BRANCH5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcLabel[" + this.bcLabel.size() + "]");
    encodedBand = encodeBandInt("bcIntref", cpEntryListToArray(this.bcIntref), Codec.DELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcIntref[" + this.bcIntref.size() + "]");
    encodedBand = encodeBandInt("bcFloatRef", cpEntryListToArray(this.bcFloatRef), Codec.DELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcFloatRef[" + this.bcFloatRef.size() + "]");
    encodedBand = encodeBandInt("bcLongRef", cpEntryListToArray(this.bcLongRef), Codec.DELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcLongRef[" + this.bcLongRef.size() + "]");
    encodedBand = encodeBandInt("bcDoubleRef", cpEntryListToArray(this.bcDoubleRef), Codec.DELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcDoubleRef[" + this.bcDoubleRef.size() + "]");
    encodedBand = encodeBandInt("bcStringRef", cpEntryListToArray(this.bcStringRef), Codec.DELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcStringRef[" + this.bcStringRef.size() + "]");
    encodedBand = encodeBandInt("bcClassRef", cpEntryOrNullListToArray(this.bcClassRef), Codec.UNSIGNED5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcClassRef[" + this.bcClassRef.size() + "]");
    encodedBand = encodeBandInt("bcFieldRef", cpEntryListToArray(this.bcFieldRef), Codec.DELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcFieldRef[" + this.bcFieldRef.size() + "]");
    encodedBand = encodeBandInt("bcMethodRef", cpEntryListToArray(this.bcMethodRef), Codec.UNSIGNED5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcMethodRef[" + this.bcMethodRef.size() + "]");
    encodedBand = encodeBandInt("bcIMethodRef", cpEntryListToArray(this.bcIMethodRef), Codec.DELTA5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcIMethodRef[" + this.bcIMethodRef.size() + "]");
    encodedBand = encodeBandInt("bcThisField", integerListToArray(this.bcThisField), Codec.UNSIGNED5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcThisField[" + this.bcThisField.size() + "]");
    encodedBand = encodeBandInt("bcSuperField", integerListToArray(this.bcSuperField), Codec.UNSIGNED5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcSuperField[" + this.bcSuperField.size() + "]");
    encodedBand = encodeBandInt("bcThisMethod", integerListToArray(this.bcThisMethod), Codec.UNSIGNED5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcThisMethod[" + this.bcThisMethod.size() + "]");
    encodedBand = encodeBandInt("bcSuperMethod", integerListToArray(this.bcSuperMethod), Codec.UNSIGNED5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcSuperMethod[" + this.bcSuperMethod.size() + "]");
    encodedBand = encodeBandInt("bcInitRef", integerListToArray(this.bcInitRef), Codec.UNSIGNED5);
    out.write(encodedBand);
    PackingUtils.log("Wrote " + encodedBand.length + " bytes from bcInitRef[" + this.bcInitRef.size() + "]");
  }
  
  public void setCurrentClass(String name, String superName) {
    this.currentClass = name;
    this.superClass = superName;
  }
  
  private void updateRenumbering() {
    if (this.bciRenumbering.isEmpty())
      this.bciRenumbering.add(0); 
    this.renumberedOffset++;
    for (int i = this.bciRenumbering.size(); i < this.byteCodeOffset; i++)
      this.bciRenumbering.add(-1); 
    this.bciRenumbering.add(this.renumberedOffset);
  }
  
  public void visitEnd() {
    for (int i = 0; i < this.bciRenumbering.size(); i++) {
      if (this.bciRenumbering.get(i) == -1) {
        this.bciRenumbering.remove(i);
        this.bciRenumbering.add(i, ++this.renumberedOffset);
      } 
    } 
    if (this.renumberedOffset != 0) {
      if (this.renumberedOffset + 1 != this.bciRenumbering.size())
        throw new IllegalStateException("Mistake made with renumbering"); 
      for (int i = this.bcLabel.size() - 1; i >= 0; i--) {
        Object label = this.bcLabel.get(i);
        if (label instanceof Integer)
          break; 
        if (label instanceof Label) {
          this.bcLabel.remove(i);
          Integer offset = (Integer)this.labelsToOffsets.get(label);
          int relativeOffset = this.bcLabelRelativeOffsets.get(i);
          this.bcLabel.add(i, 
              Integer.valueOf(this.bciRenumbering.get(offset.intValue()) - this.bciRenumbering.get(relativeOffset)));
        } 
      } 
      this.bcCodes.add(255);
      this.segment.getClassBands().doBciRenumbering(this.bciRenumbering, this.labelsToOffsets);
      this.bciRenumbering.clear();
      this.labelsToOffsets.clear();
      this.byteCodeOffset = 0;
      this.renumberedOffset = 0;
    } 
  }
  
  public void visitFieldInsn(int opcode, String owner, String name, String desc) {
    this.byteCodeOffset += 3;
    updateRenumbering();
    boolean aload_0 = false;
    if (this.bcCodes.size() > 0 && this.bcCodes.get(this.bcCodes.size() - 1) == 42) {
      this.bcCodes.remove(this.bcCodes.size() - 1);
      aload_0 = true;
    } 
    CPMethodOrField cpField = this.cpBands.getCPField(owner, name, desc);
    if (aload_0)
      opcode += 7; 
    if (owner.equals(this.currentClass)) {
      opcode += 24;
      this.bcThisField.add(cpField);
    } else {
      if (aload_0) {
        opcode -= 7;
        this.bcCodes.add(42);
      } 
      this.bcFieldRef.add(cpField);
    } 
    aload_0 = false;
    this.bcCodes.add(opcode);
  }
  
  public void visitIincInsn(int var, int increment) {
    if (var > 255 || increment > 255) {
      this.byteCodeOffset += 6;
      this.bcCodes.add(196);
      this.bcCodes.add(132);
      this.bcLocal.add(var);
      this.bcShort.add(increment);
    } else {
      this.byteCodeOffset += 3;
      this.bcCodes.add(132);
      this.bcLocal.add(var);
      this.bcByte.add(increment & 0xFF);
    } 
    updateRenumbering();
  }
  
  public void visitInsn(int opcode) {
    if (opcode >= 202)
      throw new IllegalArgumentException("Non-standard bytecode instructions not supported"); 
    this.bcCodes.add(opcode);
    this.byteCodeOffset++;
    updateRenumbering();
  }
  
  public void visitIntInsn(int opcode, int operand) {
    switch (opcode) {
      case 17:
        this.bcCodes.add(opcode);
        this.bcShort.add(operand);
        this.byteCodeOffset += 3;
        break;
      case 16:
      case 188:
        this.bcCodes.add(opcode);
        this.bcByte.add(operand & 0xFF);
        this.byteCodeOffset += 2;
        break;
    } 
    updateRenumbering();
  }
  
  public void visitJumpInsn(int opcode, Label label) {
    this.bcCodes.add(opcode);
    this.bcLabel.add(label);
    this.bcLabelRelativeOffsets.add(this.byteCodeOffset);
    this.byteCodeOffset += 3;
    updateRenumbering();
  }
  
  public void visitLabel(Label label) { this.labelsToOffsets.put(label, Integer.valueOf(this.byteCodeOffset)); }
  
  public void visitLdcInsn(Object cst) {
    CPConstant<?> constant = this.cpBands.getConstant(cst);
    if (this.segment.lastConstantHadWideIndex() || constant instanceof CPLong || constant instanceof CPDouble) {
      this.byteCodeOffset += 3;
      if (constant instanceof CPInt) {
        this.bcCodes.add(237);
        this.bcIntref.add((CPInt)constant);
      } else if (constant instanceof CPFloat) {
        this.bcCodes.add(238);
        this.bcFloatRef.add((CPFloat)constant);
      } else if (constant instanceof CPLong) {
        this.bcCodes.add(20);
        this.bcLongRef.add((CPLong)constant);
      } else if (constant instanceof CPDouble) {
        this.bcCodes.add(239);
        this.bcDoubleRef.add((CPDouble)constant);
      } else if (constant instanceof CPString) {
        this.bcCodes.add(19);
        this.bcStringRef.add((CPString)constant);
      } else if (constant instanceof CPClass) {
        this.bcCodes.add(236);
        this.bcClassRef.add((CPClass)constant);
      } else {
        throw new IllegalArgumentException("Constant should not be null");
      } 
    } else {
      this.byteCodeOffset += 2;
      if (constant instanceof CPInt) {
        this.bcCodes.add(234);
        this.bcIntref.add((CPInt)constant);
      } else if (constant instanceof CPFloat) {
        this.bcCodes.add(235);
        this.bcFloatRef.add((CPFloat)constant);
      } else if (constant instanceof CPString) {
        this.bcCodes.add(18);
        this.bcStringRef.add((CPString)constant);
      } else if (constant instanceof CPClass) {
        this.bcCodes.add(233);
        this.bcClassRef.add((CPClass)constant);
      } 
    } 
    updateRenumbering();
  }
  
  public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {
    this.bcCodes.add(171);
    this.bcLabel.add(dflt);
    this.bcLabelRelativeOffsets.add(this.byteCodeOffset);
    this.bcCaseCount.add(keys.length);
    for (int i = 0; i < labels.length; i++) {
      this.bcCaseValue.add(keys[i]);
      this.bcLabel.add(labels[i]);
      this.bcLabelRelativeOffsets.add(this.byteCodeOffset);
    } 
    int padding = ((this.byteCodeOffset + 1) % 4 == 0) ? 0 : (4 - (this.byteCodeOffset + 1) % 4);
    this.byteCodeOffset += 1 + padding + 8 + 8 * keys.length;
    updateRenumbering();
  }
  
  public void visitMethodInsn(int opcode, String owner, String name, String desc) {
    CPMethodOrField cpIMethod;
    boolean aload_0;
    this.byteCodeOffset += 3;
    switch (opcode) {
      case 182:
      case 183:
      case 184:
        aload_0 = false;
        if (this.bcCodes.size() > 0 && this.bcCodes.get(this.bcCodes.size() - 1) == 42) {
          this.bcCodes.remove(this.bcCodes.size() - 1);
          aload_0 = true;
          opcode += 7;
        } 
        if (owner.equals(this.currentClass)) {
          opcode += 24;
          if (name.equals("<init>") && opcode == 207) {
            opcode = 230;
            this.bcInitRef.add(this.cpBands.getCPMethod(owner, name, desc));
          } else {
            this.bcThisMethod.add(this.cpBands.getCPMethod(owner, name, desc));
          } 
        } else if (owner.equals(this.superClass)) {
          opcode += 38;
          if (name.equals("<init>") && opcode == 221) {
            opcode = 231;
            this.bcInitRef.add(this.cpBands.getCPMethod(owner, name, desc));
          } else {
            this.bcSuperMethod.add(this.cpBands.getCPMethod(owner, name, desc));
          } 
        } else {
          if (aload_0) {
            opcode -= 7;
            this.bcCodes.add(42);
          } 
          if (name.equals("<init>") && opcode == 183 && owner.equals(this.currentNewClass)) {
            opcode = 232;
            this.bcInitRef.add(this.cpBands.getCPMethod(owner, name, desc));
          } else {
            this.bcMethodRef.add(this.cpBands.getCPMethod(owner, name, desc));
          } 
        } 
        this.bcCodes.add(opcode);
        break;
      case 185:
        this.byteCodeOffset += 2;
        cpIMethod = this.cpBands.getCPIMethod(owner, name, desc);
        this.bcIMethodRef.add(cpIMethod);
        this.bcCodes.add(185);
        break;
    } 
    updateRenumbering();
  }
  
  public void visitMultiANewArrayInsn(String desc, int dimensions) {
    this.byteCodeOffset += 4;
    updateRenumbering();
    this.bcCodes.add(197);
    this.bcClassRef.add(this.cpBands.getCPClass(desc));
    this.bcByte.add(dimensions & 0xFF);
  }
  
  public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {
    this.bcCodes.add(170);
    this.bcLabel.add(dflt);
    this.bcLabelRelativeOffsets.add(this.byteCodeOffset);
    this.bcCaseValue.add(min);
    int count = labels.length;
    this.bcCaseCount.add(count);
    for (int i = 0; i < count; i++) {
      this.bcLabel.add(labels[i]);
      this.bcLabelRelativeOffsets.add(this.byteCodeOffset);
    } 
    int padding = (this.byteCodeOffset % 4 == 0) ? 0 : (4 - this.byteCodeOffset % 4);
    this.byteCodeOffset += padding + 12 + 4 * labels.length;
    updateRenumbering();
  }
  
  public void visitTypeInsn(int opcode, String type) {
    this.byteCodeOffset += 3;
    updateRenumbering();
    this.bcCodes.add(opcode);
    this.bcClassRef.add(this.cpBands.getCPClass(type));
    if (opcode == 187)
      this.currentNewClass = type; 
  }
  
  public void visitVarInsn(int opcode, int var) {
    if (var > 255) {
      this.byteCodeOffset += 4;
      this.bcCodes.add(196);
      this.bcCodes.add(opcode);
      this.bcLocal.add(var);
    } else if (var > 3 || opcode == 169) {
      this.byteCodeOffset += 2;
      this.bcCodes.add(opcode);
      this.bcLocal.add(var);
    } else {
      this.byteCodeOffset++;
      switch (opcode) {
        case 21:
        case 54:
          this.bcCodes.add(opcode + 5 + var);
          break;
        case 22:
        case 55:
          this.bcCodes.add(opcode + 8 + var);
          break;
        case 23:
        case 56:
          this.bcCodes.add(opcode + 11 + var);
          break;
        case 24:
        case 57:
          this.bcCodes.add(opcode + 14 + var);
          break;
        case 25:
        case 58:
          this.bcCodes.add(opcode + 17 + var);
          break;
      } 
    } 
    updateRenumbering();
  }
}
