package org.apache.commons.codec.language;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import org.apache.commons.codec.EncoderException;
import org.apache.commons.codec.Resources;
import org.apache.commons.codec.StringEncoder;

public class DaitchMokotoffSoundex implements StringEncoder {
  private static final String COMMENT = "//";
  
  private static final String DOUBLE_QUOTE = "\"";
  
  private static final String MULTILINE_COMMENT_END = "*/";
  
  private static final String MULTILINE_COMMENT_START = "/*";
  
  private static final String RESOURCE_FILE = "org/apache/commons/codec/language/dmrules.txt";
  
  private static final int MAX_LENGTH = 6;
  
  private static final Map<Character, List<Rule>> RULES = new HashMap();
  
  private static final Map<Character, Character> FOLDINGS = new HashMap();
  
  private final boolean folding;
  
  static  {
    try (Scanner scanner = new Scanner(Resources.getInputStream("org/apache/commons/codec/language/dmrules.txt"), "UTF-8")) {
      parseRules(scanner, "org/apache/commons/codec/language/dmrules.txt", RULES, FOLDINGS);
    } 
    RULES.forEach((k, v) -> v.sort(()));
  }
  
  private static void parseRules(Scanner scanner, String location, Map<Character, List<Rule>> ruleMapping, Map<Character, Character> asciiFoldings) {
    int currentLine = 0;
    boolean inMultilineComment = false;
    while (scanner.hasNextLine()) {
      currentLine++;
      String rawLine = scanner.nextLine();
      String line = rawLine;
      if (inMultilineComment) {
        if (line.endsWith("*/"))
          inMultilineComment = false; 
        continue;
      } 
      if (line.startsWith("/*")) {
        inMultilineComment = true;
        continue;
      } 
      int cmtI = line.indexOf("//");
      if (cmtI >= 0)
        line = line.substring(0, cmtI); 
      line = line.trim();
      if (line.isEmpty())
        continue; 
      if (line.contains("=")) {
        String[] parts = line.split("=");
        if (parts.length != 2)
          throw new IllegalArgumentException("Malformed folding statement split into " + parts.length + " parts: " + rawLine + " in " + location); 
        String leftCharacter = parts[0];
        String rightCharacter = parts[1];
        if (leftCharacter.length() != 1 || rightCharacter.length() != 1)
          throw new IllegalArgumentException("Malformed folding statement - patterns are not single characters: " + rawLine + " in " + location); 
        asciiFoldings.put(Character.valueOf(leftCharacter.charAt(0)), Character.valueOf(rightCharacter.charAt(0)));
        continue;
      } 
      String[] parts = line.split("\\s+");
      if (parts.length != 4)
        throw new IllegalArgumentException("Malformed rule statement split into " + parts.length + " parts: " + rawLine + " in " + location); 
      try {
        String pattern = stripQuotes(parts[0]);
        String replacement1 = stripQuotes(parts[1]);
        String replacement2 = stripQuotes(parts[2]);
        String replacement3 = stripQuotes(parts[3]);
        Rule r = new Rule(pattern, replacement1, replacement2, replacement3);
        char patternKey = Rule.access$000(r).charAt(0);
        List<Rule> rules = (List)ruleMapping.computeIfAbsent(Character.valueOf(patternKey), k -> new ArrayList());
        rules.add(r);
      } catch (IllegalArgumentException e) {
        throw new IllegalStateException("Problem parsing line '" + currentLine + "' in " + location, e);
      } 
    } 
  }
  
  private static String stripQuotes(String str) {
    if (str.startsWith("\""))
      str = str.substring(1); 
    if (str.endsWith("\""))
      str = str.substring(0, str.length() - 1); 
    return str;
  }
  
  public DaitchMokotoffSoundex() { this(true); }
  
  public DaitchMokotoffSoundex(boolean folding) { this.folding = folding; }
  
  private String cleanup(String input) {
    StringBuilder sb = new StringBuilder();
    for (char ch : input.toCharArray()) {
      if (!Character.isWhitespace(ch)) {
        ch = Character.toLowerCase(ch);
        Character character = (Character)FOLDINGS.get(Character.valueOf(ch));
        if (this.folding && character != null)
          ch = character.charValue(); 
        sb.append(ch);
      } 
    } 
    return sb.toString();
  }
  
  public Object encode(Object obj) throws EncoderException {
    if (!(obj instanceof String))
      throw new EncoderException("Parameter supplied to DaitchMokotoffSoundex encode is not of type java.lang.String"); 
    return encode((String)obj);
  }
  
  public String encode(String source) {
    if (source == null)
      return null; 
    return soundex(source, false)[0];
  }
  
  public String soundex(String source) {
    String[] branches = soundex(source, true);
    StringBuilder sb = new StringBuilder();
    int index = 0;
    for (String branch : branches) {
      sb.append(branch);
      if (++index < branches.length)
        sb.append('|'); 
    } 
    return sb.toString();
  }
  
  private String[] soundex(String source, boolean branching) {
    if (source == null)
      return null; 
    String input = cleanup(source);
    Set<Branch> currentBranches = new LinkedHashSet<Branch>();
    currentBranches.add(new Branch(null));
    char lastChar = Character.MIN_VALUE;
    for (int index = 0; index < input.length(); index++) {
      char ch = input.charAt(index);
      if (!Character.isWhitespace(ch)) {
        String inputContext = input.substring(index);
        List<Rule> rules = (List)RULES.get(Character.valueOf(ch));
        if (rules != null) {
          List<Branch> nextBranches = branching ? new ArrayList() : Collections.emptyList();
          for (Rule rule : rules) {
            if (rule.matches(inputContext)) {
              if (branching)
                nextBranches.clear(); 
              String[] replacements = rule.getReplacements(inputContext, (lastChar == '\000'));
              boolean branchingRequired = (replacements.length > 1 && branching);
              for (Branch branch : currentBranches) {
                for (String nextReplacement : replacements) {
                  Branch nextBranch = branchingRequired ? branch.createBranch() : branch;
                  boolean force = ((lastChar == 'm' && ch == 'n') || (lastChar == 'n' && ch == 'm'));
                  nextBranch.processNextReplacement(nextReplacement, force);
                  if (!branching)
                    break; 
                  nextBranches.add(nextBranch);
                } 
              } 
              if (branching) {
                currentBranches.clear();
                currentBranches.addAll(nextBranches);
              } 
              index += rule.getPatternLength() - 1;
              break;
            } 
          } 
          lastChar = ch;
        } 
      } 
    } 
    String[] result = new String[currentBranches.size()];
    int index = 0;
    for (Branch branch : currentBranches) {
      branch.finish();
      result[index++] = branch.toString();
    } 
    return result;
  }
}
