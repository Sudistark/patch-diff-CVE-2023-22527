package org.apache.commons.codec.language;

import java.util.Locale;
import org.apache.commons.codec.EncoderException;
import org.apache.commons.codec.StringEncoder;

public class ColognePhonetic implements StringEncoder {
  private static final char[] AEIJOUY = { 'A', 'E', 'I', 'J', 'O', 'U', 'Y' };
  
  private static final char[] CSZ = { 'C', 'S', 'Z' };
  
  private static final char[] FPVW = { 'F', 'P', 'V', 'W' };
  
  private static final char[] GKQ = { 'G', 'K', 'Q' };
  
  private static final char[] CKQ = { 'C', 'K', 'Q' };
  
  private static final char[] AHKLOQRUX = { 'A', 'H', 'K', 'L', 'O', 'Q', 'R', 'U', 'X' };
  
  private static final char[] SZ = { 'S', 'Z' };
  
  private static final char[] AHKOQUX = { 'A', 'H', 'K', 'O', 'Q', 'U', 'X' };
  
  private static final char[] DTX = { 'D', 'T', 'X' };
  
  private static final char CHAR_IGNORE = '-';
  
  private static boolean arrayContains(char[] arr, char key) {
    for (char element : arr) {
      if (element == key)
        return true; 
    } 
    return false;
  }
  
  public String colognePhonetic(String text) {
    if (text == null)
      return null; 
    CologneInputBuffer input = new CologneInputBuffer(this, preprocess(text));
    CologneOutputBuffer output = new CologneOutputBuffer(this, input.length() * 2);
    char lastChar = '-';
    while (!input.isEmpty()) {
      char nextChar, chr = input.removeNext();
      if (!input.isEmpty()) {
        nextChar = input.getNextChar();
      } else {
        nextChar = '-';
      } 
      if (chr < 'A' || chr > 'Z')
        continue; 
      if (arrayContains(AEIJOUY, chr)) {
        output.put('0');
      } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) {
        output.put('1');
      } else if ((chr == 'D' || chr == 'T') && !arrayContains(CSZ, nextChar)) {
        output.put('2');
      } else if (arrayContains(FPVW, chr)) {
        output.put('3');
      } else if (arrayContains(GKQ, chr)) {
        output.put('4');
      } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) {
        output.put('4');
        output.put('8');
      } else if (chr == 'S' || chr == 'Z') {
        output.put('8');
      } else if (chr == 'C') {
        if (output.isEmpty()) {
          if (arrayContains(AHKLOQRUX, nextChar)) {
            output.put('4');
          } else {
            output.put('8');
          } 
        } else if (arrayContains(SZ, lastChar) || !arrayContains(AHKOQUX, nextChar)) {
          output.put('8');
        } else {
          output.put('4');
        } 
      } else if (arrayContains(DTX, chr)) {
        output.put('8');
      } else {
        switch (chr) {
          case 'R':
            output.put('7');
            break;
          case 'L':
            output.put('5');
            break;
          case 'M':
          case 'N':
            output.put('6');
            break;
          case 'H':
            output.put('-');
            break;
        } 
      } 
      lastChar = chr;
    } 
    return output.toString();
  }
  
  public Object encode(Object object) throws EncoderException {
    if (!(object instanceof String))
      throw new EncoderException("This method's parameter was expected to be of the type " + String.class
          .getName() + ". But actually it was of the type " + object
          
          .getClass().getName() + "."); 
    return encode((String)object);
  }
  
  public String encode(String text) { return colognePhonetic(text); }
  
  public boolean isEncodeEqual(String text1, String text2) { return colognePhonetic(text1).equals(colognePhonetic(text2)); }
  
  private char[] preprocess(String text) {
    char[] chrs = text.toUpperCase(Locale.GERMAN).toCharArray();
    for (int index = 0; index < chrs.length; index++) {
      switch (chrs[index]) {
        case 'Ä':
          chrs[index] = 'A';
          break;
        case 'Ü':
          chrs[index] = 'U';
          break;
        case 'Ö':
          chrs[index] = 'O';
          break;
      } 
    } 
    return chrs;
  }
}
