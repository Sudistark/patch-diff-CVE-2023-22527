package org.apache.commons.codec.binary;

import java.util.Arrays;
import java.util.Objects;
import org.apache.commons.codec.BinaryDecoder;
import org.apache.commons.codec.BinaryEncoder;
import org.apache.commons.codec.CodecPolicy;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.EncoderException;

public abstract class BaseNCodec implements BinaryEncoder, BinaryDecoder {
  static final int EOF = -1;
  
  public static final int MIME_CHUNK_SIZE = 76;
  
  public static final int PEM_CHUNK_SIZE = 64;
  
  private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;
  
  private static final int DEFAULT_BUFFER_SIZE = 8192;
  
  private static final int MAX_BUFFER_SIZE = 2147483639;
  
  protected static final int MASK_8BITS = 255;
  
  protected static final byte PAD_DEFAULT = 61;
  
  protected static final CodecPolicy DECODING_POLICY_DEFAULT = CodecPolicy.LENIENT;
  
  static final byte[] CHUNK_SEPARATOR = { 13, 10 };
  
  @Deprecated
  protected final byte PAD = 61;
  
  protected final byte pad;
  
  private final int unencodedBlockSize;
  
  private final int encodedBlockSize;
  
  protected final int lineLength;
  
  private final int chunkSeparatorLength;
  
  private final CodecPolicy decodingPolicy;
  
  private static int createPositiveCapacity(int minCapacity) {
    if (minCapacity < 0)
      throw new OutOfMemoryError("Unable to allocate array size: " + (minCapacity & 0xFFFFFFFFL)); 
    return Math.max(minCapacity, 2147483639);
  }
  
  public static byte[] getChunkSeparator() { return (byte[])CHUNK_SEPARATOR.clone(); }
  
  @Deprecated
  protected static boolean isWhiteSpace(byte byteToCheck) { return Character.isWhitespace(byteToCheck); }
  
  private static byte[] resizeBuffer(Context context, int minCapacity) {
    int oldCapacity = context.buffer.length;
    int newCapacity = oldCapacity * 2;
    if (Integer.compareUnsigned(newCapacity, minCapacity) < 0)
      newCapacity = minCapacity; 
    if (Integer.compareUnsigned(newCapacity, 2147483639) > 0)
      newCapacity = createPositiveCapacity(minCapacity); 
    byte[] b = Arrays.copyOf(context.buffer, newCapacity);
    context.buffer = b;
    return b;
  }
  
  protected BaseNCodec(int unencodedBlockSize, int encodedBlockSize, int lineLength, int chunkSeparatorLength) { this(unencodedBlockSize, encodedBlockSize, lineLength, chunkSeparatorLength, (byte)61); }
  
  protected BaseNCodec(int unencodedBlockSize, int encodedBlockSize, int lineLength, int chunkSeparatorLength, byte pad) { this(unencodedBlockSize, encodedBlockSize, lineLength, chunkSeparatorLength, pad, DECODING_POLICY_DEFAULT); }
  
  protected BaseNCodec(int unencodedBlockSize, int encodedBlockSize, int lineLength, int chunkSeparatorLength, byte pad, CodecPolicy decodingPolicy) {
    this.PAD = 61;
    this.unencodedBlockSize = unencodedBlockSize;
    this.encodedBlockSize = encodedBlockSize;
    boolean useChunking = (lineLength > 0 && chunkSeparatorLength > 0);
    this.lineLength = useChunking ? (lineLength / encodedBlockSize * encodedBlockSize) : 0;
    this.chunkSeparatorLength = chunkSeparatorLength;
    this.pad = pad;
    this.decodingPolicy = (CodecPolicy)Objects.requireNonNull(decodingPolicy, "codecPolicy");
  }
  
  int available(Context context) { return hasData(context) ? (context.pos - context.readPos) : 0; }
  
  protected boolean containsAlphabetOrPad(byte[] arrayOctet) {
    if (arrayOctet == null)
      return false; 
    for (byte element : arrayOctet) {
      if (this.pad == element || isInAlphabet(element))
        return true; 
    } 
    return false;
  }
  
  public byte[] decode(byte[] pArray) {
    if (BinaryCodec.isEmpty(pArray))
      return pArray; 
    Context context = new Context();
    decode(pArray, 0, pArray.length, context);
    decode(pArray, 0, -1, context);
    byte[] result = new byte[context.pos];
    readResults(result, 0, result.length, context);
    return result;
  }
  
  abstract void decode(byte[] paramArrayOfByte, int paramInt1, int paramInt2, Context paramContext);
  
  public Object decode(Object obj) throws DecoderException {
    if (obj instanceof byte[])
      return decode((byte[])obj); 
    if (obj instanceof String)
      return decode((String)obj); 
    throw new DecoderException("Parameter supplied to Base-N decode is not a byte[] or a String");
  }
  
  public byte[] decode(String pArray) { return decode(StringUtils.getBytesUtf8(pArray)); }
  
  public byte[] encode(byte[] pArray) {
    if (BinaryCodec.isEmpty(pArray))
      return pArray; 
    return encode(pArray, 0, pArray.length);
  }
  
  public byte[] encode(byte[] pArray, int offset, int length) {
    if (BinaryCodec.isEmpty(pArray))
      return pArray; 
    Context context = new Context();
    encode(pArray, offset, length, context);
    encode(pArray, offset, -1, context);
    byte[] buf = new byte[context.pos - context.readPos];
    readResults(buf, 0, buf.length, context);
    return buf;
  }
  
  abstract void encode(byte[] paramArrayOfByte, int paramInt1, int paramInt2, Context paramContext);
  
  public Object encode(Object obj) throws DecoderException {
    if (!(obj instanceof byte[]))
      throw new EncoderException("Parameter supplied to Base-N encode is not a byte[]"); 
    return encode((byte[])obj);
  }
  
  public String encodeAsString(byte[] pArray) { return StringUtils.newStringUtf8(encode(pArray)); }
  
  public String encodeToString(byte[] pArray) { return StringUtils.newStringUtf8(encode(pArray)); }
  
  protected byte[] ensureBufferSize(int size, Context context) {
    if (context.buffer == null) {
      context.buffer = new byte[Math.max(size, getDefaultBufferSize())];
      context.pos = 0;
      context.readPos = 0;
    } else if (context.pos + size - context.buffer.length > 0) {
      return resizeBuffer(context, context.pos + size);
    } 
    return context.buffer;
  }
  
  public CodecPolicy getCodecPolicy() { return this.decodingPolicy; }
  
  protected int getDefaultBufferSize() { return 8192; }
  
  public long getEncodedLength(byte[] pArray) {
    long len = ((pArray.length + this.unencodedBlockSize - 1) / this.unencodedBlockSize) * this.encodedBlockSize;
    if (this.lineLength > 0)
      len += (len + this.lineLength - 1L) / this.lineLength * this.chunkSeparatorLength; 
    return len;
  }
  
  boolean hasData(Context context) { return (context.pos > context.readPos); }
  
  protected abstract boolean isInAlphabet(byte paramByte);
  
  public boolean isInAlphabet(byte[] arrayOctet, boolean allowWSPad) {
    for (byte octet : arrayOctet) {
      if (!isInAlphabet(octet) && (!allowWSPad || (octet != this.pad && 
        !Character.isWhitespace(octet))))
        return false; 
    } 
    return true;
  }
  
  public boolean isInAlphabet(String basen) { return isInAlphabet(StringUtils.getBytesUtf8(basen), true); }
  
  public boolean isStrictDecoding() { return (this.decodingPolicy == CodecPolicy.STRICT); }
  
  int readResults(byte[] b, int bPos, int bAvail, Context context) {
    if (hasData(context)) {
      int len = Math.min(available(context), bAvail);
      System.arraycopy(context.buffer, context.readPos, b, bPos, len);
      context.readPos += len;
      if (!hasData(context))
        context.pos = context.readPos = 0; 
      return len;
    } 
    return context.eof ? -1 : 0;
  }
}
