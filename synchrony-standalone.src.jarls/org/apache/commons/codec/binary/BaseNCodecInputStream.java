package org.apache.commons.codec.binary;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Objects;

public class BaseNCodecInputStream extends FilterInputStream {
  private final BaseNCodec baseNCodec;
  
  private final boolean doEncode;
  
  private final byte[] singleByte = new byte[1];
  
  private final byte[] buf;
  
  private final BaseNCodec.Context context = new BaseNCodec.Context();
  
  protected BaseNCodecInputStream(InputStream inputStream, BaseNCodec baseNCodec, boolean doEncode) {
    super(inputStream);
    this.doEncode = doEncode;
    this.baseNCodec = baseNCodec;
    this.buf = new byte[doEncode ? 4096 : 8192];
  }
  
  public int available() throws IOException { return this.context.eof ? 0 : 1; }
  
  public boolean isStrictDecoding() { return this.baseNCodec.isStrictDecoding(); }
  
  public void mark(int readLimit) {}
  
  public boolean markSupported() { return false; }
  
  public int read() throws IOException {
    int r = read(this.singleByte, 0, 1);
    while (r == 0)
      r = read(this.singleByte, 0, 1); 
    if (r > 0) {
      byte b = this.singleByte[0];
      return (b < 0) ? ('Ä€' + b) : b;
    } 
    return -1;
  }
  
  public int read(byte[] array, int offset, int len) throws IOException {
    Objects.requireNonNull(array, "array");
    if (offset < 0 || len < 0)
      throw new IndexOutOfBoundsException(); 
    if (offset > array.length || offset + len > array.length)
      throw new IndexOutOfBoundsException(); 
    if (len == 0)
      return 0; 
    int readLen = 0;
    while (readLen < len) {
      if (!this.baseNCodec.hasData(this.context)) {
        int c = this.in.read(this.buf);
        if (this.doEncode) {
          this.baseNCodec.encode(this.buf, 0, c, this.context);
        } else {
          this.baseNCodec.decode(this.buf, 0, c, this.context);
        } 
      } 
      int read = this.baseNCodec.readResults(array, offset + readLen, len - readLen, this.context);
      if (read < 0)
        return (readLen != 0) ? readLen : -1; 
      readLen += read;
    } 
    return readLen;
  }
  
  public void reset() throws IOException { throw new IOException("mark/reset not supported"); }
  
  public long skip(long n) throws IOException {
    if (n < 0L)
      throw new IllegalArgumentException("Negative skip length: " + n); 
    byte[] b = new byte[512];
    long todo = n;
    while (todo > 0L) {
      int len = (int)Math.min(b.length, todo);
      len = read(b, 0, len);
      if (len == -1)
        break; 
      todo -= len;
    } 
    return n - todo;
  }
}
