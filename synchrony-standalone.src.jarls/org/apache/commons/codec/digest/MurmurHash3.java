package org.apache.commons.codec.digest;

import org.apache.commons.codec.binary.StringUtils;

public final class MurmurHash3 {
  @Deprecated
  public static final long NULL_HASHCODE = 2862933555777941757L;
  
  public static final int DEFAULT_SEED = 104729;
  
  private static final int C1_32 = -862048943;
  
  private static final int C2_32 = 461845907;
  
  private static final int R1_32 = 15;
  
  private static final int R2_32 = 13;
  
  private static final int M_32 = 5;
  
  private static final int N_32 = -430675100;
  
  private static final long C1 = -8663945395140668459L;
  
  private static final long C2 = 5545529020109919103L;
  
  private static final int R1 = 31;
  
  private static final int R2 = 27;
  
  private static final int R3 = 33;
  
  private static final int M = 5;
  
  private static final int N1 = 1390208809;
  
  private static final int N2 = 944331445;
  
  public static int hash32(long data1, long data2) { return hash32(data1, data2, 104729); }
  
  public static int hash32(long data1, long data2, int seed) {
    int hash = seed;
    long r0 = Long.reverseBytes(data1);
    long r1 = Long.reverseBytes(data2);
    hash = mix32((int)r0, hash);
    hash = mix32((int)(r0 >>> 32), hash);
    hash = mix32((int)r1, hash);
    hash = mix32((int)(r1 >>> 32), hash);
    hash ^= 0x10;
    return fmix32(hash);
  }
  
  public static int hash32(long data) { return hash32(data, 104729); }
  
  public static int hash32(long data, int seed) {
    int hash = seed;
    long r0 = Long.reverseBytes(data);
    hash = mix32((int)r0, hash);
    hash = mix32((int)(r0 >>> 32), hash);
    hash ^= 0x8;
    return fmix32(hash);
  }
  
  @Deprecated
  public static int hash32(byte[] data) { return hash32(data, 0, data.length, 104729); }
  
  @Deprecated
  public static int hash32(String data) {
    byte[] bytes = StringUtils.getBytesUtf8(data);
    return hash32(bytes, 0, bytes.length, 104729);
  }
  
  @Deprecated
  public static int hash32(byte[] data, int length) { return hash32(data, length, 104729); }
  
  @Deprecated
  public static int hash32(byte[] data, int length, int seed) { return hash32(data, 0, length, seed); }
  
  @Deprecated
  public static int hash32(byte[] data, int offset, int length, int seed) {
    int hash = seed;
    int nblocks = length >> 2;
    for (int i = 0; i < nblocks; i++) {
      int index = offset + (i << 2);
      int k = getLittleEndianInt(data, index);
      hash = mix32(k, hash);
    } 
    int index = offset + (nblocks << 2);
    int k1 = 0;
    switch (offset + length - index) {
      case 3:
        k1 ^= data[index + 2] << 16;
      case 2:
        k1 ^= data[index + 1] << 8;
      case 1:
        k1 ^= data[index];
        k1 *= -862048943;
        k1 = Integer.rotateLeft(k1, 15);
        k1 *= 461845907;
        hash ^= k1;
        break;
    } 
    hash ^= length;
    return fmix32(hash);
  }
  
  public static int hash32x86(byte[] data) { return hash32x86(data, 0, data.length, 0); }
  
  public static int hash32x86(byte[] data, int offset, int length, int seed) {
    int hash = seed;
    int nblocks = length >> 2;
    for (int i = 0; i < nblocks; i++) {
      int index = offset + (i << 2);
      int k = getLittleEndianInt(data, index);
      hash = mix32(k, hash);
    } 
    int index = offset + (nblocks << 2);
    int k1 = 0;
    switch (offset + length - index) {
      case 3:
        k1 ^= (data[index + 2] & 0xFF) << 16;
      case 2:
        k1 ^= (data[index + 1] & 0xFF) << 8;
      case 1:
        k1 ^= data[index] & 0xFF;
        k1 *= -862048943;
        k1 = Integer.rotateLeft(k1, 15);
        k1 *= 461845907;
        hash ^= k1;
        break;
    } 
    hash ^= length;
    return fmix32(hash);
  }
  
  @Deprecated
  public static long hash64(long data) {
    hash = 104729L;
    long k = Long.reverseBytes(data);
    k *= -8663945395140668459L;
    k = Long.rotateLeft(k, 31);
    k *= 5545529020109919103L;
    hash ^= k;
    hash = Long.rotateLeft(hash, 27) * 5L + 1390208809L;
    hash ^= 0x8L;
    return fmix64(hash);
  }
  
  @Deprecated
  public static long hash64(int data) {
    long k1 = Integer.reverseBytes(data) & 0xFFFFFFFFL;
    hash = 104729L;
    k1 *= -8663945395140668459L;
    k1 = Long.rotateLeft(k1, 31);
    k1 *= 5545529020109919103L;
    hash ^= k1;
    hash ^= 0x4L;
    return fmix64(hash);
  }
  
  @Deprecated
  public static long hash64(short data) {
    hash = 104729L;
    long k1 = 0L;
    k1 ^= (data & 0xFFL) << 8;
    k1 ^= ((data & 0xFF00) >> 8) & 0xFFL;
    k1 *= -8663945395140668459L;
    k1 = Long.rotateLeft(k1, 31);
    k1 *= 5545529020109919103L;
    hash ^= k1;
    hash ^= 0x2L;
    return fmix64(hash);
  }
  
  @Deprecated
  public static long hash64(byte[] data) { return hash64(data, 0, data.length, 104729); }
  
  @Deprecated
  public static long hash64(byte[] data, int offset, int length) { return hash64(data, offset, length, 104729); }
  
  @Deprecated
  public static long hash64(byte[] data, int offset, int length, int seed) {
    hash = seed;
    int nblocks = length >> 3;
    for (int i = 0; i < nblocks; i++) {
      int index = offset + (i << 3);
      long k = getLittleEndianLong(data, index);
      k *= -8663945395140668459L;
      k = Long.rotateLeft(k, 31);
      k *= 5545529020109919103L;
      hash ^= k;
      hash = Long.rotateLeft(hash, 27) * 5L + 1390208809L;
    } 
    long k1 = 0L;
    int index = offset + (nblocks << 3);
    switch (offset + length - index) {
      case 7:
        k1 ^= (data[index + 6] & 0xFFL) << 48;
      case 6:
        k1 ^= (data[index + 5] & 0xFFL) << 40;
      case 5:
        k1 ^= (data[index + 4] & 0xFFL) << 32;
      case 4:
        k1 ^= (data[index + 3] & 0xFFL) << 24;
      case 3:
        k1 ^= (data[index + 2] & 0xFFL) << 16;
      case 2:
        k1 ^= (data[index + 1] & 0xFFL) << 8;
      case 1:
        k1 ^= data[index] & 0xFFL;
        k1 *= -8663945395140668459L;
        k1 = Long.rotateLeft(k1, 31);
        k1 *= 5545529020109919103L;
        hash ^= k1;
        break;
    } 
    hash ^= length;
    return fmix64(hash);
  }
  
  public static long[] hash128(byte[] data) { return hash128(data, 0, data.length, 104729); }
  
  public static long[] hash128x64(byte[] data) { return hash128x64(data, 0, data.length, 0); }
  
  @Deprecated
  public static long[] hash128(String data) {
    byte[] bytes = StringUtils.getBytesUtf8(data);
    return hash128(bytes, 0, bytes.length, 104729);
  }
  
  @Deprecated
  public static long[] hash128(byte[] data, int offset, int length, int seed) { return hash128x64Internal(data, offset, length, seed); }
  
  public static long[] hash128x64(byte[] data, int offset, int length, int seed) { return hash128x64Internal(data, offset, length, seed & 0xFFFFFFFFL); }
  
  private static long[] hash128x64Internal(byte[] data, int offset, int length, long seed) {
    long h1 = seed;
    long h2 = seed;
    int nblocks = length >> 4;
    for (int i = 0; i < nblocks; i++) {
      int index = offset + (i << 4);
      long k1 = getLittleEndianLong(data, index);
      long k2 = getLittleEndianLong(data, index + 8);
      k1 *= -8663945395140668459L;
      k1 = Long.rotateLeft(k1, 31);
      k1 *= 5545529020109919103L;
      h1 ^= k1;
      h1 = Long.rotateLeft(h1, 27);
      h1 += h2;
      h1 = h1 * 5L + 1390208809L;
      k2 *= 5545529020109919103L;
      k2 = Long.rotateLeft(k2, 33);
      k2 *= -8663945395140668459L;
      h2 ^= k2;
      h2 = Long.rotateLeft(h2, 31);
      h2 += h1;
      h2 = h2 * 5L + 944331445L;
    } 
    long k1 = 0L;
    long k2 = 0L;
    int index = offset + (nblocks << 4);
    switch (offset + length - index) {
      case 15:
        k2 ^= (data[index + 14] & 0xFFL) << 48;
      case 14:
        k2 ^= (data[index + 13] & 0xFFL) << 40;
      case 13:
        k2 ^= (data[index + 12] & 0xFFL) << 32;
      case 12:
        k2 ^= (data[index + 11] & 0xFFL) << 24;
      case 11:
        k2 ^= (data[index + 10] & 0xFFL) << 16;
      case 10:
        k2 ^= (data[index + 9] & 0xFFL) << 8;
      case 9:
        k2 ^= (data[index + 8] & 0xFF);
        k2 *= 5545529020109919103L;
        k2 = Long.rotateLeft(k2, 33);
        k2 *= -8663945395140668459L;
        h2 ^= k2;
      case 8:
        k1 ^= (data[index + 7] & 0xFFL) << 56;
      case 7:
        k1 ^= (data[index + 6] & 0xFFL) << 48;
      case 6:
        k1 ^= (data[index + 5] & 0xFFL) << 40;
      case 5:
        k1 ^= (data[index + 4] & 0xFFL) << 32;
      case 4:
        k1 ^= (data[index + 3] & 0xFFL) << 24;
      case 3:
        k1 ^= (data[index + 2] & 0xFFL) << 16;
      case 2:
        k1 ^= (data[index + 1] & 0xFFL) << 8;
      case 1:
        k1 ^= (data[index] & 0xFF);
        k1 *= -8663945395140668459L;
        k1 = Long.rotateLeft(k1, 31);
        k1 *= 5545529020109919103L;
        h1 ^= k1;
        break;
    } 
    h1 ^= length;
    h2 ^= length;
    h1 += h2;
    h2 += h1;
    h1 = fmix64(h1);
    h2 = fmix64(h2);
    h1 += h2;
    h2 += h1;
    return new long[] { h1, h2 };
  }
  
  private static long getLittleEndianLong(byte[] data, int index) { return data[index] & 0xFFL | (data[index + 1] & 0xFFL) << 8 | (data[index + 2] & 0xFFL) << 16 | (data[index + 3] & 0xFFL) << 24 | (data[index + 4] & 0xFFL) << 32 | (data[index + 5] & 0xFFL) << 40 | (data[index + 6] & 0xFFL) << 48 | (data[index + 7] & 0xFFL) << 56; }
  
  private static int getLittleEndianInt(byte[] data, int index) { return data[index] & 0xFF | (data[index + 1] & 0xFF) << 8 | (data[index + 2] & 0xFF) << 16 | (data[index + 3] & 0xFF) << 24; }
  
  private static int mix32(int k, int hash) {
    k *= -862048943;
    k = Integer.rotateLeft(k, 15);
    k *= 461845907;
    hash ^= k;
    return Integer.rotateLeft(hash, 13) * 5 + -430675100;
  }
  
  private static int fmix32(int hash) {
    hash ^= hash >>> 16;
    hash *= -2048144789;
    hash ^= hash >>> 13;
    hash *= -1028477387;
    return hash >>> 16;
  }
  
  private static long fmix64(long hash) {
    hash ^= hash >>> 33;
    hash *= -49064778989728563L;
    hash ^= hash >>> 33;
    hash *= -4265267296055464877L;
    return hash >>> 33;
  }
}
