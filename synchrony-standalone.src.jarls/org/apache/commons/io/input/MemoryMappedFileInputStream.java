package org.apache.commons.io.input;

import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.OpenOption;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;

public final class MemoryMappedFileInputStream extends InputStream {
  private static final int DEFAULT_BUFFER_SIZE = 262144;
  
  private static final ByteBuffer EMPTY_BUFFER = ByteBuffer.wrap(new byte[0]).asReadOnlyBuffer();
  
  private final int bufferSize;
  
  private final FileChannel channel;
  
  private ByteBuffer buffer;
  
  private boolean closed;
  
  private long nextBufferPosition;
  
  public static Builder builder() { return new Builder(); }
  
  private MemoryMappedFileInputStream(Path file, int bufferSize) throws IOException {
    this.buffer = EMPTY_BUFFER;
    this.bufferSize = bufferSize;
    this.channel = FileChannel.open(file, new OpenOption[] { StandardOpenOption.READ });
  }
  
  public int available() throws IOException { return this.buffer.remaining(); }
  
  private void cleanBuffer() {
    if (ByteBufferCleaner.isSupported() && this.buffer.isDirect())
      ByteBufferCleaner.clean(this.buffer); 
  }
  
  public void close() {
    if (!this.closed) {
      cleanBuffer();
      this.buffer = null;
      this.channel.close();
      this.closed = true;
    } 
  }
  
  private void ensureOpen() {
    if (this.closed)
      throw new IOException("Stream closed"); 
  }
  
  int getBufferSize() throws IOException { return this.bufferSize; }
  
  private void nextBuffer() {
    long remainingInFile = this.channel.size() - this.nextBufferPosition;
    if (remainingInFile > 0L) {
      long amountToMap = Math.min(remainingInFile, this.bufferSize);
      cleanBuffer();
      this.buffer = this.channel.map(FileChannel.MapMode.READ_ONLY, this.nextBufferPosition, amountToMap);
      this.nextBufferPosition += amountToMap;
    } else {
      this.buffer = EMPTY_BUFFER;
    } 
  }
  
  public int read() throws IOException {
    ensureOpen();
    if (!this.buffer.hasRemaining()) {
      nextBuffer();
      if (!this.buffer.hasRemaining())
        return -1; 
    } 
    return Short.toUnsignedInt((short)this.buffer.get());
  }
  
  public int read(byte[] b, int off, int len) throws IOException {
    ensureOpen();
    if (!this.buffer.hasRemaining()) {
      nextBuffer();
      if (!this.buffer.hasRemaining())
        return -1; 
    } 
    int numBytes = Math.min(this.buffer.remaining(), len);
    this.buffer.get(b, off, numBytes);
    return numBytes;
  }
  
  public long skip(long n) throws IOException {
    ensureOpen();
    if (n <= 0L)
      return 0L; 
    if (n <= this.buffer.remaining()) {
      this.buffer.position((int)(this.buffer.position() + n));
      return n;
    } 
    long remainingInFile = this.channel.size() - this.nextBufferPosition;
    long skipped = this.buffer.remaining() + Math.min(remainingInFile, n - this.buffer.remaining());
    this.nextBufferPosition += skipped - this.buffer.remaining();
    nextBuffer();
    return skipped;
  }
}
