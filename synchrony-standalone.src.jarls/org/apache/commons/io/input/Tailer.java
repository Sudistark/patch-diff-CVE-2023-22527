package org.apache.commons.io.input;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.attribute.FileTime;
import java.time.Duration;
import java.util.Objects;
import org.apache.commons.io.IOUtils;
import org.apache.commons.io.ThreadUtils;
import org.apache.commons.io.file.attribute.FileTimes;

public class Tailer implements Runnable, AutoCloseable {
  private static final int DEFAULT_DELAY_MILLIS = 1000;
  
  private static final String RAF_READ_ONLY_MODE = "r";
  
  private static final Charset DEFAULT_CHARSET = Charset.defaultCharset();
  
  private final byte[] inbuf;
  
  private final Tailable tailable;
  
  private final Charset charset;
  
  private final Duration delayDuration;
  
  private final boolean tailAtEnd;
  
  private final TailerListener listener;
  
  private final boolean reOpen;
  
  public static Builder builder() { return new Builder(); }
  
  @Deprecated
  public static Tailer create(File file, Charset charset, TailerListener listener, long delayMillis, boolean end, boolean reOpen, int bufferSize) { return ((Builder)((Builder)((Builder)builder()
      .setFile(file))
      .setTailerListener(listener)
      .setCharset(charset))
      .setDelayDuration(Duration.ofMillis(delayMillis))
      .setTailFromEnd(end)
      .setReOpen(reOpen)
      .setBufferSize(bufferSize))
      .get(); }
  
  @Deprecated
  public static Tailer create(File file, TailerListener listener) { return ((Builder)builder()
      .setFile(file))
      .setTailerListener(listener)
      .get(); }
  
  @Deprecated
  public static Tailer create(File file, TailerListener listener, long delayMillis) { return ((Builder)builder()
      .setFile(file))
      .setTailerListener(listener)
      .setDelayDuration(Duration.ofMillis(delayMillis))
      .get(); }
  
  @Deprecated
  public static Tailer create(File file, TailerListener listener, long delayMillis, boolean end) { return ((Builder)builder()
      .setFile(file))
      .setTailerListener(listener)
      .setDelayDuration(Duration.ofMillis(delayMillis))
      .setTailFromEnd(end)
      .get(); }
  
  @Deprecated
  public static Tailer create(File file, TailerListener listener, long delayMillis, boolean end, boolean reOpen) { return ((Builder)builder()
      .setFile(file))
      .setTailerListener(listener)
      .setDelayDuration(Duration.ofMillis(delayMillis))
      .setTailFromEnd(end)
      .setReOpen(reOpen)
      .get(); }
  
  @Deprecated
  public static Tailer create(File file, TailerListener listener, long delayMillis, boolean end, boolean reOpen, int bufferSize) { return ((Builder)((Builder)builder()
      .setFile(file))
      .setTailerListener(listener)
      .setDelayDuration(Duration.ofMillis(delayMillis))
      .setTailFromEnd(end)
      .setReOpen(reOpen)
      .setBufferSize(bufferSize))
      .get(); }
  
  @Deprecated
  public static Tailer create(File file, TailerListener listener, long delayMillis, boolean end, int bufferSize) { return ((Builder)((Builder)builder()
      .setFile(file))
      .setTailerListener(listener)
      .setDelayDuration(Duration.ofMillis(delayMillis))
      .setTailFromEnd(end)
      .setBufferSize(bufferSize))
      .get(); }
  
  @Deprecated
  public Tailer(File file, Charset charset, TailerListener listener, long delayMillis, boolean end, boolean reOpen, int bufSize) { this(new TailablePath(file.toPath(), new java.nio.file.LinkOption[0], null), charset, listener, Duration.ofMillis(delayMillis), end, reOpen, bufSize); }
  
  @Deprecated
  public Tailer(File file, TailerListener listener) { this(file, listener, 1000L); }
  
  @Deprecated
  public Tailer(File file, TailerListener listener, long delayMillis) { this(file, listener, delayMillis, false); }
  
  @Deprecated
  public Tailer(File file, TailerListener listener, long delayMillis, boolean end) { this(file, listener, delayMillis, end, 8192); }
  
  @Deprecated
  public Tailer(File file, TailerListener listener, long delayMillis, boolean end, boolean reOpen) { this(file, listener, delayMillis, end, reOpen, 8192); }
  
  @Deprecated
  public Tailer(File file, TailerListener listener, long delayMillis, boolean end, boolean reOpen, int bufferSize) { this(file, DEFAULT_CHARSET, listener, delayMillis, end, reOpen, bufferSize); }
  
  @Deprecated
  public Tailer(File file, TailerListener listener, long delayMillis, boolean end, int bufferSize) { this(file, listener, delayMillis, end, false, bufferSize); }
  
  private Tailer(Tailable tailable, Charset charset, TailerListener listener, Duration delayDuration, boolean end, boolean reOpen, int bufferSize) {
    this.run = true;
    this.tailable = (Tailable)Objects.requireNonNull(tailable, "tailable");
    this.listener = (TailerListener)Objects.requireNonNull(listener, "listener");
    this.delayDuration = delayDuration;
    this.tailAtEnd = end;
    this.inbuf = IOUtils.byteArray(bufferSize);
    listener.init(this);
    this.reOpen = reOpen;
    this.charset = charset;
  }
  
  public void close() { this.run = false; }
  
  @Deprecated
  public long getDelay() { return this.delayDuration.toMillis(); }
  
  public Duration getDelayDuration() { return this.delayDuration; }
  
  public File getFile() {
    if (this.tailable instanceof TailablePath)
      return ((TailablePath)this.tailable).getPath().toFile(); 
    throw new IllegalStateException("Cannot extract java.io.File from " + this.tailable.getClass().getName());
  }
  
  protected boolean getRun() { return this.run; }
  
  public Tailable getTailable() { return this.tailable; }
  
  private long readLines(RandomAccessResourceBridge reader) throws IOException {
    ByteArrayOutputStream lineBuf = new ByteArrayOutputStream(64);
    try {
      long pos = reader.getPointer();
      long rePos = pos;
      boolean seenCR = false;
      int num;
      while (getRun() && (num = reader.read(this.inbuf)) != -1) {
        for (int i = 0; i < num; i++) {
          byte ch = this.inbuf[i];
          switch (ch) {
            case 10:
              seenCR = false;
              this.listener.handle(new String(lineBuf.toByteArray(), this.charset));
              lineBuf.reset();
              rePos = pos + i + 1L;
              break;
            case 13:
              if (seenCR)
                lineBuf.write(13); 
              seenCR = true;
              break;
            default:
              if (seenCR) {
                seenCR = false;
                this.listener.handle(new String(lineBuf.toByteArray(), this.charset));
                lineBuf.reset();
                rePos = pos + i + 1L;
              } 
              lineBuf.write(ch);
              break;
          } 
        } 
        pos = reader.getPointer();
      } 
      reader.seek(rePos);
      if (this.listener instanceof TailerListenerAdapter)
        ((TailerListenerAdapter)this.listener).endOfFileReached(); 
      long l = rePos;
      lineBuf.close();
      return l;
    } catch (Throwable throwable) {
      try {
        lineBuf.close();
      } catch (Throwable throwable1) {
        throwable.addSuppressed(throwable1);
      } 
      throw throwable;
    } 
  }
  
  public void run() {
    reader = null;
    try {
      last = FileTimes.EPOCH;
      long position = 0L;
      while (getRun() && reader == null) {
        try {
          reader = this.tailable.getRandomAccess("r");
        } catch (FileNotFoundException e) {
          this.listener.fileNotFound();
        } 
        if (reader == null) {
          ThreadUtils.sleep(this.delayDuration);
          continue;
        } 
        position = this.tailAtEnd ? this.tailable.size() : 0L;
        last = this.tailable.lastModifiedFileTime();
        reader.seek(position);
      } 
      while (getRun()) {
        boolean newer = this.tailable.isNewer(last);
        long length = this.tailable.size();
        if (length < position) {
          this.listener.fileRotated();
          try {
            RandomAccessResourceBridge save = reader;
            try {
              reader = this.tailable.getRandomAccess("r");
              try {
                readLines(save);
              } catch (IOException ioe) {
                this.listener.handle(ioe);
              } 
              position = 0L;
              if (save != null)
                save.close(); 
              continue;
            } catch (Throwable throwable) {
              if (save != null)
                try {
                  save.close();
                } catch (Throwable throwable1) {
                  throwable.addSuppressed(throwable1);
                }  
              throw throwable;
            } 
          } catch (FileNotFoundException e) {
            this.listener.fileNotFound();
            ThreadUtils.sleep(this.delayDuration);
            continue;
          } 
        } 
        if (length > position) {
          position = readLines(reader);
          last = this.tailable.lastModifiedFileTime();
        } else if (newer) {
          position = 0L;
          reader.seek(position);
          position = readLines(reader);
          last = this.tailable.lastModifiedFileTime();
        } 
        if (this.reOpen && reader != null)
          reader.close(); 
        ThreadUtils.sleep(this.delayDuration);
        if (getRun() && this.reOpen) {
          reader = this.tailable.getRandomAccess("r");
          reader.seek(position);
        } 
      } 
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      this.listener.handle(e);
    } catch (Exception e) {
      this.listener.handle(e);
    } finally {
      try {
        IOUtils.close(reader);
      } catch (IOException e) {
        this.listener.handle(e);
      } 
      close();
    } 
  }
  
  @Deprecated
  public void stop() { close(); }
}
