package org.slf4j.impl;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.slf4j.ILoggerFactory;
import org.slf4j.Logger;
import org.slf4j.helpers.Util;

public class Reload4jLoggerFactory implements ILoggerFactory {
  private static final String LOG4J_DELEGATION_LOOP_URL = "http://www.slf4j.org/codes.html#log4jDelegationLoop";
  
  ConcurrentMap<String, Logger> loggerMap;
  
  static  {
    try {
      Class.forName("org.apache.log4j.Log4jLoggerFactory");
      part1 = "Detected both log4j-over-slf4j.jar AND bound slf4j-reload4j.jar on the class path, preempting StackOverflowError. ";
      String part2 = "See also http://www.slf4j.org/codes.html#log4jDelegationLoop for more details.";
      Util.report(part1);
      Util.report(part2);
      throw new IllegalStateException(part1 + part2);
    } catch (ClassNotFoundException part1) {
      return;
    } 
  }
  
  public Reload4jLoggerFactory() {
    this.loggerMap = new ConcurrentHashMap();
    LogManager.getRootLogger();
  }
  
  public Logger getLogger(String name) {
    Logger log4jLogger;
    Logger slf4jLogger = (Logger)this.loggerMap.get(name);
    if (slf4jLogger != null)
      return slf4jLogger; 
    if (name.equalsIgnoreCase("ROOT")) {
      log4jLogger = LogManager.getRootLogger();
    } else {
      log4jLogger = LogManager.getLogger(name);
    } 
    Reload4jLoggerAdapter reload4jLoggerAdapter = new Reload4jLoggerAdapter(log4jLogger);
    Logger oldInstance = (Logger)this.loggerMap.putIfAbsent(name, reload4jLoggerAdapter);
    return (oldInstance == null) ? reload4jLoggerAdapter : oldInstance;
  }
}
