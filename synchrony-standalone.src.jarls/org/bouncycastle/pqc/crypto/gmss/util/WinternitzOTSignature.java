package org.bouncycastle.pqc.crypto.gmss.util;

import org.bouncycastle.crypto.Digest;

public class WinternitzOTSignature {
  private Digest messDigestOTS;
  
  private int mdsize;
  
  private int keysize;
  
  private byte[][] privateKeyOTS;
  
  private int w;
  
  private GMSSRandom gmssRandom;
  
  private int messagesize;
  
  private int checksumsize;
  
  public WinternitzOTSignature(byte[] paramArrayOfByte, Digest paramDigest, int paramInt) {
    this.w = paramInt;
    this.messDigestOTS = paramDigest;
    this.gmssRandom = new GMSSRandom(this.messDigestOTS);
    this.mdsize = this.messDigestOTS.getDigestSize();
    this.messagesize = ((this.mdsize << 3) + paramInt - 1) / paramInt;
    this.checksumsize = getLog((this.messagesize << paramInt) + 1);
    this.keysize = this.messagesize + (this.checksumsize + paramInt - 1) / paramInt;
    this.privateKeyOTS = new byte[this.keysize][];
    byte[] arrayOfByte = new byte[this.mdsize];
    System.arraycopy(paramArrayOfByte, 0, arrayOfByte, 0, arrayOfByte.length);
    for (byte b = 0; b < this.keysize; b++)
      this.privateKeyOTS[b] = this.gmssRandom.nextSeed(arrayOfByte); 
  }
  
  public byte[][] getPrivateKey() { return this.privateKeyOTS; }
  
  public byte[] getPublicKey() {
    byte[] arrayOfByte1 = new byte[this.keysize * this.mdsize];
    int i = 0;
    int j = (1 << this.w) - 1;
    for (byte b = 0; b < this.keysize; b++) {
      hashPrivateKeyBlock(b, j, arrayOfByte1, i);
      i += this.mdsize;
    } 
    this.messDigestOTS.update(arrayOfByte1, 0, arrayOfByte1.length);
    byte[] arrayOfByte2 = new byte[this.mdsize];
    this.messDigestOTS.doFinal(arrayOfByte2, 0);
    return arrayOfByte2;
  }
  
  public byte[] getSignature(byte[] paramArrayOfByte) {
    byte[] arrayOfByte1 = new byte[this.keysize * this.mdsize];
    byte[] arrayOfByte2 = new byte[this.mdsize];
    int i = 0;
    int j = 0;
    int k = 0;
    this.messDigestOTS.update(paramArrayOfByte, 0, paramArrayOfByte.length);
    this.messDigestOTS.doFinal(arrayOfByte2, 0);
    if (8 % this.w == 0) {
      int m = 8 / this.w;
      int n = (1 << this.w) - 1;
      int i1;
      for (i1 = 0; i1 < arrayOfByte2.length; i1++) {
        for (byte b = 0; b < m; b++) {
          k = arrayOfByte2[i1] & n;
          j += k;
          hashPrivateKeyBlock(i, k, arrayOfByte1, i * this.mdsize);
          arrayOfByte2[i1] = (byte)(arrayOfByte2[i1] >>> this.w);
          i++;
        } 
      } 
      j = (this.messagesize << this.w) - j;
      for (i1 = 0; i1 < this.checksumsize; i1 += this.w) {
        k = j & n;
        hashPrivateKeyBlock(i, k, arrayOfByte1, i * this.mdsize);
        j >>>= this.w;
        i++;
      } 
    } else if (this.w < 8) {
      int m = this.mdsize / this.w;
      int n = (1 << this.w) - 1;
      byte b = 0;
      int i1;
      for (i1 = 0; i1 < m; i1++) {
        long l1 = 0L;
        byte b1;
        for (b1 = 0; b1 < this.w; b1++) {
          l1 ^= ((arrayOfByte2[b] & 0xFF) << b1 << 3);
          b++;
        } 
        for (b1 = 0; b1 < 8; b1++) {
          k = (int)l1 & n;
          j += k;
          hashPrivateKeyBlock(i, k, arrayOfByte1, i * this.mdsize);
          l1 >>>= this.w;
          i++;
        } 
      } 
      m = this.mdsize % this.w;
      long l = 0L;
      for (i1 = 0; i1 < m; i1++) {
        l ^= ((arrayOfByte2[b] & 0xFF) << i1 << 3);
        b++;
      } 
      m <<= 3;
      for (i1 = 0; i1 < m; i1 += this.w) {
        k = (int)l & n;
        j += k;
        hashPrivateKeyBlock(i, k, arrayOfByte1, i * this.mdsize);
        l >>>= this.w;
        i++;
      } 
      j = (this.messagesize << this.w) - j;
      for (i1 = 0; i1 < this.checksumsize; i1 += this.w) {
        k = j & n;
        hashPrivateKeyBlock(i, k, arrayOfByte1, i * this.mdsize);
        j >>>= this.w;
        i++;
      } 
    } else if (this.w < 57) {
      int m = (this.mdsize << 3) - this.w;
      int n = (1 << this.w) - 1;
      byte[] arrayOfByte = new byte[this.mdsize];
      int i1 = 0;
      while (i1 <= m) {
        byte b1 = i1 >>> 3;
        byte b2 = i1 % 8;
        i1 += this.w;
        int i4 = i1 + 7 >>> 3;
        long l1 = 0L;
        byte b3 = 0;
        for (byte b4 = b1; b4 < i4; b4++) {
          l1 ^= ((arrayOfByte2[b4] & 0xFF) << b3 << 3);
          b3++;
        } 
        l1 >>>= b2;
        long l2 = l1 & n;
        j = (int)(j + l2);
        System.arraycopy(this.privateKeyOTS[i], 0, arrayOfByte, 0, this.mdsize);
        while (l2 > 0L) {
          this.messDigestOTS.update(arrayOfByte, 0, arrayOfByte.length);
          this.messDigestOTS.doFinal(arrayOfByte, 0);
          l2--;
        } 
        System.arraycopy(arrayOfByte, 0, arrayOfByte1, i * this.mdsize, this.mdsize);
        i++;
      } 
      int i2 = i1 >>> 3;
      if (i2 < this.mdsize) {
        int i4 = i1 % 8;
        long l1 = 0L;
        byte b = 0;
        for (int i5 = i2; i5 < this.mdsize; i5++) {
          l1 ^= ((arrayOfByte2[i5] & 0xFF) << b << 3);
          b++;
        } 
        l1 >>>= i4;
        long l2 = l1 & n;
        j = (int)(j + l2);
        System.arraycopy(this.privateKeyOTS[i], 0, arrayOfByte, 0, this.mdsize);
        while (l2 > 0L) {
          this.messDigestOTS.update(arrayOfByte, 0, arrayOfByte.length);
          this.messDigestOTS.doFinal(arrayOfByte, 0);
          l2--;
        } 
        System.arraycopy(arrayOfByte, 0, arrayOfByte1, i * this.mdsize, this.mdsize);
        i++;
      } 
      j = (this.messagesize << this.w) - j;
      int i3;
      for (i3 = 0; i3 < this.checksumsize; i3 += this.w) {
        long l = (j & n);
        System.arraycopy(this.privateKeyOTS[i], 0, arrayOfByte, 0, this.mdsize);
        while (l > 0L) {
          this.messDigestOTS.update(arrayOfByte, 0, arrayOfByte.length);
          this.messDigestOTS.doFinal(arrayOfByte, 0);
          l--;
        } 
        System.arraycopy(arrayOfByte, 0, arrayOfByte1, i * this.mdsize, this.mdsize);
        j >>>= this.w;
        i++;
      } 
    } 
    return arrayOfByte1;
  }
  
  public int getLog(int paramInt) {
    byte b1 = 1;
    byte b2 = 2;
    while (b2 < paramInt) {
      b2 <<= 1;
      b1++;
    } 
    return b1;
  }
  
  private void hashPrivateKeyBlock(int paramInt1, int paramInt2, byte[] paramArrayOfByte, int paramInt3) {
    if (paramInt2 < 1) {
      System.arraycopy(this.privateKeyOTS[paramInt1], 0, paramArrayOfByte, paramInt3, this.mdsize);
    } else {
      this.messDigestOTS.update(this.privateKeyOTS[paramInt1], 0, this.mdsize);
      this.messDigestOTS.doFinal(paramArrayOfByte, paramInt3);
      while (--paramInt2 > 0) {
        this.messDigestOTS.update(paramArrayOfByte, paramInt3, this.mdsize);
        this.messDigestOTS.doFinal(paramArrayOfByte, paramInt3);
      } 
    } 
  }
}
