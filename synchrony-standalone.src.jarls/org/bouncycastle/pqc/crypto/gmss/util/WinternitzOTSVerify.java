package org.bouncycastle.pqc.crypto.gmss.util;

import org.bouncycastle.crypto.Digest;

public class WinternitzOTSVerify {
  private Digest messDigestOTS;
  
  private int mdsize;
  
  private int w;
  
  public WinternitzOTSVerify(Digest paramDigest, int paramInt) {
    this.w = paramInt;
    this.messDigestOTS = paramDigest;
    this.mdsize = this.messDigestOTS.getDigestSize();
  }
  
  public int getSignatureLength() {
    int i = this.messDigestOTS.getDigestSize();
    int j = ((i << 3) + this.w - 1) / this.w;
    int k = getLog((j << this.w) + 1);
    j += (k + this.w - 1) / this.w;
    return i * j;
  }
  
  public byte[] Verify(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2) {
    byte[] arrayOfByte1 = new byte[this.mdsize];
    this.messDigestOTS.update(paramArrayOfByte1, 0, paramArrayOfByte1.length);
    this.messDigestOTS.doFinal(arrayOfByte1, 0);
    int i = ((this.mdsize << 3) + this.w - 1) / this.w;
    int j = getLog((i << this.w) + 1);
    int k = i + (j + this.w - 1) / this.w;
    int m = this.mdsize * k;
    if (m != paramArrayOfByte2.length)
      return null; 
    byte[] arrayOfByte2 = new byte[m];
    int n = 0;
    int i1 = 0;
    if (8 % this.w == 0) {
      int i2 = 8 / this.w;
      int i3 = (1 << this.w) - 1;
      int i4;
      for (i4 = 0; i4 < arrayOfByte1.length; i4++) {
        for (byte b = 0; b < i2; b++) {
          byte b1 = arrayOfByte1[i4] & i3;
          n += b1;
          hashSignatureBlock(paramArrayOfByte2, i1 * this.mdsize, i3 - b1, arrayOfByte2, i1 * this.mdsize);
          arrayOfByte1[i4] = (byte)(arrayOfByte1[i4] >>> this.w);
          i1++;
        } 
      } 
      n = (i << this.w) - n;
      for (i4 = 0; i4 < j; i4 += this.w) {
        int i5 = n & i3;
        hashSignatureBlock(paramArrayOfByte2, i1 * this.mdsize, i3 - i5, arrayOfByte2, i1 * this.mdsize);
        n >>>= this.w;
        i1++;
      } 
    } else if (this.w < 8) {
      int i2 = this.mdsize / this.w;
      int i3 = (1 << this.w) - 1;
      byte b = 0;
      int i4;
      for (i4 = 0; i4 < i2; i4++) {
        long l1 = 0L;
        byte b1;
        for (b1 = 0; b1 < this.w; b1++) {
          l1 ^= ((arrayOfByte1[b] & 0xFF) << b1 << 3);
          b++;
        } 
        for (b1 = 0; b1 < 8; b1++) {
          int i5 = (int)(l1 & i3);
          n += i5;
          hashSignatureBlock(paramArrayOfByte2, i1 * this.mdsize, i3 - i5, arrayOfByte2, i1 * this.mdsize);
          l1 >>>= this.w;
          i1++;
        } 
      } 
      i2 = this.mdsize % this.w;
      long l = 0L;
      for (i4 = 0; i4 < i2; i4++) {
        l ^= ((arrayOfByte1[b] & 0xFF) << i4 << 3);
        b++;
      } 
      i2 <<= 3;
      for (i4 = 0; i4 < i2; i4 += this.w) {
        int i5 = (int)(l & i3);
        n += i5;
        hashSignatureBlock(paramArrayOfByte2, i1 * this.mdsize, i3 - i5, arrayOfByte2, i1 * this.mdsize);
        l >>>= this.w;
        i1++;
      } 
      n = (i << this.w) - n;
      for (i4 = 0; i4 < j; i4 += this.w) {
        int i5 = n & i3;
        hashSignatureBlock(paramArrayOfByte2, i1 * this.mdsize, i3 - i5, arrayOfByte2, i1 * this.mdsize);
        n >>>= this.w;
        i1++;
      } 
    } else if (this.w < 57) {
      int i2 = (this.mdsize << 3) - this.w;
      int i3 = (1 << this.w) - 1;
      byte[] arrayOfByte = new byte[this.mdsize];
      int i4 = 0;
      while (i4 <= i2) {
        byte b1 = i4 >>> 3;
        byte b2 = i4 % 8;
        i4 += this.w;
        int i7 = i4 + 7 >>> 3;
        long l1 = 0L;
        byte b3 = 0;
        for (byte b4 = b1; b4 < i7; b4++) {
          l1 ^= ((arrayOfByte1[b4] & 0xFF) << b3 << 3);
          b3++;
        } 
        l1 >>>= b2;
        long l2 = l1 & i3;
        n = (int)(n + l2);
        System.arraycopy(paramArrayOfByte2, i1 * this.mdsize, arrayOfByte, 0, this.mdsize);
        while (l2 < i3) {
          this.messDigestOTS.update(arrayOfByte, 0, arrayOfByte.length);
          this.messDigestOTS.doFinal(arrayOfByte, 0);
          l2++;
        } 
        System.arraycopy(arrayOfByte, 0, arrayOfByte2, i1 * this.mdsize, this.mdsize);
        i1++;
      } 
      int i5 = i4 >>> 3;
      if (i5 < this.mdsize) {
        int i7 = i4 % 8;
        long l1 = 0L;
        byte b = 0;
        for (int i8 = i5; i8 < this.mdsize; i8++) {
          l1 ^= ((arrayOfByte1[i8] & 0xFF) << b << 3);
          b++;
        } 
        l1 >>>= i7;
        long l2 = l1 & i3;
        n = (int)(n + l2);
        System.arraycopy(paramArrayOfByte2, i1 * this.mdsize, arrayOfByte, 0, this.mdsize);
        while (l2 < i3) {
          this.messDigestOTS.update(arrayOfByte, 0, arrayOfByte.length);
          this.messDigestOTS.doFinal(arrayOfByte, 0);
          l2++;
        } 
        System.arraycopy(arrayOfByte, 0, arrayOfByte2, i1 * this.mdsize, this.mdsize);
        i1++;
      } 
      n = (i << this.w) - n;
      int i6;
      for (i6 = 0; i6 < j; i6 += this.w) {
        long l = (n & i3);
        System.arraycopy(paramArrayOfByte2, i1 * this.mdsize, arrayOfByte, 0, this.mdsize);
        while (l < i3) {
          this.messDigestOTS.update(arrayOfByte, 0, arrayOfByte.length);
          this.messDigestOTS.doFinal(arrayOfByte, 0);
          l++;
        } 
        System.arraycopy(arrayOfByte, 0, arrayOfByte2, i1 * this.mdsize, this.mdsize);
        n >>>= this.w;
        i1++;
      } 
    } 
    this.messDigestOTS.update(arrayOfByte2, 0, arrayOfByte2.length);
    byte[] arrayOfByte3 = new byte[this.mdsize];
    this.messDigestOTS.doFinal(arrayOfByte3, 0);
    return arrayOfByte3;
  }
  
  public int getLog(int paramInt) {
    byte b1 = 1;
    byte b2 = 2;
    while (b2 < paramInt) {
      b2 <<= 1;
      b1++;
    } 
    return b1;
  }
  
  private void hashSignatureBlock(byte[] paramArrayOfByte1, int paramInt1, int paramInt2, byte[] paramArrayOfByte2, int paramInt3) {
    if (paramInt2 < 1) {
      System.arraycopy(paramArrayOfByte1, paramInt1, paramArrayOfByte2, paramInt3, this.mdsize);
    } else {
      this.messDigestOTS.update(paramArrayOfByte1, paramInt1, this.mdsize);
      this.messDigestOTS.doFinal(paramArrayOfByte2, paramInt3);
      while (--paramInt2 > 0) {
        this.messDigestOTS.update(paramArrayOfByte2, paramInt3, this.mdsize);
        this.messDigestOTS.doFinal(paramArrayOfByte2, paramInt3);
      } 
    } 
  }
}
