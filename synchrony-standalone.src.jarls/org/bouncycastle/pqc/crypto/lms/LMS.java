package org.bouncycastle.pqc.crypto.lms;

import org.bouncycastle.crypto.Digest;

class LMS {
  static final short D_LEAF = -32126;
  
  static final short D_INTR = -31869;
  
  public static LMSPrivateKeyParameters generateKeys(LMSigParameters paramLMSigParameters, LMOtsParameters paramLMOtsParameters, int paramInt, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2) throws IllegalArgumentException {
    if (paramArrayOfByte2 == null || paramArrayOfByte2.length < paramLMSigParameters.getM())
      throw new IllegalArgumentException("root seed is less than " + paramLMSigParameters.getM()); 
    int i = 1 << paramLMSigParameters.getH();
    return new LMSPrivateKeyParameters(paramLMSigParameters, paramLMOtsParameters, paramInt, paramArrayOfByte1, i, paramArrayOfByte2);
  }
  
  public static LMSSignature generateSign(LMSPrivateKeyParameters paramLMSPrivateKeyParameters, byte[] paramArrayOfByte) {
    LMSContext lMSContext = paramLMSPrivateKeyParameters.generateLMSContext();
    lMSContext.update(paramArrayOfByte, 0, paramArrayOfByte.length);
    return generateSign(lMSContext);
  }
  
  public static LMSSignature generateSign(LMSContext paramLMSContext) {
    LMOtsSignature lMOtsSignature = LM_OTS.lm_ots_generate_signature(paramLMSContext.getPrivateKey(), paramLMSContext.getQ(), paramLMSContext.getC());
    return new LMSSignature(paramLMSContext.getPrivateKey().getQ(), lMOtsSignature, paramLMSContext.getSigParams(), paramLMSContext.getPath());
  }
  
  public static boolean verifySignature(LMSPublicKeyParameters paramLMSPublicKeyParameters, LMSSignature paramLMSSignature, byte[] paramArrayOfByte) {
    LMSContext lMSContext = paramLMSPublicKeyParameters.generateOtsContext(paramLMSSignature);
    LmsUtils.byteArray(paramArrayOfByte, lMSContext);
    return verifySignature(paramLMSPublicKeyParameters, lMSContext);
  }
  
  public static boolean verifySignature(LMSPublicKeyParameters paramLMSPublicKeyParameters, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2) {
    LMSContext lMSContext = paramLMSPublicKeyParameters.generateLMSContext(paramArrayOfByte1);
    LmsUtils.byteArray(paramArrayOfByte2, lMSContext);
    return verifySignature(paramLMSPublicKeyParameters, lMSContext);
  }
  
  public static boolean verifySignature(LMSPublicKeyParameters paramLMSPublicKeyParameters, LMSContext paramLMSContext) {
    LMSSignature lMSSignature = (LMSSignature)paramLMSContext.getSignature();
    LMSigParameters lMSigParameters = lMSSignature.getParameter();
    int i = lMSigParameters.getH();
    byte[][] arrayOfByte = lMSSignature.getY();
    byte[] arrayOfByte1 = LM_OTS.lm_ots_validate_signature_calculate(paramLMSContext);
    int j = (1 << i) + lMSSignature.getQ();
    byte[] arrayOfByte2 = paramLMSPublicKeyParameters.getI();
    Digest digest = DigestUtil.getDigest(lMSigParameters.getDigestOID());
    byte[] arrayOfByte3 = new byte[digest.getDigestSize()];
    digest.update(arrayOfByte2, 0, arrayOfByte2.length);
    LmsUtils.u32str(j, digest);
    LmsUtils.u16str((short)-32126, digest);
    digest.update(arrayOfByte1, 0, arrayOfByte1.length);
    digest.doFinal(arrayOfByte3, 0);
    for (byte b = 0; j > 1; b++) {
      if ((j & true) == 1) {
        digest.update(arrayOfByte2, 0, arrayOfByte2.length);
        LmsUtils.u32str(j / 2, digest);
        LmsUtils.u16str((short)-31869, digest);
        digest.update(arrayOfByte[b], 0, arrayOfByte[b].length);
        digest.update(arrayOfByte3, 0, arrayOfByte3.length);
        digest.doFinal(arrayOfByte3, 0);
      } else {
        digest.update(arrayOfByte2, 0, arrayOfByte2.length);
        LmsUtils.u32str(j / 2, digest);
        LmsUtils.u16str((short)-31869, digest);
        digest.update(arrayOfByte3, 0, arrayOfByte3.length);
        digest.update(arrayOfByte[b], 0, arrayOfByte[b].length);
        digest.doFinal(arrayOfByte3, 0);
      } 
      j /= 2;
    } 
    byte[] arrayOfByte4 = arrayOfByte3;
    return paramLMSPublicKeyParameters.matchesT1(arrayOfByte4);
  }
}
