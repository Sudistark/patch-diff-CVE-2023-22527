package org.bouncycastle.pqc.crypto.xmss;

import java.io.IOException;
import org.bouncycastle.util.Encodable;
import org.bouncycastle.util.Pack;

public final class XMSSSignature extends XMSSReducedSignature implements XMSSStoreableObjectInterface, Encodable {
  private final int index;
  
  private final byte[] random;
  
  private XMSSSignature(Builder paramBuilder) {
    super(paramBuilder);
    this.index = Builder.access$000(paramBuilder);
    int i = getParams().getTreeDigestSize();
    byte[] arrayOfByte = Builder.access$100(paramBuilder);
    if (arrayOfByte != null) {
      if (arrayOfByte.length != i)
        throw new IllegalArgumentException("size of random needs to be equal to size of digest"); 
      this.random = arrayOfByte;
    } else {
      this.random = new byte[i];
    } 
  }
  
  public byte[] getEncoded() throws IOException { return toByteArray(); }
  
  public byte[] toByteArray() throws IOException {
    int i = getParams().getTreeDigestSize();
    int j = 4;
    int k = i;
    int m = getParams().getWOTSPlus().getParams().getLen() * i;
    int n = getParams().getHeight() * i;
    int i1 = j + k + m + n;
    byte[] arrayOfByte = new byte[i1];
    int i2 = 0;
    Pack.intToBigEndian(this.index, arrayOfByte, i2);
    i2 += j;
    XMSSUtil.copyBytesAtOffset(arrayOfByte, this.random, i2);
    i2 += k;
    byte[][] arrayOfByte1 = getWOTSPlusSignature().toByteArray();
    byte b;
    for (b = 0; b < arrayOfByte1.length; b++) {
      XMSSUtil.copyBytesAtOffset(arrayOfByte, arrayOfByte1[b], i2);
      i2 += i;
    } 
    for (b = 0; b < getAuthPath().size(); b++) {
      byte[] arrayOfByte2 = ((XMSSNode)getAuthPath().get(b)).getValue();
      XMSSUtil.copyBytesAtOffset(arrayOfByte, arrayOfByte2, i2);
      i2 += i;
    } 
    return arrayOfByte;
  }
  
  public int getIndex() { return this.index; }
  
  public byte[] getRandom() throws IOException { return XMSSUtil.cloneArray(this.random); }
}
