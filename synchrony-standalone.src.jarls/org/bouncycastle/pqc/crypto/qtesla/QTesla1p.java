package org.bouncycastle.pqc.crypto.qtesla;

import java.security.SecureRandom;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Pack;

class QTesla1p {
  private static final int PARAM_N = 1024;
  
  private static final int PARAM_Q = 343576577;
  
  private static final int PARAM_Q_LOG = 29;
  
  private static final long PARAM_QINV = 2205847551L;
  
  private static final int PARAM_BARR_MULT = 3;
  
  private static final int PARAM_BARR_DIV = 30;
  
  private static final int PARAM_B = 524287;
  
  private static final int PARAM_B_BITS = 19;
  
  private static final int PARAM_S_BITS = 8;
  
  private static final int PARAM_K = 4;
  
  private static final int PARAM_H = 25;
  
  private static final int PARAM_D = 22;
  
  private static final int PARAM_GEN_A = 108;
  
  private static final int PARAM_KEYGEN_BOUND_E = 554;
  
  private static final int PARAM_E = 554;
  
  private static final int PARAM_KEYGEN_BOUND_S = 554;
  
  private static final int PARAM_S = 554;
  
  private static final int PARAM_R2_INVN = 13632409;
  
  private static final int CRYPTO_RANDOMBYTES = 32;
  
  private static final int CRYPTO_SEEDBYTES = 32;
  
  private static final int CRYPTO_C_BYTES = 32;
  
  private static final int HM_BYTES = 40;
  
  private static final int RADIX32 = 32;
  
  static final int CRYPTO_BYTES = 2592;
  
  static final int CRYPTO_SECRETKEYBYTES = 5224;
  
  static final int CRYPTO_PUBLICKEYBYTES = 14880;
  
  private static final int maskb1 = 1048575;
  
  private static int NBLOCKS_SHAKE = 56;
  
  private static int BPLUS1BYTES = 3;
  
  static int generateKeyPair(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, SecureRandom paramSecureRandom) {
    byte b1 = 0;
    byte[] arrayOfByte1 = new byte[32];
    byte[] arrayOfByte2 = new byte[224];
    int[] arrayOfInt1 = new int[1024];
    int[] arrayOfInt2 = new int[4096];
    int[] arrayOfInt3 = new int[4096];
    int[] arrayOfInt4 = new int[4096];
    int[] arrayOfInt5 = new int[1024];
    paramSecureRandom.nextBytes(arrayOfByte1);
    HashUtils.secureHashAlgorithmKECCAK128(arrayOfByte2, 0, 224, arrayOfByte1, 0, 32);
    byte b2;
    for (b2 = 0; b2 < 4; b2++) {
      do {
        Gaussian.sample_gauss_poly(++b1, arrayOfByte2, b2 * 32, arrayOfInt2, b2 * 'Ѐ');
      } while (checkPolynomial(arrayOfInt2, b2 * 'Ѐ', 554));
    } 
    do {
      Gaussian.sample_gauss_poly(++b1, arrayOfByte2, 128, arrayOfInt1, 0);
    } while (checkPolynomial(arrayOfInt1, 0, 554));
    QTesla1PPolynomial.poly_uniform(arrayOfInt3, arrayOfByte2, 160);
    QTesla1PPolynomial.poly_ntt(arrayOfInt5, arrayOfInt1);
    for (b2 = 0; b2 < 4; b2++) {
      QTesla1PPolynomial.poly_mul(arrayOfInt4, b2 * 'Ѐ', arrayOfInt3, b2 * 'Ѐ', arrayOfInt5);
      QTesla1PPolynomial.poly_add_correct(arrayOfInt4, b2 * 'Ѐ', arrayOfInt4, b2 * 'Ѐ', arrayOfInt2, b2 * 'Ѐ');
    } 
    encodePublicKey(paramArrayOfByte1, arrayOfInt4, arrayOfByte2, 160);
    encodePrivateKey(paramArrayOfByte2, arrayOfInt1, arrayOfInt2, arrayOfByte2, 160, paramArrayOfByte1);
    return 0;
  }
  
  static int generateSignature(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt1, int paramInt2, byte[] paramArrayOfByte3, SecureRandom paramSecureRandom) {
    byte[] arrayOfByte1 = new byte[32];
    byte[] arrayOfByte2 = new byte[32];
    byte[] arrayOfByte3 = new byte[144];
    int[] arrayOfInt1 = new int[25];
    short[] arrayOfShort = new short[25];
    int[] arrayOfInt2 = new int[1024];
    int[] arrayOfInt3 = new int[1024];
    int[] arrayOfInt4 = new int[1024];
    int[] arrayOfInt5 = new int[1024];
    int[] arrayOfInt6 = new int[4096];
    int[] arrayOfInt7 = new int[4096];
    int[] arrayOfInt8 = new int[4096];
    byte b = 0;
    boolean bool = false;
    System.arraycopy(paramArrayOfByte3, 5152, arrayOfByte3, 0, 32);
    byte[] arrayOfByte4 = new byte[32];
    paramSecureRandom.nextBytes(arrayOfByte4);
    System.arraycopy(arrayOfByte4, 0, arrayOfByte3, 32, 32);
    HashUtils.secureHashAlgorithmKECCAK128(arrayOfByte3, 64, 40, paramArrayOfByte2, 0, paramInt2);
    HashUtils.secureHashAlgorithmKECCAK128(arrayOfByte2, 0, 32, arrayOfByte3, 0, arrayOfByte3.length - 40);
    System.arraycopy(paramArrayOfByte3, 5184, arrayOfByte3, arrayOfByte3.length - 40, 40);
    QTesla1PPolynomial.poly_uniform(arrayOfInt8, paramArrayOfByte3, 5120);
    while (true) {
      sample_y(arrayOfInt2, arrayOfByte2, 0, ++b);
      QTesla1PPolynomial.poly_ntt(arrayOfInt3, arrayOfInt2);
      byte b1;
      for (b1 = 0; b1 < 4; b1++)
        QTesla1PPolynomial.poly_mul(arrayOfInt6, b1 * 'Ѐ', arrayOfInt8, b1 * 'Ѐ', arrayOfInt3); 
      hashFunction(arrayOfByte1, 0, arrayOfInt6, arrayOfByte3, 64);
      encodeC(arrayOfInt1, arrayOfShort, arrayOfByte1, 0);
      QTesla1PPolynomial.sparse_mul8(arrayOfInt4, 0, paramArrayOfByte3, 0, arrayOfInt1, arrayOfShort);
      QTesla1PPolynomial.poly_add(arrayOfInt5, arrayOfInt2, arrayOfInt4);
      if (testRejection(arrayOfInt5))
        continue; 
      for (b1 = 0; b1 < 4; b1++) {
        QTesla1PPolynomial.sparse_mul8(arrayOfInt7, b1 * 'Ѐ', paramArrayOfByte3, 'Ѐ' * (b1 + 1), arrayOfInt1, arrayOfShort);
        QTesla1PPolynomial.poly_sub(arrayOfInt6, b1 * 'Ѐ', arrayOfInt6, b1 * 'Ѐ', arrayOfInt7, b1 * 'Ѐ');
        bool = test_correctness(arrayOfInt6, b1 * 'Ѐ');
        if (bool)
          break; 
      } 
      if (bool)
        continue; 
      break;
    } 
    encodeSignature(paramArrayOfByte1, 0, arrayOfByte1, 0, arrayOfInt5);
    return 0;
  }
  
  static int verifying(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt1, int paramInt2, byte[] paramArrayOfByte3) {
    byte[] arrayOfByte1 = new byte[32];
    byte[] arrayOfByte2 = new byte[32];
    byte[] arrayOfByte3 = new byte[32];
    byte[] arrayOfByte4 = new byte[80];
    int[] arrayOfInt1 = new int[25];
    short[] arrayOfShort = new short[25];
    int[] arrayOfInt2 = new int[4096];
    int[] arrayOfInt3 = new int[4096];
    int[] arrayOfInt4 = new int[4096];
    int[] arrayOfInt5 = new int[4096];
    int[] arrayOfInt6 = new int[1024];
    int[] arrayOfInt7 = new int[1024];
    byte b = 0;
    if (paramInt2 != 2592)
      return -1; 
    decodeSignature(arrayOfByte1, arrayOfInt6, paramArrayOfByte2, paramInt1);
    if (testZ(arrayOfInt6))
      return -2; 
    decodePublicKey(arrayOfInt2, arrayOfByte3, 0, paramArrayOfByte3);
    HashUtils.secureHashAlgorithmKECCAK128(arrayOfByte4, 0, 40, paramArrayOfByte1, 0, paramArrayOfByte1.length);
    HashUtils.secureHashAlgorithmKECCAK128(arrayOfByte4, 40, 40, paramArrayOfByte3, 0, 14848);
    QTesla1PPolynomial.poly_uniform(arrayOfInt4, arrayOfByte3, 0);
    encodeC(arrayOfInt1, arrayOfShort, arrayOfByte1, 0);
    QTesla1PPolynomial.poly_ntt(arrayOfInt7, arrayOfInt6);
    for (b = 0; b < 4; b++) {
      QTesla1PPolynomial.sparse_mul32(arrayOfInt5, b * 'Ѐ', arrayOfInt2, b * 'Ѐ', arrayOfInt1, arrayOfShort);
      QTesla1PPolynomial.poly_mul(arrayOfInt3, b * 'Ѐ', arrayOfInt4, b * 'Ѐ', arrayOfInt7);
      QTesla1PPolynomial.poly_sub_reduce(arrayOfInt3, b * 'Ѐ', arrayOfInt3, b * 'Ѐ', arrayOfInt5, b * 'Ѐ');
    } 
    hashFunction(arrayOfByte2, 0, arrayOfInt3, arrayOfByte4, 0);
    return !memoryEqual(arrayOfByte1, 0, arrayOfByte2, 0, 32) ? -3 : 0;
  }
  
  static void encodePrivateKey(byte[] paramArrayOfByte1, int[] paramArrayOfInt1, int[] paramArrayOfInt2, byte[] paramArrayOfByte2, int paramInt, byte[] paramArrayOfByte3) {
    byte b = 0;
    char c2 = Character.MIN_VALUE;
    char c1;
    for (c1 = Character.MIN_VALUE; c1 < 'Ѐ'; c1++)
      paramArrayOfByte1[c2 + c1] = (byte)paramArrayOfInt1[c1]; 
    c2 += 1024;
    for (b = 0; b < 4; b++) {
      for (c1 = Character.MIN_VALUE; c1 < 'Ѐ'; c1++)
        paramArrayOfByte1[c2 + b * 'Ѐ' + c1] = (byte)paramArrayOfInt2[b * 'Ѐ' + c1]; 
    } 
    c2 += 'က';
    System.arraycopy(paramArrayOfByte2, paramInt, paramArrayOfByte1, c2, 64);
    c2 += '@';
    HashUtils.secureHashAlgorithmKECCAK128(paramArrayOfByte1, c2, 40, paramArrayOfByte3, 0, 14848);
    c2 += '(';
  }
  
  static void encodePublicKey(byte[] paramArrayOfByte1, int[] paramArrayOfInt, byte[] paramArrayOfByte2, int paramInt) {
    boolean bool = false;
    for (byte b = 0; b < '຀'; b += 29) {
      at(paramArrayOfByte1, b, 0, paramArrayOfInt[bool] | paramArrayOfInt[bool + true] << 29);
      at(paramArrayOfByte1, b, 1, paramArrayOfInt[bool + true] >> 3 | paramArrayOfInt[bool + 2] << 26);
      at(paramArrayOfByte1, b, 2, paramArrayOfInt[bool + 2] >> 6 | paramArrayOfInt[bool + 3] << 23);
      at(paramArrayOfByte1, b, 3, paramArrayOfInt[bool + 3] >> 9 | paramArrayOfInt[bool + 4] << 20);
      at(paramArrayOfByte1, b, 4, paramArrayOfInt[bool + 4] >> 12 | paramArrayOfInt[bool + 5] << 17);
      at(paramArrayOfByte1, b, 5, paramArrayOfInt[bool + 5] >> 15 | paramArrayOfInt[bool + 6] << 14);
      at(paramArrayOfByte1, b, 6, paramArrayOfInt[bool + 6] >> 18 | paramArrayOfInt[bool + 7] << 11);
      at(paramArrayOfByte1, b, 7, paramArrayOfInt[bool + 7] >> 21 | paramArrayOfInt[bool + 8] << 8);
      at(paramArrayOfByte1, b, 8, paramArrayOfInt[bool + 8] >> 24 | paramArrayOfInt[bool + 9] << 5);
      at(paramArrayOfByte1, b, 9, paramArrayOfInt[bool + 9] >> 27 | paramArrayOfInt[bool + 10] << 2 | paramArrayOfInt[bool + 11] << 31);
      at(paramArrayOfByte1, b, 10, paramArrayOfInt[bool + 11] >> 1 | paramArrayOfInt[bool + 12] << 28);
      at(paramArrayOfByte1, b, 11, paramArrayOfInt[bool + 12] >> 4 | paramArrayOfInt[bool + 13] << 25);
      at(paramArrayOfByte1, b, 12, paramArrayOfInt[bool + 13] >> 7 | paramArrayOfInt[bool + 14] << 22);
      at(paramArrayOfByte1, b, 13, paramArrayOfInt[bool + 14] >> 10 | paramArrayOfInt[bool + 15] << 19);
      at(paramArrayOfByte1, b, 14, paramArrayOfInt[bool + 15] >> 13 | paramArrayOfInt[bool + 16] << 16);
      at(paramArrayOfByte1, b, 15, paramArrayOfInt[bool + 16] >> 16 | paramArrayOfInt[bool + 17] << 13);
      at(paramArrayOfByte1, b, 16, paramArrayOfInt[bool + 17] >> 19 | paramArrayOfInt[bool + 18] << 10);
      at(paramArrayOfByte1, b, 17, paramArrayOfInt[bool + 18] >> 22 | paramArrayOfInt[bool + 19] << 7);
      at(paramArrayOfByte1, b, 18, paramArrayOfInt[bool + 19] >> 25 | paramArrayOfInt[bool + 20] << 4);
      at(paramArrayOfByte1, b, 19, paramArrayOfInt[bool + 20] >> 28 | paramArrayOfInt[bool + 21] << 1 | paramArrayOfInt[bool + 22] << 30);
      at(paramArrayOfByte1, b, 20, paramArrayOfInt[bool + 22] >> 2 | paramArrayOfInt[bool + 23] << 27);
      at(paramArrayOfByte1, b, 21, paramArrayOfInt[bool + 23] >> 5 | paramArrayOfInt[bool + 24] << 24);
      at(paramArrayOfByte1, b, 22, paramArrayOfInt[bool + 24] >> 8 | paramArrayOfInt[bool + 25] << 21);
      at(paramArrayOfByte1, b, 23, paramArrayOfInt[bool + 25] >> 11 | paramArrayOfInt[bool + 26] << 18);
      at(paramArrayOfByte1, b, 24, paramArrayOfInt[bool + 26] >> 14 | paramArrayOfInt[bool + 27] << 15);
      at(paramArrayOfByte1, b, 25, paramArrayOfInt[bool + 27] >> 17 | paramArrayOfInt[bool + 28] << 12);
      at(paramArrayOfByte1, b, 26, paramArrayOfInt[bool + 28] >> 20 | paramArrayOfInt[bool + 29] << 9);
      at(paramArrayOfByte1, b, 27, paramArrayOfInt[bool + 29] >> 23 | paramArrayOfInt[bool + 30] << 6);
      at(paramArrayOfByte1, b, 28, paramArrayOfInt[bool + 30] >> 26 | paramArrayOfInt[bool + 31] << 3);
      bool += true;
    } 
    System.arraycopy(paramArrayOfByte2, paramInt, paramArrayOfByte1, 14848, 32);
  }
  
  static void decodePublicKey(int[] paramArrayOfInt, byte[] paramArrayOfByte1, int paramInt, byte[] paramArrayOfByte2) {
    byte b = 0;
    byte[] arrayOfByte = paramArrayOfByte2;
    int i = 536870911;
    for (boolean bool = false; bool < 'က'; bool += true) {
      paramArrayOfInt[bool] = at(arrayOfByte, b, 0) & i;
      paramArrayOfInt[bool + true] = (at(arrayOfByte, b, 0) >>> 29 | at(arrayOfByte, b, 1) << 3) & i;
      paramArrayOfInt[bool + 2] = (at(arrayOfByte, b, 1) >>> 26 | at(arrayOfByte, b, 2) << 6) & i;
      paramArrayOfInt[bool + 3] = (at(arrayOfByte, b, 2) >>> 23 | at(arrayOfByte, b, 3) << 9) & i;
      paramArrayOfInt[bool + 4] = (at(arrayOfByte, b, 3) >>> 20 | at(arrayOfByte, b, 4) << 12) & i;
      paramArrayOfInt[bool + 5] = (at(arrayOfByte, b, 4) >>> 17 | at(arrayOfByte, b, 5) << 15) & i;
      paramArrayOfInt[bool + 6] = (at(arrayOfByte, b, 5) >>> 14 | at(arrayOfByte, b, 6) << 18) & i;
      paramArrayOfInt[bool + 7] = (at(arrayOfByte, b, 6) >>> 11 | at(arrayOfByte, b, 7) << 21) & i;
      paramArrayOfInt[bool + 8] = (at(arrayOfByte, b, 7) >>> 8 | at(arrayOfByte, b, 8) << 24) & i;
      paramArrayOfInt[bool + 9] = (at(arrayOfByte, b, 8) >>> 5 | at(arrayOfByte, b, 9) << 27) & i;
      paramArrayOfInt[bool + 10] = at(arrayOfByte, b, 9) >>> 2 & i;
      paramArrayOfInt[bool + 11] = (at(arrayOfByte, b, 9) >>> 31 | at(arrayOfByte, b, 10) << 1) & i;
      paramArrayOfInt[bool + 12] = (at(arrayOfByte, b, 10) >>> 28 | at(arrayOfByte, b, 11) << 4) & i;
      paramArrayOfInt[bool + 13] = (at(arrayOfByte, b, 11) >>> 25 | at(arrayOfByte, b, 12) << 7) & i;
      paramArrayOfInt[bool + 14] = (at(arrayOfByte, b, 12) >>> 22 | at(arrayOfByte, b, 13) << 10) & i;
      paramArrayOfInt[bool + 15] = (at(arrayOfByte, b, 13) >>> 19 | at(arrayOfByte, b, 14) << 13) & i;
      paramArrayOfInt[bool + 16] = (at(arrayOfByte, b, 14) >>> 16 | at(arrayOfByte, b, 15) << 16) & i;
      paramArrayOfInt[bool + 17] = (at(arrayOfByte, b, 15) >>> 13 | at(arrayOfByte, b, 16) << 19) & i;
      paramArrayOfInt[bool + 18] = (at(arrayOfByte, b, 16) >>> 10 | at(arrayOfByte, b, 17) << 22) & i;
      paramArrayOfInt[bool + 19] = (at(arrayOfByte, b, 17) >>> 7 | at(arrayOfByte, b, 18) << 25) & i;
      paramArrayOfInt[bool + 20] = (at(arrayOfByte, b, 18) >>> 4 | at(arrayOfByte, b, 19) << 28) & i;
      paramArrayOfInt[bool + 21] = at(arrayOfByte, b, 19) >>> 1 & i;
      paramArrayOfInt[bool + 22] = (at(arrayOfByte, b, 19) >>> 30 | at(arrayOfByte, b, 20) << 2) & i;
      paramArrayOfInt[bool + 23] = (at(arrayOfByte, b, 20) >>> 27 | at(arrayOfByte, b, 21) << 5) & i;
      paramArrayOfInt[bool + 24] = (at(arrayOfByte, b, 21) >>> 24 | at(arrayOfByte, b, 22) << 8) & i;
      paramArrayOfInt[bool + 25] = (at(arrayOfByte, b, 22) >>> 21 | at(arrayOfByte, b, 23) << 11) & i;
      paramArrayOfInt[bool + 26] = (at(arrayOfByte, b, 23) >>> 18 | at(arrayOfByte, b, 24) << 14) & i;
      paramArrayOfInt[bool + 27] = (at(arrayOfByte, b, 24) >>> 15 | at(arrayOfByte, b, 25) << 17) & i;
      paramArrayOfInt[bool + 28] = (at(arrayOfByte, b, 25) >>> 12 | at(arrayOfByte, b, 26) << 20) & i;
      paramArrayOfInt[bool + 29] = (at(arrayOfByte, b, 26) >>> 9 | at(arrayOfByte, b, 27) << 23) & i;
      paramArrayOfInt[bool + 30] = (at(arrayOfByte, b, 27) >>> 6 | at(arrayOfByte, b, 28) << 26) & i;
      paramArrayOfInt[bool + 31] = at(arrayOfByte, b, 28) >>> 3;
      b += 29;
    } 
    System.arraycopy(paramArrayOfByte2, 14848, paramArrayOfByte1, paramInt, 32);
  }
  
  private static boolean testZ(int[] paramArrayOfInt) {
    for (byte b = 0; b < 'Ѐ'; b++) {
      if (paramArrayOfInt[b] < -523733 || paramArrayOfInt[b] > 523733)
        return true; 
    } 
    return false;
  }
  
  static void encodeSignature(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, int[] paramArrayOfInt) {
    boolean bool = false;
    for (byte b = 0; b < 'ʀ'; b += 10) {
      at(paramArrayOfByte1, b, 0, paramArrayOfInt[bool] & 0xFFFFF | paramArrayOfInt[bool + true] << 20);
      at(paramArrayOfByte1, b, 1, paramArrayOfInt[bool + true] >>> 12 & 0xFF | (paramArrayOfInt[bool + 2] & 0xFFFFF) << 8 | paramArrayOfInt[bool + 3] << 28);
      at(paramArrayOfByte1, b, 2, paramArrayOfInt[bool + 3] >>> 4 & 0xFFFF | paramArrayOfInt[bool + 4] << 16);
      at(paramArrayOfByte1, b, 3, paramArrayOfInt[bool + 4] >>> 16 & 0xF | (paramArrayOfInt[bool + 5] & 0xFFFFF) << 4 | paramArrayOfInt[bool + 6] << 24);
      at(paramArrayOfByte1, b, 4, paramArrayOfInt[bool + 6] >>> 8 & 0xFFF | paramArrayOfInt[bool + 7] << 12);
      at(paramArrayOfByte1, b, 5, paramArrayOfInt[bool + 8] & 0xFFFFF | paramArrayOfInt[bool + 9] << 20);
      at(paramArrayOfByte1, b, 6, paramArrayOfInt[bool + 9] >>> 12 & 0xFF | (paramArrayOfInt[bool + 10] & 0xFFFFF) << 8 | paramArrayOfInt[bool + 11] << 28);
      at(paramArrayOfByte1, b, 7, paramArrayOfInt[bool + 11] >>> 4 & 0xFFFF | paramArrayOfInt[bool + 12] << 16);
      at(paramArrayOfByte1, b, 8, paramArrayOfInt[bool + 12] >>> 16 & 0xF | (paramArrayOfInt[bool + 13] & 0xFFFFF) << 4 | paramArrayOfInt[bool + 14] << 24);
      at(paramArrayOfByte1, b, 9, paramArrayOfInt[bool + 14] >>> 8 & 0xFFF | paramArrayOfInt[bool + 15] << 12);
      bool += true;
    } 
    System.arraycopy(paramArrayOfByte2, paramInt2, paramArrayOfByte1, paramInt1 + 2560, 32);
  }
  
  static void decodeSignature(byte[] paramArrayOfByte1, int[] paramArrayOfInt, byte[] paramArrayOfByte2, int paramInt) {
    byte b = 0;
    for (boolean bool = false; bool < 'Ѐ'; bool += true) {
      int i = at(paramArrayOfByte2, b, 0);
      int j = at(paramArrayOfByte2, b, 1);
      int k = at(paramArrayOfByte2, b, 2);
      int m = at(paramArrayOfByte2, b, 3);
      int n = at(paramArrayOfByte2, b, 4);
      int i1 = at(paramArrayOfByte2, b, 5);
      int i2 = at(paramArrayOfByte2, b, 6);
      int i3 = at(paramArrayOfByte2, b, 7);
      int i4 = at(paramArrayOfByte2, b, 8);
      int i5 = at(paramArrayOfByte2, b, 9);
      paramArrayOfInt[bool] = i << 12 >> 12;
      paramArrayOfInt[bool + true] = i >>> 20 | j << 24 >> 12;
      paramArrayOfInt[bool + 2] = j << 4 >> 12;
      paramArrayOfInt[bool + 3] = j >>> 28 | k << 16 >> 12;
      paramArrayOfInt[bool + 4] = k >>> 16 | m << 28 >> 12;
      paramArrayOfInt[bool + 5] = m << 8 >> 12;
      paramArrayOfInt[bool + 6] = m >>> 24 | n << 20 >> 12;
      paramArrayOfInt[bool + 7] = n >> 12;
      paramArrayOfInt[bool + 8] = i1 << 12 >> 12;
      paramArrayOfInt[bool + 9] = i1 >>> 20 | i2 << 24 >> 12;
      paramArrayOfInt[bool + 10] = i2 << 4 >> 12;
      paramArrayOfInt[bool + 11] = i2 >>> 28 | i3 << 16 >> 12;
      paramArrayOfInt[bool + 12] = i3 >>> 16 | i4 << 28 >> 12;
      paramArrayOfInt[bool + 13] = i4 << 8 >> 12;
      paramArrayOfInt[bool + 14] = i4 >>> 24 | i5 << 20 >> 12;
      paramArrayOfInt[bool + 15] = i5 >> 12;
      b += 10;
    } 
    System.arraycopy(paramArrayOfByte2, paramInt + 2560, paramArrayOfByte1, 0, 32);
  }
  
  static void encodeC(int[] paramArrayOfInt, short[] paramArrayOfShort, byte[] paramArrayOfByte, int paramInt) {
    boolean bool = false;
    short s = 0;
    short[] arrayOfShort = new short[1024];
    byte[] arrayOfByte = new byte[168];
    s = (short)(s + true);
    HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(arrayOfByte, 0, 168, s, paramArrayOfByte, paramInt, 32);
    Arrays.fill(arrayOfShort, (short)0);
    byte b = 0;
    while (b < 25) {
      if (bool > '¥') {
        s = (short)(s + 1);
        HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(arrayOfByte, 0, 168, s, paramArrayOfByte, paramInt, 32);
        bool = false;
      } 
      byte b1 = arrayOfByte[bool] << 8 | arrayOfByte[bool + true] & 0xFF;
      b1 &= 0x3FF;
      if (arrayOfShort[b1] == 0) {
        if ((arrayOfByte[bool + 2] & true) == 1) {
          arrayOfShort[b1] = -1;
        } else {
          arrayOfShort[b1] = 1;
        } 
        paramArrayOfInt[b] = b1;
        paramArrayOfShort[b] = arrayOfShort[b1];
        b++;
      } 
      bool += true;
    } 
  }
  
  private static void hashFunction(byte[] paramArrayOfByte1, int paramInt1, int[] paramArrayOfInt, byte[] paramArrayOfByte2, int paramInt2) {
    byte[] arrayOfByte = new byte[4176];
    for (byte b = 0; b < 4; b++) {
      char c = b * 'Ѐ';
      for (byte b1 = 0; b1 < 'Ѐ'; b1++) {
        int k = paramArrayOfInt[c];
        int i = 171788288 - k >> 31;
        k = k - 343576577 & i | k & (i ^ 0xFFFFFFFF);
        int j = k & 0x3FFFFF;
        i = 2097152 - j >> 31;
        j = j - 4194304 & i | j & (i ^ 0xFFFFFFFF);
        arrayOfByte[c++] = (byte)(k - j >> 22);
      } 
    } 
    System.arraycopy(paramArrayOfByte2, paramInt2, arrayOfByte, 4096, 80);
    HashUtils.secureHashAlgorithmKECCAK128(paramArrayOfByte1, paramInt1, 32, arrayOfByte, 0, arrayOfByte.length);
  }
  
  static int littleEndianToInt24(byte[] paramArrayOfByte, int paramInt) {
    null = paramArrayOfByte[paramInt] & 0xFF;
    null |= (paramArrayOfByte[++paramInt] & 0xFF) << 8;
    return (paramArrayOfByte[++paramInt] & 0xFF) << 16;
  }
  
  static void sample_y(int[] paramArrayOfInt, byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    byte b = 0;
    int i = 0;
    int j = 1024;
    byte[] arrayOfByte = new byte[1024 * BPLUS1BYTES + 1];
    int k = BPLUS1BYTES;
    short s = (short)(paramInt2 << 8);
    s = (short)(s + 1);
    HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(arrayOfByte, 0, 1024 * k, s, paramArrayOfByte, paramInt1, 32);
    while (b < 'Ѐ') {
      if (i >= j * k) {
        j = NBLOCKS_SHAKE;
        s = (short)(s + 1);
        HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(arrayOfByte, 0, 1024 * k, s, paramArrayOfByte, paramInt1, 32);
        i = 0;
      } 
      paramArrayOfInt[b] = littleEndianToInt24(arrayOfByte, i) & 0xFFFFF;
      paramArrayOfInt[b] = paramArrayOfInt[b] - 524287;
      if (paramArrayOfInt[b] != 524288)
        b++; 
      i += k;
    } 
  }
  
  private static void at(byte[] paramArrayOfByte, int paramInt1, int paramInt2, int paramInt3) { Pack.intToLittleEndian(paramInt3, paramArrayOfByte, paramInt1 + paramInt2 << 2); }
  
  private static int at(byte[] paramArrayOfByte, int paramInt1, int paramInt2) { return Pack.littleEndianToInt(paramArrayOfByte, paramInt1 + paramInt2 << 2); }
  
  static boolean test_correctness(int[] paramArrayOfInt, int paramInt) {
    for (int i = 0; i < 1024; i++) {
      int i2 = paramArrayOfInt[paramInt + i];
      int j = 171788288 - i2 >> 31;
      int m = i2 - 343576577 & j | i2 & (j ^ 0xFFFFFFFF);
      int n = (absolute(m) - 171787734 ^ 0xFFFFFFFF) >>> 31;
      int k = m;
      m = m + 2097152 - 1 >> 22;
      m = k - (m << 22);
      int i1 = (absolute(m) - 2096598 ^ 0xFFFFFFFF) >>> 31;
      if ((n | i1) == 1)
        return true; 
    } 
    return false;
  }
  
  private static boolean testRejection(int[] paramArrayOfInt) {
    int i = 0;
    for (byte b = 0; b < 'Ѐ'; b++)
      i |= 523733 - absolute(paramArrayOfInt[b]); 
    return (i >>> 31 != 0);
  }
  
  private static int absolute(int paramInt) {
    int i = paramInt >> 31;
    return (i ^ paramInt) - i;
  }
  
  private static boolean checkPolynomial(int[] paramArrayOfInt, int paramInt1, int paramInt2) {
    int j = 0;
    char c = 'Ѐ';
    int[] arrayOfInt = new int[1024];
    int i;
    for (i = 0; i < 1024; i++)
      arrayOfInt[i] = absolute(paramArrayOfInt[paramInt1 + i]); 
    for (i = 0; i < 25; i++) {
      for (byte b = 0; b < c - '\001'; b++) {
        int n = arrayOfInt[b];
        int i1 = arrayOfInt[b + true];
        int m = i1 - n >> 31;
        int k = i1 & m | n & (m ^ 0xFFFFFFFF);
        arrayOfInt[b + true] = n & m | i1 & (m ^ 0xFFFFFFFF);
        arrayOfInt[b] = k;
      } 
      j += arrayOfInt[c - '\001'];
      c--;
    } 
    return (j > paramInt2);
  }
  
  static boolean memoryEqual(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, int paramInt3) {
    if (paramInt1 + paramInt3 <= paramArrayOfByte1.length && paramInt2 + paramInt3 <= paramArrayOfByte2.length) {
      for (int i = 0; i < paramInt3; i++) {
        if (paramArrayOfByte1[paramInt1 + i] != paramArrayOfByte2[paramInt2 + i])
          return false; 
      } 
      return true;
    } 
    return false;
  }
}
