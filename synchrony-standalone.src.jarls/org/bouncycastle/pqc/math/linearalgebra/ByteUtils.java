package org.bouncycastle.pqc.math.linearalgebra;

public final class ByteUtils {
  private static final char[] HEX_CHARS = { 
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
      'a', 'b', 'c', 'd', 'e', 'f' };
  
  public static boolean equals(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2) {
    if (paramArrayOfByte1 == null)
      return (paramArrayOfByte2 == null); 
    if (paramArrayOfByte2 == null)
      return false; 
    if (paramArrayOfByte1.length != paramArrayOfByte2.length)
      return false; 
    boolean bool = true;
    for (int i = paramArrayOfByte1.length - 1; i >= 0; i--)
      bool &= ((paramArrayOfByte1[i] == paramArrayOfByte2[i]) ? 1 : 0); 
    return bool;
  }
  
  public static boolean equals(byte[][] paramArrayOfByte1, byte[][] paramArrayOfByte2) {
    if (paramArrayOfByte1.length != paramArrayOfByte2.length)
      return false; 
    boolean bool = true;
    for (int i = paramArrayOfByte1.length - 1; i >= 0; i--)
      bool &= equals(paramArrayOfByte1[i], paramArrayOfByte2[i]); 
    return bool;
  }
  
  public static boolean equals(byte[][][] paramArrayOfByte1, byte[][][] paramArrayOfByte2) {
    if (paramArrayOfByte1.length != paramArrayOfByte2.length)
      return false; 
    boolean bool = true;
    for (int i = paramArrayOfByte1.length - 1; i >= 0; i--) {
      if (paramArrayOfByte1[i].length != paramArrayOfByte2[i].length)
        return false; 
      for (int j = paramArrayOfByte1[i].length - 1; j >= 0; j--)
        bool &= equals(paramArrayOfByte1[i][j], paramArrayOfByte2[i][j]); 
    } 
    return bool;
  }
  
  public static int deepHashCode(byte[] paramArrayOfByte) {
    byte b = 1;
    for (byte b1 = 0; b1 < paramArrayOfByte.length; b1++)
      b = 31 * b + paramArrayOfByte[b1]; 
    return b;
  }
  
  public static int deepHashCode(byte[][] paramArrayOfByte) {
    int i = 1;
    for (byte b = 0; b < paramArrayOfByte.length; b++)
      i = 31 * i + deepHashCode(paramArrayOfByte[b]); 
    return i;
  }
  
  public static int deepHashCode(byte[][][] paramArrayOfByte) {
    int i = 1;
    for (byte b = 0; b < paramArrayOfByte.length; b++)
      i = 31 * i + deepHashCode(paramArrayOfByte[b]); 
    return i;
  }
  
  public static byte[] clone(byte[] paramArrayOfByte) {
    if (paramArrayOfByte == null)
      return null; 
    byte[] arrayOfByte = new byte[paramArrayOfByte.length];
    System.arraycopy(paramArrayOfByte, 0, arrayOfByte, 0, paramArrayOfByte.length);
    return arrayOfByte;
  }
  
  public static byte[] fromHexString(String paramString) {
    char[] arrayOfChar = paramString.toUpperCase().toCharArray();
    byte b1 = 0;
    for (byte b2 = 0; b2 < arrayOfChar.length; b2++) {
      if ((arrayOfChar[b2] >= '0' && arrayOfChar[b2] <= '9') || (arrayOfChar[b2] >= 'A' && arrayOfChar[b2] <= 'F'))
        b1++; 
    } 
    byte[] arrayOfByte = new byte[b1 + 1 >> 1];
    byte b3 = b1 & true;
    for (byte b4 = 0; b4 < arrayOfChar.length; b4++) {
      if (arrayOfChar[b4] >= '0' && arrayOfChar[b4] <= '9') {
        arrayOfByte[b3 >> 1] = (byte)(arrayOfByte[b3 >> 1] << 4);
        arrayOfByte[b3 >> 1] = (byte)(arrayOfByte[b3 >> 1] | arrayOfChar[b4] - '0');
      } else if (arrayOfChar[b4] >= 'A' && arrayOfChar[b4] <= 'F') {
        arrayOfByte[b3 >> 1] = (byte)(arrayOfByte[b3 >> 1] << 4);
        arrayOfByte[b3 >> 1] = (byte)(arrayOfByte[b3 >> 1] | arrayOfChar[b4] - 'A' + '\n');
      } else {
        continue;
      } 
      b3++;
      continue;
    } 
    return arrayOfByte;
  }
  
  public static String toHexString(byte[] paramArrayOfByte) {
    String str = "";
    for (byte b = 0; b < paramArrayOfByte.length; b++) {
      str = str + HEX_CHARS[paramArrayOfByte[b] >>> 4 & 0xF];
      str = str + HEX_CHARS[paramArrayOfByte[b] & 0xF];
    } 
    return str;
  }
  
  public static String toHexString(byte[] paramArrayOfByte, String paramString1, String paramString2) {
    String str = new String(paramString1);
    for (byte b = 0; b < paramArrayOfByte.length; b++) {
      str = str + HEX_CHARS[paramArrayOfByte[b] >>> 4 & 0xF];
      str = str + HEX_CHARS[paramArrayOfByte[b] & 0xF];
      if (b < paramArrayOfByte.length - 1)
        str = str + paramString2; 
    } 
    return str;
  }
  
  public static String toBinaryString(byte[] paramArrayOfByte) {
    String str = "";
    for (byte b = 0; b < paramArrayOfByte.length; b++) {
      byte b1 = paramArrayOfByte[b];
      for (byte b2 = 0; b2 < 8; b2++) {
        byte b3 = b1 >>> b2 & true;
        str = str + b3;
      } 
      if (b != paramArrayOfByte.length - 1)
        str = str + " "; 
    } 
    return str;
  }
  
  public static byte[] xor(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2) {
    byte[] arrayOfByte = new byte[paramArrayOfByte1.length];
    for (int i = paramArrayOfByte1.length - 1; i >= 0; i--)
      arrayOfByte[i] = (byte)(paramArrayOfByte1[i] ^ paramArrayOfByte2[i]); 
    return arrayOfByte;
  }
  
  public static byte[] concatenate(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2) {
    byte[] arrayOfByte = new byte[paramArrayOfByte1.length + paramArrayOfByte2.length];
    System.arraycopy(paramArrayOfByte1, 0, arrayOfByte, 0, paramArrayOfByte1.length);
    System.arraycopy(paramArrayOfByte2, 0, arrayOfByte, paramArrayOfByte1.length, paramArrayOfByte2.length);
    return arrayOfByte;
  }
  
  public static byte[] concatenate(byte[][] paramArrayOfByte) {
    int i = paramArrayOfByte[0].length;
    byte[] arrayOfByte = new byte[paramArrayOfByte.length * i];
    int j = 0;
    for (byte b = 0; b < paramArrayOfByte.length; b++) {
      System.arraycopy(paramArrayOfByte[b], 0, arrayOfByte, j, i);
      j += i;
    } 
    return arrayOfByte;
  }
  
  public static byte[][] split(byte[] paramArrayOfByte, int paramInt) throws ArrayIndexOutOfBoundsException {
    if (paramInt > paramArrayOfByte.length)
      throw new ArrayIndexOutOfBoundsException(); 
    byte[][] arrayOfByte = new byte[2][];
    arrayOfByte[0] = new byte[paramInt];
    arrayOfByte[1] = new byte[paramArrayOfByte.length - paramInt];
    System.arraycopy(paramArrayOfByte, 0, arrayOfByte[0], 0, paramInt);
    System.arraycopy(paramArrayOfByte, paramInt, arrayOfByte[1], 0, paramArrayOfByte.length - paramInt);
    return arrayOfByte;
  }
  
  public static byte[] subArray(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    byte[] arrayOfByte = new byte[paramInt2 - paramInt1];
    System.arraycopy(paramArrayOfByte, paramInt1, arrayOfByte, 0, paramInt2 - paramInt1);
    return arrayOfByte;
  }
  
  public static byte[] subArray(byte[] paramArrayOfByte, int paramInt) { return subArray(paramArrayOfByte, paramInt, paramArrayOfByte.length); }
  
  public static char[] toCharArray(byte[] paramArrayOfByte) {
    char[] arrayOfChar = new char[paramArrayOfByte.length];
    for (byte b = 0; b < paramArrayOfByte.length; b++)
      arrayOfChar[b] = (char)paramArrayOfByte[b]; 
    return arrayOfChar;
  }
}
