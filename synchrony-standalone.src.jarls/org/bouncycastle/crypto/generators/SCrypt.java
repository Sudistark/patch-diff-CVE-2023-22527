package org.bouncycastle.crypto.generators;

import org.bouncycastle.crypto.digests.SHA256Digest;
import org.bouncycastle.crypto.engines.Salsa20Engine;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Integers;
import org.bouncycastle.util.Pack;

public class SCrypt {
  public static byte[] generate(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt1, int paramInt2, int paramInt3, int paramInt4) {
    if (paramArrayOfByte1 == null)
      throw new IllegalArgumentException("Passphrase P must be provided."); 
    if (paramArrayOfByte2 == null)
      throw new IllegalArgumentException("Salt S must be provided."); 
    if (paramInt1 <= 1 || !isPowerOf2(paramInt1))
      throw new IllegalArgumentException("Cost parameter N must be > 1 and a power of 2"); 
    if (paramInt2 == 1 && paramInt1 >= 65536)
      throw new IllegalArgumentException("Cost parameter N must be > 1 and < 65536."); 
    if (paramInt2 < 1)
      throw new IllegalArgumentException("Block size r must be >= 1."); 
    int i = Integer.MAX_VALUE / 128 * paramInt2 * 8;
    if (paramInt3 < 1 || paramInt3 > i)
      throw new IllegalArgumentException("Parallelisation parameter p must be >= 1 and <= " + i + " (based on block size r of " + paramInt2 + ")"); 
    if (paramInt4 < 1)
      throw new IllegalArgumentException("Generated key length dkLen must be >= 1."); 
    return MFcrypt(paramArrayOfByte1, paramArrayOfByte2, paramInt1, paramInt2, paramInt3, paramInt4);
  }
  
  private static byte[] MFcrypt(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt1, int paramInt2, int paramInt3, int paramInt4) {
    int i = paramInt2 * 128;
    arrayOfByte = SingleIterationPBKDF2(paramArrayOfByte1, paramArrayOfByte2, paramInt3 * i);
    arrayOfInt = null;
    try {
      int j = arrayOfByte.length >>> 2;
      arrayOfInt = new int[j];
      Pack.littleEndianToInt(arrayOfByte, 0, arrayOfInt);
      int k = 0;
      int m;
      for (m = paramInt1 * paramInt2; paramInt1 - k > 2 && m > 1024; m >>>= 1)
        k++; 
      int n = i >>> 2;
      int i1;
      for (i1 = 0; i1 < j; i1 += n)
        SMix(arrayOfInt, i1, paramInt1, k, paramInt2); 
      Pack.intToLittleEndian(arrayOfInt, arrayOfByte, 0);
      return SingleIterationPBKDF2(paramArrayOfByte1, arrayOfByte, paramInt4);
    } finally {
      Clear(arrayOfByte);
      Clear(arrayOfInt);
    } 
  }
  
  private static byte[] SingleIterationPBKDF2(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt) {
    PKCS5S2ParametersGenerator pKCS5S2ParametersGenerator = new PKCS5S2ParametersGenerator(new SHA256Digest());
    pKCS5S2ParametersGenerator.init(paramArrayOfByte1, paramArrayOfByte2, 1);
    KeyParameter keyParameter = (KeyParameter)pKCS5S2ParametersGenerator.generateDerivedMacParameters(paramInt * 8);
    return keyParameter.getKey();
  }
  
  private static void SMix(int[] paramArrayOfInt, int paramInt1, int paramInt2, int paramInt3, int paramInt4) {
    int i = Integers.numberOfTrailingZeros(paramInt2);
    int j = paramInt2 >>> paramInt3;
    int k = 1 << paramInt3;
    int m = j - 1;
    int n = i - paramInt3;
    int i1 = paramInt4 * 32;
    arrayOfInt1 = new int[16];
    arrayOfInt2 = new int[16];
    arrayOfInt3 = new int[i1];
    arrayOfInt4 = new int[i1];
    arrayOfInt = new int[k][];
    try {
      System.arraycopy(paramArrayOfInt, paramInt1, arrayOfInt4, 0, i1);
      int i2;
      for (i2 = 0; i2 < k; i2++) {
        int[] arrayOfInt5 = new int[j * i1];
        arrayOfInt[i2] = arrayOfInt5;
        int i3 = 0;
        for (boolean bool = false; bool < j; bool += true) {
          System.arraycopy(arrayOfInt4, 0, arrayOfInt5, i3, i1);
          i3 += i1;
          BlockMix(arrayOfInt4, arrayOfInt1, arrayOfInt2, arrayOfInt3, paramInt4);
          System.arraycopy(arrayOfInt3, 0, arrayOfInt5, i3, i1);
          i3 += i1;
          BlockMix(arrayOfInt3, arrayOfInt1, arrayOfInt2, arrayOfInt4, paramInt4);
        } 
      } 
      i2 = paramInt2 - 1;
      for (byte b = 0; b < paramInt2; b++) {
        int i3 = arrayOfInt4[i1 - 16] & i2;
        int[] arrayOfInt5 = arrayOfInt[i3 >>> n];
        int i4 = (i3 & m) * i1;
        System.arraycopy(arrayOfInt5, i4, arrayOfInt3, 0, i1);
        Xor(arrayOfInt3, arrayOfInt4, 0, arrayOfInt3);
        BlockMix(arrayOfInt3, arrayOfInt1, arrayOfInt2, arrayOfInt4, paramInt4);
      } 
      System.arraycopy(arrayOfInt4, 0, paramArrayOfInt, paramInt1, i1);
    } finally {
      ClearAll(arrayOfInt);
      ClearAll(new int[][] { arrayOfInt4, arrayOfInt1, arrayOfInt2, arrayOfInt3 });
    } 
  }
  
  private static void BlockMix(int[] paramArrayOfInt1, int[] paramArrayOfInt2, int[] paramArrayOfInt3, int[] paramArrayOfInt4, int paramInt) {
    System.arraycopy(paramArrayOfInt1, paramArrayOfInt1.length - 16, paramArrayOfInt2, 0, 16);
    int i = 0;
    int j = 0;
    int k = paramArrayOfInt1.length >>> 1;
    for (int m = 2 * paramInt; m > 0; m--) {
      Xor(paramArrayOfInt2, paramArrayOfInt1, i, paramArrayOfInt3);
      Salsa20Engine.salsaCore(8, paramArrayOfInt3, paramArrayOfInt2);
      System.arraycopy(paramArrayOfInt2, 0, paramArrayOfInt4, j, 16);
      j = k + i - j;
      i += 16;
    } 
  }
  
  private static void Xor(int[] paramArrayOfInt1, int[] paramArrayOfInt2, int paramInt, int[] paramArrayOfInt3) {
    for (int i = paramArrayOfInt3.length - 1; i >= 0; i--)
      paramArrayOfInt3[i] = paramArrayOfInt1[i] ^ paramArrayOfInt2[paramInt + i]; 
  }
  
  private static void Clear(byte[] paramArrayOfByte) {
    if (paramArrayOfByte != null)
      Arrays.fill(paramArrayOfByte, (byte)0); 
  }
  
  private static void Clear(int[] paramArrayOfInt) {
    if (paramArrayOfInt != null)
      Arrays.fill(paramArrayOfInt, 0); 
  }
  
  private static void ClearAll(int[][] paramArrayOfInt) {
    for (byte b = 0; b < paramArrayOfInt.length; b++)
      Clear(paramArrayOfInt[b]); 
  }
  
  private static boolean isPowerOf2(int paramInt) { return ((paramInt & paramInt - 1) == 0); }
}
