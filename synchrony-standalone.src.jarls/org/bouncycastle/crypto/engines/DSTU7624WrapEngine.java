package org.bouncycastle.crypto.engines;

import java.util.ArrayList;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.crypto.Wrapper;
import org.bouncycastle.crypto.params.ParametersWithRandom;
import org.bouncycastle.util.Arrays;

public class DSTU7624WrapEngine implements Wrapper {
  private static final int BYTES_IN_INTEGER = 4;
  
  private boolean forWrapping;
  
  private DSTU7624Engine engine;
  
  private byte[] B;
  
  private byte[] intArray;
  
  private byte[] checkSumArray;
  
  private byte[] zeroArray;
  
  private ArrayList<byte[]> Btemp;
  
  public DSTU7624WrapEngine(int paramInt) {
    this.engine = new DSTU7624Engine(paramInt);
    this.B = new byte[this.engine.getBlockSize() / 2];
    this.checkSumArray = new byte[this.engine.getBlockSize()];
    this.zeroArray = new byte[this.engine.getBlockSize()];
    this.Btemp = new ArrayList();
    this.intArray = new byte[4];
  }
  
  public void init(boolean paramBoolean, CipherParameters paramCipherParameters) {
    if (paramCipherParameters instanceof ParametersWithRandom)
      paramCipherParameters = ((ParametersWithRandom)paramCipherParameters).getParameters(); 
    this.forWrapping = paramBoolean;
    if (paramCipherParameters instanceof org.bouncycastle.crypto.params.KeyParameter) {
      this.engine.init(paramBoolean, paramCipherParameters);
    } else {
      throw new IllegalArgumentException("invalid parameters passed to DSTU7624WrapEngine");
    } 
  }
  
  public String getAlgorithmName() { return "DSTU7624WrapEngine"; }
  
  public byte[] wrap(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    if (!this.forWrapping)
      throw new IllegalStateException("not set for wrapping"); 
    if (paramInt2 % this.engine.getBlockSize() != 0)
      throw new DataLengthException("wrap data must be a multiple of " + this.engine.getBlockSize() + " bytes"); 
    if (paramInt1 + paramInt2 > paramArrayOfByte.length)
      throw new DataLengthException("input buffer too short"); 
    int i = 2 * (1 + paramInt2 / this.engine.getBlockSize());
    int j = (i - 1) * 6;
    byte[] arrayOfByte = new byte[paramInt2 + this.engine.getBlockSize()];
    System.arraycopy(paramArrayOfByte, paramInt1, arrayOfByte, 0, paramInt2);
    System.arraycopy(arrayOfByte, 0, this.B, 0, this.engine.getBlockSize() / 2);
    this.Btemp.clear();
    int k = arrayOfByte.length - this.engine.getBlockSize() / 2;
    int m;
    for (m = this.engine.getBlockSize() / 2; k != 0; m += this.engine.getBlockSize() / 2) {
      byte[] arrayOfByte1 = new byte[this.engine.getBlockSize() / 2];
      System.arraycopy(arrayOfByte, m, arrayOfByte1, 0, this.engine.getBlockSize() / 2);
      this.Btemp.add(arrayOfByte1);
      k -= this.engine.getBlockSize() / 2;
    } 
    byte b;
    for (b = 0; b < j; b++) {
      System.arraycopy(this.B, 0, arrayOfByte, 0, this.engine.getBlockSize() / 2);
      System.arraycopy(this.Btemp.get(0), 0, arrayOfByte, this.engine.getBlockSize() / 2, this.engine.getBlockSize() / 2);
      this.engine.processBlock(arrayOfByte, 0, arrayOfByte, 0);
      intToBytes(b + true, this.intArray, 0);
      int n;
      for (n = 0; n < 4; n++)
        arrayOfByte[n + this.engine.getBlockSize() / 2] = (byte)(arrayOfByte[n + this.engine.getBlockSize() / 2] ^ this.intArray[n]); 
      System.arraycopy(arrayOfByte, this.engine.getBlockSize() / 2, this.B, 0, this.engine.getBlockSize() / 2);
      for (n = 2; n < i; n++)
        System.arraycopy(this.Btemp.get(n - 1), 0, this.Btemp.get(n - 2), 0, this.engine.getBlockSize() / 2); 
      System.arraycopy(arrayOfByte, 0, this.Btemp.get(i - 2), 0, this.engine.getBlockSize() / 2);
    } 
    System.arraycopy(this.B, 0, arrayOfByte, 0, this.engine.getBlockSize() / 2);
    m = this.engine.getBlockSize() / 2;
    for (b = 0; b < i - 1; b++) {
      System.arraycopy(this.Btemp.get(b), 0, arrayOfByte, m, this.engine.getBlockSize() / 2);
      m += this.engine.getBlockSize() / 2;
    } 
    return arrayOfByte;
  }
  
  public byte[] unwrap(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    if (this.forWrapping)
      throw new IllegalStateException("not set for unwrapping"); 
    if (paramInt2 % this.engine.getBlockSize() != 0)
      throw new DataLengthException("unwrap data must be a multiple of " + this.engine.getBlockSize() + " bytes"); 
    int i = 2 * paramInt2 / this.engine.getBlockSize();
    int j = (i - 1) * 6;
    byte[] arrayOfByte1 = new byte[paramInt2];
    System.arraycopy(paramArrayOfByte, paramInt1, arrayOfByte1, 0, paramInt2);
    byte[] arrayOfByte2 = new byte[this.engine.getBlockSize() / 2];
    System.arraycopy(arrayOfByte1, 0, arrayOfByte2, 0, this.engine.getBlockSize() / 2);
    this.Btemp.clear();
    int k = arrayOfByte1.length - this.engine.getBlockSize() / 2;
    int m;
    for (m = this.engine.getBlockSize() / 2; k != 0; m += this.engine.getBlockSize() / 2) {
      byte[] arrayOfByte = new byte[this.engine.getBlockSize() / 2];
      System.arraycopy(arrayOfByte1, m, arrayOfByte, 0, this.engine.getBlockSize() / 2);
      this.Btemp.add(arrayOfByte);
      k -= this.engine.getBlockSize() / 2;
    } 
    int n;
    for (n = 0; n < j; n++) {
      System.arraycopy(this.Btemp.get(i - 2), 0, arrayOfByte1, 0, this.engine.getBlockSize() / 2);
      System.arraycopy(arrayOfByte2, 0, arrayOfByte1, this.engine.getBlockSize() / 2, this.engine.getBlockSize() / 2);
      intToBytes(j - n, this.intArray, 0);
      int i1;
      for (i1 = 0; i1 < 4; i1++)
        arrayOfByte1[i1 + this.engine.getBlockSize() / 2] = (byte)(arrayOfByte1[i1 + this.engine.getBlockSize() / 2] ^ this.intArray[i1]); 
      this.engine.processBlock(arrayOfByte1, 0, arrayOfByte1, 0);
      System.arraycopy(arrayOfByte1, 0, arrayOfByte2, 0, this.engine.getBlockSize() / 2);
      for (i1 = 2; i1 < i; i1++)
        System.arraycopy(this.Btemp.get(i - i1 - 1), 0, this.Btemp.get(i - i1), 0, this.engine.getBlockSize() / 2); 
      System.arraycopy(arrayOfByte1, this.engine.getBlockSize() / 2, this.Btemp.get(0), 0, this.engine.getBlockSize() / 2);
    } 
    System.arraycopy(arrayOfByte2, 0, arrayOfByte1, 0, this.engine.getBlockSize() / 2);
    m = this.engine.getBlockSize() / 2;
    for (n = 0; n < i - 1; n++) {
      System.arraycopy(this.Btemp.get(n), 0, arrayOfByte1, m, this.engine.getBlockSize() / 2);
      m += this.engine.getBlockSize() / 2;
    } 
    System.arraycopy(arrayOfByte1, arrayOfByte1.length - this.engine.getBlockSize(), this.checkSumArray, 0, this.engine.getBlockSize());
    byte[] arrayOfByte3 = new byte[arrayOfByte1.length - this.engine.getBlockSize()];
    if (!Arrays.areEqual(this.checkSumArray, this.zeroArray))
      throw new InvalidCipherTextException("checksum failed"); 
    System.arraycopy(arrayOfByte1, 0, arrayOfByte3, 0, arrayOfByte1.length - this.engine.getBlockSize());
    return arrayOfByte3;
  }
  
  private void intToBytes(int paramInt1, byte[] paramArrayOfByte, int paramInt2) {
    paramArrayOfByte[paramInt2 + 3] = (byte)(paramInt1 >> 24);
    paramArrayOfByte[paramInt2 + 2] = (byte)(paramInt1 >> 16);
    paramArrayOfByte[paramInt2 + 1] = (byte)(paramInt1 >> 8);
    paramArrayOfByte[paramInt2] = (byte)paramInt1;
  }
}
