package org.bouncycastle.crypto.engines;

public final class CAST6Engine extends CAST5Engine {
  protected static final int ROUNDS = 12;
  
  protected static final int BLOCK_SIZE = 16;
  
  protected int[] _Kr = new int[48];
  
  protected int[] _Km = new int[48];
  
  protected int[] _Tr = new int[192];
  
  protected int[] _Tm = new int[192];
  
  private int[] _workingKey = new int[8];
  
  public String getAlgorithmName() { return "CAST6"; }
  
  public void reset() {}
  
  public int getBlockSize() { return 16; }
  
  protected void setKey(byte[] paramArrayOfByte) {
    int i = 1518500249;
    int j = 1859775393;
    byte b1 = 19;
    byte b2 = 17;
    for (byte b3 = 0; b3 < 24; b3++) {
      for (byte b = 0; b < 8; b++) {
        this._Tm[b3 * 8 + b] = i;
        i += j;
        this._Tr[b3 * 8 + b] = b1;
        b1 = b1 + b2 & 0x1F;
      } 
    } 
    byte[] arrayOfByte = new byte[64];
    int k = paramArrayOfByte.length;
    System.arraycopy(paramArrayOfByte, 0, arrayOfByte, 0, k);
    byte b4;
    for (b4 = 0; b4 < 8; b4++)
      this._workingKey[b4] = BytesTo32bits(arrayOfByte, b4 * 4); 
    for (b4 = 0; b4 < 12; b4++) {
      byte b = b4 * 2 * 8;
      this._workingKey[6] = this._workingKey[6] ^ F1(this._workingKey[7], this._Tm[b], this._Tr[b]);
      this._workingKey[5] = this._workingKey[5] ^ F2(this._workingKey[6], this._Tm[b + 1], this._Tr[b + 1]);
      this._workingKey[4] = this._workingKey[4] ^ F3(this._workingKey[5], this._Tm[b + 2], this._Tr[b + 2]);
      this._workingKey[3] = this._workingKey[3] ^ F1(this._workingKey[4], this._Tm[b + 3], this._Tr[b + 3]);
      this._workingKey[2] = this._workingKey[2] ^ F2(this._workingKey[3], this._Tm[b + 4], this._Tr[b + 4]);
      this._workingKey[1] = this._workingKey[1] ^ F3(this._workingKey[2], this._Tm[b + 5], this._Tr[b + 5]);
      this._workingKey[0] = this._workingKey[0] ^ F1(this._workingKey[1], this._Tm[b + 6], this._Tr[b + 6]);
      this._workingKey[7] = this._workingKey[7] ^ F2(this._workingKey[0], this._Tm[b + 7], this._Tr[b + 7]);
      b = (b4 * 2 + 1) * 8;
      this._workingKey[6] = this._workingKey[6] ^ F1(this._workingKey[7], this._Tm[b], this._Tr[b]);
      this._workingKey[5] = this._workingKey[5] ^ F2(this._workingKey[6], this._Tm[b + 1], this._Tr[b + 1]);
      this._workingKey[4] = this._workingKey[4] ^ F3(this._workingKey[5], this._Tm[b + 2], this._Tr[b + 2]);
      this._workingKey[3] = this._workingKey[3] ^ F1(this._workingKey[4], this._Tm[b + 3], this._Tr[b + 3]);
      this._workingKey[2] = this._workingKey[2] ^ F2(this._workingKey[3], this._Tm[b + 4], this._Tr[b + 4]);
      this._workingKey[1] = this._workingKey[1] ^ F3(this._workingKey[2], this._Tm[b + 5], this._Tr[b + 5]);
      this._workingKey[0] = this._workingKey[0] ^ F1(this._workingKey[1], this._Tm[b + 6], this._Tr[b + 6]);
      this._workingKey[7] = this._workingKey[7] ^ F2(this._workingKey[0], this._Tm[b + 7], this._Tr[b + 7]);
      this._Kr[b4 * 4] = this._workingKey[0] & 0x1F;
      this._Kr[b4 * 4 + 1] = this._workingKey[2] & 0x1F;
      this._Kr[b4 * 4 + 2] = this._workingKey[4] & 0x1F;
      this._Kr[b4 * 4 + 3] = this._workingKey[6] & 0x1F;
      this._Km[b4 * 4] = this._workingKey[7];
      this._Km[b4 * 4 + 1] = this._workingKey[5];
      this._Km[b4 * 4 + 2] = this._workingKey[3];
      this._Km[b4 * 4 + 3] = this._workingKey[1];
    } 
  }
  
  protected int encryptBlock(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2) {
    int[] arrayOfInt = new int[4];
    int i = BytesTo32bits(paramArrayOfByte1, paramInt1);
    int j = BytesTo32bits(paramArrayOfByte1, paramInt1 + 4);
    int k = BytesTo32bits(paramArrayOfByte1, paramInt1 + 8);
    int m = BytesTo32bits(paramArrayOfByte1, paramInt1 + 12);
    CAST_Encipher(i, j, k, m, arrayOfInt);
    Bits32ToBytes(arrayOfInt[0], paramArrayOfByte2, paramInt2);
    Bits32ToBytes(arrayOfInt[1], paramArrayOfByte2, paramInt2 + 4);
    Bits32ToBytes(arrayOfInt[2], paramArrayOfByte2, paramInt2 + 8);
    Bits32ToBytes(arrayOfInt[3], paramArrayOfByte2, paramInt2 + 12);
    return 16;
  }
  
  protected int decryptBlock(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2) {
    int[] arrayOfInt = new int[4];
    int i = BytesTo32bits(paramArrayOfByte1, paramInt1);
    int j = BytesTo32bits(paramArrayOfByte1, paramInt1 + 4);
    int k = BytesTo32bits(paramArrayOfByte1, paramInt1 + 8);
    int m = BytesTo32bits(paramArrayOfByte1, paramInt1 + 12);
    CAST_Decipher(i, j, k, m, arrayOfInt);
    Bits32ToBytes(arrayOfInt[0], paramArrayOfByte2, paramInt2);
    Bits32ToBytes(arrayOfInt[1], paramArrayOfByte2, paramInt2 + 4);
    Bits32ToBytes(arrayOfInt[2], paramArrayOfByte2, paramInt2 + 8);
    Bits32ToBytes(arrayOfInt[3], paramArrayOfByte2, paramInt2 + 12);
    return 16;
  }
  
  protected final void CAST_Encipher(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int[] paramArrayOfInt) {
    byte b;
    for (b = 0; b < 6; b++) {
      byte b1 = b * 4;
      paramInt3 ^= F1(paramInt4, this._Km[b1], this._Kr[b1]);
      paramInt2 ^= F2(paramInt3, this._Km[b1 + 1], this._Kr[b1 + 1]);
      paramInt1 ^= F3(paramInt2, this._Km[b1 + 2], this._Kr[b1 + 2]);
      paramInt4 ^= F1(paramInt1, this._Km[b1 + 3], this._Kr[b1 + 3]);
    } 
    for (b = 6; b < 12; b++) {
      byte b1 = b * 4;
      paramInt4 ^= F1(paramInt1, this._Km[b1 + 3], this._Kr[b1 + 3]);
      paramInt1 ^= F3(paramInt2, this._Km[b1 + 2], this._Kr[b1 + 2]);
      paramInt2 ^= F2(paramInt3, this._Km[b1 + 1], this._Kr[b1 + 1]);
      paramInt3 ^= F1(paramInt4, this._Km[b1], this._Kr[b1]);
    } 
    paramArrayOfInt[0] = paramInt1;
    paramArrayOfInt[1] = paramInt2;
    paramArrayOfInt[2] = paramInt3;
    paramArrayOfInt[3] = paramInt4;
  }
  
  protected final void CAST_Decipher(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int[] paramArrayOfInt) {
    byte b;
    for (b = 0; b < 6; b++) {
      byte b1 = (11 - b) * 4;
      paramInt3 ^= F1(paramInt4, this._Km[b1], this._Kr[b1]);
      paramInt2 ^= F2(paramInt3, this._Km[b1 + 1], this._Kr[b1 + 1]);
      paramInt1 ^= F3(paramInt2, this._Km[b1 + 2], this._Kr[b1 + 2]);
      paramInt4 ^= F1(paramInt1, this._Km[b1 + 3], this._Kr[b1 + 3]);
    } 
    for (b = 6; b < 12; b++) {
      byte b1 = (11 - b) * 4;
      paramInt4 ^= F1(paramInt1, this._Km[b1 + 3], this._Kr[b1 + 3]);
      paramInt1 ^= F3(paramInt2, this._Km[b1 + 2], this._Kr[b1 + 2]);
      paramInt2 ^= F2(paramInt3, this._Km[b1 + 1], this._Kr[b1 + 1]);
      paramInt3 ^= F1(paramInt4, this._Km[b1], this._Kr[b1]);
    } 
    paramArrayOfInt[0] = paramInt1;
    paramArrayOfInt[1] = paramInt2;
    paramArrayOfInt[2] = paramInt3;
    paramArrayOfInt[3] = paramInt4;
  }
}
