package org.bouncycastle.crypto.prng;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.security.SecureRandom;

public class FixedSecureRandom extends SecureRandom {
  private byte[] _data;
  
  private int _index;
  
  private int _intPad;
  
  public FixedSecureRandom(byte[] paramArrayOfByte) { this(false, new byte[][] { paramArrayOfByte }); }
  
  public FixedSecureRandom(byte[][] paramArrayOfByte) { this(false, paramArrayOfByte); }
  
  public FixedSecureRandom(boolean paramBoolean, byte[] paramArrayOfByte) { this(paramBoolean, new byte[][] { paramArrayOfByte }); }
  
  public FixedSecureRandom(boolean paramBoolean, byte[][] paramArrayOfByte) {
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
    for (byte b = 0; b != paramArrayOfByte.length; b++) {
      try {
        byteArrayOutputStream.write(paramArrayOfByte[b]);
      } catch (IOException iOException) {
        throw new IllegalArgumentException("can't save value array.");
      } 
    } 
    this._data = byteArrayOutputStream.toByteArray();
    if (paramBoolean)
      this._intPad = this._data.length % 4; 
  }
  
  public void nextBytes(byte[] paramArrayOfByte) {
    System.arraycopy(this._data, this._index, paramArrayOfByte, 0, paramArrayOfByte.length);
    this._index += paramArrayOfByte.length;
  }
  
  public byte[] generateSeed(int paramInt) {
    byte[] arrayOfByte = new byte[paramInt];
    nextBytes(arrayOfByte);
    return arrayOfByte;
  }
  
  public int nextInt() {
    int i = 0;
    i |= nextValue() << 24;
    i |= nextValue() << 16;
    if (this._intPad == 2) {
      this._intPad--;
    } else {
      i |= nextValue() << 8;
    } 
    if (this._intPad == 1) {
      this._intPad--;
    } else {
      i |= nextValue();
    } 
    return i;
  }
  
  public long nextLong() {
    null = 0L;
    null |= nextValue() << 56;
    null |= nextValue() << 48;
    null |= nextValue() << 40;
    null |= nextValue() << 32;
    null |= nextValue() << 24;
    null |= nextValue() << 16;
    null |= nextValue() << 8;
    return nextValue();
  }
  
  public boolean isExhausted() { return (this._index == this._data.length); }
  
  private int nextValue() { return this._data[this._index++] & 0xFF; }
}
