package org.bouncycastle.crypto.prng;

import org.bouncycastle.crypto.BlockCipher;

public class X931RNG {
  private static final long BLOCK64_RESEED_MAX = 32768L;
  
  private static final long BLOCK128_RESEED_MAX = 8388608L;
  
  private static final int BLOCK64_MAX_BITS_REQUEST = 4096;
  
  private static final int BLOCK128_MAX_BITS_REQUEST = 262144;
  
  private final BlockCipher engine;
  
  private final EntropySource entropySource;
  
  private final byte[] DT;
  
  private final byte[] I;
  
  private final byte[] R;
  
  private byte[] V;
  
  private long reseedCounter = 1L;
  
  public X931RNG(BlockCipher paramBlockCipher, byte[] paramArrayOfByte, EntropySource paramEntropySource) {
    this.engine = paramBlockCipher;
    this.entropySource = paramEntropySource;
    this.DT = new byte[paramBlockCipher.getBlockSize()];
    System.arraycopy(paramArrayOfByte, 0, this.DT, 0, this.DT.length);
    this.I = new byte[paramBlockCipher.getBlockSize()];
    this.R = new byte[paramBlockCipher.getBlockSize()];
  }
  
  int generate(byte[] paramArrayOfByte, boolean paramBoolean) {
    if (this.R.length == 8) {
      if (this.reseedCounter > 32768L)
        return -1; 
      if (isTooLarge(paramArrayOfByte, 512))
        throw new IllegalArgumentException("Number of bits per request limited to 4096"); 
    } else {
      if (this.reseedCounter > 8388608L)
        return -1; 
      if (isTooLarge(paramArrayOfByte, 32768))
        throw new IllegalArgumentException("Number of bits per request limited to 262144"); 
    } 
    if (paramBoolean || this.V == null) {
      this.V = this.entropySource.getEntropy();
      if (this.V.length != this.engine.getBlockSize())
        throw new IllegalStateException("Insufficient entropy returned"); 
    } 
    int i = paramArrayOfByte.length / this.R.length;
    int j;
    for (j = 0; j < i; j++) {
      this.engine.processBlock(this.DT, 0, this.I, 0);
      process(this.R, this.I, this.V);
      process(this.V, this.R, this.I);
      System.arraycopy(this.R, 0, paramArrayOfByte, j * this.R.length, this.R.length);
      increment(this.DT);
    } 
    j = paramArrayOfByte.length - i * this.R.length;
    if (j > 0) {
      this.engine.processBlock(this.DT, 0, this.I, 0);
      process(this.R, this.I, this.V);
      process(this.V, this.R, this.I);
      System.arraycopy(this.R, 0, paramArrayOfByte, i * this.R.length, j);
      increment(this.DT);
    } 
    this.reseedCounter++;
    return paramArrayOfByte.length;
  }
  
  void reseed() {
    this.V = this.entropySource.getEntropy();
    if (this.V.length != this.engine.getBlockSize())
      throw new IllegalStateException("Insufficient entropy returned"); 
    this.reseedCounter = 1L;
  }
  
  EntropySource getEntropySource() { return this.entropySource; }
  
  private void process(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, byte[] paramArrayOfByte3) {
    for (byte b = 0; b != paramArrayOfByte1.length; b++)
      paramArrayOfByte1[b] = (byte)(paramArrayOfByte2[b] ^ paramArrayOfByte3[b]); 
    this.engine.processBlock(paramArrayOfByte1, 0, paramArrayOfByte1, 0);
  }
  
  private void increment(byte[] paramArrayOfByte) {
    int i = paramArrayOfByte.length - 1;
    paramArrayOfByte[i] = (byte)(paramArrayOfByte[i] + 1);
    while (i >= 0 && (byte)(paramArrayOfByte[i] + 1) == 0)
      i--; 
  }
  
  private static boolean isTooLarge(byte[] paramArrayOfByte, int paramInt) { return (paramArrayOfByte != null && paramArrayOfByte.length > paramInt); }
}
