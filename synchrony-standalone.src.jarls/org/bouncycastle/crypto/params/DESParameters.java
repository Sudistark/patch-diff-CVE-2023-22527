package org.bouncycastle.crypto.params;

public class DESParameters extends KeyParameter {
  public static final int DES_KEY_LENGTH = 8;
  
  private static final int N_DES_WEAK_KEYS = 16;
  
  private static byte[] DES_weak_keys = { 
      1, 1, 1, 1, 1, 1, 1, 1, 31, 31, 
      31, 31, 14, 14, 14, 14, -32, -32, -32, -32, 
      -15, -15, -15, -15, -2, -2, -2, -2, -2, -2, 
      -2, -2, 1, -2, 1, -2, 1, -2, 1, -2, 
      31, -32, 31, -32, 14, -15, 14, -15, 1, -32, 
      1, -32, 1, -15, 1, -15, 31, -2, 31, -2, 
      14, -2, 14, -2, 1, 31, 1, 31, 1, 14, 
      1, 14, -32, -2, -32, -2, -15, -2, -15, -2, 
      -2, 1, -2, 1, -2, 1, -2, 1, -32, 31, 
      -32, 31, -15, 14, -15, 14, -32, 1, -32, 1, 
      -15, 1, -15, 1, -2, 31, -2, 31, -2, 14, 
      -2, 14, 31, 1, 31, 1, 14, 1, 14, 1, 
      -2, -32, -2, -32, -2, -15, -2, -15 };
  
  public DESParameters(byte[] paramArrayOfByte) {
    super(paramArrayOfByte);
    if (isWeakKey(paramArrayOfByte, 0))
      throw new IllegalArgumentException("attempt to create weak DES key"); 
  }
  
  public static boolean isWeakKey(byte[] paramArrayOfByte, int paramInt) {
    if (paramArrayOfByte.length - paramInt < 8)
      throw new IllegalArgumentException("key material too short."); 
    for (byte b = 0; b < 16; b++) {
      int i = 0;
      while (true) {
        if (i < 8) {
          if (paramArrayOfByte[i + paramInt] != DES_weak_keys[b * 8 + i])
            break; 
          i++;
          continue;
        } 
        return true;
      } 
    } 
    return false;
  }
  
  public static void setOddParity(byte[] paramArrayOfByte) {
    for (byte b = 0; b < paramArrayOfByte.length; b++) {
      byte b1 = paramArrayOfByte[b];
      paramArrayOfByte[b] = (byte)(b1 & 0xFE | (b1 >> 1 ^ b1 >> 2 ^ b1 >> 3 ^ b1 >> 4 ^ b1 >> 5 ^ b1 >> 6 ^ b1 >> 7 ^ true) & true);
    } 
  }
}
