package org.bouncycastle.crypto.encodings;

import java.security.SecureRandom;
import org.bouncycastle.crypto.AsymmetricBlockCipher;
import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.CryptoServicesRegistrar;
import org.bouncycastle.crypto.DataLengthException;
import org.bouncycastle.crypto.Digest;
import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.crypto.params.ParametersWithRandom;
import org.bouncycastle.crypto.util.DigestFactory;
import org.bouncycastle.util.Arrays;

public class OAEPEncoding implements AsymmetricBlockCipher {
  private byte[] defHash;
  
  private Digest mgf1Hash;
  
  private AsymmetricBlockCipher engine;
  
  private SecureRandom random;
  
  private boolean forEncryption;
  
  public OAEPEncoding(AsymmetricBlockCipher paramAsymmetricBlockCipher) { this(paramAsymmetricBlockCipher, DigestFactory.createSHA1(), null); }
  
  public OAEPEncoding(AsymmetricBlockCipher paramAsymmetricBlockCipher, Digest paramDigest) { this(paramAsymmetricBlockCipher, paramDigest, null); }
  
  public OAEPEncoding(AsymmetricBlockCipher paramAsymmetricBlockCipher, Digest paramDigest, byte[] paramArrayOfByte) { this(paramAsymmetricBlockCipher, paramDigest, paramDigest, paramArrayOfByte); }
  
  public OAEPEncoding(AsymmetricBlockCipher paramAsymmetricBlockCipher, Digest paramDigest1, Digest paramDigest2, byte[] paramArrayOfByte) {
    this.engine = paramAsymmetricBlockCipher;
    this.mgf1Hash = paramDigest2;
    this.defHash = new byte[paramDigest1.getDigestSize()];
    paramDigest1.reset();
    if (paramArrayOfByte != null)
      paramDigest1.update(paramArrayOfByte, 0, paramArrayOfByte.length); 
    paramDigest1.doFinal(this.defHash, 0);
  }
  
  public AsymmetricBlockCipher getUnderlyingCipher() { return this.engine; }
  
  public void init(boolean paramBoolean, CipherParameters paramCipherParameters) {
    if (paramCipherParameters instanceof ParametersWithRandom) {
      ParametersWithRandom parametersWithRandom = (ParametersWithRandom)paramCipherParameters;
      this.random = parametersWithRandom.getRandom();
    } else {
      this.random = CryptoServicesRegistrar.getSecureRandom();
    } 
    this.engine.init(paramBoolean, paramCipherParameters);
    this.forEncryption = paramBoolean;
  }
  
  public int getInputBlockSize() {
    int i = this.engine.getInputBlockSize();
    return this.forEncryption ? (i - 1 - 2 * this.defHash.length) : i;
  }
  
  public int getOutputBlockSize() {
    int i = this.engine.getOutputBlockSize();
    return this.forEncryption ? i : (i - 1 - 2 * this.defHash.length);
  }
  
  public byte[] processBlock(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws InvalidCipherTextException { return this.forEncryption ? encodeBlock(paramArrayOfByte, paramInt1, paramInt2) : decodeBlock(paramArrayOfByte, paramInt1, paramInt2); }
  
  public byte[] encodeBlock(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws InvalidCipherTextException {
    if (paramInt2 > getInputBlockSize())
      throw new DataLengthException("input data too long"); 
    byte[] arrayOfByte1 = new byte[getInputBlockSize() + 1 + 2 * this.defHash.length];
    System.arraycopy(paramArrayOfByte, paramInt1, arrayOfByte1, arrayOfByte1.length - paramInt2, paramInt2);
    arrayOfByte1[arrayOfByte1.length - paramInt2 - 1] = 1;
    System.arraycopy(this.defHash, 0, arrayOfByte1, this.defHash.length, this.defHash.length);
    byte[] arrayOfByte2 = new byte[this.defHash.length];
    this.random.nextBytes(arrayOfByte2);
    byte[] arrayOfByte3 = maskGeneratorFunction1(arrayOfByte2, 0, arrayOfByte2.length, arrayOfByte1.length - this.defHash.length);
    int i;
    for (i = this.defHash.length; i != arrayOfByte1.length; i++)
      arrayOfByte1[i] = (byte)(arrayOfByte1[i] ^ arrayOfByte3[i - this.defHash.length]); 
    System.arraycopy(arrayOfByte2, 0, arrayOfByte1, 0, this.defHash.length);
    arrayOfByte3 = maskGeneratorFunction1(arrayOfByte1, this.defHash.length, arrayOfByte1.length - this.defHash.length, this.defHash.length);
    for (i = 0; i != this.defHash.length; i++)
      arrayOfByte1[i] = (byte)(arrayOfByte1[i] ^ arrayOfByte3[i]); 
    return this.engine.processBlock(arrayOfByte1, 0, arrayOfByte1.length);
  }
  
  public byte[] decodeBlock(byte[] paramArrayOfByte, int paramInt1, int paramInt2) throws InvalidCipherTextException {
    byte[] arrayOfByte1 = this.engine.processBlock(paramArrayOfByte, paramInt1, paramInt2);
    byte[] arrayOfByte2 = new byte[this.engine.getOutputBlockSize()];
    int i = (arrayOfByte2.length < 2 * this.defHash.length + 1) ? 1 : 0;
    if (arrayOfByte1.length <= arrayOfByte2.length) {
      System.arraycopy(arrayOfByte1, 0, arrayOfByte2, arrayOfByte2.length - arrayOfByte1.length, arrayOfByte1.length);
    } else {
      System.arraycopy(arrayOfByte1, 0, arrayOfByte2, 0, arrayOfByte2.length);
      i = 1;
    } 
    byte[] arrayOfByte3 = maskGeneratorFunction1(arrayOfByte2, this.defHash.length, arrayOfByte2.length - this.defHash.length, this.defHash.length);
    int j;
    for (j = 0; j != this.defHash.length; j++)
      arrayOfByte2[j] = (byte)(arrayOfByte2[j] ^ arrayOfByte3[j]); 
    arrayOfByte3 = maskGeneratorFunction1(arrayOfByte2, 0, this.defHash.length, arrayOfByte2.length - this.defHash.length);
    for (j = this.defHash.length; j != arrayOfByte2.length; j++)
      arrayOfByte2[j] = (byte)(arrayOfByte2[j] ^ arrayOfByte3[j - this.defHash.length]); 
    j = 0;
    int k;
    for (k = 0; k != this.defHash.length; k++) {
      if (this.defHash[k] != arrayOfByte2[this.defHash.length + k])
        j = 1; 
    } 
    k = arrayOfByte2.length;
    int m;
    for (m = 2 * this.defHash.length; m != arrayOfByte2.length; m++) {
      if (((arrayOfByte2[m] != 0) ? 1 : 0) & ((k == arrayOfByte2.length) ? 1 : 0))
        k = m; 
    } 
    m = ((k > arrayOfByte2.length - 1) ? 1 : 0) | ((arrayOfByte2[k] != 1) ? 1 : 0);
    k++;
    if ((j | i | m) != 0) {
      Arrays.fill(arrayOfByte2, (byte)0);
      throw new InvalidCipherTextException("data wrong");
    } 
    byte[] arrayOfByte4 = new byte[arrayOfByte2.length - k];
    System.arraycopy(arrayOfByte2, k, arrayOfByte4, 0, arrayOfByte4.length);
    Arrays.fill(arrayOfByte2, (byte)0);
    return arrayOfByte4;
  }
  
  private void ItoOSP(int paramInt, byte[] paramArrayOfByte) {
    paramArrayOfByte[0] = (byte)(paramInt >>> 24);
    paramArrayOfByte[1] = (byte)(paramInt >>> 16);
    paramArrayOfByte[2] = (byte)(paramInt >>> 8);
    paramArrayOfByte[3] = (byte)(paramInt >>> 0);
  }
  
  private byte[] maskGeneratorFunction1(byte[] paramArrayOfByte, int paramInt1, int paramInt2, int paramInt3) {
    byte[] arrayOfByte1 = new byte[paramInt3];
    byte[] arrayOfByte2 = new byte[this.mgf1Hash.getDigestSize()];
    byte[] arrayOfByte3 = new byte[4];
    int i = 0;
    this.mgf1Hash.reset();
    while (i < paramInt3 / arrayOfByte2.length) {
      ItoOSP(i, arrayOfByte3);
      this.mgf1Hash.update(paramArrayOfByte, paramInt1, paramInt2);
      this.mgf1Hash.update(arrayOfByte3, 0, arrayOfByte3.length);
      this.mgf1Hash.doFinal(arrayOfByte2, 0);
      System.arraycopy(arrayOfByte2, 0, arrayOfByte1, i * arrayOfByte2.length, arrayOfByte2.length);
      i++;
    } 
    if (i * arrayOfByte2.length < paramInt3) {
      ItoOSP(i, arrayOfByte3);
      this.mgf1Hash.update(paramArrayOfByte, paramInt1, paramInt2);
      this.mgf1Hash.update(arrayOfByte3, 0, arrayOfByte3.length);
      this.mgf1Hash.doFinal(arrayOfByte2, 0);
      System.arraycopy(arrayOfByte2, 0, arrayOfByte1, i * arrayOfByte2.length, arrayOfByte1.length - i * arrayOfByte2.length);
    } 
    return arrayOfByte1;
  }
}
