package org.bouncycastle.crypto.fpe;

import java.math.BigInteger;
import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.BigIntegers;
import org.bouncycastle.util.Pack;

class SP80038G {
  static final String FPE_DISABLED = "org.bouncycastle.fpe.disable";
  
  static final String FF1_DISABLED = "org.bouncycastle.fpe.disable_ff1";
  
  protected static final int BLOCK_SIZE = 16;
  
  protected static final double LOG2 = Math.log(2.0D);
  
  protected static final double TWO_TO_96 = Math.pow(2.0D, 96.0D);
  
  static byte[] decryptFF1(BlockCipher paramBlockCipher, int paramInt1, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt2, int paramInt3) {
    checkArgs(paramBlockCipher, true, paramInt1, paramArrayOfByte2, paramInt2, paramInt3);
    int i = paramInt3;
    int j = i / 2;
    int k = i - j;
    short[] arrayOfShort1 = toShort(paramArrayOfByte2, paramInt2, j);
    short[] arrayOfShort2 = toShort(paramArrayOfByte2, paramInt2 + j, k);
    short[] arrayOfShort3 = decFF1(paramBlockCipher, paramInt1, paramArrayOfByte1, i, j, k, arrayOfShort1, arrayOfShort2);
    return toByte(arrayOfShort3);
  }
  
  static short[] decryptFF1w(BlockCipher paramBlockCipher, int paramInt1, byte[] paramArrayOfByte, short[] paramArrayOfShort, int paramInt2, int paramInt3) {
    checkArgs(paramBlockCipher, true, paramInt1, paramArrayOfShort, paramInt2, paramInt3);
    int i = paramInt3;
    int j = i / 2;
    int k = i - j;
    short[] arrayOfShort1 = new short[j];
    short[] arrayOfShort2 = new short[k];
    System.arraycopy(paramArrayOfShort, paramInt2, arrayOfShort1, 0, j);
    System.arraycopy(paramArrayOfShort, paramInt2 + j, arrayOfShort2, 0, k);
    return decFF1(paramBlockCipher, paramInt1, paramArrayOfByte, i, j, k, arrayOfShort1, arrayOfShort2);
  }
  
  static short[] decFF1(BlockCipher paramBlockCipher, int paramInt1, byte[] paramArrayOfByte, int paramInt2, int paramInt3, int paramInt4, short[] paramArrayOfShort1, short[] paramArrayOfShort2) {
    int i = paramArrayOfByte.length;
    int j = ((int)Math.ceil(Math.log(paramInt1) * paramInt4 / LOG2) + 7) / 8;
    int k = (j + 3) / 4 * 4 + 4;
    byte[] arrayOfByte = calculateP_FF1(paramInt1, (byte)paramInt3, paramInt2, i);
    BigInteger bigInteger = BigInteger.valueOf(paramInt1);
    BigInteger[] arrayOfBigInteger = calculateModUV(bigInteger, paramInt3, paramInt4);
    int m = paramInt3;
    for (byte b = 9; b >= 0; b--) {
      BigInteger bigInteger1 = calculateY_FF1(paramBlockCipher, bigInteger, paramArrayOfByte, j, k, b, arrayOfByte, paramArrayOfShort1);
      m = paramInt2 - m;
      BigInteger bigInteger2 = arrayOfBigInteger[b & true];
      BigInteger bigInteger3 = num(bigInteger, paramArrayOfShort2).subtract(bigInteger1).mod(bigInteger2);
      short[] arrayOfShort = paramArrayOfShort2;
      paramArrayOfShort2 = paramArrayOfShort1;
      paramArrayOfShort1 = arrayOfShort;
      str(bigInteger, bigInteger3, m, arrayOfShort, 0);
    } 
    return Arrays.concatenate(paramArrayOfShort1, paramArrayOfShort2);
  }
  
  static byte[] decryptFF3(BlockCipher paramBlockCipher, int paramInt1, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt2, int paramInt3) {
    checkArgs(paramBlockCipher, false, paramInt1, paramArrayOfByte2, paramInt2, paramInt3);
    if (paramArrayOfByte1.length != 8)
      throw new IllegalArgumentException(); 
    return implDecryptFF3(paramBlockCipher, paramInt1, paramArrayOfByte1, paramArrayOfByte2, paramInt2, paramInt3);
  }
  
  static byte[] decryptFF3_1(BlockCipher paramBlockCipher, int paramInt1, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt2, int paramInt3) {
    checkArgs(paramBlockCipher, false, paramInt1, paramArrayOfByte2, paramInt2, paramInt3);
    if (paramArrayOfByte1.length != 7)
      throw new IllegalArgumentException("tweak should be 56 bits"); 
    byte[] arrayOfByte = calculateTweak64_FF3_1(paramArrayOfByte1);
    return implDecryptFF3(paramBlockCipher, paramInt1, arrayOfByte, paramArrayOfByte2, paramInt2, paramInt3);
  }
  
  static short[] decryptFF3_1w(BlockCipher paramBlockCipher, int paramInt1, byte[] paramArrayOfByte, short[] paramArrayOfShort, int paramInt2, int paramInt3) {
    checkArgs(paramBlockCipher, false, paramInt1, paramArrayOfShort, paramInt2, paramInt3);
    if (paramArrayOfByte.length != 7)
      throw new IllegalArgumentException("tweak should be 56 bits"); 
    byte[] arrayOfByte = calculateTweak64_FF3_1(paramArrayOfByte);
    return implDecryptFF3w(paramBlockCipher, paramInt1, arrayOfByte, paramArrayOfShort, paramInt2, paramInt3);
  }
  
  static byte[] encryptFF1(BlockCipher paramBlockCipher, int paramInt1, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt2, int paramInt3) {
    checkArgs(paramBlockCipher, true, paramInt1, paramArrayOfByte2, paramInt2, paramInt3);
    int i = paramInt3;
    int j = i / 2;
    int k = i - j;
    short[] arrayOfShort1 = toShort(paramArrayOfByte2, paramInt2, j);
    short[] arrayOfShort2 = toShort(paramArrayOfByte2, paramInt2 + j, k);
    return toByte(encFF1(paramBlockCipher, paramInt1, paramArrayOfByte1, i, j, k, arrayOfShort1, arrayOfShort2));
  }
  
  static short[] encryptFF1w(BlockCipher paramBlockCipher, int paramInt1, byte[] paramArrayOfByte, short[] paramArrayOfShort, int paramInt2, int paramInt3) {
    checkArgs(paramBlockCipher, true, paramInt1, paramArrayOfShort, paramInt2, paramInt3);
    int i = paramInt3;
    int j = i / 2;
    int k = i - j;
    short[] arrayOfShort1 = new short[j];
    short[] arrayOfShort2 = new short[k];
    System.arraycopy(paramArrayOfShort, paramInt2, arrayOfShort1, 0, j);
    System.arraycopy(paramArrayOfShort, paramInt2 + j, arrayOfShort2, 0, k);
    return encFF1(paramBlockCipher, paramInt1, paramArrayOfByte, i, j, k, arrayOfShort1, arrayOfShort2);
  }
  
  private static short[] encFF1(BlockCipher paramBlockCipher, int paramInt1, byte[] paramArrayOfByte, int paramInt2, int paramInt3, int paramInt4, short[] paramArrayOfShort1, short[] paramArrayOfShort2) {
    int i = paramArrayOfByte.length;
    int j = ((int)Math.ceil(Math.log(paramInt1) * paramInt4 / LOG2) + 7) / 8;
    int k = (j + 3) / 4 * 4 + 4;
    byte[] arrayOfByte = calculateP_FF1(paramInt1, (byte)paramInt3, paramInt2, i);
    BigInteger bigInteger = BigInteger.valueOf(paramInt1);
    BigInteger[] arrayOfBigInteger = calculateModUV(bigInteger, paramInt3, paramInt4);
    int m = paramInt4;
    for (byte b = 0; b < 10; b++) {
      BigInteger bigInteger1 = calculateY_FF1(paramBlockCipher, bigInteger, paramArrayOfByte, j, k, b, arrayOfByte, paramArrayOfShort2);
      m = paramInt2 - m;
      BigInteger bigInteger2 = arrayOfBigInteger[b & true];
      BigInteger bigInteger3 = num(bigInteger, paramArrayOfShort1).add(bigInteger1).mod(bigInteger2);
      short[] arrayOfShort = paramArrayOfShort1;
      paramArrayOfShort1 = paramArrayOfShort2;
      paramArrayOfShort2 = arrayOfShort;
      str(bigInteger, bigInteger3, m, arrayOfShort, 0);
    } 
    return Arrays.concatenate(paramArrayOfShort1, paramArrayOfShort2);
  }
  
  static byte[] encryptFF3(BlockCipher paramBlockCipher, int paramInt1, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt2, int paramInt3) {
    checkArgs(paramBlockCipher, false, paramInt1, paramArrayOfByte2, paramInt2, paramInt3);
    if (paramArrayOfByte1.length != 8)
      throw new IllegalArgumentException(); 
    return implEncryptFF3(paramBlockCipher, paramInt1, paramArrayOfByte1, paramArrayOfByte2, paramInt2, paramInt3);
  }
  
  static short[] encryptFF3w(BlockCipher paramBlockCipher, int paramInt1, byte[] paramArrayOfByte, short[] paramArrayOfShort, int paramInt2, int paramInt3) {
    checkArgs(paramBlockCipher, false, paramInt1, paramArrayOfShort, paramInt2, paramInt3);
    if (paramArrayOfByte.length != 8)
      throw new IllegalArgumentException(); 
    return implEncryptFF3w(paramBlockCipher, paramInt1, paramArrayOfByte, paramArrayOfShort, paramInt2, paramInt3);
  }
  
  static short[] encryptFF3_1w(BlockCipher paramBlockCipher, int paramInt1, byte[] paramArrayOfByte, short[] paramArrayOfShort, int paramInt2, int paramInt3) {
    checkArgs(paramBlockCipher, false, paramInt1, paramArrayOfShort, paramInt2, paramInt3);
    if (paramArrayOfByte.length != 7)
      throw new IllegalArgumentException("tweak should be 56 bits"); 
    byte[] arrayOfByte = calculateTweak64_FF3_1(paramArrayOfByte);
    return encryptFF3w(paramBlockCipher, paramInt1, arrayOfByte, paramArrayOfShort, paramInt2, paramInt3);
  }
  
  static byte[] encryptFF3_1(BlockCipher paramBlockCipher, int paramInt1, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt2, int paramInt3) {
    checkArgs(paramBlockCipher, false, paramInt1, paramArrayOfByte2, paramInt2, paramInt3);
    if (paramArrayOfByte1.length != 7)
      throw new IllegalArgumentException("tweak should be 56 bits"); 
    byte[] arrayOfByte = calculateTweak64_FF3_1(paramArrayOfByte1);
    return encryptFF3(paramBlockCipher, paramInt1, arrayOfByte, paramArrayOfByte2, paramInt2, paramInt3);
  }
  
  protected static BigInteger[] calculateModUV(BigInteger paramBigInteger, int paramInt1, int paramInt2) {
    BigInteger[] arrayOfBigInteger = new BigInteger[2];
    arrayOfBigInteger[0] = paramBigInteger.pow(paramInt1);
    arrayOfBigInteger[1] = arrayOfBigInteger[0];
    if (paramInt2 != paramInt1)
      arrayOfBigInteger[1] = arrayOfBigInteger[1].multiply(paramBigInteger); 
    return arrayOfBigInteger;
  }
  
  protected static byte[] calculateP_FF1(int paramInt1, byte paramByte, int paramInt2, int paramInt3) {
    byte[] arrayOfByte = new byte[16];
    arrayOfByte[0] = 1;
    arrayOfByte[1] = 2;
    arrayOfByte[2] = 1;
    arrayOfByte[3] = 0;
    arrayOfByte[4] = (byte)(paramInt1 >> 8);
    arrayOfByte[5] = (byte)paramInt1;
    arrayOfByte[6] = 10;
    arrayOfByte[7] = paramByte;
    Pack.intToBigEndian(paramInt2, arrayOfByte, 8);
    Pack.intToBigEndian(paramInt3, arrayOfByte, 12);
    return arrayOfByte;
  }
  
  protected static byte[] calculateTweak64_FF3_1(byte[] paramArrayOfByte) {
    byte[] arrayOfByte = new byte[8];
    arrayOfByte[0] = paramArrayOfByte[0];
    arrayOfByte[1] = paramArrayOfByte[1];
    arrayOfByte[2] = paramArrayOfByte[2];
    arrayOfByte[3] = (byte)(paramArrayOfByte[3] & 0xF0);
    arrayOfByte[4] = paramArrayOfByte[4];
    arrayOfByte[5] = paramArrayOfByte[5];
    arrayOfByte[6] = paramArrayOfByte[6];
    arrayOfByte[7] = (byte)(paramArrayOfByte[3] << 4);
    return arrayOfByte;
  }
  
  protected static BigInteger calculateY_FF1(BlockCipher paramBlockCipher, BigInteger paramBigInteger, byte[] paramArrayOfByte1, int paramInt1, int paramInt2, int paramInt3, byte[] paramArrayOfByte2, short[] paramArrayOfShort) {
    int i = paramArrayOfByte1.length;
    BigInteger bigInteger = num(paramBigInteger, paramArrayOfShort);
    byte[] arrayOfByte1 = BigIntegers.asUnsignedByteArray(bigInteger);
    int j = -(i + paramInt1 + 1) & 0xF;
    byte[] arrayOfByte2 = new byte[i + j + 1 + paramInt1];
    System.arraycopy(paramArrayOfByte1, 0, arrayOfByte2, 0, i);
    arrayOfByte2[i + j] = (byte)paramInt3;
    System.arraycopy(arrayOfByte1, 0, arrayOfByte2, arrayOfByte2.length - arrayOfByte1.length, arrayOfByte1.length);
    byte[] arrayOfByte3 = prf(paramBlockCipher, Arrays.concatenate(paramArrayOfByte2, arrayOfByte2));
    byte[] arrayOfByte4 = arrayOfByte3;
    if (paramInt2 > 16) {
      int k = (paramInt2 + 16 - 1) / 16;
      arrayOfByte4 = new byte[k * 16];
      System.arraycopy(arrayOfByte3, 0, arrayOfByte4, 0, 16);
      byte[] arrayOfByte = new byte[4];
      for (byte b = 1; b < k; b++) {
        byte b1 = b * 16;
        System.arraycopy(arrayOfByte3, 0, arrayOfByte4, b1, 16);
        Pack.intToBigEndian(b, arrayOfByte, 0);
        xor(arrayOfByte, 0, arrayOfByte4, b1 + 16 - 4, 4);
        paramBlockCipher.processBlock(arrayOfByte4, b1, arrayOfByte4, b1);
      } 
    } 
    return num(arrayOfByte4, 0, paramInt2);
  }
  
  protected static BigInteger calculateY_FF3(BlockCipher paramBlockCipher, BigInteger paramBigInteger, byte[] paramArrayOfByte, int paramInt1, int paramInt2, short[] paramArrayOfShort) {
    byte[] arrayOfByte1 = new byte[16];
    Pack.intToBigEndian(paramInt2, arrayOfByte1, 0);
    xor(paramArrayOfByte, paramInt1, arrayOfByte1, 0, 4);
    BigInteger bigInteger = num(paramBigInteger, paramArrayOfShort);
    byte[] arrayOfByte2 = BigIntegers.asUnsignedByteArray(bigInteger);
    if (arrayOfByte1.length - arrayOfByte2.length < 4)
      throw new IllegalStateException("input out of range"); 
    System.arraycopy(arrayOfByte2, 0, arrayOfByte1, arrayOfByte1.length - arrayOfByte2.length, arrayOfByte2.length);
    rev(arrayOfByte1);
    paramBlockCipher.processBlock(arrayOfByte1, 0, arrayOfByte1, 0);
    rev(arrayOfByte1);
    byte[] arrayOfByte3 = arrayOfByte1;
    return num(arrayOfByte3, 0, arrayOfByte3.length);
  }
  
  protected static void checkArgs(BlockCipher paramBlockCipher, boolean paramBoolean, int paramInt1, short[] paramArrayOfShort, int paramInt2, int paramInt3) {
    checkCipher(paramBlockCipher);
    if (paramInt1 < 2 || paramInt1 > 65536)
      throw new IllegalArgumentException(); 
    checkData(paramBoolean, paramInt1, paramArrayOfShort, paramInt2, paramInt3);
  }
  
  protected static void checkArgs(BlockCipher paramBlockCipher, boolean paramBoolean, int paramInt1, byte[] paramArrayOfByte, int paramInt2, int paramInt3) {
    checkCipher(paramBlockCipher);
    if (paramInt1 < 2 || paramInt1 > 256)
      throw new IllegalArgumentException(); 
    checkData(paramBoolean, paramInt1, paramArrayOfByte, paramInt2, paramInt3);
  }
  
  protected static void checkCipher(BlockCipher paramBlockCipher) {
    if (16 != paramBlockCipher.getBlockSize())
      throw new IllegalArgumentException(); 
  }
  
  protected static void checkData(boolean paramBoolean, int paramInt1, short[] paramArrayOfShort, int paramInt2, int paramInt3) {
    checkLength(paramBoolean, paramInt1, paramInt3);
    for (int i = 0; i < paramInt3; i++) {
      short s = paramArrayOfShort[paramInt2 + i] & 0xFFFF;
      if (s >= paramInt1)
        throw new IllegalArgumentException("input data outside of radix"); 
    } 
  }
  
  protected static void checkData(boolean paramBoolean, int paramInt1, byte[] paramArrayOfByte, int paramInt2, int paramInt3) {
    checkLength(paramBoolean, paramInt1, paramInt3);
    for (int i = 0; i < paramInt3; i++) {
      byte b = paramArrayOfByte[paramInt2 + i] & 0xFF;
      if (b >= paramInt1)
        throw new IllegalArgumentException("input data outside of radix"); 
    } 
  }
  
  private static void checkLength(boolean paramBoolean, int paramInt1, int paramInt2) {
    if (paramInt2 < 2 || Math.pow(paramInt1, paramInt2) < 1000000.0D)
      throw new IllegalArgumentException("input too short"); 
    if (!paramBoolean) {
      int i = 2 * (int)Math.floor(Math.log(TWO_TO_96) / Math.log(paramInt1));
      if (paramInt2 > i)
        throw new IllegalArgumentException("maximum input length is " + i); 
    } 
  }
  
  protected static byte[] implDecryptFF3(BlockCipher paramBlockCipher, int paramInt1, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt2, int paramInt3) {
    byte[] arrayOfByte = paramArrayOfByte1;
    int i = paramInt3;
    int j = i / 2;
    int k = i - j;
    short[] arrayOfShort1 = toShort(paramArrayOfByte2, paramInt2, k);
    short[] arrayOfShort2 = toShort(paramArrayOfByte2, paramInt2 + k, j);
    short[] arrayOfShort3 = decFF3_1(paramBlockCipher, paramInt1, arrayOfByte, i, j, k, arrayOfShort1, arrayOfShort2);
    return toByte(arrayOfShort3);
  }
  
  protected static short[] implDecryptFF3w(BlockCipher paramBlockCipher, int paramInt1, byte[] paramArrayOfByte, short[] paramArrayOfShort, int paramInt2, int paramInt3) {
    byte[] arrayOfByte = paramArrayOfByte;
    int i = paramInt3;
    int j = i / 2;
    int k = i - j;
    short[] arrayOfShort1 = new short[k];
    short[] arrayOfShort2 = new short[j];
    System.arraycopy(paramArrayOfShort, paramInt2, arrayOfShort1, 0, k);
    System.arraycopy(paramArrayOfShort, paramInt2 + k, arrayOfShort2, 0, j);
    return decFF3_1(paramBlockCipher, paramInt1, arrayOfByte, i, j, k, arrayOfShort1, arrayOfShort2);
  }
  
  private static short[] decFF3_1(BlockCipher paramBlockCipher, int paramInt1, byte[] paramArrayOfByte, int paramInt2, int paramInt3, int paramInt4, short[] paramArrayOfShort1, short[] paramArrayOfShort2) {
    BigInteger bigInteger = BigInteger.valueOf(paramInt1);
    BigInteger[] arrayOfBigInteger = calculateModUV(bigInteger, paramInt3, paramInt4);
    int i = paramInt4;
    rev(paramArrayOfShort1);
    rev(paramArrayOfShort2);
    for (byte b = 7; b >= 0; b--) {
      i = paramInt2 - i;
      BigInteger bigInteger1 = arrayOfBigInteger[1 - (b & true)];
      byte b1 = 4 - (b & true) * 4;
      BigInteger bigInteger2 = calculateY_FF3(paramBlockCipher, bigInteger, paramArrayOfByte, b1, b, paramArrayOfShort1);
      BigInteger bigInteger3 = num(bigInteger, paramArrayOfShort2).subtract(bigInteger2).mod(bigInteger1);
      short[] arrayOfShort = paramArrayOfShort2;
      paramArrayOfShort2 = paramArrayOfShort1;
      paramArrayOfShort1 = arrayOfShort;
      str(bigInteger, bigInteger3, i, arrayOfShort, 0);
    } 
    rev(paramArrayOfShort1);
    rev(paramArrayOfShort2);
    return Arrays.concatenate(paramArrayOfShort1, paramArrayOfShort2);
  }
  
  protected static byte[] implEncryptFF3(BlockCipher paramBlockCipher, int paramInt1, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt2, int paramInt3) {
    byte[] arrayOfByte = paramArrayOfByte1;
    int i = paramInt3;
    int j = i / 2;
    int k = i - j;
    short[] arrayOfShort1 = toShort(paramArrayOfByte2, paramInt2, k);
    short[] arrayOfShort2 = toShort(paramArrayOfByte2, paramInt2 + k, j);
    short[] arrayOfShort3 = encFF3_1(paramBlockCipher, paramInt1, arrayOfByte, i, j, k, arrayOfShort1, arrayOfShort2);
    return toByte(arrayOfShort3);
  }
  
  protected static short[] implEncryptFF3w(BlockCipher paramBlockCipher, int paramInt1, byte[] paramArrayOfByte, short[] paramArrayOfShort, int paramInt2, int paramInt3) {
    byte[] arrayOfByte = paramArrayOfByte;
    int i = paramInt3;
    int j = i / 2;
    int k = i - j;
    short[] arrayOfShort1 = new short[k];
    short[] arrayOfShort2 = new short[j];
    System.arraycopy(paramArrayOfShort, paramInt2, arrayOfShort1, 0, k);
    System.arraycopy(paramArrayOfShort, paramInt2 + k, arrayOfShort2, 0, j);
    return encFF3_1(paramBlockCipher, paramInt1, arrayOfByte, i, j, k, arrayOfShort1, arrayOfShort2);
  }
  
  private static short[] encFF3_1(BlockCipher paramBlockCipher, int paramInt1, byte[] paramArrayOfByte, int paramInt2, int paramInt3, int paramInt4, short[] paramArrayOfShort1, short[] paramArrayOfShort2) {
    BigInteger bigInteger = BigInteger.valueOf(paramInt1);
    BigInteger[] arrayOfBigInteger = calculateModUV(bigInteger, paramInt3, paramInt4);
    int i = paramInt3;
    rev(paramArrayOfShort1);
    rev(paramArrayOfShort2);
    for (byte b = 0; b < 8; b++) {
      i = paramInt2 - i;
      BigInteger bigInteger1 = arrayOfBigInteger[true - (b & true)];
      byte b1 = 4 - (b & true) * 4;
      BigInteger bigInteger2 = calculateY_FF3(paramBlockCipher, bigInteger, paramArrayOfByte, b1, b, paramArrayOfShort2);
      BigInteger bigInteger3 = num(bigInteger, paramArrayOfShort1).add(bigInteger2).mod(bigInteger1);
      short[] arrayOfShort = paramArrayOfShort1;
      paramArrayOfShort1 = paramArrayOfShort2;
      paramArrayOfShort2 = arrayOfShort;
      str(bigInteger, bigInteger3, i, arrayOfShort, 0);
    } 
    rev(paramArrayOfShort1);
    rev(paramArrayOfShort2);
    return Arrays.concatenate(paramArrayOfShort1, paramArrayOfShort2);
  }
  
  protected static BigInteger num(byte[] paramArrayOfByte, int paramInt1, int paramInt2) { return new BigInteger(1, Arrays.copyOfRange(paramArrayOfByte, paramInt1, paramInt1 + paramInt2)); }
  
  protected static BigInteger num(BigInteger paramBigInteger, short[] paramArrayOfShort) {
    BigInteger bigInteger = BigIntegers.ZERO;
    for (byte b = 0; b < paramArrayOfShort.length; b++)
      bigInteger = bigInteger.multiply(paramBigInteger).add(BigInteger.valueOf((paramArrayOfShort[b] & 0xFFFF))); 
    return bigInteger;
  }
  
  protected static byte[] prf(BlockCipher paramBlockCipher, byte[] paramArrayOfByte) {
    if (paramArrayOfByte.length % 16 != 0)
      throw new IllegalArgumentException(); 
    int i = paramArrayOfByte.length / 16;
    byte[] arrayOfByte = new byte[16];
    for (byte b = 0; b < i; b++) {
      xor(paramArrayOfByte, b * 16, arrayOfByte, 0, 16);
      paramBlockCipher.processBlock(arrayOfByte, 0, arrayOfByte, 0);
    } 
    return arrayOfByte;
  }
  
  protected static void rev(byte[] paramArrayOfByte) {
    int i = paramArrayOfByte.length / 2;
    int j = paramArrayOfByte.length - 1;
    for (int k = 0; k < i; k++) {
      byte b = paramArrayOfByte[k];
      paramArrayOfByte[k] = paramArrayOfByte[j - k];
      paramArrayOfByte[j - k] = b;
    } 
  }
  
  protected static void rev(short[] paramArrayOfShort) {
    int i = paramArrayOfShort.length / 2;
    int j = paramArrayOfShort.length - 1;
    for (int k = 0; k < i; k++) {
      short s = paramArrayOfShort[k];
      paramArrayOfShort[k] = paramArrayOfShort[j - k];
      paramArrayOfShort[j - k] = s;
    } 
  }
  
  protected static void str(BigInteger paramBigInteger1, BigInteger paramBigInteger2, int paramInt1, short[] paramArrayOfShort, int paramInt2) {
    if (paramBigInteger2.signum() < 0)
      throw new IllegalArgumentException(); 
    for (int i = 1; i <= paramInt1; i++) {
      BigInteger[] arrayOfBigInteger = paramBigInteger2.divideAndRemainder(paramBigInteger1);
      paramArrayOfShort[paramInt2 + paramInt1 - i] = (short)arrayOfBigInteger[1].intValue();
      paramBigInteger2 = arrayOfBigInteger[0];
    } 
    if (paramBigInteger2.signum() != 0)
      throw new IllegalArgumentException(); 
  }
  
  protected static void xor(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, int paramInt3) {
    for (int i = 0; i < paramInt3; i++)
      paramArrayOfByte2[paramInt2 + i] = (byte)(paramArrayOfByte2[paramInt2 + i] ^ paramArrayOfByte1[paramInt1 + i]); 
  }
  
  private static byte[] toByte(short[] paramArrayOfShort) {
    byte[] arrayOfByte = new byte[paramArrayOfShort.length];
    for (byte b = 0; b != arrayOfByte.length; b++)
      arrayOfByte[b] = (byte)paramArrayOfShort[b]; 
    return arrayOfByte;
  }
  
  private static short[] toShort(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    short[] arrayOfShort = new short[paramInt2];
    for (int i = 0; i != arrayOfShort.length; i++)
      arrayOfShort[i] = (short)(paramArrayOfByte[paramInt1 + i] & 0xFF); 
    return arrayOfShort;
  }
}
