package org.bouncycastle.jce.provider;

import org.bouncycastle.crypto.CipherParameters;
import org.bouncycastle.crypto.Digest;
import org.bouncycastle.crypto.PBEParametersGenerator;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.ParametersWithIV;

class OldPKCS12ParametersGenerator extends PBEParametersGenerator {
  public static final int KEY_MATERIAL = 1;
  
  public static final int IV_MATERIAL = 2;
  
  public static final int MAC_MATERIAL = 3;
  
  private Digest digest;
  
  private int u;
  
  private int v;
  
  public OldPKCS12ParametersGenerator(Digest paramDigest) {
    this.digest = paramDigest;
    if (paramDigest instanceof org.bouncycastle.crypto.digests.MD5Digest) {
      this.u = 16;
      this.v = 64;
    } else if (paramDigest instanceof org.bouncycastle.crypto.digests.SHA1Digest) {
      this.u = 20;
      this.v = 64;
    } else if (paramDigest instanceof org.bouncycastle.crypto.digests.RIPEMD160Digest) {
      this.u = 20;
      this.v = 64;
    } else {
      throw new IllegalArgumentException("Digest " + paramDigest.getAlgorithmName() + " unsupported");
    } 
  }
  
  private void adjust(byte[] paramArrayOfByte1, int paramInt, byte[] paramArrayOfByte2) {
    byte b = (paramArrayOfByte2[paramArrayOfByte2.length - 1] & 0xFF) + (paramArrayOfByte1[paramInt + paramArrayOfByte2.length - 1] & 0xFF) + 1;
    paramArrayOfByte1[paramInt + paramArrayOfByte2.length - 1] = (byte)b;
    b >>>= 8;
    for (int i = paramArrayOfByte2.length - 2; i >= 0; i--) {
      b += (paramArrayOfByte2[i] & 0xFF) + (paramArrayOfByte1[paramInt + i] & 0xFF);
      paramArrayOfByte1[paramInt + i] = (byte)b;
      b >>>= 8;
    } 
  }
  
  private byte[] generateDerivedKey(int paramInt1, int paramInt2) {
    byte[] arrayOfByte4;
    byte[] arrayOfByte3;
    byte[] arrayOfByte1 = new byte[this.v];
    byte[] arrayOfByte2 = new byte[paramInt2];
    for (byte b1 = 0; b1 != arrayOfByte1.length; b1++)
      arrayOfByte1[b1] = (byte)paramInt1; 
    if (this.salt != null && this.salt.length != 0) {
      arrayOfByte3 = new byte[this.v * (this.salt.length + this.v - 1) / this.v];
      for (int j = 0; j != arrayOfByte3.length; j++)
        arrayOfByte3[j] = this.salt[j % this.salt.length]; 
    } else {
      arrayOfByte3 = new byte[0];
    } 
    if (this.password != null && this.password.length != 0) {
      arrayOfByte4 = new byte[this.v * (this.password.length + this.v - 1) / this.v];
      for (int j = 0; j != arrayOfByte4.length; j++)
        arrayOfByte4[j] = this.password[j % this.password.length]; 
    } else {
      arrayOfByte4 = new byte[0];
    } 
    byte[] arrayOfByte5 = new byte[arrayOfByte3.length + arrayOfByte4.length];
    System.arraycopy(arrayOfByte3, 0, arrayOfByte5, 0, arrayOfByte3.length);
    System.arraycopy(arrayOfByte4, 0, arrayOfByte5, arrayOfByte3.length, arrayOfByte4.length);
    byte[] arrayOfByte6 = new byte[this.v];
    int i = (paramInt2 + this.u - 1) / this.u;
    for (byte b2 = 1; b2 <= i; b2++) {
      byte[] arrayOfByte = new byte[this.u];
      this.digest.update(arrayOfByte1, 0, arrayOfByte1.length);
      this.digest.update(arrayOfByte5, 0, arrayOfByte5.length);
      this.digest.doFinal(arrayOfByte, 0);
      int j;
      for (j = 1; j != this.iterationCount; j++) {
        this.digest.update(arrayOfByte, 0, arrayOfByte.length);
        this.digest.doFinal(arrayOfByte, 0);
      } 
      for (j = 0; j != arrayOfByte6.length; j++)
        arrayOfByte6[b2] = arrayOfByte[j % arrayOfByte.length]; 
      for (j = 0; j != arrayOfByte5.length / this.v; j++)
        adjust(arrayOfByte5, j * this.v, arrayOfByte6); 
      if (b2 == i) {
        System.arraycopy(arrayOfByte, 0, arrayOfByte2, (b2 - true) * this.u, arrayOfByte2.length - (b2 - true) * this.u);
      } else {
        System.arraycopy(arrayOfByte, 0, arrayOfByte2, (b2 - true) * this.u, arrayOfByte.length);
      } 
    } 
    return arrayOfByte2;
  }
  
  public CipherParameters generateDerivedParameters(int paramInt) {
    paramInt /= 8;
    byte[] arrayOfByte = generateDerivedKey(1, paramInt);
    return new KeyParameter(arrayOfByte, 0, paramInt);
  }
  
  public CipherParameters generateDerivedParameters(int paramInt1, int paramInt2) {
    paramInt1 /= 8;
    paramInt2 /= 8;
    byte[] arrayOfByte1 = generateDerivedKey(1, paramInt1);
    byte[] arrayOfByte2 = generateDerivedKey(2, paramInt2);
    return new ParametersWithIV(new KeyParameter(arrayOfByte1, 0, paramInt1), arrayOfByte2, 0, paramInt2);
  }
  
  public CipherParameters generateDerivedMacParameters(int paramInt) {
    paramInt /= 8;
    byte[] arrayOfByte = generateDerivedKey(3, paramInt);
    return new KeyParameter(arrayOfByte, 0, paramInt);
  }
}
