package org.bouncycastle.mail.smime;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.cert.CertificateParsingException;
import java.security.cert.X509Certificate;
import java.util.Enumeration;
import javax.mail.BodyPart;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.Part;
import javax.mail.internet.ContentType;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMultipart;
import org.bouncycastle.asn1.cms.IssuerAndSerialNumber;
import org.bouncycastle.cert.jcajce.JcaX509CertificateHolder;
import org.bouncycastle.cms.CMSTypedStream;
import org.bouncycastle.mail.smime.util.CRLFOutputStream;
import org.bouncycastle.mail.smime.util.FileBackedMimeBodyPart;
import org.bouncycastle.util.Strings;

public class SMIMEUtil {
  private static final String MULTIPART = "multipart";
  
  private static final int BUF_SIZE = 32760;
  
  public static boolean isMultipartContent(Part paramPart) throws MessagingException {
    String str = Strings.toLowerCase(paramPart.getContentType());
    return str.startsWith("multipart");
  }
  
  static boolean isCanonicalisationRequired(MimeBodyPart paramMimeBodyPart, String paramString) throws MessagingException {
    String str;
    String[] arrayOfString = paramMimeBodyPart.getHeader("Content-Transfer-Encoding");
    if (arrayOfString == null) {
      str = paramString;
    } else {
      str = arrayOfString[0];
    } 
    return !str.equalsIgnoreCase("binary");
  }
  
  static void outputPreamble(LineOutputStream paramLineOutputStream, MimeBodyPart paramMimeBodyPart, String paramString) throws MessagingException, IOException {
    InputStream inputStream;
    try {
      inputStream = paramMimeBodyPart.getRawInputStream();
    } catch (MessagingException messagingException) {
      return;
    } 
    String str;
    while ((str = readLine(inputStream)) != null && !str.equals(paramString))
      paramLineOutputStream.writeln(str); 
    inputStream.close();
    if (str == null)
      throw new MessagingException("no boundary found"); 
  }
  
  static void outputPostamble(LineOutputStream paramLineOutputStream, MimeBodyPart paramMimeBodyPart, int paramInt, String paramString) throws MessagingException, IOException {
    InputStream inputStream;
    try {
      inputStream = paramMimeBodyPart.getRawInputStream();
    } catch (MessagingException messagingException) {
      return;
    } 
    int i = paramInt + 1;
    String str;
    do {
    
    } while ((str = readLine(inputStream)) != null && (!str.startsWith(paramString) || --i != 0));
    while ((str = readLine(inputStream)) != null)
      paramLineOutputStream.writeln(str); 
    inputStream.close();
    if (i != 0)
      throw new MessagingException("all boundaries not found for: " + paramString); 
  }
  
  static void outputPostamble(LineOutputStream paramLineOutputStream, BodyPart paramBodyPart1, String paramString, BodyPart paramBodyPart2) throws MessagingException, IOException {
    InputStream inputStream;
    try {
      inputStream = ((MimeBodyPart)paramBodyPart1).getRawInputStream();
    } catch (MessagingException messagingException) {
      return;
    } 
    MimeMultipart mimeMultipart = (MimeMultipart)paramBodyPart2.getContent();
    ContentType contentType = new ContentType(mimeMultipart.getContentType());
    String str1 = "--" + contentType.getParameter("boundary");
    int i = mimeMultipart.getCount() + 1;
    String str2;
    while (i != 0 && (str2 = readLine(inputStream)) != null) {
      if (str2.startsWith(str1))
        i--; 
    } 
    while ((str2 = readLine(inputStream)) != null && !str2.startsWith(paramString))
      paramLineOutputStream.writeln(str2); 
    inputStream.close();
  }
  
  private static String readLine(InputStream paramInputStream) throws IOException {
    StringBuffer stringBuffer = new StringBuffer();
    int i;
    while ((i = paramInputStream.read()) >= 0 && i != 10) {
      if (i != 13)
        stringBuffer.append((char)i); 
    } 
    return (i < 0 && stringBuffer.length() == 0) ? null : stringBuffer.toString();
  }
  
  static void outputBodyPart(OutputStream paramOutputStream, boolean paramBoolean, BodyPart paramBodyPart, String paramString) throws MessagingException, IOException {
    CRLFOutputStream cRLFOutputStream;
    if (paramBodyPart instanceof MimeBodyPart) {
      InputStream inputStream;
      String str;
      MimeBodyPart mimeBodyPart = (MimeBodyPart)paramBodyPart;
      String[] arrayOfString = mimeBodyPart.getHeader("Content-Transfer-Encoding");
      if (isMultipartContent(mimeBodyPart)) {
        Object object = paramBodyPart.getContent();
        if (object instanceof Multipart) {
          inputStream = (Multipart)object;
        } else {
          inputStream = new MimeMultipart(paramBodyPart.getDataHandler().getDataSource());
        } 
        ContentType contentType = new ContentType(inputStream.getContentType());
        String str1 = "--" + contentType.getParameter("boundary");
        LineOutputStream lineOutputStream1 = new LineOutputStream(paramOutputStream);
        Enumeration enumeration = mimeBodyPart.getAllHeaderLines();
        while (enumeration.hasMoreElements()) {
          String str2 = (String)enumeration.nextElement();
          lineOutputStream1.writeln(str2);
        } 
        lineOutputStream1.writeln();
        outputPreamble(lineOutputStream1, mimeBodyPart, str1);
        for (byte b = 0; b < inputStream.getCount(); b++) {
          lineOutputStream1.writeln(str1);
          BodyPart bodyPart = inputStream.getBodyPart(b);
          outputBodyPart(paramOutputStream, false, bodyPart, paramString);
          if (!isMultipartContent(bodyPart)) {
            lineOutputStream1.writeln();
          } else {
            outputPostamble(lineOutputStream1, mimeBodyPart, str1, bodyPart);
          } 
        } 
        lineOutputStream1.writeln(str1 + "--");
        if (paramBoolean)
          outputPostamble(lineOutputStream1, mimeBodyPart, inputStream.getCount(), str1); 
        return;
      } 
      if (arrayOfString == null) {
        str = paramString;
      } else {
        str = arrayOfString[0];
      } 
      if (!str.equalsIgnoreCase("base64") && !str.equalsIgnoreCase("quoted-printable")) {
        if (!str.equalsIgnoreCase("binary"))
          cRLFOutputStream = new CRLFOutputStream(paramOutputStream); 
        paramBodyPart.writeTo(cRLFOutputStream);
        cRLFOutputStream.flush();
        return;
      } 
      boolean bool = str.equalsIgnoreCase("base64");
      try {
        inputStream = mimeBodyPart.getRawInputStream();
      } catch (MessagingException messagingException) {
        cRLFOutputStream = new CRLFOutputStream(cRLFOutputStream);
        paramBodyPart.writeTo(cRLFOutputStream);
        cRLFOutputStream.flush();
        return;
      } 
      LineOutputStream lineOutputStream = new LineOutputStream(cRLFOutputStream);
      CRLFOutputStream cRLFOutputStream1 = mimeBodyPart.getAllHeaderLines();
      while (cRLFOutputStream1.hasMoreElements()) {
        String str1 = (String)cRLFOutputStream1.nextElement();
        lineOutputStream.writeln(str1);
      } 
      lineOutputStream.writeln();
      lineOutputStream.flush();
      if (bool) {
        Base64CRLFOutputStream base64CRLFOutputStream = new Base64CRLFOutputStream(cRLFOutputStream);
      } else {
        cRLFOutputStream1 = new CRLFOutputStream(cRLFOutputStream);
      } 
      byte[] arrayOfByte = new byte[32760];
      int i;
      while ((i = inputStream.read(arrayOfByte, 0, arrayOfByte.length)) > 0)
        cRLFOutputStream1.write(arrayOfByte, 0, i); 
      inputStream.close();
      cRLFOutputStream1.flush();
    } else {
      if (!paramString.equalsIgnoreCase("binary"))
        cRLFOutputStream = new CRLFOutputStream(cRLFOutputStream); 
      paramBodyPart.writeTo(cRLFOutputStream);
      cRLFOutputStream.flush();
    } 
  }
  
  public static MimeBodyPart toMimeBodyPart(byte[] paramArrayOfByte) throws SMIMEException { return toMimeBodyPart(new ByteArrayInputStream(paramArrayOfByte)); }
  
  public static MimeBodyPart toMimeBodyPart(InputStream paramInputStream) throws SMIMEException {
    try {
      return new MimeBodyPart(paramInputStream);
    } catch (MessagingException messagingException) {
      throw new SMIMEException("exception creating body part.", messagingException);
    } 
  }
  
  static FileBackedMimeBodyPart toWriteOnceBodyPart(CMSTypedStream paramCMSTypedStream) throws SMIMEException {
    try {
      return new WriteOnceFileBackedMimeBodyPart(paramCMSTypedStream.getContentStream(), File.createTempFile("bcMail", ".mime"));
    } catch (IOException iOException) {
      throw new SMIMEException("IOException creating tmp file:" + iOException.getMessage(), iOException);
    } catch (MessagingException messagingException) {
      throw new SMIMEException("can't create part: " + messagingException, messagingException);
    } 
  }
  
  public static FileBackedMimeBodyPart toMimeBodyPart(CMSTypedStream paramCMSTypedStream) throws SMIMEException {
    try {
      return toMimeBodyPart(paramCMSTypedStream, File.createTempFile("bcMail", ".mime"));
    } catch (IOException iOException) {
      throw new SMIMEException("IOException creating tmp file:" + iOException.getMessage(), iOException);
    } 
  }
  
  public static FileBackedMimeBodyPart toMimeBodyPart(CMSTypedStream paramCMSTypedStream, File paramFile) throws SMIMEException {
    try {
      return new FileBackedMimeBodyPart(paramCMSTypedStream.getContentStream(), paramFile);
    } catch (IOException iOException) {
      throw new SMIMEException("can't save content to file: " + iOException, iOException);
    } catch (MessagingException messagingException) {
      throw new SMIMEException("can't create part: " + messagingException, messagingException);
    } 
  }
  
  public static IssuerAndSerialNumber createIssuerAndSerialNumberFor(X509Certificate paramX509Certificate) throws CertificateParsingException {
    try {
      return new IssuerAndSerialNumber((new JcaX509CertificateHolder(paramX509Certificate)).getIssuer(), paramX509Certificate.getSerialNumber());
    } catch (Exception exception) {
      throw new CertificateParsingException("exception extracting issuer and serial number: " + exception);
    } 
  }
}
