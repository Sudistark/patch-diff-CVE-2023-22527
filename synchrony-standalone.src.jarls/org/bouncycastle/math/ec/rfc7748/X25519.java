package org.bouncycastle.math.ec.rfc7748;

import java.security.SecureRandom;
import org.bouncycastle.math.ec.rfc8032.Ed25519;
import org.bouncycastle.util.Arrays;

public abstract class X25519 {
  public static final int POINT_SIZE = 32;
  
  public static final int SCALAR_SIZE = 32;
  
  private static final int C_A = 486662;
  
  private static final int C_A24 = 121666;
  
  public static boolean calculateAgreement(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, byte[] paramArrayOfByte3, int paramInt3) {
    scalarMult(paramArrayOfByte1, paramInt1, paramArrayOfByte2, paramInt2, paramArrayOfByte3, paramInt3);
    return !Arrays.areAllZeroes(paramArrayOfByte3, paramInt3, 32);
  }
  
  private static int decode32(byte[] paramArrayOfByte, int paramInt) {
    null = paramArrayOfByte[paramInt] & 0xFF;
    null |= (paramArrayOfByte[++paramInt] & 0xFF) << 8;
    null |= (paramArrayOfByte[++paramInt] & 0xFF) << 16;
    return paramArrayOfByte[++paramInt] << 24;
  }
  
  private static void decodeScalar(byte[] paramArrayOfByte, int paramInt, int[] paramArrayOfInt) {
    for (byte b = 0; b < 8; b++)
      paramArrayOfInt[b] = decode32(paramArrayOfByte, paramInt + b * 4); 
    paramArrayOfInt[0] = paramArrayOfInt[0] & 0xFFFFFFF8;
    paramArrayOfInt[7] = paramArrayOfInt[7] & 0x7FFFFFFF;
    paramArrayOfInt[7] = paramArrayOfInt[7] | 0x40000000;
  }
  
  public static void generatePrivateKey(SecureRandom paramSecureRandom, byte[] paramArrayOfByte) {
    paramSecureRandom.nextBytes(paramArrayOfByte);
    paramArrayOfByte[0] = (byte)(paramArrayOfByte[0] & 0xF8);
    paramArrayOfByte[31] = (byte)(paramArrayOfByte[31] & 0x7F);
    paramArrayOfByte[31] = (byte)(paramArrayOfByte[31] | 0x40);
  }
  
  public static void generatePublicKey(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2) { scalarMultBase(paramArrayOfByte1, paramInt1, paramArrayOfByte2, paramInt2); }
  
  private static void pointDouble(int[] paramArrayOfInt1, int[] paramArrayOfInt2) {
    int[] arrayOfInt1 = F.create();
    int[] arrayOfInt2 = F.create();
    F.apm(paramArrayOfInt1, paramArrayOfInt2, arrayOfInt1, arrayOfInt2);
    F.sqr(arrayOfInt1, arrayOfInt1);
    F.sqr(arrayOfInt2, arrayOfInt2);
    F.mul(arrayOfInt1, arrayOfInt2, paramArrayOfInt1);
    F.sub(arrayOfInt1, arrayOfInt2, arrayOfInt1);
    F.mul(arrayOfInt1, 121666, paramArrayOfInt2);
    F.add(paramArrayOfInt2, arrayOfInt2, paramArrayOfInt2);
    F.mul(paramArrayOfInt2, arrayOfInt1, paramArrayOfInt2);
  }
  
  public static void precompute() { Ed25519.precompute(); }
  
  public static void scalarMult(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2, byte[] paramArrayOfByte3, int paramInt3) {
    int[] arrayOfInt1 = new int[8];
    decodeScalar(paramArrayOfByte1, paramInt1, arrayOfInt1);
    int[] arrayOfInt2 = F.create();
    F.decode(paramArrayOfByte2, paramInt2, arrayOfInt2);
    int[] arrayOfInt3 = F.create();
    F.copy(arrayOfInt2, 0, arrayOfInt3, 0);
    int[] arrayOfInt4 = F.create();
    arrayOfInt4[0] = 1;
    int[] arrayOfInt5 = F.create();
    arrayOfInt5[0] = 1;
    int[] arrayOfInt6 = F.create();
    int[] arrayOfInt7 = F.create();
    int[] arrayOfInt8 = F.create();
    char c = 'Ã¾';
    int i = 1;
    do {
      F.apm(arrayOfInt5, arrayOfInt6, arrayOfInt7, arrayOfInt5);
      F.apm(arrayOfInt3, arrayOfInt4, arrayOfInt6, arrayOfInt3);
      F.mul(arrayOfInt7, arrayOfInt3, arrayOfInt7);
      F.mul(arrayOfInt5, arrayOfInt6, arrayOfInt5);
      F.sqr(arrayOfInt6, arrayOfInt6);
      F.sqr(arrayOfInt3, arrayOfInt3);
      F.sub(arrayOfInt6, arrayOfInt3, arrayOfInt8);
      F.mul(arrayOfInt8, 121666, arrayOfInt4);
      F.add(arrayOfInt4, arrayOfInt3, arrayOfInt4);
      F.mul(arrayOfInt4, arrayOfInt8, arrayOfInt4);
      F.mul(arrayOfInt3, arrayOfInt6, arrayOfInt3);
      F.apm(arrayOfInt7, arrayOfInt5, arrayOfInt5, arrayOfInt6);
      F.sqr(arrayOfInt5, arrayOfInt5);
      F.sqr(arrayOfInt6, arrayOfInt6);
      F.mul(arrayOfInt6, arrayOfInt2, arrayOfInt6);
      char c1 = --c >>> '\005';
      int j = c & 0x1F;
      int k = arrayOfInt1[c1] >>> j & true;
      i ^= k;
      F.cswap(i, arrayOfInt3, arrayOfInt5);
      F.cswap(i, arrayOfInt4, arrayOfInt6);
      i = k;
    } while (c >= '\003');
    for (byte b = 0; b < 3; b++)
      pointDouble(arrayOfInt3, arrayOfInt4); 
    F.inv(arrayOfInt4, arrayOfInt4);
    F.mul(arrayOfInt3, arrayOfInt4, arrayOfInt3);
    F.normalize(arrayOfInt3);
    F.encode(arrayOfInt3, paramArrayOfByte3, paramInt3);
  }
  
  public static void scalarMultBase(byte[] paramArrayOfByte1, int paramInt1, byte[] paramArrayOfByte2, int paramInt2) {
    int[] arrayOfInt1 = F.create();
    int[] arrayOfInt2 = F.create();
    Ed25519.scalarMultBaseYZ(Friend.access$000(), paramArrayOfByte1, paramInt1, arrayOfInt1, arrayOfInt2);
    F.apm(arrayOfInt2, arrayOfInt1, arrayOfInt1, arrayOfInt2);
    F.inv(arrayOfInt2, arrayOfInt2);
    F.mul(arrayOfInt1, arrayOfInt2, arrayOfInt1);
    F.normalize(arrayOfInt1);
    F.encode(arrayOfInt1, paramArrayOfByte2, paramInt2);
  }
}
