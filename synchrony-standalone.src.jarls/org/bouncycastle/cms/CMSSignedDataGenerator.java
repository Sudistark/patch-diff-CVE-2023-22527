package org.bouncycastle.cms;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import org.bouncycastle.asn1.ASN1EncodableVector;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.ASN1Set;
import org.bouncycastle.asn1.BEROctetString;
import org.bouncycastle.asn1.DERSet;
import org.bouncycastle.asn1.cms.CMSObjectIdentifiers;
import org.bouncycastle.asn1.cms.ContentInfo;
import org.bouncycastle.asn1.cms.SignedData;
import org.bouncycastle.asn1.cms.SignerInfo;

public class CMSSignedDataGenerator extends CMSSignedGenerator {
  private List signerInfs = new ArrayList();
  
  public CMSSignedData generate(CMSTypedData paramCMSTypedData) throws CMSException { return generate(paramCMSTypedData, false); }
  
  public CMSSignedData generate(CMSTypedData paramCMSTypedData, boolean paramBoolean) throws CMSException {
    if (!this.signerInfs.isEmpty())
      throw new IllegalStateException("this method can only be used with SignerInfoGenerator"); 
    LinkedHashSet linkedHashSet = new LinkedHashSet();
    ASN1EncodableVector aSN1EncodableVector = new ASN1EncodableVector();
    this.digests.clear();
    for (SignerInformation signerInformation : this._signers) {
      CMSUtils.addDigestAlgs(linkedHashSet, signerInformation, this.digestAlgIdFinder);
      aSN1EncodableVector.add(signerInformation.toASN1Structure());
    } 
    ASN1ObjectIdentifier aSN1ObjectIdentifier = paramCMSTypedData.getContentType();
    BEROctetString bEROctetString = null;
    if (paramCMSTypedData.getContent() != null) {
      ByteArrayOutputStream byteArrayOutputStream = null;
      if (paramBoolean)
        byteArrayOutputStream = new ByteArrayOutputStream(); 
      OutputStream outputStream = CMSUtils.attachSignersToOutputStream(this.signerGens, byteArrayOutputStream);
      outputStream = CMSUtils.getSafeOutputStream(outputStream);
      try {
        paramCMSTypedData.write(outputStream);
        outputStream.close();
      } catch (IOException iOException) {
        throw new CMSException("data processing exception: " + iOException.getMessage(), iOException);
      } 
      if (paramBoolean)
        bEROctetString = new BEROctetString(byteArrayOutputStream.toByteArray()); 
    } 
    for (SignerInfoGenerator signerInfoGenerator : this.signerGens) {
      SignerInfo signerInfo = signerInfoGenerator.generate(aSN1ObjectIdentifier);
      linkedHashSet.add(signerInfo.getDigestAlgorithm());
      aSN1EncodableVector.add(signerInfo);
      byte[] arrayOfByte = signerInfoGenerator.getCalculatedDigest();
      if (arrayOfByte != null)
        this.digests.put(signerInfo.getDigestAlgorithm().getAlgorithm().getId(), arrayOfByte); 
    } 
    ASN1Set aSN1Set1 = null;
    if (this.certs.size() != 0)
      aSN1Set1 = CMSUtils.createBerSetFromList(this.certs); 
    ASN1Set aSN1Set2 = null;
    if (this.crls.size() != 0)
      aSN1Set2 = CMSUtils.createBerSetFromList(this.crls); 
    ContentInfo contentInfo1 = new ContentInfo(aSN1ObjectIdentifier, bEROctetString);
    SignedData signedData = new SignedData(CMSUtils.convertToBERSet(linkedHashSet), contentInfo1, aSN1Set1, aSN1Set2, new DERSet(aSN1EncodableVector));
    ContentInfo contentInfo2 = new ContentInfo(CMSObjectIdentifiers.signedData, signedData);
    return new CMSSignedData(paramCMSTypedData, contentInfo2);
  }
  
  public SignerInformationStore generateCounterSigners(SignerInformation paramSignerInformation) throws CMSException { return generate(new CMSProcessableByteArray(null, paramSignerInformation.getSignature()), false).getSignerInfos(); }
}
