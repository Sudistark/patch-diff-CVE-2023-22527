package org.bouncycastle.tsp.ers;

import java.io.IOException;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import org.bouncycastle.asn1.tsp.ArchiveTimeStamp;
import org.bouncycastle.asn1.tsp.PartialHashtree;
import org.bouncycastle.asn1.tsp.TSTInfo;
import org.bouncycastle.operator.DigestCalculator;
import org.bouncycastle.tsp.TSPException;
import org.bouncycastle.tsp.TimeStampRequest;
import org.bouncycastle.tsp.TimeStampRequestGenerator;
import org.bouncycastle.tsp.TimeStampResponse;
import org.bouncycastle.util.Arrays;

public class ERSArchiveTimeStampGenerator {
  private final DigestCalculator digCalc;
  
  private List<ERSData> dataObjects = new ArrayList();
  
  private ERSRootNodeCalculator rootNodeCalculator = new BinaryTreeRootCalculator();
  
  public ERSArchiveTimeStampGenerator(DigestCalculator paramDigestCalculator) { this.digCalc = paramDigestCalculator; }
  
  public void addData(ERSData paramERSData) { this.dataObjects.add(paramERSData); }
  
  public void addAllData(List<ERSData> paramList) { this.dataObjects.addAll(paramList); }
  
  public TimeStampRequest generateTimeStampRequest(TimeStampRequestGenerator paramTimeStampRequestGenerator) throws TSPException, IOException {
    PartialHashtree[] arrayOfPartialHashtree = getPartialHashtrees();
    byte[] arrayOfByte = this.rootNodeCalculator.computeRootHash(this.digCalc, arrayOfPartialHashtree);
    return paramTimeStampRequestGenerator.generate(this.digCalc.getAlgorithmIdentifier(), arrayOfByte);
  }
  
  public TimeStampRequest generateTimeStampRequest(TimeStampRequestGenerator paramTimeStampRequestGenerator, BigInteger paramBigInteger) throws TSPException, IOException {
    PartialHashtree[] arrayOfPartialHashtree = getPartialHashtrees();
    byte[] arrayOfByte = this.rootNodeCalculator.computeRootHash(this.digCalc, arrayOfPartialHashtree);
    return paramTimeStampRequestGenerator.generate(this.digCalc.getAlgorithmIdentifier(), arrayOfByte, paramBigInteger);
  }
  
  public ERSArchiveTimeStamp generateArchiveTimeStamp(TimeStampResponse paramTimeStampResponse) throws TSPException, ERSException {
    ArchiveTimeStamp archiveTimeStamp;
    PartialHashtree[] arrayOfPartialHashtree = getPartialHashtrees();
    byte[] arrayOfByte = this.rootNodeCalculator.computeRootHash(this.digCalc, arrayOfPartialHashtree);
    TSTInfo tSTInfo = paramTimeStampResponse.getTimeStampToken().getTimeStampInfo().toASN1Structure();
    if (!tSTInfo.getMessageImprint().getHashAlgorithm().equals(this.digCalc.getAlgorithmIdentifier()))
      throw new ERSException("time stamp imprint for wrong algorithm"); 
    if (!Arrays.areEqual(tSTInfo.getMessageImprint().getHashedMessage(), arrayOfByte))
      throw new ERSException("time stamp imprint for wrong root hash"); 
    if (arrayOfPartialHashtree.length == 1) {
      archiveTimeStamp = new ArchiveTimeStamp(null, null, paramTimeStampResponse.getTimeStampToken().toCMSSignedData().toASN1Structure());
    } else {
      archiveTimeStamp = new ArchiveTimeStamp(this.digCalc.getAlgorithmIdentifier(), arrayOfPartialHashtree, paramTimeStampResponse.getTimeStampToken().toCMSSignedData().toASN1Structure());
    } 
    return new ERSArchiveTimeStamp(archiveTimeStamp, this.digCalc, this.rootNodeCalculator);
  }
  
  private PartialHashtree[] getPartialHashtrees() {
    List list = ERSUtil.buildHashList(this.digCalc, this.dataObjects);
    PartialHashtree[] arrayOfPartialHashtree = new PartialHashtree[list.size()];
    HashSet hashSet = new HashSet();
    byte b;
    for (b = 0; b != this.dataObjects.size(); b++) {
      if (this.dataObjects.get(b) instanceof ERSDataGroup)
        hashSet.add((ERSDataGroup)this.dataObjects.get(b)); 
    } 
    for (b = 0; b != list.size(); b++) {
      byte[] arrayOfByte = (byte[])list.get(b);
      ERSDataGroup eRSDataGroup = null;
      for (ERSDataGroup eRSDataGroup1 : hashSet) {
        byte[] arrayOfByte1 = eRSDataGroup1.getHash(this.digCalc);
        if (Arrays.areEqual(arrayOfByte1, arrayOfByte)) {
          List list1 = eRSDataGroup1.getHashes(this.digCalc);
          arrayOfPartialHashtree[b] = new PartialHashtree((byte[][])list1.toArray(new byte[list1.size()][]));
          eRSDataGroup = eRSDataGroup1;
          break;
        } 
      } 
      if (eRSDataGroup == null) {
        arrayOfPartialHashtree[b] = new PartialHashtree(arrayOfByte);
      } else {
        hashSet.remove(eRSDataGroup);
      } 
    } 
    return arrayOfPartialHashtree;
  }
}
