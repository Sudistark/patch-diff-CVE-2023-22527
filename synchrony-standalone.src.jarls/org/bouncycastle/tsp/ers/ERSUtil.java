package org.bouncycastle.tsp.ers;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import org.bouncycastle.asn1.tsp.PartialHashtree;
import org.bouncycastle.operator.DigestCalculator;
import org.bouncycastle.util.io.Streams;

class ERSUtil {
  private static final Comparator<byte[]> hashComp = new ByteArrayComparator();
  
  static byte[] calculateDigest(DigestCalculator paramDigestCalculator, byte[] paramArrayOfByte) {
    try {
      OutputStream outputStream = paramDigestCalculator.getOutputStream();
      outputStream.write(paramArrayOfByte);
      outputStream.close();
      return paramDigestCalculator.getDigest();
    } catch (IOException iOException) {
      throw ExpUtil.createIllegalState("unable to calculate hash: " + iOException.getMessage(), iOException);
    } 
  }
  
  static byte[] calculateBranchHash(DigestCalculator paramDigestCalculator, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2) { return (hashComp.compare(paramArrayOfByte1, paramArrayOfByte2) <= 0) ? calculateDigest(paramDigestCalculator, paramArrayOfByte1, paramArrayOfByte2) : calculateDigest(paramDigestCalculator, paramArrayOfByte2, paramArrayOfByte1); }
  
  static byte[] calculateBranchHash(DigestCalculator paramDigestCalculator, byte[][] paramArrayOfByte) { return (paramArrayOfByte.length == 2) ? calculateBranchHash(paramDigestCalculator, paramArrayOfByte[0], paramArrayOfByte[1]) : calculateDigest(paramDigestCalculator, buildHashList(paramArrayOfByte).iterator()); }
  
  static byte[] calculateDigest(DigestCalculator paramDigestCalculator, byte[] paramArrayOfByte1, byte[] paramArrayOfByte2) {
    try {
      OutputStream outputStream = paramDigestCalculator.getOutputStream();
      outputStream.write(paramArrayOfByte1);
      outputStream.write(paramArrayOfByte2);
      outputStream.close();
      return paramDigestCalculator.getDigest();
    } catch (IOException iOException) {
      throw ExpUtil.createIllegalState("unable to calculate hash: " + iOException.getMessage(), iOException);
    } 
  }
  
  static byte[] calculateDigest(DigestCalculator paramDigestCalculator, Iterator<byte[]> paramIterator) {
    try {
      OutputStream outputStream = paramDigestCalculator.getOutputStream();
      while (paramIterator.hasNext())
        outputStream.write((byte[])paramIterator.next()); 
      outputStream.close();
      return paramDigestCalculator.getDigest();
    } catch (IOException iOException) {
      throw ExpUtil.createIllegalState("unable to calculate hash: " + iOException.getMessage(), iOException);
    } 
  }
  
  static byte[] calculateDigest(DigestCalculator paramDigestCalculator, InputStream paramInputStream) {
    try {
      OutputStream outputStream = paramDigestCalculator.getOutputStream();
      Streams.pipeAll(paramInputStream, outputStream);
      outputStream.close();
      return paramDigestCalculator.getDigest();
    } catch (IOException iOException) {
      throw ExpUtil.createIllegalState("unable to calculate hash: " + iOException.getMessage(), iOException);
    } 
  }
  
  static byte[] computeNodeHash(DigestCalculator paramDigestCalculator, PartialHashtree paramPartialHashtree) {
    byte[][] arrayOfByte = paramPartialHashtree.getValues();
    return (arrayOfByte.length > 1) ? calculateDigest(paramDigestCalculator, buildHashList(arrayOfByte).iterator()) : arrayOfByte[0];
  }
  
  static List<byte[]> buildHashList(byte[][] paramArrayOfByte) {
    SortedHashList sortedHashList = new SortedHashList();
    for (byte b = 0; b != paramArrayOfByte.length; b++)
      sortedHashList.add(paramArrayOfByte[b]); 
    return sortedHashList.toList();
  }
  
  static List<byte[]> buildHashList(DigestCalculator paramDigestCalculator, List<ERSData> paramList) {
    SortedHashList sortedHashList = new SortedHashList();
    for (byte b = 0; b != paramList.size(); b++)
      sortedHashList.add(((ERSData)paramList.get(b)).getHash(paramDigestCalculator)); 
    return sortedHashList.toList();
  }
}
