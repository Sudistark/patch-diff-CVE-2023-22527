package org.jsoup.parser;

import java.io.Reader;
import java.io.StringReader;
import java.util.List;
import javax.annotation.ParametersAreNonnullByDefault;
import org.jsoup.helper.Validate;
import org.jsoup.nodes.Attributes;
import org.jsoup.nodes.CDataNode;
import org.jsoup.nodes.Comment;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.DocumentType;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Entities;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.nodes.XmlDeclaration;

public class XmlTreeBuilder extends TreeBuilder {
  private static final int maxQueueDepth = 256;
  
  ParseSettings defaultSettings() { return ParseSettings.preserveCase; }
  
  @ParametersAreNonnullByDefault
  protected void initialiseParse(Reader input, String baseUri, Parser parser) {
    super.initialiseParse(input, baseUri, parser);
    this.stack.add(this.doc);
    this.doc.outputSettings()
      .syntax(Document.OutputSettings.Syntax.xml)
      .escapeMode(Entities.EscapeMode.xhtml)
      .prettyPrint(false);
  }
  
  Document parse(Reader input, String baseUri) { return parse(input, baseUri, new Parser(this)); }
  
  Document parse(String input, String baseUri) { return parse(new StringReader(input), baseUri, new Parser(this)); }
  
  XmlTreeBuilder newInstance() { return new XmlTreeBuilder(); }
  
  protected boolean process(Token token) {
    switch (null.$SwitchMap$org$jsoup$parser$Token$TokenType[token.type.ordinal()]) {
      case 1:
        insert(token.asStartTag());
      case 2:
        popStackToClose(token.asEndTag());
      case 3:
        insert(token.asComment());
      case 4:
        insert(token.asCharacter());
      case 5:
        insert(token.asDoctype());
      case 6:
        return true;
    } 
    Validate.fail("Unexpected token type: " + token.type);
  }
  
  protected void insertNode(Node node) {
    currentElement().appendChild(node);
    onNodeInserted(node, null);
  }
  
  protected void insertNode(Node node, Token token) {
    currentElement().appendChild(node);
    onNodeInserted(node, token);
  }
  
  Element insert(Token.StartTag startTag) {
    Tag tag = tagFor(startTag.name(), this.settings);
    if (startTag.hasAttributes())
      startTag.attributes.deduplicate(this.settings); 
    Element el = new Element(tag, null, this.settings.normalizeAttributes(startTag.attributes));
    insertNode(el, startTag);
    if (startTag.isSelfClosing()) {
      if (!tag.isKnownTag())
        tag.setSelfClosing(); 
    } else {
      this.stack.add(el);
    } 
    return el;
  }
  
  void insert(Token.Comment commentToken) {
    Comment comment = new Comment(commentToken.getData());
    XmlDeclaration xmlDeclaration = comment;
    if (commentToken.bogus && comment.isXmlDeclaration()) {
      XmlDeclaration decl = comment.asXmlDeclaration();
      if (decl != null)
        xmlDeclaration = decl; 
    } 
    insertNode(xmlDeclaration, commentToken);
  }
  
  void insert(Token.Character token) {
    String data = token.getData();
    insertNode(token.isCData() ? new CDataNode(data) : new TextNode(data), token);
  }
  
  void insert(Token.Doctype d) {
    DocumentType doctypeNode = new DocumentType(this.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());
    doctypeNode.setPubSysKey(d.getPubSysKey());
    insertNode(doctypeNode, d);
  }
  
  protected void popStackToClose(Token.EndTag endTag) {
    String elName = this.settings.normalizeTag(endTag.tagName);
    Element firstFound = null;
    int bottom = this.stack.size() - 1;
    int upper = (bottom >= 256) ? (bottom - 256) : 0;
    for (int pos = this.stack.size() - 1; pos >= upper; pos--) {
      Element next = (Element)this.stack.get(pos);
      if (next.nodeName().equals(elName)) {
        firstFound = next;
        break;
      } 
    } 
    if (firstFound == null)
      return; 
    for (int pos = this.stack.size() - 1; pos >= 0; pos--) {
      Element next = (Element)this.stack.get(pos);
      this.stack.remove(pos);
      if (next == firstFound) {
        onNodeClosed(next, endTag);
        break;
      } 
    } 
  }
  
  List<Node> parseFragment(String inputFragment, String baseUri, Parser parser) {
    initialiseParse(new StringReader(inputFragment), baseUri, parser);
    runParser();
    return this.doc.childNodes();
  }
  
  List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser) { return parseFragment(inputFragment, baseUri, parser); }
}
