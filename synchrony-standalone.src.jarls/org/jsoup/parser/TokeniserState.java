package org.jsoup.parser;

static final abstract enum TokeniserState {
  Data, CharacterReferenceInData, Rcdata, CharacterReferenceInRcdata, Rawtext, ScriptData, PLAINTEXT, TagOpen, EndTagOpen, TagName, RcdataLessthanSign, RCDATAEndTagOpen, RCDATAEndTagName, RawtextLessthanSign, RawtextEndTagOpen, RawtextEndTagName, ScriptDataLessthanSign, ScriptDataEndTagOpen, ScriptDataEndTagName, ScriptDataEscapeStart, ScriptDataEscapeStartDash, ScriptDataEscaped, ScriptDataEscapedDash, ScriptDataEscapedDashDash, ScriptDataEscapedLessthanSign, ScriptDataEscapedEndTagOpen, ScriptDataEscapedEndTagName, ScriptDataDoubleEscapeStart, ScriptDataDoubleEscaped, ScriptDataDoubleEscapedDash, ScriptDataDoubleEscapedDashDash, ScriptDataDoubleEscapedLessthanSign, ScriptDataDoubleEscapeEnd, BeforeAttributeName, AttributeName, AfterAttributeName, BeforeAttributeValue, AttributeValue_doubleQuoted, AttributeValue_singleQuoted, AttributeValue_unquoted, AfterAttributeValue_quoted, SelfClosingStartTag, BogusComment, MarkupDeclarationOpen, CommentStart, CommentStartDash, Comment, CommentEndDash, CommentEnd, CommentEndBang, Doctype, BeforeDoctypeName, DoctypeName, AfterDoctypeName, AfterDoctypePublicKeyword, BeforeDoctypePublicIdentifier, DoctypePublicIdentifier_doubleQuoted, DoctypePublicIdentifier_singleQuoted, AfterDoctypePublicIdentifier, BetweenDoctypePublicAndSystemIdentifiers, AfterDoctypeSystemKeyword, BeforeDoctypeSystemIdentifier, DoctypeSystemIdentifier_doubleQuoted, DoctypeSystemIdentifier_singleQuoted, AfterDoctypeSystemIdentifier, BogusDoctype, CdataSection;
  
  static final char nullChar = '\000';
  
  static final char[] attributeNameCharsSorted;
  
  static final char[] attributeValueUnquoted;
  
  private static final char replacementChar = '�';
  
  private static final String replacementStr;
  
  private static final char eof = '￿';
  
  static  {
    attributeNameCharsSorted = new char[] { 
        '\t', '\n', '\f', '\r', ' ', '"', '\'', '/', '<', '=', 
        '>' };
    attributeValueUnquoted = new char[] { 
        Character.MIN_VALUE, '\t', '\n', '\f', '\r', ' ', '"', '&', '\'', '<', 
        '=', '>', '`' };
    replacementStr = String.valueOf('�');
  }
  
  private static void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) {
    if (r.matchesLetter()) {
      String name = r.consumeLetterSequence();
      t.tagPending.appendTagName(name);
      t.dataBuffer.append(name);
      return;
    } 
    boolean needsExitTransition = false;
    if (t.isAppropriateEndTagToken() && !r.isEmpty()) {
      char c = r.consume();
      switch (c) {
        case '\t':
        case '\n':
        case '\f':
        case '\r':
        case ' ':
          t.transition(BeforeAttributeName);
          break;
        case '/':
          t.transition(SelfClosingStartTag);
          break;
        case '>':
          t.emitTagPending();
          t.transition(Data);
          break;
        default:
          t.dataBuffer.append(c);
          needsExitTransition = true;
          break;
      } 
    } else {
      needsExitTransition = true;
    } 
    if (needsExitTransition) {
      t.emit("</");
      t.emit(t.dataBuffer);
      t.transition(elseTransition);
    } 
  }
  
  private static void readRawData(Tokeniser t, CharacterReader r, TokeniserState current, TokeniserState advance) {
    switch (r.current()) {
      case '<':
        t.advanceTransition(advance);
        return;
      case '\000':
        t.error(current);
        r.advance();
        t.emit('�');
        return;
      case '￿':
        t.emit(new Token.EOF());
        return;
    } 
    String data = r.consumeRawData();
    t.emit(data);
  }
  
  private static void readCharRef(Tokeniser t, TokeniserState advance) {
    int[] c = t.consumeCharacterReference(null, false);
    if (c == null) {
      t.emit('&');
    } else {
      t.emit(c);
    } 
    t.transition(advance);
  }
  
  private static void readEndTag(Tokeniser t, CharacterReader r, TokeniserState a, TokeniserState b) {
    if (r.matchesAsciiAlpha()) {
      t.createTagPending(false);
      t.transition(a);
    } else {
      t.emit("</");
      t.transition(b);
    } 
  }
  
  private static void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) {
    if (r.matchesLetter()) {
      String name = r.consumeLetterSequence();
      t.dataBuffer.append(name);
      t.emit(name);
      return;
    } 
    char c = r.consume();
    switch (c) {
      case '\t':
      case '\n':
      case '\f':
      case '\r':
      case ' ':
      case '/':
      case '>':
        if (t.dataBuffer.toString().equals("script")) {
          t.transition(primary);
        } else {
          t.transition(fallback);
        } 
        t.emit(c);
        return;
    } 
    r.unconsume();
    t.transition(fallback);
  }
  
  abstract void read(Tokeniser paramTokeniser, CharacterReader paramCharacterReader);
}
