package org.jsoup.nodes;

import java.io.IOException;
import org.jsoup.helper.Validate;
import org.jsoup.internal.StringUtil;

public class TextNode extends LeafNode {
  public TextNode(String text) { this.value = text; }
  
  public String nodeName() { return "#text"; }
  
  public String text() { return StringUtil.normaliseWhitespace(getWholeText()); }
  
  public TextNode text(String text) {
    coreValue(text);
    return this;
  }
  
  public String getWholeText() { return coreValue(); }
  
  public boolean isBlank() { return StringUtil.isBlank(coreValue()); }
  
  public TextNode splitText(int offset) {
    String text = coreValue();
    Validate.isTrue((offset >= 0), "Split offset must be not be negative");
    Validate.isTrue((offset < text.length()), "Split offset must not be greater than current text length");
    String head = text.substring(0, offset);
    String tail = text.substring(offset);
    text(head);
    TextNode tailNode = new TextNode(tail);
    if (this.parentNode != null)
      this.parentNode.addChildren(siblingIndex() + 1, new Node[] { tailNode }); 
    return tailNode;
  }
  
  void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
    boolean prettyPrint = out.prettyPrint();
    Element parent = (this.parentNode instanceof Element) ? (Element)this.parentNode : null;
    boolean normaliseWhite = (prettyPrint && !Element.preserveWhitespace(this.parentNode));
    boolean trimLikeBlock = (parent != null && (parent.tag().isBlock() || parent.tag().formatAsBlock()));
    boolean trimLeading = false, trimTrailing = false;
    if (normaliseWhite) {
      trimLeading = ((trimLikeBlock && this.siblingIndex == 0) || this.parentNode instanceof Document);
      trimTrailing = (trimLikeBlock && nextSibling() == null);
      Node next = nextSibling();
      Node prev = previousSibling();
      boolean isBlank = isBlank();
      boolean couldSkip = ((next instanceof Element && ((Element)next).shouldIndent(out)) || (next instanceof TextNode && ((TextNode)next).isBlank()) || (prev instanceof Element && (((Element)prev).isBlock() || prev.isNode("br"))));
      if (couldSkip && isBlank)
        return; 
      if ((this.siblingIndex == 0 && parent != null && parent
        .tag().formatAsBlock() && !isBlank) || (out
        .outline() && siblingNodes().size() > 0 && !isBlank) || (this.siblingIndex > 0 && 
        isNode(prev, "br")))
        indent(accum, depth, out); 
    } 
    Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);
  }
  
  void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {}
  
  public String toString() { return outerHtml(); }
  
  public TextNode clone() { return (TextNode)super.clone(); }
  
  public static TextNode createFromEncoded(String encodedText) {
    String text = Entities.unescape(encodedText);
    return new TextNode(text);
  }
  
  static String normaliseWhitespace(String text) { return StringUtil.normaliseWhitespace(text); }
  
  static String stripLeadingWhitespace(String text) { return text.replaceFirst("^\\s+", ""); }
  
  static boolean lastCharIsWhitespace(StringBuilder sb) { return (sb.length() != 0 && sb.charAt(sb.length() - 1) == ' '); }
}
