package org.jsoup.nodes;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.function.Consumer;
import javax.annotation.Nullable;
import org.jsoup.helper.Consumer;
import org.jsoup.helper.Validate;
import org.jsoup.internal.StringUtil;
import org.jsoup.select.NodeFilter;
import org.jsoup.select.NodeTraversor;
import org.jsoup.select.NodeVisitor;

public abstract class Node implements Cloneable {
  static final List<Node> EmptyNodes = Collections.emptyList();
  
  static final String EmptyString = "";
  
  @Nullable
  Node parentNode;
  
  int siblingIndex;
  
  public String normalName() { return nodeName(); }
  
  public boolean hasParent() { return (this.parentNode != null); }
  
  public String attr(String attributeKey) {
    Validate.notNull(attributeKey);
    if (!hasAttributes())
      return ""; 
    String val = attributes().getIgnoreCase(attributeKey);
    if (val.length() > 0)
      return val; 
    if (attributeKey.startsWith("abs:"))
      return absUrl(attributeKey.substring("abs:".length())); 
    return "";
  }
  
  public int attributesSize() { return hasAttributes() ? attributes().size() : 0; }
  
  public Node attr(String attributeKey, String attributeValue) {
    attributeKey = NodeUtils.parser(this).settings().normalizeAttribute(attributeKey);
    attributes().putIgnoreCase(attributeKey, attributeValue);
    return this;
  }
  
  public boolean hasAttr(String attributeKey) {
    Validate.notNull(attributeKey);
    if (!hasAttributes())
      return false; 
    if (attributeKey.startsWith("abs:")) {
      String key = attributeKey.substring("abs:".length());
      if (attributes().hasKeyIgnoreCase(key) && !absUrl(key).isEmpty())
        return true; 
    } 
    return attributes().hasKeyIgnoreCase(attributeKey);
  }
  
  public Node removeAttr(String attributeKey) {
    Validate.notNull(attributeKey);
    if (hasAttributes())
      attributes().removeIgnoreCase(attributeKey); 
    return this;
  }
  
  public Node clearAttributes() {
    if (hasAttributes()) {
      Iterator<Attribute> it = attributes().iterator();
      while (it.hasNext()) {
        it.next();
        it.remove();
      } 
    } 
    return this;
  }
  
  public void setBaseUri(String baseUri) {
    Validate.notNull(baseUri);
    doSetBaseUri(baseUri);
  }
  
  public String absUrl(String attributeKey) {
    Validate.notEmpty(attributeKey);
    if (!hasAttributes() || !attributes().hasKeyIgnoreCase(attributeKey))
      return ""; 
    return StringUtil.resolve(baseUri(), attributes().getIgnoreCase(attributeKey));
  }
  
  public Node childNode(int index) { return (Node)ensureChildNodes().get(index); }
  
  public List<Node> childNodes() {
    if (childNodeSize() == 0)
      return EmptyNodes; 
    List<Node> children = ensureChildNodes();
    List<Node> rewrap = new ArrayList<Node>(children.size());
    rewrap.addAll(children);
    return Collections.unmodifiableList(rewrap);
  }
  
  public List<Node> childNodesCopy() {
    List<Node> nodes = ensureChildNodes();
    ArrayList<Node> children = new ArrayList<Node>(nodes.size());
    for (Node node : nodes)
      children.add(node.clone()); 
    return children;
  }
  
  protected Node[] childNodesAsArray() { return (Node[])ensureChildNodes().toArray(new Node[0]); }
  
  @Nullable
  public Node parent() { return this.parentNode; }
  
  @Nullable
  public final Node parentNode() { return this.parentNode; }
  
  public Node root() {
    Node node = this;
    while (node.parentNode != null)
      node = node.parentNode; 
    return node;
  }
  
  @Nullable
  public Document ownerDocument() {
    Node root = root();
    return (root instanceof Document) ? (Document)root : null;
  }
  
  public void remove() {
    if (this.parentNode != null)
      this.parentNode.removeChild(this); 
  }
  
  public Node before(String html) {
    addSiblingHtml(this.siblingIndex, html);
    return this;
  }
  
  public Node before(Node node) {
    Validate.notNull(node);
    Validate.notNull(this.parentNode);
    if (node.parentNode == this.parentNode)
      node.remove(); 
    this.parentNode.addChildren(this.siblingIndex, new Node[] { node });
    return this;
  }
  
  public Node after(String html) {
    addSiblingHtml(this.siblingIndex + 1, html);
    return this;
  }
  
  public Node after(Node node) {
    Validate.notNull(node);
    Validate.notNull(this.parentNode);
    if (node.parentNode == this.parentNode)
      node.remove(); 
    this.parentNode.addChildren(this.siblingIndex + 1, new Node[] { node });
    return this;
  }
  
  private void addSiblingHtml(int index, String html) {
    Validate.notNull(html);
    Validate.notNull(this.parentNode);
    Element context = (parent() instanceof Element) ? (Element)parent() : null;
    List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, context, baseUri());
    this.parentNode.addChildren(index, (Node[])nodes.toArray(new Node[0]));
  }
  
  public Node wrap(String html) {
    Validate.notEmpty(html);
    Element context = (this.parentNode != null && this.parentNode instanceof Element) ? (Element)this.parentNode : ((this instanceof Element) ? (Element)this : null);
    List<Node> wrapChildren = NodeUtils.parser(this).parseFragmentInput(html, context, baseUri());
    Node wrapNode = (Node)wrapChildren.get(0);
    if (!(wrapNode instanceof Element))
      return this; 
    Element wrap = (Element)wrapNode;
    Element deepest = getDeepChild(wrap);
    if (this.parentNode != null)
      this.parentNode.replaceChild(this, wrap); 
    deepest.addChildren(new Node[] { this });
    if (wrapChildren.size() > 0)
      for (int i = 0; i < wrapChildren.size(); i++) {
        Node remainder = (Node)wrapChildren.get(i);
        if (wrap != remainder) {
          if (remainder.parentNode != null)
            remainder.parentNode.removeChild(remainder); 
          wrap.after(remainder);
        } 
      }  
    return this;
  }
  
  @Nullable
  public Node unwrap() {
    Validate.notNull(this.parentNode);
    Node firstChild = firstChild();
    this.parentNode.addChildren(this.siblingIndex, childNodesAsArray());
    remove();
    return firstChild;
  }
  
  private Element getDeepChild(Element el) {
    while (el.childrenSize() > 0)
      el = (Element)el.childElementsList().get(0); 
    return el;
  }
  
  void nodelistChanged() {}
  
  public void replaceWith(Node in) {
    Validate.notNull(in);
    Validate.notNull(this.parentNode);
    this.parentNode.replaceChild(this, in);
  }
  
  protected void setParentNode(Node parentNode) {
    Validate.notNull(parentNode);
    if (this.parentNode != null)
      this.parentNode.removeChild(this); 
    this.parentNode = parentNode;
  }
  
  protected void replaceChild(Node out, Node in) {
    Validate.isTrue((out.parentNode == this));
    Validate.notNull(in);
    if (out == in)
      return; 
    if (in.parentNode != null)
      in.parentNode.removeChild(in); 
    int index = out.siblingIndex;
    ensureChildNodes().set(index, in);
    in.parentNode = this;
    in.setSiblingIndex(index);
    out.parentNode = null;
  }
  
  protected void removeChild(Node out) {
    Validate.isTrue((out.parentNode == this));
    int index = out.siblingIndex;
    ensureChildNodes().remove(index);
    reindexChildren(index);
    out.parentNode = null;
  }
  
  protected void addChildren(Node... children) {
    List<Node> nodes = ensureChildNodes();
    for (Node child : children) {
      reparentChild(child);
      nodes.add(child);
      child.setSiblingIndex(nodes.size() - 1);
    } 
  }
  
  protected void addChildren(int index, Node... children) {
    Validate.notNull(children);
    if (children.length == 0)
      return; 
    List<Node> nodes = ensureChildNodes();
    Node firstParent = children[0].parent();
    if (firstParent != null && firstParent.childNodeSize() == children.length) {
      boolean sameList = true;
      List<Node> firstParentNodes = firstParent.ensureChildNodes();
      int i = children.length;
      while (i-- > 0) {
        if (children[i] != firstParentNodes.get(i)) {
          sameList = false;
          break;
        } 
      } 
      if (sameList) {
        boolean wasEmpty = (childNodeSize() == 0);
        firstParent.empty();
        nodes.addAll(index, Arrays.asList(children));
        i = children.length;
        while (i-- > 0)
          (children[i]).parentNode = this; 
        if (!wasEmpty || (children[0]).siblingIndex != 0)
          reindexChildren(index); 
        return;
      } 
    } 
    Validate.noNullElements(children);
    for (Node child : children)
      reparentChild(child); 
    nodes.addAll(index, Arrays.asList(children));
    reindexChildren(index);
  }
  
  protected void reparentChild(Node child) { child.setParentNode(this); }
  
  private void reindexChildren(int start) {
    int size = childNodeSize();
    if (size == 0)
      return; 
    List<Node> childNodes = ensureChildNodes();
    for (int i = start; i < size; i++)
      ((Node)childNodes.get(i)).setSiblingIndex(i); 
  }
  
  public List<Node> siblingNodes() {
    if (this.parentNode == null)
      return Collections.emptyList(); 
    List<Node> nodes = this.parentNode.ensureChildNodes();
    List<Node> siblings = new ArrayList<Node>(nodes.size() - 1);
    for (Node node : nodes) {
      if (node != this)
        siblings.add(node); 
    } 
    return siblings;
  }
  
  @Nullable
  public Node nextSibling() {
    if (this.parentNode == null)
      return null; 
    List<Node> siblings = this.parentNode.ensureChildNodes();
    int index = this.siblingIndex + 1;
    if (siblings.size() > index)
      return (Node)siblings.get(index); 
    return null;
  }
  
  @Nullable
  public Node previousSibling() {
    if (this.parentNode == null)
      return null; 
    if (this.siblingIndex > 0)
      return (Node)this.parentNode.ensureChildNodes().get(this.siblingIndex - 1); 
    return null;
  }
  
  public int siblingIndex() { return this.siblingIndex; }
  
  protected void setSiblingIndex(int siblingIndex) { this.siblingIndex = siblingIndex; }
  
  @Nullable
  public Node firstChild() {
    if (childNodeSize() == 0)
      return null; 
    return (Node)ensureChildNodes().get(0);
  }
  
  @Nullable
  public Node lastChild() {
    int size = childNodeSize();
    if (size == 0)
      return null; 
    List<Node> children = ensureChildNodes();
    return (Node)children.get(size - 1);
  }
  
  public Node traverse(NodeVisitor nodeVisitor) {
    Validate.notNull(nodeVisitor);
    NodeTraversor.traverse(nodeVisitor, this);
    return this;
  }
  
  public Node forEachNode(Consumer<? super Node> action) {
    Validate.notNull(action);
    NodeTraversor.traverse((node, depth) -> action.accept(node), this);
    return this;
  }
  
  @Deprecated
  public Node forEachNode(Consumer<? super Node> action) {
    Validate.notNull(action);
    NodeTraversor.traverse((node, depth) -> action.accept(node), this);
    return this;
  }
  
  public Node filter(NodeFilter nodeFilter) {
    Validate.notNull(nodeFilter);
    NodeTraversor.filter(nodeFilter, this);
    return this;
  }
  
  public String outerHtml() {
    StringBuilder accum = StringUtil.borrowBuilder();
    outerHtml(accum);
    return StringUtil.releaseBuilder(accum);
  }
  
  protected void outerHtml(Appendable accum) { NodeTraversor.traverse(new OuterHtmlVisitor(accum, NodeUtils.outputSettings(this)), this); }
  
  public <T extends Appendable> T html(T appendable) {
    outerHtml(appendable);
    return appendable;
  }
  
  public Range sourceRange() { return Range.of(this, true); }
  
  static boolean isNode(@Nullable Node node, String normalName) { return (node != null && node.normalName().equals(normalName)); }
  
  final boolean isNode(String normalName) { return normalName().equals(normalName); }
  
  final boolean isEffectivelyFirst() {
    if (this.siblingIndex == 0)
      return true; 
    if (this.siblingIndex == 1) {
      Node prev = previousSibling();
      return (prev instanceof TextNode && ((TextNode)prev).isBlank());
    } 
    return false;
  }
  
  public String toString() { return outerHtml(); }
  
  protected void indent(Appendable accum, int depth, Document.OutputSettings out) throws IOException { accum.append('\n').append(StringUtil.padding(depth * out.indentAmount(), out.maxPaddingWidth())); }
  
  public boolean equals(@Nullable Object o) { return (this == o); }
  
  public int hashCode() { return super.hashCode(); }
  
  public boolean hasSameValue(@Nullable Object o) {
    if (this == o)
      return true; 
    if (o == null || getClass() != o.getClass())
      return false; 
    return outerHtml().equals(((Node)o).outerHtml());
  }
  
  public Node clone() {
    Node thisClone = doClone(null);
    LinkedList<Node> nodesToProcess = new LinkedList<Node>();
    nodesToProcess.add(thisClone);
    while (!nodesToProcess.isEmpty()) {
      Node currParent = (Node)nodesToProcess.remove();
      int size = currParent.childNodeSize();
      for (int i = 0; i < size; i++) {
        List<Node> childNodes = currParent.ensureChildNodes();
        Node childClone = ((Node)childNodes.get(i)).doClone(currParent);
        childNodes.set(i, childClone);
        nodesToProcess.add(childClone);
      } 
    } 
    return thisClone;
  }
  
  public Node shallowClone() { return doClone(null); }
  
  protected Node doClone(@Nullable Node parent) {
    Node clone;
    try {
      clone = (Node)super.clone();
    } catch (CloneNotSupportedException e) {
      throw new RuntimeException(e);
    } 
    clone.parentNode = parent;
    clone.siblingIndex = (parent == null) ? 0 : this.siblingIndex;
    if (parent == null && !(this instanceof Document)) {
      Document doc = ownerDocument();
      if (doc != null) {
        Document docClone = doc.shallowClone();
        clone.parentNode = docClone;
        docClone.ensureChildNodes().add(clone);
      } 
    } 
    return clone;
  }
  
  public abstract String nodeName();
  
  protected abstract boolean hasAttributes();
  
  public abstract Attributes attributes();
  
  public abstract String baseUri();
  
  protected abstract void doSetBaseUri(String paramString);
  
  protected abstract List<Node> ensureChildNodes();
  
  public abstract int childNodeSize();
  
  public abstract Node empty();
  
  abstract void outerHtmlHead(Appendable paramAppendable, int paramInt, Document.OutputSettings paramOutputSettings) throws IOException;
  
  abstract void outerHtmlTail(Appendable paramAppendable, int paramInt, Document.OutputSettings paramOutputSettings) throws IOException;
}
