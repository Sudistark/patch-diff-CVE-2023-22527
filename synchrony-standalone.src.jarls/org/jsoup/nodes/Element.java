package org.jsoup.nodes;

import java.io.IOException;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import javax.annotation.Nullable;
import org.jsoup.helper.Consumer;
import org.jsoup.helper.Validate;
import org.jsoup.internal.NonnullByDefault;
import org.jsoup.internal.Normalizer;
import org.jsoup.internal.StringUtil;
import org.jsoup.parser.Tag;
import org.jsoup.parser.TokenQueue;
import org.jsoup.select.Collector;
import org.jsoup.select.Elements;
import org.jsoup.select.Evaluator;
import org.jsoup.select.NodeFilter;
import org.jsoup.select.NodeTraversor;
import org.jsoup.select.NodeVisitor;
import org.jsoup.select.QueryParser;
import org.jsoup.select.Selector;

@NonnullByDefault
public class Element extends Node {
  private static final List<Element> EmptyChildren = Collections.emptyList();
  
  private static final Pattern ClassSplit = Pattern.compile("\\s+");
  
  private static final String BaseUriKey = Attributes.internalKey("baseUri");
  
  private Tag tag;
  
  @Nullable
  private WeakReference<List<Element>> shadowChildrenRef;
  
  List<Node> childNodes;
  
  @Nullable
  Attributes attributes;
  
  public Element(String tag) { this(Tag.valueOf(tag), "", null); }
  
  public Element(Tag tag, @Nullable String baseUri, @Nullable Attributes attributes) {
    Validate.notNull(tag);
    this.childNodes = EmptyNodes;
    this.attributes = attributes;
    this.tag = tag;
    if (baseUri != null)
      setBaseUri(baseUri); 
  }
  
  public Element(Tag tag, @Nullable String baseUri) { this(tag, baseUri, null); }
  
  protected boolean hasChildNodes() { return (this.childNodes != EmptyNodes); }
  
  protected List<Node> ensureChildNodes() {
    if (this.childNodes == EmptyNodes)
      this.childNodes = new NodeList(this, 4); 
    return this.childNodes;
  }
  
  protected boolean hasAttributes() { return (this.attributes != null); }
  
  public Attributes attributes() {
    if (this.attributes == null)
      this.attributes = new Attributes(); 
    return this.attributes;
  }
  
  public String baseUri() { return searchUpForAttribute(this, BaseUriKey); }
  
  private static String searchUpForAttribute(Element start, String key) {
    Element el = start;
    while (el != null) {
      if (el.attributes != null && el.attributes.hasKey(key))
        return el.attributes.get(key); 
      el = el.parent();
    } 
    return "";
  }
  
  protected void doSetBaseUri(String baseUri) { attributes().put(BaseUriKey, baseUri); }
  
  public int childNodeSize() { return this.childNodes.size(); }
  
  public String nodeName() { return this.tag.getName(); }
  
  public String tagName() { return this.tag.getName(); }
  
  public String normalName() { return this.tag.normalName(); }
  
  public Element tagName(String tagName) {
    Validate.notEmptyParam(tagName, "tagName");
    this.tag = Tag.valueOf(tagName, NodeUtils.parser(this).settings());
    return this;
  }
  
  public Tag tag() { return this.tag; }
  
  public boolean isBlock() { return this.tag.isBlock(); }
  
  public String id() { return (this.attributes != null) ? this.attributes.getIgnoreCase("id") : ""; }
  
  public Element id(String id) {
    Validate.notNull(id);
    attr("id", id);
    return this;
  }
  
  public Element attr(String attributeKey, String attributeValue) {
    super.attr(attributeKey, attributeValue);
    return this;
  }
  
  public Element attr(String attributeKey, boolean attributeValue) {
    attributes().put(attributeKey, attributeValue);
    return this;
  }
  
  public Map<String, String> dataset() { return attributes().dataset(); }
  
  @Nullable
  public final Element parent() { return (Element)this.parentNode; }
  
  public Elements parents() {
    Elements parents = new Elements();
    Element parent = parent();
    while (parent != null && !parent.isNode("#root")) {
      parents.add(parent);
      parent = parent.parent();
    } 
    return parents;
  }
  
  public Element child(int index) { return (Element)childElementsList().get(index); }
  
  public int childrenSize() { return childElementsList().size(); }
  
  public Elements children() { return new Elements(childElementsList()); }
  
  List<Element> childElementsList() {
    if (childNodeSize() == 0)
      return EmptyChildren; 
    List<Element> children;
    if (this.shadowChildrenRef == null || (children = (List)this.shadowChildrenRef.get()) == null) {
      int size = this.childNodes.size();
      children = new ArrayList<Element>(size);
      for (int i = 0; i < size; i++) {
        Node node = (Node)this.childNodes.get(i);
        if (node instanceof Element)
          children.add((Element)node); 
      } 
      this.shadowChildrenRef = new WeakReference(children);
    } 
    return children;
  }
  
  void nodelistChanged() {
    super.nodelistChanged();
    this.shadowChildrenRef = null;
  }
  
  public List<TextNode> textNodes() {
    List<TextNode> textNodes = new ArrayList<TextNode>();
    for (Node node : this.childNodes) {
      if (node instanceof TextNode)
        textNodes.add((TextNode)node); 
    } 
    return Collections.unmodifiableList(textNodes);
  }
  
  public List<DataNode> dataNodes() {
    List<DataNode> dataNodes = new ArrayList<DataNode>();
    for (Node node : this.childNodes) {
      if (node instanceof DataNode)
        dataNodes.add((DataNode)node); 
    } 
    return Collections.unmodifiableList(dataNodes);
  }
  
  public Elements select(String cssQuery) { return Selector.select(cssQuery, this); }
  
  public Elements select(Evaluator evaluator) { return Selector.select(evaluator, this); }
  
  @Nullable
  public Element selectFirst(String cssQuery) { return Selector.selectFirst(cssQuery, this); }
  
  @Nullable
  public Element selectFirst(Evaluator evaluator) { return Collector.findFirst(evaluator, this); }
  
  public Element expectFirst(String cssQuery) {
    return (Element)Validate.ensureNotNull(
        Selector.selectFirst(cssQuery, this), 
        (parent() != null) ? 
        "No elements matched the query '%s' on element '%s'." : 
        "No elements matched the query '%s' in the document.", new Object[] { cssQuery, 
          tagName() });
  }
  
  public boolean is(String cssQuery) { return is(QueryParser.parse(cssQuery)); }
  
  public boolean is(Evaluator evaluator) { return evaluator.matches(root(), this); }
  
  @Nullable
  public Element closest(String cssQuery) { return closest(QueryParser.parse(cssQuery)); }
  
  @Nullable
  public Element closest(Evaluator evaluator) {
    Validate.notNull(evaluator);
    Element el = this;
    Element root = root();
    do {
      if (evaluator.matches(root, el))
        return el; 
      el = el.parent();
    } while (el != null);
    return null;
  }
  
  public Elements selectXpath(String xpath) { return new Elements(NodeUtils.selectXpath(xpath, this, Element.class)); }
  
  public <T extends Node> List<T> selectXpath(String xpath, Class<T> nodeType) { return NodeUtils.selectXpath(xpath, this, nodeType); }
  
  public Element appendChild(Node child) {
    Validate.notNull(child);
    reparentChild(child);
    ensureChildNodes();
    this.childNodes.add(child);
    child.setSiblingIndex(this.childNodes.size() - 1);
    return this;
  }
  
  public Element appendChildren(Collection<? extends Node> children) {
    insertChildren(-1, children);
    return this;
  }
  
  public Element appendTo(Element parent) {
    Validate.notNull(parent);
    parent.appendChild(this);
    return this;
  }
  
  public Element prependChild(Node child) {
    Validate.notNull(child);
    addChildren(0, new Node[] { child });
    return this;
  }
  
  public Element prependChildren(Collection<? extends Node> children) {
    insertChildren(0, children);
    return this;
  }
  
  public Element insertChildren(int index, Collection<? extends Node> children) {
    Validate.notNull(children, "Children collection to be inserted must not be null.");
    int currentSize = childNodeSize();
    if (index < 0)
      index += currentSize + 1; 
    Validate.isTrue((index >= 0 && index <= currentSize), "Insert position out of bounds.");
    ArrayList<Node> nodes = new ArrayList<Node>(children);
    Node[] nodeArray = (Node[])nodes.toArray(new Node[0]);
    addChildren(index, nodeArray);
    return this;
  }
  
  public Element insertChildren(int index, Node... children) {
    Validate.notNull(children, "Children collection to be inserted must not be null.");
    int currentSize = childNodeSize();
    if (index < 0)
      index += currentSize + 1; 
    Validate.isTrue((index >= 0 && index <= currentSize), "Insert position out of bounds.");
    addChildren(index, children);
    return this;
  }
  
  public Element appendElement(String tagName) {
    Element child = new Element(Tag.valueOf(tagName, NodeUtils.parser(this).settings()), baseUri());
    appendChild(child);
    return child;
  }
  
  public Element prependElement(String tagName) {
    Element child = new Element(Tag.valueOf(tagName, NodeUtils.parser(this).settings()), baseUri());
    prependChild(child);
    return child;
  }
  
  public Element appendText(String text) {
    Validate.notNull(text);
    TextNode node = new TextNode(text);
    appendChild(node);
    return this;
  }
  
  public Element prependText(String text) {
    Validate.notNull(text);
    TextNode node = new TextNode(text);
    prependChild(node);
    return this;
  }
  
  public Element append(String html) {
    Validate.notNull(html);
    List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());
    addChildren((Node[])nodes.toArray(new Node[0]));
    return this;
  }
  
  public Element prepend(String html) {
    Validate.notNull(html);
    List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());
    addChildren(0, (Node[])nodes.toArray(new Node[0]));
    return this;
  }
  
  public Element before(String html) { return (Element)super.before(html); }
  
  public Element before(Node node) { return (Element)super.before(node); }
  
  public Element after(String html) { return (Element)super.after(html); }
  
  public Element after(Node node) { return (Element)super.after(node); }
  
  public Element empty() {
    this.childNodes.clear();
    return this;
  }
  
  public Element wrap(String html) { return (Element)super.wrap(html); }
  
  public String cssSelector() {
    if (id().length() > 0) {
      String idSel = "#" + TokenQueue.escapeCssIdentifier(id());
      Document doc = ownerDocument();
      if (doc != null) {
        Elements els = doc.select(idSel);
        if (els.size() == 1 && els.get(false) == this)
          return idSel; 
      } else {
        return idSel;
      } 
    } 
    String tagName = TokenQueue.escapeCssIdentifier(tagName()).replace("\\:", "|");
    StringBuilder selector = StringUtil.borrowBuilder().append(tagName);
    StringUtil.StringJoiner escapedClasses = new StringUtil.StringJoiner(".");
    for (String name : classNames())
      escapedClasses.add(TokenQueue.escapeCssIdentifier(name)); 
    String classes = escapedClasses.complete();
    if (classes.length() > 0)
      selector.append('.').append(classes); 
    if (parent() == null || parent() instanceof Document)
      return StringUtil.releaseBuilder(selector); 
    selector.insert(0, " > ");
    if (parent().select(selector.toString()).size() > 1)
      selector.append(String.format(":nth-child(%d)", new Object[] { Integer.valueOf(elementSiblingIndex() + 1) })); 
    return parent().cssSelector() + StringUtil.releaseBuilder(selector);
  }
  
  public Elements siblingElements() {
    if (this.parentNode == null)
      return new Elements(0); 
    List<Element> elements = parent().childElementsList();
    Elements siblings = new Elements(elements.size() - 1);
    for (Element el : elements) {
      if (el != this)
        siblings.add(el); 
    } 
    return siblings;
  }
  
  @Nullable
  public Element nextElementSibling() {
    if (this.parentNode == null)
      return null; 
    List<Element> siblings = parent().childElementsList();
    int index = indexInList(this, siblings);
    if (siblings.size() > index + 1)
      return (Element)siblings.get(index + 1); 
    return null;
  }
  
  public Elements nextElementSiblings() { return nextElementSiblings(true); }
  
  @Nullable
  public Element previousElementSibling() {
    if (this.parentNode == null)
      return null; 
    List<Element> siblings = parent().childElementsList();
    int index = indexInList(this, siblings);
    if (index > 0)
      return (Element)siblings.get(index - 1); 
    return null;
  }
  
  public Elements previousElementSiblings() { return nextElementSiblings(false); }
  
  private Elements nextElementSiblings(boolean next) {
    Elements els = new Elements();
    if (this.parentNode == null)
      return els; 
    els.add(this);
    return next ? els.nextAll() : els.prevAll();
  }
  
  public Element firstElementSibling() {
    if (parent() != null) {
      List<Element> siblings = parent().childElementsList();
      return (siblings.size() > 1) ? (Element)siblings.get(0) : this;
    } 
    return this;
  }
  
  public int elementSiblingIndex() {
    if (parent() == null)
      return 0; 
    return indexInList(this, parent().childElementsList());
  }
  
  public Element lastElementSibling() {
    if (parent() != null) {
      List<Element> siblings = parent().childElementsList();
      return (siblings.size() > 1) ? (Element)siblings.get(siblings.size() - 1) : this;
    } 
    return this;
  }
  
  private static <E extends Element> int indexInList(Element search, List<E> elements) {
    int size = elements.size();
    for (int i = 0; i < size; i++) {
      if (elements.get(i) == search)
        return i; 
    } 
    return 0;
  }
  
  @Nullable
  public Element firstElementChild() {
    int size = childNodeSize();
    if (size == 0)
      return null; 
    List<Node> children = ensureChildNodes();
    for (int i = 0; i < size; i++) {
      Node node = (Node)children.get(i);
      if (node instanceof Element)
        return (Element)node; 
    } 
    return null;
  }
  
  @Nullable
  public Element lastElementChild() {
    int size = childNodeSize();
    if (size == 0)
      return null; 
    List<Node> children = ensureChildNodes();
    for (int i = size - 1; i >= 0; i--) {
      Node node = (Node)children.get(i);
      if (node instanceof Element)
        return (Element)node; 
    } 
    return null;
  }
  
  public Elements getElementsByTag(String tagName) {
    Validate.notEmpty(tagName);
    tagName = Normalizer.normalize(tagName);
    return Collector.collect(new Evaluator.Tag(tagName), this);
  }
  
  @Nullable
  public Element getElementById(String id) {
    Validate.notEmpty(id);
    Elements elements = Collector.collect(new Evaluator.Id(id), this);
    if (elements.size() > 0)
      return (Element)elements.get(0); 
    return null;
  }
  
  public Elements getElementsByClass(String className) {
    Validate.notEmpty(className);
    return Collector.collect(new Evaluator.Class(className), this);
  }
  
  public Elements getElementsByAttribute(String key) {
    Validate.notEmpty(key);
    key = key.trim();
    return Collector.collect(new Evaluator.Attribute(key), this);
  }
  
  public Elements getElementsByAttributeStarting(String keyPrefix) {
    Validate.notEmpty(keyPrefix);
    keyPrefix = keyPrefix.trim();
    return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);
  }
  
  public Elements getElementsByAttributeValue(String key, String value) { return Collector.collect(new Evaluator.AttributeWithValue(key, value), this); }
  
  public Elements getElementsByAttributeValueNot(String key, String value) { return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this); }
  
  public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) { return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this); }
  
  public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) { return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this); }
  
  public Elements getElementsByAttributeValueContaining(String key, String match) { return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this); }
  
  public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) { return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this); }
  
  public Elements getElementsByAttributeValueMatching(String key, String regex) {
    Pattern pattern;
    try {
      pattern = Pattern.compile(regex);
    } catch (PatternSyntaxException e) {
      throw new IllegalArgumentException("Pattern syntax error: " + regex, e);
    } 
    return getElementsByAttributeValueMatching(key, pattern);
  }
  
  public Elements getElementsByIndexLessThan(int index) { return Collector.collect(new Evaluator.IndexLessThan(index), this); }
  
  public Elements getElementsByIndexGreaterThan(int index) { return Collector.collect(new Evaluator.IndexGreaterThan(index), this); }
  
  public Elements getElementsByIndexEquals(int index) { return Collector.collect(new Evaluator.IndexEquals(index), this); }
  
  public Elements getElementsContainingText(String searchText) { return Collector.collect(new Evaluator.ContainsText(searchText), this); }
  
  public Elements getElementsContainingOwnText(String searchText) { return Collector.collect(new Evaluator.ContainsOwnText(searchText), this); }
  
  public Elements getElementsMatchingText(Pattern pattern) { return Collector.collect(new Evaluator.Matches(pattern), this); }
  
  public Elements getElementsMatchingText(String regex) {
    Pattern pattern;
    try {
      pattern = Pattern.compile(regex);
    } catch (PatternSyntaxException e) {
      throw new IllegalArgumentException("Pattern syntax error: " + regex, e);
    } 
    return getElementsMatchingText(pattern);
  }
  
  public Elements getElementsMatchingOwnText(Pattern pattern) { return Collector.collect(new Evaluator.MatchesOwn(pattern), this); }
  
  public Elements getElementsMatchingOwnText(String regex) {
    Pattern pattern;
    try {
      pattern = Pattern.compile(regex);
    } catch (PatternSyntaxException e) {
      throw new IllegalArgumentException("Pattern syntax error: " + regex, e);
    } 
    return getElementsMatchingOwnText(pattern);
  }
  
  public Elements getAllElements() { return Collector.collect(new Evaluator.AllElements(), this); }
  
  public String text() {
    StringBuilder accum = StringUtil.borrowBuilder();
    NodeTraversor.traverse(new Object(this, accum), this);
    return StringUtil.releaseBuilder(accum).trim();
  }
  
  public String wholeText() {
    StringBuilder accum = StringUtil.borrowBuilder();
    NodeTraversor.traverse((node, depth) -> appendWholeText(node, accum), this);
    return StringUtil.releaseBuilder(accum);
  }
  
  private static void appendWholeText(Node node, StringBuilder accum) {
    if (node instanceof TextNode) {
      accum.append(((TextNode)node).getWholeText());
    } else if (node.isNode("br")) {
      accum.append("\n");
    } 
  }
  
  public String wholeOwnText() {
    StringBuilder accum = StringUtil.borrowBuilder();
    int size = childNodeSize();
    for (int i = 0; i < size; i++) {
      Node node = (Node)this.childNodes.get(i);
      appendWholeText(node, accum);
    } 
    return StringUtil.releaseBuilder(accum);
  }
  
  public String ownText() {
    StringBuilder sb = StringUtil.borrowBuilder();
    ownText(sb);
    return StringUtil.releaseBuilder(sb).trim();
  }
  
  private void ownText(StringBuilder accum) {
    for (int i = 0; i < childNodeSize(); i++) {
      Node child = (Node)this.childNodes.get(i);
      if (child instanceof TextNode) {
        TextNode textNode = (TextNode)child;
        appendNormalisedText(accum, textNode);
      } else if (child.isNode("br") && !TextNode.lastCharIsWhitespace(accum)) {
        accum.append(" ");
      } 
    } 
  }
  
  private static void appendNormalisedText(StringBuilder accum, TextNode textNode) {
    String text = textNode.getWholeText();
    if (preserveWhitespace(textNode.parentNode) || textNode instanceof CDataNode) {
      accum.append(text);
    } else {
      StringUtil.appendNormalisedWhitespace(accum, text, TextNode.lastCharIsWhitespace(accum));
    } 
  }
  
  static boolean preserveWhitespace(@Nullable Node node) {
    if (node instanceof Element) {
      Element el = (Element)node;
      int i = 0;
      do {
        if (el.tag.preserveWhitespace())
          return true; 
        el = el.parent();
        ++i;
      } while (i < 6 && el != null);
    } 
    return false;
  }
  
  public Element text(String text) {
    Validate.notNull(text);
    empty();
    Document owner = ownerDocument();
    if (owner != null && owner.parser().isContentForTagData(normalName())) {
      appendChild(new DataNode(text));
    } else {
      appendChild(new TextNode(text));
    } 
    return this;
  }
  
  public boolean hasText() {
    AtomicBoolean hasText = new AtomicBoolean(false);
    filter((node, depth) -> {
          if (node instanceof TextNode) {
            TextNode textNode = (TextNode)node;
            if (!textNode.isBlank()) {
              hasText.set(true);
              return NodeFilter.FilterResult.STOP;
            } 
          } 
          return NodeFilter.FilterResult.CONTINUE;
        });
    return hasText.get();
  }
  
  public String data() {
    StringBuilder sb = StringUtil.borrowBuilder();
    traverse((childNode, depth) -> {
          if (childNode instanceof DataNode) {
            DataNode data = (DataNode)childNode;
            sb.append(data.getWholeData());
          } else if (childNode instanceof Comment) {
            Comment comment = (Comment)childNode;
            sb.append(comment.getData());
          } else if (childNode instanceof CDataNode) {
            CDataNode cDataNode = (CDataNode)childNode;
            sb.append(cDataNode.getWholeText());
          } 
        });
    return StringUtil.releaseBuilder(sb);
  }
  
  public String className() { return attr("class").trim(); }
  
  public Set<String> classNames() {
    String[] names = ClassSplit.split(className());
    Set<String> classNames = new LinkedHashSet<String>(Arrays.asList(names));
    classNames.remove("");
    return classNames;
  }
  
  public Element classNames(Set<String> classNames) {
    Validate.notNull(classNames);
    if (classNames.isEmpty()) {
      attributes().remove("class");
    } else {
      attributes().put("class", StringUtil.join(classNames, " "));
    } 
    return this;
  }
  
  public boolean hasClass(String className) {
    if (this.attributes == null)
      return false; 
    String classAttr = this.attributes.getIgnoreCase("class");
    int len = classAttr.length();
    int wantLen = className.length();
    if (len == 0 || len < wantLen)
      return false; 
    if (len == wantLen)
      return className.equalsIgnoreCase(classAttr); 
    boolean inClass = false;
    int start = 0;
    for (int i = 0; i < len; i++) {
      if (Character.isWhitespace(classAttr.charAt(i))) {
        if (inClass) {
          if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen))
            return true; 
          inClass = false;
        } 
      } else if (!inClass) {
        inClass = true;
        start = i;
      } 
    } 
    if (inClass && len - start == wantLen)
      return classAttr.regionMatches(true, start, className, 0, wantLen); 
    return false;
  }
  
  public Element addClass(String className) {
    Validate.notNull(className);
    Set<String> classes = classNames();
    classes.add(className);
    classNames(classes);
    return this;
  }
  
  public Element removeClass(String className) {
    Validate.notNull(className);
    Set<String> classes = classNames();
    classes.remove(className);
    classNames(classes);
    return this;
  }
  
  public Element toggleClass(String className) {
    Validate.notNull(className);
    Set<String> classes = classNames();
    if (classes.contains(className)) {
      classes.remove(className);
    } else {
      classes.add(className);
    } 
    classNames(classes);
    return this;
  }
  
  public String val() {
    if (normalName().equals("textarea"))
      return text(); 
    return attr("value");
  }
  
  public Element val(String value) {
    if (normalName().equals("textarea")) {
      text(value);
    } else {
      attr("value", value);
    } 
    return this;
  }
  
  public Range endSourceRange() { return Range.of(this, false); }
  
  boolean shouldIndent(Document.OutputSettings out) { return (out.prettyPrint() && isFormatAsBlock(out) && !isInlineable(out) && !preserveWhitespace(this.parentNode)); }
  
  void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
    if (shouldIndent(out))
      if (accum instanceof StringBuilder) {
        if (((StringBuilder)accum).length() > 0)
          indent(accum, depth, out); 
      } else {
        indent(accum, depth, out);
      }  
    accum.append('<').append(tagName());
    if (this.attributes != null)
      this.attributes.html(accum, out); 
    if (this.childNodes.isEmpty() && this.tag.isSelfClosing()) {
      if (out.syntax() == Document.OutputSettings.Syntax.html && this.tag.isEmpty()) {
        accum.append('>');
      } else {
        accum.append(" />");
      } 
    } else {
      accum.append('>');
    } 
  }
  
  void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
    if (!this.childNodes.isEmpty() || !this.tag.isSelfClosing()) {
      if (out.prettyPrint() && !this.childNodes.isEmpty() && ((this.tag
        .formatAsBlock() && !preserveWhitespace(this.parentNode)) || (out
        .outline() && (this.childNodes.size() > 1 || (this.childNodes.size() == 1 && this.childNodes.get(0) instanceof Element)))))
        indent(accum, depth, out); 
      accum.append("</").append(tagName()).append('>');
    } 
  }
  
  public String html() {
    StringBuilder accum = StringUtil.borrowBuilder();
    html(accum);
    String html = StringUtil.releaseBuilder(accum);
    return NodeUtils.outputSettings(this).prettyPrint() ? html.trim() : html;
  }
  
  public <T extends Appendable> T html(T appendable) {
    int size = this.childNodes.size();
    for (int i = 0; i < size; i++)
      ((Node)this.childNodes.get(i)).outerHtml(appendable); 
    return appendable;
  }
  
  public Element html(String html) {
    empty();
    append(html);
    return this;
  }
  
  public Element clone() { return (Element)super.clone(); }
  
  public Element shallowClone() { return new Element(this.tag, baseUri(), (this.attributes == null) ? null : this.attributes.clone()); }
  
  protected Element doClone(@Nullable Node parent) {
    Element clone = (Element)super.doClone(parent);
    clone.attributes = (this.attributes != null) ? this.attributes.clone() : null;
    clone.childNodes = new NodeList(clone, this.childNodes.size());
    clone.childNodes.addAll(this.childNodes);
    return clone;
  }
  
  public Element clearAttributes() {
    if (this.attributes != null) {
      super.clearAttributes();
      this.attributes = null;
    } 
    return this;
  }
  
  public Element removeAttr(String attributeKey) { return (Element)super.removeAttr(attributeKey); }
  
  public Element root() { return (Element)super.root(); }
  
  public Element traverse(NodeVisitor nodeVisitor) { return (Element)super.traverse(nodeVisitor); }
  
  public Element forEachNode(Consumer<? super Node> action) { return (Element)super.forEachNode(action); }
  
  public Element forEach(Consumer<? super Element> action) {
    Validate.notNull(action);
    NodeTraversor.traverse((node, depth) -> {
          if (node instanceof Element)
            action.accept((Element)node); 
        }this);
    return this;
  }
  
  @Deprecated
  public Element forEach(Consumer<? super Element> action) {
    Validate.notNull(action);
    NodeTraversor.traverse((node, depth) -> {
          if (node instanceof Element)
            action.accept((Element)node); 
        }this);
    return this;
  }
  
  public Element filter(NodeFilter nodeFilter) { return (Element)super.filter(nodeFilter); }
  
  private boolean isFormatAsBlock(Document.OutputSettings out) { return (this.tag.isBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline()); }
  
  private boolean isInlineable(Document.OutputSettings out) {
    if (!this.tag.isInline())
      return false; 
    return ((parent() == null || parent().isBlock()) && 
      !isEffectivelyFirst() && 
      !out.outline() && 
      !isNode("br"));
  }
}
