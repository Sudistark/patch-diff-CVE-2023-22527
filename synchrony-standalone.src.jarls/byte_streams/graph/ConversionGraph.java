package byte_streams.graph;

import clojure.lang.AFn;
import clojure.lang.IFn;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.PersistentArrayMap;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Util;
import clojure.lang.Var;

public final class ConversionGraph implements IConversionGraph, IType {
  public final Object m;
  
  public static final Var const__0 = (Var)RT.var("clojure.core", "assoc-in");
  
  public static final AFn const__2 = (AFn)Symbol.intern(null, "seq");
  
  public static final AFn const__3 = (AFn)Symbol.intern(null, "seq");
  
  public static final AFn const__4 = (AFn)Symbol.intern(null, "stream");
  
  public static final AFn const__5 = (AFn)Symbol.intern(null, "stream");
  
  public static final Var const__6 = (Var)RT.var("clojure.core", "keys"), const__7 = (Var)RT.var("clojure.core", "mapcat"), const__8 = (Var)RT.var("clojure.core", "vals"), const__9 = (Var)RT.var("clojure.core", "filter"), const__10 = (Var)RT.var("clojure.core", "into"), const__11 = (Var)RT.var("clojure.core", "concat"), const__12 = (Var)RT.var("byte-streams.graph", "implicit-conversions"), const__13 = (Var)RT.var("clojure.core", "partial"), const__14 = (Var)RT.var("byte-streams.graph", "assignable?");
  
  public ConversionGraph(Object paramObject) { this.m = paramObject; }
  
  public static IPersistentVector getBasis() { return Tuple.create(Symbol.intern(null, "m")); }
  
  public Object possible_conversions(Object src) { src = null;
    this = null;
    return ((IFn)const__10.getRawRoot()).invoke(PersistentArrayMap.EMPTY, ((IFn)const__11.getRawRoot()).invoke(((IFn)const__12.getRawRoot()).invoke(src), ((IFn)const__7.getRawRoot()).invoke(new fn__17483(this.m), ((IFn)const__9.getRawRoot()).invoke(((IFn)const__13.getRawRoot()).invoke(const__14.getRawRoot(), src), ((IFn)const__6.getRawRoot()).invoke(this.m))))); }
  
  public Object equivalent_targets(Object dst) {
    dst = null;
    this = null;
    return ((IFn)const__9.getRawRoot()).invoke(new fn__17481(dst), ((IFn)const__7.getRawRoot()).invoke(const__6.getRawRoot(), ((IFn)const__8.getRawRoot()).invoke(this.m)));
  }
  
  public Object possible_targets() { this = null;
    return ((IFn)const__7.getRawRoot()).invoke(const__6.getRawRoot(), ((IFn)const__8.getRawRoot()).invoke(this.m)); }
  
  public Object possible_sources() { this = null;
    return ((IFn)const__6.getRawRoot()).invoke(this.m); }
  
  public Object assoc_conversion(Object src, Object dst, Object f, Object cost) {
    Object m_SINGLEQUOTE_ = ((IFn)const__0.getRawRoot()).invoke(this.m, Tuple.create(src, dst), new Conversion(f, RT.doubleCast((Number)cost)));
    boolean and__5514__auto__17492 = Util.identical(((Type)src).wrapper, null);
    src = null;
    Object src = ((Type)src).type;
    dst = null;
    Object dst = ((Type)dst).type;
    m_SINGLEQUOTE_ = null;
    src = null;
    dst = null;
    f = null;
    cost = null;
    m_SINGLEQUOTE_ = null;
    Object m_SINGLEQUOTE_ = (and__5514__auto__17492 ? Util.identical(((Type)dst).wrapper, null) : and__5514__auto__17492) ? ((IFn)const__0.getRawRoot()).invoke(((IFn)const__0.getRawRoot()).invoke(m_SINGLEQUOTE_, Tuple.create(new Type(const__2, src), new Type(const__3, dst)), new Conversion(new fn__17473(f), RT.doubleCast((Number)cost))), Tuple.create(new Type(const__4, src), new Type(const__5, dst)), new Conversion(new fn__17477(f), RT.doubleCast((Number)cost))) : m_SINGLEQUOTE_;
    m_SINGLEQUOTE_ = null;
    return new ConversionGraph(m_SINGLEQUOTE_);
  }
}
