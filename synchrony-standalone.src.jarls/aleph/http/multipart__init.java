package aleph.http;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class multipart__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__2;
  
  public static final Var const__3;
  
  public static final AFn const__12;
  
  public static final Var const__13;
  
  public static final AFn const__16;
  
  public static final Var const__17;
  
  public static final AFn const__21;
  
  public static final Var const__22;
  
  public static final AFn const__25;
  
  public static final Var const__26;
  
  public static final AFn const__29;
  
  public static final Var const__30;
  
  public static final AFn const__35;
  
  public static final Var const__36;
  
  public static final AFn const__40;
  
  public static final Var const__41;
  
  public static final AFn const__44;
  
  public static final Var const__45;
  
  public static final AFn const__48;
  
  public static final Var const__49;
  
  public static final AFn const__52;
  
  public static final Var const__53;
  
  public static final AFn const__56;
  
  public static final Var const__57;
  
  public static final Var const__58;
  
  public static final AFn const__61;
  
  public static final Var const__62;
  
  public static final AFn const__65;
  
  public static final Var const__66;
  
  public static final AFn const__69;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new multipart.fn__28439());
    const__3.setMeta((IPersistentMap)const__12);
    const__3.bindRoot(new multipart.boundary());
    const__13.setMeta((IPersistentMap)const__16);
    const__13.bindRoot(new multipart.mime_type_descriptor());
    const__17.setMeta((IPersistentMap)const__21);
    const__17.bindRoot(new multipart.populate_part());
    const__22.setMeta((IPersistentMap)const__25);
    const__22.bindRoot(new multipart.part_headers());
    const__26.setMeta((IPersistentMap)const__29);
    const__26.bindRoot(new multipart.encode_part());
    const__30.setMeta((IPersistentMap)const__35);
    const__30.bindRoot(new multipart.encode_body());
    const__36.setMeta((IPersistentMap)const__40);
    const__36.bindRoot(new multipart.ensure_charset());
    const__41.setMeta((IPersistentMap)const__44);
    const__41.bindRoot(new multipart.encode_file_upload());
    const__45.setMeta((IPersistentMap)const__48);
    const__45.bindRoot(new multipart.encode_memory_file_upload());
    const__49.setMeta((IPersistentMap)const__52);
    const__49.bindRoot(new multipart.encode_memory_attribute());
    const__53.setMeta((IPersistentMap)const__56);
    const__53.bindRoot(new multipart.encode_request());
    const__58.setMeta((IPersistentMap)const__61);
    const__58.bindRoot(new multipart.read_attributes());
    const__62.setMeta((IPersistentMap)const__65);
    const__62.bindRoot(new multipart.destroy_decoder());
    const__66.setMeta((IPersistentMap)const__69);
    const__66.bindRoot(new multipart.decode_request());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "aleph.http.multipart");
    const__2 = (AFn)Symbol.intern(null, "clojure.core");
    const__3 = (Var)RT.var("aleph.http.multipart", "boundary");
    const__12 = (AFn)RT.map(new Object[] { RT.keyword(null, "no-doc"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "line"), Integer.valueOf(40), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "aleph/http/multipart.clj" });
    const__13 = (Var)RT.var("aleph.http.multipart", "mime-type-descriptor");
    const__16 = (AFn)RT.map(new Object[] { RT.keyword(null, "no-doc"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "mime-type")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })), ((IObj)Symbol.intern(null, "encoding")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))) })), RT.keyword(null, "line"), Integer.valueOf(43), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "aleph/http/multipart.clj" });
    const__17 = (Var)RT.var("aleph.http.multipart", "populate-part");
    const__21 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "no-doc"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "part-name"), Symbol.intern(null, "content"), Symbol.intern(null, "mime-type"), Symbol.intern(null, "charset"), Symbol.intern(null, "transfer-encoding"), Symbol.intern(null, "name")) })) })), RT.keyword(null, "doc"), "Generates a part map of the appropriate format", RT.keyword(null, "line"), Integer.valueOf(50), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "aleph/http/multipart.clj" });
    const__22 = (Var)RT.var("aleph.http.multipart", "part-headers");
    const__25 = (AFn)RT.map(new Object[] { RT.keyword(null, "no-doc"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "part-name")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })), ((IObj)Symbol.intern(null, "mime-type")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })), Symbol.intern(null, "transfer-encoding"), Symbol.intern(null, "name")) })), RT.keyword(null, "line"), Integer.valueOf(82), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "aleph/http/multipart.clj" });
    const__26 = (Var)RT.var("aleph.http.multipart", "encode-part");
    const__29 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "no-doc"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "part-name"), Symbol.intern(null, "content"), Symbol.intern(null, "mime-type"), Symbol.intern(null, "charset"), Symbol.intern(null, "transfer-encoding"), Symbol.intern(null, "name")), RT.keyword(null, "as"), Symbol.intern(null, "part") })) })), RT.keyword(null, "doc"), "Generates the byte representation of a part for the bytebuffer", RT.keyword(null, "line"), Integer.valueOf(92), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "aleph/http/multipart.clj" });
    const__30 = (Var)RT.var("aleph.http.multipart", "encode-body");
    const__35 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "deprecated"), "0.4.7-alpha2", RT.keyword(null, "superseded-by"), "encode-request", RT.keyword(null, "no-doc"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "parts")), Tuple.create(((IObj)Symbol.intern(null, "boundary")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })), Symbol.intern(null, "parts")) })), RT.keyword(null, "line"), Integer.valueOf(107), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "aleph/http/multipart.clj" });
    const__36 = (Var)RT.var("aleph.http.multipart", "ensure-charset");
    const__40 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "charset")) })), RT.keyword(null, "line"), Integer.valueOf(132), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "aleph/http/multipart.clj" });
    const__41 = (Var)RT.var("aleph.http.multipart", "encode-file-upload");
    const__44 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "encoder")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "HttpPostRequestEncoder") })), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "part-name"), Symbol.intern(null, "name"), Symbol.intern(null, "file-name"), Symbol.intern(null, "content"), Symbol.intern(null, "mime-type"), Symbol.intern(null, "charset")) })) })), RT.keyword(null, "doc"), "Encode the `content` as a `FileUpload`.", RT.keyword(null, "line"), Integer.valueOf(143), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "aleph/http/multipart.clj" });
    const__45 = (Var)RT.var("aleph.http.multipart", "encode-memory-file-upload");
    const__48 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "encoder")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "HttpPostRequestEncoder") })), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "part-name"), Symbol.intern(null, "name"), Symbol.intern(null, "file-name"), Symbol.intern(null, "content"), Symbol.intern(null, "mime-type"), Symbol.intern(null, "charset")) })) })), RT.keyword(null, "doc"), "Encode the `content` as a `MemoryFileUpload`.", RT.keyword(null, "line"), Integer.valueOf(153), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "aleph/http/multipart.clj" });
    const__49 = (Var)RT.var("aleph.http.multipart", "encode-memory-attribute");
    const__52 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "encoder")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "HttpPostRequestEncoder") })), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "part-name"), Symbol.intern(null, "name"), Symbol.intern(null, "content"), Symbol.intern(null, "charset")) })) })), RT.keyword(null, "doc"), "Encode the `content` as a `MemoryAttribute`.", RT.keyword(null, "line"), Integer.valueOf(165), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "aleph/http/multipart.clj" });
    const__53 = (Var)RT.var("aleph.http.multipart", "encode-request");
    const__56 = (AFn)RT.map(new Object[] { RT.keyword(null, "no-doc"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "req")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "DefaultHttpRequest") })), Symbol.intern(null, "parts")) })), RT.keyword(null, "line"), Integer.valueOf(176), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "aleph/http/multipart.clj" });
    const__57 = (Var)RT.var("aleph.http.multipart", "http-data->map");
    const__58 = (Var)RT.var("aleph.http.multipart", "read-attributes");
    const__61 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "decoder")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "HttpPostRequestDecoder") })), Symbol.intern(null, "parts"), Symbol.intern(null, "manual-cleanup?")) })), RT.keyword(null, "line"), Integer.valueOf(224), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "aleph/http/multipart.clj" });
    const__62 = (Var)RT.var("aleph.http.multipart", "destroy-decoder");
    const__65 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "decoder")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "HttpPostRequestDecoder") })), Symbol.intern(null, "destroyed?")) })), RT.keyword(null, "line"), Integer.valueOf(232), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "aleph/http/multipart.clj" });
    const__66 = (Var)RT.var("aleph.http.multipart", "decode-request");
    const__69 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "req")), Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "body")), RT.keyword(null, "as"), Symbol.intern(null, "req") }), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "body-buffer-size"), Symbol.intern(null, "memory-limit"), Symbol.intern(null, "manual-cleanup?")), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "body-buffer-size"), Long.valueOf(65536L), Symbol.intern(null, "memory-limit"), Symbol.intern("DefaultHttpDataFactory", "MINSIZE"), Symbol.intern(null, "manual-cleanup?"), Boolean.FALSE }) })) })), RT.keyword(null, "doc"), "Takes a ring request and returns a manifold stream which yields\n   parts of the mutlipart/form-data encoded body. In case the size of\n   a part content exceeds `:memory-limit` limit (16KB by default),\n   corresponding payload would be written to a temp file. Check `:memory?`\n   flag to know whether content might be read directly from `:content` or\n   should be fetched from the file specified in `:file`.\n\n   If you want to use temporary files storage, you will have to fallback\n   to `:manual-cleanup?` otherwise the files will be removed from the filesystem\n   before you had time to copy them on another location.\n   Instead of returning a manifold stream, it will return vector composed of a\n   manifold stream and a callback to clean the resources.\n   See: https://cljdoc.org/d/aleph/aleph/CURRENT/doc/http/handling-multipart-requests#manual-cleanup\n\n   Note, that if your handler works with multipart requests only,\n   it's better to set `:raw-stream?` to `true` to avoid additional\n   input stream coercion.", RT.keyword(null, "line"), Integer.valueOf(239), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "aleph/http/multipart.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("aleph.http.multipart__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
