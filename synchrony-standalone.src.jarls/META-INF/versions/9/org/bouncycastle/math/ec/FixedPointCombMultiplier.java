package META-INF.versions.9.org.bouncycastle.math.ec;

import java.math.BigInteger;
import org.bouncycastle.math.ec.AbstractECMultiplier;
import org.bouncycastle.math.ec.ECCurve;
import org.bouncycastle.math.ec.ECLookupTable;
import org.bouncycastle.math.ec.ECPoint;
import org.bouncycastle.math.ec.FixedPointPreCompInfo;
import org.bouncycastle.math.ec.FixedPointUtil;
import org.bouncycastle.math.raw.Nat;

public class FixedPointCombMultiplier extends AbstractECMultiplier {
  protected ECPoint multiplyPositive(ECPoint paramECPoint, BigInteger paramBigInteger) {
    ECCurve eCCurve = paramECPoint.getCurve();
    int i = FixedPointUtil.getCombSize(eCCurve);
    if (paramBigInteger.bitLength() > i)
      throw new IllegalStateException("fixed-point comb doesn't support scalars larger than the curve order"); 
    FixedPointPreCompInfo fixedPointPreCompInfo = FixedPointUtil.precompute(paramECPoint);
    ECLookupTable eCLookupTable = fixedPointPreCompInfo.getLookupTable();
    int j = fixedPointPreCompInfo.getWidth();
    int k = (i + j - 1) / j;
    ECPoint eCPoint = eCCurve.getInfinity();
    int m = k * j;
    int[] arrayOfInt = Nat.fromBigInteger(m, paramBigInteger);
    int n = m - 1;
    for (int i1 = 0; i1 < k; i1++) {
      int i2 = 0;
      int i3;
      for (i3 = n - i1; i3 >= 0; i3 -= k) {
        int i4 = arrayOfInt[i3 >>> 5] >>> (i3 & 0x1F);
        i2 ^= i4 >>> 1;
        i2 <<= 1;
        i2 ^= i4;
      } 
      ECPoint eCPoint1 = eCLookupTable.lookup(i2);
      eCPoint = eCPoint.twicePlus(eCPoint1);
    } 
    return eCPoint.add(fixedPointPreCompInfo.getOffset());
  }
}
