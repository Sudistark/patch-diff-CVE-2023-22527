package META-INF.versions.9.org.bouncycastle.math.raw;

import java.util.Random;
import org.bouncycastle.math.raw.Mod;
import org.bouncycastle.math.raw.Nat;
import org.bouncycastle.util.Integers;

public abstract class Mod {
  private static final int M30 = 1073741823;
  
  private static final long M32L = 4294967295L;
  
  public static void add(int[] paramArrayOfInt1, int[] paramArrayOfInt2, int[] paramArrayOfInt3, int[] paramArrayOfInt4) {
    int i = paramArrayOfInt1.length;
    int j = Nat.add(i, paramArrayOfInt2, paramArrayOfInt3, paramArrayOfInt4);
    if (j != 0)
      Nat.subFrom(i, paramArrayOfInt1, paramArrayOfInt4); 
  }
  
  public static void checkedModOddInverse(int[] paramArrayOfInt1, int[] paramArrayOfInt2, int[] paramArrayOfInt3) {
    if (0 == modOddInverse(paramArrayOfInt1, paramArrayOfInt2, paramArrayOfInt3))
      throw new ArithmeticException("Inverse does not exist."); 
  }
  
  public static void checkedModOddInverseVar(int[] paramArrayOfInt1, int[] paramArrayOfInt2, int[] paramArrayOfInt3) {
    if (!modOddInverseVar(paramArrayOfInt1, paramArrayOfInt2, paramArrayOfInt3))
      throw new ArithmeticException("Inverse does not exist."); 
  }
  
  public static int inverse32(int paramInt) {
    null = paramInt;
    null *= (2 - paramInt * null);
    null *= (2 - paramInt * null);
    null *= (2 - paramInt * null);
    return 2 - paramInt * null;
  }
  
  public static void invert(int[] paramArrayOfInt1, int[] paramArrayOfInt2, int[] paramArrayOfInt3) { checkedModOddInverseVar(paramArrayOfInt1, paramArrayOfInt2, paramArrayOfInt3); }
  
  public static int modOddInverse(int[] paramArrayOfInt1, int[] paramArrayOfInt2, int[] paramArrayOfInt3) {
    int i = paramArrayOfInt1.length;
    int j = (i << 5) - Integers.numberOfLeadingZeros(paramArrayOfInt1[i - 1]);
    int k = (j + 29) / 30;
    int[] arrayOfInt1 = new int[4];
    int[] arrayOfInt2 = new int[k];
    int[] arrayOfInt3 = new int[k];
    int[] arrayOfInt4 = new int[k];
    int[] arrayOfInt5 = new int[k];
    int[] arrayOfInt6 = new int[k];
    arrayOfInt3[0] = 1;
    encode30(j, paramArrayOfInt2, 0, arrayOfInt5, 0);
    encode30(j, paramArrayOfInt1, 0, arrayOfInt6, 0);
    System.arraycopy(arrayOfInt6, 0, arrayOfInt4, 0, k);
    int m = -1;
    int n = inverse32(arrayOfInt6[0]);
    int i1 = getMaximumDivsteps(j);
    int i2;
    for (i2 = 0; i2 < i1; i2 += true) {
      m = divsteps30(m, arrayOfInt4[0], arrayOfInt5[0], arrayOfInt1);
      updateDE30(k, arrayOfInt2, arrayOfInt3, arrayOfInt1, n, arrayOfInt6);
      updateFG30(k, arrayOfInt4, arrayOfInt5, arrayOfInt1);
    } 
    i2 = arrayOfInt4[k - 1] >> 31;
    cnegate30(k, i2, arrayOfInt4);
    cnormalize30(k, i2, arrayOfInt2, arrayOfInt6);
    decode30(j, arrayOfInt2, 0, paramArrayOfInt3, 0);
    return Nat.equalTo(k, arrayOfInt4, 1) & Nat.equalToZero(k, arrayOfInt5);
  }
  
  public static boolean modOddInverseVar(int[] paramArrayOfInt1, int[] paramArrayOfInt2, int[] paramArrayOfInt3) {
    int i = paramArrayOfInt1.length;
    int j = (i << 5) - Integers.numberOfLeadingZeros(paramArrayOfInt1[i - 1]);
    int k = (j + 29) / 30;
    int[] arrayOfInt1 = new int[4];
    int[] arrayOfInt2 = new int[k];
    int[] arrayOfInt3 = new int[k];
    int[] arrayOfInt4 = new int[k];
    int[] arrayOfInt5 = new int[k];
    int[] arrayOfInt6 = new int[k];
    arrayOfInt3[0] = 1;
    encode30(j, paramArrayOfInt2, 0, arrayOfInt5, 0);
    encode30(j, paramArrayOfInt1, 0, arrayOfInt6, 0);
    System.arraycopy(arrayOfInt6, 0, arrayOfInt4, 0, k);
    int m = Integers.numberOfLeadingZeros(arrayOfInt5[k - 1] | true) - k * 30 + 2 - j;
    int n = -1 - m;
    int i1 = k, i2 = k;
    int i3 = inverse32(arrayOfInt6[0]);
    int i4 = getMaximumDivsteps(j);
    boolean bool = false;
    while (!Nat.isZero(i2, arrayOfInt5)) {
      if (bool >= i4)
        return false; 
      bool += true;
      n = divsteps30Var(n, arrayOfInt4[0], arrayOfInt5[0], arrayOfInt1);
      updateDE30(i1, arrayOfInt2, arrayOfInt3, arrayOfInt1, i3, arrayOfInt6);
      updateFG30(i2, arrayOfInt4, arrayOfInt5, arrayOfInt1);
      int i7 = arrayOfInt4[i2 - 1];
      int i8 = arrayOfInt5[i2 - 1];
      int i9 = i2 - 2 >> 31;
      i9 |= i7 ^ i7 >> 31;
      i9 |= i8 ^ i8 >> 31;
      if (i9 == 0) {
        arrayOfInt4[i2 - 2] = arrayOfInt4[i2 - 2] | i7 << 30;
        arrayOfInt5[i2 - 2] = arrayOfInt5[i2 - 2] | i8 << 30;
        i2--;
      } 
    } 
    int i5 = arrayOfInt4[i2 - 1] >> 31;
    int i6 = arrayOfInt2[i1 - 1] >> 31;
    if (i6 < 0)
      i6 = add30(i1, arrayOfInt2, arrayOfInt6); 
    if (i5 < 0) {
      i6 = negate30(i1, arrayOfInt2);
      i5 = negate30(i2, arrayOfInt4);
    } 
    if (!Nat.isOne(i2, arrayOfInt4))
      return false; 
    if (i6 < 0)
      i6 = add30(i1, arrayOfInt2, arrayOfInt6); 
    decode30(j, arrayOfInt2, 0, paramArrayOfInt3, 0);
    return true;
  }
  
  public static int[] random(int[] paramArrayOfInt) {
    int i = paramArrayOfInt.length;
    Random random = new Random();
    int[] arrayOfInt = Nat.create(i);
    int j = paramArrayOfInt[i - 1];
    j |= j >>> 1;
    j |= j >>> 2;
    j |= j >>> 4;
    j |= j >>> 8;
    j |= j >>> 16;
    do {
      for (byte b = 0; b != i; b++)
        arrayOfInt[b] = random.nextInt(); 
      arrayOfInt[i - 1] = arrayOfInt[i - 1] & j;
    } while (Nat.gte(i, arrayOfInt, paramArrayOfInt));
    return arrayOfInt;
  }
  
  public static void subtract(int[] paramArrayOfInt1, int[] paramArrayOfInt2, int[] paramArrayOfInt3, int[] paramArrayOfInt4) {
    int i = paramArrayOfInt1.length;
    int j = Nat.sub(i, paramArrayOfInt2, paramArrayOfInt3, paramArrayOfInt4);
    if (j != 0)
      Nat.addTo(i, paramArrayOfInt1, paramArrayOfInt4); 
  }
  
  private static int add30(int paramInt, int[] paramArrayOfInt1, int[] paramArrayOfInt2) {
    null = 0;
    int i = paramInt - 1;
    for (byte b = 0; b < i; b++) {
      null += paramArrayOfInt1[b] + paramArrayOfInt2[b];
      paramArrayOfInt1[b] = null & 0x3FFFFFFF;
      null >>= 30;
    } 
    null += paramArrayOfInt1[i] + paramArrayOfInt2[i];
    paramArrayOfInt1[i] = null;
    return 30;
  }
  
  private static void cnegate30(int paramInt1, int paramInt2, int[] paramArrayOfInt) {
    int i = 0, j = paramInt1 - 1;
    for (byte b = 0; b < j; b++) {
      i += (paramArrayOfInt[b] ^ paramInt2) - paramInt2;
      paramArrayOfInt[b] = i & 0x3FFFFFFF;
      i >>= 30;
    } 
    i += (paramArrayOfInt[j] ^ paramInt2) - paramInt2;
    paramArrayOfInt[j] = i;
  }
  
  private static void cnormalize30(int paramInt1, int paramInt2, int[] paramArrayOfInt1, int[] paramArrayOfInt2) {
    int i = paramInt1 - 1;
    int j = 0, k = paramArrayOfInt1[i] >> 31;
    int m;
    for (m = 0; m < i; m++) {
      int n = paramArrayOfInt1[m] + (paramArrayOfInt2[m] & k);
      n = (n ^ paramInt2) - paramInt2;
      j += n;
      paramArrayOfInt1[m] = j & 0x3FFFFFFF;
      j >>= 30;
    } 
    m = paramArrayOfInt1[i] + (paramArrayOfInt2[i] & k);
    m = (m ^ paramInt2) - paramInt2;
    j += m;
    paramArrayOfInt1[i] = j;
    j = 0;
    k = paramArrayOfInt1[i] >> 31;
    for (m = 0; m < i; m++) {
      int n = paramArrayOfInt1[m] + (paramArrayOfInt2[m] & k);
      j += n;
      paramArrayOfInt1[m] = j & 0x3FFFFFFF;
      j >>= 30;
    } 
    m = paramArrayOfInt1[i] + (paramArrayOfInt2[i] & k);
    j += m;
    paramArrayOfInt1[i] = j;
  }
  
  private static void decode30(int paramInt1, int[] paramArrayOfInt1, int paramInt2, int[] paramArrayOfInt2, int paramInt3) {
    boolean bool = false;
    long l = 0L;
    while (paramInt1 > 0) {
      while (bool < Math.min(32, paramInt1)) {
        l |= paramArrayOfInt1[paramInt2++] << bool;
        bool += true;
      } 
      paramArrayOfInt2[paramInt3++] = (int)l;
      l >>>= 32;
      bool -= true;
      paramInt1 -= 32;
    } 
  }
  
  private static int divsteps30(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt) {
    int i = 1, j = 0, k = 0, m = 1;
    int n = paramInt2, i1 = paramInt3;
    for (byte b = 0; b < 30; b++) {
      int i2 = paramInt1 >> 31;
      int i3 = -(i1 & true);
      int i4 = (n ^ i2) - i2;
      int i5 = (i ^ i2) - i2;
      int i6 = (j ^ i2) - i2;
      i1 += (i4 & i3);
      k += (i5 & i3);
      m += (i6 & i3);
      i2 &= i3;
      paramInt1 = (paramInt1 ^ i2) - i2 + 1;
      n += (i1 & i2);
      i += (k & i2);
      j += (m & i2);
      i1 >>= 1;
      i <<= 1;
      j <<= 1;
    } 
    paramArrayOfInt[0] = i;
    paramArrayOfInt[1] = j;
    paramArrayOfInt[2] = k;
    paramArrayOfInt[3] = m;
    return paramInt1;
  }
  
  private static int divsteps30Var(int paramInt1, int paramInt2, int paramInt3, int[] paramArrayOfInt) {
    int i = 1, j = 0, k = 0, m = 1;
    int n = paramInt2, i1 = paramInt3;
    int i2 = 30;
    while (true) {
      int i3, i4 = Integers.numberOfTrailingZeros(i1 | -1 << i2);
      i1 >>= i4;
      i <<= i4;
      j <<= i4;
      paramInt1 -= i4;
      i2 -= i4;
      if (i2 <= 0)
        break; 
      if (paramInt1 < 0) {
        paramInt1 = -paramInt1;
        int i6 = n;
        n = i1;
        i1 = -i6;
        int i7 = i;
        i = k;
        k = -i7;
        int i8 = j;
        j = m;
        m = -i8;
        int i9 = (paramInt1 + 1 > i2) ? i2 : (paramInt1 + 1);
        int i5 = -1 >>> 32 - i9 & 0x3F;
        i3 = n * i1 * (n * n - 2) & i5;
      } else {
        int i6 = (paramInt1 + 1 > i2) ? i2 : (paramInt1 + 1);
        int i5 = -1 >>> 32 - i6 & 0xF;
        i3 = n + ((n + 1 & 0x4) << 1);
        i3 = -i3 * i1 & i5;
      } 
      i1 += n * i3;
      k += i * i3;
      m += j * i3;
    } 
    paramArrayOfInt[0] = i;
    paramArrayOfInt[1] = j;
    paramArrayOfInt[2] = k;
    paramArrayOfInt[3] = m;
    return paramInt1;
  }
  
  private static void encode30(int paramInt1, int[] paramArrayOfInt1, int paramInt2, int[] paramArrayOfInt2, int paramInt3) {
    boolean bool = false;
    long l = 0L;
    while (paramInt1 > 0) {
      if (bool < Math.min(30, paramInt1)) {
        l |= (paramArrayOfInt1[paramInt2++] & 0xFFFFFFFFL) << bool;
        bool += true;
      } 
      paramArrayOfInt2[paramInt3++] = (int)l & 0x3FFFFFFF;
      l >>>= 30;
      bool -= true;
      paramInt1 -= 30;
    } 
  }
  
  private static int getMaximumDivsteps(int paramInt) { return (49 * paramInt + ((paramInt < 46) ? 80 : 47)) / 17; }
  
  private static int negate30(int paramInt, int[] paramArrayOfInt) {
    null = 0;
    int i = paramInt - 1;
    for (byte b = 0; b < i; b++) {
      null -= paramArrayOfInt[b];
      paramArrayOfInt[b] = null & 0x3FFFFFFF;
      null >>= 30;
    } 
    null -= paramArrayOfInt[i];
    paramArrayOfInt[i] = null;
    return 30;
  }
  
  private static void updateDE30(int paramInt1, int[] paramArrayOfInt1, int[] paramArrayOfInt2, int[] paramArrayOfInt3, int paramInt2, int[] paramArrayOfInt4) {
    int i = paramArrayOfInt3[0], j = paramArrayOfInt3[1], k = paramArrayOfInt3[2], m = paramArrayOfInt3[3];
    int i5 = paramArrayOfInt1[paramInt1 - 1] >> 31;
    int i6 = paramArrayOfInt2[paramInt1 - 1] >> 31;
    int i2 = (i & i5) + (j & i6);
    int i3 = (k & i5) + (m & i6);
    int i4 = paramArrayOfInt4[0];
    int n = paramArrayOfInt1[0];
    int i1 = paramArrayOfInt2[0];
    long l1 = i * n + j * i1;
    long l2 = k * n + m * i1;
    i2 -= (paramInt2 * (int)l1 + i2 & 0x3FFFFFFF);
    i3 -= (paramInt2 * (int)l2 + i3 & 0x3FFFFFFF);
    l1 += i4 * i2;
    l2 += i4 * i3;
    l1 >>= 30;
    l2 >>= 30;
    for (byte b = 1; b < paramInt1; b++) {
      i4 = paramArrayOfInt4[b];
      n = paramArrayOfInt1[b];
      i1 = paramArrayOfInt2[b];
      l1 += i * n + j * i1 + i4 * i2;
      l2 += k * n + m * i1 + i4 * i3;
      paramArrayOfInt1[b - true] = (int)l1 & 0x3FFFFFFF;
      l1 >>= 30;
      paramArrayOfInt2[b - true] = (int)l2 & 0x3FFFFFFF;
      l2 >>= 30;
    } 
    paramArrayOfInt1[paramInt1 - 1] = (int)l1;
    paramArrayOfInt2[paramInt1 - 1] = (int)l2;
  }
  
  private static void updateFG30(int paramInt, int[] paramArrayOfInt1, int[] paramArrayOfInt2, int[] paramArrayOfInt3) {
    int i = paramArrayOfInt3[0], j = paramArrayOfInt3[1], k = paramArrayOfInt3[2], m = paramArrayOfInt3[3];
    int n = paramArrayOfInt1[0];
    int i1 = paramArrayOfInt2[0];
    long l1 = i * n + j * i1;
    long l2 = k * n + m * i1;
    l1 >>= 30;
    l2 >>= 30;
    for (byte b = 1; b < paramInt; b++) {
      n = paramArrayOfInt1[b];
      i1 = paramArrayOfInt2[b];
      l1 += i * n + j * i1;
      l2 += k * n + m * i1;
      paramArrayOfInt1[b - true] = (int)l1 & 0x3FFFFFFF;
      l1 >>= 30;
      paramArrayOfInt2[b - true] = (int)l2 & 0x3FFFFFFF;
      l2 >>= 30;
    } 
    paramArrayOfInt1[paramInt - 1] = (int)l1;
    paramArrayOfInt2[paramInt - 1] = (int)l2;
  }
}
