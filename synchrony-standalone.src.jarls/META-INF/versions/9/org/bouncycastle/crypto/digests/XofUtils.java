package META-INF.versions.9.org.bouncycastle.crypto.digests;

import org.bouncycastle.crypto.digests.XofUtils;
import org.bouncycastle.util.Arrays;

public class XofUtils {
  public static byte[] leftEncode(long paramLong) {
    byte b1 = 1;
    long l = paramLong;
    while (l >>= 8 != 0L)
      b1 = (byte)(b1 + true); 
    byte[] arrayOfByte = new byte[b1 + 1];
    arrayOfByte[0] = b1;
    for (byte b2 = 1; b2 <= b1; b2++)
      arrayOfByte[b2] = (byte)(int)(paramLong >> 8 * (b1 - b2)); 
    return arrayOfByte;
  }
  
  public static byte[] rightEncode(long paramLong) {
    byte b1 = 1;
    long l = paramLong;
    while (l >>= 8 != 0L)
      b1 = (byte)(b1 + true); 
    byte[] arrayOfByte = new byte[b1 + 1];
    arrayOfByte[b1] = b1;
    for (byte b2 = 0; b2 < b1; b2++)
      arrayOfByte[b2] = (byte)(int)(paramLong >> 8 * (b1 - b2 - 1)); 
    return arrayOfByte;
  }
  
  static byte[] encode(byte paramByte) { return Arrays.concatenate(leftEncode(8L), new byte[] { paramByte }); }
  
  static byte[] encode(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    if (paramArrayOfByte.length == paramInt2)
      return Arrays.concatenate(leftEncode((paramInt2 * 8)), paramArrayOfByte); 
    return Arrays.concatenate(leftEncode((paramInt2 * 8)), Arrays.copyOfRange(paramArrayOfByte, paramInt1, paramInt1 + paramInt2));
  }
}
