package META-INF.versions.9.org.bouncycastle.pqc.crypto.xmss;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import org.bouncycastle.crypto.Digest;
import org.bouncycastle.pqc.crypto.xmss.XMSSUtil;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.encoders.Hex;

public class XMSSUtil {
  public static int log2(int paramInt) {
    byte b = 0;
    while (paramInt >>= 1 != 0)
      b++; 
    return b;
  }
  
  public static byte[] toBytesBigEndian(long paramLong, int paramInt) {
    byte[] arrayOfByte = new byte[paramInt];
    for (int i = paramInt - 1; i >= 0; i--) {
      arrayOfByte[i] = (byte)(int)paramLong;
      paramLong >>>= 8;
    } 
    return arrayOfByte;
  }
  
  public static void longToBigEndian(long paramLong, byte[] paramArrayOfByte, int paramInt) {
    if (paramArrayOfByte == null)
      throw new NullPointerException("in == null"); 
    if (paramArrayOfByte.length - paramInt < 8)
      throw new IllegalArgumentException("not enough space in array"); 
    paramArrayOfByte[paramInt] = (byte)(int)(paramLong >> 56 & 0xFFL);
    paramArrayOfByte[paramInt + 1] = (byte)(int)(paramLong >> 48 & 0xFFL);
    paramArrayOfByte[paramInt + 2] = (byte)(int)(paramLong >> 40 & 0xFFL);
    paramArrayOfByte[paramInt + 3] = (byte)(int)(paramLong >> 32 & 0xFFL);
    paramArrayOfByte[paramInt + 4] = (byte)(int)(paramLong >> 24 & 0xFFL);
    paramArrayOfByte[paramInt + 5] = (byte)(int)(paramLong >> 16 & 0xFFL);
    paramArrayOfByte[paramInt + 6] = (byte)(int)(paramLong >> 8 & 0xFFL);
    paramArrayOfByte[paramInt + 7] = (byte)(int)(paramLong & 0xFFL);
  }
  
  public static long bytesToXBigEndian(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    if (paramArrayOfByte == null)
      throw new NullPointerException("in == null"); 
    long l = 0L;
    for (int i = paramInt1; i < paramInt1 + paramInt2; i++)
      l = l << 8 | (paramArrayOfByte[i] & 0xFF); 
    return l;
  }
  
  public static byte[] cloneArray(byte[] paramArrayOfByte) {
    if (paramArrayOfByte == null)
      throw new NullPointerException("in == null"); 
    byte[] arrayOfByte = new byte[paramArrayOfByte.length];
    System.arraycopy(paramArrayOfByte, 0, arrayOfByte, 0, paramArrayOfByte.length);
    return arrayOfByte;
  }
  
  public static byte[][] cloneArray(byte[][] paramArrayOfByte) {
    if (hasNullPointer(paramArrayOfByte))
      throw new NullPointerException("in has null pointers"); 
    byte[][] arrayOfByte = new byte[paramArrayOfByte.length][];
    for (byte b = 0; b < paramArrayOfByte.length; b++) {
      arrayOfByte[b] = new byte[paramArrayOfByte[b].length];
      System.arraycopy(paramArrayOfByte[b], 0, arrayOfByte[b], 0, paramArrayOfByte[b].length);
    } 
    return arrayOfByte;
  }
  
  public static boolean areEqual(byte[][] paramArrayOfByte1, byte[][] paramArrayOfByte2) {
    if (hasNullPointer(paramArrayOfByte1) || hasNullPointer(paramArrayOfByte2))
      throw new NullPointerException("a or b == null"); 
    for (byte b = 0; b < paramArrayOfByte1.length; b++) {
      if (!Arrays.areEqual(paramArrayOfByte1[b], paramArrayOfByte2[b]))
        return false; 
    } 
    return true;
  }
  
  public static void dumpByteArray(byte[][] paramArrayOfByte) {
    if (hasNullPointer(paramArrayOfByte))
      throw new NullPointerException("x has null pointers"); 
    for (byte b = 0; b < paramArrayOfByte.length; b++)
      System.out.println(Hex.toHexString(paramArrayOfByte[b])); 
  }
  
  public static boolean hasNullPointer(byte[][] paramArrayOfByte) {
    if (paramArrayOfByte == null)
      return true; 
    for (byte b = 0; b < paramArrayOfByte.length; b++) {
      if (paramArrayOfByte[b] == null)
        return true; 
    } 
    return false;
  }
  
  public static void copyBytesAtOffset(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, int paramInt) {
    if (paramArrayOfByte1 == null)
      throw new NullPointerException("dst == null"); 
    if (paramArrayOfByte2 == null)
      throw new NullPointerException("src == null"); 
    if (paramInt < 0)
      throw new IllegalArgumentException("offset hast to be >= 0"); 
    if (paramArrayOfByte2.length + paramInt > paramArrayOfByte1.length)
      throw new IllegalArgumentException("src length + offset must not be greater than size of destination"); 
    for (int i = 0; i < paramArrayOfByte2.length; i++)
      paramArrayOfByte1[paramInt + i] = paramArrayOfByte2[i]; 
  }
  
  public static byte[] extractBytesAtOffset(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    if (paramArrayOfByte == null)
      throw new NullPointerException("src == null"); 
    if (paramInt1 < 0)
      throw new IllegalArgumentException("offset hast to be >= 0"); 
    if (paramInt2 < 0)
      throw new IllegalArgumentException("length hast to be >= 0"); 
    if (paramInt1 + paramInt2 > paramArrayOfByte.length)
      throw new IllegalArgumentException("offset + length must not be greater then size of source array"); 
    byte[] arrayOfByte = new byte[paramInt2];
    for (int i = 0; i < arrayOfByte.length; i++)
      arrayOfByte[i] = paramArrayOfByte[paramInt1 + i]; 
    return arrayOfByte;
  }
  
  public static boolean isIndexValid(int paramInt, long paramLong) {
    if (paramLong < 0L)
      throw new IllegalStateException("index must not be negative"); 
    return (paramLong < 1L << paramInt);
  }
  
  public static int getDigestSize(Digest paramDigest) {
    if (paramDigest == null)
      throw new NullPointerException("digest == null"); 
    String str = paramDigest.getAlgorithmName();
    if (str.equals("SHAKE128"))
      return 32; 
    if (str.equals("SHAKE256"))
      return 64; 
    return paramDigest.getDigestSize();
  }
  
  public static long getTreeIndex(long paramLong, int paramInt) { return paramLong >> paramInt; }
  
  public static int getLeafIndex(long paramLong, int paramInt) { return (int)(paramLong & (1L << paramInt) - 1L); }
  
  public static byte[] serialize(Object paramObject) throws IOException {
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
    ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
    objectOutputStream.writeObject(paramObject);
    objectOutputStream.flush();
    return byteArrayOutputStream.toByteArray();
  }
  
  public static Object deserialize(byte[] paramArrayOfByte, Class paramClass) throws IOException, ClassNotFoundException {
    ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(paramArrayOfByte);
    CheckingStream checkingStream = new CheckingStream(paramClass, byteArrayInputStream);
    Object object = checkingStream.readObject();
    if (checkingStream.available() != 0)
      throw new IOException("unexpected data found at end of ObjectInputStream"); 
    if (paramClass.isInstance(object))
      return object; 
    throw new IOException("unexpected class found in ObjectInputStream");
  }
  
  public static int calculateTau(int paramInt1, int paramInt2) {
    int i = 0;
    for (int j = 0; j < paramInt2; j++) {
      if ((paramInt1 >> j & true) == 0) {
        i = j;
        break;
      } 
    } 
    return i;
  }
  
  public static boolean isNewBDSInitNeeded(long paramLong, int paramInt1, int paramInt2) {
    if (paramLong == 0L)
      return false; 
    return (paramLong % (long)Math.pow((1 << paramInt1), (paramInt2 + 1)) == 0L);
  }
  
  public static boolean isNewAuthenticationPathNeeded(long paramLong, int paramInt1, int paramInt2) {
    if (paramLong == 0L)
      return false; 
    return ((paramLong + 1L) % (long)Math.pow((1 << paramInt1), paramInt2) == 0L);
  }
}
