package manifold.stream.deferred;

import clojure.lang.AFn;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IReference;
import clojure.lang.ISeq;
import clojure.lang.IType;
import clojure.lang.Keyword;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.concurrent.locks.Lock;
import manifold.stream.core.IEventSource;
import manifold.stream.core.IEventStream;

public final class DeferredSource implements IEventSource, IReference, IEventStream, IType {
  public final Object d;
  
  public final Object lock;
  
  public final Object __drainedCallbacks;
  
  public static final Keyword const__0 = (Keyword)RT.keyword("manifold.stream.deferred", "none");
  
  public static final Var const__2 = (Var)RT.var("manifold.deferred", "success-deferred");
  
  public static final Var const__3 = (Var)RT.var("manifold.deferred", "deferred");
  
  public static final Var const__4 = (Var)RT.var("manifold.deferred", "connect");
  
  public static final Var const__5 = (Var)RT.var("manifold.deferred", "timeout!");
  
  public static final AFn const__7 = (AFn)RT.map(new Object[] { RT.keyword(null, "type"), "deferred" });
  
  public static final Var const__8 = (Var)RT.var("clojure.core", "apply"), const__9 = (Var)RT.var("manifold.stream.graph", "downstream"), const__10 = (Var)RT.var("clojure.core", "deref"), const__11 = (Var)RT.var("manifold.utils", "invoke-callbacks");
  
  public DeferredSource(Object paramObject1, Object paramObject2, Object paramObject3, Object paramObject4, Object paramObject5, Object paramObject6) { this.d = paramObject1;
    this.lock = paramObject2;
    this.__mta = paramObject3;
    this.__isDrained = paramObject4;
    this.__drainedCallbacks = paramObject5;
    this.__weakHandle = paramObject6; }
  
  public static IPersistentVector getBasis() { return Tuple.create(((IObj)Symbol.intern(null, "d")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "AtomicReference") })), Symbol.intern(null, "lock"), ((IObj)Symbol.intern(null, "__mta")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "volatile-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "__isDrained")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "volatile-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "__drainedCallbacks")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.LinkedList") })), ((IObj)Symbol.intern(null, "__weakHandle")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "volatile-mutable"), Boolean.TRUE }))); }
  
  public Object markDrained() {
    Object object;
    lock__14923__auto__16200 = this.lock;
    ((Lock)lock__14923__auto__16200).lock();
    null;
    try {
      this.__isDrained = Boolean.TRUE;
      object = ((IFn)const__11.getRawRoot()).invoke(this.__drainedCallbacks);
    } finally {
      lock__14923__auto__16200 = null;
      ((Lock)lock__14923__auto__16200).unlock();
      null;
    } 
    return object;
  }
  
  public Object isDrained() { return this.__isDrained; }
  
  public Object take(Object default_val, Object blocking_QMARK_) { // Byte code:
    //   0: aload_0
    //   1: getfield d : Ljava/lang/Object;
    //   4: checkcast java/util/concurrent/atomic/AtomicReference
    //   7: getstatic manifold/stream/deferred/DeferredSource.const__0 : Lclojure/lang/Keyword;
    //   10: invokevirtual getAndSet : (Ljava/lang/Object;)Ljava/lang/Object;
    //   13: astore_3
    //   14: getstatic manifold/stream/deferred/DeferredSource.const__0 : Lclojure/lang/Keyword;
    //   17: aload_3
    //   18: invokestatic identical : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   21: ifeq -> 67
    //   24: aload_2
    //   25: aconst_null
    //   26: astore_2
    //   27: dup
    //   28: ifnull -> 43
    //   31: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   34: if_acmpeq -> 44
    //   37: aload_1
    //   38: aconst_null
    //   39: astore_1
    //   40: goto -> 63
    //   43: pop
    //   44: getstatic manifold/stream/deferred/DeferredSource.const__2 : Lclojure/lang/Var;
    //   47: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   50: checkcast clojure/lang/IFn
    //   53: aload_1
    //   54: aconst_null
    //   55: astore_1
    //   56: aconst_null
    //   57: astore_0
    //   58: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   63: goto -> 116
    //   66: athrow
    //   67: aload_0
    //   68: checkcast manifold/stream/core/IEventSource
    //   71: invokeinterface markDrained : ()Ljava/lang/Object;
    //   76: pop
    //   77: aload_2
    //   78: aconst_null
    //   79: astore_2
    //   80: dup
    //   81: ifnull -> 112
    //   84: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   87: if_acmpeq -> 113
    //   90: getstatic manifold/stream/deferred/DeferredSource.const__10 : Lclojure/lang/Var;
    //   93: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   96: checkcast clojure/lang/IFn
    //   99: aload_3
    //   100: aconst_null
    //   101: astore_3
    //   102: aconst_null
    //   103: astore_0
    //   104: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   109: goto -> 116
    //   112: pop
    //   113: aload_3
    //   114: aconst_null
    //   115: astore_3
    //   116: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #42	-> 0
    //   #52	-> 10
    //   #53	-> 14
    //   #53	-> 18
    //   #54	-> 24
    //   #56	-> 50
    //   #56	-> 56
    //   #58	-> 71
    //   #59	-> 77
    //   #59	-> 96
    //   #59	-> 102
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   14	102	3	d	Ljava/lang/Object;
    //   0	116	0	this	Lmanifold/stream/deferred/DeferredSource;
    //   0	116	1	default_val	Ljava/lang/Object;
    //   0	116	2	blocking_QMARK_	Ljava/lang/Object; }
  
  public Object onDrained(Object callback__15726__auto__) { // Byte code:
    //   0: aload_0
    //   1: getfield lock : Ljava/lang/Object;
    //   4: astore_2
    //   5: aload_2
    //   6: checkcast java/util/concurrent/locks/Lock
    //   9: invokeinterface lock : ()V
    //   14: aconst_null
    //   15: pop
    //   16: aload_0
    //   17: getfield __isDrained : Ljava/lang/Object;
    //   20: dup
    //   21: ifnull -> 44
    //   24: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   27: if_acmpeq -> 45
    //   30: aload_1
    //   31: aconst_null
    //   32: astore_1
    //   33: checkcast clojure/lang/IFn
    //   36: invokeinterface invoke : ()Ljava/lang/Object;
    //   41: goto -> 70
    //   44: pop
    //   45: aload_0
    //   46: getfield __drainedCallbacks : Ljava/lang/Object;
    //   49: checkcast java/util/LinkedList
    //   52: aload_1
    //   53: aconst_null
    //   54: astore_1
    //   55: invokevirtual add : (Ljava/lang/Object;)Z
    //   58: ifeq -> 67
    //   61: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   64: goto -> 70
    //   67: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   70: astore_3
    //   71: aload_2
    //   72: aconst_null
    //   73: astore_2
    //   74: checkcast java/util/concurrent/locks/Lock
    //   77: invokeinterface unlock : ()V
    //   82: aconst_null
    //   83: pop
    //   84: goto -> 105
    //   87: astore #4
    //   89: aload_2
    //   90: aconst_null
    //   91: astore_2
    //   92: checkcast java/util/concurrent/locks/Lock
    //   95: invokeinterface unlock : ()V
    //   100: aconst_null
    //   101: pop
    //   102: aload #4
    //   104: athrow
    //   105: aload_3
    //   106: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #42	-> 0
    //   #42	-> 9
    //   #42	-> 16
    //   #42	-> 33
    //   #42	-> 36
    //   #42	-> 55
    //   #42	-> 77
    //   #42	-> 95
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   5	101	2	lock__14923__auto__16201	Ljava/lang/Object;
    //   0	106	0	this	Lmanifold/stream/deferred/DeferredSource;
    //   0	106	1	callback__15726__auto__	Ljava/lang/Object;
    // Exception table:
    //   from	to	target	type
    //   16	71	87	finally }
  
  public Object downstream() { this = null;
    return ((IFn)const__9.getRawRoot()).invoke(this); }
  
  public IPersistentMap alterMeta(IFn f__15719__auto__, ISeq args__15720__auto__) {
    Object lock__14925__auto__16203 = this.lock;
    ((Lock)lock__14925__auto__16203).lock();
    null;
    f__15719__auto__ = null;
    args__15720__auto__ = null;
    Object x__14926__auto__16202 = this.__mta = ((IFn)const__8.getRawRoot()).invoke(f__15719__auto__, this.__mta, args__15720__auto__);
    lock__14925__auto__16203 = null;
    ((Lock)lock__14925__auto__16203).unlock();
    null;
    x__14926__auto__16202 = null;
    return (IPersistentMap)x__14926__auto__16202;
  }
  
  public Object description() { return const__7; }
  
  public Object isSynchronous() { return Boolean.FALSE; }
  
  public Object close() { return null; }
  
  public IPersistentMap resetMeta(IPersistentMap m__15718__auto__) {
    Object lock__14925__auto__16205 = this.lock;
    ((Lock)lock__14925__auto__16205).lock();
    null;
    Object x__14926__auto__16204 = this.__mta = m__15718__auto__ = null;
    lock__14925__auto__16205 = null;
    ((Lock)lock__14925__auto__16205).unlock();
    null;
    x__14926__auto__16204 = null;
    return (IPersistentMap)x__14926__auto__16204;
  }
  
  public Object connector(Object ___15727__auto__) { return null; }
  
  public IPersistentMap meta() { return (IPersistentMap)this.__mta; }
  
  public Object take(Object default_val, Object blocking_QMARK_, Object timeout, Object timeout_val) { // Byte code:
    //   0: aload_0
    //   1: checkcast manifold/stream/core/IEventSource
    //   4: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   7: getstatic manifold/stream/deferred/DeferredSource.const__0 : Lclojure/lang/Keyword;
    //   10: invokeinterface take : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   15: astore #5
    //   17: aload #5
    //   19: getstatic manifold/stream/deferred/DeferredSource.const__0 : Lclojure/lang/Keyword;
    //   22: invokestatic identical : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   25: ifeq -> 71
    //   28: aload_2
    //   29: aconst_null
    //   30: astore_2
    //   31: dup
    //   32: ifnull -> 47
    //   35: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   38: if_acmpeq -> 48
    //   41: aload_1
    //   42: aconst_null
    //   43: astore_1
    //   44: goto -> 67
    //   47: pop
    //   48: getstatic manifold/stream/deferred/DeferredSource.const__2 : Lclojure/lang/Var;
    //   51: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   54: checkcast clojure/lang/IFn
    //   57: aload_1
    //   58: aconst_null
    //   59: astore_1
    //   60: aconst_null
    //   61: astore_0
    //   62: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   67: goto -> 148
    //   70: athrow
    //   71: aload_0
    //   72: checkcast manifold/stream/core/IEventSource
    //   75: invokeinterface markDrained : ()Ljava/lang/Object;
    //   80: pop
    //   81: getstatic manifold/stream/deferred/DeferredSource.const__3 : Lclojure/lang/Var;
    //   84: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   87: checkcast clojure/lang/IFn
    //   90: invokeinterface invoke : ()Ljava/lang/Object;
    //   95: astore #6
    //   97: getstatic manifold/stream/deferred/DeferredSource.const__4 : Lclojure/lang/Var;
    //   100: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   103: checkcast clojure/lang/IFn
    //   106: aload #5
    //   108: aconst_null
    //   109: astore #5
    //   111: aload #6
    //   113: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   118: pop
    //   119: getstatic manifold/stream/deferred/DeferredSource.const__5 : Lclojure/lang/Var;
    //   122: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   125: checkcast clojure/lang/IFn
    //   128: aload #6
    //   130: aconst_null
    //   131: astore #6
    //   133: aload_3
    //   134: aconst_null
    //   135: astore_3
    //   136: aload #4
    //   138: aconst_null
    //   139: astore #4
    //   141: aconst_null
    //   142: astore_0
    //   143: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   148: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #42	-> 0
    //   #64	-> 10
    //   #65	-> 17
    //   #65	-> 22
    //   #66	-> 28
    //   #68	-> 54
    //   #68	-> 60
    //   #70	-> 75
    //   #71	-> 87
    //   #71	-> 90
    //   #72	-> 103
    //   #72	-> 113
    //   #73	-> 125
    //   #73	-> 141
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   97	51	6	d_SINGLEQUOTE_	Ljava/lang/Object;
    //   17	131	5	d	Ljava/lang/Object;
    //   0	148	0	this	Lmanifold/stream/deferred/DeferredSource;
    //   0	148	1	default_val	Ljava/lang/Object;
    //   0	148	2	blocking_QMARK_	Ljava/lang/Object;
    //   0	148	3	timeout	Ljava/lang/Object;
    //   0	148	4	timeout_val	Ljava/lang/Object; }
  
  public Object weakHandle(Object ref_queue__15722__auto__) { // Byte code:
    //   0: aload_0
    //   1: getfield lock : Ljava/lang/Object;
    //   4: astore_2
    //   5: aload_2
    //   6: checkcast java/util/concurrent/locks/Lock
    //   9: invokeinterface lock : ()V
    //   14: aconst_null
    //   15: pop
    //   16: aload_0
    //   17: getfield __weakHandle : Ljava/lang/Object;
    //   20: astore_3
    //   21: aload_3
    //   22: dup
    //   23: ifnull -> 38
    //   26: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   29: if_acmpeq -> 39
    //   32: aload_3
    //   33: aconst_null
    //   34: astore_3
    //   35: goto -> 61
    //   38: pop
    //   39: aload_0
    //   40: new java/lang/ref/WeakReference
    //   43: dup
    //   44: aload_0
    //   45: aload_1
    //   46: aconst_null
    //   47: astore_1
    //   48: checkcast java/lang/ref/ReferenceQueue
    //   51: invokespecial <init> : (Ljava/lang/Object;Ljava/lang/ref/ReferenceQueue;)V
    //   54: putfield __weakHandle : Ljava/lang/Object;
    //   57: aload_0
    //   58: getfield __weakHandle : Ljava/lang/Object;
    //   61: astore #4
    //   63: aload_2
    //   64: aconst_null
    //   65: astore_2
    //   66: checkcast java/util/concurrent/locks/Lock
    //   69: invokeinterface unlock : ()V
    //   74: aconst_null
    //   75: pop
    //   76: goto -> 97
    //   79: astore #5
    //   81: aload_2
    //   82: aconst_null
    //   83: astore_2
    //   84: checkcast java/util/concurrent/locks/Lock
    //   87: invokeinterface unlock : ()V
    //   92: aconst_null
    //   93: pop
    //   94: aload #5
    //   96: athrow
    //   97: aload #4
    //   99: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #42	-> 0
    //   #42	-> 9
    //   #42	-> 21
    //   #42	-> 69
    //   #42	-> 87
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   21	40	3	or__5516__auto__16206	Ljava/lang/Object;
    //   5	94	2	lock__14923__auto__16207	Ljava/lang/Object;
    //   0	99	0	this	Lmanifold/stream/deferred/DeferredSource;
    //   0	99	1	ref_queue__15722__auto__	Ljava/lang/Object;
    // Exception table:
    //   from	to	target	type
    //   16	63	79	finally }
}
