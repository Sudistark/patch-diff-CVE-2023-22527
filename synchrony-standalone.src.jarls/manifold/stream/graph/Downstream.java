package manifold.stream.graph;

import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;

public final class Downstream implements IType {
  public final long timeout;
  
  public final boolean upstream_QMARK_;
  
  public final boolean downstream_QMARK_;
  
  public final Object sink;
  
  public final Object description;
  
  public Downstream(long paramLong, boolean paramBoolean1, boolean paramBoolean2, Object paramObject1, Object paramObject2) { this.timeout = paramLong;
    this.upstream_QMARK_ = paramBoolean1;
    this.downstream_QMARK_ = paramBoolean2;
    this.sink = paramObject1;
    this.description = paramObject2; }
  
  public static IPersistentVector getBasis() { return Tuple.create(((IObj)Symbol.intern(null, "timeout")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "upstream?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "boolean") })), ((IObj)Symbol.intern(null, "downstream?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "boolean") })), ((IObj)Symbol.intern(null, "sink")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IEventSink") })), ((IObj)Symbol.intern(null, "description")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))); }
  
  static  {
  
  }
}
