package manifold.stream;

import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import manifold.stream.core.IEventSink;
import manifold.stream.core.IEventStream;

public final class SinkProxy implements IEventStream, IEventSink, IType {
  public final Object sink;
  
  public SinkProxy(Object paramObject) { this.sink = paramObject; }
  
  public static IPersistentVector getBasis() { return Tuple.create(((IObj)Symbol.intern(null, "sink")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IEventSink") }))); }
  
  public Object onClosed(Object callback) { callback = null;
    return ((IEventSink)this.sink).onClosed(callback); }
  
  public Object isClosed() { return ((IEventSink)this.sink).isClosed(); }
  
  public Object put(Object x, Object blocking_QMARK_, Object timeout, Object timeout_val) { x = null;
    blocking_QMARK_ = null;
    timeout = null;
    timeout_val = null;
    return ((IEventSink)this.sink).put(x, blocking_QMARK_, timeout, timeout_val); }
  
  public Object put(Object x, Object blocking_QMARK_) { x = null;
    blocking_QMARK_ = null;
    return ((IEventSink)this.sink).put(x, blocking_QMARK_); }
  
  public Object weakHandle(Object ref_queue) { ref_queue = null;
    return ((IEventStream)this.sink).weakHandle(ref_queue); }
  
  public Object close() { return ((IEventStream)this.sink).close(); }
  
  public Object downstream() { return ((IEventStream)this.sink).downstream(); }
  
  public Object isSynchronous() { return ((IEventStream)this.sink).isSynchronous(); }
  
  public Object description() { return ((IEventStream)this.sink).description(); }
  
  static  {
  
  }
}
