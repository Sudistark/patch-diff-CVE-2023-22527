package manifold.stream;

import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IReference;
import clojure.lang.ISeq;
import clojure.lang.IType;
import clojure.lang.Keyword;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.concurrent.locks.Lock;
import manifold.stream.core.IEventSink;
import manifold.stream.core.IEventSource;
import manifold.stream.core.IEventStream;

public final class SplicedStream implements IEventStream, IReference, IEventSink, IEventSource, IType {
  public final Object sink;
  
  public final Object source;
  
  public final Object lock;
  
  public static final Var const__0 = (Var)RT.var("clojure.core", "apply");
  
  public static final Keyword const__2 = (Keyword)RT.keyword(null, "type"), const__3 = (Keyword)RT.keyword(null, "sink"), const__4 = (Keyword)RT.keyword(null, "source");
  
  public SplicedStream(Object paramObject1, Object paramObject2, Object paramObject3, Object paramObject4) { this.sink = paramObject1;
    this.source = paramObject2;
    this.mta = paramObject3;
    this.lock = paramObject4; }
  
  public static IPersistentVector getBasis() { return Tuple.create(((IObj)Symbol.intern(null, "sink")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IEventSink") })), ((IObj)Symbol.intern(null, "source")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IEventSource") })), ((IObj)Symbol.intern(null, "mta")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "volatile-mutable"), Boolean.TRUE })), Symbol.intern(null, "lock")); }
  
  public Object connector(Object sink) { sink = null;
    return ((IEventSource)this.source).connector(sink); }
  
  public Object onDrained(Object callback) { callback = null;
    return ((IEventSource)this.source).onDrained(callback); }
  
  public Object isDrained() { return ((IEventSource)this.source).isDrained(); }
  
  public Object take(Object default_val, Object blocking_QMARK_, Object timeout, Object timeout_val) { default_val = null;
    blocking_QMARK_ = null;
    timeout = null;
    timeout_val = null;
    return ((IEventSource)this.source).take(default_val, blocking_QMARK_, timeout, timeout_val); }
  
  public Object take(Object default_val, Object blocking_QMARK_) { default_val = null;
    blocking_QMARK_ = null;
    return ((IEventSource)this.source).take(default_val, blocking_QMARK_); }
  
  public Object onClosed(Object callback) { callback = null;
    return ((IEventSink)this.sink).onClosed(callback); }
  
  public Object isClosed() { return ((IEventSink)this.sink).isClosed(); }
  
  public Object put(Object x, Object blocking_QMARK_, Object timeout, Object timeout_val) { x = null;
    blocking_QMARK_ = null;
    timeout = null;
    timeout_val = null;
    return ((IEventSink)this.sink).put(x, blocking_QMARK_, timeout, timeout_val); }
  
  public Object put(Object x, Object blocking_QMARK_) { x = null;
    blocking_QMARK_ = null;
    return ((IEventSink)this.sink).put(x, blocking_QMARK_); }
  
  public Object weakHandle(Object ref_queue) { ref_queue = null;
    return ((IEventStream)this.source).weakHandle(ref_queue); }
  
  public Object close() {
    ((IEventStream)this.source).close();
    return ((IEventStream)this.sink).close();
  }
  
  public Object downstream() { return ((IEventStream)this.source).downstream(); }
  
  public Object description() { return RT.mapUniqueKeys(new Object[] { const__2, "splice", const__3, ((IEventStream)this.sink).description(), const__4, ((IEventStream)this.source).description() }); }
  
  public Object isSynchronous() {
    Object or__5516__auto__16798 = ((IEventStream)this.sink).isSynchronous();
    if (or__5516__auto__16798 != null) {
      if (or__5516__auto__16798 != Boolean.FALSE)
        or__5516__auto__16798 = null; 
    } else {
      or__5516__auto__16798;
    } 
    return ((IEventStream)this.source).isSynchronous();
  }
  
  public IPersistentMap alterMeta(IFn f, ISeq args) {
    Object lock__14925__auto__16800 = this.lock;
    ((Lock)lock__14925__auto__16800).lock();
    null;
    f = null;
    args = null;
    Object x__14926__auto__16799 = this.mta = ((IFn)const__0.getRawRoot()).invoke(f, this.mta, args);
    lock__14925__auto__16800 = null;
    ((Lock)lock__14925__auto__16800).unlock();
    null;
    x__14926__auto__16799 = null;
    return (IPersistentMap)x__14926__auto__16799;
  }
  
  public IPersistentMap resetMeta(IPersistentMap m) {
    Object lock__14925__auto__16802 = this.lock;
    ((Lock)lock__14925__auto__16802).lock();
    null;
    Object x__14926__auto__16801 = this.mta = m = null;
    lock__14925__auto__16802 = null;
    ((Lock)lock__14925__auto__16802).unlock();
    null;
    x__14926__auto__16801 = null;
    return (IPersistentMap)x__14926__auto__16801;
  }
  
  public IPersistentMap meta() { return (IPersistentMap)this.mta; }
}
