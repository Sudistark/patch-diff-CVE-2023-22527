package manifold.stream.default;

import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IReference;
import clojure.lang.ISeq;
import clojure.lang.IType;
import clojure.lang.Keyword;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Var;
import java.util.LinkedList;
import java.util.concurrent.locks.Lock;
import manifold.stream.core.IEventSink;
import manifold.stream.core.IEventSource;
import manifold.stream.core.IEventStream;

public final class Stream implements IEventSource, IReference, IEventSink, IEventStream, IType {
  public final boolean permanent_QMARK_;
  
  public final Object description;
  
  public final Object producers;
  
  public final Object consumers;
  
  public final long capacity;
  
  public final Object messages;
  
  public final Object executor;
  
  public final Object add_BANG_;
  
  public final Object dirty_takes;
  
  public final Object lock;
  
  public final Object __drainedCallbacks;
  
  public final Object __closedCallbacks;
  
  private static Class __cached_class__0;
  
  private static Class __cached_class__1;
  
  public static final Var const__2 = (Var)RT.var("clojure.tools.logging.impl", "get-logger");
  
  public static final Var const__3 = (Var)RT.var("clojure.tools.logging", "*logger-factory*");
  
  public static final Object const__4 = RT.readString("#=(find-ns ^#=(clojure.lang.PersistentArrayMap/create {:no-doc true}) manifold.stream.default)");
  
  public static final Var const__5 = (Var)RT.var("clojure.tools.logging.impl", "enabled?");
  
  public static final Keyword const__6 = (Keyword)RT.keyword(null, "warn");
  
  public static final Var const__8 = (Var)RT.var("clojure.tools.logging", "log*");
  
  public static final Var const__9 = (Var)RT.var("clojure.core", "print-str");
  
  public static final Var const__10 = (Var)RT.var("clojure.core", "format");
  
  public static final Var const__11 = (Var)RT.var("manifold.stream.default", "max-consumers");
  
  public static final Var const__13 = (Var)RT.var("manifold.deferred", "success-deferred");
  
  public static final Var const__15 = (Var)RT.var("manifold.stream.default", "re-nil");
  
  public static final Keyword const__16 = (Keyword)RT.keyword(null, "else");
  
  public static final Var const__17 = (Var)RT.var("clojure.core", "deref");
  
  public static final Keyword const__20 = (Keyword)RT.keyword(null, "pending-puts");
  
  public static final Keyword const__21 = (Keyword)RT.keyword(null, "drained?");
  
  public static final Keyword const__22 = (Keyword)RT.keyword(null, "buffer-size");
  
  public static final Object const__23 = Long.valueOf(0L);
  
  public static final Keyword const__24 = (Keyword)RT.keyword(null, "permanent?");
  
  public static final Keyword const__25 = (Keyword)RT.keyword(null, "type");
  
  public static final Keyword const__26 = (Keyword)RT.keyword(null, "sink?");
  
  public static final Keyword const__27 = (Keyword)RT.keyword(null, "closed?");
  
  public static final Keyword const__28 = (Keyword)RT.keyword(null, "pending-takes");
  
  public static final Keyword const__29 = (Keyword)RT.keyword(null, "buffer-capacity");
  
  public static final Keyword const__30 = (Keyword)RT.keyword(null, "source?");
  
  public static final Var const__31 = (Var)RT.var("clojure.core", "apply"), const__32 = (Var)RT.var("manifold.stream.graph", "downstream"), const__34 = (Var)RT.var("clojure.core", "false?"), const__38 = (Var)RT.var("manifold.utils", "invoke-callbacks");
  
  public Stream(boolean paramBoolean, Object paramObject1, Object paramObject2, Object paramObject3, long paramLong, Object paramObject4, Object paramObject5, Object paramObject6, Object paramObject7, Object paramObject8, Object paramObject9, Object paramObject10, Object paramObject11, Object paramObject12, Object paramObject13, Object paramObject14) { this.permanent_QMARK_ = paramBoolean;
    this.description = paramObject1;
    this.producers = paramObject2;
    this.consumers = paramObject3;
    this.capacity = paramLong;
    this.messages = paramObject4;
    this.executor = paramObject5;
    this.add_BANG_ = paramObject6;
    this.dirty_takes = paramObject7;
    this.lock = paramObject8;
    this.__mta = paramObject9;
    this.__isDrained = paramObject10;
    this.__drainedCallbacks = paramObject11;
    this.__weakHandle = paramObject12;
    this.__isClosed = paramObject13;
    this.__closedCallbacks = paramObject14; }
  
  public static IPersistentVector getBasis() { return RT.vector(new Object[] { 
          ((IObj)Symbol.intern(null, "permanent?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "boolean") })), Symbol.intern(null, "description"), ((IObj)Symbol.intern(null, "producers")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "LinkedList") })), ((IObj)Symbol.intern(null, "consumers")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "LinkedList") })), ((IObj)Symbol.intern(null, "capacity")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "messages")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Queue") })), Symbol.intern(null, "executor"), Symbol.intern(null, "add!"), ((IObj)Symbol.intern(null, "dirty-takes")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "AtomicLong") })), Symbol.intern(null, "lock"), 
          ((IObj)Symbol.intern(null, "__mta")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "volatile-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "__isDrained")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "volatile-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "__drainedCallbacks")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.LinkedList") })), ((IObj)Symbol.intern(null, "__weakHandle")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "volatile-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "__isClosed")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "volatile-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "__closedCallbacks")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.LinkedList") })) }); }
  
  public Object markDrained() {
    Object object;
    lock__14923__auto__15970 = this.lock;
    ((Lock)lock__14923__auto__15970).lock();
    null;
    try {
      this.__isDrained = Boolean.TRUE;
      object = ((IFn)const__38.getRawRoot()).invoke(this.__drainedCallbacks);
    } finally {
      lock__14923__auto__15970 = null;
      ((Lock)lock__14923__auto__15970).unlock();
      null;
    } 
    return object;
  }
  
  public Object onClosed(Object callback__15724__auto__) { // Byte code:
    //   0: aload_0
    //   1: getfield lock : Ljava/lang/Object;
    //   4: astore_2
    //   5: aload_2
    //   6: checkcast java/util/concurrent/locks/Lock
    //   9: invokeinterface lock : ()V
    //   14: aconst_null
    //   15: pop
    //   16: aload_0
    //   17: getfield __isClosed : Ljava/lang/Object;
    //   20: dup
    //   21: ifnull -> 44
    //   24: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   27: if_acmpeq -> 45
    //   30: aload_1
    //   31: aconst_null
    //   32: astore_1
    //   33: checkcast clojure/lang/IFn
    //   36: invokeinterface invoke : ()Ljava/lang/Object;
    //   41: goto -> 70
    //   44: pop
    //   45: aload_0
    //   46: getfield __closedCallbacks : Ljava/lang/Object;
    //   49: checkcast java/util/LinkedList
    //   52: aload_1
    //   53: aconst_null
    //   54: astore_1
    //   55: invokevirtual add : (Ljava/lang/Object;)Z
    //   58: ifeq -> 67
    //   61: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   64: goto -> 70
    //   67: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   70: astore_3
    //   71: aload_2
    //   72: aconst_null
    //   73: astore_2
    //   74: checkcast java/util/concurrent/locks/Lock
    //   77: invokeinterface unlock : ()V
    //   82: aconst_null
    //   83: pop
    //   84: goto -> 105
    //   87: astore #4
    //   89: aload_2
    //   90: aconst_null
    //   91: astore_2
    //   92: checkcast java/util/concurrent/locks/Lock
    //   95: invokeinterface unlock : ()V
    //   100: aconst_null
    //   101: pop
    //   102: aload #4
    //   104: athrow
    //   105: aload_3
    //   106: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #61	-> 0
    //   #61	-> 9
    //   #61	-> 16
    //   #61	-> 33
    //   #61	-> 36
    //   #61	-> 55
    //   #61	-> 77
    //   #61	-> 95
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   5	101	2	lock__14923__auto__15971	Ljava/lang/Object;
    //   0	106	0	this	Lmanifold/stream/default/Stream;
    //   0	106	1	callback__15724__auto__	Ljava/lang/Object;
    // Exception table:
    //   from	to	target	type
    //   16	71	87	finally }
  
  public Object markClosed() {
    Object object;
    lock__14923__auto__15972 = this.lock;
    ((Lock)lock__14923__auto__15972).lock();
    null;
    try {
      this.__isClosed = Boolean.TRUE;
      object = ((IFn)const__38.getRawRoot()).invoke(this.__closedCallbacks);
    } finally {
      lock__14923__auto__15972 = null;
      ((Lock)lock__14923__auto__15972).unlock();
      null;
    } 
    return object;
  }
  
  public Object isDrained() { // Byte code:
    //   0: aload_0
    //   1: getfield lock : Ljava/lang/Object;
    //   4: astore_1
    //   5: aload_1
    //   6: checkcast java/util/concurrent/locks/Lock
    //   9: invokeinterface lock : ()V
    //   14: aconst_null
    //   15: pop
    //   16: aload_0
    //   17: checkcast manifold/stream/core/IEventSink
    //   20: invokeinterface isClosed : ()Ljava/lang/Object;
    //   25: astore_2
    //   26: aload_2
    //   27: dup
    //   28: ifnull -> 137
    //   31: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   34: if_acmpeq -> 138
    //   37: aload_0
    //   38: getfield producers : Ljava/lang/Object;
    //   41: checkcast java/util/LinkedList
    //   44: invokevirtual peek : ()Ljava/lang/Object;
    //   47: aconst_null
    //   48: invokestatic identical : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   51: istore_3
    //   52: iload_3
    //   53: ifeq -> 121
    //   56: aload_0
    //   57: getfield messages : Ljava/lang/Object;
    //   60: aconst_null
    //   61: invokestatic identical : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   64: istore #4
    //   66: iload #4
    //   68: ifeq -> 89
    //   71: iload #4
    //   73: ifeq -> 82
    //   76: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   79: goto -> 85
    //   82: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   85: goto -> 117
    //   88: athrow
    //   89: aload_0
    //   90: getfield messages : Ljava/lang/Object;
    //   93: checkcast java/util/Queue
    //   96: invokeinterface peek : ()Ljava/lang/Object;
    //   101: aconst_null
    //   102: invokestatic identical : (Ljava/lang/Object;Ljava/lang/Object;)Z
    //   105: ifeq -> 114
    //   108: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   111: goto -> 117
    //   114: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   117: goto -> 134
    //   120: athrow
    //   121: iload_3
    //   122: ifeq -> 131
    //   125: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   128: goto -> 134
    //   131: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   134: goto -> 141
    //   137: pop
    //   138: aload_2
    //   139: aconst_null
    //   140: astore_2
    //   141: astore #5
    //   143: aload_1
    //   144: aconst_null
    //   145: astore_1
    //   146: checkcast java/util/concurrent/locks/Lock
    //   149: invokeinterface unlock : ()V
    //   154: aconst_null
    //   155: pop
    //   156: goto -> 177
    //   159: astore #6
    //   161: aload_1
    //   162: aconst_null
    //   163: astore_1
    //   164: checkcast java/util/concurrent/locks/Lock
    //   167: invokeinterface unlock : ()V
    //   172: aconst_null
    //   173: pop
    //   174: aload #6
    //   176: athrow
    //   177: aload #5
    //   179: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #61	-> 0
    //   #135	-> 9
    //   #136	-> 20
    //   #136	-> 26
    //   #137	-> 44
    //   #137	-> 48
    //   #136	-> 52
    //   #138	-> 61
    //   #138	-> 66
    //   #139	-> 96
    //   #139	-> 102
    //   #135	-> 149
    //   #135	-> 167
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   66	51	4	or__5516__auto__15973	Z
    //   52	82	3	and__5514__auto__15974	Z
    //   26	115	2	and__5514__auto__15975	Ljava/lang/Object;
    //   5	174	1	lock__14923__auto__15976	Ljava/lang/Object;
    //   0	179	0	this	Lmanifold/stream/default/Stream;
    // Exception table:
    //   from	to	target	type
    //   16	88	159	finally
    //   89	120	159	finally
    //   121	143	159	finally }
  
  public Object take(Object default_val, Object blocking_QMARK_) { default_val = null;
    blocking_QMARK_ = null;
    return ((IEventSource)this).take(default_val, blocking_QMARK_, null, null); }
  
  public Object put(Object msg, Object blocking_QMARK_, Object timeout, Object timeout_val) {
    Object acc = new LinkedList(), lock__14923__auto__15977 = this.lock;
    ((Lock)lock__14923__auto__15977).lock();
    null;
    msg = null;
    lock__14923__auto__15977 = null;
    Object result = ((IFn)new fn__15960(this, msg, acc, lock__14923__auto__15977, this.add_BANG_)).invoke();
    boolean close_QMARK_ = RT.isReduced(result);
    result = null;
    result = null;
    Object result = close_QMARK_ ? ((IFn)const__17.getRawRoot()).invoke(result) : result;
    acc = null;
    timeout = null;
    timeout_val = null;
    Object val = ((IFn)new fn__15964(this, acc, timeout, timeout_val)).invoke();
    boolean or__5516__auto__15978 = close_QMARK_;
    result = null;
    if ((or__5516__auto__15978 ? (or__5516__auto__15978 ? Boolean.TRUE : Boolean.FALSE) : ((IFn)const__34.getRawRoot()).invoke(result)) != null) {
      if ((or__5516__auto__15978 ? (or__5516__auto__15978 ? Boolean.TRUE : Boolean.FALSE) : ((IFn)const__34.getRawRoot()).invoke(result)) != Boolean.FALSE) {
        ((IEventStream)this).close();
        this = null;
      } 
    } else {
      or__5516__auto__15978 ? (or__5516__auto__15978 ? Boolean.TRUE : Boolean.FALSE) : ((IFn)const__34.getRawRoot()).invoke(result);
    } 
    val = null;
    if (const__16 != null) {
      if (const__16 != Boolean.FALSE) {
        val = null;
        this = null;
      } 
    } else {
      const__16;
    } 
    return (val instanceof manifold.deferred.IDeferred) ? val : null;
  }
  
  public Object onDrained(Object callback__15726__auto__) { // Byte code:
    //   0: aload_0
    //   1: getfield lock : Ljava/lang/Object;
    //   4: astore_2
    //   5: aload_2
    //   6: checkcast java/util/concurrent/locks/Lock
    //   9: invokeinterface lock : ()V
    //   14: aconst_null
    //   15: pop
    //   16: aload_0
    //   17: getfield __isDrained : Ljava/lang/Object;
    //   20: dup
    //   21: ifnull -> 44
    //   24: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   27: if_acmpeq -> 45
    //   30: aload_1
    //   31: aconst_null
    //   32: astore_1
    //   33: checkcast clojure/lang/IFn
    //   36: invokeinterface invoke : ()Ljava/lang/Object;
    //   41: goto -> 70
    //   44: pop
    //   45: aload_0
    //   46: getfield __drainedCallbacks : Ljava/lang/Object;
    //   49: checkcast java/util/LinkedList
    //   52: aload_1
    //   53: aconst_null
    //   54: astore_1
    //   55: invokevirtual add : (Ljava/lang/Object;)Z
    //   58: ifeq -> 67
    //   61: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   64: goto -> 70
    //   67: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   70: astore_3
    //   71: aload_2
    //   72: aconst_null
    //   73: astore_2
    //   74: checkcast java/util/concurrent/locks/Lock
    //   77: invokeinterface unlock : ()V
    //   82: aconst_null
    //   83: pop
    //   84: goto -> 105
    //   87: astore #4
    //   89: aload_2
    //   90: aconst_null
    //   91: astore_2
    //   92: checkcast java/util/concurrent/locks/Lock
    //   95: invokeinterface unlock : ()V
    //   100: aconst_null
    //   101: pop
    //   102: aload #4
    //   104: athrow
    //   105: aload_3
    //   106: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #61	-> 0
    //   #61	-> 9
    //   #61	-> 16
    //   #61	-> 33
    //   #61	-> 36
    //   #61	-> 55
    //   #61	-> 77
    //   #61	-> 95
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   5	101	2	lock__14923__auto__15979	Ljava/lang/Object;
    //   0	106	0	this	Lmanifold/stream/default/Stream;
    //   0	106	1	callback__15726__auto__	Ljava/lang/Object;
    // Exception table:
    //   from	to	target	type
    //   16	71	87	finally }
  
  public Object isClosed() { return this.__isClosed; }
  
  public Object downstream() { this = null;
    return ((IFn)const__32.getRawRoot()).invoke(this); }
  
  public IPersistentMap alterMeta(IFn f__15719__auto__, ISeq args__15720__auto__) {
    Object lock__14925__auto__15981 = this.lock;
    ((Lock)lock__14925__auto__15981).lock();
    null;
    f__15719__auto__ = null;
    args__15720__auto__ = null;
    Object x__14926__auto__15980 = this.__mta = ((IFn)const__31.getRawRoot()).invoke(f__15719__auto__, this.__mta, args__15720__auto__);
    lock__14925__auto__15981 = null;
    ((Lock)lock__14925__auto__15981).unlock();
    null;
    x__14926__auto__15980 = null;
    return (IPersistentMap)x__14926__auto__15980;
  }
  
  public Object description() { // Byte code:
    //   0: bipush #20
    //   2: anewarray java/lang/Object
    //   5: dup
    //   6: iconst_0
    //   7: getstatic manifold/stream/default/Stream.const__20 : Lclojure/lang/Keyword;
    //   10: aastore
    //   11: dup
    //   12: iconst_1
    //   13: aload_0
    //   14: getfield producers : Ljava/lang/Object;
    //   17: checkcast java/util/LinkedList
    //   20: invokevirtual size : ()I
    //   23: invokestatic valueOf : (I)Ljava/lang/Integer;
    //   26: aastore
    //   27: dup
    //   28: iconst_2
    //   29: getstatic manifold/stream/default/Stream.const__21 : Lclojure/lang/Keyword;
    //   32: aastore
    //   33: dup
    //   34: iconst_3
    //   35: aload_0
    //   36: checkcast manifold/stream/core/IEventSource
    //   39: invokeinterface isDrained : ()Ljava/lang/Object;
    //   44: aastore
    //   45: dup
    //   46: iconst_4
    //   47: getstatic manifold/stream/default/Stream.const__22 : Lclojure/lang/Keyword;
    //   50: aastore
    //   51: dup
    //   52: iconst_5
    //   53: aload_0
    //   54: getfield messages : Ljava/lang/Object;
    //   57: dup
    //   58: ifnull -> 85
    //   61: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   64: if_acmpeq -> 86
    //   67: aload_0
    //   68: getfield messages : Ljava/lang/Object;
    //   71: checkcast java/util/Collection
    //   74: invokeinterface size : ()I
    //   79: invokestatic valueOf : (I)Ljava/lang/Integer;
    //   82: goto -> 89
    //   85: pop
    //   86: getstatic manifold/stream/default/Stream.const__23 : Ljava/lang/Object;
    //   89: aastore
    //   90: dup
    //   91: bipush #6
    //   93: getstatic manifold/stream/default/Stream.const__24 : Lclojure/lang/Keyword;
    //   96: aastore
    //   97: dup
    //   98: bipush #7
    //   100: aload_0
    //   101: getfield permanent_QMARK_ : Z
    //   104: ifeq -> 113
    //   107: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   110: goto -> 116
    //   113: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   116: aastore
    //   117: dup
    //   118: bipush #8
    //   120: getstatic manifold/stream/default/Stream.const__25 : Lclojure/lang/Keyword;
    //   123: aastore
    //   124: dup
    //   125: bipush #9
    //   127: ldc_w 'manifold'
    //   130: aastore
    //   131: dup
    //   132: bipush #10
    //   134: getstatic manifold/stream/default/Stream.const__26 : Lclojure/lang/Keyword;
    //   137: aastore
    //   138: dup
    //   139: bipush #11
    //   141: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   144: aastore
    //   145: dup
    //   146: bipush #12
    //   148: getstatic manifold/stream/default/Stream.const__27 : Lclojure/lang/Keyword;
    //   151: aastore
    //   152: dup
    //   153: bipush #13
    //   155: aload_0
    //   156: checkcast manifold/stream/core/IEventSink
    //   159: invokeinterface isClosed : ()Ljava/lang/Object;
    //   164: aastore
    //   165: dup
    //   166: bipush #14
    //   168: getstatic manifold/stream/default/Stream.const__28 : Lclojure/lang/Keyword;
    //   171: aastore
    //   172: dup
    //   173: bipush #15
    //   175: aload_0
    //   176: getfield consumers : Ljava/lang/Object;
    //   179: checkcast java/util/LinkedList
    //   182: invokevirtual size : ()I
    //   185: invokestatic valueOf : (I)Ljava/lang/Integer;
    //   188: aastore
    //   189: dup
    //   190: bipush #16
    //   192: getstatic manifold/stream/default/Stream.const__29 : Lclojure/lang/Keyword;
    //   195: aastore
    //   196: dup
    //   197: bipush #17
    //   199: aload_0
    //   200: getfield capacity : J
    //   203: invokestatic num : (J)Ljava/lang/Number;
    //   206: aastore
    //   207: dup
    //   208: bipush #18
    //   210: getstatic manifold/stream/default/Stream.const__30 : Lclojure/lang/Keyword;
    //   213: aastore
    //   214: dup
    //   215: bipush #19
    //   217: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   220: aastore
    //   221: invokestatic mapUniqueKeys : ([Ljava/lang/Object;)Lclojure/lang/IPersistentMap;
    //   224: astore_1
    //   225: aload_0
    //   226: getfield description : Ljava/lang/Object;
    //   229: dup
    //   230: ifnull -> 259
    //   233: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   236: if_acmpeq -> 260
    //   239: aload_0
    //   240: getfield description : Ljava/lang/Object;
    //   243: checkcast clojure/lang/IFn
    //   246: aload_1
    //   247: aconst_null
    //   248: astore_1
    //   249: aconst_null
    //   250: astore_0
    //   251: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   256: goto -> 263
    //   259: pop
    //   260: aload_1
    //   261: aconst_null
    //   262: astore_1
    //   263: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #61	-> 0
    //   #78	-> 20
    //   #84	-> 39
    //   #80	-> 53
    //   #80	-> 74
    //   #83	-> 159
    //   #81	-> 182
    //   #85	-> 225
    //   #86	-> 243
    //   #86	-> 249
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   225	38	1	m	Ljava/lang/Object;
    //   0	263	0	this	Lmanifold/stream/default/Stream; }
  
  public Object isSynchronous() { return Boolean.FALSE; }
  
  public Object close() { // Byte code:
    //   0: aload_0
    //   1: getfield permanent_QMARK_ : Z
    //   4: ifeq -> 12
    //   7: aconst_null
    //   8: goto -> 207
    //   11: athrow
    //   12: aload_0
    //   13: getfield lock : Ljava/lang/Object;
    //   16: astore_1
    //   17: aload_1
    //   18: checkcast java/util/concurrent/locks/Lock
    //   21: invokeinterface lock : ()V
    //   26: aconst_null
    //   27: pop
    //   28: aload_0
    //   29: checkcast manifold/stream/core/IEventSink
    //   32: invokeinterface isClosed : ()Ljava/lang/Object;
    //   37: dup
    //   38: ifnull -> 51
    //   41: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   44: if_acmpeq -> 52
    //   47: aconst_null
    //   48: goto -> 169
    //   51: pop
    //   52: new manifold/stream/default/Stream$fn__15946
    //   55: dup
    //   56: aload_0
    //   57: getfield add_BANG_ : Ljava/lang/Object;
    //   60: invokespecial <init> : (Ljava/lang/Object;)V
    //   63: checkcast clojure/lang/IFn
    //   66: invokeinterface invoke : ()Ljava/lang/Object;
    //   71: pop
    //   72: aload_0
    //   73: getfield consumers : Ljava/lang/Object;
    //   76: checkcast java/util/LinkedList
    //   79: invokevirtual poll : ()Ljava/lang/Object;
    //   82: astore_2
    //   83: aload_2
    //   84: dup
    //   85: ifnull -> 123
    //   88: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   91: if_acmpeq -> 124
    //   94: aload_2
    //   95: aconst_null
    //   96: astore_2
    //   97: astore_3
    //   98: new manifold/stream/default/Stream$fn__15956
    //   101: dup
    //   102: aload_3
    //   103: aconst_null
    //   104: astore_3
    //   105: invokespecial <init> : (Ljava/lang/Object;)V
    //   108: checkcast clojure/lang/IFn
    //   111: invokeinterface invoke : ()Ljava/lang/Object;
    //   116: pop
    //   117: goto -> 72
    //   120: nop
    //   121: nop
    //   122: athrow
    //   123: pop
    //   124: aconst_null
    //   125: pop
    //   126: aload_0
    //   127: checkcast manifold/stream/core/IEventSink
    //   130: invokeinterface markClosed : ()Ljava/lang/Object;
    //   135: pop
    //   136: aload_0
    //   137: checkcast manifold/stream/core/IEventSource
    //   140: invokeinterface isDrained : ()Ljava/lang/Object;
    //   145: dup
    //   146: ifnull -> 167
    //   149: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   152: if_acmpeq -> 168
    //   155: aload_0
    //   156: checkcast manifold/stream/core/IEventSource
    //   159: invokeinterface markDrained : ()Ljava/lang/Object;
    //   164: goto -> 169
    //   167: pop
    //   168: aconst_null
    //   169: astore #4
    //   171: aload_1
    //   172: aconst_null
    //   173: astore_1
    //   174: checkcast java/util/concurrent/locks/Lock
    //   177: invokeinterface unlock : ()V
    //   182: aconst_null
    //   183: pop
    //   184: goto -> 205
    //   187: astore #5
    //   189: aload_1
    //   190: aconst_null
    //   191: astore_1
    //   192: checkcast java/util/concurrent/locks/Lock
    //   195: invokeinterface unlock : ()V
    //   200: aconst_null
    //   201: pop
    //   202: aload #5
    //   204: athrow
    //   205: aload #4
    //   207: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #61	-> 0
    //   #90	-> 0
    //   #91	-> 21
    //   #92	-> 28
    //   #92	-> 32
    //   #94	-> 63
    //   #94	-> 66
    //   #122	-> 79
    //   #122	-> 83
    //   #123	-> 108
    //   #123	-> 111
    //   #129	-> 130
    //   #131	-> 136
    //   #131	-> 140
    //   #132	-> 159
    //   #91	-> 177
    //   #91	-> 195
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   98	22	3	c	Ljava/lang/Object;
    //   83	43	2	temp__5735__auto__15982	Ljava/lang/Object;
    //   17	190	1	lock__14923__auto__15983	Ljava/lang/Object;
    //   0	207	0	this	Lmanifold/stream/default/Stream;
    // Exception table:
    //   from	to	target	type
    //   28	120	187	finally
    //   123	171	187	finally }
  
  public IPersistentMap resetMeta(IPersistentMap m__15718__auto__) {
    Object lock__14925__auto__15985 = this.lock;
    ((Lock)lock__14925__auto__15985).lock();
    null;
    Object x__14926__auto__15984 = this.__mta = m__15718__auto__ = null;
    lock__14925__auto__15985 = null;
    ((Lock)lock__14925__auto__15985).unlock();
    null;
    x__14926__auto__15984 = null;
    return (IPersistentMap)x__14926__auto__15984;
  }
  
  public Object connector(Object ___15727__auto__) { return null; }
  
  public IPersistentMap meta() { return (IPersistentMap)this.__mta; }
  
  public Object take(Object default_val, Object blocking_QMARK_, Object timeout, Object timeout_val) { // Byte code:
    //   0: aload_0
    //   1: getfield lock : Ljava/lang/Object;
    //   4: astore #5
    //   6: aload #5
    //   8: checkcast java/util/concurrent/locks/Lock
    //   11: invokeinterface lock : ()V
    //   16: aconst_null
    //   17: pop
    //   18: new manifold/stream/default/Stream$fn__15925
    //   21: dup
    //   22: aload_3
    //   23: aconst_null
    //   24: astore_3
    //   25: aload_0
    //   26: getfield dirty_takes : Ljava/lang/Object;
    //   29: aload #4
    //   31: aconst_null
    //   32: astore #4
    //   34: aload_0
    //   35: getfield producers : Ljava/lang/Object;
    //   38: aload #5
    //   40: aconst_null
    //   41: astore #5
    //   43: aload_0
    //   44: getfield executor : Ljava/lang/Object;
    //   47: aload_0
    //   48: getfield consumers : Ljava/lang/Object;
    //   51: aload_0
    //   52: getfield messages : Ljava/lang/Object;
    //   55: aload_0
    //   56: aload_1
    //   57: invokespecial <init> : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V
    //   60: checkcast clojure/lang/IFn
    //   63: invokeinterface invoke : ()Ljava/lang/Object;
    //   68: astore #5
    //   70: aload #5
    //   72: instanceof manifold/stream/default/Consumer
    //   75: ifeq -> 406
    //   78: getstatic manifold/stream/default/Stream.const__3 : Lclojure/lang/Var;
    //   81: invokevirtual get : ()Ljava/lang/Object;
    //   84: dup
    //   85: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   88: getstatic manifold/stream/default/Stream.__cached_class__0 : Ljava/lang/Class;
    //   91: if_acmpeq -> 108
    //   94: dup
    //   95: instanceof clojure/tools/logging/impl/LoggerFactory
    //   98: ifne -> 126
    //   101: dup
    //   102: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   105: putstatic manifold/stream/default/Stream.__cached_class__0 : Ljava/lang/Class;
    //   108: getstatic manifold/stream/default/Stream.const__2 : Lclojure/lang/Var;
    //   111: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   114: swap
    //   115: getstatic manifold/stream/default/Stream.const__4 : Ljava/lang/Object;
    //   118: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   123: goto -> 137
    //   126: checkcast clojure/tools/logging/impl/LoggerFactory
    //   129: getstatic manifold/stream/default/Stream.const__4 : Ljava/lang/Object;
    //   132: invokeinterface get_logger : (Ljava/lang/Object;)Ljava/lang/Object;
    //   137: astore #6
    //   139: aload #6
    //   141: dup
    //   142: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   145: getstatic manifold/stream/default/Stream.__cached_class__1 : Ljava/lang/Class;
    //   148: if_acmpeq -> 165
    //   151: dup
    //   152: instanceof clojure/tools/logging/impl/Logger
    //   155: ifne -> 183
    //   158: dup
    //   159: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   162: putstatic manifold/stream/default/Stream.__cached_class__1 : Ljava/lang/Class;
    //   165: getstatic manifold/stream/default/Stream.const__5 : Lclojure/lang/Var;
    //   168: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   171: swap
    //   172: getstatic manifold/stream/default/Stream.const__6 : Lclojure/lang/Keyword;
    //   175: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   180: goto -> 194
    //   183: checkcast clojure/tools/logging/impl/Logger
    //   186: getstatic manifold/stream/default/Stream.const__6 : Lclojure/lang/Keyword;
    //   189: invokeinterface enabled_QMARK_ : (Ljava/lang/Object;)Ljava/lang/Object;
    //   194: dup
    //   195: ifnull -> 359
    //   198: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   201: if_acmpeq -> 360
    //   204: new java/lang/IllegalStateException
    //   207: dup
    //   208: invokespecial <init> : ()V
    //   211: astore #7
    //   213: aload #7
    //   215: instanceof java/lang/Throwable
    //   218: ifeq -> 290
    //   221: getstatic manifold/stream/default/Stream.const__8 : Lclojure/lang/Var;
    //   224: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   227: checkcast clojure/lang/IFn
    //   230: aload #6
    //   232: aconst_null
    //   233: astore #6
    //   235: getstatic manifold/stream/default/Stream.const__6 : Lclojure/lang/Keyword;
    //   238: aload #7
    //   240: aconst_null
    //   241: astore #7
    //   243: getstatic manifold/stream/default/Stream.const__9 : Lclojure/lang/Var;
    //   246: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   249: checkcast clojure/lang/IFn
    //   252: getstatic manifold/stream/default/Stream.const__10 : Lclojure/lang/Var;
    //   255: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   258: checkcast clojure/lang/IFn
    //   261: ldc_w 'excessive pending takes (> %s), closing stream'
    //   264: getstatic manifold/stream/default/Stream.const__11 : Lclojure/lang/Var;
    //   267: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   270: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   275: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   280: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   285: pop
    //   286: goto -> 356
    //   289: athrow
    //   290: getstatic manifold/stream/default/Stream.const__8 : Lclojure/lang/Var;
    //   293: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   296: checkcast clojure/lang/IFn
    //   299: aload #6
    //   301: aconst_null
    //   302: astore #6
    //   304: getstatic manifold/stream/default/Stream.const__6 : Lclojure/lang/Keyword;
    //   307: aconst_null
    //   308: getstatic manifold/stream/default/Stream.const__9 : Lclojure/lang/Var;
    //   311: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   314: checkcast clojure/lang/IFn
    //   317: aload #7
    //   319: aconst_null
    //   320: astore #7
    //   322: getstatic manifold/stream/default/Stream.const__10 : Lclojure/lang/Var;
    //   325: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   328: checkcast clojure/lang/IFn
    //   331: ldc_w 'excessive pending takes (> %s), closing stream'
    //   334: getstatic manifold/stream/default/Stream.const__11 : Lclojure/lang/Var;
    //   337: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   340: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   345: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   350: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   355: pop
    //   356: goto -> 362
    //   359: pop
    //   360: aconst_null
    //   361: pop
    //   362: aload_0
    //   363: astore #6
    //   365: aload #6
    //   367: aconst_null
    //   368: astore #6
    //   370: checkcast manifold/stream/core/IEventStream
    //   373: invokeinterface close : ()Ljava/lang/Object;
    //   378: pop
    //   379: getstatic manifold/stream/default/Stream.const__13 : Lclojure/lang/Var;
    //   382: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   385: checkcast clojure/lang/IFn
    //   388: aload_1
    //   389: aconst_null
    //   390: astore_1
    //   391: aload_0
    //   392: getfield executor : Ljava/lang/Object;
    //   395: aconst_null
    //   396: astore_0
    //   397: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   402: goto -> 578
    //   405: athrow
    //   406: aload #5
    //   408: instanceof manifold/stream/default/Consumption
    //   411: ifeq -> 517
    //   414: aload #5
    //   416: aconst_null
    //   417: astore #5
    //   419: astore #6
    //   421: new manifold/stream/default/Stream$fn__15942
    //   424: dup
    //   425: aload #6
    //   427: invokespecial <init> : (Ljava/lang/Object;)V
    //   430: checkcast clojure/lang/IFn
    //   433: invokeinterface invoke : ()Ljava/lang/Object;
    //   438: pop
    //   439: getstatic manifold/stream/default/Stream.const__15 : Lclojure/lang/Var;
    //   442: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   445: checkcast clojure/lang/IFn
    //   448: aload #6
    //   450: aconst_null
    //   451: astore #6
    //   453: checkcast manifold/stream/default/Consumption
    //   456: getfield message : Ljava/lang/Object;
    //   459: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   464: astore #7
    //   466: aload_2
    //   467: aconst_null
    //   468: astore_2
    //   469: dup
    //   470: ifnull -> 487
    //   473: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   476: if_acmpeq -> 488
    //   479: aload #7
    //   481: aconst_null
    //   482: astore #7
    //   484: goto -> 513
    //   487: pop
    //   488: getstatic manifold/stream/default/Stream.const__13 : Lclojure/lang/Var;
    //   491: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   494: checkcast clojure/lang/IFn
    //   497: aload #7
    //   499: aconst_null
    //   500: astore #7
    //   502: aload_0
    //   503: getfield executor : Ljava/lang/Object;
    //   506: aconst_null
    //   507: astore_0
    //   508: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   513: goto -> 578
    //   516: athrow
    //   517: getstatic manifold/stream/default/Stream.const__16 : Lclojure/lang/Keyword;
    //   520: dup
    //   521: ifnull -> 576
    //   524: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   527: if_acmpeq -> 577
    //   530: aload_2
    //   531: aconst_null
    //   532: astore_2
    //   533: dup
    //   534: ifnull -> 567
    //   537: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   540: if_acmpeq -> 568
    //   543: getstatic manifold/stream/default/Stream.const__17 : Lclojure/lang/Var;
    //   546: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   549: checkcast clojure/lang/IFn
    //   552: aload #5
    //   554: aconst_null
    //   555: astore #5
    //   557: aconst_null
    //   558: astore_0
    //   559: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   564: goto -> 573
    //   567: pop
    //   568: aload #5
    //   570: aconst_null
    //   571: astore #5
    //   573: goto -> 578
    //   576: pop
    //   577: aconst_null
    //   578: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #61	-> 0
    //   #199	-> 11
    //   #199	-> 60
    //   #199	-> 63
    //   #249	-> 70
    //   #253	-> 78
    //   #253	-> 118
    //   #253	-> 139
    //   #253	-> 139
    //   #253	-> 175
    //   #253	-> 213
    //   #253	-> 227
    //   #253	-> 249
    //   #253	-> 258
    //   #253	-> 270
    //   #253	-> 275
    //   #253	-> 280
    //   #253	-> 296
    //   #253	-> 314
    //   #253	-> 328
    //   #253	-> 340
    //   #253	-> 345
    //   #253	-> 350
    //   #254	-> 373
    //   #255	-> 385
    //   #255	-> 395
    //   #249	-> 406
    //   #259	-> 430
    //   #259	-> 433
    //   #263	-> 445
    //   #263	-> 453
    //   #263	-> 459
    //   #264	-> 466
    //   #266	-> 494
    //   #266	-> 506
    //   #249	-> 517
    //   #269	-> 530
    //   #269	-> 549
    //   #269	-> 557
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   6	62	5	lock__14923__auto__15986	Ljava/lang/Object;
    //   213	143	7	x__8621__auto__15987	Ljava/lang/Object;
    //   139	223	6	logger__8620__auto__15988	Ljava/lang/Object;
    //   365	14	6	x__15677__auto__15989	Ljava/lang/Object;
    //   466	47	7	msg	Ljava/lang/Object;
    //   421	92	6	result	Ljava/lang/Object;
    //   70	508	5	result	Ljava/lang/Object;
    //   0	578	0	this	Lmanifold/stream/default/Stream;
    //   0	578	1	default_val	Ljava/lang/Object;
    //   0	578	2	blocking_QMARK_	Ljava/lang/Object;
    //   0	578	3	timeout	Ljava/lang/Object;
    //   0	578	4	timeout_val	Ljava/lang/Object; }
  
  public Object weakHandle(Object ref_queue__15722__auto__) { // Byte code:
    //   0: aload_0
    //   1: getfield lock : Ljava/lang/Object;
    //   4: astore_2
    //   5: aload_2
    //   6: checkcast java/util/concurrent/locks/Lock
    //   9: invokeinterface lock : ()V
    //   14: aconst_null
    //   15: pop
    //   16: aload_0
    //   17: getfield __weakHandle : Ljava/lang/Object;
    //   20: astore_3
    //   21: aload_3
    //   22: dup
    //   23: ifnull -> 38
    //   26: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   29: if_acmpeq -> 39
    //   32: aload_3
    //   33: aconst_null
    //   34: astore_3
    //   35: goto -> 61
    //   38: pop
    //   39: aload_0
    //   40: new java/lang/ref/WeakReference
    //   43: dup
    //   44: aload_0
    //   45: aload_1
    //   46: aconst_null
    //   47: astore_1
    //   48: checkcast java/lang/ref/ReferenceQueue
    //   51: invokespecial <init> : (Ljava/lang/Object;Ljava/lang/ref/ReferenceQueue;)V
    //   54: putfield __weakHandle : Ljava/lang/Object;
    //   57: aload_0
    //   58: getfield __weakHandle : Ljava/lang/Object;
    //   61: astore #4
    //   63: aload_2
    //   64: aconst_null
    //   65: astore_2
    //   66: checkcast java/util/concurrent/locks/Lock
    //   69: invokeinterface unlock : ()V
    //   74: aconst_null
    //   75: pop
    //   76: goto -> 97
    //   79: astore #5
    //   81: aload_2
    //   82: aconst_null
    //   83: astore_2
    //   84: checkcast java/util/concurrent/locks/Lock
    //   87: invokeinterface unlock : ()V
    //   92: aconst_null
    //   93: pop
    //   94: aload #5
    //   96: athrow
    //   97: aload #4
    //   99: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #61	-> 0
    //   #61	-> 9
    //   #61	-> 21
    //   #61	-> 69
    //   #61	-> 87
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   21	40	3	or__5516__auto__15990	Ljava/lang/Object;
    //   5	94	2	lock__14923__auto__15991	Ljava/lang/Object;
    //   0	99	0	this	Lmanifold/stream/default/Stream;
    //   0	99	1	ref_queue__15722__auto__	Ljava/lang/Object;
    // Exception table:
    //   from	to	target	type
    //   16	63	79	finally }
  
  public Object put(Object msg, Object blocking_QMARK_) { msg = null;
    blocking_QMARK_ = null;
    return ((IEventSink)this).put(msg, blocking_QMARK_, null, null); }
}
