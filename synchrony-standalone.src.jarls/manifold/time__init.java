package manifold;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class time__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Keyword const__3;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final AFn const__14;
  
  public static final Var const__15;
  
  public static final AFn const__18;
  
  public static final Var const__19;
  
  public static final AFn const__22;
  
  public static final Var const__23;
  
  public static final AFn const__26;
  
  public static final Var const__27;
  
  public static final AFn const__30;
  
  public static final Var const__31;
  
  public static final AFn const__34;
  
  public static final Var const__35;
  
  public static final AFn const__38;
  
  public static final Var const__39;
  
  public static final AFn const__42;
  
  public static final AFn const__43;
  
  public static final Var const__44;
  
  public static final AFn const__47;
  
  public static final Var const__48;
  
  public static final AFn const__49;
  
  public static final Var const__50;
  
  public static final AFn const__51;
  
  public static final Var const__52;
  
  public static final AFn const__53;
  
  public static final Var const__54;
  
  public static final AFn const__55;
  
  public static final Var const__56;
  
  public static final AFn const__57;
  
  public static final AFn const__58;
  
  public static final Object const__59;
  
  public static final Var const__60;
  
  public static final Var const__61;
  
  public static final Var const__62;
  
  public static final Var const__63;
  
  public static final ISeq const__64;
  
  public static final Var const__65;
  
  public static final Var const__66;
  
  public static final AFn const__70;
  
  public static final Keyword const__71;
  
  public static final AFn const__72;
  
  public static final Keyword const__73;
  
  public static final Keyword const__74;
  
  public static final AFn const__77;
  
  public static final Keyword const__78;
  
  public static final Var const__79;
  
  public static final Var const__80;
  
  public static final Var const__81;
  
  public static final AFn const__82;
  
  public static final AFn const__83;
  
  public static final Keyword const__84;
  
  public static final AFn const__85;
  
  public static final AFn const__86;
  
  public static final Var const__87;
  
  public static final AFn const__88;
  
  public static final Var const__89;
  
  public static final AFn const__93;
  
  public static final Var const__94;
  
  public static final AFn const__97;
  
  public static final Var const__98;
  
  public static final AFn const__101;
  
  public static final Var const__102;
  
  public static final AFn const__105;
  
  public static final Var const__106;
  
  public static final AFn const__109;
  
  public static final Var const__110;
  
  public static final AFn const__113;
  
  public static final Var const__114;
  
  public static final AFn const__117;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new time.fn__14940());
    const__6.setMeta((IPersistentMap)const__14);
    const__6.bindRoot(new time.nanoseconds());
    const__15.setMeta((IPersistentMap)const__18);
    const__15.bindRoot(new time.microseconds());
    const__19.setMeta((IPersistentMap)const__22);
    const__19.bindRoot(new time.milliseconds());
    const__23.setMeta((IPersistentMap)const__26);
    const__23.bindRoot(new time.seconds());
    const__27.setMeta((IPersistentMap)const__30);
    const__27.bindRoot(new time.minutes());
    const__31.setMeta((IPersistentMap)const__34);
    const__31.bindRoot(new time.hours());
    const__35.setMeta((IPersistentMap)const__38);
    const__35.bindRoot(new time.days());
    const__39.setMeta((IPersistentMap)const__42);
    const__39.bindRoot(new time.hz());
    const__44.setMeta((IPersistentMap)const__47);
    const__48.setMeta((IPersistentMap)const__49);
    const__50.setMeta((IPersistentMap)const__51);
    const__52.setMeta((IPersistentMap)const__53);
    const__54.setMeta((IPersistentMap)const__55);
    const__56.setMeta((IPersistentMap)const__57);
    const__89.setMeta((IPersistentMap)const__93);
    const__89.bindRoot(new time.cancel_on_exception());
    const__94.setMeta((IPersistentMap)const__97);
    const__94.bindRoot(new time.scheduled_executor__GT_clock());
    const__98.setMeta((IPersistentMap)const__101);
    const__98.bindRoot(new time.mock_clock());
    const__102.setMeta((IPersistentMap)const__105);
    const__102.bindRoot(new time.with_clock());
    ((Var)const__102)














      
      .setMacro();
    const__106.setMeta((IPersistentMap)const__109);
    const__106.bindRoot(new time.in());
    const__110.setMeta((IPersistentMap)const__113);
    const__110.bindRoot(new time.every());
    const__114.setMeta((IPersistentMap)const__117);
    const__114.bindRoot(new time.at());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "manifold.time")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "author"), "Zach Tellman", RT.keyword(null, "doc"), "This namespace contains methods for converting units of time, with milliseconds as the base representation, and for deferring execution of functions to some time in the future.  In practice, the methods here are not necessary to use Manifold effectively - `manifold.deferred/timeout` and `manifold.stream/periodically` are more directly useful - but they are available for anyone who should need them." }));
    const__3 = (Keyword)RT.keyword(null, "doc");
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "author"), "Zach Tellman", RT.keyword(null, "doc"), "This namespace contains methods for converting units of time, with milliseconds as the base representation, and for deferring execution of functions to some time in the future.  In practice, the methods here are not necessary to use Manifold effectively - `manifold.deferred/timeout` and `manifold.stream/periodically` are more directly useful - but they are available for anyone who should need them." });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("manifold.time", "nanoseconds");
    const__14 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Converts nanoseconds -> milliseconds", RT.keyword(null, "line"), Integer.valueOf(22), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__15 = (Var)RT.var("manifold.time", "microseconds");
    const__18 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Converts microseconds -> milliseconds", RT.keyword(null, "line"), Integer.valueOf(27), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__19 = (Var)RT.var("manifold.time", "milliseconds");
    const__22 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Converts milliseconds -> milliseconds", RT.keyword(null, "line"), Integer.valueOf(32), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__23 = (Var)RT.var("manifold.time", "seconds");
    const__26 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Converts seconds -> milliseconds", RT.keyword(null, "line"), Integer.valueOf(37), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__27 = (Var)RT.var("manifold.time", "minutes");
    const__30 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Converts minutes -> milliseconds", RT.keyword(null, "line"), Integer.valueOf(42), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__31 = (Var)RT.var("manifold.time", "hours");
    const__34 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Converts hours -> milliseconds", RT.keyword(null, "line"), Integer.valueOf(47), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__35 = (Var)RT.var("manifold.time", "days");
    const__38 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Converts days -> milliseconds", RT.keyword(null, "line"), Integer.valueOf(52), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__39 = (Var)RT.var("manifold.time", "hz");
    const__42 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Converts frequency -> period in milliseconds", RT.keyword(null, "line"), Integer.valueOf(57), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__43 = (AFn)Symbol.intern(null, "manifold.deferred");
    const__44 = (Var)RT.var("manifold.deferred", "success!");
    const__47 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(126), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__48 = (Var)RT.var("manifold.deferred", "error!");
    const__49 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(126), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__50 = (Var)RT.var("manifold.deferred", "deferred");
    const__51 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(126), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__52 = (Var)RT.var("manifold.deferred", "realized?");
    const__53 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(126), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__54 = (Var)RT.var("manifold.deferred", "chain");
    const__55 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(126), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__56 = (Var)RT.var("manifold.deferred", "connect");
    const__57 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(126), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__58 = (AFn)Symbol.intern(null, "manifold.time");
    const__59 = RT.classForName("manifold.time.IMockClock");
    const__60 = (Var)RT.var("clojure.core", "alter-meta!");
    const__61 = (Var)RT.var("manifold.time", "IMockClock");
    const__62 = (Var)RT.var("clojure.core", "assoc");
    const__63 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__64 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "now")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the current time for the clock", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "clock")) })) })), ((IObj)Symbol.intern(null, "advance")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Advances the mock clock by the specified interval of `time`.\n\n    Advancing the clock is a continuous action - the clock doesn't just jump\n    from `now` to `new-now = (+ (now clock) time)`. Rather, for each scheduled\n    event within `[now; new-now]` the clock is reset to the time of the event\n    and the event function is executed.\n\n    For example, if you have a periodic function scheduled with\n\n      (every 1 #(swap! counter inc))\n\n    and advance the clock by 5, the counter will be incremented 6 times in\n    total: once initially, as the initial delay is 0 and 5 times for every 1 ms\n    step of the clock.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "clock"), Symbol.intern(null, "time")) })) })) }));
    const__65 = (Var)RT.var("clojure.core", "alter-var-root");
    const__66 = (Var)RT.var("clojure.core", "merge");
    const__70 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "manifold.time.IMockClock"), RT.keyword(null, "on-interface"), RT.classForName("manifold.time.IMockClock") });
    const__71 = (Keyword)RT.keyword(null, "sigs");
    const__72 = (AFn)RT.map(new Object[] { RT.keyword(null, "now"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "now")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the current time for the clock", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "clock")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "clock")) })), RT.keyword(null, "doc"), "Returns the current time for the clock" }), RT.keyword(null, "advance"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "advance")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Advances the mock clock by the specified interval of `time`.\n\n    Advancing the clock is a continuous action - the clock doesn't just jump\n    from `now` to `new-now = (+ (now clock) time)`. Rather, for each scheduled\n    event within `[now; new-now]` the clock is reset to the time of the event\n    and the event function is executed.\n\n    For example, if you have a periodic function scheduled with\n\n      (every 1 #(swap! counter inc))\n\n    and advance the clock by 5, the counter will be incremented 6 times in\n    total: once initially, as the initial delay is 0 and 5 times for every 1 ms\n    step of the clock.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "clock"), Symbol.intern(null, "time")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "clock"), Symbol.intern(null, "time")) })), RT.keyword(null, "doc"), "Advances the mock clock by the specified interval of `time`.\n\n    Advancing the clock is a continuous action - the clock doesn't just jump\n    from `now` to `new-now = (+ (now clock) time)`. Rather, for each scheduled\n    event within `[now; new-now]` the clock is reset to the time of the event\n    and the event function is executed.\n\n    For example, if you have a periodic function scheduled with\n\n      (every 1 #(swap! counter inc))\n\n    and advance the clock by 5, the counter will be incremented 6 times in\n    total: once initially, as the initial delay is 0 and 5 times for every 1 ms\n    step of the clock." }) });
    const__73 = (Keyword)RT.keyword(null, "var");
    const__74 = (Keyword)RT.keyword(null, "method-map");
    const__77 = (AFn)RT.map(new Object[] { RT.keyword(null, "advance"), RT.keyword(null, "advance"), RT.keyword(null, "now"), RT.keyword(null, "now") });
    const__78 = (Keyword)RT.keyword(null, "method-builders");
    const__79 = (Var)RT.var("clojure.core", "intern");
    const__80 = (Var)RT.var("clojure.core", "*ns*");
    const__81 = (Var)RT.var("clojure.core", "with-meta");
    const__82 = (AFn)((IObj)Symbol.intern(null, "now")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the current time for the clock", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "clock")) })) }));
    const__83 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "now")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the current time for the clock", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "clock")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "clock")) })), RT.keyword(null, "doc"), "Returns the current time for the clock" });
    const__84 = (Keyword)RT.keyword(null, "protocol");
    const__85 = (AFn)((IObj)Symbol.intern(null, "advance")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Advances the mock clock by the specified interval of `time`.\n\n    Advancing the clock is a continuous action - the clock doesn't just jump\n    from `now` to `new-now = (+ (now clock) time)`. Rather, for each scheduled\n    event within `[now; new-now]` the clock is reset to the time of the event\n    and the event function is executed.\n\n    For example, if you have a periodic function scheduled with\n\n      (every 1 #(swap! counter inc))\n\n    and advance the clock by 5, the counter will be incremented 6 times in\n    total: once initially, as the initial delay is 0 and 5 times for every 1 ms\n    step of the clock.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "clock"), Symbol.intern(null, "time")) })) }));
    const__86 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "advance")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Advances the mock clock by the specified interval of `time`.\n\n    Advancing the clock is a continuous action - the clock doesn't just jump\n    from `now` to `new-now = (+ (now clock) time)`. Rather, for each scheduled\n    event within `[now; new-now]` the clock is reset to the time of the event\n    and the event function is executed.\n\n    For example, if you have a periodic function scheduled with\n\n      (every 1 #(swap! counter inc))\n\n    and advance the clock by 5, the counter will be incremented 6 times in\n    total: once initially, as the initial delay is 0 and 5 times for every 1 ms\n    step of the clock.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "clock"), Symbol.intern(null, "time")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "clock"), Symbol.intern(null, "time")) })), RT.keyword(null, "doc"), "Advances the mock clock by the specified interval of `time`.\n\n    Advancing the clock is a continuous action - the clock doesn't just jump\n    from `now` to `new-now = (+ (now clock) time)`. Rather, for each scheduled\n    event within `[now; new-now]` the clock is reset to the time of the event\n    and the event function is executed.\n\n    For example, if you have a periodic function scheduled with\n\n      (every 1 #(swap! counter inc))\n\n    and advance the clock by 5, the counter will be incremented 6 times in\n    total: once initially, as the initial delay is 0 and 5 times for every 1 ms\n    step of the clock." });
    const__87 = (Var)RT.var("clojure.core", "-reset-methods");
    const__88 = (AFn)Symbol.intern(null, "IMockClock");
    const__89 = (Var)RT.var("manifold.time", "cancel-on-exception");
    const__93 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "cancel-fn")) })), RT.keyword(null, "line"), Integer.valueOf(153), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__94 = (Var)RT.var("manifold.time", "scheduled-executor->clock");
    const__97 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "e")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ScheduledExecutorService") }))) })), RT.keyword(null, "line"), Integer.valueOf(160), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__98 = (Var)RT.var("manifold.time", "mock-clock");
  }
  
  public static void __init1() {
    const__101 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "initial-time")) })), RT.keyword(null, "doc"), "Creates a clock designed for testing scheduled behaviors.  It can replace the default\n   scheduler using `with-clock`, and can be advanced to a particular time via `advance`.  By\n   default, the initial time is `0`.", RT.keyword(null, "line"), Integer.valueOf(180), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__102 = (Var)RT.var("manifold.time", "with-clock");
    const__105 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "clock"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Ensures that all calls to `every` and `in` are made through the specified clock, rather\n   than the default one.", RT.keyword(null, "line"), Integer.valueOf(243), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__106 = (Var)RT.var("manifold.time", "in");
    const__109 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "interval")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "double") })), Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Schedules no-arg function `f` to be invoked in `interval` milliseconds.  Returns a deferred\n   representing the returned value of the function (unwrapped if `f` itself returns a deferred).\n   If the returned deferred is completed before the interval has passed, the timeout function\n   will be cancelled.", RT.keyword(null, "line"), Integer.valueOf(250), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__110 = (Var)RT.var("manifold.time", "every");
    const__113 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "period"), Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "period"), Symbol.intern(null, "initial-delay"), Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Schedules no-arg function `f` to be invoked every `period` milliseconds, after `initial-delay`\n   milliseconds, which defaults to `0`.  Returns a zero-argument function which, when invoked,\n   cancels the repeated invocation.\n\n   If the invocation of `f` ever throws an exception, repeated invocation is automatically\n   cancelled.", RT.keyword(null, "line"), Integer.valueOf(267), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
    const__114 = (Var)RT.var("manifold.time", "at");
    const__117 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "timestamp"), Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Schedules no-arg function `f` to be invoked at `timestamp`, which is the milliseconds\n   since the epoch.  Returns a deferred representing the returned value of the function\n   (unwrapped if `f` itself returns a deferred).", RT.keyword(null, "line"), Integer.valueOf(279), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "manifold/time.clj" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("manifold.time__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
