package mount;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class lite__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Keyword const__2;
  
  public static final AFn const__5;
  
  public static final AFn const__6;
  
  public static final Object const__7;
  
  public static final Var const__8;
  
  public static final Var const__9;
  
  public static final Var const__10;
  
  public static final Var const__11;
  
  public static final ISeq const__12;
  
  public static final Var const__13;
  
  public static final Var const__14;
  
  public static final AFn const__18;
  
  public static final Keyword const__19;
  
  public static final AFn const__20;
  
  public static final Keyword const__21;
  
  public static final Keyword const__22;
  
  public static final AFn const__27;
  
  public static final Keyword const__28;
  
  public static final Var const__29;
  
  public static final Var const__30;
  
  public static final Var const__31;
  
  public static final AFn const__32;
  
  public static final AFn const__33;
  
  public static final Keyword const__34;
  
  public static final AFn const__35;
  
  public static final AFn const__36;
  
  public static final AFn const__37;
  
  public static final AFn const__38;
  
  public static final AFn const__39;
  
  public static final AFn const__40;
  
  public static final Var const__41;
  
  public static final AFn const__42;
  
  public static final Var const__43;
  
  public static final Keyword const__44;
  
  public static final AFn const__52;
  
  public static final Var const__53;
  
  public static final AFn const__56;
  
  public static final Var const__57;
  
  public static final AFn const__60;
  
  public static final Var const__61;
  
  public static final Var const__62;
  
  public static final Object const__63;
  
  public static final Object const__64;
  
  public static final Object const__65;
  
  public static final Var const__66;
  
  public static final Var const__67;
  
  public static final Var const__68;
  
  public static final AFn const__71;
  
  public static final Var const__72;
  
  public static final AFn const__75;
  
  public static final Var const__76;
  
  public static final AFn const__79;
  
  public static final Var const__80;
  
  public static final AFn const__83;
  
  public static final Var const__84;
  
  public static final AFn const__87;
  
  public static final Var const__88;
  
  public static final AFn const__91;
  
  public static final Var const__92;
  
  public static final AFn const__95;
  
  public static final Var const__96;
  
  public static final AFn const__99;
  
  public static final Var const__100;
  
  public static final AFn const__103;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new lite.fn__23937());
    const__43.setMeta((IPersistentMap)const__52);
    const__43.bindRoot(new lite.throw_started());
    const__53.setMeta((IPersistentMap)const__56);
    const__53.bindRoot(new lite.throw_unstarted());
    const__57.setMeta((IPersistentMap)const__60);
    const__57.bindRoot(new lite.throw_not_found());
    const__68.setMeta((IPersistentMap)const__71);
    const__68.bindRoot(new lite.var_status_EQ_());
    const__72.setMeta((IPersistentMap)const__75);
    const__72.bindRoot(new lite.prune_states());
    const__76.setMeta((IPersistentMap)const__79);
    const__76.bindRoot(new lite.state());
    ((Var)const__76)









      
      .setMacro();
    const__80.setMeta((IPersistentMap)const__83);
    const__80.bindRoot(new lite.defstate());
    ((Var)const__80)










      
      .setMacro();
    const__84.setMeta((IPersistentMap)const__87);
    const__84.bindRoot(new lite.start());
    const__88.setMeta((IPersistentMap)const__91);
    const__88.bindRoot(new lite.stop());
    const__92.setMeta((IPersistentMap)const__95);
    const__92.bindRoot(new lite.status());
    const__96.setMeta((IPersistentMap)const__99);
    const__96.bindRoot(new lite.with_substitutes());
    ((Var)const__96)
































































      
      .setMacro();
    const__100.setMeta((IPersistentMap)const__103);
    const__100.bindRoot(new lite.with_session());
    ((Var)const__100)







      
      .setMacro();
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "mount.lite")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The core namespace providing the public API", RT.keyword("clojure.tools.namespace.repl", "load"), Boolean.FALSE, RT.keyword("clojure.tools.namespace.repl", "unload"), Boolean.FALSE }));
    const__2 = (Keyword)RT.keyword(null, "doc");
    const__5 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "The core namespace providing the public API", RT.keyword("clojure.tools.namespace.repl", "load"), Boolean.FALSE, RT.keyword("clojure.tools.namespace.repl", "unload"), Boolean.FALSE });
    const__6 = (AFn)Symbol.intern(null, "clojure.core");
    const__7 = RT.classForName("mount.lite.IState");
    const__8 = (Var)RT.var("clojure.core", "alter-meta!");
    const__9 = (Var)RT.var("mount.lite", "IState");
    const__10 = (Var)RT.var("clojure.core", "assoc");
    const__11 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__12 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "start*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) })), ((IObj)Symbol.intern(null, "stop*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) })), ((IObj)Symbol.intern(null, "status*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) })), ((IObj)Symbol.intern(null, "properties")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) })) }));
    const__13 = (Var)RT.var("clojure.core", "alter-var-root");
    const__14 = (Var)RT.var("clojure.core", "merge");
    const__18 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "mount.lite.IState"), RT.keyword(null, "on-interface"), RT.classForName("mount.lite.IState") });
    const__19 = (Keyword)RT.keyword(null, "sigs");
    const__20 = (AFn)RT.map(new Object[] { RT.keyword(null, "start*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "start*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })), RT.keyword(null, "doc"), null }), RT.keyword(null, "stop*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "stop*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })), RT.keyword(null, "doc"), null }), RT.keyword(null, "status*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "status*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })), RT.keyword(null, "doc"), null }), RT.keyword(null, "properties"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "properties")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })), RT.keyword(null, "doc"), null }) });
    const__21 = (Keyword)RT.keyword(null, "var");
    const__22 = (Keyword)RT.keyword(null, "method-map");
    const__27 = (AFn)RT.map(new Object[] { RT.keyword(null, "properties"), RT.keyword(null, "properties"), RT.keyword(null, "stop*"), RT.keyword(null, "stop*"), RT.keyword(null, "start*"), RT.keyword(null, "start*"), RT.keyword(null, "status*"), RT.keyword(null, "status*") });
    const__28 = (Keyword)RT.keyword(null, "method-builders");
    const__29 = (Var)RT.var("clojure.core", "intern");
    const__30 = (Var)RT.var("clojure.core", "*ns*");
    const__31 = (Var)RT.var("clojure.core", "with-meta");
    const__32 = (AFn)((IObj)Symbol.intern(null, "stop*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) }));
    const__33 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "stop*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })), RT.keyword(null, "doc"), null });
    const__34 = (Keyword)RT.keyword(null, "protocol");
    const__35 = (AFn)((IObj)Symbol.intern(null, "properties")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) }));
    const__36 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "properties")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })), RT.keyword(null, "doc"), null });
    const__37 = (AFn)((IObj)Symbol.intern(null, "start*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) }));
    const__38 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "start*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })), RT.keyword(null, "doc"), null });
    const__39 = (AFn)((IObj)Symbol.intern(null, "status*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) }));
    const__40 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "status*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_")) })), RT.keyword(null, "doc"), null });
    const__41 = (Var)RT.var("clojure.core", "-reset-methods");
    const__42 = (AFn)((IObj)Symbol.intern(null, "IState")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "no-doc"), Boolean.TRUE }));
    const__43 = (Var)RT.var("mount.lite", "throw-started");
    const__44 = (Keyword)RT.keyword(null, "private");
    const__52 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name")) })), RT.keyword(null, "line"), Integer.valueOf(23), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "mount/lite.clj" });
    const__53 = (Var)RT.var("mount.lite", "throw-unstarted");
    const__56 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name")) })), RT.keyword(null, "line"), Integer.valueOf(29), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "mount/lite.clj" });
    const__57 = (Var)RT.var("mount.lite", "throw-not-found");
    const__60 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "var")) })), RT.keyword(null, "line"), Integer.valueOf(35), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "mount/lite.clj" });
    const__61 = (Var)RT.var("clojure.core", "prefer-method");
    const__62 = (Var)RT.var("clojure.core", "print-method");
    const__63 = RT.classForName("java.util.Map");
    const__64 = RT.classForName("clojure.lang.IDeref");
    const__65 = RT.classForName("clojure.lang.IRecord");
    const__66 = (Var)RT.var("mount.lite", "->State");
    const__67 = (Var)RT.var("mount.lite", "map->State");
    const__68 = (Var)RT.var("mount.lite", "var-status=");
    const__71 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "status")) })), RT.keyword(null, "line"), Integer.valueOf(77), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "mount/lite.clj" });
    const__72 = (Var)RT.var("mount.lite", "prune-states");
    const__75 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "states")) })), RT.keyword(null, "line"), Integer.valueOf(82), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "mount/lite.clj" });
    const__76 = (Var)RT.var("mount.lite", "state");
    const__79 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "start"), Symbol.intern(null, "stop"), Symbol.intern(null, "name")), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "name"), "-anonymous-" }), RT.keyword(null, "as"), Symbol.intern(null, "fields") })) })), RT.keyword(null, "doc"), "Create an anonymous state, useful for substituting. Supports three\n  keyword arguments. A required :start expression, an optional :stop\n  expression, and an optional :name for the state.", RT.keyword(null, "line"), Integer.valueOf(108), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "mount/lite.clj" });
    const__80 = (Var)RT.var("mount.lite", "defstate");
    const__83 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Define a state. At least a :start expression should be supplied.\n  Optionally one can define a :stop expression. Supports docstring and\n  attribute map.", RT.keyword(null, "line"), Integer.valueOf(120), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "mount/lite.clj" });
    const__84 = (Var)RT.var("mount.lite", "start");
    const__87 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "up-to-var")) })), RT.keyword(null, "doc"), "Start all the loaded defstates, or only the defstates up to the\n  given state var. Only stopped defstates are started. They are\n  started in the context of the current session.", RT.keyword(null, "line"), Integer.valueOf(136), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "mount/lite.clj" });
    const__88 = (Var)RT.var("mount.lite", "stop");
    const__91 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "down-to-var")) })), RT.keyword(null, "doc"), "Stop all the loaded defstates, or only the defstates down to the\n  given state var. Only started defstates are stopped. They are\n  stopped in the context of the current session.", RT.keyword(null, "line"), Integer.valueOf(158), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "mount/lite.clj" });
    const__92 = (Var)RT.var("mount.lite", "status");
    const__95 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Retrieve status map for all states.", RT.keyword(null, "line"), Integer.valueOf(178), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "mount/lite.clj" });
    const__96 = (Var)RT.var("mount.lite", "with-substitutes");
    const__99 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "var-sub-pairs"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Given a vector with var-state pairs, an inner start function will\n  use the :start expression of the substitutes for the specified\n  vars. Nested `with-substitutes` are merged.", RT.keyword(null, "line"), Integer.valueOf(186), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "mount/lite.clj" });
  }
  
  public static void __init1() {
    const__100 = (Var)RT.var("mount.lite", "with-session");
    const__103 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Creates a new thread, with a new system of states. All states are\n  initially in the stopped status in this thread, regardless of the\n  status in the thread that spawns this new session. This spawned\n  thread and its subthreads will automatically use the states that are\n  started within this thread or subthreads. Exiting the spawned thread\n  will automatically stop all states in this session.\n\n  Returns a map with the spawned :thread and a :promise that will be\n  set to the result of the body or an exception.", RT.keyword(null, "line"), Integer.valueOf(195), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "mount/lite.clj" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("mount.lite__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
