package instaparse;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class abnf__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__3;
  
  public static final AFn const__4;
  
  public static final Var const__5;
  
  public static final AFn const__12;
  
  public static final Var const__13;
  
  public static final AFn const__15;
  
  public static final Keyword const__16;
  
  public static final Var const__17;
  
  public static final Keyword const__18;
  
  public static final Keyword const__19;
  
  public static final Var const__20;
  
  public static final Var const__21;
  
  public static final Var const__22;
  
  public static final Keyword const__23;
  
  public static final Keyword const__24;
  
  public static final Var const__25;
  
  public static final Keyword const__26;
  
  public static final Keyword const__27;
  
  public static final Keyword const__28;
  
  public static final Keyword const__29;
  
  public static final Keyword const__30;
  
  public static final Keyword const__31;
  
  public static final Keyword const__32;
  
  public static final Keyword const__33;
  
  public static final Keyword const__34;
  
  public static final Keyword const__35;
  
  public static final Keyword const__36;
  
  public static final Var const__37;
  
  public static final AFn const__39;
  
  public static final Var const__40;
  
  public static final AFn const__42;
  
  public static final Var const__43;
  
  public static final AFn const__45;
  
  public static final Var const__46;
  
  public static final AFn const__51;
  
  public static final Var const__52;
  
  public static final AFn const__54;
  
  public static final Var const__55;
  
  public static final Keyword const__56;
  
  public static final Var const__57;
  
  public static final Var const__58;
  
  public static final Var const__59;
  
  public static final AFn const__62;
  
  public static final Var const__63;
  
  public static final AFn const__66;
  
  public static final Var const__67;
  
  public static final AFn const__70;
  
  public static final Var const__71;
  
  public static final AFn const__74;
  
  public static final Var const__75;
  
  public static final AFn const__78;
  
  public static final Var const__79;
  
  public static final AFn const__82;
  
  public static final Var const__83;
  
  public static final AFn const__85;
  
  public static final Keyword const__86;
  
  public static final Var const__87;
  
  public static final Keyword const__88;
  
  public static final Keyword const__89;
  
  public static final Var const__90;
  
  public static final Keyword const__91;
  
  public static final Keyword const__92;
  
  public static final Var const__93;
  
  public static final Keyword const__94;
  
  public static final Keyword const__95;
  
  public static final Keyword const__96;
  
  public static final Keyword const__97;
  
  public static final Var const__98;
  
  public static final Keyword const__99;
  
  public static final Var const__100;
  
  public static final Keyword const__101;
  
  public static final Keyword const__102;
  
  public static final Keyword const__103;
  
  public static final Keyword const__104;
  
  public static final Keyword const__105;
  
  public static final Keyword const__106;
  
  public static final Var const__107;
  
  public static final Var const__108;
  
  public static final Keyword const__109;
  
  public static final Keyword const__110;
  
  public static final Keyword const__111;
  
  public static final Keyword const__112;
  
  public static final Keyword const__113;
  
  public static final Var const__114;
  
  public static final AFn const__117;
  
  public static final Var const__118;
  
  public static final AFn const__121;
  
  public static final Var const__122;
  
  public static final AFn const__125;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new abnf.fn__19975());
    const__5.setDynamic(true).setMeta((IPersistentMap)const__12);
    const__5.setDynamic(true).bindRoot(Boolean.FALSE);
    const__13.setMeta((IPersistentMap)const__15);
    const__13
























      
      .bindRoot(RT.mapUniqueKeys(new Object[] { 
            const__16, ((IFn)const__17.getRawRoot()).invoke("\r\n"), const__18, ((IFn)const__17.getRawRoot())



            
            .invoke("\t"), const__19, ((IFn)const__20.getRawRoot())
            
            .invoke(((IFn)const__20.getRawRoot()).invoke(((IFn)const__17.getRawRoot()).invoke(" "), ((IFn)const__17.getRawRoot()).invoke("\t")), ((IFn)const__21.getRawRoot())
              .invoke(((IFn)const__22.getRawRoot())
                .invoke(((IFn)const__17.getRawRoot()).invoke("\r\n"), ((IFn)const__20.getRawRoot())
                  .invoke(((IFn)const__17.getRawRoot()).invoke(" "), ((IFn)const__17.getRawRoot()).invoke("\t"))))), const__23, ((IFn)const__17.getRawRoot()).invoke("\n"), const__24, ((IFn)const__25.getRawRoot())

            
            .invoke("[\\u0021-\\u007E]"), 
            const__26, ((IFn)const__25.getRawRoot()).invoke("[0-9]"), const__27, ((IFn)const__17.getRawRoot()).invoke(" "), const__28, ((IFn)const__25.getRawRoot()).invoke("[0-9a-fA-F]"), const__29, ((IFn)const__25.getRawRoot()).invoke("[\\u0000-\\u001F|\\u007F]"), const__30, ((IFn)const__17.getRawRoot()).invoke("\""), 
            const__31, ((IFn)const__20.getRawRoot()).invoke(((IFn)const__17.getRawRoot()).invoke(" "), ((IFn)const__17.getRawRoot())
              .invoke("\t")), const__32, ((IFn)const__17.getRawRoot()).invoke("\r"), const__33, ((IFn)const__25.getRawRoot()).invoke("[\\u0000-\\u00FF]"), const__34, ((IFn)const__25.getRawRoot()).invoke("[a-zA-Z]"), const__35, ((IFn)const__25.getRawRoot()).invoke("[\\u0001-\\u007F]"), 
            const__36, ((IFn)const__25.getRawRoot()).invoke("[01]") }));
    const__37.setMeta((IPersistentMap)const__39);
    const__37.bindRoot("\n<rulelist> = <opt-whitespace> (rule | hide-tag-rule)+;\nrule = rulename-left <defined-as> alternation <opt-whitespace>;\nhide-tag-rule = hide-tag <defined-as> alternation <opt-whitespace>;\nrulename-left = rulename;\nrulename-right = rulename;\n<hide-tag> = <'<' opt-whitespace> rulename-left <opt-whitespace '>'>;\ndefined-as = <opt-whitespace> ('=' | '=/') <opt-whitespace>;\nalternation = concatenation (<opt-whitespace '/' opt-whitespace> concatenation)*;\nconcatenation = repetition (<whitespace> repetition)*;\nrepetition = [repeat] <opt-whitespace> element;\nrepeat = NUM | (NUM? '*' NUM?);\n<element> = rulename-right | group | hide | option | char-val | num-val\n          | look | neg | regexp;\nlook = <'&' opt-whitespace> element;\nneg = <'!' opt-whitespace> element;\n<group> = <'(' opt-whitespace> alternation <opt-whitespace ')'>;\noption = <'[' opt-whitespace> alternation <opt-whitespace ']'>;\nhide = <'<' opt-whitespace> alternation <opt-whitespace '>'>;\nchar-val = <'\\u0022'> #'[\\u0020-\\u0021\\u0023-\\u007E]'* <'\\u0022'> (* double-quoted strings *)\n         | <'\\u0027'> #'[\\u0020-\\u0026(-~]'* <'\\u0027'>;  (* single-quoted strings *)\n<num-val> = <'%'> (bin-val | dec-val | hex-val);\nbin-val = <'b'> bin-char\n          [ (<'.'> bin-char)+ | ('-' bin-char) ];\nbin-char = ('0' | '1')+;\ndec-val = <'d'> dec-char\n          [ (<'.'> dec-char)+ | ('-' dec-char) ];\ndec-char = DIGIT+;\nhex-val = <'x'> hex-char\n          [ (<'.'> hex-char)+ | ('-' hex-char) ];\nhex-char = HEXDIG+;\nNUM = DIGIT+;\n<DIGIT> = #'[0-9]';\n<HEXDIG> = #'[0-9a-fA-F]';\n\n\n(* extra entrypoint to be used by the abnf combinator *)\n<rules-or-parser> = rulelist | alternation;\n  ");
    const__40.setMeta((IPersistentMap)const__42);
    const__40.bindRoot("\n<rulename> = #'[a-zA-Z][-a-zA-Z0-9]*(?x) #identifier';\nopt-whitespace = #'\\s*(?:;.*?(?:\\u000D?\\u000A\\s*|$))*(?x) # optional whitespace or comments';\nwhitespace = #'\\s+(?:;.*?\\u000D?\\u000A\\s*)*(?x) # whitespace or comments';\nregexp = #\"#'[^'\\\\]*(?:\\\\.[^'\\\\]*)*'(?x) #Single-quoted regexp\"\n       | #\"#\\\"[^\\\"\\\\]*(?:\\\\.[^\\\"\\\\]*)*\\\"(?x) #Double-quoted regexp\"\n");
    const__43.setMeta((IPersistentMap)const__45);
    const__43.bindRoot("\n<rulename> = #'[a-zA-Z][-a-zA-Z0-9]*';\nopt-whitespace = #'\\s*(?:;.*?(?:\\u000D?\\u000A\\s*|$))*';\nwhitespace = #'\\s+(?:;.*?\\u000D?\\u000A\\s*)*';\nregexp = #\"#'[^'\\\\]*(?:\\\\.[^'\\\\]*)*'\"\n       | #\"#\\\"[^\\\"\\\\]*(?:\\\\.[^\\\"\\\\]*)*\\\"\"\n");
    const__46.setMeta((IPersistentMap)const__51);
    const__46.bindRoot(new abnf.precompile_cljs_grammar());
    ((Var)const__46).setMacro();
    const__52.setMeta((IPersistentMap)const__54);
    const__52



















      
      .bindRoot(((IFn)const__55.getRawRoot()).invoke(const__56, ((IFn)const__57.getRawRoot())
          .invoke(((IFn)const__58.getRawRoot()).invoke(const__37.getRawRoot(), const__40.getRawRoot()))));
    const__59.setMeta((IPersistentMap)const__62);
    const__59.bindRoot(new abnf.get_char_combinator());
    const__63.setMeta((IPersistentMap)const__66);
    const__63.bindRoot(new abnf.project());
    const__67.setMeta((IPersistentMap)const__70);
    const__67.bindRoot(new abnf.merge_core());
    const__71.setMeta((IPersistentMap)const__74);
    const__71.bindRoot(new abnf.hide_tag_QMARK_());
    const__75.setMeta((IPersistentMap)const__78);
    const__75.bindRoot(new abnf.alt_preserving_hide_tag());
    const__79.setMeta((IPersistentMap)const__82);
    const__79.bindRoot(new abnf.parse_int());
    const__83.setMeta((IPersistentMap)const__85);
    const__83.bindRoot(RT.mapUniqueKeys(new Object[] { 
            const__86, const__87.getRawRoot(), const__88, new abnf.fn__20021(), const__89, const__90.getRawRoot(), const__91, new abnf.fn__20023(), const__92, const__93.getRawRoot(), 
            const__94, new abnf.fn__20025(), const__95, new abnf.fn__20027(), const__96, new abnf.fn__20029(), const__97, const__98.getRawRoot(), const__99, const__100.getRawRoot(), 
            const__101, new abnf.fn__20031(), const__102, const__59.getRawRoot(), const__103, const__59.getRawRoot(), const__104, const__22.getRawRoot(), const__105, const__20.getRawRoot(), 
            const__106, ((IFn)const__107.getRawRoot()).invoke(const__25.getRawRoot(), const__108.getRawRoot()), const__109, new abnf.fn__20033(), const__110, new abnf.fn__20037(), const__111, new abnf.fn__20039(), const__112, const__59.getRawRoot(), 
            const__113, new abnf.fn__20042() }));
    const__114.setMeta((IPersistentMap)const__117);
    const__114.bindRoot(new abnf.rules__GT_grammar_map());
    const__118.setMeta((IPersistentMap)const__121);
    const__118.bindRoot(new abnf.abnf());
    const__122.setMeta((IPersistentMap)const__125);
    const__122.bindRoot(new abnf.build_parser());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "instaparse.abnf")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "This is the context free grammar that recognizes ABNF notation." }));
    const__3 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "This is the context free grammar that recognizes ABNF notation." });
    const__4 = (AFn)Symbol.intern(null, "clojure.core");
    const__5 = (Var)RT.var("instaparse.abnf", "*case-insensitive*");
    const__12 = (AFn)RT.map(new Object[] { RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(16), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "instaparse/abnf.clj", RT.keyword(null, "doc"), "This is normally set to false, in which case the non-terminals\nare treated as case-sensitive, which is NOT the norm\nfor ABNF grammars. If you really want case-insensitivity,\nbind this to true, in which case all non-terminals\nwill be converted to upper-case internally (which\nyou'll have to keep in mind when transforming)." });
    const__13 = (Var)RT.var("instaparse.abnf", "abnf-core");
    const__15 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(25), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "instaparse/abnf.clj" });
    const__16 = (Keyword)RT.keyword(null, "CRLF");
    const__17 = (Var)RT.var("instaparse.combinators-source", "string");
    const__18 = (Keyword)RT.keyword(null, "HTAB");
    const__19 = (Keyword)RT.keyword(null, "LWSP");
    const__20 = (Var)RT.var("instaparse.combinators-source", "alt");
    const__21 = (Var)RT.var("instaparse.combinators-source", "star");
    const__22 = (Var)RT.var("instaparse.combinators-source", "cat");
    const__23 = (Keyword)RT.keyword(null, "LF");
    const__24 = (Keyword)RT.keyword(null, "VCHAR");
    const__25 = (Var)RT.var("instaparse.combinators-source", "regexp");
    const__26 = (Keyword)RT.keyword(null, "DIGIT");
    const__27 = (Keyword)RT.keyword(null, "SP");
    const__28 = (Keyword)RT.keyword(null, "HEXDIG");
    const__29 = (Keyword)RT.keyword(null, "CTL");
    const__30 = (Keyword)RT.keyword(null, "DQUOTE");
    const__31 = (Keyword)RT.keyword(null, "WSP");
    const__32 = (Keyword)RT.keyword(null, "CR");
    const__33 = (Keyword)RT.keyword(null, "OCTET");
    const__34 = (Keyword)RT.keyword(null, "ALPHA");
    const__35 = (Keyword)RT.keyword(null, "CHAR");
    const__36 = (Keyword)RT.keyword(null, "BIT");
    const__37 = (Var)RT.var("instaparse.abnf", "abnf-grammar-common");
    const__39 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(47), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "instaparse/abnf.clj" });
    const__40 = (Var)RT.var("instaparse.abnf", "abnf-grammar-clj-only");
    const__42 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(88), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "instaparse/abnf.clj" });
    const__43 = (Var)RT.var("instaparse.abnf", "abnf-grammar-cljs-only");
    const__45 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(97), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "instaparse/abnf.clj" });
    const__46 = (Var)RT.var("instaparse.abnf", "precompile-cljs-grammar");
    const__51 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "line"), Integer.valueOf(107), RT.keyword(null, "column"), Integer.valueOf(4), RT.keyword(null, "file"), "instaparse/abnf.clj" });
    const__52 = (Var)RT.var("instaparse.abnf", "abnf-parser");
    const__54 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(128), RT.keyword(null, "column"), Integer.valueOf(4), RT.keyword(null, "file"), "instaparse/abnf.clj" });
    const__55 = (Var)RT.var("instaparse.reduction", "apply-standard-reductions");
    const__56 = (Keyword)RT.keyword(null, "hiccup");
    const__57 = (Var)RT.var("instaparse.cfg", "ebnf");
    const__58 = (Var)RT.var("clojure.core", "str");
    const__59 = (Var)RT.var("instaparse.abnf", "get-char-combinator");
    const__62 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "nums")) })), RT.keyword(null, "line"), Integer.valueOf(134), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "instaparse/abnf.clj" });
    const__63 = (Var)RT.var("instaparse.abnf", "project");
    const__66 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m"), Symbol.intern(null, "ks")) })), RT.keyword(null, "doc"), "Restricts map to certain keys", RT.keyword(null, "line"), Integer.valueOf(142), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "instaparse/abnf.clj" });
    const__67 = (Var)RT.var("instaparse.abnf", "merge-core");
    const__70 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "grammar-map")) })), RT.keyword(null, "doc"), "Merges abnf-core map in with parsed grammar map", RT.keyword(null, "line"), Integer.valueOf(150), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "instaparse/abnf.clj" });
    const__71 = (Var)RT.var("instaparse.abnf", "hide-tag?");
    const__74 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p")) })), RT.keyword(null, "doc"), "Tests whether parser was constructed with hide-tag", RT.keyword(null, "line"), Integer.valueOf(157), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "instaparse/abnf.clj" });
    const__75 = (Var)RT.var("instaparse.abnf", "alt-preserving-hide-tag");
    const__78 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p1"), Symbol.intern(null, "p2")) })), RT.keyword(null, "line"), Integer.valueOf(162), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "instaparse/abnf.clj" });
    const__79 = (Var)RT.var("instaparse.abnf", "parse-int");
    const__82 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "string")), Tuple.create(Symbol.intern(null, "string"), Symbol.intern(null, "radix")) })), RT.keyword(null, "line"), Integer.valueOf(176), RT.keyword(null, "column"), Integer.valueOf(4), RT.keyword(null, "file"), "instaparse/abnf.clj" });
    const__83 = (Var)RT.var("instaparse.abnf", "abnf-transformer");
    const__85 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(182), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "instaparse/abnf.clj" });
    const__86 = (Keyword)RT.keyword(null, "neg");
    const__87 = (Var)RT.var("instaparse.combinators-source", "neg");
    const__88 = (Keyword)RT.keyword(null, "hide-tag-rule");
    const__89 = (Keyword)RT.keyword(null, "look");
    const__90 = (Var)RT.var("instaparse.combinators-source", "look");
    const__91 = (Keyword)RT.keyword(null, "bin-char");
    const__92 = (Keyword)RT.keyword(null, "rule");
    const__93 = (Var)RT.var("clojure.core", "hash-map");
    const__94 = (Keyword)RT.keyword(null, "rulename-right");
    const__95 = (Keyword)RT.keyword(null, "NUM");
    const__96 = (Keyword)RT.keyword(null, "char-val");
    const__97 = (Keyword)RT.keyword(null, "hide");
    const__98 = (Var)RT.var("instaparse.combinators-source", "hide");
    const__99 = (Keyword)RT.keyword(null, "option");
  }
  
  public static void __init1() {
    const__100 = (Var)RT.var("instaparse.combinators-source", "opt");
    const__101 = (Keyword)RT.keyword(null, "hex-char");
    const__102 = (Keyword)RT.keyword(null, "bin-val");
    const__103 = (Keyword)RT.keyword(null, "dec-val");
    const__104 = (Keyword)RT.keyword(null, "concatenation");
    const__105 = (Keyword)RT.keyword(null, "alternation");
    const__106 = (Keyword)RT.keyword(null, "regexp");
    const__107 = (Var)RT.var("clojure.core", "comp");
    const__108 = (Var)RT.var("instaparse.cfg", "process-regexp");
    const__109 = (Keyword)RT.keyword(null, "repetition");
    const__110 = (Keyword)RT.keyword(null, "rulename-left");
    const__111 = (Keyword)RT.keyword(null, "repeat");
    const__112 = (Keyword)RT.keyword(null, "hex-val");
    const__113 = (Keyword)RT.keyword(null, "dec-char");
    const__114 = (Var)RT.var("instaparse.abnf", "rules->grammar-map");
    const__117 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rules")) })), RT.keyword(null, "line"), Integer.valueOf(236), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "instaparse/abnf.clj" });
    const__118 = (Var)RT.var("instaparse.abnf", "abnf");
    const__121 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "&"), RT.map(new Object[] { RT.keyword(null, "as"), Symbol.intern(null, "opts") })) })), RT.keyword(null, "doc"), "Takes an ABNF grammar specification string and returns the combinator version.\nIf you give it the right-hand side of a rule, it will return the combinator equivalent.\nIf you give it a series of rules, it will give you back a grammar map.\nUseful for combining with other combinators.", RT.keyword(null, "line"), Integer.valueOf(240), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "instaparse/abnf.clj" });
    const__122 = (Var)RT.var("instaparse.abnf", "build-parser");
    const__125 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "output-format")) })), RT.keyword(null, "line"), Integer.valueOf(258), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "instaparse/abnf.clj" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("instaparse.abnf__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
