package clj_commons.primitive_math;

public class Primitives {
  public static byte toByte(long paramLong) { return (byte)(int)paramLong; }
  
  public static short toShort(long paramLong) { return (short)(int)paramLong; }
  
  public static int toInteger(long paramLong) { return (int)paramLong; }
  
  public static float toFloat(double paramDouble) { return (float)paramDouble; }
  
  public static short reverseShort(long paramLong) { return (short)((short)(int)paramLong << 8 | (char)(int)paramLong >>> '\b'); }
  
  public static int reverseInteger(long paramLong) {
    int i = (int)paramLong;
    return i << 24 | (i & 0xFF00) << 8 | (i & 0xFF0000) >>> 8 | i >>> 24;
  }
  
  public static long reverseLong(long paramLong) { return reverseInteger(paramLong) << 32 | 
      reverseInteger(paramLong >>> 32) & 0xFFFFFFFFL; }
  
  public static boolean isTrue(boolean paramBoolean) { return (paramBoolean == true); }
  
  public static boolean isFalse(boolean paramBoolean) { return !paramBoolean; }
  
  public static boolean and(boolean paramBoolean1, boolean paramBoolean2) { return (paramBoolean1 && paramBoolean2); }
  
  public static boolean or(boolean paramBoolean1, boolean paramBoolean2) { return (paramBoolean1 || paramBoolean2); }
  
  public static boolean not(boolean paramBoolean) { return !paramBoolean; }
  
  public static boolean xor(boolean paramBoolean1, boolean paramBoolean2) { return ((paramBoolean1 || paramBoolean2) && (!paramBoolean1 || !paramBoolean2)); }
  
  public static long bitAnd(long paramLong1, long paramLong2) { return paramLong1 & paramLong2; }
  
  public static long bitOr(long paramLong1, long paramLong2) { return paramLong1 | paramLong2; }
  
  public static long bitXor(long paramLong1, long paramLong2) { return paramLong1 ^ paramLong2; }
  
  public static long bitNot(long paramLong) { return paramLong ^ 0xFFFFFFFFFFFFFFFFL; }
  
  public static long shiftLeft(long paramLong1, long paramLong2) { return paramLong1 << (int)paramLong2; }
  
  public static long shiftRight(long paramLong1, long paramLong2) { return paramLong1 >> (int)paramLong2; }
  
  public static long unsignedShiftRight(long paramLong1, long paramLong2) { return paramLong1 >>> (int)paramLong2; }
  
  public static int unsignedShiftRight(int paramInt, long paramLong) { return paramInt >>> (int)paramLong; }
  
  public static boolean lt(long paramLong1, long paramLong2) { return (paramLong1 < paramLong2); }
  
  public static boolean lt(float paramFloat1, float paramFloat2) { return (paramFloat1 < paramFloat2); }
  
  public static boolean lt(double paramDouble1, double paramDouble2) { return (paramDouble1 < paramDouble2); }
  
  public static boolean lte(double paramDouble1, double paramDouble2) { return (paramDouble1 <= paramDouble2); }
  
  public static boolean lte(float paramFloat1, float paramFloat2) { return (paramFloat1 <= paramFloat2); }
  
  public static boolean lte(long paramLong1, long paramLong2) { return (paramLong1 <= paramLong2); }
  
  public static boolean gt(long paramLong1, long paramLong2) { return (paramLong1 > paramLong2); }
  
  public static boolean gt(float paramFloat1, float paramFloat2) { return (paramFloat1 > paramFloat2); }
  
  public static boolean gt(double paramDouble1, double paramDouble2) { return (paramDouble1 > paramDouble2); }
  
  public static boolean gte(long paramLong1, long paramLong2) { return (paramLong1 >= paramLong2); }
  
  public static boolean gte(float paramFloat1, float paramFloat2) { return (paramFloat1 >= paramFloat2); }
  
  public static boolean gte(double paramDouble1, double paramDouble2) { return (paramDouble1 >= paramDouble2); }
  
  public static boolean eq(long paramLong1, long paramLong2) { return (paramLong1 == paramLong2); }
  
  public static boolean eq(float paramFloat1, float paramFloat2) { return (paramFloat1 == paramFloat2); }
  
  public static boolean eq(double paramDouble1, double paramDouble2) { return (paramDouble1 == paramDouble2); }
  
  public static boolean neq(long paramLong1, long paramLong2) { return (paramLong1 != paramLong2); }
  
  public static boolean neq(float paramFloat1, float paramFloat2) { return (paramFloat1 != paramFloat2); }
  
  public static boolean neq(double paramDouble1, double paramDouble2) { return (paramDouble1 != paramDouble2); }
  
  public static long rem(long paramLong1, long paramLong2) { return paramLong1 % paramLong2; }
  
  public static long inc(long paramLong) { return paramLong + 1L; }
  
  public static float inc(float paramFloat) { return paramFloat + 1.0F; }
  
  public static double inc(double paramDouble) { return paramDouble + 1.0D; }
  
  public static long dec(long paramLong) { return paramLong - 1L; }
  
  public static float dec(float paramFloat) { return paramFloat - 1.0F; }
  
  public static double dec(double paramDouble) { return paramDouble - 1.0D; }
  
  public static boolean isZero(long paramLong) { return (paramLong == 0L); }
  
  public static boolean isZero(float paramFloat) { return (paramFloat == 0.0F); }
  
  public static boolean isZero(double paramDouble) { return (paramDouble == 0.0D); }
  
  public static long add(long paramLong1, long paramLong2) { return paramLong1 + paramLong2; }
  
  public static float add(float paramFloat1, float paramFloat2) { return paramFloat1 + paramFloat2; }
  
  public static double add(double paramDouble1, double paramDouble2) { return paramDouble1 + paramDouble2; }
  
  public static long subtract(long paramLong1, long paramLong2) { return paramLong1 - paramLong2; }
  
  public static float subtract(float paramFloat1, float paramFloat2) { return paramFloat1 - paramFloat2; }
  
  public static double subtract(double paramDouble1, double paramDouble2) { return paramDouble1 - paramDouble2; }
  
  public static long negate(long paramLong) { return -paramLong; }
  
  public static float negate(float paramFloat) { return -paramFloat; }
  
  public static double negate(double paramDouble) { return -paramDouble; }
  
  public static long multiply(long paramLong1, long paramLong2) { return paramLong1 * paramLong2; }
  
  public static float multiply(float paramFloat1, float paramFloat2) { return paramFloat1 * paramFloat2; }
  
  public static double multiply(double paramDouble1, double paramDouble2) { return paramDouble1 * paramDouble2; }
  
  public static long divide(long paramLong1, long paramLong2) { return paramLong1 / paramLong2; }
  
  public static float divide(float paramFloat1, float paramFloat2) { return paramFloat1 / paramFloat2; }
  
  public static double divide(double paramDouble1, double paramDouble2) { return paramDouble1 / paramDouble2; }
  
  public static long max(long paramLong1, long paramLong2) { return (paramLong1 < paramLong2) ? paramLong2 : paramLong1; }
  
  public static long min(long paramLong1, long paramLong2) { return (paramLong1 > paramLong2) ? paramLong2 : paramLong1; }
  
  public static float max(float paramFloat1, float paramFloat2) { return (paramFloat1 < paramFloat2) ? paramFloat2 : paramFloat1; }
  
  public static float min(float paramFloat1, float paramFloat2) { return (paramFloat1 > paramFloat2) ? paramFloat2 : paramFloat1; }
  
  public static double max(double paramDouble1, double paramDouble2) { return (paramDouble1 < paramDouble2) ? paramDouble2 : paramDouble1; }
  
  public static double min(double paramDouble1, double paramDouble2) { return (paramDouble1 > paramDouble2) ? paramDouble2 : paramDouble1; }
}
