package clojure;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;

public class core_deftype__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Var const__2;
  
  public static final AFn const__12;
  
  public static final Var const__13;
  
  public static final AFn const__16;
  
  public static final Var const__17;
  
  public static final AFn const__21;
  
  public static final Var const__22;
  
  public static final AFn const__25;
  
  public static final Var const__26;
  
  public static final AFn const__29;
  
  public static final Var const__30;
  
  public static final AFn const__33;
  
  public static final Var const__34;
  
  public static final AFn const__37;
  
  public static final Var const__38;
  
  public static final AFn const__41;
  
  public static final Var const__42;
  
  public static final AFn const__45;
  
  public static final Var const__46;
  
  public static final AFn const__49;
  
  public static final Var const__50;
  
  public static final AFn const__53;
  
  public static final Var const__54;
  
  public static final AFn const__57;
  
  public static final Var const__58;
  
  public static final AFn const__61;
  
  public static final Var const__62;
  
  public static final AFn const__66;
  
  public static final Var const__67;
  
  public static final AFn const__70;
  
  public static final Var const__71;
  
  public static final AFn const__74;
  
  public static final Var const__75;
  
  public static final AFn const__78;
  
  public static final Var const__79;
  
  public static final AFn const__82;
  
  public static final Var const__83;
  
  public static final AFn const__86;
  
  public static final Var const__87;
  
  public static final AFn const__90;
  
  public static final Var const__91;
  
  public static final AFn const__94;
  
  public static final Var const__95;
  
  public static final AFn const__98;
  
  public static final Var const__99;
  
  public static final AFn const__102;
  
  public static final Var const__103;
  
  public static final AFn const__106;
  
  public static final Var const__107;
  
  public static final AFn const__110;
  
  public static final Var const__111;
  
  public static final AFn const__114;
  
  public static final Var const__115;
  
  public static final AFn const__118;
  
  public static final Var const__119;
  
  public static final AFn const__122;
  
  public static final Var const__123;
  
  public static final AFn const__126;
  
  public static final Var const__127;
  
  public static final AFn const__130;
  
  public static final Var const__131;
  
  public static final AFn const__134;
  
  public static final Var const__135;
  
  public static final AFn const__138;
  
  public static final Var const__139;
  
  public static final AFn const__142;
  
  public static final Var const__143;
  
  public static final AFn const__146;
  
  public static final Var const__147;
  
  public static final AFn const__150;
  
  public static final Var const__151;
  
  public static final AFn const__154;
  
  public static final Var const__155;
  
  public static final AFn const__158;
  
  public static final Var const__159;
  
  public static final AFn const__162;
  
  public static final Var const__163;
  
  public static final AFn const__166;
  
  public static void load() {
    const__2.setMeta((IPersistentMap)const__12);
    const__2.bindRoot(new core.namespace_munge());
    const__13.setMeta((IPersistentMap)const__16);
    const__13.bindRoot(new core.definterface());
    ((Var)const__13)









      
      .setMacro();
    const__17.setMeta((IPersistentMap)const__21);
    const__17.bindRoot(new core.parse_opts());
    const__22.setMeta((IPersistentMap)const__25);
    const__22.bindRoot(new core.parse_impls());
    const__26.setMeta((IPersistentMap)const__29);
    const__26.bindRoot(new core.parse_opts_PLUS_specs());
    const__30.setMeta((IPersistentMap)const__33);
    const__30.bindRoot(new core.reify());
    ((Var)const__30)
















































      
      .setMacro();
    const__34.setMeta((IPersistentMap)const__37);
    const__34.bindRoot(new core.hash_combine());
    const__38.setMeta((IPersistentMap)const__41);
    const__38.bindRoot(new core.munge());
    const__42.setMeta((IPersistentMap)const__45);
    const__42.bindRoot(new core.imap_cons());
    const__46.setMeta((IPersistentMap)const__49);
    const__46.bindRoot(new core.emit_defrecord());
    const__50.setMeta((IPersistentMap)const__53);
    const__50.bindRoot(new core.build_positional_factory());
    const__54.setMeta((IPersistentMap)const__57);
    const__54.bindRoot(new core.validate_fields());
    const__58.setMeta((IPersistentMap)const__61);
    const__58.bindRoot(new core.defrecord());
    ((Var)const__58)
















































































































































































































































      
      .setMacro();
    const__62.setMeta((IPersistentMap)const__66);
    const__62.bindRoot(new core.record_QMARK_());
    const__67.setMeta((IPersistentMap)const__70);
    const__67.bindRoot(new core.emit_deftype_STAR_());
    const__71.setMeta((IPersistentMap)const__74);
    const__71.bindRoot(new core.deftype());
    ((Var)const__71)












































































































      
      .setMacro();
    const__75.setMeta((IPersistentMap)const__78);
    const__75.bindRoot(new core.expand_method_impl_cache());
    const__79.setMeta((IPersistentMap)const__82);
    const__79.bindRoot(new core.super_chain());
    const__83.setMeta((IPersistentMap)const__86);
    const__83.bindRoot(new core.pref());
    const__87.setMeta((IPersistentMap)const__90);
    const__87.bindRoot(new core.find_protocol_impl());
    const__91.setMeta((IPersistentMap)const__94);
    const__91.bindRoot(new core.find_protocol_method());
    const__95.setMeta((IPersistentMap)const__98);
    const__95.bindRoot(new core.protocol_QMARK_());
    const__99.setMeta((IPersistentMap)const__102);
    const__99.bindRoot(new core.implements_QMARK_());
    const__103.setMeta((IPersistentMap)const__106);
    const__103.bindRoot(new core.extends_QMARK_());
    const__107.setMeta((IPersistentMap)const__110);
    const__107.bindRoot(new core.extenders());
    const__111.setMeta((IPersistentMap)const__114);
    const__111.bindRoot(new core.satisfies_QMARK_());
    const__115.setMeta((IPersistentMap)const__118);
    const__115.bindRoot(new core._cache_protocol_fn());
    const__119.setMeta((IPersistentMap)const__122);
    const__119.bindRoot(new core.emit_method_builder());
    const__123.setMeta((IPersistentMap)const__126);
    const__123.bindRoot(new core._reset_methods());
    const__127.setMeta((IPersistentMap)const__130);
    const__127.bindRoot(new core.assert_same_protocol());
    const__131.setMeta((IPersistentMap)const__134);
    const__131.bindRoot(new core.emit_protocol());
    const__135.setMeta((IPersistentMap)const__138);
    const__135.bindRoot(new core.defprotocol());
    ((Var)const__135)
























































































































































































































































































      
      .setMacro();
    const__139.setMeta((IPersistentMap)const__142);
    const__139.bindRoot(new core.extend());
    const__143.setMeta((IPersistentMap)const__146);
    const__143.bindRoot(new core.emit_impl());
    const__147.setMeta((IPersistentMap)const__150);
    const__147.bindRoot(new core.emit_hinted_impl());
    const__151.setMeta((IPersistentMap)const__154);
    const__151.bindRoot(new core.emit_extend_type());
    const__155.setMeta((IPersistentMap)const__158);
    const__155.bindRoot(new core.extend_type());
    ((Var)const__155)


































































































































      
      .setMacro();
    const__159.setMeta((IPersistentMap)const__162);
    const__159.bindRoot(new core.emit_extend_protocol());
    const__163.setMeta((IPersistentMap)const__166);
    const__163.bindRoot(new core.extend_protocol());
    ((Var)const__163)






























      
      .setMacro();
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "clojure.core");
    const__2 = (Var)RT.var("clojure.core", "namespace-munge");
    const__12 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ns")) })), RT.keyword(null, "doc"), "Convert a Clojure namespace name to a legal Java package name.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(13), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__13 = (Var)RT.var("clojure.core", "definterface");
    const__16 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "sigs")) })), RT.keyword(null, "doc"), "Creates a new Java interface with the given name and method sigs.\n  The method return types and parameter types may be specified with type hints,\n  defaulting to Object if omitted.\n\n  (definterface MyInterface\n    (^int method1 [x])\n    (^Bar method2 [^Baz b ^Quux q]))", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(20), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__17 = (Var)RT.var("clojure.core", "parse-opts");
    const__21 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "line"), Integer.valueOf(40), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__22 = (Var)RT.var("clojure.core", "parse-impls");
    const__25 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "specs")) })), RT.keyword(null, "line"), Integer.valueOf(46), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__26 = (Var)RT.var("clojure.core", "parse-opts+specs");
    const__29 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "opts+specs")) })), RT.keyword(null, "line"), Integer.valueOf(53), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__30 = (Var)RT.var("clojure.core", "reify");
    const__33 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "opts+specs")) })), RT.keyword(null, "doc"), "reify is a macro with the following structure:\n\n (reify options* specs*)\n  \n  Currently there are no options.\n\n  Each spec consists of the protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that the first parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations.  Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  The return type can be indicated by a type hint on the method name,\n  and arg types can be indicated by a type hint on arg names. If you\n  leave out all hints, reify will try to match on same name/arity\n  method in the protocol(s)/interface(s) - this is preferred. If you\n  supply any hints at all, no inference is done, so all hints (or\n  default of Object) must be correct, for both arguments and return\n  type. If a method is overloaded in a protocol/interface, multiple\n  independent method definitions must be supplied.  If overloaded with\n  same arity in an interface you must specify complete hints to\n  disambiguate - a missing hint implies Object.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n  \n  (str (let [f \"foo\"] \n       (reify Object \n         (toString [this] f))))\n  == \"foo\"\n\n  (seq (let [f \"foo\"] \n       (reify clojure.lang.Seqable \n         (seq [this] (seq f)))))\n  == (\\f \\o \\o))\n  \n  reify always implements clojure.lang.IObj and transfers meta\n  data of the form to the created object.\n  \n  (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n  == {:k :v}", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(70), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__34 = (Var)RT.var("clojure.core", "hash-combine");
    const__37 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "y")) })), RT.keyword(null, "line"), Integer.valueOf(126), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__38 = (Var)RT.var("clojure.core", "munge");
    const__41 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "line"), Integer.valueOf(129), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__42 = (Var)RT.var("clojure.core", "imap-cons");
    const__45 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "this")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IPersistentMap") })), Symbol.intern(null, "o")) })), RT.keyword(null, "line"), Integer.valueOf(132), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__46 = (Var)RT.var("clojure.core", "emit-defrecord");
    const__49 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "tagname"), Symbol.intern(null, "cname"), Symbol.intern(null, "fields"), Symbol.intern(null, "interfaces"), Symbol.intern(null, "methods"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Do not use this directly - use defrecord", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(148), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__50 = (Var)RT.var("clojure.core", "build-positional-factory");
    const__53 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "nom"), Symbol.intern(null, "classname"), Symbol.intern(null, "fields")) })), RT.keyword(null, "doc"), "Used to build a positional factory for a given type/record.  Because of the\n  limitation of 20 arguments to Clojure functions, this factory needs to be\n  constructed to deal with more arguments.  It does this by building a straight\n  forward type/record ctor call in the <=20 case, and a call to the same\n  ctor pulling the extra args out of the & overage parameter.  Finally, the\n  arity is constrained to the number of expected fields and an ArityException\n  will be thrown at runtime if the actual arg count does not match.", RT.keyword(null, "line"), Integer.valueOf(266), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__54 = (Var)RT.var("clojure.core", "validate-fields");
    const__57 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fields"), Symbol.intern(null, "name")) })), RT.keyword(null, "doc"), "", RT.keyword(null, "line"), Integer.valueOf(293), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__58 = (Var)RT.var("clojure.core", "defrecord");
    const__61 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "fields")), Symbol.intern(null, "&"), Symbol.intern(null, "opts+specs")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(383), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "(defrecord name [fields*]  options* specs*)\n\n  Options are expressed as sequential keywords and arguments (in any order).\n\n  Supported options:\n  :load-ns - if true, importing the record class will cause the\n             namespace in which the record was defined to be loaded.\n             Defaults to false.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args*] body)*\n\n  Dynamically generates compiled bytecode for class with the given\n  name, in a package with the same name as the current namespace, the\n  given fields, and, optionally, methods for protocols and/or\n  interfaces.\n\n  The class will have the (immutable) fields named by\n  fields, which can have type hints. Protocols/interfaces and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations. Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The class will have implementations of several (clojure.lang)\n  interfaces generated automatically: IObj (metadata support) and\n  IPersistentMap, and all of their superinterfaces.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will defined Java .hashCode and .equals consistent with the\n  contract for java.util.Map.\n\n  When AOT compiling, generates compiled bytecode for a class with the\n  given name (a symbol), prepends the current ns as the package, and\n  writes the .class file to the *compile-path* directory.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta,\n  __extmap, __hash and __hasheq are currently reserved and should not\n  be used when defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(312), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__62 = (Var)RT.var("clojure.core", "record?");
    const__66 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x is a record", RT.keyword(null, "added"), "1.6", RT.keyword(null, "static"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(405), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__67 = (Var)RT.var("clojure.core", "emit-deftype*");
    const__70 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "tagname"), Symbol.intern(null, "cname"), Symbol.intern(null, "fields"), Symbol.intern(null, "interfaces"), Symbol.intern(null, "methods"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Do not use this directly - use deftype", RT.keyword(null, "line"), Integer.valueOf(412), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__71 = (Var)RT.var("clojure.core", "deftype");
    const__74 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "fields")), Symbol.intern(null, "&"), Symbol.intern(null, "opts+specs")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(489), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "(deftype name [fields*]  options* specs*)\n\n  Options are expressed as sequential keywords and arguments (in any order).\n\n  Supported options:\n  :load-ns - if true, importing the type class will cause the\n             namespace in which the type was defined to be loaded.\n             Defaults to false.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args*] body)*\n\n  Dynamically generates compiled bytecode for class with the given\n  name, in a package with the same name as the current namespace, the\n  given fields, and, optionally, methods for protocols and/or\n  interfaces. \n\n  The class will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols/interfaces and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly. Fields can be qualified\n  with the metadata :volatile-mutable true or :unsynchronized-mutable\n  true, at which point (set! afield aval) will be supported in method\n  bodies. Note well that mutable fields are extremely difficult to use\n  correctly, and are present only to facilitate the building of higher\n  level constructs, such as Clojure's reference types, in Clojure\n  itself. They are for experts only - if the semantics and\n  implications of :volatile-mutable or :unsynchronized-mutable are not\n  immediately apparent to you, you should not be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations. Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  When AOT compiling, generates compiled bytecode for a class with the\n  given name (a symbol), prepends the current ns as the package, and\n  writes the .class file to the *compile-path* directory.\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta, __extmap, __hash and __hasheq are currently\n  reserved and should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(422), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__75 = (Var)RT.var("clojure.core", "expand-method-impl-cache");
    const__78 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "cache")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.MethodImplCache") })), Symbol.intern(null, "c"), Symbol.intern(null, "f")) })), RT.keyword(null, "line"), Integer.valueOf(508), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__79 = (Var)RT.var("clojure.core", "super-chain");
    const__82 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") }))) })), RT.keyword(null, "line"), Integer.valueOf(525), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__83 = (Var)RT.var("clojure.core", "pref");
    const__86 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "a")), Tuple.create(((IObj)Symbol.intern(null, "a")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") })), ((IObj)Symbol.intern(null, "b")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") }))) })), RT.keyword(null, "line"), Integer.valueOf(529), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__87 = (Var)RT.var("clojure.core", "find-protocol-impl");
    const__90 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "protocol"), Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(535), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__91 = (Var)RT.var("clojure.core", "find-protocol-method");
    const__94 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "protocol"), Symbol.intern(null, "methodk"), Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(546), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__95 = (Var)RT.var("clojure.core", "protocol?");
    const__98 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "maybe-p")) })), RT.keyword(null, "line"), Integer.valueOf(549), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__99 = (Var)RT.var("clojure.core", "implements?");
  }
  
  public static void __init1() {
    const__102 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "protocol"), Symbol.intern(null, "atype")) })), RT.keyword(null, "line"), Integer.valueOf(553), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__103 = (Var)RT.var("clojure.core", "extends?");
    const__106 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "protocol"), Symbol.intern(null, "atype")) })), RT.keyword(null, "doc"), "Returns true if atype extends protocol", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(556), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__107 = (Var)RT.var("clojure.core", "extenders");
    const__110 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "protocol")) })), RT.keyword(null, "doc"), "Returns a collection of the types explicitly extending protocol", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(563), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__111 = (Var)RT.var("clojure.core", "satisfies?");
    const__114 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "protocol"), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns true if x satisfies the protocol", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(569), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__115 = (Var)RT.var("clojure.core", "-cache-protocol-fn");
    const__118 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "pf")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.AFunction") })), Symbol.intern(null, "x"), ((IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") })), ((IObj)Symbol.intern(null, "interf")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.lang.IFn") }))) })), RT.keyword(null, "line"), Integer.valueOf(575), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__119 = (Var)RT.var("clojure.core", "emit-method-builder");
    const__122 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "on-interface"), Symbol.intern(null, "method"), Symbol.intern(null, "on-method"), Symbol.intern(null, "arglists"), Symbol.intern(null, "extend-via-meta")) })), RT.keyword(null, "line"), Integer.valueOf(587), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__123 = (Var)RT.var("clojure.core", "-reset-methods");
    const__126 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "protocol")) })), RT.keyword(null, "line"), Integer.valueOf(628), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__127 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__130 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "protocol-var"), Symbol.intern(null, "method-syms")) })), RT.keyword(null, "line"), Integer.valueOf(633), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__131 = (Var)RT.var("clojure.core", "emit-protocol");
    const__134 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "opts+sigs")) })), RT.keyword(null, "line"), Integer.valueOf(644), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__135 = (Var)RT.var("clojure.core", "defprotocol");
    const__138 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "opts+sigs")) })), RT.keyword(null, "doc"), "A protocol is a named set of named methods and their signatures:\n  (defprotocol AProtocolName\n\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n   ;options\n   :extend-via-metadata true\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in \n  Java parlance). defprotocol is dynamic, has no special compile-time \n  effect, and defines no new types or classes. Implementations of \n  the protocol methods can be provided using extend.\n\n  When :extend-via-metadata is true, values can extend protocols by\n  adding metadata where keys are fully-qualified protocol function\n  symbols and values are function implementations. Protocol\n  implementations are checked first for direct definitions (defrecord,\n  deftype, reify), then metadata definitions, then external\n  extensions (extend, extend-type, extend-protocol)\n\n  defprotocol will automatically generate a corresponding interface,\n  with the same name as the protocol, i.e. given a protocol:\n  my.ns/Protocol, an interface: my.ns.Protocol. The interface will\n  have methods corresponding to the protocol functions, and the\n  protocol will automatically work with instances of the interface.\n\n  Note that you should not use this interface with deftype or\n  reify, as they support the protocol directly:\n\n  (defprotocol P \n    (foo [this]) \n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c] \n   P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n  \n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo \n    (let [x 42]\n      (reify P \n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(704), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__139 = (Var)RT.var("clojure.core", "extend");
    const__142 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "atype"), Symbol.intern(null, "&"), Symbol.intern(null, "proto+mmaps")) })), RT.keyword(null, "doc"), "Implementations of protocol methods can be provided using the extend construct:\n\n  (extend AType\n    AProtocol\n     {:foo an-existing-fn\n      :bar (fn [a b] ...)\n      :baz (fn ([a]...) ([a b] ...)...)}\n    BProtocol \n      {...} \n    ...)\n \n  extend takes a type/class (or interface, see below), and one or more\n  protocol + method map pairs. It will extend the polymorphism of the\n  protocol's methods to call the supplied methods when an AType is\n  provided as the first argument. \n\n  Method maps are maps of the keyword-ized method names to ordinary\n  fns. This facilitates easy reuse of existing fns and fn maps, for\n  code reuse/mixins without derivation or composition. You can extend\n  an interface to a protocol. This is primarily to facilitate interop\n  with the host (e.g. Java) but opens the door to incidental multiple\n  inheritance of implementation since a class can inherit from more\n  than one interface, both of which extend the protocol. It is TBD how\n  to specify which impl to use. You can extend a protocol on nil.\n\n  If you are supplying the definitions explicitly (i.e. not reusing\n  exsting functions or mixin maps), you may find it more convenient to\n  use the extend-type or extend-protocol macros.\n\n  Note that multiple independent extend clauses can exist for the same\n  type, not all protocols need be defined in a single extend call.\n\n  See also:\n  extends?, satisfies?, extenders", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(768), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__143 = (Var)RT.var("clojure.core", "emit-impl");
    const__146 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "fs"))) })), RT.keyword(null, "line"), Integer.valueOf(815), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__147 = (Var)RT.var("clojure.core", "emit-hinted-impl");
    const__150 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "c"), Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "fs"))) })), RT.keyword(null, "line"), Integer.valueOf(819), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__151 = (Var)RT.var("clojure.core", "emit-extend-type");
    const__154 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "c"), Symbol.intern(null, "specs")) })), RT.keyword(null, "line"), Integer.valueOf(831), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__155 = (Var)RT.var("clojure.core", "extend-type");
    const__158 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "t"), Symbol.intern(null, "&"), Symbol.intern(null, "specs")) })), RT.keyword(null, "doc"), "A macro that expands into an extend call. Useful when you are\n  supplying the definitions explicitly inline, extend-type\n  automatically creates the maps required by extend.  Propagates the\n  class as a type hint on the first argument of all fns.\n\n  (extend-type MyType \n    Countable\n      (cnt [c] ...)\n    Foo\n      (bar [x y] ...)\n      (baz ([x] ...) ([x y & zs] ...)))\n\n  expands into:\n\n  (extend MyType\n   Countable\n     {:cnt (fn [c] ...)}\n   Foo\n     {:baz (fn ([x] ...) ([x y & zs] ...))\n      :bar (fn [x y] ...)})", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(836), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__159 = (Var)RT.var("clojure.core", "emit-extend-protocol");
    const__162 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "specs")) })), RT.keyword(null, "line"), Integer.valueOf(861), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_deftype.clj" });
    const__163 = (Var)RT.var("clojure.core", "extend-protocol");
    const__166 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "p"), Symbol.intern(null, "&"), Symbol.intern(null, "specs")) })), RT.keyword(null, "doc"), "Useful when you want to provide several implementations of the same\n  protocol all at once. Takes a single protocol and the implementation\n  of that protocol for one or more types. Expands into calls to\n  extend-type:\n\n  (extend-protocol Protocol\n    AType\n      (foo [x] ...)\n      (bar [x y] ...)\n    BType\n      (foo [x] ...)\n      (bar [x y] ...)\n    AClass\n      (foo [x] ...)\n      (bar [x y] ...)\n    nil\n      (foo [x] ...)\n      (bar [x y] ...))\n\n  expands into:\n\n  (do\n   (clojure.core/extend-type AType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type BType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type AClass Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type nil Protocol \n     (foo [x] ...) \n     (bar [x y] ...)))", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(868), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_deftype.clj" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("clojure.core_deftype__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
