package clojure.java;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.PersistentVector;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class jdbc__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Keyword const__3;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final Var const__7;
  
  public static final Keyword const__8;
  
  public static final Keyword const__10;
  
  public static final Keyword const__12;
  
  public static final Object const__13;
  
  public static final Keyword const__14;
  
  public static final AFn const__15;
  
  public static final Var const__16;
  
  public static final AFn const__19;
  
  public static final Var const__20;
  
  public static final AFn const__24;
  
  public static final Var const__25;
  
  public static final AFn const__28;
  
  public static final Var const__29;
  
  public static final Keyword const__30;
  
  public static final AFn const__34;
  
  public static final Object const__35;
  
  public static final Var const__36;
  
  public static final Var const__37;
  
  public static final Var const__38;
  
  public static final Var const__39;
  
  public static final ISeq const__40;
  
  public static final Var const__41;
  
  public static final Var const__42;
  
  public static final AFn const__46;
  
  public static final Keyword const__47;
  
  public static final AFn const__48;
  
  public static final Keyword const__49;
  
  public static final Keyword const__50;
  
  public static final Keyword const__51;
  
  public static final Keyword const__52;
  
  public static final AFn const__53;
  
  public static final Keyword const__54;
  
  public static final Var const__55;
  
  public static final Var const__56;
  
  public static final Var const__57;
  
  public static final AFn const__58;
  
  public static final AFn const__59;
  
  public static final Keyword const__60;
  
  public static final AFn const__61;
  
  public static final AFn const__62;
  
  public static final Var const__63;
  
  public static final AFn const__64;
  
  public static final Var const__65;
  
  public static final AFn const__68;
  
  public static final Var const__69;
  
  public static final Object const__70;
  
  public static final Object const__71;
  
  public static final Var const__72;
  
  public static final AFn const__74;
  
  public static final AFn const__76;
  
  public static final Var const__77;
  
  public static final AFn const__79;
  
  public static final AFn const__80;
  
  public static final Var const__81;
  
  public static final AFn const__83;
  
  public static final AFn const__84;
  
  public static final Var const__85;
  
  public static final AFn const__87;
  
  public static final AFn const__95;
  
  public static final Var const__96;
  
  public static final AFn const__98;
  
  public static final AFn const__99;
  
  public static final Var const__100;
  
  public static final AFn const__103;
  
  public static final Var const__104;
  
  public static final AFn const__107;
  
  public static final Var const__108;
  
  public static final AFn const__111;
  
  public static final Var const__112;
  
  public static final AFn const__115;
  
  public static final Var const__116;
  
  public static final AFn const__119;
  
  public static final Var const__120;
  
  public static final AFn const__123;
  
  public static final Var const__124;
  
  public static final AFn const__127;
  
  public static final Object const__128;
  
  public static final Var const__129;
  
  public static final ISeq const__130;
  
  public static final AFn const__132;
  
  public static final AFn const__133;
  
  public static final Keyword const__134;
  
  public static final AFn const__135;
  
  public static final AFn const__136;
  
  public static final AFn const__137;
  
  public static final AFn const__138;
  
  public static final Object const__139;
  
  public static final Object const__140;
  
  public static final Var const__141;
  
  public static final ISeq const__142;
  
  public static final AFn const__144;
  
  public static final AFn const__145;
  
  public static final Keyword const__146;
  
  public static final AFn const__147;
  
  public static final AFn const__148;
  
  public static final AFn const__149;
  
  public static final AFn const__150;
  
  public static final Var const__151;
  
  public static final AFn const__154;
  
  public static final Object const__155;
  
  public static final Var const__156;
  
  public static final ISeq const__157;
  
  public static final AFn const__159;
  
  public static final AFn const__160;
  
  public static final Keyword const__161;
  
  public static final AFn const__162;
  
  public static final AFn const__163;
  
  public static final AFn const__164;
  
  public static final AFn const__165;
  
  public static final Object const__166;
  
  public static final Var const__167;
  
  public static final AFn const__170;
  
  public static final Var const__171;
  
  public static final AFn const__174;
  
  public static final Var const__175;
  
  public static final AFn const__178;
  
  public static final Var const__179;
  
  public static final AFn const__182;
  
  public static final Var const__183;
  
  public static final AFn const__185;
  
  public static final Keyword const__186;
  
  public static final Keyword const__187;
  
  public static final Var const__188;
  
  public static final AFn const__190;
  
  public static final Keyword const__191;
  
  public static final Keyword const__192;
  
  public static final Var const__193;
  
  public static final AFn const__195;
  
  public static final Keyword const__196;
  
  public static final Keyword const__197;
  
  public static final Keyword const__198;
  
  public static final Var const__199;
  
  public static final Var const__200;
  
  public static final Var const__201;
  
  public static final Object const__202;
  
  public static final Object const__203;
  
  public static final Var const__204;
  
  public static final AFn const__207;
  
  public static final Var const__208;
  
  public static final AFn const__211;
  
  public static final Var const__212;
  
  public static final AFn const__215;
  
  public static final Var const__216;
  
  public static final AFn const__218;
  
  public static final Var const__219;
  
  public static final AFn const__222;
  
  public static final Var const__223;
  
  public static final AFn const__226;
  
  public static final Var const__227;
  
  public static final AFn const__230;
  
  public static final Var const__231;
  
  public static final AFn const__234;
  
  public static final Var const__235;
  
  public static final AFn const__238;
  
  public static final Var const__239;
  
  public static final AFn const__242;
  
  public static final Var const__243;
  
  public static final AFn const__245;
  
  public static final Keyword const__246;
  
  public static final Keyword const__247;
  
  public static final Keyword const__248;
  
  public static final Keyword const__249;
  
  public static final Keyword const__250;
  
  public static final Var const__251;
  
  public static final AFn const__253;
  
  public static final Var const__254;
  
  public static final Var const__255;
  
  public static final AFn const__258;
  
  public static final Var const__259;
  
  public static final AFn const__262;
  
  public static final Var const__263;
  
  public static final AFn const__266;
  
  public static final Var const__267;
  
  public static final AFn const__270;
  
  public static final Var const__271;
  
  public static final AFn const__274;
  
  public static final Var const__275;
  
  public static final AFn const__278;
  
  public static final Var const__279;
  
  public static final AFn const__282;
  
  public static final Var const__283;
  
  public static final AFn const__286;
  
  public static final Var const__287;
  
  public static final AFn const__290;
  
  public static final Var const__291;
  
  public static final AFn const__294;
  
  public static final Var const__295;
  
  public static final AFn const__298;
  
  public static final Var const__299;
  
  public static final AFn const__302;
  
  public static final Var const__303;
  
  public static final AFn const__306;
  
  public static final Var const__307;
  
  public static final AFn const__310;
  
  public static final Var const__311;
  
  public static final AFn const__314;
  
  public static final Var const__315;
  
  public static final AFn const__318;
  
  public static final Var const__319;
  
  public static final AFn const__322;
  
  public static final Var const__323;
  
  public static final AFn const__326;
  
  public static final Var const__327;
  
  public static final AFn const__330;
  
  public static final Var const__331;
  
  public static final AFn const__334;
  
  public static final Var const__335;
  
  public static final AFn const__338;
  
  public static final Var const__339;
  
  public static final AFn const__342;
  
  public static final Var const__343;
  
  public static final AFn const__346;
  
  public static final Var const__347;
  
  public static final AFn const__350;
  
  public static final Var const__351;
  
  public static final AFn const__354;
  
  public static final Var const__355;
  
  public static final AFn const__358;
  
  public static final Var const__359;
  
  public static final AFn const__362;
  
  public static final Var const__363;
  
  public static final AFn const__366;
  
  public static final Var const__367;
  
  public static final AFn const__370;
  
  public static final Var const__371;
  
  public static final AFn const__374;
  
  public static final Var const__375;
  
  public static final AFn const__378;
  
  public static final Var const__379;
  
  public static final AFn const__382;
  
  public static final Var const__383;
  
  public static final AFn const__386;
  
  public static final Var const__387;
  
  public static final AFn const__390;
  
  public static final Var const__391;
  
  public static final AFn const__394;
  
  public static final Var const__395;
  
  public static final AFn const__398;
  
  public static final Var const__399;
  
  public static final AFn const__402;
  
  public static final Var const__403;
  
  public static final AFn const__406;
  
  public static final Var const__407;
  
  public static final AFn const__410;
  
  public static final Var const__411;
  
  public static final AFn const__414;
  
  public static final Var const__415;
  
  public static final AFn const__418;
  
  public static final Var const__419;
  
  public static final AFn const__422;
  
  public static final Var const__423;
  
  public static final AFn const__426;
  
  public static final Var const__427;
  
  public static final AFn const__430;
  
  public static final Var const__431;
  
  public static final AFn const__434;
  
  public static final Var const__435;
  
  public static final AFn const__438;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new jdbc.fn__24746());
    const__7.setMeta((IPersistentMap)const__15);
    const__7.bindRoot(new jdbc.as_sql_name());
    const__16.setMeta((IPersistentMap)const__19);
    const__16.bindRoot(new jdbc.quoted());
    const__20.setMeta((IPersistentMap)const__24);
    const__20.bindRoot(new jdbc.table_str());
    const__25.setMeta((IPersistentMap)const__28);
    const__25.bindRoot(new jdbc.kv_sql());
    const__29.setMeta((IPersistentMap)const__34);
    const__29.bindRoot(new jdbc.as_properties());
    const__65.setMeta((IPersistentMap)const__68);
    const__65.bindRoot(new jdbc.inc_level());
    const__72.setMeta((IPersistentMap)const__74);
    const__72.bindRoot(const__76);
    const__77.setMeta((IPersistentMap)const__79);
    const__77.bindRoot(const__80);
    const__81.setMeta((IPersistentMap)const__83);
    const__81.bindRoot(const__84);
    const__85.setMeta((IPersistentMap)const__87);
    const__85.bindRoot(const__95);
    const__96.setMeta((IPersistentMap)const__98);
    const__96.bindRoot(const__99);
    const__100.setMeta((IPersistentMap)const__103);
    const__100.bindRoot(new jdbc.parse_properties_uri());
    const__104.setMeta((IPersistentMap)const__107);
    const__104.bindRoot(new jdbc.strip_jdbc());
    const__108.setMeta((IPersistentMap)const__111);
    const__108.bindRoot(new jdbc.when_available());
    ((Var)const__108)






























































































      
      .setMacro();
    const__112.setMeta((IPersistentMap)const__115);
    const__112.bindRoot(new jdbc.modify_connection());
    const__116.setMeta((IPersistentMap)const__119);
    const__116.bindRoot(new jdbc.get_driver_connection());
    const__120.setMeta((IPersistentMap)const__123);
    const__120.bindRoot(new jdbc.get_connection());
    const__124.setMeta((IPersistentMap)const__127);
    const__124.bindRoot(new jdbc.make_cols_unique());
    const__151.setMeta((IPersistentMap)const__154);
    const__151.bindRoot(new jdbc.dft_set_parameters());
    const__167.setMeta((IPersistentMap)const__170);
    const__167.bindRoot(new jdbc.dft_read_columns());
    const__171.setMeta((IPersistentMap)const__174);
    const__171.bindRoot(new jdbc.make_identifier_fn());
    const__175.setMeta((IPersistentMap)const__178);
    const__175.bindRoot(new jdbc.result_set_seq());
    const__179.setMeta((IPersistentMap)const__182);
    const__179.bindRoot(new jdbc.execute_batch());
    const__183.setMeta((IPersistentMap)const__185);
    const__183
























































































      
      .bindRoot(RT.mapUniqueKeys(new Object[] { const__186, Integer.valueOf(ResultSet.CONCUR_READ_ONLY), const__187, Integer.valueOf(ResultSet.CONCUR_UPDATABLE) }));
    const__188.setMeta((IPersistentMap)const__190);
    const__188




      
      .bindRoot(RT.mapUniqueKeys(new Object[] { const__191, Integer.valueOf(ResultSet.HOLD_CURSORS_OVER_COMMIT), const__192, Integer.valueOf(ResultSet.CLOSE_CURSORS_AT_COMMIT) }));
    const__193.setMeta((IPersistentMap)const__195);
    const__193




      
      .bindRoot(RT.mapUniqueKeys(new Object[] { const__196, Integer.valueOf(ResultSet.TYPE_FORWARD_ONLY), const__197, Integer.valueOf(ResultSet.TYPE_SCROLL_INSENSITIVE), const__198, Integer.valueOf(ResultSet.TYPE_SCROLL_SENSITIVE) }));
    const__199





      
      .setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { const__30, ((IFn)const__200.getRawRoot()).invoke(((IFn)const__201.getRawRoot()).invoke(const__70, PersistentVector.EMPTY)), const__8, const__202, const__10, const__203, const__12, const__13, const__14, "clojure/java/jdbc.clj" }));
    const__199.bindRoot(new jdbc.string_array());
    const__204.setMeta((IPersistentMap)const__207);
    const__204.bindRoot(new jdbc.prepare_statement());
    const__208.setMeta((IPersistentMap)const__211);
    const__208.bindRoot(new jdbc.print_sql_exception());
    const__212.setMeta((IPersistentMap)const__215);
    const__212.bindRoot(new jdbc.print_sql_exception_chain());
    const__216.setMeta((IPersistentMap)const__218);
    const__216



















































































      
      .bindRoot(RT.map(new Object[] { Integer.valueOf(Statement.EXECUTE_FAILED), "EXECUTE_FAILED", Integer.valueOf(Statement.SUCCESS_NO_INFO), "SUCCESS_NO_INFO" }));
    const__219.setMeta((IPersistentMap)const__222);
    const__219.bindRoot(new jdbc.print_update_counts());
    const__223.setMeta((IPersistentMap)const__226);
    const__223.bindRoot(new jdbc.db_find_connection());
    const__227.setMeta((IPersistentMap)const__230);
    const__227.bindRoot(new jdbc.db_connection());
    const__231.setMeta((IPersistentMap)const__234);
    const__231.bindRoot(new jdbc.db_set_rollback_only_BANG_());
    const__235.setMeta((IPersistentMap)const__238);
    const__235.bindRoot(new jdbc.db_unset_rollback_only_BANG_());
    const__239.setMeta((IPersistentMap)const__242);
    const__239.bindRoot(new jdbc.db_is_rollback_only());
    const__243.setMeta((IPersistentMap)const__245);
    const__243













































      
      .bindRoot(RT.mapUniqueKeys(new Object[] { const__246, Integer.valueOf(Connection.TRANSACTION_NONE), const__247, Integer.valueOf(Connection.TRANSACTION_READ_COMMITTED), const__248, Integer.valueOf(Connection.TRANSACTION_READ_UNCOMMITTED), const__249, Integer.valueOf(Connection.TRANSACTION_REPEATABLE_READ), const__250, Integer.valueOf(Connection.TRANSACTION_SERIALIZABLE) }));
    const__251.setMeta((IPersistentMap)const__253);
    const__251









      
      .bindRoot(((IFn)const__254.getRawRoot()).invoke(const__243.getRawRoot()));
    const__255.setMeta((IPersistentMap)const__258);
    const__255.bindRoot(new jdbc.get_isolation_level());
    const__259.setMeta((IPersistentMap)const__262);
    const__259.bindRoot(new jdbc.db_transaction_STAR_());
    const__263.setMeta((IPersistentMap)const__266);
    const__263.bindRoot(new jdbc.with_db_transaction());
    ((Var)const__263)




















































































      
      .setMacro();
    const__267.setMeta((IPersistentMap)const__270);
    const__267.bindRoot(new jdbc.with_db_connection());
    ((Var)const__267)












      
      .setMacro();
    const__271.setMeta((IPersistentMap)const__274);
    const__271.bindRoot(new jdbc.with_db_metadata());
    ((Var)const__271)











      
      .setMacro();
    const__275.setMeta((IPersistentMap)const__278);
    const__275.bindRoot(new jdbc.process_result_set());
    const__279.setMeta((IPersistentMap)const__282);
    const__279.bindRoot(new jdbc.metadata_result());
    const__283.setMeta((IPersistentMap)const__286);
    const__283.bindRoot(new jdbc.metadata_query());
    ((Var)const__283)







































      
      .setMacro();
    const__287.setMeta((IPersistentMap)const__290);
    const__287.bindRoot(new jdbc.db_do_commands());
    const__291.setMeta((IPersistentMap)const__294);
    const__291.bindRoot(new jdbc.db_do_execute_prepared_return_keys());
    const__295.setMeta((IPersistentMap)const__298);
    const__295.bindRoot(new jdbc.sql_stmt_QMARK_());
    const__299.setMeta((IPersistentMap)const__302);
    const__299.bindRoot(new jdbc.db_do_prepared_return_keys());
    const__303.setMeta((IPersistentMap)const__306);
    const__303.bindRoot(new jdbc.db_do_execute_prepared_statement());
    const__307.setMeta((IPersistentMap)const__310);
    const__307.bindRoot(new jdbc.db_do_prepared());
    const__311.setMeta((IPersistentMap)const__314);
    const__311.bindRoot(new jdbc.execute_query_with_params());
    const__315.setMeta((IPersistentMap)const__318);
    const__315.bindRoot(new jdbc.db_query_with_resultset_STAR_());
    const__319.setMeta((IPersistentMap)const__322);
    const__319.bindRoot(new jdbc.db_query_with_resultset());
    const__323.setMeta((IPersistentMap)const__326);
    const__323.bindRoot(new jdbc.query());
    const__327.setMeta((IPersistentMap)const__330);
    const__327.bindRoot(new jdbc.get_rs_columns());
    const__331.setMeta((IPersistentMap)const__334);
    const__331.bindRoot(new jdbc.init_reduce_rs());
    const__335.setMeta((IPersistentMap)const__338);
    const__335.bindRoot(new jdbc.reducible_result_set_STAR_());
    const__339.setMeta((IPersistentMap)const__342);
    const__339.bindRoot(new jdbc.reducible_result_set());
    const__343.setMeta((IPersistentMap)const__346);
    const__343.bindRoot(new jdbc.query_reducer());
    const__347.setMeta((IPersistentMap)const__350);
    const__347.bindRoot(new jdbc.mapify_result_set());
    const__351.setMeta((IPersistentMap)const__354);
    const__351.bindRoot(new jdbc.raw_query_reducer());
    const__355.setMeta((IPersistentMap)const__358);
    const__355.bindRoot(new jdbc.reducible_query());
    const__359.setMeta((IPersistentMap)const__362);
    const__359.bindRoot(new jdbc.direction());
    const__363.setMeta((IPersistentMap)const__366);
    const__363.bindRoot(new jdbc.order_by_sql());
    const__367.setMeta((IPersistentMap)const__370);
    const__367.bindRoot(new jdbc.find_by_keys());
    const__371.setMeta((IPersistentMap)const__374);
    const__371.bindRoot(new jdbc.get_by_id());
    const__375.setMeta((IPersistentMap)const__378);
    const__375.bindRoot(new jdbc.execute_BANG_());
    const__379.setMeta((IPersistentMap)const__382);
    const__379.bindRoot(new jdbc.delete_sql());
    const__383.setMeta((IPersistentMap)const__386);
    const__383.bindRoot(new jdbc.delete_BANG_());
    const__387.setMeta((IPersistentMap)const__390);
    const__387.bindRoot(new jdbc.multi_insert_helper());
    const__391.setMeta((IPersistentMap)const__394);
    const__391.bindRoot(new jdbc.insert_helper());
    const__395.setMeta((IPersistentMap)const__398);
    const__395.bindRoot(new jdbc.col_str());
    const__399.setMeta((IPersistentMap)const__402);
    const__399.bindRoot(new jdbc.insert_multi_row_sql());
    const__403.setMeta((IPersistentMap)const__406);
    const__403.bindRoot(new jdbc.insert_single_row_sql());
    const__407.setMeta((IPersistentMap)const__410);
    const__407.bindRoot(new jdbc.insert_rows_BANG_());
    const__411.setMeta((IPersistentMap)const__414);
    const__411.bindRoot(new jdbc.insert_cols_BANG_());
    const__415.setMeta((IPersistentMap)const__418);
    const__415.bindRoot(new jdbc.insert_BANG_());
    const__419.setMeta((IPersistentMap)const__422);
    const__419.bindRoot(new jdbc.insert_multi_BANG_());
    const__423.setMeta((IPersistentMap)const__426);
    const__423.bindRoot(new jdbc.update_sql());
    const__427.setMeta((IPersistentMap)const__430);
    const__427.bindRoot(new jdbc.update_BANG_());
    const__431.setMeta((IPersistentMap)const__434);
    const__431.bindRoot(new jdbc.create_table_ddl());
    const__435.setMeta((IPersistentMap)const__438);
    const__435.bindRoot(new jdbc.drop_table_ddl());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.java.jdbc")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "author"), "Stephen C. Gilardi, Sean Corfield", RT.keyword(null, "doc"), "A Clojure interface to SQL databases via JDBC\n\nclojure.java.jdbc provides a simple abstraction for CRUD (create, read,\nupdate, delete) operations on a SQL database, along with basic transaction\nsupport. Basic DDL operations are also supported (create table, drop table,\naccess to table metadata).\n\nMaps are used to represent records, making it easy to store and retrieve\ndata. Results can be processed using any standard sequence operations.\n\nFor most operations, Java's PreparedStatement is used so your SQL and\nparameters can be represented as simple vectors where the first element\nis the SQL string, with ? for each parameter, and the remaining elements\nare the parameter values to be substituted.\n\nFor more documentation, see:\n\nhttp://clojure-doc.org/articles/ecosystem/java_jdbc/home.html" }));
    const__3 = (Keyword)RT.keyword(null, "doc");
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "author"), "Stephen C. Gilardi, Sean Corfield", RT.keyword(null, "doc"), "A Clojure interface to SQL databases via JDBC\n\nclojure.java.jdbc provides a simple abstraction for CRUD (create, read,\nupdate, delete) operations on a SQL database, along with basic transaction\nsupport. Basic DDL operations are also supported (create table, drop table,\naccess to table metadata).\n\nMaps are used to represent records, making it easy to store and retrieve\ndata. Results can be processed using any standard sequence operations.\n\nFor most operations, Java's PreparedStatement is used so your SQL and\nparameters can be represented as simple vectors where the first element\nis the SQL string, with ? for each parameter, and the remaining elements\nare the parameter values to be substituted.\n\nFor more documentation, see:\n\nhttp://clojure-doc.org/articles/ecosystem/java_jdbc/home.html" });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.core", "*warn-on-reflection*");
    const__7 = (Var)RT.var("clojure.java.jdbc", "as-sql-name");
    const__8 = (Keyword)RT.keyword(null, "arglists");
    const__10 = (Keyword)RT.keyword(null, "line");
    const__12 = (Keyword)RT.keyword(null, "column");
    const__13 = Integer.valueOf(1);
    const__14 = (Keyword)RT.keyword(null, "file");
    const__15 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Given a naming strategy function and a keyword or string, return\n   a string per that naming strategy.\n   A name of the form x.y is treated as multiple names, x, y, etc,\n   and each are turned into strings via the naming strategy and then\n   joined back together so x.y might become `x`.`y` if the naming\n   strategy quotes identifiers with `.", RT.keyword(null, "line"), Integer.valueOf(53), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__16 = (Var)RT.var("clojure.java.jdbc", "quoted");
    const__19 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "q")) })), RT.keyword(null, "doc"), "Given a (vector) pair of delimiters (characters or strings), return a naming\n  strategy function that will quote SQL entities with them.\n  Given a single delimiter, treat it as a (vector) pair of that delimiter.\n    ((quoted [\\[ \\]]) \"foo\") will return \"[foo]\" -- for MS SQL Server\n    ((quoted \\`') \"foo\") will return \"`foo`\" -- for MySQL\n  Intended to be used with :entities to provide a quoting (naming) strategy that\n  is appropriate for your database.", RT.keyword(null, "line"), Integer.valueOf(67), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__20 = (Var)RT.var("clojure.java.jdbc", "table-str");
    const__24 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "table"), Symbol.intern(null, "entities")) })), RT.keyword(null, "doc"), "Transform a table spec to an entity name for SQL. The table spec may be a\n  string, a keyword or a map with a single pair - table name and alias.", RT.keyword(null, "line"), Integer.valueOf(88), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__25 = (Var)RT.var("clojure.java.jdbc", "kv-sql");
    const__28 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ks"), Symbol.intern(null, "vs"), Symbol.intern(null, "entities"), Symbol.intern(null, "null-op")) })), RT.keyword(null, "doc"), "Given a sequence of column name keys and a matching sequence of column\n  values, and an entities mapping function, return a sequence of SQL fragments\n  that can be joined for part of an UPDATE SET or a SELECT WHERE clause.\n  Note that we pass the appropriate operator for NULL since it is different\n  in each case.", RT.keyword(null, "line"), Integer.valueOf(98), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__29 = (Var)RT.var("clojure.java.jdbc", "as-properties");
    const__30 = (Keyword)RT.keyword(null, "tag");
    const__34 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.util.Properties"), RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), "Convert any seq of pairs to a java.utils.Properties instance.\n   Uses as-sql-name to convert both keys and values into strings.", RT.keyword(null, "line"), Integer.valueOf(110), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__35 = RT.classForName("clojure.java.jdbc.Connectable");
    const__36 = (Var)RT.var("clojure.core", "alter-meta!");
    const__37 = (Var)RT.var("clojure.java.jdbc", "Connectable");
    const__38 = (Var)RT.var("clojure.core", "assoc");
    const__39 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__40 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "add-connection")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "connection")) })) })), ((IObj)Symbol.intern(null, "get-level")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db")) })) })) }));
    const__41 = (Var)RT.var("clojure.core", "alter-var-root");
    const__42 = (Var)RT.var("clojure.core", "merge");
    const__46 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.java.jdbc.Connectable"), RT.keyword(null, "on-interface"), RT.classForName("clojure.java.jdbc.Connectable") });
    const__47 = (Keyword)RT.keyword(null, "sigs");
    const__48 = (AFn)RT.map(new Object[] { RT.keyword(null, "add-connection"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "add-connection")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "connection")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "connection")) })), RT.keyword(null, "doc"), null }), RT.keyword(null, "get-level"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-level")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db")) })), RT.keyword(null, "doc"), null }) });
    const__49 = (Keyword)RT.keyword(null, "var");
    const__50 = (Keyword)RT.keyword(null, "method-map");
    const__51 = (Keyword)RT.keyword(null, "get-level");
    const__52 = (Keyword)RT.keyword(null, "add-connection");
    const__53 = (AFn)RT.map(new Object[] { RT.keyword(null, "get-level"), RT.keyword(null, "get-level"), RT.keyword(null, "add-connection"), RT.keyword(null, "add-connection") });
    const__54 = (Keyword)RT.keyword(null, "method-builders");
    const__55 = (Var)RT.var("clojure.core", "intern");
    const__56 = (Var)RT.var("clojure.core", "*ns*");
    const__57 = (Var)RT.var("clojure.core", "with-meta");
    const__58 = (AFn)((IObj)Symbol.intern(null, "add-connection")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "connection")) })) }));
    const__59 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "add-connection")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "connection")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "connection")) })), RT.keyword(null, "doc"), null });
    const__60 = (Keyword)RT.keyword(null, "protocol");
    const__61 = (AFn)((IObj)Symbol.intern(null, "get-level")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db")) })) }));
    const__62 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-level")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db")) })), RT.keyword(null, "doc"), null });
    const__63 = (Var)RT.var("clojure.core", "-reset-methods");
    const__64 = (AFn)Symbol.intern(null, "Connectable");
    const__65 = (Var)RT.var("clojure.java.jdbc", "inc-level");
    const__68 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db")) })), RT.keyword(null, "doc"), "Increment the nesting level for a transacted database connection.\n   If we are at the top level, also add in a rollback state.", RT.keyword(null, "line"), Integer.valueOf(127), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__69 = (Var)RT.var("clojure.core", "extend");
    const__70 = RT.classForName("java.lang.String");
    const__71 = RT.classForName("clojure.lang.Associative");
    const__72 = (Var)RT.var("clojure.java.jdbc", "classnames");
    const__74 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(149), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj", RT.keyword(null, "doc"), "Map of subprotocols to classnames. dbtype specifies one of these keys.\n\n  The subprotocols map below provides aliases for dbtype.\n\n  Most databases have just a single class name for their driver but we\n  support a sequence of class names to try in order to allow for drivers\n  that change their names over time (e.g., MySQL)." });
    const__76 = (AFn)RT.map(new Object[] { 
          "h2:mem", "org.h2.Driver", "mysql", Tuple.create("com.mysql.cj.jdbc.Driver", "com.mysql.jdbc.Driver"), "oracle:thin", "oracle.jdbc.OracleDriver", "pgsql", "com.impossibl.postgres.jdbc.PGDriver", "oracle:oci", "oracle.jdbc.OracleDriver", 
          "postgresql", "org.postgresql.Driver", "sqlite", "org.sqlite.JDBC", "h2", "org.h2.Driver", "jtds:sqlserver", "net.sourceforge.jtds.jdbc.Driver", "hsqldb", "org.hsqldb.jdbcDriver", 
          "redshift", "com.amazon.redshift.jdbc.Driver", "derby", "org.apache.derby.jdbc.EmbeddedDriver", "sqlserver", "com.microsoft.sqlserver.jdbc.SQLServerDriver" });
    const__77 = (Var)RT.var("clojure.java.jdbc", "subprotocols");
    const__79 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(172), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj", RT.keyword(null, "doc"), "Map of schemes to subprotocols. Used to provide aliases for dbtype." });
    const__80 = (AFn)RT.map(new Object[] { 
          "hsql", "hsqldb", "jtds", "jtds:sqlserver", "mssql", "sqlserver", "oracle", "oracle:thin", "oracle:sid", "oracle:thin", 
          "postgres", "postgresql" });
    const__81 = (Var)RT.var("clojure.java.jdbc", "host-prefixes");
    const__83 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(181), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj", RT.keyword(null, "doc"), "Map of subprotocols to non-standard host-prefixes.\n  Anything not listed is assumed to use //." });
    const__84 = (AFn)RT.map(new Object[] { "oracle:oci", "@", "oracle:thin", "@" });
    const__85 = (Var)RT.var("clojure.java.jdbc", "ports");
    const__87 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(187), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj", RT.keyword(null, "doc"), "Map of subprotocols to ports." });
    const__95 = (AFn)RT.map(new Object[] { 
          "jtds:sqlserver", Long.valueOf(1433L), "mysql", Long.valueOf(3306L), "oracle:oci", Long.valueOf(1521L), "oracle:sid", Long.valueOf(1521L), "oracle:thin", Long.valueOf(1521L), 
          "postgresql", Long.valueOf(5432L), "sqlserver", Long.valueOf(1433L) });
    const__96 = (Var)RT.var("clojure.java.jdbc", "dbname-separators");
    const__98 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(197), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj", RT.keyword(null, "doc"), "Map of schemes to separators. The default is / but a couple are different." });
    const__99 = (AFn)RT.map(new Object[] { "mssql", ";DATABASENAME=", "sqlserver", ";DATABASENAME=", "oracle:sid", ":" });
  }
  
  public static void __init1() {
    const__100 = (Var)RT.var("clojure.java.jdbc", "parse-properties-uri");
    const__103 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "uri")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "URI") }))) })), RT.keyword(null, "line"), Integer.valueOf(203), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__104 = (Var)RT.var("clojure.java.jdbc", "strip-jdbc");
    const__107 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "spec")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))) })), RT.keyword(null, "line"), Integer.valueOf(226), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__108 = (Var)RT.var("clojure.java.jdbc", "when-available");
    const__111 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "sym"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "line"), Integer.valueOf(232), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__112 = (Var)RT.var("clojure.java.jdbc", "modify-connection");
    const__115 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(((IObj)Symbol.intern(null, "connection")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.sql.Connection") })), Symbol.intern(null, "opts"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.sql.Connection") })) })), RT.keyword(null, "doc"), "Given a database connection and a map of options, update the connection\n  as specified by the options.", RT.keyword(null, "line"), Integer.valueOf(239), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__116 = (Var)RT.var("clojure.java.jdbc", "get-driver-connection");
    const__119 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { RT.vector(new Object[] { Symbol.intern(null, "classname"), Symbol.intern(null, "subprotocol"), Symbol.intern(null, "db-spec"), Symbol.intern(null, "url"), Symbol.intern(null, "etc"), Symbol.intern(null, "opts"), Symbol.intern(null, "error-msg") }) })), RT.keyword(null, "doc"), "Common logic for loading the DriverManager and the designed JDBC driver\n  class and obtaining the appropriate Connection object.", RT.keyword(null, "line"), Integer.valueOf(250), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__120 = (Var)RT.var("clojure.java.jdbc", "get-connection");
    const__123 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "db-spec"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.sql.Connection") })), ((IObj)Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), RT.vector(new Object[] { 
                          Symbol.intern(null, "connection"), Symbol.intern(null, "factory"), Symbol.intern(null, "connection-uri"), Symbol.intern(null, "classname"), Symbol.intern(null, "subprotocol"), Symbol.intern(null, "subname"), Symbol.intern(null, "dbtype"), Symbol.intern(null, "dbname"), Symbol.intern(null, "host"), Symbol.intern(null, "port"), 
                          Symbol.intern(null, "datasource"), Symbol.intern(null, "username"), Symbol.intern(null, "password"), Symbol.intern(null, "user"), Symbol.intern(null, "name"), Symbol.intern(null, "environment") }), RT.keyword(null, "as"), Symbol.intern(null, "db-spec") }), Symbol.intern(null, "opts"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.sql.Connection") })) })), RT.keyword(null, "doc"), "Creates a connection to a database. db-spec is usually a map containing connection\n  parameters but can also be a URI or a String.\n\n  The only time you should call this function is when you need a Connection for\n  prepare-statement -- no other public functions in clojure.java.jdbc accept a\n  raw Connection object: they all expect a db-spec (either a raw db-spec or one\n  obtained via with-db-connection or with-db-transaction).\n\n  The correct usage of get-connection for prepare-statement is:\n\n      (with-open [conn (jdbc/get-connection db-spec)]\n        ... (jdbc/prepare-statement conn sql-statement options) ...)\n\n  Any connection obtained via calling get-connection directly must be closed\n  explicitly (via with-open or a direct call to .close on the Connection object).\n\n  The various possibilities are described below:\n\n  DriverManager (preferred):\n    :dbtype      (required) a String, the type of the database (the jdbc subprotocol)\n    :dbname      (required) a String, the name of the database\n    :classname   (optional) a String, the jdbc driver class name\n    :host        (optional) a String, the host name/IP of the database\n                            (defaults to 127.0.0.1)\n    :port        (optional) a Long, the port of the database\n                            (defaults to 3306 for mysql, 1433 for mssql/jtds, else nil)\n    (others)     (optional) passed to the driver as properties\n                            (may include :user and :password)\n\n  Raw:\n    :connection-uri (required) a String\n                 Passed directly to DriverManager/getConnection\n                 (both :user and :password may be specified as well, rather\n                  than passing them as part of the connection string)\n\n  Other formats accepted:\n\n  Existing Connection:\n    :connection  (required) an existing open connection that can be used\n                 but cannot be closed (only the parent connection can be closed)\n\n  DriverManager (alternative / legacy style):\n    :subprotocol (required) a String, the jdbc subprotocol\n    :subname     (required) a String, the jdbc subname\n    :classname   (optional) a String, the jdbc driver class name\n    (others)     (optional) passed to the driver as properties\n                            (may include :user and :password)\n\n  Factory:\n    :factory     (required) a function of one argument, a map of params\n    (others)     (optional) passed to the factory function in a map\n\n  DataSource:\n    :datasource  (required) a javax.sql.DataSource\n    :username    (optional) a String - deprecated, use :user instead\n    :user        (optional) a String - preferred\n    :password    (optional) a String, required if :user is supplied\n\n  JNDI:\n    :name        (required) a String or javax.naming.Name\n    :environment (optional) a java.util.Map\n\n  java.net.URI:\n    Parsed JDBC connection string (see java.lang.String format next)\n\n  java.lang.String:\n    subprotocol://user:password@host:post/subname\n                 An optional prefix of jdbc: is allowed.", RT.keyword(null, "line"), Integer.valueOf(274), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__124 = (Var)RT.var("clojure.java.jdbc", "make-cols-unique");
    const__127 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xf")) })), RT.keyword(null, "doc"), "A transducer that, given a collection of strings, returns a collection of\n  strings that have been made unique by appending _n to duplicates.", RT.keyword(null, "line"), Integer.valueOf(440), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__128 = RT.classForName("clojure.java.jdbc.ISQLValue");
    const__129 = (Var)RT.var("clojure.java.jdbc", "ISQLValue");
    const__130 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "sql-value")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Convert a Clojure value into a SQL value.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val")) })) })) }));
    const__132 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.java.jdbc.ISQLValue"), RT.keyword(null, "on-interface"), RT.classForName("clojure.java.jdbc.ISQLValue"), RT.keyword(null, "doc"), "Protocol for creating SQL values from Clojure values. Default\n   implementations (for Object and nil) just return the argument,\n   but it can be extended to provide custom behavior to support\n   exotic types supported by different databases." });
    const__133 = (AFn)RT.map(new Object[] { RT.keyword(null, "sql-value"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "sql-value")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Convert a Clojure value into a SQL value.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "Convert a Clojure value into a SQL value." }) });
    const__134 = (Keyword)RT.keyword(null, "sql-value");
    const__135 = (AFn)RT.map(new Object[] { RT.keyword(null, "sql-value"), RT.keyword(null, "sql-value") });
    const__136 = (AFn)((IObj)Symbol.intern(null, "sql-value")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Convert a Clojure value into a SQL value.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val")) })) }));
    const__137 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "sql-value")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Convert a Clojure value into a SQL value.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "Convert a Clojure value into a SQL value." });
    const__138 = (AFn)Symbol.intern(null, "ISQLValue");
    const__139 = RT.classForName("java.lang.Object");
    const__140 = RT.classForName("clojure.java.jdbc.ISQLParameter");
    const__141 = (Var)RT.var("clojure.java.jdbc", "ISQLParameter");
    const__142 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "set-parameter")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Convert a Clojure value into a SQL value and store it as the ix'th\n     parameter in the given SQL statement object.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val"), Symbol.intern(null, "stmt"), Symbol.intern(null, "ix")) })) })) }));
    const__144 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.java.jdbc.ISQLParameter"), RT.keyword(null, "on-interface"), RT.classForName("clojure.java.jdbc.ISQLParameter"), RT.keyword(null, "doc"), "Protocol for setting SQL parameters in statement objects, which\n   can convert from Clojure values. The default implementation just\n   delegates the conversion to ISQLValue's sql-value conversion and\n   uses .setObject on the parameter. It can be extended to use other\n   methods of PreparedStatement to convert and set parameter values." });
    const__145 = (AFn)RT.map(new Object[] { RT.keyword(null, "set-parameter"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "set-parameter")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Convert a Clojure value into a SQL value and store it as the ix'th\n     parameter in the given SQL statement object.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val"), Symbol.intern(null, "stmt"), Symbol.intern(null, "ix")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val"), Symbol.intern(null, "stmt"), Symbol.intern(null, "ix")) })), RT.keyword(null, "doc"), "Convert a Clojure value into a SQL value and store it as the ix'th\n     parameter in the given SQL statement object." }) });
    const__146 = (Keyword)RT.keyword(null, "set-parameter");
    const__147 = (AFn)RT.map(new Object[] { RT.keyword(null, "set-parameter"), RT.keyword(null, "set-parameter") });
    const__148 = (AFn)((IObj)Symbol.intern(null, "set-parameter")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Convert a Clojure value into a SQL value and store it as the ix'th\n     parameter in the given SQL statement object.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val"), Symbol.intern(null, "stmt"), Symbol.intern(null, "ix")) })) }));
    const__149 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "set-parameter")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Convert a Clojure value into a SQL value and store it as the ix'th\n     parameter in the given SQL statement object.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val"), Symbol.intern(null, "stmt"), Symbol.intern(null, "ix")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val"), Symbol.intern(null, "stmt"), Symbol.intern(null, "ix")) })), RT.keyword(null, "doc"), "Convert a Clojure value into a SQL value and store it as the ix'th\n     parameter in the given SQL statement object." });
    const__150 = (AFn)Symbol.intern(null, "ISQLParameter");
    const__151 = (Var)RT.var("clojure.java.jdbc", "dft-set-parameters");
    const__154 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "stmt"), Symbol.intern(null, "params")) })), RT.keyword(null, "doc"), "Default implementation of parameter setting for the given statement.", RT.keyword(null, "line"), Integer.valueOf(490), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__155 = RT.classForName("clojure.java.jdbc.IResultSetReadColumn");
    const__156 = (Var)RT.var("clojure.java.jdbc", "IResultSetReadColumn");
    const__157 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "result-set-read-column")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Function for transforming values after reading them from the database", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val"), Symbol.intern(null, "rsmeta"), Symbol.intern(null, "idx")) })) })) }));
    const__159 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.java.jdbc.IResultSetReadColumn"), RT.keyword(null, "on-interface"), RT.classForName("clojure.java.jdbc.IResultSetReadColumn"), RT.keyword(null, "doc"), "Protocol for reading objects from the java.sql.ResultSet. Default\n   implementations (for Object and nil) return the argument, and the\n   Boolean implementation ensures a canonicalized true/false value,\n   but it can be extended to provide custom behavior for special types." });
    const__160 = (AFn)RT.map(new Object[] { RT.keyword(null, "result-set-read-column"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "result-set-read-column")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Function for transforming values after reading them from the database", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val"), Symbol.intern(null, "rsmeta"), Symbol.intern(null, "idx")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val"), Symbol.intern(null, "rsmeta"), Symbol.intern(null, "idx")) })), RT.keyword(null, "doc"), "Function for transforming values after reading them from the database" }) });
    const__161 = (Keyword)RT.keyword(null, "result-set-read-column");
    const__162 = (AFn)RT.map(new Object[] { RT.keyword(null, "result-set-read-column"), RT.keyword(null, "result-set-read-column") });
    const__163 = (AFn)((IObj)Symbol.intern(null, "result-set-read-column")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Function for transforming values after reading them from the database", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val"), Symbol.intern(null, "rsmeta"), Symbol.intern(null, "idx")) })) }));
    const__164 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "result-set-read-column")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Function for transforming values after reading them from the database", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val"), Symbol.intern(null, "rsmeta"), Symbol.intern(null, "idx")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "val"), Symbol.intern(null, "rsmeta"), Symbol.intern(null, "idx")) })), RT.keyword(null, "doc"), "Function for transforming values after reading them from the database" });
    const__165 = (AFn)Symbol.intern(null, "IResultSetReadColumn");
    const__166 = RT.classForName("java.lang.Boolean");
    const__167 = (Var)RT.var("clojure.java.jdbc", "dft-read-columns");
    const__170 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "rs")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ResultSet") })), Symbol.intern(null, "rsmeta"), Symbol.intern(null, "idxs")) })), RT.keyword(null, "doc"), "Default implementation of reading row values from result set, given the\n  result set metadata and the indices.", RT.keyword(null, "line"), Integer.valueOf(516), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__171 = (Var)RT.var("clojure.java.jdbc", "make-identifier-fn");
    const__174 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "identifiers"), Symbol.intern(null, "qualifier"), Symbol.intern(null, "keywordize?")) })), RT.keyword(null, "doc"), "Given the user's identifiers function, an optional namespace qualifier, and\n  a flag indicating whether to produce keywords or not, return a compound\n  function that will perform the appropriate entity to identifier conversion.", RT.keyword(null, "line"), Integer.valueOf(522), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__175 = (Var)RT.var("clojure.java.jdbc", "result-set-seq");
    const__178 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rs")), Tuple.create(((IObj)Symbol.intern(null, "rs")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ResultSet") })), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "as-arrays?"), Symbol.intern(null, "identifiers"), Symbol.intern(null, "keywordize?"), Symbol.intern(null, "qualifier"), Symbol.intern(null, "read-columns")), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "identifiers"), Symbol.intern("str", "lower-case"), Symbol.intern(null, "keywordize?"), Boolean.TRUE, Symbol.intern(null, "read-columns"), Symbol.intern(null, "dft-read-columns") }) })) })), RT.keyword(null, "doc"), "Creates and returns a lazy sequence of maps corresponding to the rows in the\n  java.sql.ResultSet rs. Loosely based on clojure.core/resultset-seq but it\n  respects the specified naming strategy. Duplicate column names are made unique\n  by appending _N before applying the naming strategy (where N is a unique integer),\n  unless the :as-arrays? option is :cols-as-is, in which case the column names\n  are untouched (the result set maintains column name/value order).\n  The :identifiers option specifies how SQL column names are converted to Clojure\n  keywords. The default is to convert them to lower case.\n  The :keywordize? option can be specified as false to opt-out of the conversion\n  to keywords.\n  The :qualifier option specifies the namespace qualifier for those identifiers\n  (and this may not be specified when :keywordize? is false).", RT.keyword(null, "line"), Integer.valueOf(538), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__179 = (Var)RT.var("clojure.java.jdbc", "execute-batch");
    const__182 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "stmt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Statement") }))) })), RT.keyword(null, "doc"), "Executes a batch of SQL commands and returns a sequence of update counts.\n   (-2) indicates a single operation operating on an unknown number of rows.\n   Specifically, Oracle returns that and we must call getUpdateCount() to get\n   the actual number of rows affected. In general, operations return an array\n   of update counts, so this may not be a general solution for Oracle...", RT.keyword(null, "line"), Integer.valueOf(584), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__183 = (Var)RT.var("clojure.java.jdbc", "result-set-concurrency");
    const__185 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "doc"), "Map friendly :concurrency values to ResultSet constants.", RT.keyword(null, "line"), Integer.valueOf(596), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__186 = (Keyword)RT.keyword(null, "read-only");
    const__187 = (Keyword)RT.keyword(null, "updatable");
    const__188 = (Var)RT.var("clojure.java.jdbc", "result-set-holdability");
    const__190 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "doc"), "Map friendly :cursors values to ResultSet constants.", RT.keyword(null, "line"), Integer.valueOf(602), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__191 = (Keyword)RT.keyword(null, "hold");
    const__192 = (Keyword)RT.keyword(null, "close");
    const__193 = (Var)RT.var("clojure.java.jdbc", "result-set-type");
    const__195 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "doc"), "Map friendly :type values to ResultSet constants.", RT.keyword(null, "line"), Integer.valueOf(608), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__196 = (Keyword)RT.keyword(null, "forward-only");
    const__197 = (Keyword)RT.keyword(null, "scroll-insensitive");
    const__198 = (Keyword)RT.keyword(null, "scroll-sensitive");
    const__199 = (Var)RT.var("clojure.java.jdbc", "string-array");
  }
  
  public static void __init2() {
    const__200 = (Var)RT.var("clojure.core", "class");
    const__201 = (Var)RT.var("clojure.core", "into-array");
    const__202 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "return-keys")) }));
    const__203 = Integer.valueOf(615);
    const__204 = (Var)RT.var("clojure.java.jdbc", "prepare-statement");
    const__207 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "con"), Symbol.intern(null, "sql")), Tuple.create(((IObj)Symbol.intern(null, "con")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.sql.Connection") })), ((IObj)Symbol.intern(null, "sql")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })), RT.map(new Object[] { RT.keyword(null, "keys"), RT.vector(new Object[] { Symbol.intern(null, "return-keys"), Symbol.intern(null, "result-type"), Symbol.intern(null, "concurrency"), Symbol.intern(null, "cursors"), Symbol.intern(null, "fetch-size"), Symbol.intern(null, "max-rows"), Symbol.intern(null, "timeout") }) })) })), RT.keyword(null, "doc"), "Create a prepared statement from a connection, a SQL string and a map\n  of options:\n     :return-keys truthy | nil - default nil\n       for some drivers, this may be a vector of column names to identify\n       the generated keys to return, otherwise it should just be true\n     :result-type :forward-only | :scroll-insensitive | :scroll-sensitive\n     :concurrency :read-only | :updatable\n     :cursors     :hold | :close\n     :fetch-size  n\n     :max-rows    n\n     :timeout     n\n  Note that :result-type and :concurrency must be specified together as the\n  underlying Java API expects both (or neither).", RT.keyword(null, "line"), Integer.valueOf(619), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__208 = (Var)RT.var("clojure.java.jdbc", "print-sql-exception");
    const__211 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "exception")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "SQLException") }))) })), RT.keyword(null, "doc"), "Prints the contents of an SQLException to *out*", RT.keyword(null, "line"), Integer.valueOf(678), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__212 = (Var)RT.var("clojure.java.jdbc", "print-sql-exception-chain");
    const__215 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "exception")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "SQLException") }))) })), RT.keyword(null, "doc"), "Prints a chain of SQLExceptions to *out*", RT.keyword(null, "line"), Integer.valueOf(692), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__216 = (Var)RT.var("clojure.java.jdbc", "special-counts");
    const__218 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(700), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__219 = (Var)RT.var("clojure.java.jdbc", "print-update-counts");
    const__222 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "exception")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "BatchUpdateException") }))) })), RT.keyword(null, "doc"), "Prints the update counts from a BatchUpdateException to *out*", RT.keyword(null, "line"), Integer.valueOf(704), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__223 = (Var)RT.var("clojure.java.jdbc", "db-find-connection");
    const__226 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "db"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.sql.Connection") })) })), RT.keyword(null, "doc"), "Returns the current database connection (or nil if there is none)", RT.keyword(null, "line"), Integer.valueOf(718), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__227 = (Var)RT.var("clojure.java.jdbc", "db-connection");
    const__230 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "db"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.sql.Connection") })) })), RT.keyword(null, "doc"), "Returns the current database connection (or throws if there is none)", RT.keyword(null, "line"), Integer.valueOf(724), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__231 = (Var)RT.var("clojure.java.jdbc", "db-set-rollback-only!");
    const__234 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db")) })), RT.keyword(null, "doc"), "Marks the outermost transaction such that it will rollback rather than\n  commit when complete", RT.keyword(null, "line"), Integer.valueOf(730), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__235 = (Var)RT.var("clojure.java.jdbc", "db-unset-rollback-only!");
    const__238 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db")) })), RT.keyword(null, "doc"), "Marks the outermost transaction such that it will not rollback when complete", RT.keyword(null, "line"), Integer.valueOf(736), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__239 = (Var)RT.var("clojure.java.jdbc", "db-is-rollback-only");
    const__242 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db")) })), RT.keyword(null, "doc"), "Returns true if the outermost transaction will rollback rather than\n  commit when complete", RT.keyword(null, "line"), Integer.valueOf(741), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__243 = (Var)RT.var("clojure.java.jdbc", "isolation-levels");
    const__245 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(747), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj", RT.keyword(null, "doc"), "Transaction isolation levels." });
    const__246 = (Keyword)RT.keyword(null, "none");
    const__247 = (Keyword)RT.keyword(null, "read-committed");
    const__248 = (Keyword)RT.keyword(null, "read-uncommitted");
    const__249 = (Keyword)RT.keyword(null, "repeatable-read");
    const__250 = (Keyword)RT.keyword(null, "serializable");
    const__251 = (Var)RT.var("clojure.java.jdbc", "isolation-kws");
    const__253 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(756), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj", RT.keyword(null, "doc"), "Map transaction isolation constants to our keywords." });
    const__254 = (Var)RT.var("clojure.set", "map-invert");
    const__255 = (Var)RT.var("clojure.java.jdbc", "get-isolation-level");
    const__258 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db")) })), RT.keyword(null, "doc"), "Given a db-spec (with an optional connection), return the current\n  transaction isolation level, if known. Return nil if there is no\n  active connection in the db-spec. Return :unknown if we do not\n  recognize the isolation level.", RT.keyword(null, "line"), Integer.valueOf(760), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__259 = (Var)RT.var("clojure.java.jdbc", "db-transaction*");
    const__262 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "func")), Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "func"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Evaluates func as a transaction on the open database connection. Any\n  nested transactions are absorbed into the outermost transaction. By\n  default, all database updates are committed together as a group after\n  evaluating the outermost body, or rolled back on any uncaught\n  exception. If rollback is set within scope of the outermost transaction,\n  the entire transaction will be rolled back rather than committed when\n  complete.\n  The isolation option may be :none, :read-committed, :read-uncommitted,\n  :repeatable-read, or :serializable. Note that not all databases support\n  all of those isolation levels, and may either throw an exception or\n  substitute another isolation level.\n  The read-only? option puts the transaction in readonly mode (if supported).", RT.keyword(null, "line"), Integer.valueOf(769), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__263 = (Var)RT.var("clojure.java.jdbc", "with-db-transaction");
    const__266 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "binding"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Evaluates body in the context of a transaction on the specified database connection.\n  The binding provides the database connection for the transaction and the name to which\n  that is bound for evaluation of the body. The binding may also specify the isolation\n  level for the transaction, via the :isolation option and/or set the transaction to\n  readonly via the :read-only? option.\n  (with-db-transaction [t-con db-spec {:isolation level :read-only? true}]\n    ... t-con ...)\n  See db-transaction* for more details.", RT.keyword(null, "line"), Integer.valueOf(844), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__267 = (Var)RT.var("clojure.java.jdbc", "with-db-connection");
    const__270 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "binding"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Evaluates body in the context of an active connection to the database.\n  (with-db-connection [con-db db-spec opts]\n    ... con-db ...)", RT.keyword(null, "line"), Integer.valueOf(858), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__271 = (Var)RT.var("clojure.java.jdbc", "with-db-metadata");
    const__274 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "binding"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Evaluates body in the context of an active connection with metadata bound\n   to the specified name. See also metadata-result for dealing with the results\n   of operations that retrieve information from the metadata.\n   (with-db-metadata [md db-spec opts]\n     ... md ...)", RT.keyword(null, "line"), Integer.valueOf(871), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__275 = (Var)RT.var("clojure.java.jdbc", "process-result-set");
    const__278 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rset"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Given a Java ResultSet and options, produce a processed result-set-seq,\n  honoring as-arrays?, result-set-fn, and row-fn from opts.", RT.keyword(null, "line"), Integer.valueOf(886), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__279 = (Var)RT.var("clojure.java.jdbc", "metadata-result");
    const__282 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rs-or-value")), Tuple.create(Symbol.intern(null, "rs-or-value"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "If the argument is a java.sql.ResultSet, turn it into a result-set-seq,\n  else return it as-is. This makes working with metadata easier.\n  Also accepts an option map containing :identifiers, :keywordize?, :qualifier,\n  :as-arrays?, :row-fn, and :result-set-fn to control how the ResultSet is\n  transformed and returned. See query for more details.", RT.keyword(null, "line"), Integer.valueOf(900), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__283 = (Var)RT.var("clojure.java.jdbc", "metadata-query");
    const__286 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "meta-query"), Symbol.intern(null, "&"), Symbol.intern(null, "opt-args")) })), RT.keyword(null, "doc"), "Given a Java expression that extracts metadata (in the context of with-db-metadata),\n  and a map of options like metadata-result, manage the connection for a single\n  metadata-based query. Example usage:\n\n  (with-db-metadata [meta db-spec]\n    (metadata-query (.getTables meta nil nil nil (into-array String [\"TABLE\"]))\n      {:row-fn ... :result-set-fn ...}))", RT.keyword(null, "line"), Integer.valueOf(912), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__287 = (Var)RT.var("clojure.java.jdbc", "db-do-commands");
    const__290 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "sql-commands")), Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "transaction?"), Symbol.intern(null, "sql-commands")) })), RT.keyword(null, "doc"), "Executes SQL commands on the specified database connection. Wraps the commands\n  in a transaction if transaction? is true. transaction? can be omitted and it\n  defaults to true. Accepts a single SQL command (string) or a vector of them.\n  Uses executeBatch. This may affect what SQL you can run via db-do-commands.", RT.keyword(null, "line"), Integer.valueOf(924), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__291 = (Var)RT.var("clojure.java.jdbc", "db-do-execute-prepared-return-keys");
    const__294 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), ((IObj)Symbol.intern(null, "stmt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "PreparedStatement") })), Symbol.intern(null, "param-group"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Executes a PreparedStatement, optionally in a transaction, and (attempts to)\n  return any generated keys.\n\n  Supports :multi? which causes a full result set sequence of keys to be\n  returned, and assumes the param-group is a sequence of parameter lists,\n  rather than a single sequence of parameters.\n\n  Also supports :row-fn and, if :multi? is truthy, :result-set-fn", RT.keyword(null, "line"), Integer.valueOf(945), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__295 = (Var)RT.var("clojure.java.jdbc", "sql-stmt?");
    const__298 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "expr")) })), RT.keyword(null, "doc"), "Given an expression, return true if it is either a string (SQL) or a\n  PreparedStatement.", RT.keyword(null, "line"), Integer.valueOf(991), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__299 = (Var)RT.var("clojure.java.jdbc", "db-do-prepared-return-keys");
  }
  
  public static void __init3() {
    const__302 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "sql-params")), Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "transaction?"), Symbol.intern(null, "sql-params")), Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "transaction?"), Symbol.intern(null, "sql-params"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Executes an (optionally parameterized) SQL prepared statement on the\n  open database connection. The param-group is a seq of values for all of\n  the parameters. transaction? can be omitted and will default to true.\n  Return the generated keys for the (single) update/insert.\n  A PreparedStatement may be passed in, instead of a SQL string, in which\n  case :return-keys MUST BE SET on that PreparedStatement!", RT.keyword(null, "line"), Integer.valueOf(997), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__303 = (Var)RT.var("clojure.java.jdbc", "db-do-execute-prepared-statement");
    const__306 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), ((IObj)Symbol.intern(null, "stmt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "PreparedStatement") })), Symbol.intern(null, "param-groups"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Execute a PreparedStatement, optionally in a transaction.", RT.keyword(null, "line"), Integer.valueOf(1024), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__307 = (Var)RT.var("clojure.java.jdbc", "db-do-prepared");
    const__310 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "sql-params")), Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "transaction?"), Symbol.intern(null, "sql-params")), Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "transaction?"), Symbol.intern(null, "sql-params"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Executes an (optionally parameterized) SQL prepared statement on the\n  open database connection. Each param-group is a seq of values for all of\n  the parameters. transaction? can be omitted and defaults to true.\n  The sql parameter can either be a SQL string or a PreparedStatement.\n  Return a seq of update counts (one count for each param-group).", RT.keyword(null, "line"), Integer.valueOf(1042), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__311 = (Var)RT.var("clojure.java.jdbc", "execute-query-with-params");
    const__314 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "stmt")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "PreparedStatement") })), Symbol.intern(null, "params"), Symbol.intern(null, "set-parameters"), Symbol.intern(null, "func")) })), RT.keyword(null, "doc"), "Given a prepared statement, a set of parameters, a parameter setting\n  function, and a function to process the result set, execute the query and\n  apply the processing function.", RT.keyword(null, "line"), Integer.valueOf(1066), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__315 = (Var)RT.var("clojure.java.jdbc", "db-query-with-resultset*");
    const__318 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "sql"), Symbol.intern(null, "params"), Symbol.intern(null, "func"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Given a db-spec, a SQL statement (or a prepared statement), a set of\n  parameters, a result set processing function and options, execute the query.", RT.keyword(null, "line"), Integer.valueOf(1075), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__319 = (Var)RT.var("clojure.java.jdbc", "db-query-with-resultset");
    const__322 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "sql-params"), Symbol.intern(null, "func")), Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "sql-params"), Symbol.intern(null, "func"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Executes a query, then evaluates func passing in the raw ResultSet as an\n   argument. The second argument is a vector containing either:\n    [sql & params] - a SQL query, followed by any parameters it needs\n    [stmt & params] - a PreparedStatement, followed by any parameters it needs\n                      (the PreparedStatement already contains the SQL query)\n  The opts map is passed to prepare-statement.\n  Uses executeQuery. This may affect what SQL you can run via query.", RT.keyword(null, "line"), Integer.valueOf(1101), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__323 = (Var)RT.var("clojure.java.jdbc", "query");
    const__326 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "sql-params")), Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "sql-params"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Given a database connection and a vector containing SQL and optional parameters,\n  perform a simple database query. The options specify how to construct the result\n  set (and are also passed to prepare-statement as needed):\n    :as-arrays? - return the results as a set of arrays, default false.\n    :identifiers - applied to each column name in the result set, default lower-case\n    :keywordize? - defaults to true, can be false to opt-out of converting\n        identifiers to keywords\n    :qualifier - optionally provides the namespace qualifier for identifiers\n    :result-set-fn - applied to the entire result set, default doall / vec\n        if :as-arrays? true, :result-set-fn will default to vec\n        if :as-arrays? false, :result-set-fn will default to doall\n    :row-fn - applied to each row as the result set is constructed, default identity\n  The second argument is a vector containing a SQL string or PreparedStatement, followed\n  by any parameters it needs.\n  See also prepare-statement for additional options.", RT.keyword(null, "line"), Integer.valueOf(1126), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__327 = (Var)RT.var("clojure.java.jdbc", "get-rs-columns");
    const__330 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "idxs"), ((IObj)Symbol.intern(null, "rsmeta")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ResultSetMetaData") })), Symbol.intern(null, "identifier-fn")) })), RT.keyword(null, "doc"), "Given a set of indices, a result set's metadata, and a function to convert\n  SQL entity names to Clojure column names,\n  return the unique vector of column names.", RT.keyword(null, "line"), Integer.valueOf(1169), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__331 = (Var)RT.var("clojure.java.jdbc", "init-reduce-rs");
    const__334 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { RT.vector(new Object[] { Symbol.intern(null, "cols"), ((IObj)Symbol.intern(null, "rs")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ResultSet") })), Symbol.intern(null, "rsmeta"), Symbol.intern(null, "idxs"), Symbol.intern(null, "f"), Symbol.intern(null, "init"), Symbol.intern(null, "read-columns") }) })), RT.keyword(null, "doc"), "Given a sequence of columns, a result set, its metadata, a sequence of\n  indices, a mapping function to apply, an initial value, and a function that\n  can read column data from the result set, reduce the result set and\n  return the result of that reduction.", RT.keyword(null, "line"), Integer.valueOf(1179), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__335 = (Var)RT.var("clojure.java.jdbc", "reducible-result-set*");
    const__338 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "rs")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ResultSet") })), Symbol.intern(null, "idxs"), ((IObj)Symbol.intern(null, "rsmeta")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ResultSetMetaData") })), Symbol.intern(null, "cols"), Symbol.intern(null, "read-columns")) })), RT.keyword(null, "doc"), "Given a java.sql.ResultSet, indices, metadata, column names and a reader,\n  return a reducible collection.\n  Compiled with Clojure 1.7 or later -- uses clojure.lang.IReduce.", RT.keyword(null, "line"), Integer.valueOf(1193), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__339 = (Var)RT.var("clojure.java.jdbc", "reducible-result-set");
    const__342 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "rs")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ResultSet") })), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "identifiers"), Symbol.intern(null, "keywordize?"), Symbol.intern(null, "qualifier"), Symbol.intern(null, "read-columns")), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "identifiers"), Symbol.intern("str", "lower-case"), Symbol.intern(null, "keywordize?"), Boolean.TRUE, Symbol.intern(null, "read-columns"), Symbol.intern(null, "dft-read-columns") }) })) })), RT.keyword(null, "doc"), "Given a java.sql.ResultSet return a reducible collection.\n  Compiled with Clojure 1.7 or later -- uses clojure.lang.IReduce\n  Note: :as-arrays? is not accepted here.", RT.keyword(null, "line"), Integer.valueOf(1211), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__343 = (Var)RT.var("clojure.java.jdbc", "query-reducer");
    const__346 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "identifiers"), Symbol.intern(null, "keywordize?"), Symbol.intern(null, "qualifier"), Symbol.intern(null, "read-columns")) })), RT.keyword(null, "doc"), "Given options, return a function of f (or f and init) that accepts a\n  result set and reduces it using f.", RT.keyword(null, "line"), Integer.valueOf(1227), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__347 = (Var)RT.var("clojure.java.jdbc", "mapify-result-set");
    const__350 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "rs")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ResultSet") }))) })), RT.keyword(null, "doc"), "Given a result set, return an object that wraps the current row as a hash\n  map. Note that a result set is mutable and the current row will change behind\n  this wrapper so operations need to be eager (and fairly limited).\n  Supports ILookup (keywords are treated as strings).\n  Supports Associative for lookup only (again, keywords are treated as strings).\n  Later we may realize a new hash map when assoc (and other, future, operations\n  are performed on the result set row).", RT.keyword(null, "line"), Integer.valueOf(1246), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__351 = (Var)RT.var("clojure.java.jdbc", "raw-query-reducer");
    const__354 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "init")) })), RT.keyword(null, "doc"), "Given a function f and an initial value, return a function that accepts a\n  result set and reduces it using no translation. The result set is extended\n  to support ILookup and the readonly parts of Associative only.", RT.keyword(null, "line"), Integer.valueOf(1280), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__355 = (Var)RT.var("clojure.java.jdbc", "reducible-query");
    const__358 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "sql-params")), Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "sql-params"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Given a database connection, a vector containing SQL and optional parameters,\n  return a reducible collection. When reduced, it will start the database query\n  and reduce the result set, and then close the connection:\n    (transduce (map :cost) + (reducible-query db sql-params))\n\n  The following options from query etc are not accepted here:\n    :as-arrays? :explain :explain-fn :result-set-fn :row-fn\n  See prepare-statement for additional options that may be passed through.\n\n  If :raw? true is specified, the rows of the result set are not converted to\n  hash maps, and it as if the following options were specified:\n    :identifiers identity :keywordize? false :qualifier nil\n  In addition, the rows of the result set may only be read as if they were hash\n  maps (get, keyword lookup, select-keys) but the sequence representation is\n  not available (so, no keys, no vals, and no seq calls). This is much faster\n  than converting each row to a hash map but it is also more restrictive.", RT.keyword(null, "line"), Integer.valueOf(1295), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__359 = (Var)RT.var("clojure.java.jdbc", "direction");
    const__362 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "entities"), Symbol.intern(null, "c"), Symbol.intern(null, "d")) })), RT.keyword(null, "doc"), "Given an entities function, a column name, and a direction,\n  return the matching SQL column / order.\n  Throw an exception for an invalid direction.", RT.keyword(null, "line"), Integer.valueOf(1344), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__363 = (Var)RT.var("clojure.java.jdbc", "order-by-sql");
    const__366 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "order-by"), Symbol.intern(null, "entities")) })), RT.keyword(null, "doc"), "Given a sequence of column specs and an entities function, return\n  a SQL fragment for the ORDER BY clause. A column spec may be a name\n  (either a string or keyword) or a map from column name to direction\n  (:asc or :desc).", RT.keyword(null, "line"), Integer.valueOf(1354), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__367 = (Var)RT.var("clojure.java.jdbc", "find-by-keys");
    const__370 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "table"), Symbol.intern(null, "columns")), Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "table"), Symbol.intern(null, "columns"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Given a database connection, a table name, a map of column name/value\n  pairs, and an optional options map, return any matching rows.\n\n  An :order-by option may be supplied to sort the rows, e.g.,\n\n      {:order-by [{:name :asc} {:age :desc} {:income :asc}]}\n      ;; equivalent to:\n      {:order-by [:name {:age :desc} :income]}\n\n  The :order-by value is a sequence of column names (to sort in ascending\n  order) and/or maps from column names to directions (:asc or :desc). The\n  directions may be strings or keywords and are not case-sensitive. They\n  are mapped to ASC or DESC in the generated SQL.\n\n  Note: if a ordering map has more than one key, the order of the columns\n  in the generated SQL ORDER BY clause is unspecified (so such maps should\n  only contain one key/value pair).", RT.keyword(null, "line"), Integer.valueOf(1368), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__371 = (Var)RT.var("clojure.java.jdbc", "get-by-id");
    const__374 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "table"), Symbol.intern(null, "pk-value")), Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "table"), Symbol.intern(null, "pk-value"), Symbol.intern(null, "pk-name-or-opts")), Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "table"), Symbol.intern(null, "pk-value"), Symbol.intern(null, "pk-name"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Given a database connection, a table name, a primary key value, an\n  optional primary key column name, and an optional options map, return\n  a single matching row, or nil.\n  The primary key column name defaults to :id.", RT.keyword(null, "line"), Integer.valueOf(1401), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__375 = (Var)RT.var("clojure.java.jdbc", "execute!");
    const__378 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "sql-params")), Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "sql-params"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Given a database connection and a vector containing SQL (or PreparedStatement)\n  followed by optional parameters, perform a general (non-select) SQL operation.\n\n  The :transaction? option specifies whether to run the operation in a\n  transaction or not (default true).\n\n  If the :multi? option is false (the default), the SQL statement should be\n  followed by the parameters for that statement.\n\n  If the :multi? option is true, the SQL statement should be followed by one or\n  more vectors of parameters, one for each application of the SQL statement.\n\n  If :return-keys is provided, db-do-prepared-return-keys will be called\n  instead of db-do-prepared, and the result will be a sequence of maps\n  containing the generated keys. If present, :row-fn will be applied. If :multi?\n  then :result-set-fn will also be applied if present. :as-arrays? may also be\n  specified (which will affect what :result-set-fn is passed).\n\n  If there are no parameters specified, executeUpdate will be used, otherwise\n  executeBatch will be used. This may affect what SQL you can run via execute!", RT.keyword(null, "line"), Integer.valueOf(1417), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__379 = (Var)RT.var("clojure.java.jdbc", "delete-sql");
    const__382 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "table"), Tuple.create(Symbol.intern(null, "where"), Symbol.intern(null, "&"), Symbol.intern(null, "params")), Symbol.intern(null, "entities")) })), RT.keyword(null, "doc"), "Given a table name, a where class and its parameters and an optional entities spec,\n  return a vector of the SQL for that delete operation followed by its parameters. The\n  entities spec (default 'as-is') specifies how to transform column names.", RT.keyword(null, "line"), Integer.valueOf(1452), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__383 = (Var)RT.var("clojure.java.jdbc", "delete!");
    const__386 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "table"), Symbol.intern(null, "where-clause")), Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "table"), Symbol.intern(null, "where-clause"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Given a database connection, a table name and a where clause of columns to match,\n  perform a delete. The options may specify how to transform column names in the\n  map (default 'as-is') and whether to run the delete in a transaction (default true).\n  Example:\n    (delete! db :person [\"zip = ?\" 94546])\n  is equivalent to:\n    (execute! db [\"DELETE FROM person WHERE zip = ?\" 94546])", RT.keyword(null, "line"), Integer.valueOf(1461), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__387 = (Var)RT.var("clojure.java.jdbc", "multi-insert-helper");
    const__390 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "stmts"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Given a (connected) database connection and some SQL statements (for multiple\n   inserts), run a prepared statement on each and return any generated keys.\n   Note: we are eager so an unrealized lazy-seq cannot escape from the connection.", RT.keyword(null, "line"), Integer.valueOf(1475), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__391 = (Var)RT.var("clojure.java.jdbc", "insert-helper");
    const__394 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "transaction?"), Symbol.intern(null, "stmts"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Given a (connected) database connection, a transaction flag and some SQL statements\n   (for one or more inserts), run a prepared statement or a sequence of them.", RT.keyword(null, "line"), Integer.valueOf(1500), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__395 = (Var)RT.var("clojure.java.jdbc", "col-str");
    const__398 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "col"), Symbol.intern(null, "entities")) })), RT.keyword(null, "doc"), "Transform a column spec to an entity name for SQL. The column spec may be a\n  string, a keyword or a map with a single pair - column name and alias.", RT.keyword(null, "line"), Integer.valueOf(1508), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__399 = (Var)RT.var("clojure.java.jdbc", "insert-multi-row-sql");
  }
  
  public static void __init4() {
    const__402 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "table"), Symbol.intern(null, "columns"), Symbol.intern(null, "values"), Symbol.intern(null, "entities")) })), RT.keyword(null, "doc"), "Given a table and a list of columns, followed by a list of column value sequences,\n  return a vector of the SQL needed for the insert followed by the list of column\n  value sequences. The entities function specifies how column names are transformed.", RT.keyword(null, "line"), Integer.valueOf(1517), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__403 = (Var)RT.var("clojure.java.jdbc", "insert-single-row-sql");
    const__406 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "table"), Symbol.intern(null, "row"), Symbol.intern(null, "entities")) })), RT.keyword(null, "doc"), "Given a table and a map representing a row, return a vector of the SQL needed for\n  the insert followed by the list of column values. The entities function specifies\n  how column names are transformed.", RT.keyword(null, "line"), Integer.valueOf(1536), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__407 = (Var)RT.var("clojure.java.jdbc", "insert-rows!");
    const__410 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "table"), Symbol.intern(null, "rows"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Given a database connection, a table name, a sequence of rows, and an options\n  map, insert the rows into the database.", RT.keyword(null, "line"), Integer.valueOf(1549), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__411 = (Var)RT.var("clojure.java.jdbc", "insert-cols!");
    const__414 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "table"), Symbol.intern(null, "cols"), Symbol.intern(null, "values"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Given a database connection, a table name, a sequence of columns names, a\n  sequence of vectors of column values, one per row, and an options map,\n  insert the rows into the database.", RT.keyword(null, "line"), Integer.valueOf(1567), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__415 = (Var)RT.var("clojure.java.jdbc", "insert!");
    const__418 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "table"), Symbol.intern(null, "row")), Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "table"), Symbol.intern(null, "cols-or-row"), Symbol.intern(null, "values-or-opts")), Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "table"), Symbol.intern(null, "cols"), Symbol.intern(null, "values"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Given a database connection, a table name and either a map representing a rows,\n  or a list of column names followed by a list of column values also representing\n  a single row, perform an insert.\n  When inserting a row as a map, the result is the database-specific form of the\n  generated keys, if available (note: PostgreSQL returns the whole row).\n  When inserting a row as a list of column values, the result is the count of\n  rows affected (1), if available (from getUpdateCount after executeBatch).\n  The row map or column value vector may be followed by a map of options:\n  The :transaction? option specifies whether to run in a transaction or not.\n  The default is true (use a transaction). The :entities option specifies how\n  to convert the table name and column names to SQL entities.", RT.keyword(null, "line"), Integer.valueOf(1581), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__419 = (Var)RT.var("clojure.java.jdbc", "insert-multi!");
    const__422 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "table"), Symbol.intern(null, "rows")), Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "table"), Symbol.intern(null, "cols-or-rows"), Symbol.intern(null, "values-or-opts")), Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "table"), Symbol.intern(null, "cols"), Symbol.intern(null, "values"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Given a database connection, a table name and either a sequence of maps (for\n  rows) or a sequence of column names, followed by a sequence of vectors (for\n  the values in each row), and possibly a map of options, insert that data into\n  the database.\n\n  When inserting rows as a sequence of maps, the result is a sequence of the\n  generated keys, if available (note: PostgreSQL returns the whole rows). A\n  separate database operation is used for each row inserted. This may be slow\n  for if a large sequence of maps is provided.\n\n  When inserting rows as a sequence of lists of column values, the result is\n  a sequence of the counts of rows affected (a sequence of 1's), if available.\n  Yes, that is singularly unhelpful. Thank you getUpdateCount and executeBatch!\n  A single database operation should be used to insert all the rows at once.\n  This may be much faster than inserting a sequence of rows (which performs an\n  insert for each map in the sequence).\n\n  Note: some database drivers need to be told to rewrite the SQL for this to\n  be performed as a single, batched operation. In particular, PostgreSQL\n  requires :reWriteBatchedInserts true and My SQL requires\n  :rewriteBatchedStatement true (both non-standard JDBC options, of course!).\n  These options should be passed into the driver when the connection is\n  created (however that is done in your program).\n\n  The :transaction? option specifies whether to run in a transaction or not.\n  The default is true (use a transaction). The :entities option specifies how\n  to convert the table name and column names to SQL entities.", RT.keyword(null, "line"), Integer.valueOf(1601), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__423 = (Var)RT.var("clojure.java.jdbc", "update-sql");
    const__426 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "table"), Symbol.intern(null, "set-map"), Tuple.create(Symbol.intern(null, "where"), Symbol.intern(null, "&"), Symbol.intern(null, "params")), Symbol.intern(null, "entities")) })), RT.keyword(null, "doc"), "Given a table name, a map of columns to set, a optional map of columns to\n  match, and an entities, return a vector of the SQL for that update followed\n  by its parameters. Example:\n    (update :person {:zip 94540} [\"zip = ?\" 94546] identity)\n  returns:\n    [\"UPDATE person SET zip = ? WHERE zip = ?\" 94540 94546]", RT.keyword(null, "line"), Integer.valueOf(1637), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__427 = (Var)RT.var("clojure.java.jdbc", "update!");
    const__430 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "table"), Symbol.intern(null, "set-map"), Symbol.intern(null, "where-clause")), Tuple.create(Symbol.intern(null, "db"), Symbol.intern(null, "table"), Symbol.intern(null, "set-map"), Symbol.intern(null, "where-clause"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Given a database connection, a table name, a map of column values to set and a\n  where clause of columns to match, perform an update. The options may specify\n  how column names (in the set / match maps) should be transformed (default\n  'as-is') and whether to run the update in a transaction (default true).\n  Example:\n    (update! db :person {:zip 94540} [\"zip = ?\" 94546])\n  is equivalent to:\n    (execute! db [\"UPDATE person SET zip = ? WHERE zip = ?\" 94540 94546])", RT.keyword(null, "line"), Integer.valueOf(1655), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__431 = (Var)RT.var("clojure.java.jdbc", "create-table-ddl");
    const__434 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "table"), Symbol.intern(null, "specs")), Tuple.create(Symbol.intern(null, "table"), Symbol.intern(null, "specs"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Given a table name and a vector of column specs, return the DDL string for\n  creating that table. Each column spec is, in turn, a vector of keywords or\n  strings that is converted to strings and concatenated with spaces to form\n  a single column description in DDL, e.g.,\n    [:cost :int \"not null\"]\n    [:name \"varchar(32)\"]\n  The first element of a column spec is treated as a SQL entity (so if you\n  provide the :entities option, that will be used to transform it). The\n  remaining elements are left as-is when converting them to strings.\n  An options map may be provided that can contain:\n  :table-spec -- a string that is appended to the DDL -- and/or\n  :entities -- a function to specify how column names are transformed.\n  :conditional? -- either a boolean, indicating whether to add 'IF NOT EXISTS',\n    or a string, which is inserted literally before the table name, or a\n    function of two arguments (table name and the create statement), that can\n    manipulate the generated statement to better support other databases, e.g.,\n    MS SQL Server which need to wrap create table in an existence query.", RT.keyword(null, "line"), Integer.valueOf(1670), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
    const__435 = (Var)RT.var("clojure.java.jdbc", "drop-table-ddl");
    const__438 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "table")), Tuple.create(Symbol.intern(null, "table"), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "entities"), Symbol.intern(null, "conditional?")), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "entities"), Symbol.intern(null, "identity") }) })) })), RT.keyword(null, "doc"), "Given a table name, return the DDL string for dropping that table.\n  An options map may be provided that can contain:\n  :entities -- a function to specify how column names are transformed.\n  :conditional? -- either a boolean, indicating whether to add 'IF EXISTS',\n    or a string, which is inserted literally before the table name, or a\n    function of two arguments (table name and the create statement), that can\n    manipulate the generated statement to better support other databases, e.g.,\n    MS SQL Server which need to wrap create table in an existence query.", RT.keyword(null, "line"), Integer.valueOf(1715), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/jdbc.clj" });
  }
  
  static  {
    __init0();
    __init1();
    __init2();
    __init3();
    __init4();
    Compiler.pushNSandLoader(RT.classForName("clojure.java.jdbc__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
