package clojure.java;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class io__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Keyword const__3;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final AFn const__13;
  
  public static final Var const__14;
  
  public static final Var const__15;
  
  public static final Object const__16;
  
  public static final Var const__17;
  
  public static final AFn const__19;
  
  public static final Object const__20;
  
  public static final Var const__21;
  
  public static final Var const__22;
  
  public static final Var const__23;
  
  public static final Var const__24;
  
  public static final ISeq const__25;
  
  public static final Var const__26;
  
  public static final Var const__27;
  
  public static final AFn const__31;
  
  public static final Keyword const__32;
  
  public static final AFn const__33;
  
  public static final Keyword const__34;
  
  public static final Keyword const__35;
  
  public static final Keyword const__36;
  
  public static final Keyword const__37;
  
  public static final AFn const__38;
  
  public static final Keyword const__39;
  
  public static final Var const__40;
  
  public static final Var const__41;
  
  public static final Var const__42;
  
  public static final AFn const__43;
  
  public static final AFn const__44;
  
  public static final Keyword const__45;
  
  public static final AFn const__46;
  
  public static final AFn const__47;
  
  public static final Var const__48;
  
  public static final AFn const__49;
  
  public static final Var const__50;
  
  public static final AFn const__54;
  
  public static final Var const__55;
  
  public static final Object const__56;
  
  public static final Object const__57;
  
  public static final Object const__58;
  
  public static final Object const__59;
  
  public static final Object const__60;
  
  public static final Var const__61;
  
  public static final ISeq const__62;
  
  public static final AFn const__64;
  
  public static final AFn const__65;
  
  public static final Keyword const__66;
  
  public static final Keyword const__67;
  
  public static final Keyword const__68;
  
  public static final Keyword const__69;
  
  public static final AFn const__70;
  
  public static final AFn const__71;
  
  public static final AFn const__72;
  
  public static final AFn const__73;
  
  public static final AFn const__74;
  
  public static final AFn const__75;
  
  public static final AFn const__76;
  
  public static final AFn const__77;
  
  public static final AFn const__78;
  
  public static final AFn const__79;
  
  public static final Var const__80;
  
  public static final Object const__82;
  
  public static final AFn const__86;
  
  public static final Var const__87;
  
  public static final Object const__88;
  
  public static final AFn const__91;
  
  public static final Var const__92;
  
  public static final Object const__93;
  
  public static final AFn const__96;
  
  public static final Var const__97;
  
  public static final Object const__98;
  
  public static final AFn const__101;
  
  public static final Var const__102;
  
  public static final AFn const__106;
  
  public static final Var const__107;
  
  public static final AFn const__110;
  
  public static final Var const__111;
  
  public static final AFn const__114;
  
  public static final Var const__115;
  
  public static final AFn const__117;
  
  public static final Var const__118;
  
  public static final AFn const__121;
  
  public static final Var const__122;
  
  public static final AFn const__125;
  
  public static final Object const__126;
  
  public static final Object const__127;
  
  public static final Object const__128;
  
  public static final Object const__129;
  
  public static final Object const__130;
  
  public static final Object const__131;
  
  public static final Var const__132;
  
  public static final AFn const__133;
  
  public static final AFn const__134;
  
  public static final AFn const__135;
  
  public static final AFn const__136;
  
  public static final AFn const__137;
  
  public static final AFn const__138;
  
  public static final AFn const__139;
  
  public static final AFn const__140;
  
  public static final AFn const__141;
  
  public static final AFn const__142;
  
  public static final AFn const__143;
  
  public static final AFn const__144;
  
  public static final Var const__145;
  
  public static final AFn const__148;
  
  public static final Var const__149;
  
  public static final AFn const__152;
  
  public static final Var const__153;
  
  public static final AFn const__156;
  
  public static final Var const__157;
  
  public static final AFn const__160;
  
  public static final Var const__161;
  
  public static final AFn const__164;
  
  public static final Var const__165;
  
  public static final AFn const__168;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new io.fn__11346());
    const__6.setMeta((IPersistentMap)const__13);
    const__6

















      
      .bindRoot(((IFn)const__14.getRawRoot()).invoke(((IFn)const__15.getRawRoot()).invoke(byte.class, const__16)));
    const__17.setMeta((IPersistentMap)const__19);
    const__17



      
      .bindRoot(((IFn)const__14.getRawRoot()).invoke(((IFn)const__15.getRawRoot()).invoke(char.class, const__16)));
    const__50.setMeta((IPersistentMap)const__54);
    const__50.bindRoot(new io.escaped_utf8_urlstring__GT_str());
    const__80.setMeta((IPersistentMap)const__86);
    const__80.bindRoot(new io.reader());
    const__87.setMeta((IPersistentMap)const__91);
    const__87.bindRoot(new io.writer());
    const__92.setMeta((IPersistentMap)const__96);
    const__92.bindRoot(new io.input_stream());
    const__97.setMeta((IPersistentMap)const__101);
    const__97.bindRoot(new io.output_stream());
    const__102.setMeta((IPersistentMap)const__106);
    const__102.bindRoot(new io.append_QMARK_());
    const__107.setMeta((IPersistentMap)const__110);
    const__107.bindRoot(new io.encoding());
    const__111.setMeta((IPersistentMap)const__114);
    const__111.bindRoot(new io.buffer_size());
    const__115.setMeta((IPersistentMap)const__117);
    const__115.bindRoot(RT.mapUniqueKeys(new Object[] { const__67, new io.fn__11470(), const__66, new io.fn__11472(), const__68, new io.fn__11474(), const__69, new io.fn__11476() }));
    const__118.setMeta((IPersistentMap)const__121);
    const__118.bindRoot(new io.inputstream__GT_reader());
    const__122.setMeta((IPersistentMap)const__125);
    const__122.bindRoot(new io.outputstream__GT_writer());
    const__145.setMeta((IPersistentMap)const__148);
    const__145.bindRoot(new io.copy());
    const__149.setMeta((IPersistentMap)const__152);
    const__149.bindRoot(new io.as_relative_path());
    const__153.setMeta((IPersistentMap)const__156);
    const__153.bindRoot(new io.file());
    const__157.setMeta((IPersistentMap)const__160);
    const__157.bindRoot(new io.delete_file());
    const__161.setMeta((IPersistentMap)const__164);
    const__161.bindRoot(new io.make_parents());
    const__165.setMeta((IPersistentMap)const__168);
    const__165.bindRoot(new io.resource());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.java.io")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "author"), "Stuart Sierra, Chas Emerick, Stuart Halloway", RT.keyword(null, "doc"), "This file defines polymorphic I/O utility functions for Clojure." }));
    const__3 = (Keyword)RT.keyword(null, "doc");
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "author"), "Stuart Sierra, Chas Emerick, Stuart Halloway", RT.keyword(null, "doc"), "This file defines polymorphic I/O utility functions for Clojure." });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.java.io", "byte-array-type");
    const__13 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Type object for a Java primitive byte array.", RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(24), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/io.clj" });
    const__14 = (Var)RT.var("clojure.core", "class");
    const__15 = (Var)RT.var("clojure.core", "make-array");
    const__16 = Long.valueOf(0L);
    const__17 = (Var)RT.var("clojure.java.io", "char-array-type");
    const__19 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Type object for a Java primitive char array.", RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(30), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/io.clj" });
    const__20 = RT.classForName("clojure.java.io.Coercions");
    const__21 = (Var)RT.var("clojure.core", "alter-meta!");
    const__22 = (Var)RT.var("clojure.java.io", "Coercions");
    const__23 = (Var)RT.var("clojure.core", "assoc");
    const__24 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__25 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "as-file")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Coerce argument to a file.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })) })), ((IObj)Symbol.intern(null, "as-url")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Coerce argument to a URL.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })) })) }));
    const__26 = (Var)RT.var("clojure.core", "alter-var-root");
    const__27 = (Var)RT.var("clojure.core", "merge");
    const__31 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.java.io.Coercions"), RT.keyword(null, "on-interface"), RT.classForName("clojure.java.io.Coercions"), RT.keyword(null, "doc"), "Coerce between various 'resource-namish' things." });
    const__32 = (Keyword)RT.keyword(null, "sigs");
    const__33 = (AFn)RT.map(new Object[] { RT.keyword(null, "as-file"), RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.io.File"), RT.keyword(null, "added"), "1.2", RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "as-file")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Coerce argument to a file.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Coerce argument to a file." }), RT.keyword(null, "as-url"), RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.net.URL"), RT.keyword(null, "added"), "1.2", RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "as-url")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Coerce argument to a URL.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Coerce argument to a URL." }) });
    const__34 = (Keyword)RT.keyword(null, "var");
    const__35 = (Keyword)RT.keyword(null, "method-map");
    const__36 = (Keyword)RT.keyword(null, "as-file");
    const__37 = (Keyword)RT.keyword(null, "as-url");
    const__38 = (AFn)RT.map(new Object[] { RT.keyword(null, "as-file"), RT.keyword(null, "as-file"), RT.keyword(null, "as-url"), RT.keyword(null, "as-url") });
    const__39 = (Keyword)RT.keyword(null, "method-builders");
    const__40 = (Var)RT.var("clojure.core", "intern");
    const__41 = (Var)RT.var("clojure.core", "*ns*");
    const__42 = (Var)RT.var("clojure.core", "with-meta");
    const__43 = (AFn)((IObj)Symbol.intern(null, "as-url")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Coerce argument to a URL.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })) }));
    const__44 = (AFn)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.net.URL"), RT.keyword(null, "added"), "1.2", RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "as-url")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Coerce argument to a URL.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Coerce argument to a URL." });
    const__45 = (Keyword)RT.keyword(null, "protocol");
    const__46 = (AFn)((IObj)Symbol.intern(null, "as-file")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Coerce argument to a file.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })) }));
    const__47 = (AFn)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.io.File"), RT.keyword(null, "added"), "1.2", RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "as-file")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Coerce argument to a file.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Coerce argument to a file." });
    const__48 = (Var)RT.var("clojure.core", "-reset-methods");
    const__49 = (AFn)((IObj)Symbol.intern(null, "Coercions")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "added"), "1.2" }));
    const__50 = (Var)RT.var("clojure.java.io", "escaped-utf8-urlstring->str");
    const__54 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "line"), Integer.valueOf(40), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/io.clj" });
    const__55 = (Var)RT.var("clojure.core", "extend");
    const__56 = RT.classForName("java.lang.String");
    const__57 = RT.classForName("java.io.File");
    const__58 = RT.classForName("java.net.URL");
    const__59 = RT.classForName("java.net.URI");
    const__60 = RT.classForName("clojure.java.io.IOFactory");
    const__61 = (Var)RT.var("clojure.java.io", "IOFactory");
    const__62 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "make-reader")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Creates a BufferedReader. See also IOFactory docs.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })) })), ((IObj)Symbol.intern(null, "make-writer")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Creates a BufferedWriter. See also IOFactory docs.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })) })), ((IObj)Symbol.intern(null, "make-input-stream")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Creates a BufferedInputStream. See also IOFactory docs.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })) })), ((IObj)Symbol.intern(null, "make-output-stream")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Creates a BufferedOutputStream. See also IOFactory docs.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })) })) }));
    const__64 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.java.io.IOFactory"), RT.keyword(null, "on-interface"), RT.classForName("clojure.java.io.IOFactory"), RT.keyword(null, "doc"), "Factory functions that create ready-to-use, buffered versions of\n   the various Java I/O stream types, on top of anything that can\n   be unequivocally converted to the requested kind of stream.\n\n   Common options include\n   \n     :append    true to open stream in append mode\n     :encoding  string name of encoding to use, e.g. \"UTF-8\".\n\n   Callers should generally prefer the higher level API provided by\n   reader, writer, input-stream, and output-stream." });
    const__65 = (AFn)RT.map(new Object[] { RT.keyword(null, "make-reader"), RT.map(new Object[] { RT.keyword(null, "added"), "1.2", RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "make-reader")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Creates a BufferedReader. See also IOFactory docs.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Creates a BufferedReader. See also IOFactory docs." }), RT.keyword(null, "make-writer"), RT.map(new Object[] { RT.keyword(null, "added"), "1.2", RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "make-writer")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Creates a BufferedWriter. See also IOFactory docs.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Creates a BufferedWriter. See also IOFactory docs." }), RT.keyword(null, "make-input-stream"), RT.map(new Object[] { RT.keyword(null, "added"), "1.2", RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "make-input-stream")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Creates a BufferedInputStream. See also IOFactory docs.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Creates a BufferedInputStream. See also IOFactory docs." }), RT.keyword(null, "make-output-stream"), RT.map(new Object[] { RT.keyword(null, "added"), "1.2", RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "make-output-stream")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Creates a BufferedOutputStream. See also IOFactory docs.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Creates a BufferedOutputStream. See also IOFactory docs." }) });
    const__66 = (Keyword)RT.keyword(null, "make-writer");
    const__67 = (Keyword)RT.keyword(null, "make-reader");
    const__68 = (Keyword)RT.keyword(null, "make-input-stream");
    const__69 = (Keyword)RT.keyword(null, "make-output-stream");
    const__70 = (AFn)RT.map(new Object[] { RT.keyword(null, "make-writer"), RT.keyword(null, "make-writer"), RT.keyword(null, "make-reader"), RT.keyword(null, "make-reader"), RT.keyword(null, "make-input-stream"), RT.keyword(null, "make-input-stream"), RT.keyword(null, "make-output-stream"), RT.keyword(null, "make-output-stream") });
    const__71 = (AFn)((IObj)Symbol.intern(null, "make-input-stream")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Creates a BufferedInputStream. See also IOFactory docs.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })) }));
    const__72 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.2", RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "make-input-stream")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Creates a BufferedInputStream. See also IOFactory docs.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Creates a BufferedInputStream. See also IOFactory docs." });
    const__73 = (AFn)((IObj)Symbol.intern(null, "make-reader")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Creates a BufferedReader. See also IOFactory docs.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })) }));
    const__74 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.2", RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "make-reader")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Creates a BufferedReader. See also IOFactory docs.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Creates a BufferedReader. See also IOFactory docs." });
    const__75 = (AFn)((IObj)Symbol.intern(null, "make-output-stream")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Creates a BufferedOutputStream. See also IOFactory docs.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })) }));
    const__76 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.2", RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "make-output-stream")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Creates a BufferedOutputStream. See also IOFactory docs.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Creates a BufferedOutputStream. See also IOFactory docs." });
    const__77 = (AFn)((IObj)Symbol.intern(null, "make-writer")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Creates a BufferedWriter. See also IOFactory docs.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })) }));
    const__78 = (AFn)RT.map(new Object[] { RT.keyword(null, "added"), "1.2", RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "make-writer")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Creates a BufferedWriter. See also IOFactory docs.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Creates a BufferedWriter. See also IOFactory docs." });
    const__79 = (AFn)((IObj)Symbol.intern(null, "IOFactory")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "added"), "1.2" }));
    const__80 = (Var)RT.var("clojure.java.io", "reader");
    const__82 = RT.classForName("java.io.Reader");
    const__86 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.io.Reader"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "&"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Attempts to coerce its argument into an open java.io.Reader.\n   Default implementations always return a java.io.BufferedReader.\n\n   Default implementations are provided for Reader, BufferedReader,\n   InputStream, File, URI, URL, Socket, byte arrays, character arrays,\n   and String.\n\n   If argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the Reader is properly\n   closed.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(86), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/io.clj" });
    const__87 = (Var)RT.var("clojure.java.io", "writer");
    const__88 = RT.classForName("java.io.Writer");
    const__91 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.io.Writer"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "&"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Attempts to coerce its argument into an open java.io.Writer.\n   Default implementations always return a java.io.BufferedWriter.\n\n   Default implementations are provided for Writer, BufferedWriter,\n   OutputStream, File, URI, URL, Socket, and String.\n\n   If the argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the Writer is properly\n   closed.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(104), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/io.clj" });
    const__92 = (Var)RT.var("clojure.java.io", "input-stream");
    const__93 = RT.classForName("java.io.InputStream");
    const__96 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.io.InputStream"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "&"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Attempts to coerce its argument into an open java.io.InputStream.\n   Default implementations always return a java.io.BufferedInputStream.\n\n   Default implementations are defined for InputStream, File, URI, URL,\n   Socket, byte array, and String arguments.\n\n   If the argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the InputStream is properly\n   closed.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(121), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/io.clj" });
    const__97 = (Var)RT.var("clojure.java.io", "output-stream");
    const__98 = RT.classForName("java.io.OutputStream");
  }
  
  public static void __init1() {
    const__101 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.io.OutputStream"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x"), Symbol.intern(null, "&"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Attempts to coerce its argument into an open java.io.OutputStream.\n   Default implementations always return a java.io.BufferedOutputStream.\n\n   Default implementations are defined for OutputStream, File, URI, URL,\n   Socket, and String arguments.\n\n   If the argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the OutputStream is\n   properly closed.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(138), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/io.clj" });
    const__102 = (Var)RT.var("clojure.java.io", "append?");
    const__106 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.Boolean"), RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "opts")) })), RT.keyword(null, "line"), Integer.valueOf(155), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/io.clj" });
    const__107 = (Var)RT.var("clojure.java.io", "encoding");
    const__110 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "opts")) })), RT.keyword(null, "line"), Integer.valueOf(158), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/io.clj" });
    const__111 = (Var)RT.var("clojure.java.io", "buffer-size");
    const__114 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "opts")) })), RT.keyword(null, "line"), Integer.valueOf(161), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/io.clj" });
    const__115 = (Var)RT.var("clojure.java.io", "default-streams-impl");
    const__117 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(164), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/io.clj" });
    const__118 = (Var)RT.var("clojure.java.io", "inputstream->reader");
    const__121 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "is")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "InputStream") })), Symbol.intern(null, "opts")) })), RT.keyword(null, "line"), Integer.valueOf(174), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/io.clj" });
    const__122 = (Var)RT.var("clojure.java.io", "outputstream->writer");
    const__125 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "os")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "OutputStream") })), Symbol.intern(null, "opts")) })), RT.keyword(null, "line"), Integer.valueOf(178), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/io.clj" });
    const__126 = RT.classForName("java.io.BufferedInputStream");
    const__127 = RT.classForName("java.io.BufferedReader");
    const__128 = RT.classForName("java.io.BufferedWriter");
    const__129 = RT.classForName("java.io.BufferedOutputStream");
    const__130 = RT.classForName("java.net.Socket");
    const__131 = RT.classForName("java.lang.Object");
    const__132 = (Var)RT.var("clojure.java.io", "do-copy");
    const__133 = (AFn)Tuple.create(RT.classForName("java.io.InputStream"), RT.classForName("java.io.OutputStream"));
    const__134 = (AFn)Tuple.create(RT.classForName("java.io.InputStream"), RT.classForName("java.io.Writer"));
    const__135 = (AFn)Tuple.create(RT.classForName("java.io.InputStream"), RT.classForName("java.io.File"));
    const__136 = (AFn)Tuple.create(RT.classForName("java.io.Reader"), RT.classForName("java.io.OutputStream"));
    const__137 = (AFn)Tuple.create(RT.classForName("java.io.Reader"), RT.classForName("java.io.Writer"));
    const__138 = (AFn)Tuple.create(RT.classForName("java.io.Reader"), RT.classForName("java.io.File"));
    const__139 = (AFn)Tuple.create(RT.classForName("java.io.File"), RT.classForName("java.io.OutputStream"));
    const__140 = (AFn)Tuple.create(RT.classForName("java.io.File"), RT.classForName("java.io.Writer"));
    const__141 = (AFn)Tuple.create(RT.classForName("java.io.File"), RT.classForName("java.io.File"));
    const__142 = (AFn)Tuple.create(RT.classForName("java.lang.String"), RT.classForName("java.io.OutputStream"));
    const__143 = (AFn)Tuple.create(RT.classForName("java.lang.String"), RT.classForName("java.io.Writer"));
    const__144 = (AFn)Tuple.create(RT.classForName("java.lang.String"), RT.classForName("java.io.File"));
    const__145 = (Var)RT.var("clojure.java.io", "copy");
    const__148 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "input"), Symbol.intern(null, "output"), Symbol.intern(null, "&"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Copies input to output.  Returns nil or throws IOException.\n  Input may be an InputStream, Reader, File, byte[], char[], or String.\n  Output may be an OutputStream, Writer, or File.\n\n  Options are key/value pairs and may be one of\n\n    :buffer-size  buffer size to use, default is 1024.\n    :encoding     encoding to use if converting between\n                  byte and char streams.   \n\n  Does not close any streams except those it opens itself \n  (on a File).", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(391), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/io.clj" });
    const__149 = (Var)RT.var("clojure.java.io", "as-relative-path");
    const__152 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Take an as-file-able thing and return a string if it is\n   a relative path, else IllegalArgumentException.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(408), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/io.clj" });
    const__153 = (Var)RT.var("clojure.java.io", "file");
    const__156 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.io.File"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "arg")), Tuple.create(Symbol.intern(null, "parent"), Symbol.intern(null, "child")), Tuple.create(Symbol.intern(null, "parent"), Symbol.intern(null, "child"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) })), RT.keyword(null, "doc"), "Returns a java.io.File, passing each arg to as-file.  Multiple-arg\n   versions treat the first argument as parent and subsequent args as\n   children relative to the parent.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(418), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/io.clj" });
    const__157 = (Var)RT.var("clojure.java.io", "delete-file");
    const__160 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "&"), Tuple.create(Symbol.intern(null, "silently"))) })), RT.keyword(null, "doc"), "Delete file f. If silently is nil or false, raise an exception on failure, else return the value of silently.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(430), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/io.clj" });
    const__161 = (Var)RT.var("clojure.java.io", "make-parents");
    const__164 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) })), RT.keyword(null, "doc"), "Given the same arg(s) as for file, creates all parent directories of\n   the file they represent.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(438), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/java/io.clj" });
    const__165 = (Var)RT.var("clojure.java.io", "resource");
    const__168 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.net.URL"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")), Tuple.create(Symbol.intern(null, "n"), ((IObj)Symbol.intern(null, "loader")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ClassLoader") }))) })), RT.keyword(null, "doc"), "Returns the URL for a named resource. Use the context class loader\n   if no loader is specified.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(446), 
          RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/java/io.clj" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("clojure.java.io__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
