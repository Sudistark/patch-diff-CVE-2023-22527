package clojure.lang;

import clojure.asm.ClassWriter;
import clojure.asm.Label;
import clojure.asm.Opcodes;
import clojure.asm.Type;
import clojure.asm.commons.GeneratorAdapter;
import clojure.asm.commons.Method;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Compiler implements Opcodes {
  static final Symbol DEF = Symbol.intern("def");
  
  static final Symbol LOOP = Symbol.intern("loop*");
  
  static final Symbol RECUR = Symbol.intern("recur");
  
  static final Symbol IF = Symbol.intern("if");
  
  static final Symbol LET = Symbol.intern("let*");
  
  static final Symbol LETFN = Symbol.intern("letfn*");
  
  static final Symbol DO = Symbol.intern("do");
  
  static final Symbol FN = Symbol.intern("fn*");
  
  static final Symbol FNONCE = (Symbol)Symbol.intern("fn*").withMeta(RT.map(new Object[] { Keyword.intern(null, "once"), RT.T }));
  
  static final Symbol QUOTE = Symbol.intern("quote");
  
  static final Symbol THE_VAR = Symbol.intern("var");
  
  static final Symbol DOT = Symbol.intern(".");
  
  static final Symbol ASSIGN = Symbol.intern("set!");
  
  static final Symbol TRY = Symbol.intern("try");
  
  static final Symbol CATCH = Symbol.intern("catch");
  
  static final Symbol FINALLY = Symbol.intern("finally");
  
  static final Symbol THROW = Symbol.intern("throw");
  
  static final Symbol MONITOR_ENTER = Symbol.intern("monitor-enter");
  
  static final Symbol MONITOR_EXIT = Symbol.intern("monitor-exit");
  
  static final Symbol IMPORT = Symbol.intern("clojure.core", "import*");
  
  static final Symbol DEFTYPE = Symbol.intern("deftype*");
  
  static final Symbol CASE = Symbol.intern("case*");
  
  static final Symbol CLASS = Symbol.intern("Class");
  
  static final Symbol NEW = Symbol.intern("new");
  
  static final Symbol THIS = Symbol.intern("this");
  
  static final Symbol REIFY = Symbol.intern("reify*");
  
  static final Symbol LIST = Symbol.intern("clojure.core", "list");
  
  static final Symbol HASHMAP = Symbol.intern("clojure.core", "hash-map");
  
  static final Symbol VECTOR = Symbol.intern("clojure.core", "vector");
  
  static final Symbol IDENTITY = Symbol.intern("clojure.core", "identity");
  
  static final Symbol _AMP_ = Symbol.intern("&");
  
  static final Symbol ISEQ = Symbol.intern("clojure.lang.ISeq");
  
  static final Keyword loadNs = Keyword.intern(null, "load-ns");
  
  static final Keyword inlineKey = Keyword.intern(null, "inline");
  
  static final Keyword inlineAritiesKey = Keyword.intern(null, "inline-arities");
  
  static final Keyword staticKey = Keyword.intern(null, "static");
  
  static final Keyword arglistsKey = Keyword.intern(null, "arglists");
  
  static final Symbol INVOKE_STATIC = Symbol.intern("invokeStatic");
  
  static final Keyword volatileKey = Keyword.intern(null, "volatile");
  
  static final Keyword implementsKey = Keyword.intern(null, "implements");
  
  static final String COMPILE_STUB_PREFIX = "compile__stub";
  
  static final Keyword protocolKey = Keyword.intern(null, "protocol");
  
  static final Keyword onKey = Keyword.intern(null, "on");
  
  static Keyword dynamicKey = Keyword.intern("dynamic");
  
  static final Keyword redefKey = Keyword.intern(null, "redef");
  
  static final Symbol NS = Symbol.intern("ns");
  
  static final Symbol IN_NS = Symbol.intern("in-ns");
  
  public static final IPersistentMap specials = PersistentHashMap.create(new Object[] { 
        DEF, new DefExpr.Parser(), LOOP, new LetExpr.Parser(), RECUR, new RecurExpr.Parser(), IF, new IfExpr.Parser(), CASE, new CaseExpr.Parser(), 
        LET, new LetExpr.Parser(), LETFN, new LetFnExpr.Parser(), DO, new BodyExpr.Parser(), FN, null, QUOTE, new ConstantExpr.Parser(), 
        THE_VAR, new TheVarExpr.Parser(), IMPORT, new ImportExpr.Parser(), DOT, new HostExpr.Parser(), ASSIGN, new AssignExpr.Parser(), DEFTYPE, new NewInstanceExpr.DeftypeParser(), 
        REIFY, new NewInstanceExpr.ReifyParser(), TRY, new TryExpr.Parser(), THROW, new ThrowExpr.Parser(), MONITOR_ENTER, new MonitorEnterExpr.Parser(), MONITOR_EXIT, new MonitorExitExpr.Parser(), 
        CATCH, null, FINALLY, null, NEW, new NewExpr.Parser(), _AMP_, null });
  
  private static final int MAX_POSITIONAL_ARITY = 20;
  
  private static final Type OBJECT_TYPE;
  
  private static final Type KEYWORD_TYPE = Type.getType(Keyword.class);
  
  private static final Type VAR_TYPE = Type.getType(Var.class);
  
  private static final Type SYMBOL_TYPE = Type.getType(Symbol.class);
  
  private static final Type IFN_TYPE = Type.getType(IFn.class);
  
  private static final Type AFUNCTION_TYPE = Type.getType(AFunction.class);
  
  private static final Type RT_TYPE = Type.getType(RT.class);
  
  private static final Type NUMBERS_TYPE = Type.getType(Numbers.class);
  
  static final Type CLASS_TYPE = Type.getType(Class.class);
  
  static final Type NS_TYPE = Type.getType(Namespace.class);
  
  static final Type UTIL_TYPE = Type.getType(Util.class);
  
  static final Type REFLECTOR_TYPE = Type.getType(Reflector.class);
  
  static final Type THROWABLE_TYPE = Type.getType(Throwable.class);
  
  static final Type BOOLEAN_OBJECT_TYPE = Type.getType(Boolean.class);
  
  static final Type IPERSISTENTMAP_TYPE = Type.getType(IPersistentMap.class);
  
  static final Type IOBJ_TYPE = Type.getType(IObj.class);
  
  static final Type TUPLE_TYPE = Type.getType(Tuple.class);
  
  static final Method[] createTupleMethods = { Method.getMethod("clojure.lang.IPersistentVector create()"), 
      Method.getMethod("clojure.lang.IPersistentVector create(Object)"), 
      Method.getMethod("clojure.lang.IPersistentVector create(Object,Object)"), 
      Method.getMethod("clojure.lang.IPersistentVector create(Object,Object,Object)"), 
      Method.getMethod("clojure.lang.IPersistentVector create(Object,Object,Object,Object)"), 
      Method.getMethod("clojure.lang.IPersistentVector create(Object,Object,Object,Object,Object)"), 
      Method.getMethod("clojure.lang.IPersistentVector create(Object,Object,Object,Object,Object,Object)") };
  
  private static final Type[][] ARG_TYPES;
  
  private static final Type[] EXCEPTION_TYPES = new Type[0];
  
  public static final Var LOCAL_ENV;
  
  public static final Var LOOP_LOCALS;
  
  public static final Var LOOP_LABEL;
  
  public static final Var CONSTANTS;
  
  public static final Var CONSTANT_IDS;
  
  public static final Var KEYWORD_CALLSITES;
  
  public static final Var PROTOCOL_CALLSITES;
  
  public static final Var VAR_CALLSITES;
  
  public static final Var KEYWORDS;
  
  public static final Var VARS;
  
  public static final Var METHOD;
  
  public static final Var IN_CATCH_FINALLY;
  
  public static final Var METHOD_RETURN_CONTEXT;
  
  public static final Var NO_RECUR;
  
  public static final Var LOADER;
  
  public static final Var SOURCE;
  
  public static final Var SOURCE_PATH;
  
  public static final Var COMPILE_PATH;
  
  public static final Var COMPILE_FILES;
  
  public static final Var INSTANCE;
  
  public static final Var ADD_ANNOTATIONS;
  
  public static final Keyword disableLocalsClearingKey;
  
  public static final Keyword directLinkingKey;
  
  public static final Keyword elideMetaKey;
  
  public static final Var COMPILER_OPTIONS;
  
  public static final Var LINE;
  
  public static final Var COLUMN;
  
  public static final Var LINE_BEFORE;
  
  public static final Var COLUMN_BEFORE;
  
  public static final Var LINE_AFTER;
  
  public static final Var COLUMN_AFTER;
  
  public static final Var NEXT_LOCAL_NUM;
  
  public static final Var RET_LOCAL_NUM;
  
  public static final Var COMPILE_STUB_SYM;
  
  public static final Var COMPILE_STUB_CLASS;
  
  public static final Var CLEAR_PATH;
  
  public static final Var CLEAR_ROOT;
  
  public static final Var CLEAR_SITES;
  
  public static final Class RECUR_CLASS;
  
  static final NilExpr NIL_EXPR;
  
  static final BooleanExpr TRUE_EXPR;
  
  static final BooleanExpr FALSE_EXPR;
  
  public static final IPersistentMap CHAR_MAP;
  
  public static final IPersistentMap DEMUNGE_MAP;
  
  public static final Pattern DEMUNGE_PATTERN;
  
  private static final Object MACRO_CHECK_LOCK;
  
  private static final Object OPTS_COND_ALLOWED;
  
  static  {
    OBJECT_TYPE = Type.getType(Object.class);
    ARG_TYPES = new Type[22][];
    for (i = 0; i <= 20; i++) {
      Type[] a = new Type[i];
      for (int j = 0; j < i; j++)
        a[j] = OBJECT_TYPE; 
      ARG_TYPES[i] = a;
    } 
    Type[] arrayOfType = new Type[21];
    for (int j = 0; j < 20; j++)
      arrayOfType[j] = OBJECT_TYPE; 
    arrayOfType[20] = Type.getType("[Ljava/lang/Object;");
    ARG_TYPES[21] = arrayOfType;
    LOCAL_ENV = Var.create(null).setDynamic();
    LOOP_LOCALS = Var.create().setDynamic();
    LOOP_LABEL = Var.create().setDynamic();
    CONSTANTS = Var.create().setDynamic();
    CONSTANT_IDS = Var.create().setDynamic();
    KEYWORD_CALLSITES = Var.create().setDynamic();
    PROTOCOL_CALLSITES = Var.create().setDynamic();
    VAR_CALLSITES = Var.create().setDynamic();
    KEYWORDS = Var.create().setDynamic();
    VARS = Var.create().setDynamic();
    METHOD = Var.create(null).setDynamic();
    IN_CATCH_FINALLY = Var.create(null).setDynamic();
    METHOD_RETURN_CONTEXT = Var.create(null).setDynamic();
    NO_RECUR = Var.create(null).setDynamic();
    LOADER = Var.create().setDynamic();
    SOURCE = Var.intern(Namespace.findOrCreate(Symbol.intern("clojure.core")), Symbol.intern("*source-path*"), "NO_SOURCE_FILE").setDynamic();
    SOURCE_PATH = Var.intern(Namespace.findOrCreate(Symbol.intern("clojure.core")), Symbol.intern("*file*"), "NO_SOURCE_PATH").setDynamic();
    COMPILE_PATH = Var.intern(Namespace.findOrCreate(Symbol.intern("clojure.core")), Symbol.intern("*compile-path*"), null).setDynamic();
    COMPILE_FILES = Var.intern(Namespace.findOrCreate(Symbol.intern("clojure.core")), Symbol.intern("*compile-files*"), Boolean.FALSE).setDynamic();
    INSTANCE = Var.intern(Namespace.findOrCreate(Symbol.intern("clojure.core")), 
        Symbol.intern("instance?"));
    ADD_ANNOTATIONS = Var.intern(Namespace.findOrCreate(Symbol.intern("clojure.core")), 
        Symbol.intern("add-annotations"));
    disableLocalsClearingKey = Keyword.intern("disable-locals-clearing");
    directLinkingKey = Keyword.intern("direct-linking");
    elideMetaKey = Keyword.intern("elide-meta");
    compilerOptions = null;
    for (Map.Entry e : System.getProperties().entrySet()) {
      String name = (String)e.getKey();
      String v = (String)e.getValue();
      if (name.startsWith("clojure.compiler."))
        compilerOptions = RT.assoc(compilerOptions, 
            RT.keyword(null, name.substring(1 + name.lastIndexOf('.'))), 
            RT.readString(v)); 
    } 
    COMPILER_OPTIONS = Var.intern(Namespace.findOrCreate(Symbol.intern("clojure.core")), Symbol.intern("*compiler-options*"), compilerOptions).setDynamic();
    LINE = Var.create(Integer.valueOf(0)).setDynamic();
    COLUMN = Var.create(Integer.valueOf(0)).setDynamic();
    LINE_BEFORE = Var.create(Integer.valueOf(0)).setDynamic();
    COLUMN_BEFORE = Var.create(Integer.valueOf(0)).setDynamic();
    LINE_AFTER = Var.create(Integer.valueOf(0)).setDynamic();
    COLUMN_AFTER = Var.create(Integer.valueOf(0)).setDynamic();
    NEXT_LOCAL_NUM = Var.create(Integer.valueOf(0)).setDynamic();
    RET_LOCAL_NUM = Var.create().setDynamic();
    COMPILE_STUB_SYM = Var.create(null).setDynamic();
    COMPILE_STUB_CLASS = Var.create(null).setDynamic();
    CLEAR_PATH = Var.create(null).setDynamic();
    CLEAR_ROOT = Var.create(null).setDynamic();
    CLEAR_SITES = Var.create(null).setDynamic();
    RECUR_CLASS = Recur.class;
    NIL_EXPR = new NilExpr();
    TRUE_EXPR = new BooleanExpr(true);
    FALSE_EXPR = new BooleanExpr(false);
    CHAR_MAP = PersistentHashMap.create(new Object[] { 
          Character.valueOf('-'), "_", 
          
          Character.valueOf(':'), "_COLON_", 
          Character.valueOf('+'), "_PLUS_", 
          Character.valueOf('>'), "_GT_", 
          Character.valueOf('<'), "_LT_", 
          Character.valueOf('='), "_EQ_", 
          Character.valueOf('~'), "_TILDE_", 
          Character.valueOf('!'), "_BANG_", 
          Character.valueOf('@'), "_CIRCA_", 
          Character.valueOf('#'), "_SHARP_", 
          Character.valueOf('\''), "_SINGLEQUOTE_", 
          Character.valueOf('"'), "_DOUBLEQUOTE_", 
          Character.valueOf('%'), "_PERCENT_", 
          Character.valueOf('^'), "_CARET_", 
          Character.valueOf('&'), "_AMPERSAND_", 
          Character.valueOf('*'), "_STAR_", 
          Character.valueOf('|'), "_BAR_", 
          Character.valueOf('{'), "_LBRACE_", 
          Character.valueOf('}'), "_RBRACE_", 
          Character.valueOf('['), "_LBRACK_", 
          Character.valueOf(']'), "_RBRACK_", 
          Character.valueOf('/'), "_SLASH_", 
          Character.valueOf('\\'), "_BSLASH_", 
          Character.valueOf('?'), "_QMARK_" });
    compilerOptions = RT.map(new Object[] { "$", Character.valueOf('/') });
    for (ISeq s = RT.seq(CHAR_MAP); s != null; s = s.next()) {
      IMapEntry e = (IMapEntry)s.first();
      Character origCh = (Character)e.key();
      String escapeStr = (String)e.val();
      compilerOptions = compilerOptions.assoc(escapeStr, origCh);
    } 
    DEMUNGE_MAP = compilerOptions;
    Object[] mungeStrs = RT.toArray(RT.keys(compilerOptions));
    Arrays.sort(mungeStrs, new Object());
    StringBuilder sb = new StringBuilder();
    boolean first = true;
    for (Object s : mungeStrs) {
      String escapeStr = (String)s;
      if (!first)
        sb.append("|"); 
      first = false;
      sb.append("\\Q");
      sb.append(escapeStr);
      sb.append("\\E");
    } 
    DEMUNGE_PATTERN = Pattern.compile(sb.toString());
    MACRO_CHECK = null;
    MACRO_CHECK_LOADING = false;
    MACRO_CHECK_LOCK = new Object();
    OPTS_COND_ALLOWED = RT.mapUniqueKeys(new Object[] { LispReader.OPT_READ_COND, LispReader.COND_ALLOW });
  }
  
  public static Object getCompilerOption(Keyword k) { return RT.get(COMPILER_OPTIONS.deref(), k); }
  
  static Object elideMeta(Object m) {
    Collection<Object> elides = (Collection)getCompilerOption(elideMetaKey);
    if (elides != null)
      for (Object k : elides)
        m = RT.dissoc(m, k);  
    return m;
  }
  
  static int lineDeref() { return ((Number)LINE.deref()).intValue(); }
  
  static int columnDeref() { return ((Number)COLUMN.deref()).intValue(); }
  
  static boolean isSpecial(Object sym) { return specials.containsKey(sym); }
  
  static boolean inTailCall(C context) { return (context == C.RETURN && METHOD_RETURN_CONTEXT.deref() != null && IN_CATCH_FINALLY.deref() == null); }
  
  static Symbol resolveSymbol(Symbol sym) {
    if (sym.name.indexOf('.') > 0)
      return sym; 
    if (sym.ns != null) {
      Namespace ns = namespaceFor(sym);
      if (ns == null || ((ns.name.name == null) ? (sym.ns == null) : ns.name.name.equals(sym.ns)))
        return sym; 
      return Symbol.intern(ns.name.name, sym.name);
    } 
    Object o = currentNS().getMapping(sym);
    if (o == null)
      return Symbol.intern((currentNS()).name.name, sym.name); 
    if (o instanceof Class)
      return Symbol.intern(null, ((Class)o).getName()); 
    if (o instanceof Var) {
      Var v = (Var)o;
      return Symbol.intern(v.ns.name.name, v.sym.name);
    } 
    return null;
  }
  
  static Class maybePrimitiveType(Expr e) {
    if (e instanceof MaybePrimitiveExpr && e.hasJavaClass() && ((MaybePrimitiveExpr)e).canEmitPrimitive()) {
      Class c = e.getJavaClass();
      if (Util.isPrimitive(c))
        return c; 
    } 
    return null;
  }
  
  static Class maybeJavaClass(Collection<Expr> exprs) {
    Class match = null;
    try {
      for (Expr e : exprs) {
        if (e instanceof ThrowExpr)
          continue; 
        if (!e.hasJavaClass())
          return null; 
        Class c = e.getJavaClass();
        if (match == null) {
          match = c;
          continue;
        } 
        if (match != c)
          return null; 
      } 
    } catch (Exception e) {
      return null;
    } 
    return match;
  }
  
  public static boolean subsumes(Class[] c1, Class[] c2) {
    Boolean better = Boolean.valueOf(false);
    for (int i = 0; i < c1.length; i++) {
      if (c1[i] != c2[i])
        if ((!c1[i].isPrimitive() && c2[i].isPrimitive()) || c2[i].isAssignableFrom(c1[i])) {
          better = Boolean.valueOf(true);
        } else {
          return false;
        }  
    } 
    return better.booleanValue();
  }
  
  static String getTypeStringForArgs(IPersistentVector args) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < args.count(); i++) {
      Expr arg = (Expr)args.nth(i);
      if (i > 0)
        sb.append(", "); 
      sb.append((arg.hasJavaClass() && arg.getJavaClass() != null) ? arg.getJavaClass().getName() : "unknown");
    } 
    return sb.toString();
  }
  
  static int getMatchingParams(String methodName, ArrayList<Class[]> paramlists, IPersistentVector argexprs, List<Class> rets) {
    int matchIdx = -1;
    boolean tied = false;
    boolean foundExact = false;
    for (int i = 0; i < paramlists.size(); i++) {
      boolean match = true;
      ISeq aseq = argexprs.seq();
      int exact = 0;
      for (int p = 0; match && p < argexprs.count() && aseq != null; p++, aseq = aseq.next()) {
        Expr arg = (Expr)aseq.first();
        Class aclass = arg.hasJavaClass() ? arg.getJavaClass() : Object.class;
        Class pclass = (Class[])paramlists.get(i)[p];
        if (arg.hasJavaClass() && aclass == pclass) {
          exact++;
        } else {
          match = Reflector.paramArgTypeMatch(pclass, aclass);
        } 
      } 
      if (exact == argexprs.count()) {
        if (!foundExact || matchIdx == -1 || ((Class)rets.get(matchIdx)).isAssignableFrom((Class)rets.get(i)))
          matchIdx = i; 
        tied = false;
        foundExact = true;
      } else if (match && !foundExact) {
        if (matchIdx == -1) {
          matchIdx = i;
        } else if (subsumes((Class[])paramlists.get(i), (Class[])paramlists.get(matchIdx))) {
          matchIdx = i;
          tied = false;
        } else if (Arrays.equals((Object[])paramlists.get(matchIdx), (Object[])paramlists.get(i))) {
          if (((Class)rets.get(matchIdx)).isAssignableFrom((Class)rets.get(i)))
            matchIdx = i; 
        } else if (!subsumes((Class[])paramlists.get(matchIdx), (Class[])paramlists.get(i))) {
          tied = true;
        } 
      } 
    } 
    if (tied)
      throw new IllegalArgumentException("More than one matching method found: " + methodName); 
    return matchIdx;
  }
  
  public static String munge(String name) {
    StringBuilder sb = new StringBuilder();
    for (char c : name.toCharArray()) {
      String sub = (String)CHAR_MAP.valAt(Character.valueOf(c));
      if (sub != null) {
        sb.append(sub);
      } else {
        sb.append(c);
      } 
    } 
    return sb.toString();
  }
  
  public static String demunge(String mungedName) {
    StringBuilder sb = new StringBuilder();
    Matcher m = DEMUNGE_PATTERN.matcher(mungedName);
    int lastMatchEnd = 0;
    while (m.find()) {
      int start = m.start();
      int end = m.end();
      sb.append(mungedName.substring(lastMatchEnd, start));
      lastMatchEnd = end;
      Character origCh = (Character)DEMUNGE_MAP.valAt(m.group());
      sb.append(origCh);
    } 
    sb.append(mungedName.substring(lastMatchEnd));
    return sb.toString();
  }
  
  static PathNode clearPathRoot() { return (PathNode)CLEAR_ROOT.get(); }
  
  private static LocalBinding registerLocal(Symbol sym, Symbol tag, Expr init, boolean isArg) {
    int num = getAndIncLocalNum();
    LocalBinding b = new LocalBinding(num, sym, tag, init, isArg, clearPathRoot());
    IPersistentMap localsMap = (IPersistentMap)LOCAL_ENV.deref();
    LOCAL_ENV.set(RT.assoc(localsMap, b.sym, b));
    ObjMethod method = (ObjMethod)METHOD.deref();
    method.locals = (IPersistentMap)RT.assoc(method.locals, b, b);
    method.indexlocals = (IPersistentMap)RT.assoc(method.indexlocals, Integer.valueOf(num), b);
    return b;
  }
  
  private static int getAndIncLocalNum() {
    num = ((Number)NEXT_LOCAL_NUM.deref()).intValue();
    ObjMethod m = (ObjMethod)METHOD.deref();
    if (num > m.maxLocal)
      m.maxLocal = num; 
    NEXT_LOCAL_NUM.set(Integer.valueOf(num + 1));
    return num;
  }
  
  public static Expr analyze(C context, Object form) { return analyze(context, form, null); }
  
  private static Expr analyze(C context, Object form, String name) {
    try {
      if (form instanceof LazySeq) {
        Object mform = form;
        form = RT.seq(form);
        if (form == null)
          form = PersistentList.EMPTY; 
        form = ((IObj)form).withMeta(RT.meta(mform));
      } 
      if (form == null)
        return NIL_EXPR; 
      if (form == Boolean.TRUE)
        return TRUE_EXPR; 
      if (form == Boolean.FALSE)
        return FALSE_EXPR; 
      Class fclass = form.getClass();
      if (fclass == Symbol.class)
        return analyzeSymbol((Symbol)form); 
      if (fclass == Keyword.class)
        return registerKeyword((Keyword)form); 
      if (form instanceof Number)
        return NumberExpr.parse((Number)form); 
      if (fclass == String.class)
        return new StringExpr(((String)form).intern()); 
      if (form instanceof IPersistentCollection && !(form instanceof IRecord) && !(form instanceof IType) && ((IPersistentCollection)form).count() == 0) {
        MetaExpr metaExpr = new EmptyExpr(form);
        if (RT.meta(form) != null)
          metaExpr = new MetaExpr(metaExpr, MapExpr.parse((context == C.EVAL) ? context : C.EXPRESSION, ((IObj)form).meta())); 
        return metaExpr;
      } 
      if (form instanceof ISeq)
        return analyzeSeq(context, (ISeq)form, name); 
      if (form instanceof IPersistentVector)
        return VectorExpr.parse(context, (IPersistentVector)form); 
      if (form instanceof IRecord)
        return new ConstantExpr(form); 
      if (form instanceof IType)
        return new ConstantExpr(form); 
      if (form instanceof IPersistentMap)
        return MapExpr.parse(context, (IPersistentMap)form); 
      if (form instanceof IPersistentSet)
        return SetExpr.parse(context, (IPersistentSet)form); 
      return new ConstantExpr(form);
    } catch (Throwable e) {
      if (!(e instanceof CompilerException))
        throw new CompilerException((String)SOURCE_PATH.deref(), lineDeref(), columnDeref(), e); 
      throw (CompilerException)e;
    } 
  }
  
  public static Var isMacro(Object op) {
    if (op instanceof Symbol && referenceLocal((Symbol)op) != null)
      return null; 
    if (op instanceof Symbol || op instanceof Var) {
      Var v = (op instanceof Var) ? (Var)op : lookupVar((Symbol)op, false, false);
      if (v != null && v.isMacro()) {
        if (v.ns != currentNS() && !v.isPublic())
          throw new IllegalStateException("var: " + v + " is not public"); 
        return v;
      } 
    } 
    return null;
  }
  
  public static IFn isInline(Object op, int arity) {
    if (op instanceof Symbol && referenceLocal((Symbol)op) != null)
      return null; 
    if (op instanceof Symbol || op instanceof Var) {
      Var v = (op instanceof Var) ? (Var)op : lookupVar((Symbol)op, false);
      if (v != null) {
        if (v.ns != currentNS() && !v.isPublic())
          throw new IllegalStateException("var: " + v + " is not public"); 
        IFn ret = (IFn)RT.get(v.meta(), inlineKey);
        if (ret != null) {
          IFn arityPred = (IFn)RT.get(v.meta(), inlineAritiesKey);
          if (arityPred == null || RT.booleanCast(arityPred.invoke(Integer.valueOf(arity))))
            return ret; 
        } 
      } 
    } 
    return null;
  }
  
  public static boolean namesStaticMember(Symbol sym) { return (sym.ns != null && namespaceFor(sym) == null); }
  
  public static Object preserveTag(ISeq src, Object dst) {
    Symbol tag = tagOf(src);
    if (tag != null && dst instanceof IObj) {
      IPersistentMap meta = RT.meta(dst);
      return ((IObj)dst).withMeta((IPersistentMap)RT.assoc(meta, RT.TAG_KEY, tag));
    } 
    return dst;
  }
  
  private static Var ensureMacroCheck() throws ClassNotFoundException, IOException {
    if (MACRO_CHECK == null)
      synchronized (MACRO_CHECK_LOCK) {
        if (MACRO_CHECK == null) {
          MACRO_CHECK_LOADING = true;
          RT.load("clojure/spec/alpha");
          RT.load("clojure/core/specs/alpha");
          MACRO_CHECK = Var.find(Symbol.intern("clojure.spec.alpha", "macroexpand-check"));
          MACRO_CHECK_LOADING = false;
        } 
      }  
    return MACRO_CHECK;
  }
  
  public static void checkSpecs(Var v, ISeq form) {
    if (RT.CHECK_SPECS && !MACRO_CHECK_LOADING)
      try {
        ensureMacroCheck().applyTo(RT.cons(v, RT.list(form.next())));
      } catch (Exception e) {
        throw new CompilerException((String)SOURCE_PATH.deref(), lineDeref(), columnDeref(), v.toSymbol(), CompilerException.PHASE_MACRO_SYNTAX_CHECK, e);
      }  
  }
  
  public static Object macroexpand1(Object x) {
    if (x instanceof ISeq) {
      ISeq form = (ISeq)x;
      Object op = RT.first(form);
      if (isSpecial(op))
        return x; 
      Var v = isMacro(op);
      if (v != null) {
        checkSpecs(v, form);
        try {
          ISeq args = RT.cons(form, RT.cons(LOCAL_ENV.get(), form.next()));
          return v.applyTo(args);
        } catch (ArityException e) {
          if (e.name.equals(munge(v.ns.name.name) + "$" + munge(v.sym.name)))
            throw new ArityException(e.actual - 2, e.name); 
          throw e;
        } catch (CompilerException e) {
          throw e;
        } catch (IllegalArgumentException|IllegalStateException|ExceptionInfo e) {
          throw new CompilerException((String)SOURCE_PATH.deref(), lineDeref(), columnDeref(), (op instanceof Symbol) ? (Symbol)op : null, CompilerException.PHASE_MACRO_SYNTAX_CHECK, e);
        } catch (Throwable e) {
          throw new CompilerException((String)SOURCE_PATH.deref(), lineDeref(), columnDeref(), (op instanceof Symbol) ? (Symbol)op : null, e.getClass().equals(Exception.class) ? CompilerException.PHASE_MACRO_SYNTAX_CHECK : CompilerException.PHASE_MACROEXPANSION, e);
        } 
      } 
      if (op instanceof Symbol) {
        Symbol sym = (Symbol)op;
        String sname = sym.name;
        if (sym.name.charAt(0) == '.') {
          if (RT.length(form) < 2)
            throw new IllegalArgumentException("Malformed member expression, expecting (.member target ...)"); 
          Symbol meth = Symbol.intern(sname.substring(1));
          Object target = RT.second(form);
          if (HostExpr.maybeClass(target, false) != null)
            target = ((IObj)RT.list(IDENTITY, target)).withMeta(RT.map(new Object[] { RT.TAG_KEY, CLASS })); 
          return preserveTag(form, RT.listStar(DOT, target, meth, form.next().next()));
        } 
        if (namesStaticMember(sym)) {
          Symbol target = Symbol.intern(sym.ns);
          Class c = HostExpr.maybeClass(target, false);
          if (c != null) {
            Symbol meth = Symbol.intern(sym.name);
            return preserveTag(form, RT.listStar(DOT, target, meth, form.next()));
          } 
        } else {
          int idx = sname.lastIndexOf('.');
          if (idx == sname.length() - 1)
            return RT.listStar(NEW, Symbol.intern(sname.substring(0, idx)), form.next()); 
        } 
      } 
    } 
    return x;
  }
  
  static Object macroexpand(Object form) {
    Object exf = macroexpand1(form);
    if (exf != form)
      return macroexpand(exf); 
    return form;
  }
  
  private static Expr analyzeSeq(C context, ISeq form, String name) {
    Object line = Integer.valueOf(lineDeref());
    Object column = Integer.valueOf(columnDeref());
    if (RT.meta(form) != null && RT.meta(form).containsKey(RT.LINE_KEY))
      line = RT.meta(form).valAt(RT.LINE_KEY); 
    if (RT.meta(form) != null && RT.meta(form).containsKey(RT.COLUMN_KEY))
      column = RT.meta(form).valAt(RT.COLUMN_KEY); 
    Var.pushThreadBindings(RT.map(new Object[] { LINE, line, COLUMN, column }));
    Object op = null;
    try {
      Object me = macroexpand1(form);
      if (me != form)
        return analyze(context, me, name); 
      op = RT.first(form);
      if (op == null)
        throw new IllegalArgumentException("Can't call nil, form: " + form); 
      IFn inline = isInline(op, RT.count(RT.next(form)));
      if (inline != null)
        return analyze(context, preserveTag(form, inline.applyTo(RT.next(form)))); 
      if (op.equals(FN))
        return FnExpr.parse(context, form, name); 
      IParser p;
      if ((p = (IParser)specials.valAt(op)) != null)
        return p.parse(context, form); 
      return InvokeExpr.parse(context, form);
    } catch (Throwable e) {
      Symbol s = (op != null && op instanceof Symbol) ? (Symbol)op : null;
      if (!(e instanceof CompilerException))
        throw new CompilerException((String)SOURCE_PATH.deref(), lineDeref(), columnDeref(), s, e); 
      throw (CompilerException)e;
    } finally {
      Var.popThreadBindings();
    } 
  }
  
  static String errorMsg(String source, int line, int column, String s) { return String.format("%s, compiling:(%s:%d:%d)", new Object[] { s, source, Integer.valueOf(line), Integer.valueOf(column) }); }
  
  public static Object eval(Object form) { return eval(form, true); }
  
  public static Object eval(Object form, boolean freshLoader) {
    createdLoader = false;
    Var.pushThreadBindings(RT.map(new Object[] { LOADER, RT.makeClassLoader() }));
    createdLoader = true;
    try {
      IPersistentMap meta = RT.meta(form);
      Object line = (meta != null) ? meta.valAt(RT.LINE_KEY, LINE.deref()) : LINE.deref();
      Object column = (meta != null) ? meta.valAt(RT.COLUMN_KEY, COLUMN.deref()) : COLUMN.deref();
      IPersistentMap bindings = RT.mapUniqueKeys(new Object[] { LINE, line, COLUMN, column });
      if (meta != null) {
        Object eval_file = meta.valAt(RT.EVAL_FILE_KEY);
        if (eval_file != null) {
          bindings = bindings.assoc(SOURCE_PATH, eval_file);
          try {
            bindings = bindings.assoc(SOURCE, (new File((String)eval_file)).getName());
          } catch (Throwable throwable) {}
        } 
      } 
      Var.pushThreadBindings(bindings);
    } finally {
      if (createdLoader)
        Var.popThreadBindings(); 
    } 
  }
  
  private static int registerConstant(Object o) {
    if (!CONSTANTS.isBound())
      return -1; 
    PersistentVector v = (PersistentVector)CONSTANTS.deref();
    IdentityHashMap<Object, Integer> ids = (IdentityHashMap)CONSTANT_IDS.deref();
    Integer i = (Integer)ids.get(o);
    if (i != null)
      return i.intValue(); 
    CONSTANTS.set(RT.conj(v, o));
    ids.put(o, Integer.valueOf(v.count()));
    return v.count();
  }
  
  private static KeywordExpr registerKeyword(Keyword keyword) {
    if (!KEYWORDS.isBound())
      return new KeywordExpr(keyword); 
    IPersistentMap keywordsMap = (IPersistentMap)KEYWORDS.deref();
    Object id = RT.get(keywordsMap, keyword);
    if (id == null)
      KEYWORDS.set(RT.assoc(keywordsMap, keyword, Integer.valueOf(registerConstant(keyword)))); 
    return new KeywordExpr(keyword);
  }
  
  private static int registerKeywordCallsite(Keyword keyword) {
    if (!KEYWORD_CALLSITES.isBound())
      throw new IllegalAccessError("KEYWORD_CALLSITES is not bound"); 
    IPersistentVector keywordCallsites = (IPersistentVector)KEYWORD_CALLSITES.deref();
    keywordCallsites = keywordCallsites.cons(keyword);
    KEYWORD_CALLSITES.set(keywordCallsites);
    return keywordCallsites.count() - 1;
  }
  
  private static int registerProtocolCallsite(Var v) {
    if (!PROTOCOL_CALLSITES.isBound())
      throw new IllegalAccessError("PROTOCOL_CALLSITES is not bound"); 
    IPersistentVector protocolCallsites = (IPersistentVector)PROTOCOL_CALLSITES.deref();
    protocolCallsites = protocolCallsites.cons(v);
    PROTOCOL_CALLSITES.set(protocolCallsites);
    return protocolCallsites.count() - 1;
  }
  
  private static void registerVarCallsite(Var v) {
    if (!VAR_CALLSITES.isBound())
      throw new IllegalAccessError("VAR_CALLSITES is not bound"); 
    IPersistentCollection varCallsites = (IPersistentCollection)VAR_CALLSITES.deref();
    varCallsites = varCallsites.cons(v);
    VAR_CALLSITES.set(varCallsites);
  }
  
  static ISeq fwdPath(PathNode p1) {
    ISeq ret = null;
    for (; p1 != null; p1 = p1.parent)
      ret = RT.cons(p1, ret); 
    return ret;
  }
  
  static PathNode commonPath(PathNode n1, PathNode n2) {
    ISeq xp = fwdPath(n1);
    ISeq yp = fwdPath(n2);
    if (RT.first(xp) != RT.first(yp))
      return null; 
    while (RT.second(xp) != null && RT.second(xp) == RT.second(yp)) {
      xp = xp.next();
      yp = yp.next();
    } 
    return (PathNode)RT.first(xp);
  }
  
  static void addAnnotation(Object visitor, IPersistentMap meta) {
    if (meta != null && ADD_ANNOTATIONS.isBound())
      ADD_ANNOTATIONS.invoke(visitor, meta); 
  }
  
  static void addParameterAnnotation(Object visitor, IPersistentMap meta, int i) {
    if (meta != null && ADD_ANNOTATIONS.isBound())
      ADD_ANNOTATIONS.invoke(visitor, meta, Integer.valueOf(i)); 
  }
  
  private static Expr analyzeSymbol(Symbol sym) {
    Symbol tag = tagOf(sym);
    if (sym.ns == null) {
      LocalBinding b = referenceLocal(sym);
      if (b != null)
        return new LocalBindingExpr(b, tag); 
    } else if (namespaceFor(sym) == null) {
      Symbol nsSym = Symbol.intern(sym.ns);
      Class c = HostExpr.maybeClass(nsSym, false);
      if (c != null) {
        if (Reflector.getField(c, sym.name, true) != null)
          return new StaticFieldExpr(lineDeref(), columnDeref(), c, sym.name, tag); 
        throw Util.runtimeException("Unable to find static field: " + sym.name + " in " + c);
      } 
    } 
    Object o = resolve(sym);
    if (o instanceof Var) {
      Var v = (Var)o;
      if (isMacro(v) != null)
        throw Util.runtimeException("Can't take value of a macro: " + v); 
      if (RT.booleanCast(RT.get(v.meta(), RT.CONST_KEY)))
        return analyze(C.EXPRESSION, RT.list(QUOTE, v.get())); 
      registerVar(v);
      return new VarExpr(v, tag);
    } 
    if (o instanceof Class)
      return new ConstantExpr(o); 
    if (o instanceof Symbol)
      return new UnresolvedVarExpr((Symbol)o); 
    throw Util.runtimeException("Unable to resolve symbol: " + sym + " in this context");
  }
  
  static String destubClassName(String className) {
    if (className.startsWith("compile__stub"))
      return className.substring("compile__stub".length() + 1); 
    return className;
  }
  
  static Type getType(Class c) {
    String descriptor = Type.getType(c).getDescriptor();
    if (descriptor.startsWith("L"))
      descriptor = "L" + destubClassName(descriptor.substring(1)); 
    return Type.getType(descriptor);
  }
  
  static Object resolve(Symbol sym, boolean allowPrivate) { return resolveIn(currentNS(), sym, allowPrivate); }
  
  static Object resolve(Symbol sym) { return resolveIn(currentNS(), sym, false); }
  
  static Namespace namespaceFor(Symbol sym) { return namespaceFor(currentNS(), sym); }
  
  static Namespace namespaceFor(Namespace inns, Symbol sym) {
    Symbol nsSym = Symbol.intern(sym.ns);
    Namespace ns = inns.lookupAlias(nsSym);
    if (ns == null)
      ns = Namespace.find(nsSym); 
    return ns;
  }
  
  public static Object resolveIn(Namespace n, Symbol sym, boolean allowPrivate) {
    if (sym.ns != null) {
      Namespace ns = namespaceFor(n, sym);
      if (ns == null)
        throw Util.runtimeException("No such namespace: " + sym.ns); 
      Var v = ns.findInternedVar(Symbol.intern(sym.name));
      if (v == null)
        throw Util.runtimeException("No such var: " + sym); 
      if (v.ns != currentNS() && !v.isPublic() && !allowPrivate)
        throw new IllegalStateException("var: " + sym + " is not public"); 
      return v;
    } 
    if (sym.name.indexOf('.') > 0 || sym.name.charAt(0) == '[')
      return RT.classForName(sym.name); 
    if (sym.equals(NS))
      return RT.NS_VAR; 
    if (sym.equals(IN_NS))
      return RT.IN_NS_VAR; 
    if (Util.equals(sym, COMPILE_STUB_SYM.get()))
      return COMPILE_STUB_CLASS.get(); 
    Object o = n.getMapping(sym);
    if (o == null) {
      if (RT.booleanCast(RT.ALLOW_UNRESOLVED_VARS.deref()))
        return sym; 
      throw Util.runtimeException("Unable to resolve symbol: " + sym + " in this context");
    } 
    return o;
  }
  
  public static Object maybeResolveIn(Namespace n, Symbol sym) {
    if (sym.ns != null) {
      Namespace ns = namespaceFor(n, sym);
      if (ns == null)
        return null; 
      Var v = ns.findInternedVar(Symbol.intern(sym.name));
      if (v == null)
        return null; 
      return v;
    } 
    if ((sym.name.indexOf('.') > 0 && !sym.name.endsWith(".")) || sym.name.charAt(0) == '[')
      try {
        return RT.classForName(sym.name);
      } catch (Exception e) {
        if (e instanceof ClassNotFoundException)
          return null; 
        return Util.sneakyThrow(e);
      }  
    if (sym.equals(NS))
      return RT.NS_VAR; 
    if (sym.equals(IN_NS))
      return RT.IN_NS_VAR; 
    return n.getMapping(sym);
  }
  
  static Var lookupVar(Symbol sym, boolean internNew, boolean registerMacro) {
    Var var = null;
    if (sym.ns != null) {
      Namespace ns = namespaceFor(sym);
      if (ns == null)
        return null; 
      Symbol name = Symbol.intern(sym.name);
      if (internNew && ns == currentNS()) {
        var = currentNS().intern(name);
      } else {
        var = ns.findInternedVar(name);
      } 
    } else if (sym.equals(NS)) {
      var = RT.NS_VAR;
    } else if (sym.equals(IN_NS)) {
      var = RT.IN_NS_VAR;
    } else {
      Object o = currentNS().getMapping(sym);
      if (o == null) {
        if (internNew)
          var = currentNS().intern(Symbol.intern(sym.name)); 
      } else if (o instanceof Var) {
        var = (Var)o;
      } else {
        throw Util.runtimeException("Expecting var, but " + sym + " is mapped to " + o);
      } 
    } 
    if (var != null && (!var.isMacro() || registerMacro))
      registerVar(var); 
    return var;
  }
  
  static Var lookupVar(Symbol sym, boolean internNew) { return lookupVar(sym, internNew, true); }
  
  private static void registerVar(Var var) {
    if (!VARS.isBound())
      return; 
    IPersistentMap varsMap = (IPersistentMap)VARS.deref();
    Object id = RT.get(varsMap, var);
    if (id == null)
      VARS.set(RT.assoc(varsMap, var, Integer.valueOf(registerConstant(var)))); 
  }
  
  static Namespace currentNS() { return (Namespace)RT.CURRENT_NS.deref(); }
  
  static void closeOver(LocalBinding b, ObjMethod method) {
    if (b != null && method != null) {
      LocalBinding lb = (LocalBinding)RT.get(method.locals, b);
      if (lb == null) {
        method.objx.closes = (IPersistentMap)RT.assoc(method.objx.closes, b, b);
        closeOver(b, method.parent);
      } else {
        if (lb.idx == 0)
          method.usesThis = true; 
        if (IN_CATCH_FINALLY.deref() != null)
          method.localsUsedInCatchFinally = (PersistentHashSet)method.localsUsedInCatchFinally.cons(Integer.valueOf(b.idx)); 
      } 
    } 
  }
  
  static LocalBinding referenceLocal(Symbol sym) {
    if (!LOCAL_ENV.isBound())
      return null; 
    LocalBinding b = (LocalBinding)RT.get(LOCAL_ENV.deref(), sym);
    if (b != null) {
      ObjMethod method = (ObjMethod)METHOD.deref();
      if (b.idx == 0)
        method.usesThis = true; 
      closeOver(b, method);
    } 
    return b;
  }
  
  private static Symbol tagOf(Object o) {
    Object tag = RT.get(RT.meta(o), RT.TAG_KEY);
    if (tag instanceof Symbol)
      return (Symbol)tag; 
    if (tag instanceof String)
      return Symbol.intern(null, (String)tag); 
    return null;
  }
  
  public static Object loadFile(String file) throws IOException {
    f = new FileInputStream(file);
    try {
      return load(new InputStreamReader(f, RT.UTF8), (new File(file)).getAbsolutePath(), (new File(file)).getName());
    } finally {
      f.close();
    } 
  }
  
  public static Object load(Reader rdr) { return load(rdr, null, "NO_SOURCE_FILE"); }
  
  static void consumeWhitespaces(LineNumberingPushbackReader pushbackReader) {
    int ch = LispReader.read1(pushbackReader);
    while (LispReader.isWhitespace(ch))
      ch = LispReader.read1(pushbackReader); 
    LispReader.unread(pushbackReader, ch);
  }
  
  private static Object readerOpts(String sourceName) throws IOException {
    if (sourceName != null && sourceName.endsWith(".cljc"))
      return OPTS_COND_ALLOWED; 
    return null;
  }
  
  public static Object load(Reader rdr, String sourcePath, String sourceName) {
    Object EOF = new Object();
    Object ret = null;
    LineNumberingPushbackReader pushbackReader = (rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader)rdr : new LineNumberingPushbackReader(rdr);
    consumeWhitespaces(pushbackReader);
    Var.pushThreadBindings(
        RT.mapUniqueKeys(new Object[] { 
            LOADER, RT.makeClassLoader(), SOURCE_PATH, sourcePath, SOURCE, sourceName, METHOD, null, LOCAL_ENV, null, 
            LOOP_LOCALS, null, NEXT_LOCAL_NUM, 




            
            Integer.valueOf(0), RT.READEVAL, RT.T, RT.CURRENT_NS, RT.CURRENT_NS
            
            .deref(), LINE_BEFORE, 
            Integer.valueOf(pushbackReader.getLineNumber()), 
            COLUMN_BEFORE, 
            Integer.valueOf(pushbackReader.getColumnNumber()), LINE_AFTER, 
            Integer.valueOf(pushbackReader.getLineNumber()), COLUMN_AFTER, 
            Integer.valueOf(pushbackReader.getColumnNumber()), RT.UNCHECKED_MATH, RT.UNCHECKED_MATH
            .deref(), RT.WARN_ON_REFLECTION, RT.WARN_ON_REFLECTION
            .deref(), 
            RT.DATA_READERS, RT.DATA_READERS
            .deref() }));
    Object readerOpts = readerOpts(sourceName);
    try {
      for (Object r = LispReader.read(pushbackReader, false, EOF, false, readerOpts); r != EOF; 
        r = LispReader.read(pushbackReader, false, EOF, false, readerOpts)) {
        consumeWhitespaces(pushbackReader);
        LINE_AFTER.set(Integer.valueOf(pushbackReader.getLineNumber()));
        COLUMN_AFTER.set(Integer.valueOf(pushbackReader.getColumnNumber()));
        ret = eval(r, false);
        LINE_BEFORE.set(Integer.valueOf(pushbackReader.getLineNumber()));
        COLUMN_BEFORE.set(Integer.valueOf(pushbackReader.getColumnNumber()));
      } 
    } catch (ReaderException e) {
      throw new CompilerException(sourcePath, e.line, e.column, null, CompilerException.PHASE_READ, e.getCause());
    } catch (Throwable e) {
      if (!(e instanceof CompilerException))
        throw new CompilerException(sourcePath, ((Integer)LINE_BEFORE.deref()).intValue(), ((Integer)COLUMN_BEFORE.deref()).intValue(), e); 
      throw (CompilerException)e;
    } finally {
      Var.popThreadBindings();
    } 
    return ret;
  }
  
  public static void writeClassFile(String internalName, byte[] bytecode) throws IOException {
    String genPath = (String)COMPILE_PATH.deref();
    if (genPath == null)
      throw Util.runtimeException("*compile-path* not set"); 
    String[] dirs = internalName.split("/");
    String p = genPath;
    for (int i = 0; i < dirs.length - 1; i++) {
      p = p + File.separator + dirs[i];
      (new File(p)).mkdir();
    } 
    String path = genPath + File.separator + internalName + ".class";
    File cf = new File(path);
    cf.createNewFile();
    cfs = new FileOutputStream(cf);
    try {
      cfs.write(bytecode);
      cfs.flush();
    } finally {
      cfs.close();
    } 
  }
  
  public static void pushNS() {
    Var.pushThreadBindings(PersistentHashMap.create(new Object[] { Var.intern(Symbol.intern("clojure.core"), 
              Symbol.intern("*ns*")).setDynamic(), null }));
  }
  
  public static void pushNSandLoader(ClassLoader loader) {
    Var.pushThreadBindings(RT.map(new Object[] { Var.intern(Symbol.intern("clojure.core"), 
              Symbol.intern("*ns*")).setDynamic(), null, RT.FN_LOADER_VAR, loader, RT.READEVAL, RT.T }));
  }
  
  public static ILookupThunk getLookupThunk(Object target, Keyword k) { return null; }
  
  static void compile1(GeneratorAdapter gen, ObjExpr objx, Object form) {
    Object line = Integer.valueOf(lineDeref());
    Object column = Integer.valueOf(columnDeref());
    if (RT.meta(form) != null && RT.meta(form).containsKey(RT.LINE_KEY))
      line = RT.meta(form).valAt(RT.LINE_KEY); 
    if (RT.meta(form) != null && RT.meta(form).containsKey(RT.COLUMN_KEY))
      column = RT.meta(form).valAt(RT.COLUMN_KEY); 
    Var.pushThreadBindings(
        RT.map(new Object[] { LINE, line, COLUMN, column, LOADER, RT.makeClassLoader() }));
    try {
      form = macroexpand(form);
      if (form instanceof ISeq && Util.equals(RT.first(form), DO)) {
        for (ISeq s = RT.next(form); s != null; s = RT.next(s))
          compile1(gen, objx, RT.first(s)); 
      } else {
        Expr expr = analyze(C.EVAL, form);
        objx.keywords = (IPersistentMap)KEYWORDS.deref();
        objx.vars = (IPersistentMap)VARS.deref();
        objx.constants = (PersistentVector)CONSTANTS.deref();
        expr.emit(C.EXPRESSION, objx, gen);
        expr.eval();
      } 
    } finally {
      Var.popThreadBindings();
    } 
  }
  
  public static Object compile(Reader rdr, String sourcePath, String sourceName) {
    if (COMPILE_PATH.deref() == null)
      throw Util.runtimeException("*compile-path* not set"); 
    Object EOF = new Object();
    Object ret = null;
    LineNumberingPushbackReader pushbackReader = (rdr instanceof LineNumberingPushbackReader) ? (LineNumberingPushbackReader)rdr : new LineNumberingPushbackReader(rdr);
    Var.pushThreadBindings(
        RT.mapUniqueKeys(new Object[] { 
            SOURCE_PATH, sourcePath, SOURCE, sourceName, METHOD, null, LOCAL_ENV, null, LOOP_LOCALS, null, 
            NEXT_LOCAL_NUM, Integer.valueOf(0), RT.READEVAL, RT.T, RT.CURRENT_NS, RT.CURRENT_NS
            
            .deref(), LINE_BEFORE, 
            Integer.valueOf(pushbackReader.getLineNumber()), COLUMN_BEFORE, 
            Integer.valueOf(pushbackReader.getColumnNumber()), 
            LINE_AFTER, 
            Integer.valueOf(pushbackReader.getLineNumber()), COLUMN_AFTER, 
            Integer.valueOf(pushbackReader.getColumnNumber()), CONSTANTS, PersistentVector.EMPTY, CONSTANT_IDS, new IdentityHashMap(), KEYWORDS, PersistentHashMap.EMPTY, 
            VARS, PersistentHashMap.EMPTY, RT.UNCHECKED_MATH, RT.UNCHECKED_MATH



            
            .deref(), RT.WARN_ON_REFLECTION, RT.WARN_ON_REFLECTION
            .deref(), RT.DATA_READERS, RT.DATA_READERS
            .deref() }));
    try {
      ObjExpr objx = new ObjExpr(null);
      objx.internalName = sourcePath.replace(File.separator, "/").substring(0, sourcePath.lastIndexOf('.')) + "__init";
      objx.objtype = Type.getObjectType(objx.internalName);
      ClassWriter cw = classWriter();
      ClassWriter classWriter = cw;
      classWriter.visit(52, 33, objx.internalName, null, "java/lang/Object", null);
      GeneratorAdapter gen = new GeneratorAdapter(9, Method.getMethod("void load ()"), null, null, classWriter);
      gen.visitCode();
      Object readerOpts = readerOpts(sourceName);
      for (Object r = LispReader.read(pushbackReader, false, EOF, false, readerOpts); r != EOF; 
        r = LispReader.read(pushbackReader, false, EOF, false, readerOpts)) {
        LINE_AFTER.set(Integer.valueOf(pushbackReader.getLineNumber()));
        COLUMN_AFTER.set(Integer.valueOf(pushbackReader.getColumnNumber()));
        compile1(gen, objx, r);
        LINE_BEFORE.set(Integer.valueOf(pushbackReader.getLineNumber()));
        COLUMN_BEFORE.set(Integer.valueOf(pushbackReader.getColumnNumber()));
      } 
      gen.returnValue();
      gen.endMethod();
      for (int i = 0; i < objx.constants.count(); i++) {
        if (objx.usedConstants.contains(Integer.valueOf(i)))
          classWriter.visitField(25, objx.constantName(i), objx.constantType(i).getDescriptor(), null, null); 
      } 
      int INITS_PER = 100;
      int numInits = objx.constants.count() / 100;
      if (objx.constants.count() % 100 != 0)
        numInits++; 
      for (int n = 0; n < numInits; n++) {
        GeneratorAdapter clinitgen = new GeneratorAdapter(9, Method.getMethod("void __init" + n + "()"), null, null, classWriter);
        clinitgen.visitCode();
        try {
          Var.pushThreadBindings(RT.map(new Object[] { RT.PRINT_DUP, RT.T }));
          for (int i = n * 100; i < objx.constants.count() && i < (n + 1) * 100; i++) {
            if (objx.usedConstants.contains(Integer.valueOf(i))) {
              objx.emitValue(objx.constants.nth(i), clinitgen);
              clinitgen.checkCast(objx.constantType(i));
              clinitgen.putStatic(objx.objtype, objx.constantName(i), objx.constantType(i));
            } 
          } 
        } finally {
          Var.popThreadBindings();
        } 
        clinitgen.returnValue();
        clinitgen.endMethod();
      } 
      GeneratorAdapter clinitgen = new GeneratorAdapter(9, Method.getMethod("void <clinit> ()"), null, null, classWriter);
      clinitgen.visitCode();
      Label startTry = clinitgen.newLabel();
      Label endTry = clinitgen.newLabel();
      Label end = clinitgen.newLabel();
      Label finallyLabel = clinitgen.newLabel();
      for (int n = 0; n < numInits; n++)
        clinitgen.invokeStatic(objx.objtype, Method.getMethod("void __init" + n + "()")); 
      clinitgen.push(objx.internalName.replace('/', '.'));
      clinitgen.invokeStatic(RT_TYPE, Method.getMethod("Class classForName(String)"));
      clinitgen.invokeVirtual(CLASS_TYPE, Method.getMethod("ClassLoader getClassLoader()"));
      clinitgen.invokeStatic(Type.getType(Compiler.class), Method.getMethod("void pushNSandLoader(ClassLoader)"));
      clinitgen.mark(startTry);
      clinitgen.invokeStatic(objx.objtype, Method.getMethod("void load()"));
      clinitgen.mark(endTry);
      clinitgen.invokeStatic(VAR_TYPE, Method.getMethod("void popThreadBindings()"));
      clinitgen.goTo(end);
      clinitgen.mark(finallyLabel);
      clinitgen.invokeStatic(VAR_TYPE, Method.getMethod("void popThreadBindings()"));
      clinitgen.throwException();
      clinitgen.mark(end);
      clinitgen.visitTryCatchBlock(startTry, endTry, finallyLabel, null);
      clinitgen.returnValue();
      clinitgen.endMethod();
      classWriter.visitEnd();
      writeClassFile(objx.internalName, cw.toByteArray());
    } catch (ReaderException e) {
      throw new CompilerException(sourcePath, e.line, e.column, e.getCause());
    } finally {
      Var.popThreadBindings();
    } 
    return ret;
  }
  
  static boolean inty(Class c) { return (c == int.class || c == short.class || c == byte.class || c == char.class); }
  
  static Class retType(Class tc, Class ret) {
    if (tc == null)
      return ret; 
    if (ret == null)
      return tc; 
    if (ret.isPrimitive() && tc.isPrimitive()) {
      if ((inty(ret) && inty(tc)) || ret == tc)
        return tc; 
      throw new UnsupportedOperationException("Cannot coerce " + ret + " to " + tc + ", use a cast instead");
    } 
    return tc;
  }
  
  static Class primClass(Symbol sym) {
    if (sym == null)
      return null; 
    Class c = null;
    if (sym.name.equals("int")) {
      c = int.class;
    } else if (sym.name.equals("long")) {
      c = long.class;
    } else if (sym.name.equals("float")) {
      c = float.class;
    } else if (sym.name.equals("double")) {
      c = double.class;
    } else if (sym.name.equals("char")) {
      c = char.class;
    } else if (sym.name.equals("short")) {
      c = short.class;
    } else if (sym.name.equals("byte")) {
      c = byte.class;
    } else if (sym.name.equals("boolean")) {
      c = boolean.class;
    } else if (sym.name.equals("void")) {
      c = void.class;
    } 
    return c;
  }
  
  static Class tagClass(Object tag) {
    if (tag == null)
      return Object.class; 
    Class c = null;
    if (tag instanceof Symbol)
      c = primClass((Symbol)tag); 
    if (c == null)
      c = HostExpr.tagToClass(tag); 
    return c;
  }
  
  static Class primClass(Class c) { return c.isPrimitive() ? c : Object.class; }
  
  static Class boxClass(Class p) {
    if (!p.isPrimitive())
      return p; 
    Class c = null;
    if (p == int.class) {
      c = Integer.class;
    } else if (p == long.class) {
      c = Long.class;
    } else if (p == float.class) {
      c = Float.class;
    } else if (p == double.class) {
      c = Double.class;
    } else if (p == char.class) {
      c = Character.class;
    } else if (p == short.class) {
      c = Short.class;
    } else if (p == byte.class) {
      c = Byte.class;
    } else if (p == boolean.class) {
      c = Boolean.class;
    } 
    return c;
  }
  
  static IPersistentCollection emptyVarCallSites() { return PersistentHashSet.EMPTY; }
  
  public static ClassWriter classWriter() { return new Object(3); }
}
