package clojure.lang;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;

public class PersistentVector extends APersistentVector implements IObj, IEditableCollection, IReduce, IKVReduce {
  static final AtomicReference<Thread> NOEDIT = new AtomicReference(null);
  
  public static final Node EMPTY_NODE = new Node(NOEDIT, new Object[32]);
  
  final int cnt;
  
  public final int shift;
  
  public final Node root;
  
  public final Object[] tail;
  
  final IPersistentMap _meta;
  
  public static final PersistentVector EMPTY = new PersistentVector(0, 5, EMPTY_NODE, new Object[0]);
  
  private static final IFn TRANSIENT_VECTOR_CONJ = new Object();
  
  public static PersistentVector adopt(Object[] items) { return new PersistentVector(items.length, 5, EMPTY_NODE, items); }
  
  public static PersistentVector create(IReduceInit items) {
    TransientVector ret = EMPTY.asTransient();
    items.reduce(TRANSIENT_VECTOR_CONJ, ret);
    return ret.persistent();
  }
  
  public static PersistentVector create(ISeq items) {
    Object[] arr = new Object[32];
    int i = 0;
    for (; items != null && i < 32; items = items.next())
      arr[i++] = items.first(); 
    if (items != null) {
      PersistentVector start = new PersistentVector(32, 5, EMPTY_NODE, arr);
      TransientVector ret = start.asTransient();
      for (; items != null; items = items.next())
        ret = ret.conj(items.first()); 
      return ret.persistent();
    } 
    if (i == 32)
      return new PersistentVector(32, 5, EMPTY_NODE, arr); 
    Object[] arr2 = new Object[i];
    System.arraycopy(arr, 0, arr2, 0, i);
    return new PersistentVector(i, 5, EMPTY_NODE, arr2);
  }
  
  public static PersistentVector create(List list) {
    int size = list.size();
    if (size <= 32)
      return new PersistentVector(size, 5, EMPTY_NODE, list.toArray()); 
    TransientVector ret = EMPTY.asTransient();
    for (int i = 0; i < size; i++)
      ret = ret.conj(list.get(i)); 
    return ret.persistent();
  }
  
  public static PersistentVector create(Iterable items) {
    if (items instanceof ArrayList)
      return create((ArrayList)items); 
    Iterator iter = items.iterator();
    TransientVector ret = EMPTY.asTransient();
    while (iter.hasNext())
      ret = ret.conj(iter.next()); 
    return ret.persistent();
  }
  
  public static PersistentVector create(Object... items) {
    TransientVector ret = EMPTY.asTransient();
    for (Object item : items)
      ret = ret.conj(item); 
    return ret.persistent();
  }
  
  PersistentVector(int cnt, int shift, Node root, Object[] tail) {
    this._meta = null;
    this.cnt = cnt;
    this.shift = shift;
    this.root = root;
    this.tail = tail;
  }
  
  PersistentVector(IPersistentMap meta, int cnt, int shift, Node root, Object[] tail) {
    this._meta = meta;
    this.cnt = cnt;
    this.shift = shift;
    this.root = root;
    this.tail = tail;
  }
  
  public TransientVector asTransient() { return new TransientVector(this); }
  
  final int tailoff() {
    if (this.cnt < 32)
      return 0; 
    return this.cnt - 1 >>> 5 << 5;
  }
  
  public Object[] arrayFor(int i) {
    if (i >= 0 && i < this.cnt) {
      if (i >= tailoff())
        return this.tail; 
      Node node = this.root;
      for (int level = this.shift; level > 0; level -= 5)
        node = (Node)node.array[i >>> level & 0x1F]; 
      return node.array;
    } 
    throw new IndexOutOfBoundsException();
  }
  
  public Object nth(int i) {
    Object[] node = arrayFor(i);
    return node[i & 0x1F];
  }
  
  public Object nth(int i, Object notFound) {
    if (i >= 0 && i < this.cnt)
      return nth(i); 
    return notFound;
  }
  
  public PersistentVector assocN(int i, Object val) {
    if (i >= 0 && i < this.cnt) {
      if (i >= tailoff()) {
        Object[] newTail = new Object[this.tail.length];
        System.arraycopy(this.tail, 0, newTail, 0, this.tail.length);
        newTail[i & 0x1F] = val;
        return new PersistentVector(meta(), this.cnt, this.shift, this.root, newTail);
      } 
      return new PersistentVector(meta(), this.cnt, this.shift, doAssoc(this.shift, this.root, i, val), this.tail);
    } 
    if (i == this.cnt)
      return cons(val); 
    throw new IndexOutOfBoundsException();
  }
  
  private static Node doAssoc(int level, Node node, int i, Object val) {
    Node ret = new Node(node.edit, (Object[])node.array.clone());
    if (level == 0) {
      ret.array[i & 0x1F] = val;
    } else {
      int subidx = i >>> level & 0x1F;
      ret.array[subidx] = doAssoc(level - 5, (Node)node.array[subidx], i, val);
    } 
    return ret;
  }
  
  public int count() { return this.cnt; }
  
  public PersistentVector withMeta(IPersistentMap meta) {
    if (meta() == meta)
      return this; 
    return new PersistentVector(meta, this.cnt, this.shift, this.root, this.tail);
  }
  
  public IPersistentMap meta() { return this._meta; }
  
  public PersistentVector cons(Object val) {
    Node newroot;
    if (this.cnt - tailoff() < 32) {
      newroot = new Object[this.tail.length + 1];
      System.arraycopy(this.tail, 0, newroot, 0, this.tail.length);
      newroot[this.tail.length] = val;
      return new PersistentVector(meta(), this.cnt + 1, this.shift, this.root, newroot);
    } 
    Node tailnode = new Node(this.root.edit, this.tail);
    int newshift = this.shift;
    if (this.cnt >>> 5 > 1 << this.shift) {
      newroot = new Node(this.root.edit);
      newroot.array[0] = this.root;
      newroot.array[1] = newPath(this.root.edit, this.shift, tailnode);
      newshift += 5;
    } else {
      newroot = pushTail(this.shift, this.root, tailnode);
    } 
    return new PersistentVector(meta(), this.cnt + 1, newshift, newroot, new Object[] { val });
  }
  
  private Node pushTail(int level, Node parent, Node tailnode) {
    Node nodeToInsert;
    int subidx = this.cnt - 1 >>> level & 0x1F;
    Node ret = new Node(parent.edit, (Object[])parent.array.clone());
    if (level == 5) {
      nodeToInsert = tailnode;
    } else {
      Node child = (Node)parent.array[subidx];
      nodeToInsert = (child != null) ? pushTail(level - 5, child, tailnode) : newPath(this.root.edit, level - 5, tailnode);
    } 
    ret.array[subidx] = nodeToInsert;
    return ret;
  }
  
  private static Node newPath(AtomicReference<Thread> edit, int level, Node node) {
    if (level == 0)
      return node; 
    Node ret = new Node(edit);
    ret.array[0] = newPath(edit, level - 5, node);
    return ret;
  }
  
  public IChunkedSeq chunkedSeq() {
    if (count() == 0)
      return null; 
    return new ChunkedSeq(this, 0, 0);
  }
  
  public ISeq seq() { return chunkedSeq(); }
  
  Iterator rangedIterator(int start, int end) { return new Object(this, start, end); }
  
  public Iterator iterator() { return rangedIterator(0, count()); }
  
  public Object reduce(IFn f) {
    Object init;
    if (this.cnt > 0) {
      init = arrayFor(0)[0];
    } else {
      return f.invoke();
    } 
    int step = 0;
    int i;
    for (i = 0; i < this.cnt; i += step) {
      Object[] array = arrayFor(i);
      for (int j = (i == 0) ? 1 : 0; j < array.length; j++) {
        init = f.invoke(init, array[j]);
        if (RT.isReduced(init))
          return ((IDeref)init).deref(); 
      } 
      step = array.length;
    } 
    return init;
  }
  
  public Object reduce(IFn f, Object init) {
    int step = 0;
    int i;
    for (i = 0; i < this.cnt; i += step) {
      Object[] array = arrayFor(i);
      for (int j = 0; j < array.length; j++) {
        init = f.invoke(init, array[j]);
        if (RT.isReduced(init))
          return ((IDeref)init).deref(); 
      } 
      step = array.length;
    } 
    return init;
  }
  
  public Object kvreduce(IFn f, Object init) {
    int step = 0;
    int i;
    for (i = 0; i < this.cnt; i += step) {
      Object[] array = arrayFor(i);
      for (int j = 0; j < array.length; j++) {
        init = f.invoke(init, Integer.valueOf(j + i), array[j]);
        if (RT.isReduced(init))
          return ((IDeref)init).deref(); 
      } 
      step = array.length;
    } 
    return init;
  }
  
  public IPersistentCollection empty() { return EMPTY.withMeta(meta()); }
  
  public PersistentVector pop() {
    if (this.cnt == 0)
      throw new IllegalStateException("Can't pop empty vector"); 
    if (this.cnt == 1)
      return EMPTY.withMeta(meta()); 
    if (this.cnt - tailoff() > 1) {
      Object[] newTail = new Object[this.tail.length - 1];
      System.arraycopy(this.tail, 0, newTail, 0, newTail.length);
      return new PersistentVector(meta(), this.cnt - 1, this.shift, this.root, newTail);
    } 
    Object[] newtail = arrayFor(this.cnt - 2);
    Node newroot = popTail(this.shift, this.root);
    int newshift = this.shift;
    if (newroot == null)
      newroot = EMPTY_NODE; 
    if (this.shift > 5 && newroot.array[true] == null) {
      newroot = (Node)newroot.array[0];
      newshift -= 5;
    } 
    return new PersistentVector(meta(), this.cnt - 1, newshift, newroot, newtail);
  }
  
  private Node popTail(int level, Node node) {
    int subidx = this.cnt - 2 >>> level & 0x1F;
    if (level > 5) {
      Node newchild = popTail(level - 5, (Node)node.array[subidx]);
      if (newchild == null && subidx == 0)
        return null; 
      Node ret = new Node(this.root.edit, (Object[])node.array.clone());
      ret.array[subidx] = newchild;
      return ret;
    } 
    if (subidx == 0)
      return null; 
    Node ret = new Node(this.root.edit, (Object[])node.array.clone());
    ret.array[subidx] = null;
    return ret;
  }
}
