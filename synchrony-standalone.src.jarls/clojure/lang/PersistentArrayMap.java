package clojure.lang;

import java.util.Iterator;
import java.util.Map;

public class PersistentArrayMap extends APersistentMap implements IObj, IEditableCollection, IMapIterable, IKVReduce {
  final Object[] array;
  
  static final int HASHTABLE_THRESHOLD = 16;
  
  public static final PersistentArrayMap EMPTY = new PersistentArrayMap();
  
  private final IPersistentMap _meta;
  
  public static IPersistentMap create(Map other) {
    ITransientMap ret = EMPTY.asTransient();
    for (Object o : other.entrySet()) {
      Map.Entry e = (Map.Entry)o;
      ret = ret.assoc(e.getKey(), e.getValue());
    } 
    return ret.persistent();
  }
  
  protected PersistentArrayMap() {
    this.array = new Object[0];
    this._meta = null;
  }
  
  public PersistentArrayMap withMeta(IPersistentMap meta) {
    if (meta() == meta)
      return this; 
    return new PersistentArrayMap(meta, this.array);
  }
  
  PersistentArrayMap create(Object... init) { return new PersistentArrayMap(meta(), init); }
  
  IPersistentMap createHT(Object[] init) { return PersistentHashMap.create(meta(), init); }
  
  public static PersistentArrayMap createWithCheck(Object[] init) {
    for (int i = 0; i < init.length; i += 2) {
      for (int j = i + 2; j < init.length; j += 2) {
        if (equalKey(init[i], init[j]))
          throw new IllegalArgumentException("Duplicate key: " + init[i]); 
      } 
    } 
    return new PersistentArrayMap(init);
  }
  
  public static PersistentArrayMap createAsIfByAssoc(Object[] init) {
    if ((init.length & true) == 1)
      throw new IllegalArgumentException(String.format("No value supplied for key: %s", new Object[] { init[init.length - 1] })); 
    int n = 0;
    for (int i = 0; i < init.length; i += 2) {
      boolean duplicateKey = false;
      for (int j = 0; j < i; j += 2) {
        if (equalKey(init[i], init[j])) {
          duplicateKey = true;
          break;
        } 
      } 
      if (!duplicateKey)
        n += 2; 
    } 
    if (n < init.length) {
      Object[] nodups = new Object[n];
      int m = 0;
      for (int i = 0; i < init.length; i += 2) {
        boolean duplicateKey = false;
        for (int j = 0; j < m; j += 2) {
          if (equalKey(init[i], nodups[j])) {
            duplicateKey = true;
            break;
          } 
        } 
        if (!duplicateKey) {
          int j;
          for (j = init.length - 2; j >= i; j -= 2) {
            if (equalKey(init[i], init[j]))
              break; 
          } 
          nodups[m] = init[i];
          nodups[m + 1] = init[j + 1];
          m += 2;
        } 
      } 
      if (m != n)
        throw new IllegalArgumentException("Internal error: m=" + m); 
      init = nodups;
    } 
    return new PersistentArrayMap(init);
  }
  
  public PersistentArrayMap(Object[] init) {
    this.array = init;
    this._meta = null;
  }
  
  public PersistentArrayMap(IPersistentMap meta, Object[] init) {
    this._meta = meta;
    this.array = init;
  }
  
  public int count() { return this.array.length / 2; }
  
  public boolean containsKey(Object key) { return (indexOf(key) >= 0); }
  
  public IMapEntry entryAt(Object key) {
    int i = indexOf(key);
    if (i >= 0)
      return MapEntry.create(this.array[i], this.array[i + 1]); 
    return null;
  }
  
  public IPersistentMap assocEx(Object key, Object val) {
    int i = indexOf(key);
    if (i >= 0)
      throw Util.runtimeException("Key already present"); 
    if (this.array.length >= 16)
      return createHT(this.array).assocEx(key, val); 
    Object[] newArray = new Object[this.array.length + 2];
    if (this.array.length > 0)
      System.arraycopy(this.array, 0, newArray, 2, this.array.length); 
    newArray[0] = key;
    newArray[1] = val;
    return create(newArray);
  }
  
  public IPersistentMap assoc(Object key, Object val) {
    Object[] newArray;
    int i = indexOf(key);
    if (i >= 0) {
      if (this.array[i + true] == val)
        return this; 
      newArray = (Object[])this.array.clone();
      newArray[i + 1] = val;
    } else {
      if (this.array.length >= 16)
        return createHT(this.array).assoc(key, val); 
      newArray = new Object[this.array.length + 2];
      if (this.array.length > 0)
        System.arraycopy(this.array, 0, newArray, 0, this.array.length); 
      newArray[newArray.length - 2] = key;
      newArray[newArray.length - 1] = val;
    } 
    return create(newArray);
  }
  
  public IPersistentMap without(Object key) {
    int i = indexOf(key);
    if (i >= 0) {
      int newlen = this.array.length - 2;
      if (newlen == 0)
        return empty(); 
      Object[] newArray = new Object[newlen];
      System.arraycopy(this.array, 0, newArray, 0, i);
      System.arraycopy(this.array, i + 2, newArray, i, newlen - i);
      return create(newArray);
    } 
    return this;
  }
  
  public IPersistentMap empty() { return EMPTY.withMeta(meta()); }
  
  public final Object valAt(Object key, Object notFound) {
    int i = indexOf(key);
    if (i >= 0)
      return this.array[i + 1]; 
    return notFound;
  }
  
  public Object valAt(Object key) { return valAt(key, null); }
  
  public int capacity() { return count(); }
  
  private int indexOfObject(Object key) {
    Util.EquivPred ep = Util.equivPred(key);
    for (int i = 0; i < this.array.length; i += 2) {
      if (ep.equiv(key, this.array[i]))
        return i; 
    } 
    return -1;
  }
  
  private int indexOf(Object key) {
    if (key instanceof Keyword) {
      for (int i = 0; i < this.array.length; i += 2) {
        if (key == this.array[i])
          return i; 
      } 
      return -1;
    } 
    return indexOfObject(key);
  }
  
  static boolean equalKey(Object k1, Object k2) {
    if (k1 instanceof Keyword)
      return (k1 == k2); 
    return Util.equiv(k1, k2);
  }
  
  public Iterator iterator() { return new Iter(this.array, APersistentMap.MAKE_ENTRY); }
  
  public Iterator keyIterator() { return new Iter(this.array, APersistentMap.MAKE_KEY); }
  
  public Iterator valIterator() { return new Iter(this.array, APersistentMap.MAKE_VAL); }
  
  public ISeq seq() {
    if (this.array.length > 0)
      return new Seq(this.array, 0); 
    return null;
  }
  
  public IPersistentMap meta() { return this._meta; }
  
  public Object kvreduce(IFn f, Object init) {
    for (int i = 0; i < this.array.length; i += 2) {
      init = f.invoke(init, this.array[i], this.array[i + 1]);
      if (RT.isReduced(init))
        return ((IDeref)init).deref(); 
    } 
    return init;
  }
  
  public ITransientMap asTransient() { return new TransientArrayMap(this.array); }
}
