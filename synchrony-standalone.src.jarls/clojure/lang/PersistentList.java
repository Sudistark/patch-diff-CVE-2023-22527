package clojure.lang;

import java.util.List;
import java.util.ListIterator;

public class PersistentList extends ASeq implements IPersistentList, IReduce, List, Counted {
  private final Object _first;
  
  private final IPersistentList _rest;
  
  private final int _count;
  
  public static IFn creator = new Primordial();
  
  public static final EmptyList EMPTY = new EmptyList(null);
  
  public PersistentList(Object first) {
    this._first = first;
    this._rest = null;
    this._count = 1;
  }
  
  PersistentList(IPersistentMap meta, Object _first, IPersistentList _rest, int _count) {
    super(meta);
    this._first = _first;
    this._rest = _rest;
    this._count = _count;
  }
  
  public static IPersistentList create(List init) {
    IPersistentList iPersistentList = EMPTY;
    for (ListIterator i = init.listIterator(init.size()); i.hasPrevious();)
      iPersistentList = (IPersistentList)iPersistentList.cons(i.previous()); 
    return iPersistentList;
  }
  
  public Object first() { return this._first; }
  
  public ISeq next() {
    if (this._count == 1)
      return null; 
    return (ISeq)this._rest;
  }
  
  public Object peek() { return first(); }
  
  public IPersistentList pop() {
    if (this._rest == null)
      return EMPTY.withMeta(this._meta); 
    return this._rest;
  }
  
  public int count() { return this._count; }
  
  public PersistentList cons(Object o) { return new PersistentList(meta(), o, this, this._count + 1); }
  
  public IPersistentCollection empty() { return EMPTY.withMeta(meta()); }
  
  public PersistentList withMeta(IPersistentMap meta) {
    if (meta != this._meta)
      return new PersistentList(meta, this._first, this._rest, this._count); 
    return this;
  }
  
  public Object reduce(IFn f) {
    Object ret = first();
    for (ISeq s = next(); s != null; s = s.next()) {
      ret = f.invoke(ret, s.first());
      if (RT.isReduced(ret))
        return ((IDeref)ret).deref(); 
    } 
    return ret;
  }
  
  public Object reduce(IFn f, Object start) {
    Object ret = f.invoke(start, first());
    for (ISeq s = next(); s != null; s = s.next()) {
      if (RT.isReduced(ret))
        return ((IDeref)ret).deref(); 
      ret = f.invoke(ret, s.first());
    } 
    if (RT.isReduced(ret))
      return ((IDeref)ret).deref(); 
    return ret;
  }
}
