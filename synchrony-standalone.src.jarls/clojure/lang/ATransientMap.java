package clojure.lang;

import java.util.Map;

public abstract class ATransientMap extends AFn implements ITransientMap, ITransientAssociative2 {
  public ITransientMap conj(Object o) {
    ensureEditable();
    if (o instanceof Map.Entry) {
      Map.Entry e = (Map.Entry)o;
      return assoc(e.getKey(), e.getValue());
    } 
    if (o instanceof IPersistentVector) {
      IPersistentVector v = (IPersistentVector)o;
      if (v.count() != 2)
        throw new IllegalArgumentException("Vector arg to map conj must be a pair"); 
      return assoc(v.nth(0), v.nth(1));
    } 
    ITransientMap iTransientMap = this;
    for (ISeq es = RT.seq(o); es != null; es = es.next()) {
      Map.Entry e = (Map.Entry)es.first();
      iTransientMap = iTransientMap.assoc(e.getKey(), e.getValue());
    } 
    return iTransientMap;
  }
  
  public final Object invoke(Object arg1) { return valAt(arg1); }
  
  public final Object invoke(Object arg1, Object notFound) { return valAt(arg1, notFound); }
  
  public final Object valAt(Object key) { return valAt(key, null); }
  
  public final ITransientMap assoc(Object key, Object val) {
    ensureEditable();
    return doAssoc(key, val);
  }
  
  public final ITransientMap without(Object key) {
    ensureEditable();
    return doWithout(key);
  }
  
  public final IPersistentMap persistent() {
    ensureEditable();
    return doPersistent();
  }
  
  public final Object valAt(Object key, Object notFound) {
    ensureEditable();
    return doValAt(key, notFound);
  }
  
  private static final Object NOT_FOUND = new Object();
  
  public final boolean containsKey(Object key) { return (valAt(key, NOT_FOUND) != NOT_FOUND); }
  
  public final IMapEntry entryAt(Object key) {
    Object v = valAt(key, NOT_FOUND);
    if (v != NOT_FOUND)
      return MapEntry.create(key, v); 
    return null;
  }
  
  public final int count() {
    ensureEditable();
    return doCount();
  }
  
  abstract void ensureEditable();
  
  abstract ITransientMap doAssoc(Object paramObject1, Object paramObject2);
  
  abstract ITransientMap doWithout(Object paramObject);
  
  abstract Object doValAt(Object paramObject1, Object paramObject2);
  
  abstract int doCount();
  
  abstract IPersistentMap doPersistent();
}
