package clojure.lang;

import java.util.Map;

public abstract class ARef extends AReference implements IRef {
  public ARef() {}
  
  public ARef(IPersistentMap meta) { super(meta); }
  
  void validate(IFn vf, Object val) {
    try {
      if (vf != null && !RT.booleanCast(vf.invoke(val)))
        throw new IllegalStateException("Invalid reference state"); 
    } catch (RuntimeException re) {
      throw re;
    } catch (Exception e) {
      throw new IllegalStateException("Invalid reference state", e);
    } 
  }
  
  void validate(Object val) { validate(this.validator, val); }
  
  public void setValidator(IFn vf) {
    validate(vf, deref());
    this.validator = vf;
  }
  
  public IFn getValidator() { return this.validator; }
  
  public IPersistentMap getWatches() { return this.watches; }
  
  public IRef addWatch(Object key, IFn callback) {
    this.watches = this.watches.assoc(key, callback);
    return this;
  }
  
  public IRef removeWatch(Object key) {
    this.watches = this.watches.without(key);
    return this;
  }
  
  public void notifyWatches(Object oldval, Object newval) {
    IPersistentMap ws = this.watches;
    if (ws.count() > 0)
      for (ISeq s = ws.seq(); s != null; s = s.next()) {
        Map.Entry e = (Map.Entry)s.first();
        IFn fn = (IFn)e.getValue();
        if (fn != null)
          fn.invoke(e.getKey(), this, oldval, newval); 
      }  
  }
}
