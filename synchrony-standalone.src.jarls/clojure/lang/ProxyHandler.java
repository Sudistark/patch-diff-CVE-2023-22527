package clojure.lang;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class ProxyHandler implements InvocationHandler {
  final IPersistentMap fns;
  
  public ProxyHandler(IPersistentMap fns) { this.fns = fns; }
  
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    Class rt = method.getReturnType();
    IFn fn = (IFn)this.fns.valAt(method.getName());
    if (fn == null) {
      if (rt == void.class)
        return null; 
      if (method.getName().equals("equals"))
        return Boolean.valueOf((proxy == args[false])); 
      if (method.getName().equals("hashCode"))
        return Integer.valueOf(System.identityHashCode(proxy)); 
      if (method.getName().equals("toString"))
        return "Proxy: " + System.identityHashCode(proxy); 
      throw new UnsupportedOperationException();
    } 
    Object ret = fn.applyTo(ArraySeq.create(args));
    if (rt == void.class)
      return null; 
    if (rt.isPrimitive()) {
      if (rt == char.class)
        return ret; 
      if (rt == int.class)
        return Integer.valueOf(((Number)ret).intValue()); 
      if (rt == long.class)
        return Long.valueOf(((Number)ret).longValue()); 
      if (rt == float.class)
        return Float.valueOf(((Number)ret).floatValue()); 
      if (rt == double.class)
        return Double.valueOf(((Number)ret).doubleValue()); 
      if (rt == boolean.class && !(ret instanceof Boolean))
        return (ret == null) ? Boolean.FALSE : Boolean.TRUE; 
      if (rt == byte.class)
        return Byte.valueOf((byte)((Number)ret).intValue()); 
      if (rt == short.class)
        return Short.valueOf((short)((Number)ret).intValue()); 
    } 
    return ret;
  }
}
