package clojure.lang;

import java.util.Map;

public final class MethodImplCache {
  public final IPersistentMap protocol;
  
  public final Symbol sym;
  
  public final Keyword methodk;
  
  public final int shift;
  
  public final int mask;
  
  public final Object[] table;
  
  public final Map map;
  
  Entry mre;
  
  public MethodImplCache(Symbol sym, IPersistentMap protocol, Keyword methodk) { this(sym, protocol, methodk, 0, 0, RT.EMPTY_ARRAY); }
  
  public MethodImplCache(Symbol sym, IPersistentMap protocol, Keyword methodk, int shift, int mask, Object[] table) {
    this.mre = null;
    this.sym = sym;
    this.protocol = protocol;
    this.methodk = methodk;
    this.shift = shift;
    this.mask = mask;
    this.table = table;
    this.map = null;
  }
  
  public MethodImplCache(Symbol sym, IPersistentMap protocol, Keyword methodk, Map map) {
    this.mre = null;
    this.sym = sym;
    this.protocol = protocol;
    this.methodk = methodk;
    this.shift = 0;
    this.mask = 0;
    this.table = null;
    this.map = map;
  }
  
  public IFn fnFor(Class c) {
    Entry last = this.mre;
    if (last != null && last.c == c)
      return last.fn; 
    return findFnFor(c);
  }
  
  IFn findFnFor(Class c) {
    if (this.map != null) {
      Entry e = (Entry)this.map.get(c);
      this.mre = e;
      return (e != null) ? e.fn : null;
    } 
    int idx = (Util.hash(c) >> this.shift & this.mask) << 1;
    if (idx < this.table.length && this.table[idx] == c) {
      Entry e = (Entry)this.table[idx + 1];
      this.mre = e;
      return (e != null) ? e.fn : null;
    } 
    return null;
  }
}
