package clojure.lang;

import java.io.IOException;
import java.io.PushbackReader;
import java.io.Reader;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class LispReader {
  static final Symbol QUOTE = Symbol.intern("quote");
  
  static final Symbol THE_VAR = Symbol.intern("var");
  
  static Symbol UNQUOTE = Symbol.intern("clojure.core", "unquote");
  
  static Symbol UNQUOTE_SPLICING = Symbol.intern("clojure.core", "unquote-splicing");
  
  static Symbol CONCAT = Symbol.intern("clojure.core", "concat");
  
  static Symbol SEQ = Symbol.intern("clojure.core", "seq");
  
  static Symbol LIST = Symbol.intern("clojure.core", "list");
  
  static Symbol APPLY = Symbol.intern("clojure.core", "apply");
  
  static Symbol HASHMAP = Symbol.intern("clojure.core", "hash-map");
  
  static Symbol HASHSET = Symbol.intern("clojure.core", "hash-set");
  
  static Symbol VECTOR = Symbol.intern("clojure.core", "vector");
  
  static Symbol WITH_META = Symbol.intern("clojure.core", "with-meta");
  
  static Symbol META = Symbol.intern("clojure.core", "meta");
  
  static Symbol DEREF = Symbol.intern("clojure.core", "deref");
  
  static Symbol READ_COND = Symbol.intern("clojure.core", "read-cond");
  
  static Symbol READ_COND_SPLICING = Symbol.intern("clojure.core", "read-cond-splicing");
  
  static Keyword UNKNOWN = Keyword.intern(null, "unknown");
  
  static IFn[] macros = new IFn[256];
  
  static IFn[] dispatchMacros = new IFn[256];
  
  static Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)");
  
  static Pattern intPat = Pattern.compile("([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?");
  
  static Pattern ratioPat = Pattern.compile("([-+]?[0-9]+)/([0-9]+)");
  
  static Pattern floatPat = Pattern.compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?");
  
  static Var GENSYM_ENV = Var.create(null).setDynamic();
  
  static Var ARG_ENV = Var.create(null).setDynamic();
  
  static IFn ctorReader = new CtorReader();
  
  static Var READ_COND_ENV = Var.create(null).setDynamic();
  
  public static final Keyword OPT_EOF;
  
  public static final Keyword OPT_FEATURES;
  
  public static final Keyword OPT_READ_COND;
  
  public static final Keyword EOFTHROW;
  
  private static final Keyword PLATFORM_KEY;
  
  private static final Object PLATFORM_FEATURES;
  
  public static final Keyword COND_ALLOW;
  
  public static final Keyword COND_PRESERVE;
  
  private static final Object READ_EOF;
  
  private static final Object READ_FINISHED;
  
  static  {
    macros[34] = new StringReader();
    macros[59] = new CommentReader();
    macros[39] = new WrappingReader(QUOTE);
    macros[64] = new WrappingReader(DEREF);
    macros[94] = new MetaReader();
    macros[96] = new SyntaxQuoteReader();
    macros[126] = new UnquoteReader();
    macros[40] = new ListReader();
    macros[41] = new UnmatchedDelimiterReader();
    macros[91] = new VectorReader();
    macros[93] = new UnmatchedDelimiterReader();
    macros[123] = new MapReader();
    macros[125] = new UnmatchedDelimiterReader();
    macros[92] = new CharacterReader();
    macros[37] = new ArgReader();
    macros[35] = new DispatchReader();
    dispatchMacros[94] = new MetaReader();
    dispatchMacros[35] = new SymbolicValueReader();
    dispatchMacros[39] = new VarReader();
    dispatchMacros[34] = new RegexReader();
    dispatchMacros[40] = new FnReader();
    dispatchMacros[123] = new SetReader();
    dispatchMacros[61] = new EvalReader();
    dispatchMacros[33] = new CommentReader();
    dispatchMacros[60] = new UnreadableReader();
    dispatchMacros[95] = new DiscardReader();
    dispatchMacros[63] = new ConditionalReader();
    dispatchMacros[58] = new NamespaceMapReader();
    OPT_EOF = Keyword.intern(null, "eof");
    OPT_FEATURES = Keyword.intern(null, "features");
    OPT_READ_COND = Keyword.intern(null, "read-cond");
    EOFTHROW = Keyword.intern(null, "eofthrow");
    PLATFORM_KEY = Keyword.intern(null, "clj");
    PLATFORM_FEATURES = PersistentHashSet.create(new Object[] { PLATFORM_KEY });
    COND_ALLOW = Keyword.intern(null, "allow");
    COND_PRESERVE = Keyword.intern(null, "preserve");
    READ_EOF = new Object();
    READ_FINISHED = new Object();
  }
  
  static boolean isWhitespace(int ch) { return (Character.isWhitespace(ch) || ch == 44); }
  
  static void unread(PushbackReader r, int ch) {
    if (ch != -1)
      try {
        r.unread(ch);
      } catch (IOException e) {
        throw Util.sneakyThrow(e);
      }  
  }
  
  public static int read1(Reader r) {
    try {
      return r.read();
    } catch (IOException e) {
      throw Util.sneakyThrow(e);
    } 
  }
  
  public static Object read(PushbackReader r, Object opts) {
    boolean eofIsError = true;
    Object eofValue = null;
    if (opts != null && opts instanceof IPersistentMap) {
      Object eof = ((IPersistentMap)opts).valAt(OPT_EOF, EOFTHROW);
      if (!EOFTHROW.equals(eof)) {
        eofIsError = false;
        eofValue = eof;
      } 
    } 
    return read(r, eofIsError, eofValue, false, opts);
  }
  
  public static Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive) { return read(r, eofIsError, eofValue, isRecursive, PersistentHashMap.EMPTY); }
  
  public static Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive, Object opts) { return read(r, eofIsError, eofValue, null, null, isRecursive, opts, null, (Resolver)RT.READER_RESOLVER.deref()); }
  
  private static Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive, Object opts, Object pendingForms) { return read(r, eofIsError, eofValue, null, null, isRecursive, opts, ensurePending(pendingForms), (Resolver)RT.READER_RESOLVER.deref()); }
  
  private static Object ensurePending(Object pendingForms) {
    if (pendingForms == null)
      return new LinkedList(); 
    return pendingForms;
  }
  
  private static Object installPlatformFeature(Object opts) {
    if (opts == null)
      return RT.mapUniqueKeys(new Object[] { OPT_FEATURES, PLATFORM_FEATURES }); 
    IPersistentMap mopts = (IPersistentMap)opts;
    Object features = mopts.valAt(OPT_FEATURES);
    if (features == null)
      return mopts.assoc(OPT_FEATURES, PLATFORM_FEATURES); 
    return mopts.assoc(OPT_FEATURES, RT.conj((IPersistentSet)features, PLATFORM_KEY));
  }
  
  private static Object read(PushbackReader r, boolean eofIsError, Object eofValue, Character returnOn, Object returnOnValue, boolean isRecursive, Object opts, Object pendingForms, Resolver resolver) {
    if (RT.READEVAL.deref() == UNKNOWN)
      throw Util.runtimeException("Reading disallowed - *read-eval* bound to :unknown"); 
    opts = installPlatformFeature(opts);
    try {
      int ch;
      while (true) {
        if (pendingForms instanceof List && !((List)pendingForms).isEmpty())
          return ((List)pendingForms).remove(0); 
        ch = read1(r);
        while (isWhitespace(ch))
          ch = read1(r); 
        if (ch == -1) {
          if (eofIsError)
            throw Util.runtimeException("EOF while reading"); 
          return eofValue;
        } 
        if (returnOn != null && returnOn.charValue() == ch)
          return returnOnValue; 
        if (Character.isDigit(ch))
          return readNumber(r, (char)ch); 
        IFn macroFn = getMacro(ch);
        if (macroFn != null) {
          Object ret = macroFn.invoke(r, Character.valueOf((char)ch), opts, pendingForms);
          if (ret == r)
            continue; 
          return ret;
        } 
        break;
      } 
      if (ch == 43 || ch == 45) {
        int ch2 = read1(r);
        if (Character.isDigit(ch2)) {
          unread(r, ch2);
          return readNumber(r, (char)ch);
        } 
        unread(r, ch2);
      } 
      String token = readToken(r, (char)ch);
      return interpretToken(token, resolver);
    } catch (Exception e) {
      if (isRecursive || !(r instanceof LineNumberingPushbackReader))
        throw Util.sneakyThrow(e); 
      LineNumberingPushbackReader rdr = (LineNumberingPushbackReader)r;
      throw new ReaderException(rdr.getLineNumber(), rdr.getColumnNumber(), e);
    } 
  }
  
  private static String readToken(PushbackReader r, char initch) {
    StringBuilder sb = new StringBuilder();
    sb.append(initch);
    while (true) {
      int ch = read1(r);
      if (ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch)) {
        unread(r, ch);
        return sb.toString();
      } 
      sb.append((char)ch);
    } 
  }
  
  private static Object readNumber(PushbackReader r, char initch) {
    StringBuilder sb = new StringBuilder();
    sb.append(initch);
    while (true) {
      int ch = read1(r);
      if (ch == -1 || isWhitespace(ch) || isMacro(ch)) {
        unread(r, ch);
        break;
      } 
      sb.append((char)ch);
    } 
    String s = sb.toString();
    Object n = matchNumber(s);
    if (n == null)
      throw new NumberFormatException("Invalid number: " + s); 
    return n;
  }
  
  private static int readUnicodeChar(String token, int offset, int length, int base) {
    if (token.length() != offset + length)
      throw new IllegalArgumentException("Invalid unicode character: \\" + token); 
    int uc = 0;
    for (int i = offset; i < offset + length; i++) {
      int d = Character.digit(token.charAt(i), base);
      if (d == -1)
        throw new IllegalArgumentException("Invalid digit: " + token.charAt(i)); 
      uc = uc * base + d;
    } 
    return (char)uc;
  }
  
  private static int readUnicodeChar(PushbackReader r, int initch, int base, int length, boolean exact) {
    int uc = Character.digit(initch, base);
    if (uc == -1)
      throw new IllegalArgumentException("Invalid digit: " + (char)initch); 
    int i = 1;
    for (; i < length; i++) {
      int ch = read1(r);
      if (ch == -1 || isWhitespace(ch) || isMacro(ch)) {
        unread(r, ch);
        break;
      } 
      int d = Character.digit(ch, base);
      if (d == -1)
        throw new IllegalArgumentException("Invalid digit: " + (char)ch); 
      uc = uc * base + d;
    } 
    if (i != length && exact)
      throw new IllegalArgumentException("Invalid character length: " + i + ", should be: " + length); 
    return uc;
  }
  
  private static Object interpretToken(String s, Resolver resolver) {
    if (s.equals("nil"))
      return null; 
    if (s.equals("true"))
      return RT.T; 
    if (s.equals("false"))
      return RT.F; 
    Object ret = null;
    ret = matchSymbol(s, resolver);
    if (ret != null)
      return ret; 
    throw Util.runtimeException("Invalid token: " + s);
  }
  
  private static Object matchSymbol(String s, Resolver resolver) {
    Matcher m = symbolPat.matcher(s);
    if (m.matches()) {
      int gc = m.groupCount();
      String ns = m.group(1);
      String name = m.group(2);
      if ((ns != null && ns.endsWith(":/")) || name.endsWith(":") || s.indexOf("::", 1) != -1)
        return null; 
      if (s.startsWith("::")) {
        Namespace kns;
        Symbol ks = Symbol.intern(s.substring(2));
        if (resolver != null) {
          if (ks.ns != null) {
            kns = resolver.resolveAlias(Symbol.intern(ks.ns));
          } else {
            kns = resolver.currentNS();
          } 
          if (kns != null)
            return Keyword.intern(kns.name, ks.name); 
          return null;
        } 
        if (ks.ns != null) {
          kns = Compiler.currentNS().lookupAlias(Symbol.intern(ks.ns));
        } else {
          kns = Compiler.currentNS();
        } 
        if (kns != null)
          return Keyword.intern(kns.name.name, ks.name); 
        return null;
      } 
      boolean isKeyword = (s.charAt(0) == ':');
      Symbol sym = Symbol.intern(s.substring(isKeyword ? 1 : 0));
      if (isKeyword)
        return Keyword.intern(sym); 
      return sym;
    } 
    return null;
  }
  
  private static Object matchNumber(String s) {
    Matcher m = intPat.matcher(s);
    if (m.matches()) {
      if (m.group(2) != null) {
        if (m.group(8) != null)
          return BigInt.ZERO; 
        return Numbers.num(0L);
      } 
      boolean negate = m.group(1).equals("-");
      int radix = 10;
      String n;
      if ((n = m.group(3)) != null) {
        radix = 10;
      } else if ((n = m.group(4)) != null) {
        radix = 16;
      } else if ((n = m.group(5)) != null) {
        radix = 8;
      } else if ((n = m.group(7)) != null) {
        radix = Integer.parseInt(m.group(6));
      } 
      if (n == null)
        return null; 
      BigInteger bn = new BigInteger(n, radix);
      if (negate)
        bn = bn.negate(); 
      if (m.group(8) != null)
        return BigInt.fromBigInteger(bn); 
      return (bn.bitLength() < 64) ? Numbers.num(bn.longValue()) : BigInt.fromBigInteger(bn);
    } 
    m = floatPat.matcher(s);
    if (m.matches()) {
      if (m.group(4) != null)
        return new BigDecimal(m.group(1)); 
      return Double.valueOf(Double.parseDouble(s));
    } 
    m = ratioPat.matcher(s);
    if (m.matches()) {
      String numerator = m.group(1);
      if (numerator.startsWith("+"))
        numerator = numerator.substring(1); 
      return Numbers.divide(Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(numerator))), Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(m.group(2)))));
    } 
    return null;
  }
  
  private static IFn getMacro(int ch) {
    if (ch < macros.length)
      return macros[ch]; 
    return null;
  }
  
  private static boolean isMacro(int ch) { return (ch < macros.length && macros[ch] != null); }
  
  private static boolean isTerminatingMacro(int ch) { return (ch != 35 && ch != 39 && ch != 37 && isMacro(ch)); }
  
  static Symbol garg(int n) { return Symbol.intern(null, ((n == -1) ? "rest" : ("p" + n)) + "__" + RT.nextID() + "#"); }
  
  static Symbol registerArg(int n) {
    PersistentTreeMap argsyms = (PersistentTreeMap)ARG_ENV.deref();
    if (argsyms == null)
      throw new IllegalStateException("arg literal not in #()"); 
    Symbol ret = (Symbol)argsyms.valAt(Integer.valueOf(n));
    if (ret == null) {
      ret = garg(n);
      ARG_ENV.set(argsyms.assoc(Integer.valueOf(n), ret));
    } 
    return ret;
  }
  
  static boolean isUnquoteSplicing(Object form) { return (form instanceof ISeq && Util.equals(RT.first(form), UNQUOTE_SPLICING)); }
  
  static boolean isUnquote(Object form) { return (form instanceof ISeq && Util.equals(RT.first(form), UNQUOTE)); }
  
  public static List readDelimitedList(char delim, PushbackReader r, boolean isRecursive, Object opts, Object pendingForms) {
    int firstline = (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader)r).getLineNumber() : -1;
    ArrayList a = new ArrayList();
    Resolver resolver = (Resolver)RT.READER_RESOLVER.deref();
    while (true) {
      Object form = read(r, false, READ_EOF, Character.valueOf(delim), READ_FINISHED, isRecursive, opts, pendingForms, resolver);
      if (form == READ_EOF) {
        if (firstline < 0)
          throw Util.runtimeException("EOF while reading"); 
        throw Util.runtimeException("EOF while reading, starting at line " + firstline);
      } 
      if (form == READ_FINISHED)
        return a; 
      a.add(form);
    } 
  }
  
  static boolean isPreserveReadCond(Object opts) {
    if (RT.booleanCast(READ_COND_ENV.deref()) && opts instanceof IPersistentMap) {
      Object readCond = ((IPersistentMap)opts).valAt(OPT_READ_COND);
      return COND_PRESERVE.equals(readCond);
    } 
    return false;
  }
}
