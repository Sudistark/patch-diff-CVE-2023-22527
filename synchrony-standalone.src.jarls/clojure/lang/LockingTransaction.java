package clojure.lang;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.TreeMap;
import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

public class LockingTransaction {
  public static final int RETRY_LIMIT = 10000;
  
  public static final int LOCK_WAIT_MSECS = 100;
  
  public static final long BARGE_WAIT_NANOS = 10000000L;
  
  static final int RUNNING = 0;
  
  static final int COMMITTING = 1;
  
  static final int RETRY = 2;
  
  static final int KILLED = 3;
  
  static final int COMMITTED = 4;
  
  static final ThreadLocal<LockingTransaction> transaction = new ThreadLocal();
  
  private static final AtomicLong lastPoint = new AtomicLong();
  
  Info info;
  
  long readPoint;
  
  long startPoint;
  
  long startTime;
  
  void getReadPoint() { this.readPoint = lastPoint.incrementAndGet(); }
  
  long getCommitPoint() { return lastPoint.incrementAndGet(); }
  
  void stop(int status) {
    if (this.info != null) {
      synchronized (this.info) {
        this.info.status.set(status);
        this.info.latch.countDown();
      } 
      this.info = null;
      this.vals.clear();
      this.sets.clear();
      this.commutes.clear();
    } 
  }
  
  final RetryEx retryex = new RetryEx();
  
  final ArrayList<Agent.Action> actions = new ArrayList();
  
  final HashMap<Ref, Object> vals = new HashMap();
  
  final HashSet<Ref> sets = new HashSet();
  
  final TreeMap<Ref, ArrayList<CFn>> commutes = new TreeMap();
  
  final HashSet<Ref> ensures = new HashSet();
  
  void tryWriteLock(Ref ref) {
    try {
      if (!ref.lock.writeLock().tryLock(100L, TimeUnit.MILLISECONDS))
        throw this.retryex; 
    } catch (InterruptedException e) {
      throw this.retryex;
    } 
  }
  
  Object lock(Ref ref) {
    releaseIfEnsured(ref);
    unlocked = true;
    try {
      tryWriteLock(ref);
      unlocked = false;
      if (ref.tvals != null && ref.tvals.point > this.readPoint)
        throw this.retryex; 
      Info refinfo = ref.tinfo;
      if (refinfo != null && refinfo != this.info && refinfo.running())
        if (!barge(refinfo)) {
          ref.lock.writeLock().unlock();
          unlocked = true;
          return blockAndBail(refinfo);
        }  
      ref.tinfo = this.info;
      return (ref.tvals == null) ? null : ref.tvals.val;
    } finally {
      if (!unlocked)
        ref.lock.writeLock().unlock(); 
    } 
  }
  
  private Object blockAndBail(Info refinfo) {
    stop(2);
    try {
      refinfo.latch.await(100L, TimeUnit.MILLISECONDS);
    } catch (InterruptedException interruptedException) {}
    throw this.retryex;
  }
  
  private void releaseIfEnsured(Ref ref) {
    if (this.ensures.contains(ref)) {
      this.ensures.remove(ref);
      ref.lock.readLock().unlock();
    } 
  }
  
  void abort() {
    stop(3);
    throw new AbortException();
  }
  
  private boolean bargeTimeElapsed() { return (System.nanoTime() - this.startTime > 10000000L); }
  
  private boolean barge(Info refinfo) {
    boolean barged = false;
    if (bargeTimeElapsed() && this.startPoint < refinfo.startPoint) {
      barged = refinfo.status.compareAndSet(0, 3);
      if (barged)
        refinfo.latch.countDown(); 
    } 
    return barged;
  }
  
  static LockingTransaction getEx() {
    t = (LockingTransaction)transaction.get();
    if (t == null || t.info == null)
      throw new IllegalStateException("No transaction running"); 
    return t;
  }
  
  public static boolean isRunning() { return (getRunning() != null); }
  
  static LockingTransaction getRunning() {
    t = (LockingTransaction)transaction.get();
    if (t == null || t.info == null)
      return null; 
    return t;
  }
  
  public static Object runInTransaction(Callable fn) throws Exception {
    Object ret;
    LockingTransaction t = (LockingTransaction)transaction.get();
    if (t == null) {
      transaction.set(t = new LockingTransaction());
      try {
        ret = t.run(fn);
      } finally {
        transaction.remove();
      } 
    } else if (t.info != null) {
      ret = fn.call();
    } else {
      ret = t.run(fn);
    } 
    return ret;
  }
  
  Object run(Callable fn) throws Exception {
    done = false;
    Object ret = null;
    locked = new ArrayList<Ref>();
    notify = new ArrayList<Notify>();
    for (int i = 0; !done && i < 10000; i++) {
      try {
        getReadPoint();
        if (i == 0) {
          this.startPoint = this.readPoint;
          this.startTime = System.nanoTime();
        } 
        this.info = new Info(0, this.startPoint);
        ret = fn.call();
        if (this.info.status.compareAndSet(0, 1)) {
          for (Map.Entry<Ref, ArrayList<CFn>> e : this.commutes.entrySet()) {
            Ref ref = (Ref)e.getKey();
            if (this.sets.contains(ref))
              continue; 
            boolean wasEnsured = this.ensures.contains(ref);
            releaseIfEnsured(ref);
            tryWriteLock(ref);
            locked.add(ref);
            if (wasEnsured && ref.tvals != null && ref.tvals.point > this.readPoint)
              throw this.retryex; 
            Info refinfo = ref.tinfo;
            if (refinfo != null && refinfo != this.info && refinfo.running())
              if (!barge(refinfo))
                throw this.retryex;  
            Object val = (ref.tvals == null) ? null : ref.tvals.val;
            this.vals.put(ref, val);
            for (CFn f : (ArrayList)e.getValue())
              this.vals.put(ref, f.fn.applyTo(RT.cons(this.vals.get(ref), f.args))); 
          } 
          for (Ref ref : this.sets) {
            tryWriteLock(ref);
            locked.add(ref);
          } 
          for (Map.Entry<Ref, Object> e : this.vals.entrySet()) {
            Ref ref = (Ref)e.getKey();
            ref.validate(ref.getValidator(), e.getValue());
          } 
          long commitPoint = getCommitPoint();
          for (Map.Entry<Ref, Object> e : this.vals.entrySet()) {
            Ref ref = (Ref)e.getKey();
            Object oldval = (ref.tvals == null) ? null : ref.tvals.val;
            Object newval = e.getValue();
            int hcount = ref.histCount();
            if (ref.tvals == null) {
              ref.tvals = new Ref.TVal(newval, commitPoint);
            } else if ((ref.faults.get() > 0 && hcount < ref.maxHistory) || hcount < ref.minHistory) {
              ref.tvals = new Ref.TVal(newval, commitPoint, ref.tvals);
              ref.faults.set(0);
            } else {
              ref.tvals = ref.tvals.next;
              ref.tvals.val = newval;
              ref.tvals.point = commitPoint;
            } 
            if (ref.getWatches().count() > 0)
              notify.add(new Notify(ref, oldval, newval)); 
          } 
          done = true;
          this.info.status.set(4);
        } 
        for (int k = locked.size() - 1; k >= 0; k--)
          ((Ref)locked.get(k)).lock.writeLock().unlock(); 
        locked.clear();
        for (Ref r : this.ensures)
          r.lock.readLock().unlock(); 
        this.ensures.clear();
      } catch (RetryEx retryEx) {
      
      } finally {
        for (int k = locked.size() - 1; k >= 0; k--)
          ((Ref)locked.get(k)).lock.writeLock().unlock(); 
        locked.clear();
        for (Ref r : this.ensures)
          r.lock.readLock().unlock(); 
        this.ensures.clear();
        stop(done ? 4 : 2);
        try {
          if (done) {
            for (Notify n : notify)
              n.ref.notifyWatches(n.oldval, n.newval); 
            for (Agent.Action action : this.actions)
              Agent.dispatchAction(action); 
          } 
        } finally {
          notify.clear();
          this.actions.clear();
        } 
      } 
    } 
    if (!done)
      throw Util.runtimeException("Transaction failed after reaching retry limit"); 
    return ret;
  }
  
  public void enqueue(Agent.Action action) { this.actions.add(action); }
  
  Object doGet(Ref ref) {
    if (!this.info.running())
      throw this.retryex; 
    if (this.vals.containsKey(ref))
      return this.vals.get(ref); 
    try {
      ref.lock.readLock().lock();
      if (ref.tvals == null)
        throw new IllegalStateException(ref.toString() + " is unbound."); 
      Ref.TVal ver = ref.tvals;
      do {
        if (ver.point <= this.readPoint)
          return ver.val; 
      } while ((ver = ver.prior) != ref.tvals);
    } finally {
      ref.lock.readLock().unlock();
    } 
    ref.faults.incrementAndGet();
    throw this.retryex;
  }
  
  Object doSet(Ref ref, Object val) {
    if (!this.info.running())
      throw this.retryex; 
    if (this.commutes.containsKey(ref))
      throw new IllegalStateException("Can't set after commute"); 
    if (!this.sets.contains(ref)) {
      this.sets.add(ref);
      lock(ref);
    } 
    this.vals.put(ref, val);
    return val;
  }
  
  void doEnsure(Ref ref) {
    if (!this.info.running())
      throw this.retryex; 
    if (this.ensures.contains(ref))
      return; 
    ref.lock.readLock().lock();
    if (ref.tvals != null && ref.tvals.point > this.readPoint) {
      ref.lock.readLock().unlock();
      throw this.retryex;
    } 
    Info refinfo = ref.tinfo;
    if (refinfo != null && refinfo.running()) {
      ref.lock.readLock().unlock();
      if (refinfo != this.info)
        blockAndBail(refinfo); 
    } else {
      this.ensures.add(ref);
    } 
  }
  
  Object doCommute(Ref ref, IFn fn, ISeq args) {
    if (!this.info.running())
      throw this.retryex; 
    if (!this.vals.containsKey(ref)) {
      Object val = null;
      try {
        ref.lock.readLock().lock();
        val = (ref.tvals == null) ? null : ref.tvals.val;
      } finally {
        ref.lock.readLock().unlock();
      } 
      this.vals.put(ref, val);
    } 
    ArrayList<CFn> fns = (ArrayList)this.commutes.get(ref);
    if (fns == null)
      this.commutes.put(ref, fns = new ArrayList<CFn>()); 
    fns.add(new CFn(fn, args));
    Object ret = fn.applyTo(RT.cons(this.vals.get(ref), args));
    this.vals.put(ref, ret);
    return ret;
  }
}
