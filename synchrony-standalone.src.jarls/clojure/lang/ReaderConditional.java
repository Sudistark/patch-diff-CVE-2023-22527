package clojure.lang;

public class ReaderConditional implements ILookup {
  public static final Keyword FORM_KW = Keyword.intern("form");
  
  public static final Keyword SPLICING_KW = Keyword.intern("splicing?");
  
  public final Object form;
  
  public final Boolean splicing;
  
  public static ReaderConditional create(Object form, boolean splicing) { return new ReaderConditional(form, splicing); }
  
  private ReaderConditional(Object form, boolean splicing) {
    this.form = form;
    this.splicing = Boolean.valueOf(splicing);
  }
  
  public Object valAt(Object key) { return valAt(key, null); }
  
  public Object valAt(Object key, Object notFound) {
    if (FORM_KW.equals(key))
      return this.form; 
    if (SPLICING_KW.equals(key))
      return this.splicing; 
    return notFound;
  }
  
  public boolean equals(Object o) {
    if (this == o)
      return true; 
    if (o == null || getClass() != o.getClass())
      return false; 
    ReaderConditional that = (ReaderConditional)o;
    if ((this.form != null) ? !this.form.equals(that.form) : (that.form != null))
      return false; 
    if ((this.splicing != null) ? !this.splicing.equals(that.splicing) : (that.splicing != null))
      return false; 
    return true;
  }
  
  public int hashCode() {
    result = Util.hash(this.form);
    return 31 * result + Util.hash(this.splicing);
  }
}
