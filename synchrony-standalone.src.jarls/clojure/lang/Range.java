package clojure.lang;

import java.util.Iterator;

public class Range extends ASeq implements IChunkedSeq, IReduce {
  private static final int CHUNK_SIZE = 32;
  
  final Object end;
  
  final Object start;
  
  final Object step;
  
  final BoundsCheck boundsCheck;
  
  private static BoundsCheck positiveStep(Object end) { return new Object(end); }
  
  private static BoundsCheck negativeStep(Object end) { return new Object(end); }
  
  private Range(Object start, Object end, Object step, BoundsCheck boundsCheck) {
    this.end = end;
    this.start = start;
    this.step = step;
    this.boundsCheck = boundsCheck;
  }
  
  private Range(Object start, Object end, Object step, BoundsCheck boundsCheck, IChunk chunk, ISeq chunkNext) {
    this.end = end;
    this.start = start;
    this.step = step;
    this.boundsCheck = boundsCheck;
    this._chunk = chunk;
    this._chunkNext = chunkNext;
  }
  
  private Range(IPersistentMap meta, Object start, Object end, Object step, BoundsCheck boundsCheck, IChunk chunk, ISeq chunkNext) {
    super(meta);
    this.end = end;
    this.start = start;
    this.step = step;
    this.boundsCheck = boundsCheck;
    this._chunk = chunk;
    this._chunkNext = chunkNext;
  }
  
  public static ISeq create(Object end) {
    if (Numbers.isPos(end))
      return new Range(Long.valueOf(0L), end, Long.valueOf(1L), positiveStep(end)); 
    return PersistentList.EMPTY;
  }
  
  public static ISeq create(Object start, Object end) { return create(start, end, Long.valueOf(1L)); }
  
  public static ISeq create(Object start, Object end, Object step) {
    if ((Numbers.isPos(step) && Numbers.gt(start, end)) || (
      Numbers.isNeg(step) && Numbers.gt(end, start)) || 
      Numbers.equiv(start, end))
      return PersistentList.EMPTY; 
    if (Numbers.isZero(step))
      return Repeat.create(start); 
    return new Range(start, end, step, Numbers.isPos(step) ? positiveStep(end) : negativeStep(end));
  }
  
  public Obj withMeta(IPersistentMap meta) {
    if (meta == this._meta)
      return this; 
    return new Range(meta, this.end, this.start, this.step, this.boundsCheck, this._chunk, this._chunkNext);
  }
  
  public Object first() { return this.start; }
  
  public void forceChunk() {
    if (this._chunk != null)
      return; 
    Object[] arr = new Object[32];
    int n = 0;
    Object val = this.start;
    while (n < 32) {
      arr[n++] = val;
      val = Numbers.addP(val, this.step);
      if (this.boundsCheck.exceededBounds(val)) {
        this._chunk = new ArrayChunk(arr, 0, n);
        return;
      } 
    } 
    if (this.boundsCheck.exceededBounds(val)) {
      this._chunk = new ArrayChunk(arr, 0, 32);
      return;
    } 
    this._chunk = new ArrayChunk(arr, 0, 32);
    this._chunkNext = new Range(val, this.end, this.step, this.boundsCheck);
  }
  
  public ISeq next() {
    if (this._next != null)
      return this._next; 
    forceChunk();
    if (this._chunk.count() > 1) {
      IChunk smallerChunk = this._chunk.dropFirst();
      this._next = new Range(smallerChunk.nth(0), this.end, this.step, this.boundsCheck, smallerChunk, this._chunkNext);
      return this._next;
    } 
    return chunkedNext();
  }
  
  public IChunk chunkedFirst() {
    forceChunk();
    return this._chunk;
  }
  
  public ISeq chunkedNext() { return chunkedMore().seq(); }
  
  public ISeq chunkedMore() {
    forceChunk();
    if (this._chunkNext == null)
      return PersistentList.EMPTY; 
    return this._chunkNext;
  }
  
  public Object reduce(IFn f) {
    Object acc = this.start;
    Number i = Numbers.addP(this.start, this.step);
    while (!this.boundsCheck.exceededBounds(i)) {
      acc = f.invoke(acc, i);
      if (RT.isReduced(acc))
        return ((Reduced)acc).deref(); 
      i = Numbers.addP(i, this.step);
    } 
    return acc;
  }
  
  public Object reduce(IFn f, Object val) {
    Object acc = val;
    Object i = this.start;
    while (!this.boundsCheck.exceededBounds(i)) {
      acc = f.invoke(acc, i);
      if (RT.isReduced(acc))
        return ((Reduced)acc).deref(); 
      i = Numbers.addP(i, this.step);
    } 
    return acc;
  }
  
  public Iterator iterator() { return new RangeIterator(this); }
}
