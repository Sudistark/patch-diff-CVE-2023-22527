package clojure.lang;

import java.util.Collection;
import java.util.Iterator;

public class PersistentQueue extends Obj implements IPersistentList, Collection, Counted, IHashEq {
  public static final PersistentQueue EMPTY = new PersistentQueue(null, 0, null, null);
  
  final int cnt;
  
  final ISeq f;
  
  final PersistentVector r;
  
  int _hash;
  
  int _hasheq;
  
  PersistentQueue(IPersistentMap meta, int cnt, ISeq f, PersistentVector r) {
    super(meta);
    this.cnt = cnt;
    this.f = f;
    this.r = r;
  }
  
  public boolean equiv(Object obj) {
    if (!(obj instanceof Sequential))
      return false; 
    ISeq ms = RT.seq(obj);
    for (ISeq s = seq(); s != null; s = s.next(), ms = ms.next()) {
      if (ms == null || !Util.equiv(s.first(), ms.first()))
        return false; 
    } 
    return (ms == null);
  }
  
  public boolean equals(Object obj) {
    if (!(obj instanceof Sequential))
      return false; 
    ISeq ms = RT.seq(obj);
    for (ISeq s = seq(); s != null; s = s.next(), ms = ms.next()) {
      if (ms == null || !Util.equals(s.first(), ms.first()))
        return false; 
    } 
    return (ms == null);
  }
  
  public int hashCode() {
    int hash = this._hash;
    if (hash == 0) {
      hash = 1;
      for (ISeq s = seq(); s != null; s = s.next())
        hash = 31 * hash + ((s.first() == null) ? 0 : s.first().hashCode()); 
      this._hash = hash;
    } 
    return hash;
  }
  
  public int hasheq() {
    int cached = this._hasheq;
    if (cached == 0)
      this._hasheq = cached = Murmur3.hashOrdered(this); 
    return cached;
  }
  
  public Object peek() { return RT.first(this.f); }
  
  public PersistentQueue pop() {
    if (this.f == null)
      return this; 
    ISeq f1 = this.f.next();
    PersistentVector r1 = this.r;
    if (f1 == null) {
      f1 = RT.seq(this.r);
      r1 = null;
    } 
    return new PersistentQueue(meta(), this.cnt - 1, f1, r1);
  }
  
  public int count() { return this.cnt; }
  
  public ISeq seq() {
    if (this.f == null)
      return null; 
    return new Seq(this.f, RT.seq(this.r));
  }
  
  public PersistentQueue cons(Object o) {
    if (this.f == null)
      return new PersistentQueue(meta(), this.cnt + 1, RT.list(o), null); 
    return new PersistentQueue(meta(), this.cnt + 1, this.f, ((this.r != null) ? this.r : PersistentVector.EMPTY).cons(o));
  }
  
  public IPersistentCollection empty() { return EMPTY.withMeta(meta()); }
  
  public PersistentQueue withMeta(IPersistentMap meta) {
    if (meta() == meta)
      return this; 
    return new PersistentQueue(meta, this.cnt, this.f, this.r);
  }
  
  public Object[] toArray() { return RT.seqToArray(seq()); }
  
  public boolean add(Object o) { throw new UnsupportedOperationException(); }
  
  public boolean remove(Object o) { throw new UnsupportedOperationException(); }
  
  public boolean addAll(Collection c) { throw new UnsupportedOperationException(); }
  
  public void clear() { throw new UnsupportedOperationException(); }
  
  public boolean retainAll(Collection c) { throw new UnsupportedOperationException(); }
  
  public boolean removeAll(Collection c) { throw new UnsupportedOperationException(); }
  
  public boolean containsAll(Collection c) {
    for (Object o : c) {
      if (contains(o))
        return true; 
    } 
    return false;
  }
  
  public Object[] toArray(Object[] a) { return RT.seqToPassedArray(seq(), a); }
  
  public int size() { return count(); }
  
  public boolean isEmpty() { return (count() == 0); }
  
  public boolean contains(Object o) {
    for (ISeq s = seq(); s != null; s = s.next()) {
      if (Util.equiv(s.first(), o))
        return true; 
    } 
    return false;
  }
  
  public Iterator iterator() { return new Object(this); }
}
