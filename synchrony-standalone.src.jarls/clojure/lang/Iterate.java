package clojure.lang;

public class Iterate extends ASeq implements IReduce, IPending {
  private static final Object UNREALIZED_SEED = new Object();
  
  private final IFn f;
  
  private final Object prevSeed;
  
  private Iterate(IFn f, Object prevSeed, Object seed) {
    this.f = f;
    this.prevSeed = prevSeed;
    this._seed = seed;
  }
  
  private Iterate(IPersistentMap meta, IFn f, Object prevSeed, Object seed, ISeq next) {
    super(meta);
    this.f = f;
    this.prevSeed = prevSeed;
    this._seed = seed;
    this._next = next;
  }
  
  public static ISeq create(IFn f, Object seed) { return new Iterate(f, null, seed); }
  
  public boolean isRealized() { return (this._seed != UNREALIZED_SEED); }
  
  public Object first() {
    if (this._seed == UNREALIZED_SEED)
      this._seed = this.f.invoke(this.prevSeed); 
    return this._seed;
  }
  
  public ISeq next() {
    if (this._next == null)
      this._next = new Iterate(this.f, first(), UNREALIZED_SEED); 
    return this._next;
  }
  
  public Iterate withMeta(IPersistentMap meta) {
    if (meta() == meta)
      return this; 
    return new Iterate(meta, this.f, this.prevSeed, this._seed, this._next);
  }
  
  public Object reduce(IFn rf) {
    Object first = first();
    Object ret = first;
    Object v = this.f.invoke(first);
    while (true) {
      ret = rf.invoke(ret, v);
      if (RT.isReduced(ret))
        return ((IDeref)ret).deref(); 
      v = this.f.invoke(v);
    } 
  }
  
  public Object reduce(IFn rf, Object start) {
    Object ret = start;
    Object v = first();
    while (true) {
      ret = rf.invoke(ret, v);
      if (RT.isReduced(ret))
        return ((IDeref)ret).deref(); 
      v = this.f.invoke(v);
    } 
  }
}
