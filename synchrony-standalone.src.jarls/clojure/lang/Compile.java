package clojure.lang;

import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;

public class Compile {
  private static final String PATH_PROP = "clojure.compile.path";
  
  private static final String REFLECTION_WARNING_PROP = "clojure.compile.warn-on-reflection";
  
  private static final String UNCHECKED_MATH_PROP = "clojure.compile.unchecked-math";
  
  private static final Var compile_path = RT.var("clojure.core", "*compile-path*");
  
  private static final Var compile = RT.var("clojure.core", "compile");
  
  private static final Var warn_on_reflection = RT.var("clojure.core", "*warn-on-reflection*");
  
  private static final Var unchecked_math = RT.var("clojure.core", "*unchecked-math*");
  
  public static void main(String[] args) throws IOException, ClassNotFoundException {
    RT.init();
    out = (OutputStreamWriter)RT.OUT.deref();
    err = RT.errPrintWriter();
    String path = System.getProperty("clojure.compile.path");
    int count = args.length;
    if (path == null) {
      err.println("ERROR: Must set system property clojure.compile.path\nto the location for compiled .class files.\nThis directory must also be on your CLASSPATH.");
      System.exit(1);
    } 
    boolean warnOnReflection = System.getProperty("clojure.compile.warn-on-reflection", "false").equals("true");
    String uncheckedMathProp = System.getProperty("clojure.compile.unchecked-math");
    Object uncheckedMath = Boolean.FALSE;
    if ("true".equals(uncheckedMathProp)) {
      uncheckedMath = Boolean.TRUE;
    } else if ("warn-on-boxed".equals(uncheckedMathProp)) {
      uncheckedMath = Keyword.intern("warn-on-boxed");
    } 
    RT.load("clojure/core/specs/alpha");
    try {
      Var.pushThreadBindings(RT.map(new Object[] { compile_path, path, warn_on_reflection, 
              Boolean.valueOf(warnOnReflection), unchecked_math, uncheckedMath }));
      for (String lib : args) {
        out.write("Compiling " + lib + " to " + path + "\n");
        out.flush();
        compile.invoke(Symbol.intern(lib));
      } 
    } finally {
      Var.popThreadBindings();
      try {
        out.flush();
      } catch (IOException e) {
        e.printStackTrace(err);
      } 
    } 
  }
}
