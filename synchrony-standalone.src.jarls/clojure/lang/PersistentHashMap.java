package clojure.lang;

import java.util.Iterator;
import java.util.Map;
import java.util.concurrent.atomic.AtomicReference;

public class PersistentHashMap extends APersistentMap implements IEditableCollection, IObj, IMapIterable, IKVReduce {
  final int count;
  
  final INode root;
  
  final boolean hasNull;
  
  final Object nullValue;
  
  final IPersistentMap _meta;
  
  public static final PersistentHashMap EMPTY = new PersistentHashMap(0, null, false, null);
  
  private static final Object NOT_FOUND = new Object();
  
  public static IPersistentMap create(Map other) {
    ITransientMap iTransientMap = EMPTY.asTransient();
    for (Object o : other.entrySet()) {
      Map.Entry e = (Map.Entry)o;
      iTransientMap = iTransientMap.assoc(e.getKey(), e.getValue());
    } 
    return iTransientMap.persistent();
  }
  
  public static PersistentHashMap create(Object... init) {
    ITransientMap iTransientMap = EMPTY.asTransient();
    for (int i = 0; i < init.length; i += 2)
      iTransientMap = iTransientMap.assoc(init[i], init[i + 1]); 
    return (PersistentHashMap)iTransientMap.persistent();
  }
  
  public static PersistentHashMap createWithCheck(Object... init) {
    ITransientMap iTransientMap = EMPTY.asTransient();
    for (int i = 0; i < init.length; i += 2) {
      iTransientMap = iTransientMap.assoc(init[i], init[i + 1]);
      if (iTransientMap.count() != i / 2 + 1)
        throw new IllegalArgumentException("Duplicate key: " + init[i]); 
    } 
    return (PersistentHashMap)iTransientMap.persistent();
  }
  
  public static PersistentHashMap create(ISeq items) {
    ITransientMap iTransientMap = EMPTY.asTransient();
    for (; items != null; items = items.next().next()) {
      if (items.next() == null)
        throw new IllegalArgumentException(String.format("No value supplied for key: %s", new Object[] { items.first() })); 
      iTransientMap = iTransientMap.assoc(items.first(), RT.second(items));
    } 
    return (PersistentHashMap)iTransientMap.persistent();
  }
  
  public static PersistentHashMap createWithCheck(ISeq items) {
    ITransientMap iTransientMap = EMPTY.asTransient();
    for (int i = 0; items != null; items = items.next().next(), i++) {
      if (items.next() == null)
        throw new IllegalArgumentException(String.format("No value supplied for key: %s", new Object[] { items.first() })); 
      iTransientMap = iTransientMap.assoc(items.first(), RT.second(items));
      if (iTransientMap.count() != i + 1)
        throw new IllegalArgumentException("Duplicate key: " + items.first()); 
    } 
    return (PersistentHashMap)iTransientMap.persistent();
  }
  
  public static PersistentHashMap create(IPersistentMap meta, Object... init) { return create(init).withMeta(meta); }
  
  PersistentHashMap(int count, INode root, boolean hasNull, Object nullValue) {
    this.count = count;
    this.root = root;
    this.hasNull = hasNull;
    this.nullValue = nullValue;
    this._meta = null;
  }
  
  public PersistentHashMap(IPersistentMap meta, int count, INode root, boolean hasNull, Object nullValue) {
    this._meta = meta;
    this.count = count;
    this.root = root;
    this.hasNull = hasNull;
    this.nullValue = nullValue;
  }
  
  static int hash(Object k) { return Util.hasheq(k); }
  
  public boolean containsKey(Object key) {
    if (key == null)
      return this.hasNull; 
    return (this.root != null) ? ((this.root.find(false, hash(key), key, NOT_FOUND) != NOT_FOUND)) : false;
  }
  
  public IMapEntry entryAt(Object key) {
    if (key == null)
      return this.hasNull ? MapEntry.create(null, this.nullValue) : null; 
    return (this.root != null) ? this.root.find(0, hash(key), key) : null;
  }
  
  public IPersistentMap assoc(Object key, Object val) {
    if (key == null) {
      if (this.hasNull && val == this.nullValue)
        return this; 
      return new PersistentHashMap(meta(), this.hasNull ? this.count : (this.count + 1), this.root, true, val);
    } 
    Box addedLeaf = new Box(null);
    INode newroot = ((this.root == null) ? BitmapIndexedNode.EMPTY : this.root).assoc(0, hash(key), key, val, addedLeaf);
    if (newroot == this.root)
      return this; 
    return new PersistentHashMap(meta(), (addedLeaf.val == null) ? this.count : (this.count + 1), newroot, this.hasNull, this.nullValue);
  }
  
  public Object valAt(Object key, Object notFound) {
    if (key == null)
      return this.hasNull ? this.nullValue : notFound; 
    return (this.root != null) ? this.root.find(0, hash(key), key, notFound) : notFound;
  }
  
  public Object valAt(Object key) { return valAt(key, null); }
  
  public IPersistentMap assocEx(Object key, Object val) {
    if (containsKey(key))
      throw Util.runtimeException("Key already present"); 
    return assoc(key, val);
  }
  
  public IPersistentMap without(Object key) {
    if (key == null)
      return this.hasNull ? new PersistentHashMap(meta(), this.count - 1, this.root, false, null) : this; 
    if (this.root == null)
      return this; 
    INode newroot = this.root.without(0, hash(key), key);
    if (newroot == this.root)
      return this; 
    return new PersistentHashMap(meta(), this.count - 1, newroot, this.hasNull, this.nullValue);
  }
  
  static final Iterator EMPTY_ITER = new Object();
  
  private Iterator iterator(IFn f) {
    Iterator rootIter = (this.root == null) ? EMPTY_ITER : this.root.iterator(f);
    if (this.hasNull)
      return new Object(this, rootIter, f); 
    return rootIter;
  }
  
  public Iterator iterator() { return iterator(APersistentMap.MAKE_ENTRY); }
  
  public Iterator keyIterator() { return iterator(APersistentMap.MAKE_KEY); }
  
  public Iterator valIterator() { return iterator(APersistentMap.MAKE_VAL); }
  
  public Object kvreduce(IFn f, Object init) {
    init = this.hasNull ? f.invoke(init, null, this.nullValue) : init;
    if (RT.isReduced(init))
      return ((IDeref)init).deref(); 
    if (this.root != null) {
      init = this.root.kvreduce(f, init);
      if (RT.isReduced(init))
        return ((IDeref)init).deref(); 
      return init;
    } 
    return init;
  }
  
  public Object fold(long n, IFn combinef, IFn reducef, IFn fjinvoke, IFn fjtask, IFn fjfork, IFn fjjoin) {
    Object object = new Object(this, combinef, reducef, fjtask, fjfork, fjjoin);
    return fjinvoke.invoke(object);
  }
  
  public int count() { return this.count; }
  
  public ISeq seq() {
    ISeq s = (this.root != null) ? this.root.nodeSeq() : null;
    return this.hasNull ? new Cons(MapEntry.create(null, this.nullValue), s) : s;
  }
  
  public IPersistentCollection empty() { return EMPTY.withMeta(meta()); }
  
  static int mask(int hash, int shift) { return hash >>> shift & 0x1F; }
  
  public PersistentHashMap withMeta(IPersistentMap meta) {
    if (this._meta == meta)
      return this; 
    return new PersistentHashMap(meta, this.count, this.root, this.hasNull, this.nullValue);
  }
  
  public TransientHashMap asTransient() { return new TransientHashMap(this); }
  
  public IPersistentMap meta() { return this._meta; }
  
  private static INode[] cloneAndSet(INode[] array, int i, INode a) {
    INode[] clone = (INode[])array.clone();
    clone[i] = a;
    return clone;
  }
  
  private static Object[] cloneAndSet(Object[] array, int i, Object a) {
    Object[] clone = (Object[])array.clone();
    clone[i] = a;
    return clone;
  }
  
  private static Object[] cloneAndSet(Object[] array, int i, Object a, int j, Object b) {
    Object[] clone = (Object[])array.clone();
    clone[i] = a;
    clone[j] = b;
    return clone;
  }
  
  private static Object[] removePair(Object[] array, int i) {
    Object[] newArray = new Object[array.length - 2];
    System.arraycopy(array, 0, newArray, 0, 2 * i);
    System.arraycopy(array, 2 * (i + 1), newArray, 2 * i, newArray.length - 2 * i);
    return newArray;
  }
  
  private static INode createNode(int shift, Object key1, Object val1, int key2hash, Object key2, Object val2) {
    int key1hash = hash(key1);
    if (key1hash == key2hash)
      return new HashCollisionNode(null, key1hash, 2, new Object[] { key1, val1, key2, val2 }); 
    Box addedLeaf = new Box(null);
    AtomicReference<Thread> edit = new AtomicReference<Thread>();
    return BitmapIndexedNode.EMPTY
      .assoc(edit, shift, key1hash, key1, val1, addedLeaf)
      .assoc(edit, shift, key2hash, key2, val2, addedLeaf);
  }
  
  private static INode createNode(AtomicReference<Thread> edit, int shift, Object key1, Object val1, int key2hash, Object key2, Object val2) {
    int key1hash = hash(key1);
    if (key1hash == key2hash)
      return new HashCollisionNode(null, key1hash, 2, new Object[] { key1, val1, key2, val2 }); 
    Box addedLeaf = new Box(null);
    return BitmapIndexedNode.EMPTY
      .assoc(edit, shift, key1hash, key1, val1, addedLeaf)
      .assoc(edit, shift, key2hash, key2, val2, addedLeaf);
  }
  
  private static int bitpos(int hash, int shift) { return 1 << mask(hash, shift); }
}
