package clojure.lang;

import java.math.BigDecimal;
import java.math.BigInteger;

public class Numbers {
  public static boolean isZero(Object x) { return ops(x).isZero((Number)x); }
  
  public static boolean isPos(Object x) { return ops(x).isPos((Number)x); }
  
  public static boolean isNeg(Object x) { return ops(x).isNeg((Number)x); }
  
  public static Number minus(Object x) { return ops(x).negate((Number)x); }
  
  public static Number minusP(Object x) { return ops(x).negateP((Number)x); }
  
  public static Number inc(Object x) { return ops(x).inc((Number)x); }
  
  public static Number incP(Object x) { return ops(x).incP((Number)x); }
  
  public static Number dec(Object x) { return ops(x).dec((Number)x); }
  
  public static Number decP(Object x) { return ops(x).decP((Number)x); }
  
  public static Number add(Object x, Object y) { return ops(x).combine(ops(y)).add((Number)x, (Number)y); }
  
  public static Number addP(Object x, Object y) { return ops(x).combine(ops(y)).addP((Number)x, (Number)y); }
  
  public static Number minus(Object x, Object y) {
    Ops yops = ops(y);
    return ops(x).combine(yops).add((Number)x, yops.negate((Number)y));
  }
  
  public static Number minusP(Object x, Object y) {
    Ops yops = ops(y);
    Number negativeY = yops.negateP((Number)y);
    Ops negativeYOps = ops(negativeY);
    return ops(x).combine(negativeYOps).addP((Number)x, negativeY);
  }
  
  public static Number multiply(Object x, Object y) { return ops(x).combine(ops(y)).multiply((Number)x, (Number)y); }
  
  public static Number multiplyP(Object x, Object y) { return ops(x).combine(ops(y)).multiplyP((Number)x, (Number)y); }
  
  public static Number divide(Object x, Object y) {
    if (isNaN(x))
      return (Number)x; 
    if (isNaN(y))
      return (Number)y; 
    Ops yops = ops(y);
    if (yops.isZero((Number)y))
      throw new ArithmeticException("Divide by zero"); 
    return ops(x).combine(yops).divide((Number)x, (Number)y);
  }
  
  public static Number quotient(Object x, Object y) {
    Ops yops = ops(y);
    if (yops.isZero((Number)y))
      throw new ArithmeticException("Divide by zero"); 
    return ops(x).combine(yops).quotient((Number)x, (Number)y);
  }
  
  public static Number remainder(Object x, Object y) {
    Ops yops = ops(y);
    if (yops.isZero((Number)y))
      throw new ArithmeticException("Divide by zero"); 
    return ops(x).combine(yops).remainder((Number)x, (Number)y);
  }
  
  public static double quotient(double n, double d) {
    if (d == 0.0D)
      throw new ArithmeticException("Divide by zero"); 
    double q = n / d;
    if (q <= 9.223372036854776E18D && q >= -9.223372036854776E18D)
      return (long)q; 
    return (new BigDecimal(q)).toBigInteger().doubleValue();
  }
  
  public static double remainder(double n, double d) {
    if (d == 0.0D)
      throw new ArithmeticException("Divide by zero"); 
    double q = n / d;
    if (q <= 9.223372036854776E18D && q >= -9.223372036854776E18D)
      return n - (long)q * d; 
    Number bq = (new BigDecimal(q)).toBigInteger();
    return n - bq.doubleValue() * d;
  }
  
  public static boolean equiv(Object x, Object y) { return equiv((Number)x, (Number)y); }
  
  public static boolean equiv(Number x, Number y) { return ops(x).combine(ops(y)).equiv(x, y); }
  
  public static boolean equal(Number x, Number y) {
    return (category(x) == category(y) && 
      ops(x).combine(ops(y)).equiv(x, y));
  }
  
  public static boolean lt(Object x, Object y) { return ops(x).combine(ops(y)).lt((Number)x, (Number)y); }
  
  public static boolean lte(Object x, Object y) { return ops(x).combine(ops(y)).lte((Number)x, (Number)y); }
  
  public static boolean gt(Object x, Object y) { return ops(x).combine(ops(y)).lt((Number)y, (Number)x); }
  
  public static boolean gte(Object x, Object y) { return ops(x).combine(ops(y)).gte((Number)x, (Number)y); }
  
  public static int compare(Number x, Number y) {
    Ops ops = ops(x).combine(ops(y));
    if (ops.lt(x, y))
      return -1; 
    if (ops.lt(y, x))
      return 1; 
    return 0;
  }
  
  @WarnBoxedMath(false)
  static BigInt toBigInt(Object x) {
    if (x instanceof BigInt)
      return (BigInt)x; 
    if (x instanceof BigInteger)
      return BigInt.fromBigInteger((BigInteger)x); 
    return BigInt.fromLong(((Number)x).longValue());
  }
  
  @WarnBoxedMath(false)
  static BigInteger toBigInteger(Object x) {
    if (x instanceof BigInteger)
      return (BigInteger)x; 
    if (x instanceof BigInt)
      return ((BigInt)x).toBigInteger(); 
    return BigInteger.valueOf(((Number)x).longValue());
  }
  
  @WarnBoxedMath(false)
  static BigDecimal toBigDecimal(Object x) {
    if (x instanceof BigDecimal)
      return (BigDecimal)x; 
    if (x instanceof BigInt) {
      BigInt bi = (BigInt)x;
      if (bi.bipart == null)
        return BigDecimal.valueOf(bi.lpart); 
      return new BigDecimal(bi.bipart);
    } 
    if (x instanceof BigInteger)
      return new BigDecimal((BigInteger)x); 
    if (x instanceof Double)
      return new BigDecimal(((Number)x).doubleValue()); 
    if (x instanceof Float)
      return new BigDecimal(((Number)x).doubleValue()); 
    if (x instanceof Ratio) {
      Ratio r = (Ratio)x;
      return (BigDecimal)divide(new BigDecimal(r.numerator), r.denominator);
    } 
    return BigDecimal.valueOf(((Number)x).longValue());
  }
  
  @WarnBoxedMath(false)
  public static Ratio toRatio(Object x) {
    if (x instanceof Ratio)
      return (Ratio)x; 
    if (x instanceof BigDecimal) {
      BigDecimal bx = (BigDecimal)x;
      BigInteger bv = bx.unscaledValue();
      int scale = bx.scale();
      if (scale < 0)
        return new Ratio(bv.multiply(BigInteger.TEN.pow(-scale)), BigInteger.ONE); 
      return new Ratio(bv, BigInteger.TEN.pow(scale));
    } 
    return new Ratio(toBigInteger(x), BigInteger.ONE);
  }
  
  @WarnBoxedMath(false)
  public static Number rationalize(Number x) {
    if (x instanceof Float || x instanceof Double)
      return rationalize(BigDecimal.valueOf(x.doubleValue())); 
    if (x instanceof BigDecimal) {
      BigDecimal bx = (BigDecimal)x;
      BigInteger bv = bx.unscaledValue();
      int scale = bx.scale();
      if (scale < 0)
        return BigInt.fromBigInteger(bv.multiply(BigInteger.TEN.pow(-scale))); 
      return divide(bv, BigInteger.TEN.pow(scale));
    } 
    return x;
  }
  
  @WarnBoxedMath(false)
  public static Number reduceBigInt(BigInt val) {
    if (val.bipart == null)
      return num(val.lpart); 
    return val.bipart;
  }
  
  public static Number divide(BigInteger n, BigInteger d) {
    if (d.equals(BigInteger.ZERO))
      throw new ArithmeticException("Divide by zero"); 
    BigInteger gcd = n.gcd(d);
    if (gcd.equals(BigInteger.ZERO))
      return BigInt.ZERO; 
    n = n.divide(gcd);
    d = d.divide(gcd);
    if (d.equals(BigInteger.ONE))
      return BigInt.fromBigInteger(n); 
    if (d.equals(BigInteger.ONE.negate()))
      return BigInt.fromBigInteger(n.negate()); 
    return new Ratio((d.signum() < 0) ? n.negate() : n, 
        (d.signum() < 0) ? d.negate() : d);
  }
  
  public static int shiftLeftInt(int x, int n) { return x << n; }
  
  public static long shiftLeft(Object x, Object y) { return shiftLeft(bitOpsCast(x), bitOpsCast(y)); }
  
  public static long shiftLeft(Object x, long y) { return shiftLeft(bitOpsCast(x), y); }
  
  public static long shiftLeft(long x, Object y) { return shiftLeft(x, bitOpsCast(y)); }
  
  public static long shiftLeft(long x, long n) { return x << (int)n; }
  
  public static int shiftRightInt(int x, int n) { return x >> n; }
  
  public static long shiftRight(Object x, Object y) { return shiftRight(bitOpsCast(x), bitOpsCast(y)); }
  
  public static long shiftRight(Object x, long y) { return shiftRight(bitOpsCast(x), y); }
  
  public static long shiftRight(long x, Object y) { return shiftRight(x, bitOpsCast(y)); }
  
  public static long shiftRight(long x, long n) { return x >> (int)n; }
  
  public static int unsignedShiftRightInt(int x, int n) { return x >>> n; }
  
  public static long unsignedShiftRight(Object x, Object y) { return unsignedShiftRight(bitOpsCast(x), bitOpsCast(y)); }
  
  public static long unsignedShiftRight(Object x, long y) { return unsignedShiftRight(bitOpsCast(x), y); }
  
  public static long unsignedShiftRight(long x, Object y) { return unsignedShiftRight(x, bitOpsCast(y)); }
  
  public static long unsignedShiftRight(long x, long n) { return x >>> (int)n; }
  
  static final LongOps LONG_OPS = new LongOps();
  
  static final DoubleOps DOUBLE_OPS = new DoubleOps();
  
  static final RatioOps RATIO_OPS = new RatioOps();
  
  static final BigIntOps BIGINT_OPS = new BigIntOps();
  
  static final BigDecimalOps BIGDECIMAL_OPS = new BigDecimalOps();
  
  static Ops ops(Object x) {
    Class xc = x.getClass();
    if (xc == Long.class)
      return LONG_OPS; 
    if (xc == Double.class)
      return DOUBLE_OPS; 
    if (xc == Integer.class)
      return LONG_OPS; 
    if (xc == Float.class)
      return DOUBLE_OPS; 
    if (xc == BigInt.class)
      return BIGINT_OPS; 
    if (xc == BigInteger.class)
      return BIGINT_OPS; 
    if (xc == Ratio.class)
      return RATIO_OPS; 
    if (xc == BigDecimal.class)
      return BIGDECIMAL_OPS; 
    return LONG_OPS;
  }
  
  @WarnBoxedMath(false)
  static int hasheqFrom(Number x, Class xc) {
    if (xc == Integer.class || xc == Short.class || xc == Byte.class || (xc == BigInteger.class && 

      
      lte(x, Float.MAX_VALUE) && gte(x, Float.MIN_VALUE))) {
      long lpart = x.longValue();
      return Murmur3.hashLong(lpart);
    } 
    if (xc == BigDecimal.class) {
      if (isZero(x))
        return BigDecimal.ZERO.hashCode(); 
      BigDecimal tmp = ((BigDecimal)x).stripTrailingZeros();
      return tmp.hashCode();
    } 
    if (xc == Float.class && x.equals(Float.valueOf(-0.0F)))
      return 0; 
    return x.hashCode();
  }
  
  @WarnBoxedMath(false)
  static int hasheq(Number x) {
    Class xc = x.getClass();
    if (xc == Long.class) {
      long lpart = x.longValue();
      return Murmur3.hashLong(lpart);
    } 
    if (xc == Double.class) {
      if (x.equals(Double.valueOf(-0.0D)))
        return 0; 
      return x.hashCode();
    } 
    return hasheqFrom(x, xc);
  }
  
  static Category category(Object x) {
    Class xc = x.getClass();
    if (xc == Integer.class)
      return Category.INTEGER; 
    if (xc == Double.class)
      return Category.FLOATING; 
    if (xc == Long.class)
      return Category.INTEGER; 
    if (xc == Float.class)
      return Category.FLOATING; 
    if (xc == BigInt.class)
      return Category.INTEGER; 
    if (xc == Ratio.class)
      return Category.RATIO; 
    if (xc == BigDecimal.class)
      return Category.DECIMAL; 
    return Category.INTEGER;
  }
  
  static long bitOpsCast(Object x) {
    Class xc = x.getClass();
    if (xc == Long.class || xc == Integer.class || xc == Short.class || xc == Byte.class)
      return RT.longCast(x); 
    throw new IllegalArgumentException("bit operation not supported for: " + xc);
  }
  
  @WarnBoxedMath(false)
  public static float[] float_array(int size, Object init) {
    float[] ret = new float[size];
    if (init instanceof Number) {
      float f = ((Number)init).floatValue();
      for (int i = 0; i < ret.length; i++)
        ret[i] = f; 
    } else {
      ISeq s = RT.seq(init);
      for (int i = 0; i < size && s != null; i++, s = s.next())
        ret[i] = ((Number)s.first()).floatValue(); 
    } 
    return ret;
  }
  
  @WarnBoxedMath(false)
  public static float[] float_array(Object sizeOrSeq) {
    if (sizeOrSeq instanceof Number)
      return new float[((Number)sizeOrSeq).intValue()]; 
    ISeq s = RT.seq(sizeOrSeq);
    int size = RT.count(s);
    float[] ret = new float[size];
    for (int i = 0; i < size && s != null; i++, s = s.next())
      ret[i] = ((Number)s.first()).floatValue(); 
    return ret;
  }
  
  @WarnBoxedMath(false)
  public static double[] double_array(int size, Object init) {
    double[] ret = new double[size];
    if (init instanceof Number) {
      double f = ((Number)init).doubleValue();
      for (int i = 0; i < ret.length; i++)
        ret[i] = f; 
    } else {
      ISeq s = RT.seq(init);
      for (int i = 0; i < size && s != null; i++, s = s.next())
        ret[i] = ((Number)s.first()).doubleValue(); 
    } 
    return ret;
  }
  
  @WarnBoxedMath(false)
  public static double[] double_array(Object sizeOrSeq) {
    if (sizeOrSeq instanceof Number)
      return new double[((Number)sizeOrSeq).intValue()]; 
    ISeq s = RT.seq(sizeOrSeq);
    int size = RT.count(s);
    double[] ret = new double[size];
    for (int i = 0; i < size && s != null; i++, s = s.next())
      ret[i] = ((Number)s.first()).doubleValue(); 
    return ret;
  }
  
  @WarnBoxedMath(false)
  public static int[] int_array(int size, Object init) {
    int[] ret = new int[size];
    if (init instanceof Number) {
      int f = ((Number)init).intValue();
      for (int i = 0; i < ret.length; i++)
        ret[i] = f; 
    } else {
      ISeq s = RT.seq(init);
      for (int i = 0; i < size && s != null; i++, s = s.next())
        ret[i] = ((Number)s.first()).intValue(); 
    } 
    return ret;
  }
  
  @WarnBoxedMath(false)
  public static int[] int_array(Object sizeOrSeq) {
    if (sizeOrSeq instanceof Number)
      return new int[((Number)sizeOrSeq).intValue()]; 
    ISeq s = RT.seq(sizeOrSeq);
    int size = RT.count(s);
    int[] ret = new int[size];
    for (int i = 0; i < size && s != null; i++, s = s.next())
      ret[i] = ((Number)s.first()).intValue(); 
    return ret;
  }
  
  @WarnBoxedMath(false)
  public static long[] long_array(int size, Object init) {
    long[] ret = new long[size];
    if (init instanceof Number) {
      long f = ((Number)init).longValue();
      for (int i = 0; i < ret.length; i++)
        ret[i] = f; 
    } else {
      ISeq s = RT.seq(init);
      for (int i = 0; i < size && s != null; i++, s = s.next())
        ret[i] = ((Number)s.first()).longValue(); 
    } 
    return ret;
  }
  
  @WarnBoxedMath(false)
  public static long[] long_array(Object sizeOrSeq) {
    if (sizeOrSeq instanceof Number)
      return new long[((Number)sizeOrSeq).intValue()]; 
    ISeq s = RT.seq(sizeOrSeq);
    int size = RT.count(s);
    long[] ret = new long[size];
    for (int i = 0; i < size && s != null; i++, s = s.next())
      ret[i] = ((Number)s.first()).longValue(); 
    return ret;
  }
  
  @WarnBoxedMath(false)
  public static short[] short_array(int size, Object init) {
    short[] ret = new short[size];
    if (init instanceof Short) {
      short s = ((Short)init).shortValue();
      for (int i = 0; i < ret.length; i++)
        ret[i] = s; 
    } else {
      ISeq s = RT.seq(init);
      for (int i = 0; i < size && s != null; i++, s = s.next())
        ret[i] = ((Number)s.first()).shortValue(); 
    } 
    return ret;
  }
  
  @WarnBoxedMath(false)
  public static short[] short_array(Object sizeOrSeq) {
    if (sizeOrSeq instanceof Number)
      return new short[((Number)sizeOrSeq).intValue()]; 
    ISeq s = RT.seq(sizeOrSeq);
    int size = RT.count(s);
    short[] ret = new short[size];
    for (int i = 0; i < size && s != null; i++, s = s.next())
      ret[i] = ((Number)s.first()).shortValue(); 
    return ret;
  }
  
  @WarnBoxedMath(false)
  public static char[] char_array(int size, Object init) {
    char[] ret = new char[size];
    if (init instanceof Character) {
      char c = ((Character)init).charValue();
      for (int i = 0; i < ret.length; i++)
        ret[i] = c; 
    } else {
      ISeq s = RT.seq(init);
      for (int i = 0; i < size && s != null; i++, s = s.next())
        ret[i] = ((Character)s.first()).charValue(); 
    } 
    return ret;
  }
  
  @WarnBoxedMath(false)
  public static char[] char_array(Object sizeOrSeq) {
    if (sizeOrSeq instanceof Number)
      return new char[((Number)sizeOrSeq).intValue()]; 
    ISeq s = RT.seq(sizeOrSeq);
    int size = RT.count(s);
    char[] ret = new char[size];
    for (int i = 0; i < size && s != null; i++, s = s.next())
      ret[i] = ((Character)s.first()).charValue(); 
    return ret;
  }
  
  @WarnBoxedMath(false)
  public static byte[] byte_array(int size, Object init) {
    byte[] ret = new byte[size];
    if (init instanceof Byte) {
      byte b = ((Byte)init).byteValue();
      for (int i = 0; i < ret.length; i++)
        ret[i] = b; 
    } else {
      ISeq s = RT.seq(init);
      for (int i = 0; i < size && s != null; i++, s = s.next())
        ret[i] = ((Number)s.first()).byteValue(); 
    } 
    return ret;
  }
  
  @WarnBoxedMath(false)
  public static byte[] byte_array(Object sizeOrSeq) {
    if (sizeOrSeq instanceof Number)
      return new byte[((Number)sizeOrSeq).intValue()]; 
    ISeq s = RT.seq(sizeOrSeq);
    int size = RT.count(s);
    byte[] ret = new byte[size];
    for (int i = 0; i < size && s != null; i++, s = s.next())
      ret[i] = ((Number)s.first()).byteValue(); 
    return ret;
  }
  
  @WarnBoxedMath(false)
  public static boolean[] boolean_array(int size, Object init) {
    boolean[] ret = new boolean[size];
    if (init instanceof Boolean) {
      boolean b = ((Boolean)init).booleanValue();
      for (int i = 0; i < ret.length; i++)
        ret[i] = b; 
    } else {
      ISeq s = RT.seq(init);
      for (int i = 0; i < size && s != null; i++, s = s.next())
        ret[i] = ((Boolean)s.first()).booleanValue(); 
    } 
    return ret;
  }
  
  @WarnBoxedMath(false)
  public static boolean[] boolean_array(Object sizeOrSeq) {
    if (sizeOrSeq instanceof Number)
      return new boolean[((Number)sizeOrSeq).intValue()]; 
    ISeq s = RT.seq(sizeOrSeq);
    int size = RT.count(s);
    boolean[] ret = new boolean[size];
    for (int i = 0; i < size && s != null; i++, s = s.next())
      ret[i] = ((Boolean)s.first()).booleanValue(); 
    return ret;
  }
  
  @WarnBoxedMath(false)
  public static boolean[] booleans(Object array) { return (boolean[])array; }
  
  @WarnBoxedMath(false)
  public static byte[] bytes(Object array) { return (byte[])array; }
  
  @WarnBoxedMath(false)
  public static char[] chars(Object array) { return (char[])array; }
  
  @WarnBoxedMath(false)
  public static short[] shorts(Object array) { return (short[])array; }
  
  @WarnBoxedMath(false)
  public static float[] floats(Object array) { return (float[])array; }
  
  @WarnBoxedMath(false)
  public static double[] doubles(Object array) { return (double[])array; }
  
  @WarnBoxedMath(false)
  public static int[] ints(Object array) { return (int[])array; }
  
  @WarnBoxedMath(false)
  public static long[] longs(Object array) { return (long[])array; }
  
  public static Number num(Object x) { return (Number)x; }
  
  public static Number num(float x) { return Float.valueOf(x); }
  
  public static Number num(double x) { return Double.valueOf(x); }
  
  public static double add(double x, double y) { return x + y; }
  
  public static double addP(double x, double y) { return x + y; }
  
  public static double minus(double x, double y) { return x - y; }
  
  public static double minusP(double x, double y) { return x - y; }
  
  public static double minus(double x) { return -x; }
  
  public static double minusP(double x) { return -x; }
  
  public static double inc(double x) { return x + 1.0D; }
  
  public static double incP(double x) { return x + 1.0D; }
  
  public static double dec(double x) { return x - 1.0D; }
  
  public static double decP(double x) { return x - 1.0D; }
  
  public static double multiply(double x, double y) { return x * y; }
  
  public static double multiplyP(double x, double y) { return x * y; }
  
  public static double divide(double x, double y) { return x / y; }
  
  public static boolean equiv(double x, double y) { return (x == y); }
  
  public static boolean lt(double x, double y) { return (x < y); }
  
  public static boolean lte(double x, double y) { return (x <= y); }
  
  public static boolean gt(double x, double y) { return (x > y); }
  
  public static boolean gte(double x, double y) { return (x >= y); }
  
  public static boolean isPos(double x) { return (x > 0.0D); }
  
  public static boolean isNeg(double x) { return (x < 0.0D); }
  
  public static boolean isZero(double x) { return (x == 0.0D); }
  
  static int throwIntOverflow() { throw new ArithmeticException("integer overflow"); }
  
  public static int unchecked_int_add(int x, int y) { return x + y; }
  
  public static int unchecked_int_subtract(int x, int y) { return x - y; }
  
  public static int unchecked_int_negate(int x) { return -x; }
  
  public static int unchecked_int_inc(int x) { return x + 1; }
  
  public static int unchecked_int_dec(int x) { return x - 1; }
  
  public static int unchecked_int_multiply(int x, int y) { return x * y; }
  
  public static long not(Object x) { return not(bitOpsCast(x)); }
  
  public static long not(long x) { return x ^ 0xFFFFFFFFFFFFFFFFL; }
  
  public static long and(Object x, Object y) { return and(bitOpsCast(x), bitOpsCast(y)); }
  
  public static long and(Object x, long y) { return and(bitOpsCast(x), y); }
  
  public static long and(long x, Object y) { return and(x, bitOpsCast(y)); }
  
  public static long and(long x, long y) { return x & y; }
  
  public static long or(Object x, Object y) { return or(bitOpsCast(x), bitOpsCast(y)); }
  
  public static long or(Object x, long y) { return or(bitOpsCast(x), y); }
  
  public static long or(long x, Object y) { return or(x, bitOpsCast(y)); }
  
  public static long or(long x, long y) { return x | y; }
  
  public static long xor(Object x, Object y) { return xor(bitOpsCast(x), bitOpsCast(y)); }
  
  public static long xor(Object x, long y) { return xor(bitOpsCast(x), y); }
  
  public static long xor(long x, Object y) { return xor(x, bitOpsCast(y)); }
  
  public static long xor(long x, long y) { return x ^ y; }
  
  public static long andNot(Object x, Object y) { return andNot(bitOpsCast(x), bitOpsCast(y)); }
  
  public static long andNot(Object x, long y) { return andNot(bitOpsCast(x), y); }
  
  public static long andNot(long x, Object y) { return andNot(x, bitOpsCast(y)); }
  
  public static long andNot(long x, long y) { return x & (y ^ 0xFFFFFFFFFFFFFFFFL); }
  
  public static long clearBit(Object x, Object y) { return clearBit(bitOpsCast(x), bitOpsCast(y)); }
  
  public static long clearBit(Object x, long y) { return clearBit(bitOpsCast(x), y); }
  
  public static long clearBit(long x, Object y) { return clearBit(x, bitOpsCast(y)); }
  
  public static long clearBit(long x, long n) { return x & (1L << (int)n ^ 0xFFFFFFFFFFFFFFFFL); }
  
  public static long setBit(Object x, Object y) { return setBit(bitOpsCast(x), bitOpsCast(y)); }
  
  public static long setBit(Object x, long y) { return setBit(bitOpsCast(x), y); }
  
  public static long setBit(long x, Object y) { return setBit(x, bitOpsCast(y)); }
  
  public static long setBit(long x, long n) { return x | 1L << (int)n; }
  
  public static long flipBit(Object x, Object y) { return flipBit(bitOpsCast(x), bitOpsCast(y)); }
  
  public static long flipBit(Object x, long y) { return flipBit(bitOpsCast(x), y); }
  
  public static long flipBit(long x, Object y) { return flipBit(x, bitOpsCast(y)); }
  
  public static long flipBit(long x, long n) { return x ^ 1L << (int)n; }
  
  public static boolean testBit(Object x, Object y) { return testBit(bitOpsCast(x), bitOpsCast(y)); }
  
  public static boolean testBit(Object x, long y) { return testBit(bitOpsCast(x), y); }
  
  public static boolean testBit(long x, Object y) { return testBit(x, bitOpsCast(y)); }
  
  public static boolean testBit(long x, long n) { return ((x & 1L << (int)n) != 0L); }
  
  public static int unchecked_int_divide(int x, int y) { return x / y; }
  
  public static int unchecked_int_remainder(int x, int y) { return x % y; }
  
  public static Number num(long x) { return Long.valueOf(x); }
  
  public static long unchecked_add(long x, long y) { return x + y; }
  
  public static long unchecked_minus(long x, long y) { return x - y; }
  
  public static long unchecked_multiply(long x, long y) { return x * y; }
  
  public static long unchecked_minus(long x) { return -x; }
  
  public static long unchecked_inc(long x) { return x + 1L; }
  
  public static long unchecked_dec(long x) { return x - 1L; }
  
  public static Number unchecked_add(Object x, Object y) { return ops(x).combine(ops(y)).unchecked_add((Number)x, (Number)y); }
  
  public static Number unchecked_minus(Object x, Object y) {
    Ops yops = ops(y);
    return ops(x).combine(yops).unchecked_add((Number)x, yops.unchecked_negate((Number)y));
  }
  
  public static Number unchecked_multiply(Object x, Object y) { return ops(x).combine(ops(y)).unchecked_multiply((Number)x, (Number)y); }
  
  public static Number unchecked_minus(Object x) { return ops(x).unchecked_negate((Number)x); }
  
  public static Number unchecked_inc(Object x) { return ops(x).unchecked_inc((Number)x); }
  
  public static Number unchecked_dec(Object x) { return ops(x).unchecked_dec((Number)x); }
  
  public static double unchecked_add(double x, double y) { return add(x, y); }
  
  public static double unchecked_minus(double x, double y) { return minus(x, y); }
  
  public static double unchecked_multiply(double x, double y) { return multiply(x, y); }
  
  public static double unchecked_minus(double x) { return minus(x); }
  
  public static double unchecked_inc(double x) { return inc(x); }
  
  public static double unchecked_dec(double x) { return dec(x); }
  
  public static double unchecked_add(double x, Object y) { return add(x, y); }
  
  public static double unchecked_minus(double x, Object y) { return minus(x, y); }
  
  public static double unchecked_multiply(double x, Object y) { return multiply(x, y); }
  
  public static double unchecked_add(Object x, double y) { return add(x, y); }
  
  public static double unchecked_minus(Object x, double y) { return minus(x, y); }
  
  public static double unchecked_multiply(Object x, double y) { return multiply(x, y); }
  
  public static double unchecked_add(double x, long y) { return add(x, y); }
  
  public static double unchecked_minus(double x, long y) { return minus(x, y); }
  
  public static double unchecked_multiply(double x, long y) { return multiply(x, y); }
  
  public static double unchecked_add(long x, double y) { return add(x, y); }
  
  public static double unchecked_minus(long x, double y) { return minus(x, y); }
  
  public static double unchecked_multiply(long x, double y) { return multiply(x, y); }
  
  public static Number unchecked_add(long x, Object y) { return unchecked_add(Long.valueOf(x), y); }
  
  public static Number unchecked_minus(long x, Object y) { return unchecked_minus(Long.valueOf(x), y); }
  
  public static Number unchecked_multiply(long x, Object y) { return unchecked_multiply(Long.valueOf(x), y); }
  
  public static Number unchecked_add(Object x, long y) { return unchecked_add(x, Long.valueOf(y)); }
  
  public static Number unchecked_minus(Object x, long y) { return unchecked_minus(x, Long.valueOf(y)); }
  
  public static Number unchecked_multiply(Object x, long y) { return unchecked_multiply(x, Long.valueOf(y)); }
  
  public static Number quotient(double x, Object y) { return quotient(Double.valueOf(x), y); }
  
  public static Number quotient(Object x, double y) { return quotient(x, Double.valueOf(y)); }
  
  public static Number quotient(long x, Object y) { return quotient(Long.valueOf(x), y); }
  
  public static Number quotient(Object x, long y) { return quotient(x, Long.valueOf(y)); }
  
  public static double quotient(double x, long y) { return quotient(x, y); }
  
  public static double quotient(long x, double y) { return quotient(x, y); }
  
  public static Number remainder(double x, Object y) { return remainder(Double.valueOf(x), y); }
  
  public static Number remainder(Object x, double y) { return remainder(x, Double.valueOf(y)); }
  
  public static Number remainder(long x, Object y) { return remainder(Long.valueOf(x), y); }
  
  public static Number remainder(Object x, long y) { return remainder(x, Long.valueOf(y)); }
  
  public static double remainder(double x, long y) { return remainder(x, y); }
  
  public static double remainder(long x, double y) { return remainder(x, y); }
  
  public static long add(long x, long y) {
    long ret = x + y;
    if ((ret ^ x) < 0L && (ret ^ y) < 0L)
      return throwIntOverflow(); 
    return ret;
  }
  
  public static Number addP(long x, long y) {
    long ret = x + y;
    if ((ret ^ x) < 0L && (ret ^ y) < 0L)
      return addP(Long.valueOf(x), Long.valueOf(y)); 
    return num(ret);
  }
  
  public static long minus(long x, long y) {
    long ret = x - y;
    if ((ret ^ x) < 0L && (ret ^ y ^ 0xFFFFFFFFFFFFFFFFL) < 0L)
      return throwIntOverflow(); 
    return ret;
  }
  
  public static Number minusP(long x, long y) {
    long ret = x - y;
    if ((ret ^ x) < 0L && (ret ^ y ^ 0xFFFFFFFFFFFFFFFFL) < 0L)
      return minusP(Long.valueOf(x), Long.valueOf(y)); 
    return num(ret);
  }
  
  public static long minus(long x) {
    if (x == Float.MIN_VALUE)
      return throwIntOverflow(); 
    return -x;
  }
  
  public static Number minusP(long x) {
    if (x == Float.MIN_VALUE)
      return BigInt.fromBigInteger(BigInteger.valueOf(x).negate()); 
    return num(-x);
  }
  
  public static long inc(long x) {
    if (x == Float.MAX_VALUE)
      return throwIntOverflow(); 
    return x + 1L;
  }
  
  public static Number incP(long x) {
    if (x == Float.MAX_VALUE)
      return BIGINT_OPS.inc(Long.valueOf(x)); 
    return num(x + 1L);
  }
  
  public static long dec(long x) {
    if (x == Float.MIN_VALUE)
      return throwIntOverflow(); 
    return x - 1L;
  }
  
  public static Number decP(long x) {
    if (x == Float.MIN_VALUE)
      return BIGINT_OPS.dec(Long.valueOf(x)); 
    return num(x - 1L);
  }
  
  public static long multiply(long x, long y) {
    if (x == Float.MIN_VALUE && y < 0L)
      return throwIntOverflow(); 
    long ret = x * y;
    if (y != 0L && ret / y != x)
      return throwIntOverflow(); 
    return ret;
  }
  
  public static Number multiplyP(long x, long y) {
    if (x == Float.MIN_VALUE && y < 0L)
      return multiplyP(Long.valueOf(x), Long.valueOf(y)); 
    long ret = x * y;
    if (y != 0L && ret / y != x)
      return multiplyP(Long.valueOf(x), Long.valueOf(y)); 
    return num(ret);
  }
  
  public static long quotient(long x, long y) { return x / y; }
  
  public static long remainder(long x, long y) { return x % y; }
  
  public static boolean equiv(long x, long y) { return (x == y); }
  
  public static boolean lt(long x, long y) { return (x < y); }
  
  public static boolean lte(long x, long y) { return (x <= y); }
  
  public static boolean gt(long x, long y) { return (x > y); }
  
  public static boolean gte(long x, long y) { return (x >= y); }
  
  public static boolean isPos(long x) { return (x > 0L); }
  
  public static boolean isNeg(long x) { return (x < 0L); }
  
  public static boolean isZero(long x) { return (x == 0L); }
  
  public static Number add(long x, Object y) { return add(Long.valueOf(x), y); }
  
  public static Number add(Object x, long y) { return add(x, Long.valueOf(y)); }
  
  public static Number addP(long x, Object y) { return addP(Long.valueOf(x), y); }
  
  public static Number addP(Object x, long y) { return addP(x, Long.valueOf(y)); }
  
  public static double add(double x, Object y) { return add(x, ((Number)y).doubleValue()); }
  
  public static double add(Object x, double y) { return add(((Number)x).doubleValue(), y); }
  
  public static double add(double x, long y) { return x + y; }
  
  public static double add(long x, double y) { return x + y; }
  
  public static double addP(double x, Object y) { return addP(x, ((Number)y).doubleValue()); }
  
  public static double addP(Object x, double y) { return addP(((Number)x).doubleValue(), y); }
  
  public static double addP(double x, long y) { return x + y; }
  
  public static double addP(long x, double y) { return x + y; }
  
  public static Number minus(long x, Object y) { return minus(Long.valueOf(x), y); }
  
  public static Number minus(Object x, long y) { return minus(x, Long.valueOf(y)); }
  
  public static Number minusP(long x, Object y) { return minusP(Long.valueOf(x), y); }
  
  public static Number minusP(Object x, long y) { return minusP(x, Long.valueOf(y)); }
  
  public static double minus(double x, Object y) { return minus(x, ((Number)y).doubleValue()); }
  
  public static double minus(Object x, double y) { return minus(((Number)x).doubleValue(), y); }
  
  public static double minus(double x, long y) { return x - y; }
  
  public static double minus(long x, double y) { return x - y; }
  
  public static double minusP(double x, Object y) { return minus(x, ((Number)y).doubleValue()); }
  
  public static double minusP(Object x, double y) { return minus(((Number)x).doubleValue(), y); }
  
  public static double minusP(double x, long y) { return x - y; }
  
  public static double minusP(long x, double y) { return x - y; }
  
  public static Number multiply(long x, Object y) { return multiply(Long.valueOf(x), y); }
  
  public static Number multiply(Object x, long y) { return multiply(x, Long.valueOf(y)); }
  
  public static Number multiplyP(long x, Object y) { return multiplyP(Long.valueOf(x), y); }
  
  public static Number multiplyP(Object x, long y) { return multiplyP(x, Long.valueOf(y)); }
  
  public static double multiply(double x, Object y) { return multiply(x, ((Number)y).doubleValue()); }
  
  public static double multiply(Object x, double y) { return multiply(((Number)x).doubleValue(), y); }
  
  public static double multiply(double x, long y) { return x * y; }
  
  public static double multiply(long x, double y) { return x * y; }
  
  public static double multiplyP(double x, Object y) { return multiplyP(x, ((Number)y).doubleValue()); }
  
  public static double multiplyP(Object x, double y) { return multiplyP(((Number)x).doubleValue(), y); }
  
  public static double multiplyP(double x, long y) { return x * y; }
  
  public static double multiplyP(long x, double y) { return x * y; }
  
  public static Number divide(long x, Object y) { return divide(Long.valueOf(x), y); }
  
  public static Number divide(Object x, long y) { return divide(x, Long.valueOf(y)); }
  
  public static double divide(double x, Object y) { return x / ((Number)y).doubleValue(); }
  
  public static double divide(Object x, double y) { return ((Number)x).doubleValue() / y; }
  
  public static double divide(double x, long y) { return x / y; }
  
  public static double divide(long x, double y) { return x / y; }
  
  public static Number divide(long x, long y) { return divide(Long.valueOf(x), Long.valueOf(y)); }
  
  public static boolean lt(long x, Object y) { return lt(Long.valueOf(x), y); }
  
  public static boolean lt(Object x, long y) { return lt(x, Long.valueOf(y)); }
  
  public static boolean lt(double x, Object y) { return (x < ((Number)y).doubleValue()); }
  
  public static boolean lt(Object x, double y) { return (((Number)x).doubleValue() < y); }
  
  public static boolean lt(double x, long y) { return (x < y); }
  
  public static boolean lt(long x, double y) { return (x < y); }
  
  public static boolean lte(long x, Object y) { return lte(Long.valueOf(x), y); }
  
  public static boolean lte(Object x, long y) { return lte(x, Long.valueOf(y)); }
  
  public static boolean lte(double x, Object y) { return (x <= ((Number)y).doubleValue()); }
  
  public static boolean lte(Object x, double y) { return (((Number)x).doubleValue() <= y); }
  
  public static boolean lte(double x, long y) { return (x <= y); }
  
  public static boolean lte(long x, double y) { return (x <= y); }
  
  public static boolean gt(long x, Object y) { return gt(Long.valueOf(x), y); }
  
  public static boolean gt(Object x, long y) { return gt(x, Long.valueOf(y)); }
  
  public static boolean gt(double x, Object y) { return (x > ((Number)y).doubleValue()); }
  
  public static boolean gt(Object x, double y) { return (((Number)x).doubleValue() > y); }
  
  public static boolean gt(double x, long y) { return (x > y); }
  
  public static boolean gt(long x, double y) { return (x > y); }
  
  public static boolean gte(long x, Object y) { return gte(Long.valueOf(x), y); }
  
  public static boolean gte(Object x, long y) { return gte(x, Long.valueOf(y)); }
  
  public static boolean gte(double x, Object y) { return (x >= ((Number)y).doubleValue()); }
  
  public static boolean gte(Object x, double y) { return (((Number)x).doubleValue() >= y); }
  
  public static boolean gte(double x, long y) { return (x >= y); }
  
  public static boolean gte(long x, double y) { return (x >= y); }
  
  public static boolean equiv(long x, Object y) { return equiv(Long.valueOf(x), y); }
  
  public static boolean equiv(Object x, long y) { return equiv(x, Long.valueOf(y)); }
  
  public static boolean equiv(double x, Object y) { return (x == ((Number)y).doubleValue()); }
  
  public static boolean equiv(Object x, double y) { return (((Number)x).doubleValue() == y); }
  
  public static boolean equiv(double x, long y) { return (x == y); }
  
  public static boolean equiv(long x, double y) { return (x == y); }
  
  static boolean isNaN(Object x) {
    return ((x instanceof Double && ((Double)x).isNaN()) || (x instanceof Float && ((Float)x)
      .isNaN()));
  }
  
  public static double max(double x, double y) { return Math.max(x, y); }
  
  public static Object max(double x, long y) {
    if (Double.isNaN(x))
      return Double.valueOf(x); 
    if (x > y)
      return Double.valueOf(x); 
    return Long.valueOf(y);
  }
  
  public static Object max(double x, Object y) {
    if (Double.isNaN(x))
      return Double.valueOf(x); 
    if (isNaN(y))
      return y; 
    if (x > ((Number)y).doubleValue())
      return Double.valueOf(x); 
    return y;
  }
  
  public static Object max(long x, double y) {
    if (Double.isNaN(y))
      return Double.valueOf(y); 
    if (x > y)
      return Long.valueOf(x); 
    return Double.valueOf(y);
  }
  
  public static long max(long x, long y) {
    if (x > y)
      return x; 
    return y;
  }
  
  public static Object max(long x, Object y) {
    if (isNaN(y))
      return y; 
    if (gt(x, y))
      return Long.valueOf(x); 
    return y;
  }
  
  public static Object max(Object x, long y) {
    if (isNaN(x))
      return x; 
    if (gt(x, y))
      return x; 
    return Long.valueOf(y);
  }
  
  public static Object max(Object x, double y) {
    if (isNaN(x))
      return x; 
    if (Double.isNaN(y))
      return Double.valueOf(y); 
    if (((Number)x).doubleValue() > y)
      return x; 
    return Double.valueOf(y);
  }
  
  public static Object max(Object x, Object y) {
    if (isNaN(x))
      return x; 
    if (isNaN(y))
      return y; 
    if (gt(x, y))
      return x; 
    return y;
  }
  
  public static double min(double x, double y) { return Math.min(x, y); }
  
  public static Object min(double x, long y) {
    if (Double.isNaN(x))
      return Double.valueOf(x); 
    if (x < y)
      return Double.valueOf(x); 
    return Long.valueOf(y);
  }
  
  public static Object min(double x, Object y) {
    if (Double.isNaN(x))
      return Double.valueOf(x); 
    if (isNaN(y))
      return y; 
    if (x < ((Number)y).doubleValue())
      return Double.valueOf(x); 
    return y;
  }
  
  public static Object min(long x, double y) {
    if (Double.isNaN(y))
      return Double.valueOf(y); 
    if (x < y)
      return Long.valueOf(x); 
    return Double.valueOf(y);
  }
  
  public static long min(long x, long y) {
    if (x < y)
      return x; 
    return y;
  }
  
  public static Object min(long x, Object y) {
    if (isNaN(y))
      return y; 
    if (lt(x, y))
      return Long.valueOf(x); 
    return y;
  }
  
  public static Object min(Object x, long y) {
    if (isNaN(x))
      return x; 
    if (lt(x, y))
      return x; 
    return Long.valueOf(y);
  }
  
  public static Object min(Object x, double y) {
    if (isNaN(x))
      return x; 
    if (Double.isNaN(y))
      return Double.valueOf(y); 
    if (((Number)x).doubleValue() < y)
      return x; 
    return Double.valueOf(y);
  }
  
  public static Object min(Object x, Object y) {
    if (isNaN(x))
      return x; 
    if (isNaN(y))
      return y; 
    if (lt(x, y))
      return x; 
    return y;
  }
}
