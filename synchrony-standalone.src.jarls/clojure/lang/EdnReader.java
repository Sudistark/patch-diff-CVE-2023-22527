package clojure.lang;

import java.io.IOException;
import java.io.PushbackReader;
import java.io.Reader;
import java.io.StringReader;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class EdnReader {
  static IFn[] macros = new IFn[256];
  
  static IFn[] dispatchMacros = new IFn[256];
  
  static Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)");
  
  static Pattern intPat = Pattern.compile("([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?");
  
  static Pattern ratioPat = Pattern.compile("([-+]?[0-9]+)/([0-9]+)");
  
  static Pattern floatPat = Pattern.compile("([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?");
  
  static IFn taggedReader = new TaggedReader();
  
  static final Keyword EOF;
  
  static  {
    macros[34] = new StringReader();
    macros[59] = new CommentReader();
    macros[94] = new MetaReader();
    macros[40] = new ListReader();
    macros[41] = new UnmatchedDelimiterReader();
    macros[91] = new VectorReader();
    macros[93] = new UnmatchedDelimiterReader();
    macros[123] = new MapReader();
    macros[125] = new UnmatchedDelimiterReader();
    macros[92] = new CharacterReader();
    macros[35] = new DispatchReader();
    dispatchMacros[35] = new SymbolicValueReader();
    dispatchMacros[94] = new MetaReader();
    dispatchMacros[123] = new SetReader();
    dispatchMacros[60] = new UnreadableReader();
    dispatchMacros[95] = new DiscardReader();
    dispatchMacros[58] = new NamespaceMapReader();
    EOF = Keyword.intern(null, "eof");
  }
  
  static boolean nonConstituent(int ch) { return (ch == 64 || ch == 96 || ch == 126); }
  
  public static Object readString(String s, IPersistentMap opts) {
    PushbackReader r = new PushbackReader(new StringReader(s));
    return read(r, opts);
  }
  
  static boolean isWhitespace(int ch) { return (Character.isWhitespace(ch) || ch == 44); }
  
  static void unread(PushbackReader r, int ch) {
    if (ch != -1)
      try {
        r.unread(ch);
      } catch (IOException e) {
        throw Util.sneakyThrow(e);
      }  
  }
  
  public static int read1(Reader r) {
    try {
      return r.read();
    } catch (IOException e) {
      throw Util.sneakyThrow(e);
    } 
  }
  
  public static Object read(PushbackReader r, IPersistentMap opts) { return read(r, !opts.containsKey(EOF), opts.valAt(EOF), false, opts); }
  
  public static Object read(PushbackReader r, boolean eofIsError, Object eofValue, boolean isRecursive, Object opts) {
    try {
      int ch;
      while (true) {
        ch = read1(r);
        while (isWhitespace(ch))
          ch = read1(r); 
        if (ch == -1) {
          if (eofIsError)
            throw Util.runtimeException("EOF while reading"); 
          return eofValue;
        } 
        if (Character.isDigit(ch)) {
          Object n = readNumber(r, (char)ch);
          if (RT.suppressRead())
            return null; 
          return n;
        } 
        IFn macroFn = getMacro(ch);
        if (macroFn != null) {
          Object ret = macroFn.invoke(r, Character.valueOf((char)ch), opts);
          if (RT.suppressRead())
            return null; 
          if (ret == r)
            continue; 
          return ret;
        } 
        break;
      } 
      if (ch == 43 || ch == 45) {
        int ch2 = read1(r);
        if (Character.isDigit(ch2)) {
          unread(r, ch2);
          Object n = readNumber(r, (char)ch);
          if (RT.suppressRead())
            return null; 
          return n;
        } 
        unread(r, ch2);
      } 
      String token = readToken(r, (char)ch, true);
      if (RT.suppressRead())
        return null; 
      return interpretToken(token);
    } catch (Exception e) {
      if (isRecursive || !(r instanceof LineNumberingPushbackReader))
        throw Util.sneakyThrow(e); 
      LineNumberingPushbackReader rdr = (LineNumberingPushbackReader)r;
      throw new ReaderException(rdr.getLineNumber(), rdr.getColumnNumber(), e);
    } 
  }
  
  private static String readToken(PushbackReader r, char initch, boolean leadConstituent) {
    StringBuilder sb = new StringBuilder();
    if (leadConstituent && nonConstituent(initch))
      throw Util.runtimeException("Invalid leading character: " + initch); 
    sb.append(initch);
    while (true) {
      int ch = read1(r);
      if (ch == -1 || isWhitespace(ch) || isTerminatingMacro(ch)) {
        unread(r, ch);
        return sb.toString();
      } 
      if (nonConstituent(ch))
        throw Util.runtimeException("Invalid constituent character: " + (char)ch); 
      sb.append((char)ch);
    } 
  }
  
  private static Object readNumber(PushbackReader r, char initch) {
    StringBuilder sb = new StringBuilder();
    sb.append(initch);
    while (true) {
      int ch = read1(r);
      if (ch == -1 || isWhitespace(ch) || isMacro(ch)) {
        unread(r, ch);
        break;
      } 
      sb.append((char)ch);
    } 
    String s = sb.toString();
    Object n = matchNumber(s);
    if (n == null)
      throw new NumberFormatException("Invalid number: " + s); 
    return n;
  }
  
  private static int readUnicodeChar(String token, int offset, int length, int base) {
    if (token.length() != offset + length)
      throw new IllegalArgumentException("Invalid unicode character: \\" + token); 
    int uc = 0;
    for (int i = offset; i < offset + length; i++) {
      int d = Character.digit(token.charAt(i), base);
      if (d == -1)
        throw new IllegalArgumentException("Invalid digit: " + token.charAt(i)); 
      uc = uc * base + d;
    } 
    return (char)uc;
  }
  
  private static int readUnicodeChar(PushbackReader r, int initch, int base, int length, boolean exact) {
    int uc = Character.digit(initch, base);
    if (uc == -1)
      throw new IllegalArgumentException("Invalid digit: " + (char)initch); 
    int i = 1;
    for (; i < length; i++) {
      int ch = read1(r);
      if (ch == -1 || isWhitespace(ch) || isMacro(ch)) {
        unread(r, ch);
        break;
      } 
      int d = Character.digit(ch, base);
      if (d == -1)
        throw new IllegalArgumentException("Invalid digit: " + (char)ch); 
      uc = uc * base + d;
    } 
    if (i != length && exact)
      throw new IllegalArgumentException("Invalid character length: " + i + ", should be: " + length); 
    return uc;
  }
  
  private static Object interpretToken(String s) {
    if (s.equals("nil"))
      return null; 
    if (s.equals("true"))
      return RT.T; 
    if (s.equals("false"))
      return RT.F; 
    Object ret = null;
    ret = matchSymbol(s);
    if (ret != null)
      return ret; 
    throw Util.runtimeException("Invalid token: " + s);
  }
  
  private static Object matchSymbol(String s) {
    Matcher m = symbolPat.matcher(s);
    if (m.matches()) {
      int gc = m.groupCount();
      String ns = m.group(1);
      String name = m.group(2);
      if ((ns != null && ns.endsWith(":/")) || name
        .endsWith(":") || s
        .indexOf("::", 1) != -1)
        return null; 
      if (s.startsWith("::"))
        return null; 
      boolean isKeyword = (s.charAt(0) == ':');
      Symbol sym = Symbol.intern(s.substring(isKeyword ? 1 : 0));
      if (isKeyword)
        return Keyword.intern(sym); 
      return sym;
    } 
    return null;
  }
  
  private static Object matchNumber(String s) {
    Matcher m = intPat.matcher(s);
    if (m.matches()) {
      if (m.group(2) != null) {
        if (m.group(8) != null)
          return BigInt.ZERO; 
        return Numbers.num(0L);
      } 
      boolean negate = m.group(1).equals("-");
      int radix = 10;
      String n;
      if ((n = m.group(3)) != null) {
        radix = 10;
      } else if ((n = m.group(4)) != null) {
        radix = 16;
      } else if ((n = m.group(5)) != null) {
        radix = 8;
      } else if ((n = m.group(7)) != null) {
        radix = Integer.parseInt(m.group(6));
      } 
      if (n == null)
        return null; 
      BigInteger bn = new BigInteger(n, radix);
      if (negate)
        bn = bn.negate(); 
      if (m.group(8) != null)
        return BigInt.fromBigInteger(bn); 
      return (bn.bitLength() < 64) ? 
        Numbers.num(bn.longValue()) : 
        BigInt.fromBigInteger(bn);
    } 
    m = floatPat.matcher(s);
    if (m.matches()) {
      if (m.group(4) != null)
        return new BigDecimal(m.group(1)); 
      return Double.valueOf(Double.parseDouble(s));
    } 
    m = ratioPat.matcher(s);
    if (m.matches()) {
      String numerator = m.group(1);
      if (numerator.startsWith("+"))
        numerator = numerator.substring(1); 
      return Numbers.divide(Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(numerator))), 
          Numbers.reduceBigInt(BigInt.fromBigInteger(new BigInteger(m.group(2)))));
    } 
    return null;
  }
  
  private static IFn getMacro(int ch) {
    if (ch < macros.length)
      return macros[ch]; 
    return null;
  }
  
  private static boolean isMacro(int ch) { return (ch < macros.length && macros[ch] != null); }
  
  private static boolean isTerminatingMacro(int ch) { return (ch != 35 && ch != 39 && isMacro(ch)); }
  
  public static List readDelimitedList(char delim, PushbackReader r, boolean isRecursive, Object opts) {
    int firstline = (r instanceof LineNumberingPushbackReader) ? ((LineNumberingPushbackReader)r).getLineNumber() : -1;
    ArrayList a = new ArrayList();
    while (true) {
      int ch = read1(r);
      while (isWhitespace(ch))
        ch = read1(r); 
      if (ch == -1) {
        if (firstline < 0)
          throw Util.runtimeException("EOF while reading"); 
        throw Util.runtimeException("EOF while reading, starting at line " + firstline);
      } 
      if (ch == delim)
        break; 
      IFn macroFn = getMacro(ch);
      if (macroFn != null) {
        Object mret = macroFn.invoke(r, Character.valueOf((char)ch), opts);
        if (mret != r)
          a.add(mret); 
        continue;
      } 
      unread(r, ch);
      Object o = read(r, true, null, isRecursive, opts);
      if (o != r)
        a.add(o); 
    } 
    return a;
  }
}
