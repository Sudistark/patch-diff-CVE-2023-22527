package clojure.lang;

import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

public class TransformerIterator implements Iterator {
  private static final Buffer EMPTY = new Empty(null);
  
  private static final Object NONE = new Object();
  
  private final Iterator sourceIter;
  
  private final IFn xf;
  
  private final boolean multi;
  
  private TransformerIterator(IFn xform, Iterator sourceIter, boolean multi) {
    this.buffer = EMPTY;
    this.next = NONE;
    this.completed = false;
    this.sourceIter = sourceIter;
    this.xf = (IFn)xform.invoke(new Object(this));
    this.multi = multi;
  }
  
  public static Iterator create(IFn xform, Iterator source) { return new TransformerIterator(xform, source, false); }
  
  public static Iterator createMulti(IFn xform, List sources) {
    Iterator[] iters = new Iterator[sources.size()];
    for (int i = 0; i < sources.size(); i++)
      iters[i] = (Iterator)sources.get(i); 
    return new TransformerIterator(xform, new MultiIterator(iters), true);
  }
  
  private boolean step() {
    if (this.next != NONE)
      return true; 
    while (this.next == NONE) {
      if (this.buffer.isEmpty()) {
        if (this.completed)
          return false; 
        if (this.sourceIter.hasNext()) {
          Object iter = null;
          if (this.multi) {
            iter = this.xf.applyTo(RT.cons(null, this.sourceIter.next()));
          } else {
            iter = this.xf.invoke(null, this.sourceIter.next());
          } 
          if (RT.isReduced(iter)) {
            this.xf.invoke(null);
            this.completed = true;
          } 
          continue;
        } 
        this.xf.invoke(null);
        this.completed = true;
        continue;
      } 
      this.next = this.buffer.remove();
    } 
    return true;
  }
  
  public boolean hasNext() { return step(); }
  
  public Object next() {
    if (hasNext()) {
      Object ret = this.next;
      this.next = NONE;
      return ret;
    } 
    throw new NoSuchElementException();
  }
  
  public void remove() { throw new UnsupportedOperationException(); }
}
