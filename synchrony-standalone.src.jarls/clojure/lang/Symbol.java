package clojure.lang;

import java.io.ObjectStreamException;
import java.io.Serializable;

public class Symbol extends AFn implements IObj, Comparable, Named, Serializable, IHashEq {
  final String ns;
  
  final String name;
  
  private int _hasheq;
  
  final IPersistentMap _meta;
  
  String _str;
  
  public String toString() {
    if (this._str == null)
      if (this.ns != null) {
        this._str = this.ns + "/" + this.name;
      } else {
        this._str = this.name;
      }  
    return this._str;
  }
  
  public String getNamespace() { return this.ns; }
  
  public String getName() { return this.name; }
  
  public static Symbol create(String ns, String name) { return intern(ns, name); }
  
  public static Symbol create(String nsname) { return intern(nsname); }
  
  public static Symbol intern(String ns, String name) { return new Symbol(ns, name); }
  
  public static Symbol intern(String nsname) {
    int i = nsname.indexOf('/');
    if (i == -1 || nsname.equals("/"))
      return new Symbol(null, nsname); 
    return new Symbol(nsname.substring(0, i), nsname.substring(i + 1));
  }
  
  private Symbol(String ns_interned, String name_interned) {
    this.name = name_interned;
    this.ns = ns_interned;
    this._meta = null;
  }
  
  public boolean equals(Object o) {
    if (this == o)
      return true; 
    if (!(o instanceof Symbol))
      return false; 
    Symbol symbol = (Symbol)o;
    return (Util.equals(this.ns, symbol.ns) && this.name.equals(symbol.name));
  }
  
  public int hashCode() { return Util.hashCombine(this.name.hashCode(), Util.hash(this.ns)); }
  
  public int hasheq() {
    if (this._hasheq == 0)
      this._hasheq = Util.hashCombine(Murmur3.hashUnencodedChars(this.name), Util.hash(this.ns)); 
    return this._hasheq;
  }
  
  public IObj withMeta(IPersistentMap meta) {
    if (meta() == meta)
      return this; 
    return new Symbol(meta, this.ns, this.name);
  }
  
  private Symbol(IPersistentMap meta, String ns, String name) {
    this.name = name;
    this.ns = ns;
    this._meta = meta;
  }
  
  public int compareTo(Object o) {
    Symbol s = (Symbol)o;
    if (equals(o))
      return 0; 
    if (this.ns == null && s.ns != null)
      return -1; 
    if (this.ns != null) {
      if (s.ns == null)
        return 1; 
      int nsc = this.ns.compareTo(s.ns);
      if (nsc != 0)
        return nsc; 
    } 
    return this.name.compareTo(s.name);
  }
  
  private Object readResolve() throws ObjectStreamException { return intern(this.ns, this.name); }
  
  public Object invoke(Object obj) { return RT.get(obj, this); }
  
  public Object invoke(Object obj, Object notFound) { return RT.get(obj, this, notFound); }
  
  public IPersistentMap meta() { return this._meta; }
}
