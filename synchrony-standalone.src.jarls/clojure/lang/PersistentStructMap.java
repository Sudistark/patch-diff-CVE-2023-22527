package clojure.lang;

import java.util.Iterator;

public class PersistentStructMap extends APersistentMap implements IObj {
  final Def def;
  
  final Object[] vals;
  
  final IPersistentMap ext;
  
  final IPersistentMap _meta;
  
  public static Def createSlotMap(ISeq keys) {
    if (keys == null)
      throw new IllegalArgumentException("Must supply keys"); 
    int c = RT.count(keys);
    Object[] v = new Object[2 * c];
    int i = 0;
    for (ISeq s = keys; s != null; s = s.next(), i++) {
      v[2 * i] = s.first();
      v[2 * i + 1] = Integer.valueOf(i);
    } 
    return new Def(keys, RT.map(v));
  }
  
  public static PersistentStructMap create(Def def, ISeq keyvals) {
    Object[] vals = new Object[def.keyslots.count()];
    IPersistentMap iPersistentMap = PersistentHashMap.EMPTY;
    for (; keyvals != null; keyvals = keyvals.next().next()) {
      if (keyvals.next() == null)
        throw new IllegalArgumentException(String.format("No value supplied for key: %s", new Object[] { keyvals.first() })); 
      Object k = keyvals.first();
      Object v = RT.second(keyvals);
      IMapEntry iMapEntry = def.keyslots.entryAt(k);
      if (iMapEntry != null) {
        vals[((Integer)iMapEntry.getValue()).intValue()] = v;
      } else {
        iPersistentMap = iPersistentMap.assoc(k, v);
      } 
    } 
    return new PersistentStructMap(null, def, vals, iPersistentMap);
  }
  
  public static PersistentStructMap construct(Def def, ISeq valseq) {
    Object[] vals = new Object[def.keyslots.count()];
    PersistentHashMap persistentHashMap = PersistentHashMap.EMPTY;
    for (int i = 0; i < vals.length && valseq != null; valseq = valseq.next(), i++)
      vals[i] = valseq.first(); 
    if (valseq != null)
      throw new IllegalArgumentException("Too many arguments to struct constructor"); 
    return new PersistentStructMap(null, def, vals, persistentHashMap);
  }
  
  public static IFn getAccessor(Def def, Object key) {
    IMapEntry iMapEntry = def.keyslots.entryAt(key);
    if (iMapEntry != null) {
      int i = ((Integer)iMapEntry.getValue()).intValue();
      return new Object(def, i);
    } 
    throw new IllegalArgumentException("Not a key of struct");
  }
  
  protected PersistentStructMap(IPersistentMap meta, Def def, Object[] vals, IPersistentMap ext) {
    this._meta = meta;
    this.ext = ext;
    this.def = def;
    this.vals = vals;
  }
  
  protected PersistentStructMap makeNew(IPersistentMap meta, Def def, Object[] vals, IPersistentMap ext) { return new PersistentStructMap(meta, def, vals, ext); }
  
  public IObj withMeta(IPersistentMap meta) {
    if (meta == this._meta)
      return this; 
    return makeNew(meta, this.def, this.vals, this.ext);
  }
  
  public IPersistentMap meta() { return this._meta; }
  
  public boolean containsKey(Object key) { return (this.def.keyslots.containsKey(key) || this.ext.containsKey(key)); }
  
  public IMapEntry entryAt(Object key) {
    IMapEntry iMapEntry = this.def.keyslots.entryAt(key);
    if (iMapEntry != null)
      return MapEntry.create(iMapEntry.getKey(), this.vals[((Integer)iMapEntry.getValue()).intValue()]); 
    return this.ext.entryAt(key);
  }
  
  public IPersistentMap assoc(Object key, Object val) {
    IMapEntry iMapEntry = this.def.keyslots.entryAt(key);
    if (iMapEntry != null) {
      int i = ((Integer)iMapEntry.getValue()).intValue();
      Object[] newVals = (Object[])this.vals.clone();
      newVals[i] = val;
      return makeNew(this._meta, this.def, newVals, this.ext);
    } 
    return makeNew(this._meta, this.def, this.vals, this.ext.assoc(key, val));
  }
  
  public Object valAt(Object key) {
    Integer i = (Integer)this.def.keyslots.valAt(key);
    if (i != null)
      return this.vals[i.intValue()]; 
    return this.ext.valAt(key);
  }
  
  public Object valAt(Object key, Object notFound) {
    Integer i = (Integer)this.def.keyslots.valAt(key);
    if (i != null)
      return this.vals[i.intValue()]; 
    return this.ext.valAt(key, notFound);
  }
  
  public IPersistentMap assocEx(Object key, Object val) {
    if (containsKey(key))
      throw Util.runtimeException("Key already present"); 
    return assoc(key, val);
  }
  
  public IPersistentMap without(Object key) {
    IMapEntry iMapEntry = this.def.keyslots.entryAt(key);
    if (iMapEntry != null)
      throw Util.runtimeException("Can't remove struct key"); 
    IPersistentMap newExt = this.ext.without(key);
    if (newExt == this.ext)
      return this; 
    return makeNew(this._meta, this.def, this.vals, newExt);
  }
  
  public Iterator iterator() { return new Object(this); }
  
  public int count() { return this.vals.length + RT.count(this.ext); }
  
  public ISeq seq() { return new Seq(null, this.def.keys, this.vals, 0, this.ext); }
  
  public IPersistentCollection empty() { return construct(this.def, null); }
}
