package clojure.lang;

public class Repeat extends ASeq implements IReduce {
  private static final long INFINITE = -1L;
  
  private final long count;
  
  private final Object val;
  
  private Repeat(long count, Object val) {
    this.count = count;
    this.val = val;
  }
  
  private Repeat(IPersistentMap meta, long count, Object val) {
    super(meta);
    this.count = count;
    this.val = val;
  }
  
  public static Repeat create(Object val) { return new Repeat(-1L, val); }
  
  public static ISeq create(long count, Object val) {
    if (count <= 0L)
      return PersistentList.EMPTY; 
    return new Repeat(count, val);
  }
  
  public Object first() { return this.val; }
  
  public ISeq next() {
    if (this._next == null)
      if (this.count > 1L) {
        this._next = new Repeat(this.count - 1L, this.val);
      } else if (this.count == -1L) {
        this._next = this;
      }  
    return this._next;
  }
  
  public Repeat withMeta(IPersistentMap meta) {
    if (meta() == meta)
      return this; 
    return new Repeat(meta, this.count, this.val);
  }
  
  public Object reduce(IFn f) {
    Object ret = this.val;
    if (this.count == -1L) {
      do {
        ret = f.invoke(ret, this.val);
      } while (!RT.isReduced(ret));
      return ((IDeref)ret).deref();
    } 
    for (long i = 1L; i < this.count; i++) {
      ret = f.invoke(ret, this.val);
      if (RT.isReduced(ret))
        return ((IDeref)ret).deref(); 
    } 
    return ret;
  }
  
  public Object reduce(IFn f, Object start) {
    Object ret = start;
    if (this.count == -1L) {
      do {
        ret = f.invoke(ret, this.val);
      } while (!RT.isReduced(ret));
      return ((IDeref)ret).deref();
    } 
    long i;
    for (i = 0L; i < this.count; i++) {
      ret = f.invoke(ret, this.val);
      if (RT.isReduced(ret))
        return ((IDeref)ret).deref(); 
    } 
    return ret;
  }
}
