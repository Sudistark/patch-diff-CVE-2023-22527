package clojure.lang;

import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;

public class Agent extends ARef {
  static final Keyword CONTINUE = Keyword.intern(null, "continue");
  
  static final Keyword FAIL = Keyword.intern(null, "fail");
  
  AtomicReference<ActionQueue> aq = new AtomicReference(ActionQueue.EMPTY);
  
  private static final AtomicLong sendThreadPoolCounter = new AtomicLong(0L);
  
  private static final AtomicLong sendOffThreadPoolCounter = new AtomicLong(0L);
  
  static final ThreadLocal<IPersistentVector> nested = new ThreadLocal();
  
  private static ThreadFactory createThreadFactory(String format, AtomicLong threadPoolCounter) { return new Object(format, threadPoolCounter); }
  
  public static void shutdown() {
    soloExecutor.shutdown();
    pooledExecutor.shutdown();
  }
  
  public Agent(Object state) { this(state, null); }
  
  public Agent(Object state, IPersistentMap meta) {
    super(meta);
    setState(state);
  }
  
  boolean setState(Object newState) {
    validate(newState);
    boolean ret = (this.state != newState);
    this.state = newState;
    return ret;
  }
  
  public Object deref() { return this.state; }
  
  public Throwable getError() { return ((ActionQueue)this.aq.get()).error; }
  
  public void setErrorMode(Keyword k) { this.errorMode = k; }
  
  public Keyword getErrorMode() { return this.errorMode; }
  
  public void setErrorHandler(IFn f) { this.errorHandler = f; }
  
  public IFn getErrorHandler() { return this.errorHandler; }
  
  public Object restart(Object newState, boolean clearActions) {
    if (getError() == null)
      throw Util.runtimeException("Agent does not need a restart"); 
    validate(newState);
    this.state = newState;
    if (clearActions) {
      this.aq.set(ActionQueue.EMPTY);
    } else {
      boolean restarted = false;
      ActionQueue prior = null;
      while (!restarted) {
        prior = (ActionQueue)this.aq.get();
        restarted = this.aq.compareAndSet(prior, new ActionQueue(prior.q, null));
      } 
      if (prior.q.count() > 0)
        ((Action)prior.q.peek()).execute(); 
    } 
    return newState;
  }
  
  public Object dispatch(IFn fn, ISeq args, Executor exec) {
    Throwable error = getError();
    if (error != null)
      throw Util.runtimeException("Agent is failed, needs restart", error); 
    Action action = new Action(this, fn, args, exec);
    dispatchAction(action);
    return this;
  }
  
  static void dispatchAction(Action action) {
    LockingTransaction trans = LockingTransaction.getRunning();
    if (trans != null) {
      trans.enqueue(action);
    } else if (nested.get() != null) {
      nested.set(((IPersistentVector)nested.get()).cons(action));
    } else {
      action.agent.enqueue(action);
    } 
  }
  
  void enqueue(Action action) {
    boolean queued = false;
    ActionQueue prior = null;
    while (!queued) {
      prior = (ActionQueue)this.aq.get();
      queued = this.aq.compareAndSet(prior, new ActionQueue((IPersistentStack)prior.q.cons(action), prior.error));
    } 
    if (prior.q.count() == 0 && prior.error == null)
      action.execute(); 
  }
  
  public int getQueueCount() { return ((ActionQueue)this.aq.get()).q.count(); }
  
  public static int releasePendingSends() {
    sends = (IPersistentVector)nested.get();
    if (sends == null)
      return 0; 
    for (int i = 0; i < sends.count(); i++) {
      Action a = (Action)sends.valAt(Integer.valueOf(i));
      a.agent.enqueue(a);
    } 
    nested.set(PersistentVector.EMPTY);
    return sends.count();
  }
}
