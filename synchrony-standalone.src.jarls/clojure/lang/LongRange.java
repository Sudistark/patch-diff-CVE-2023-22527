package clojure.lang;

import java.util.Iterator;

public class LongRange extends ASeq implements Counted, IChunkedSeq, IReduce {
  private static final int CHUNK_SIZE = 32;
  
  final long start;
  
  final long end;
  
  final long step;
  
  final BoundsCheck boundsCheck;
  
  private static BoundsCheck positiveStep(long end) { return new Object(end); }
  
  private static BoundsCheck negativeStep(long end) { return new Object(end); }
  
  private LongRange(long start, long end, long step, BoundsCheck boundsCheck) {
    this.start = start;
    this.end = end;
    this.step = step;
    this.boundsCheck = boundsCheck;
  }
  
  private LongRange(long start, long end, long step, BoundsCheck boundsCheck, LongChunk chunk, ISeq chunkNext) {
    this.start = start;
    this.end = end;
    this.step = step;
    this.boundsCheck = boundsCheck;
    this._chunk = chunk;
    this._chunkNext = chunkNext;
  }
  
  private LongRange(IPersistentMap meta, long start, long end, long step, BoundsCheck boundsCheck, LongChunk chunk, ISeq chunkNext) {
    super(meta);
    this.start = start;
    this.end = end;
    this.step = step;
    this.boundsCheck = boundsCheck;
    this._chunk = chunk;
    this._chunkNext = chunkNext;
  }
  
  public static ISeq create(long end) {
    if (end > 0L)
      return new LongRange(0L, end, 1L, positiveStep(end)); 
    return PersistentList.EMPTY;
  }
  
  public static ISeq create(long start, long end) {
    if (start >= end)
      return PersistentList.EMPTY; 
    return new LongRange(start, end, 1L, positiveStep(end));
  }
  
  public static ISeq create(long start, long end, long step) {
    if (step > 0L) {
      if (end <= start)
        return PersistentList.EMPTY; 
      return new LongRange(start, end, step, positiveStep(end));
    } 
    if (step < 0L) {
      if (end >= start)
        return PersistentList.EMPTY; 
      return new LongRange(start, end, step, negativeStep(end));
    } 
    if (end == start)
      return PersistentList.EMPTY; 
    return Repeat.create(Long.valueOf(start));
  }
  
  public Obj withMeta(IPersistentMap meta) {
    if (meta == this._meta)
      return this; 
    return new LongRange(meta, this.start, this.end, this.step, this.boundsCheck, this._chunk, this._chunkNext);
  }
  
  public Object first() { return Long.valueOf(this.start); }
  
  public void forceChunk() {
    long count;
    if (this._chunk != null)
      return; 
    try {
      count = rangeCount(this.start, this.end, this.step);
    } catch (ArithmeticException e) {
      count = steppingCount(this.start, this.end, this.step);
    } 
    if (count > 32L) {
      long nextStart = this.start + this.step * 32L;
      this._chunkNext = new LongRange(nextStart, this.end, this.step, this.boundsCheck);
      this._chunk = new LongChunk(this.start, this.step, 32);
    } else {
      this._chunk = new LongChunk(this.start, this.step, (int)count);
    } 
  }
  
  public ISeq next() {
    if (this._next != null)
      return this._next; 
    forceChunk();
    if (this._chunk.count() > 1) {
      LongChunk smallerChunk = this._chunk.dropFirst();
      this._next = new LongRange(smallerChunk.first(), this.end, this.step, this.boundsCheck, smallerChunk, this._chunkNext);
      return this._next;
    } 
    return chunkedNext();
  }
  
  public IChunk chunkedFirst() {
    forceChunk();
    return this._chunk;
  }
  
  public ISeq chunkedNext() { return chunkedMore().seq(); }
  
  public ISeq chunkedMore() {
    forceChunk();
    if (this._chunkNext == null)
      return PersistentList.EMPTY; 
    return this._chunkNext;
  }
  
  long steppingCount(long start, long end, long step) {
    long count = 1L;
    long s = start;
    while (count <= 32L) {
      try {
        s = Numbers.add(s, step);
        if (this.boundsCheck.exceededBounds(s))
          break; 
        count++;
      } catch (ArithmeticException e) {
        break;
      } 
    } 
    return count;
  }
  
  long rangeCount(long start, long end, long step) { return Numbers.add(Numbers.add(Numbers.minus(end, start), step), (this.step > 0L) ? -1L : 1L) / step; }
  
  public int count() {
    try {
      long c = rangeCount(this.start, this.end, this.step);
      if (c > 2147483647L)
        return Numbers.throwIntOverflow(); 
      return (int)c;
    } catch (ArithmeticException e) {
      Iterator iter = iterator();
      long count = 0L;
      while (iter.hasNext()) {
        iter.next();
        count++;
      } 
      if (count > 2147483647L)
        return Numbers.throwIntOverflow(); 
      return (int)count;
    } 
  }
  
  public Object reduce(IFn f) {
    Object acc = Long.valueOf(this.start);
    long i = this.start + this.step;
    while (!this.boundsCheck.exceededBounds(i)) {
      acc = f.invoke(acc, Long.valueOf(i));
      if (acc instanceof Reduced)
        return ((Reduced)acc).deref(); 
      i += this.step;
    } 
    return acc;
  }
  
  public Object reduce(IFn f, Object val) {
    Object acc = val;
    long i = this.start;
    do {
      acc = f.invoke(acc, Long.valueOf(i));
      if (RT.isReduced(acc))
        return ((Reduced)acc).deref(); 
      i += this.step;
    } while (!this.boundsCheck.exceededBounds(i));
    return acc;
  }
  
  public Iterator iterator() { return new LongRangeIterator(this); }
}
