package clojure.tools;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentArrayMap;
import clojure.lang.PersistentHashSet;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class macro__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final AFn const__13;
  
  public static final Var const__14;
  
  public static final Var const__15;
  
  public static final Var const__16;
  
  public static final AFn const__19;
  
  public static final Var const__20;
  
  public static final AFn const__22;
  
  public static final Var const__23;
  
  public static final AFn const__25;
  
  public static final Var const__26;
  
  public static final AFn const__30;
  
  public static final Var const__31;
  
  public static final AFn const__34;
  
  public static final Var const__35;
  
  public static final AFn const__38;
  
  public static final Var const__39;
  
  public static final AFn const__42;
  
  public static final Var const__43;
  
  public static final AFn const__46;
  
  public static final Var const__47;
  
  public static final AFn const__50;
  
  public static final Var const__51;
  
  public static final AFn const__54;
  
  public static final Var const__55;
  
  public static final AFn const__58;
  
  public static final Var const__59;
  
  public static final AFn const__62;
  
  public static final Var const__63;
  
  public static final AFn const__66;
  
  public static final Var const__67;
  
  public static final AFn const__70;
  
  public static final Var const__71;
  
  public static final AFn const__74;
  
  public static final Var const__75;
  
  public static final AFn const__77;
  
  public static final AFn const__78;
  
  public static final AFn const__79;
  
  public static final AFn const__80;
  
  public static final AFn const__81;
  
  public static final AFn const__82;
  
  public static final AFn const__83;
  
  public static final Var const__84;
  
  public static final AFn const__85;
  
  public static final AFn const__86;
  
  public static final AFn const__87;
  
  public static final AFn const__88;
  
  public static final Var const__89;
  
  public static final AFn const__92;
  
  public static final AFn const__95;
  
  public static final Var const__96;
  
  public static final AFn const__99;
  
  public static final Var const__100;
  
  public static final AFn const__103;
  
  public static final Var const__104;
  
  public static final AFn const__107;
  
  public static final Var const__108;
  
  public static final AFn const__111;
  
  public static final Var const__112;
  
  public static final AFn const__115;
  
  public static final Var const__116;
  
  public static final AFn const__119;
  
  public static final Var const__120;
  
  public static final AFn const__123;
  
  public static final Var const__124;
  
  public static final AFn const__127;
  
  public static final Var const__128;
  
  public static final AFn const__131;
  
  public static final Var const__132;
  
  public static final AFn const__135;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new macro.fn__30518());
    const__6.setMeta((IPersistentMap)const__13);
    const__6




















      
      .bindRoot(((IFn)const__14.getRawRoot()).invoke(PersistentHashSet.EMPTY, ((IFn)const__15.getRawRoot()).invoke(Compiler.specials)));
    const__16.setDynamic(true).setMeta((IPersistentMap)const__19);
    const__16.setDynamic(true).bindRoot(PersistentArrayMap.EMPTY);
    const__20.setDynamic(true).setMeta((IPersistentMap)const__22);
    const__20.setDynamic(true).bindRoot(PersistentArrayMap.EMPTY);
    const__23.setDynamic(true).setMeta((IPersistentMap)const__25);
    const__23.setDynamic(true).bindRoot(PersistentHashSet.EMPTY);
    const__26.setMeta((IPersistentMap)const__30);
    const__26.bindRoot(new macro.protected_QMARK_());
    const__31.setMeta((IPersistentMap)const__34);
    const__31.bindRoot(new macro.expand_symbol());
    const__35.setMeta((IPersistentMap)const__38);
    const__35.bindRoot(new macro.expand_1());
    const__39.setMeta((IPersistentMap)const__42);
    const__39.bindRoot(new macro.expand());
    const__43.setMeta((IPersistentMap)const__46);
    const__47.setMeta((IPersistentMap)const__50);
    const__47.bindRoot(new macro.expand_args());
    const__51.setMeta((IPersistentMap)const__54);
    const__51.bindRoot(new macro.expand_bindings());
    const__55.setMeta((IPersistentMap)const__58);
    const__55.bindRoot(new macro.expand_with_bindings());
    const__59.setMeta((IPersistentMap)const__62);
    const__59.bindRoot(new macro.expand_fn_body());
    const__63.setMeta((IPersistentMap)const__66);
    const__63.bindRoot(new macro.expand_fn());
    const__67.setMeta((IPersistentMap)const__70);
    const__67.bindRoot(new macro.expand_deftype());
    const__71.setMeta((IPersistentMap)const__74);
    const__71.bindRoot(new macro.expand_reify());
    const__75.setMeta((IPersistentMap)const__77);
    const__75.bindRoot(RT.mapUniqueKeys(new Object[] { 
            const__78, const__67.getRawRoot(), const__79, const__63.getRawRoot(), const__80, const__55.getRawRoot(), const__81, const__55.getRawRoot(), const__82, new macro.fn__30568(), 
            const__83, const__84.getRawRoot(), const__85, const__55.getRawRoot(), const__86, const__71.getRawRoot(), const__87, new macro.fn__30570(), const__88, const__84.getRawRoot() }));
    const__89.setMeta((IPersistentMap)const__92);
    const__89.bindRoot(new macro.expand_list());
    const__43.setMeta((IPersistentMap)const__95);
    const__43.bindRoot(new macro.expand_all());
    const__96.setMeta((IPersistentMap)const__99);
    const__96.bindRoot(new macro.check_not_qualified());
    const__100.setMeta((IPersistentMap)const__103);
    const__100.bindRoot(new macro.macrolet());
    ((Var)const__100)
















































































































































































      
      .setMacro();
    const__104.setMeta((IPersistentMap)const__107);
    const__104.bindRoot(new macro.symbol_macrolet());
    ((Var)const__104)









      
      .setMacro();
    const__108.setMeta((IPersistentMap)const__111);
    const__108.bindRoot(new macro.defsymbolmacro());
    ((Var)const__108)








      
      .setMacro();
    const__112.setMeta((IPersistentMap)const__115);
    const__112.bindRoot(new macro.with_symbol_macros());
    ((Var)const__112)







      
      .setMacro();
    const__116.setMeta((IPersistentMap)const__119);
    const__116.bindRoot(new macro.deftemplate());
    ((Var)const__116)



      
      .setMacro();
    const__120.setMeta((IPersistentMap)const__123);
    const__120.bindRoot(new macro.mexpand_1());
    const__124.setMeta((IPersistentMap)const__127);
    const__124.bindRoot(new macro.mexpand());
    const__128.setMeta((IPersistentMap)const__131);
    const__128.bindRoot(new macro.mexpand_all());
    const__132.setMeta((IPersistentMap)const__135);
    const__132.bindRoot(new macro.name_with_attributes());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.tools.macro")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "author"), "Konrad Hinsen", RT.keyword(null, "doc"), "Local macros and symbol macros\n\n           Local macros are defined by a macrolet form. They are usable only\n           inside its body. Symbol macros can be defined globally\n           (defsymbolmacro) or locally (symbol-macrolet). A symbol\n           macro defines a form that replaces a symbol during macro\n           expansion. Function arguments and symbols bound in let\n           forms are not subject to symbol macro expansion.\n\n           Local macros are most useful in the definition of the expansion\n           of another macro, they may be used anywhere. Global symbol\n           macros can be used only inside a with-symbol-macros form." }));
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "author"), "Konrad Hinsen", RT.keyword(null, "doc"), "Local macros and symbol macros\n\n           Local macros are defined by a macrolet form. They are usable only\n           inside its body. Symbol macros can be defined globally\n           (defsymbolmacro) or locally (symbol-macrolet). A symbol\n           macro defines a form that replaces a symbol during macro\n           expansion. Function arguments and symbols bound in let\n           forms are not subject to symbol macro expansion.\n\n           Local macros are most useful in the definition of the expansion\n           of another macro, they may be used anywhere. Global symbol\n           macros can be used only inside a with-symbol-macros form." });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.tools.macro", "special-forms");
    const__13 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(32), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__14 = (Var)RT.var("clojure.core", "into");
    const__15 = (Var)RT.var("clojure.core", "keys");
    const__16 = (Var)RT.var("clojure.tools.macro", "macro-fns");
    const__19 = (AFn)RT.map(new Object[] { RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(41), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__20 = (Var)RT.var("clojure.tools.macro", "macro-symbols");
    const__22 = (AFn)RT.map(new Object[] { RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(43), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__23 = (Var)RT.var("clojure.tools.macro", "protected-symbols");
    const__25 = (AFn)RT.map(new Object[] { RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(45), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__26 = (Var)RT.var("clojure.tools.macro", "protected?");
    const__30 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "symbol")) })), RT.keyword(null, "line"), Integer.valueOf(47), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__31 = (Var)RT.var("clojure.tools.macro", "expand-symbol");
    const__34 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "symbol")) })), RT.keyword(null, "doc"), "Expand symbol macros", RT.keyword(null, "line"), Integer.valueOf(56), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__35 = (Var)RT.var("clojure.tools.macro", "expand-1");
    const__38 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Perform a single non-recursive macro expansion of form.", RT.keyword(null, "line"), Integer.valueOf(68), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__39 = (Var)RT.var("clojure.tools.macro", "expand");
    const__42 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Perform repeated non-recursive macro expansion of form, until it no\n   longer changes.", RT.keyword(null, "line"), Integer.valueOf(92), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__43 = (Var)RT.var("clojure.tools.macro", "expand-all");
    const__46 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(101), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__47 = (Var)RT.var("clojure.tools.macro", "expand-args");
    const__50 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")), Tuple.create(Symbol.intern(null, "form"), Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Recursively expand the arguments of form, leaving its first\n   n elements unchanged.", RT.keyword(null, "line"), Integer.valueOf(103), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__51 = (Var)RT.var("clojure.tools.macro", "expand-bindings");
    const__54 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "exprs")) })), RT.keyword(null, "line"), Integer.valueOf(111), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__55 = (Var)RT.var("clojure.tools.macro", "expand-with-bindings");
    const__58 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Handle let*, letfn* and loop* forms. The symbols defined in them are\n   protected from symbol macro expansion, the definitions and the body\n   expressions are expanded recursively.", RT.keyword(null, "line"), Integer.valueOf(120), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__59 = (Var)RT.var("clojure.tools.macro", "expand-fn-body");
    const__62 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "args"), Symbol.intern(null, "&"), Symbol.intern(null, "exprs"))) })), RT.keyword(null, "line"), Integer.valueOf(133), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__63 = (Var)RT.var("clojure.tools.macro", "expand-fn");
    const__66 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Handle fn* forms. The arguments are protected from symbol macro\n   expansion, the bodies are expanded recursively.", RT.keyword(null, "line"), Integer.valueOf(139), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__67 = (Var)RT.var("clojure.tools.macro", "expand-deftype");
    const__70 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.vector(new Object[] { Symbol.intern(null, "symbol"), Symbol.intern(null, "typename"), Symbol.intern(null, "classname"), Symbol.intern(null, "fields"), Symbol.intern(null, "implements"), Symbol.intern(null, "interfaces"), Symbol.intern(null, "&"), Symbol.intern(null, "methods") })) })), RT.keyword(null, "doc"), "Handle deftype* forms.", RT.keyword(null, "line"), Integer.valueOf(152), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__71 = (Var)RT.var("clojure.tools.macro", "expand-reify");
    const__74 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "symbol"), Symbol.intern(null, "interfaces"), Symbol.intern(null, "&"), Symbol.intern(null, "methods"))) })), RT.keyword(null, "doc"), "Handle reify* forms.", RT.keyword(null, "line"), Integer.valueOf(161), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__75 = (Var)RT.var("clojure.tools.macro", "special-form-handlers");
    const__77 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(169), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__78 = (AFn)Symbol.intern(null, "deftype*");
    const__79 = (AFn)Symbol.intern(null, "fn*");
    const__80 = (AFn)Symbol.intern(null, "letfn*");
    const__81 = (AFn)Symbol.intern(null, "loop*");
    const__82 = (AFn)Symbol.intern(null, "def");
    const__83 = (AFn)Symbol.intern(null, "quote");
    const__84 = (Var)RT.var("clojure.core", "identity");
    const__85 = (AFn)Symbol.intern(null, "let*");
    const__86 = (AFn)Symbol.intern(null, "reify*");
    const__87 = (AFn)Symbol.intern(null, "new");
    const__88 = (AFn)Symbol.intern(null, "var");
    const__89 = (Var)RT.var("clojure.tools.macro", "expand-list");
    const__92 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Recursively expand a form that is a list or a cons.", RT.keyword(null, "line"), Integer.valueOf(181), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__95 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Expand a form recursively.", RT.keyword(null, "line"), Integer.valueOf(191), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__96 = (Var)RT.var("clojure.tools.macro", "check-not-qualified");
    const__99 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "symbols")) })), RT.keyword(null, "doc"), "Verify that none of the supplied symbols are namespace-qualified", RT.keyword(null, "line"), Integer.valueOf(201), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/macro.clj" });
  }
  
  public static void __init1() {
    const__100 = (Var)RT.var("clojure.tools.macro", "macrolet");
    const__103 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fn-bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "exprs")) })), RT.keyword(null, "doc"), "Define local macros that are used in the expansion of exprs. The\n   syntax is the same as for letfn forms.", RT.keyword(null, "line"), Integer.valueOf(211), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__104 = (Var)RT.var("clojure.tools.macro", "symbol-macrolet");
    const__107 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "symbol-bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "exprs")) })), RT.keyword(null, "doc"), "Define local symbol macros that are used in the expansion of exprs.\n   The syntax is the same as for let forms.", RT.keyword(null, "line"), Integer.valueOf(222), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__108 = (Var)RT.var("clojure.tools.macro", "defsymbolmacro");
    const__111 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "symbol"), Symbol.intern(null, "expansion")) })), RT.keyword(null, "doc"), "Define a symbol macro. Because symbol macros are not part of\n   Clojure's built-in macro expansion system, they can be used only\n   inside a with-symbol-macros form.", RT.keyword(null, "line"), Integer.valueOf(232), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__112 = (Var)RT.var("clojure.tools.macro", "with-symbol-macros");
    const__115 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "exprs")) })), RT.keyword(null, "doc"), "Fully expand exprs, including symbol macros.", RT.keyword(null, "line"), Integer.valueOf(241), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__116 = (Var)RT.var("clojure.tools.macro", "deftemplate");
    const__119 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "params"), Symbol.intern(null, "&"), Symbol.intern(null, "forms")) })), RT.keyword(null, "doc"), "Define a macro that expands into forms after replacing the\n   symbols in params (a vector) by the corresponding parameters\n   given in the macro call.", RT.keyword(null, "line"), Integer.valueOf(246), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__120 = (Var)RT.var("clojure.tools.macro", "mexpand-1");
    const__123 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Like clojure.core/macroexpand-1, but takes into account symbol macros.", RT.keyword(null, "line"), Integer.valueOf(258), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__124 = (Var)RT.var("clojure.tools.macro", "mexpand");
    const__127 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Like clojure.core/macroexpand, but takes into account symbol macros.", RT.keyword(null, "line"), Integer.valueOf(266), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__128 = (Var)RT.var("clojure.tools.macro", "mexpand-all");
    const__131 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "form")) })), RT.keyword(null, "doc"), "Perform a full recursive macro expansion of a form.", RT.keyword(null, "line"), Integer.valueOf(274), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/macro.clj" });
    const__132 = (Var)RT.var("clojure.tools.macro", "name-with-attributes");
    const__135 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "macro-args")) })), RT.keyword(null, "doc"), "To be used in macro definitions.\n   Handles optional docstrings and attribute maps for a name to be defined\n   in a list of macro arguments. If the first macro argument is a string,\n   it is added as a docstring to name and removed from the macro argument\n   list. If afterwards the first macro argument is a map, its entries are\n   added to the name's metadata map and the map is removed from the\n   macro argument list. The return value is a vector containing the name\n   with its extended metadata map and the list of unprocessed macro\n   arguments.", RT.keyword(null, "line"), Integer.valueOf(282), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/macro.clj" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("clojure.tools.macro__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
