package clojure.tools.analyzer;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class ast__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__3;
  
  public static final AFn const__4;
  
  public static final Var const__5;
  
  public static final AFn const__13;
  
  public static final Var const__14;
  
  public static final AFn const__17;
  
  public static final Var const__18;
  
  public static final AFn const__21;
  
  public static final Var const__22;
  
  public static final AFn const__26;
  
  public static final Var const__27;
  
  public static final AFn const__30;
  
  public static final Var const__31;
  
  public static final AFn const__34;
  
  public static final Var const__35;
  
  public static final AFn const__38;
  
  public static final Var const__39;
  
  public static final AFn const__42;
  
  public static final Var const__43;
  
  public static final AFn const__46;
  
  public static final Var const__47;
  
  public static final AFn const__50;
  
  public static final Var const__51;
  
  public static final AFn const__54;
  
  public static final Var const__55;
  
  public static final AFn const__58;
  
  public static void load() { LockingTransaction.runInTransaction((Callable)new ast.fn__986());
    const__5.setMeta((IPersistentMap)const__13);
    const__5.bindRoot(new ast.cycling());
    const__14.setMeta((IPersistentMap)const__17);
    const__14.bindRoot(new ast.children_STAR_());
    const__18.setMeta((IPersistentMap)const__21);
    const__18.bindRoot(new ast.children());
    const__22.setMeta((IPersistentMap)const__26);
    const__22.bindRoot(new ast._update_children());
    const__27.setMeta((IPersistentMap)const__30);
    const__27.bindRoot(new ast.update_children_reduced());
    const__31.setMeta((IPersistentMap)const__34);
    const__31.bindRoot(new ast.unreduced());
    const__35.setMeta((IPersistentMap)const__38);
    const__35.bindRoot(new ast.update_children());
    const__39.setMeta((IPersistentMap)const__42);
    const__39.bindRoot(new ast.walk());
    const__43.setMeta((IPersistentMap)const__46);
    const__43.bindRoot(new ast.prewalk());
    const__47.setMeta((IPersistentMap)const__50);
    const__47.bindRoot(new ast.postwalk());
    const__51.setMeta((IPersistentMap)const__54);
    const__51.bindRoot(new ast.nodes());
    const__55.setMeta((IPersistentMap)const__58);
    const__55.bindRoot(new ast.ast__GT_eav()); }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.tools.analyzer.ast")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Utilities for AST walking/updating" }));
    const__3 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Utilities for AST walking/updating" });
    const__4 = (AFn)Symbol.intern(null, "clojure.core");
    const__5 = (Var)RT.var("clojure.tools.analyzer.ast", "cycling");
    const__13 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "fns*")) })), RT.keyword(null, "doc"), "Combine the given passes in a single pass that will be applieed repeatedly\n   to the AST until applying it another time will have no effect", RT.keyword(null, "line"), Integer.valueOf(14), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/ast.clj" });
    const__14 = (Var)RT.var("clojure.tools.analyzer.ast", "children*");
    const__17 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "children")), RT.keyword(null, "as"), Symbol.intern(null, "ast") })) })), RT.keyword(null, "doc"), "Return a vector of vectors of the children node key and the children expression\n   of the AST node, if it has any.\n   The returned vector returns the childrens in the order as they appear in the\n   :children field of the AST, and the children expressions may be either a node\n   or a vector of nodes.", RT.keyword(null, "line"), Integer.valueOf(26), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/ast.clj" });
    const__18 = (Var)RT.var("clojure.tools.analyzer.ast", "children");
    const__21 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ast")) })), RT.keyword(null, "doc"), "Return a vector of the children expression of the AST node, if it has any.\n   The children expressions are kept in order and flattened so that the returning\n   vector contains only nodes and not vectors of nodes.", RT.keyword(null, "line"), Integer.valueOf(36), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/ast.clj" });
    const__22 = (Var)RT.var("clojure.tools.analyzer.ast", "-update-children");
    const__26 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ast"), Symbol.intern(null, "f"), Symbol.intern(null, "r?")) })), RT.keyword(null, "line"), Integer.valueOf(46), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/ast.clj" });
    const__27 = (Var)RT.var("clojure.tools.analyzer.ast", "update-children-reduced");
    const__30 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ast"), Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "ast"), Symbol.intern(null, "f"), Symbol.intern(null, "reversed?")) })), RT.keyword(null, "doc"), "Like update-children but returns a reduced holding the AST if f short-circuited.", RT.keyword(null, "line"), Integer.valueOf(58), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/ast.clj" });
    const__31 = (Var)RT.var("clojure.tools.analyzer.ast", "unreduced");
    const__34 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(70), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/ast.clj" });
    const__35 = (Var)RT.var("clojure.tools.analyzer.ast", "update-children");
    const__38 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ast"), Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "ast"), Symbol.intern(null, "f"), Symbol.intern(null, "reversed?")) })), RT.keyword(null, "doc"), "Applies `f` to each AST children node, replacing it with the returned value.\n   If reversed? is not-nil, `pre` and `post` will be applied starting from the last\n   children of the AST node to the first one.\n   Short-circuits on reduced.", RT.keyword(null, "line"), Integer.valueOf(75), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/ast.clj" });
    const__39 = (Var)RT.var("clojure.tools.analyzer.ast", "walk");
    const__42 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ast"), Symbol.intern(null, "pre"), Symbol.intern(null, "post")), Tuple.create(Symbol.intern(null, "ast"), Symbol.intern(null, "pre"), Symbol.intern(null, "post"), Symbol.intern(null, "reversed?")) })), RT.keyword(null, "doc"), "Walk the ast applying `pre` when entering the nodes, and `post` when exiting.\n   Both functions must return a valid node since the returned value will replace\n   the node in the AST which was given as input to the function.\n   If reversed? is not-nil, `pre` and `post` will be applied starting from the last\n   children of the AST node to the first one.\n   Short-circuits on reduced.", RT.keyword(null, "line"), Integer.valueOf(84), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/ast.clj" });
    const__43 = (Var)RT.var("clojure.tools.analyzer.ast", "prewalk");
    const__46 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ast"), Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Shorthand for (walk ast f identity)", RT.keyword(null, "line"), Integer.valueOf(105), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/ast.clj" });
    const__47 = (Var)RT.var("clojure.tools.analyzer.ast", "postwalk");
    const__50 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ast"), Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "ast"), Symbol.intern(null, "f"), Symbol.intern(null, "reversed?")) })), RT.keyword(null, "doc"), "Shorthand for (walk ast identity f reversed?)", RT.keyword(null, "line"), Integer.valueOf(110), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/ast.clj" });
    const__51 = (Var)RT.var("clojure.tools.analyzer.ast", "nodes");
    const__54 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ast")) })), RT.keyword(null, "doc"), "Returns a lazy-seq of all the nodes in the given AST, in depth-first pre-order.", RT.keyword(null, "line"), Integer.valueOf(117), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/ast.clj" });
    const__55 = (Var)RT.var("clojure.tools.analyzer.ast", "ast->eav");
    const__58 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ast")) })), RT.keyword(null, "doc"), "Returns an EAV representation of the current AST that can be used by\n   Datomic's Datalog.", RT.keyword(null, "line"), Integer.valueOf(123), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/ast.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("clojure.tools.analyzer.ast__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
