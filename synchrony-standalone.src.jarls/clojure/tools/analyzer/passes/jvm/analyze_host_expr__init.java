package clojure.tools.analyzer.passes.jvm;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IPersistentMap;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentHashSet;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class analyze_host_expr__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__2;
  
  public static final Var const__3;
  
  public static final Keyword const__4;
  
  public static final Keyword const__6;
  
  public static final Keyword const__8;
  
  public static final Object const__9;
  
  public static final Keyword const__10;
  
  public static final AFn const__11;
  
  public static final Var const__12;
  
  public static final AFn const__15;
  
  public static final Var const__16;
  
  public static final AFn const__19;
  
  public static final Var const__20;
  
  public static final AFn const__23;
  
  public static final Var const__24;
  
  public static final AFn const__27;
  
  public static final Var const__28;
  
  public static final AFn const__31;
  
  public static final Var const__32;
  
  public static final AFn const__35;
  
  public static final Var const__36;
  
  public static final Object const__37;
  
  public static final Keyword const__38;
  
  public static final Keyword const__39;
  
  public static final Keyword const__40;
  
  public static final Keyword const__41;
  
  public static final Keyword const__42;
  
  public static final Object const__43;
  
  public static void load() { LockingTransaction.runInTransaction((Callable)new analyze_host_expr.fn__2139());
    const__3.setMeta((IPersistentMap)const__11);
    const__3.bindRoot(new analyze_host_expr.maybe_static_field());
    const__12.setMeta((IPersistentMap)const__15);
    const__12.bindRoot(new analyze_host_expr.maybe_static_method());
    const__16.setMeta((IPersistentMap)const__19);
    const__16.bindRoot(new analyze_host_expr.maybe_instance_method());
    const__20.setMeta((IPersistentMap)const__23);
    const__20.bindRoot(new analyze_host_expr.maybe_instance_field());
    const__24.setMeta((IPersistentMap)const__27);
    const__24.bindRoot(new analyze_host_expr.analyze_host_call());
    const__28.setMeta((IPersistentMap)const__31);
    const__28.bindRoot(new analyze_host_expr.analyze_host_field());
    const__32.setMeta((IPersistentMap)const__35);
    const__32.bindRoot(new analyze_host_expr._analyze_host_expr());
    const__36.setMeta((IPersistentMap)RT.mapUniqueKeys(new Object[] { 
            const__4, const__37, const__38, "Performing some reflection, transforms :host-interop/:host-call/:host-field\n   nodes in either: :static-field, :static-call, :instance-call, :instance-field\n   or :host-interop nodes, and a :var or :maybe-class node in a :const :class node,\n   if necessary (class literals shadow Vars).\n\n   A :host-interop node represents either an instance-field or a no-arg instance-method. ", const__39, RT.mapUniqueKeys(new Object[] { const__40, const__41, const__42, PersistentHashSet.EMPTY }), const__6, const__43, const__8, const__9, 
            const__10, "clojure/tools/analyzer/passes/jvm/analyze_host_expr.clj" }));
    const__36.bindRoot(new analyze_host_expr.analyze_host_expr()); }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "clojure.tools.analyzer.passes.jvm.analyze-host-expr");
    const__2 = (AFn)Symbol.intern(null, "clojure.core");
    const__3 = (Var)RT.var("clojure.tools.analyzer.passes.jvm.analyze-host-expr", "maybe-static-field");
    const__4 = (Keyword)RT.keyword(null, "arglists");
    const__6 = (Keyword)RT.keyword(null, "line");
    const__8 = (Keyword)RT.keyword(null, "column");
    const__9 = Integer.valueOf(1);
    const__10 = (Keyword)RT.keyword(null, "file");
    const__11 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "class"), Symbol.intern(null, "sym"))) })), RT.keyword(null, "line"), Integer.valueOf(14), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/passes/jvm/analyze_host_expr.clj" });
    const__12 = (Var)RT.var("clojure.tools.analyzer.passes.jvm.analyze-host-expr", "maybe-static-method");
    const__15 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "class"), Symbol.intern(null, "sym"))) })), RT.keyword(null, "line"), Integer.valueOf(23), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/passes/jvm/analyze_host_expr.clj" });
    const__16 = (Var)RT.var("clojure.tools.analyzer.passes.jvm.analyze-host-expr", "maybe-instance-method");
    const__19 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "target-expr"), Symbol.intern(null, "class"), Symbol.intern(null, "sym")) })), RT.keyword(null, "line"), Integer.valueOf(31), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/passes/jvm/analyze_host_expr.clj" });
    const__20 = (Var)RT.var("clojure.tools.analyzer.passes.jvm.analyze-host-expr", "maybe-instance-field");
    const__23 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "target-expr"), Symbol.intern(null, "class"), Symbol.intern(null, "sym")) })), RT.keyword(null, "line"), Integer.valueOf(41), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/passes/jvm/analyze_host_expr.clj" });
    const__24 = (Var)RT.var("clojure.tools.analyzer.passes.jvm.analyze-host-expr", "analyze-host-call");
    const__27 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "target-type"), Symbol.intern(null, "method"), Symbol.intern(null, "args"), Symbol.intern(null, "target-expr"), Symbol.intern(null, "class"), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(52), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/passes/jvm/analyze_host_expr.clj" });
    const__28 = (Var)RT.var("clojure.tools.analyzer.passes.jvm.analyze-host-expr", "analyze-host-field");
    const__31 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "target-type"), Symbol.intern(null, "field"), Symbol.intern(null, "target-expr"), Symbol.intern(null, "class"), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(68), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/passes/jvm/analyze_host_expr.clj" });
    const__32 = (Var)RT.var("clojure.tools.analyzer.passes.jvm.analyze-host-expr", "-analyze-host-expr");
    const__35 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "target-type"), Symbol.intern(null, "m-or-f"), Symbol.intern(null, "target-expr"), Symbol.intern(null, "class"), Symbol.intern(null, "env")) })), RT.keyword(null, "line"), Integer.valueOf(96), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/analyzer/passes/jvm/analyze_host_expr.clj" });
    const__36 = (Var)RT.var("clojure.tools.analyzer.passes.jvm.analyze-host-expr", "analyze-host-expr");
    const__37 = PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "op"), Symbol.intern(null, "target"), Symbol.intern(null, "form"), Symbol.intern(null, "tag"), Symbol.intern(null, "env"), Symbol.intern(null, "class")), RT.keyword(null, "as"), Symbol.intern(null, "ast") })) }));
    const__38 = (Keyword)RT.keyword(null, "doc");
    const__39 = (Keyword)RT.keyword(null, "pass-info");
    const__40 = (Keyword)RT.keyword(null, "walk");
    const__41 = (Keyword)RT.keyword(null, "post");
    const__42 = (Keyword)RT.keyword(null, "depends");
    const__43 = Integer.valueOf(142);
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("clojure.tools.analyzer.passes.jvm.analyze_host_expr__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
