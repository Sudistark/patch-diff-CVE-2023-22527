package clojure.tools.reader.reader_types;

import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Util;
import clojure.lang.Var;
import java.io.Closeable;
import java.io.IOException;

public final class SourceLoggingPushbackReader implements IndexingReader, IPushbackReader, Reader, Closeable, IType {
  public final Object rdr;
  
  long line;
  
  long column;
  
  Object line_start_QMARK_;
  
  Object prev;
  
  long prev_column;
  
  public final Object file_name;
  
  public final Object source_log_frames;
  
  private static Class __cached_class__0;
  
  private static Class __cached_class__1;
  
  private static Class __cached_class__2;
  
  public static final Var const__0 = (Var)RT.var("clojure.tools.reader.reader-types", "read-char"), const__1 = (Var)RT.var("clojure.tools.reader.reader-types", "normalize-newline"), const__2 = (Var)RT.var("clojure.tools.reader.impl.utils", "newline?"), const__5 = (Var)RT.var("clojure.tools.reader.reader-types", "log-source-char"), const__6 = (Var)RT.var("clojure.tools.reader.reader-types", "peek-char"), const__8 = (Var)RT.var("clojure.tools.reader.reader-types", "drop-last-logged-char"), const__9 = (Var)RT.var("clojure.tools.reader.reader-types", "unread");
  
  public SourceLoggingPushbackReader(Object paramObject1, long paramLong1, long paramLong2, Object paramObject2, Object paramObject3, long paramLong3, Object paramObject4, Object paramObject5) { this.rdr = paramObject1;
    this.line = paramLong1;
    this.column = paramLong2;
    this.line_start_QMARK_ = paramObject2;
    this.prev = paramObject3;
    this.prev_column = paramLong3;
    this.file_name = paramObject4;
    this.source_log_frames = paramObject5; }
  
  public static IPersistentVector getBasis() { return RT.vector(new Object[] { Symbol.intern(null, "rdr"), ((IObj)Symbol.intern(null, "line")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long"), RT.keyword(null, "unsynchronized-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "column")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long"), RT.keyword(null, "unsynchronized-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "line-start?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "unsynchronized-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "prev")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "unsynchronized-mutable"), Boolean.TRUE })), ((IObj)Symbol.intern(null, "prev-column")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long"), RT.keyword(null, "unsynchronized-mutable"), Boolean.TRUE })), Symbol.intern(null, "file-name"), Symbol.intern(null, "source-log-frames") }); }
  
  public void close() throws IOException { ((Closeable)this.rdr)
      .close();
    (this.rdr instanceof Closeable) ? null : null; }
  
  public Object get_file_name() { return this.file_name; }
  
  public Object get_column_number() {
    this = null;
    return Integer.valueOf(RT.intCast(this.column));
  }
  
  public Object get_line_number() {
    this = null;
    return Integer.valueOf(RT.intCast(this.line));
  }
  
  public Object unread(Object ch) { // Byte code:
    //   0: aload_0
    //   1: getfield line_start_QMARK_ : Ljava/lang/Object;
    //   4: dup
    //   5: ifnull -> 36
    //   8: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   11: if_acmpeq -> 37
    //   14: aload_0
    //   15: aload_0
    //   16: getfield line : J
    //   19: invokestatic dec : (J)J
    //   22: putfield line : J
    //   25: aload_0
    //   26: aload_0
    //   27: getfield prev_column : J
    //   30: putfield column : J
    //   33: goto -> 48
    //   36: pop
    //   37: aload_0
    //   38: aload_0
    //   39: getfield column : J
    //   42: invokestatic dec : (J)J
    //   45: putfield column : J
    //   48: aload_0
    //   49: aload_0
    //   50: getfield prev : Ljava/lang/Object;
    //   53: putfield line_start_QMARK_ : Ljava/lang/Object;
    //   56: aload_1
    //   57: dup
    //   58: ifnull -> 89
    //   61: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   64: if_acmpeq -> 90
    //   67: getstatic clojure/tools/reader/reader_types/SourceLoggingPushbackReader.const__8 : Lclojure/lang/Var;
    //   70: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   73: checkcast clojure/lang/IFn
    //   76: aload_0
    //   77: getfield source_log_frames : Ljava/lang/Object;
    //   80: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   85: pop
    //   86: goto -> 92
    //   89: pop
    //   90: aconst_null
    //   91: pop
    //   92: aload_0
    //   93: getfield rdr : Ljava/lang/Object;
    //   96: dup
    //   97: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   100: getstatic clojure/tools/reader/reader_types/SourceLoggingPushbackReader.__cached_class__2 : Ljava/lang/Class;
    //   103: if_acmpeq -> 120
    //   106: dup
    //   107: instanceof clojure/tools/reader/reader_types/IPushbackReader
    //   110: ifne -> 140
    //   113: dup
    //   114: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   117: putstatic clojure/tools/reader/reader_types/SourceLoggingPushbackReader.__cached_class__2 : Ljava/lang/Class;
    //   120: getstatic clojure/tools/reader/reader_types/SourceLoggingPushbackReader.const__9 : Lclojure/lang/Var;
    //   123: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   126: swap
    //   127: aload_1
    //   128: aconst_null
    //   129: astore_1
    //   130: aconst_null
    //   131: astore_0
    //   132: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   137: goto -> 151
    //   140: checkcast clojure/tools/reader/reader_types/IPushbackReader
    //   143: aload_1
    //   144: aconst_null
    //   145: astore_1
    //   146: invokeinterface unread : (Ljava/lang/Object;)Ljava/lang/Object;
    //   151: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #246	-> 0
    //   #269	-> 0
    //   #270	-> 19
    //   #272	-> 42
    //   #274	-> 56
    //   #275	-> 73
    //   #275	-> 80
    //   #276	-> 92
    //   #276	-> 130
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   0	151	0	this	Lclojure/tools/reader/reader_types/SourceLoggingPushbackReader;
    //   0	151	1	ch	Ljava/lang/Object; }
  
  public Object peek_char() { if (Util.classOf(this.rdr) != __cached_class__1)
      if (!(this.rdr instanceof Reader)) {
        __cached_class__1 = Util.classOf(this.rdr);
      } else {
        return ((Reader)this.rdr).peek_char();
      }  
    this = null; }
  
  public Object read_char() { // Byte code:
    //   0: aload_0
    //   1: getfield rdr : Ljava/lang/Object;
    //   4: dup
    //   5: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   8: getstatic clojure/tools/reader/reader_types/SourceLoggingPushbackReader.__cached_class__0 : Ljava/lang/Class;
    //   11: if_acmpeq -> 28
    //   14: dup
    //   15: instanceof clojure/tools/reader/reader_types/Reader
    //   18: ifne -> 43
    //   21: dup
    //   22: invokestatic classOf : (Ljava/lang/Object;)Ljava/lang/Class;
    //   25: putstatic clojure/tools/reader/reader_types/SourceLoggingPushbackReader.__cached_class__0 : Ljava/lang/Class;
    //   28: getstatic clojure/tools/reader/reader_types/SourceLoggingPushbackReader.const__0 : Lclojure/lang/Var;
    //   31: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   34: swap
    //   35: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   40: goto -> 51
    //   43: checkcast clojure/tools/reader/reader_types/Reader
    //   46: invokeinterface read_char : ()Ljava/lang/Object;
    //   51: astore_1
    //   52: aload_1
    //   53: dup
    //   54: ifnull -> 197
    //   57: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   60: if_acmpeq -> 198
    //   63: aload_1
    //   64: aconst_null
    //   65: astore_1
    //   66: astore_2
    //   67: getstatic clojure/tools/reader/reader_types/SourceLoggingPushbackReader.const__1 : Lclojure/lang/Var;
    //   70: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   73: checkcast clojure/lang/IFn
    //   76: aload_0
    //   77: getfield rdr : Ljava/lang/Object;
    //   80: aload_2
    //   81: aconst_null
    //   82: astore_2
    //   83: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   88: astore_3
    //   89: aload_0
    //   90: aload_0
    //   91: getfield line_start_QMARK_ : Ljava/lang/Object;
    //   94: putfield prev : Ljava/lang/Object;
    //   97: aload_0
    //   98: getstatic clojure/tools/reader/reader_types/SourceLoggingPushbackReader.const__2 : Lclojure/lang/Var;
    //   101: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   104: checkcast clojure/lang/IFn
    //   107: aload_3
    //   108: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   113: putfield line_start_QMARK_ : Ljava/lang/Object;
    //   116: aload_0
    //   117: getfield line_start_QMARK_ : Ljava/lang/Object;
    //   120: dup
    //   121: ifnull -> 157
    //   124: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   127: if_acmpeq -> 158
    //   130: aload_0
    //   131: aload_0
    //   132: getfield column : J
    //   135: putfield prev_column : J
    //   138: aload_0
    //   139: lconst_0
    //   140: putfield column : J
    //   143: aload_0
    //   144: aload_0
    //   145: getfield line : J
    //   148: invokestatic inc : (J)J
    //   151: putfield line : J
    //   154: goto -> 160
    //   157: pop
    //   158: aconst_null
    //   159: pop
    //   160: aload_0
    //   161: aload_0
    //   162: getfield column : J
    //   165: invokestatic inc : (J)J
    //   168: putfield column : J
    //   171: getstatic clojure/tools/reader/reader_types/SourceLoggingPushbackReader.const__5 : Lclojure/lang/Var;
    //   174: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   177: checkcast clojure/lang/IFn
    //   180: aload_0
    //   181: getfield source_log_frames : Ljava/lang/Object;
    //   184: aload_3
    //   185: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   190: pop
    //   191: aload_3
    //   192: aconst_null
    //   193: astore_3
    //   194: goto -> 199
    //   197: pop
    //   198: aconst_null
    //   199: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #246	-> 0
    //   #252	-> 0
    //   #252	-> 35
    //   #252	-> 52
    //   #253	-> 73
    //   #253	-> 83
    //   #255	-> 104
    //   #255	-> 108
    //   #256	-> 116
    //   #259	-> 148
    //   #260	-> 165
    //   #261	-> 177
    //   #261	-> 185
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   89	105	3	ch	Ljava/lang/Object;
    //   67	127	2	ch	Ljava/lang/Object;
    //   52	147	1	temp__5735__auto__3436	Ljava/lang/Object;
    //   0	199	0	this	Lclojure/tools/reader/reader_types/SourceLoggingPushbackReader; }
}
