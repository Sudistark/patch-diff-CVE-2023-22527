package clojure.tools.reader.reader_types;

import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.Numbers;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;

public final class StringReader implements Reader, IType {
  public final Object s;
  
  public final long s_len;
  
  long s_pos;
  
  public StringReader(Object paramObject, long paramLong1, long paramLong2) { this.s = paramObject;
    this.s_len = paramLong1;
    this.s_pos = paramLong2; }
  
  public static IPersistentVector getBasis() { return Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })), ((IObj)Symbol.intern(null, "s-len")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "s-pos")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long"), RT.keyword(null, "unsynchronized-mutable"), Boolean.TRUE }))); }
  
  public Object peek_char() { this = null;
    return (this.s_len > this.s_pos) ? RT.nth(this.s, RT.intCast(this.s_pos)) : null; }
  
  public Object read_char() {
    Object r = RT.nth(this.s, RT.intCast(this.s_pos));
    this.s_pos = Numbers.inc(this.s_pos);
    r = null;
    return (this.s_len > this.s_pos) ? r : null;
  }
  
  static  {
  
  }
}
