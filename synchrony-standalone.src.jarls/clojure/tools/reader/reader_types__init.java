package clojure.tools.reader;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class reader_types__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Keyword const__2;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final AFn const__15;
  
  public static final Object const__16;
  
  public static final Var const__17;
  
  public static final Var const__18;
  
  public static final Var const__19;
  
  public static final Var const__20;
  
  public static final ISeq const__21;
  
  public static final Var const__22;
  
  public static final Var const__23;
  
  public static final AFn const__27;
  
  public static final Keyword const__28;
  
  public static final AFn const__29;
  
  public static final Keyword const__30;
  
  public static final Keyword const__31;
  
  public static final Keyword const__32;
  
  public static final Keyword const__33;
  
  public static final AFn const__34;
  
  public static final Keyword const__35;
  
  public static final Var const__36;
  
  public static final Var const__37;
  
  public static final Var const__38;
  
  public static final AFn const__39;
  
  public static final AFn const__40;
  
  public static final Keyword const__41;
  
  public static final AFn const__42;
  
  public static final AFn const__43;
  
  public static final Var const__44;
  
  public static final AFn const__45;
  
  public static final Object const__46;
  
  public static final Var const__47;
  
  public static final ISeq const__48;
  
  public static final AFn const__50;
  
  public static final AFn const__51;
  
  public static final Keyword const__52;
  
  public static final AFn const__53;
  
  public static final AFn const__54;
  
  public static final AFn const__55;
  
  public static final AFn const__56;
  
  public static final Object const__57;
  
  public static final Var const__58;
  
  public static final ISeq const__59;
  
  public static final AFn const__61;
  
  public static final AFn const__62;
  
  public static final Keyword const__63;
  
  public static final Keyword const__64;
  
  public static final Keyword const__65;
  
  public static final AFn const__66;
  
  public static final AFn const__67;
  
  public static final AFn const__68;
  
  public static final AFn const__69;
  
  public static final AFn const__70;
  
  public static final AFn const__71;
  
  public static final AFn const__72;
  
  public static final AFn const__73;
  
  public static final Var const__74;
  
  public static final AFn const__77;
  
  public static final Var const__78;
  
  public static final Object const__79;
  
  public static final Object const__80;
  
  public static final Var const__81;
  
  public static final Object const__82;
  
  public static final Var const__83;
  
  public static final ISeq const__84;
  
  public static final AFn const__86;
  
  public static final AFn const__87;
  
  public static final Keyword const__88;
  
  public static final AFn const__89;
  
  public static final AFn const__90;
  
  public static final AFn const__91;
  
  public static final AFn const__92;
  
  public static final Var const__93;
  
  public static final AFn const__96;
  
  public static final Var const__97;
  
  public static final AFn const__99;
  
  public static final Object const__100;
  
  public static final Object const__101;
  
  public static final Object const__102;
  
  public static final Object const__103;
  
  public static final Var const__104;
  
  public static final ISeq const__105;
  
  public static final AFn const__107;
  
  public static final AFn const__108;
  
  public static final Keyword const__109;
  
  public static final AFn const__110;
  
  public static final AFn const__111;
  
  public static final AFn const__112;
  
  public static final AFn const__113;
  
  public static final Object const__114;
  
  public static final Var const__115;
  
  public static final AFn const__118;
  
  public static final Var const__119;
  
  public static final AFn const__122;
  
  public static final Var const__123;
  
  public static final AFn const__126;
  
  public static final Var const__127;
  
  public static final AFn const__130;
  
  public static final Var const__131;
  
  public static final AFn const__134;
  
  public static final Var const__135;
  
  public static final AFn const__138;
  
  public static final AFn const__141;
  
  public static final AFn const__146;
  
  public static final Var const__147;
  
  public static final AFn const__150;
  
  public static final Var const__151;
  
  public static final AFn const__154;
  
  public static final Var const__155;
  
  public static final AFn const__158;
  
  public static final Var const__159;
  
  public static final AFn const__162;
  
  public static final Var const__163;
  
  public static final AFn const__166;
  
  public static final Var const__167;
  
  public static final AFn const__170;
  
  public static final Var const__171;
  
  public static final AFn const__174;
  
  public static final Var const__175;
  
  public static final AFn const__178;
  
  public static final Var const__179;
  
  public static final AFn const__182;
  
  public static final Var const__183;
  
  public static final AFn const__186;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new reader_types.fn__3250());
    const__6.setMeta((IPersistentMap)const__15);
    const__6.bindRoot(new reader_types.update_BANG_());
    ((Var)const__6)







      
      .setMacro();
    const__74.setMeta((IPersistentMap)const__77);
    const__74.bindRoot(new reader_types.normalize_newline());
    const__93.setMeta((IPersistentMap)const__96);
    const__97.setMeta((IPersistentMap)const__99);
    const__115.setMeta((IPersistentMap)const__118);
    const__115.bindRoot(new reader_types.merge_meta());
    const__119.setMeta((IPersistentMap)const__122);
    const__119.bindRoot(new reader_types.peek_source_log());
    const__123.setMeta((IPersistentMap)const__126);
    const__123.bindRoot(new reader_types.log_source_char());
    const__127.setMeta((IPersistentMap)const__130);
    const__127.bindRoot(new reader_types.drop_last_logged_char());
    const__131.setMeta((IPersistentMap)const__134);
    const__131.bindRoot(new reader_types.log_source_STAR_());
    const__135.setMeta((IPersistentMap)const__138);
    const__135.bindRoot(new reader_types.indexing_reader_QMARK_());
    const__93.setMeta((IPersistentMap)const__141);
    const__93.bindRoot(new reader_types.string_reader());
    const__97.setMeta((IPersistentMap)const__146);
    const__97.bindRoot(new reader_types.push_back_reader());
    const__147.setMeta((IPersistentMap)const__150);
    const__147.bindRoot(new reader_types.string_push_back_reader());
    const__151.setMeta((IPersistentMap)const__154);
    const__151.bindRoot(new reader_types.input_stream_reader());
    const__155.setMeta((IPersistentMap)const__158);
    const__155.bindRoot(new reader_types.input_stream_push_back_reader());
    const__159.setMeta((IPersistentMap)const__162);
    const__159.bindRoot(new reader_types.indexing_push_back_reader());
    const__163.setMeta((IPersistentMap)const__166);
    const__163.bindRoot(new reader_types.source_logging_push_back_reader());
    const__167.setMeta((IPersistentMap)const__170);
    const__167.bindRoot(new reader_types.read_line());
    const__171.setMeta((IPersistentMap)const__174);
    const__171.bindRoot(new reader_types.reader_error());
    const__175.setMeta((IPersistentMap)const__178);
    const__175.bindRoot(new reader_types.source_logging_reader_QMARK_());
    const__179.setMeta((IPersistentMap)const__182);
    const__179.bindRoot(new reader_types.log_source());
    ((Var)const__179)


























































































































































      
      .setMacro();
    const__183.setMeta((IPersistentMap)const__186);
    const__183.bindRoot(new reader_types.line_start_QMARK_());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.tools.reader.reader-types")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Protocols and default Reader types implementation", RT.keyword(null, "author"), "Bronsa" }));
    const__2 = (Keyword)RT.keyword(null, "doc");
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Protocols and default Reader types implementation", RT.keyword(null, "author"), "Bronsa" });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.tools.reader.reader-types", "update!");
    const__15 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "what"), Symbol.intern(null, "f")) })), RT.keyword(null, "line"), Integer.valueOf(18), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__16 = RT.classForName("clojure.tools.reader.reader_types.Reader");
    const__17 = (Var)RT.var("clojure.core", "alter-meta!");
    const__18 = (Var)RT.var("clojure.tools.reader.reader-types", "Reader");
    const__19 = (Var)RT.var("clojure.core", "assoc");
    const__20 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__21 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "read-char")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the next char from the Reader, nil if the end of stream has been reached", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) })), ((IObj)Symbol.intern(null, "peek-char")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the next char from the Reader without removing it from the reader stream", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) })) }));
    const__22 = (Var)RT.var("clojure.core", "alter-var-root");
    const__23 = (Var)RT.var("clojure.core", "merge");
    const__27 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.tools.reader.reader_types.Reader"), RT.keyword(null, "on-interface"), RT.classForName("clojure.tools.reader.reader_types.Reader") });
    const__28 = (Keyword)RT.keyword(null, "sigs");
    const__29 = (AFn)RT.map(new Object[] { RT.keyword(null, "read-char"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "read-char")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the next char from the Reader, nil if the end of stream has been reached", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })), RT.keyword(null, "doc"), "Returns the next char from the Reader, nil if the end of stream has been reached" }), RT.keyword(null, "peek-char"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "peek-char")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the next char from the Reader without removing it from the reader stream", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })), RT.keyword(null, "doc"), "Returns the next char from the Reader without removing it from the reader stream" }) });
    const__30 = (Keyword)RT.keyword(null, "var");
    const__31 = (Keyword)RT.keyword(null, "method-map");
    const__32 = (Keyword)RT.keyword(null, "peek-char");
    const__33 = (Keyword)RT.keyword(null, "read-char");
    const__34 = (AFn)RT.map(new Object[] { RT.keyword(null, "peek-char"), RT.keyword(null, "peek-char"), RT.keyword(null, "read-char"), RT.keyword(null, "read-char") });
    const__35 = (Keyword)RT.keyword(null, "method-builders");
    const__36 = (Var)RT.var("clojure.core", "intern");
    const__37 = (Var)RT.var("clojure.core", "*ns*");
    const__38 = (Var)RT.var("clojure.core", "with-meta");
    const__39 = (AFn)((IObj)Symbol.intern(null, "peek-char")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the next char from the Reader without removing it from the reader stream", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) }));
    const__40 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "peek-char")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the next char from the Reader without removing it from the reader stream", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })), RT.keyword(null, "doc"), "Returns the next char from the Reader without removing it from the reader stream" });
    const__41 = (Keyword)RT.keyword(null, "protocol");
    const__42 = (AFn)((IObj)Symbol.intern(null, "read-char")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the next char from the Reader, nil if the end of stream has been reached", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) }));
    const__43 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "read-char")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the next char from the Reader, nil if the end of stream has been reached", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })), RT.keyword(null, "doc"), "Returns the next char from the Reader, nil if the end of stream has been reached" });
    const__44 = (Var)RT.var("clojure.core", "-reset-methods");
    const__45 = (AFn)Symbol.intern(null, "Reader");
    const__46 = RT.classForName("clojure.tools.reader.reader_types.IPushbackReader");
    const__47 = (Var)RT.var("clojure.tools.reader.reader-types", "IPushbackReader");
    const__48 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "unread")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Pushes back a single character on to the stream", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader"), Symbol.intern(null, "ch")) })) })) }));
    const__50 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.tools.reader.reader_types.IPushbackReader"), RT.keyword(null, "on-interface"), RT.classForName("clojure.tools.reader.reader_types.IPushbackReader") });
    const__51 = (AFn)RT.map(new Object[] { RT.keyword(null, "unread"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "unread")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Pushes back a single character on to the stream", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader"), Symbol.intern(null, "ch")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), "Pushes back a single character on to the stream" }) });
    const__52 = (Keyword)RT.keyword(null, "unread");
    const__53 = (AFn)RT.map(new Object[] { RT.keyword(null, "unread"), RT.keyword(null, "unread") });
    const__54 = (AFn)((IObj)Symbol.intern(null, "unread")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Pushes back a single character on to the stream", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader"), Symbol.intern(null, "ch")) })) }));
    const__55 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "unread")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Pushes back a single character on to the stream", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader"), Symbol.intern(null, "ch")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader"), Symbol.intern(null, "ch")) })), RT.keyword(null, "doc"), "Pushes back a single character on to the stream" });
    const__56 = (AFn)Symbol.intern(null, "IPushbackReader");
    const__57 = RT.classForName("clojure.tools.reader.reader_types.IndexingReader");
    const__58 = (Var)RT.var("clojure.tools.reader.reader-types", "IndexingReader");
    const__59 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "get-line-number")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the line number of the next character to be read from the stream", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) })), ((IObj)Symbol.intern(null, "get-column-number")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the column number of the next character to be read from the stream", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) })), ((IObj)Symbol.intern(null, "get-file-name")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the file name the reader is reading from, or nil", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) })) }));
    const__61 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.tools.reader.reader_types.IndexingReader"), RT.keyword(null, "on-interface"), RT.classForName("clojure.tools.reader.reader_types.IndexingReader") });
    const__62 = (AFn)RT.map(new Object[] { RT.keyword(null, "get-line-number"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-line-number")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the line number of the next character to be read from the stream", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })), RT.keyword(null, "doc"), "Returns the line number of the next character to be read from the stream" }), RT.keyword(null, "get-column-number"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-column-number")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the column number of the next character to be read from the stream", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })), RT.keyword(null, "doc"), "Returns the column number of the next character to be read from the stream" }), RT.keyword(null, "get-file-name"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-file-name")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the file name the reader is reading from, or nil", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })), RT.keyword(null, "doc"), "Returns the file name the reader is reading from, or nil" }) });
    const__63 = (Keyword)RT.keyword(null, "get-column-number");
    const__64 = (Keyword)RT.keyword(null, "get-file-name");
    const__65 = (Keyword)RT.keyword(null, "get-line-number");
    const__66 = (AFn)RT.map(new Object[] { RT.keyword(null, "get-column-number"), RT.keyword(null, "get-column-number"), RT.keyword(null, "get-file-name"), RT.keyword(null, "get-file-name"), RT.keyword(null, "get-line-number"), RT.keyword(null, "get-line-number") });
    const__67 = (AFn)((IObj)Symbol.intern(null, "get-line-number")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the line number of the next character to be read from the stream", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) }));
    const__68 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-line-number")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the line number of the next character to be read from the stream", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })), RT.keyword(null, "doc"), "Returns the line number of the next character to be read from the stream" });
    const__69 = (AFn)((IObj)Symbol.intern(null, "get-file-name")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the file name the reader is reading from, or nil", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) }));
    const__70 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-file-name")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the file name the reader is reading from, or nil", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })), RT.keyword(null, "doc"), "Returns the file name the reader is reading from, or nil" });
    const__71 = (AFn)((IObj)Symbol.intern(null, "get-column-number")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the column number of the next character to be read from the stream", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) }));
    const__72 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-column-number")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns the column number of the next character to be read from the stream", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader")) })), RT.keyword(null, "doc"), "Returns the column number of the next character to be read from the stream" });
    const__73 = (AFn)Symbol.intern(null, "IndexingReader");
    const__74 = (Var)RT.var("clojure.tools.reader.reader-types", "normalize-newline");
    const__77 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr"), Symbol.intern(null, "ch")) })), RT.keyword(null, "line"), Integer.valueOf(106), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__78 = (Var)RT.var("clojure.core", "extend");
    const__79 = RT.classForName("java.io.PushbackReader");
    const__80 = RT.classForName("clojure.lang.LineNumberingPushbackReader");
    const__81 = (Var)RT.var("clojure.core", "constantly");
    const__82 = RT.classForName("clojure.tools.reader.reader_types.ReaderCoercer");
    const__83 = (Var)RT.var("clojure.tools.reader.reader-types", "ReaderCoercer");
    const__84 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "to-rdr")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr")) })) })) }));
    const__86 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.tools.reader.reader_types.ReaderCoercer"), RT.keyword(null, "on-interface"), RT.classForName("clojure.tools.reader.reader_types.ReaderCoercer") });
    const__87 = (AFn)RT.map(new Object[] { RT.keyword(null, "to-rdr"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "to-rdr")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr")) })), RT.keyword(null, "doc"), null }) });
    const__88 = (Keyword)RT.keyword(null, "to-rdr");
    const__89 = (AFn)RT.map(new Object[] { RT.keyword(null, "to-rdr"), RT.keyword(null, "to-rdr") });
    const__90 = (AFn)((IObj)Symbol.intern(null, "to-rdr")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr")) })) }));
    const__91 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "to-rdr")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr")) })), RT.keyword(null, "doc"), null });
    const__92 = (AFn)Symbol.intern(null, "ReaderCoercer");
    const__93 = (Var)RT.var("clojure.tools.reader.reader-types", "string-reader");
    const__96 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(183), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__97 = (Var)RT.var("clojure.tools.reader.reader-types", "push-back-reader");
    const__99 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(183), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
  }
  
  public static void __init1() {
    const__100 = RT.classForName("java.lang.Object");
    const__101 = RT.classForName("java.lang.String");
    const__102 = RT.classForName("java.io.Reader");
    const__103 = RT.classForName("clojure.tools.reader.reader_types.PushbackReaderCoercer");
    const__104 = (Var)RT.var("clojure.tools.reader.reader-types", "PushbackReaderCoercer");
    const__105 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "to-pbr")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr"), Symbol.intern(null, "buf-len")) })) })) }));
    const__107 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.tools.reader.reader_types.PushbackReaderCoercer"), RT.keyword(null, "on-interface"), RT.classForName("clojure.tools.reader.reader_types.PushbackReaderCoercer") });
    const__108 = (AFn)RT.map(new Object[] { RT.keyword(null, "to-pbr"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "to-pbr")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr"), Symbol.intern(null, "buf-len")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr"), Symbol.intern(null, "buf-len")) })), RT.keyword(null, "doc"), null }) });
    const__109 = (Keyword)RT.keyword(null, "to-pbr");
    const__110 = (AFn)RT.map(new Object[] { RT.keyword(null, "to-pbr"), RT.keyword(null, "to-pbr") });
    const__111 = (AFn)((IObj)Symbol.intern(null, "to-pbr")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr"), Symbol.intern(null, "buf-len")) })) }));
    const__112 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "to-pbr")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr"), Symbol.intern(null, "buf-len")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr"), Symbol.intern(null, "buf-len")) })), RT.keyword(null, "doc"), null });
    const__113 = (AFn)Symbol.intern(null, "PushbackReaderCoercer");
    const__114 = RT.classForName("clojure.tools.reader.reader_types.PushbackReader");
    const__115 = (Var)RT.var("clojure.tools.reader.reader-types", "merge-meta");
    const__118 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "obj"), Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), "Returns an object of the same type and value as `obj`, with its\n  metadata merged over `m`.", RT.keyword(null, "line"), Integer.valueOf(219), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__119 = (Var)RT.var("clojure.tools.reader.reader-types", "peek-source-log");
    const__122 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "source-log-frames")) })), RT.keyword(null, "doc"), "Returns a string containing the contents of the top most source\n  logging frame.", RT.keyword(null, "line"), Integer.valueOf(226), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__123 = (Var)RT.var("clojure.tools.reader.reader-types", "log-source-char");
    const__126 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "source-log-frames"), Symbol.intern(null, "char")) })), RT.keyword(null, "doc"), "Logs `char` to all currently active source logging frames.", RT.keyword(null, "line"), Integer.valueOf(233), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__127 = (Var)RT.var("clojure.tools.reader.reader-types", "drop-last-logged-char");
    const__130 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "source-log-frames")) })), RT.keyword(null, "doc"), "Removes the last logged character from all currently active source\n  logging frames. Called when pushing a character back.", RT.keyword(null, "line"), Integer.valueOf(239), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__131 = (Var)RT.var("clojure.tools.reader.reader-types", "log-source*");
    const__134 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader"), Symbol.intern(null, "f")) })), RT.keyword(null, "line"), Integer.valueOf(288), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__135 = (Var)RT.var("clojure.tools.reader.reader-types", "indexing-reader?");
    const__138 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr")) })), RT.keyword(null, "doc"), "Returns true if the reader satisfies IndexingReader", RT.keyword(null, "line"), Integer.valueOf(304), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__141 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))) })), RT.keyword(null, "doc"), "Creates a StringReader from a given string", RT.keyword(null, "line"), Integer.valueOf(314), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__146 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.io.Closeable"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr")), Tuple.create(Symbol.intern(null, "rdr"), Symbol.intern(null, "buf-len")) })), RT.keyword(null, "doc"), "Creates a PushbackReader from a given reader or string", RT.keyword(null, "line"), Integer.valueOf(319), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__147 = (Var)RT.var("clojure.tools.reader.reader-types", "string-push-back-reader");
    const__150 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.io.Closeable"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")), Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })), Symbol.intern(null, "buf-len")) })), RT.keyword(null, "doc"), "Creates a PushbackReader from a given string", RT.keyword(null, "line"), Integer.valueOf(324), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__151 = (Var)RT.var("clojure.tools.reader.reader-types", "input-stream-reader");
    const__154 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.io.Closeable"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "is")) })), RT.keyword(null, "doc"), "Creates an InputStreamReader from an InputStream", RT.keyword(null, "line"), Integer.valueOf(331), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__155 = (Var)RT.var("clojure.tools.reader.reader-types", "input-stream-push-back-reader");
    const__158 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.io.Closeable"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "is")), Tuple.create(((IObj)Symbol.intern(null, "is")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "InputStream") })), Symbol.intern(null, "buf-len")) })), RT.keyword(null, "doc"), "Creates a PushbackReader from a given InputStream", RT.keyword(null, "line"), Integer.valueOf(336), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__159 = (Var)RT.var("clojure.tools.reader.reader-types", "indexing-push-back-reader");
    const__162 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.io.Closeable"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s-or-rdr")), Tuple.create(Symbol.intern(null, "s-or-rdr"), Symbol.intern(null, "buf-len")), Tuple.create(Symbol.intern(null, "s-or-rdr"), Symbol.intern(null, "buf-len"), Symbol.intern(null, "file-name")) })), RT.keyword(null, "doc"), "Creates an IndexingPushbackReader from a given string or PushbackReader", RT.keyword(null, "line"), Integer.valueOf(343), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__163 = (Var)RT.var("clojure.tools.reader.reader-types", "source-logging-push-back-reader");
    const__166 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "tag"), RT.classForName("java.io.Closeable"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s-or-rdr")), Tuple.create(Symbol.intern(null, "s-or-rdr"), Symbol.intern(null, "buf-len")), Tuple.create(Symbol.intern(null, "s-or-rdr"), Symbol.intern(null, "buf-len"), Symbol.intern(null, "file-name")) })), RT.keyword(null, "doc"), "Creates a SourceLoggingPushbackReader from a given string or PushbackReader", RT.keyword(null, "line"), Integer.valueOf(353), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__167 = (Var)RT.var("clojure.tools.reader.reader-types", "read-line");
    const__170 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "rdr")) })), RT.keyword(null, "doc"), "Reads a line from the reader or from *in* if no reader is specified", RT.keyword(null, "line"), Integer.valueOf(372), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__171 = (Var)RT.var("clojure.tools.reader.reader-types", "reader-error");
    const__174 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr"), Symbol.intern(null, "&"), Symbol.intern(null, "msg")) })), RT.keyword(null, "doc"), "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", RT.keyword(null, "line"), Integer.valueOf(385), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__175 = (Var)RT.var("clojure.tools.reader.reader-types", "source-logging-reader?");
    const__178 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr")) })), RT.keyword(null, "line"), Integer.valueOf(398), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__179 = (Var)RT.var("clojure.tools.reader.reader-types", "log-source");
    const__182 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reader"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "If reader is a SourceLoggingPushbackReader, execute body in a source\n  logging context. Otherwise, execute body, returning the result.", RT.keyword(null, "line"), Integer.valueOf(402), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
    const__183 = (Var)RT.var("clojure.tools.reader.reader-types", "line-start?");
    const__186 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rdr")) })), RT.keyword(null, "doc"), "Returns true if rdr is an IndexingReader and the current char starts a new line", RT.keyword(null, "line"), Integer.valueOf(411), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/reader/reader_types.clj" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("clojure.tools.reader.reader_types__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
