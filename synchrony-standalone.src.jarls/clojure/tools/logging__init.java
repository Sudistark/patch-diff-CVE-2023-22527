package clojure.tools;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentHashSet;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class logging__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final AFn const__13;
  
  public static final Var const__14;
  
  public static final Keyword const__15;
  
  public static final Keyword const__16;
  
  public static final Var const__17;
  
  public static final AFn const__19;
  
  public static final AFn const__22;
  
  public static final Var const__23;
  
  public static final AFn const__25;
  
  public static final Var const__26;
  
  public static final AFn const__30;
  
  public static final Var const__31;
  
  public static final AFn const__34;
  
  public static final Var const__35;
  
  public static final AFn const__38;
  
  public static final Var const__39;
  
  public static final AFn const__42;
  
  public static final Var const__43;
  
  public static final AFn const__46;
  
  public static final Var const__47;
  
  public static final AFn const__50;
  
  public static final Var const__51;
  
  public static final AFn const__54;
  
  public static final Var const__55;
  
  public static final AFn const__58;
  
  public static final Var const__59;
  
  public static final AFn const__62;
  
  public static final Var const__63;
  
  public static final AFn const__66;
  
  public static final Var const__67;
  
  public static final AFn const__70;
  
  public static final Var const__71;
  
  public static final AFn const__74;
  
  public static final Var const__75;
  
  public static final AFn const__78;
  
  public static final Var const__79;
  
  public static final AFn const__82;
  
  public static final Var const__83;
  
  public static final AFn const__86;
  
  public static final Var const__87;
  
  public static final AFn const__90;
  
  public static final Var const__91;
  
  public static final AFn const__94;
  
  public static final Var const__95;
  
  public static final AFn const__98;
  
  public static final Var const__99;
  
  public static final AFn const__102;
  
  public static final Var const__103;
  
  public static final AFn const__106;
  
  public static final Var const__107;
  
  public static final AFn const__110;
  
  public static final Var const__111;
  
  public static final AFn const__114;
  
  public static final AFn const__116;
  
  public static final Var const__117;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new logging.fn__8611());
    const__6.setDynamic(true).setMeta((IPersistentMap)const__13);
    const__6.setDynamic(true)
















      
      .bindRoot(((IFn)const__14.getRawRoot()).invoke(null, const__15, const__16));
    const__17.setDynamic(true).setMeta((IPersistentMap)const__19);
    const__17.setDynamic(true).bindRoot(const__22);
    const__23.setDynamic(true).setMeta((IPersistentMap)const__25);
    const__23.setDynamic(true).bindRoot(null);
    const__26.setMeta((IPersistentMap)const__30);
    const__26.bindRoot(new logging.log_STAR_());
    const__31.setDynamic(true).setMeta((IPersistentMap)const__34);
    const__35.setMeta((IPersistentMap)const__38);
    const__35.bindRoot(new logging.log());
    ((Var)const__35)




































      
      .setMacro();
    const__39.setMeta((IPersistentMap)const__42);
    const__39.bindRoot(new logging.logp());
    ((Var)const__39)












      
      .setMacro();
    const__43.setMeta((IPersistentMap)const__46);
    const__43.bindRoot(new logging.logf());
    ((Var)const__43)












      
      .setMacro();
    const__47.setMeta((IPersistentMap)const__50);
    const__47.bindRoot(new logging.enabled_QMARK_());
    ((Var)const__47)












      
      .setMacro();
    const__51.setMeta((IPersistentMap)const__54);
    const__51.bindRoot(new logging.spy());
    ((Var)const__51)







      
      .setMacro();
    const__55.setMeta((IPersistentMap)const__58);
    const__55.bindRoot(new logging.spyf());
    ((Var)const__55)














      
      .setMacro();
    const__59.setMeta((IPersistentMap)const__62);
    const__59.bindRoot(new logging.log_stream());
    const__63.setMeta((IPersistentMap)const__66);
    const__63.bindRoot(new logging.with_logs());
    ((Var)const__63)





























      
      .setMacro();
    const__67.setMeta((IPersistentMap)const__70);
    const__67.bindRoot(new logging.trace());
    ((Var)const__67)



















      
      .setMacro();
    const__71.setMeta((IPersistentMap)const__74);
    const__71.bindRoot(new logging.debug());
    ((Var)const__71)




      
      .setMacro();
    const__75.setMeta((IPersistentMap)const__78);
    const__75.bindRoot(new logging.info());
    ((Var)const__75)




      
      .setMacro();
    const__79.setMeta((IPersistentMap)const__82);
    const__79.bindRoot(new logging.warn());
    ((Var)const__79)




      
      .setMacro();
    const__83.setMeta((IPersistentMap)const__86);
    const__83.bindRoot(new logging.error());
    ((Var)const__83)




      
      .setMacro();
    const__87.setMeta((IPersistentMap)const__90);
    const__87.bindRoot(new logging.fatal());
    ((Var)const__87)




      
      .setMacro();
    const__91.setMeta((IPersistentMap)const__94);
    const__91.bindRoot(new logging.tracef());
    ((Var)const__91)




      
      .setMacro();
    const__95.setMeta((IPersistentMap)const__98);
    const__95.bindRoot(new logging.debugf());
    ((Var)const__95)




      
      .setMacro();
    const__99.setMeta((IPersistentMap)const__102);
    const__99.bindRoot(new logging.infof());
    ((Var)const__99)




      
      .setMacro();
    const__103.setMeta((IPersistentMap)const__106);
    const__103.bindRoot(new logging.warnf());
    ((Var)const__103)




      
      .setMacro();
    const__107.setMeta((IPersistentMap)const__110);
    const__107.bindRoot(new logging.errorf());
    ((Var)const__107)




      
      .setMacro();
    const__111.setMeta((IPersistentMap)const__114);
    const__111.bindRoot(new logging.fatalf());
    ((Var)const__111)




      
      .setMacro();
    const__31.setDynamic(true).setMeta((IPersistentMap)const__116);
    const__31.setDynamic(true)









      
      .bindRoot(((IFn)const__117.getRawRoot()).invoke());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.tools.logging")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "author"), "Alex Taggart", RT.keyword(null, "doc"), "Logging macros which delegate to a specific logging implementation. At\n            runtime a specific implementation is selected by invoking\n            clojure.tools.logging.impl/find-factory.\n\n            The logging implementation can be explicitly provided by using\n            binding or alter-var-root to change the value of *logger-factory* to\n            another implementation of clojure.tools.logging.impl/LoggerFactory\n            (see also the *-factory functions in the impl namespace)." }));
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "author"), "Alex Taggart", RT.keyword(null, "doc"), "Logging macros which delegate to a specific logging implementation. At\n            runtime a specific implementation is selected by invoking\n            clojure.tools.logging.impl/find-factory.\n\n            The logging implementation can be explicitly provided by using\n            binding or alter-var-root to change the value of *logger-factory* to\n            another implementation of clojure.tools.logging.impl/LoggerFactory\n            (see also the *-factory functions in the impl namespace)." });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.tools.logging", "*logging-agent*");
    const__13 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "The default agent used for performing logging when direct logging is\n  disabled. See log* for details.", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(28), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__14 = (Var)RT.var("clojure.core", "agent");
    const__15 = (Keyword)RT.keyword(null, "error-mode");
    const__16 = (Keyword)RT.keyword(null, "continue");
    const__17 = (Var)RT.var("clojure.tools.logging", "*tx-agent-levels*");
    const__19 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "The set of levels that will require using an agent when logging from within a\n  running transaction. Defaults to #{:info :warn}. See log* for details.", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(33), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__22 = (AFn)PersistentHashSet.create(new Object[] { RT.keyword(null, "warn"), RT.keyword(null, "info") });
    const__23 = (Var)RT.var("clojure.tools.logging", "*force*");
    const__25 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Overrides the default rules for choosing between logging directly or via an\n  agent. Defaults to nil. See log* for details.", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(38), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__26 = (Var)RT.var("clojure.tools.logging", "log*");
    const__30 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "logger"), Symbol.intern(null, "level"), Symbol.intern(null, "throwable"), Symbol.intern(null, "message")) })), RT.keyword(null, "doc"), "Attempts to log a message, either directly or via an agent; does not check if\n  the level is enabled.\n\n  For performance reasons, an agent will only be used when invoked within a\n  running transaction, and only for logging levels specified by\n  *tx-agent-levels*. This allows those entries to only be written once the\n  transaction commits, and are discarded if it is retried or aborted.  As\n  corollary, other levels (e.g., :debug, :error) will be written even from\n  failed transactions though at the cost of repeat messages during retries.\n\n  One can override the above by setting *force* to :direct or :agent; all\n  subsequent writes will be direct or via an agent, respectively.", RT.keyword(null, "line"), Integer.valueOf(43), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__31 = (Var)RT.var("clojure.tools.logging", "*logger-factory*");
    const__34 = (AFn)RT.map(new Object[] { RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(67), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__35 = (Var)RT.var("clojure.tools.logging", "log");
    const__38 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "level"), Symbol.intern(null, "message")), Tuple.create(Symbol.intern(null, "level"), Symbol.intern(null, "throwable"), Symbol.intern(null, "message")), Tuple.create(Symbol.intern(null, "logger-ns"), Symbol.intern(null, "level"), Symbol.intern(null, "throwable"), Symbol.intern(null, "message")), Tuple.create(Symbol.intern(null, "logger-factory"), Symbol.intern(null, "logger-ns"), Symbol.intern(null, "level"), Symbol.intern(null, "throwable"), Symbol.intern(null, "message")) })), RT.keyword(null, "doc"), "Evaluates and logs a message only if the specified level is enabled. See log*\n  for more details.", RT.keyword(null, "line"), Integer.valueOf(69), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__39 = (Var)RT.var("clojure.tools.logging", "logp");
    const__42 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "level"), Symbol.intern(null, "message"), Symbol.intern(null, "&"), Symbol.intern(null, "more")), Tuple.create(Symbol.intern(null, "level"), Symbol.intern(null, "throwable"), Symbol.intern(null, "message"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(86), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Logs a message using print style args. Can optionally take a throwable as its\n  second arg. See level-specific macros, e.g., debug.", RT.keyword(null, "line"), Integer.valueOf(83), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__43 = (Var)RT.var("clojure.tools.logging", "logf");
    const__46 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "level"), Symbol.intern(null, "fmt"), Symbol.intern(null, "&"), Symbol.intern(null, "fmt-args")), Tuple.create(Symbol.intern(null, "level"), Symbol.intern(null, "throwable"), Symbol.intern(null, "fmt"), Symbol.intern(null, "&"), Symbol.intern(null, "fmt-args")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(100), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Logs a message using a format string and args. Can optionally take a\n  throwable as its second arg. See level-specific macros, e.g., debugf.", RT.keyword(null, "line"), Integer.valueOf(97), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__47 = (Var)RT.var("clojure.tools.logging", "enabled?");
    const__50 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "level")), Tuple.create(Symbol.intern(null, "level"), Symbol.intern(null, "logger-ns")) })), RT.keyword(null, "doc"), "Returns true if the specific logging level is enabled.  Use of this macro\n  should only be necessary if one needs to execute alternate code paths beyond\n  whether the log should be written to.", RT.keyword(null, "line"), Integer.valueOf(111), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__51 = (Var)RT.var("clojure.tools.logging", "spy");
    const__54 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "expr")), Tuple.create(Symbol.intern(null, "level"), Symbol.intern(null, "expr")) })), RT.keyword(null, "doc"), "Evaluates expr and may write the form and its result to the log. Returns the\n  result of expr. Defaults to :debug log level.", RT.keyword(null, "line"), Integer.valueOf(120), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__55 = (Var)RT.var("clojure.tools.logging", "spyf");
    const__58 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fmt"), Symbol.intern(null, "expr")), Tuple.create(Symbol.intern(null, "level"), Symbol.intern(null, "fmt"), Symbol.intern(null, "expr")) })), RT.keyword(null, "doc"), "Evaluates expr and may write (format fmt result) to the log. Returns the\n  result of expr. Defaults to :debug log level.", RT.keyword(null, "line"), Integer.valueOf(136), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__59 = (Var)RT.var("clojure.tools.logging", "log-stream");
    const__62 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "level"), Symbol.intern(null, "logger-ns")) })), RT.keyword(null, "doc"), "Creates a PrintStream that will output to the log at the specified level.", RT.keyword(null, "line"), Integer.valueOf(146), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__63 = (Var)RT.var("clojure.tools.logging", "with-logs");
    const__66 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "logger-ns"), Symbol.intern(null, "&"), Symbol.intern(null, "body")), Tuple.create(Tuple.create(Symbol.intern(null, "logger-ns"), Symbol.intern(null, "out-level"), Symbol.intern(null, "err-level")), Symbol.intern(null, "&"), Symbol.intern(null, "body")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(198), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Evaluates exprs in a context in which *out* and *err* write to the log. The\n  specified logger-ns value will be used to namespace all log entries.\n\n  By default *out* and *err* write to :info and :error, respectively.", RT.keyword(null, "line"), Integer.valueOf(193), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__67 = (Var)RT.var("clojure.tools.logging", "trace");
    const__70 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "message"), Symbol.intern(null, "&"), Symbol.intern(null, "more")), Tuple.create(Symbol.intern(null, "throwable"), Symbol.intern(null, "message"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(216), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Trace level logging using print-style args.", RT.keyword(null, "line"), Integer.valueOf(214), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__71 = (Var)RT.var("clojure.tools.logging", "debug");
    const__74 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "message"), Symbol.intern(null, "&"), Symbol.intern(null, "more")), Tuple.create(Symbol.intern(null, "throwable"), Symbol.intern(null, "message"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(222), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Debug level logging using print-style args.", RT.keyword(null, "line"), Integer.valueOf(220), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__75 = (Var)RT.var("clojure.tools.logging", "info");
    const__78 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "message"), Symbol.intern(null, "&"), Symbol.intern(null, "more")), Tuple.create(Symbol.intern(null, "throwable"), Symbol.intern(null, "message"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(228), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Info level logging using print-style args.", RT.keyword(null, "line"), Integer.valueOf(226), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__79 = (Var)RT.var("clojure.tools.logging", "warn");
    const__82 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "message"), Symbol.intern(null, "&"), Symbol.intern(null, "more")), Tuple.create(Symbol.intern(null, "throwable"), Symbol.intern(null, "message"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(234), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Warn level logging using print-style args.", RT.keyword(null, "line"), Integer.valueOf(232), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__83 = (Var)RT.var("clojure.tools.logging", "error");
    const__86 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "message"), Symbol.intern(null, "&"), Symbol.intern(null, "more")), Tuple.create(Symbol.intern(null, "throwable"), Symbol.intern(null, "message"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(240), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Error level logging using print-style args.", RT.keyword(null, "line"), Integer.valueOf(238), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__87 = (Var)RT.var("clojure.tools.logging", "fatal");
    const__90 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "message"), Symbol.intern(null, "&"), Symbol.intern(null, "more")), Tuple.create(Symbol.intern(null, "throwable"), Symbol.intern(null, "message"), Symbol.intern(null, "&"), Symbol.intern(null, "more")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(246), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Fatal level logging using print-style args.", RT.keyword(null, "line"), Integer.valueOf(244), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__91 = (Var)RT.var("clojure.tools.logging", "tracef");
    const__94 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fmt"), Symbol.intern(null, "&"), Symbol.intern(null, "fmt-args")), Tuple.create(Symbol.intern(null, "throwable"), Symbol.intern(null, "fmt"), Symbol.intern(null, "&"), Symbol.intern(null, "fmt-args")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(252), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Trace level logging using format.", RT.keyword(null, "line"), Integer.valueOf(250), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__95 = (Var)RT.var("clojure.tools.logging", "debugf");
    const__98 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fmt"), Symbol.intern(null, "&"), Symbol.intern(null, "fmt-args")), Tuple.create(Symbol.intern(null, "throwable"), Symbol.intern(null, "fmt"), Symbol.intern(null, "&"), Symbol.intern(null, "fmt-args")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(258), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Debug level logging using format.", RT.keyword(null, "line"), Integer.valueOf(256), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__99 = (Var)RT.var("clojure.tools.logging", "infof");
  }
  
  public static void __init1() {
    const__102 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fmt"), Symbol.intern(null, "&"), Symbol.intern(null, "fmt-args")), Tuple.create(Symbol.intern(null, "throwable"), Symbol.intern(null, "fmt"), Symbol.intern(null, "&"), Symbol.intern(null, "fmt-args")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(264), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Info level logging using format.", RT.keyword(null, "line"), Integer.valueOf(262), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__103 = (Var)RT.var("clojure.tools.logging", "warnf");
    const__106 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fmt"), Symbol.intern(null, "&"), Symbol.intern(null, "fmt-args")), Tuple.create(Symbol.intern(null, "throwable"), Symbol.intern(null, "fmt"), Symbol.intern(null, "&"), Symbol.intern(null, "fmt-args")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(270), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Warn level logging using format.", RT.keyword(null, "line"), Integer.valueOf(268), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__107 = (Var)RT.var("clojure.tools.logging", "errorf");
    const__110 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fmt"), Symbol.intern(null, "&"), Symbol.intern(null, "fmt-args")), Tuple.create(Symbol.intern(null, "throwable"), Symbol.intern(null, "fmt"), Symbol.intern(null, "&"), Symbol.intern(null, "fmt-args")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(276), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Error level logging using format.", RT.keyword(null, "line"), Integer.valueOf(274), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__111 = (Var)RT.var("clojure.tools.logging", "fatalf");
    const__114 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fmt"), Symbol.intern(null, "&"), Symbol.intern(null, "fmt-args")), Tuple.create(Symbol.intern(null, "throwable"), Symbol.intern(null, "fmt"), Symbol.intern(null, "&"), Symbol.intern(null, "fmt-args")) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(282), RT.keyword(null, "column"), Integer.valueOf(15) })), RT.keyword(null, "doc"), "Fatal level logging using format.", RT.keyword(null, "line"), Integer.valueOf(280), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__116 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "An instance satisfying the impl/LoggerFactory protocol. Used internally to\n   obtain an impl/Logger. Defaults to the value returned from impl/find-factory.", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(286), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/tools/logging.clj" });
    const__117 = (Var)RT.var("clojure.tools.logging.impl", "find-factory");
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("clojure.tools.logging__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
