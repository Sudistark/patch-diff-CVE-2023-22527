package clojure;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentHashSet;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class main__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final AFn const__13;
  
  public static final Var const__14;
  
  public static final AFn const__19;
  
  public static final Var const__20;
  
  public static final AFn const__23;
  
  public static final Var const__24;
  
  public static final AFn const__27;
  
  public static final AFn const__28;
  
  public static final Var const__29;
  
  public static final AFn const__32;
  
  public static final Var const__33;
  
  public static final AFn const__36;
  
  public static final Var const__37;
  
  public static final AFn const__40;
  
  public static final Var const__41;
  
  public static final AFn const__44;
  
  public static final Var const__45;
  
  public static final AFn const__48;
  
  public static final Var const__49;
  
  public static final AFn const__52;
  
  public static final Var const__53;
  
  public static final AFn const__56;
  
  public static final Var const__57;
  
  public static final AFn const__60;
  
  public static final Var const__61;
  
  public static final AFn const__64;
  
  public static final Var const__65;
  
  public static final AFn const__68;
  
  public static final Var const__69;
  
  public static final AFn const__72;
  
  public static final Var const__73;
  
  public static final AFn const__76;
  
  public static final Var const__77;
  
  public static final AFn const__80;
  
  public static final Var const__81;
  
  public static final AFn const__84;
  
  public static final Var const__85;
  
  public static final AFn const__88;
  
  public static final Var const__89;
  
  public static final AFn const__92;
  
  public static final Var const__93;
  
  public static final AFn const__95;
  
  public static final AFn const__96;
  
  public static final Var const__97;
  
  public static final AFn const__100;
  
  public static final Var const__101;
  
  public static final AFn const__104;
  
  public static final Var const__105;
  
  public static final AFn const__108;
  
  public static final Var const__109;
  
  public static final AFn const__112;
  
  public static final Var const__113;
  
  public static final AFn const__116;
  
  public static final Var const__117;
  
  public static final AFn const__120;
  
  public static final Var const__121;
  
  public static final AFn const__124;
  
  public static final Var const__125;
  
  public static final AFn const__128;
  
  public static final Var const__129;
  
  public static final AFn const__132;
  
  public static final Var const__133;
  
  public static final AFn const__136;
  
  public static final Var const__137;
  
  public static final AFn const__140;
  
  public static final Var const__141;
  
  public static final AFn const__144;
  
  public static final Var const__145;
  
  public static final AFn const__148;
  
  public static final Var const__149;
  
  public static final AFn const__152;
  
  public static final Var const__153;
  
  public static final AFn const__156;
  
  public static final Var const__157;
  
  public static final AFn const__160;
  
  public static final AFn const__163;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new main.fn__8976());
    const__6.setMeta((IPersistentMap)const__13);
    const__14.setMeta((IPersistentMap)const__19);
    const__14.bindRoot(new main.demunge());
    const__20.setMeta((IPersistentMap)const__23);
    const__20.bindRoot(new main.root_cause());
    const__24.setMeta((IPersistentMap)const__27);
    const__24.bindRoot(const__28);
    const__29.setMeta((IPersistentMap)const__32);
    const__29.bindRoot(new main.core_class_QMARK_());
    const__33.setMeta((IPersistentMap)const__36);
    const__33.bindRoot(new main.stack_element_str());
    const__37.setMeta((IPersistentMap)const__40);
    const__37.bindRoot(new main.with_bindings());
    ((Var)const__37)
































































      
      .setMacro();
    const__41.setMeta((IPersistentMap)const__44);
    const__41.bindRoot(new main.repl_prompt());
    const__45.setMeta((IPersistentMap)const__48);
    const__45.bindRoot(new main.skip_if_eol());
    const__49.setMeta((IPersistentMap)const__52);
    const__49.bindRoot(new main.skip_whitespace());
    const__53.setMeta((IPersistentMap)const__56);
    const__53.bindRoot(new main.renumbering_read());
    const__57.setMeta((IPersistentMap)const__60);
    const__57.bindRoot(new main.repl_read());
    const__61.setMeta((IPersistentMap)const__64);
    const__61.bindRoot(new main.repl_exception());
    const__65.setMeta((IPersistentMap)const__68);
    const__65.bindRoot(new main.file_name());
    const__69.setMeta((IPersistentMap)const__72);
    const__69.bindRoot(new main.file_path());
    const__73.setMeta((IPersistentMap)const__76);
    const__73.bindRoot(new main.java_loc__GT_source());
    const__77.setMeta((IPersistentMap)const__80);
    const__77.bindRoot(new main.ex_triage());
    const__81.setMeta((IPersistentMap)const__84);
    const__81.bindRoot(new main.ex_str());
    const__85.setMeta((IPersistentMap)const__88);
    const__85.bindRoot(new main.err__GT_msg());
    const__89.setMeta((IPersistentMap)const__92);
    const__89.bindRoot(new main.repl_caught());
    const__93.setMeta((IPersistentMap)const__95);
    const__93.bindRoot(const__96);
    const__97.setMeta((IPersistentMap)const__100);
    const__97.bindRoot(new main.with_read_known());
    ((Var)const__97)


























































































































































































































































































      
      .setMacro();
    const__101.setMeta((IPersistentMap)const__104);
    const__101.bindRoot(new main.repl());
    const__105.setMeta((IPersistentMap)const__108);
    const__105.bindRoot(new main.load_script());
    const__109.setMeta((IPersistentMap)const__112);
    const__109.bindRoot(new main.init_opt());
    const__113.setMeta((IPersistentMap)const__116);
    const__113.bindRoot(new main.eval_opt());
    const__117.setMeta((IPersistentMap)const__120);
    const__117.bindRoot(new main.init_dispatch());
    const__121.setMeta((IPersistentMap)const__124);
    const__121.bindRoot(new main.initialize());
    const__125.setMeta((IPersistentMap)const__128);
    const__125.bindRoot(new main.main_opt());
    const__129.setMeta((IPersistentMap)const__132);
    const__129.bindRoot(new main.repl_opt());
    const__133.setMeta((IPersistentMap)const__136);
    const__133.bindRoot(new main.script_opt());
    const__137.setMeta((IPersistentMap)const__140);
    const__137.bindRoot(new main.null_opt());
    const__141.setMeta((IPersistentMap)const__144);
    const__141.bindRoot(new main.help_opt());
    const__145.setMeta((IPersistentMap)const__148);
    const__145.bindRoot(new main.main_dispatch());
    const__149.setMeta((IPersistentMap)const__152);
    const__149.bindRoot(new main.legacy_repl());
    const__153.setMeta((IPersistentMap)const__156);
    const__153.bindRoot(new main.legacy_script());
    const__157.setMeta((IPersistentMap)const__160);
    const__157.bindRoot(new main.report_error());
    const__6.setMeta((IPersistentMap)const__163);
    const__6.bindRoot(new main.main());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.main")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Top-level main function for Clojure REPL and scripts.", RT.keyword(null, "author"), "Stephen C. Gilardi and Rich Hickey" }));
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Top-level main function for Clojure REPL and scripts.", RT.keyword(null, "author"), "Stephen C. Gilardi and Rich Hickey" });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.main", "main");
    const__13 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(24), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/main.clj" });
    const__14 = (Var)RT.var("clojure.main", "demunge");
    const__19 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fn-name")) })), RT.keyword(null, "doc"), "Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.", RT.keyword(null, "added"), "1.3", RT.keyword(null, "line"), Integer.valueOf(28), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__20 = (Var)RT.var("clojure.main", "root-cause");
    const__23 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "t")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Throwable") }))) })), RT.keyword(null, "doc"), "Returns the initial cause of an exception or error by peeling off all of\n  its wrappers", RT.keyword(null, "added"), "1.3", RT.keyword(null, "line"), Integer.valueOf(35), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__24 = (Var)RT.var("clojure.main", "core-namespaces");
    const__27 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(50), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/main.clj" });
    const__28 = (AFn)PersistentHashSet.create(new Object[] { 
          "clojure.zip", "clojure.reflect", "clojure.pprint", "clojure.java.io", "clojure.main", "clojure.set", "clojure.datafy", "clojure.core", "clojure.core.protocols", "clojure.walk", 
          "clojure.edn", "clojure.instant", "clojure.xml", "clojure.string", "clojure.uuid", "clojure.spec.gen.alpha", "clojure.spec.alpha", "clojure.spec.test.alpha", "clojure.template", "clojure.data", 
          "clojure.core.reducers", "clojure.repl" });
    const__29 = (Var)RT.var("clojure.main", "core-class?");
    const__32 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "class-name")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))) })), RT.keyword(null, "line"), Integer.valueOf(56), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/main.clj" });
    const__33 = (Var)RT.var("clojure.main", "stack-element-str");
    const__36 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "el")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "StackTraceElement") }))) })), RT.keyword(null, "doc"), "Returns a (possibly unmunged) string representation of a StackTraceElement", RT.keyword(null, "added"), "1.3", RT.keyword(null, "line"), Integer.valueOf(62), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__37 = (Var)RT.var("clojure.main", "with-bindings");
    const__40 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Executes body in the context of thread-local bindings for several vars\n  that often need to be set!: *ns* *warn-on-reflection* *math-context*\n  *print-meta* *print-length* *print-level* *compile-path*\n  *command-line-args* *1 *2 *3 *e", RT.keyword(null, "line"), Integer.valueOf(77), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/main.clj" });
    const__41 = (Var)RT.var("clojure.main", "repl-prompt");
    const__44 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Default :prompt hook for repl", RT.keyword(null, "line"), Integer.valueOf(103), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/main.clj" });
    const__45 = (Var)RT.var("clojure.main", "skip-if-eol");
    const__48 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "If the next character on stream s is a newline, skips it, otherwise\n  leaves the stream untouched. Returns :line-start, :stream-end, or :body\n  to indicate the relative location of the next character on s. The stream\n  must either be an instance of LineNumberingPushbackReader or duplicate\n  its behavior of both supporting .unread and collapsing all of CR, LF, and\n  CRLF to a single \\newline.", RT.keyword(null, "line"), Integer.valueOf(108), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/main.clj" });
    const__49 = (Var)RT.var("clojure.main", "skip-whitespace");
    const__52 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "doc"), "Skips whitespace characters on stream s. Returns :line-start, :stream-end,\n  or :body to indicate the relative location of the next character on s.\n  Interprets comma as whitespace and semicolon as comment to end of line.\n  Does not interpret #! as comment to end of line because only one\n  character of lookahead is available. The stream must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF to a single\n  \\newline.", RT.keyword(null, "line"), Integer.valueOf(122), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/main.clj" });
    const__53 = (Var)RT.var("clojure.main", "renumbering-read");
    const__56 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "opts"), ((IObj)Symbol.intern(null, "reader")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "LineNumberingPushbackReader") })), Symbol.intern(null, "line-number")) })), RT.keyword(null, "doc"), "Reads from reader, which must be a LineNumberingPushbackReader, while capturing\n  the read string. If the read is successful, reset the line number and re-read.\n  The line number on re-read is the passed line-number unless :line or\n  :clojure.core/eval-file meta are explicitly set on the read value.", RT.keyword(null, "added"), "1.10", RT.keyword(null, "line"), Integer.valueOf(140), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__57 = (Var)RT.var("clojure.main", "repl-read");
    const__60 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "request-prompt"), Symbol.intern(null, "request-exit")) })), RT.keyword(null, "doc"), "Default :read hook for repl. Reads from *in* which must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF into a single\n  \\newline. repl-read:\n    - skips whitespace, then\n      - returns request-prompt on start of line, or\n      - returns request-exit on end of stream, or\n      - reads an object from the input stream, then\n        - skips the next input character if it's end of line, then\n        - returns the object.", RT.keyword(null, "line"), Integer.valueOf(154), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/main.clj" });
    const__61 = (Var)RT.var("clojure.main", "repl-exception");
    const__64 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "throwable")) })), RT.keyword(null, "doc"), "Returns the root cause of throwables", RT.keyword(null, "line"), Integer.valueOf(172), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/main.clj" });
    const__65 = (Var)RT.var("clojure.main", "file-name");
    const__68 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "full-path")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))) })), RT.keyword(null, "doc"), "Helper to get just the file name part of a path or nil", RT.keyword(null, "line"), Integer.valueOf(177), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__69 = (Var)RT.var("clojure.main", "file-path");
    const__72 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "full-path")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))) })), RT.keyword(null, "doc"), "Helper to get the relative path to the source file or nil", RT.keyword(null, "line"), Integer.valueOf(185), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__73 = (Var)RT.var("clojure.main", "java-loc->source");
    const__76 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "clazz"), Symbol.intern(null, "method")) })), RT.keyword(null, "doc"), "Convert Java class name and method symbol to source symbol, either a\n  Clojure function or Java class and method.", RT.keyword(null, "line"), Integer.valueOf(198), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__77 = (Var)RT.var("clojure.main", "ex-triage");
    const__80 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "datafied-throwable")) })), RT.keyword(null, "doc"), "Returns an analysis of the phase, error, cause, and location of an error that occurred\n  based on Throwable data, as returned by Throwable->map. All attributes other than phase\n  are optional:\n    :clojure.error/phase - keyword phase indicator, one of:\n      :read-source :compile-syntax-check :compilation :macro-syntax-check :macroexpansion\n      :execution :read-eval-result :print-eval-result\n    :clojure.error/source - file name (no path)\n    :clojure.error/path - source path\n    :clojure.error/line - integer line number\n    :clojure.error/column - integer column number\n    :clojure.error/symbol - symbol being expanded/compiled/invoked\n    :clojure.error/class - cause exception class symbol\n    :clojure.error/cause - cause exception message\n    :clojure.error/spec - explain-data for spec error", RT.keyword(null, "added"), "1.10", RT.keyword(null, "line"), Integer.valueOf(208), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__81 = (Var)RT.var("clojure.main", "ex-str");
    const__84 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.map(new Object[] { RT.keyword("clojure.error", "keys"), RT.vector(new Object[] { Symbol.intern(null, "phase"), Symbol.intern(null, "source"), Symbol.intern(null, "path"), Symbol.intern(null, "line"), Symbol.intern(null, "column"), Symbol.intern(null, "symbol"), Symbol.intern(null, "class"), Symbol.intern(null, "cause"), Symbol.intern(null, "spec") }), RT.keyword(null, "as"), Symbol.intern(null, "triage-data") })) })), RT.keyword(null, "doc"), "Returns a string from exception data, as produced by ex-triage.\n  The first line summarizes the exception phase and location.\n  The subsequent lines describe the cause.", RT.keyword(null, "added"), "1.10", RT.keyword(null, "line"), Integer.valueOf(269), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__85 = (Var)RT.var("clojure.main", "err->msg");
    const__88 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "e")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Throwable") }))) })), RT.keyword(null, "doc"), "Helper to return an error message string from an exception.", RT.keyword(null, "line"), Integer.valueOf(343), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/main.clj" });
    const__89 = (Var)RT.var("clojure.main", "repl-caught");
    const__92 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "e")) })), RT.keyword(null, "doc"), "Default :caught hook for repl", RT.keyword(null, "line"), Integer.valueOf(348), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/main.clj" });
    const__93 = (Var)RT.var("clojure.main", "repl-requires");
    const__95 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "A sequence of lib specs that are applied to `require`\nby default when a new command-line REPL is started.", RT.keyword(null, "line"), Integer.valueOf(355), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/main.clj" });
    const__96 = (AFn)Tuple.create(Tuple.create(Symbol.intern(null, "clojure.repl"), RT.keyword(null, "refer"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "source"), Symbol.intern(null, "apropos"), Symbol.intern(null, "dir"), Symbol.intern(null, "pst"), Symbol.intern(null, "doc"), Symbol.intern(null, "find-doc") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(357), RT.keyword(null, "column"), Integer.valueOf(26) }))), Tuple.create(Symbol.intern(null, "clojure.java.javadoc"), RT.keyword(null, "refer"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "javadoc") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(358), RT.keyword(null, "column"), Integer.valueOf(34) }))), Tuple.create(Symbol.intern(null, "clojure.pprint"), RT.keyword(null, "refer"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "pp"), Symbol.intern(null, "pprint") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(359), RT.keyword(null, "column"), Integer.valueOf(28) }))));
    const__97 = (Var)RT.var("clojure.main", "with-read-known");
  }
  
  public static void __init1() {
    const__100 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Evaluates body with *read-eval* set to a \"known\" value,\n   i.e. substituting true for :unknown if necessary.", RT.keyword(null, "line"), Integer.valueOf(361), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/main.clj" });
    const__101 = (Var)RT.var("clojure.main", "repl");
    const__104 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "options")) })), RT.keyword(null, "doc"), "Generic, reusable, read-eval-print loop. By default, reads from *in*,\n  writes to *out*, and prints exception summaries to *err*. If you use the\n  default :read hook, *in* must either be an instance of\n  LineNumberingPushbackReader or duplicate its behavior of both supporting\n  .unread and collapsing CR, LF, and CRLF into a single \\newline. Options\n  are sequential keyword-value pairs. Available options and their defaults:\n\n     - :init, function of no arguments, initialization hook called with\n       bindings for set!-able vars in place.\n       default: #()\n\n     - :need-prompt, function of no arguments, called before each\n       read-eval-print except the first, the user will be prompted if it\n       returns true.\n       default: (if (instance? LineNumberingPushbackReader *in*)\n                  #(.atLineStart *in*)\n                  #(identity true))\n\n     - :prompt, function of no arguments, prompts for more input.\n       default: repl-prompt\n\n     - :flush, function of no arguments, flushes output\n       default: flush\n\n     - :read, function of two arguments, reads from *in*:\n         - returns its first argument to request a fresh prompt\n           - depending on need-prompt, this may cause the repl to prompt\n             before reading again\n         - returns its second argument to request an exit from the repl\n         - else returns the next object read from the input stream\n       default: repl-read\n\n     - :eval, function of one argument, returns the evaluation of its\n       argument\n       default: eval\n\n     - :print, function of one argument, prints its argument to the output\n       default: prn\n\n     - :caught, function of one argument, a throwable, called when\n       read, eval, or print throws an exception or error\n       default: repl-caught", RT.keyword(null, "line"), Integer.valueOf(368), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/main.clj" });
    const__105 = (Var)RT.var("clojure.main", "load-script");
    const__108 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "path")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))) })), RT.keyword(null, "doc"), "Loads Clojure source from a file or resource given its path. Paths\n  beginning with @ or @/ are considered relative to classpath.", RT.keyword(null, "line"), Integer.valueOf(468), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/main.clj" });
    const__109 = (Var)RT.var("clojure.main", "init-opt");
    const__112 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "path")) })), RT.keyword(null, "doc"), "Load a script", RT.keyword(null, "line"), Integer.valueOf(477), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__113 = (Var)RT.var("clojure.main", "eval-opt");
    const__116 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "str")) })), RT.keyword(null, "doc"), "Evals expressions in str, prints each non-nil result using prn", RT.keyword(null, "line"), Integer.valueOf(482), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__117 = (Var)RT.var("clojure.main", "init-dispatch");
    const__120 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "opt")) })), RT.keyword(null, "doc"), "Returns the handler associated with an init opt", RT.keyword(null, "line"), Integer.valueOf(494), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__121 = (Var)RT.var("clojure.main", "initialize");
    const__124 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "args"), Symbol.intern(null, "inits")) })), RT.keyword(null, "doc"), "Common initialize routine for repl, script, and null opts", RT.keyword(null, "line"), Integer.valueOf(502), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__125 = (Var)RT.var("clojure.main", "main-opt");
    const__128 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "main-ns"), Symbol.intern(null, "&"), Symbol.intern(null, "args")), Symbol.intern(null, "inits")) })), RT.keyword(null, "doc"), "Call the -main function from a namespace with string arguments from\n  the command line.", RT.keyword(null, "line"), Integer.valueOf(510), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__129 = (Var)RT.var("clojure.main", "repl-opt");
    const__132 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "&"), Symbol.intern(null, "args")), Symbol.intern(null, "inits")) })), RT.keyword(null, "doc"), "Start a repl with args and inits. Print greeting if no eval options were\n  present", RT.keyword(null, "line"), Integer.valueOf(518), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__133 = (Var)RT.var("clojure.main", "script-opt");
    const__136 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "path"), Symbol.intern(null, "&"), Symbol.intern(null, "args")), Symbol.intern(null, "inits")) })), RT.keyword(null, "doc"), "Run a script from a file, resource, or standard in with args and inits", RT.keyword(null, "line"), Integer.valueOf(530), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__137 = (Var)RT.var("clojure.main", "null-opt");
    const__140 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "args"), Symbol.intern(null, "inits")) })), RT.keyword(null, "doc"), "No repl or script opt present, just bind args and run inits", RT.keyword(null, "line"), Integer.valueOf(539), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__141 = (Var)RT.var("clojure.main", "help-opt");
    const__144 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "_"), Symbol.intern(null, "_")) })), RT.keyword(null, "doc"), "Print help text for main", RT.keyword(null, "line"), Integer.valueOf(545), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__145 = (Var)RT.var("clojure.main", "main-dispatch");
    const__148 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "opt")) })), RT.keyword(null, "doc"), "Returns the handler associated with a main option", RT.keyword(null, "line"), Integer.valueOf(550), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__149 = (Var)RT.var("clojure.main", "legacy-repl");
    const__152 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Called by the clojure.lang.Repl.main stub to run a repl with args\n  specified the old way", RT.keyword(null, "line"), Integer.valueOf(564), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__153 = (Var)RT.var("clojure.main", "legacy-script");
    const__156 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Called by the clojure.lang.Script.main stub to run a script with args\n  specified the old way", RT.keyword(null, "line"), Integer.valueOf(574), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/main.clj" });
    const__157 = (Var)RT.var("clojure.main", "report-error");
    const__160 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "t")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Throwable") })), Symbol.intern(null, "&"), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "target")), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "target"), "file" }), RT.keyword(null, "as"), Symbol.intern(null, "opts") })) })), RT.keyword(null, "doc"), "Create and output an exception report for a Throwable to target.\n\n  Options:\n    :target - \"file\" (default), \"stderr\", \"none\"\n\n  If file is specified but cannot be written, falls back to stderr.", RT.keyword(null, "line"), Integer.valueOf(584), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/main.clj" });
    const__163 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Usage: java -cp clojure.jar clojure.main [init-opt*] [main-opt] [arg*]\n\n  With no options or args, runs an interactive Read-Eval-Print Loop\n\n  init options:\n    -i, --init path     Load a file or resource\n    -e, --eval string   Evaluate expressions in string; print non-nil values\n    --report target     Report uncaught exception to \"file\" (default), \"stderr\",\n                        or \"none\", overrides System property clojure.main.report\n\n  main options:\n    -m, --main ns-name  Call the -main function from a namespace with args\n    -r, --repl          Run a repl\n    path                Run a script from a file or resource\n    -                   Run a script from standard input\n    -h, -?, --help      Print this help message and exit\n\n  operation:\n\n    - Establishes thread-local bindings for commonly set!-able vars\n    - Enters the user namespace\n    - Binds *command-line-args* to a seq of strings containing command line\n      args that appear after any main option\n    - Runs all init options in order\n    - Calls a -main function or runs a repl or script if requested\n\n  The init options may be repeated and mixed freely, but must appear before\n  any main option. The appearance of any eval option before running a repl\n  suppresses the usual repl greeting message: \"Clojure ~(clojure-version)\".\n\n  Paths may be absolute or relative in the filesystem or relative to\n  classpath. Classpath-relative paths have prefix of @ or @/", RT.keyword(null, "line"), Integer.valueOf(616), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/main.clj" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("clojure.main__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
