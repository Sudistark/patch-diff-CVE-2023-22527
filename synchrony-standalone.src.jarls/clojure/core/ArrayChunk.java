package clojure.core;

import clojure.lang.IChunk;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.Indexed;
import clojure.lang.Numbers;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;

public final class ArrayChunk implements IChunk, Indexed, IType {
  public final Object am;
  
  public final Object arr;
  
  public final int off;
  
  public final int end;
  
  public ArrayChunk(Object paramObject1, Object paramObject2, int paramInt1, int paramInt2) { this.am = paramObject1;
    this.arr = paramObject2;
    this.off = paramInt1;
    this.end = paramInt2; }
  
  public static IPersistentVector getBasis() { return Tuple.create(((IObj)Symbol.intern(null, "am")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "clojure.core.ArrayManager") })), Symbol.intern(null, "arr"), ((IObj)Symbol.intern(null, "off")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "int") })), ((IObj)Symbol.intern(null, "end")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "int") }))); }
  
  public Object reduce(IFn f, Object init) { // Byte code:
    //   0: aload_2
    //   1: aconst_null
    //   2: astore_2
    //   3: astore_3
    //   4: aload_0
    //   5: getfield off : I
    //   8: i2l
    //   9: lstore #4
    //   11: lload #4
    //   13: aload_0
    //   14: getfield end : I
    //   17: i2l
    //   18: lcmp
    //   19: ifge -> 94
    //   22: aload_1
    //   23: checkcast clojure/lang/IFn
    //   26: aload_3
    //   27: aconst_null
    //   28: astore_3
    //   29: aload_0
    //   30: getfield am : Ljava/lang/Object;
    //   33: checkcast clojure/core/ArrayManager
    //   36: aload_0
    //   37: getfield arr : Ljava/lang/Object;
    //   40: lload #4
    //   42: invokestatic intCast : (J)I
    //   45: invokeinterface aget : (Ljava/lang/Object;I)Ljava/lang/Object;
    //   50: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   55: astore #6
    //   57: aload #6
    //   59: invokestatic isReduced : (Ljava/lang/Object;)Z
    //   62: ifeq -> 74
    //   65: aload #6
    //   67: aconst_null
    //   68: astore #6
    //   70: goto -> 90
    //   73: athrow
    //   74: aload #6
    //   76: aconst_null
    //   77: astore #6
    //   79: lload #4
    //   81: invokestatic inc : (J)J
    //   84: lstore #4
    //   86: astore_3
    //   87: goto -> 11
    //   90: goto -> 97
    //   93: athrow
    //   94: aload_3
    //   95: aconst_null
    //   96: astore_3
    //   97: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #36	-> 0
    //   #0	-> 8
    //   #51	-> 11
    //   #51	-> 11
    //   #52	-> 23
    //   #52	-> 45
    //   #52	-> 50
    //   #53	-> 57
    //   #53	-> 59
    //   #55	-> 81
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   57	33	6	ret	Ljava/lang/Object;
    //   4	93	3	ret	Ljava/lang/Object;
    //   11	86	4	i	J
    //   0	97	0	this	Lclojure/core/ArrayChunk;
    //   0	97	1	f	Lclojure/lang/IFn;
    //   0	97	2	init	Ljava/lang/Object; }
  
  public IChunk dropFirst() {
    if (this.off == this.end)
      throw (Throwable)new IllegalStateException((String)"dropFirst of empty chunk"); 
    return (IChunk)new ArrayChunk(this.am, this.arr, 
        
        RT.intCast(Numbers.inc(this.off)), this.end);
  }
  
  public int count() {
    return RT.intCast(Numbers.minus(this.end, this.off));
  }
  
  public Object nth(int i) {
    return ((ArrayManager)this.am).aget(this.arr, RT.intCast(Numbers.add(this.off, i)));
  }
  
  static  {
  
  }
}
