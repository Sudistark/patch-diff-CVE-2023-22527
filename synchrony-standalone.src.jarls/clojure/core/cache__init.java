package clojure.core;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class cache__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Keyword const__2;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final Object const__7;
  
  public static final Var const__8;
  
  public static final Var const__9;
  
  public static final Var const__10;
  
  public static final Var const__11;
  
  public static final ISeq const__12;
  
  public static final Var const__13;
  
  public static final Var const__14;
  
  public static final AFn const__18;
  
  public static final Keyword const__19;
  
  public static final AFn const__20;
  
  public static final Keyword const__21;
  
  public static final Keyword const__22;
  
  public static final AFn const__29;
  
  public static final Keyword const__30;
  
  public static final Var const__31;
  
  public static final Var const__32;
  
  public static final Var const__33;
  
  public static final AFn const__34;
  
  public static final AFn const__35;
  
  public static final Keyword const__36;
  
  public static final AFn const__37;
  
  public static final AFn const__38;
  
  public static final AFn const__39;
  
  public static final AFn const__40;
  
  public static final AFn const__41;
  
  public static final AFn const__42;
  
  public static final AFn const__43;
  
  public static final AFn const__44;
  
  public static final AFn const__45;
  
  public static final AFn const__46;
  
  public static final Var const__47;
  
  public static final AFn const__48;
  
  public static final Var const__49;
  
  public static final AFn const__56;
  
  public static final Var const__57;
  
  public static final AFn const__61;
  
  public static final Var const__62;
  
  public static final AFn const__65;
  
  public static final Var const__66;
  
  public static final AFn const__69;
  
  public static final Var const__70;
  
  public static final AFn const__73;
  
  public static final Var const__74;
  
  public static final AFn const__77;
  
  public static final Var const__78;
  
  public static final AFn const__81;
  
  public static final Var const__82;
  
  public static final AFn const__85;
  
  public static final Var const__86;
  
  public static final AFn const__89;
  
  public static final Var const__90;
  
  public static final AFn const__93;
  
  public static final Var const__94;
  
  public static final AFn const__97;
  
  public static final Var const__98;
  
  public static final AFn const__101;
  
  public static final Var const__102;
  
  public static final AFn const__105;
  
  public static final Var const__106;
  
  public static final AFn const__109;
  
  public static final Var const__110;
  
  public static final AFn const__113;
  
  public static final Var const__114;
  
  public static final AFn const__117;
  
  public static final Var const__118;
  
  public static final AFn const__121;
  
  public static final Var const__122;
  
  public static final AFn const__125;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new cache.fn__1371());
    const__49.setMeta((IPersistentMap)const__56);
    const__49.bindRoot(new cache.default_wrapper_fn());
    const__57.setMeta((IPersistentMap)const__61);
    const__57.bindRoot(new cache.through());
    const__62.setMeta((IPersistentMap)const__65);
    const__62.bindRoot(new cache.through_cache());
    const__66.setMeta((IPersistentMap)const__69);
    const__66.bindRoot(new cache.defcache());
    ((Var)const__66)













































      
      .setMacro();
    const__70.setMeta((IPersistentMap)const__73);
    const__70.bindRoot(new cache.describe_layout());
    const__74.setMeta((IPersistentMap)const__77);
    const__74.bindRoot(new cache.prune_queue());
    const__78.setMeta((IPersistentMap)const__81);
    const__78.bindRoot(new cache.build_leastness_queue());
    const__82.setMeta((IPersistentMap)const__85);
    const__82.bindRoot(new cache.key_killer_q());
    const__86.setMeta((IPersistentMap)const__89);
    const__86.bindRoot(new cache.prune_stack());
    const__90.setMeta((IPersistentMap)const__93);
    const__90.bindRoot(new cache.clear_soft_cache_BANG_());
    const__94.setMeta((IPersistentMap)const__97);
    const__94.bindRoot(new cache.make_reference());
    const__98.setMeta((IPersistentMap)const__101);
    const__98.bindRoot(new cache.basic_cache_factory());
    const__102.setMeta((IPersistentMap)const__105);
    const__102.bindRoot(new cache.fifo_cache_factory());
    const__106.setMeta((IPersistentMap)const__109);
    const__106.bindRoot(new cache.lru_cache_factory());
    const__110.setMeta((IPersistentMap)const__113);
    const__110.bindRoot(new cache.ttl_cache_factory());
    const__114.setMeta((IPersistentMap)const__117);
    const__114.bindRoot(new cache.lu_cache_factory());
    const__118.setMeta((IPersistentMap)const__121);
    const__118.bindRoot(new cache.lirs_cache_factory());
    const__122.setMeta((IPersistentMap)const__125);
    const__122.bindRoot(new cache.soft_cache_factory());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.core.cache")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "A caching library for Clojure.", RT.keyword(null, "author"), "Fogus" }));
    const__2 = (Keyword)RT.keyword(null, "doc");
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "A caching library for Clojure.", RT.keyword(null, "author"), "Fogus" });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.core", "*warn-on-reflection*");
    const__7 = RT.classForName("clojure.core.cache.CacheProtocol");
    const__8 = (Var)RT.var("clojure.core", "alter-meta!");
    const__9 = (Var)RT.var("clojure.core.cache", "CacheProtocol");
    const__10 = (Var)RT.var("clojure.core", "assoc");
    const__11 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__12 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "lookup")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Retrieve the value associated with `e` if it exists, else `nil` in\n   the 2-arg case.  Retrieve the value associated with `e` if it exists,\n   else `not-found` in the 3-arg case.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")), Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e"), Symbol.intern(null, "not-found")) })) })), ((IObj)Symbol.intern(null, "has?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Checks if the cache contains a value associated with `e`", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")) })) })), ((IObj)Symbol.intern(null, "hit")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Is meant to be called if the cache is determined to contain a value\n   associated with `e`", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")) })) })), ((IObj)Symbol.intern(null, "miss")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Is meant to be called if the cache is determined to **not** contain a\n   value associated with `e`", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e"), Symbol.intern(null, "ret")) })) })), ((IObj)Symbol.intern(null, "evict")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Removes an entry from the cache", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")) })) })), ((IObj)Symbol.intern(null, "seed")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Is used to signal that the cache should be created with a seed.\n   The contract is that said cache should return an instance of its\n   own type.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "base")) })) })) }));
    const__13 = (Var)RT.var("clojure.core", "alter-var-root");
    const__14 = (Var)RT.var("clojure.core", "merge");
    const__18 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.core.cache.CacheProtocol"), RT.keyword(null, "on-interface"), RT.classForName("clojure.core.cache.CacheProtocol"), RT.keyword(null, "doc"), "This is the protocol describing the basic cache capability." });
    const__19 = (Keyword)RT.keyword(null, "sigs");
    const__20 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "lookup"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "lookup")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Retrieve the value associated with `e` if it exists, else `nil` in\n   the 2-arg case.  Retrieve the value associated with `e` if it exists,\n   else `not-found` in the 3-arg case.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")), Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e"), Symbol.intern(null, "not-found")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")), Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e"), Symbol.intern(null, "not-found")) })), RT.keyword(null, "doc"), "Retrieve the value associated with `e` if it exists, else `nil` in\n   the 2-arg case.  Retrieve the value associated with `e` if it exists,\n   else `not-found` in the 3-arg case." }), RT.keyword(null, "has?"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "has?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Checks if the cache contains a value associated with `e`", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")) })), RT.keyword(null, "doc"), "Checks if the cache contains a value associated with `e`" }), RT.keyword(null, "hit"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "hit")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Is meant to be called if the cache is determined to contain a value\n   associated with `e`", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")) })), RT.keyword(null, "doc"), "Is meant to be called if the cache is determined to contain a value\n   associated with `e`" }), RT.keyword(null, "miss"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "miss")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Is meant to be called if the cache is determined to **not** contain a\n   value associated with `e`", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e"), Symbol.intern(null, "ret")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e"), Symbol.intern(null, "ret")) })), RT.keyword(null, "doc"), "Is meant to be called if the cache is determined to **not** contain a\n   value associated with `e`" }), RT.keyword(null, "evict"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "evict")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Removes an entry from the cache", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")) })), RT.keyword(null, "doc"), "Removes an entry from the cache" }), 
          RT.keyword(null, "seed"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "seed")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Is used to signal that the cache should be created with a seed.\n   The contract is that said cache should return an instance of its\n   own type.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "base")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "base")) })), RT.keyword(null, "doc"), "Is used to signal that the cache should be created with a seed.\n   The contract is that said cache should return an instance of its\n   own type." }) });
    const__21 = (Keyword)RT.keyword(null, "var");
    const__22 = (Keyword)RT.keyword(null, "method-map");
    const__29 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "has?"), RT.keyword(null, "has?"), RT.keyword(null, "evict"), RT.keyword(null, "evict"), RT.keyword(null, "hit"), RT.keyword(null, "hit"), RT.keyword(null, "miss"), RT.keyword(null, "miss"), RT.keyword(null, "lookup"), RT.keyword(null, "lookup"), 
          RT.keyword(null, "seed"), RT.keyword(null, "seed") });
    const__30 = (Keyword)RT.keyword(null, "method-builders");
    const__31 = (Var)RT.var("clojure.core", "intern");
    const__32 = (Var)RT.var("clojure.core", "*ns*");
    const__33 = (Var)RT.var("clojure.core", "with-meta");
    const__34 = (AFn)((IObj)Symbol.intern(null, "lookup")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Retrieve the value associated with `e` if it exists, else `nil` in\n   the 2-arg case.  Retrieve the value associated with `e` if it exists,\n   else `not-found` in the 3-arg case.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")), Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e"), Symbol.intern(null, "not-found")) })) }));
    const__35 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "lookup")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Retrieve the value associated with `e` if it exists, else `nil` in\n   the 2-arg case.  Retrieve the value associated with `e` if it exists,\n   else `not-found` in the 3-arg case.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")), Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e"), Symbol.intern(null, "not-found")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")), Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e"), Symbol.intern(null, "not-found")) })), RT.keyword(null, "doc"), "Retrieve the value associated with `e` if it exists, else `nil` in\n   the 2-arg case.  Retrieve the value associated with `e` if it exists,\n   else `not-found` in the 3-arg case." });
    const__36 = (Keyword)RT.keyword(null, "protocol");
    const__37 = (AFn)((IObj)Symbol.intern(null, "seed")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Is used to signal that the cache should be created with a seed.\n   The contract is that said cache should return an instance of its\n   own type.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "base")) })) }));
    const__38 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "seed")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Is used to signal that the cache should be created with a seed.\n   The contract is that said cache should return an instance of its\n   own type.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "base")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "base")) })), RT.keyword(null, "doc"), "Is used to signal that the cache should be created with a seed.\n   The contract is that said cache should return an instance of its\n   own type." });
    const__39 = (AFn)((IObj)Symbol.intern(null, "miss")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Is meant to be called if the cache is determined to **not** contain a\n   value associated with `e`", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e"), Symbol.intern(null, "ret")) })) }));
    const__40 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "miss")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Is meant to be called if the cache is determined to **not** contain a\n   value associated with `e`", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e"), Symbol.intern(null, "ret")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e"), Symbol.intern(null, "ret")) })), RT.keyword(null, "doc"), "Is meant to be called if the cache is determined to **not** contain a\n   value associated with `e`" });
    const__41 = (AFn)((IObj)Symbol.intern(null, "hit")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Is meant to be called if the cache is determined to contain a value\n   associated with `e`", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")) })) }));
    const__42 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "hit")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Is meant to be called if the cache is determined to contain a value\n   associated with `e`", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")) })), RT.keyword(null, "doc"), "Is meant to be called if the cache is determined to contain a value\n   associated with `e`" });
    const__43 = (AFn)((IObj)Symbol.intern(null, "has?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Checks if the cache contains a value associated with `e`", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")) })) }));
    const__44 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "has?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Checks if the cache contains a value associated with `e`", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")) })), RT.keyword(null, "doc"), "Checks if the cache contains a value associated with `e`" });
    const__45 = (AFn)((IObj)Symbol.intern(null, "evict")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Removes an entry from the cache", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")) })) }));
    const__46 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "evict")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Removes an entry from the cache", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "e")) })), RT.keyword(null, "doc"), "Removes an entry from the cache" });
    const__47 = (Var)RT.var("clojure.core", "-reset-methods");
    const__48 = (AFn)Symbol.intern(null, "CacheProtocol");
    const__49 = (Var)RT.var("clojure.core.cache", "default-wrapper-fn");
    const__56 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(42), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/cache.clj" });
    const__57 = (Var)RT.var("clojure.core.cache", "through");
    const__61 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "item")), Tuple.create(Symbol.intern(null, "value-fn"), Symbol.intern(null, "cache"), Symbol.intern(null, "item")), Tuple.create(Symbol.intern(null, "wrap-fn"), Symbol.intern(null, "value-fn"), Symbol.intern(null, "cache"), Symbol.intern(null, "item")) })), RT.keyword(null, "doc"), "The basic hit/miss logic for the cache system.  Expects a wrap function and\n  value function.  The wrap function takes the value function and the item in question\n  and is expected to run the value function with the item whenever a cache\n  miss occurs.  The intent is to hide any cache-specific cells from leaking\n  into the cache logic itelf.", RT.keyword(null, "line"), Integer.valueOf(44), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/cache.clj" });
    const__62 = (Var)RT.var("clojure.core.cache", "through-cache");
    const__65 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "item")), Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "item"), Symbol.intern(null, "value-fn")), Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "item"), Symbol.intern(null, "wrap-fn"), Symbol.intern(null, "value-fn")) })), RT.keyword(null, "doc"), "The basic hit/miss logic for the cache system.  Like through but always has\n  the cache argument in the first position for easier use with swap! etc.", RT.keyword(null, "line"), Integer.valueOf(57), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/cache.clj" });
    const__66 = (Var)RT.var("clojure.core.cache", "defcache");
    const__69 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "type-name"), Symbol.intern(null, "fields"), Symbol.intern(null, "&"), Symbol.intern(null, "specifics")) })), RT.keyword(null, "line"), Integer.valueOf(67), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/cache.clj" });
    const__70 = (Var)RT.var("clojure.core.cache", "describe-layout");
    const__73 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "mappy"), Symbol.intern(null, "limit")) })), RT.keyword(null, "line"), Integer.valueOf(158), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/cache.clj" });
    const__74 = (Var)RT.var("clojure.core.cache", "prune-queue");
    const__77 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "q"), Symbol.intern(null, "k")) })), RT.keyword(null, "line"), Integer.valueOf(168), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/cache.clj" });
    const__78 = (Var)RT.var("clojure.core.cache", "build-leastness-queue");
    const__81 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "base"), Symbol.intern(null, "limit"), Symbol.intern(null, "start-at")) })), RT.keyword(null, "line"), Integer.valueOf(207), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/cache.clj" });
    const__82 = (Var)RT.var("clojure.core.cache", "key-killer-q");
    const__85 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ttl"), Symbol.intern(null, "q"), Symbol.intern(null, "expiry"), Symbol.intern(null, "now")) })), RT.keyword(null, "line"), Integer.valueOf(260), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/cache.clj" });
    const__86 = (Var)RT.var("clojure.core.cache", "prune-stack");
    const__89 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "lruS"), Symbol.intern(null, "lruQ"), Symbol.intern(null, "cache")) })), RT.keyword(null, "line"), Integer.valueOf(429), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/cache.clj" });
    const__90 = (Var)RT.var("clojure.core.cache", "clear-soft-cache!");
    const__93 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "cache")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.Map") })), ((IObj)Symbol.intern(null, "rcache")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.Map") })), ((IObj)Symbol.intern(null, "rq")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "ReferenceQueue") }))) })), RT.keyword(null, "line"), Integer.valueOf(509), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/cache.clj" });
    const__94 = (Var)RT.var("clojure.core.cache", "make-reference");
    const__97 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "v"), Symbol.intern(null, "rq")) })), RT.keyword(null, "line"), Integer.valueOf(517), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/cache.clj" });
    const__98 = (Var)RT.var("clojure.core.cache", "basic-cache-factory");
  }
  
  public static void __init1() {
    const__101 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "base"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "pre"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "map?"), Symbol.intern(null, "base") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(584), RT.keyword(null, "column"), Integer.valueOf(10) }))) })) })), RT.keyword(null, "doc"), "Returns a pluggable basic cache initialied to `base`", RT.keyword(null, "line"), Integer.valueOf(581), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/cache.clj" });
    const__102 = (Var)RT.var("clojure.core.cache", "fifo-cache-factory");
    const__105 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "base"), Symbol.intern(null, "&"), RT.map(new Object[] { Symbol.intern(null, "threshold"), RT.keyword(null, "threshold"), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "threshold"), Long.valueOf(32L) }) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "pre"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "number?"), Symbol.intern(null, "threshold") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(603), RT.keyword(null, "column"), Integer.valueOf(10) })), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "<"), Long.valueOf(0L), Symbol.intern(null, "threshold") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(603), RT.keyword(null, "column"), Integer.valueOf(30) })), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "map?"), Symbol.intern(null, "base") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(604), RT.keyword(null, "column"), Integer.valueOf(10) }))), RT.keyword(null, "post"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "=="), Symbol.intern(null, "threshold"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "count"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, ".q"), ((IObj)Symbol.intern(null, "%")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "FIFOCache") })) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(605), RT.keyword(null, "column"), Integer.valueOf(32) })) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(605), RT.keyword(null, "column"), Integer.valueOf(25) })) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(605), RT.keyword(null, "column"), Integer.valueOf(11) }))) })) })), RT.keyword(null, "doc"), "Returns a FIFO cache with the cache and FIFO queue initialized to `base` --\n   the queue is filled as the values are pulled out of `base`.  If the associative\n   structure can guarantee ordering, then the said ordering will define the\n   eventual eviction order.  Otherwise, there are no guarantees for the eventual\n   eviction ordering.\n\n   This function takes an optional `:threshold` argument that defines the maximum number\n   of elements in the cache before the FIFO semantics apply (default is 32).\n\n   If the number of elements in `base` is greater than the limit then some items\n   in `base` will be dropped from the resulting cache.  If the associative\n   structure used as `base` can guarantee sorting, then the last `limit` elements\n   will be used as the cache seed values.  Otherwise, there are no guarantees about\n   the elements in the resulting cache.", RT.keyword(null, "line"), Integer.valueOf(587), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/cache.clj" });
    const__106 = (Var)RT.var("clojure.core.cache", "lru-cache-factory");
    const__109 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "base"), Symbol.intern(null, "&"), RT.map(new Object[] { Symbol.intern(null, "threshold"), RT.keyword(null, "threshold"), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "threshold"), Long.valueOf(32L) }) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "pre"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "number?"), Symbol.intern(null, "threshold") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(615), RT.keyword(null, "column"), Integer.valueOf(10) })), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "<"), Long.valueOf(0L), Symbol.intern(null, "threshold") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(615), RT.keyword(null, "column"), Integer.valueOf(30) })), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "map?"), Symbol.intern(null, "base") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(616), RT.keyword(null, "column"), Integer.valueOf(10) }))) })) })), RT.keyword(null, "doc"), "Returns an LRU cache with the cache and usage-table initialied to `base` --\n   each entry is initialized with the same usage value.\n\n   This function takes an optional `:threshold` argument that defines the maximum number\n   of elements in the cache before the LRU semantics apply (default is 32).", RT.keyword(null, "line"), Integer.valueOf(608), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/cache.clj" });
    const__110 = (Var)RT.var("clojure.core.cache", "ttl-cache-factory");
    const__113 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "base"), Symbol.intern(null, "&"), RT.map(new Object[] { Symbol.intern(null, "ttl"), RT.keyword(null, "ttl"), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "ttl"), Long.valueOf(2000L) }) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "pre"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "number?"), Symbol.intern(null, "ttl") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(626), RT.keyword(null, "column"), Integer.valueOf(10) })), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "<="), Long.valueOf(0L), Symbol.intern(null, "ttl") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(626), RT.keyword(null, "column"), Integer.valueOf(24) })), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "map?"), Symbol.intern(null, "base") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(627), RT.keyword(null, "column"), Integer.valueOf(10) }))) })) })), RT.keyword(null, "doc"), "Returns a TTL cache with the cache and expiration-table initialized to `base` --\n   each with the same time-to-live.\n\n   This function also allows an optional `:ttl` argument that defines the default\n   time in milliseconds that entries are allowed to reside in the cache.", RT.keyword(null, "line"), Integer.valueOf(619), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/cache.clj" });
    const__114 = (Var)RT.var("clojure.core.cache", "lu-cache-factory");
    const__117 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "base"), Symbol.intern(null, "&"), RT.map(new Object[] { Symbol.intern(null, "threshold"), RT.keyword(null, "threshold"), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "threshold"), Long.valueOf(32L) }) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "pre"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "number?"), Symbol.intern(null, "threshold") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(636), RT.keyword(null, "column"), Integer.valueOf(10) })), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "<"), Long.valueOf(0L), Symbol.intern(null, "threshold") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(636), RT.keyword(null, "column"), Integer.valueOf(30) })), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "map?"), Symbol.intern(null, "base") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(637), RT.keyword(null, "column"), Integer.valueOf(10) }))) })) })), RT.keyword(null, "doc"), "Returns an LU cache with the cache and usage-table initialied to `base`.\n\n   This function takes an optional `:threshold` argument that defines the maximum number\n   of elements in the cache before the LU semantics apply (default is 32).", RT.keyword(null, "line"), Integer.valueOf(630), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/cache.clj" });
    const__118 = (Var)RT.var("clojure.core.cache", "lirs-cache-factory");
    const__121 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "base"), Symbol.intern(null, "&"), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "s-history-limit"), Symbol.intern(null, "q-history-limit")), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "s-history-limit"), Long.valueOf(32L), Symbol.intern(null, "q-history-limit"), Long.valueOf(32L) }) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "pre"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "number?"), Symbol.intern(null, "s-history-limit") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(646), RT.keyword(null, "column"), Integer.valueOf(10) })), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "<"), Long.valueOf(0L), Symbol.intern(null, "s-history-limit") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(646), RT.keyword(null, "column"), Integer.valueOf(36) })), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "number?"), Symbol.intern(null, "q-history-limit") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(647), RT.keyword(null, "column"), Integer.valueOf(10) })), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "<"), Long.valueOf(0L), Symbol.intern(null, "q-history-limit") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(647), RT.keyword(null, "column"), Integer.valueOf(36) })), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "map?"), Symbol.intern(null, "base") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(648), RT.keyword(null, "column"), Integer.valueOf(10) }))) })) })), RT.keyword(null, "doc"), "Returns an LIRS cache with the S & R LRU lists set to the indicated\n   limits.", RT.keyword(null, "line"), Integer.valueOf(640), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/cache.clj" });
    const__122 = (Var)RT.var("clojure.core.cache", "soft-cache-factory");
    const__125 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "base"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "pre"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "map?"), Symbol.intern(null, "base") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(659), RT.keyword(null, "column"), Integer.valueOf(10) }))) })) })), RT.keyword(null, "doc"), "Returns a SoftReference cache.  Cached values will be referred to with\n  SoftReferences, allowing the values to be garbage collected when there is\n  memory pressure on the JVM.\n\n  SoftCache is a mutable cache, since it is always based on a\n  ConcurrentHashMap.", RT.keyword(null, "line"), Integer.valueOf(651), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/cache.clj" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("clojure.core.cache__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
