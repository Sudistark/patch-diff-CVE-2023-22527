package clojure.core;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class protocols__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__2;
  
  public static final Var const__3;
  
  public static final Object const__4;
  
  public static final Var const__5;
  
  public static final Var const__6;
  
  public static final Var const__7;
  
  public static final Keyword const__8;
  
  public static final Var const__9;
  
  public static final ISeq const__10;
  
  public static final Var const__11;
  
  public static final Var const__12;
  
  public static final AFn const__16;
  
  public static final Keyword const__17;
  
  public static final AFn const__18;
  
  public static final Keyword const__19;
  
  public static final Keyword const__20;
  
  public static final Keyword const__21;
  
  public static final AFn const__22;
  
  public static final Keyword const__23;
  
  public static final Var const__24;
  
  public static final Var const__25;
  
  public static final Var const__26;
  
  public static final AFn const__27;
  
  public static final AFn const__28;
  
  public static final Keyword const__29;
  
  public static final Var const__30;
  
  public static final AFn const__31;
  
  public static final Object const__32;
  
  public static final Var const__33;
  
  public static final ISeq const__34;
  
  public static final AFn const__36;
  
  public static final AFn const__37;
  
  public static final Keyword const__38;
  
  public static final AFn const__39;
  
  public static final AFn const__40;
  
  public static final AFn const__41;
  
  public static final AFn const__42;
  
  public static final Var const__43;
  
  public static final AFn const__52;
  
  public static final Var const__53;
  
  public static final AFn const__56;
  
  public static final Var const__57;
  
  public static final AFn const__60;
  
  public static final Var const__61;
  
  public static final AFn const__64;
  
  public static final Var const__65;
  
  public static final Object const__66;
  
  public static final Object const__67;
  
  public static final Object const__68;
  
  public static final Object const__69;
  
  public static final Object const__70;
  
  public static final Object const__71;
  
  public static final Object const__72;
  
  public static final Object const__73;
  
  public static final Object const__74;
  
  public static final Object const__75;
  
  public static final Object const__76;
  
  public static final Var const__77;
  
  public static final ISeq const__78;
  
  public static final AFn const__80;
  
  public static final AFn const__81;
  
  public static final AFn const__83;
  
  public static final AFn const__84;
  
  public static final AFn const__85;
  
  public static final AFn const__86;
  
  public static final Object const__87;
  
  public static final Var const__88;
  
  public static final ISeq const__89;
  
  public static final AFn const__92;
  
  public static final AFn const__93;
  
  public static final Keyword const__94;
  
  public static final AFn const__95;
  
  public static final AFn const__96;
  
  public static final AFn const__97;
  
  public static final AFn const__98;
  
  public static final Object const__99;
  
  public static final Var const__100;
  
  public static final ISeq const__101;
  
  public static final AFn const__103;
  
  public static final AFn const__104;
  
  public static final Keyword const__105;
  
  public static final AFn const__106;
  
  public static final AFn const__107;
  
  public static final AFn const__108;
  
  public static final AFn const__109;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new protocols.fn__8081());
    const__43.setMeta((IPersistentMap)const__52);
    const__43.bindRoot(new protocols.seq_reduce());
    const__53.setMeta((IPersistentMap)const__56);
    const__53.bindRoot(new protocols.iter_reduce());
    const__57.setMeta((IPersistentMap)const__60);
    const__57.bindRoot(new protocols.naive_seq_reduce());
    const__61.setMeta((IPersistentMap)const__64);
    const__61.bindRoot(new protocols.interface_or_naive_reduce());
    new Object[2][0] = const__105;
    new Object[2][1] = new protocols.fn__8230();
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "clojure.core.protocols");
    const__2 = (AFn)Symbol.intern(null, "clojure.core");
    const__3 = (Var)RT.var("clojure.core", "*warn-on-reflection*");
    const__4 = RT.classForName("clojure.core.protocols.CollReduce");
    const__5 = (Var)RT.var("clojure.core", "alter-meta!");
    const__6 = (Var)RT.var("clojure.core.protocols", "CollReduce");
    const__7 = (Var)RT.var("clojure.core", "assoc");
    const__8 = (Keyword)RT.keyword(null, "doc");
    const__9 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__10 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "coll-reduce")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "f"), Symbol.intern(null, "val")) })) })) }));
    const__11 = (Var)RT.var("clojure.core", "alter-var-root");
    const__12 = (Var)RT.var("clojure.core", "merge");
    const__16 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.core.protocols.CollReduce"), RT.keyword(null, "on-interface"), RT.classForName("clojure.core.protocols.CollReduce"), RT.keyword(null, "doc"), "Protocol for collection types that can implement reduce faster than\n  first/next recursion. Called by clojure.core/reduce. Baseline\n  implementation defined in terms of Iterable." });
    const__17 = (Keyword)RT.keyword(null, "sigs");
    const__18 = (AFn)RT.map(new Object[] { RT.keyword(null, "coll-reduce"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "coll-reduce")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "f"), Symbol.intern(null, "val")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "f"), Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), null }) });
    const__19 = (Keyword)RT.keyword(null, "var");
    const__20 = (Keyword)RT.keyword(null, "method-map");
    const__21 = (Keyword)RT.keyword(null, "coll-reduce");
    const__22 = (AFn)RT.map(new Object[] { RT.keyword(null, "coll-reduce"), RT.keyword(null, "coll-reduce") });
    const__23 = (Keyword)RT.keyword(null, "method-builders");
    const__24 = (Var)RT.var("clojure.core", "intern");
    const__25 = (Var)RT.var("clojure.core", "*ns*");
    const__26 = (Var)RT.var("clojure.core", "with-meta");
    const__27 = (AFn)((IObj)Symbol.intern(null, "coll-reduce")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "f"), Symbol.intern(null, "val")) })) }));
    const__28 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "coll-reduce")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "f"), Symbol.intern(null, "val")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "f"), Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), null });
    const__29 = (Keyword)RT.keyword(null, "protocol");
    const__30 = (Var)RT.var("clojure.core", "-reset-methods");
    const__31 = (AFn)Symbol.intern(null, "CollReduce");
    const__32 = RT.classForName("clojure.core.protocols.InternalReduce");
    const__33 = (Var)RT.var("clojure.core.protocols", "InternalReduce");
    const__34 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "internal-reduce")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "seq"), Symbol.intern(null, "f"), Symbol.intern(null, "start")) })) })) }));
    const__36 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.core.protocols.InternalReduce"), RT.keyword(null, "on-interface"), RT.classForName("clojure.core.protocols.InternalReduce"), RT.keyword(null, "doc"), "Protocol for concrete seq types that can reduce themselves\n   faster than first/next recursion. Called by clojure.core/reduce." });
    const__37 = (AFn)RT.map(new Object[] { RT.keyword(null, "internal-reduce"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "internal-reduce")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "seq"), Symbol.intern(null, "f"), Symbol.intern(null, "start")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "seq"), Symbol.intern(null, "f"), Symbol.intern(null, "start")) })), RT.keyword(null, "doc"), null }) });
    const__38 = (Keyword)RT.keyword(null, "internal-reduce");
    const__39 = (AFn)RT.map(new Object[] { RT.keyword(null, "internal-reduce"), RT.keyword(null, "internal-reduce") });
    const__40 = (AFn)((IObj)Symbol.intern(null, "internal-reduce")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "seq"), Symbol.intern(null, "f"), Symbol.intern(null, "start")) })) }));
    const__41 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "internal-reduce")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "seq"), Symbol.intern(null, "f"), Symbol.intern(null, "start")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "seq"), Symbol.intern(null, "f"), Symbol.intern(null, "start")) })), RT.keyword(null, "doc"), null });
    const__42 = (AFn)Symbol.intern(null, "InternalReduce");
    const__43 = (Var)RT.var("clojure.core.protocols", "seq-reduce");
    const__52 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "f"), Symbol.intern(null, "val")) })), RT.keyword(null, "line"), Integer.valueOf(24), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/protocols.clj" });
    const__53 = (Var)RT.var("clojure.core.protocols", "iter-reduce");
    const__56 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "coll")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.lang.Iterable") })), Symbol.intern(null, "f")), Tuple.create(((IObj)Symbol.intern(null, "coll")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.lang.Iterable") })), Symbol.intern(null, "f"), Symbol.intern(null, "val")) })), RT.keyword(null, "line"), Integer.valueOf(33), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/protocols.clj" });
    const__57 = (Var)RT.var("clojure.core.protocols", "naive-seq-reduce");
    const__60 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s"), Symbol.intern(null, "f"), Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "Reduces a seq, ignoring any opportunities to switch to a more\n  specialized implementation.", RT.keyword(null, "line"), Integer.valueOf(55), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/protocols.clj" });
    const__61 = (Var)RT.var("clojure.core.protocols", "interface-or-naive-reduce");
    const__64 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "f"), Symbol.intern(null, "val")) })), RT.keyword(null, "doc"), "Reduces via IReduceInit if possible, else naively.", RT.keyword(null, "line"), Integer.valueOf(68), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/protocols.clj" });
    const__65 = (Var)RT.var("clojure.core", "extend");
    const__66 = RT.classForName("java.lang.Object");
    const__67 = RT.classForName("clojure.lang.APersistentMap$KeySeq");
    const__68 = RT.classForName("java.lang.Iterable");
    const__69 = RT.classForName("clojure.lang.IReduceInit");
    const__70 = RT.classForName("clojure.lang.ASeq");
    const__71 = RT.classForName("clojure.lang.LazySeq");
    const__72 = RT.classForName("clojure.lang.APersistentMap$ValSeq");
    const__73 = RT.classForName("clojure.lang.PersistentVector");
    const__74 = RT.classForName("clojure.lang.IChunkedSeq");
    const__75 = RT.classForName("clojure.lang.StringSeq");
    const__76 = RT.classForName("clojure.core.protocols.IKVReduce");
    const__77 = (Var)RT.var("clojure.core.protocols", "IKVReduce");
    const__78 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "kv-reduce")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "amap"), Symbol.intern(null, "f"), Symbol.intern(null, "init")) })) })) }));
    const__80 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.core.protocols.IKVReduce"), RT.keyword(null, "on-interface"), RT.classForName("clojure.core.protocols.IKVReduce"), RT.keyword(null, "doc"), "Protocol for concrete associative types that can reduce themselves\n   via a function of key and val faster than first/next recursion over map\n   entries. Called by clojure.core/reduce-kv, and has same\n   semantics (just different arg order)." });
    const__81 = (AFn)RT.map(new Object[] { RT.keyword(null, "kv-reduce"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "kv-reduce")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "amap"), Symbol.intern(null, "f"), Symbol.intern(null, "init")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "amap"), Symbol.intern(null, "f"), Symbol.intern(null, "init")) })), RT.keyword(null, "doc"), null }) });
    const__83 = (AFn)RT.map(new Object[] { RT.keyword(null, "kv-reduce"), RT.keyword(null, "kv-reduce") });
    const__84 = (AFn)((IObj)Symbol.intern(null, "kv-reduce")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "amap"), Symbol.intern(null, "f"), Symbol.intern(null, "init")) })) }));
    const__85 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "kv-reduce")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "amap"), Symbol.intern(null, "f"), Symbol.intern(null, "init")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "amap"), Symbol.intern(null, "f"), Symbol.intern(null, "init")) })), RT.keyword(null, "doc"), null });
    const__86 = (AFn)Symbol.intern(null, "IKVReduce");
    const__87 = RT.classForName("clojure.core.protocols.Datafiable");
    const__88 = (Var)RT.var("clojure.core.protocols", "Datafiable");
    const__89 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "datafy")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "return a representation of o as data (default identity)", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "o")) })) })) }));
    const__92 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.core.protocols.Datafiable"), RT.keyword(null, "on-interface"), RT.classForName("clojure.core.protocols.Datafiable"), RT.keyword(null, "extend-via-metadata"), Boolean.TRUE });
    const__93 = (AFn)RT.map(new Object[] { RT.keyword(null, "datafy"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "datafy")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "return a representation of o as data (default identity)", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "o")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "o")) })), RT.keyword(null, "doc"), "return a representation of o as data (default identity)" }) });
    const__94 = (Keyword)RT.keyword(null, "datafy");
    const__95 = (AFn)RT.map(new Object[] { RT.keyword(null, "datafy"), RT.keyword(null, "datafy") });
    const__96 = (AFn)((IObj)Symbol.intern(null, "datafy")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "return a representation of o as data (default identity)", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "o")) })) }));
    const__97 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "datafy")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "return a representation of o as data (default identity)", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "o")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "o")) })), RT.keyword(null, "doc"), "return a representation of o as data (default identity)" });
    const__98 = (AFn)Symbol.intern(null, "Datafiable");
    const__99 = RT.classForName("clojure.core.protocols.Navigable");
  }
  
  public static void __init1() {
    const__100 = (Var)RT.var("clojure.core.protocols", "Navigable");
    const__101 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "nav")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "return (possibly transformed) v in the context of coll and k (a key/index or nil),\ndefaults to returning v.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "k"), Symbol.intern(null, "v")) })) })) }));
    const__103 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.core.protocols.Navigable"), RT.keyword(null, "on-interface"), RT.classForName("clojure.core.protocols.Navigable"), RT.keyword(null, "extend-via-metadata"), Boolean.TRUE });
    const__104 = (AFn)RT.map(new Object[] { RT.keyword(null, "nav"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "nav")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "return (possibly transformed) v in the context of coll and k (a key/index or nil),\ndefaults to returning v.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "k"), Symbol.intern(null, "v")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "k"), Symbol.intern(null, "v")) })), RT.keyword(null, "doc"), "return (possibly transformed) v in the context of coll and k (a key/index or nil),\ndefaults to returning v." }) });
    const__105 = (Keyword)RT.keyword(null, "nav");
    const__106 = (AFn)RT.map(new Object[] { RT.keyword(null, "nav"), RT.keyword(null, "nav") });
    const__107 = (AFn)((IObj)Symbol.intern(null, "nav")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "return (possibly transformed) v in the context of coll and k (a key/index or nil),\ndefaults to returning v.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "k"), Symbol.intern(null, "v")) })) }));
    const__108 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "nav")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "return (possibly transformed) v in the context of coll and k (a key/index or nil),\ndefaults to returning v.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "k"), Symbol.intern(null, "v")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "k"), Symbol.intern(null, "v")) })), RT.keyword(null, "doc"), "return (possibly transformed) v in the context of coll and k (a key/index or nil),\ndefaults to returning v." });
    const__109 = (AFn)Symbol.intern(null, "Navigable");
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("clojure.core.protocols__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
