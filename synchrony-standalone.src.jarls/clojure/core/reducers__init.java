package clojure.core;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.Delay;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class reducers__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Keyword const__2;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final AFn const__7;
  
  public static final AFn const__8;
  
  public static final Var const__9;
  
  public static final Var const__10;
  
  public static final AFn const__16;
  
  public static final Var const__17;
  
  public static final AFn const__21;
  
  public static final Var const__22;
  
  public static final AFn const__26;
  
  public static final Var const__27;
  
  public static final AFn const__30;
  
  public static final Var const__31;
  
  public static final AFn const__34;
  
  public static final Var const__35;
  
  public static final AFn const__38;
  
  public static final Object const__39;
  
  public static final Var const__40;
  
  public static final Var const__41;
  
  public static final Var const__42;
  
  public static final Var const__43;
  
  public static final ISeq const__44;
  
  public static final Var const__45;
  
  public static final Var const__46;
  
  public static final AFn const__50;
  
  public static final Keyword const__51;
  
  public static final AFn const__52;
  
  public static final Keyword const__53;
  
  public static final Keyword const__54;
  
  public static final Keyword const__55;
  
  public static final AFn const__56;
  
  public static final Keyword const__57;
  
  public static final Var const__58;
  
  public static final Var const__59;
  
  public static final Var const__60;
  
  public static final AFn const__61;
  
  public static final AFn const__62;
  
  public static final Keyword const__63;
  
  public static final Var const__64;
  
  public static final AFn const__65;
  
  public static final Var const__66;
  
  public static final AFn const__70;
  
  public static final Var const__71;
  
  public static final AFn const__74;
  
  public static final Var const__75;
  
  public static final AFn const__78;
  
  public static final Var const__79;
  
  public static final AFn const__82;
  
  public static final Var const__83;
  
  public static final AFn const__86;
  
  public static final Var const__87;
  
  public static final AFn const__90;
  
  public static final Var const__91;
  
  public static final AFn const__94;
  
  public static final Var const__95;
  
  public static final AFn const__98;
  
  public static final Var const__99;
  
  public static final AFn const__102;
  
  public static final Var const__103;
  
  public static final AFn const__106;
  
  public static final Var const__107;
  
  public static final AFn const__110;
  
  public static final Var const__111;
  
  public static final AFn const__114;
  
  public static final Var const__115;
  
  public static final AFn const__118;
  
  public static final Var const__119;
  
  public static final AFn const__122;
  
  public static final Var const__123;
  
  public static final AFn const__126;
  
  public static final Var const__127;
  
  public static final AFn const__130;
  
  public static final Var const__131;
  
  public static final AFn const__134;
  
  public static final Var const__135;
  
  public static final AFn const__138;
  
  public static final Var const__139;
  
  public static final AFn const__142;
  
  public static final Var const__143;
  
  public static final AFn const__146;
  
  public static final Var const__147;
  
  public static final Object const__148;
  
  public static final Object const__149;
  
  public static final Object const__150;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new reducers.fn__42944());
    const__10.setMeta((IPersistentMap)const__16);
    const__10.bindRoot(new Delay((IFn)new reducers.fn__42946()));
    const__17.setMeta((IPersistentMap)const__21);
    const__17.bindRoot(new reducers.fjtask());
    const__22.setMeta((IPersistentMap)const__26);
    const__22.bindRoot(new reducers.fjinvoke());
    const__27.setMeta((IPersistentMap)const__30);
    const__27.bindRoot(new reducers.fjfork());
    const__31.setMeta((IPersistentMap)const__34);
    const__31.bindRoot(new reducers.fjjoin());
    const__35.setMeta((IPersistentMap)const__38);
    const__35.bindRoot(new reducers.reduce());
    const__66.setMeta((IPersistentMap)const__70);
    const__66.bindRoot(new reducers.fold());
    const__71.setMeta((IPersistentMap)const__74);
    const__71.bindRoot(new reducers.reducer());
    const__75.setMeta((IPersistentMap)const__78);
    const__75.bindRoot(new reducers.folder());
    const__79.setMeta((IPersistentMap)const__82);
    const__79.bindRoot(new reducers.do_curried());
    const__83.setMeta((IPersistentMap)const__86);
    const__83.bindRoot(new reducers.defcurried());
    ((Var)const__83)
























































      
      .setMacro();
    const__87.setMeta((IPersistentMap)const__90);
    const__87.bindRoot(new reducers.do_rfn());
    const__91.setMeta((IPersistentMap)const__94);
    const__91.bindRoot(new reducers.rfn());
    ((Var)const__91)















      
      .setMacro();
    const__95.setMeta((IPersistentMap)const__98);
    const__95.bindRoot(new reducers.map());
    const__99.setMeta((IPersistentMap)const__102);
    const__99.bindRoot(new reducers.mapcat());
    const__103.setMeta((IPersistentMap)const__106);
    const__103.bindRoot(new reducers.filter());
    const__107.setMeta((IPersistentMap)const__110);
    const__107.bindRoot(new reducers.remove());
    const__111.setMeta((IPersistentMap)const__114);
    const__111.bindRoot(new reducers.flatten());
    const__115.setMeta((IPersistentMap)const__118);
    const__115.bindRoot(new reducers.take_while());
    const__119.setMeta((IPersistentMap)const__122);
    const__119.bindRoot(new reducers.take());
    const__123.setMeta((IPersistentMap)const__126);
    const__123.bindRoot(new reducers.drop());
    const__127.setMeta((IPersistentMap)const__130);
    const__127.bindRoot(new reducers.cat());
    const__131.setMeta((IPersistentMap)const__134);
    const__131.bindRoot(new reducers.append_BANG_());
    const__135.setMeta((IPersistentMap)const__138);
    const__135.bindRoot(new reducers.foldcat());
    const__139.setMeta((IPersistentMap)const__142);
    const__139.bindRoot(new reducers.monoid());
    const__143.setMeta((IPersistentMap)const__146);
    const__143.bindRoot(new reducers.foldvec());
    new Object[2][0] = const__55;
    new Object[2][1] = new reducers.fn__43079();
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.core.reducers")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "A library for reduction and parallel folding. Alpha and subject\n      to change.", RT.keyword(null, "author"), "Rich Hickey" }));
    const__2 = (Keyword)RT.keyword(null, "doc");
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "A library for reduction and parallel folding. Alpha and subject\n      to change.", RT.keyword(null, "author"), "Rich Hickey" });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.core", "alias");
    const__7 = (AFn)Symbol.intern(null, "core");
    const__8 = (AFn)Symbol.intern(null, "clojure.core");
    const__9 = (Var)RT.var("clojure.core", "*warn-on-reflection*");
    const__10 = (Var)RT.var("clojure.core.reducers", "pool");
    const__16 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(22), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__17 = (Var)RT.var("clojure.core.reducers", "fjtask");
    const__21 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "f")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Callable") }))) })), RT.keyword(null, "line"), Integer.valueOf(24), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__22 = (Var)RT.var("clojure.core.reducers", "fjinvoke");
    const__26 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")) })), RT.keyword(null, "line"), Integer.valueOf(27), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__27 = (Var)RT.var("clojure.core.reducers", "fjfork");
    const__30 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "task")) })), RT.keyword(null, "line"), Integer.valueOf(32), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__31 = (Var)RT.var("clojure.core.reducers", "fjjoin");
    const__34 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "task")) })), RT.keyword(null, "line"), Integer.valueOf(34), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__35 = (Var)RT.var("clojure.core.reducers", "reduce");
    const__38 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "init"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Like core/reduce except:\n     When init is not provided, (f) is used.\n     Maps are reduced with reduce-kv", RT.keyword(null, "line"), Integer.valueOf(38), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__39 = RT.classForName("clojure.core.reducers.CollFold");
    const__40 = (Var)RT.var("clojure.core", "alter-meta!");
    const__41 = (Var)RT.var("clojure.core.reducers", "CollFold");
    const__42 = (Var)RT.var("clojure.core", "assoc");
    const__43 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__44 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "coll-fold")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "n"), Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef")) })) })) }));
    const__45 = (Var)RT.var("clojure.core", "alter-var-root");
    const__46 = (Var)RT.var("clojure.core", "merge");
    const__50 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.core.reducers.CollFold"), RT.keyword(null, "on-interface"), RT.classForName("clojure.core.reducers.CollFold") });
    const__51 = (Keyword)RT.keyword(null, "sigs");
    const__52 = (AFn)RT.map(new Object[] { RT.keyword(null, "coll-fold"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "coll-fold")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "n"), Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "n"), Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef")) })), RT.keyword(null, "doc"), null }) });
    const__53 = (Keyword)RT.keyword(null, "var");
    const__54 = (Keyword)RT.keyword(null, "method-map");
    const__55 = (Keyword)RT.keyword(null, "coll-fold");
    const__56 = (AFn)RT.map(new Object[] { RT.keyword(null, "coll-fold"), RT.keyword(null, "coll-fold") });
    const__57 = (Keyword)RT.keyword(null, "method-builders");
    const__58 = (Var)RT.var("clojure.core", "intern");
    const__59 = (Var)RT.var("clojure.core", "*ns*");
    const__60 = (Var)RT.var("clojure.core", "with-meta");
    const__61 = (AFn)((IObj)Symbol.intern(null, "coll-fold")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "n"), Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef")) })) }));
    const__62 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "coll-fold")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), null, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "n"), Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "n"), Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef")) })), RT.keyword(null, "doc"), null });
    const__63 = (Keyword)RT.keyword(null, "protocol");
    const__64 = (Var)RT.var("clojure.core", "-reset-methods");
    const__65 = (AFn)Symbol.intern(null, "CollFold");
    const__66 = (Var)RT.var("clojure.core.reducers", "fold");
    const__70 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "reducef"), Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef"), Symbol.intern(null, "coll")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef). combinef must be associative, and, when called with no\n  arguments, (combinef) must produce its identity element. These\n  operations may be performed in parallel, but the results will\n  preserve order.", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(51), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__71 = (Var)RT.var("clojure.core.reducers", "reducer");
    const__74 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "xf")) })), RT.keyword(null, "doc"), "Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(67), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__75 = (Var)RT.var("clojure.core.reducers", "folder");
    const__78 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "xf")) })), RT.keyword(null, "doc"), "Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(81), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__79 = (Var)RT.var("clojure.core.reducers", "do-curried");
    const__82 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "doc"), Symbol.intern(null, "meta"), Symbol.intern(null, "args"), Symbol.intern(null, "body")) })), RT.keyword(null, "line"), Integer.valueOf(99), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__83 = (Var)RT.var("clojure.core.reducers", "defcurried");
    const__86 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "doc"), Symbol.intern(null, "meta"), Symbol.intern(null, "args"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Builds another arity of the fn that returns a fn awaiting the last\n  param", RT.keyword(null, "line"), Integer.valueOf(106), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__87 = (Var)RT.var("clojure.core.reducers", "do-rfn");
    const__90 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f1"), Symbol.intern(null, "k"), Symbol.intern(null, "fkv")) })), RT.keyword(null, "line"), Integer.valueOf(112), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__91 = (Var)RT.var("clojure.core.reducers", "rfn");
    const__94 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "f1"), Symbol.intern(null, "k")), Symbol.intern(null, "fkv")) })), RT.keyword(null, "doc"), "Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl.", RT.keyword(null, "line"), Integer.valueOf(123), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__95 = (Var)RT.var("clojure.core.reducers", "map");
    const__98 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Applies f to every value in the reduction of coll. Foldable.", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(128), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__99 = (Var)RT.var("clojure.core.reducers", "mapcat");
  }
  
  public static void __init1() {
    const__102 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable.", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(138), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__103 = (Var)RT.var("clojure.core.reducers", "filter");
    const__106 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred")), Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(154), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__107 = (Var)RT.var("clojure.core.reducers", "remove");
    const__110 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred")), Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(167), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__111 = (Var)RT.var("clojure.core.reducers", "flatten");
    const__114 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection.", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(174), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__115 = (Var)RT.var("clojure.core.reducers", "take-while");
    const__118 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "pred")), Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Ends the reduction of coll when (pred val) returns logical false.", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(189), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__119 = (Var)RT.var("clojure.core.reducers", "take");
    const__122 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Ends the reduction of coll after consuming n values.", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(201), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__123 = (Var)RT.var("clojure.core.reducers", "drop");
    const__126 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")), Tuple.create(Symbol.intern(null, "n"), Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Elides the first n values from the reduction of coll.", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(215), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__127 = (Var)RT.var("clojure.core.reducers", "cat");
    const__130 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "ctor")), Tuple.create(Symbol.intern(null, "left"), Symbol.intern(null, "right")) })), RT.keyword(null, "doc"), "A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat.", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(255), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__131 = (Var)RT.var("clojure.core.reducers", "append!");
    const__134 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "acc")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.util.Collection") })), Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), ".adds x to acc and returns acc", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(275), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__135 = (Var)RT.var("clojure.core.reducers", "foldcat");
    const__138 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Equivalent to (fold cat append! coll)", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(281), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__139 = (Var)RT.var("clojure.core.reducers", "monoid");
    const__142 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "op"), Symbol.intern(null, "ctor")) })), RT.keyword(null, "doc"), "Builds a combining fn out of the supplied operator and identity\n  constructor. op must be associative and ctor called with no args\n  must return an identity value for it.", RT.keyword(null, "added"), "1.5", RT.keyword(null, "line"), Integer.valueOf(287), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__143 = (Var)RT.var("clojure.core.reducers", "foldvec");
    const__146 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "v"), Symbol.intern(null, "n"), Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef")) })), RT.keyword(null, "line"), Integer.valueOf(298), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/reducers.clj" });
    const__147 = (Var)RT.var("clojure.core", "extend");
    const__148 = RT.classForName("java.lang.Object");
    const__149 = RT.classForName("clojure.lang.IPersistentVector");
    const__150 = RT.classForName("clojure.lang.PersistentHashMap");
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("clojure.core.reducers__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
