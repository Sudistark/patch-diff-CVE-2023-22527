package clojure.core;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class memoize__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final AFn const__15;
  
  public static final Var const__16;
  
  public static final AFn const__19;
  
  public static final Var const__20;
  
  public static final AFn const__22;
  
  public static final Var const__23;
  
  public static final AFn const__26;
  
  public static final Var const__27;
  
  public static final AFn const__30;
  
  public static final Var const__31;
  
  public static final AFn const__34;
  
  public static final Var const__35;
  
  public static final AFn const__38;
  
  public static final Var const__39;
  
  public static final AFn const__42;
  
  public static final Var const__43;
  
  public static final AFn const__46;
  
  public static final Var const__47;
  
  public static final AFn const__50;
  
  public static final Var const__51;
  
  public static final AFn const__54;
  
  public static final Var const__55;
  
  public static final AFn const__58;
  
  public static final Var const__59;
  
  public static final AFn const__62;
  
  public static final Var const__63;
  
  public static final AFn const__66;
  
  public static final Var const__67;
  
  public static final AFn const__70;
  
  public static final Var const__71;
  
  public static final AFn const__74;
  
  public static final Var const__75;
  
  public static final AFn const__78;
  
  public static final Var const__79;
  
  public static final AFn const__82;
  
  public static final Var const__83;
  
  public static final AFn const__86;
  
  public static final Var const__87;
  
  public static final AFn const__90;
  
  public static final Var const__91;
  
  public static final AFn const__94;
  
  public static final Var const__95;
  
  public static final AFn const__98;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new memoize.fn__1709());
    const__6.setMeta((IPersistentMap)const__15);
    const__6.bindRoot(new memoize.d_lay());
    const__16.setMeta((IPersistentMap)const__19);
    const__16.bindRoot(new memoize.through_STAR_());
    const__20.setMeta((IPersistentMap)const__22);
    const__20.bindRoot(new memoize.cache_id());
    const__23.setMeta((IPersistentMap)const__26);
    const__23.bindRoot(new memoize.snapshot());
    const__27.setMeta((IPersistentMap)const__30);
    const__27.bindRoot(new memoize.memoized_QMARK_());
    const__31.setMeta((IPersistentMap)const__34);
    const__31.bindRoot(new memoize.memo_clear_BANG_());
    const__35.setMeta((IPersistentMap)const__38);
    const__35.bindRoot(new memoize.memo_swap_BANG_());
    const__39.setMeta((IPersistentMap)const__42);
    const__39.bindRoot(new memoize.memo_unwrap());
    const__43.setMeta((IPersistentMap)const__46);
    const__43.bindRoot(new memoize.build_memoizer());
    const__47.setMeta((IPersistentMap)const__50);
    const__47.bindRoot(new memoize.memo());
    const__51.setMeta((IPersistentMap)const__54);
    const__51.bindRoot(new memoize._BANG__BANG_());
    const__55.setMeta((IPersistentMap)const__58);
    const__55.bindRoot(new memoize.def_deprecated());
    ((Var)const__55)





















































































































































      
      .setMacro();
    const__59.setMeta((IPersistentMap)const__62);
    const__59.bindRoot(new memoize.massert());
    ((Var)const__59)



      
      .setMacro();
    const__63.setMeta((IPersistentMap)const__66);
    const__63.bindRoot(new memoize.check_args());
    ((Var)const__63)


      
      .setMacro();
    const__67.setMeta((IPersistentMap)const__70);
    const__67.bindRoot(new memoize.memo_fifo());
    const__71.setMeta((IPersistentMap)const__74);
    const__71.bindRoot(new memoize.fifo());
    const__75.setMeta((IPersistentMap)const__78);
    const__75.bindRoot(new memoize.memo_lru());
    const__79.setMeta((IPersistentMap)const__82);
    const__79.bindRoot(new memoize.lru());
    const__83.setMeta((IPersistentMap)const__86);
    const__83.bindRoot(new memoize.memo_ttl());
    const__87.setMeta((IPersistentMap)const__90);
    const__87.bindRoot(new memoize.ttl());
    const__91.setMeta((IPersistentMap)const__94);
    const__91.bindRoot(new memoize.memo_lu());
    const__95.setMeta((IPersistentMap)const__98);
    const__95.bindRoot(new memoize.lu());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.core.memoize")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "core.memoize is a memoization library offering functionality above Clojure's core `memoize`\n  function in the following ways:\n\n  **Pluggable memoization**\n\n  core.memoize allows for different back-end cache implmentations to be used as appropriate without\n  changing the memoization modus operandi.\n\n  **Manipulable memoization**\n\n  Because core.memoize allows you to access a function's memoization store, you do interesting things like\n  clear it, modify it, and save it for later.\n  ", RT.keyword(null, "author"), "fogus" }));
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "core.memoize is a memoization library offering functionality above Clojure's core `memoize`\n  function in the following ways:\n\n  **Pluggable memoization**\n\n  core.memoize allows for different back-end cache implmentations to be used as appropriate without\n  changing the memoization modus operandi.\n\n  **Manipulable memoization**\n\n  Because core.memoize allows you to access a function's memoization store, you do interesting things like\n  clear it, modify it, and save it for later.\n  ", RT.keyword(null, "author"), "fogus" });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.core.memoize", "d-lay");
    const__15 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fun")) })), RT.keyword(null, "line"), Integer.valueOf(71), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__16 = (Var)RT.var("clojure.core.memoize", "through*");
    const__19 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache"), Symbol.intern(null, "f"), Symbol.intern(null, "item")) })), RT.keyword(null, "line"), Integer.valueOf(76), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__20 = (Var)RT.var("clojure.core.memoize", "cache-id");
    const__22 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "doc"), "Returns a function's cache identity.", RT.keyword(null, "line"), Integer.valueOf(85), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__23 = (Var)RT.var("clojure.core.memoize", "snapshot");
    const__26 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "memoized-fn")) })), RT.keyword(null, "doc"), "Returns a snapshot of a core.memo-placed memoization cache.  By snapshot\n   you can infer that what you get is only the cache contents at a\n   moment in time.", RT.keyword(null, "line"), Integer.valueOf(92), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__27 = (Var)RT.var("clojure.core.memoize", "memoized?");
    const__30 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Returns true if a function has an core.memo-placed cache, false otherwise.", RT.keyword(null, "line"), Integer.valueOf(102), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__31 = (Var)RT.var("clojure.core.memoize", "memo-clear!");
    const__34 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Reaches into an core.memo-memoized function and clears the cache.  This is a\n   destructive operation and should be used with care.\n\n   When the second argument is a vector of input arguments, clears cache only\n   for argument vector.\n\n   Keep in mind that depending on what other threads or doing, an\n   immediate call to `snapshot` may not yield an empty cache.  That's\n   cool though, we've learned to deal with that stuff in Clojure by\n   now.", RT.keyword(null, "line"), Integer.valueOf(107), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__35 = (Var)RT.var("clojure.core.memoize", "memo-swap!");
    const__38 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "base")) })), RT.keyword(null, "doc"), "Takes a core.memo-populated function and a map and replaces the memoization cache\n   with the supplied map.  This is potentially some serious voodoo,\n   since you can effectively change the semantics of a function on the fly.\n\n       (def id (memo identity))\n       (memo-swap! id '{[13] :omg})\n       (id 13)\n       ;=> :omg\n\n   With great power comes ... yadda yadda yadda.", RT.keyword(null, "line"), Integer.valueOf(125), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__39 = (Var)RT.var("clojure.core.memoize", "memo-unwrap");
    const__42 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")) })), RT.keyword(null, "line"), Integer.valueOf(146), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__43 = (Var)RT.var("clojure.core.memoize", "build-memoizer");
    const__46 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "cache-factory"), Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Builds a function that given a function, returns a pluggable memoized\n   version of it.  `build-memoizer` Takes a cache factory function, a function\n   to memoize, and the arguments to the factory.  At least one of those\n   functions should be the function to be memoized.", RT.keyword(null, "line"), Integer.valueOf(152), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__47 = (Var)RT.var("clojure.core.memoize", "memo");
    const__50 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "seed")) })), RT.keyword(null, "doc"), "Used as a more flexible alternative to Clojure's core `memoization`\n   function.  Memoized functions built using `memo` will respond to\n   the core.memo manipulable memoization utilities.  As a nice bonus,\n   you can use `memo` in place of `memoize` without any additional\n   changes.\n\n   The default way to use this function is to simply apply a function\n   that will be memoized.  Additionally, you may also supply a map\n   of the form `'{[42] 42, [108] 108}` where keys are a vector\n   mapping expected argument values to arity positions.  The map values\n   are the return values of the memoized function.\n\n   You can access the memoization cache directly via the `:clojure.core.memoize/cache` key\n   on the memoized function's metadata.  However, it is advised to\n   use the core.memo primitives instead as implementation details may\n   change over time.", RT.keyword(null, "line"), Integer.valueOf(171), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__51 = (Var)RT.var("clojure.core.memoize", "!!");
    const__54 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "c")) })), RT.keyword(null, "line"), Integer.valueOf(197), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__55 = (Var)RT.var("clojure.core.memoize", "def-deprecated");
    const__58 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "nom"), Symbol.intern(null, "ds"), Symbol.intern(null, "&"), Symbol.intern(null, "arities")) })), RT.keyword(null, "line"), Integer.valueOf(203), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__59 = (Var)RT.var("clojure.core.memoize", "massert");
    const__62 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "condition"), Symbol.intern(null, "msg")) })), RT.keyword(null, "line"), Integer.valueOf(208), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__63 = (Var)RT.var("clojure.core.memoize", "check-args");
    const__66 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "nom"), Symbol.intern(null, "f"), Symbol.intern(null, "base"), Symbol.intern(null, "key"), Symbol.intern(null, "threshold")) })), RT.keyword(null, "line"), Integer.valueOf(212), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__67 = (Var)RT.var("clojure.core.memoize", "memo-fifo");
    const__70 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "limit")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "limit"), Symbol.intern(null, "base")) })), RT.keyword(null, "doc"), "DEPRECATED: Please use clojure.core.memoize/fifo instead.", RT.keyword(null, "line"), Integer.valueOf(231), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__71 = (Var)RT.var("clojure.core.memoize", "fifo");
    const__74 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "base")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "tkey"), Symbol.intern(null, "threshold")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "base"), Symbol.intern(null, "key"), Symbol.intern(null, "threshold")) })), RT.keyword(null, "doc"), "Works the same as the basic memoization function (i.e. `memo`\n   and `core.memoize` except when a given threshold is breached.\n\n   Observe the following:\n\n       (require '[clojure.core.memoize :as memo])\n\n       (def id (memo/fifo identity :fifo/threshold 2))\n\n       (id 42)\n       (id 43)\n       (snapshot id)\n       ;=> {[42] 42, [43] 43}\n\n   As you see, the limit of `2` has not been breached yet, but\n   if you call again with another value, then it is:\n\n       (id 44)\n       (snapshot id)\n       ;=> {[44] 44, [43] 43}\n\n   That is, the oldest entry `42` is pushed out of the\n   memoization cache.  This is the standard **F**irst **I**n\n   **F**irst **O**ut behavior.", RT.keyword(null, "line"), Integer.valueOf(242), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__75 = (Var)RT.var("clojure.core.memoize", "memo-lru");
    const__78 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "limit")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "limit"), Symbol.intern(null, "base")) })), RT.keyword(null, "doc"), "DEPRECATED: Please use clojure.core.memoize/lru instead.", RT.keyword(null, "line"), Integer.valueOf(281), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__79 = (Var)RT.var("clojure.core.memoize", "lru");
    const__82 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "base")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "tkey"), Symbol.intern(null, "threshold")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "base"), Symbol.intern(null, "key"), Symbol.intern(null, "threshold")) })), RT.keyword(null, "doc"), "Works the same as the basic memoization function (i.e. `memo`\n   and `core.memoize` except when a given threshold is breached.\n\n   Observe the following:\n\n       (require '[clojure.core.memoize :as memo])\n\n       (def id (memo/lru identity :lru/threshold 2))\n\n       (id 42)\n       (id 43)\n       (snapshot id)\n       ;=> {[42] 42, [43] 43}\n\n   At this point the cache has not yet crossed the set threshold\n   of `2`, but if you execute yet another call the story will\n   change:\n\n       (id 44)\n       (snapshot id)\n       ;=> {[44] 44, [43] 43}\n\n   At this point the operation of the LRU cache looks exactly\n   the same at the FIFO cache.  However, the difference becomes\n   apparent on further use:\n\n       (id 43)\n       (id 0)\n       (snapshot id)\n       ;=> {[0] 0, [43] 43}\n\n   As you see, once again calling `id` with the argument `43`\n   will expose the LRU nature of the underlying cache.  That is,\n   when the threshold is passed, the cache will expel the\n   **L**east **R**ecently **U**sed element in favor of the new.", RT.keyword(null, "line"), Integer.valueOf(292), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__83 = (Var)RT.var("clojure.core.memoize", "memo-ttl");
    const__86 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "limit")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "limit"), Symbol.intern(null, "base")) })), RT.keyword(null, "doc"), "DEPRECATED: Please use clojure.core.memoize/ttl instead.", RT.keyword(null, "line"), Integer.valueOf(342), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__87 = (Var)RT.var("clojure.core.memoize", "ttl");
    const__90 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "base")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "tkey"), Symbol.intern(null, "threshold")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "base"), Symbol.intern(null, "key"), Symbol.intern(null, "threshold")) })), RT.keyword(null, "doc"), "Unlike many of the other core.memo memoization functions,\n   `memo-ttl`'s cache policy is time-based rather than algortihmic\n   or explicit.  When memoizing a function using `memo-ttl` you\n   should provide a **T**ime **T**o **L**ive parameter in\n   milliseconds.\n\n       (require '[clojure.core.memoize :as memo])\n\n       (def id (memo/ttl identity :ttl/threshold 5000))\n\n       (id 42)\n       (snapshot id)\n       ;=> {[42] 42}\n\n       ... wait 5 seconds ...\n       (id 43)\n       (snapshot id)\n       ;=> {[43] 43}\n\n   The expired cache entries will be removed on each cache **miss**.", RT.keyword(null, "line"), Integer.valueOf(353), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__91 = (Var)RT.var("clojure.core.memoize", "memo-lu");
    const__94 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "limit")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "limit"), Symbol.intern(null, "base")) })), RT.keyword(null, "doc"), "DEPRECATED: Please use clojure.core.memoize/lu instead.", RT.keyword(null, "line"), Integer.valueOf(388), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
    const__95 = (Var)RT.var("clojure.core.memoize", "lu");
    const__98 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "base")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "tkey"), Symbol.intern(null, "threshold")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "base"), Symbol.intern(null, "key"), Symbol.intern(null, "threshold")) })), RT.keyword(null, "doc"), "Similar to the implementation of memo-lru, except that this\n   function removes all cache values whose usage value is\n   smallest:\n\n       (require '[clojure.core.memoize :as memo])\n\n       (def id (memo/lu identity :lu/threshold 3))\n\n       (id 42)\n       (id 42)\n       (id 43)\n       (id 44)\n       (snapshot id)\n       ;=> {[44] 44, [42] 42}\n\n   The **L**east **U**sed values are cleared on cache misses.", RT.keyword(null, "line"), Integer.valueOf(399), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/memoize.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("clojure.core.memoize__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
