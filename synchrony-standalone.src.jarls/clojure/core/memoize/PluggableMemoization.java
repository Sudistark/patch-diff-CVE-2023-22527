package clojure.core.memoize;

import clojure.core.cache.CacheProtocol;
import clojure.lang.IFn;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Util;
import clojure.lang.Var;

public final class PluggableMemoization implements CacheProtocol, IType {
  public final Object f;
  
  public final Object cache;
  
  private static Class __cached_class__0;
  
  private static Class __cached_class__1;
  
  private static Class __cached_class__2;
  
  private static Class __cached_class__3;
  
  private static Class __cached_class__4;
  
  private static Class __cached_class__5;
  
  public static final Var const__0 = (Var)RT.var("clojure.core.cache", "has?"), const__1 = (Var)RT.var("clojure.core.cache", "hit"), const__2 = (Var)RT.var("clojure.core.cache", "miss"), const__3 = (Var)RT.var("clojure.core.cache", "evict"), const__4 = (Var)RT.var("clojure.core.cache", "lookup"), const__5 = (Var)RT.var("clojure.core.cache", "seed"), const__6 = (Var)RT.var("clojure.core", "str");
  
  public PluggableMemoization(Object paramObject1, Object paramObject2) { this.f = paramObject1;
    this.cache = paramObject2; }
  
  public static IPersistentVector getBasis() { return Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "cache")); }
  
  public String toString() { this = null;
    return (String)((IFn)const__6.getRawRoot()).invoke(this.cache); }
  
  public Object seed(Object base) { if (Util.classOf(this.cache) != __cached_class__5)
      if (!(this.cache instanceof CacheProtocol)) {
        __cached_class__5 = Util.classOf(this.cache);
      } else {
        base = null;
        return new PluggableMemoization(this.f, ((CacheProtocol)this.cache).seed(base));
      }  
    base = null; }
  
  public Object lookup(Object item) { if (Util.classOf(this.cache) != __cached_class__4)
      if (!(this.cache instanceof CacheProtocol)) {
        __cached_class__4 = Util.classOf(this.cache);
      } else {
        item = null;
        return ((CacheProtocol)this.cache).lookup(item);
      }  
    item = null;
    this = null; }
  
  public Object evict(Object key) { if (Util.classOf(this.cache) != __cached_class__3)
      if (!(this.cache instanceof CacheProtocol)) {
        __cached_class__3 = Util.classOf(this.cache);
      } else {
        key = null;
        return new PluggableMemoization(this.f, ((CacheProtocol)this.cache).evict(key));
      }  
    key = null; }
  
  public Object miss(Object item, Object result) { if (Util.classOf(this.cache) != __cached_class__2)
      if (!(this.cache instanceof CacheProtocol)) {
        __cached_class__2 = Util.classOf(this.cache);
      } else {
        item = null;
        result = null;
        return new PluggableMemoization(this.f, ((CacheProtocol)this.cache).miss(item, result));
      }  
    item = null;
    result = null; }
  
  public Object hit(Object item) { if (Util.classOf(this.cache) != __cached_class__1)
      if (!(this.cache instanceof CacheProtocol)) {
        __cached_class__1 = Util.classOf(this.cache);
      } else {
        item = null;
        return new PluggableMemoization(this.f, ((CacheProtocol)this.cache).hit(item));
      }  
    item = null; }
  
  public Object has_QMARK_(Object item) { if (Util.classOf(this.cache) != __cached_class__0)
      if (!(this.cache instanceof CacheProtocol)) {
        __cached_class__0 = Util.classOf(this.cache);
      } else {
        item = null;
        return ((CacheProtocol)this.cache).has_QMARK_(item);
      }  
    item = null;
    this = null; }
}
