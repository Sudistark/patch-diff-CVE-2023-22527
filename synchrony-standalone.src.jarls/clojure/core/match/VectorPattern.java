package clojure.core.match;

import clojure.core.match.protocols.IContainsRestPattern;
import clojure.core.match.protocols.IPatternCompile;
import clojure.core.match.protocols.ISpecializeMatrix;
import clojure.core.match.protocols.IVectorPattern;
import clojure.lang.AFn;
import clojure.lang.IFn;
import clojure.lang.ILookup;
import clojure.lang.ILookupThunk;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.Keyword;
import clojure.lang.KeywordLookupSite;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Util;
import clojure.lang.Var;

public final class VectorPattern implements IPatternCompile, IVectorPattern, ILookup, IObj, IContainsRestPattern, ISpecializeMatrix, IType {
  public final Object v;
  
  public final Object t;
  
  public final Object size;
  
  public final Object offset;
  
  public final Object rest_QMARK_;
  
  public final Object _meta;
  
  public static final Var const__0 = (Var)RT.var("clojure.core", "str");
  
  public static final Var const__4 = (Var)RT.var("clojure.core", "map");
  
  public static final Keyword const__5 = (Keyword)RT.keyword(null, "v");
  
  public static final Keyword const__6 = (Keyword)RT.keyword(null, "t");
  
  public static final Keyword const__7 = (Keyword)RT.keyword(null, "size");
  
  public static final Keyword const__8 = (Keyword)RT.keyword(null, "offset");
  
  public static final Keyword const__9 = (Keyword)RT.keyword(null, "rest?");
  
  public static final AFn const__10 = (AFn)Tuple.create(RT.keyword(null, "v"), RT.keyword(null, "t"), RT.keyword(null, "size"), RT.keyword(null, "offset"), RT.keyword(null, "rest?"));
  
  public static final Keyword const__11 = (Keyword)RT.keyword("clojure.core.match", "tag");
  
  public static final Keyword const__12 = (Keyword)RT.keyword("clojure.core.match", "vector");
  
  public static final Var const__13 = (Var)RT.var("clojure.core.match", "array-tag");
  
  public static final Var const__14 = (Var)RT.var("clojure.core.match", "check-size?");
  
  public static final Var const__15 = (Var)RT.var("clojure.core.match", "test-with-min-size-inline");
  
  public static final Var const__16 = (Var)RT.var("clojure.core.match", "test-with-size-inline");
  
  public static final Var const__17 = (Var)RT.var("clojure.core.match", "test-inline");
  
  public static final Var const__18 = (Var)RT.var("clojure.core", "subvec");
  
  public static final Object const__19 = Long.valueOf(0L);
  
  public static final Var const__20 = (Var)RT.var("clojure.core.match", "rest-pattern?");
  
  public static final Var const__21 = (Var)RT.var("clojure.core", "first");
  
  public static final Var const__23 = (Var)RT.var("clojure.core", "some");
  
  public static final Var const__26 = (Var)RT.var("clojure.core.match", "rows");
  
  public static final Var const__27 = (Var)RT.var("clojure.core.match", "occurrences");
  
  public static final Keyword const__28 = (Keyword)RT.keyword(null, "focr");
  
  public static final Keyword const__29 = (Keyword)RT.keyword(null, "fp");
  
  public static final Var const__30 = (Var)RT.var("clojure.core", "ffirst");
  
  public static final Keyword const__31 = (Keyword)RT.keyword(null, "pat");
  
  public static final Var const__32 = (Var)RT.var("clojure.core.match", "calc-rest?-and-min-size");
  
  public static final Var const__35 = (Var)RT.var("clojure.core", "assoc");
  
  public static final Keyword const__36 = (Keyword)RT.keyword(null, "min-size");
  
  public static final Keyword const__37 = (Keyword)RT.keyword(null, "tag");
  
  public static final Var const__38 = (Var)RT.var("clojure.core.match", "specialize-vector-pattern-matrix");
  
  public static final Var const__39 = (Var)RT.var("clojure.core.match", "vector-pattern-matrix-ocrs");
  
  public static final Var const__40 = (Var)RT.var("clojure.core.match", "pattern-matrix");
  
  static final KeywordLookupSite __site__0__;
  
  static ILookupThunk __thunk__0__ = __site__0__ = new KeywordLookupSite(RT.keyword(null, "p"));
  
  static final KeywordLookupSite __site__1__;
  
  static ILookupThunk __thunk__1__ = __site__1__ = new KeywordLookupSite(RT.keyword(null, "t"));
  
  public VectorPattern(Object paramObject1, Object paramObject2, Object paramObject3, Object paramObject4, Object paramObject5, Object paramObject6) { this.v = paramObject1;
    this.t = paramObject2;
    this.size = paramObject3;
    this.offset = paramObject4;
    this.rest_QMARK_ = paramObject5;
    this._meta = paramObject6; }
  
  public static IPersistentVector getBasis() { return Tuple.create(Symbol.intern(null, "v"), Symbol.intern(null, "t"), Symbol.intern(null, "size"), Symbol.intern(null, "offset"), Symbol.intern(null, "rest?"), Symbol.intern(null, "_meta")); }
  
  public Object specialize_matrix(Object matrix) {
    Object rows = ((IFn)const__26.getRawRoot()).invoke(matrix);
    matrix = null;
    Object ocrs = ((IFn)const__27.getRawRoot()).invoke(matrix);
    Object focr = ((IFn)const__21.getRawRoot()).invoke(ocrs);
    Object env = RT.mapUniqueKeys(new Object[] { const__28, focr, const__29, ((IFn)const__30.getRawRoot()).invoke(rows), const__31, this });
    Object vec__36424 = ((IFn)const__32.getRawRoot()).invoke(rows, env);
    Object rest_QMARK_ = RT.nth(vec__36424, RT.intCast(0L), null);
    vec__36424 = null;
    Object min_size = RT.nth(vec__36424, RT.intCast(1L), null);
    env = null;
    rest_QMARK_ = null;
    min_size = null;
    focr = null;
    Object or__5516__auto__36428 = ((IFn)const__13.getRawRoot()).invoke(focr);
    if (or__5516__auto__36428 != null) {
      if (or__5516__auto__36428 != Boolean.FALSE)
        or__5516__auto__36428 = null; 
    } else {
      or__5516__auto__36428;
    } 
    if (__thunk__1__ != __thunk__1__.get(this)) {
      this;
    } else {
      __thunk__1__.get(this);
    } 
    Object env_SINGLEQUOTE_ = ((IFn)const__35.getRawRoot()).invoke(env, const__9, rest_QMARK_, const__36, min_size, const__37, (__thunk__1__ = __site__1__.fault(this)).get(this));
    rows = null;
    Object nrows = ((IFn)const__38.getRawRoot()).invoke(rows, env_SINGLEQUOTE_);
    ocrs = null;
    env_SINGLEQUOTE_ = null;
    Object nocrs = ((IFn)const__39.getRawRoot()).invoke(ocrs, env_SINGLEQUOTE_);
    nrows = null;
    nocrs = null;
    this = null;
    return ((IFn)const__40.getRawRoot()).invoke(nrows, nocrs);
  }
  
  public Object split(Object n) { // Byte code:
    //   0: getstatic clojure/core/match/VectorPattern.const__18 : Lclojure/lang/Var;
    //   3: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   6: checkcast clojure/lang/IFn
    //   9: aload_0
    //   10: getfield v : Ljava/lang/Object;
    //   13: getstatic clojure/core/match/VectorPattern.const__19 : Ljava/lang/Object;
    //   16: aload_1
    //   17: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   22: astore_2
    //   23: getstatic clojure/core/match/VectorPattern.const__18 : Lclojure/lang/Var;
    //   26: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   29: checkcast clojure/lang/IFn
    //   32: aload_0
    //   33: getfield v : Ljava/lang/Object;
    //   36: aload_1
    //   37: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   42: astore_3
    //   43: new clojure/core/match/VectorPattern
    //   46: dup
    //   47: aload_2
    //   48: aconst_null
    //   49: astore_2
    //   50: aload_0
    //   51: getfield t : Ljava/lang/Object;
    //   54: aload_1
    //   55: aload_0
    //   56: getfield offset : Ljava/lang/Object;
    //   59: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   62: aload_0
    //   63: getfield _meta : Ljava/lang/Object;
    //   66: invokespecial <init> : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V
    //   69: astore #4
    //   71: getstatic clojure/core/match/VectorPattern.const__20 : Lclojure/lang/Var;
    //   74: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   77: checkcast clojure/lang/IFn
    //   80: getstatic clojure/core/match/VectorPattern.const__21 : Lclojure/lang/Var;
    //   83: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   86: checkcast clojure/lang/IFn
    //   89: aload_3
    //   90: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   95: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   100: dup
    //   101: ifnull -> 170
    //   104: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   107: if_acmpeq -> 171
    //   110: getstatic clojure/core/match/VectorPattern.__thunk__0__ : Lclojure/lang/ILookupThunk;
    //   113: dup
    //   114: getstatic clojure/core/match/VectorPattern.const__21 : Lclojure/lang/Var;
    //   117: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   120: checkcast clojure/lang/IFn
    //   123: aload_3
    //   124: aconst_null
    //   125: astore_3
    //   126: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   131: dup_x2
    //   132: invokeinterface get : (Ljava/lang/Object;)Ljava/lang/Object;
    //   137: dup_x2
    //   138: if_acmpeq -> 145
    //   141: pop
    //   142: goto -> 167
    //   145: swap
    //   146: pop
    //   147: dup
    //   148: getstatic clojure/core/match/VectorPattern.__site__0__ : Lclojure/lang/KeywordLookupSite;
    //   151: swap
    //   152: invokeinterface fault : (Ljava/lang/Object;)Lclojure/lang/ILookupThunk;
    //   157: dup
    //   158: putstatic clojure/core/match/VectorPattern.__thunk__0__ : Lclojure/lang/ILookupThunk;
    //   161: swap
    //   162: invokeinterface get : (Ljava/lang/Object;)Ljava/lang/Object;
    //   167: goto -> 263
    //   170: pop
    //   171: getstatic clojure/core/match/VectorPattern.const__23 : Lclojure/lang/Var;
    //   174: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   177: checkcast clojure/lang/IFn
    //   180: getstatic clojure/core/match/VectorPattern.const__20 : Lclojure/lang/Var;
    //   183: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   186: aload_3
    //   187: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   192: astore #5
    //   194: aload_3
    //   195: invokestatic count : (Ljava/lang/Object;)I
    //   198: istore #6
    //   200: aload #5
    //   202: dup
    //   203: ifnull -> 224
    //   206: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   209: if_acmpeq -> 225
    //   212: iload #6
    //   214: i2l
    //   215: invokestatic dec : (J)J
    //   218: invokestatic num : (J)Ljava/lang/Number;
    //   221: goto -> 230
    //   224: pop
    //   225: iload #6
    //   227: invokestatic valueOf : (I)Ljava/lang/Integer;
    //   230: astore #7
    //   232: new clojure/core/match/VectorPattern
    //   235: dup
    //   236: aload_3
    //   237: aconst_null
    //   238: astore_3
    //   239: aload_0
    //   240: getfield t : Ljava/lang/Object;
    //   243: aload #7
    //   245: aconst_null
    //   246: astore #7
    //   248: aload_1
    //   249: aconst_null
    //   250: astore_1
    //   251: aload #5
    //   253: aconst_null
    //   254: astore #5
    //   256: aload_0
    //   257: getfield _meta : Ljava/lang/Object;
    //   260: invokespecial <init> : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V
    //   263: astore #5
    //   265: aload #4
    //   267: aconst_null
    //   268: astore #4
    //   270: aload #5
    //   272: aconst_null
    //   273: astore #5
    //   275: invokestatic create : (Ljava/lang/Object;Ljava/lang/Object;)Lclojure/lang/IPersistentVector;
    //   278: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #1324	-> 0
    //   #1365	-> 6
    //   #1365	-> 17
    //   #1366	-> 29
    //   #1366	-> 37
    //   #1368	-> 71
    //   #1368	-> 77
    //   #1368	-> 86
    //   #1368	-> 90
    //   #1368	-> 95
    //   #1369	-> 110
    //   #1369	-> 120
    //   #1369	-> 126
    //   #1369	-> 131
    //   #1370	-> 177
    //   #1370	-> 187
    //   #1371	-> 195
    //   #1372	-> 200
    //   #1372	-> 215
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   194	69	5	rest_QMARK_	Ljava/lang/Object;
    //   200	63	6	rvc	I
    //   232	31	7	size	Ljava/lang/Object;
    //   23	255	2	lv	Ljava/lang/Object;
    //   43	235	3	rv	Ljava/lang/Object;
    //   71	207	4	pl	Ljava/lang/Object;
    //   265	13	5	pr	Ljava/lang/Object;
    //   0	278	0	this	Lclojure/core/match/VectorPattern;
    //   0	278	1	n	Ljava/lang/Object; }
  
  public Object contains_rest_pattern_QMARK_() { return this.rest_QMARK_; }
  
  public Object to_source_STAR_(Object ocr) { // Byte code:
    //   0: getstatic clojure/core/match/VectorPattern.const__13 : Lclojure/lang/Var;
    //   3: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   6: checkcast clojure/lang/IFn
    //   9: aload_1
    //   10: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   15: astore_2
    //   16: aload_2
    //   17: dup
    //   18: ifnull -> 33
    //   21: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   24: if_acmpeq -> 34
    //   27: aload_2
    //   28: aconst_null
    //   29: astore_2
    //   30: goto -> 38
    //   33: pop
    //   34: aload_0
    //   35: getfield t : Ljava/lang/Object;
    //   38: astore_2
    //   39: getstatic clojure/core/match/VectorPattern.const__14 : Lclojure/lang/Var;
    //   42: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   45: checkcast clojure/lang/IFn
    //   48: aload_2
    //   49: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   54: dup
    //   55: ifnull -> 137
    //   58: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   61: if_acmpeq -> 138
    //   64: aload_0
    //   65: getfield rest_QMARK_ : Ljava/lang/Object;
    //   68: dup
    //   69: ifnull -> 107
    //   72: getstatic java/lang/Boolean.FALSE : Ljava/lang/Boolean;
    //   75: if_acmpeq -> 108
    //   78: getstatic clojure/core/match/VectorPattern.const__15 : Lclojure/lang/Var;
    //   81: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   84: checkcast clojure/lang/IFn
    //   87: aload_2
    //   88: aconst_null
    //   89: astore_2
    //   90: aload_1
    //   91: aconst_null
    //   92: astore_1
    //   93: aload_0
    //   94: getfield size : Ljava/lang/Object;
    //   97: aconst_null
    //   98: astore_0
    //   99: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   104: goto -> 134
    //   107: pop
    //   108: getstatic clojure/core/match/VectorPattern.const__16 : Lclojure/lang/Var;
    //   111: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   114: checkcast clojure/lang/IFn
    //   117: aload_2
    //   118: aconst_null
    //   119: astore_2
    //   120: aload_1
    //   121: aconst_null
    //   122: astore_1
    //   123: aload_0
    //   124: getfield size : Ljava/lang/Object;
    //   127: aconst_null
    //   128: astore_0
    //   129: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   134: goto -> 160
    //   137: pop
    //   138: getstatic clojure/core/match/VectorPattern.const__17 : Lclojure/lang/Var;
    //   141: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   144: checkcast clojure/lang/IFn
    //   147: aload_2
    //   148: aconst_null
    //   149: astore_2
    //   150: aload_1
    //   151: aconst_null
    //   152: astore_1
    //   153: aconst_null
    //   154: astore_0
    //   155: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   160: areturn
    // Line number table:
    //   Java source line number -> byte code offset
    //   #1324	-> 0
    //   #1353	-> 6
    //   #1353	-> 10
    //   #1353	-> 16
    //   #1354	-> 39
    //   #1354	-> 45
    //   #1354	-> 49
    //   #1355	-> 64
    //   #1356	-> 84
    //   #1356	-> 97
    //   #1357	-> 114
    //   #1357	-> 127
    //   #1358	-> 144
    //   #1358	-> 153
    // Local variable table:
    //   start	length	slot	name	descriptor
    //   16	22	2	or__5516__auto__36429	Ljava/lang/Object;
    //   39	121	2	t	Ljava/lang/Object;
    //   0	160	0	this	Lclojure/core/match/VectorPattern;
    //   0	160	1	ocr	Ljava/lang/Object; }
  
  public Object valAt(Object k, Object not_found) {
    Object G__36423 = k = null;
    switch (Util.hash(G__36423) >> 4 & 0xF) {
      case 3:
        if (G__36423 == const__11);
        break;
      case 5:
        if (G__36423 == const__6);
        break;
      case 9:
        if (G__36423 == const__9);
        break;
      case 11:
        if (G__36423 == const__7);
        break;
      case 12:
        if (G__36423 == const__8);
        break;
      case 13:
        if (G__36423 == const__5);
        break;
    } 
    return null;
  }
  
  public Object valAt(Object k) { k = null;
    return ((ILookup)this).valAt(k, null); }
  
  public IObj withMeta(IPersistentMap new_meta) { new_meta = null;
    return (IObj)new VectorPattern(this.v, this.t, this.size, this.offset, this.rest_QMARK_, new_meta); }
  
  public IPersistentMap meta() { return (IPersistentMap)this._meta; }
  
  public boolean equals(Object other) {
    boolean and__5514__auto__36430 = other instanceof VectorPattern;
    other = null;
    return and__5514__auto__36430 ? Util.equiv(Tuple.create(this.v, this.t, this.size, this.offset, this.rest_QMARK_), ((IFn)const__4.getRawRoot()).invoke(new fn__36421(other), const__10)) : and__5514__auto__36430;
  }
  
  public String toString() { this = null;
    return (String)((IFn)const__0.getRawRoot()).invoke(this.v, " ", this.t); }
}
