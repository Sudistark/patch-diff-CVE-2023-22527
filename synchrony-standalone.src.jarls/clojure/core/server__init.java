package clojure.core;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class server__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final Var const__7;
  
  public static final AFn const__14;
  
  public static final Var const__15;
  
  public static final AFn const__20;
  
  public static final Var const__21;
  
  public static final AFn const__24;
  
  public static final Var const__25;
  
  public static final AFn const__28;
  
  public static final Var const__29;
  
  public static final AFn const__32;
  
  public static final Var const__33;
  
  public static final AFn const__36;
  
  public static final Var const__37;
  
  public static final AFn const__40;
  
  public static final Var const__41;
  
  public static final AFn const__44;
  
  public static final Var const__45;
  
  public static final AFn const__48;
  
  public static final Var const__49;
  
  public static final AFn const__52;
  
  public static final Var const__53;
  
  public static final AFn const__56;
  
  public static final Var const__57;
  
  public static final AFn const__60;
  
  public static final Var const__61;
  
  public static final AFn const__64;
  
  public static final Var const__65;
  
  public static final AFn const__68;
  
  public static final Var const__69;
  
  public static final AFn const__72;
  
  public static final Var const__73;
  
  public static final AFn const__77;
  
  public static final Var const__78;
  
  public static final AFn const__81;
  
  public static final Var const__82;
  
  public static final AFn const__85;
  
  public static final Var const__86;
  
  public static final AFn const__89;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new server.fn__8844());
    const__7.setDynamic(true).setMeta((IPersistentMap)const__14);
    const__7.setDynamic(true).bindRoot(null);
    const__15.setMeta((IPersistentMap)const__20);
    const__15.bindRoot(new server.with_lock());
    ((Var)const__15)
      
      .setMacro();
    const__21.setMeta((IPersistentMap)const__24);
    const__21.bindRoot(new server.thread());
    ((Var)const__21)







      
      .setMacro();
    const__25.setMeta((IPersistentMap)const__28);
    const__25.bindRoot(new server.required());
    const__29.setMeta((IPersistentMap)const__32);
    const__29.bindRoot(new server.validate_opts());
    const__33.setMeta((IPersistentMap)const__36);
    const__33.bindRoot(new server.accept_connection());
    const__37.setMeta((IPersistentMap)const__40);
    const__37.bindRoot(new server.start_server());
    const__41.setMeta((IPersistentMap)const__44);
    const__41.bindRoot(new server.stop_server());
    const__45.setMeta((IPersistentMap)const__48);
    const__45.bindRoot(new server.stop_servers());
    const__49.setMeta((IPersistentMap)const__52);
    const__49.bindRoot(new server.parse_props());
    const__53.setMeta((IPersistentMap)const__56);
    const__53.bindRoot(new server.start_servers());
    const__57.setMeta((IPersistentMap)const__60);
    const__57.bindRoot(new server.repl_init());
    const__61.setMeta((IPersistentMap)const__64);
    const__61.bindRoot(new server.repl_read());
    const__65.setMeta((IPersistentMap)const__68);
    const__65.bindRoot(new server.repl());
    const__69.setMeta((IPersistentMap)const__72);
    const__69.bindRoot(new server.ex__GT_data());
    const__73.setMeta((IPersistentMap)const__77);
    const__73.bindRoot(new server.prepl());
    const__78.setMeta((IPersistentMap)const__81);
    const__78.bindRoot(new server.resolve_fn());
    const__82.setMeta((IPersistentMap)const__85);
    const__82.bindRoot(new server.io_prepl());
    const__86.setMeta((IPersistentMap)const__89);
    const__86.bindRoot(new server.remote_prepl());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.core.server")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Socket server support", RT.keyword(null, "author"), "Alex Miller" }));
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "Socket server support", RT.keyword(null, "author"), "Alex Miller" });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.core", "*warn-on-reflection*");
    const__7 = (Var)RT.var("clojure.core.server", "*session*");
    const__14 = (AFn)RT.map(new Object[] { RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(23), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/server.clj" });
    const__15 = (Var)RT.var("clojure.core.server", "with-lock");
    const__20 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "lock-expr"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "line"), Integer.valueOf(29), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/server.clj" });
    const__21 = (Var)RT.var("clojure.core.server", "thread");
    const__24 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "name")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })), Symbol.intern(null, "daemon"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "line"), Integer.valueOf(38), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/server.clj" });
    const__25 = (Var)RT.var("clojure.core.server", "required");
    const__28 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "opts"), Symbol.intern(null, "prop")) })), RT.keyword(null, "doc"), "Throw if opts does not contain prop.", RT.keyword(null, "line"), Integer.valueOf(44), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/server.clj" });
    const__29 = (Var)RT.var("clojure.core.server", "validate-opts");
    const__32 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "port"), Symbol.intern(null, "accept")), RT.keyword(null, "as"), Symbol.intern(null, "opts") })) })), RT.keyword(null, "doc"), "Validate server config options", RT.keyword(null, "line"), Integer.valueOf(50), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/server.clj" });
    const__33 = (Var)RT.var("clojure.core.server", "accept-connection");
    const__36 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { RT.vector(new Object[] { ((IObj)Symbol.intern(null, "conn")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Socket") })), Symbol.intern(null, "name"), Symbol.intern(null, "client-id"), Symbol.intern(null, "in"), Symbol.intern(null, "out"), Symbol.intern(null, "err"), Symbol.intern(null, "accept"), Symbol.intern(null, "args") }) })), RT.keyword(null, "doc"), "Start accept function, to be invoked on a client thread, given:\n    conn - client socket\n    name - server name\n    client-id - client identifier\n    in - in stream\n    out - out stream\n    err - err stream\n    accept - accept fn symbol to invoke\n    args - to pass to accept-fn", RT.keyword(null, "line"), Integer.valueOf(57), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/server.clj" });
    const__37 = (Var)RT.var("clojure.core.server", "start-server");
    const__40 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Start a socket server given the specified opts:\n    :address Host or address, string, defaults to loopback address\n    :port Port, integer, required\n    :name Name, required\n    :accept Namespaced symbol of the accept function to invoke, required\n    :args Vector of args to pass to accept function\n    :bind-err Bind *err* to socket out stream?, defaults to true\n    :server-daemon Is server thread a daemon?, defaults to true\n    :client-daemon Are client threads daemons?, defaults to true\n   Returns server socket.", RT.keyword(null, "line"), Integer.valueOf(84), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/server.clj" });
    const__41 = (Var)RT.var("clojure.core.server", "stop-server");
    const__44 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "name")) })), RT.keyword(null, "doc"), "Stop server with name or use the server-name from *session* if none supplied.\n  Returns true if server stopped successfully, nil if not found, or throws if\n  there is an error closing the socket.", RT.keyword(null, "line"), Integer.valueOf(125), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/server.clj" });
    const__45 = (Var)RT.var("clojure.core.server", "stop-servers");
    const__48 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Stop all servers ignores all errors, and returns nil.", RT.keyword(null, "line"), Integer.valueOf(139), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/server.clj" });
    const__49 = (Var)RT.var("clojure.core.server", "parse-props");
    const__52 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "props")) })), RT.keyword(null, "doc"), "Parse clojure.server.* from properties to produce a map of server configs.", RT.keyword(null, "line"), Integer.valueOf(146), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/server.clj" });
    const__53 = (Var)RT.var("clojure.core.server", "start-servers");
    const__56 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "system-props")) })), RT.keyword(null, "doc"), "Start all servers specified in the system properties.", RT.keyword(null, "line"), Integer.valueOf(157), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/server.clj" });
    const__57 = (Var)RT.var("clojure.core.server", "repl-init");
    const__60 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "Initialize repl in user namespace and make standard repl requires.", RT.keyword(null, "line"), Integer.valueOf(163), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/server.clj" });
    const__61 = (Var)RT.var("clojure.core.server", "repl-read");
    const__64 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "request-prompt"), Symbol.intern(null, "request-exit")) })), RT.keyword(null, "doc"), "Enhanced :read hook for repl supporting :repl/quit.", RT.keyword(null, "line"), Integer.valueOf(169), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/server.clj" });
    const__65 = (Var)RT.var("clojure.core.server", "repl");
    const__68 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "REPL with predefined hooks for attachable socket server.", RT.keyword(null, "line"), Integer.valueOf(180), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/server.clj" });
    const__69 = (Var)RT.var("clojure.core.server", "ex->data");
    const__72 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ex"), Symbol.intern(null, "phase")) })), RT.keyword(null, "line"), Integer.valueOf(187), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/server.clj" });
    const__73 = (Var)RT.var("clojure.core.server", "prepl");
    const__77 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "in-reader"), Symbol.intern(null, "out-fn"), Symbol.intern(null, "&"), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "stdin")) })) })), RT.keyword(null, "doc"), "a REPL with structured output (for programs)\n  reads forms to eval from in-reader (a LineNumberingPushbackReader)\n  Closing the input or passing the form :repl/quit will cause it to return\n\n  Calls out-fn with data, one of:\n  {:tag :ret\n   :val val ;;eval result\n   :ns ns-name-string\n   :ms long ;;eval time in milliseconds\n   :form string ;;iff successfully read\n   :clojure.error/phase (:execution et al per clojure.main/ex-triage) ;;iff error occurred\n  }\n  {:tag :out\n   :val string} ;chars from during-eval *out*\n  {:tag :err\n   :val string} ;chars from during-eval *err*\n  {:tag :tap\n   :val val} ;values from tap>\n\n  You might get more than one :out or :err per eval, but exactly one :ret\n  tap output can happen at any time (i.e. between evals)\n  If during eval an attempt is made to read *in* it will read from in-reader unless :stdin is supplied\n\n  Alpha, subject to change.", RT.keyword(null, "added"), "1.10", RT.keyword(null, "line"), Integer.valueOf(191), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/server.clj" });
    const__78 = (Var)RT.var("clojure.core.server", "resolve-fn");
    const__81 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "valf")) })), RT.keyword(null, "line"), Integer.valueOf(263), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core/server.clj" });
    const__82 = (Var)RT.var("clojure.core.server", "io-prepl");
    const__85 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "valf")), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "valf"), Symbol.intern(null, "pr-str") }) })) })), RT.keyword(null, "doc"), "prepl bound to *in* and *out*, suitable for use with e.g. server/repl (socket-repl).\n  :ret and :tap vals will be processed by valf, a fn of one argument\n  or a symbol naming same (default pr-str)\n\n  Alpha, subject to change.", RT.keyword(null, "added"), "1.10", RT.keyword(null, "line"), Integer.valueOf(272), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/server.clj" });
    const__86 = (Var)RT.var("clojure.core.server", "remote-prepl");
    const__89 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "host")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })), Symbol.intern(null, "port"), ((IObj)Symbol.intern(null, "in-reader")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Reader") })), Symbol.intern(null, "out-fn"), Symbol.intern(null, "&"), RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "valf"), Symbol.intern(null, "readf")), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "valf"), Symbol.intern(null, "read-string"), Symbol.intern(null, "readf"), PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "fn*"), Tuple.create(Symbol.intern(null, "p1__8961#"), Symbol.intern(null, "p2__8962#")), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "read"), Symbol.intern(null, "p1__8961#"), Boolean.FALSE, Symbol.intern(null, "p2__8962#") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(307), RT.keyword(null, "column"), Integer.valueOf(73) })) })) }) })) })), RT.keyword(null, "doc"), "Implements a prepl on in-reader and out-fn by forwarding to a\n  remote [io-]prepl over a socket.  Messages will be read by readf, a\n  fn of a LineNumberingPushbackReader and EOF value or a symbol naming\n  same (default #(read %1 false %2)),\n  :ret and :tap vals will be processed by valf, a fn of one argument\n  or a symbol naming same (default read-string). If that function\n  throws, :val will be unprocessed.\n\n  Alpha, subject to change.", RT.keyword(null, "added"), "1.10", RT.keyword(null, "line"), Integer.valueOf(295), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core/server.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("clojure.core.server__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
