package clojure.core.async.impl.buffers;

import clojure.core.async.impl.protocols.Buffer;
import clojure.core.async.impl.protocols.UnblockingBuffer;
import clojure.lang.Counted;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;

public final class PromiseBuffer implements UnblockingBuffer, Buffer, Counted, IType {
  Object val;
  
  public static final Var const__0 = (Var)RT.var("clojure.core.async.impl.buffers", "undelivered?");
  
  public PromiseBuffer(Object paramObject) { this.val = paramObject; }
  
  public static IPersistentVector getBasis() { return Tuple.create(((IObj)Symbol.intern(null, "val")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "unsynchronized-mutable"), Boolean.TRUE }))); }
  
  public int count() { if (((IFn)const__0.getRawRoot()).invoke(this.val) != null) {
      if (((IFn)const__0.getRawRoot()).invoke(this.val) != Boolean.FALSE);
    } else {
      ((IFn)const__0.getRawRoot()).invoke(this.val);
    } 
    return RT.intCast(1L); }
  
  public Object close_buf_BANG_() { if (((IFn)const__0.getRawRoot()).invoke(this.val) != null) {
      if (((IFn)const__0.getRawRoot()).invoke(this.val) != Boolean.FALSE)
        this.val = null; 
    } else {
      ((IFn)const__0.getRawRoot()).invoke(this.val);
    } 
    return null; }
  
  public Object add_BANG__STAR_(Object itm) { if (((IFn)const__0.getRawRoot()).invoke(this.val) != null) {
      if (((IFn)const__0.getRawRoot()).invoke(this.val) != Boolean.FALSE) {
        this.val = itm = null;
        return this;
      } 
    } else {
      ((IFn)const__0.getRawRoot()).invoke(this.val);
    } 
    null;
    return this; }
  
  public Object remove_BANG_() { return this.val; }
  
  public Object full_QMARK_() { return Boolean.FALSE; }
}
