package clojure.pprint;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IPersistentMap;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import clojure.pprint;
import java.util.Arrays;

public class pprint_base__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Var const__2;
  
  public static final AFn const__11;
  
  public static final Var const__12;
  
  public static final AFn const__14;
  
  public static final Object const__15;
  
  public static final Var const__16;
  
  public static final AFn const__18;
  
  public static final Object const__19;
  
  public static final Var const__20;
  
  public static final AFn const__23;
  
  public static final Var const__24;
  
  public static final AFn const__26;
  
  public static final Var const__27;
  
  public static final AFn const__29;
  
  public static final Var const__30;
  
  public static final AFn const__32;
  
  public static final Var const__33;
  
  public static final AFn const__35;
  
  public static final Var const__36;
  
  public static final AFn const__38;
  
  public static final Object const__39;
  
  public static final Var const__40;
  
  public static final AFn const__42;
  
  public static final Object const__43;
  
  public static final Var const__44;
  
  public static final AFn const__46;
  
  public static final Var const__47;
  
  public static final AFn const__50;
  
  public static final Var const__51;
  
  public static final AFn const__53;
  
  public static final Var const__54;
  
  public static final Var const__55;
  
  public static final AFn const__59;
  
  public static final Var const__60;
  
  public static final AFn const__62;
  
  public static final AFn const__87;
  
  public static final Var const__88;
  
  public static final AFn const__91;
  
  public static final Var const__92;
  
  public static final AFn const__95;
  
  public static final Var const__96;
  
  public static final AFn const__99;
  
  public static final Var const__100;
  
  public static final AFn const__103;
  
  public static final Var const__104;
  
  public static final AFn const__107;
  
  public static final Var const__108;
  
  public static final AFn const__111;
  
  public static final Var const__112;
  
  public static final AFn const__115;
  
  public static final Var const__116;
  
  public static final AFn const__119;
  
  public static final Var const__120;
  
  public static final AFn const__123;
  
  public static final Var const__124;
  
  public static final AFn const__127;
  
  public static final Var const__128;
  
  public static final AFn const__131;
  
  public static final Var const__132;
  
  public static final AFn const__135;
  
  public static final Var const__136;
  
  public static final AFn const__139;
  
  public static final Var const__140;
  
  public static final AFn const__143;
  
  public static final Var const__144;
  
  public static final AFn const__147;
  
  public static final Var const__148;
  
  public static final AFn const__151;
  
  public static final Var const__152;
  
  public static final AFn const__155;
  
  public static final Var const__156;
  
  public static final AFn const__159;
  
  public static final Var const__160;
  
  public static final AFn const__163;
  
  public static final Var const__164;
  
  public static final AFn const__167;
  
  public static void load() {
    const__2.setDynamic(true).setMeta((IPersistentMap)const__11);
    const__2.setDynamic(true).bindRoot(Boolean.TRUE);
    const__12.setDynamic(true).setMeta((IPersistentMap)const__14);
    const__12.setDynamic(true).bindRoot(const__15);
    const__16.setDynamic(true).setMeta((IPersistentMap)const__18);
    const__16.setDynamic(true).bindRoot(const__19);
    const__20.setDynamic(true).setMeta((IPersistentMap)const__23);
    const__20.setDynamic(true).bindRoot(null);
    const__24.setDynamic(true).setMeta((IPersistentMap)const__26);
    const__24.setDynamic(true).bindRoot(null);
    const__27.setDynamic(true).setMeta((IPersistentMap)const__29);
    const__27.setDynamic(true).bindRoot(null);
    const__30.setDynamic(true).setMeta((IPersistentMap)const__32);
    const__30.setDynamic(true).bindRoot(null);
    const__33.setDynamic(true).setMeta((IPersistentMap)const__35);
    const__33.setDynamic(true).bindRoot(null);
    const__36.setDynamic(true).setMeta((IPersistentMap)const__38);
    const__36.setDynamic(true).bindRoot(const__39);
    const__40.setDynamic(true).setMeta((IPersistentMap)const__42);
    const__40.setDynamic(true).bindRoot(const__43);
    const__44.setDynamic(true).setMeta((IPersistentMap)const__46);
    const__44.setDynamic(true).bindRoot(null);
    const__47.setMeta((IPersistentMap)const__50);
    const__51.setMeta((IPersistentMap)const__53);
    const__51.bindRoot(const__54.get());
    const__55.setMeta((IPersistentMap)const__59);
    const__55.bindRoot(new pprint.pr_with_base());
    const__60.setMeta((IPersistentMap)const__62);
    const__60.bindRoot(const__87);
    const__88.setMeta((IPersistentMap)const__91);
    const__88.bindRoot(new pprint.binding_map());
    ((Var)const__88)





































































































      
      .setMacro();
    const__92.setMeta((IPersistentMap)const__95);
    const__92.bindRoot(new pprint.table_ize());
    const__96.setMeta((IPersistentMap)const__99);
    const__96.bindRoot(new pprint.pretty_writer_QMARK_());
    const__100.setMeta((IPersistentMap)const__103);
    const__100.bindRoot(new pprint.make_pretty_writer());
    const__104.setMeta((IPersistentMap)const__107);
    const__104.bindRoot(new pprint.with_pretty_writer());
    ((Var)const__104)





















      
      .setMacro();
    const__108.setMeta((IPersistentMap)const__111);
    const__108.bindRoot(new pprint.write_out());
    const__112.setMeta((IPersistentMap)const__115);
    const__112.bindRoot(new pprint.write());
    const__116.setMeta((IPersistentMap)const__119);
    const__116.bindRoot(new pprint.pprint());
    const__120.setMeta((IPersistentMap)const__123);
    const__120.bindRoot(new pprint.pp());
    ((Var)const__120)




























































































      
      .setMacro();
    const__124.setMeta((IPersistentMap)const__127);
    const__124.bindRoot(new pprint.set_pprint_dispatch());
    const__128.setMeta((IPersistentMap)const__131);
    const__128.bindRoot(new pprint.with_pprint_dispatch());
    ((Var)const__128)


















      
      .setMacro();
    const__132.setMeta((IPersistentMap)const__135);
    const__132.bindRoot(new pprint.parse_lb_options());
    const__136.setMeta((IPersistentMap)const__139);
    const__136.bindRoot(new pprint.check_enumerated_arg());
    const__140.setMeta((IPersistentMap)const__143);
    const__140.bindRoot(new pprint.level_exceeded());
    const__144.setMeta((IPersistentMap)const__147);
    const__144.bindRoot(new pprint.pprint_logical_block());
    ((Var)const__144)


























      
      .setMacro();
    const__148.setMeta((IPersistentMap)const__151);
    const__148.bindRoot(new pprint.pprint_newline());
    const__152.setMeta((IPersistentMap)const__155);
    const__152.bindRoot(new pprint.pprint_indent());
    const__156.setMeta((IPersistentMap)const__159);
    const__156.bindRoot(new pprint.pprint_tab());
    const__160.setMeta((IPersistentMap)const__163);
    const__160.bindRoot(new pprint.pll_mod_body());
    const__164.setMeta((IPersistentMap)const__167);
    const__164.bindRoot(new pprint.print_length_loop());
    ((Var)const__164)























































































      
      .setMacro();
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "clojure.pprint");
    const__2 = (Var)RT.var("clojure.pprint", "*print-pretty*");
    const__11 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "Bind to true if you want write to use pretty printing", RT.keyword(null, "added"), "1.2", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(30), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__12 = (Var)RT.var("clojure.pprint", "*print-right-margin*");
    const__14 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all \nnon-mandatory newlines.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(40), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__15 = Long.valueOf(72L);
    const__16 = (Var)RT.var("clojure.pprint", "*print-miser-width*");
    const__18 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "The column at which to enter miser style. Depending on the dispatch table, \nmiser style add newlines in more places to try to keep lines short allowing for further \nlevels of nesting.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(47), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__19 = Long.valueOf(40L);
    const__20 = (Var)RT.var("clojure.pprint", "*print-lines*");
    const__23 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "doc"), "Maximum number of lines to print in a pretty print instance (N.B. This is not yet used)", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(55), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__24 = (Var)RT.var("clojure.pprint", "*print-circle*");
    const__26 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "doc"), "Mark circular structures (N.B. This is not yet used)", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(61), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__27 = (Var)RT.var("clojure.pprint", "*print-shared*");
    const__29 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "doc"), "Mark repeated structures rather than repeat them (N.B. This is not yet used)", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(67), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__30 = (Var)RT.var("clojure.pprint", "*print-suppress-namespaces*");
    const__32 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "Don't print namespaces with symbols. This is particularly useful when \npretty printing the results of macro expansions", RT.keyword(null, "added"), "1.2", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(72), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__33 = (Var)RT.var("clojure.pprint", "*print-radix*");
    const__35 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8, \nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the \nradix specifier is in the form #XXr where XX is the decimal value of *print-base* ", RT.keyword(null, "added"), "1.2", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(80), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__36 = (Var)RT.var("clojure.pprint", "*print-base*");
    const__38 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "doc"), "The base to use for printing integers and rationals.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(87), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__39 = Long.valueOf(10L);
    const__40 = (Var)RT.var("clojure.pprint", "*current-level*");
    const__42 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(99), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__43 = Long.valueOf(0L);
    const__44 = (Var)RT.var("clojure.pprint", "*current-length*");
    const__46 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(101), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__47 = (Var)RT.var("clojure.pprint", "format-simple-number");
    const__50 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(109), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__51 = (Var)RT.var("clojure.pprint", "orig-pr");
    const__53 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(111), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__54 = (Var)RT.var("clojure.core", "pr");
    const__55 = (Var)RT.var("clojure.pprint", "pr-with-base");
    const__59 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(113), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__60 = (Var)RT.var("clojure.pprint", "write-option-table");
    const__62 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(118), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__87 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "miser-width"), Symbol.intern("clojure.pprint", "*print-miser-width*"), RT.keyword(null, "right-margin"), Symbol.intern("clojure.pprint", "*print-right-margin*"), RT.keyword(null, "circle"), Symbol.intern("clojure.pprint", "*print-circle*"), RT.keyword(null, "lines"), Symbol.intern("clojure.pprint", "*print-lines*"), RT.keyword(null, "suppress-namespaces"), Symbol.intern("clojure.pprint", "*print-suppress-namespaces*"), 
          RT.keyword(null, "radix"), Symbol.intern("clojure.pprint", "*print-radix*"), RT.keyword(null, "level"), Symbol.intern("clojure.core", "*print-level*"), RT.keyword(null, "readably"), Symbol.intern("clojure.core", "*print-readably*"), RT.keyword(null, "dispatch"), Symbol.intern("clojure.pprint", "*print-pprint-dispatch*"), RT.keyword(null, "length"), Symbol.intern("clojure.core", "*print-length*"), 
          RT.keyword(null, "pretty"), Symbol.intern("clojure.pprint", "*print-pretty*"), RT.keyword(null, "base"), Symbol.intern("clojure.pprint", "*print-base*") });
    const__88 = (Var)RT.var("clojure.pprint", "binding-map");
    const__91 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "amap"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "line"), Integer.valueOf(137), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__92 = (Var)RT.var("clojure.pprint", "table-ize");
    const__95 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "t"), Symbol.intern(null, "m")) })), RT.keyword(null, "line"), Integer.valueOf(146), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__96 = (Var)RT.var("clojure.pprint", "pretty-writer?");
    const__99 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Return true iff x is a PrettyWriter", RT.keyword(null, "line"), Integer.valueOf(151), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
  }
  
  public static void __init1() {
    const__100 = (Var)RT.var("clojure.pprint", "make-pretty-writer");
    const__103 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "base-writer"), Symbol.intern(null, "right-margin"), Symbol.intern(null, "miser-width")) })), RT.keyword(null, "doc"), "Wrap base-writer in a PrettyWriter with the specified right-margin and miser-width", RT.keyword(null, "line"), Integer.valueOf(155), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__104 = (Var)RT.var("clojure.pprint", "with-pretty-writer");
    const__107 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "base-writer"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "line"), Integer.valueOf(160), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__108 = (Var)RT.var("clojure.pprint", "write-out");
    const__111 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "object")) })), RT.keyword(null, "doc"), "Write an object to *out* subject to the current bindings of the printer control \nvariables. Use the kw-args argument to override individual variables for this call (and \nany recursive calls).\n\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\nof the caller.\n\nThis method is primarily intended for use by pretty print dispatch functions that \nalready know that the pretty printer will have set up their environment appropriately.\nNormal library clients should use the standard \"write\" interface. ", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(171), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__112 = (Var)RT.var("clojure.pprint", "write");
    const__115 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "object"), Symbol.intern(null, "&"), Symbol.intern(null, "kw-args")) })), RT.keyword(null, "doc"), "Write an object subject to the current bindings of the printer control variables.\nUse the kw-args argument to override individual variables for this call (and any \nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\n\nThe following keyword arguments can be passed with values:\n  Keyword              Meaning                              Default value\n  :stream              Writer for output or nil             true (indicates *out*)\n  :base                Base to use for writing rationals    Current value of *print-base*\n  :circle*             If true, mark circular structures    Current value of *print-circle*\n  :length              Maximum elements to show in sublists Current value of *print-length*\n  :level               Maximum depth                        Current value of *print-level*\n  :lines*              Maximum lines of output              Current value of *print-lines*\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\n  :readably*           If true, print readably              Current value of *print-readably*\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\n\n  * = not yet supported\n", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(197), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__116 = (Var)RT.var("clojure.pprint", "pprint");
    const__119 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "object")), Tuple.create(Symbol.intern(null, "object"), Symbol.intern(null, "writer")) })), RT.keyword(null, "doc"), "Pretty print object to the optional output writer. If the writer is not provided, \nprint the object to the currently bound value of *out*.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(241), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__120 = (Var)RT.var("clojure.pprint", "pp");
    const__123 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "doc"), "A convenience macro that pretty prints the last thing output. This is\nexactly equivalent to (pprint *1).", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(254), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__124 = (Var)RT.var("clojure.pprint", "set-pprint-dispatch");
    const__127 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "function")) })), RT.keyword(null, "doc"), "Set the pretty print dispatch function to a function matching (fn [obj] ...)\nwhere obj is the object to pretty print. That function will be called with *out* set\nto a pretty printing writer to which it should do its printing.\n\nFor example functions, see simple-dispatch and code-dispatch in \nclojure.pprint.dispatch.clj.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(260), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__128 = (Var)RT.var("clojure.pprint", "with-pprint-dispatch");
    const__131 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "function"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Execute body with the pretty print dispatch function bound to function.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(274), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__132 = (Var)RT.var("clojure.pprint", "parse-lb-options");
    const__135 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "opts"), Symbol.intern(null, "body")) })), RT.keyword(null, "line"), Integer.valueOf(285), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__136 = (Var)RT.var("clojure.pprint", "check-enumerated-arg");
    const__139 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "arg"), Symbol.intern(null, "choices")) })), RT.keyword(null, "line"), Integer.valueOf(292), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__140 = (Var)RT.var("clojure.pprint", "level-exceeded");
    const__143 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "line"), Integer.valueOf(299), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__144 = (Var)RT.var("clojure.pprint", "pprint-logical-block");
    const__147 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), Tuple.create(Tuple.create(Symbol.intern(null, "options*"), Symbol.intern(null, "body"))), RT.keyword(null, "doc"), "Execute the body as a pretty printing logical block with output to *out* which \nmust be a pretty printing writer. When used from pprint or cl-format, this can be \nassumed. \n\nThis function is intended for use when writing custom dispatch functions.\n\nBefore the body, the caller can optionally specify options: :prefix, :per-line-prefix, \nand :suffix.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(302), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__148 = (Var)RT.var("clojure.pprint", "pprint-newline");
    const__151 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "kind")) })), RT.keyword(null, "doc"), "Print a conditional newline to a pretty printing stream. kind specifies if the \nnewline is :linear, :miser, :fill, or :mandatory. \n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(329), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__152 = (Var)RT.var("clojure.pprint", "pprint-indent");
    const__155 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "relative-to"), Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Create an indent at this point in the pretty printing stream. This defines how \nfollowing lines are indented. relative-to can be either :block or :current depending \nwhether the indent should be computed relative to the start of the logical block or\nthe current column position. n is an offset. \n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(341), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__156 = (Var)RT.var("clojure.pprint", "pprint-tab");
    const__159 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "kind"), Symbol.intern(null, "colnum"), Symbol.intern(null, "colinc")) })), RT.keyword(null, "doc"), "Tab at this point in the pretty printing stream. kind specifies whether the tab\nis :line, :section, :line-relative, or :section-relative. \n\nColnum and colinc specify the target column and the increment to move the target\nforward if the output is already past the original target.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\n\nTHIS FUNCTION IS NOT YET IMPLEMENTED.", RT.keyword(null, "added"), "1.2", RT.keyword(null, "line"), Integer.valueOf(356), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__160 = (Var)RT.var("clojure.pprint", "pll-mod-body");
    const__163 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "var-sym"), Symbol.intern(null, "body")) })), RT.keyword(null, "line"), Integer.valueOf(380), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
    const__164 = (Var)RT.var("clojure.pprint", "print-length-loop");
    const__167 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "A version of loop that iterates at most *print-length* times. This is designed \nfor use in pretty-printer dispatch functions.", RT.keyword(null, "added"), "1.3", RT.keyword(null, "line"), Integer.valueOf(391), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/pprint/pprint_base.clj" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("clojure.pprint.pprint_base__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
