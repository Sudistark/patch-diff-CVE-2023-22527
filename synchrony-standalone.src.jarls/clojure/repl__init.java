package clojure;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class repl__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final AFn const__13;
  
  public static final AFn const__14;
  
  public static final Var const__15;
  
  public static final AFn const__19;
  
  public static final Var const__20;
  
  public static final AFn const__23;
  
  public static final Var const__24;
  
  public static final AFn const__27;
  
  public static final Var const__28;
  
  public static final AFn const__32;
  
  public static final Var const__33;
  
  public static final AFn const__36;
  
  public static final Var const__37;
  
  public static final AFn const__40;
  
  public static final Var const__41;
  
  public static final AFn const__44;
  
  public static final Var const__45;
  
  public static final AFn const__48;
  
  public static final Var const__49;
  
  public static final AFn const__52;
  
  public static final Var const__53;
  
  public static final AFn const__56;
  
  public static final Var const__57;
  
  public static final AFn const__60;
  
  public static final Var const__61;
  
  public static final AFn const__64;
  
  public static final Var const__65;
  
  public static final AFn const__68;
  
  public static final Var const__69;
  
  public static final AFn const__72;
  
  public static final Var const__73;
  
  public static final AFn const__76;
  
  public static final Var const__77;
  
  public static final AFn const__80;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new repl.fn__11581());
    const__6.setMeta((IPersistentMap)const__13);
    const__6.bindRoot(const__14);
    const__15.setMeta((IPersistentMap)const__19);
    const__15.bindRoot(new repl.special_doc());
    const__20.setMeta((IPersistentMap)const__23);
    const__20.bindRoot(new repl.namespace_doc());
    const__24.setMeta((IPersistentMap)const__27);
    const__24.bindRoot(new repl.print_doc());
    const__28.setMeta((IPersistentMap)const__32);
    const__28.bindRoot(new repl.find_doc());
    const__33.setMeta((IPersistentMap)const__36);
    const__33.bindRoot(new repl.doc());
    ((Var)const__33)























































































































      
      .setMacro();
    const__37.setMeta((IPersistentMap)const__40);
    const__37.bindRoot(new repl.source_fn());
    const__41.setMeta((IPersistentMap)const__44);
    const__41.bindRoot(new repl.source());
    ((Var)const__41)







































      
      .setMacro();
    const__45.setMeta((IPersistentMap)const__48);
    const__45.bindRoot(new repl.apropos());
    const__49.setMeta((IPersistentMap)const__52);
    const__49.bindRoot(new repl.dir_fn());
    const__53.setMeta((IPersistentMap)const__56);
    const__53.bindRoot(new repl.dir());
    ((Var)const__53)



























      
      .setMacro();
    const__57.setMeta((IPersistentMap)const__60);
    const__57.bindRoot(new repl.demunge());
    const__61.setMeta((IPersistentMap)const__64);
    const__61.bindRoot(new repl.root_cause());
    const__65.setMeta((IPersistentMap)const__68);
    const__65.bindRoot(new repl.stack_element_str());
    const__69.setMeta((IPersistentMap)const__72);
    const__69.bindRoot(new repl.pst());
    const__73.setMeta((IPersistentMap)const__76);
    const__73.bindRoot(new repl.thread_stopper());
    const__77.setMeta((IPersistentMap)const__80);
    const__77.bindRoot(new repl.set_break_handler_BANG_());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.repl")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "author"), "Chris Houser, Christophe Grand, Stephen Gilardi, Michel Salim", RT.keyword(null, "doc"), "Utilities meant to be used interactively at the REPL" }));
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "author"), "Chris Houser, Christophe Grand, Stephen Gilardi, Michel Salim", RT.keyword(null, "doc"), "Utilities meant to be used interactively at the REPL" });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.repl", "special-doc-map");
    const__13 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(19), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/repl.clj" });
    const__14 = (AFn)RT.map(new Object[] { 
          Symbol.intern(null, "monitor-exit"), RT.map(new Object[] { RT.keyword(null, "forms"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "monitor-exit"), Symbol.intern(null, "x") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(43), RT.keyword(null, "column"), Integer.valueOf(27) }))), RT.keyword(null, "doc"), "Synchronization primitive that should be avoided\n  in user code. Use the 'locking' macro." }), Symbol.intern(null, "try"), RT.map(new Object[] { RT.keyword(null, "forms"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "try"), Symbol.intern(null, "expr*"), Symbol.intern(null, "catch-clause*"), Symbol.intern(null, "finally-clause?") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(66), RT.keyword(null, "column"), Integer.valueOf(18) }))), RT.keyword(null, "doc"), "catch-clause => (catch classname name expr*)\n  finally-clause => (finally expr*)\n\n  Catches and handles Java exceptions." }), Symbol.intern(null, "do"), RT.map(new Object[] { RT.keyword(null, "forms"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "do"), Symbol.intern(null, "exprs*") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(33), RT.keyword(null, "column"), Integer.valueOf(17) }))), RT.keyword(null, "doc"), "Evaluates the expressions in order and returns the value of\n  the last. If no expressions are supplied, returns nil." }), Symbol.intern(null, "if"), RT.map(new Object[] { RT.keyword(null, "forms"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "if"), Symbol.intern(null, "test"), Symbol.intern(null, "then"), Symbol.intern(null, "else?") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(36), RT.keyword(null, "column"), Integer.valueOf(17) }))), RT.keyword(null, "doc"), "Evaluates test. If not the singular values nil or false,\n  evaluates and yields then, otherwise, evaluates and yields else. If\n  else is not supplied it defaults to nil." }), Symbol.intern(null, "new"), RT.map(new Object[] { RT.keyword(null, "forms"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "Classname."), Symbol.intern(null, "args*") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(46), RT.keyword(null, "column"), Integer.valueOf(18) })), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "new"), Symbol.intern(null, "Classname"), Symbol.intern(null, "args*") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(46), RT.keyword(null, "column"), Integer.valueOf(37) }))), RT.keyword(null, "url"), "java_interop#new", RT.keyword(null, "doc"), "The args, if any, are evaluated from left to right, and\n  passed to the constructor of the class named by Classname. The\n  constructed object is returned." }), 
          Symbol.intern(null, "recur"), RT.map(new Object[] { RT.keyword(null, "forms"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "recur"), Symbol.intern(null, "exprs*") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(53), RT.keyword(null, "column"), Integer.valueOf(20) }))), RT.keyword(null, "doc"), "Evaluates the exprs in order, then, in parallel, rebinds\n  the bindings of the recursion point to the values of the exprs.\n  Execution then jumps back to the recursion point, a loop or fn method." }), Symbol.intern(null, "set!"), RT.map(new Object[] { RT.keyword(null, "forms"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "set!"), Symbol.intern(null, "var-symbol"), Symbol.intern(null, "expr") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(57), RT.keyword(null, "column"), Integer.valueOf(18) })), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "set!"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "."), Symbol.intern(null, "instance-expr"), Symbol.intern(null, "instanceFieldName-symbol") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(58), RT.keyword(null, "column"), Integer.valueOf(24) })), Symbol.intern(null, "expr") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(58), RT.keyword(null, "column"), Integer.valueOf(18) })), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "set!"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "."), Symbol.intern(null, "Classname-symbol"), Symbol.intern(null, "staticFieldName-symbol") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(59), RT.keyword(null, "column"), Integer.valueOf(24) })), Symbol.intern(null, "expr") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(59), RT.keyword(null, "column"), Integer.valueOf(18) }))), RT.keyword(null, "url"), "vars#set", RT.keyword(null, "doc"), "Used to set thread-local-bound vars, Java object instance\nfields, and Java class static fields." }), Symbol.intern(null, "."), RT.map(new Object[] { RT.keyword(null, "url"), "java_interop#dot", RT.keyword(null, "forms"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, ".instanceMember"), Symbol.intern(null, "instance"), Symbol.intern(null, "args*") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(21), RT.keyword(null, "column"), Integer.valueOf(16) })), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, ".instanceMember"), Symbol.intern(null, "Classname"), Symbol.intern(null, "args*") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(22), RT.keyword(null, "column"), Integer.valueOf(16) })), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern("Classname", "staticMethod"), Symbol.intern(null, "args*") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(23), RT.keyword(null, "column"), Integer.valueOf(16) })), Symbol.intern("Classname", "staticField")), RT.keyword(null, "doc"), "The instance member form works for both fields and methods.\n  They all expand into calls to the dot operator at macroexpansion time." }), Symbol.intern(null, "var"), RT.map(new Object[] { RT.keyword(null, "forms"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "var"), Symbol.intern(null, "symbol") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(71), RT.keyword(null, "column"), Integer.valueOf(18) }))), RT.keyword(null, "doc"), "The symbol must resolve to a var, and the Var object\nitself (not its value) is returned. The reader macro #'x expands to (var x)." }), Symbol.intern(null, "quote"), RT.map(new Object[] { RT.keyword(null, "forms"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "quote"), Symbol.intern(null, "form") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(51), RT.keyword(null, "column"), Integer.valueOf(20) }))), RT.keyword(null, "doc"), "Yields the unevaluated form." }), 
          Symbol.intern(null, "throw"), RT.map(new Object[] { RT.keyword(null, "forms"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "throw"), Symbol.intern(null, "expr") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(63), RT.keyword(null, "column"), Integer.valueOf(20) }))), RT.keyword(null, "doc"), "The expr is evaluated and thrown, therefore it should\n  yield an instance of some derivee of Throwable." }), Symbol.intern(null, "monitor-enter"), RT.map(new Object[] { RT.keyword(null, "forms"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "monitor-enter"), Symbol.intern(null, "x") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(40), RT.keyword(null, "column"), Integer.valueOf(28) }))), RT.keyword(null, "doc"), "Synchronization primitive that should be avoided\n  in user code. Use the 'locking' macro." }), Symbol.intern(null, "def"), RT.map(new Object[] { RT.keyword(null, "forms"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "def"), Symbol.intern(null, "symbol"), Symbol.intern(null, "doc-string?"), Symbol.intern(null, "init?") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(27), RT.keyword(null, "column"), Integer.valueOf(18) }))), RT.keyword(null, "doc"), "Creates and interns a global var with the name\n  of symbol in the current namespace (*ns*) or locates such a var if\n  it already exists.  If init is supplied, it is evaluated, and the\n  root binding of the var is set to the resulting value.  If init is\n  not supplied, the root binding of the var is unaffected." }) });
    const__15 = (Var)RT.var("clojure.repl", "special-doc");
    const__19 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name-symbol")) })), RT.keyword(null, "line"), Integer.valueOf(75), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/repl.clj" });
    const__20 = (Var)RT.var("clojure.repl", "namespace-doc");
    const__23 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "nspace")) })), RT.keyword(null, "line"), Integer.valueOf(80), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/repl.clj" });
    const__24 = (Var)RT.var("clojure.repl", "print-doc");
    const__27 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.map(new Object[] { Symbol.intern(null, "n"), RT.keyword(null, "ns"), Symbol.intern(null, "nm"), RT.keyword(null, "name"), RT.keyword(null, "keys"), RT.vector(new Object[] { Symbol.intern(null, "forms"), Symbol.intern(null, "arglists"), Symbol.intern(null, "special-form"), Symbol.intern(null, "doc"), Symbol.intern(null, "url"), Symbol.intern(null, "macro"), Symbol.intern(null, "spec") }), RT.keyword(null, "as"), Symbol.intern(null, "m") })) })), RT.keyword(null, "line"), Integer.valueOf(83), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/repl.clj" });
    const__28 = (Var)RT.var("clojure.repl", "find-doc");
    const__32 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "re-string-or-pattern")) })), RT.keyword(null, "doc"), "Prints documentation for any var whose documentation or name\n contains a match for re-string-or-pattern", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(116), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/repl.clj" });
    const__33 = (Var)RT.var("clojure.repl", "doc");
    const__36 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "name")) })), RT.keyword(null, "doc"), "Prints documentation for a var or special form given its name,\n   or for a spec if given a keyword", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(132), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/repl.clj" });
    const__37 = (Var)RT.var("clojure.repl", "source-fn");
    const__40 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Returns a string of the source code for the given symbol, if it can\n  find it.  This requires that the symbol resolve to a Var defined in\n  a namespace for which the .clj is in the classpath.  Returns nil if\n  it can't find the source.  For most REPL usage, 'source' is more\n  convenient.\n\n  Example: (source-fn 'filter)", RT.keyword(null, "line"), Integer.valueOf(148), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/repl.clj" });
    const__41 = (Var)RT.var("clojure.repl", "source");
    const__44 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "n")) })), RT.keyword(null, "doc"), "Prints the source code for the given symbol, if it can find it.\n  This requires that the symbol resolve to a Var defined in a\n  namespace for which the .clj is in the classpath.\n\n  Example: (source filter)", RT.keyword(null, "line"), Integer.valueOf(173), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/repl.clj" });
    const__45 = (Var)RT.var("clojure.repl", "apropos");
    const__48 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "str-or-pattern")) })), RT.keyword(null, "doc"), "Given a regular expression or stringable thing, return a seq of all\npublic definitions in all currently-loaded namespaces that match the\nstr-or-pattern.", RT.keyword(null, "line"), Integer.valueOf(182), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/repl.clj" });
    const__49 = (Var)RT.var("clojure.repl", "dir-fn");
    const__52 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ns")) })), RT.keyword(null, "doc"), "Returns a sorted seq of symbols naming public vars in\n  a namespace or namespace alias. Looks for aliases in *ns*", RT.keyword(null, "line"), Integer.valueOf(196), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/repl.clj" });
    const__53 = (Var)RT.var("clojure.repl", "dir");
    const__56 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "nsname")) })), RT.keyword(null, "doc"), "Prints a sorted directory of public vars in a namespace", RT.keyword(null, "line"), Integer.valueOf(202), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/repl.clj" });
    const__57 = (Var)RT.var("clojure.repl", "demunge");
    const__60 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "fn-name")) })), RT.keyword(null, "doc"), "Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.", RT.keyword(null, "added"), "1.3", RT.keyword(null, "line"), Integer.valueOf(208), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/repl.clj" });
    const__61 = (Var)RT.var("clojure.repl", "root-cause");
    const__64 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "t")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Throwable") }))) })), RT.keyword(null, "doc"), "Returns the initial cause of an exception or error by peeling off all of\n  its wrappers", RT.keyword(null, "added"), "1.3", RT.keyword(null, "line"), Integer.valueOf(215), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/repl.clj" });
    const__65 = (Var)RT.var("clojure.repl", "stack-element-str");
    const__68 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "el")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "StackTraceElement") }))) })), RT.keyword(null, "doc"), "Returns a (possibly unmunged) string representation of a StackTraceElement", RT.keyword(null, "added"), "1.3", RT.keyword(null, "line"), Integer.valueOf(228), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/repl.clj" });
    const__69 = (Var)RT.var("clojure.repl", "pst");
    const__72 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "e-or-depth")), Tuple.create(((IObj)Symbol.intern(null, "e")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Throwable") })), Symbol.intern(null, "depth")) })), RT.keyword(null, "doc"), "Prints a stack trace of the exception, to the depth requested. If none supplied, uses the root cause of the\n  most recent repl exception (*e), and a depth of 12.", RT.keyword(null, "added"), "1.3", RT.keyword(null, "line"), Integer.valueOf(241), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/repl.clj" });
    const__73 = (Var)RT.var("clojure.repl", "thread-stopper");
    const__76 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "thread")) })), RT.keyword(null, "doc"), "Returns a function that takes one arg and uses that as an exception message\n  to stop the given thread.  Defaults to the current thread", RT.keyword(null, "line"), Integer.valueOf(274), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/repl.clj" });
    const__77 = (Var)RT.var("clojure.repl", "set-break-handler!");
    const__80 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "f")) })), RT.keyword(null, "doc"), "Register INT signal handler.  After calling this, Ctrl-C will cause\n  the given function f to be called with a single argument, the signal.\n  Uses thread-stopper if no function given.", RT.keyword(null, "line"), Integer.valueOf(280), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/repl.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("clojure.repl__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
