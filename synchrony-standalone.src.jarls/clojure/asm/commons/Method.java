package clojure.asm.commons;

import clojure.asm.Type;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

public class Method {
  private final String name;
  
  private final String descriptor;
  
  private static final Map<String, String> PRIMITIVE_TYPE_DESCRIPTORS;
  
  static  {
    descriptors = new HashMap();
    descriptors.put("void", "V");
    descriptors.put("byte", "B");
    descriptors.put("char", "C");
    descriptors.put("double", "D");
    descriptors.put("float", "F");
    descriptors.put("int", "I");
    descriptors.put("long", "J");
    descriptors.put("short", "S");
    descriptors.put("boolean", "Z");
    PRIMITIVE_TYPE_DESCRIPTORS = descriptors;
  }
  
  public Method(String name, String descriptor) {
    this.name = name;
    this.descriptor = descriptor;
  }
  
  public Method(String name, Type returnType, Type[] argumentTypes) { this(name, Type.getMethodDescriptor(returnType, argumentTypes)); }
  
  public static Method getMethod(Method method) { return new Method(method.getName(), Type.getMethodDescriptor(method)); }
  
  public static Method getMethod(Constructor<?> constructor) { return new Method("<init>", Type.getConstructorDescriptor(constructor)); }
  
  public static Method getMethod(String method) { return getMethod(method, false); }
  
  public static Method getMethod(String method, boolean defaultPackage) {
    int currentArgumentEndIndex, spaceIndex = method.indexOf(' ');
    int currentArgumentStartIndex = method.indexOf('(', spaceIndex) + 1;
    int endIndex = method.indexOf(')', currentArgumentStartIndex);
    if (spaceIndex == -1 || currentArgumentStartIndex == 0 || endIndex == -1)
      throw new IllegalArgumentException(); 
    String returnType = method.substring(0, spaceIndex);
    String methodName = method.substring(spaceIndex + 1, currentArgumentStartIndex - 1).trim();
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append('(');
    do {
      String argumentDescriptor;
      currentArgumentEndIndex = method.indexOf(',', currentArgumentStartIndex);
      if (currentArgumentEndIndex == -1) {
        argumentDescriptor = getDescriptor(method
            .substring(currentArgumentStartIndex, endIndex).trim(), defaultPackage);
      } else {
        argumentDescriptor = getDescriptor(method
            .substring(currentArgumentStartIndex, currentArgumentEndIndex).trim(), defaultPackage);
        currentArgumentStartIndex = currentArgumentEndIndex + 1;
      } 
      stringBuilder.append(argumentDescriptor);
    } while (currentArgumentEndIndex != -1);
    stringBuilder.append(')');
    stringBuilder.append(getDescriptor(returnType, defaultPackage));
    return new Method(methodName, stringBuilder.toString());
  }
  
  private static String getDescriptor(String type, boolean defaultPackage) {
    if ("".equals(type))
      return type; 
    StringBuilder stringBuilder = new StringBuilder();
    int arrayBracketsIndex = 0;
    while ((arrayBracketsIndex = type.indexOf("[]", arrayBracketsIndex) + 1) > 0)
      stringBuilder.append('['); 
    String elementType = type.substring(0, type.length() - stringBuilder.length() * 2);
    String descriptor = (String)PRIMITIVE_TYPE_DESCRIPTORS.get(elementType);
    if (descriptor != null) {
      stringBuilder.append(descriptor);
    } else {
      stringBuilder.append('L');
      if (elementType.indexOf('.') < 0) {
        if (!defaultPackage)
          stringBuilder.append("java/lang/"); 
        stringBuilder.append(elementType);
      } else {
        stringBuilder.append(elementType.replace('.', '/'));
      } 
      stringBuilder.append(';');
    } 
    return stringBuilder.toString();
  }
  
  public String getName() { return this.name; }
  
  public String getDescriptor() { return this.descriptor; }
  
  public Type getReturnType() { return Type.getReturnType(this.descriptor); }
  
  public Type[] getArgumentTypes() { return Type.getArgumentTypes(this.descriptor); }
  
  public String toString() { return this.name + this.descriptor; }
  
  public boolean equals(Object other) {
    if (!(other instanceof Method))
      return false; 
    Method otherMethod = (Method)other;
    return (this.name.equals(otherMethod.name) && this.descriptor.equals(otherMethod.descriptor));
  }
  
  public int hashCode() { return this.name.hashCode() ^ this.descriptor.hashCode(); }
}
