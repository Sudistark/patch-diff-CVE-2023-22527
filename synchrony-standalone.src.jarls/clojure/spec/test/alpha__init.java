package clojure.spec.test;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;

public class alpha__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__2;
  
  public static final AFn const__3;
  
  public static final AFn const__4;
  
  public static final Var const__5;
  
  public static final AFn const__6;
  
  public static final AFn const__7;
  
  public static final Var const__8;
  
  public static final AFn const__17;
  
  public static final Var const__18;
  
  public static final AFn const__21;
  
  public static final Var const__22;
  
  public static final AFn const__25;
  
  public static final Var const__26;
  
  public static final AFn const__29;
  
  public static final Var const__30;
  
  public static final AFn const__34;
  
  public static final Var const__35;
  
  public static final AFn const__38;
  
  public static final Var const__39;
  
  public static final AFn const__42;
  
  public static final Var const__43;
  
  public static final AFn const__46;
  
  public static final Var const__47;
  
  public static final AFn const__50;
  
  public static final Var const__51;
  
  public static final AFn const__54;
  
  public static final Var const__55;
  
  public static final AFn const__58;
  
  public static final Var const__59;
  
  public static final AFn const__62;
  
  public static final Var const__63;
  
  public static final AFn const__66;
  
  public static final Var const__67;
  
  public static final AFn const__70;
  
  public static final Var const__71;
  
  public static final AFn const__74;
  
  public static final Var const__75;
  
  public static final AFn const__78;
  
  public static final Var const__79;
  
  public static final AFn const__82;
  
  public static final Var const__83;
  
  public static final AFn const__86;
  
  public static final Var const__87;
  
  public static final AFn const__90;
  
  public static final Var const__91;
  
  public static final AFn const__94;
  
  public static final Var const__95;
  
  public static final AFn const__98;
  
  public static final Var const__99;
  
  public static final AFn const__102;
  
  public static final Var const__103;
  
  public static final AFn const__106;
  
  public static final Var const__107;
  
  public static final AFn const__110;
  
  public static final Var const__111;
  
  public static final AFn const__114;
  
  public static final Var const__115;
  
  public static final AFn const__118;
  
  public static final Var const__119;
  
  public static final AFn const__122;
  
  public static final Var const__123;
  
  public static final AFn const__126;
  
  public static final Var const__127;
  
  public static final AFn const__130;
  
  public static final Var const__131;
  
  public static final AFn const__134;
  
  public static final Var const__135;
  
  public static final AFn const__138;
  
  public static final Var const__139;
  
  public static final AFn const__142;
  
  public static final Var const__143;
  
  public static final AFn const__146;
  
  public static final Var const__147;
  
  public static final AFn const__150;
  
  public static final Var const__151;
  
  public static final AFn const__154;
  
  public static final Var const__155;
  
  public static final AFn const__158;
  
  public static void load() { // Byte code:
    //   0: getstatic clojure/spec/test/alpha__init.const__0 : Lclojure/lang/Var;
    //   3: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   6: checkcast clojure/lang/IFn
    //   9: getstatic clojure/spec/test/alpha__init.const__1 : Lclojure/lang/AFn;
    //   12: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   17: new clojure/spec/test/alpha$loading__6434__auto____2987
    //   20: dup
    //   21: invokespecial <init> : ()V
    //   24: checkcast clojure/lang/IFn
    //   27: invokeinterface invoke : ()Ljava/lang/Object;
    //   32: getstatic clojure/spec/test/alpha__init.const__1 : Lclojure/lang/AFn;
    //   35: checkcast clojure/lang/Symbol
    //   38: getstatic clojure/spec/test/alpha__init.const__2 : Lclojure/lang/AFn;
    //   41: invokevirtual equals : (Ljava/lang/Object;)Z
    //   44: ifeq -> 52
    //   47: aconst_null
    //   48: goto -> 67
    //   51: pop
    //   52: new clojure/spec/test/alpha$fn__2989
    //   55: dup
    //   56: invokespecial <init> : ()V
    //   59: checkcast java/util/concurrent/Callable
    //   62: invokestatic runInTransaction : (Ljava/util/concurrent/Callable;)Ljava/lang/Object;
    //   65: pop
    //   66: aconst_null
    //   67: getstatic clojure/spec/test/alpha__init.const__0 : Lclojure/lang/Var;
    //   70: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   73: checkcast clojure/lang/IFn
    //   76: getstatic clojure/spec/test/alpha__init.const__3 : Lclojure/lang/AFn;
    //   79: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   84: getstatic clojure/spec/test/alpha__init.const__0 : Lclojure/lang/Var;
    //   87: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   90: checkcast clojure/lang/IFn
    //   93: getstatic clojure/spec/test/alpha__init.const__4 : Lclojure/lang/AFn;
    //   96: invokeinterface invoke : (Ljava/lang/Object;)Ljava/lang/Object;
    //   101: getstatic clojure/spec/test/alpha__init.const__5 : Lclojure/lang/Var;
    //   104: invokevirtual getRawRoot : ()Ljava/lang/Object;
    //   107: checkcast clojure/lang/IFn
    //   110: getstatic clojure/spec/test/alpha__init.const__6 : Lclojure/lang/AFn;
    //   113: getstatic clojure/spec/test/alpha__init.const__7 : Lclojure/lang/AFn;
    //   116: invokeinterface invoke : (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    //   121: getstatic clojure/spec/test/alpha__init.const__8 : Lclojure/lang/Var;
    //   124: dup
    //   125: getstatic clojure/spec/test/alpha__init.const__17 : Lclojure/lang/AFn;
    //   128: checkcast clojure/lang/IPersistentMap
    //   131: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   134: dup
    //   135: new clojure/spec/test/alpha$throwable_QMARK_
    //   138: dup
    //   139: invokespecial <init> : ()V
    //   142: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   145: getstatic clojure/spec/test/alpha__init.const__18 : Lclojure/lang/Var;
    //   148: dup
    //   149: getstatic clojure/spec/test/alpha__init.const__21 : Lclojure/lang/AFn;
    //   152: checkcast clojure/lang/IPersistentMap
    //   155: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   158: dup
    //   159: new clojure/spec/test/alpha$__GT_sym
    //   162: dup
    //   163: invokespecial <init> : ()V
    //   166: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   169: getstatic clojure/spec/test/alpha__init.const__22 : Lclojure/lang/Var;
    //   172: dup
    //   173: getstatic clojure/spec/test/alpha__init.const__25 : Lclojure/lang/AFn;
    //   176: checkcast clojure/lang/IPersistentMap
    //   179: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   182: dup
    //   183: new clojure/spec/test/alpha$__GT_var
    //   186: dup
    //   187: invokespecial <init> : ()V
    //   190: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   193: getstatic clojure/spec/test/alpha__init.const__26 : Lclojure/lang/Var;
    //   196: dup
    //   197: getstatic clojure/spec/test/alpha__init.const__29 : Lclojure/lang/AFn;
    //   200: checkcast clojure/lang/IPersistentMap
    //   203: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   206: dup
    //   207: new clojure/spec/test/alpha$collectionize
    //   210: dup
    //   211: invokespecial <init> : ()V
    //   214: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   217: getstatic clojure/spec/test/alpha__init.const__30 : Lclojure/lang/Var;
    //   220: dup
    //   221: getstatic clojure/spec/test/alpha__init.const__34 : Lclojure/lang/AFn;
    //   224: checkcast clojure/lang/IPersistentMap
    //   227: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   230: dup
    //   231: new clojure/spec/test/alpha$enumerate_namespace
    //   234: dup
    //   235: invokespecial <init> : ()V
    //   238: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   241: getstatic clojure/spec/test/alpha__init.const__35 : Lclojure/lang/Var;
    //   244: iconst_1
    //   245: invokevirtual setDynamic : (Z)Lclojure/lang/Var;
    //   248: dup
    //   249: getstatic clojure/spec/test/alpha__init.const__38 : Lclojure/lang/AFn;
    //   252: checkcast clojure/lang/IPersistentMap
    //   255: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   258: dup
    //   259: getstatic java/lang/Boolean.TRUE : Ljava/lang/Boolean;
    //   262: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   265: getstatic clojure/spec/test/alpha__init.const__39 : Lclojure/lang/Var;
    //   268: dup
    //   269: getstatic clojure/spec/test/alpha__init.const__42 : Lclojure/lang/AFn;
    //   272: checkcast clojure/lang/IPersistentMap
    //   275: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   278: dup
    //   279: new clojure/spec/test/alpha$fn_spec_QMARK_
    //   282: dup
    //   283: invokespecial <init> : ()V
    //   286: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   289: getstatic clojure/spec/test/alpha__init.const__43 : Lclojure/lang/Var;
    //   292: dup
    //   293: getstatic clojure/spec/test/alpha__init.const__46 : Lclojure/lang/AFn;
    //   296: checkcast clojure/lang/IPersistentMap
    //   299: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   302: dup
    //   303: new clojure/spec/test/alpha$with_instrument_disabled
    //   306: dup
    //   307: invokespecial <init> : ()V
    //   310: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   313: getstatic clojure/spec/test/alpha__init.const__43 : Lclojure/lang/Var;
    //   316: checkcast clojure/lang/Var
    //   319: invokevirtual setMacro : ()V
    //   322: aconst_null
    //   323: getstatic clojure/spec/test/alpha__init.const__43 : Lclojure/lang/Var;
    //   326: getstatic clojure/spec/test/alpha__init.const__47 : Lclojure/lang/Var;
    //   329: dup
    //   330: getstatic clojure/spec/test/alpha__init.const__50 : Lclojure/lang/AFn;
    //   333: checkcast clojure/lang/IPersistentMap
    //   336: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   339: dup
    //   340: new clojure/spec/test/alpha$interpret_stack_trace_element
    //   343: dup
    //   344: invokespecial <init> : ()V
    //   347: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   350: getstatic clojure/spec/test/alpha__init.const__51 : Lclojure/lang/Var;
    //   353: dup
    //   354: getstatic clojure/spec/test/alpha__init.const__54 : Lclojure/lang/AFn;
    //   357: checkcast clojure/lang/IPersistentMap
    //   360: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   363: dup
    //   364: new clojure/spec/test/alpha$stacktrace_relevant_to_instrument
    //   367: dup
    //   368: invokespecial <init> : ()V
    //   371: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   374: getstatic clojure/spec/test/alpha__init.const__55 : Lclojure/lang/Var;
    //   377: dup
    //   378: getstatic clojure/spec/test/alpha__init.const__58 : Lclojure/lang/AFn;
    //   381: checkcast clojure/lang/IPersistentMap
    //   384: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   387: dup
    //   388: new clojure/spec/test/alpha$spec_checking_fn
    //   391: dup
    //   392: invokespecial <init> : ()V
    //   395: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   398: getstatic clojure/spec/test/alpha__init.const__59 : Lclojure/lang/Var;
    //   401: dup
    //   402: getstatic clojure/spec/test/alpha__init.const__62 : Lclojure/lang/AFn;
    //   405: checkcast clojure/lang/IPersistentMap
    //   408: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   411: dup
    //   412: new clojure/spec/test/alpha$no_fspec
    //   415: dup
    //   416: invokespecial <init> : ()V
    //   419: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   422: new clojure/spec/test/alpha$fn__3030
    //   425: dup
    //   426: invokespecial <init> : ()V
    //   429: checkcast clojure/lang/IFn
    //   432: invokeinterface invoke : ()Ljava/lang/Object;
    //   437: getstatic clojure/spec/test/alpha__init.const__63 : Lclojure/lang/Var;
    //   440: dup
    //   441: getstatic clojure/spec/test/alpha__init.const__66 : Lclojure/lang/AFn;
    //   444: checkcast clojure/lang/IPersistentMap
    //   447: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   450: dup
    //   451: new clojure/spec/test/alpha$instrument_choose_fn
    //   454: dup
    //   455: invokespecial <init> : ()V
    //   458: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   461: getstatic clojure/spec/test/alpha__init.const__67 : Lclojure/lang/Var;
    //   464: dup
    //   465: getstatic clojure/spec/test/alpha__init.const__70 : Lclojure/lang/AFn;
    //   468: checkcast clojure/lang/IPersistentMap
    //   471: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   474: dup
    //   475: new clojure/spec/test/alpha$instrument_choose_spec
    //   478: dup
    //   479: invokespecial <init> : ()V
    //   482: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   485: getstatic clojure/spec/test/alpha__init.const__71 : Lclojure/lang/Var;
    //   488: dup
    //   489: getstatic clojure/spec/test/alpha__init.const__74 : Lclojure/lang/AFn;
    //   492: checkcast clojure/lang/IPersistentMap
    //   495: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   498: dup
    //   499: new clojure/spec/test/alpha$instrument_1
    //   502: dup
    //   503: invokespecial <init> : ()V
    //   506: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   509: getstatic clojure/spec/test/alpha__init.const__75 : Lclojure/lang/Var;
    //   512: dup
    //   513: getstatic clojure/spec/test/alpha__init.const__78 : Lclojure/lang/AFn;
    //   516: checkcast clojure/lang/IPersistentMap
    //   519: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   522: dup
    //   523: new clojure/spec/test/alpha$unstrument_1
    //   526: dup
    //   527: invokespecial <init> : ()V
    //   530: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   533: getstatic clojure/spec/test/alpha__init.const__79 : Lclojure/lang/Var;
    //   536: dup
    //   537: getstatic clojure/spec/test/alpha__init.const__82 : Lclojure/lang/AFn;
    //   540: checkcast clojure/lang/IPersistentMap
    //   543: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   546: dup
    //   547: new clojure/spec/test/alpha$opt_syms
    //   550: dup
    //   551: invokespecial <init> : ()V
    //   554: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   557: getstatic clojure/spec/test/alpha__init.const__83 : Lclojure/lang/Var;
    //   560: dup
    //   561: getstatic clojure/spec/test/alpha__init.const__86 : Lclojure/lang/AFn;
    //   564: checkcast clojure/lang/IPersistentMap
    //   567: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   570: dup
    //   571: new clojure/spec/test/alpha$fn_spec_name_QMARK_
    //   574: dup
    //   575: invokespecial <init> : ()V
    //   578: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   581: getstatic clojure/spec/test/alpha__init.const__87 : Lclojure/lang/Var;
    //   584: dup
    //   585: getstatic clojure/spec/test/alpha__init.const__90 : Lclojure/lang/AFn;
    //   588: checkcast clojure/lang/IPersistentMap
    //   591: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   594: dup
    //   595: new clojure/spec/test/alpha$instrumentable_syms
    //   598: dup
    //   599: invokespecial <init> : ()V
    //   602: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   605: getstatic clojure/spec/test/alpha__init.const__91 : Lclojure/lang/Var;
    //   608: dup
    //   609: getstatic clojure/spec/test/alpha__init.const__94 : Lclojure/lang/AFn;
    //   612: checkcast clojure/lang/IPersistentMap
    //   615: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   618: dup
    //   619: new clojure/spec/test/alpha$instrument
    //   622: dup
    //   623: invokespecial <init> : ()V
    //   626: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   629: getstatic clojure/spec/test/alpha__init.const__95 : Lclojure/lang/Var;
    //   632: dup
    //   633: getstatic clojure/spec/test/alpha__init.const__98 : Lclojure/lang/AFn;
    //   636: checkcast clojure/lang/IPersistentMap
    //   639: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   642: dup
    //   643: new clojure/spec/test/alpha$unstrument
    //   646: dup
    //   647: invokespecial <init> : ()V
    //   650: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   653: getstatic clojure/spec/test/alpha__init.const__99 : Lclojure/lang/Var;
    //   656: dup
    //   657: getstatic clojure/spec/test/alpha__init.const__102 : Lclojure/lang/AFn;
    //   660: checkcast clojure/lang/IPersistentMap
    //   663: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   666: dup
    //   667: new clojure/spec/test/alpha$explain_check
    //   670: dup
    //   671: invokespecial <init> : ()V
    //   674: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   677: getstatic clojure/spec/test/alpha__init.const__103 : Lclojure/lang/Var;
    //   680: dup
    //   681: getstatic clojure/spec/test/alpha__init.const__106 : Lclojure/lang/AFn;
    //   684: checkcast clojure/lang/IPersistentMap
    //   687: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   690: dup
    //   691: new clojure/spec/test/alpha$check_call
    //   694: dup
    //   695: invokespecial <init> : ()V
    //   698: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   701: getstatic clojure/spec/test/alpha__init.const__107 : Lclojure/lang/Var;
    //   704: dup
    //   705: getstatic clojure/spec/test/alpha__init.const__110 : Lclojure/lang/AFn;
    //   708: checkcast clojure/lang/IPersistentMap
    //   711: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   714: dup
    //   715: new clojure/spec/test/alpha$quick_check
    //   718: dup
    //   719: invokespecial <init> : ()V
    //   722: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   725: getstatic clojure/spec/test/alpha__init.const__111 : Lclojure/lang/Var;
    //   728: dup
    //   729: getstatic clojure/spec/test/alpha__init.const__114 : Lclojure/lang/AFn;
    //   732: checkcast clojure/lang/IPersistentMap
    //   735: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   738: dup
    //   739: new clojure/spec/test/alpha$make_check_result
    //   742: dup
    //   743: invokespecial <init> : ()V
    //   746: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   749: getstatic clojure/spec/test/alpha__init.const__115 : Lclojure/lang/Var;
    //   752: dup
    //   753: getstatic clojure/spec/test/alpha__init.const__118 : Lclojure/lang/AFn;
    //   756: checkcast clojure/lang/IPersistentMap
    //   759: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   762: dup
    //   763: new clojure/spec/test/alpha$check_1
    //   766: dup
    //   767: invokespecial <init> : ()V
    //   770: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   773: getstatic clojure/spec/test/alpha__init.const__119 : Lclojure/lang/Var;
    //   776: dup
    //   777: getstatic clojure/spec/test/alpha__init.const__122 : Lclojure/lang/AFn;
    //   780: checkcast clojure/lang/IPersistentMap
    //   783: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   786: dup
    //   787: new clojure/spec/test/alpha$sym__GT_check_map
    //   790: dup
    //   791: invokespecial <init> : ()V
    //   794: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   797: getstatic clojure/spec/test/alpha__init.const__123 : Lclojure/lang/Var;
    //   800: dup
    //   801: getstatic clojure/spec/test/alpha__init.const__126 : Lclojure/lang/AFn;
    //   804: checkcast clojure/lang/IPersistentMap
    //   807: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   810: dup
    //   811: new clojure/spec/test/alpha$validate_check_opts
    //   814: dup
    //   815: invokespecial <init> : ()V
    //   818: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   821: getstatic clojure/spec/test/alpha__init.const__127 : Lclojure/lang/Var;
    //   824: dup
    //   825: getstatic clojure/spec/test/alpha__init.const__130 : Lclojure/lang/AFn;
    //   828: checkcast clojure/lang/IPersistentMap
    //   831: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   834: dup
    //   835: new clojure/spec/test/alpha$check_fn
    //   838: dup
    //   839: invokespecial <init> : ()V
    //   842: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   845: getstatic clojure/spec/test/alpha__init.const__131 : Lclojure/lang/Var;
    //   848: dup
    //   849: getstatic clojure/spec/test/alpha__init.const__134 : Lclojure/lang/AFn;
    //   852: checkcast clojure/lang/IPersistentMap
    //   855: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   858: dup
    //   859: new clojure/spec/test/alpha$checkable_syms
    //   862: dup
    //   863: invokespecial <init> : ()V
    //   866: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   869: getstatic clojure/spec/test/alpha__init.const__135 : Lclojure/lang/Var;
    //   872: dup
    //   873: getstatic clojure/spec/test/alpha__init.const__138 : Lclojure/lang/AFn;
    //   876: checkcast clojure/lang/IPersistentMap
    //   879: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   882: dup
    //   883: new clojure/spec/test/alpha$check
    //   886: dup
    //   887: invokespecial <init> : ()V
    //   890: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   893: getstatic clojure/spec/test/alpha__init.const__139 : Lclojure/lang/Var;
    //   896: dup
    //   897: getstatic clojure/spec/test/alpha__init.const__142 : Lclojure/lang/AFn;
    //   900: checkcast clojure/lang/IPersistentMap
    //   903: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   906: dup
    //   907: new clojure/spec/test/alpha$failure_type
    //   910: dup
    //   911: invokespecial <init> : ()V
    //   914: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   917: getstatic clojure/spec/test/alpha__init.const__143 : Lclojure/lang/Var;
    //   920: dup
    //   921: getstatic clojure/spec/test/alpha__init.const__146 : Lclojure/lang/AFn;
    //   924: checkcast clojure/lang/IPersistentMap
    //   927: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   930: dup
    //   931: new clojure/spec/test/alpha$unwrap_failure
    //   934: dup
    //   935: invokespecial <init> : ()V
    //   938: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   941: getstatic clojure/spec/test/alpha__init.const__147 : Lclojure/lang/Var;
    //   944: dup
    //   945: getstatic clojure/spec/test/alpha__init.const__150 : Lclojure/lang/AFn;
    //   948: checkcast clojure/lang/IPersistentMap
    //   951: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   954: dup
    //   955: new clojure/spec/test/alpha$result_type
    //   958: dup
    //   959: invokespecial <init> : ()V
    //   962: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   965: getstatic clojure/spec/test/alpha__init.const__151 : Lclojure/lang/Var;
    //   968: dup
    //   969: getstatic clojure/spec/test/alpha__init.const__154 : Lclojure/lang/AFn;
    //   972: checkcast clojure/lang/IPersistentMap
    //   975: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   978: dup
    //   979: new clojure/spec/test/alpha$abbrev_result
    //   982: dup
    //   983: invokespecial <init> : ()V
    //   986: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   989: getstatic clojure/spec/test/alpha__init.const__155 : Lclojure/lang/Var;
    //   992: dup
    //   993: getstatic clojure/spec/test/alpha__init.const__158 : Lclojure/lang/AFn;
    //   996: checkcast clojure/lang/IPersistentMap
    //   999: invokevirtual setMeta : (Lclojure/lang/IPersistentMap;)V
    //   1002: dup
    //   1003: new clojure/spec/test/alpha$summarize_results
    //   1006: dup
    //   1007: invokespecial <init> : ()V
    //   1010: invokevirtual bindRoot : (Ljava/lang/Object;)V
    //   1013: return
    // Line number table:
    //   Java source line number -> byte code offset
    //   #9	-> 6
    //   #9	-> 12
    //   #9	-> 24
    //   #9	-> 27
    //   #9	-> 32
    //   #9	-> 41
    //   #9	-> 62
    //   #17	-> 73
    //   #17	-> 79
    //   #18	-> 90
    //   #18	-> 96
    //   #19	-> 107
    //   #19	-> 116
    //   #68	-> 319
    //   #150	-> 429
    //   #150	-> 432 }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "clojure.spec.test.alpha");
    const__2 = (AFn)Symbol.intern(null, "clojure.core");
    const__3 = (AFn)Symbol.intern(null, "clojure.spec.test.check");
    const__4 = (AFn)Symbol.intern(null, "clojure.spec.test.alpha");
    const__5 = (Var)RT.var("clojure.core", "alias");
    const__6 = (AFn)Symbol.intern(null, "stc");
    const__7 = (AFn)Symbol.intern(null, "clojure.spec.test.check");
    const__8 = (Var)RT.var("clojure.spec.test.alpha", "throwable?");
    const__17 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(21), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__18 = (Var)RT.var("clojure.spec.test.alpha", "->sym");
    const__21 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(25), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__22 = (Var)RT.var("clojure.spec.test.alpha", "->var");
    const__25 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s-or-v")) })), RT.keyword(null, "line"), Integer.valueOf(29), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__26 = (Var)RT.var("clojure.spec.test.alpha", "collectionize");
    const__29 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(38), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__30 = (Var)RT.var("clojure.spec.test.alpha", "enumerate-namespace");
    const__34 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ns-sym-or-syms")) })), RT.keyword(null, "doc"), "Given a symbol naming an ns, or a collection of such symbols,\nreturns the set of all symbols naming vars in those nses.", RT.keyword(null, "line"), Integer.valueOf(44), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__35 = (Var)RT.var("clojure.spec.test.alpha", "*instrument-enabled*");
    const__38 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "dynamic"), Boolean.TRUE, RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(59), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj", 
          RT.keyword(null, "doc"), "if false, instrumented fns call straight through" });
    const__39 = (Var)RT.var("clojure.spec.test.alpha", "fn-spec?");
    const__42 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "m")) })), RT.keyword(null, "doc"), "Fn-spec must include at least :args or :ret specs.", RT.keyword(null, "line"), Integer.valueOf(63), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__43 = (Var)RT.var("clojure.spec.test.alpha", "with-instrument-disabled");
    const__46 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "body")) })), RT.keyword(null, "doc"), "Disables instrument's checking of calls, within a scope.", RT.keyword(null, "line"), Integer.valueOf(68), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__47 = (Var)RT.var("clojure.spec.test.alpha", "interpret-stack-trace-element");
    const__50 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "cls"), Symbol.intern(null, "method"), Symbol.intern(null, "file"), Symbol.intern(null, "line"))) })), RT.keyword(null, "doc"), "Given the vector-of-syms form of a stacktrace element produced\nby e.g. Throwable->map, returns a map form that adds some keys\nguessing the original Clojure names. Returns a map with\n\n  :class         class name symbol from stack trace\n  :method        method symbol from stack trace\n  :file          filename from stack trace\n  :line          line number from stack trace\n  :var-scope     optional Clojure var symbol scoping fn def\n  :local-fn      optional local Clojure symbol scoping fn def\n\nFor non-Clojure fns, :scope and :local-fn will be absent.", RT.keyword(null, "line"), Integer.valueOf(74), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__51 = (Var)RT.var("clojure.spec.test.alpha", "stacktrace-relevant-to-instrument");
    const__54 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "elems")) })), RT.keyword(null, "doc"), "Takes a coll of stack trace elements (as returned by\nStackTraceElement->vec) and returns a coll of maps as per\ninterpret-stack-trace-element that are relevant to a\nfailure in instrument.", RT.keyword(null, "line"), Integer.valueOf(103), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__55 = (Var)RT.var("clojure.spec.test.alpha", "spec-checking-fn");
    const__58 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "v"), Symbol.intern(null, "f"), Symbol.intern(null, "fn-spec")) })), RT.keyword(null, "line"), Integer.valueOf(117), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__59 = (Var)RT.var("clojure.spec.test.alpha", "no-fspec");
    const__62 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "v"), Symbol.intern(null, "spec")) })), RT.keyword(null, "line"), Integer.valueOf(145), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__63 = (Var)RT.var("clojure.spec.test.alpha", "instrument-choose-fn");
    const__66 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "spec"), Symbol.intern(null, "sym"), RT.map(new Object[] { Symbol.intern(null, "over"), RT.keyword(null, "gen"), RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "stub"), Symbol.intern(null, "replace")) })) })), RT.keyword(null, "doc"), "Helper for instrument.", RT.keyword(null, "line"), Integer.valueOf(152), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__67 = (Var)RT.var("clojure.spec.test.alpha", "instrument-choose-spec");
    const__70 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "spec"), Symbol.intern(null, "sym"), RT.map(new Object[] { Symbol.intern(null, "overrides"), RT.keyword(null, "spec") })) })), RT.keyword(null, "doc"), "Helper for instrument", RT.keyword(null, "line"), Integer.valueOf(159), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__71 = (Var)RT.var("clojure.spec.test.alpha", "instrument-1");
    const__74 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s"), Symbol.intern(null, "opts")) })), RT.keyword(null, "line"), Integer.valueOf(164), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__75 = (Var)RT.var("clojure.spec.test.alpha", "unstrument-1");
    const__78 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "line"), Integer.valueOf(180), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__79 = (Var)RT.var("clojure.spec.test.alpha", "opt-syms");
    const__82 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Returns set of symbols referenced by 'instrument' opts map", RT.keyword(null, "line"), Integer.valueOf(190), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__83 = (Var)RT.var("clojure.spec.test.alpha", "fn-spec-name?");
    const__86 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "line"), Integer.valueOf(195), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__87 = (Var)RT.var("clojure.spec.test.alpha", "instrumentable-syms");
    const__90 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Given an opts map as per instrument, returns the set of syms\nthat can be instrumented.", RT.keyword(null, "line"), Integer.valueOf(200), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__91 = (Var)RT.var("clojure.spec.test.alpha", "instrument");
    const__94 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "sym-or-syms")), Tuple.create(Symbol.intern(null, "sym-or-syms"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Instruments the vars named by sym-or-syms, a symbol or collection\nof symbols, or all instrumentable vars if sym-or-syms is not\nspecified.\n\nIf a var has an :args fn-spec, sets the var's root binding to a\nfn that checks arg conformance (throwing an exception on failure)\nbefore delegating to the original fn.\n\nThe opts map can be used to override registered specs, and/or to\nreplace fn implementations entirely. Opts for symbols not included\nin sym-or-syms are ignored. This facilitates sharing a common\noptions map across many different calls to instrument.\n\nThe opts map may have the following keys:\n\n  :spec     a map from var-name symbols to override specs\n  :stub     a set of var-name symbols to be replaced by stubs\n  :gen      a map from spec names to generator overrides\n  :replace  a map from var-name symbols to replacement fns\n\n:spec overrides registered fn-specs with specs your provide. Use\n:spec overrides to provide specs for libraries that do not have\nthem, or to constrain your own use of a fn to a subset of its\nspec'ed contract.\n\n:stub replaces a fn with a stub that checks :args, then uses the\n:ret spec to generate a return value.\n\n:gen overrides are used only for :stub generation.\n\n:replace replaces a fn with a fn that checks args conformance, then\ninvokes the fn you provide, enabling arbitrary stubbing and mocking.\n\n:spec can be used in combination with :stub or :replace.\n\nReturns a collection of syms naming the vars instrumented.", RT.keyword(null, "line"), Integer.valueOf(211), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__95 = (Var)RT.var("clojure.spec.test.alpha", "unstrument");
    const__98 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "sym-or-syms")) })), RT.keyword(null, "doc"), "Undoes instrument on the vars named by sym-or-syms, specified\nas in instrument. With no args, unstruments all instrumented vars.\nReturns a collection of syms naming the vars unstrumented.", RT.keyword(null, "line"), Integer.valueOf(260), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__99 = (Var)RT.var("clojure.spec.test.alpha", "explain-check");
  }
  
  public static void __init1() {
    const__102 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "args"), Symbol.intern(null, "spec"), Symbol.intern(null, "v"), Symbol.intern(null, "role")) })), RT.keyword(null, "line"), Integer.valueOf(276), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__103 = (Var)RT.var("clojure.spec.test.alpha", "check-call");
    const__106 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "specs"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Returns true if call passes specs, otherwise *returns* an exception\nwith explain-data + ::s/failure.", RT.keyword(null, "line"), Integer.valueOf(286), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__107 = (Var)RT.var("clojure.spec.test.alpha", "quick-check");
    const__110 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "specs"), RT.map(new Object[] { Symbol.intern(null, "gen"), RT.keyword(null, "gen"), Symbol.intern(null, "opts"), RT.keyword("clojure.spec.test.check", "opts") })) })), RT.keyword(null, "line"), Integer.valueOf(303), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__111 = (Var)RT.var("clojure.spec.test.alpha", "make-check-result");
    const__114 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "check-sym"), Symbol.intern(null, "spec"), Symbol.intern(null, "test-check-ret")) })), RT.keyword(null, "doc"), "Builds spec result map.", RT.keyword(null, "line"), Integer.valueOf(312), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__115 = (Var)RT.var("clojure.spec.test.alpha", "check-1");
    const__118 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "s"), Symbol.intern(null, "f"), Symbol.intern(null, "v"), Symbol.intern(null, "spec")) }), Symbol.intern(null, "opts")) })), RT.keyword(null, "line"), Integer.valueOf(324), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__119 = (Var)RT.var("clojure.spec.test.alpha", "sym->check-map");
    const__122 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "s")) })), RT.keyword(null, "line"), Integer.valueOf(345), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__123 = (Var)RT.var("clojure.spec.test.alpha", "validate-check-opts");
    const__126 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "opts")) })), RT.keyword(null, "line"), Integer.valueOf(352), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__127 = (Var)RT.var("clojure.spec.test.alpha", "check-fn");
    const__130 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "spec")), Tuple.create(Symbol.intern(null, "f"), Symbol.intern(null, "spec"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Runs generative tests for fn f using spec and opts. See\n'check' for options and return.", RT.keyword(null, "line"), Integer.valueOf(356), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__131 = (Var)RT.var("clojure.spec.test.alpha", "checkable-syms");
    const__134 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Given an opts map as per check, returns the set of syms that\ncan be checked.", RT.keyword(null, "line"), Integer.valueOf(364), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__135 = (Var)RT.var("clojure.spec.test.alpha", "check");
    const__138 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "sym-or-syms")), Tuple.create(Symbol.intern(null, "sym-or-syms"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Run generative tests for spec conformance on vars named by\nsym-or-syms, a symbol or collection of symbols. If sym-or-syms\nis not specified, check all checkable vars.\n\nThe opts map includes the following optional keys, where stc\naliases clojure.spec.test.check: \n\n::stc/opts  opts to flow through test.check/quick-check\n:gen        map from spec names to generator overrides\n\nThe ::stc/opts include :num-tests in addition to the keys\ndocumented by test.check. Generator overrides are passed to\nspec/gen when generating function args.\n\nReturns a lazy sequence of check result maps with the following\nkeys\n\n:spec       the spec tested\n:sym        optional symbol naming the var tested\n:failure    optional test failure\n::stc/ret   optional value returned by test.check/quick-check\n\nThe value for :failure can be any exception. Exceptions thrown by\nspec itself will have an ::s/failure value in ex-data:\n\n:check-failed   at least one checked return did not conform\n:no-args-spec   no :args spec provided\n:no-fn          no fn provided\n:no-fspec       no fspec provided\n:no-gen         unable to generate :args\n:instrument     invalid args detected by instrument\n", RT.keyword(null, "line"), Integer.valueOf(373), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__139 = (Var)RT.var("clojure.spec.test.alpha", "failure-type");
    const__142 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(416), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__143 = (Var)RT.var("clojure.spec.test.alpha", "unwrap-failure");
    const__146 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(420), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__147 = (Var)RT.var("clojure.spec.test.alpha", "result-type");
    const__150 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "ret")) })), RT.keyword(null, "doc"), "Returns the type of the check result. This can be any of the\n::s/failure keywords documented in 'check', or:\n\n  :check-passed   all checked fn returns conformed\n  :check-threw    checked fn threw an exception", RT.keyword(null, "line"), Integer.valueOf(426), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__151 = (Var)RT.var("clojure.spec.test.alpha", "abbrev-result");
    const__154 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "doc"), "Given a check result, returns an abbreviated version\nsuitable for summary use.", RT.keyword(null, "line"), Integer.valueOf(439), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
    const__155 = (Var)RT.var("clojure.spec.test.alpha", "summarize-results");
    const__158 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "check-results")), Tuple.create(Symbol.intern(null, "check-results"), Symbol.intern(null, "summary-result")) })), RT.keyword(null, "doc"), "Given a collection of check-results, e.g. from 'check', pretty\nprints the summary-result (default abbrev-result) of each.\n\nReturns a map with :total, the total number of results, plus a\nkey with a count for each different :type of result.", RT.keyword(null, "line"), Integer.valueOf(449), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/spec/test/alpha.clj" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("clojure.spec.test.alpha__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
