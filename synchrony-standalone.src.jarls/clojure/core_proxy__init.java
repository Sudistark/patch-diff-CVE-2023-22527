package clojure;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;

public class core_proxy__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Var const__2;
  
  public static final AFn const__10;
  
  public static final Var const__11;
  
  public static final AFn const__15;
  
  public static final Var const__16;
  
  public static final AFn const__20;
  
  public static final Var const__21;
  
  public static final AFn const__26;
  
  public static final Var const__27;
  
  public static final AFn const__30;
  
  public static final Var const__31;
  
  public static final AFn const__34;
  
  public static final Var const__35;
  
  public static final AFn const__39;
  
  public static final Var const__40;
  
  public static final AFn const__43;
  
  public static final Var const__44;
  
  public static final AFn const__47;
  
  public static final Var const__48;
  
  public static final AFn const__51;
  
  public static final Var const__52;
  
  public static final AFn const__55;
  
  public static final Var const__56;
  
  public static final AFn const__59;
  
  public static final Var const__60;
  
  public static final AFn const__63;
  
  public static final Var const__64;
  
  public static final AFn const__67;
  
  public static final Var const__68;
  
  public static final AFn const__71;
  
  public static void load() {
    const__2.setMeta((IPersistentMap)const__10);
    const__2.bindRoot(new core.method_sig());
    const__11.setMeta((IPersistentMap)const__15);
    const__11.bindRoot(new core.most_specific());
    const__16.setMeta((IPersistentMap)const__20);
    const__16.bindRoot(new core.group_by_sig());
    const__21.setMeta((IPersistentMap)const__26);
    const__21.bindRoot(new core.proxy_name());
    const__27.setMeta((IPersistentMap)const__30);
    const__27.bindRoot(new core.generate_proxy());
    const__31.setMeta((IPersistentMap)const__34);
    const__31.bindRoot(new core.get_super_and_interfaces());
    const__35.setMeta((IPersistentMap)const__39);
    const__35.bindRoot(new core.get_proxy_class());
    const__40.setMeta((IPersistentMap)const__43);
    const__40.bindRoot(new core.construct_proxy());
    const__44.setMeta((IPersistentMap)const__47);
    const__44.bindRoot(new core.init_proxy());
    const__48.setMeta((IPersistentMap)const__51);
    const__48.bindRoot(new core.update_proxy());
    const__52.setMeta((IPersistentMap)const__55);
    const__52.bindRoot(new core.proxy_mappings());
    const__56.setMeta((IPersistentMap)const__59);
    const__56.bindRoot(new core.proxy());
    ((Var)const__56)






























































































































































































































































































































      
      .setMacro();
    const__60.setMeta((IPersistentMap)const__63);
    const__60.bindRoot(new core.proxy_call_with_super());
    const__64.setMeta((IPersistentMap)const__67);
    const__64.bindRoot(new core.proxy_super());
    ((Var)const__64)




























































      
      .setMacro();
    const__68.setMeta((IPersistentMap)const__71);
    const__68.bindRoot(new core.bean());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "clojure.core");
    const__2 = (Var)RT.var("clojure.core", "method-sig");
    const__10 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "meth")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.lang.reflect.Method") }))) })), RT.keyword(null, "line"), Integer.valueOf(20), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_proxy.clj" });
    const__11 = (Var)RT.var("clojure.core", "most-specific");
    const__15 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rtypes")) })), RT.keyword(null, "line"), Integer.valueOf(23), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_proxy.clj" });
    const__16 = (Var)RT.var("clojure.core", "group-by-sig");
    const__20 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll")) })), RT.keyword(null, "doc"), "Takes a collection of [msig meth] and returns a seq of maps from\n   return-types to meths.", RT.keyword(null, "line"), Integer.valueOf(27), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_proxy.clj" });
    const__21 = (Var)RT.var("clojure.core", "proxy-name");
    const__26 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "super")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") })), Symbol.intern(null, "interfaces")) })), RT.keyword(null, "tag"), RT.classForName("java.lang.String"), RT.keyword(null, "line"), Integer.valueOf(37), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_proxy.clj" });
    const__27 = (Var)RT.var("clojure.core", "generate-proxy");
    const__30 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "super")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") })), Symbol.intern(null, "interfaces")) })), RT.keyword(null, "line"), Integer.valueOf(48), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_proxy.clj" });
    const__31 = (Var)RT.var("clojure.core", "get-super-and-interfaces");
    const__34 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "bases")) })), RT.keyword(null, "line"), Integer.valueOf(271), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_proxy.clj" });
    const__35 = (Var)RT.var("clojure.core", "get-proxy-class");
    const__39 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "bases")) })), RT.keyword(null, "doc"), "Takes an optional single class followed by zero or more\n  interfaces. If not supplied class defaults to Object.  Creates an\n  returns an instance of a proxy class derived from the supplied\n  classes. The resulting value is cached and used for any subsequent\n  requests for the same class set. Returns a Class object.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(276), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_proxy.clj" });
    const__40 = (Var)RT.var("clojure.core", "construct-proxy");
    const__43 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "c"), Symbol.intern(null, "&"), Symbol.intern(null, "ctor-args")) })), RT.keyword(null, "doc"), "Takes a proxy class and any arguments for its superclass ctor and\n  creates and returns an instance of the proxy.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(290), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_proxy.clj" });
    const__44 = (Var)RT.var("clojure.core", "init-proxy");
    const__47 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "proxy")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IProxy") })), Symbol.intern(null, "mappings")) })), RT.keyword(null, "doc"), "Takes a proxy instance and a map of strings (which must\n  correspond to methods of the proxy superclass/superinterfaces) to\n  fns (which must take arguments matching the corresponding method,\n  plus an additional (explicit) first arg corresponding to this, and\n  sets the proxy's fn map.  Returns the proxy.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(297), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_proxy.clj" });
    const__48 = (Var)RT.var("clojure.core", "update-proxy");
    const__51 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "proxy")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IProxy") })), Symbol.intern(null, "mappings")) })), RT.keyword(null, "doc"), "Takes a proxy instance and a map of strings (which must\n  correspond to methods of the proxy superclass/superinterfaces) to\n  fns (which must take arguments matching the corresponding method,\n  plus an additional (explicit) first arg corresponding to this, and\n  updates (via assoc) the proxy's fn map. nil can be passed instead of\n  a fn, in which case the corresponding method will revert to the\n  default behavior. Note that this function can be used to update the\n  behavior of an existing instance without changing its identity.\n  Returns the proxy.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(308), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_proxy.clj" });
    const__52 = (Var)RT.var("clojure.core", "proxy-mappings");
    const__55 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "proxy")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "IProxy") }))) })), RT.keyword(null, "doc"), "Takes a proxy instance and returns the proxy's fn map.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(323), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_proxy.clj" });
    const__56 = (Var)RT.var("clojure.core", "proxy");
    const__59 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "class-and-interfaces"), Symbol.intern(null, "args"), Symbol.intern(null, "&"), Symbol.intern(null, "fs")) })), RT.keyword(null, "doc"), "class-and-interfaces - a vector of class names\n\n  args - a (possibly empty) vector of arguments to the superclass\n  constructor.\n\n  f => (name [params*] body) or\n  (name ([params*] body) ([params+] body) ...)\n\n  Expands to code which creates a instance of a proxy class that\n  implements the named class/interface(s) by calling the supplied\n  fns. A single class, if provided, must be first. If not provided it\n  defaults to Object.\n\n  The interfaces names must be valid interface types. If a method fn\n  is not provided for a class method, the superclass method will be\n  called. If a method fn is not provided for an interface method, an\n  UnsupportedOperationException will be thrown should it be\n  called. Method fns are closures and can capture the environment in\n  which proxy is called. Each method fn takes an additional implicit\n  first arg, which is bound to 'this. Note that while method fns can\n  be provided to override protected methods, they have no other access\n  to protected members, nor to super, as these capabilities cannot be\n  proxied.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(329), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_proxy.clj" });
    const__60 = (Var)RT.var("clojure.core", "proxy-call-with-super");
    const__63 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "call"), Symbol.intern(null, "this"), Symbol.intern(null, "meth")) })), RT.keyword(null, "line"), Integer.valueOf(384), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/core_proxy.clj" });
    const__64 = (Var)RT.var("clojure.core", "proxy-super");
    const__67 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "meth"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Use to call a superclass method in the body of a proxy method. \n  Note, expansion captures 'this", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(391), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_proxy.clj" });
    const__68 = (Var)RT.var("clojure.core", "bean");
    const__71 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "x")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Object") }))) })), RT.keyword(null, "doc"), "Takes a Java object and returns a read-only implementation of the\n  map abstraction based upon its JavaBean properties.", RT.keyword(null, "added"), "1.0", RT.keyword(null, "line"), Integer.valueOf(398), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/core_proxy.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("clojure.core_proxy__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
