package clojure.reflect;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import clojure.reflect;
import java.util.Arrays;

public class java__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final Var const__2;
  
  public static final AFn const__3;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final Var const__7;
  
  public static final Object const__8;
  
  public static final Var const__9;
  
  public static final Keyword const__10;
  
  public static final Object const__11;
  
  public static final Object const__12;
  
  public static final Var const__13;
  
  public static final Keyword const__17;
  
  public static final AFn const__23;
  
  public static final Var const__24;
  
  public static final AFn const__27;
  
  public static final Var const__28;
  
  public static final AFn const__31;
  
  public static final Var const__32;
  
  public static final AFn const__35;
  
  public static final Var const__36;
  
  public static final AFn const__39;
  
  public static final Var const__40;
  
  public static final AFn const__42;
  
  public static final Var const__43;
  
  public static final Var const__44;
  
  public static final AFn const__98;
  
  public static final Var const__99;
  
  public static final AFn const__102;
  
  public static final Var const__103;
  
  public static final AFn const__106;
  
  public static final Var const__107;
  
  public static final AFn const__110;
  
  public static final Var const__111;
  
  public static final AFn const__114;
  
  public static final Var const__115;
  
  public static final AFn const__118;
  
  public static final Var const__119;
  
  public static final AFn const__122;
  
  public static final Var const__123;
  
  public static final AFn const__126;
  
  public static final Var const__127;
  
  public static final AFn const__130;
  
  public static final Var const__131;
  
  public static final AFn const__133;
  
  public static final Var const__134;
  
  public static final AFn const__137;
  
  public static final Object const__138;
  
  public static final Var const__139;
  
  public static final Var const__140;
  
  public static final Var const__141;
  
  public static final Var const__142;
  
  public static final ISeq const__143;
  
  public static final Var const__144;
  
  public static final Var const__145;
  
  public static final AFn const__149;
  
  public static final Keyword const__150;
  
  public static final AFn const__151;
  
  public static final Keyword const__152;
  
  public static final Keyword const__153;
  
  public static final Keyword const__154;
  
  public static final AFn const__155;
  
  public static final Keyword const__156;
  
  public static final Var const__157;
  
  public static final Var const__158;
  
  public static final Var const__159;
  
  public static final AFn const__160;
  
  public static final AFn const__161;
  
  public static final Keyword const__162;
  
  public static final Var const__163;
  
  public static final AFn const__164;
  
  public static final Object const__165;
  
  public static final Object const__166;
  
  public static void load() {
    const__13.setMeta((IPersistentMap)const__23);
    const__13.bindRoot(new reflect.typesym());
    const__24.setMeta((IPersistentMap)const__27);
    const__24.bindRoot(new reflect.resource_name());
    const__28.setMeta((IPersistentMap)const__31);
    const__28.bindRoot(new reflect.access_flag());
    const__32.setMeta((IPersistentMap)const__35);
    const__32.bindRoot(new reflect.field_descriptor__GT_class_symbol());
    const__36.setMeta((IPersistentMap)const__39);
    const__36.bindRoot(new reflect.internal_name__GT_class_symbol());
    const__40.setMeta((IPersistentMap)const__42);
    const__40

























































      
      .bindRoot(((IFn)const__43.getRawRoot()).invoke(((IFn)const__44.getRawRoot())
          .invoke(const__28.getRawRoot(), const__98)));
    const__99.setMeta((IPersistentMap)const__102);
    const__99.bindRoot(new reflect.parse_flags());
    const__103.setMeta((IPersistentMap)const__106);
    const__103.bindRoot(new reflect.constructor__GT_map());
    const__107.setMeta((IPersistentMap)const__110);
    const__107.bindRoot(new reflect.declared_constructors());
    const__111.setMeta((IPersistentMap)const__114);
    const__111.bindRoot(new reflect.method__GT_map());
    const__115.setMeta((IPersistentMap)const__118);
    const__115.bindRoot(new reflect.declared_methods());
    const__119.setMeta((IPersistentMap)const__122);
    const__119.bindRoot(new reflect.field__GT_map());
    const__123.setMeta((IPersistentMap)const__126);
    const__123.bindRoot(new reflect.declared_fields());
    const__127.setMeta((IPersistentMap)const__130);
    const__127.bindRoot(new reflect.typeref__GT_class());
    const__131.setMeta((IPersistentMap)const__133);
    const__131









      
      .bindRoot(new JavaReflector(((Thread)Thread.currentThread()).getContextClassLoader()));
    const__134.setMeta((IPersistentMap)const__137);
    const__134.bindRoot(new reflect.parse_method_descriptor());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "clojure.reflect");
    const__2 = (Var)RT.var("clojure.core", "require");
    const__3 = (AFn)Tuple.create(Symbol.intern(null, "clojure.datafy"), RT.keyword(null, "refer"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "datafy") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(12), RT.keyword(null, "column"), Integer.valueOf(34) })));
    const__4 = (AFn)Tuple.create(Symbol.intern(null, "clojure.set"), RT.keyword(null, "as"), Symbol.intern(null, "set"));
    const__5 = (AFn)Tuple.create(Symbol.intern(null, "clojure.string"), RT.keyword(null, "as"), Symbol.intern(null, "str"));
    const__6 = (Var)RT.var("clojure.core", "*warn-on-reflection*");
    const__7 = (Var)RT.var("clojure.core", "extend");
    const__8 = RT.classForName("clojure.lang.Symbol");
    const__9 = (Var)RT.var("clojure.reflect", "TypeReference");
    const__10 = (Keyword)RT.keyword(null, "typename");
    const__11 = RT.classForName("java.lang.Class");
    const__12 = RT.classForName("clojure.asm.Type");
    const__13 = (Var)RT.var("clojure.reflect", "typesym");
    const__17 = (Keyword)RT.keyword(null, "doc");
    const__23 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "t")) })), RT.keyword(null, "doc"), "Given a typeref, create a legal Clojure symbol version of the\n   type's name.", RT.keyword(null, "line"), Integer.valueOf(36), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/reflect/java.clj" });
    const__24 = (Var)RT.var("clojure.reflect", "resource-name");
    const__27 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "typeref")) })), RT.keyword(null, "doc"), "Given a typeref, return implied resource name. Used by Reflectors\n   such as ASM that need to find and read classbytes from files.", RT.keyword(null, "line"), Integer.valueOf(47), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/reflect/java.clj" });
    const__28 = (Var)RT.var("clojure.reflect", "access-flag");
    const__31 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Tuple.create(Symbol.intern(null, "name"), Symbol.intern(null, "flag"), Symbol.intern(null, "&"), Symbol.intern(null, "contexts"))) })), RT.keyword(null, "line"), Integer.valueOf(55), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/reflect/java.clj" });
    const__32 = (Var)RT.var("clojure.reflect", "field-descriptor->class-symbol");
    const__35 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(((IObj)Symbol.intern(null, "d")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") })))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "pre"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "string?"), Symbol.intern(null, "d") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(64), RT.keyword(null, "column"), Integer.valueOf(10) }))) })) })), RT.keyword(null, "doc"), "Convert a Java field descriptor to a Clojure class symbol. Field\n   descriptors are described in section 4.3.2 of the JVM spec, 2nd ed.:\n   http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#14152", RT.keyword(null, "line"), Integer.valueOf(59), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/reflect/java.clj" });
    const__36 = (Var)RT.var("clojure.reflect", "internal-name->class-symbol");
    const__39 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "d"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "pre"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "string?"), Symbol.intern(null, "d") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(74), RT.keyword(null, "column"), Integer.valueOf(10) }))) })) })), RT.keyword(null, "doc"), "Convert a Java internal name to a Clojure class symbol. Internal\n   names uses slashes instead of dots, e.g. java/lang/String. See\n   Section 4.2 of the JVM spec, 2nd ed.:\n\n   http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#14757", RT.keyword(null, "line"), Integer.valueOf(67), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/reflect/java.clj" });
    const__40 = (Var)RT.var("clojure.reflect", "flag-descriptors");
    const__42 = (AFn)RT.map(new Object[] { RT.keyword(null, "doc"), "The Java access bitflags, along with their friendly names and\nthe kinds of objects to which they can apply.", RT.keyword(null, "line"), Integer.valueOf(77), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/reflect/java.clj" });
    const__43 = (Var)RT.var("clojure.core", "vec");
    const__44 = (Var)RT.var("clojure.core", "map");
    const__98 = (AFn)RT.vector(new Object[] { 
          Tuple.create(RT.keyword(null, "public"), Long.valueOf(1L), RT.keyword(null, "class"), RT.keyword(null, "field"), RT.keyword(null, "method")), Tuple.create(RT.keyword(null, "private"), Long.valueOf(2L), RT.keyword(null, "class"), RT.keyword(null, "field"), RT.keyword(null, "method")), Tuple.create(RT.keyword(null, "protected"), Long.valueOf(4L), RT.keyword(null, "class"), RT.keyword(null, "field"), RT.keyword(null, "method")), Tuple.create(RT.keyword(null, "static"), Long.valueOf(8L), RT.keyword(null, "field"), RT.keyword(null, "method")), Tuple.create(RT.keyword(null, "final"), Long.valueOf(16L), RT.keyword(null, "class"), RT.keyword(null, "field"), RT.keyword(null, "method")), Tuple.create(RT.keyword(null, "synchronized"), Long.valueOf(32L), RT.keyword(null, "method")), Tuple.create(RT.keyword(null, "volatile"), Long.valueOf(64L), RT.keyword(null, "field")), Tuple.create(RT.keyword(null, "bridge"), Long.valueOf(64L), RT.keyword(null, "method")), Tuple.create(RT.keyword(null, "varargs"), Long.valueOf(128L), RT.keyword(null, "method")), Tuple.create(RT.keyword(null, "transient"), Long.valueOf(128L), RT.keyword(null, "field")), 
          Tuple.create(RT.keyword(null, "native"), Long.valueOf(256L), RT.keyword(null, "method")), Tuple.create(RT.keyword(null, "interface"), Long.valueOf(512L), RT.keyword(null, "class")), Tuple.create(RT.keyword(null, "abstract"), Long.valueOf(1024L), RT.keyword(null, "class"), RT.keyword(null, "method")), Tuple.create(RT.keyword(null, "strict"), Long.valueOf(2048L), RT.keyword(null, "method")), Tuple.create(RT.keyword(null, "synthetic"), Long.valueOf(4096L), RT.keyword(null, "class"), RT.keyword(null, "field"), RT.keyword(null, "method")), Tuple.create(RT.keyword(null, "annotation"), Long.valueOf(8192L), RT.keyword(null, "class")), Tuple.create(RT.keyword(null, "enum"), Long.valueOf(16384L), RT.keyword(null, "class"), RT.keyword(null, "field"), RT.keyword(null, "inner")) });
    const__99 = (Var)RT.var("clojure.reflect", "parse-flags");
  }
  
  public static void __init1() {
    const__102 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "flags"), Symbol.intern(null, "context")) })), RT.keyword(null, "doc"), "Convert reflection bitflags into a set of keywords.", RT.keyword(null, "line"), Integer.valueOf(103), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/reflect/java.clj" });
    const__103 = (Var)RT.var("clojure.reflect", "constructor->map");
    const__106 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "constructor")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.lang.reflect.Constructor") }))) })), RT.keyword(null, "line"), Integer.valueOf(118), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/reflect/java.clj" });
    const__107 = (Var)RT.var("clojure.reflect", "declared-constructors");
    const__110 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "cls")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") }))) })), RT.keyword(null, "doc"), "Return a set of the declared constructors of class as a Clojure map.", RT.keyword(null, "line"), Integer.valueOf(127), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/reflect/java.clj" });
    const__111 = (Var)RT.var("clojure.reflect", "method->map");
    const__114 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "method")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.lang.reflect.Method") }))) })), RT.keyword(null, "line"), Integer.valueOf(137), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/reflect/java.clj" });
    const__115 = (Var)RT.var("clojure.reflect", "declared-methods");
    const__118 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "cls")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") }))) })), RT.keyword(null, "doc"), "Return a set of the declared constructors of class as a Clojure map.", RT.keyword(null, "line"), Integer.valueOf(147), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/reflect/java.clj" });
    const__119 = (Var)RT.var("clojure.reflect", "field->map");
    const__122 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "field")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.lang.reflect.Field") }))) })), RT.keyword(null, "line"), Integer.valueOf(157), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/reflect/java.clj" });
    const__123 = (Var)RT.var("clojure.reflect", "declared-fields");
    const__126 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "cls")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "Class") }))) })), RT.keyword(null, "doc"), "Return a set of the declared fields of class as a Clojure map.", RT.keyword(null, "line"), Integer.valueOf(165), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/reflect/java.clj" });
    const__127 = (Var)RT.var("clojure.reflect", "typeref->class");
    const__130 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "typeref"), Symbol.intern(null, "classloader"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "java.lang.Class") })) })), RT.keyword(null, "line"), Integer.valueOf(172), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/reflect/java.clj" });
    const__131 = (Var)RT.var("clojure.reflect", "default-reflector");
    const__133 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(188), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/reflect/java.clj" });
    const__134 = (Var)RT.var("clojure.reflect", "parse-method-descriptor");
    const__137 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "md")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "String") }))) })), RT.keyword(null, "line"), Integer.valueOf(191), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/reflect/java.clj" });
    const__138 = RT.classForName("clojure.reflect.ClassResolver");
    const__139 = (Var)RT.var("clojure.core", "alter-meta!");
    const__140 = (Var)RT.var("clojure.reflect", "ClassResolver");
    const__141 = (Var)RT.var("clojure.core", "assoc");
    const__142 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__143 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "resolve-class")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Given a class name, return that typeref's class bytes as an InputStream.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "name")) })) })) }));
    const__144 = (Var)RT.var("clojure.core", "alter-var-root");
    const__145 = (Var)RT.var("clojure.core", "merge");
    const__149 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "clojure.reflect.ClassResolver"), RT.keyword(null, "on-interface"), RT.classForName("clojure.reflect.ClassResolver") });
    const__150 = (Keyword)RT.keyword(null, "sigs");
    const__151 = (AFn)RT.map(new Object[] { RT.keyword(null, "resolve-class"), RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "InputStream"), RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "resolve-class")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Given a class name, return that typeref's class bytes as an InputStream.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "name")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "name")) })), RT.keyword(null, "doc"), "Given a class name, return that typeref's class bytes as an InputStream." }) });
    const__152 = (Keyword)RT.keyword(null, "var");
    const__153 = (Keyword)RT.keyword(null, "method-map");
    const__154 = (Keyword)RT.keyword(null, "resolve-class");
    const__155 = (AFn)RT.map(new Object[] { RT.keyword(null, "resolve-class"), RT.keyword(null, "resolve-class") });
    const__156 = (Keyword)RT.keyword(null, "method-builders");
    const__157 = (Var)RT.var("clojure.core", "intern");
    const__158 = (Var)RT.var("clojure.core", "*ns*");
    const__159 = (Var)RT.var("clojure.core", "with-meta");
    const__160 = (AFn)((IObj)Symbol.intern(null, "resolve-class")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Given a class name, return that typeref's class bytes as an InputStream.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "name")) })) }));
    const__161 = (AFn)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "InputStream"), RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "resolve-class")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Given a class name, return that typeref's class bytes as an InputStream.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "name")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "this"), Symbol.intern(null, "name")) })), RT.keyword(null, "doc"), "Given a class name, return that typeref's class bytes as an InputStream." });
    const__162 = (Keyword)RT.keyword(null, "protocol");
    const__163 = (Var)RT.var("clojure.core", "-reset-methods");
    const__164 = (AFn)Symbol.intern(null, "ClassResolver");
    const__165 = RT.classForName("clojure.lang.Fn");
    const__166 = RT.classForName("java.lang.ClassLoader");
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("clojure.reflect.java__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
