package clojure.data;

import clojure.data.priority_map.PersistentPriorityMap;
import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentArrayMap;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class priority_map__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final AFn const__13;
  
  public static final Var const__14;
  
  public static final AFn const__18;
  
  public static final AFn const__21;
  
  public static final Var const__22;
  
  public static final Var const__23;
  
  public static final AFn const__26;
  
  public static final Var const__27;
  
  public static final AFn const__30;
  
  public static final Var const__31;
  
  public static final AFn const__34;
  
  public static final Var const__35;
  
  public static final AFn const__38;
  
  public static final Var const__39;
  
  public static final AFn const__42;
  
  public static final Var const__43;
  
  public static final AFn const__46;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new priority_map.fn__1245());
    const__6.setMeta((IPersistentMap)const__13);
    const__14.setMeta((IPersistentMap)const__18);
    const__14.bindRoot(new priority_map.apply_keyfn());
    ((Var)const__14)
























































































































































































      
      .setMacro();
    const__6.setMeta((IPersistentMap)const__21);
    const__6


















































































































































































      
      .bindRoot(new PersistentPriorityMap(((IFn)const__22.getRawRoot()).invoke(), PersistentArrayMap.EMPTY, PersistentArrayMap.EMPTY, null));
    const__23.setMeta((IPersistentMap)const__26);
    const__23.bindRoot(new priority_map.pm_empty_by());
    const__27.setMeta((IPersistentMap)const__30);
    const__27.bindRoot(new priority_map.pm_empty_keyfn());
    const__31.setMeta((IPersistentMap)const__34);
    const__31.bindRoot(new priority_map.priority_map());
    const__35.setMeta((IPersistentMap)const__38);
    const__35.bindRoot(new priority_map.priority_map_by());
    const__39.setMeta((IPersistentMap)const__42);
    const__39.bindRoot(new priority_map.priority_map_keyfn());
    const__43.setMeta((IPersistentMap)const__46);
    const__43.bindRoot(new priority_map.priority_map_keyfn_by());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.data.priority-map")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "author"), "Mark Engelberg", RT.keyword(null, "doc"), "A priority map is very similar to a sorted map, but whereas a sorted map produces a\nsequence of the entries sorted by key, a priority map produces the entries sorted by value.\nIn addition to supporting all the functions a sorted map supports, a priority map\ncan also be thought of as a queue of [item priority] pairs.  To support usage as\na versatile priority queue, priority maps also support conj/peek/pop operations.\n\nThe standard way to construct a priority map is with priority-map:\nuser=> (def p (priority-map :a 2 :b 1 :c 3 :d 5 :e 4 :f 3))\n#'user/p\nuser=> p\n{:b 1, :a 2, :c 3, :f 3, :e 4, :d 5}\n\nSo :b has priority 1, :a has priority 2, and so on.\nNotice how the priority map prints in an order sorted by its priorities (i.e., the map's values)\n\nWe can use assoc to assign a priority to a new item:\nuser=> (assoc p :g 1)\n{:b 1, :g 1, :a 2, :c 3, :f 3, :e 4, :d 5}\n\nor to assign a new priority to an extant item:\nuser=> (assoc p :c 4)\n{:b 1, :a 2, :f 3, :c 4, :e 4, :d 5}\n\nWe can remove an item from the priority map:\nuser=> (dissoc p :e)\n{:b 1, :a 2, :c 3, :f 3, :d 5}\n\nAn alternative way to add to the priority map is to conj a [item priority] pair:\nuser=> (conj p [:g 0])\n{:g 0, :b 1, :a 2, :c 3, :f 3, :e 4, :d 5}\n\nor use into:\nuser=> (into p [[:g 0] [:h 1] [:i 2]])\n{:g 0, :b 1, :h 1, :a 2, :i 2, :c 3, :f 3, :e 4, :d 5}\n\nPriority maps are countable:\nuser=> (count p)\n6\n\nLike other maps, equivalence is based not on type, but on contents.\nIn other words, just as a sorted-map can be equal to a hash-map,\nso can a priority-map.\nuser=> (= p {:b 1, :a 2, :c 3, :f 3, :e 4, :d 5})\ntrue\n\nYou can test them for emptiness:\nuser=> (empty? (priority-map))\ntrue\nuser=> (empty? p)\nfalse\n\nYou can test whether an item is in the priority map:\nuser=> (contains? p :a)\ntrue\nuser=> (contains? p :g)\nfalse\n\nIt is easy to look up the priority of a given item, using any of the standard map mechanisms:\nuser=> (get p :a)\n2\nuser=> (get p :g 10)\n10\nuser=> (p :a)\n2\nuser=> (:a p)\n2\n\nPriority maps derive much of their utility by providing priority-based seq.\nNote that no guarantees are made about the order in which items of the same priority appear.\nuser=> (seq p)\n([:b 1] [:a 2] [:c 3] [:f 3] [:e 4] [:d 5])\nBecause no guarantees are made about the order of same-priority items, note that\nrseq might not be an exact reverse of the seq.  It is only guaranteed to be in\ndescending order.\nuser=> (rseq p)\n([:d 5] [:e 4] [:c 3] [:f 3] [:a 2] [:b 1])\n\nThis means first/rest/next/for/map/etc. all operate in priority order.\nuser=> (first p)\n[:b 1]\nuser=> (rest p)\n([:a 2] [:c 3] [:f 3] [:e 4] [:d 5])\n\nPriority maps support metadata:\nuser=> (meta (with-meta p {:extra :info}))\n{:extra :info}\n\nBut perhaps most importantly, priority maps can also function as priority queues.\npeek, like first, gives you the first [item priority] pair in the collection.\npop removes the first [item priority] from the collection.\n(Note that unlike rest, which returns a seq, pop returns a priority map).\n\nuser=> (peek p)\n[:b 1]\nuser=> (pop p)\n{:a 2, :c 3, :f 3, :e 4, :d 5}\n\nIt is also possible to use a custom comparator:\nuser=> (priority-map-by > :a 1 :b 2 :c 3)\n{:c 3, :b 2, :a 1}\n\nSometimes, it is desirable to have a map where the values contain more information\nthan just the priority.  For example, let's say you want a map like:\n{:a [2 :apple], :b [1 :banana], :c [3 :carrot]}\nand you want to sort the map by the numeric priority found in the pair.\n\nA common mistake is to try to solve this with a custom comparator:\n(priority-map \n  (fn [[priority1 _] [priority2 _]] (< priority1 priority2))\n  :a [2 :apple], :b [1 :banana], :c [3 :carrot])\n\nThis will not work!  In Clojure, like Java, all comparators must be total orders,\nmeaning that you can't have a tie unless the objects you are comparing are\nin fact equal.  The above comparator breaks that rule because\n[2 :apple] and [2 :apricot] tie, but are not equal.\n\nThe correct way to construct such a priority map is by specifying a keyfn, which is used\nto extract the true priority from the priority map's vals.  (Note: It might seem a little odd\nthat the priority-extraction function is called a *key*fn, even though it is applied to the\nmap's values.  This terminology is based on the docstring of clojure.core/sort-by, which\nuses `keyfn` for the function which extracts the sort order.) \n\nIn the above example,\n\nuser=> (priority-map-keyfn first :a [2 :apple], :b [1 :banana], :c [3 :carrot])\n{:b [1 :banana], :a [2 :apple], :c [3 :carrot]}\n\nYou can also combine a keyfn with a comparator that operates on the extracted priorities:\n\nuser=> (priority-map-keyfn-by \n          first >\n          :a [2 :apple], :b [1 :banana], :c [3 :carrot])\n{:c [3 :carrot], :a [2 :apple], :b [1 :banana]}\n\n \n\nAll of these operations are efficient.  Generally speaking, most operations\nare O(log n) where n is the number of distinct priorities.  Some operations\n(for example, straightforward lookup of an item's priority, or testing\nwhether a given item is in the priority map) are as efficient\nas Clojure's built-in map.\n\nThe key to this efficiency is that internally, not only does the priority map store\nan ordinary hash map of items to priority, but it also stores a sorted map that\nmaps priorities to sets of items with that priority.\n\nA typical textbook priority queue data structure supports at the ability to add\na [item priority] pair to the queue, and to pop/peek the next [item priority] pair.\nBut many real-world applications of priority queues require more features, such\nas the ability to test whether something is already in the queue, or to reassign\na priority.  For example, a standard formulation of Dijkstra's algorithm requires the\nability to reduce the priority number associated with a given item.  Once you\nthrow persistence into the mix with the desire to adjust priorities, the traditional\nstructures just don't work that well.\n\nThis particular blend of Clojure's built-in hash sets, hash maps, and sorted maps\nproved to be a great way to implement an especially flexible persistent priority queue.\n\nConnoisseurs of algorithms will note that this structure's peek operation is not O(1) as\nit would be if based upon a heap data structure, but I feel this is a small concession for\nthe blend of persistence, priority reassignment, and priority-sorted seq, which can be\nquite expensive to achieve with a heap (I did actually try this for comparison).  Furthermore,\nthis peek's logarithmic behavior is quite good (on my computer I can do a million\npeeks at a priority map with a million items in 750ms).  Also, consider that peek and pop\nusually follow one another, and even with a heap, pop is logarithmic.  So the net combination\nof peek and pop is not much different between this versatile formulation of a priority map and\na more limited heap-based one.  In a nutshell, peek, although not O(1), is unlikely to be the\nbottleneck in your program.\n\nAll in all, I hope you will find priority maps to be an easy-to-use and useful addition\nto Clojure's assortment of built-in maps (hash-map and sorted-map).\n" }));
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "author"), "Mark Engelberg", RT.keyword(null, "doc"), "A priority map is very similar to a sorted map, but whereas a sorted map produces a\nsequence of the entries sorted by key, a priority map produces the entries sorted by value.\nIn addition to supporting all the functions a sorted map supports, a priority map\ncan also be thought of as a queue of [item priority] pairs.  To support usage as\na versatile priority queue, priority maps also support conj/peek/pop operations.\n\nThe standard way to construct a priority map is with priority-map:\nuser=> (def p (priority-map :a 2 :b 1 :c 3 :d 5 :e 4 :f 3))\n#'user/p\nuser=> p\n{:b 1, :a 2, :c 3, :f 3, :e 4, :d 5}\n\nSo :b has priority 1, :a has priority 2, and so on.\nNotice how the priority map prints in an order sorted by its priorities (i.e., the map's values)\n\nWe can use assoc to assign a priority to a new item:\nuser=> (assoc p :g 1)\n{:b 1, :g 1, :a 2, :c 3, :f 3, :e 4, :d 5}\n\nor to assign a new priority to an extant item:\nuser=> (assoc p :c 4)\n{:b 1, :a 2, :f 3, :c 4, :e 4, :d 5}\n\nWe can remove an item from the priority map:\nuser=> (dissoc p :e)\n{:b 1, :a 2, :c 3, :f 3, :d 5}\n\nAn alternative way to add to the priority map is to conj a [item priority] pair:\nuser=> (conj p [:g 0])\n{:g 0, :b 1, :a 2, :c 3, :f 3, :e 4, :d 5}\n\nor use into:\nuser=> (into p [[:g 0] [:h 1] [:i 2]])\n{:g 0, :b 1, :h 1, :a 2, :i 2, :c 3, :f 3, :e 4, :d 5}\n\nPriority maps are countable:\nuser=> (count p)\n6\n\nLike other maps, equivalence is based not on type, but on contents.\nIn other words, just as a sorted-map can be equal to a hash-map,\nso can a priority-map.\nuser=> (= p {:b 1, :a 2, :c 3, :f 3, :e 4, :d 5})\ntrue\n\nYou can test them for emptiness:\nuser=> (empty? (priority-map))\ntrue\nuser=> (empty? p)\nfalse\n\nYou can test whether an item is in the priority map:\nuser=> (contains? p :a)\ntrue\nuser=> (contains? p :g)\nfalse\n\nIt is easy to look up the priority of a given item, using any of the standard map mechanisms:\nuser=> (get p :a)\n2\nuser=> (get p :g 10)\n10\nuser=> (p :a)\n2\nuser=> (:a p)\n2\n\nPriority maps derive much of their utility by providing priority-based seq.\nNote that no guarantees are made about the order in which items of the same priority appear.\nuser=> (seq p)\n([:b 1] [:a 2] [:c 3] [:f 3] [:e 4] [:d 5])\nBecause no guarantees are made about the order of same-priority items, note that\nrseq might not be an exact reverse of the seq.  It is only guaranteed to be in\ndescending order.\nuser=> (rseq p)\n([:d 5] [:e 4] [:c 3] [:f 3] [:a 2] [:b 1])\n\nThis means first/rest/next/for/map/etc. all operate in priority order.\nuser=> (first p)\n[:b 1]\nuser=> (rest p)\n([:a 2] [:c 3] [:f 3] [:e 4] [:d 5])\n\nPriority maps support metadata:\nuser=> (meta (with-meta p {:extra :info}))\n{:extra :info}\n\nBut perhaps most importantly, priority maps can also function as priority queues.\npeek, like first, gives you the first [item priority] pair in the collection.\npop removes the first [item priority] from the collection.\n(Note that unlike rest, which returns a seq, pop returns a priority map).\n\nuser=> (peek p)\n[:b 1]\nuser=> (pop p)\n{:a 2, :c 3, :f 3, :e 4, :d 5}\n\nIt is also possible to use a custom comparator:\nuser=> (priority-map-by > :a 1 :b 2 :c 3)\n{:c 3, :b 2, :a 1}\n\nSometimes, it is desirable to have a map where the values contain more information\nthan just the priority.  For example, let's say you want a map like:\n{:a [2 :apple], :b [1 :banana], :c [3 :carrot]}\nand you want to sort the map by the numeric priority found in the pair.\n\nA common mistake is to try to solve this with a custom comparator:\n(priority-map \n  (fn [[priority1 _] [priority2 _]] (< priority1 priority2))\n  :a [2 :apple], :b [1 :banana], :c [3 :carrot])\n\nThis will not work!  In Clojure, like Java, all comparators must be total orders,\nmeaning that you can't have a tie unless the objects you are comparing are\nin fact equal.  The above comparator breaks that rule because\n[2 :apple] and [2 :apricot] tie, but are not equal.\n\nThe correct way to construct such a priority map is by specifying a keyfn, which is used\nto extract the true priority from the priority map's vals.  (Note: It might seem a little odd\nthat the priority-extraction function is called a *key*fn, even though it is applied to the\nmap's values.  This terminology is based on the docstring of clojure.core/sort-by, which\nuses `keyfn` for the function which extracts the sort order.) \n\nIn the above example,\n\nuser=> (priority-map-keyfn first :a [2 :apple], :b [1 :banana], :c [3 :carrot])\n{:b [1 :banana], :a [2 :apple], :c [3 :carrot]}\n\nYou can also combine a keyfn with a comparator that operates on the extracted priorities:\n\nuser=> (priority-map-keyfn-by \n          first >\n          :a [2 :apple], :b [1 :banana], :c [3 :carrot])\n{:c [3 :carrot], :a [2 :apple], :b [1 :banana]}\n\n \n\nAll of these operations are efficient.  Generally speaking, most operations\nare O(log n) where n is the number of distinct priorities.  Some operations\n(for example, straightforward lookup of an item's priority, or testing\nwhether a given item is in the priority map) are as efficient\nas Clojure's built-in map.\n\nThe key to this efficiency is that internally, not only does the priority map store\nan ordinary hash map of items to priority, but it also stores a sorted map that\nmaps priorities to sets of items with that priority.\n\nA typical textbook priority queue data structure supports at the ability to add\na [item priority] pair to the queue, and to pop/peek the next [item priority] pair.\nBut many real-world applications of priority queues require more features, such\nas the ability to test whether something is already in the queue, or to reassign\na priority.  For example, a standard formulation of Dijkstra's algorithm requires the\nability to reduce the priority number associated with a given item.  Once you\nthrow persistence into the mix with the desire to adjust priorities, the traditional\nstructures just don't work that well.\n\nThis particular blend of Clojure's built-in hash sets, hash maps, and sorted maps\nproved to be a great way to implement an especially flexible persistent priority queue.\n\nConnoisseurs of algorithms will note that this structure's peek operation is not O(1) as\nit would be if based upon a heap data structure, but I feel this is a small concession for\nthe blend of persistence, priority reassignment, and priority-sorted seq, which can be\nquite expensive to achieve with a heap (I did actually try this for comparison).  Furthermore,\nthis peek's logarithmic behavior is quite good (on my computer I can do a million\npeeks at a priority map with a million items in 750ms).  Also, consider that peek and pop\nusually follow one another, and even with a heap, pop is logarithmic.  So the net combination\nof peek and pop is not much different between this versatile formulation of a priority map and\na more limited heap-based one.  In a nutshell, peek, although not O(1), is unlikely to be the\nbottleneck in your program.\n\nAll in all, I hope you will find priority maps to be an easy-to-use and useful addition\nto Clojure's assortment of built-in maps (hash-map and sorted-map).\n" });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.data.priority-map", "pm-empty");
    const__13 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(191), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/priority_map.clj" });
    const__14 = (Var)RT.var("clojure.data.priority-map", "apply-keyfn");
    const__18 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "x")) })), RT.keyword(null, "line"), Integer.valueOf(193), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/priority_map.clj" });
    const__21 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(383), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/priority_map.clj" });
    const__22 = (Var)RT.var("clojure.core", "sorted-map");
    const__23 = (Var)RT.var("clojure.data.priority-map", "pm-empty-by");
    const__26 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "comparator")) })), RT.keyword(null, "line"), Integer.valueOf(384), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/priority_map.clj" });
    const__27 = (Var)RT.var("clojure.data.priority-map", "pm-empty-keyfn");
    const__30 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "keyfn")), Tuple.create(Symbol.intern(null, "keyfn"), Symbol.intern(null, "comparator")) })), RT.keyword(null, "line"), Integer.valueOf(385), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/priority_map.clj" });
    const__31 = (Var)RT.var("clojure.data.priority-map", "priority-map");
    const__34 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "&"), Symbol.intern(null, "keyvals"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "pre"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "even?"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "count"), Symbol.intern(null, "keyvals") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(396), RT.keyword(null, "column"), Integer.valueOf(17) })) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(396), RT.keyword(null, "column"), Integer.valueOf(10) }))) })) })), RT.keyword(null, "doc"), "Usage: (priority-map key val key val ...)\nReturns a new priority map with optional supplied mappings.\n(priority-map) returns an empty priority map.", RT.keyword(null, "line"), Integer.valueOf(391), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/priority_map.clj" });
    const__35 = (Var)RT.var("clojure.data.priority-map", "priority-map-by");
    const__38 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "comparator"), Symbol.intern(null, "&"), Symbol.intern(null, "keyvals"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "pre"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "even?"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "count"), Symbol.intern(null, "keyvals") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(404), RT.keyword(null, "column"), Integer.valueOf(17) })) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(404), RT.keyword(null, "column"), Integer.valueOf(10) }))) })) })), RT.keyword(null, "doc"), "Usage: (priority-map comparator key val key val ...)\nReturns a new priority map with custom comparator and optional supplied mappings.\n(priority-map-by comparator) yields an empty priority map with custom comparator.", RT.keyword(null, "line"), Integer.valueOf(399), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/priority_map.clj" });
    const__39 = (Var)RT.var("clojure.data.priority-map", "priority-map-keyfn");
    const__42 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "keyfn"), Symbol.intern(null, "&"), Symbol.intern(null, "keyvals"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "pre"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "even?"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "count"), Symbol.intern(null, "keyvals") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(413), RT.keyword(null, "column"), Integer.valueOf(17) })) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(413), RT.keyword(null, "column"), Integer.valueOf(10) }))) })) })), RT.keyword(null, "doc"), "Usage: (priority-map-keyfn keyfn key val key val ...)\nReturns a new priority map with custom keyfn and optional supplied mappings.\nThe priority is determined by comparing (keyfn val). \n(priority-map-keyfn keyfn) yields an empty priority map with custom keyfn.", RT.keyword(null, "line"), Integer.valueOf(407), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/priority_map.clj" });
    const__43 = (Var)RT.var("clojure.data.priority-map", "priority-map-keyfn-by");
    const__46 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "keyfn"), Symbol.intern(null, "comparator"), Symbol.intern(null, "&"), Symbol.intern(null, "keyvals"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "pre"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "even?"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "count"), Symbol.intern(null, "keyvals") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(422), RT.keyword(null, "column"), Integer.valueOf(17) })) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(422), RT.keyword(null, "column"), Integer.valueOf(10) }))) })) })), RT.keyword(null, "doc"), "Usage: (priority-map-keyfn-by keyfn comparator key val key val ...)\nReturns a new priority map with custom keyfn, custom comparator, and optional supplied mappings.\nThe priority is determined by comparing (keyfn val).\n(priority-map-keyfn-by keyfn comparator) yields an empty priority map with custom keyfn and comparator.", RT.keyword(null, "line"), Integer.valueOf(416), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/priority_map.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("clojure.data.priority_map__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
