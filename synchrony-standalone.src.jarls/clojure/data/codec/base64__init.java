package clojure.data.codec;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.Numbers;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class base64__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__4;
  
  public static final AFn const__5;
  
  public static final Var const__6;
  
  public static final Var const__7;
  
  public static final Var const__8;
  
  public static final AFn const__16;
  
  public static final Var const__18;
  
  public static final Var const__19;
  
  public static final Var const__20;
  
  public static final Var const__21;
  
  public static final Var const__22;
  
  public static final AFn const__24;
  
  public static final Var const__25;
  
  public static final AFn const__29;
  
  public static final Var const__30;
  
  public static final AFn const__33;
  
  public static final Var const__34;
  
  public static final AFn const__37;
  
  public static final Var const__38;
  
  public static final AFn const__41;
  
  public static final Var const__42;
  
  public static final AFn const__45;
  
  public static final Var const__46;
  
  public static final AFn const__49;
  
  public static final Var const__50;
  
  public static final AFn const__53;
  
  public static final Var const__54;
  
  public static final AFn const__57;
  
  public static final Var const__58;
  
  public static final AFn const__61;
  
  public static final Var const__62;
  
  public static final AFn const__65;
  
  public static final Var const__66;
  
  public static final AFn const__69;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new base64.fn__14552());
    const__8.setMeta((IPersistentMap)const__16);
    const__8







      
      .bindRoot(Numbers.byte_array(((IFn)const__18.getRawRoot())
          .invoke(((IFn)const__19.getRawRoot()).invoke(const__20.getRawRoot(), const__21.getRawRoot()), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")));
    const__22.setMeta((IPersistentMap)const__24);
    const__22.bindRoot(((IFn)new base64.fn__14554()).invoke());
    const__25.setMeta((IPersistentMap)const__29);
    const__25.bindRoot(new base64.enc_length());
    const__30.setMeta((IPersistentMap)const__33);
    const__30.bindRoot(new base64.dec_length());
    const__34.setMeta((IPersistentMap)const__37);
    const__34.bindRoot(new base64.pad_length());
    const__38.setMeta((IPersistentMap)const__41);
    const__38.bindRoot(new base64.decode_BANG_());
    const__42.setMeta((IPersistentMap)const__45);
    const__42.bindRoot(new base64.decode());
    const__46.setMeta((IPersistentMap)const__49);
    const__46.bindRoot(new base64.encode_BANG_());
    const__50.setMeta((IPersistentMap)const__53);
    const__50.bindRoot(new base64.encode());
    const__54.setMeta((IPersistentMap)const__57);
    const__54.bindRoot(new base64.read_fully());
    const__58.setMeta((IPersistentMap)const__61);
    const__58.bindRoot(new base64.buf_size());
    const__62.setMeta((IPersistentMap)const__65);
    const__62.bindRoot(new base64.decoding_transfer());
    const__66.setMeta((IPersistentMap)const__69);
    const__66.bindRoot(new base64.encoding_transfer());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)((IObj)Symbol.intern(null, "clojure.data.codec.base64")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "author"), "Alex Taggart", RT.keyword(null, "doc"), "Functions for working with base64 encodings." }));
    const__4 = (AFn)RT.map(new Object[] { RT.keyword(null, "author"), "Alex Taggart", RT.keyword(null, "doc"), "Functions for working with base64 encodings." });
    const__5 = (AFn)Symbol.intern(null, "clojure.core");
    const__6 = (Var)RT.var("clojure.core", "*unchecked-math*");
    const__7 = (Var)RT.var("clojure.core", "*warn-on-reflection*");
    const__8 = (Var)RT.var("clojure.data.codec.base64", "enc-bytes");
    const__16 = (AFn)RT.map(new Object[] { RT.keyword(null, "tag"), "[B", RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(20), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/codec/base64.clj" });
    const__18 = (Var)RT.var("clojure.core", "map");
    const__19 = (Var)RT.var("clojure.core", "comp");
    const__20 = (Var)RT.var("clojure.core", "byte");
    const__21 = (Var)RT.var("clojure.core", "int");
    const__22 = (Var)RT.var("clojure.data.codec.base64", "dec-bytes");
    const__24 = (AFn)RT.map(new Object[] { RT.keyword(null, "tag"), "[B", RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(25), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/codec/base64.clj" });
    const__25 = (Var)RT.var("clojure.data.codec.base64", "enc-length");
    const__29 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(((IObj)Symbol.intern(null, "n")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })) })), RT.keyword(null, "doc"), "Calculates what would be the length after encoding of an input array of length n.", RT.keyword(null, "line"), Integer.valueOf(31), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/codec/base64.clj" });
    const__30 = (Var)RT.var("clojure.data.codec.base64", "dec-length");
    const__33 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(((IObj)Symbol.intern(null, "in-length")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "pad-length")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })) })), RT.keyword(null, "doc"), "Calculates what would be the length after decoding of an input array of length\n   in-length with the specified padding length.", RT.keyword(null, "line"), Integer.valueOf(39), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/codec/base64.clj" });
    const__34 = (Var)RT.var("clojure.data.codec.base64", "pad-length");
    const__37 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(((IObj)Symbol.intern(null, "input")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "bytes") })), ((IObj)Symbol.intern(null, "offset")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "length")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })) })), RT.keyword(null, "doc"), "Returns the length of padding on the end of the input array.", RT.keyword(null, "line"), Integer.valueOf(49), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/codec/base64.clj" });
    const__38 = (Var)RT.var("clojure.data.codec.base64", "decode!");
    const__41 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(((IObj)Symbol.intern(null, "input")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "bytes") })), ((IObj)Symbol.intern(null, "offset")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "length")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "output")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "bytes") })))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })) })), RT.keyword(null, "doc"), "Reads from the input byte array for the specified length starting at the offset\n   index, and base64 decodes into the output array starting at index 0. Returns the\n   length written to output.\n\n   Note: length must be a multiple of 4.", RT.keyword(null, "line"), Integer.valueOf(61), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/codec/base64.clj" });
    const__42 = (Var)RT.var("clojure.data.codec.base64", "decode");
    const__45 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "input")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "bytes") }))), Tuple.create(((IObj)Symbol.intern(null, "input")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "bytes") })), ((IObj)Symbol.intern(null, "offset")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "length")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") }))) })), RT.keyword(null, "doc"), "Returns a base64 decoded byte array.\n\n  Note: length must be a multiple of 4.", RT.keyword(null, "line"), Integer.valueOf(139), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/codec/base64.clj" });
    const__46 = (Var)RT.var("clojure.data.codec.base64", "encode!");
    const__49 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(((IObj)Symbol.intern(null, "input")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "bytes") })), ((IObj)Symbol.intern(null, "offset")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "length")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "output")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "bytes") })))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })) })), RT.keyword(null, "doc"), "Reads from the input byte array for the specified length starting at the offset\n   index, and base64 encodes into the output array starting at index 0. Returns the\n   length written to output.\n\n   Note: if using partial input, length must be a multiple of 3 to avoid padding.", RT.keyword(null, "line"), Integer.valueOf(151), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/codec/base64.clj" });
    const__50 = (Var)RT.var("clojure.data.codec.base64", "encode");
    const__53 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "input")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "bytes") }))), Tuple.create(((IObj)Symbol.intern(null, "input")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "bytes") })), ((IObj)Symbol.intern(null, "offset")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "length")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") }))) })), RT.keyword(null, "doc"), "Returns a base64 encoded byte array.", RT.keyword(null, "line"), Integer.valueOf(227), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/codec/base64.clj" });
    const__54 = (Var)RT.var("clojure.data.codec.base64", "read-fully");
    const__57 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(((IObj)Symbol.intern(null, "input")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "InputStream") })), ((IObj)Symbol.intern(null, "buf")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "bytes") })))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })) })), RT.keyword(null, "doc"), "Will fill the buffer to capacity, or with whatever is left in the input.\n   Returns the bytes read.", RT.keyword(null, "line"), Integer.valueOf(237), RT.keyword(null, "column"), Integer.valueOf(1), 
          RT.keyword(null, "file"), "clojure/data/codec/base64.clj" });
    const__58 = (Var)RT.var("clojure.data.codec.base64", "buf-size");
    const__61 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "opts"), ((IObj)Symbol.intern(null, "default")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })), ((IObj)Symbol.intern(null, "multiple-of")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "long") })) })), RT.keyword(null, "line"), Integer.valueOf(250), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/codec/base64.clj" });
    const__62 = (Var)RT.var("clojure.data.codec.base64", "decoding-transfer");
    const__65 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "input-stream")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "InputStream") })), ((IObj)Symbol.intern(null, "output-stream")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "OutputStream") })), Symbol.intern(null, "&"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Base64 decodes from input-stream to output-stream. Returns nil or throws IOException.\n\n  Options are key/value pairs and may be one of\n    :buffer-size  read buffer size to use, must be a multiple of 4; default is 8192.", RT.keyword(null, "line"), Integer.valueOf(257), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/codec/base64.clj" });
    const__66 = (Var)RT.var("clojure.data.codec.base64", "encoding-transfer");
    const__69 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(((IObj)Symbol.intern(null, "input-stream")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "InputStream") })), ((IObj)Symbol.intern(null, "output-stream")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "tag"), Symbol.intern(null, "OutputStream") })), Symbol.intern(null, "&"), Symbol.intern(null, "opts")) })), RT.keyword(null, "doc"), "Base64 encodes from input-stream to output-stream. Returns nil or throws IOException.\n\n  Options are key/value pairs and may be one of\n    :buffer-size  read buffer size to use, must be a multiple of 3; default is 6144.", RT.keyword(null, "line"), Integer.valueOf(275), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "clojure/data/codec/base64.clj" });
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("clojure.data.codec.base64__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
