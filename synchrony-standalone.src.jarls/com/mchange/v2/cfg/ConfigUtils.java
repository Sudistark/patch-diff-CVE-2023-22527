package com.mchange.v2.cfg;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;

final class ConfigUtils {
  private static final String[] DFLT_VM_RSRC_PATHFILES = { "/com/mchange/v2/cfg/vmConfigResourcePaths.txt", "/mchange-config-resource-paths.txt" };
  
  private static final String[] HARDCODED_DFLT_RSRC_PATHS = { "/mchange-commons.properties", "hocon:/reference,/application,/", "/" };
  
  static final String[] NO_PATHS = new String[0];
  
  static MultiPropertiesConfig vmConfig = null;
  
  static MultiPropertiesConfig read(String[] paramArrayOfString, List paramList) { return new BasicMultiPropertiesConfig(paramArrayOfString, paramList); }
  
  public static MultiPropertiesConfig read(String[] paramArrayOfString) { return new BasicMultiPropertiesConfig(paramArrayOfString); }
  
  public static MultiPropertiesConfig combine(MultiPropertiesConfig[] paramArrayOfMultiPropertiesConfig) { return (new CombinedMultiPropertiesConfig(paramArrayOfMultiPropertiesConfig)).toBasic(); }
  
  public static MultiPropertiesConfig readVmConfig(String[] paramArrayOfString1, String[] paramArrayOfString2) { return readVmConfig(paramArrayOfString1, paramArrayOfString2, (List)null); }
  
  static List vmCondensedPaths(String[] paramArrayOfString1, String[] paramArrayOfString2, List paramList) {
    List list = condensePaths(new String[][] { paramArrayOfString1, vmResourcePaths(paramList), paramArrayOfString2 });
    return ensureHoconInterresolvability(list);
  }
  
  static String stringFromPathsList(List paramList) {
    StringBuffer stringBuffer = new StringBuffer(2048);
    byte b;
    int i;
    for (b = 0, i = paramList.size(); b < i; b++) {
      if (b)
        stringBuffer.append(", "); 
      stringBuffer.append(paramList.get(b));
    } 
    return stringBuffer.toString();
  }
  
  public static MultiPropertiesConfig readVmConfig(String[] paramArrayOfString1, String[] paramArrayOfString2, List paramList) {
    paramArrayOfString1 = (paramArrayOfString1 == null) ? NO_PATHS : paramArrayOfString1;
    paramArrayOfString2 = (paramArrayOfString2 == null) ? NO_PATHS : paramArrayOfString2;
    List list = vmCondensedPaths(paramArrayOfString1, paramArrayOfString2, paramList);
    if (paramList != null)
      paramList.add(new DelayedLogItem(DelayedLogItem.Level.FINER, "Reading VM config for path list " + stringFromPathsList(list))); 
    return read((String[])list.toArray(new String[list.size()]), paramList);
  }
  
  private static List condensePaths(String[][] paramArrayOfString) {
    HashSet hashSet = new HashSet();
    ArrayList arrayList = new ArrayList();
    for (int i = paramArrayOfString.length; --i >= 0;) {
      for (int j = paramArrayOfString[i].length; --j >= 0; ) {
        String str = paramArrayOfString[i][j];
        if (!hashSet.contains(str)) {
          hashSet.add(str);
          arrayList.add(str);
        } 
      } 
    } 
    Collections.reverse(arrayList);
    return arrayList;
  }
  
  private static List readResourcePathsFromResourcePathsTextFile(String paramString, List paramList) {
    ArrayList arrayList = new ArrayList();
    bufferedReader = null;
    try {
      inputStream = MultiPropertiesConfig.class.getResourceAsStream(paramString);
      if (inputStream != null) {
        bufferedReader = new BufferedReader(new InputStreamReader(inputStream, "8859_1"));
        String str;
        while ((str = bufferedReader.readLine()) != null) {
          str = str.trim();
          if ("".equals(str) || str.startsWith("#"))
            continue; 
          arrayList.add(str);
        } 
        if (paramList != null)
          paramList.add(new DelayedLogItem(DelayedLogItem.Level.FINEST, String.format("Added paths from resource path text file at '%s'", new Object[] { paramString }))); 
      } else if (paramList != null) {
        paramList.add(new DelayedLogItem(DelayedLogItem.Level.FINEST, String.format("Could not find resource path text file for path '%s'. Skipping.", new Object[] { paramString })));
      } 
    } catch (IOException iOException) {
      iOException.printStackTrace();
    } finally {
      try {
        if (bufferedReader != null)
          bufferedReader.close(); 
      } catch (IOException iOException) {
        iOException.printStackTrace();
      } 
    } 
    return arrayList;
  }
  
  private static List readResourcePathsFromResourcePathsTextFiles(String[] paramArrayOfString, List paramList) {
    ArrayList arrayList = new ArrayList();
    byte b;
    int i;
    for (b = 0, i = paramArrayOfString.length; b < i; b++)
      arrayList.addAll(readResourcePathsFromResourcePathsTextFile(paramArrayOfString[b], paramList)); 
    return arrayList;
  }
  
  private static String[] vmResourcePaths(List paramList) {
    List list = vmResourcePathList(paramList);
    return (String[])list.toArray(new String[list.size()]);
  }
  
  private static List vmResourcePathList(List paramList) {
    List list2, list1 = readResourcePathsFromResourcePathsTextFiles(DFLT_VM_RSRC_PATHFILES, paramList);
    if (list1.size() > 0) {
      list2 = list1;
    } else {
      list2 = Arrays.asList(HARDCODED_DFLT_RSRC_PATHS);
    } 
    return list2;
  }
  
  public static MultiPropertiesConfig readVmConfig() { return readVmConfig((List)null); }
  
  public static MultiPropertiesConfig readVmConfig(List paramList) {
    if (vmConfig == null) {
      List list = vmResourcePathList(paramList);
      vmConfig = new BasicMultiPropertiesConfig((String[])list.toArray(new String[list.size()]));
    } 
    return vmConfig;
  }
  
  public static boolean foundVmConfig() { return (vmConfig != null); }
  
  public static void dumpByPrefix(MultiPropertiesConfig paramMultiPropertiesConfig, String paramString) {
    Properties properties = paramMultiPropertiesConfig.getPropertiesByPrefix(paramString);
    TreeMap treeMap = new TreeMap();
    treeMap.putAll(properties);
    for (Map.Entry entry : treeMap.entrySet())
      System.err.println(entry.getKey() + " --> " + entry.getValue()); 
  }
  
  private static void putToSet(Map<String, Set<String>> paramMap, String paramString1, String paramString2) {
    Set set = (Set)paramMap.get(paramString1);
    if (set == null) {
      set = new HashSet();
      paramMap.put(paramString1, set);
    } 
    set.add(paramString2);
  }
  
  private static String makeHoconPathFromElements(List<String> paramList) {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("hocon:");
    boolean bool = true;
    for (String str : paramList) {
      if (bool) {
        bool = false;
      } else {
        stringBuilder.append(",");
      } 
      stringBuilder.append(str);
    } 
    return stringBuilder.toString();
  }
  
  private static String normalizeHoconPathElement(String paramString) { return (paramString.indexOf(":") < 0 && paramString.charAt(0) != '/') ? ('/' + paramString) : paramString; }
  
  private static List<String> ensureHoconInterresolvability(List<String> paramList) {
    HashMap hashMap1 = new HashMap();
    HashMap hashMap2 = new HashMap();
    ArrayList arrayList = new ArrayList();
    for (String str : paramList) {
      if (str.toLowerCase().startsWith("hocon:")) {
        String[] arrayOfString = str.substring("hocon:".length()).split("\\s*,\\s*");
        byte b;
        for (b = 0, null = arrayOfString.length; b < null; b++)
          arrayOfString[b] = normalizeHoconPathElement(arrayOfString[b]); 
        hashMap1.put(str, Arrays.asList(arrayOfString));
        for (String str1 : arrayOfString) {
          putToSet(hashMap2, str1, str);
          if (str1.indexOf('.') < 0 && !"/".equals(str1)) {
            putToSet(hashMap2, str1 + ".conf", str);
            putToSet(hashMap2, str1 + ".properties", str);
            putToSet(hashMap2, str1 + ".json", str);
          } 
        } 
      } 
    } 
    for (String str : paramList) {
      if (str.toLowerCase().startsWith("hocon:")) {
        List list = (List)hashMap1.get(str);
        HashSet hashSet = new HashSet();
        for (String str1 : list) {
          if (!"/".equals(str1))
            hashSet.addAll((Collection)hashMap2.get(str1)); 
        } 
        ArrayList arrayList1 = new ArrayList();
        for (String str1 : paramList) {
          if (str.toLowerCase().startsWith("hocon:") && 
            str1 != str && 
            hashSet.contains(str1))
            arrayList1.addAll((Collection)hashMap1.get(str1)); 
        } 
        arrayList1.addAll((Collection)hashMap1.get(str));
        arrayList.add(makeHoconPathFromElements(arrayList1));
        continue;
      } 
      arrayList.add(str);
    } 
    return arrayList;
  }
}
