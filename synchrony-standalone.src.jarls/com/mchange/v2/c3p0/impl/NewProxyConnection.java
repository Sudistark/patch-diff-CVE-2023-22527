package com.mchange.v2.c3p0.impl;

import com.mchange.v2.c3p0.C3P0ProxyConnection;
import com.mchange.v2.log.MLevel;
import com.mchange.v2.log.MLog;
import com.mchange.v2.log.MLogger;
import com.mchange.v2.sql.SqlUtils;
import com.mchange.v2.util.ResourceClosedException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.Array;
import java.sql.Blob;
import java.sql.CallableStatement;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.NClob;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLClientInfoException;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Savepoint;
import java.sql.Statement;
import java.sql.Struct;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.Executor;
import javax.sql.ConnectionEventListener;

public final class NewProxyConnection implements Connection, C3P0ProxyConnection {
  protected Connection inner;
  
  boolean txn_known_resolved;
  
  DatabaseMetaData metaData;
  
  private void __setInner(Connection inner) { this.inner = inner; }
  
  NewProxyConnection(Connection inner) {
    this.txn_known_resolved = true;
    this.metaData = null;
    this.cel = new Object(this);
    __setInner(inner);
  }
  
  public void setReadOnly(boolean a) throws SQLException {
    try {
      this.inner.setReadOnly(a);
      this.parentPooledConnection.markNewReadOnly(a);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public void close() throws SQLException {
    try {
      if (!isDetached()) {
        NewPooledConnection npc = this.parentPooledConnection;
        detach();
        npc.markClosedProxyConnection(this, this.txn_known_resolved);
        this.inner = null;
      } else if (logger.isLoggable(MLevel.FINE)) {
        logger.log(MLevel.FINE, this + ": close() called after already close()ed or abort()ed.");
      } 
    } catch (NullPointerException exc) {
      if (isDetached()) {
        if (logger.isLoggable(MLevel.FINE))
          logger.log(MLevel.FINE, this + ": close() called more than once."); 
      } else {
        throw exc;
      } 
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public boolean isReadOnly() throws SQLException {
    try {
      this.txn_known_resolved = false;
      return this.inner.isReadOnly();
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public Statement createStatement(int a, int b) throws SQLException {
    try {
      this.txn_known_resolved = false;
      Statement innerStmt = this.inner.createStatement(a, b);
      this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
      return new NewProxyStatement(innerStmt, this.parentPooledConnection, false, this);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public Statement createStatement() throws SQLException {
    try {
      this.txn_known_resolved = false;
      Statement innerStmt = this.inner.createStatement();
      this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
      return new NewProxyStatement(innerStmt, this.parentPooledConnection, false, this);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public Statement createStatement(int a, int b, int c) throws SQLException {
    try {
      this.txn_known_resolved = false;
      Statement innerStmt = this.inner.createStatement(a, b, c);
      this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
      return new NewProxyStatement(innerStmt, this.parentPooledConnection, false, this);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public PreparedStatement prepareStatement(String a, int b) throws SQLException {
    try {
      this.txn_known_resolved = false;
      if (this.parentPooledConnection.isStatementCaching())
        try {
          Class[] argTypes = { String.class, int.class };
          Method method = Connection.class.getMethod("prepareStatement", argTypes);
          Object[] args = { a, new Integer(b) };
          PreparedStatement innerStmt = (PreparedStatement)this.parentPooledConnection.checkoutStatement(method, args);
          return new NewProxyPreparedStatement(innerStmt, this.parentPooledConnection, true, this);
        } catch (ResourceClosedException e) {
          if (logger.isLoggable(MLevel.FINE))
            logger.log(MLevel.FINE, "A Connection tried to prepare a Statement via a Statement cache that is already closed. This can happen -- rarely -- if a DataSource is closed or reset() while Connections are checked-out and in use.", e); 
          PreparedStatement innerStmt = this.inner.prepareStatement(a, b);
          this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
          return new NewProxyPreparedStatement(innerStmt, this.parentPooledConnection, false, this);
        }  
      PreparedStatement innerStmt = this.inner.prepareStatement(a, b);
      this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
      return new NewProxyPreparedStatement(innerStmt, this.parentPooledConnection, false, this);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public PreparedStatement prepareStatement(String a, int[] b) throws SQLException {
    try {
      this.txn_known_resolved = false;
      if (this.parentPooledConnection.isStatementCaching())
        try {
          Class[] argTypes = { String.class, int[].class };
          Method method = Connection.class.getMethod("prepareStatement", argTypes);
          Object[] args = { a, b };
          PreparedStatement innerStmt = (PreparedStatement)this.parentPooledConnection.checkoutStatement(method, args);
          return new NewProxyPreparedStatement(innerStmt, this.parentPooledConnection, true, this);
        } catch (ResourceClosedException e) {
          if (logger.isLoggable(MLevel.FINE))
            logger.log(MLevel.FINE, "A Connection tried to prepare a Statement via a Statement cache that is already closed. This can happen -- rarely -- if a DataSource is closed or reset() while Connections are checked-out and in use.", e); 
          PreparedStatement innerStmt = this.inner.prepareStatement(a, b);
          this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
          return new NewProxyPreparedStatement(innerStmt, this.parentPooledConnection, false, this);
        }  
      PreparedStatement innerStmt = this.inner.prepareStatement(a, b);
      this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
      return new NewProxyPreparedStatement(innerStmt, this.parentPooledConnection, false, this);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public PreparedStatement prepareStatement(String a, int b, int c) throws SQLException {
    try {
      this.txn_known_resolved = false;
      if (this.parentPooledConnection.isStatementCaching())
        try {
          Class[] argTypes = { String.class, int.class, int.class };
          Method method = Connection.class.getMethod("prepareStatement", argTypes);
          Object[] args = { a, new Integer(b), new Integer(c) };
          PreparedStatement innerStmt = (PreparedStatement)this.parentPooledConnection.checkoutStatement(method, args);
          return new NewProxyPreparedStatement(innerStmt, this.parentPooledConnection, true, this);
        } catch (ResourceClosedException e) {
          if (logger.isLoggable(MLevel.FINE))
            logger.log(MLevel.FINE, "A Connection tried to prepare a Statement via a Statement cache that is already closed. This can happen -- rarely -- if a DataSource is closed or reset() while Connections are checked-out and in use.", e); 
          PreparedStatement innerStmt = this.inner.prepareStatement(a, b, c);
          this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
          return new NewProxyPreparedStatement(innerStmt, this.parentPooledConnection, false, this);
        }  
      PreparedStatement innerStmt = this.inner.prepareStatement(a, b, c);
      this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
      return new NewProxyPreparedStatement(innerStmt, this.parentPooledConnection, false, this);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public PreparedStatement prepareStatement(String a, String[] b) throws SQLException {
    try {
      this.txn_known_resolved = false;
      if (this.parentPooledConnection.isStatementCaching())
        try {
          Class[] argTypes = { String.class, String[].class };
          Method method = Connection.class.getMethod("prepareStatement", argTypes);
          Object[] args = { a, b };
          PreparedStatement innerStmt = (PreparedStatement)this.parentPooledConnection.checkoutStatement(method, args);
          return new NewProxyPreparedStatement(innerStmt, this.parentPooledConnection, true, this);
        } catch (ResourceClosedException e) {
          if (logger.isLoggable(MLevel.FINE))
            logger.log(MLevel.FINE, "A Connection tried to prepare a Statement via a Statement cache that is already closed. This can happen -- rarely -- if a DataSource is closed or reset() while Connections are checked-out and in use.", e); 
          PreparedStatement innerStmt = this.inner.prepareStatement(a, b);
          this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
          return new NewProxyPreparedStatement(innerStmt, this.parentPooledConnection, false, this);
        }  
      PreparedStatement innerStmt = this.inner.prepareStatement(a, b);
      this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
      return new NewProxyPreparedStatement(innerStmt, this.parentPooledConnection, false, this);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public PreparedStatement prepareStatement(String a, int b, int c, int d) throws SQLException {
    try {
      this.txn_known_resolved = false;
      if (this.parentPooledConnection.isStatementCaching())
        try {
          Class[] argTypes = { String.class, int.class, int.class, int.class };
          Method method = Connection.class.getMethod("prepareStatement", argTypes);
          Object[] args = { a, new Integer(b), new Integer(c), new Integer(d) };
          PreparedStatement innerStmt = (PreparedStatement)this.parentPooledConnection.checkoutStatement(method, args);
          return new NewProxyPreparedStatement(innerStmt, this.parentPooledConnection, true, this);
        } catch (ResourceClosedException e) {
          if (logger.isLoggable(MLevel.FINE))
            logger.log(MLevel.FINE, "A Connection tried to prepare a Statement via a Statement cache that is already closed. This can happen -- rarely -- if a DataSource is closed or reset() while Connections are checked-out and in use.", e); 
          PreparedStatement innerStmt = this.inner.prepareStatement(a, b, c, d);
          this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
          return new NewProxyPreparedStatement(innerStmt, this.parentPooledConnection, false, this);
        }  
      PreparedStatement innerStmt = this.inner.prepareStatement(a, b, c, d);
      this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
      return new NewProxyPreparedStatement(innerStmt, this.parentPooledConnection, false, this);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public PreparedStatement prepareStatement(String a) throws SQLException {
    try {
      this.txn_known_resolved = false;
      if (this.parentPooledConnection.isStatementCaching())
        try {
          Class[] argTypes = { String.class };
          Method method = Connection.class.getMethod("prepareStatement", argTypes);
          Object[] args = { a };
          PreparedStatement innerStmt = (PreparedStatement)this.parentPooledConnection.checkoutStatement(method, args);
          return new NewProxyPreparedStatement(innerStmt, this.parentPooledConnection, true, this);
        } catch (ResourceClosedException e) {
          if (logger.isLoggable(MLevel.FINE))
            logger.log(MLevel.FINE, "A Connection tried to prepare a Statement via a Statement cache that is already closed. This can happen -- rarely -- if a DataSource is closed or reset() while Connections are checked-out and in use.", e); 
          PreparedStatement innerStmt = this.inner.prepareStatement(a);
          this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
          return new NewProxyPreparedStatement(innerStmt, this.parentPooledConnection, false, this);
        }  
      PreparedStatement innerStmt = this.inner.prepareStatement(a);
      this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
      return new NewProxyPreparedStatement(innerStmt, this.parentPooledConnection, false, this);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public CallableStatement prepareCall(String a) throws SQLException {
    try {
      this.txn_known_resolved = false;
      if (this.parentPooledConnection.isStatementCaching())
        try {
          Class[] argTypes = { String.class };
          Method method = Connection.class.getMethod("prepareCall", argTypes);
          Object[] args = { a };
          CallableStatement innerStmt = (CallableStatement)this.parentPooledConnection.checkoutStatement(method, args);
          return new NewProxyCallableStatement(innerStmt, this.parentPooledConnection, true, this);
        } catch (ResourceClosedException e) {
          if (logger.isLoggable(MLevel.FINE))
            logger.log(MLevel.FINE, "A Connection tried to prepare a CallableStatement via a Statement cache that is already closed. This can happen -- rarely -- if a DataSource is closed or reset() while Connections are checked-out and in use.", e); 
          CallableStatement innerStmt = this.inner.prepareCall(a);
          this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
          return new NewProxyCallableStatement(innerStmt, this.parentPooledConnection, false, this);
        }  
      CallableStatement innerStmt = this.inner.prepareCall(a);
      this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
      return new NewProxyCallableStatement(innerStmt, this.parentPooledConnection, false, this);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public CallableStatement prepareCall(String a, int b, int c, int d) throws SQLException {
    try {
      this.txn_known_resolved = false;
      if (this.parentPooledConnection.isStatementCaching())
        try {
          Class[] argTypes = { String.class, int.class, int.class, int.class };
          Method method = Connection.class.getMethod("prepareCall", argTypes);
          Object[] args = { a, new Integer(b), new Integer(c), new Integer(d) };
          CallableStatement innerStmt = (CallableStatement)this.parentPooledConnection.checkoutStatement(method, args);
          return new NewProxyCallableStatement(innerStmt, this.parentPooledConnection, true, this);
        } catch (ResourceClosedException e) {
          if (logger.isLoggable(MLevel.FINE))
            logger.log(MLevel.FINE, "A Connection tried to prepare a CallableStatement via a Statement cache that is already closed. This can happen -- rarely -- if a DataSource is closed or reset() while Connections are checked-out and in use.", e); 
          CallableStatement innerStmt = this.inner.prepareCall(a, b, c, d);
          this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
          return new NewProxyCallableStatement(innerStmt, this.parentPooledConnection, false, this);
        }  
      CallableStatement innerStmt = this.inner.prepareCall(a, b, c, d);
      this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
      return new NewProxyCallableStatement(innerStmt, this.parentPooledConnection, false, this);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public CallableStatement prepareCall(String a, int b, int c) throws SQLException {
    try {
      this.txn_known_resolved = false;
      if (this.parentPooledConnection.isStatementCaching())
        try {
          Class[] argTypes = { String.class, int.class, int.class };
          Method method = Connection.class.getMethod("prepareCall", argTypes);
          Object[] args = { a, new Integer(b), new Integer(c) };
          CallableStatement innerStmt = (CallableStatement)this.parentPooledConnection.checkoutStatement(method, args);
          return new NewProxyCallableStatement(innerStmt, this.parentPooledConnection, true, this);
        } catch (ResourceClosedException e) {
          if (logger.isLoggable(MLevel.FINE))
            logger.log(MLevel.FINE, "A Connection tried to prepare a CallableStatement via a Statement cache that is already closed. This can happen -- rarely -- if a DataSource is closed or reset() while Connections are checked-out and in use.", e); 
          CallableStatement innerStmt = this.inner.prepareCall(a, b, c);
          this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
          return new NewProxyCallableStatement(innerStmt, this.parentPooledConnection, false, this);
        }  
      CallableStatement innerStmt = this.inner.prepareCall(a, b, c);
      this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
      return new NewProxyCallableStatement(innerStmt, this.parentPooledConnection, false, this);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public DatabaseMetaData getMetaData() throws SQLException {
    try {
      this.txn_known_resolved = false;
      if (this.metaData == null) {
        DatabaseMetaData innerMetaData = this.inner.getMetaData();
        this.metaData = new NewProxyDatabaseMetaData(innerMetaData, this.parentPooledConnection, this);
      } 
      return this.metaData;
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public void setTransactionIsolation(int a) throws SQLException {
    try {
      this.inner.setTransactionIsolation(a);
      this.parentPooledConnection.markNewTxnIsolation(a);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public void setCatalog(String a) throws SQLException {
    try {
      this.inner.setCatalog(a);
      this.parentPooledConnection.markNewCatalog(a);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public void setHoldability(int a) throws SQLException {
    try {
      this.inner.setHoldability(a);
      this.parentPooledConnection.markNewHoldability(a);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public void setTypeMap(Map a) throws SQLException {
    try {
      this.inner.setTypeMap(a);
      this.parentPooledConnection.markNewTypeMap(a);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public SQLWarning getWarnings() throws SQLException {
    try {
      return this.inner.getWarnings();
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public void clearWarnings() throws SQLException {
    try {
      this.inner.clearWarnings();
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public boolean isClosed() throws SQLException {
    try {
      return isDetached();
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public void commit() throws SQLException {
    try {
      this.inner.commit();
      this.txn_known_resolved = true;
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public void rollback(Savepoint a) throws SQLException {
    try {
      this.inner.rollback(a);
      this.txn_known_resolved = true;
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public void rollback() throws SQLException {
    try {
      this.inner.rollback();
      this.txn_known_resolved = true;
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public void setAutoCommit(boolean a) throws SQLException {
    try {
      this.inner.setAutoCommit(a);
      this.txn_known_resolved = true;
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public void setClientInfo(String a, String b) throws SQLClientInfoException {
    try {
      try {
        this.txn_known_resolved = false;
        this.inner.setClientInfo(a, b);
      } catch (NullPointerException exc) {
        if (isDetached())
          throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
        throw exc;
      } catch (Exception exc) {
        if (!isDetached())
          throw this.parentPooledConnection.handleThrowable(exc); 
        throw SqlUtils.toSQLException(exc);
      } 
    } catch (Exception e) {
      throw SqlUtils.toSQLClientInfoException(e);
    } 
  }
  
  public void setClientInfo(Properties a) throws SQLClientInfoException {
    try {
      try {
        this.txn_known_resolved = false;
        this.inner.setClientInfo(a);
      } catch (NullPointerException exc) {
        if (isDetached())
          throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
        throw exc;
      } catch (Exception exc) {
        if (!isDetached())
          throw this.parentPooledConnection.handleThrowable(exc); 
        throw SqlUtils.toSQLException(exc);
      } 
    } catch (Exception e) {
      throw SqlUtils.toSQLClientInfoException(e);
    } 
  }
  
  public void abort(Executor a) throws SQLException {
    try {
      if (!isDetached()) {
        NewPooledConnection npc = this.parentPooledConnection;
        Executor exec = a;
        detach();
        this.inner = null;
        Object object = new Object(this, npc);
        exec.execute(object);
      } else if (logger.isLoggable(MLevel.FINE)) {
        logger.log(MLevel.FINE, this + ": abort() after already close()ed or abort()ed.");
      } 
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public String nativeSQL(String a) throws SQLException {
    try {
      this.txn_known_resolved = false;
      return this.inner.nativeSQL(a);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public boolean getAutoCommit() throws SQLException {
    try {
      this.txn_known_resolved = false;
      return this.inner.getAutoCommit();
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public String getCatalog() throws SQLException {
    try {
      this.txn_known_resolved = false;
      return this.inner.getCatalog();
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public int getTransactionIsolation() throws SQLException {
    try {
      this.txn_known_resolved = false;
      return this.inner.getTransactionIsolation();
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public Map getTypeMap() throws SQLException {
    try {
      this.txn_known_resolved = false;
      return this.inner.getTypeMap();
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public int getHoldability() throws SQLException {
    try {
      this.txn_known_resolved = false;
      return this.inner.getHoldability();
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public Savepoint setSavepoint() throws SQLException {
    try {
      this.txn_known_resolved = false;
      return this.inner.setSavepoint();
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public Savepoint setSavepoint(String a) throws SQLException {
    try {
      this.txn_known_resolved = false;
      return this.inner.setSavepoint(a);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public void releaseSavepoint(Savepoint a) throws SQLException {
    try {
      this.txn_known_resolved = false;
      this.inner.releaseSavepoint(a);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public Clob createClob() throws SQLException {
    try {
      this.txn_known_resolved = false;
      return this.inner.createClob();
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public Blob createBlob() throws SQLException {
    try {
      this.txn_known_resolved = false;
      return this.inner.createBlob();
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public NClob createNClob() throws SQLException {
    try {
      this.txn_known_resolved = false;
      return this.inner.createNClob();
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public SQLXML createSQLXML() throws SQLException {
    try {
      this.txn_known_resolved = false;
      return this.inner.createSQLXML();
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public Properties getClientInfo() throws SQLException {
    try {
      this.txn_known_resolved = false;
      return this.inner.getClientInfo();
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public String getClientInfo(String a) throws SQLException {
    try {
      this.txn_known_resolved = false;
      return this.inner.getClientInfo(a);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public Array createArrayOf(String a, Object[] b) throws SQLException {
    try {
      this.txn_known_resolved = false;
      return this.inner.createArrayOf(a, b);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public Struct createStruct(String a, Object[] b) throws SQLException {
    try {
      this.txn_known_resolved = false;
      return this.inner.createStruct(a, b);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public void setSchema(String a) throws SQLException {
    try {
      this.txn_known_resolved = false;
      this.inner.setSchema(a);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public String getSchema() throws SQLException {
    try {
      this.txn_known_resolved = false;
      return this.inner.getSchema();
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public void setNetworkTimeout(Executor a, int b) throws SQLException {
    try {
      this.txn_known_resolved = false;
      this.inner.setNetworkTimeout(a, b);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public int getNetworkTimeout() throws SQLException {
    try {
      this.txn_known_resolved = false;
      return this.inner.getNetworkTimeout();
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public boolean isValid(int a) throws SQLException {
    try {
      if (isDetached())
        return false; 
      return this.inner.isValid(a);
    } catch (NullPointerException exc) {
      if (isDetached())
        throw SqlUtils.toSQLException("You can't operate on a closed Connection!!!", exc); 
      throw exc;
    } catch (Exception exc) {
      if (!isDetached())
        throw this.parentPooledConnection.handleThrowable(exc); 
      throw SqlUtils.toSQLException(exc);
    } 
  }
  
  public Object unwrap(Class a) throws SQLException {
    if (isWrapperForInner(a))
      return this.inner.unwrap(a); 
    if (isWrapperForThis(a))
      return this; 
    throw new SQLException(this + " is not a wrapper for or implementation of " + a.getName());
  }
  
  public boolean isWrapperFor(Class a) throws SQLException { return (isWrapperForInner(a) || isWrapperForThis(a)); }
  
  public Object rawConnectionOperation(Method m, Object target, Object[] args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, SQLException {
    maybeDirtyTransaction();
    if (this.inner == null)
      throw new SQLException("You cannot operate on a closed Connection!"); 
    if (target == C3P0ProxyConnection.RAW_CONNECTION)
      target = this.inner; 
    for (int i = 0, len = args.length; i < len; i++) {
      if (args[i] == C3P0ProxyConnection.RAW_CONNECTION)
        args[i] = this.inner; 
    } 
    Object out = m.invoke(target, args);
    if (out instanceof CallableStatement) {
      CallableStatement innerStmt = (CallableStatement)out;
      this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
      out = new NewProxyCallableStatement(innerStmt, this.parentPooledConnection, false, this);
    } else if (out instanceof PreparedStatement) {
      PreparedStatement innerStmt = (PreparedStatement)out;
      this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
      out = new NewProxyPreparedStatement(innerStmt, this.parentPooledConnection, false, this);
    } else if (out instanceof Statement) {
      Statement innerStmt = (Statement)out;
      this.parentPooledConnection.markActiveUncachedStatement(innerStmt);
      out = new NewProxyStatement(innerStmt, this.parentPooledConnection, false, this);
    } else if (out instanceof ResultSet) {
      ResultSet innerRs = (ResultSet)out;
      this.parentPooledConnection.markActiveRawConnectionResultSet(innerRs);
      out = new NewProxyResultSet(innerRs, this.parentPooledConnection, this.inner, this);
    } else if (out instanceof DatabaseMetaData) {
      out = new NewProxyDatabaseMetaData((DatabaseMetaData)out, this.parentPooledConnection);
    } 
    return out;
  }
  
  void maybeDirtyTransaction() throws SQLException { this.txn_known_resolved = false; }
  
  private static final MLogger logger = MLog.getLogger("com.mchange.v2.c3p0.impl.NewProxyConnection");
  
  ConnectionEventListener cel;
  
  void attach(NewPooledConnection parentPooledConnection) {
    this.parentPooledConnection = parentPooledConnection;
    parentPooledConnection.addConnectionEventListener(this.cel);
  }
  
  private void detach() throws SQLException {
    this.parentPooledConnection.removeConnectionEventListener(this.cel);
    this.parentPooledConnection = null;
  }
  
  NewProxyConnection(Connection inner, NewPooledConnection parentPooledConnection) {
    this(inner);
    attach(parentPooledConnection);
  }
  
  boolean isDetached() throws SQLException { return (this.parentPooledConnection == null); }
  
  public String toString() throws SQLException { return super.toString() + " [wrapping: " + this.inner + "]"; }
  
  private boolean isWrapperForInner(Class intfcl) throws SQLException { return (Connection.class == intfcl || intfcl.isAssignableFrom(this.inner.getClass())); }
  
  private boolean isWrapperForThis(Class intfcl) throws SQLException { return intfcl.isAssignableFrom(getClass()); }
}
