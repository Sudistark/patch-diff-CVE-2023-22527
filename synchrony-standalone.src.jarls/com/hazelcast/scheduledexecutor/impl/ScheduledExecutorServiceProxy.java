package com.hazelcast.scheduledexecutor.impl;

import com.hazelcast.core.ManagedContext;
import com.hazelcast.core.Member;
import com.hazelcast.core.PartitionAware;
import com.hazelcast.internal.cluster.ClusterService;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.scheduledexecutor.IScheduledExecutorService;
import com.hazelcast.scheduledexecutor.IScheduledFuture;
import com.hazelcast.scheduledexecutor.NamedTask;
import com.hazelcast.scheduledexecutor.ScheduledTaskHandler;
import com.hazelcast.scheduledexecutor.impl.operations.GetAllScheduledOnPartitionOperationFactory;
import com.hazelcast.scheduledexecutor.impl.operations.ScheduleTaskOperation;
import com.hazelcast.scheduledexecutor.impl.operations.ShutdownOperation;
import com.hazelcast.spi.AbstractDistributedObject;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.OperationService;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.FutureUtil;
import com.hazelcast.util.MapUtil;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.UuidUtil;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class ScheduledExecutorServiceProxy extends AbstractDistributedObject<DistributedScheduledExecutorService> implements IScheduledExecutorService {
  private static final int SHUTDOWN_TIMEOUT = 10;
  
  private final FutureUtil.ExceptionHandler shutdownExceptionHandler = new Object(this);
  
  private final String name;
  
  private final ILogger logger;
  
  ScheduledExecutorServiceProxy(String name, NodeEngine nodeEngine, DistributedScheduledExecutorService service) {
    super(nodeEngine, service);
    this.name = name;
    this.logger = nodeEngine.getLogger(ScheduledExecutorServiceProxy.class);
  }
  
  public String getName() { return this.name; }
  
  public String getServiceName() { return "hz:impl:scheduledExecutorService"; }
  
  public IScheduledFuture schedule(Runnable command, long delay, TimeUnit unit) {
    Preconditions.checkNotNull(command, "Command is null");
    Preconditions.checkNotNull(unit, "Unit is null");
    initializeManagedContext(command);
    ScheduledRunnableAdapter<?> callable = createScheduledRunnableAdapter(command);
    return schedule(callable, delay, unit);
  }
  
  public <V> IScheduledFuture<V> schedule(Callable<V> command, long delay, TimeUnit unit) {
    Preconditions.checkNotNull(command, "Command is null");
    Preconditions.checkNotNull(unit, "Unit is null");
    initializeManagedContext(command);
    String name = extractNameOrGenerateOne(command);
    int partitionId = getTaskOrKeyPartitionId(command, name);
    TaskDefinition<V> definition = new TaskDefinition<V>(TaskDefinition.Type.SINGLE_RUN, name, command, delay, unit);
    return submitOnPartitionSync(name, new ScheduleTaskOperation(getName(), definition), partitionId);
  }
  
  public IScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
    Preconditions.checkNotNull(command, "Command is null");
    Preconditions.checkNotNull(unit, "Unit is null");
    initializeManagedContext(command);
    String name = extractNameOrGenerateOne(command);
    int partitionId = getTaskOrKeyPartitionId(command, name);
    ScheduledRunnableAdapter<?> adapter = createScheduledRunnableAdapter(command);
    TaskDefinition definition = new TaskDefinition(TaskDefinition.Type.AT_FIXED_RATE, name, adapter, initialDelay, period, unit);
    return submitOnPartitionSync(name, new ScheduleTaskOperation(getName(), definition), partitionId);
  }
  
  public IScheduledFuture<?> scheduleOnMember(Runnable command, Member member, long delay, TimeUnit unit) {
    Preconditions.checkNotNull(member, "Member is null");
    Preconditions.checkNotNull(unit, "Unit is null");
    initializeManagedContext(command);
    return (IScheduledFuture)scheduleOnMembers(command, Collections.singleton(member), delay, unit).get(member);
  }
  
  public <V> IScheduledFuture<V> scheduleOnMember(Callable<V> command, Member member, long delay, TimeUnit unit) {
    Preconditions.checkNotNull(member, "Member is null");
    Preconditions.checkNotNull(unit, "Unit is null");
    initializeManagedContext(command);
    return (IScheduledFuture)scheduleOnMembers(command, Collections.singleton(member), delay, unit).get(member);
  }
  
  public IScheduledFuture<?> scheduleOnMemberAtFixedRate(Runnable command, Member member, long initialDelay, long period, TimeUnit unit) {
    Preconditions.checkNotNull(member, "Member is null");
    Preconditions.checkNotNull(unit, "Unit is null");
    initializeManagedContext(command);
    return (IScheduledFuture)scheduleOnMembersAtFixedRate(command, Collections.singleton(member), initialDelay, period, unit).get(member);
  }
  
  public IScheduledFuture<?> scheduleOnKeyOwner(Runnable command, Object key, long delay, TimeUnit unit) {
    Preconditions.checkNotNull(command, "Command is null");
    Preconditions.checkNotNull(unit, "Unit is null");
    initializeManagedContext(command);
    ScheduledRunnableAdapter<?> callable = createScheduledRunnableAdapter(command);
    return scheduleOnKeyOwner(callable, key, delay, unit);
  }
  
  public <V> IScheduledFuture<V> scheduleOnKeyOwner(Callable<V> command, Object key, long delay, TimeUnit unit) {
    Preconditions.checkNotNull(command, "Command is null");
    Preconditions.checkNotNull(key, "Key is null");
    Preconditions.checkNotNull(unit, "Unit is null");
    initializeManagedContext(command);
    String name = extractNameOrGenerateOne(command);
    int partitionId = getKeyPartitionId(key);
    TaskDefinition definition = new TaskDefinition(TaskDefinition.Type.SINGLE_RUN, name, command, delay, unit);
    return submitOnPartitionSync(name, new ScheduleTaskOperation(getName(), definition), partitionId);
  }
  
  public IScheduledFuture<?> scheduleOnKeyOwnerAtFixedRate(Runnable command, Object key, long initialDelay, long period, TimeUnit unit) {
    Preconditions.checkNotNull(command, "Command is null");
    Preconditions.checkNotNull(key, "Key is null");
    Preconditions.checkNotNull(unit, "Unit is null");
    initializeManagedContext(command);
    String name = extractNameOrGenerateOne(command);
    int partitionId = getKeyPartitionId(key);
    ScheduledRunnableAdapter<?> adapter = createScheduledRunnableAdapter(command);
    TaskDefinition definition = new TaskDefinition(TaskDefinition.Type.AT_FIXED_RATE, name, adapter, initialDelay, period, unit);
    return submitOnPartitionSync(name, new ScheduleTaskOperation(getName(), definition), partitionId);
  }
  
  public Map<Member, IScheduledFuture<?>> scheduleOnAllMembers(Runnable command, long delay, TimeUnit unit) {
    Preconditions.checkNotNull(command, "Command is null");
    Preconditions.checkNotNull(unit, "Unit is null");
    initializeManagedContext(command);
    return scheduleOnMembers(command, getNodeEngine().getClusterService().getMembers(), delay, unit);
  }
  
  public <V> Map<Member, IScheduledFuture<V>> scheduleOnAllMembers(Callable<V> command, long delay, TimeUnit unit) {
    Preconditions.checkNotNull(command, "Command is null");
    Preconditions.checkNotNull(unit, "Unit is null");
    initializeManagedContext(command);
    return scheduleOnMembers(command, getNodeEngine().getClusterService().getMembers(), delay, unit);
  }
  
  public Map<Member, IScheduledFuture<?>> scheduleOnAllMembersAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
    Preconditions.checkNotNull(command, "Command is null");
    Preconditions.checkNotNull(unit, "Unit is null");
    initializeManagedContext(command);
    return scheduleOnMembersAtFixedRate(command, getNodeEngine().getClusterService().getMembers(), initialDelay, period, unit);
  }
  
  public Map<Member, IScheduledFuture<?>> scheduleOnMembers(Runnable command, Collection<Member> members, long delay, TimeUnit unit) {
    Preconditions.checkNotNull(command, "Command is null");
    Preconditions.checkNotNull(members, "Members is null");
    Preconditions.checkNotNull(unit, "Unit is null");
    initializeManagedContext(command);
    ScheduledRunnableAdapter callable = createScheduledRunnableAdapter(command);
    return scheduleOnMembers(callable, members, delay, unit);
  }
  
  public <V> Map<Member, IScheduledFuture<V>> scheduleOnMembers(Callable<V> command, Collection<Member> members, long delay, TimeUnit unit) {
    Preconditions.checkNotNull(command, "Command is null");
    Preconditions.checkNotNull(members, "Members is null");
    Preconditions.checkNotNull(unit, "Unit is null");
    initializeManagedContext(command);
    String name = extractNameOrGenerateOne(command);
    Map<Member, IScheduledFuture<V>> futures = MapUtil.createHashMap(members.size());
    for (Member member : members) {
      TaskDefinition<V> definition = new TaskDefinition<V>(TaskDefinition.Type.SINGLE_RUN, name, command, delay, unit);
      futures.put(member, 
          submitOnMemberSync(name, new ScheduleTaskOperation(getName(), definition), member));
    } 
    return futures;
  }
  
  public Map<Member, IScheduledFuture<?>> scheduleOnMembersAtFixedRate(Runnable command, Collection<Member> members, long initialDelay, long period, TimeUnit unit) {
    Preconditions.checkNotNull(command, "Command is null");
    Preconditions.checkNotNull(members, "Members is null");
    Preconditions.checkNotNull(unit, "Unit is null");
    initializeManagedContext(command);
    String name = extractNameOrGenerateOne(command);
    ScheduledRunnableAdapter<?> adapter = createScheduledRunnableAdapter(command);
    Map<Member, IScheduledFuture<?>> futures = MapUtil.createHashMapAdapter(members.size());
    for (Member member : members) {
      TaskDefinition definition = new TaskDefinition(TaskDefinition.Type.AT_FIXED_RATE, name, adapter, initialDelay, period, unit);
      futures.put(member, submitOnMemberSync(name, new ScheduleTaskOperation(getName(), definition), member));
    } 
    return futures;
  }
  
  public IScheduledFuture<?> getScheduledFuture(ScheduledTaskHandler handler) {
    Preconditions.checkNotNull(handler, "Handler is null");
    ScheduledFutureProxy proxy = new ScheduledFutureProxy(handler, this);
    initializeManagedContext(proxy);
    return proxy;
  }
  
  public <V> Map<Member, List<IScheduledFuture<V>>> getAllScheduledFutures() {
    Map<Member, List<IScheduledFuture<V>>> accumulator = new LinkedHashMap<Member, List<IScheduledFuture<V>>>();
    retrieveAllPartitionOwnedScheduled(accumulator);
    retrieveAllMemberOwnedScheduled(accumulator);
    return accumulator;
  }
  
  public void shutdown() {
    NodeEngine nodeEngine = getNodeEngine();
    Collection<Member> members = nodeEngine.getClusterService().getMembers();
    OperationService operationService = nodeEngine.getOperationService();
    Collection<Future> calls = new LinkedList<Future>();
    for (Member member : members) {
      ShutdownOperation shutdownOperation = new ShutdownOperation(this.name);
      calls.add(operationService.invokeOnTarget("hz:impl:scheduledExecutorService", shutdownOperation, member.getAddress()));
    } 
    FutureUtil.waitWithDeadline(calls, 10L, TimeUnit.SECONDS, this.shutdownExceptionHandler);
  }
  
  private <V> void retrieveAllMemberOwnedScheduled(Map<Member, List<IScheduledFuture<V>>> accumulator) {
    try {
      InvokeOnMembers invokeOnMembers = new InvokeOnMembers(getNodeEngine(), getServiceName(), new GetAllScheduledOnMemberOperationFactory(this.name), getNodeEngine().getClusterService().getMembers());
      accumulateTaskHandlersAsScheduledFutures(accumulator, invokeOnMembers.invoke());
    } catch (Exception e) {
      throw ExceptionUtil.rethrow(e);
    } 
  }
  
  private <V> void retrieveAllPartitionOwnedScheduled(Map<Member, List<IScheduledFuture<V>>> accumulator) {
    try {
      accumulateTaskHandlersAsScheduledFutures(accumulator, 
          getNodeEngine().getOperationService().invokeOnAllPartitions(getServiceName(), new GetAllScheduledOnPartitionOperationFactory(this.name)));
    } catch (Throwable t) {
      throw ExceptionUtil.rethrow(t);
    } 
  }
  
  private <V> void accumulateTaskHandlersAsScheduledFutures(Map<Member, List<IScheduledFuture<V>>> accumulator, Map<?, ?> taskHandlersMap) {
    ClusterService clusterService = getNodeEngine().getClusterService();
    IPartitionService partitionService = getNodeEngine().getPartitionService();
    for (Map.Entry<?, ?> entry : taskHandlersMap.entrySet()) {
      Member owner;
      Object key = entry.getKey();
      if (key instanceof Number) {
        owner = clusterService.getMember(partitionService.getPartitionOwner(((Integer)key).intValue()));
      } else {
        owner = (Member)key;
      } 
      List<ScheduledTaskHandler> handlers = (List)entry.getValue();
      List<IScheduledFuture<V>> futures = new ArrayList<IScheduledFuture<V>>();
      for (ScheduledTaskHandler handler : handlers) {
        ScheduledFutureProxy scheduledFutureProxy = new ScheduledFutureProxy(handler, this);
        initializeManagedContext(scheduledFutureProxy);
        futures.add(scheduledFutureProxy);
      } 
      if (accumulator.containsKey(owner)) {
        List<IScheduledFuture<V>> memberFutures = (List)accumulator.get(owner);
        memberFutures.addAll(futures);
        continue;
      } 
      accumulator.put(owner, futures);
    } 
  }
  
  private <T> ScheduledRunnableAdapter<T> createScheduledRunnableAdapter(Runnable command) {
    Preconditions.checkNotNull(command, "Command can't be null");
    return new ScheduledRunnableAdapter(command);
  }
  
  private <V> IScheduledFuture<V> createFutureProxy(int partitionId, String taskName) {
    ScheduledFutureProxy proxy = new ScheduledFutureProxy(ScheduledTaskHandlerImpl.of(partitionId, getName(), taskName), this);
    proxy.setHazelcastInstance(getNodeEngine().getHazelcastInstance());
    return proxy;
  }
  
  private <V> IScheduledFuture<V> createFutureProxy(Address address, String taskName) {
    ScheduledFutureProxy proxy = new ScheduledFutureProxy(ScheduledTaskHandlerImpl.of(address, getName(), taskName), this);
    proxy.setHazelcastInstance(getNodeEngine().getHazelcastInstance());
    return proxy;
  }
  
  private int getKeyPartitionId(Object key) { return getNodeEngine().getPartitionService().getPartitionId(key); }
  
  private int getTaskOrKeyPartitionId(Callable task, Object key) {
    if (task instanceof PartitionAware) {
      Object newKey = ((PartitionAware)task).getPartitionKey();
      if (newKey != null)
        key = newKey; 
    } 
    return getKeyPartitionId(key);
  }
  
  private int getTaskOrKeyPartitionId(Runnable task, Object key) {
    if (task instanceof PartitionAware) {
      Object newKey = ((PartitionAware)task).getPartitionKey();
      if (newKey != null)
        key = newKey; 
    } 
    return getKeyPartitionId(key);
  }
  
  private String extractNameOrGenerateOne(Object command) {
    String name = null;
    if (command instanceof NamedTask)
      name = ((NamedTask)command).getName(); 
    return (name != null) ? name : UuidUtil.newUnsecureUuidString();
  }
  
  private <V> IScheduledFuture<V> submitOnPartitionSync(String taskName, Operation op, int partitionId) {
    op.setPartitionId(partitionId);
    invokeOnPartition(op).join();
    return createFutureProxy(partitionId, taskName);
  }
  
  private <V> IScheduledFuture<V> submitOnMemberSync(String taskName, Operation op, Member member) {
    Address address = member.getAddress();
    getOperationService().invokeOnTarget(getServiceName(), op, address).join();
    return createFutureProxy(address, taskName);
  }
  
  private void initializeManagedContext(Object object) {
    ManagedContext context = getNodeEngine().getSerializationService().getManagedContext();
    if (object instanceof NamedTaskDecorator) {
      ((NamedTaskDecorator)object).initializeContext(context);
    } else {
      context.initialize(object);
    } 
  }
}
