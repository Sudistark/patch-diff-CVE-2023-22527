package com.hazelcast.scheduledexecutor.impl.operations;

import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.scheduledexecutor.impl.DistributedScheduledExecutorService;
import com.hazelcast.scheduledexecutor.impl.ScheduledExecutorContainer;
import com.hazelcast.scheduledexecutor.impl.ScheduledExecutorDataSerializerHook;
import com.hazelcast.scheduledexecutor.impl.ScheduledExecutorPartition;
import com.hazelcast.scheduledexecutor.impl.ScheduledTaskDescriptor;
import com.hazelcast.util.MapUtil;
import java.io.IOException;
import java.util.Map;

public class ReplicationOperation extends AbstractSchedulerOperation {
  private Map<String, Map<String, ScheduledTaskDescriptor>> map;
  
  public ReplicationOperation() {}
  
  public ReplicationOperation(Map<String, Map<String, ScheduledTaskDescriptor>> map) { this.map = map; }
  
  public void run() {
    DistributedScheduledExecutorService service = (DistributedScheduledExecutorService)getService();
    ScheduledExecutorPartition partition = service.getPartition(getPartitionId());
    for (Map.Entry<String, Map<String, ScheduledTaskDescriptor>> entry : this.map.entrySet()) {
      ScheduledExecutorContainer container = partition.getOrCreateContainer((String)entry.getKey());
      for (Map.Entry<String, ScheduledTaskDescriptor> descriptorEntry : ((Map)entry.getValue()).entrySet()) {
        String taskName = (String)descriptorEntry.getKey();
        ScheduledTaskDescriptor descriptor = (ScheduledTaskDescriptor)descriptorEntry.getValue();
        if (!container.has(taskName))
          container.enqueueSuspended(descriptor, false); 
      } 
    } 
  }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException {
    out.writeInt(this.map.size());
    for (Map.Entry<String, Map<String, ScheduledTaskDescriptor>> entry : this.map.entrySet()) {
      out.writeUTF((String)entry.getKey());
      out.writeInt(((Map)entry.getValue()).size());
      for (Map.Entry<String, ScheduledTaskDescriptor> subEntry : ((Map)entry.getValue()).entrySet()) {
        out.writeUTF((String)subEntry.getKey());
        out.writeObject(subEntry.getValue());
      } 
    } 
  }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    int size = in.readInt();
    this.map = MapUtil.createHashMap(size);
    for (int i = 0; i < size; i++) {
      String key = in.readUTF();
      int subSize = in.readInt();
      Map<String, ScheduledTaskDescriptor> subMap = MapUtil.createHashMap(subSize);
      this.map.put(key, subMap);
      for (int k = 0; k < subSize; k++)
        subMap.put(in.readUTF(), (ScheduledTaskDescriptor)in.readObject()); 
    } 
  }
  
  public int getFactoryId() { return ScheduledExecutorDataSerializerHook.F_ID; }
  
  public int getId() { return 19; }
}
