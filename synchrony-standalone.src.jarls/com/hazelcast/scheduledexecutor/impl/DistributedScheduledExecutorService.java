package com.hazelcast.scheduledexecutor.impl;

import com.hazelcast.config.ScheduledExecutorConfig;
import com.hazelcast.core.DistributedObject;
import com.hazelcast.internal.config.ConfigValidator;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.MemberAttributeServiceEvent;
import com.hazelcast.spi.MembershipAwareService;
import com.hazelcast.spi.MembershipServiceEvent;
import com.hazelcast.spi.MigrationAwareService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.PartitionMigrationEvent;
import com.hazelcast.spi.PartitionReplicationEvent;
import com.hazelcast.spi.QuorumAwareService;
import com.hazelcast.spi.RemoteService;
import com.hazelcast.spi.SplitBrainHandlerService;
import com.hazelcast.spi.impl.executionservice.InternalExecutionService;
import com.hazelcast.spi.partition.MigrationEndpoint;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.ContextMutexFactory;
import com.hazelcast.util.ExceptionUtil;
import java.util.Collections;
import java.util.Properties;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicBoolean;

public class DistributedScheduledExecutorService implements ManagedService, RemoteService, MigrationAwareService, QuorumAwareService, SplitBrainHandlerService, MembershipAwareService {
  public static final String SERVICE_NAME = "hz:impl:scheduledExecutorService";
  
  public static final int MEMBER_BIN = -1;
  
  private static final Object NULL_OBJECT = new Object();
  
  private final ConcurrentMap<String, Boolean> shutdownExecutors = new ConcurrentHashMap();
  
  private final Set<ScheduledFutureProxy> lossListeners = Collections.synchronizedSet(Collections.newSetFromMap(new WeakHashMap()));
  
  private final AtomicBoolean migrationMode = new AtomicBoolean();
  
  private final ConcurrentMap<String, Object> quorumConfigCache = new ConcurrentHashMap();
  
  private final ContextMutexFactory quorumConfigCacheMutexFactory = new ContextMutexFactory();
  
  private final ConstructorFunction<String, Object> quorumConfigConstructor = new Object(this);
  
  private NodeEngine nodeEngine;
  
  private ScheduledExecutorPartition[] partitions;
  
  private ScheduledExecutorMemberBin memberBin;
  
  private String partitionLostRegistration;
  
  public void init(NodeEngine nodeEngine, Properties properties) {
    int partitionCount = nodeEngine.getPartitionService().getPartitionCount();
    this.nodeEngine = nodeEngine;
    this.partitions = new ScheduledExecutorPartition[partitionCount];
    reset();
  }
  
  public ScheduledExecutorPartition getPartition(int partitionId) { return this.partitions[partitionId]; }
  
  public ScheduledExecutorContainerHolder getPartitionOrMemberBin(int id) {
    if (id == -1)
      return this.memberBin; 
    return getPartition(id);
  }
  
  public NodeEngine getNodeEngine() { return this.nodeEngine; }
  
  public void reset() {
    shutdown(true);
    this.memberBin = new ScheduledExecutorMemberBin(this.nodeEngine);
    if (this.partitionLostRegistration == null)
      registerPartitionListener(); 
    for (int partitionId = 0; partitionId < this.partitions.length; partitionId++) {
      if (this.partitions[partitionId] != null)
        this.partitions[partitionId].destroy(); 
      this.partitions[partitionId] = new ScheduledExecutorPartition(this.nodeEngine, partitionId);
    } 
  }
  
  public void shutdown(boolean terminate) {
    this.shutdownExecutors.clear();
    if (this.memberBin != null)
      this.memberBin.destroy(); 
    this.lossListeners.clear();
    unRegisterPartitionListenerIfExists();
    for (ScheduledExecutorPartition partition : this.partitions) {
      if (partition != null)
        partition.destroy(); 
    } 
  }
  
  void addLossListener(ScheduledFutureProxy future) { this.lossListeners.add(future); }
  
  public DistributedObject createDistributedObject(String name) {
    ScheduledExecutorConfig executorConfig = this.nodeEngine.getConfig().findScheduledExecutorConfig(name);
    ConfigValidator.checkScheduledExecutorConfig(executorConfig, this.nodeEngine.getSplitBrainMergePolicyProvider());
    return new ScheduledExecutorServiceProxy(name, this.nodeEngine, this);
  }
  
  public void destroyDistributedObject(String name) {
    if (this.shutdownExecutors.remove(name) == null)
      ((InternalExecutionService)this.nodeEngine.getExecutionService()).shutdownScheduledDurableExecutor(name); 
    resetPartitionOrMemberBinContainer(name);
    this.quorumConfigCache.remove(name);
  }
  
  public void shutdownExecutor(String name) {
    if (this.shutdownExecutors.putIfAbsent(name, Boolean.TRUE) == null)
      ((InternalExecutionService)this.nodeEngine.getExecutionService()).shutdownScheduledDurableExecutor(name); 
  }
  
  public boolean isShutdown(String name) { return this.shutdownExecutors.containsKey(name); }
  
  public Operation prepareReplicationOperation(PartitionReplicationEvent event) {
    int partitionId = event.getPartitionId();
    ScheduledExecutorPartition partition = this.partitions[partitionId];
    return partition.prepareReplicationOperation(event.getReplicaIndex(), this.migrationMode.get());
  }
  
  public Runnable prepareMergeRunnable() {
    ScheduledExecutorContainerCollector collector = new ScheduledExecutorContainerCollector(this.nodeEngine, this.partitions);
    collector.run();
    return new Merger(this, collector);
  }
  
  public void beforeMigration(PartitionMigrationEvent event) { this.migrationMode.compareAndSet(false, true); }
  
  public void commitMigration(PartitionMigrationEvent event) {
    int partitionId = event.getPartitionId();
    if (event.getMigrationEndpoint() == MigrationEndpoint.SOURCE) {
      discardReserved(partitionId, event.getNewReplicaIndex());
    } else if (event.getNewReplicaIndex() == 0) {
      ScheduledExecutorPartition partition = this.partitions[partitionId];
      partition.promoteSuspended();
    } 
    this.migrationMode.set(false);
  }
  
  public void rollbackMigration(PartitionMigrationEvent event) {
    int partitionId = event.getPartitionId();
    if (event.getMigrationEndpoint() == MigrationEndpoint.DESTINATION) {
      discardReserved(event.getPartitionId(), event.getCurrentReplicaIndex());
    } else if (event.getCurrentReplicaIndex() == 0) {
      ScheduledExecutorPartition partition = this.partitions[partitionId];
      partition.promoteSuspended();
    } 
    this.migrationMode.set(false);
  }
  
  private void discardReserved(int partitionId, int thresholdReplicaIndex) {
    ScheduledExecutorPartition partition = this.partitions[partitionId];
    partition.disposeObsoleteReplicas(thresholdReplicaIndex);
  }
  
  private void resetPartitionOrMemberBinContainer(String name) {
    if (this.memberBin != null)
      this.memberBin.destroyContainer(name); 
    for (ScheduledExecutorPartition partition : this.partitions)
      partition.destroyContainer(name); 
  }
  
  private void registerPartitionListener() { this
      .partitionLostRegistration = getNodeEngine().getPartitionService().addPartitionLostListener(new Object(this)); }
  
  private void unRegisterPartitionListenerIfExists() {
    if (this.partitionLostRegistration == null)
      return; 
    try {
      getNodeEngine().getPartitionService().removePartitionLostListener(this.partitionLostRegistration);
    } catch (Exception ex) {
      if (ExceptionUtil.peel(ex, com.hazelcast.core.HazelcastInstanceNotActiveException.class, null) instanceof com.hazelcast.core.HazelcastInstanceNotActiveException)
        throw ExceptionUtil.rethrow(ex); 
    } 
    this.partitionLostRegistration = null;
  }
  
  public void memberAdded(MembershipServiceEvent event) {}
  
  public void memberRemoved(MembershipServiceEvent event) {
    ScheduledFutureProxy[] futures = (ScheduledFutureProxy[])this.lossListeners.toArray(new ScheduledFutureProxy[0]);
    for (ScheduledFutureProxy future : futures)
      future.notifyMemberLost(event); 
  }
  
  public void memberAttributeChanged(MemberAttributeServiceEvent event) {}
  
  public String getQuorumName(String name) {
    Object quorumName = ConcurrencyUtil.getOrPutSynchronized(this.quorumConfigCache, name, this.quorumConfigCacheMutexFactory, this.quorumConfigConstructor);
    return (quorumName == NULL_OBJECT) ? null : (String)quorumName;
  }
}
