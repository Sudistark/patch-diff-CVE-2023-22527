package com.hazelcast.org.snakeyaml.engine.v2.parser;

import com.hazelcast.org.snakeyaml.engine.v2.api.LoadSettings;
import com.hazelcast.org.snakeyaml.engine.v2.common.Anchor;
import com.hazelcast.org.snakeyaml.engine.v2.common.ArrayStack;
import com.hazelcast.org.snakeyaml.engine.v2.common.FlowStyle;
import com.hazelcast.org.snakeyaml.engine.v2.common.ScalarStyle;
import com.hazelcast.org.snakeyaml.engine.v2.common.SpecVersion;
import com.hazelcast.org.snakeyaml.engine.v2.events.AliasEvent;
import com.hazelcast.org.snakeyaml.engine.v2.events.Event;
import com.hazelcast.org.snakeyaml.engine.v2.events.ImplicitTuple;
import com.hazelcast.org.snakeyaml.engine.v2.events.MappingStartEvent;
import com.hazelcast.org.snakeyaml.engine.v2.events.ScalarEvent;
import com.hazelcast.org.snakeyaml.engine.v2.events.SequenceStartEvent;
import com.hazelcast.org.snakeyaml.engine.v2.exceptions.Mark;
import com.hazelcast.org.snakeyaml.engine.v2.exceptions.ParserException;
import com.hazelcast.org.snakeyaml.engine.v2.scanner.Scanner;
import com.hazelcast.org.snakeyaml.engine.v2.scanner.ScannerImpl;
import com.hazelcast.org.snakeyaml.engine.v2.scanner.StreamReader;
import com.hazelcast.org.snakeyaml.engine.v2.tokens.AliasToken;
import com.hazelcast.org.snakeyaml.engine.v2.tokens.AnchorToken;
import com.hazelcast.org.snakeyaml.engine.v2.tokens.DirectiveToken;
import com.hazelcast.org.snakeyaml.engine.v2.tokens.ScalarToken;
import com.hazelcast.org.snakeyaml.engine.v2.tokens.TagToken;
import com.hazelcast.org.snakeyaml.engine.v2.tokens.TagTuple;
import com.hazelcast.org.snakeyaml.engine.v2.tokens.Token;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;

public class ParserImpl implements Parser {
  private static final Map<String, String> DEFAULT_TAGS = new HashMap();
  
  protected final Scanner scanner;
  
  private final LoadSettings settings;
  
  private Optional<Event> currentEvent;
  
  private final ArrayStack<Production> states;
  
  private final ArrayStack<Optional<Mark>> marksStack;
  
  private Optional<Production> state;
  
  private VersionTagsTuple directives;
  
  static  {
    DEFAULT_TAGS.put("!", "!");
    DEFAULT_TAGS.put("!!", "tag:yaml.org,2002:");
  }
  
  public ParserImpl(StreamReader reader, LoadSettings settings) { this(new ScannerImpl(reader), settings); }
  
  public ParserImpl(Scanner scanner, LoadSettings settings) {
    this.scanner = scanner;
    this.settings = settings;
    this.currentEvent = Optional.empty();
    this.directives = new VersionTagsTuple(Optional.empty(), new HashMap(DEFAULT_TAGS));
    this.states = new ArrayStack(100);
    this.marksStack = new ArrayStack(10);
    this.state = Optional.of(new ParseStreamStart(this, null));
  }
  
  public boolean checkEvent(Event.ID choice) {
    peekEvent();
    return (this.currentEvent.isPresent() && ((Event)this.currentEvent.get()).getEventId() == choice);
  }
  
  private void produce() {
    if (!this.currentEvent.isPresent())
      this.state.ifPresent(prod -> this.currentEvent = Optional.of(prod.produce())); 
  }
  
  public Event peekEvent() {
    produce();
    return (Event)this.currentEvent.orElseThrow(() -> new NoSuchElementException("No more Events found."));
  }
  
  public Event next() {
    peekEvent();
    Event value = (Event)this.currentEvent.orElseThrow(() -> new NoSuchElementException("No more Events found."));
    this.currentEvent = Optional.empty();
    return value;
  }
  
  public boolean hasNext() {
    produce();
    return this.currentEvent.isPresent();
  }
  
  private VersionTagsTuple processDirectives() {
    Optional<SpecVersion> yamlSpecVersion = Optional.empty();
    HashMap<String, String> tagHandles = new HashMap<String, String>();
    while (this.scanner.checkToken(new Token.ID[] { Token.ID.Directive })) {
      DirectiveToken token = (DirectiveToken)this.scanner.next();
      Optional<List<?>> dirOption = token.getValue();
      if (dirOption.isPresent()) {
        List<?> directiveValue = (List)dirOption.get();
        if (token.getName().equals("YAML")) {
          if (yamlSpecVersion.isPresent())
            throw new ParserException("found duplicate YAML directive", token.getStartMark()); 
          List<Integer> value = directiveValue;
          Integer major = (Integer)value.get(0);
          Integer minor = (Integer)value.get(1);
          yamlSpecVersion = Optional.of(this.settings.getVersionFunction().apply(new SpecVersion(major.intValue(), minor.intValue())));
          continue;
        } 
        if (token.getName().equals("TAG")) {
          List<String> value = directiveValue;
          String handle = (String)value.get(0);
          String prefix = (String)value.get(1);
          if (tagHandles.containsKey(handle))
            throw new ParserException("duplicate tag handle " + handle, token
                .getStartMark()); 
          tagHandles.put(handle, prefix);
        } 
      } 
    } 
    if (!yamlSpecVersion.isPresent() || !tagHandles.isEmpty()) {
      for (Map.Entry<String, String> entry : DEFAULT_TAGS.entrySet()) {
        if (!tagHandles.containsKey(entry.getKey()))
          tagHandles.put(entry.getKey(), entry.getValue()); 
      } 
      this.directives = new VersionTagsTuple(yamlSpecVersion, tagHandles);
    } 
    return this.directives;
  }
  
  private Event parseFlowNode() { return parseNode(false, false); }
  
  private Event parseBlockNodeOrIndentlessSequence() { return parseNode(true, true); }
  
  private Event parseNode(boolean block, boolean indentlessSequence) {
    ScalarEvent scalarEvent;
    Optional<Mark> startMark = Optional.empty();
    Optional<Mark> endMark = Optional.empty();
    Optional<Mark> tagMark = Optional.empty();
    if (this.scanner.checkToken(new Token.ID[] { Token.ID.Alias })) {
      AliasToken token = (AliasToken)this.scanner.next();
      scalarEvent = new AliasEvent(Optional.of(token.getValue()), token.getStartMark(), token.getEndMark());
      this.state = Optional.of(this.states.pop());
    } else {
      Optional<Anchor> anchor = Optional.empty();
      TagTuple tagTupleValue = null;
      if (this.scanner.checkToken(new Token.ID[] { Token.ID.Anchor })) {
        AnchorToken token = (AnchorToken)this.scanner.next();
        startMark = token.getStartMark();
        endMark = token.getEndMark();
        anchor = Optional.of(token.getValue());
        if (this.scanner.checkToken(new Token.ID[] { Token.ID.Tag })) {
          TagToken tagToken = (TagToken)this.scanner.next();
          tagMark = tagToken.getStartMark();
          endMark = tagToken.getEndMark();
          tagTupleValue = tagToken.getValue();
        } 
      } else {
        TagToken tagToken = (TagToken)this.scanner.next();
        startMark = tagToken.getStartMark();
        tagMark = startMark;
        endMark = tagToken.getEndMark();
        tagTupleValue = tagToken.getValue();
        if (this.scanner.checkToken(new Token.ID[] { Token.ID.Tag }) && this.scanner.checkToken(new Token.ID[] { Token.ID.Anchor })) {
          AnchorToken token = (AnchorToken)this.scanner.next();
          endMark = token.getEndMark();
          anchor = Optional.of(token.getValue());
        } 
      } 
      Optional<String> tag = Optional.empty();
      if (tagTupleValue != null) {
        String handle = tagTupleValue.getHandle();
        String suffix = tagTupleValue.getSuffix();
        if (handle != null) {
          if (!this.directives.getTags().containsKey(handle))
            throw new ParserException("while parsing a node", startMark, "found undefined tag handle " + handle, tagMark); 
          tag = Optional.of((String)this.directives.getTags().get(handle) + suffix);
        } else {
          tag = Optional.of(suffix);
        } 
      } 
      if (!startMark.isPresent()) {
        startMark = this.scanner.peekToken().getStartMark();
        endMark = startMark;
      } 
      boolean implicit = !tag.isPresent();
      if (indentlessSequence && this.scanner.checkToken(new Token.ID[] { Token.ID.BlockEntry })) {
        endMark = this.scanner.peekToken().getEndMark();
        scalarEvent = new SequenceStartEvent(anchor, tag, implicit, FlowStyle.BLOCK, startMark, endMark);
        this.state = Optional.of(new ParseIndentlessSequenceEntry(this, null));
      } else if (this.scanner.checkToken(new Token.ID[] { Token.ID.Scalar })) {
        ImplicitTuple implicitValues;
        ScalarToken token = (ScalarToken)this.scanner.next();
        endMark = token.getEndMark();
        if (token.isPlain() && !tag.isPresent()) {
          implicitValues = new ImplicitTuple(true, false);
        } else if (!tag.isPresent()) {
          implicitValues = new ImplicitTuple(false, true);
        } else {
          implicitValues = new ImplicitTuple(false, false);
        } 
        scalarEvent = new ScalarEvent(anchor, tag, implicitValues, token.getValue(), token.getStyle(), startMark, endMark);
        this.state = Optional.of(this.states.pop());
      } else if (this.scanner.checkToken(new Token.ID[] { Token.ID.FlowSequenceStart })) {
        endMark = this.scanner.peekToken().getEndMark();
        scalarEvent = new SequenceStartEvent(anchor, tag, implicit, FlowStyle.FLOW, startMark, endMark);
        this.state = Optional.of(new ParseFlowSequenceFirstEntry(this, null));
      } else if (this.scanner.checkToken(new Token.ID[] { Token.ID.FlowMappingStart })) {
        endMark = this.scanner.peekToken().getEndMark();
        scalarEvent = new MappingStartEvent(anchor, tag, implicit, FlowStyle.FLOW, startMark, endMark);
        this.state = Optional.of(new ParseFlowMappingFirstKey(this, null));
      } else if (block && this.scanner.checkToken(new Token.ID[] { Token.ID.BlockSequenceStart })) {
        endMark = this.scanner.peekToken().getStartMark();
        scalarEvent = new SequenceStartEvent(anchor, tag, implicit, FlowStyle.BLOCK, startMark, endMark);
        this.state = Optional.of(new ParseBlockSequenceFirstEntry(this, null));
      } else if (block && this.scanner.checkToken(new Token.ID[] { Token.ID.BlockMappingStart })) {
        endMark = this.scanner.peekToken().getStartMark();
        scalarEvent = new MappingStartEvent(anchor, tag, implicit, FlowStyle.BLOCK, startMark, endMark);
        this.state = Optional.of(new ParseBlockMappingFirstKey(this, null));
      } else if (anchor.isPresent() || tag.isPresent()) {
        scalarEvent = new ScalarEvent(anchor, tag, new ImplicitTuple(implicit, false), "", ScalarStyle.PLAIN, startMark, endMark);
        this.state = Optional.of(this.states.pop());
      } else {
        String node;
        if (block) {
          node = "block";
        } else {
          node = "flow";
        } 
        Token token = this.scanner.peekToken();
        throw new ParserException("while parsing a " + node + " node", startMark, "expected the node content, but found '" + token
            .getTokenId() + "'", token
            .getStartMark());
      } 
    } 
    return scalarEvent;
  }
  
  private Event processEmptyScalar(Optional<Mark> mark) { return new ScalarEvent(Optional.empty(), Optional.empty(), new ImplicitTuple(true, false), "", ScalarStyle.PLAIN, mark, mark); }
  
  private Optional<Mark> markPop() { return (Optional)this.marksStack.pop(); }
  
  private void markPush(Optional<Mark> mark) { this.marksStack.push(mark); }
}
