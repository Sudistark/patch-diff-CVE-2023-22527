package com.hazelcast.aggregation.impl;

import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.IdentifiedDataSerializable;
import com.hazelcast.query.impl.Comparables;
import com.hazelcast.util.MapUtil;
import java.io.IOException;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;

public final class CanonicalizingHashSet<E> extends Object implements Set<E>, IdentifiedDataSerializable {
  private HashMap<Object, E> map;
  
  public CanonicalizingHashSet() { this.map = new HashMap(); }
  
  public CanonicalizingHashSet(int capacity) { this.map = new HashMap(capacity); }
  
  void addAllInternal(CanonicalizingHashSet<E> set) { this.map.putAll(set.map); }
  
  void addInternal(E e) { this.map.put(canonicalize(e), e); }
  
  public void writeData(ObjectDataOutput out) throws IOException {
    out.writeInt(size());
    for (Object element : this)
      out.writeObject(element); 
  }
  
  public void readData(ObjectDataInput in) throws IOException {
    int count = in.readInt();
    this.map = new HashMap(MapUtil.calculateInitialCapacity(count));
    for (int i = 0; i < count; i++) {
      E element = (E)in.readObject();
      addInternal(element);
    } 
  }
  
  public int getFactoryId() { return AggregatorDataSerializerHook.F_ID; }
  
  public int getId() { return 19; }
  
  public int size() { return this.map.size(); }
  
  public boolean isEmpty() { return this.map.isEmpty(); }
  
  public boolean contains(Object o) { return this.map.containsKey(canonicalize(o)); }
  
  public Iterator<E> iterator() { return this.map.values().iterator(); }
  
  public Object[] toArray() { return this.map.values().toArray(); }
  
  public <T> T[] toArray(T[] a) { return (T[])this.map.values().toArray(a); }
  
  public boolean add(E e) { throw new UnsupportedOperationException(); }
  
  public boolean remove(Object o) { throw new UnsupportedOperationException(); }
  
  public boolean containsAll(Collection<?> c) {
    for (Object element : c) {
      if (!contains(element))
        return false; 
    } 
    return true;
  }
  
  public boolean addAll(Collection<? extends E> c) { throw new UnsupportedOperationException(); }
  
  public boolean retainAll(Collection<?> c) { throw new UnsupportedOperationException(); }
  
  public boolean removeAll(Collection<?> c) { throw new UnsupportedOperationException(); }
  
  public void clear() { throw new UnsupportedOperationException(); }
  
  public int hashCode() { return this.map.keySet().hashCode(); }
  
  public boolean equals(Object obj) {
    if (this == obj)
      return true; 
    if (!(obj instanceof Set))
      return false; 
    Set that = (Set)obj;
    return containsAll(that);
  }
  
  public String toString() { return this.map.values().toString(); }
  
  private static Object canonicalize(Object value) {
    if (value instanceof Comparable)
      return Comparables.canonicalizeForHashLookup((Comparable)value); 
    return value;
  }
}
