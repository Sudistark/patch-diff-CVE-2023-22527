package com.hazelcast.map.impl.journal;

import com.hazelcast.config.EventJournalConfig;
import com.hazelcast.config.InMemoryFormat;
import com.hazelcast.config.RingbufferConfig;
import com.hazelcast.core.EntryEventType;
import com.hazelcast.internal.serialization.InternalSerializationService;
import com.hazelcast.logging.ILogger;
import com.hazelcast.map.impl.MapContainer;
import com.hazelcast.map.impl.MapServiceContext;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.nio.serialization.DataType;
import com.hazelcast.ringbuffer.impl.ReadResultSetImpl;
import com.hazelcast.ringbuffer.impl.RingbufferContainer;
import com.hazelcast.ringbuffer.impl.RingbufferService;
import com.hazelcast.ringbuffer.impl.RingbufferWaitNotifyKey;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.ObjectNamespace;
import com.hazelcast.spi.WaitNotifyKey;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.impl.operationparker.OperationParker;

public class RingbufferMapEventJournalImpl implements MapEventJournal {
  private final NodeEngineImpl nodeEngine;
  
  private final MapServiceContext mapServiceContext;
  
  private final ILogger logger;
  
  public RingbufferMapEventJournalImpl(NodeEngine engine, MapServiceContext mapServiceContext) {
    this.nodeEngine = (NodeEngineImpl)engine;
    this.mapServiceContext = mapServiceContext;
    this.logger = this.nodeEngine.getLogger(RingbufferMapEventJournalImpl.class);
  }
  
  public void writeUpdateEvent(EventJournalConfig journalConfig, ObjectNamespace namespace, int partitionId, Data key, Object oldValue, Object newValue) { addToEventRingbuffer(journalConfig, namespace, partitionId, EntryEventType.UPDATED, key, oldValue, newValue); }
  
  public void writeAddEvent(EventJournalConfig journalConfig, ObjectNamespace namespace, int partitionId, Data key, Object value) { addToEventRingbuffer(journalConfig, namespace, partitionId, EntryEventType.ADDED, key, null, value); }
  
  public void writeRemoveEvent(EventJournalConfig journalConfig, ObjectNamespace namespace, int partitionId, Data key, Object value) { addToEventRingbuffer(journalConfig, namespace, partitionId, EntryEventType.REMOVED, key, value, null); }
  
  public void writeEvictEvent(EventJournalConfig journalConfig, ObjectNamespace namespace, int partitionId, Data key, Object value) { addToEventRingbuffer(journalConfig, namespace, partitionId, EntryEventType.EVICTED, key, value, null); }
  
  public void writeLoadEvent(EventJournalConfig journalConfig, ObjectNamespace namespace, int partitionId, Data key, Object value) { addToEventRingbuffer(journalConfig, namespace, partitionId, EntryEventType.LOADED, key, null, value); }
  
  public long newestSequence(ObjectNamespace namespace, int partitionId) { return getRingbufferOrFail(namespace, partitionId).tailSequence(); }
  
  public long oldestSequence(ObjectNamespace namespace, int partitionId) { return getRingbufferOrFail(namespace, partitionId).headSequence(); }
  
  public boolean isPersistenceEnabled(ObjectNamespace namespace, int partitionId) { return getRingbufferOrFail(namespace, partitionId).getStore().isEnabled(); }
  
  public void destroy(ObjectNamespace namespace, int partitionId) {
    RingbufferService service;
    try {
      service = getRingbufferService();
    } catch (Exception e) {
      if (this.nodeEngine.isRunning())
        this.logger.fine("Could not retrieve ringbuffer service to destroy event journal " + namespace, e); 
      return;
    } 
    service.destroyContainer(partitionId, namespace);
  }
  
  public void isAvailableOrNextSequence(ObjectNamespace namespace, int partitionId, long sequence) { getRingbufferOrFail(namespace, partitionId).checkBlockableReadSequence(sequence); }
  
  public boolean isNextAvailableSequence(ObjectNamespace namespace, int partitionId, long sequence) { return getRingbufferOrFail(namespace, partitionId).shouldWait(sequence); }
  
  public WaitNotifyKey getWaitNotifyKey(ObjectNamespace namespace, int partitionId) { return new RingbufferWaitNotifyKey(namespace, partitionId); }
  
  public <T> long readMany(ObjectNamespace namespace, int partitionId, long beginSequence, ReadResultSetImpl<InternalEventJournalMapEvent, T> resultSet) { return getRingbufferOrFail(namespace, partitionId).readMany(beginSequence, resultSet); }
  
  public void cleanup(ObjectNamespace namespace, int partitionId) { getRingbufferOrFail(namespace, partitionId).cleanup(); }
  
  public boolean hasEventJournal(ObjectNamespace namespace) {
    EventJournalConfig config = getEventJournalConfig(namespace);
    return (config != null && config.isEnabled());
  }
  
  public EventJournalConfig getEventJournalConfig(ObjectNamespace namespace) { return this.nodeEngine.getConfig().findMapEventJournalConfig(namespace.getObjectName()); }
  
  public RingbufferConfig toRingbufferConfig(EventJournalConfig config, ObjectNamespace namespace) {
    MapContainer mapContainer = this.mapServiceContext.getMapContainer(namespace.getObjectName());
    int partitionCount = this.nodeEngine.getPartitionService().getPartitionCount();
    return (new RingbufferConfig())
      .setAsyncBackupCount(mapContainer.getAsyncBackupCount())
      .setBackupCount(mapContainer.getBackupCount())
      .setInMemoryFormat(InMemoryFormat.OBJECT)
      .setCapacity(config.getCapacity() / partitionCount)
      .setTimeToLiveSeconds(config.getTimeToLiveSeconds());
  }
  
  private void addToEventRingbuffer(EventJournalConfig journalConfig, ObjectNamespace namespace, int partitionId, EntryEventType eventType, Data key, Object oldValue, Object newValue) {
    if (journalConfig == null || !journalConfig.isEnabled())
      return; 
    RingbufferContainer<InternalEventJournalMapEvent, Object> eventContainer = getRingbufferOrNull(namespace, partitionId);
    if (eventContainer == null)
      return; 
    InternalEventJournalMapEvent event = new InternalEventJournalMapEvent(toData(key), toData(newValue), toData(oldValue), eventType.getType());
    eventContainer.add(event);
    getOperationParker().unpark(eventContainer);
  }
  
  private Data toData(Object val) { return getSerializationService().toData(val, DataType.HEAP); }
  
  private RingbufferContainer<InternalEventJournalMapEvent, Object> getRingbufferOrFail(ObjectNamespace namespace, int partitionId) {
    RingbufferContainer<InternalEventJournalMapEvent, Object> ringbuffer = getRingbufferOrNull(namespace, partitionId);
    if (ringbuffer == null)
      throw new IllegalStateException("There is no event journal configured for map with name: " + namespace
          .getObjectName()); 
    return ringbuffer;
  }
  
  private RingbufferContainer<InternalEventJournalMapEvent, Object> getRingbufferOrNull(ObjectNamespace namespace, int partitionId) {
    RingbufferService service = getRingbufferService();
    RingbufferContainer<InternalEventJournalMapEvent, Object> container = service.getContainerOrNull(partitionId, namespace);
    if (container != null)
      return container; 
    EventJournalConfig config = getEventJournalConfig(namespace);
    if (config == null || !config.isEnabled())
      return null; 
    RingbufferConfig ringbufferConfig = toRingbufferConfig(config, namespace);
    return service.getOrCreateContainer(partitionId, namespace, ringbufferConfig);
  }
  
  private RingbufferService getRingbufferService() { return (RingbufferService)this.nodeEngine.getService("hz:impl:ringbufferService"); }
  
  private OperationParker getOperationParker() { return this.nodeEngine.getOperationParker(); }
  
  private InternalSerializationService getSerializationService() { return (InternalSerializationService)this.nodeEngine.getSerializationService(); }
}
