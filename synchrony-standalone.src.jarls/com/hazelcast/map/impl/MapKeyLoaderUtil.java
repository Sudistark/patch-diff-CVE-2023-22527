package com.hazelcast.map.impl;

import com.hazelcast.config.MaxSizeConfig;
import com.hazelcast.core.IFunction;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.util.CollectionUtil;
import com.hazelcast.util.MapUtil;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

public final class MapKeyLoaderUtil {
  static MapKeyLoader.Role assignRole(boolean isPartitionOwner, boolean isMapNamePartition, boolean isMapNamePartitionFirstReplica) {
    if (isMapNamePartition) {
      if (isPartitionOwner)
        return MapKeyLoader.Role.SENDER; 
      if (isMapNamePartitionFirstReplica)
        return MapKeyLoader.Role.SENDER_BACKUP; 
      return MapKeyLoader.Role.NONE;
    } 
    return isPartitionOwner ? MapKeyLoader.Role.RECEIVER : MapKeyLoader.Role.NONE;
  }
  
  static Iterator<Map<Integer, List<Data>>> toBatches(Iterator<Map.Entry<Integer, Data>> entries, int maxBatch) { return new Object(entries, maxBatch); }
  
  private static Map<Integer, List<Data>> nextBatch(Iterator<Map.Entry<Integer, Data>> entries, int maxBatch) {
    Map<Integer, List<Data>> batch = MapUtil.createHashMap(maxBatch);
    while (entries.hasNext()) {
      Map.Entry<Integer, Data> e = (Map.Entry)entries.next();
      List<Data> partitionKeys = CollectionUtil.addToValueList(batch, e.getKey(), e.getValue());
      if (partitionKeys.size() >= maxBatch)
        break; 
    } 
    return batch;
  }
  
  public static int getMaxSizePerNode(MaxSizeConfig maxSizeConfig) {
    double maxSizePerNode = (maxSizeConfig.getMaxSizePolicy() == MaxSizeConfig.MaxSizePolicy.PER_NODE) ? maxSizeConfig.getSize() : -1.0D;
    if (maxSizePerNode == 2.147483647E9D)
      return -1; 
    return (int)maxSizePerNode;
  }
  
  static IFunction<Data, Map.Entry<Integer, Data>> toPartition(IPartitionService partitionService) { return new DataToEntry(partitionService); }
}
