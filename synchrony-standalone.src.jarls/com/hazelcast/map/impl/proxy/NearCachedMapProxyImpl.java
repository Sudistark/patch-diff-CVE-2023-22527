package com.hazelcast.map.impl.proxy;

import com.hazelcast.config.MapConfig;
import com.hazelcast.config.NearCacheConfig;
import com.hazelcast.core.ExecutionCallback;
import com.hazelcast.core.ICompletableFuture;
import com.hazelcast.internal.cluster.ClusterService;
import com.hazelcast.internal.nearcache.NearCache;
import com.hazelcast.internal.nearcache.impl.invalidation.RepairingHandler;
import com.hazelcast.map.EntryProcessor;
import com.hazelcast.map.impl.MapEntries;
import com.hazelcast.map.impl.MapService;
import com.hazelcast.map.impl.nearcache.MapNearCacheManager;
import com.hazelcast.map.impl.nearcache.invalidation.InvalidationListener;
import com.hazelcast.map.impl.nearcache.invalidation.UuidFilter;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.query.Predicate;
import com.hazelcast.spi.ExecutionService;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.MapUtil;
import com.hazelcast.util.executor.CompletedFuture;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

public class NearCachedMapProxyImpl<K, V> extends MapProxyImpl<K, V> {
  private final ClusterService clusterService;
  
  private final boolean cacheLocalEntries;
  
  private final boolean invalidateOnChange;
  
  private final boolean serializeKeys;
  
  private MapNearCacheManager mapNearCacheManager;
  
  private NearCache<Object, Object> nearCache;
  
  private RepairingHandler repairingHandler;
  
  public NearCachedMapProxyImpl(String name, MapService mapService, NodeEngine nodeEngine, MapConfig mapConfig) {
    super(name, mapService, nodeEngine, mapConfig);
    this.clusterService = nodeEngine.getClusterService();
    NearCacheConfig nearCacheConfig = mapConfig.getNearCacheConfig();
    this.cacheLocalEntries = nearCacheConfig.isCacheLocalEntries();
    this.invalidateOnChange = nearCacheConfig.isInvalidateOnChange();
    this.serializeKeys = nearCacheConfig.isSerializeKeys();
  }
  
  public NearCache<Object, Object> getNearCache() { return this.nearCache; }
  
  public void initialize() {
    super.initialize();
    this.mapNearCacheManager = this.mapServiceContext.getMapNearCacheManager();
    this.nearCache = this.mapNearCacheManager.getOrCreateNearCache(this.name, this.mapConfig.getNearCacheConfig());
    if (this.invalidateOnChange)
      registerInvalidationListener(); 
  }
  
  protected V getInternal(Object key) {
    key = toNearCacheKeyWithStrategy(key);
    V value = (V)getCachedValue(key, true);
    if (value != NearCache.NOT_CACHED)
      return value; 
    try {
      Data keyData = toDataWithStrategy(key);
      long reservationId = tryReserveForUpdate(key, keyData);
      value = (V)super.getInternal(keyData);
      if (reservationId != -1L)
        value = (V)tryPublishReserved(key, value, reservationId); 
      return value;
    } catch (Throwable throwable) {
      invalidateNearCache(key);
      throw ExceptionUtil.rethrow(throwable);
    } 
  }
  
  protected InternalCompletableFuture<Data> getAsyncInternal(Object key) {
    InternalCompletableFuture<Data> future;
    Object ncKey = toNearCacheKeyWithStrategy(key);
    Object value = getCachedValue(ncKey, false);
    if (value != NearCache.NOT_CACHED) {
      ExecutionService executionService = getNodeEngine().getExecutionService();
      return new CompletedFuture(this.serializationService, value, executionService.getExecutor("hz:async"));
    } 
    Data keyData = toDataWithStrategy(key);
    long reservationId = tryReserveForUpdate(ncKey, keyData);
    try {
      future = super.getAsyncInternal(keyData);
    } catch (Throwable t) {
      invalidateNearCache(ncKey);
      throw ExceptionUtil.rethrow(t);
    } 
    if (reservationId != -1L)
      future.andThen(new Object(this, ncKey, reservationId)); 
    return future;
  }
  
  protected Data putInternal(Object key, Data value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
    key = toNearCacheKeyWithStrategy(key);
    try {
      return super.putInternal(key, value, ttl, ttlUnit, maxIdle, maxIdleUnit);
    } finally {
      invalidateNearCache(key);
    } 
  }
  
  protected boolean setTtlInternal(Object key, long ttl, TimeUnit timeUnit) {
    key = toNearCacheKeyWithStrategy(key);
    try {
      return super.setTtlInternal(key, ttl, timeUnit);
    } finally {
      invalidateNearCache(key);
    } 
  }
  
  protected boolean tryPutInternal(Object key, Data value, long timeout, TimeUnit timeunit) {
    key = toNearCacheKeyWithStrategy(key);
    try {
      return super.tryPutInternal(key, value, timeout, timeunit);
    } finally {
      invalidateNearCache(key);
    } 
  }
  
  protected Data putIfAbsentInternal(Object key, Data value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
    key = toNearCacheKeyWithStrategy(key);
    try {
      return super.putIfAbsentInternal(key, value, ttl, ttlUnit, maxIdle, maxIdleUnit);
    } finally {
      invalidateNearCache(key);
    } 
  }
  
  protected void putTransientInternal(Object key, Data value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
    key = toNearCacheKeyWithStrategy(key);
    try {
      super.putTransientInternal(key, value, ttl, ttlUnit, maxIdle, maxIdleUnit);
    } finally {
      invalidateNearCache(key);
    } 
  }
  
  protected InternalCompletableFuture<Data> putAsyncInternal(Object key, Data value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
    key = toNearCacheKeyWithStrategy(key);
    try {
      return super.putAsyncInternal(key, value, ttl, ttlUnit, maxIdle, maxIdleUnit);
    } finally {
      invalidateNearCache(key);
    } 
  }
  
  protected InternalCompletableFuture<Data> setAsyncInternal(Object key, Data value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
    key = toNearCacheKeyWithStrategy(key);
    try {
      return super.setAsyncInternal(key, value, ttl, ttlUnit, maxIdle, maxIdleUnit);
    } finally {
      invalidateNearCache(key);
    } 
  }
  
  protected boolean replaceInternal(Object key, Data expect, Data update) {
    key = toNearCacheKeyWithStrategy(key);
    try {
      return super.replaceInternal(key, expect, update);
    } finally {
      invalidateNearCache(key);
    } 
  }
  
  protected Data replaceInternal(Object key, Data value) {
    key = toNearCacheKeyWithStrategy(key);
    try {
      return super.replaceInternal(key, value);
    } finally {
      invalidateNearCache(key);
    } 
  }
  
  protected void setInternal(Object key, Data value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
    key = toNearCacheKeyWithStrategy(key);
    try {
      super.setInternal(key, value, ttl, ttlUnit, maxIdle, maxIdleUnit);
    } finally {
      invalidateNearCache(key);
    } 
  }
  
  protected boolean evictInternal(Object key) {
    key = toNearCacheKeyWithStrategy(key);
    try {
      return super.evictInternal(key);
    } finally {
      invalidateNearCache(key);
    } 
  }
  
  protected void evictAllInternal() {
    try {
      super.evictAllInternal();
    } finally {
      this.nearCache.clear();
    } 
  }
  
  public void clearInternal() {
    try {
      super.clearInternal();
    } finally {
      this.nearCache.clear();
    } 
  }
  
  public void loadAllInternal(boolean replaceExistingValues) {
    try {
      super.loadAllInternal(replaceExistingValues);
    } finally {
      if (replaceExistingValues)
        this.nearCache.clear(); 
    } 
  }
  
  protected void loadInternal(Set<K> keys, Iterable<Data> dataKeys, boolean replaceExistingValues) {
    if (this.serializeKeys)
      dataKeys = convertToData(keys); 
    try {
      super.loadInternal(keys, dataKeys, replaceExistingValues);
    } finally {
      Iterable<?> ncKeys = this.serializeKeys ? dataKeys : keys;
      for (Object key : ncKeys)
        invalidateNearCache(key); 
    } 
  }
  
  protected Data removeInternal(Object key) {
    key = toNearCacheKeyWithStrategy(key);
    try {
      return super.removeInternal(key);
    } finally {
      invalidateNearCache(key);
    } 
  }
  
  protected void removeAllInternal(Predicate predicate) {
    try {
      super.removeAllInternal(predicate);
    } finally {
      this.nearCache.clear();
    } 
  }
  
  protected void deleteInternal(Object key) {
    key = toNearCacheKeyWithStrategy(key);
    try {
      super.deleteInternal(key);
    } finally {
      invalidateNearCache(key);
    } 
  }
  
  protected boolean removeInternal(Object key, Data value) {
    key = toNearCacheKeyWithStrategy(key);
    try {
      return super.removeInternal(key, value);
    } finally {
      invalidateNearCache(key);
    } 
  }
  
  protected boolean tryRemoveInternal(Object key, long timeout, TimeUnit timeunit) {
    key = toNearCacheKeyWithStrategy(key);
    try {
      return super.tryRemoveInternal(key, timeout, timeunit);
    } finally {
      invalidateNearCache(key);
    } 
  }
  
  protected InternalCompletableFuture<Data> removeAsyncInternal(Object key) {
    key = toNearCacheKeyWithStrategy(key);
    try {
      return super.removeAsyncInternal(key);
    } finally {
      invalidateNearCache(key);
    } 
  }
  
  protected boolean containsKeyInternal(Object key) {
    key = toNearCacheKeyWithStrategy(key);
    Object cachedValue = getCachedValue(key, false);
    if (cachedValue != NearCache.NOT_CACHED)
      return (cachedValue != null); 
    return super.containsKeyInternal(key);
  }
  
  protected void getAllInternal(Set<K> keys, List<Data> dataKeys, List<Object> resultingKeyValuePairs) {
    if (this.serializeKeys)
      toDataKeysWithReservations(keys, dataKeys, null, null); 
    Collection<?> ncKeys = this.serializeKeys ? dataKeys : new LinkedList(keys);
    populateResultFromNearCache(ncKeys, resultingKeyValuePairs);
    if (ncKeys.isEmpty())
      return; 
    reservations = MapUtil.createHashMap(ncKeys.size());
    Map<Data, Object> reverseKeyMap = null;
    if (!this.serializeKeys) {
      reverseKeyMap = MapUtil.createHashMap(ncKeys.size());
      toDataKeysWithReservations(ncKeys, dataKeys, reservations, reverseKeyMap);
    } else {
      createNearCacheReservations(ncKeys, reservations);
    } 
    try {
      int currentSize = resultingKeyValuePairs.size();
      super.getAllInternal(keys, dataKeys, resultingKeyValuePairs);
      populateResultFromRemote(currentSize, resultingKeyValuePairs, reservations, reverseKeyMap);
    } finally {
      releaseReservedKeys(reservations);
    } 
  }
  
  private void toDataKeysWithReservations(Collection<?> keys, Collection<Data> dataKeys, Map<Object, Long> reservations, Map<Data, Object> reverseKeyMap) {
    for (Object key : keys) {
      Data keyData = toDataWithStrategy(key);
      dataKeys.add(keyData);
      if (reservations != null) {
        long reservationId = tryReserveForUpdate(key, keyData);
        if (reservationId != -1L)
          reservations.put(key, Long.valueOf(reservationId)); 
      } 
      if (reverseKeyMap != null)
        reverseKeyMap.put(keyData, key); 
    } 
  }
  
  private void populateResultFromNearCache(Collection keys, List<Object> resultingKeyValuePairs) {
    Iterator iterator = keys.iterator();
    while (iterator.hasNext()) {
      Object key = iterator.next();
      Object value = getCachedValue(key, true);
      if (value != null && value != NearCache.NOT_CACHED) {
        resultingKeyValuePairs.add(key);
        resultingKeyValuePairs.add(value);
        iterator.remove();
      } 
    } 
  }
  
  private void createNearCacheReservations(Collection<Data> dataKeys, Map<Object, Long> reservations) {
    for (Data key : dataKeys) {
      long reservationId = tryReserveForUpdate(key, key);
      if (reservationId != -1L)
        reservations.put(key, Long.valueOf(reservationId)); 
    } 
  }
  
  private void populateResultFromRemote(int currentSize, List<Object> resultingKeyValuePairs, Map<Object, Long> reservations, Map<Data, Object> reverseKeyMap) {
    for (int i = currentSize; i < resultingKeyValuePairs.size(); i += 2) {
      Data keyData = (Data)resultingKeyValuePairs.get(i);
      Data valueData = (Data)resultingKeyValuePairs.get(i + 1);
      Object ncKey = this.serializeKeys ? keyData : reverseKeyMap.get(keyData);
      if (!this.serializeKeys)
        resultingKeyValuePairs.set(i, ncKey); 
      Long reservationId = (Long)reservations.get(ncKey);
      if (reservationId != null) {
        Object cachedValue = tryPublishReserved(ncKey, valueData, reservationId.longValue());
        resultingKeyValuePairs.set(i + 1, cachedValue);
        reservations.remove(ncKey);
      } 
    } 
  }
  
  private void releaseReservedKeys(Map<Object, Long> reservationResults) {
    for (Object key : reservationResults.keySet())
      invalidateNearCache(key); 
  }
  
  protected void invokePutAllOperationFactory(long size, int[] partitions, MapEntries[] entries) throws Exception {
    try {
      super.invokePutAllOperationFactory(size, partitions, entries);
    } finally {
      if (this.serializeKeys)
        for (MapEntries mapEntries : entries) {
          if (mapEntries != null)
            for (int i = 0; i < mapEntries.size(); i++)
              invalidateNearCache(mapEntries.getKey(i));  
        }  
    } 
  }
  
  protected void finalizePutAll(Map<?, ?> map) {
    try {
      super.finalizePutAll(map);
    } finally {
      if (!this.serializeKeys)
        for (Object key : map.keySet())
          invalidateNearCache(key);  
    } 
  }
  
  public Data executeOnKeyInternal(Object key, EntryProcessor entryProcessor) {
    key = toNearCacheKeyWithStrategy(key);
    try {
      return super.executeOnKeyInternal(key, entryProcessor);
    } finally {
      invalidateNearCache(key);
    } 
  }
  
  public ICompletableFuture<Map<K, Object>> submitToKeysInternal(Set<K> keys, Set<Data> dataKeys, EntryProcessor entryProcessor) {
    if (this.serializeKeys)
      toDataCollectionWithNonNullKeyValidation(keys, dataKeys); 
    try {
      return super.submitToKeysInternal(keys, dataKeys, entryProcessor);
    } finally {
      Set<?> ncKeys = this.serializeKeys ? dataKeys : keys;
      for (Object key : ncKeys)
        invalidateNearCache(key); 
    } 
  }
  
  public InternalCompletableFuture<Object> executeOnKeyInternal(Object key, EntryProcessor entryProcessor, ExecutionCallback<Object> callback) {
    key = toNearCacheKeyWithStrategy(key);
    try {
      return super.executeOnKeyInternal(key, entryProcessor, callback);
    } finally {
      invalidateNearCache(key);
    } 
  }
  
  public void executeOnEntriesInternal(EntryProcessor entryProcessor, Predicate predicate, List<Data> resultingKeyValuePairs) {
    try {
      super.executeOnEntriesInternal(entryProcessor, predicate, resultingKeyValuePairs);
    } finally {
      for (int i = 0; i < resultingKeyValuePairs.size(); i += 2) {
        Data key = (Data)resultingKeyValuePairs.get(i);
        invalidateNearCache(this.serializeKeys ? key : toObject(key));
      } 
    } 
  }
  
  protected void postDestroy() {
    try {
      if (this.invalidateOnChange) {
        this.mapNearCacheManager.deregisterRepairingHandler(this.name);
        removeEntryListener(this.invalidationListenerId);
      } 
    } finally {
      super.postDestroy();
    } 
  }
  
  protected void invalidateNearCache(Object key) {
    if (key == null)
      return; 
    this.nearCache.invalidate(key);
  }
  
  private Object tryPublishReserved(Object key, Object value, long reservationId) {
    assert value != NearCache.NOT_CACHED;
    Object cachedValue = this.nearCache.tryPublishReserved(key, value, reservationId, true);
    return (cachedValue != null) ? cachedValue : value;
  }
  
  private Object getCachedValue(Object key, boolean deserializeValue) {
    Object value = this.nearCache.get(key);
    if (value == null)
      return NearCache.NOT_CACHED; 
    if (value == NearCache.CACHED_AS_NULL)
      return null; 
    this.mapServiceContext.interceptAfterGet(this.name, value);
    return deserializeValue ? toObject(value) : value;
  }
  
  private long tryReserveForUpdate(Object key, Data keyData) {
    if (!cachingAllowedFor(keyData))
      return -1L; 
    return this.nearCache.tryReserveForUpdate(key, keyData);
  }
  
  private boolean cachingAllowedFor(Data keyData) { return (this.cacheLocalEntries || this.clusterService.getLocalMember().isLiteMember() || !isOwn(keyData)); }
  
  private boolean isOwn(Data key) {
    int partitionId = this.partitionService.getPartitionId(key);
    return this.partitionService.isPartitionOwner(partitionId);
  }
  
  private Object toNearCacheKeyWithStrategy(Object key) { return this.serializeKeys ? this.serializationService.toData(key, this.partitionStrategy) : key; }
  
  public String addNearCacheInvalidationListener(InvalidationListener listener) {
    String localMemberUuid = getNodeEngine().getClusterService().getLocalMember().getUuid();
    UuidFilter uuidFilter = new UuidFilter(localMemberUuid);
    return this.mapServiceContext.addEventListener(listener, uuidFilter, this.name);
  }
  
  private void registerInvalidationListener() {
    this.repairingHandler = this.mapNearCacheManager.newRepairingHandler(this.name, this.nearCache);
    this.invalidationListenerId = addNearCacheInvalidationListener(new NearCacheInvalidationListener(this, null));
  }
}
