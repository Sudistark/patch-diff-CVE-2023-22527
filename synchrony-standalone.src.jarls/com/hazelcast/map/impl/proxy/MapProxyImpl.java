package com.hazelcast.map.impl.proxy;

import com.hazelcast.aggregation.Aggregator;
import com.hazelcast.config.InMemoryFormat;
import com.hazelcast.config.MapConfig;
import com.hazelcast.core.EntryListener;
import com.hazelcast.core.EntryView;
import com.hazelcast.core.ExecutionCallback;
import com.hazelcast.core.HazelcastException;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.ICompletableFuture;
import com.hazelcast.core.IMap;
import com.hazelcast.core.ManagedContext;
import com.hazelcast.core.PartitioningStrategy;
import com.hazelcast.internal.cluster.Versions;
import com.hazelcast.internal.journal.EventJournalInitialSubscriberState;
import com.hazelcast.internal.journal.EventJournalReader;
import com.hazelcast.internal.util.SimpleCompletedFuture;
import com.hazelcast.map.EntryProcessor;
import com.hazelcast.map.MapInterceptor;
import com.hazelcast.map.QueryCache;
import com.hazelcast.map.impl.MapService;
import com.hazelcast.map.impl.SimpleEntryView;
import com.hazelcast.map.impl.iterator.MapPartitionIterator;
import com.hazelcast.map.impl.iterator.MapQueryPartitionIterator;
import com.hazelcast.map.impl.journal.MapEventJournalReadOperation;
import com.hazelcast.map.impl.journal.MapEventJournalSubscribeOperation;
import com.hazelcast.map.impl.operation.MapOperationProvider;
import com.hazelcast.map.impl.query.AggregationResult;
import com.hazelcast.map.impl.query.QueryResult;
import com.hazelcast.map.impl.query.QueryResultUtils;
import com.hazelcast.map.impl.query.Target;
import com.hazelcast.map.impl.querycache.QueryCacheContext;
import com.hazelcast.map.impl.querycache.subscriber.QueryCacheEndToEndProvider;
import com.hazelcast.map.impl.querycache.subscriber.QueryCacheRequest;
import com.hazelcast.map.impl.querycache.subscriber.SubscriberContext;
import com.hazelcast.map.journal.EventJournalMapEvent;
import com.hazelcast.map.listener.MapListener;
import com.hazelcast.map.listener.MapPartitionLostListener;
import com.hazelcast.mapreduce.Collator;
import com.hazelcast.mapreduce.CombinerFactory;
import com.hazelcast.mapreduce.Job;
import com.hazelcast.mapreduce.JobCompletableFuture;
import com.hazelcast.mapreduce.JobTracker;
import com.hazelcast.mapreduce.KeyValueSource;
import com.hazelcast.mapreduce.Mapper;
import com.hazelcast.mapreduce.MappingJob;
import com.hazelcast.mapreduce.ReducerFactory;
import com.hazelcast.mapreduce.ReducingSubmittableJob;
import com.hazelcast.mapreduce.aggregation.Aggregation;
import com.hazelcast.mapreduce.aggregation.Supplier;
import com.hazelcast.monitor.LocalMapStats;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.projection.Projection;
import com.hazelcast.query.Predicate;
import com.hazelcast.query.TruePredicate;
import com.hazelcast.ringbuffer.ReadResultSet;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.util.CollectionUtil;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.IterationType;
import com.hazelcast.util.MapUtil;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.SetUtil;
import com.hazelcast.util.executor.DelegatingFuture;
import com.hazelcast.util.function.Function;
import com.hazelcast.util.function.Predicate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class MapProxyImpl<K, V> extends MapProxySupport<K, V> implements EventJournalReader<EventJournalMapEvent<K, V>> {
  public MapProxyImpl(String name, MapService mapService, NodeEngine nodeEngine, MapConfig mapConfig) { super(name, mapService, nodeEngine, mapConfig); }
  
  public V get(Object key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    return (V)toObject(getInternal(key));
  }
  
  public V put(K key, V value) { return (V)put(key, value, -1L, TimeUnit.MILLISECONDS); }
  
  public V put(K key, V value, long ttl, TimeUnit timeunit) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    Data valueData = toData(value);
    Data result = putInternal(key, valueData, ttl, timeunit, -1L, TimeUnit.MILLISECONDS);
    return (V)toObject(result);
  }
  
  public V put(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
    if (isClusterVersionLessThan(Versions.V3_11))
      throw new UnsupportedOperationException("put with Max-Idle operation is available when cluster version is 3.11 or higher"); 
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    Data valueData = toData(value);
    Data result = putInternal(key, valueData, ttl, ttlUnit, maxIdle, maxIdleUnit);
    return (V)toObject(result);
  }
  
  public boolean tryPut(K key, V value, long timeout, TimeUnit timeunit) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    Data valueData = toData(value);
    return tryPutInternal(key, valueData, timeout, timeunit);
  }
  
  public V putIfAbsent(K key, V value) { return (V)putIfAbsent(key, value, -1L, TimeUnit.MILLISECONDS); }
  
  public V putIfAbsent(K key, V value, long ttl, TimeUnit timeunit) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    Data valueData = toData(value);
    Data result = putIfAbsentInternal(key, valueData, ttl, timeunit, -1L, TimeUnit.MILLISECONDS);
    return (V)toObject(result);
  }
  
  public V putIfAbsent(K key, V value, long ttl, TimeUnit timeunit, long maxIdle, TimeUnit maxIdleUnit) {
    if (isClusterVersionLessThan(Versions.V3_11))
      throw new UnsupportedOperationException("putIfAbsent with Max-Idle operation is available when cluster version is 3.11 or higher"); 
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    Data valueData = toData(value);
    Data result = putIfAbsentInternal(key, valueData, ttl, timeunit, maxIdle, maxIdleUnit);
    return (V)toObject(result);
  }
  
  public void putTransient(K key, V value, long ttl, TimeUnit timeunit) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    Data valueData = toData(value);
    putTransientInternal(key, valueData, ttl, timeunit, -1L, TimeUnit.MILLISECONDS);
  }
  
  public void putTransient(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
    if (isClusterVersionLessThan(Versions.V3_11))
      throw new UnsupportedOperationException("putTransient with Max-Idle operation is available when cluster version is 3.11 or higher"); 
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    Data valueData = toData(value);
    putTransientInternal(key, valueData, ttl, ttlUnit, maxIdle, maxIdleUnit);
  }
  
  public boolean replace(K key, V oldValue, V newValue) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkNotNull(oldValue, "Null value is not allowed!");
    Preconditions.checkNotNull(newValue, "Null value is not allowed!");
    Data oldValueData = toData(oldValue);
    Data newValueData = toData(newValue);
    return replaceInternal(key, oldValueData, newValueData);
  }
  
  public V replace(K key, V value) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    Data valueData = toData(value);
    return (V)toObject(replaceInternal(key, valueData));
  }
  
  public void set(K key, V value) { set(key, value, -1L, TimeUnit.MILLISECONDS); }
  
  public void set(K key, V value, long ttl, TimeUnit ttlUnit) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    Data valueData = toData(value);
    setInternal(key, valueData, ttl, ttlUnit, -1L, TimeUnit.MILLISECONDS);
  }
  
  public void set(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
    if (isClusterVersionLessThan(Versions.V3_11))
      throw new UnsupportedOperationException("set with Max-Idle operation is available when cluster version is 3.11 or higher"); 
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    Data valueData = toData(value);
    setInternal(key, valueData, ttl, ttlUnit, maxIdle, maxIdleUnit);
  }
  
  public V remove(Object key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Data result = removeInternal(key);
    return (V)toObject(result);
  }
  
  public boolean remove(Object key, Object value) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    Data valueData = toData(value);
    return removeInternal(key, valueData);
  }
  
  public void removeAll(Predicate<K, V> predicate) {
    Preconditions.checkNotNull(predicate, "predicate cannot be null");
    handleHazelcastInstanceAwareParams(new Object[] { predicate });
    removeAllInternal(predicate);
  }
  
  public void delete(Object key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    deleteInternal(key);
  }
  
  public boolean containsKey(Object key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    return containsKeyInternal(key);
  }
  
  public boolean containsValue(Object value) {
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    Data valueData = toData(value);
    return containsValueInternal(valueData);
  }
  
  public void lock(K key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Data keyData = toDataWithStrategy(key);
    this.lockSupport.lock(getNodeEngine(), keyData);
  }
  
  public void lock(Object key, long leaseTime, TimeUnit timeUnit) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkPositive(leaseTime, "leaseTime should be positive");
    Data keyData = toDataWithStrategy(key);
    this.lockSupport.lock(getNodeEngine(), keyData, timeUnit.toMillis(leaseTime));
  }
  
  public void unlock(K key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Data keyData = toDataWithStrategy(key);
    this.lockSupport.unlock(getNodeEngine(), keyData);
  }
  
  public boolean tryRemove(K key, long timeout, TimeUnit timeunit) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    return tryRemoveInternal(key, timeout, timeunit);
  }
  
  public ICompletableFuture<V> getAsync(K key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    return new DelegatingFuture(getAsyncInternal(key), this.serializationService);
  }
  
  public boolean isLocked(K key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Data keyData = toDataWithStrategy(key);
    return this.lockSupport.isLocked(getNodeEngine(), keyData);
  }
  
  public ICompletableFuture<V> putAsync(K key, V value) { return putAsync(key, value, -1L, TimeUnit.MILLISECONDS); }
  
  public ICompletableFuture<V> putAsync(K key, V value, long ttl, TimeUnit timeunit) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    Data valueData = toData(value);
    return new DelegatingFuture(
        putAsyncInternal(key, valueData, ttl, timeunit, -1L, TimeUnit.MILLISECONDS), this.serializationService);
  }
  
  public ICompletableFuture<V> putAsync(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
    if (isClusterVersionLessThan(Versions.V3_11))
      throw new UnsupportedOperationException("putAsync with Max-Idle operation is available when cluster version is 3.11 or higher"); 
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    Data valueData = toData(value);
    return new DelegatingFuture(
        putAsyncInternal(key, valueData, ttl, ttlUnit, maxIdle, maxIdleUnit), this.serializationService);
  }
  
  public ICompletableFuture<Void> setAsync(K key, V value) { return setAsync(key, value, -1L, TimeUnit.MILLISECONDS); }
  
  public ICompletableFuture<Void> setAsync(K key, V value, long ttl, TimeUnit timeunit) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    Data valueData = toData(value);
    return new DelegatingFuture(
        setAsyncInternal(key, valueData, ttl, timeunit, -1L, TimeUnit.MILLISECONDS), this.serializationService);
  }
  
  public ICompletableFuture<Void> setAsync(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdle, TimeUnit maxIdleUnit) {
    if (isClusterVersionLessThan(Versions.V3_11))
      throw new UnsupportedOperationException("setAsync with Max-Idle operation is available when cluster version is 3.11 or higher"); 
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    Data valueData = toData(value);
    return new DelegatingFuture(
        setAsyncInternal(key, valueData, ttl, ttlUnit, maxIdle, maxIdleUnit), this.serializationService);
  }
  
  public ICompletableFuture<V> removeAsync(K key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    return new DelegatingFuture(removeAsyncInternal(key), this.serializationService);
  }
  
  public Map<K, V> getAll(Set<K> keys) {
    if (CollectionUtil.isEmpty(keys))
      return Collections.emptyMap(); 
    int keysSize = keys.size();
    List<Data> dataKeys = new LinkedList<Data>();
    List<Object> resultingKeyValuePairs = new ArrayList<Object>(keysSize * 2);
    getAllInternal(keys, dataKeys, resultingKeyValuePairs);
    Map<K, V> result = MapUtil.createHashMap(keysSize);
    for (int i = 0; i < resultingKeyValuePairs.size(); ) {
      K key = (K)toObject(resultingKeyValuePairs.get(i++));
      V value = (V)toObject(resultingKeyValuePairs.get(i++));
      result.put(key, value);
    } 
    return result;
  }
  
  public boolean setTtl(K key, long ttl, TimeUnit timeunit) {
    Preconditions.checkNotNull(key);
    Preconditions.checkNotNull(timeunit);
    return setTtlInternal(key, ttl, timeunit);
  }
  
  public void putAll(Map<? extends K, ? extends V> map) {
    Preconditions.checkNotNull(map, "Null argument map is not allowed");
    putAllInternal(map);
  }
  
  public boolean tryLock(K key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Data keyData = toDataWithStrategy(key);
    return this.lockSupport.tryLock(getNodeEngine(), keyData);
  }
  
  public boolean tryLock(K key, long time, TimeUnit timeunit) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Data keyData = toDataWithStrategy(key);
    return this.lockSupport.tryLock(getNodeEngine(), keyData, time, timeunit);
  }
  
  public boolean tryLock(K key, long time, TimeUnit timeunit, long leaseTime, TimeUnit leaseTimeUnit) throws InterruptedException {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Data keyData = toDataWithStrategy(key);
    return this.lockSupport.tryLock(getNodeEngine(), keyData, time, timeunit, leaseTime, leaseTimeUnit);
  }
  
  public void forceUnlock(K key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Data keyData = toDataWithStrategy(key);
    this.lockSupport.forceUnlock(getNodeEngine(), keyData);
  }
  
  public String addInterceptor(MapInterceptor interceptor) {
    Preconditions.checkNotNull(interceptor, "Interceptor should not be null!");
    handleHazelcastInstanceAwareParams(new Object[] { interceptor });
    return addMapInterceptorInternal(interceptor);
  }
  
  public void removeInterceptor(String id) {
    Preconditions.checkNotNull(id, "Interceptor ID should not be null!");
    removeMapInterceptorInternal(id);
  }
  
  public String addLocalEntryListener(MapListener listener) {
    Preconditions.checkNotNull(listener, "Null listener is not allowed!");
    handleHazelcastInstanceAwareParams(new Object[] { listener });
    return addLocalEntryListenerInternal(listener);
  }
  
  public String addLocalEntryListener(EntryListener listener) {
    Preconditions.checkNotNull(listener, "Null listener is not allowed!");
    handleHazelcastInstanceAwareParams(new Object[] { listener });
    return addLocalEntryListenerInternal(listener);
  }
  
  public String addLocalEntryListener(MapListener listener, Predicate<K, V> predicate, boolean includeValue) {
    Preconditions.checkNotNull(listener, "Null listener is not allowed!");
    Preconditions.checkNotNull(predicate, "Predicate should not be null!");
    handleHazelcastInstanceAwareParams(new Object[] { listener, predicate });
    return addLocalEntryListenerInternal(listener, predicate, null, includeValue);
  }
  
  public String addLocalEntryListener(EntryListener listener, Predicate<K, V> predicate, boolean includeValue) {
    Preconditions.checkNotNull(listener, "Null listener is not allowed!");
    Preconditions.checkNotNull(predicate, "Predicate should not be null!");
    handleHazelcastInstanceAwareParams(new Object[] { listener, predicate });
    return addLocalEntryListenerInternal(listener, predicate, null, includeValue);
  }
  
  public String addLocalEntryListener(MapListener listener, Predicate<K, V> predicate, K key, boolean includeValue) {
    Preconditions.checkNotNull(listener, "Null listener is not allowed!");
    Preconditions.checkNotNull(predicate, "Predicate should not be null!");
    handleHazelcastInstanceAwareParams(new Object[] { listener, predicate });
    return addLocalEntryListenerInternal(listener, predicate, toDataWithStrategy(key), includeValue);
  }
  
  public String addLocalEntryListener(EntryListener listener, Predicate<K, V> predicate, K key, boolean includeValue) {
    Preconditions.checkNotNull(listener, "Null listener is not allowed!");
    Preconditions.checkNotNull(predicate, "Predicate should not be null!");
    handleHazelcastInstanceAwareParams(new Object[] { listener, predicate });
    return addLocalEntryListenerInternal(listener, predicate, toDataWithStrategy(key), includeValue);
  }
  
  public String addEntryListener(MapListener listener, boolean includeValue) {
    Preconditions.checkNotNull(listener, "Null listener is not allowed!");
    handleHazelcastInstanceAwareParams(new Object[] { listener });
    return addEntryListenerInternal(listener, null, includeValue);
  }
  
  public String addEntryListener(EntryListener listener, boolean includeValue) {
    Preconditions.checkNotNull(listener, "Null listener is not allowed!");
    handleHazelcastInstanceAwareParams(new Object[] { listener });
    return addEntryListenerInternal(listener, null, includeValue);
  }
  
  public String addEntryListener(MapListener listener, K key, boolean includeValue) {
    Preconditions.checkNotNull(listener, "Null listener is not allowed!");
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    handleHazelcastInstanceAwareParams(new Object[] { listener });
    return addEntryListenerInternal(listener, toDataWithStrategy(key), includeValue);
  }
  
  public String addEntryListener(EntryListener listener, K key, boolean includeValue) {
    Preconditions.checkNotNull(listener, "Null listener is not allowed!");
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    handleHazelcastInstanceAwareParams(new Object[] { listener });
    return addEntryListenerInternal(listener, toDataWithStrategy(key), includeValue);
  }
  
  public String addEntryListener(MapListener listener, Predicate<K, V> predicate, K key, boolean includeValue) {
    Preconditions.checkNotNull(listener, "Null listener is not allowed!");
    Preconditions.checkNotNull(predicate, "Predicate should not be null!");
    handleHazelcastInstanceAwareParams(new Object[] { listener, predicate });
    return addEntryListenerInternal(listener, predicate, toDataWithStrategy(key), includeValue);
  }
  
  public String addEntryListener(EntryListener listener, Predicate<K, V> predicate, K key, boolean includeValue) {
    Preconditions.checkNotNull(listener, "Null listener is not allowed!");
    Preconditions.checkNotNull(predicate, "Predicate should not be null!");
    handleHazelcastInstanceAwareParams(new Object[] { listener, predicate });
    return addEntryListenerInternal(listener, predicate, toDataWithStrategy(key), includeValue);
  }
  
  public String addEntryListener(MapListener listener, Predicate<K, V> predicate, boolean includeValue) {
    Preconditions.checkNotNull(listener, "Null listener is not allowed!");
    Preconditions.checkNotNull(predicate, "Predicate should not be null!");
    handleHazelcastInstanceAwareParams(new Object[] { listener, predicate });
    return addEntryListenerInternal(listener, predicate, null, includeValue);
  }
  
  public String addEntryListener(EntryListener listener, Predicate<K, V> predicate, boolean includeValue) {
    Preconditions.checkNotNull(listener, "Null listener is not allowed!");
    Preconditions.checkNotNull(predicate, "Predicate should not be null!");
    handleHazelcastInstanceAwareParams(new Object[] { listener, predicate });
    return addEntryListenerInternal(listener, predicate, null, includeValue);
  }
  
  public boolean removeEntryListener(String id) {
    Preconditions.checkNotNull(id, "Listener ID should not be null!");
    return removeEntryListenerInternal(id);
  }
  
  public String addPartitionLostListener(MapPartitionLostListener listener) {
    Preconditions.checkNotNull(listener, "Null listener is not allowed!");
    handleHazelcastInstanceAwareParams(new Object[] { listener });
    return addPartitionLostListenerInternal(listener);
  }
  
  public boolean removePartitionLostListener(String id) {
    Preconditions.checkNotNull(id, "Listener ID should not be null!");
    return removePartitionLostListenerInternal(id);
  }
  
  public EntryView<K, V> getEntryView(K key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    SimpleEntryView<K, V> entryViewInternal = (SimpleEntryView)getEntryViewInternal(toDataWithStrategy(key));
    if (entryViewInternal == null)
      return null; 
    Data value = (Data)entryViewInternal.getValue();
    entryViewInternal.setKey(key);
    entryViewInternal.setValue(toObject(value));
    return entryViewInternal;
  }
  
  public boolean evict(Object key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    return evictInternal(key);
  }
  
  public void evictAll() { evictAllInternal(); }
  
  public void loadAll(boolean replaceExistingValues) {
    Preconditions.checkTrue(isMapStoreEnabled(), "First you should configure a map store");
    loadAllInternal(replaceExistingValues);
  }
  
  public void loadAll(Set<K> keys, boolean replaceExistingValues) {
    Preconditions.checkTrue(isMapStoreEnabled(), "First you should configure a map store");
    Preconditions.checkNotNull(keys, "Null keys collection is not allowed!");
    Preconditions.checkNoNullInside(keys, "Null key is not allowed!");
    loadInternal(keys, null, replaceExistingValues);
  }
  
  public void clear() { clearInternal(); }
  
  public Set<K> keySet() { return keySet(TruePredicate.INSTANCE); }
  
  public Set<K> keySet(Predicate predicate) { return executePredicate(predicate, IterationType.KEY, true); }
  
  public Set<Map.Entry<K, V>> entrySet() { return entrySet(TruePredicate.INSTANCE); }
  
  public Set<Map.Entry<K, V>> entrySet(Predicate predicate) { return executePredicate(predicate, IterationType.ENTRY, true); }
  
  public Collection<V> values() { return values(TruePredicate.INSTANCE); }
  
  public Collection<V> values(Predicate predicate) { return executePredicate(predicate, IterationType.VALUE, false); }
  
  private Set executePredicate(Predicate predicate, IterationType iterationType, boolean uniqueResult) {
    Preconditions.checkNotNull(predicate, "Predicate should not be null!");
    QueryResult result = (QueryResult)executeQueryInternal(predicate, iterationType, Target.ALL_NODES);
    incrementOtherOperationsStat();
    return QueryResultUtils.transformToSet(this.serializationService, result, predicate, iterationType, uniqueResult, false);
  }
  
  public Set<K> localKeySet() { return localKeySet(TruePredicate.INSTANCE); }
  
  public Set<K> localKeySet(Predicate predicate) {
    Preconditions.checkNotNull(predicate, "Predicate should not be null!");
    QueryResult result = (QueryResult)executeQueryInternal(predicate, IterationType.KEY, Target.LOCAL_NODE);
    incrementOtherOperationsStat();
    return QueryResultUtils.transformToSet(this.serializationService, result, predicate, IterationType.KEY, false, false);
  }
  
  public Object executeOnKey(K key, EntryProcessor entryProcessor) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    handleHazelcastInstanceAwareParams(new Object[] { entryProcessor });
    Data result = executeOnKeyInternal(key, entryProcessor);
    return toObject(result);
  }
  
  public Map<K, Object> executeOnKeys(Set<K> keys, EntryProcessor entryProcessor) {
    try {
      return (Map)submitToKeys(keys, entryProcessor).get();
    } catch (Exception e) {
      throw ExceptionUtil.rethrow(e);
    } 
  }
  
  public ICompletableFuture<Map<K, Object>> submitToKeys(Set<K> keys, EntryProcessor entryProcessor) {
    Preconditions.checkNotNull(keys, "Null keys collection is not allowed!");
    if (keys.isEmpty())
      return new SimpleCompletedFuture(Collections.emptyMap()); 
    handleHazelcastInstanceAwareParams(new Object[] { entryProcessor });
    Set<Data> dataKeys = SetUtil.createHashSet(keys.size());
    return submitToKeysInternal(keys, dataKeys, entryProcessor);
  }
  
  public void submitToKey(K key, EntryProcessor entryProcessor, ExecutionCallback callback) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    handleHazelcastInstanceAwareParams(new Object[] { entryProcessor, callback });
    executeOnKeyInternal(key, entryProcessor, callback);
  }
  
  public ICompletableFuture submitToKey(K key, EntryProcessor entryProcessor) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    handleHazelcastInstanceAwareParams(new Object[] { entryProcessor });
    InternalCompletableFuture future = executeOnKeyInternal(key, entryProcessor, null);
    return new DelegatingFuture(future, this.serializationService);
  }
  
  public Map<K, Object> executeOnEntries(EntryProcessor entryProcessor) { return executeOnEntries(entryProcessor, TruePredicate.INSTANCE); }
  
  public Map<K, Object> executeOnEntries(EntryProcessor entryProcessor, Predicate predicate) {
    handleHazelcastInstanceAwareParams(new Object[] { entryProcessor, predicate });
    List<Data> result = new ArrayList<Data>();
    executeOnEntriesInternal(entryProcessor, predicate, result);
    if (result.isEmpty())
      return Collections.emptyMap(); 
    Map<K, Object> resultingMap = MapUtil.createHashMap(result.size() / 2);
    for (int i = 0; i < result.size(); ) {
      Data key = (Data)result.get(i++);
      Data value = (Data)result.get(i++);
      resultingMap.put(toObject(key), toObject(value));
    } 
    return resultingMap;
  }
  
  public <R> R aggregate(Aggregator<Map.Entry<K, V>, R> aggregator) { return (R)aggregate(aggregator, TruePredicate.truePredicate()); }
  
  public <R> R aggregate(Aggregator<Map.Entry<K, V>, R> aggregator, Predicate<K, V> predicate) {
    Preconditions.checkNotNull(aggregator, "Aggregator should not be null!");
    Preconditions.checkNotNull(predicate, "Predicate should not be null!");
    checkNotPagingPredicate(predicate, "aggregate");
    aggregator = (Aggregator)this.serializationService.toObject(this.serializationService.toData(aggregator));
    AggregationResult result = (AggregationResult)executeQueryInternal(predicate, aggregator, null, IterationType.ENTRY, Target.ALL_NODES);
    return (R)result.getAggregator().aggregate();
  }
  
  public <R> Collection<R> project(Projection<Map.Entry<K, V>, R> projection) { return project(projection, TruePredicate.INSTANCE); }
  
  public <R> Collection<R> project(Projection<Map.Entry<K, V>, R> projection, Predicate<K, V> predicate) {
    Preconditions.checkNotNull(projection, "Projection should not be null!");
    Preconditions.checkNotNull(predicate, "Predicate should not be null!");
    checkNotPagingPredicate(predicate, "project");
    projection = (Projection)this.serializationService.toObject(this.serializationService.toData(projection));
    QueryResult result = (QueryResult)executeQueryInternal(predicate, null, projection, IterationType.VALUE, Target.ALL_NODES);
    return QueryResultUtils.transformToSet(this.serializationService, result, predicate, IterationType.VALUE, false, false);
  }
  
  public <SuppliedValue, Result> Result aggregate(Supplier<K, V, SuppliedValue> supplier, Aggregation<K, SuppliedValue, Result> aggregation) {
    Preconditions.checkTrue((InMemoryFormat.NATIVE != this.mapConfig.getInMemoryFormat()), "NATIVE storage format is not supported for MapReduce");
    HazelcastInstance hazelcastInstance = getNodeEngine().getHazelcastInstance();
    JobTracker jobTracker = hazelcastInstance.getJobTracker("hz::aggregation-map-" + getName());
    return (Result)aggregate(supplier, aggregation, jobTracker);
  }
  
  public <SuppliedValue, Result> Result aggregate(Supplier<K, V, SuppliedValue> supplier, Aggregation<K, SuppliedValue, Result> aggregation, JobTracker jobTracker) {
    Preconditions.checkTrue((InMemoryFormat.NATIVE != this.mapConfig.getInMemoryFormat()), "NATIVE storage format is not supported for MapReduce");
    try {
      ReducingSubmittableJob reducingJob;
      Preconditions.isNotNull(jobTracker, "jobTracker");
      KeyValueSource<K, V> keyValueSource = KeyValueSource.fromMap(this);
      Job<K, V> job = jobTracker.newJob(keyValueSource);
      Mapper mapper = aggregation.getMapper(supplier);
      CombinerFactory combinerFactory = aggregation.getCombinerFactory();
      ReducerFactory reducerFactory = aggregation.getReducerFactory();
      Collator collator = aggregation.getCollator();
      MappingJob mappingJob = job.mapper(mapper);
      if (combinerFactory == null) {
        reducingJob = mappingJob.reducer(reducerFactory);
      } else {
        reducingJob = mappingJob.combiner(combinerFactory).reducer(reducerFactory);
      } 
      JobCompletableFuture jobCompletableFuture = reducingJob.submit(collator);
      return (Result)jobCompletableFuture.get();
    } catch (Exception e) {
      throw new HazelcastException(e);
    } 
  }
  
  protected Object invoke(Operation operation, int partitionId) throws Throwable {
    InternalCompletableFuture internalCompletableFuture = this.operationService.invokeOnPartition("hz:impl:mapService", operation, partitionId);
    Object response = internalCompletableFuture.get();
    Object result = toObject(response);
    if (result instanceof Throwable)
      throw (Throwable)result; 
    return result;
  }
  
  public Iterator<Map.Entry<K, V>> iterator(int fetchSize, int partitionId, boolean prefetchValues) { return new MapPartitionIterator(this, fetchSize, partitionId, prefetchValues); }
  
  public <R> Iterator<R> iterator(int fetchSize, int partitionId, Projection<Map.Entry<K, V>, R> projection, Predicate<K, V> predicate) {
    if (predicate instanceof com.hazelcast.query.PagingPredicate)
      throw new IllegalArgumentException("Paging predicate is not allowed when iterating map by query"); 
    Preconditions.checkNotNull(projection, "Projection should not be null!");
    Preconditions.checkNotNull(predicate, "Predicate should not be null!");
    projection = (Projection)this.serializationService.toObject(this.serializationService.toData(projection));
    handleHazelcastInstanceAwareParams(new Object[] { predicate });
    return new MapQueryPartitionIterator(this, fetchSize, partitionId, predicate, projection);
  }
  
  public ICompletableFuture<EventJournalInitialSubscriberState> subscribeToEventJournal(int partitionId) {
    MapEventJournalSubscribeOperation op = new MapEventJournalSubscribeOperation(this.name);
    op.setPartitionId(partitionId);
    return this.operationService.invokeOnPartition(op);
  }
  
  public <T> ICompletableFuture<ReadResultSet<T>> readFromEventJournal(long startSequence, int minSize, int maxSize, int partitionId, Predicate<? super EventJournalMapEvent<K, V>> predicate, Function<? super EventJournalMapEvent<K, V>, ? extends T> projection) {
    if (maxSize < minSize)
      throw new IllegalArgumentException("maxSize " + maxSize + " must be greater or equal to minSize " + minSize); 
    ManagedContext context = this.serializationService.getManagedContext();
    context.initialize(predicate);
    context.initialize(projection);
    MapEventJournalReadOperation<K, V, T> op = new MapEventJournalReadOperation<K, V, T>(this.name, startSequence, minSize, maxSize, predicate, projection);
    op.setPartitionId(partitionId);
    return this.operationService.invokeOnPartition(op);
  }
  
  public String toString() { return "IMap{name='" + this.name + '\'' + '}'; }
  
  public QueryCache<K, V> getQueryCache(String name) {
    Preconditions.checkNotNull(name, "name cannot be null");
    return getQueryCacheInternal(name, null, null, null, this);
  }
  
  public QueryCache<K, V> getQueryCache(String name, Predicate<K, V> predicate, boolean includeValue) {
    Preconditions.checkNotNull(name, "name cannot be null");
    Preconditions.checkNotNull(predicate, "predicate cannot be null");
    Preconditions.checkNotInstanceOf(com.hazelcast.query.PagingPredicate.class, predicate, "predicate");
    handleHazelcastInstanceAwareParams(new Object[] { predicate });
    return getQueryCacheInternal(name, null, predicate, Boolean.valueOf(includeValue), this);
  }
  
  public QueryCache<K, V> getQueryCache(String name, MapListener listener, Predicate<K, V> predicate, boolean includeValue) {
    Preconditions.checkNotNull(name, "name cannot be null");
    Preconditions.checkNotNull(predicate, "predicate cannot be null");
    Preconditions.checkNotInstanceOf(com.hazelcast.query.PagingPredicate.class, predicate, "predicate");
    handleHazelcastInstanceAwareParams(new Object[] { listener, predicate });
    return getQueryCacheInternal(name, listener, predicate, Boolean.valueOf(includeValue), this);
  }
  
  private QueryCache<K, V> getQueryCacheInternal(String name, MapListener listener, Predicate<K, V> predicate, Boolean includeValue, IMap<K, V> map) {
    QueryCacheContext queryCacheContext = this.mapServiceContext.getQueryCacheContext();
    QueryCacheRequest request = QueryCacheRequest.newQueryCacheRequest().forMap(map).withCacheName(name).withListener(listener).withPredicate(predicate).withIncludeValue(includeValue).withContext(queryCacheContext);
    return createQueryCache(request);
  }
  
  private QueryCache<K, V> createQueryCache(QueryCacheRequest request) {
    QueryCacheContext queryCacheContext = request.getContext();
    SubscriberContext subscriberContext = queryCacheContext.getSubscriberContext();
    QueryCacheEndToEndProvider queryCacheEndToEndProvider = subscriberContext.getEndToEndQueryCacheProvider();
    return queryCacheEndToEndProvider.getOrCreateQueryCache(request.getMapName(), request.getCacheName(), subscriberContext
        .newEndToEndConstructor(request));
  }
  
  private static void checkNotPagingPredicate(Predicate predicate, String method) {
    if (predicate instanceof com.hazelcast.query.PagingPredicate)
      throw new IllegalArgumentException("PagingPredicate not supported in " + method + " method"); 
  }
}
