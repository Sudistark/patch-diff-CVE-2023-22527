package com.hazelcast.map.impl.record;

import com.hazelcast.nio.serialization.Data;
import com.hazelcast.util.JVMUtil;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

class CachedDataRecordWithStats extends DataRecordWithStats {
  private static final AtomicReferenceFieldUpdater<CachedDataRecordWithStats, Object> CACHED_VALUE = AtomicReferenceFieldUpdater.newUpdater(CachedDataRecordWithStats.class, Object.class, "cachedValue");
  
  private static final int CACHED_VALUE_REF_COST_IN_BYTES = JVMUtil.REFERENCE_COST_IN_BYTES;
  
  CachedDataRecordWithStats() {}
  
  CachedDataRecordWithStats(Data value) { super(value); }
  
  public void setValue(Data o) {
    super.setValue(o);
    this.cachedValue = null;
  }
  
  public Object getCachedValueUnsafe() { return this.cachedValue; }
  
  public boolean casCachedValue(Object expectedValue, Object newValue) { return CACHED_VALUE.compareAndSet(this, expectedValue, newValue); }
  
  public long getCost() { return super.getCost() + CACHED_VALUE_REF_COST_IN_BYTES; }
  
  public boolean equals(Object o) {
    if (this == o)
      return true; 
    if (o == null || getClass() != o.getClass())
      return false; 
    if (!super.equals(o))
      return false; 
    CachedDataRecordWithStats that = (CachedDataRecordWithStats)o;
    return (this.cachedValue != null) ? this.cachedValue.equals(that.cachedValue) : ((that.cachedValue == null) ? 1 : 0);
  }
  
  public int hashCode() {
    result = super.hashCode();
    return 31 * result + ((this.cachedValue != null) ? this.cachedValue.hashCode() : 0);
  }
}
