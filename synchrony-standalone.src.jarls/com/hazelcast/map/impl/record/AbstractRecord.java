package com.hazelcast.map.impl.record;

import com.hazelcast.nio.serialization.Data;
import com.hazelcast.query.Metadata;
import com.hazelcast.util.JVMUtil;
import com.hazelcast.util.TimeUtil;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.concurrent.TimeUnit;

public abstract class AbstractRecord<V> extends Object implements Record<V> {
  public static final long EPOCH_TIME = TimeUtil.zeroOutMs(1514764800000L);
  
  private static final int NUMBER_OF_LONGS = 2;
  
  private static final int NUMBER_OF_INTS = 5;
  
  protected Data key;
  
  protected long version;
  
  protected int ttl;
  
  protected int maxIdle;
  
  private int creationTime = -1;
  
  private Metadata metadata;
  
  public void setMetadata(Metadata metadata) { this.metadata = metadata; }
  
  public Metadata getMetadata() { return this.metadata; }
  
  public final long getVersion() { return this.version; }
  
  public final void setVersion(long version) { this.version = version; }
  
  public long getTtl() { return (this.ttl == Integer.MAX_VALUE) ? Float.MAX_VALUE : TimeUnit.SECONDS.toMillis(this.ttl); }
  
  public void setTtl(long ttl) {
    long ttlSeconds = TimeUnit.MILLISECONDS.toSeconds(ttl);
    if (ttlSeconds == 0L && ttl != 0L)
      ttlSeconds = 1L; 
    this.ttl = (ttlSeconds > 2147483647L) ? Integer.MAX_VALUE : (int)ttlSeconds;
  }
  
  public long getMaxIdle() { return (this.maxIdle == Integer.MAX_VALUE) ? Float.MAX_VALUE : TimeUnit.SECONDS.toMillis(this.maxIdle); }
  
  public void setMaxIdle(long maxIdle) {
    long maxIdleSeconds = TimeUnit.MILLISECONDS.toSeconds(maxIdle);
    if (maxIdleSeconds == 0L && maxIdle != 0L)
      maxIdleSeconds = 1L; 
    this.maxIdle = (maxIdleSeconds > 2147483647L) ? Integer.MAX_VALUE : (int)maxIdleSeconds;
  }
  
  public long getLastAccessTime() { return recomputeWithBaseTime(this.lastAccessTime); }
  
  public void setLastAccessTime(long lastAccessTime) { this.lastAccessTime = stripBaseTime(lastAccessTime); }
  
  public long getLastUpdateTime() { return recomputeWithBaseTime(this.lastUpdateTime); }
  
  public void setLastUpdateTime(long lastUpdateTime) { this.lastUpdateTime = stripBaseTime(lastUpdateTime); }
  
  public long getCreationTime() { return recomputeWithBaseTime(this.creationTime); }
  
  public void setCreationTime(long creationTime) { this.creationTime = stripBaseTime(creationTime); }
  
  public long getHits() { return this.hits; }
  
  public void setHits(long hits) { this.hits = hits; }
  
  public long getCost() { return (JVMUtil.REFERENCE_COST_IN_BYTES + 16 + 20); }
  
  public void onUpdate(long now) {
    this.version++;
    this.lastUpdateTime = stripBaseTime(now);
  }
  
  public Object getCachedValueUnsafe() { return Record.NOT_CACHED; }
  
  public void onAccess(long now) {
    this.hits++;
    this.lastAccessTime = stripBaseTime(now);
  }
  
  public void onStore() {}
  
  public boolean casCachedValue(Object expectedValue, Object newValue) { return true; }
  
  public Data getKey() { return this.key; }
  
  public void setKey(Data key) { this.key = key; }
  
  public final long getSequence() { return -1L; }
  
  public final void setSequence(long sequence) {}
  
  public long getExpirationTime() { return -1L; }
  
  public void setExpirationTime(long expirationTime) {}
  
  public long getLastStoredTime() { return -1L; }
  
  public void setLastStoredTime(long lastStoredTime) {}
  
  public boolean equals(Object o) {
    if (this == o)
      return true; 
    if (o == null || getClass() != o.getClass())
      return false; 
    AbstractRecord<?> that = (AbstractRecord)o;
    if (this.version != that.version)
      return false; 
    if (this.ttl != that.ttl)
      return false; 
    if (this.maxIdle != that.maxIdle)
      return false; 
    if (this.creationTime != that.creationTime)
      return false; 
    if (this.hits != that.hits)
      return false; 
    if (this.lastAccessTime != that.lastAccessTime)
      return false; 
    if (this.lastUpdateTime != that.lastUpdateTime)
      return false; 
    return this.key.equals(that.key);
  }
  
  public int hashCode() {
    result = (this.key != null) ? this.key.hashCode() : 0;
    result = 31 * result + (int)(this.version ^ this.version >>> 32);
    result = 31 * result + this.ttl;
    result = 31 * result + this.maxIdle;
    result = 31 * result + this.creationTime;
    result = 31 * result + (int)(this.hits ^ this.hits >>> 32);
    result = 31 * result + this.lastAccessTime;
    return 31 * result + this.lastUpdateTime;
  }
  
  protected long recomputeWithBaseTime(int value) {
    if (value == -1)
      return 0L; 
    long exploded = TimeUnit.SECONDS.toMillis(value);
    return exploded + EPOCH_TIME;
  }
  
  protected int stripBaseTime(long value) {
    int diff = -1;
    if (value > 0L)
      diff = (int)TimeUnit.MILLISECONDS.toSeconds(value - EPOCH_TIME); 
    return diff;
  }
}
