package com.hazelcast.map.impl.querycache.subscriber.operation;

import com.hazelcast.map.impl.MapDataSerializerHook;
import com.hazelcast.map.impl.operation.MapOperation;
import com.hazelcast.map.impl.query.Query;
import com.hazelcast.map.impl.query.QueryEngine;
import com.hazelcast.map.impl.query.QueryResult;
import com.hazelcast.map.impl.query.QueryResultRow;
import com.hazelcast.map.impl.query.Target;
import com.hazelcast.map.impl.querycache.QueryCacheContext;
import com.hazelcast.map.impl.querycache.accumulator.AccumulatorInfo;
import com.hazelcast.map.impl.querycache.accumulator.AccumulatorInfoSupplier;
import com.hazelcast.map.impl.querycache.event.QueryCacheEventData;
import com.hazelcast.map.impl.querycache.publisher.MapListenerRegistry;
import com.hazelcast.map.impl.querycache.publisher.MapPublisherRegistry;
import com.hazelcast.map.impl.querycache.publisher.PartitionAccumulatorRegistry;
import com.hazelcast.map.impl.querycache.publisher.PublisherContext;
import com.hazelcast.map.impl.querycache.publisher.PublisherRegistry;
import com.hazelcast.map.impl.querycache.publisher.QueryCacheListenerRegistry;
import com.hazelcast.map.impl.querycache.utils.QueryCacheUtil;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.OperationService;
import com.hazelcast.util.FutureUtil;
import com.hazelcast.util.IterationType;
import com.hazelcast.util.collection.Int2ObjectHashMap;
import java.io.IOException;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class PublisherCreateOperation extends MapOperation {
  private static final long ACCUMULATOR_READ_OPERATION_TIMEOUT_MINUTES = 5L;
  
  private AccumulatorInfo info;
  
  private QueryResult queryResult;
  
  public PublisherCreateOperation() {}
  
  public PublisherCreateOperation(AccumulatorInfo info) {
    super(info.getMapName());
    this.info = info;
  }
  
  public void run() {
    boolean populate = this.info.isPopulate();
    if (populate)
      this.info.setPublishable(false); 
    init();
    if (populate) {
      this.queryResult = createSnapshot();
    } else {
      this.queryResult = null;
    } 
  }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException {
    super.writeInternal(out);
    out.writeObject(this.info);
  }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    super.readInternal(in);
    this.info = (AccumulatorInfo)in.readObject();
  }
  
  public Object getResponse() { return this.queryResult; }
  
  private void init() {
    registerAccumulatorInfo();
    registerPublisherAccumulator();
    registerLocalIMapListener();
  }
  
  private void registerLocalIMapListener() {
    String mapName = this.info.getMapName();
    String cacheId = this.info.getCacheId();
    PublisherContext publisherContext = getPublisherContext();
    MapListenerRegistry registry = publisherContext.getMapListenerRegistry();
    QueryCacheListenerRegistry listenerRegistry = registry.getOrCreate(mapName);
    listenerRegistry.getOrCreate(cacheId);
  }
  
  private void registerAccumulatorInfo() {
    String mapName = this.info.getMapName();
    String cacheId = this.info.getCacheId();
    PublisherContext publisherContext = getPublisherContext();
    AccumulatorInfoSupplier infoSupplier = publisherContext.getAccumulatorInfoSupplier();
    infoSupplier.putIfAbsent(mapName, cacheId, this.info);
  }
  
  private void registerPublisherAccumulator() {
    String mapName = this.info.getMapName();
    String cacheId = this.info.getCacheId();
    PublisherContext publisherContext = getPublisherContext();
    MapPublisherRegistry mapPublisherRegistry = publisherContext.getMapPublisherRegistry();
    PublisherRegistry publisherRegistry = mapPublisherRegistry.getOrCreate(mapName);
    publisherRegistry.remove(cacheId);
    PartitionAccumulatorRegistry partitionAccumulatorRegistry = publisherRegistry.getOrCreate(cacheId);
    partitionAccumulatorRegistry.setUuid(getCallerUuid());
  }
  
  private PublisherContext getPublisherContext() {
    QueryCacheContext queryCacheContext = getContext();
    return queryCacheContext.getPublisherContext();
  }
  
  private QueryCacheContext getContext() { return this.mapServiceContext.getQueryCacheContext(); }
  
  private QueryResult createSnapshot() throws Exception {
    QueryResult queryResult = runInitialQuery();
    replayEventsOverResultSet(queryResult);
    return queryResult;
  }
  
  private QueryResult runInitialQuery() throws Exception {
    QueryEngine queryEngine = this.mapServiceContext.getQueryEngine(this.name);
    IterationType iterationType = this.info.isIncludeValue() ? IterationType.ENTRY : IterationType.KEY;
    Query query = Query.of().mapName(this.name).predicate(this.info.getPredicate()).iterationType(iterationType).build();
    return (QueryResult)queryEngine.execute(query, Target.LOCAL_NODE);
  }
  
  private void replayEventsOverResultSet(QueryResult queryResult) throws Exception {
    Map<Integer, Future<Object>> future = readAccumulators();
    for (Map.Entry<Integer, Future<Object>> entry : future.entrySet()) {
      int partitionId = ((Integer)entry.getKey()).intValue();
      Object eventsInOneAcc = ((Future)entry.getValue()).get();
      if (eventsInOneAcc == null)
        continue; 
      eventsInOneAcc = this.mapServiceContext.toObject(eventsInOneAcc);
      List<QueryCacheEventData> eventDataList = (List)eventsInOneAcc;
      for (QueryCacheEventData eventData : eventDataList) {
        if (eventData.getDataKey() == null) {
          removePartitionResults(queryResult, partitionId);
          continue;
        } 
        add(queryResult, newQueryResultRow(eventData));
      } 
    } 
  }
  
  private void removePartitionResults(QueryResult queryResult, int partitionId) {
    List<QueryResultRow> rows = queryResult.getRows();
    Iterator<QueryResultRow> iterator = rows.iterator();
    while (iterator.hasNext()) {
      QueryResultRow resultRow = (QueryResultRow)iterator.next();
      if (getPartitionId(resultRow) == partitionId)
        iterator.remove(); 
    } 
  }
  
  private int getPartitionId(QueryResultRow resultRow) { return getNodeEngine().getPartitionService().getPartitionId(resultRow.getKey()); }
  
  private Map<Integer, Future<Object>> readAccumulators() {
    String mapName = this.info.getMapName();
    String cacheId = this.info.getCacheId();
    Collection<Integer> partitionIds = getPartitionIdsOfAccumulators();
    if (partitionIds.isEmpty())
      return Collections.emptyMap(); 
    Int2ObjectHashMap int2ObjectHashMap = new Int2ObjectHashMap(partitionIds.size());
    for (Integer partitionId : partitionIds)
      int2ObjectHashMap.put(partitionId, 
          readAndResetAccumulator(mapName, cacheId, partitionId)); 
    waitResult(int2ObjectHashMap.values());
    return int2ObjectHashMap;
  }
  
  private Future<Object> readAndResetAccumulator(String mapName, String cacheId, Integer partitionId) {
    ReadAndResetAccumulatorOperation readAndResetAccumulatorOperation = new ReadAndResetAccumulatorOperation(mapName, cacheId);
    OperationService operationService = getNodeEngine().getOperationService();
    return operationService.invokeOnPartition("hz:impl:mapService", readAndResetAccumulatorOperation, partitionId.intValue());
  }
  
  private void add(QueryResult result, QueryResultRow row) { result.addRow(row); }
  
  private QueryResultRow newQueryResultRow(QueryCacheEventData eventData) {
    Data dataKey = eventData.getDataKey();
    Data dataNewValue = eventData.getDataNewValue();
    return new QueryResultRow(dataKey, dataNewValue);
  }
  
  private Collection<Integer> getPartitionIdsOfAccumulators() {
    String mapName = this.info.getMapName();
    String cacheId = this.info.getCacheId();
    QueryCacheContext context = getContext();
    return QueryCacheUtil.getAccumulators(context, mapName, cacheId).keySet();
  }
  
  private static Collection<Object> waitResult(Collection<Future<Object>> lsFutures) { return FutureUtil.returnWithDeadline(lsFutures, 5L, TimeUnit.MINUTES, FutureUtil.RETHROW_EVERYTHING); }
  
  public int getFactoryId() { return MapDataSerializerHook.F_ID; }
  
  public int getId() { return 126; }
}
