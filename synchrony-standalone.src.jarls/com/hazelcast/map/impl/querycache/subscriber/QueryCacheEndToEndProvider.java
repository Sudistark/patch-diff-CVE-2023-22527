package com.hazelcast.map.impl.querycache.subscriber;

import com.hazelcast.nio.IOUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.ContextMutexFactory;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class QueryCacheEndToEndProvider<K, V> extends Object {
  private final ContextMutexFactory mutexFactory;
  
  private final ConcurrentMap<String, ConcurrentMap<String, InternalQueryCache<K, V>>> queryCacheRegistryPerMap;
  
  private final ConstructorFunction<String, ConcurrentMap<String, InternalQueryCache<K, V>>> queryCacheRegistryConstructor;
  
  public QueryCacheEndToEndProvider(ContextMutexFactory mutexFactory) {
    this.queryCacheRegistryConstructor = new Object(this);
    this.mutexFactory = mutexFactory;
    this.queryCacheRegistryPerMap = new ConcurrentHashMap();
  }
  
  public InternalQueryCache<K, V> getOrCreateQueryCache(String mapName, String cacheName, ConstructorFunction<String, InternalQueryCache<K, V>> constructor) {
    InternalQueryCache<K, V> existingQueryCache = getExistingQueryCacheOrNull(mapName, cacheName);
    if (existingQueryCache != null)
      return existingQueryCache; 
    return tryCreateQueryCache(mapName, cacheName, constructor);
  }
  
  private InternalQueryCache<K, V> getExistingQueryCacheOrNull(String mapName, String cacheName) {
    ConcurrentMap<String, InternalQueryCache<K, V>> queryCacheRegistry = (ConcurrentMap)this.queryCacheRegistryPerMap.get(mapName);
    if (queryCacheRegistry != null) {
      InternalQueryCache<K, V> queryCache = (InternalQueryCache)queryCacheRegistry.get(cacheName);
      if (queryCache != null)
        return queryCache; 
    } 
    return null;
  }
  
  public InternalQueryCache<K, V> tryCreateQueryCache(String mapName, String cacheName, ConstructorFunction<String, InternalQueryCache<K, V>> constructor) {
    mutex = this.mutexFactory.mutexFor(mapName);
    try {
    
    } finally {
      IOUtil.closeResource(mutex);
    } 
  }
  
  public void removeSingleQueryCache(String mapName, String cacheName) {
    mutex = this.mutexFactory.mutexFor(mapName);
    try {
      synchronized (mutex) {
        Map<String, InternalQueryCache<K, V>> queryCacheRegistry = (Map)this.queryCacheRegistryPerMap.get(mapName);
        if (queryCacheRegistry != null)
          queryCacheRegistry.remove(cacheName); 
      } 
    } finally {
      IOUtil.closeResource(mutex);
    } 
  }
  
  public void destroyAllQueryCaches(String mapName) {
    mutex = this.mutexFactory.mutexFor(mapName);
    try {
      synchronized (mutex) {
        Map<String, InternalQueryCache<K, V>> queryCacheRegistry = (Map)this.queryCacheRegistryPerMap.remove(mapName);
        if (queryCacheRegistry != null)
          for (InternalQueryCache<K, V> queryCache : queryCacheRegistry.values())
            queryCache.destroy();  
      } 
    } finally {
      IOUtil.closeResource(mutex);
    } 
  }
  
  public int getQueryCacheCount(String mapName) {
    Map<String, InternalQueryCache<K, V>> queryCacheRegistry = (Map)this.queryCacheRegistryPerMap.get(mapName);
    if (queryCacheRegistry == null)
      return 0; 
    return queryCacheRegistry.size();
  }
}
