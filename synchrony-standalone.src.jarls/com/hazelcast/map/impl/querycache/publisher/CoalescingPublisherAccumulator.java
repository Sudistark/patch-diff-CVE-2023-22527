package com.hazelcast.map.impl.querycache.publisher;

import com.hazelcast.logging.ILogger;
import com.hazelcast.map.impl.querycache.QueryCacheContext;
import com.hazelcast.map.impl.querycache.QueryCacheEventService;
import com.hazelcast.map.impl.querycache.accumulator.AccumulatorInfo;
import com.hazelcast.map.impl.querycache.accumulator.AccumulatorProcessor;
import com.hazelcast.map.impl.querycache.accumulator.BasicAccumulator;
import com.hazelcast.map.impl.querycache.event.QueryCacheEventData;
import com.hazelcast.map.impl.querycache.event.sequence.Sequenced;
import com.hazelcast.nio.serialization.Data;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

class CoalescingPublisherAccumulator extends BasicAccumulator<QueryCacheEventData> {
  private final Map<Data, Long> index = new HashMap();
  
  CoalescingPublisherAccumulator(QueryCacheContext context, AccumulatorInfo info) { super(context, info); }
  
  public void accumulate(QueryCacheEventData eventData) {
    setSequence(eventData);
    getBuffer().add(eventData);
    AccumulatorInfo info = getInfo();
    if (!info.isPublishable())
      return; 
    poll(this.handler, info.getBatchSize());
    poll(this.handler, info.getDelaySeconds(), TimeUnit.SECONDS);
  }
  
  public void reset() {
    this.index.clear();
    super.reset();
  }
  
  private void setSequence(QueryCacheEventData eventData) {
    Data dataKey = eventData.getDataKey();
    Long sequence = (Long)this.index.get(dataKey);
    if (sequence != null) {
      eventData.setSequence(sequence.longValue());
    } else {
      long nextSequence = this.partitionSequencer.nextSequence();
      eventData.setSequence(nextSequence);
      this.index.put(dataKey, Long.valueOf(nextSequence));
    } 
    if (this.logger.isFinestEnabled())
      this.logger.finest(String.format("Added to index key=%s, sequence=%d, indexSize=%d", new Object[] { eventData
              .getKey(), Long.valueOf(eventData.getSequence()), Integer.valueOf(this.index.size()) })); 
  }
  
  protected AccumulatorProcessor<Sequenced> createAccumulatorProcessor(AccumulatorInfo info, QueryCacheEventService eventService) { return new CoalescedEventAccumulatorProcessor(this, info, eventService); }
}
