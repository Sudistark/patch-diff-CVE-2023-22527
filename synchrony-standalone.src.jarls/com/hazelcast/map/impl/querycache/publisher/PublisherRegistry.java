package com.hazelcast.map.impl.querycache.publisher;

import com.hazelcast.map.impl.querycache.QueryCacheContext;
import com.hazelcast.map.impl.querycache.Registry;
import com.hazelcast.map.impl.querycache.accumulator.AccumulatorInfo;
import com.hazelcast.map.impl.querycache.accumulator.AccumulatorInfoSupplier;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import java.util.Collections;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class PublisherRegistry extends Object implements Registry<String, PartitionAccumulatorRegistry> {
  private final ConstructorFunction<String, PartitionAccumulatorRegistry> partitionAccumulatorRegistryConstructor;
  
  private final String mapName;
  
  private final QueryCacheContext context;
  
  private final ConcurrentMap<String, PartitionAccumulatorRegistry> partitionAccumulators;
  
  public PublisherRegistry(QueryCacheContext context, String mapName) {
    this.partitionAccumulatorRegistryConstructor = new Object(this);
    this.context = context;
    this.mapName = mapName;
    this.partitionAccumulators = new ConcurrentHashMap();
  }
  
  public PartitionAccumulatorRegistry getOrCreate(String cacheId) { return (PartitionAccumulatorRegistry)ConcurrencyUtil.getOrPutIfAbsent(this.partitionAccumulators, cacheId, this.partitionAccumulatorRegistryConstructor); }
  
  public PartitionAccumulatorRegistry getOrNull(String cacheId) { return (PartitionAccumulatorRegistry)this.partitionAccumulators.get(cacheId); }
  
  public Map<String, PartitionAccumulatorRegistry> getAll() { return Collections.unmodifiableMap(this.partitionAccumulators); }
  
  public PartitionAccumulatorRegistry remove(String cacheId) { return (PartitionAccumulatorRegistry)this.partitionAccumulators.remove(cacheId); }
  
  private AccumulatorInfo getAccumulatorInfo(String cacheId) {
    PublisherContext publisherContext = this.context.getPublisherContext();
    AccumulatorInfoSupplier infoSupplier = publisherContext.getAccumulatorInfoSupplier();
    return infoSupplier.getAccumulatorInfoOrNull(this.mapName, cacheId);
  }
  
  private PublisherAccumulatorFactory createPublisherAccumulatorFactory() { return new PublisherAccumulatorFactory(this.context); }
}
