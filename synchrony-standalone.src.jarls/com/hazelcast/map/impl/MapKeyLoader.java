package com.hazelcast.map.impl;

import com.hazelcast.core.ExecutionCallback;
import com.hazelcast.core.IFunction;
import com.hazelcast.instance.MemberImpl;
import com.hazelcast.internal.cluster.ClusterService;
import com.hazelcast.logging.ILogger;
import com.hazelcast.logging.Logger;
import com.hazelcast.map.impl.mapstore.MapStoreContext;
import com.hazelcast.map.impl.operation.KeyLoadStatusOperation;
import com.hazelcast.map.impl.operation.KeyLoadStatusOperationFactory;
import com.hazelcast.map.impl.operation.MapOperation;
import com.hazelcast.map.impl.operation.MapOperationProvider;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.IOUtil;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.ExecutionService;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.OperationService;
import com.hazelcast.spi.partition.IPartition;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.util.FutureUtil;
import com.hazelcast.util.IterableUtil;
import com.hazelcast.util.StateMachine;
import com.hazelcast.util.scheduler.CoalescingDelayedTrigger;
import java.io.Closeable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class MapKeyLoader {
  private static final long LOADING_TRIGGER_DELAY = TimeUnit.SECONDS.toMillis(5L);
  
  private ILogger logger;
  
  private String mapName;
  
  private OperationService opService;
  
  private IPartitionService partitionService;
  
  private final ClusterService clusterService;
  
  private IFunction<Object, Data> toData;
  
  private ExecutionService execService;
  
  private CoalescingDelayedTrigger delayedTrigger;
  
  private int maxSizePerNode;
  
  private int maxBatch;
  
  private int mapNamePartition;
  
  private int partitionId;
  
  private boolean hasBackup;
  
  private LoadFinishedFuture keyLoadFinished;
  
  private MapOperationProvider operationProvider;
  
  private final StateMachine<Role> role;
  
  private final StateMachine<State> state;
  
  public MapKeyLoader(String mapName, OperationService opService, IPartitionService ps, ClusterService clusterService, ExecutionService execService, IFunction<Object, Data> serialize) {
    this.keyLoadFinished = new LoadFinishedFuture(Boolean.valueOf(true), null);
    this
      
      .role = StateMachine.of(Role.NONE).withTransition(Role.NONE, Role.SENDER, new Role[] { Role.RECEIVER, Role.SENDER_BACKUP }).withTransition(Role.SENDER_BACKUP, Role.SENDER, new Role[0]);
    this

      
      .state = StateMachine.of(State.NOT_LOADED).withTransition(State.NOT_LOADED, State.LOADING, new State[0]).withTransition(State.LOADING, State.LOADED, new State[] { State.NOT_LOADED }).withTransition(State.LOADED, State.LOADING, new State[0]);
    this.mapName = mapName;
    this.opService = opService;
    this.partitionService = ps;
    this.clusterService = clusterService;
    this.toData = serialize;
    this.execService = execService;
    this.logger = Logger.getLogger(MapKeyLoader.class);
  }
  
  public Future startInitialLoad(MapStoreContext mapStoreContext, int partitionId) {
    this.partitionId = partitionId;
    this.mapNamePartition = this.partitionService.getPartitionId((Data)this.toData.apply(this.mapName));
    Role newRole = calculateRole();
    this.role.nextOrStay(newRole);
    this.state.next(State.LOADING);
    if (this.logger.isFinestEnabled())
      this.logger.finest("startInitialLoad invoked " + getStateMessage()); 
    switch (null.$SwitchMap$com$hazelcast$map$impl$MapKeyLoader$Role[newRole.ordinal()]) {
      case 1:
        return sendKeys(mapStoreContext, false);
      case 2:
      case 3:
        return triggerLoading();
    } 
    return this.keyLoadFinished;
  }
  
  private Role calculateRole() {
    boolean isPartitionOwner = this.partitionService.isPartitionOwner(this.partitionId);
    boolean isMapNamePartition = (this.partitionId == this.mapNamePartition);
    boolean isMapNamePartitionFirstReplica = false;
    if (this.hasBackup && isMapNamePartition) {
      IPartition partition = this.partitionService.getPartition(this.partitionId);
      Address firstReplicaAddress = partition.getReplicaAddress(1);
      MemberImpl memberImpl = this.clusterService.getMember(firstReplicaAddress);
      if (memberImpl != null)
        isMapNamePartitionFirstReplica = memberImpl.localMember(); 
    } 
    return MapKeyLoaderUtil.assignRole(isPartitionOwner, isMapNamePartition, isMapNamePartitionFirstReplica);
  }
  
  private Future<?> sendKeys(MapStoreContext mapStoreContext, boolean replaceExistingValues) {
    if (this.keyLoadFinished.isDone()) {
      this.keyLoadFinished = new LoadFinishedFuture(null);
      Future<Boolean> sent = this.execService.submit("hz:map-loadAllKeys", new Object(this, mapStoreContext, replaceExistingValues));
      this.execService.asCompletableFuture(sent).andThen(this.keyLoadFinished);
    } 
    return this.keyLoadFinished;
  }
  
  private Future triggerLoading() {
    if (this.keyLoadFinished.isDone()) {
      this.keyLoadFinished = new LoadFinishedFuture(null);
      this.execService.execute("hz:map-loadAllKeys", new Object(this));
    } 
    return this.keyLoadFinished;
  }
  
  private ExecutionCallback<Boolean> loadingFinishedCallback() { return new Object(this); }
  
  private void updateLocalKeyLoadStatus(Throwable t) {
    KeyLoadStatusOperation keyLoadStatusOperation = new KeyLoadStatusOperation(this.mapName, t);
    if (this.hasBackup && this.role.is(Role.SENDER_BACKUP, new Role[0])) {
      this.opService.createInvocationBuilder("hz:impl:mapService", keyLoadStatusOperation, this.partitionId).setReplicaIndex(1).invoke();
    } else {
      this.opService.createInvocationBuilder("hz:impl:mapService", keyLoadStatusOperation, this.partitionId).invoke();
    } 
  }
  
  public Future<?> startLoading(MapStoreContext mapStoreContext, boolean replaceExistingValues) {
    this.role.nextOrStay(Role.SENDER);
    if (this.state.is(State.LOADING, new State[0]))
      return this.keyLoadFinished; 
    this.state.next(State.LOADING);
    return sendKeys(mapStoreContext, replaceExistingValues);
  }
  
  public void trackLoading(boolean lastBatch, Throwable exception) {
    if (lastBatch) {
      this.state.nextOrStay(State.LOADED);
      if (exception != null) {
        this.keyLoadFinished.setResult(exception);
      } else {
        this.keyLoadFinished.setResult(Boolean.valueOf(true));
      } 
    } else if (this.state.is(State.LOADED, new State[0])) {
      this.state.next(State.LOADING);
    } 
  }
  
  public void triggerLoadingWithDelay() {
    if (this.delayedTrigger == null) {
      Object object = new Object(this);
      this.delayedTrigger = new CoalescingDelayedTrigger(this.execService, LOADING_TRIGGER_DELAY, LOADING_TRIGGER_DELAY, object);
    } 
    this.delayedTrigger.executeWithDelay();
  }
  
  public boolean shouldDoInitialLoad() {
    if (this.role.is(Role.SENDER_BACKUP, new Role[0])) {
      this.role.next(Role.SENDER);
      if (this.state.is(State.LOADING, new State[0])) {
        this.state.next(State.NOT_LOADED);
        this.keyLoadFinished.setResult(Boolean.valueOf(false));
      } 
    } 
    return this.state.is(State.NOT_LOADED, new State[0]);
  }
  
  private void sendKeysInBatches(MapStoreContext mapStoreContext, boolean replaceExistingValues) throws Exception {
    if (this.logger.isFinestEnabled())
      this.logger.finest("sendKeysInBatches invoked " + getStateMessage()); 
    clusterSize = this.partitionService.getMemberPartitionsMap().size();
    keys = null;
    loadError = null;
    try {
      Iterable<Object> allKeys = mapStoreContext.loadAllKeys();
      keys = allKeys.iterator();
      Iterator<Data> dataKeys = IterableUtil.map(keys, this.toData);
      int mapMaxSize = clusterSize * this.maxSizePerNode;
      if (mapMaxSize > 0)
        dataKeys = IterableUtil.limit(dataKeys, mapMaxSize); 
      Iterator<Map.Entry<Integer, Data>> partitionsAndKeys = IterableUtil.map(dataKeys, MapKeyLoaderUtil.toPartition(this.partitionService));
      Iterator<Map<Integer, List<Data>>> batches = MapKeyLoaderUtil.toBatches(partitionsAndKeys, this.maxBatch);
      List<Future> futures = new ArrayList<Future>();
      while (batches.hasNext()) {
        Map<Integer, List<Data>> batch = (Map)batches.next();
        futures.addAll(sendBatch(batch, replaceExistingValues));
      } 
      FutureUtil.waitForever(futures);
    } catch (Exception caught) {
      loadError = caught;
    } finally {
      sendKeyLoadCompleted(clusterSize, loadError);
      if (keys instanceof Closeable)
        IOUtil.closeResource((Closeable)keys); 
    } 
  }
  
  private List<Future> sendBatch(Map<Integer, List<Data>> batch, boolean replaceExistingValues) {
    Set<Map.Entry<Integer, List<Data>>> entries = batch.entrySet();
    List<Future> futures = new ArrayList<Future>(entries.size());
    for (Map.Entry<Integer, List<Data>> e : entries) {
      int partitionId = ((Integer)e.getKey()).intValue();
      List<Data> keys = (List)e.getValue();
      MapOperation op = this.operationProvider.createLoadAllOperation(this.mapName, keys, replaceExistingValues);
      InternalCompletableFuture<Object> future = this.opService.invokeOnPartition("hz:impl:mapService", op, partitionId);
      futures.add(future);
    } 
    return futures;
  }
  
  private void sendKeyLoadCompleted(int clusterSize, Throwable exception) throws Exception {
    List<Future> futures = new ArrayList<Future>();
    KeyLoadStatusOperation keyLoadStatusOperation = new KeyLoadStatusOperation(this.mapName, exception);
    InternalCompletableFuture internalCompletableFuture = this.opService.createInvocationBuilder("hz:impl:mapService", keyLoadStatusOperation, this.mapNamePartition).setReplicaIndex(0).invoke();
    futures.add(internalCompletableFuture);
    if (this.hasBackup && clusterSize > 1) {
      KeyLoadStatusOperation keyLoadStatusOperation1 = new KeyLoadStatusOperation(this.mapName, exception);
      InternalCompletableFuture internalCompletableFuture1 = this.opService.createInvocationBuilder("hz:impl:mapService", keyLoadStatusOperation1, this.mapNamePartition).setReplicaIndex(1).invoke();
      futures.add(internalCompletableFuture1);
    } 
    FutureUtil.waitForever(futures);
    this.opService.invokeOnAllPartitions("hz:impl:mapService", new KeyLoadStatusOperationFactory(this.mapName, exception));
  }
  
  public void setMaxBatch(int maxBatch) { this.maxBatch = maxBatch; }
  
  public void setMaxSize(int maxSize) { this.maxSizePerNode = maxSize; }
  
  public void setHasBackup(boolean hasBackup) { this.hasBackup = hasBackup; }
  
  public void setMapOperationProvider(MapOperationProvider operationProvider) { this.operationProvider = operationProvider; }
  
  public boolean isKeyLoadFinished() { return this.keyLoadFinished.isDone(); }
  
  public void promoteToLoadedOnMigration() {
    this.state.next(State.LOADING);
    this.state.next(State.LOADED);
  }
  
  private String getStateMessage() { return "on partitionId=" + this.partitionId + " on " + this.clusterService.getThisAddress() + " role=" + this.role + " state=" + this.state; }
}
