package com.hazelcast.map.impl.event;

import com.hazelcast.core.EntryEventType;
import com.hazelcast.core.EntryView;
import com.hazelcast.internal.serialization.InternalSerializationService;
import com.hazelcast.map.impl.EntryEventFilter;
import com.hazelcast.map.impl.EventListenerFilter;
import com.hazelcast.map.impl.MapContainer;
import com.hazelcast.map.impl.MapServiceContext;
import com.hazelcast.map.impl.query.QueryEventFilter;
import com.hazelcast.map.impl.wan.MapReplicationRemove;
import com.hazelcast.map.impl.wan.MapReplicationUpdate;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.EventFilter;
import com.hazelcast.spi.EventRegistration;
import com.hazelcast.spi.EventService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.spi.properties.HazelcastProperty;
import com.hazelcast.util.Clock;
import com.hazelcast.util.CollectionUtil;
import com.hazelcast.wan.ReplicationEventObject;
import com.hazelcast.wan.WanReplicationPublisher;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedList;

public class MapEventPublisherImpl implements MapEventPublisher {
  public static final String PROP_LISTENER_WITH_PREDICATE_PRODUCES_NATURAL_EVENT_TYPES = "hazelcast.map.entry.filtering.natural.event.types";
  
  public static final HazelcastProperty LISTENER_WITH_PREDICATE_PRODUCES_NATURAL_EVENT_TYPES = new HazelcastProperty("hazelcast.map.entry.filtering.natural.event.types", false);
  
  protected final NodeEngine nodeEngine;
  
  protected final EventService eventService;
  
  protected final IPartitionService partitionService;
  
  protected final MapServiceContext mapServiceContext;
  
  protected final FilteringStrategy filteringStrategy;
  
  protected final InternalSerializationService serializationService;
  
  protected final QueryCacheEventPublisher queryCacheEventPublisher;
  
  public MapEventPublisherImpl(MapServiceContext mapServiceContext) {
    this.mapServiceContext = mapServiceContext;
    this.nodeEngine = mapServiceContext.getNodeEngine();
    this.partitionService = this.nodeEngine.getPartitionService();
    this.serializationService = (InternalSerializationService)this.nodeEngine.getSerializationService();
    this.eventService = this.nodeEngine.getEventService();
    if (this.nodeEngine.getProperties()
      .getBoolean(LISTENER_WITH_PREDICATE_PRODUCES_NATURAL_EVENT_TYPES)) {
      this.filteringStrategy = new QueryCacheNaturalFilteringStrategy(this.serializationService, mapServiceContext);
    } else {
      this.filteringStrategy = new DefaultEntryEventFilteringStrategy(this.serializationService, mapServiceContext);
    } 
    this
      .queryCacheEventPublisher = new QueryCacheEventPublisher(this.filteringStrategy, mapServiceContext.getQueryCacheContext(), this.serializationService);
  }
  
  public void publishWanUpdate(String mapName, EntryView<Data, Data> entryView, boolean hasLoadProvenance) {
    if (!isOwnedPartition((Data)entryView.getKey()))
      return; 
    MapContainer mapContainer = this.mapServiceContext.getMapContainer(mapName);
    Object wanMergePolicy = mapContainer.getWanMergePolicy();
    MapReplicationUpdate event = new MapReplicationUpdate(mapName, wanMergePolicy, entryView);
    publishWanEvent(mapName, event);
  }
  
  public void publishWanRemove(String mapName, Data key) {
    if (!isOwnedPartition(key))
      return; 
    MapReplicationRemove event = new MapReplicationRemove(mapName, key, Clock.currentTimeMillis());
    publishWanEvent(mapName, event);
  }
  
  protected void publishWanEvent(String mapName, ReplicationEventObject event) {
    MapContainer mapContainer = this.mapServiceContext.getMapContainer(mapName);
    WanReplicationPublisher wanReplicationPublisher = mapContainer.getWanReplicationPublisher();
    if (isOwnedPartition(event.getKey())) {
      wanReplicationPublisher.publishReplicationEvent("hz:impl:mapService", event);
    } else {
      wanReplicationPublisher.publishReplicationEventBackup("hz:impl:mapService", event);
    } 
  }
  
  private boolean isOwnedPartition(Data dataKey) {
    int partitionId = this.partitionService.getPartitionId(dataKey);
    return this.partitionService.getPartition(partitionId, false).isLocal();
  }
  
  public void publishMapEvent(Address caller, String mapName, EntryEventType eventType, int numberOfEntriesAffected) {
    Collection<EventRegistration> mapsListenerRegistrations = getRegistrations(mapName);
    if (CollectionUtil.isEmpty(mapsListenerRegistrations))
      return; 
    Collection<EventRegistration> registrations = null;
    for (EventRegistration registration : mapsListenerRegistrations) {
      EventFilter filter = registration.getFilter();
      if (filter instanceof EventListenerFilter && 
        !filter.eval(Integer.valueOf(eventType.getType())))
        continue; 
      if (!(filter instanceof com.hazelcast.map.impl.MapPartitionLostEventFilter)) {
        if (registrations == null)
          registrations = new ArrayList<EventRegistration>(); 
        registrations.add(registration);
      } 
    } 
    if (CollectionUtil.isEmpty(registrations))
      return; 
    String source = getThisNodesAddress();
    MapEventData mapEventData = new MapEventData(source, mapName, caller, eventType.getType(), numberOfEntriesAffected);
    publishEventInternal(registrations, mapEventData, mapName.hashCode());
  }
  
  public void publishEvent(Address caller, String mapName, EntryEventType eventType, Data dataKey, Object oldValue, Object dataValue) { publishEvent(caller, mapName, eventType, dataKey, oldValue, dataValue, null); }
  
  public void publishEvent(Address caller, String mapName, EntryEventType eventType, Data dataKey, Object oldValue, Object value, Object mergingValue) {
    Collection<EventRegistration> registrations = getRegistrations(mapName);
    if (CollectionUtil.isEmpty(registrations))
      return; 
    publishEvent(registrations, caller, mapName, eventType, dataKey, oldValue, value, mergingValue);
  }
  
  private void publishEvent(Collection<EventRegistration> registrations, Address caller, String mapName, EntryEventType eventType, Data dataKey, Object oldValue, Object newValue, Object mergingValue) {
    EntryEventDataCache eventDataCache = this.filteringStrategy.getEntryEventDataCache();
    int orderKey = pickOrderKey(dataKey);
    for (EventRegistration registration : registrations) {
      EventFilter filter = registration.getFilter();
      int eventTypeForPublishing = this.filteringStrategy.doFilter(filter, dataKey, oldValue, newValue, eventType, mapName);
      if (eventTypeForPublishing == -1)
        continue; 
      EntryEventData eventDataToBePublished = eventDataCache.getOrCreateEventData(mapName, caller, dataKey, newValue, oldValue, mergingValue, eventTypeForPublishing, 
          isIncludeValue(filter));
      this.eventService.publishEvent("hz:impl:mapService", registration, eventDataToBePublished, orderKey);
    } 
    if (!eventDataCache.isEmpty())
      postPublishEvent(eventDataCache.eventDataIncludingValues(), eventDataCache.eventDataExcludingValues()); 
  }
  
  protected void postPublishEvent(Collection<EntryEventData> eventDataIncludingValues, Collection<EntryEventData> eventDataExcludingValues) {
    if (eventDataIncludingValues != null)
      for (EntryEventData entryEventData : eventDataIncludingValues)
        this.queryCacheEventPublisher.addEventToQueryCache(entryEventData);  
  }
  
  static boolean isIncludeValue(EventFilter filter) {
    if (filter instanceof EventListenerFilter)
      filter = ((EventListenerFilter)filter).getEventFilter(); 
    if (filter instanceof com.hazelcast.spi.impl.eventservice.impl.TrueEventFilter)
      return true; 
    if (filter instanceof QueryEventFilter)
      return ((QueryEventFilter)filter).isIncludeValue(); 
    if (filter instanceof EntryEventFilter)
      return ((EntryEventFilter)filter).isIncludeValue(); 
    throw new IllegalArgumentException("Unknown EventFilter type = [" + filter.getClass().getCanonicalName() + "]");
  }
  
  public void publishMapPartitionLostEvent(Address caller, String mapName, int partitionId) {
    Collection<EventRegistration> registrations = new LinkedList<EventRegistration>();
    for (EventRegistration registration : getRegistrations(mapName)) {
      if (registration.getFilter() instanceof com.hazelcast.map.impl.MapPartitionLostEventFilter)
        registrations.add(registration); 
    } 
    if (registrations.isEmpty())
      return; 
    String thisNodesAddress = getThisNodesAddress();
    MapPartitionEventData eventData = new MapPartitionEventData(thisNodesAddress, mapName, caller, partitionId);
    publishEventInternal(registrations, eventData, partitionId);
  }
  
  public void hintMapEvent(Address caller, String mapName, EntryEventType eventType, int numberOfEntriesAffected, int partitionId) { this.queryCacheEventPublisher.hintMapEvent(caller, mapName, eventType, numberOfEntriesAffected, partitionId); }
  
  public void addEventToQueryCache(Object eventData) { this.queryCacheEventPublisher.addEventToQueryCache(eventData); }
  
  public boolean hasEventListener(String mapName) { return this.eventService.hasEventRegistration("hz:impl:mapService", mapName); }
  
  protected Collection<EventRegistration> getRegistrations(String mapName) { return this.eventService.getRegistrations("hz:impl:mapService", mapName); }
  
  private int pickOrderKey(Data key) { return (key == null) ? -1 : key.hashCode(); }
  
  protected void publishEventInternal(Collection<EventRegistration> registrations, Object eventData, int orderKey) {
    this.eventService.publishEvent("hz:impl:mapService", registrations, eventData, orderKey);
    this.queryCacheEventPublisher.addEventToQueryCache(eventData);
  }
  
  private String getThisNodesAddress() {
    Address thisAddress = this.nodeEngine.getThisAddress();
    return thisAddress.toString();
  }
}
