package com.hazelcast.map.impl.mapstore.writebehind;

import com.hazelcast.map.ReachedMaxSizeException;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

class BoundedWriteBehindQueue<E> extends Object implements WriteBehindQueue<E> {
  private final AtomicInteger writeBehindQueueItemCounter;
  
  private final int maxCapacity;
  
  private final WriteBehindQueue<E> queue;
  
  BoundedWriteBehindQueue(int maxCapacity, AtomicInteger writeBehindQueueItemCounter, WriteBehindQueue<E> queue) {
    this.maxCapacity = maxCapacity;
    this.writeBehindQueueItemCounter = writeBehindQueueItemCounter;
    this.queue = queue;
  }
  
  public void addFirst(Collection<E> collection) {
    if (collection == null || collection.isEmpty())
      return; 
    addCapacity(collection.size());
    this.queue.addFirst(collection);
  }
  
  public void addLast(E e) {
    addCapacity(1);
    this.queue.addLast(e);
  }
  
  public E peek() { return (E)this.queue.peek(); }
  
  public boolean removeFirstOccurrence(E e) {
    boolean result = this.queue.removeFirstOccurrence(e);
    if (result)
      addCapacity(-1); 
    return result;
  }
  
  public int drainTo(Collection<E> collection) {
    int size = this.queue.drainTo(collection);
    addCapacity(-size);
    return size;
  }
  
  public boolean contains(E e) { return this.queue.contains(e); }
  
  public int size() { return this.queue.size(); }
  
  public void clear() {
    int size = size();
    this.queue.clear();
    addCapacity(-size);
  }
  
  public List<E> asList() { return this.queue.asList(); }
  
  public void filter(IPredicate<E> predicate, Collection<E> collection) { this.queue.filter(predicate, collection); }
  
  private void addCapacity(int capacity) {
    int maxCapacity = this.maxCapacity;
    AtomicInteger writeBehindQueueItemCounter = this.writeBehindQueueItemCounter;
    int currentCapacity = writeBehindQueueItemCounter.get();
    int newCapacity = currentCapacity + capacity;
    if (newCapacity < 0)
      return; 
    if (maxCapacity < newCapacity)
      throwException(currentCapacity, maxCapacity, capacity); 
    while (!writeBehindQueueItemCounter.compareAndSet(currentCapacity, newCapacity)) {
      currentCapacity = writeBehindQueueItemCounter.get();
      newCapacity = currentCapacity + capacity;
      if (newCapacity < 0)
        return; 
      if (maxCapacity < newCapacity)
        throwException(currentCapacity, maxCapacity, capacity); 
    } 
  }
  
  private void throwException(int currentCapacity, int maxSize, int requiredCapacity) {
    String msg = String.format("Reached node-wide max capacity for write-behind-stores. Max allowed capacity = [%d], current capacity = [%d], required capacity = [%d]", new Object[] { Integer.valueOf(maxSize), Integer.valueOf(currentCapacity), Integer.valueOf(requiredCapacity) });
    throw new ReachedMaxSizeException(msg);
  }
}
