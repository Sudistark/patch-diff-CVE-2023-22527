package com.hazelcast.map.impl.mapstore.writebehind;

import com.hazelcast.config.MapStoreConfig;
import com.hazelcast.map.impl.MapServiceContext;
import com.hazelcast.map.impl.PartitionContainer;
import com.hazelcast.map.impl.mapstore.MapDataStore;
import com.hazelcast.map.impl.mapstore.MapStoreContext;
import com.hazelcast.map.impl.mapstore.writebehind.entry.DelayedEntry;
import com.hazelcast.map.impl.recordstore.RecordStore;
import com.hazelcast.spi.ExecutionService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.partition.IPartition;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.spi.properties.GroupProperty;
import com.hazelcast.spi.properties.HazelcastProperties;
import com.hazelcast.util.Clock;
import com.hazelcast.util.CollectionUtil;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

public class StoreWorker implements Runnable {
  private final String mapName;
  
  private final MapServiceContext mapServiceContext;
  
  private final IPartitionService partitionService;
  
  private final ExecutionService executionService;
  
  private final WriteBehindProcessor writeBehindProcessor;
  
  private final long backupDelayMillis;
  
  private final long writeDelayMillis;
  
  private final int partitionCount;
  
  private long lastHighestStoreTime;
  
  public StoreWorker(MapStoreContext mapStoreContext, WriteBehindProcessor writeBehindProcessor) {
    this.mapName = mapStoreContext.getMapName();
    this.mapServiceContext = mapStoreContext.getMapServiceContext();
    NodeEngine nodeEngine = this.mapServiceContext.getNodeEngine();
    this.partitionService = nodeEngine.getPartitionService();
    this.executionService = nodeEngine.getExecutionService();
    this.writeBehindProcessor = writeBehindProcessor;
    this.backupDelayMillis = getReplicaWaitTimeMillis();
    this.lastHighestStoreTime = Clock.currentTimeMillis();
    this.writeDelayMillis = TimeUnit.SECONDS.toMillis(getWriteDelaySeconds(mapStoreContext));
    this.partitionCount = this.partitionService.getPartitionCount();
  }
  
  public void start() {
    if (this.running)
      return; 
    this.running = true;
    schedule();
  }
  
  public void stop() { this.running = false; }
  
  public void run() {
    try {
      runInternal();
    } finally {
      if (this.running)
        schedule(); 
    } 
  }
  
  private void schedule() { this.executionService.schedule(this, 1L, TimeUnit.SECONDS); }
  
  private void runInternal() {
    long now = Clock.currentTimeMillis();
    long ownerHighestStoreTime = calculateHighestStoreTime(this.lastHighestStoreTime, now);
    long backupHighestStoreTime = ownerHighestStoreTime - this.backupDelayMillis;
    this.lastHighestStoreTime = ownerHighestStoreTime;
    List<DelayedEntry> ownersList = null;
    List<DelayedEntry> backupsList = null;
    for (int partitionId = 0; partitionId < this.partitionCount && 
      !Thread.currentThread().isInterrupted(); partitionId++) {
      RecordStore recordStore = getRecordStoreOrNull(this.mapName, partitionId);
      if (hasEntryInWriteBehindQueue(recordStore)) {
        boolean localPartition = isPartitionLocal(partitionId);
        if (!localPartition) {
          backupsList = initListIfNull(backupsList, this.partitionCount);
          selectEntriesToStore(recordStore, backupsList, backupHighestStoreTime);
        } else {
          ownersList = initListIfNull(ownersList, this.partitionCount);
          selectEntriesToStore(recordStore, ownersList, ownerHighestStoreTime);
        } 
      } 
    } 
    if (!CollectionUtil.isEmpty(ownersList)) {
      Map<Integer, List<DelayedEntry>> failuresPerPartition = this.writeBehindProcessor.process(ownersList);
      removeFinishedStoreOperationsFromQueues(this.mapName, ownersList);
      reAddFailedStoreOperationsToQueues(this.mapName, failuresPerPartition);
    } 
    if (!CollectionUtil.isEmpty(backupsList))
      doInBackup(backupsList); 
    notifyFlush();
  }
  
  private static List<DelayedEntry> initListIfNull(List<DelayedEntry> list, int capacity) {
    if (list == null)
      list = new ArrayList<DelayedEntry>(capacity); 
    return list;
  }
  
  private long calculateHighestStoreTime(long lastHighestStoreTime, long now) { return (now >= lastHighestStoreTime + this.writeDelayMillis) ? now : lastHighestStoreTime; }
  
  private boolean hasEntryInWriteBehindQueue(RecordStore recordStore) {
    if (recordStore == null)
      return false; 
    MapDataStore mapDataStore = recordStore.getMapDataStore();
    WriteBehindStore dataStore = (WriteBehindStore)mapDataStore;
    WriteBehindQueue<DelayedEntry> writeBehindQueue = dataStore.getWriteBehindQueue();
    return (writeBehindQueue.size() != 0);
  }
  
  private void notifyFlush() {
    for (int partitionId = 0; partitionId < this.partitionCount; partitionId++) {
      RecordStore recordStore = getRecordStoreOrNull(this.mapName, partitionId);
      if (recordStore != null) {
        WriteBehindStore mapDataStore = (WriteBehindStore)recordStore.getMapDataStore();
        mapDataStore.notifyFlush();
      } 
    } 
  }
  
  private boolean isPartitionLocal(int partitionId) {
    IPartition partition = this.partitionService.getPartition(partitionId, false);
    return partition.isLocal();
  }
  
  private void selectEntriesToStore(RecordStore recordStore, List<DelayedEntry> entries, long highestStoreTime) {
    WriteBehindQueue<DelayedEntry> queue = getWriteBehindQueue(recordStore);
    long nextSequenceToFlush = getSequenceToFlush(recordStore);
    filterWriteBehindQueue(highestStoreTime, nextSequenceToFlush, entries, queue);
  }
  
  private void filterWriteBehindQueue(long highestStoreTime, long sequence, Collection<DelayedEntry> collection, WriteBehindQueue<DelayedEntry> queue) {
    if (sequence > 0L) {
      queue.filter(new Object(this, sequence), collection);
    } else {
      queue.filter(new Object(this, highestStoreTime), collection);
    } 
  }
  
  private void removeFinishedStoreOperationsFromQueues(String mapName, List<DelayedEntry> entries) {
    for (DelayedEntry entry : entries) {
      RecordStore recordStore = getRecordStoreOrNull(mapName, entry.getPartitionId());
      if (recordStore != null)
        getWriteBehindQueue(recordStore).removeFirstOccurrence(entry); 
    } 
  }
  
  private void reAddFailedStoreOperationsToQueues(String mapName, Map<Integer, List<DelayedEntry>> failuresPerPartition) {
    if (failuresPerPartition.isEmpty())
      return; 
    for (Map.Entry<Integer, List<DelayedEntry>> entry : failuresPerPartition.entrySet()) {
      Integer partitionId = (Integer)entry.getKey();
      List<DelayedEntry> failures = (List)failuresPerPartition.get(partitionId);
      if (CollectionUtil.isEmpty(failures))
        continue; 
      RecordStore recordStore = getRecordStoreOrNull(mapName, partitionId.intValue());
      if (recordStore == null)
        continue; 
      WriteBehindQueue<DelayedEntry> queue = getWriteBehindQueue(recordStore);
      queue.addFirst(failures);
    } 
  }
  
  private void doInBackup(List<DelayedEntry> delayedEntries) {
    this.writeBehindProcessor.callBeforeStoreListeners(delayedEntries);
    removeFinishedStoreOperationsFromQueues(this.mapName, delayedEntries);
    this.writeBehindProcessor.callAfterStoreListeners(delayedEntries);
  }
  
  private long getReplicaWaitTimeMillis() {
    HazelcastProperties hazelcastProperties = this.mapServiceContext.getNodeEngine().getProperties();
    return hazelcastProperties.getMillis(GroupProperty.MAP_REPLICA_SCHEDULED_TASK_DELAY_SECONDS);
  }
  
  private RecordStore getRecordStoreOrNull(String mapName, int partitionId) {
    PartitionContainer partitionContainer = this.mapServiceContext.getPartitionContainer(partitionId);
    return partitionContainer.getExistingRecordStore(mapName);
  }
  
  private WriteBehindQueue<DelayedEntry> getWriteBehindQueue(RecordStore recordStore) {
    WriteBehindStore writeBehindStore = (WriteBehindStore)recordStore.getMapDataStore();
    return writeBehindStore.getWriteBehindQueue();
  }
  
  private long getSequenceToFlush(RecordStore recordStore) {
    WriteBehindStore writeBehindStore = (WriteBehindStore)recordStore.getMapDataStore();
    return writeBehindStore.getSequenceToFlush();
  }
  
  private static int getWriteDelaySeconds(MapStoreContext mapStoreContext) {
    MapStoreConfig mapStoreConfig = mapStoreContext.getMapStoreConfig();
    return mapStoreConfig.getWriteDelaySeconds();
  }
  
  public String toString() { return "StoreWorker{mapName='" + this.mapName + "'}"; }
}
