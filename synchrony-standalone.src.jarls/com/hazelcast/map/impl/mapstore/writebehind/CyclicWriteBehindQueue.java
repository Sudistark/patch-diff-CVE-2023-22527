package com.hazelcast.map.impl.mapstore.writebehind;

import com.hazelcast.map.impl.mapstore.writebehind.entry.DelayedEntry;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.util.MutableInteger;
import com.hazelcast.util.Preconditions;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

class CyclicWriteBehindQueue extends Object implements WriteBehindQueue<DelayedEntry> {
  private final Deque<DelayedEntry> deque = new ArrayDeque();
  
  private final Map<Data, MutableInteger> index = new HashMap();
  
  public void addFirst(Collection<DelayedEntry> collection) {
    for (DelayedEntry entry : collection)
      this.deque.addFirst(entry); 
    addCountIndex(collection);
  }
  
  public void addLast(DelayedEntry entry) {
    this.deque.addLast(entry);
    addCountIndex(entry);
  }
  
  public DelayedEntry peek() { return (DelayedEntry)this.deque.peek(); }
  
  public boolean removeFirstOccurrence(DelayedEntry entry) {
    DelayedEntry removedEntry = (DelayedEntry)this.deque.pollFirst();
    if (removedEntry == null)
      return false; 
    decreaseCountIndex(entry);
    return true;
  }
  
  public boolean contains(DelayedEntry entry) {
    Data key = (Data)entry.getKey();
    return this.index.containsKey(key);
  }
  
  public int size() { return this.deque.size(); }
  
  public void clear() {
    this.deque.clear();
    resetCountIndex();
  }
  
  public int drainTo(Collection<DelayedEntry> collection) {
    Preconditions.checkNotNull(collection, "collection can not be null");
    Iterator<DelayedEntry> iterator = this.deque.iterator();
    while (iterator.hasNext()) {
      DelayedEntry e = (DelayedEntry)iterator.next();
      collection.add(e);
      iterator.remove();
    } 
    resetCountIndex();
    return collection.size();
  }
  
  public List<DelayedEntry> asList() { return Collections.unmodifiableList(new ArrayList(this.deque)); }
  
  public void filter(IPredicate<DelayedEntry> predicate, Collection<DelayedEntry> collection) {
    Iterator<DelayedEntry> iterator = this.deque.iterator();
    while (iterator.hasNext()) {
      DelayedEntry e = (DelayedEntry)iterator.next();
      if (predicate.test(e))
        collection.add(e); 
    } 
  }
  
  private void addCountIndex(DelayedEntry entry) {
    Data key = (Data)entry.getKey();
    Map<Data, MutableInteger> index = this.index;
    MutableInteger count = (MutableInteger)index.get(key);
    if (count == null)
      count = new MutableInteger(); 
    count.value++;
    index.put(key, count);
  }
  
  private void addCountIndex(Collection<DelayedEntry> collection) {
    for (DelayedEntry entry : collection)
      addCountIndex(entry); 
  }
  
  private void decreaseCountIndex(DelayedEntry entry) {
    Data key = (Data)entry.getKey();
    Map<Data, MutableInteger> index = this.index;
    MutableInteger count = (MutableInteger)index.get(key);
    if (count == null)
      return; 
    count.value--;
    if (count.value == 0) {
      index.remove(key);
    } else {
      index.put(key, count);
    } 
  }
  
  private void resetCountIndex() { this.index.clear(); }
}
