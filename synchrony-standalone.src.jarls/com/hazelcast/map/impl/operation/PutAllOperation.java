package com.hazelcast.map.impl.operation;

import com.hazelcast.core.EntryEventType;
import com.hazelcast.map.impl.MapEntries;
import com.hazelcast.map.impl.record.Record;
import com.hazelcast.map.impl.record.RecordInfo;
import com.hazelcast.map.impl.record.Records;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.BackupAwareOperation;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.PartitionAwareOperation;
import com.hazelcast.spi.impl.MutatingOperation;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class PutAllOperation extends MapOperation implements PartitionAwareOperation, BackupAwareOperation, MutatingOperation {
  private MapEntries mapEntries;
  
  private boolean hasMapListener;
  
  private boolean hasWanReplication;
  
  private boolean hasBackups;
  
  private boolean hasInvalidation;
  
  private List<RecordInfo> backupRecordInfos;
  
  private List<Data> invalidationKeys;
  
  public PutAllOperation() {}
  
  public PutAllOperation(String name, MapEntries mapEntries) {
    super(name);
    this.mapEntries = mapEntries;
  }
  
  public void run() {
    this.hasMapListener = this.mapEventPublisher.hasEventListener(this.name);
    this.hasWanReplication = this.mapContainer.isWanReplicationEnabled();
    this.hasBackups = hasBackups();
    this.hasInvalidation = this.mapContainer.hasInvalidationListener();
    if (this.hasBackups)
      this.backupRecordInfos = new ArrayList(this.mapEntries.size()); 
    if (this.hasInvalidation)
      this.invalidationKeys = new ArrayList(this.mapEntries.size()); 
    for (int i = 0; i < this.mapEntries.size(); i++)
      put(this.mapEntries.getKey(i), this.mapEntries.getValue(i)); 
  }
  
  private boolean hasBackups() { return (this.mapContainer.getTotalBackupCount() > 0); }
  
  private void put(Data dataKey, Data dataValue) {
    Object oldValue = putToRecordStore(dataKey, dataValue);
    dataValue = getValueOrPostProcessedValue(dataKey, dataValue);
    this.mapServiceContext.interceptAfterPut(this.name, dataValue);
    if (this.hasMapListener) {
      EntryEventType eventType = (oldValue == null) ? EntryEventType.ADDED : EntryEventType.UPDATED;
      this.mapEventPublisher.publishEvent(getCallerAddress(), this.name, eventType, dataKey, oldValue, dataValue);
    } 
    if (this.hasWanReplication)
      publishWanUpdate(dataKey, dataValue); 
    if (this.hasBackups) {
      Record record = this.recordStore.getRecord(dataKey);
      RecordInfo replicationInfo = Records.buildRecordInfo(record);
      this.backupRecordInfos.add(replicationInfo);
    } 
    evict(dataKey);
    if (this.hasInvalidation)
      this.invalidationKeys.add(dataKey); 
  }
  
  private Object putToRecordStore(Data dataKey, Data dataValue) {
    if (this.hasMapListener)
      return this.recordStore.put(dataKey, dataValue, -1L, -1L); 
    this.recordStore.set(dataKey, dataValue, -1L, -1L);
    return null;
  }
  
  public void afterRun() {
    invalidateNearCache(this.invalidationKeys);
    super.afterRun();
  }
  
  private Data getValueOrPostProcessedValue(Data dataKey, Data dataValue) {
    if (!isPostProcessing(this.recordStore))
      return dataValue; 
    Record record = this.recordStore.getRecord(dataKey);
    return this.mapServiceContext.toData(record.getValue());
  }
  
  public Object getResponse() { return Boolean.valueOf(true); }
  
  public boolean shouldBackup() { return (this.hasBackups && !this.mapEntries.isEmpty()); }
  
  public final int getAsyncBackupCount() { return this.mapContainer.getAsyncBackupCount(); }
  
  public final int getSyncBackupCount() { return this.mapContainer.getBackupCount(); }
  
  public Operation getBackupOperation() { return new PutAllBackupOperation(this.name, this.mapEntries, this.backupRecordInfos, false); }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException {
    super.writeInternal(out);
    this.mapEntries.writeData(out);
  }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    super.readInternal(in);
    this.mapEntries = new MapEntries();
    this.mapEntries.readData(in);
  }
  
  public int getId() { return 21; }
}
