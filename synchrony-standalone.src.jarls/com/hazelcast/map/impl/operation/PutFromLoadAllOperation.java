package com.hazelcast.map.impl.operation;

import com.hazelcast.map.impl.record.Record;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.BackupAwareOperation;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.PartitionAwareOperation;
import com.hazelcast.spi.impl.MutatingOperation;
import com.hazelcast.util.CollectionUtil;
import com.hazelcast.util.Preconditions;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class PutFromLoadAllOperation extends MapOperation implements PartitionAwareOperation, MutatingOperation, BackupAwareOperation {
  private List<Data> keyValueSequence;
  
  private List<Data> invalidationKeys;
  
  public PutFromLoadAllOperation() { this.keyValueSequence = Collections.emptyList(); }
  
  public PutFromLoadAllOperation(String name, List<Data> keyValueSequence) {
    super(name);
    Preconditions.checkFalse(CollectionUtil.isEmpty(keyValueSequence), "key-value sequence cannot be empty or null");
    this.keyValueSequence = keyValueSequence;
  }
  
  public void run() {
    boolean hasInterceptor = this.mapServiceContext.hasInterceptor(this.name);
    List<Data> keyValueSequence = this.keyValueSequence;
    for (int i = 0; i < keyValueSequence.size(); i += 2) {
      Data key = (Data)keyValueSequence.get(i);
      Data dataValue = (Data)keyValueSequence.get(i + 1);
      Preconditions.checkNotNull(key, "Key loaded by a MapLoader cannot be null.");
      Object value = hasInterceptor ? this.mapServiceContext.toObject(dataValue) : dataValue;
      this.recordStore.putFromLoad(key, value, getCallerAddress());
      if (value == null || this.recordStore.existInMemory(key)) {
        if (value != null)
          callAfterPutInterceptors(value); 
        if (isPostProcessing(this.recordStore)) {
          Record record = this.recordStore.getRecord(key);
          Preconditions.checkNotNull(record, "Value loaded by a MapLoader cannot be null.");
          value = record.getValue();
        } 
        publishLoadAsWanUpdate(key, value);
        addInvalidation(key);
      } 
    } 
  }
  
  private void addInvalidation(Data key) {
    if (!this.mapContainer.hasInvalidationListener())
      return; 
    if (this.invalidationKeys == null)
      this.invalidationKeys = new ArrayList(this.keyValueSequence.size() / 2); 
    this.invalidationKeys.add(key);
  }
  
  private void callAfterPutInterceptors(Object value) { this.mapService.getMapServiceContext().interceptAfterPut(this.name, value); }
  
  public void afterRun() {
    invalidateNearCache(this.invalidationKeys);
    evict(null);
    super.afterRun();
  }
  
  public Object getResponse() { return Boolean.valueOf(true); }
  
  public boolean shouldBackup() { return !this.keyValueSequence.isEmpty(); }
  
  public final int getAsyncBackupCount() { return this.mapContainer.getAsyncBackupCount(); }
  
  public final int getSyncBackupCount() { return this.mapContainer.getBackupCount(); }
  
  public Operation getBackupOperation() { return new PutFromLoadAllBackupOperation(this.name, this.keyValueSequence); }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException {
    super.writeInternal(out);
    List<Data> keyValueSequence = this.keyValueSequence;
    int size = keyValueSequence.size();
    out.writeInt(size);
    for (Data data : keyValueSequence)
      out.writeData(data); 
  }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    super.readInternal(in);
    int size = in.readInt();
    if (size < 1) {
      this.keyValueSequence = Collections.emptyList();
    } else {
      List<Data> tmpKeyValueSequence = new ArrayList<Data>(size);
      for (int i = 0; i < size; i++) {
        Data data = in.readData();
        tmpKeyValueSequence.add(data);
      } 
      this.keyValueSequence = tmpKeyValueSequence;
    } 
  }
  
  public int getId() { return 57; }
}
