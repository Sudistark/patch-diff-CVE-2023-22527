package com.hazelcast.map.impl.operation;

import com.hazelcast.core.EntryEventType;
import com.hazelcast.map.impl.MapEntries;
import com.hazelcast.map.impl.record.Record;
import com.hazelcast.map.impl.record.RecordInfo;
import com.hazelcast.map.impl.record.Records;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.BackupAwareOperation;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.PartitionAwareOperation;
import com.hazelcast.spi.merge.SplitBrainMergePolicy;
import com.hazelcast.spi.merge.SplitBrainMergeTypes;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class MergeOperation extends MapOperation implements PartitionAwareOperation, BackupAwareOperation {
  private List<SplitBrainMergeTypes.MapMergeTypes> mergingEntries;
  
  private SplitBrainMergePolicy<Data, SplitBrainMergeTypes.MapMergeTypes> mergePolicy;
  
  private boolean hasMapListener;
  
  private boolean hasWanReplication;
  
  private boolean hasBackups;
  
  private boolean hasInvalidation;
  
  private MapEntries mapEntries;
  
  private List<RecordInfo> backupRecordInfos;
  
  private List<Data> invalidationKeys;
  
  private boolean hasMergedValues;
  
  public MergeOperation() {}
  
  MergeOperation(String name, List<SplitBrainMergeTypes.MapMergeTypes> mergingEntries, SplitBrainMergePolicy<Data, SplitBrainMergeTypes.MapMergeTypes> mergePolicy, boolean disableWanReplicationEvent) {
    super(name);
    this.mergingEntries = mergingEntries;
    this.mergePolicy = mergePolicy;
    this.disableWanReplicationEvent = disableWanReplicationEvent;
  }
  
  public void run() {
    this.hasMapListener = this.mapEventPublisher.hasEventListener(this.name);
    this.hasWanReplication = (this.mapContainer.isWanReplicationEnabled() && !this.disableWanReplicationEvent);
    this.hasBackups = (this.mapContainer.getTotalBackupCount() > 0);
    this.hasInvalidation = this.mapContainer.hasInvalidationListener();
    if (this.hasBackups) {
      this.mapEntries = new MapEntries(this.mergingEntries.size());
      this.backupRecordInfos = new ArrayList(this.mergingEntries.size());
    } 
    if (this.hasInvalidation)
      this.invalidationKeys = new ArrayList(this.mergingEntries.size()); 
    for (SplitBrainMergeTypes.MapMergeTypes mergingEntry : this.mergingEntries)
      merge(mergingEntry); 
  }
  
  private void merge(SplitBrainMergeTypes.MapMergeTypes mergingEntry) {
    Data dataKey = (Data)mergingEntry.getKey();
    Data oldValue = this.hasMapListener ? getValue(dataKey) : null;
    if (this.recordStore.merge(mergingEntry, this.mergePolicy, getCallerProvenance())) {
      this.hasMergedValues = true;
      Data dataValue = getValueOrPostProcessedValue(dataKey, getValue(dataKey));
      this.mapServiceContext.interceptAfterPut(this.name, dataValue);
      if (this.hasMapListener)
        this.mapEventPublisher.publishEvent(getCallerAddress(), this.name, EntryEventType.MERGED, dataKey, oldValue, dataValue); 
      if (this.hasWanReplication)
        publishWanUpdate(dataKey, dataValue); 
      if (this.hasBackups) {
        this.mapEntries.add(dataKey, dataValue);
        this.backupRecordInfos.add(Records.buildRecordInfo(this.recordStore.getRecord(dataKey)));
      } 
      evict(dataKey);
      if (this.hasInvalidation)
        this.invalidationKeys.add(dataKey); 
    } 
  }
  
  private Data getValueOrPostProcessedValue(Data dataKey, Data dataValue) {
    if (!isPostProcessing(this.recordStore))
      return dataValue; 
    Record record = this.recordStore.getRecord(dataKey);
    return this.mapServiceContext.toData(record.getValue());
  }
  
  private Data getValue(Data dataKey) {
    Record record = this.recordStore.getRecord(dataKey);
    if (record != null)
      return this.mapServiceContext.toData(record.getValue()); 
    return null;
  }
  
  public Object getResponse() { return Boolean.valueOf(this.hasMergedValues); }
  
  public boolean shouldBackup() { return (this.hasBackups && !this.backupRecordInfos.isEmpty()); }
  
  public int getSyncBackupCount() { return this.mapContainer.getBackupCount(); }
  
  public int getAsyncBackupCount() { return this.mapContainer.getAsyncBackupCount(); }
  
  public void afterRun() {
    invalidateNearCache(this.invalidationKeys);
    super.afterRun();
  }
  
  public Operation getBackupOperation() { return new PutAllBackupOperation(this.name, this.mapEntries, this.backupRecordInfos, this.disableWanReplicationEvent); }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException {
    super.writeInternal(out);
    out.writeInt(this.mergingEntries.size());
    for (SplitBrainMergeTypes.MapMergeTypes mergingEntry : this.mergingEntries)
      out.writeObject(mergingEntry); 
    out.writeObject(this.mergePolicy);
    out.writeBoolean(this.disableWanReplicationEvent);
  }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    super.readInternal(in);
    int size = in.readInt();
    this.mergingEntries = new ArrayList(size);
    for (int i = 0; i < size; i++) {
      SplitBrainMergeTypes.MapMergeTypes mergingEntry = (SplitBrainMergeTypes.MapMergeTypes)in.readObject();
      this.mergingEntries.add(mergingEntry);
    } 
    this.mergePolicy = (SplitBrainMergePolicy)in.readObject();
    this.disableWanReplicationEvent = in.readBoolean();
  }
  
  public int getId() { return 147; }
}
