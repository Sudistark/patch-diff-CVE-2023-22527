package com.hazelcast.map.impl;

import com.hazelcast.map.impl.record.Record;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.util.JVMUtil;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

class BinaryMapEntryCostEstimator extends Object implements EntryCostEstimator<Data, Record> {
  private static final int HASH_ENTRY_HASH_COST_IN_BYTES = JVMUtil.REFERENCE_COST_IN_BYTES;
  
  private static final int HASH_ENTRY_VALUE_REF_COST_IN_BYTES = JVMUtil.REFERENCE_COST_IN_BYTES;
  
  private static final int HASH_ENTRY_KEY_REF_COST_IN_BYTES = JVMUtil.REFERENCE_COST_IN_BYTES;
  
  private static final int HASH_ENTRY_NEXT_REF_COST_IN_BYTES = JVMUtil.REFERENCE_COST_IN_BYTES;
  
  private static final int HASH_ENTRY_COST_IN_BYTES = HASH_ENTRY_HASH_COST_IN_BYTES + HASH_ENTRY_KEY_REF_COST_IN_BYTES + HASH_ENTRY_VALUE_REF_COST_IN_BYTES + HASH_ENTRY_NEXT_REF_COST_IN_BYTES;
  
  public long getEstimate() { return this.estimate; }
  
  @SuppressFBWarnings(value = {"VO_VOLATILE_INCREMENT"}, justification = "We have the guarantee that only a single partition thread at any given time can change the volatile field, but multiple threads can read it.")
  public void adjustEstimateBy(long adjustment) { this.estimate += adjustment; }
  
  public void reset() { this.estimate = 0L; }
  
  public long calculateValueCost(Record value) { return value.getCost(); }
  
  public long calculateEntryCost(Data key, Record value) {
    totalMapEntryCost = 0L;
    totalMapEntryCost += HASH_ENTRY_COST_IN_BYTES;
    totalMapEntryCost += key.getHeapCost();
    return value.getCost();
  }
}
