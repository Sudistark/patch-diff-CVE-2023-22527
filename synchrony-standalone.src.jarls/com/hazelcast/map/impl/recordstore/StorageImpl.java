package com.hazelcast.map.impl.recordstore;

import com.hazelcast.config.InMemoryFormat;
import com.hazelcast.core.EntryView;
import com.hazelcast.map.impl.EntryCostEstimator;
import com.hazelcast.map.impl.OwnedEntryCostEstimatorFactory;
import com.hazelcast.map.impl.iterator.MapEntriesWithCursor;
import com.hazelcast.map.impl.iterator.MapKeysWithCursor;
import com.hazelcast.map.impl.record.Record;
import com.hazelcast.map.impl.record.RecordFactory;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.serialization.SerializationService;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

public class StorageImpl<R extends Record> extends Object implements Storage<Data, R> {
  private final RecordFactory<R> recordFactory;
  
  private final StorageSCHM<R> records;
  
  private EntryCostEstimator<Data, Record> entryCostEstimator;
  
  StorageImpl(RecordFactory<R> recordFactory, InMemoryFormat inMemoryFormat, SerializationService serializationService) {
    this.recordFactory = recordFactory;
    this.entryCostEstimator = OwnedEntryCostEstimatorFactory.createMapSizeEstimator(inMemoryFormat);
    this.records = new StorageSCHM(serializationService);
  }
  
  public void clear(boolean isDuringShutdown) {
    this.records.clear();
    this.entryCostEstimator.reset();
  }
  
  public Collection<R> values() { return this.records.values(); }
  
  public Iterator<R> mutationTolerantIterator() { return this.records.values().iterator(); }
  
  public void put(Data key, R record) {
    record.setKey(key);
    R previousRecord = (R)(Record)this.records.put(key, record);
    if (previousRecord == null) {
      updateCostEstimate(this.entryCostEstimator.calculateEntryCost(key, record));
    } else {
      updateCostEstimate(-this.entryCostEstimator.calculateValueCost(previousRecord));
      updateCostEstimate(this.entryCostEstimator.calculateValueCost(record));
    } 
  }
  
  public void updateRecordValue(Data key, R record, Object value) {
    updateCostEstimate(-this.entryCostEstimator.calculateValueCost(record));
    this.recordFactory.setValue(record, value);
    updateCostEstimate(this.entryCostEstimator.calculateValueCost(record));
  }
  
  public R get(Data key) { return (R)(Record)this.records.get(key); }
  
  public R getIfSameKey(Data key) { throw new UnsupportedOperationException("StorageImpl#getIfSameKey"); }
  
  public int size() { return this.records.size(); }
  
  public boolean isEmpty() { return this.records.isEmpty(); }
  
  public void destroy(boolean isDuringShutdown) { clear(isDuringShutdown); }
  
  public EntryCostEstimator getEntryCostEstimator() { return this.entryCostEstimator; }
  
  public boolean containsKey(Data key) { return this.records.containsKey(key); }
  
  public void removeRecord(R record) {
    if (record == null)
      return; 
    Data key = record.getKey();
    this.records.remove(key);
    updateCostEstimate(-this.entryCostEstimator.calculateEntryCost(key, record));
  }
  
  protected void updateCostEstimate(long entrySize) { this.entryCostEstimator.adjustEstimateBy(entrySize); }
  
  public void setEntryCostEstimator(EntryCostEstimator entryCostEstimator) { this.entryCostEstimator = entryCostEstimator; }
  
  public void disposeDeferredBlocks() {}
  
  public Iterable getRandomSamples(int sampleCount) { return this.records.getRandomSamples(sampleCount); }
  
  public MapKeysWithCursor fetchKeys(int tableIndex, int size) {
    List<Data> keys = new ArrayList<Data>(size);
    int newTableIndex = this.records.fetchKeys(tableIndex, size, keys);
    return new MapKeysWithCursor(keys, newTableIndex);
  }
  
  public MapEntriesWithCursor fetchEntries(int tableIndex, int size, SerializationService serializationService) {
    List<Map.Entry<Data, R>> entries = new ArrayList<Map.Entry<Data, R>>(size);
    int newTableIndex = this.records.fetchEntries(tableIndex, size, entries);
    List<Map.Entry<Data, Data>> entriesData = new ArrayList<Map.Entry<Data, Data>>(entries.size());
    for (Map.Entry<Data, R> entry : entries) {
      R record = (R)(Record)entry.getValue();
      Data dataValue = serializationService.toData(record.getValue());
      entriesData.add(new AbstractMap.SimpleEntry(entry.getKey(), dataValue));
    } 
    return new MapEntriesWithCursor(entriesData, newTableIndex);
  }
  
  public Record extractRecordFromLazy(EntryView entryView) { return ((LazyEntryViewFromRecord)entryView).getRecord(); }
}
