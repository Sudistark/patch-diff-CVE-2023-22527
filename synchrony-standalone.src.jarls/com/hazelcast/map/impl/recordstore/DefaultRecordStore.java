package com.hazelcast.map.impl.recordstore;

import com.hazelcast.concurrent.lock.LockService;
import com.hazelcast.config.InMemoryFormat;
import com.hazelcast.config.NativeMemoryConfig;
import com.hazelcast.core.EntryEventType;
import com.hazelcast.core.EntryView;
import com.hazelcast.internal.cluster.ClusterService;
import com.hazelcast.internal.cluster.Versions;
import com.hazelcast.logging.ILogger;
import com.hazelcast.map.impl.EntryViews;
import com.hazelcast.map.impl.ExpirationTimeSetter;
import com.hazelcast.map.impl.MapContainer;
import com.hazelcast.map.impl.MapEntries;
import com.hazelcast.map.impl.MapKeyLoader;
import com.hazelcast.map.impl.MapService;
import com.hazelcast.map.impl.event.EntryEventData;
import com.hazelcast.map.impl.iterator.MapEntriesWithCursor;
import com.hazelcast.map.impl.iterator.MapKeysWithCursor;
import com.hazelcast.map.impl.mapstore.MapDataStore;
import com.hazelcast.map.impl.mapstore.MapDataStores;
import com.hazelcast.map.impl.mapstore.writebehind.WriteBehindQueue;
import com.hazelcast.map.impl.mapstore.writebehind.WriteBehindStore;
import com.hazelcast.map.impl.mapstore.writebehind.entry.DelayedEntry;
import com.hazelcast.map.impl.querycache.QueryCacheContext;
import com.hazelcast.map.impl.querycache.publisher.MapPublisherRegistry;
import com.hazelcast.map.impl.querycache.publisher.PublisherContext;
import com.hazelcast.map.impl.querycache.publisher.PublisherRegistry;
import com.hazelcast.map.impl.record.Record;
import com.hazelcast.map.impl.record.Records;
import com.hazelcast.map.merge.MapMergePolicy;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.query.impl.Index;
import com.hazelcast.query.impl.Indexes;
import com.hazelcast.query.impl.InternalIndex;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.ObjectNamespace;
import com.hazelcast.spi.exception.RetryableHazelcastException;
import com.hazelcast.spi.impl.merge.MergingValueFactory;
import com.hazelcast.spi.merge.SplitBrainMergePolicy;
import com.hazelcast.spi.merge.SplitBrainMergeTypes;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.util.Clock;
import com.hazelcast.util.CollectionUtil;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.FutureUtil;
import com.hazelcast.util.MapUtil;
import com.hazelcast.wan.impl.CallerProvenance;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Future;
import javax.annotation.Nonnull;

public class DefaultRecordStore extends AbstractEvictableRecordStore {
  protected final ILogger logger;
  
  protected final RecordStoreLoader recordStoreLoader;
  
  protected final MapKeyLoader keyLoader;
  
  protected final Collection<Future> loadingFutures = new ConcurrentLinkedQueue();
  
  private boolean loadedOnCreate;
  
  private boolean loadedOnPreMigration;
  
  private final IPartitionService partitionService;
  
  public DefaultRecordStore(MapContainer mapContainer, int partitionId, MapKeyLoader keyLoader, ILogger logger) {
    super(mapContainer, partitionId);
    this.logger = logger;
    this.keyLoader = keyLoader;
    this.recordStoreLoader = createRecordStoreLoader(this.mapStoreContext);
    this.partitionService = this.mapServiceContext.getNodeEngine().getPartitionService();
  }
  
  public MapDataStore<Data, Object> getMapDataStore() { return this.mapDataStore; }
  
  public long softFlush() {
    updateStoreStats();
    return this.mapDataStore.softFlush();
  }
  
  private void flush(Collection<Record> recordsToBeFlushed, boolean backup) {
    for (Record record : recordsToBeFlushed)
      this.mapDataStore.flush(record.getKey(), record.getValue(), backup); 
  }
  
  public Record getRecord(Data key) { return (Record)this.storage.get(key); }
  
  public void putRecord(Data key, Record record) {
    markRecordStoreExpirable(record.getTtl(), record.getMaxIdle());
    this.storage.put(key, record);
    this.mutationObserver.onReplicationPutRecord(key, record);
    updateStatsOnPut(record.getHits());
  }
  
  public Record putBackup(Data key, Object value, CallerProvenance provenance) { return putBackup(key, value, -1L, -1L, false, provenance); }
  
  public Record putBackup(Data key, Object value, long ttl, long maxIdle, boolean putTransient, CallerProvenance provenance) {
    long now = getNow();
    markRecordStoreExpirable(ttl, maxIdle);
    Record record = getRecordOrNull(key, now, true);
    if (record == null) {
      record = createRecord(key, value, ttl, maxIdle, now);
      this.storage.put(key, record);
      this.mutationObserver.onPutRecord(key, record);
    } else {
      updateRecord(key, record, value, now, true);
    } 
    if (persistenceEnabledFor(provenance))
      if (putTransient) {
        this.mapDataStore.addTransient(key, now);
      } else {
        this.mapDataStore.addBackup(key, value, now);
      }  
    return record;
  }
  
  public Iterator<Record> iterator() { return new AbstractEvictableRecordStore.ReadOnlyRecordIterator(this, this.storage.values()); }
  
  public Iterator<Record> iterator(long now, boolean backup) { return new AbstractEvictableRecordStore.ReadOnlyRecordIterator(this, this.storage.values(), now, backup); }
  
  public MapKeysWithCursor fetchKeys(int tableIndex, int size) { return this.storage.fetchKeys(tableIndex, size); }
  
  public MapEntriesWithCursor fetchEntries(int tableIndex, int size) { return this.storage.fetchEntries(tableIndex, size, this.serializationService); }
  
  public Iterator<Record> loadAwareIterator(long now, boolean backup) {
    checkIfLoaded();
    return iterator(now, backup);
  }
  
  public int size() { return this.storage.size(); }
  
  public boolean isEmpty() {
    checkIfLoaded();
    return this.storage.isEmpty();
  }
  
  public boolean containsValue(Object value) {
    checkIfLoaded();
    long now = getNow();
    Collection<Record> records = this.storage.values();
    if (!records.isEmpty())
      value = (this.inMemoryFormat == InMemoryFormat.OBJECT) ? this.serializationService.toObject(value) : this.serializationService.toData(value); 
    for (Record record : records) {
      if (getOrNullIfExpired(record, now, false) == null)
        continue; 
      if (this.valueComparator.isEqual(value, record.getValue(), this.serializationService))
        return true; 
    } 
    return false;
  }
  
  public boolean txnLock(Data key, String caller, long threadId, long referenceId, long ttl, boolean blockReads) {
    checkIfLoaded();
    return (this.lockStore != null && this.lockStore.txnLock(key, caller, threadId, referenceId, ttl, blockReads));
  }
  
  public boolean extendLock(Data key, String caller, long threadId, long ttl) {
    checkIfLoaded();
    return (this.lockStore != null && this.lockStore.extendLeaseTime(key, caller, threadId, ttl));
  }
  
  public boolean localLock(Data key, String caller, long threadId, long referenceId, long ttl) {
    checkIfLoaded();
    return (this.lockStore != null && this.lockStore.localLock(key, caller, threadId, referenceId, ttl));
  }
  
  public boolean unlock(Data key, String caller, long threadId, long referenceId) {
    checkIfLoaded();
    return (this.lockStore != null && this.lockStore.unlock(key, caller, threadId, referenceId));
  }
  
  public boolean lock(Data key, String caller, long threadId, long referenceId, long ttl) {
    checkIfLoaded();
    return (this.lockStore != null && this.lockStore.lock(key, caller, threadId, referenceId, ttl));
  }
  
  public boolean forceUnlock(Data dataKey) { return (this.lockStore != null && this.lockStore.forceUnlock(dataKey)); }
  
  public boolean isLocked(Data dataKey) { return (this.lockStore != null && this.lockStore.isLocked(dataKey)); }
  
  public boolean isTransactionallyLocked(Data key) { return (this.lockStore != null && this.lockStore.shouldBlockReads(key)); }
  
  public boolean canAcquireLock(Data key, String caller, long threadId) { return (this.lockStore == null || this.lockStore.canAcquireLock(key, caller, threadId)); }
  
  public boolean isLockedBy(Data key, String caller, long threadId) { return (this.lockStore != null && this.lockStore.isLockedBy(key, caller, threadId)); }
  
  public String getLockOwnerInfo(Data key) { return (this.lockStore != null) ? this.lockStore.getOwnerInfo(key) : null; }
  
  public Record loadRecordOrNull(Data key, boolean backup, Address callerAddress) {
    Record record = null;
    Object value = this.mapDataStore.load(key);
    if (value != null) {
      record = createRecord(key, value, -1L, -1L, getNow());
      this.storage.put(key, record);
      this.mutationObserver.onLoadRecord(key, record);
      if (!backup) {
        saveIndex(record, null);
        this.mapEventPublisher.publishEvent(callerAddress, this.name, EntryEventType.LOADED, key, null, value, null);
      } 
      evictEntries(key);
    } 
    if (!backup && record != null && hasQueryCache())
      addEventToQueryCache(record); 
    return record;
  }
  
  protected List<Data> getKeysFromRecords(Collection<Record> clearableRecords) {
    List<Data> keys = new ArrayList<Data>(clearableRecords.size());
    for (Record clearableRecord : clearableRecords)
      keys.add(clearableRecord.getKey()); 
    return keys;
  }
  
  protected int removeRecords(Collection<Record> recordsToRemove) { return removeOrEvictRecords(recordsToRemove, false); }
  
  protected int evictRecords(Collection<Record> recordsToEvict) { return removeOrEvictRecords(recordsToEvict, true); }
  
  private int removeOrEvictRecords(Collection<Record> recordsToRemove, boolean eviction) {
    if (CollectionUtil.isEmpty(recordsToRemove))
      return 0; 
    int removalSize = recordsToRemove.size();
    Iterator<Record> iterator = recordsToRemove.iterator();
    while (iterator.hasNext()) {
      Record record = (Record)iterator.next();
      if (eviction) {
        this.mutationObserver.onEvictRecord(record.getKey(), record);
      } else {
        this.mutationObserver.onRemoveRecord(record.getKey(), record);
      } 
      this.storage.removeRecord(record);
      iterator.remove();
    } 
    return removalSize;
  }
  
  protected Collection<Record> getNotLockedRecords() {
    Set<Data> lockedKeySet = (this.lockStore == null) ? null : this.lockStore.getLockedKeys();
    if (CollectionUtil.isEmpty(lockedKeySet))
      return this.storage.values(); 
    int notLockedKeyCount = this.storage.size() - lockedKeySet.size();
    if (notLockedKeyCount <= 0)
      return Collections.emptyList(); 
    List<Record> notLockedRecords = new ArrayList<Record>(notLockedKeyCount);
    Collection<Record> records = this.storage.values();
    for (Record record : records) {
      if (!lockedKeySet.contains(record.getKey()))
        notLockedRecords.add(record); 
    } 
    return notLockedRecords;
  }
  
  public Object evict(Data key, boolean backup) {
    Record record = (Record)this.storage.get(key);
    Object value = null;
    if (record != null) {
      value = record.getValue();
      this.mapDataStore.flush(key, value, backup);
      removeIndex(record);
      this.mutationObserver.onEvictRecord(key, record);
      this.storage.removeRecord(record);
      if (!backup)
        this.mapServiceContext.interceptRemove(this.name, value); 
    } 
    return value;
  }
  
  public int evictAll(boolean backup) {
    checkIfLoaded();
    Collection<Record> evictableRecords = getNotLockedRecords();
    flush(evictableRecords, backup);
    removeIndex(evictableRecords);
    return evictRecords(evictableRecords);
  }
  
  public void removeBackup(Data key, CallerProvenance provenance) {
    long now = getNow();
    Record record = getRecordOrNull(key, now, true);
    if (record == null)
      return; 
    this.mutationObserver.onRemoveRecord(key, record);
    this.storage.removeRecord(record);
    if (persistenceEnabledFor(provenance))
      this.mapDataStore.removeBackup(key, now); 
  }
  
  public boolean delete(Data key, CallerProvenance provenance) {
    checkIfLoaded();
    long now = getNow();
    Record record = getRecordOrNull(key, now, false);
    if (record == null) {
      if (persistenceEnabledFor(provenance))
        this.mapDataStore.remove(key, now); 
    } else {
      return (removeRecord(key, record, now, provenance) != null);
    } 
    return false;
  }
  
  public Object remove(Data key, CallerProvenance provenance) {
    Object oldValue;
    checkIfLoaded();
    long now = getNow();
    Record record = getRecordOrNull(key, now, false);
    if (record == null) {
      oldValue = this.mapDataStore.load(key);
      if (oldValue != null && persistenceEnabledFor(provenance))
        this.mapDataStore.remove(key, now); 
    } else {
      oldValue = removeRecord(key, record, now, provenance);
    } 
    return oldValue;
  }
  
  public boolean remove(Data key, Object testValue) {
    Object oldValue;
    checkIfLoaded();
    long now = getNow();
    Record record = getRecordOrNull(key, now, false);
    boolean removed = false;
    if (record == null) {
      oldValue = this.mapDataStore.load(key);
      if (oldValue == null)
        return false; 
    } else {
      oldValue = record.getValue();
    } 
    if (this.valueComparator.isEqual(testValue, oldValue, this.serializationService)) {
      this.mapServiceContext.interceptRemove(this.name, oldValue);
      this.mapDataStore.remove(key, now);
      if (record != null) {
        removeIndex(record);
        onStore(record);
        this.mutationObserver.onRemoveRecord(key, record);
        this.storage.removeRecord(record);
      } 
      removed = true;
    } 
    return removed;
  }
  
  public Object get(Data key, boolean backup, Address callerAddress, boolean touch) {
    checkIfLoaded();
    long now = getNow();
    Record record = getRecordOrNull(key, now, backup);
    if (record == null) {
      record = loadRecordOrNull(key, backup, callerAddress);
    } else if (touch) {
      accessRecord(record, now);
    } 
    value = (record == null) ? null : record.getValue();
    return this.mapServiceContext.interceptGet(this.name, value);
  }
  
  public Data readBackupData(Data key) {
    Record record = getRecord(key);
    if (record == null)
      return null; 
    if (this.partitionService.isPartitionOwner(this.partitionId))
      record.setLastAccessTime(Clock.currentTimeMillis()); 
    Object value = record.getValue();
    this.mapServiceContext.interceptAfterGet(this.name, value);
    return this.mapServiceContext.toData(value);
  }
  
  public MapEntries getAll(Set<Data> keys, Address callerAddress) {
    checkIfLoaded();
    long now = getNow();
    MapEntries mapEntries = new MapEntries(keys.size());
    Iterator<Data> iterator = keys.iterator();
    while (iterator.hasNext()) {
      Data key = (Data)iterator.next();
      Record record = getRecordOrNull(key, now, false);
      if (record != null) {
        addMapEntrySet(key, record.getValue(), mapEntries);
        accessRecord(record, now);
        iterator.remove();
      } 
    } 
    Map loadedEntries = loadEntries(keys, callerAddress);
    addMapEntrySet(loadedEntries, mapEntries);
    return mapEntries;
  }
  
  protected Map<Data, Object> loadEntries(Set<Data> keys, Address callerAddress) {
    Map loadedEntries = this.mapDataStore.loadAll(keys);
    if (loadedEntries == null || loadedEntries.isEmpty())
      return Collections.emptyMap(); 
    Map<Data, Object> resultMap = MapUtil.createHashMap(loadedEntries.size());
    Set entrySet = loadedEntries.entrySet();
    for (Object object : entrySet) {
      Map.Entry entry = (Map.Entry)object;
      Data key = toData(entry.getKey());
      Object value = entry.getValue();
      resultMap.put(key, value);
      putFromLoad(key, value, callerAddress);
    } 
    if (hasQueryCache())
      for (Data key : resultMap.keySet()) {
        Record record = (Record)this.storage.get(key);
        addEventToQueryCache(record);
      }  
    return resultMap;
  }
  
  protected void addMapEntrySet(Object key, Object value, MapEntries mapEntries) {
    if (key == null || value == null)
      return; 
    value = this.mapServiceContext.interceptGet(this.name, value);
    Data dataKey = this.mapServiceContext.toData(key);
    Data dataValue = this.mapServiceContext.toData(value);
    mapEntries.add(dataKey, dataValue);
  }
  
  protected void addMapEntrySet(Map<Object, Object> entries, MapEntries mapEntries) {
    for (Map.Entry<Object, Object> entry : entries.entrySet())
      addMapEntrySet(entry.getKey(), entry.getValue(), mapEntries); 
  }
  
  public boolean existInMemory(Data key) { return this.storage.containsKey(key); }
  
  public boolean containsKey(Data key, Address callerAddress) {
    checkIfLoaded();
    long now = getNow();
    Record record = getRecordOrNull(key, now, false);
    if (record == null)
      record = loadRecordOrNull(key, false, callerAddress); 
    boolean contains = (record != null);
    if (contains)
      accessRecord(record, now); 
    return contains;
  }
  
  public boolean hasQueryCache() {
    QueryCacheContext queryCacheContext = this.mapServiceContext.getQueryCacheContext();
    PublisherContext publisherContext = queryCacheContext.getPublisherContext();
    MapPublisherRegistry mapPublisherRegistry = publisherContext.getMapPublisherRegistry();
    PublisherRegistry publisherRegistry = mapPublisherRegistry.getOrNull(this.name);
    return (publisherRegistry != null);
  }
  
  private void addEventToQueryCache(Record record) {
    EntryEventData eventData = new EntryEventData(this.thisAddress.toString(), this.name, this.thisAddress, record.getKey(), this.mapServiceContext.toData(record.getValue()), null, null, EntryEventType.ADDED.getType());
    this.mapEventPublisher.addEventToQueryCache(eventData);
  }
  
  public boolean setTtl(Data key, long ttl) {
    if (this.mapServiceContext.getNodeEngine().getClusterService().getClusterVersion().isLessThan(Versions.V3_11))
      throw new UnsupportedOperationException("Modifying TTL is available when cluster version is 3.11 or higher"); 
    long now = getNow();
    Record record = getRecordOrNull(key, now, false);
    if (record == null)
      return false; 
    markRecordStoreExpirable(ttl, -1L);
    ExpirationTimeSetter.setExpirationTimes(ttl, -1L, record, this.mapContainer.getMapConfig(), true);
    return true;
  }
  
  public Object set(Data dataKey, Object value, long ttl, long maxIdle) { return putInternal(dataKey, value, ttl, maxIdle, false, true); }
  
  public Object put(Data key, Object value, long ttl, long maxIdle) { return putInternal(key, value, ttl, maxIdle, true, true); }
  
  protected Object putInternal(Data key, Object value, long ttl, long maxIdle, boolean loadFromStore, boolean countAsAccess) {
    checkIfLoaded();
    long now = getNow();
    markRecordStoreExpirable(ttl, maxIdle);
    Record record = getRecordOrNull(key, now, false);
    Object oldValue = (record == null) ? (loadFromStore ? this.mapDataStore.load(key) : null) : record.getValue();
    value = this.mapServiceContext.interceptPut(this.name, oldValue, value);
    value = this.mapDataStore.add(key, value, now);
    onStore(record);
    if (record == null) {
      record = createRecord(key, value, ttl, maxIdle, now);
      this.storage.put(key, record);
      this.mutationObserver.onPutRecord(key, record);
    } else {
      updateRecord(key, record, value, now, countAsAccess);
      ExpirationTimeSetter.setExpirationTimes(ttl, maxIdle, record, this.mapContainer.getMapConfig(), false);
    } 
    saveIndex(record, oldValue);
    return oldValue;
  }
  
  public boolean merge(SplitBrainMergeTypes.MapMergeTypes mergingEntry, SplitBrainMergePolicy<Data, SplitBrainMergeTypes.MapMergeTypes> mergePolicy) { return merge(mergingEntry, mergePolicy, CallerProvenance.NOT_WAN); }
  
  public boolean merge(SplitBrainMergeTypes.MapMergeTypes mergingEntry, SplitBrainMergePolicy<Data, SplitBrainMergeTypes.MapMergeTypes> mergePolicy, CallerProvenance provenance) {
    Object newValue;
    checkIfLoaded();
    long now = getNow();
    this.serializationService.getManagedContext().initialize(mergingEntry);
    this.serializationService.getManagedContext().initialize(mergePolicy);
    Data key = (Data)mergingEntry.getKey();
    Record record = getRecordOrNull(key, now, false);
    Object oldValue = null;
    if (record == null) {
      newValue = mergePolicy.merge(mergingEntry, null);
      if (newValue == null)
        return false; 
      newValue = persistenceEnabledFor(provenance) ? this.mapDataStore.add(key, newValue, now) : newValue;
      record = createRecord(key, newValue, -1L, -1L, now);
      mergeRecordExpiration(record, mergingEntry);
      this.storage.put(key, record);
      this.mutationObserver.onPutRecord(key, record);
    } else {
      oldValue = record.getValue();
      SplitBrainMergeTypes.MapMergeTypes existingEntry = MergingValueFactory.createMergingEntry(this.serializationService, record);
      newValue = mergePolicy.merge(mergingEntry, existingEntry);
      if (newValue == null) {
        removeIndex(record);
        if (persistenceEnabledFor(provenance))
          this.mapDataStore.remove(key, now); 
        onStore(record);
        this.mutationObserver.onRemoveRecord(key, record);
        this.storage.removeRecord(record);
        return true;
      } 
      if (this.valueComparator.isEqual(newValue, oldValue, this.serializationService)) {
        mergeRecordExpiration(record, mergingEntry);
        return true;
      } 
      newValue = persistenceEnabledFor(provenance) ? this.mapDataStore.add(key, newValue, now) : newValue;
      onStore(record);
      this.mutationObserver.onUpdateRecord(key, record, newValue);
      this.storage.updateRecordValue(key, record, newValue);
    } 
    saveIndex(record, oldValue);
    return (newValue != null);
  }
  
  public boolean merge(Data key, EntryView mergingEntry, MapMergePolicy mergePolicy) { return merge(key, mergingEntry, mergePolicy, CallerProvenance.NOT_WAN); }
  
  public boolean merge(Data key, EntryView mergingEntry, MapMergePolicy mergePolicy, CallerProvenance provenance) {
    Object newValue;
    checkIfLoaded();
    long now = getNow();
    Record record = getRecordOrNull(key, now, false);
    mergingEntry = EntryViews.toLazyEntryView(mergingEntry, this.serializationService, mergePolicy);
    Object oldValue = null;
    if (record == null) {
      Object notExistingKey = this.mapServiceContext.toObject(key);
      EntryView nullEntryView = EntryViews.createNullEntryView(notExistingKey);
      newValue = mergePolicy.merge(this.name, mergingEntry, nullEntryView);
      if (newValue == null)
        return false; 
      newValue = persistenceEnabledFor(provenance) ? this.mapDataStore.add(key, newValue, now) : newValue;
      record = createRecord(key, newValue, -1L, -1L, now);
      mergeRecordExpiration(record, mergingEntry);
      this.storage.put(key, record);
      this.mutationObserver.onPutRecord(key, record);
    } else {
      oldValue = record.getValue();
      EntryView existingEntry = EntryViews.createLazyEntryView(record.getKey(), record.getValue(), record, this.serializationService, mergePolicy);
      newValue = mergePolicy.merge(this.name, mergingEntry, existingEntry);
      if (newValue == null) {
        removeIndex(record);
        if (persistenceEnabledFor(provenance))
          this.mapDataStore.remove(key, now); 
        onStore(record);
        this.mutationObserver.onRemoveRecord(key, record);
        this.storage.removeRecord(record);
        return true;
      } 
      if (this.valueComparator.isEqual(newValue, oldValue, this.serializationService)) {
        mergeRecordExpiration(record, mergingEntry);
        return true;
      } 
      newValue = persistenceEnabledFor(provenance) ? this.mapDataStore.add(key, newValue, now) : newValue;
      onStore(record);
      this.mutationObserver.onUpdateRecord(key, record, newValue);
      this.storage.updateRecordValue(key, record, newValue);
    } 
    saveIndex(record, oldValue);
    return (newValue != null);
  }
  
  public Object replace(Data key, Object update) {
    checkIfLoaded();
    long now = getNow();
    Record record = getRecordOrNull(key, now, false);
    if (record == null || record.getValue() == null)
      return null; 
    Object oldValue = record.getValue();
    update = this.mapServiceContext.interceptPut(this.name, oldValue, update);
    update = this.mapDataStore.add(key, update, now);
    onStore(record);
    updateRecord(key, record, update, now, true);
    ExpirationTimeSetter.setExpirationTimes(record.getTtl(), record.getMaxIdle(), record, this.mapContainer.getMapConfig(), false);
    saveIndex(record, oldValue);
    return oldValue;
  }
  
  public boolean replace(Data key, Object expect, Object update) {
    checkIfLoaded();
    long now = getNow();
    Record record = getRecordOrNull(key, now, false);
    if (record == null)
      return false; 
    Object current = record.getValue();
    if (!this.valueComparator.isEqual(expect, current, this.serializationService))
      return false; 
    update = this.mapServiceContext.interceptPut(this.name, current, update);
    update = this.mapDataStore.add(key, update, now);
    onStore(record);
    updateRecord(key, record, update, now, true);
    ExpirationTimeSetter.setExpirationTimes(record.getTtl(), record.getMaxIdle(), record, this.mapContainer.getMapConfig(), false);
    saveIndex(record, current);
    return true;
  }
  
  public Object putTransient(Data key, Object value, long ttl, long maxIdle) {
    checkIfLoaded();
    long now = getNow();
    markRecordStoreExpirable(ttl, maxIdle);
    Record record = getRecordOrNull(key, now, false);
    Object oldValue = null;
    if (record == null) {
      value = this.mapServiceContext.interceptPut(this.name, null, value);
      record = createRecord(key, value, ttl, maxIdle, now);
      this.storage.put(key, record);
      this.mutationObserver.onPutRecord(key, record);
    } else {
      oldValue = record.getValue();
      value = this.mapServiceContext.interceptPut(this.name, oldValue, value);
      updateRecord(key, record, value, now, true);
      ExpirationTimeSetter.setExpirationTimes(ttl, maxIdle, record, this.mapContainer.getMapConfig(), false);
    } 
    saveIndex(record, oldValue);
    this.mapDataStore.addTransient(key, now);
    return oldValue;
  }
  
  public Object putFromLoad(Data key, Object value, Address callerAddress) { return putFromLoadInternal(key, value, -1L, -1L, false, callerAddress); }
  
  public Object putFromLoadBackup(Data key, Object value) { return putFromLoadInternal(key, value, -1L, -1L, true, null); }
  
  private Object putFromLoadInternal(Data key, Object value, long ttl, long maxIdle, boolean backup, Address callerAddress) {
    if (!isKeyAndValueLoadable(key, value))
      return null; 
    long now = getNow();
    if (shouldEvict())
      return null; 
    markRecordStoreExpirable(ttl, maxIdle);
    Record record = getRecordOrNull(key, now, false);
    Object oldValue = null;
    EntryEventType entryEventType = null;
    if (record == null) {
      value = this.mapServiceContext.interceptPut(this.name, null, value);
      record = createRecord(key, value, ttl, maxIdle, now);
      this.storage.put(key, record);
      if (canPublishLoadEvent()) {
        this.mutationObserver.onLoadRecord(key, record);
      } else {
        this.mutationObserver.onPutRecord(key, record);
      } 
    } else {
      oldValue = record.getValue();
      value = this.mapServiceContext.interceptPut(this.name, oldValue, value);
      updateRecord(key, record, value, now, true);
      ExpirationTimeSetter.setExpirationTimes(ttl, maxIdle, record, this.mapContainer.getMapConfig(), false);
      entryEventType = EntryEventType.UPDATED;
    } 
    if (!backup) {
      saveIndex(record, oldValue);
      if (entryEventType == EntryEventType.UPDATED) {
        this.mapEventPublisher.publishEvent(callerAddress, this.name, EntryEventType.UPDATED, key, oldValue, value);
      } else if (canPublishLoadEvent()) {
        this.mapEventPublisher.publishEvent(callerAddress, this.name, EntryEventType.LOADED, key, null, value);
      } else {
        this.mapEventPublisher.publishEvent(callerAddress, this.name, EntryEventType.ADDED, key, null, value);
      } 
    } 
    return oldValue;
  }
  
  private boolean canPublishLoadEvent() {
    NodeEngine nodeEngine = this.mapServiceContext.getNodeEngine();
    ClusterService clusterService = nodeEngine.getClusterService();
    boolean version311OrLater = clusterService.getClusterVersion().isGreaterOrEqual(Versions.V3_11);
    boolean addEventPublishingEnabled = this.mapContainer.isAddEventPublishingEnabled();
    return (version311OrLater && !addEventPublishingEnabled);
  }
  
  protected boolean isKeyAndValueLoadable(Data key, Object value) {
    if (key == null) {
      this.logger.warning("Found an attempt to load a null key from map-store, ignoring it.");
      return false;
    } 
    if (value == null) {
      this.logger.warning("Found an attempt to load a null value from map-store, ignoring it.");
      return false;
    } 
    if (this.partitionService.getPartitionId(key) != this.partitionId)
      throw new IllegalStateException("MapLoader loaded an item belongs to a different partition"); 
    return true;
  }
  
  public boolean setWithUncountedAccess(Data dataKey, Object value, long ttl, long maxIdle) {
    Object oldValue = putInternal(dataKey, value, ttl, maxIdle, false, false);
    return (oldValue == null);
  }
  
  public Object putIfAbsent(Data key, Object value, long ttl, long maxIdle, Address callerAddress) {
    Object oldValue;
    checkIfLoaded();
    long now = getNow();
    markRecordStoreExpirable(ttl, maxIdle);
    Record record = getRecordOrNull(key, now, false);
    if (record == null) {
      oldValue = this.mapDataStore.load(key);
      if (oldValue != null) {
        record = createRecord(key, oldValue, -1L, -1L, now);
        this.storage.put(key, record);
        this.mutationObserver.onPutRecord(key, record);
        this.mapEventPublisher.publishEvent(callerAddress, this.name, EntryEventType.LOADED, key, null, oldValue);
      } 
    } else {
      accessRecord(record, now);
      oldValue = record.getValue();
    } 
    if (oldValue == null) {
      value = this.mapServiceContext.interceptPut(this.name, null, value);
      value = this.mapDataStore.add(key, value, now);
      onStore(record);
      record = createRecord(key, value, ttl, maxIdle, now);
      this.storage.put(key, record);
      this.mutationObserver.onPutRecord(key, record);
      ExpirationTimeSetter.setExpirationTimes(ttl, maxIdle, record, this.mapContainer.getMapConfig(), false);
    } 
    saveIndex(record, oldValue);
    return oldValue;
  }
  
  protected Object removeRecord(Data key, @Nonnull Record record, long now, CallerProvenance provenance) {
    Object oldValue = record.getValue();
    oldValue = this.mapServiceContext.interceptRemove(this.name, oldValue);
    if (oldValue != null) {
      removeIndex(record);
      if (persistenceEnabledFor(provenance))
        this.mapDataStore.remove(key, now); 
      onStore(record);
    } 
    this.mutationObserver.onRemoveRecord(key, record);
    this.storage.removeRecord(record);
    return oldValue;
  }
  
  public Record getRecordOrNull(Data key) {
    long now = getNow();
    return getRecordOrNull(key, now, false);
  }
  
  protected Record getRecordOrNull(Data key, long now, boolean backup) {
    Record record = (Record)this.storage.get(key);
    if (record == null)
      return null; 
    return getOrNullIfExpired(record, now, backup);
  }
  
  protected void onStore(Record record) {
    if (record == null || this.mapDataStore == MapDataStores.EMPTY_MAP_DATA_STORE)
      return; 
    record.onStore();
  }
  
  private void updateStoreStats() {
    if (!(this.mapDataStore instanceof WriteBehindStore) || 
      !this.mapContainer.getMapConfig().isStatisticsEnabled())
      return; 
    long now = Clock.currentTimeMillis();
    WriteBehindQueue<DelayedEntry> writeBehindQueue = ((WriteBehindStore)this.mapDataStore).getWriteBehindQueue();
    List<DelayedEntry> delayedEntries = writeBehindQueue.asList();
    for (DelayedEntry delayedEntry : delayedEntries) {
      Record record = getRecordOrNull(toData(delayedEntry.getKey()), now, false);
      onStore(record);
    } 
  }
  
  public boolean isKeyLoadFinished() { return this.keyLoader.isKeyLoadFinished(); }
  
  public void checkIfLoaded() {
    if (this.loadingFutures.isEmpty())
      return; 
    if (FutureUtil.allDone(this.loadingFutures)) {
      doneFutures = null;
      try {
        doneFutures = FutureUtil.getAllDone(this.loadingFutures);
        FutureUtil.checkAllDone(doneFutures);
      } catch (Exception e) {
        this.logger.severe("Exception while loading map " + this.name, e);
        throw ExceptionUtil.rethrow(e);
      } finally {
        this.loadingFutures.removeAll(doneFutures);
      } 
    } else {
      this.keyLoader.triggerLoadingWithDelay();
      throw new RetryableHazelcastException("Map " + getName() + " is still loading data from external store");
    } 
  }
  
  public boolean isLoaded() {
    boolean result = FutureUtil.allDone(this.loadingFutures);
    if (result)
      this.loadingFutures.removeAll(FutureUtil.getAllDone(this.loadingFutures)); 
    return result;
  }
  
  public Collection<Future> getLoadingFutures() { return this.loadingFutures; }
  
  public void startLoading() {
    if (this.logger.isFinestEnabled())
      this.logger.finest("StartLoading invoked " + getStateMessage()); 
    if (this.mapStoreContext.isMapLoader() && !this.loadedOnCreate)
      if (!this.loadedOnPreMigration) {
        if (this.logger.isFinestEnabled())
          this.logger.finest("Triggering load " + getStateMessage()); 
        this.loadedOnCreate = true;
        this.loadingFutures.add(this.keyLoader.startInitialLoad(this.mapStoreContext, this.partitionId));
      } else {
        if (this.logger.isFinestEnabled())
          this.logger.finest("Promoting to loaded on migration " + getStateMessage()); 
        this.keyLoader.promoteToLoadedOnMigration();
      }  
  }
  
  public void setPreMigrationLoadedStatus(boolean loaded) { this.loadedOnPreMigration = loaded; }
  
  public void loadAll(boolean replaceExistingValues) {
    if (this.logger.isFinestEnabled())
      this.logger.finest("loadAll invoked " + getStateMessage()); 
    this.logger.info("Starting to load all keys for map " + this.name + " on partitionId=" + this.partitionId);
    Future<?> loadingKeysFuture = this.keyLoader.startLoading(this.mapStoreContext, replaceExistingValues);
    this.loadingFutures.add(loadingKeysFuture);
  }
  
  public void loadAllFromStore(List<Data> keys, boolean replaceExistingValues) {
    if (!keys.isEmpty()) {
      Future f = this.recordStoreLoader.loadValues(keys, replaceExistingValues);
      this.loadingFutures.add(f);
    } 
  }
  
  public void updateLoadStatus(boolean lastBatch, Throwable exception) {
    this.keyLoader.trackLoading(lastBatch, exception);
    if (lastBatch)
      this.logger.finest("Completed loading map " + this.name + " on partitionId=" + this.partitionId); 
  }
  
  public void maybeDoInitialLoad() {
    if (this.keyLoader.shouldDoInitialLoad())
      loadAll(false); 
  }
  
  private String getStateMessage() {
    return "on partitionId=" + this.partitionId + " on " + this.mapServiceContext.getNodeEngine().getThisAddress() + " loadedOnCreate=" + this.loadedOnCreate + " loadedOnPreMigration=" + this.loadedOnPreMigration + " isLoaded=" + 
      
      isLoaded();
  }
  
  public int clear() {
    checkIfLoaded();
    Collection<Record> clearableRecords = getNotLockedRecords();
    List<Data> keys = getKeysFromRecords(clearableRecords);
    this.mapDataStore.removeAll(keys);
    clearMapStore();
    removeIndex(clearableRecords);
    return removeRecords(clearableRecords);
  }
  
  public void reset() {
    clearMapStore();
    this.storage.clear(false);
    this.stats.reset();
    this.mutationObserver.onReset();
  }
  
  public void destroy() { clearPartition(false, true); }
  
  public void clearPartition(boolean onShutdown, boolean onStorageDestroy) {
    clearLockStore();
    clearOtherDataThanStorage(onShutdown, onStorageDestroy);
    if (onShutdown) {
      if (hasPooledMemoryAllocator()) {
        destroyStorageImmediate(true, true);
      } else {
        destroyStorageAfterClear(true, true);
      } 
    } else if (onStorageDestroy) {
      destroyStorageAfterClear(false, false);
    } else {
      clearStorage(false);
    } 
  }
  
  private boolean hasPooledMemoryAllocator() {
    NodeEngine nodeEngine = this.mapServiceContext.getNodeEngine();
    NativeMemoryConfig nativeMemoryConfig = nodeEngine.getConfig().getNativeMemoryConfig();
    return (nativeMemoryConfig != null && nativeMemoryConfig.getAllocatorType() == NativeMemoryConfig.MemoryAllocatorType.POOLED);
  }
  
  public void clearOtherDataThanStorage(boolean onShutdown, boolean onStorageDestroy) {
    clearMapStore();
    clearIndexedData(onShutdown, onStorageDestroy);
  }
  
  private void destroyStorageImmediate(boolean isDuringShutdown, boolean internal) {
    this.storage.destroy(isDuringShutdown);
    this.mutationObserver.onDestroy(internal);
  }
  
  public void destroyStorageAfterClear(boolean isDuringShutdown, boolean internal) {
    clearStorage(isDuringShutdown);
    destroyStorageImmediate(isDuringShutdown, internal);
  }
  
  private void clearStorage(boolean isDuringShutdown) {
    this.storage.clear(isDuringShutdown);
    this.mutationObserver.onClear();
  }
  
  private void clearLockStore() {
    NodeEngine nodeEngine = this.mapServiceContext.getNodeEngine();
    LockService lockService = (LockService)nodeEngine.getSharedService("hz:impl:lockService");
    if (lockService != null) {
      ObjectNamespace namespace = MapService.getObjectNamespace(this.name);
      lockService.clearLockStore(this.partitionId, namespace);
    } 
  }
  
  private void clearMapStore() { this.mapDataStore.reset(); }
  
  private void clearIndexedData(boolean onShutdown, boolean onStorageDestroy) {
    clearGlobalIndexes(onShutdown);
    clearPartitionedIndexes(onStorageDestroy);
  }
  
  private void clearGlobalIndexes(boolean onShutdown) {
    Indexes indexes = this.mapContainer.getIndexes(this.partitionId);
    if (indexes.isGlobal())
      if (onShutdown) {
        indexes.destroyIndexes();
      } else if (indexes.haveAtLeastOneIndex()) {
        fullScanLocalDataToClear(indexes);
      }  
  }
  
  private void clearPartitionedIndexes(boolean onStorageDestroy) {
    Indexes indexes = this.mapContainer.getIndexes(this.partitionId);
    if (indexes.isGlobal())
      return; 
    if (onStorageDestroy) {
      indexes.destroyIndexes();
    } else {
      indexes.clearAll();
    } 
  }
  
  private void fullScanLocalDataToClear(Indexes indexes) {
    InternalIndex[] indexesSnapshot = indexes.getIndexes();
    for (Record record : this.storage.values()) {
      Data key = record.getKey();
      Object value = Records.getValueOrCachedValue(record, this.serializationService);
      indexes.removeEntry(key, value, Index.OperationSource.SYSTEM);
    } 
    Indexes.markPartitionAsUnindexed(this.partitionId, indexesSnapshot);
  }
}
