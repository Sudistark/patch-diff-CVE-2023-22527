package com.hazelcast.map.impl.recordstore;

import com.hazelcast.config.InMemoryFormat;
import com.hazelcast.core.EntryView;
import com.hazelcast.internal.eviction.ExpiredKey;
import com.hazelcast.internal.nearcache.impl.invalidation.InvalidationQueue;
import com.hazelcast.map.impl.MapContainer;
import com.hazelcast.map.impl.MapEntries;
import com.hazelcast.map.impl.iterator.MapEntriesWithCursor;
import com.hazelcast.map.impl.iterator.MapKeysWithCursor;
import com.hazelcast.map.impl.mapstore.MapDataStore;
import com.hazelcast.map.impl.record.Record;
import com.hazelcast.map.impl.record.RecordFactory;
import com.hazelcast.map.merge.MapMergePolicy;
import com.hazelcast.monitor.LocalRecordStoreStats;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.merge.SplitBrainMergePolicy;
import com.hazelcast.spi.merge.SplitBrainMergeTypes;
import com.hazelcast.wan.impl.CallerProvenance;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

public interface RecordStore<R extends Record> {
  public static final long DEFAULT_TTL = -1L;
  
  public static final long DEFAULT_MAX_IDLE = -1L;
  
  LocalRecordStoreStats getLocalRecordStoreStats();
  
  void accessRecord(Record paramRecord, long paramLong);
  
  String getName();
  
  Object set(Data paramData, Object paramObject, long paramLong1, long paramLong2);
  
  Object put(Data paramData, Object paramObject, long paramLong1, long paramLong2);
  
  Object putIfAbsent(Data paramData, Object paramObject, long paramLong1, long paramLong2, Address paramAddress);
  
  R putBackup(Data paramData, Object paramObject, CallerProvenance paramCallerProvenance);
  
  R putBackup(Data paramData, Object paramObject, long paramLong1, long paramLong2, boolean paramBoolean, CallerProvenance paramCallerProvenance);
  
  boolean setWithUncountedAccess(Data paramData, Object paramObject, long paramLong1, long paramLong2);
  
  Object remove(Data paramData, CallerProvenance paramCallerProvenance);
  
  boolean delete(Data paramData, CallerProvenance paramCallerProvenance);
  
  boolean remove(Data paramData, Object paramObject);
  
  boolean setTtl(Data paramData, long paramLong);
  
  void removeBackup(Data paramData, CallerProvenance paramCallerProvenance);
  
  Object get(Data paramData, boolean paramBoolean1, Address paramAddress, boolean paramBoolean2);
  
  Object get(Data paramData, boolean paramBoolean, Address paramAddress);
  
  Data readBackupData(Data paramData);
  
  MapEntries getAll(Set<Data> paramSet, Address paramAddress);
  
  boolean existInMemory(Data paramData);
  
  boolean containsKey(Data paramData, Address paramAddress);
  
  int getLockedEntryCount();
  
  Object replace(Data paramData, Object paramObject);
  
  boolean replace(Data paramData, Object paramObject1, Object paramObject2);
  
  Object putTransient(Data paramData, Object paramObject, long paramLong1, long paramLong2);
  
  Object putFromLoad(Data paramData, Object paramObject, Address paramAddress);
  
  Object putFromLoadBackup(Data paramData, Object paramObject);
  
  boolean merge(SplitBrainMergeTypes.MapMergeTypes paramMapMergeTypes, SplitBrainMergePolicy<Data, SplitBrainMergeTypes.MapMergeTypes> paramSplitBrainMergePolicy);
  
  boolean merge(SplitBrainMergeTypes.MapMergeTypes paramMapMergeTypes, SplitBrainMergePolicy<Data, SplitBrainMergeTypes.MapMergeTypes> paramSplitBrainMergePolicy, CallerProvenance paramCallerProvenance);
  
  boolean merge(Data paramData, EntryView paramEntryView, MapMergePolicy paramMapMergePolicy);
  
  boolean merge(Data paramData, EntryView paramEntryView, MapMergePolicy paramMapMergePolicy, CallerProvenance paramCallerProvenance);
  
  R getRecord(Data paramData);
  
  void putRecord(Data paramData, R paramR);
  
  Iterator<Record> iterator();
  
  Iterator<Record> iterator(long paramLong, boolean paramBoolean);
  
  MapKeysWithCursor fetchKeys(int paramInt1, int paramInt2);
  
  MapEntriesWithCursor fetchEntries(int paramInt1, int paramInt2);
  
  Iterator<Record> loadAwareIterator(long paramLong, boolean paramBoolean);
  
  int size();
  
  boolean txnLock(Data paramData, String paramString, long paramLong1, long paramLong2, long paramLong3, boolean paramBoolean);
  
  boolean extendLock(Data paramData, String paramString, long paramLong1, long paramLong2);
  
  boolean localLock(Data paramData, String paramString, long paramLong1, long paramLong2, long paramLong3);
  
  boolean lock(Data paramData, String paramString, long paramLong1, long paramLong2, long paramLong3);
  
  boolean isLockedBy(Data paramData, String paramString, long paramLong);
  
  boolean unlock(Data paramData, String paramString, long paramLong1, long paramLong2);
  
  boolean isLocked(Data paramData);
  
  boolean isTransactionallyLocked(Data paramData);
  
  boolean canAcquireLock(Data paramData, String paramString, long paramLong);
  
  String getLockOwnerInfo(Data paramData);
  
  boolean containsValue(Object paramObject);
  
  Object evict(Data paramData, boolean paramBoolean);
  
  int evictAll(boolean paramBoolean);
  
  MapContainer getMapContainer();
  
  long softFlush();
  
  boolean forceUnlock(Data paramData);
  
  long getOwnedEntryCost();
  
  boolean isEmpty();
  
  void evictExpiredEntries(int paramInt, boolean paramBoolean);
  
  boolean isExpirable();
  
  boolean isExpired(R paramR, long paramLong, boolean paramBoolean);
  
  void doPostEvictionOperations(Record paramRecord);
  
  MapDataStore<Data, Object> getMapDataStore();
  
  InvalidationQueue<ExpiredKey> getExpiredKeysQueue();
  
  int getPartitionId();
  
  R getRecordOrNull(Data paramData);
  
  void evictEntries(Data paramData);
  
  boolean shouldEvict();
  
  Storage createStorage(RecordFactory<R> paramRecordFactory, InMemoryFormat paramInMemoryFormat);
  
  Record createRecord(Data paramData, Object paramObject, long paramLong1, long paramLong2, long paramLong3);
  
  Record loadRecordOrNull(Data paramData, boolean paramBoolean, Address paramAddress);
  
  void disposeDeferredBlocks();
  
  void init();
  
  Storage getStorage();
  
  void sampleAndForceRemoveEntries(int paramInt);
  
  void startLoading();
  
  void setPreMigrationLoadedStatus(boolean paramBoolean);
  
  boolean isKeyLoadFinished();
  
  boolean isLoaded();
  
  void checkIfLoaded();
  
  void loadAll(boolean paramBoolean);
  
  void maybeDoInitialLoad();
  
  void loadAllFromStore(List<Data> paramList, boolean paramBoolean);
  
  void updateLoadStatus(boolean paramBoolean, Throwable paramThrowable);
  
  boolean hasQueryCache();
  
  void clearPartition(boolean paramBoolean1, boolean paramBoolean2);
  
  int clear();
  
  void reset();
  
  void destroy();
}
