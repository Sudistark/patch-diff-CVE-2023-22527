package com.hazelcast.mapreduce.impl.task;

import com.hazelcast.mapreduce.Context;
import com.hazelcast.mapreduce.KeyPredicate;
import com.hazelcast.mapreduce.KeyValueSource;
import com.hazelcast.mapreduce.Mapper;
import com.hazelcast.spi.partition.IPartitionService;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

public abstract class MappingPhase<KeyIn, ValueIn, KeyOut, ValueOut> extends Object {
  private final AtomicBoolean cancelled;
  
  private final KeyPredicate<? super KeyIn> predicate;
  
  private final Object[] keys;
  
  private Object[][] partitionMappedKeys;
  
  private Object[] partitionKeys;
  
  public MappingPhase(Collection<? extends KeyIn> keys, KeyPredicate<? super KeyIn> predicate) {
    this.cancelled = new AtomicBoolean();
    this.predicate = predicate;
    this.keys = (keys != null) ? keys.toArray(new Object[0]) : null;
  }
  
  public void cancel() { this.cancelled.set(true); }
  
  protected boolean isCancelled() { return this.cancelled.get(); }
  
  protected boolean processingPartitionNecessary(int partitionId, IPartitionService partitionService) {
    if (partitionId == -1) {
      this.partitionKeys = null;
      return true;
    } 
    this.partitionKeys = prepareKeys(partitionId, partitionService);
    if (this.keys == null || this.keys.length == 0 || this.predicate != null)
      return true; 
    return (this.partitionKeys != null && this.partitionKeys.length > 0);
  }
  
  protected boolean matches(KeyIn key) {
    if (this.partitionKeys == null && this.predicate == null)
      return true; 
    if (this.partitionKeys != null && this.partitionKeys.length > 0)
      for (Object matcher : this.partitionKeys) {
        if (key == matcher || key.equals(matcher))
          return true; 
      }  
    return (this.predicate != null && this.predicate.evaluate(key));
  }
  
  private Object[] prepareKeys(int partitionId, IPartitionService partitionService) {
    if (this.keys == null || this.keys.length == 0)
      return null; 
    if (this.partitionMappedKeys != null)
      return this.partitionMappedKeys[partitionId]; 
    this.partitionMappedKeys = buildCache(partitionService);
    return this.partitionMappedKeys[partitionId];
  }
  
  private Object[][] buildCache(IPartitionService partitionService) {
    List[] mapping = buildMapping(partitionService);
    Object[][] cache = new Object[mapping.length][];
    for (int i = 0; i < cache.length; i++) {
      List<Object> keys = mapping[i];
      if (keys != null)
        cache[i] = keys.toArray(new Object[0]); 
    } 
    return cache;
  }
  
  private List<Object>[] buildMapping(IPartitionService partitionService) {
    List[] mapping = new List[partitionService.getPartitionCount()];
    for (Object key : this.keys) {
      int pid = partitionService.getPartitionId(key);
      List<Object> list = mapping[pid];
      if (list == null) {
        list = new ArrayList<Object>();
        mapping[pid] = list;
      } 
      list.add(key);
    } 
    return mapping;
  }
  
  protected abstract void executeMappingPhase(KeyValueSource<KeyIn, ValueIn> paramKeyValueSource, Mapper<KeyIn, ValueIn, KeyOut, ValueOut> paramMapper, Context<KeyOut, ValueOut> paramContext);
}
