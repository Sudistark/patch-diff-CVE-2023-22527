package com.hazelcast.mapreduce.impl.task;

import com.hazelcast.core.IFunction;
import com.hazelcast.internal.serialization.InternalSerializationService;
import com.hazelcast.mapreduce.Combiner;
import com.hazelcast.mapreduce.CombinerFactory;
import com.hazelcast.mapreduce.Context;
import com.hazelcast.mapreduce.impl.MapReduceUtil;
import com.hazelcast.util.ConcurrentReferenceHashMap;
import com.hazelcast.util.IConcurrentMap;
import com.hazelcast.util.MapUtil;
import java.util.Map;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;

public class DefaultContext<KeyIn, ValueIn> extends Object implements Context<KeyIn, ValueIn> {
  private static final AtomicIntegerFieldUpdater<DefaultContext> COLLECTED = AtomicIntegerFieldUpdater.newUpdater(DefaultContext.class, "collected");
  
  private final IConcurrentMap<KeyIn, Combiner<ValueIn, ?>> combiners;
  
  private final CombinerFactory<KeyIn, ValueIn, ?> combinerFactory;
  
  private final MapCombineTask mapCombineTask;
  
  private final IFunction<KeyIn, Combiner<ValueIn, ?>> combinerFunction;
  
  protected DefaultContext(CombinerFactory<KeyIn, ValueIn, ?> combinerFactory, MapCombineTask mapCombineTask) {
    this.combiners = new ConcurrentReferenceHashMap(ConcurrentReferenceHashMap.ReferenceType.STRONG, ConcurrentReferenceHashMap.ReferenceType.STRONG);
    this.combinerFunction = new CombinerFunction(this, null);
    this.mapCombineTask = mapCombineTask;
    this.combinerFactory = (combinerFactory != null) ? combinerFactory : new CollectingCombinerFactory(null);
  }
  
  public void setPartitionId(int partitionId) { this.partitionId = partitionId; }
  
  public void emit(KeyIn key, ValueIn value) {
    Combiner<ValueIn, ?> combiner = getOrCreateCombiner(key);
    combiner.combine(value);
    COLLECTED.incrementAndGet(this);
    this.mapCombineTask.onEmit(this, this.partitionId);
  }
  
  public <Chunk> Map<KeyIn, Chunk> requestChunk() {
    int mapSize = MapReduceUtil.mapSize(this.combiners.size());
    Map<KeyIn, Chunk> chunkMap = MapUtil.createHashMapAdapter(mapSize);
    for (Map.Entry<KeyIn, Combiner<ValueIn, ?>> entry : this.combiners.entrySet()) {
      Combiner<ValueIn, ?> combiner = (Combiner)entry.getValue();
      Chunk chunk = (Chunk)combiner.finalizeChunk();
      combiner.reset();
      if (chunk != null)
        chunkMap.put(entry.getKey(), chunk); 
    } 
    COLLECTED.set(this, 0);
    return chunkMap;
  }
  
  public int getCollected() { return this.collected; }
  
  public void finalizeCombiners() {
    for (Combiner<ValueIn, ?> combiner : this.combiners.values())
      combiner.finalizeCombine(); 
  }
  
  public Combiner<ValueIn, ?> getOrCreateCombiner(KeyIn key) { return (Combiner)this.combiners.applyIfAbsent(key, this.combinerFunction); }
  
  public void setSerializationService(InternalSerializationService serializationService) { this.serializationService = serializationService; }
  
  public InternalSerializationService getSerializationService() { return this.serializationService; }
}
