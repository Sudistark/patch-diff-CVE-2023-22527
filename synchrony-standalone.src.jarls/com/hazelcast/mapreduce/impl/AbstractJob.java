package com.hazelcast.mapreduce.impl;

import com.hazelcast.mapreduce.Collator;
import com.hazelcast.mapreduce.CombinerFactory;
import com.hazelcast.mapreduce.Job;
import com.hazelcast.mapreduce.JobCompletableFuture;
import com.hazelcast.mapreduce.JobTracker;
import com.hazelcast.mapreduce.KeyPredicate;
import com.hazelcast.mapreduce.KeyValueSource;
import com.hazelcast.mapreduce.Mapper;
import com.hazelcast.mapreduce.MappingJob;
import com.hazelcast.mapreduce.ReducerFactory;
import com.hazelcast.mapreduce.TopologyChangedStrategy;
import com.hazelcast.util.Preconditions;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;

public abstract class AbstractJob<KeyIn, ValueIn> extends Object implements Job<KeyIn, ValueIn> {
  protected final String name;
  
  protected final JobTracker jobTracker;
  
  protected final KeyValueSource<KeyIn, ValueIn> keyValueSource;
  
  protected Mapper<KeyIn, ValueIn, ?, ?> mapper;
  
  protected CombinerFactory<?, ?, ?> combinerFactory;
  
  protected ReducerFactory<?, ?, ?> reducerFactory;
  
  protected Collection<KeyIn> keys;
  
  protected KeyPredicate<? super KeyIn> predicate;
  
  protected int chunkSize;
  
  protected TopologyChangedStrategy topologyChangedStrategy;
  
  public AbstractJob(String name, JobTracker jobTracker, KeyValueSource<KeyIn, ValueIn> keyValueSource) {
    this.chunkSize = -1;
    this.name = name;
    this.jobTracker = jobTracker;
    this.keyValueSource = keyValueSource;
  }
  
  public <KeyOut, ValueOut> MappingJob<KeyIn, KeyOut, ValueOut> mapper(Mapper<KeyIn, ValueIn, KeyOut, ValueOut> mapper) {
    Preconditions.isNotNull(mapper, "mapper");
    if (this.mapper != null)
      throw new IllegalStateException("mapper already set"); 
    this.mapper = mapper;
    return new MappingJobImpl(this);
  }
  
  public Job<KeyIn, ValueIn> onKeys(Iterable<? extends KeyIn> keys) {
    addKeys(keys);
    return this;
  }
  
  public Job<KeyIn, ValueIn> onKeys(KeyIn... keys) {
    addKeys(keys);
    return this;
  }
  
  public Job<KeyIn, ValueIn> keyPredicate(KeyPredicate<? super KeyIn> predicate) {
    setKeyPredicate(predicate);
    return this;
  }
  
  public Job<KeyIn, ValueIn> chunkSize(int chunkSize) {
    this.chunkSize = chunkSize;
    return this;
  }
  
  public Job<KeyIn, ValueIn> topologyChangedStrategy(TopologyChangedStrategy topologyChangedStrategy) {
    this.topologyChangedStrategy = topologyChangedStrategy;
    return this;
  }
  
  protected <T> JobCompletableFuture<T> submit(Collator collator) {
    prepareKeyPredicate();
    return invoke(collator);
  }
  
  protected void prepareKeyPredicate() {
    if (this.predicate == null)
      return; 
    if (this.keyValueSource.isAllKeysSupported()) {
      Collection<KeyIn> allKeys = this.keyValueSource.getAllKeys();
      for (KeyIn key : allKeys) {
        if (this.predicate.evaluate(key)) {
          if (this.keys == null)
            this.keys = new HashSet(); 
          this.keys.add(key);
        } 
      } 
    } 
  }
  
  private void addKeys(Iterable<? extends KeyIn> keys) {
    if (this.keys == null)
      this.keys = new HashSet(); 
    for (KeyIn key : keys)
      this.keys.add(key); 
  }
  
  private void addKeys(KeyIn... keys) {
    if (this.keys == null)
      this.keys = new ArrayList(); 
    this.keys.addAll(Arrays.asList(keys));
  }
  
  private void setKeyPredicate(KeyPredicate<? super KeyIn> predicate) {
    Preconditions.isNotNull(predicate, "predicate");
    this.predicate = predicate;
  }
  
  private <T> JobCompletableFuture<T> submit() { return submit(null); }
  
  protected abstract <T> JobCompletableFuture<T> invoke(Collator paramCollator);
}
