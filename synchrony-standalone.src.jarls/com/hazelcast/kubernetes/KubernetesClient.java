package com.hazelcast.kubernetes;

import com.hazelcast.internal.json.JsonArray;
import com.hazelcast.internal.json.JsonObject;
import com.hazelcast.internal.json.JsonValue;
import com.hazelcast.logging.ILogger;
import com.hazelcast.logging.Logger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

class KubernetesClient {
  private static final ILogger LOGGER = Logger.getLogger(KubernetesClient.class);
  
  private static final List<String> NON_RETRYABLE_KEYWORDS = Arrays.asList(new String[] { "\"reason\":\"Forbidden\"", "\"reason\":\"Unauthorized\"", "Failure in generating SSLSocketFactory" });
  
  private final String namespace;
  
  private final String kubernetesMaster;
  
  private final String apiToken;
  
  private final String caCertificate;
  
  private final int retries;
  
  private boolean useNodeNameAsExternalAddress;
  
  private boolean isNoPublicIpAlreadyLogged;
  
  KubernetesClient(String namespace, String kubernetesMaster, String apiToken, String caCertificate, int retries, boolean useNodeNameAsExternalAddress) {
    this.namespace = namespace;
    this.kubernetesMaster = kubernetesMaster;
    this.apiToken = apiToken;
    this.caCertificate = caCertificate;
    this.retries = retries;
    this.useNodeNameAsExternalAddress = useNodeNameAsExternalAddress;
  }
  
  List<Endpoint> endpoints() {
    try {
      String urlString = String.format("%s/api/v1/namespaces/%s/pods", new Object[] { this.kubernetesMaster, this.namespace });
      return enrichWithPublicAddresses(parsePodsList(callGet(urlString)));
    } catch (RestClientException e) {
      return handleKnownException(e);
    } 
  }
  
  List<Endpoint> endpointsByServiceLabel(String serviceLabel, String serviceLabelValue) {
    try {
      String param = String.format("labelSelector=%s=%s", new Object[] { serviceLabel, serviceLabelValue });
      String urlString = String.format("%s/api/v1/namespaces/%s/endpoints?%s", new Object[] { this.kubernetesMaster, this.namespace, param });
      return enrichWithPublicAddresses(parseEndpointsList(callGet(urlString)));
    } catch (RestClientException e) {
      return handleKnownException(e);
    } 
  }
  
  List<Endpoint> endpointsByName(String endpointName) {
    try {
      String urlString = String.format("%s/api/v1/namespaces/%s/endpoints/%s", new Object[] { this.kubernetesMaster, this.namespace, endpointName });
      return enrichWithPublicAddresses(parseEndpoints(callGet(urlString)));
    } catch (RestClientException e) {
      return handleKnownException(e);
    } 
  }
  
  List<Endpoint> endpointsByPodLabel(String podLabel, String podLabelValue) {
    try {
      String param = String.format("labelSelector=%s=%s", new Object[] { podLabel, podLabelValue });
      String urlString = String.format("%s/api/v1/namespaces/%s/pods?%s", new Object[] { this.kubernetesMaster, this.namespace, param });
      return enrichWithPublicAddresses(parsePodsList(callGet(urlString)));
    } catch (RestClientException e) {
      return handleKnownException(e);
    } 
  }
  
  String zone(String podName) {
    String nodeUrlString = String.format("%s/api/v1/nodes/%s", new Object[] { this.kubernetesMaster, nodeName(podName) });
    return extractZone(callGet(nodeUrlString));
  }
  
  String nodeName(String podName) {
    String podUrlString = String.format("%s/api/v1/namespaces/%s/pods/%s", new Object[] { this.kubernetesMaster, this.namespace, podName });
    return extractNodeName(callGet(podUrlString));
  }
  
  private static List<Endpoint> parsePodsList(JsonObject podsListJson) {
    List<Endpoint> addresses = new ArrayList<Endpoint>();
    for (JsonValue item : toJsonArray(podsListJson.get("items"))) {
      JsonObject status = item.asObject().get("status").asObject();
      String ip = toString(status.get("podIP"));
      if (ip != null) {
        Integer port = extractContainerPort(item);
        addresses.add(new Endpoint(new EndpointAddress(ip, port), isReady(status)));
      } 
    } 
    return addresses;
  }
  
  private static Integer extractContainerPort(JsonValue podItemJson) {
    JsonArray containers = toJsonArray(podItemJson.asObject().get("spec").asObject().get("containers"));
    if (containers.size() == 1) {
      JsonValue container = containers.get(0);
      JsonArray ports = toJsonArray(container.asObject().get("ports"));
      if (ports.size() == 1) {
        JsonValue port = ports.get(0);
        JsonValue containerPort = port.asObject().get("containerPort");
        if (containerPort != null && containerPort.isNumber())
          return Integer.valueOf(containerPort.asInt()); 
      } 
    } 
    return null;
  }
  
  private static boolean isReady(JsonObject podItemStatusJson) {
    for (JsonValue containerStatus : toJsonArray(podItemStatusJson.get("containerStatuses"))) {
      if (!containerStatus.asObject().get("ready").asBoolean())
        return false; 
    } 
    return true;
  }
  
  private static List<Endpoint> parseEndpointsList(JsonObject endpointsListJson) {
    List<Endpoint> endpoints = new ArrayList<Endpoint>();
    for (JsonValue item : toJsonArray(endpointsListJson.get("items")))
      endpoints.addAll(parseEndpoints(item)); 
    return endpoints;
  }
  
  private static List<Endpoint> parseEndpoints(JsonValue endpointItemJson) {
    List<Endpoint> addresses = new ArrayList<Endpoint>();
    for (JsonValue subset : toJsonArray(endpointItemJson.asObject().get("subsets"))) {
      Integer endpointPort = extractPort(subset);
      for (JsonValue address : toJsonArray(subset.asObject().get("addresses")))
        addresses.add(extractEntrypointAddress(address, endpointPort, true)); 
      for (JsonValue address : toJsonArray(subset.asObject().get("notReadyAddresses")))
        addresses.add(extractEntrypointAddress(address, endpointPort, false)); 
    } 
    return addresses;
  }
  
  private static Integer extractPort(JsonValue subsetJson) {
    JsonArray ports = toJsonArray(subsetJson.asObject().get("ports"));
    if (ports.size() == 1) {
      JsonValue port = ports.get(0);
      return Integer.valueOf(port.asObject().get("port").asInt());
    } 
    return null;
  }
  
  private static Endpoint extractEntrypointAddress(JsonValue endpointAddressJson, Integer endpointPort, boolean isReady) {
    String ip = endpointAddressJson.asObject().get("ip").asString();
    Integer port = extractHazelcastServicePortFrom(endpointAddressJson, endpointPort);
    Map<String, Object> additionalProperties = extractAdditionalPropertiesFrom(endpointAddressJson);
    return new Endpoint(new EndpointAddress(ip, port), isReady, additionalProperties);
  }
  
  private static Integer extractHazelcastServicePortFrom(JsonValue endpointAddressJson, Integer endpointPort) {
    JsonValue servicePort = endpointAddressJson.asObject().get("hazelcast-service-port");
    if (servicePort != null && servicePort.isNumber())
      return Integer.valueOf(servicePort.asInt()); 
    return endpointPort;
  }
  
  private static Map<String, Object> extractAdditionalPropertiesFrom(JsonValue endpointAddressJson) {
    Set<String> knownFieldNames = new HashSet<String>(Arrays.asList(new String[] { "ip", "nodeName", "targetRef", "hostname", "hazelcast-service-port" }));
    Map<String, Object> result = new HashMap<String, Object>();
    for (JsonObject.Member member : endpointAddressJson.asObject()) {
      if (!knownFieldNames.contains(member.getName()))
        result.put(member.getName(), toString(member.getValue())); 
    } 
    return result;
  }
  
  private static String extractNodeName(JsonObject podJson) { return toString(podJson.get("spec").asObject().get("nodeName")); }
  
  private static String extractZone(JsonObject nodeJson) {
    JsonObject labels = nodeJson.get("metadata").asObject().get("labels").asObject();
    JsonValue zone = labels.get("failure-domain.kubernetes.io/zone");
    if (zone != null)
      return toString(zone); 
    return toString(labels.get("failure-domain.beta.kubernetes.io/zone"));
  }
  
  private List<Endpoint> enrichWithPublicAddresses(List<Endpoint> endpoints) {
    try {
      String endpointsUrl = String.format("%s/api/v1/namespaces/%s/endpoints", new Object[] { this.kubernetesMaster, this.namespace });
      JsonObject endpointsJson = callGet(endpointsUrl);
      List<EndpointAddress> privateAddresses = privateAddresses(endpoints);
      Map<EndpointAddress, String> services = extractServices(endpointsJson, privateAddresses);
      Map<EndpointAddress, String> nodes = extractNodes(endpointsJson, privateAddresses);
      Map<EndpointAddress, String> publicIps = new HashMap<EndpointAddress, String>();
      Map<EndpointAddress, Integer> publicPorts = new HashMap<EndpointAddress, Integer>();
      Map<String, String> cachedNodePublicIps = new HashMap<String, String>();
      for (Map.Entry<EndpointAddress, String> serviceEntry : services.entrySet()) {
        EndpointAddress privateAddress = (EndpointAddress)serviceEntry.getKey();
        String service = (String)serviceEntry.getValue();
        String serviceUrl = String.format("%s/api/v1/namespaces/%s/services/%s", new Object[] { this.kubernetesMaster, this.namespace, service });
        JsonObject serviceJson = callGet(serviceUrl);
        try {
          String loadBalancerIp = extractLoadBalancerIp(serviceJson);
          Integer servicePort = extractServicePort(serviceJson);
          publicIps.put(privateAddress, loadBalancerIp);
          publicPorts.put(privateAddress, servicePort);
        } catch (Exception e) {
          String nodePublicAddress;
          Integer nodePort = extractNodePort(serviceJson);
          String node = (String)nodes.get(privateAddress);
          if (cachedNodePublicIps.containsKey(node)) {
            nodePublicAddress = (String)cachedNodePublicIps.get(node);
          } else {
            nodePublicAddress = externalAddressForNode(node);
            cachedNodePublicIps.put(node, nodePublicAddress);
          } 
          publicIps.put(privateAddress, nodePublicAddress);
          publicPorts.put(privateAddress, nodePort);
        } 
      } 
      return createEndpoints(endpoints, publicIps, publicPorts);
    } catch (Exception e) {
      LOGGER.finest(e);
      if (!this.isNoPublicIpAlreadyLogged) {
        LOGGER.warning("Cannot fetch public IPs of Hazelcast Member PODs, you won't be able to use Hazelcast Smart Client from outside of the Kubernetes network");
        this.isNoPublicIpAlreadyLogged = true;
      } 
      return endpoints;
    } 
  }
  
  private static List<EndpointAddress> privateAddresses(List<Endpoint> endpoints) {
    List<EndpointAddress> result = new ArrayList<EndpointAddress>();
    for (Endpoint endpoint : endpoints)
      result.add(endpoint.getPrivateAddress()); 
    return result;
  }
  
  private static Map<EndpointAddress, String> extractServices(JsonObject endpointsListJson, List<EndpointAddress> privateAddresses) {
    Map<EndpointAddress, String> result = new HashMap<EndpointAddress, String>();
    Set<EndpointAddress> left = new HashSet<EndpointAddress>(privateAddresses);
    for (JsonValue item : toJsonArray(endpointsListJson.get("items"))) {
      String service = toString(item.asObject().get("metadata").asObject().get("name"));
      List<Endpoint> endpoints = parseEndpoints(item);
      if (endpoints.size() == 1) {
        EndpointAddress address = ((Endpoint)endpoints.get(0)).getPrivateAddress();
        if (left.contains(address)) {
          result.put(address, service);
          left.remove(address);
        } 
      } 
    } 
    if (!left.isEmpty())
      throw new KubernetesClientException(String.format("Cannot fetch services dedicated to the following PODs: %s", new Object[] { left })); 
    return result;
  }
  
  private static Map<EndpointAddress, String> extractNodes(JsonObject endpointsListJson, List<EndpointAddress> privateAddresses) {
    Map<EndpointAddress, String> result = new HashMap<EndpointAddress, String>();
    Set<EndpointAddress> left = new HashSet<EndpointAddress>(privateAddresses);
    for (JsonValue item : toJsonArray(endpointsListJson.get("items"))) {
      for (JsonValue subset : toJsonArray(item.asObject().get("subsets"))) {
        JsonObject subsetObject = subset.asObject();
        List<Integer> ports = new ArrayList<Integer>();
        for (JsonValue port : toJsonArray(subsetObject.get("ports")))
          ports.add(Integer.valueOf(port.asObject().get("port").asInt())); 
        Map<EndpointAddress, String> nodes = new HashMap<EndpointAddress, String>();
        nodes.putAll(extractNodes(subsetObject.get("addresses"), ports));
        nodes.putAll(extractNodes(subsetObject.get("notReadyAddresses"), ports));
        for (Map.Entry<EndpointAddress, String> nodeEntry : nodes.entrySet()) {
          EndpointAddress address = (EndpointAddress)nodeEntry.getKey();
          if (privateAddresses.contains(address)) {
            result.put(address, nodes.get(address));
            left.remove(address);
          } 
        } 
      } 
    } 
    if (!left.isEmpty())
      throw new KubernetesClientException(String.format("Cannot fetch nodeName from the following PODs: %s", new Object[] { left })); 
    return result;
  }
  
  private static Map<EndpointAddress, String> extractNodes(JsonValue addressesJson, List<Integer> ports) {
    Map<EndpointAddress, String> result = new HashMap<EndpointAddress, String>();
    for (JsonValue address : toJsonArray(addressesJson)) {
      String ip = address.asObject().get("ip").asString();
      String nodeName = toString(address.asObject().get("nodeName"));
      for (Integer port : ports)
        result.put(new EndpointAddress(ip, port), nodeName); 
    } 
    return result;
  }
  
  private static String extractLoadBalancerIp(JsonObject serviceResponse) { return serviceResponse.get("status").asObject()
      .get("loadBalancer").asObject()
      .get("ingress").asArray().get(0).asObject()
      .get("ip").asString(); }
  
  private static Integer extractServicePort(JsonObject serviceJson) {
    JsonArray ports = toJsonArray(serviceJson.get("spec").asObject().get("ports"));
    if (ports.size() != 1)
      throw new KubernetesClientException("Cannot fetch nodePort from the service"); 
    return Integer.valueOf(ports.get(0).asObject().get("port").asInt());
  }
  
  private static Integer extractNodePort(JsonObject serviceJson) {
    JsonArray ports = toJsonArray(serviceJson.get("spec").asObject().get("ports"));
    if (ports.size() != 1)
      throw new KubernetesClientException("Cannot fetch nodePort from the service"); 
    return Integer.valueOf(ports.get(0).asObject().get("nodePort").asInt());
  }
  
  private String externalAddressForNode(String node) {
    String nodeExternalAddress;
    if (this.useNodeNameAsExternalAddress) {
      LOGGER.info("Using node name instead of public IP for node, must be available from client: " + node);
      nodeExternalAddress = node;
    } else {
      String nodeUrl = String.format("%s/api/v1/nodes/%s", new Object[] { this.kubernetesMaster, node });
      nodeExternalAddress = extractNodePublicIp(callGet(nodeUrl));
    } 
    return nodeExternalAddress;
  }
  
  private static String extractNodePublicIp(JsonObject nodeJson) {
    for (JsonValue address : toJsonArray(nodeJson.get("status").asObject().get("addresses"))) {
      if ("ExternalIP".equals(address.asObject().get("type").asString()))
        return address.asObject().get("address").asString(); 
    } 
    throw new KubernetesClientException("Node does not have ExternalIP assigned");
  }
  
  private static List<Endpoint> createEndpoints(List<Endpoint> endpoints, Map<EndpointAddress, String> publicIps, Map<EndpointAddress, Integer> publicPorts) {
    List<Endpoint> result = new ArrayList<Endpoint>();
    for (Endpoint endpoint : endpoints) {
      EndpointAddress privateAddress = endpoint.getPrivateAddress();
      EndpointAddress publicAddress = new EndpointAddress((String)publicIps.get(privateAddress), (Integer)publicPorts.get(privateAddress));
      result.add(new Endpoint(privateAddress, publicAddress, endpoint.isReady(), endpoint.getAdditionalProperties()));
    } 
    return result;
  }
  
  private JsonObject callGet(String urlString) { return (JsonObject)RetryUtils.retry(new Object(this, urlString), this.retries, NON_RETRYABLE_KEYWORDS); }
  
  private static List<Endpoint> handleKnownException(RestClientException e) {
    if (e.getHttpErrorCode() == 401) {
      LOGGER.severe("Kubernetes API authorization failure, please check your 'api-token' property");
    } else if (e.getHttpErrorCode() == 403) {
      LOGGER.severe("Kubernetes API forbidden access, please check that your Service Account have the correct (Cluster) Role rules");
    } else {
      throw e;
    } 
    LOGGER.finest(e);
    return Collections.emptyList();
  }
  
  private static JsonArray toJsonArray(JsonValue jsonValue) {
    if (jsonValue == null || jsonValue.isNull())
      return new JsonArray(); 
    return jsonValue.asArray();
  }
  
  private static String toString(JsonValue jsonValue) {
    if (jsonValue == null || jsonValue.isNull())
      return null; 
    if (jsonValue.isString())
      return jsonValue.asString(); 
    return jsonValue.toString();
  }
}
