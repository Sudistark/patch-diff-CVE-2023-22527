package com.hazelcast.crdt.pncounter;

import com.hazelcast.cluster.impl.VectorClock;
import com.hazelcast.config.Config;
import com.hazelcast.core.DistributedObject;
import com.hazelcast.crdt.CRDTReplicationAwareService;
import com.hazelcast.crdt.CRDTReplicationContainer;
import com.hazelcast.internal.util.Memoizer;
import com.hazelcast.monitor.LocalPNCounterStats;
import com.hazelcast.monitor.impl.LocalPNCounterStatsImpl;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.QuorumAwareService;
import com.hazelcast.spi.RemoteService;
import com.hazelcast.spi.StatisticsAwareService;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class PNCounterService extends Object implements ManagedService, RemoteService, CRDTReplicationAwareService<PNCounterImpl>, QuorumAwareService, StatisticsAwareService<LocalPNCounterStats> {
  public static final String SERVICE_NAME = "hz:impl:PNCounterService";
  
  private final ConcurrentMap<String, PNCounterImpl> counters = new ConcurrentHashMap();
  
  private final ConstructorFunction<String, PNCounterImpl> counterConstructorFn = new Object(this);
  
  private final Memoizer<String, Object> quorumConfigCache = new Memoizer(new Object(this));
  
  private final ConcurrentMap<String, LocalPNCounterStatsImpl> statsMap = new ConcurrentHashMap();
  
  private Map unmodifiableStatsMap = Collections.unmodifiableMap(this.statsMap);
  
  private final ConstructorFunction<String, LocalPNCounterStatsImpl> statsConstructorFunction = new Object(this);
  
  private final Object newCounterCreationMutex = new Object();
  
  private NodeEngine nodeEngine;
  
  public PNCounterImpl getCounter(String name) { return (PNCounterImpl)ConcurrencyUtil.getOrPutSynchronized(this.counters, name, this.newCounterCreationMutex, this.counterConstructorFn); }
  
  public boolean containsCounter(String name) { return this.counters.containsKey(name); }
  
  public LocalPNCounterStatsImpl getLocalPNCounterStats(String name) { return (LocalPNCounterStatsImpl)ConcurrencyUtil.getOrPutSynchronized(this.statsMap, name, this.statsMap, this.statsConstructorFunction); }
  
  public void init(NodeEngine nodeEngine, Properties properties) { this.nodeEngine = nodeEngine; }
  
  public void reset() {}
  
  public void shutdown(boolean terminate) {
    this.counters.clear();
    this.statsMap.clear();
  }
  
  public PNCounterProxy createDistributedObject(String objectName) { return new PNCounterProxy(objectName, this.nodeEngine, this); }
  
  public void destroyDistributedObject(String objectName) {
    this.counters.remove(objectName);
    this.statsMap.remove(objectName);
    this.quorumConfigCache.remove(objectName);
  }
  
  public CRDTReplicationContainer prepareReplicationOperation(Map<String, VectorClock> previouslyReplicatedVectorClocks, int targetIndex) {
    HashMap<String, VectorClock> currentVectorClocks = new HashMap<String, VectorClock>();
    HashMap<String, PNCounterImpl> counters = new HashMap<String, PNCounterImpl>();
    Config config = this.nodeEngine.getConfig();
    for (Map.Entry<String, PNCounterImpl> counterEntry : this.counters.entrySet()) {
      String counterName = (String)counterEntry.getKey();
      PNCounterImpl counter = (PNCounterImpl)counterEntry.getValue();
      if (targetIndex >= config.findPNCounterConfig(counterName).getReplicaCount())
        continue; 
      VectorClock counterCurrentVectorClock = counter.getCurrentVectorClock();
      VectorClock counterPreviousVectorClock = (VectorClock)previouslyReplicatedVectorClocks.get(counterName);
      if (counterPreviousVectorClock == null || counterCurrentVectorClock.isAfter(counterPreviousVectorClock))
        counters.put(counterName, counter); 
      currentVectorClocks.put(counterName, counterCurrentVectorClock);
    } 
    return counters.isEmpty() ? null : new CRDTReplicationContainer(new PNCounterReplicationOperation(counters), currentVectorClocks);
  }
  
  public String getName() { return "hz:impl:PNCounterService"; }
  
  public void merge(String name, PNCounterImpl value) {
    PNCounterImpl counter = getCounter(name);
    counter.merge(value);
    long counterValue = counter.get(null).getValue();
    getLocalPNCounterStats(name).setValue(counterValue);
  }
  
  public CRDTReplicationContainer prepareMigrationOperation(int maxConfiguredReplicaCount) {
    HashMap<String, VectorClock> currentVectorClocks = new HashMap<String, VectorClock>();
    HashMap<String, PNCounterImpl> counters = new HashMap<String, PNCounterImpl>();
    Config config = this.nodeEngine.getConfig();
    for (Map.Entry<String, PNCounterImpl> counterEntry : this.counters.entrySet()) {
      String counterName = (String)counterEntry.getKey();
      PNCounterImpl counter = (PNCounterImpl)counterEntry.getValue();
      if (config.findPNCounterConfig(counterName).getReplicaCount() >= maxConfiguredReplicaCount)
        continue; 
      counters.put(counterName, counter);
      currentVectorClocks.put(counterName, counter.getCurrentVectorClock());
    } 
    return counters.isEmpty() ? null : new CRDTReplicationContainer(new PNCounterReplicationOperation(counters), currentVectorClocks);
  }
  
  public boolean clearCRDTState(Map<String, VectorClock> vectorClocks) {
    boolean allCleared = true;
    for (Map.Entry<String, VectorClock> vectorClockEntry : vectorClocks.entrySet()) {
      String counterName = (String)vectorClockEntry.getKey();
      VectorClock vectorClock = (VectorClock)vectorClockEntry.getValue();
      PNCounterImpl counter = (PNCounterImpl)this.counters.get(counterName);
      if (counter == null)
        continue; 
      if (counter.markMigrated(vectorClock)) {
        this.counters.remove(counterName);
        this.statsMap.remove(counterName);
        continue;
      } 
      allCleared = false;
    } 
    return allCleared;
  }
  
  public void prepareToSafeShutdown() {
    synchronized (this.newCounterCreationMutex) {
      this.isShuttingDown = true;
    } 
    for (PNCounterImpl counter : this.counters.values())
      counter.markMigrated(); 
  }
  
  public String getQuorumName(String name) { return (String)this.quorumConfigCache.getOrCalculate(name); }
  
  public Map<String, LocalPNCounterStats> getStats() { return this.unmodifiableStatsMap; }
}
