package com.hazelcast.crdt.pncounter;

import com.hazelcast.cluster.impl.VectorClock;
import com.hazelcast.cluster.memberselector.MemberSelectors;
import com.hazelcast.core.HazelcastException;
import com.hazelcast.core.Member;
import com.hazelcast.crdt.pncounter.operations.AddOperation;
import com.hazelcast.crdt.pncounter.operations.CRDTTimestampedLong;
import com.hazelcast.crdt.pncounter.operations.GetOperation;
import com.hazelcast.internal.cluster.Versions;
import com.hazelcast.internal.util.ThreadLocalRandomProvider;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.partition.NoDataMemberInClusterException;
import com.hazelcast.spi.AbstractDistributedObject;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.InvocationBuilder;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

public class PNCounterProxy extends AbstractDistributedObject<PNCounterService> implements PNCounter {
  private static final AtomicReferenceFieldUpdater<PNCounterProxy, VectorClock> OBSERVED_TIMESTAMPS_UPDATER = AtomicReferenceFieldUpdater.newUpdater(PNCounterProxy.class, VectorClock.class, "observedClock");
  
  private static final List<Address> EMPTY_ADDRESS_LIST = Collections.emptyList();
  
  private final String name;
  
  private final ILogger logger;
  
  private final Object targetSelectionMutex = new Object();
  
  private int operationTryCount = -1;
  
  PNCounterProxy(String name, NodeEngine nodeEngine, PNCounterService service) {
    super(nodeEngine, service);
    this.name = name;
    this.logger = nodeEngine.getLogger(PNCounterProxy.class);
  }
  
  public String getName() { return this.name; }
  
  public String getServiceName() { return "hz:impl:PNCounterService"; }
  
  public long get() { return invoke(new GetOperation(this.name, this.observedClock)); }
  
  public long getAndAdd(long delta) { return invoke(new AddOperation(this.name, delta, true, this.observedClock)); }
  
  public long addAndGet(long delta) { return invoke(new AddOperation(this.name, delta, false, this.observedClock)); }
  
  public long getAndSubtract(long delta) { return invoke(new AddOperation(this.name, -delta, true, this.observedClock)); }
  
  public long subtractAndGet(long delta) { return invoke(new AddOperation(this.name, -delta, false, this.observedClock)); }
  
  public long decrementAndGet() { return invoke(new AddOperation(this.name, -1L, false, this.observedClock)); }
  
  public long incrementAndGet() { return invoke(new AddOperation(this.name, 1L, false, this.observedClock)); }
  
  public long getAndDecrement() { return invoke(new AddOperation(this.name, -1L, true, this.observedClock)); }
  
  public long getAndIncrement() { return invoke(new AddOperation(this.name, 1L, true, this.observedClock)); }
  
  public void reset() { this.observedClock = null; }
  
  private long invoke(Operation operation) {
    if (getNodeEngine().getClusterService().getClusterVersion().isLessThan(Versions.V3_10))
      throw new UnsupportedOperationException("PNCounter operations are not supported when cluster version is less than 3.10"); 
    return invokeInternal(operation, EMPTY_ADDRESS_LIST, null);
  }
  
  private long invokeInternal(Operation operation, List<Address> excludedAddresses, HazelcastException lastException) {
    Address target = getCRDTOperationTarget(excludedAddresses);
    if (target == null)
      throw (lastException != null) ? lastException : new NoDataMemberInClusterException("Cannot invoke operations on a CRDT because the cluster does not contain any data members"); 
    try {
      InvocationBuilder builder = getNodeEngine().getOperationService().createInvocationBuilder("hz:impl:PNCounterService", operation, target);
      if (this.operationTryCount > 0)
        builder.setTryCount(this.operationTryCount); 
      InternalCompletableFuture<CRDTTimestampedLong> future = builder.invoke();
      CRDTTimestampedLong result = (CRDTTimestampedLong)future.join();
      updateObservedReplicaTimestamps(result.getVectorClock());
      return result.getValue();
    } catch (HazelcastException e) {
      this.logger.fine("Exception occurred while invoking operation on target " + target + ", choosing different target", e);
      if (excludedAddresses == EMPTY_ADDRESS_LIST)
        excludedAddresses = new ArrayList<Address>(); 
      excludedAddresses.add(target);
      return invokeInternal(operation, excludedAddresses, e);
    } 
  }
  
  private void updateObservedReplicaTimestamps(VectorClock receivedVectorClock) {
    VectorClock currentClock;
    do {
      currentClock = this.observedClock;
      if (currentClock != null && currentClock.isAfter(receivedVectorClock))
        break; 
    } while (!OBSERVED_TIMESTAMPS_UPDATER.compareAndSet(this, currentClock, receivedVectorClock));
  }
  
  private Address getCRDTOperationTarget(List<Address> excludedAddresses) {
    if (this.currentTargetReplicaAddress != null && !excludedAddresses.contains(this.currentTargetReplicaAddress))
      return this.currentTargetReplicaAddress; 
    synchronized (this.targetSelectionMutex) {
      if (this.currentTargetReplicaAddress == null || excludedAddresses.contains(this.currentTargetReplicaAddress))
        this.currentTargetReplicaAddress = chooseTargetReplica(excludedAddresses); 
    } 
    return this.currentTargetReplicaAddress;
  }
  
  private Address chooseTargetReplica(List<Address> excludedAddresses) {
    List<Address> replicaAddresses = getReplicaAddresses(excludedAddresses);
    if (replicaAddresses.isEmpty())
      return null; 
    Address localAddress = getNodeEngine().getLocalMember().getAddress();
    if (replicaAddresses.contains(localAddress))
      return localAddress; 
    int randomReplicaIndex = ThreadLocalRandomProvider.get().nextInt(replicaAddresses.size());
    return (Address)replicaAddresses.get(randomReplicaIndex);
  }
  
  private List<Address> getReplicaAddresses(Collection<Address> excludedAddresses) {
    Collection<Member> dataMembers = getNodeEngine().getClusterService().getMembers(MemberSelectors.DATA_MEMBER_SELECTOR);
    int maxConfiguredReplicaCount = getNodeEngine().getConfig().findPNCounterConfig(this.name).getReplicaCount();
    int currentReplicaCount = Math.min(maxConfiguredReplicaCount, dataMembers.size());
    ArrayList<Address> replicaAddresses = new ArrayList<Address>(currentReplicaCount);
    Iterator<Member> dataMemberIterator = dataMembers.iterator();
    for (int i = 0; i < currentReplicaCount; i++) {
      Address dataMemberAddress = ((Member)dataMemberIterator.next()).getAddress();
      if (!excludedAddresses.contains(dataMemberAddress))
        replicaAddresses.add(dataMemberAddress); 
    } 
    return replicaAddresses;
  }
  
  public Address getCurrentTargetReplicaAddress() { return this.currentTargetReplicaAddress; }
  
  public void setOperationTryCount(int operationTryCount) { this.operationTryCount = operationTryCount; }
  
  public String toString() { return "PNCounter{name='" + this.name + "'}"; }
}
