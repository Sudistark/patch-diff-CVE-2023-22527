package com.hazelcast.internal.journal;

import com.hazelcast.config.EventJournalConfig;
import com.hazelcast.config.RingbufferConfig;
import com.hazelcast.ringbuffer.impl.ReadResultSetImpl;
import com.hazelcast.spi.ObjectNamespace;
import com.hazelcast.spi.WaitNotifyKey;

public interface EventJournal<E> {
  long newestSequence(ObjectNamespace paramObjectNamespace, int paramInt);
  
  long oldestSequence(ObjectNamespace paramObjectNamespace, int paramInt);
  
  boolean isPersistenceEnabled(ObjectNamespace paramObjectNamespace, int paramInt);
  
  void destroy(ObjectNamespace paramObjectNamespace, int paramInt);
  
  void isAvailableOrNextSequence(ObjectNamespace paramObjectNamespace, int paramInt, long paramLong);
  
  boolean isNextAvailableSequence(ObjectNamespace paramObjectNamespace, int paramInt, long paramLong);
  
  WaitNotifyKey getWaitNotifyKey(ObjectNamespace paramObjectNamespace, int paramInt);
  
  <T> long readMany(ObjectNamespace paramObjectNamespace, int paramInt, long paramLong, ReadResultSetImpl<E, T> paramReadResultSetImpl);
  
  void cleanup(ObjectNamespace paramObjectNamespace, int paramInt);
  
  boolean hasEventJournal(ObjectNamespace paramObjectNamespace);
  
  EventJournalConfig getEventJournalConfig(ObjectNamespace paramObjectNamespace);
  
  RingbufferConfig toRingbufferConfig(EventJournalConfig paramEventJournalConfig, ObjectNamespace paramObjectNamespace);
}
