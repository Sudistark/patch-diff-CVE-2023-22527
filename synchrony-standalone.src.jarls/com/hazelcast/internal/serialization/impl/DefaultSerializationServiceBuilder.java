package com.hazelcast.internal.serialization.impl;

import com.hazelcast.config.GlobalSerializerConfig;
import com.hazelcast.config.JavaSerializationFilterConfig;
import com.hazelcast.config.SerializationConfig;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.HazelcastInstanceAware;
import com.hazelcast.core.ManagedContext;
import com.hazelcast.core.PartitioningStrategy;
import com.hazelcast.instance.BuildInfoProvider;
import com.hazelcast.internal.memory.GlobalMemoryAccessorRegistry;
import com.hazelcast.internal.serialization.InputOutputFactory;
import com.hazelcast.internal.serialization.InternalSerializationService;
import com.hazelcast.internal.serialization.SerializationServiceBuilder;
import com.hazelcast.internal.serialization.impl.bufferpool.BufferPoolFactoryImpl;
import com.hazelcast.nio.ClassLoaderUtil;
import com.hazelcast.nio.ClassNameFilter;
import com.hazelcast.nio.SerializationClassNameFilter;
import com.hazelcast.nio.serialization.ClassDefinition;
import com.hazelcast.nio.serialization.DataSerializableFactory;
import com.hazelcast.nio.serialization.HazelcastSerializationException;
import com.hazelcast.nio.serialization.PortableFactory;
import com.hazelcast.nio.serialization.Serializer;
import com.hazelcast.nio.serialization.SerializerHook;
import com.hazelcast.spi.properties.GroupProperty;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.StringUtil;
import com.hazelcast.util.function.Supplier;
import java.nio.ByteOrder;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class DefaultSerializationServiceBuilder implements SerializationServiceBuilder {
  static final ByteOrder DEFAULT_BYTE_ORDER = ByteOrder.BIG_ENDIAN;
  
  private static final String BYTE_ORDER_OVERRIDE_PROPERTY = "hazelcast.serialization.byteOrder";
  
  private static final int DEFAULT_OUT_BUFFER_SIZE = 4096;
  
  protected final Map<Integer, DataSerializableFactory> dataSerializableFactories = new HashMap();
  
  protected final Map<Integer, PortableFactory> portableFactories = new HashMap();
  
  protected final Set<ClassDefinition> classDefinitions = new HashSet();
  
  protected ClassLoader classLoader;
  
  protected SerializationConfig config;
  
  protected byte version = -1;
  
  protected int portableVersion = -1;
  
  protected boolean checkClassDefErrors = true;
  
  protected ManagedContext managedContext;
  
  protected boolean useNativeByteOrder;
  
  protected ByteOrder byteOrder = DEFAULT_BYTE_ORDER;
  
  protected boolean enableCompression;
  
  protected boolean enableSharedObject;
  
  protected boolean allowUnsafe;
  
  protected int initialOutputBufferSize = 4096;
  
  protected PartitioningStrategy partitioningStrategy;
  
  protected HazelcastInstance hazelcastInstance;
  
  protected Supplier<RuntimeException> notActiveExceptionSupplier;
  
  protected ClassNameFilter classNameFilter;
  
  public SerializationServiceBuilder setVersion(byte version) {
    byte maxVersion = BuildInfoProvider.getBuildInfo().getSerializationVersion();
    if (version > maxVersion)
      throw new IllegalArgumentException("Configured serialization version is higher than the max supported version: " + maxVersion); 
    this.version = version;
    return this;
  }
  
  public SerializationServiceBuilder setPortableVersion(int portableVersion) {
    if (portableVersion < 0)
      throw new IllegalArgumentException("Portable Version cannot be negative!"); 
    this.portableVersion = portableVersion;
    return this;
  }
  
  public SerializationServiceBuilder setClassLoader(ClassLoader classLoader) {
    this.classLoader = classLoader;
    return this;
  }
  
  public SerializationServiceBuilder setConfig(SerializationConfig config) {
    this.config = config;
    if (this.portableVersion < 0)
      this.portableVersion = config.getPortableVersion(); 
    this.checkClassDefErrors = config.isCheckClassDefErrors();
    this.useNativeByteOrder = config.isUseNativeByteOrder();
    this.byteOrder = config.getByteOrder();
    this.enableCompression = config.isEnableCompression();
    this.enableSharedObject = config.isEnableSharedObject();
    this.allowUnsafe = config.isAllowUnsafe();
    JavaSerializationFilterConfig filterConfig = config.getJavaSerializationFilterConfig();
    this.classNameFilter = (filterConfig == null) ? null : new SerializationClassNameFilter(filterConfig);
    return this;
  }
  
  public SerializationServiceBuilder addDataSerializableFactory(int id, DataSerializableFactory factory) {
    this.dataSerializableFactories.put(Integer.valueOf(id), factory);
    return this;
  }
  
  public SerializationServiceBuilder addPortableFactory(int id, PortableFactory factory) {
    this.portableFactories.put(Integer.valueOf(id), factory);
    return this;
  }
  
  public SerializationServiceBuilder addClassDefinition(ClassDefinition cd) {
    this.classDefinitions.add(cd);
    return this;
  }
  
  public SerializationServiceBuilder setCheckClassDefErrors(boolean checkClassDefErrors) {
    this.checkClassDefErrors = checkClassDefErrors;
    return this;
  }
  
  public SerializationServiceBuilder setManagedContext(ManagedContext managedContext) {
    this.managedContext = managedContext;
    return this;
  }
  
  public SerializationServiceBuilder setUseNativeByteOrder(boolean useNativeByteOrder) {
    this.useNativeByteOrder = useNativeByteOrder;
    return this;
  }
  
  public SerializationServiceBuilder setByteOrder(ByteOrder byteOrder) {
    this.byteOrder = byteOrder;
    return this;
  }
  
  public SerializationServiceBuilder setHazelcastInstance(HazelcastInstance hazelcastInstance) {
    this.hazelcastInstance = hazelcastInstance;
    return this;
  }
  
  public SerializationServiceBuilder setEnableCompression(boolean enableCompression) {
    this.enableCompression = enableCompression;
    return this;
  }
  
  public SerializationServiceBuilder setEnableSharedObject(boolean enableSharedObject) {
    this.enableSharedObject = enableSharedObject;
    return this;
  }
  
  public SerializationServiceBuilder setAllowUnsafe(boolean allowUnsafe) {
    this.allowUnsafe = allowUnsafe;
    return this;
  }
  
  public SerializationServiceBuilder setPartitioningStrategy(PartitioningStrategy partitionStrategy) {
    this.partitioningStrategy = partitionStrategy;
    return this;
  }
  
  public SerializationServiceBuilder setNotActiveExceptionSupplier(Supplier<RuntimeException> notActiveExceptionSupplier) {
    this.notActiveExceptionSupplier = notActiveExceptionSupplier;
    return this;
  }
  
  public SerializationServiceBuilder setInitialOutputBufferSize(int initialOutputBufferSize) {
    if (initialOutputBufferSize <= 0)
      throw new IllegalArgumentException("Initial buffer size must be positive!"); 
    this.initialOutputBufferSize = initialOutputBufferSize;
    return this;
  }
  
  public InternalSerializationService build() {
    initVersions();
    if (this.config != null) {
      addConfigDataSerializableFactories(this.dataSerializableFactories, this.config, this.classLoader);
      addConfigPortableFactories(this.portableFactories, this.config, this.classLoader);
      this.classDefinitions.addAll(this.config.getClassDefinitions());
    } 
    InputOutputFactory inputOutputFactory = createInputOutputFactory();
    InternalSerializationService ss = createSerializationService(inputOutputFactory, this.notActiveExceptionSupplier);
    registerSerializerHooks(ss);
    if (this.config != null && 
      this.config.getGlobalSerializerConfig() != null) {
      GlobalSerializerConfig globalSerializerConfig = this.config.getGlobalSerializerConfig();
      Serializer serializer = globalSerializerConfig.getImplementation();
      if (serializer == null)
        try {
          serializer = (Serializer)ClassLoaderUtil.newInstance(this.classLoader, globalSerializerConfig.getClassName());
        } catch (Exception e) {
          throw new HazelcastSerializationException(e);
        }  
      if (serializer instanceof HazelcastInstanceAware)
        ((HazelcastInstanceAware)serializer).setHazelcastInstance(this.hazelcastInstance); 
      ((AbstractSerializationService)ss)
        .registerGlobal(serializer, globalSerializerConfig.isOverrideJavaSerialization());
    } 
    return ss;
  }
  
  private void initVersions() {
    if (this.version < 0) {
      String defaultVal = GroupProperty.SERIALIZATION_VERSION.getDefaultValue();
      byte versionCandidate = Byte.parseByte(System.getProperty(GroupProperty.SERIALIZATION_VERSION.getName(), defaultVal));
      byte maxVersion = Byte.parseByte(defaultVal);
      if (versionCandidate > maxVersion)
        throw new IllegalArgumentException("Configured serialization version is higher than the max supported version: " + maxVersion); 
      this.version = versionCandidate;
    } 
    if (this.portableVersion < 0)
      this.portableVersion = 0; 
  }
  
  protected InternalSerializationService createSerializationService(InputOutputFactory inputOutputFactory, Supplier<RuntimeException> notActiveExceptionSupplier) {
    SerializationServiceV1 serializationServiceV1;
    switch (this.version) {
      case 1:
        serializationServiceV1 = ((SerializationServiceV1.Builder)((SerializationServiceV1.Builder)((SerializationServiceV1.Builder)((SerializationServiceV1.Builder)((SerializationServiceV1.Builder)((SerializationServiceV1.Builder)((SerializationServiceV1.Builder)((SerializationServiceV1.Builder)((SerializationServiceV1.Builder)((SerializationServiceV1.Builder)((SerializationServiceV1.Builder)((SerializationServiceV1.Builder)((SerializationServiceV1.Builder)((SerializationServiceV1.Builder)SerializationServiceV1.builder().withInputOutputFactory(inputOutputFactory)).withVersion(this.version)).withPortableVersion(this.portableVersion)).withClassLoader(this.classLoader)).withDataSerializableFactories(this.dataSerializableFactories)).withPortableFactories(this.portableFactories)).withManagedContext(this.managedContext)).withGlobalPartitionStrategy(this.partitioningStrategy)).withInitialOutputBufferSize(this.initialOutputBufferSize)).withBufferPoolFactory(new BufferPoolFactoryImpl())).withEnableCompression(this.enableCompression)).withEnableSharedObject(this.enableSharedObject)).withNotActiveExceptionSupplier(notActiveExceptionSupplier)).withClassNameFilter(this.classNameFilter)).build();
        serializationServiceV1.registerClassDefinitions(this.classDefinitions, this.checkClassDefErrors);
        return serializationServiceV1;
    } 
    throw new IllegalArgumentException("Serialization version is not supported!");
  }
  
  private void registerSerializerHooks(InternalSerializationService ss) {
    SerializerHookLoader serializerHookLoader = new SerializerHookLoader(this.config, this.classLoader);
    Map<Class, Object> serializers = serializerHookLoader.getSerializers();
    for (Map.Entry<Class, Object> entry : serializers.entrySet()) {
      Serializer serializer;
      Class serializationType = (Class)entry.getKey();
      Object value = entry.getValue();
      if (value instanceof SerializerHook) {
        serializer = ((SerializerHook)value).createSerializer();
      } else {
        serializer = (Serializer)value;
      } 
      if (value instanceof HazelcastInstanceAware)
        ((HazelcastInstanceAware)value).setHazelcastInstance(this.hazelcastInstance); 
      if (ClassLoaderUtil.isInternalType(value.getClass())) {
        ((AbstractSerializationService)ss).safeRegister(serializationType, serializer);
        continue;
      } 
      ((AbstractSerializationService)ss).register(serializationType, serializer);
    } 
  }
  
  protected InputOutputFactory createInputOutputFactory() {
    overrideByteOrder();
    if (this.byteOrder == null)
      this.byteOrder = DEFAULT_BYTE_ORDER; 
    if (this.useNativeByteOrder)
      this.byteOrder = ByteOrder.nativeOrder(); 
    return (this.byteOrder == ByteOrder.nativeOrder() && this.allowUnsafe && GlobalMemoryAccessorRegistry.MEM_AVAILABLE) ? new UnsafeInputOutputFactory() : new ByteArrayInputOutputFactory(this.byteOrder);
  }
  
  protected void overrideByteOrder() {
    String byteOrderOverride = System.getProperty("hazelcast.serialization.byteOrder");
    if (StringUtil.isNullOrEmpty(byteOrderOverride))
      return; 
    if (ByteOrder.BIG_ENDIAN.toString().equals(byteOrderOverride)) {
      this.byteOrder = ByteOrder.BIG_ENDIAN;
    } else if (ByteOrder.LITTLE_ENDIAN.toString().equals(byteOrderOverride)) {
      this.byteOrder = ByteOrder.LITTLE_ENDIAN;
    } 
  }
  
  private void addConfigDataSerializableFactories(Map<Integer, DataSerializableFactory> dataSerializableFactories, SerializationConfig config, ClassLoader cl) {
    registerDataSerializableFactories(dataSerializableFactories, config);
    buildDataSerializableFactories(dataSerializableFactories, config, cl);
    for (DataSerializableFactory f : dataSerializableFactories.values()) {
      if (f instanceof HazelcastInstanceAware)
        ((HazelcastInstanceAware)f).setHazelcastInstance(this.hazelcastInstance); 
    } 
  }
  
  private void registerDataSerializableFactories(Map<Integer, DataSerializableFactory> dataSerializableFactories, SerializationConfig config) {
    for (Map.Entry<Integer, DataSerializableFactory> entry : config.getDataSerializableFactories().entrySet()) {
      int factoryId = ((Integer)entry.getKey()).intValue();
      DataSerializableFactory factory = (DataSerializableFactory)entry.getValue();
      if (factoryId <= 0)
        throw new IllegalArgumentException("DataSerializableFactory factoryId must be positive! -> " + factory); 
      if (dataSerializableFactories.containsKey(Integer.valueOf(factoryId)))
        throw new IllegalArgumentException("DataSerializableFactory with factoryId '" + factoryId + "' is already registered!"); 
      dataSerializableFactories.put(Integer.valueOf(factoryId), factory);
    } 
  }
  
  private void buildDataSerializableFactories(Map<Integer, DataSerializableFactory> dataSerializableFactories, SerializationConfig config, ClassLoader cl) {
    for (Map.Entry<Integer, String> entry : config.getDataSerializableFactoryClasses().entrySet()) {
      DataSerializableFactory factory;
      int factoryId = ((Integer)entry.getKey()).intValue();
      String factoryClassName = (String)entry.getValue();
      if (factoryId <= 0)
        throw new IllegalArgumentException("DataSerializableFactory factoryId must be positive! -> " + factoryClassName); 
      if (dataSerializableFactories.containsKey(Integer.valueOf(factoryId)))
        throw new IllegalArgumentException("DataSerializableFactory with factoryId '" + factoryId + "' is already registered!"); 
      try {
        factory = (DataSerializableFactory)ClassLoaderUtil.newInstance(cl, factoryClassName);
      } catch (Exception e) {
        throw new HazelcastSerializationException(e);
      } 
      dataSerializableFactories.put(Integer.valueOf(factoryId), factory);
    } 
  }
  
  private void addConfigPortableFactories(Map<Integer, PortableFactory> portableFactories, SerializationConfig config, ClassLoader cl) {
    registerPortableFactories(portableFactories, config);
    buildPortableFactories(portableFactories, config, cl);
    for (PortableFactory f : portableFactories.values()) {
      if (f instanceof HazelcastInstanceAware)
        ((HazelcastInstanceAware)f).setHazelcastInstance(this.hazelcastInstance); 
    } 
  }
  
  private void registerPortableFactories(Map<Integer, PortableFactory> portableFactories, SerializationConfig config) {
    for (Map.Entry<Integer, PortableFactory> entry : config.getPortableFactories().entrySet()) {
      int factoryId = ((Integer)entry.getKey()).intValue();
      PortableFactory factory = (PortableFactory)entry.getValue();
      if (factoryId <= 0)
        throw new IllegalArgumentException("PortableFactory factoryId must be positive! -> " + factory); 
      if (portableFactories.containsKey(Integer.valueOf(factoryId)))
        throw new IllegalArgumentException("PortableFactory with factoryId '" + factoryId + "' is already registered!"); 
      portableFactories.put(Integer.valueOf(factoryId), factory);
    } 
  }
  
  private void buildPortableFactories(Map<Integer, PortableFactory> portableFactories, SerializationConfig config, ClassLoader cl) {
    Map<Integer, String> portableFactoryClasses = config.getPortableFactoryClasses();
    for (Map.Entry<Integer, String> entry : portableFactoryClasses.entrySet()) {
      PortableFactory factory;
      int factoryId = ((Integer)entry.getKey()).intValue();
      String factoryClassName = (String)entry.getValue();
      if (factoryId <= 0)
        throw new IllegalArgumentException("PortableFactory factoryId must be positive! -> " + factoryClassName); 
      if (portableFactories.containsKey(Integer.valueOf(factoryId)))
        throw new IllegalArgumentException("PortableFactory with factoryId '" + factoryId + "' is already registered!"); 
      try {
        factory = (PortableFactory)ClassLoaderUtil.newInstance(cl, factoryClassName);
      } catch (Exception e) {
        throw new HazelcastSerializationException(e);
      } 
      portableFactories.put(Integer.valueOf(factoryId), factory);
    } 
  }
}
