package com.hazelcast.internal.serialization.impl;

import com.hazelcast.core.ManagedContext;
import com.hazelcast.internal.serialization.InternalSerializationService;
import com.hazelcast.internal.serialization.PortableContext;
import com.hazelcast.nio.BufferObjectDataInput;
import com.hazelcast.nio.serialization.ClassDefinition;
import com.hazelcast.nio.serialization.ClassDefinitionBuilder;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.nio.serialization.FieldDefinition;
import com.hazelcast.nio.serialization.FieldType;
import com.hazelcast.nio.serialization.Portable;
import com.hazelcast.query.impl.getters.ExtractorHelper;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import java.io.IOException;
import java.nio.ByteOrder;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Pattern;

final class PortableContextImpl implements PortableContext {
  private static final Pattern NESTED_FIELD_PATTERN = Pattern.compile("\\.");
  
  private final int version;
  
  private final ConcurrentHashMap<Integer, ClassDefinitionContext> classDefContextMap;
  
  private final InternalSerializationService serializationService;
  
  private final ConstructorFunction<Integer, ClassDefinitionContext> constructorFunction;
  
  PortableContextImpl(InternalSerializationService serializationService, int version) {
    this.classDefContextMap = new ConcurrentHashMap();
    this.constructorFunction = new Object(this);
    this.serializationService = serializationService;
    this.version = version;
  }
  
  public int getClassVersion(int factoryId, int classId) { return getClassDefContext(factoryId).getClassVersion(classId); }
  
  public void setClassVersion(int factoryId, int classId, int version) { getClassDefContext(factoryId).setClassVersion(classId, version); }
  
  public ClassDefinition lookupClassDefinition(int factoryId, int classId, int version) { return getClassDefContext(factoryId).lookup(classId, version); }
  
  public ClassDefinition lookupClassDefinition(Data data) throws IOException {
    if (!data.isPortable())
      throw new IllegalArgumentException("Data is not Portable!"); 
    BufferObjectDataInput in = this.serializationService.createObjectDataInput(data);
    int factoryId = in.readInt();
    int classId = in.readInt();
    int version = in.readInt();
    ClassDefinition classDefinition = lookupClassDefinition(factoryId, classId, version);
    if (classDefinition == null)
      classDefinition = readClassDefinition(in, factoryId, classId, version); 
    return classDefinition;
  }
  
  ClassDefinition readClassDefinition(BufferObjectDataInput in, int factoryId, int classId, int version) throws IOException {
    boolean register = true;
    ClassDefinitionBuilder builder = new ClassDefinitionBuilder(factoryId, classId, version);
    in.readInt();
    int fieldCount = in.readInt();
    int offset = in.position();
    for (int i = 0; i < fieldCount; i++) {
      int pos = in.readInt(offset + i * 4);
      in.position(pos);
      short len = in.readShort();
      char[] chars = new char[len];
      for (int k = 0; k < len; k++)
        chars[k] = (char)in.readUnsignedByte(); 
      FieldType type = FieldType.get(in.readByte());
      String name = new String(chars);
      int fieldFactoryId = 0;
      int fieldClassId = 0;
      int fieldVersion = version;
      if (type == FieldType.PORTABLE) {
        if (in.readBoolean())
          register = false; 
        fieldFactoryId = in.readInt();
        fieldClassId = in.readInt();
        if (register) {
          fieldVersion = in.readInt();
          readClassDefinition(in, fieldFactoryId, fieldClassId, fieldVersion);
        } 
      } else if (type == FieldType.PORTABLE_ARRAY) {
        int k = in.readInt();
        fieldFactoryId = in.readInt();
        fieldClassId = in.readInt();
        if (k > 0) {
          int p = in.readInt();
          in.position(p);
          fieldVersion = in.readInt();
          readClassDefinition(in, fieldFactoryId, fieldClassId, fieldVersion);
        } else {
          register = false;
        } 
      } 
      builder.addField(new FieldDefinitionImpl(i, name, type, fieldFactoryId, fieldClassId, fieldVersion));
    } 
    ClassDefinition classDefinition = builder.build();
    if (register)
      classDefinition = registerClassDefinition(classDefinition); 
    return classDefinition;
  }
  
  public ClassDefinition registerClassDefinition(ClassDefinition cd) { return getClassDefContext(cd.getFactoryId()).register(cd); }
  
  public ClassDefinition lookupOrRegisterClassDefinition(Portable p) throws IOException {
    int portableVersion = SerializationUtil.getPortableVersion(p, this.version);
    ClassDefinition cd = lookupClassDefinition(p.getFactoryId(), p.getClassId(), portableVersion);
    if (cd == null) {
      ClassDefinitionWriter writer = new ClassDefinitionWriter(this, p.getFactoryId(), p.getClassId(), portableVersion);
      p.writePortable(writer);
      cd = writer.registerAndGet();
    } 
    return cd;
  }
  
  public FieldDefinition getFieldDefinition(ClassDefinition classDef, String name) {
    FieldDefinition fd = classDef.getField(name);
    if (fd == null)
      if (name.contains(".")) {
        String[] fieldNames = NESTED_FIELD_PATTERN.split(name);
        if (fieldNames.length <= 1)
          return fd; 
        ClassDefinition currentClassDef = classDef;
        for (int i = 0; i < fieldNames.length; i++) {
          fd = currentClassDef.getField(fieldNames[i]);
          if (fd == null)
            fd = currentClassDef.getField(ExtractorHelper.extractAttributeNameNameWithoutArguments(fieldNames[i])); 
          if (i == fieldNames.length - 1)
            break; 
          if (fd == null)
            throw new IllegalArgumentException("Unknown field: " + name); 
          currentClassDef = lookupClassDefinition(fd.getFactoryId(), fd.getClassId(), fd
              .getVersion());
          if (currentClassDef == null)
            throw new IllegalArgumentException("Not a registered Portable field: " + fd); 
        } 
      } else {
        fd = classDef.getField(ExtractorHelper.extractAttributeNameNameWithoutArguments(name));
      }  
    return fd;
  }
  
  private ClassDefinitionContext getClassDefContext(int factoryId) { return (ClassDefinitionContext)ConcurrencyUtil.getOrPutIfAbsent(this.classDefContextMap, Integer.valueOf(factoryId), this.constructorFunction); }
  
  public int getVersion() { return this.version; }
  
  public ManagedContext getManagedContext() { return this.serializationService.getManagedContext(); }
  
  public ByteOrder getByteOrder() { return this.serializationService.getByteOrder(); }
}
