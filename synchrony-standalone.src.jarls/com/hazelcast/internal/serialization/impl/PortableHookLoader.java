package com.hazelcast.internal.serialization.impl;

import com.hazelcast.internal.serialization.PortableHook;
import com.hazelcast.logging.Logger;
import com.hazelcast.nio.serialization.ClassDefinition;
import com.hazelcast.nio.serialization.PortableFactory;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.ServiceLoader;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;

final class PortableHookLoader {
  private static final String FACTORY_ID = "com.hazelcast.PortableHook";
  
  private final Map<Integer, ? extends PortableFactory> configuredFactories;
  
  private final Map<Integer, PortableFactory> factories;
  
  private final Collection<ClassDefinition> definitions;
  
  private final ClassLoader classLoader;
  
  PortableHookLoader(Map<Integer, ? extends PortableFactory> configuredFactories, ClassLoader classLoader) {
    this.factories = new HashMap();
    this.definitions = new HashSet();
    this.configuredFactories = configuredFactories;
    this.classLoader = classLoader;
    load();
  }
  
  private void load() {
    try {
      Iterator<PortableHook> hooks = ServiceLoader.iterator(PortableHook.class, "com.hazelcast.PortableHook", this.classLoader);
      while (hooks.hasNext()) {
        PortableHook hook = (PortableHook)hooks.next();
        PortableFactory factory = hook.createFactory();
        if (factory != null)
          register(hook.getFactoryId(), factory); 
        Collection<ClassDefinition> defs = hook.getBuiltinDefinitions();
        if (defs != null && !defs.isEmpty())
          this.definitions.addAll(defs); 
      } 
    } catch (Exception e) {
      throw ExceptionUtil.rethrow(e);
    } 
    if (this.configuredFactories != null)
      for (Map.Entry<Integer, ? extends PortableFactory> entry : this.configuredFactories.entrySet())
        register(((Integer)entry.getKey()).intValue(), (PortableFactory)entry.getValue());  
  }
  
  Map<Integer, PortableFactory> getFactories() { return this.factories; }
  
  Collection<ClassDefinition> getDefinitions() { return this.definitions; }
  
  private void register(int factoryId, PortableFactory factory) {
    PortableFactory current = (PortableFactory)this.factories.get(Integer.valueOf(factoryId));
    if (current != null) {
      if (current.equals(factory)) {
        Logger.getLogger(getClass()).warning("PortableFactory[" + factoryId + "] is already registered! Skipping " + factory);
      } else {
        throw new IllegalArgumentException("PortableFactory[" + factoryId + "] is already registered! " + current + " -> " + factory);
      } 
    } else {
      this.factories.put(Integer.valueOf(factoryId), factory);
    } 
  }
}
