package com.hazelcast.internal.serialization.impl;

import com.hazelcast.core.PartitioningStrategy;
import com.hazelcast.internal.serialization.PortableContext;
import com.hazelcast.nio.BufferObjectDataInput;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.serialization.ClassDefinition;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.nio.serialization.DataType;
import com.hazelcast.nio.serialization.FieldDefinition;
import com.hazelcast.nio.serialization.FieldType;
import com.hazelcast.nio.serialization.HazelcastSerializationException;
import com.hazelcast.nio.serialization.PortableReader;
import com.hazelcast.util.MapUtil;
import java.io.IOException;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class SerializationServiceV1 extends AbstractSerializationService {
  private static final int FACTORY_AND_CLASS_ID_BYTE_LENGTH = 8;
  
  private static final int EE_BYTE_LENGTH = 2;
  
  private final PortableContextImpl portableContext;
  
  private final PortableSerializer portableSerializer;
  
  SerializationServiceV1(AbstractBuilder<?> builder) {
    super(builder);
    PortableHookLoader loader = new PortableHookLoader(AbstractBuilder.access$000(builder), builder.getClassLoader());
    this.portableContext = new PortableContextImpl(this, AbstractBuilder.access$100(builder));
    for (ClassDefinition cd : loader.getDefinitions())
      this.portableContext.registerClassDefinition(cd); 
    this.dataSerializerAdapter = SerializationUtil.createSerializerAdapter(new DataSerializableSerializer(
          AbstractBuilder.access$200(builder), builder.getClassLoader()), this);
    this.portableSerializer = new PortableSerializer(this.portableContext, loader.getFactories());
    this.portableSerializerAdapter = SerializationUtil.createSerializerAdapter(this.portableSerializer, this);
    this.javaSerializerAdapter = SerializationUtil.createSerializerAdapter(new JavaDefaultSerializers.JavaSerializer(
          AbstractBuilder.access$300(builder), AbstractBuilder.access$400(builder), AbstractBuilder.access$500(builder)), this);
    this.javaExternalizableAdapter = SerializationUtil.createSerializerAdapter(new JavaDefaultSerializers.ExternalizableSerializer(
          AbstractBuilder.access$400(builder), AbstractBuilder.access$500(builder)), this);
    registerConstantSerializers();
    registerJavaTypeSerializers();
  }
  
  public <B extends Data> B toData(Object obj, DataType type) {
    if (type == DataType.NATIVE)
      throw new IllegalArgumentException("Native data type is not supported"); 
    return (B)toData(obj);
  }
  
  public <B extends Data> B toData(Object obj, DataType type, PartitioningStrategy strategy) {
    if (type == DataType.NATIVE)
      throw new IllegalArgumentException("Native data type is not supported"); 
    return (B)toData(obj, strategy);
  }
  
  public <B extends Data> B convertData(Data data, DataType type) {
    if (type == DataType.NATIVE)
      throw new IllegalArgumentException("Native data type is not supported"); 
    return (B)data;
  }
  
  public PortableReader createPortableReader(Data data) throws IOException {
    if (!data.isPortable())
      throw new IllegalArgumentException("Given data is not Portable! -> " + data.getType()); 
    BufferObjectDataInput in = createObjectDataInput(data);
    return this.portableSerializer.createReader(in);
  }
  
  public PortableContext getPortableContext() { return this.portableContext; }
  
  private void registerConstantSerializers() {
    registerConstant(null, this.nullSerializerAdapter);
    registerConstant(com.hazelcast.nio.serialization.DataSerializable.class, this.dataSerializerAdapter);
    registerConstant(com.hazelcast.nio.serialization.Portable.class, this.portableSerializerAdapter);
    registerConstant(Byte.class, new ConstantSerializers.ByteSerializer());
    registerConstant(Boolean.class, new ConstantSerializers.BooleanSerializer());
    registerConstant(Character.class, new ConstantSerializers.CharSerializer());
    registerConstant(Short.class, new ConstantSerializers.ShortSerializer());
    registerConstant(Integer.class, new ConstantSerializers.IntegerSerializer());
    registerConstant(Long.class, new ConstantSerializers.LongSerializer());
    registerConstant(Float.class, new ConstantSerializers.FloatSerializer());
    registerConstant(Double.class, new ConstantSerializers.DoubleSerializer());
    registerConstant(String.class, new ConstantSerializers.StringSerializer());
    registerConstant(byte[].class, new ConstantSerializers.TheByteArraySerializer());
    registerConstant(boolean[].class, new ConstantSerializers.BooleanArraySerializer());
    registerConstant(char[].class, new ConstantSerializers.CharArraySerializer());
    registerConstant(short[].class, new ConstantSerializers.ShortArraySerializer());
    registerConstant(int[].class, new ConstantSerializers.IntegerArraySerializer());
    registerConstant(long[].class, new ConstantSerializers.LongArraySerializer());
    registerConstant(float[].class, new ConstantSerializers.FloatArraySerializer());
    registerConstant(double[].class, new ConstantSerializers.DoubleArraySerializer());
    registerConstant(String[].class, new ConstantSerializers.StringArraySerializer());
  }
  
  private void registerJavaTypeSerializers() {
    registerConstant(java.util.Date.class, new JavaDefaultSerializers.DateSerializer());
    registerConstant(java.math.BigInteger.class, new JavaDefaultSerializers.BigIntegerSerializer());
    registerConstant(java.math.BigDecimal.class, new JavaDefaultSerializers.BigDecimalSerializer());
    registerConstant(Class.class, new JavaDefaultSerializers.ClassSerializer());
    registerConstant(Enum.class, new JavaDefaultSerializers.EnumSerializer());
    registerConstant(java.util.ArrayList.class, new ArrayListStreamSerializer());
    registerConstant(java.util.LinkedList.class, new LinkedListStreamSerializer());
    safeRegister(java.io.Serializable.class, this.javaSerializerAdapter);
    safeRegister(java.io.Externalizable.class, this.javaExternalizableAdapter);
    safeRegister(com.hazelcast.core.HazelcastJsonValue.class, new JavaDefaultSerializers.HazelcastJsonValueSerializer());
  }
  
  public void registerClassDefinitions(Collection<ClassDefinition> classDefinitions, boolean checkClassDefErrors) {
    Map<Integer, Map<Integer, ClassDefinition>> factoryMap = MapUtil.createHashMap(classDefinitions.size());
    for (ClassDefinition cd : classDefinitions) {
      int factoryId = cd.getFactoryId();
      Map<Integer, ClassDefinition> classDefMap = (Map)factoryMap.get(Integer.valueOf(factoryId));
      if (classDefMap == null) {
        classDefMap = new HashMap<Integer, ClassDefinition>();
        factoryMap.put(Integer.valueOf(factoryId), classDefMap);
      } 
      int classId = cd.getClassId();
      if (classDefMap.containsKey(Integer.valueOf(classId)))
        throw new HazelcastSerializationException("Duplicate registration found for factory-id : " + factoryId + ", class-id " + classId); 
      classDefMap.put(Integer.valueOf(classId), cd);
    } 
    for (ClassDefinition classDefinition : classDefinitions)
      registerClassDefinition(classDefinition, factoryMap, checkClassDefErrors); 
  }
  
  private void registerClassDefinition(ClassDefinition cd, Map<Integer, Map<Integer, ClassDefinition>> factoryMap, boolean checkClassDefErrors) {
    Set<String> fieldNames = cd.getFieldNames();
    for (String fieldName : fieldNames) {
      FieldDefinition fd = cd.getField(fieldName);
      if (fd.getType() == FieldType.PORTABLE || fd.getType() == FieldType.PORTABLE_ARRAY) {
        int factoryId = fd.getFactoryId();
        int classId = fd.getClassId();
        Map<Integer, ClassDefinition> classDefinitionMap = (Map)factoryMap.get(Integer.valueOf(factoryId));
        if (classDefinitionMap != null) {
          ClassDefinition nestedCd = (ClassDefinition)classDefinitionMap.get(Integer.valueOf(classId));
          if (nestedCd != null) {
            registerClassDefinition(nestedCd, factoryMap, checkClassDefErrors);
            this.portableContext.registerClassDefinition(nestedCd);
            continue;
          } 
        } 
        if (checkClassDefErrors)
          throw new HazelcastSerializationException("Could not find registered ClassDefinition for factory-id : " + factoryId + ", class-id " + classId); 
      } 
    } 
    this.portableContext.registerClassDefinition(cd);
  }
  
  final PortableSerializer getPortableSerializer() { return this.portableSerializer; }
  
  public ObjectDataInput initDataSerializableInputAndSkipTheHeader(Data data) throws IOException {
    BufferObjectDataInput bufferObjectDataInput = createObjectDataInput(data);
    byte header = bufferObjectDataInput.readByte();
    if (DataSerializableSerializer.isFlagSet(header, (byte)1)) {
      skipBytesSafely(bufferObjectDataInput, 8);
    } else {
      bufferObjectDataInput.readUTF();
    } 
    if (DataSerializableSerializer.isFlagSet(header, (byte)2))
      skipBytesSafely(bufferObjectDataInput, 2); 
    return bufferObjectDataInput;
  }
  
  public static Builder builder() { return new Builder(); }
  
  private void skipBytesSafely(ObjectDataInput input, int count) throws IOException {
    if (input.skipBytes(count) != count)
      throw new HazelcastSerializationException("Malformed serialization format"); 
  }
}
