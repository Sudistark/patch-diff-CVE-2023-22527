package com.hazelcast.internal.serialization.impl;

import com.hazelcast.nio.BufferObjectDataInput;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.serialization.ClassDefinition;
import com.hazelcast.nio.serialization.FieldType;
import com.hazelcast.nio.serialization.HazelcastSerializationException;
import com.hazelcast.nio.serialization.Portable;
import com.hazelcast.nio.serialization.PortableReader;
import com.hazelcast.query.extractor.ValueCallback;
import com.hazelcast.query.extractor.ValueCollector;
import com.hazelcast.query.extractor.ValueReader;
import com.hazelcast.query.extractor.ValueReadingException;
import com.hazelcast.query.impl.getters.ImmutableMultiResult;
import com.hazelcast.query.impl.getters.MultiResult;
import java.io.IOException;
import java.util.List;
import java.util.Set;

public class DefaultPortableReader extends ValueReader implements PortableReader {
  private static final MultiResult NULL_EMPTY_TARGET_MULTIRESULT;
  
  protected final ClassDefinition cd;
  
  protected final PortableSerializer serializer;
  
  private final BufferObjectDataInput in;
  
  private final int finalPosition;
  
  private final int offset;
  
  private final PortableNavigatorContext ctx;
  
  private final PortablePathCursor pathCursor;
  
  private boolean raw;
  
  static  {
    result = new MultiResult();
    result.addNullOrEmptyTarget();
    NULL_EMPTY_TARGET_MULTIRESULT = new ImmutableMultiResult(result);
  }
  
  DefaultPortableReader(PortableSerializer serializer, BufferObjectDataInput in, ClassDefinition cd) {
    this.in = in;
    this.serializer = serializer;
    this.cd = cd;
    this.ctx = new PortableNavigatorContext(in, cd, serializer);
    this.pathCursor = new PortablePathCursor();
    this.finalPosition = this.ctx.getCurrentFinalPosition();
    this.offset = this.ctx.getCurrentOffset();
  }
  
  public int getVersion() { return this.cd.getVersion(); }
  
  public boolean hasField(String fieldName) { return this.cd.hasField(fieldName); }
  
  public Set<String> getFieldNames() { return this.cd.getFieldNames(); }
  
  public FieldType getFieldType(String fieldName) { return this.cd.getFieldType(fieldName); }
  
  public int getFieldClassId(String fieldName) { return this.cd.getFieldClassId(fieldName); }
  
  public ObjectDataInput getRawDataInput() throws IOException {
    if (!this.raw) {
      int pos = this.in.readInt(this.offset + this.cd.getFieldCount() * 4);
      this.in.position(pos);
    } 
    this.raw = true;
    return this.in;
  }
  
  final void end() { this.in.position(this.finalPosition); }
  
  public byte readByte(String path) throws IOException {
    PortablePosition pos = findPositionForReading(path);
    validatePrimitive(pos, FieldType.BYTE);
    return this.in.readByte(pos.getStreamPosition());
  }
  
  public short readShort(String path) throws IOException {
    PortablePosition pos = findPositionForReading(path);
    validatePrimitive(pos, FieldType.SHORT);
    return this.in.readShort(pos.getStreamPosition());
  }
  
  public int readInt(String path) {
    PortablePosition pos = findPositionForReading(path);
    validatePrimitive(pos, FieldType.INT);
    return this.in.readInt(pos.getStreamPosition());
  }
  
  public long readLong(String path) throws IOException {
    PortablePosition pos = findPositionForReading(path);
    validatePrimitive(pos, FieldType.LONG);
    return this.in.readLong(pos.getStreamPosition());
  }
  
  public float readFloat(String path) throws IOException {
    PortablePosition pos = findPositionForReading(path);
    validatePrimitive(pos, FieldType.FLOAT);
    return this.in.readFloat(pos.getStreamPosition());
  }
  
  public double readDouble(String path) throws IOException {
    PortablePosition pos = findPositionForReading(path);
    validatePrimitive(pos, FieldType.DOUBLE);
    return this.in.readDouble(pos.getStreamPosition());
  }
  
  public boolean readBoolean(String path) {
    PortablePosition pos = findPositionForReading(path);
    validatePrimitive(pos, FieldType.BOOLEAN);
    return this.in.readBoolean(pos.getStreamPosition());
  }
  
  public char readChar(String path) throws IOException {
    PortablePosition pos = findPositionForReading(path);
    validatePrimitive(pos, FieldType.CHAR);
    return this.in.readChar(pos.getStreamPosition());
  }
  
  public String readUTF(String path) throws IOException {
    currentPos = this.in.position();
    try {
      PortablePosition position = findPositionForReading(path);
      if (position.isNullOrEmpty())
        return null; 
      validateNotMultiPosition(position);
      validateType(position, FieldType.UTF);
      this.in.position(position.getStreamPosition());
      return this.in.readUTF();
    } finally {
      this.in.position(currentPos);
    } 
  }
  
  public Portable readPortable(String path) throws IOException {
    currentPos = this.in.position();
    try {
      PortablePosition position = findPositionForReading(path);
      if (position.isNullOrEmpty())
        return null; 
      validateNotMultiPosition(position);
      validateType(position, FieldType.PORTABLE);
      this.in.position(position.getStreamPosition());
      return this.serializer.readAndInitialize(this.in, position.getFactoryId(), position.getClassId());
    } finally {
      this.in.position(currentPos);
    } 
  }
  
  public byte[] readByteArray(String path) throws IOException {
    currentPos = this.in.position();
    try {
      PortablePosition position = findPositionForReading(path);
      if (position.isNullOrEmpty())
        return null; 
      if (position.isMultiPosition())
        return readMultiByteArray(position.asMultiPosition()); 
      return readSingleByteArray(position);
    } finally {
      this.in.position(currentPos);
    } 
  }
  
  private byte[] readMultiByteArray(List<PortablePosition> positions) throws IOException {
    byte[] result = new byte[positions.size()];
    for (int i = 0; i < result.length; i++) {
      PortablePosition position = (PortablePosition)positions.get(i);
      validateNonNullOrEmptyPosition(position);
      validateType(position, FieldType.BYTE);
      result[i] = this.in.readByte(position.getStreamPosition());
    } 
    return result;
  }
  
  private byte[] readSingleByteArray(PortablePosition position) throws IOException {
    validateType(position, FieldType.BYTE_ARRAY);
    this.in.position(position.getStreamPosition());
    return this.in.readByteArray();
  }
  
  public boolean[] readBooleanArray(String path) throws IOException {
    currentPos = this.in.position();
    try {
      PortablePosition position = findPositionForReading(path);
      if (position.isNullOrEmpty())
        return null; 
      if (position.isMultiPosition())
        return readMultiBooleanArray(position.asMultiPosition()); 
      return readSingleBooleanArray(position);
    } finally {
      this.in.position(currentPos);
    } 
  }
  
  private boolean[] readMultiBooleanArray(List<PortablePosition> positions) throws IOException {
    boolean[] result = new boolean[positions.size()];
    for (int i = 0; i < result.length; i++) {
      PortablePosition position = (PortablePosition)positions.get(i);
      validateNonNullOrEmptyPosition(position);
      validateType(position, FieldType.BOOLEAN);
      result[i] = this.in.readBoolean(position.getStreamPosition());
    } 
    return result;
  }
  
  private boolean[] readSingleBooleanArray(PortablePosition position) throws IOException {
    validateType(position, FieldType.BOOLEAN_ARRAY);
    this.in.position(position.getStreamPosition());
    return this.in.readBooleanArray();
  }
  
  public char[] readCharArray(String path) throws IOException {
    currentPos = this.in.position();
    try {
      PortablePosition position = findPositionForReading(path);
      if (position.isNullOrEmpty())
        return null; 
      if (position.isMultiPosition())
        return readMultiCharArray(position.asMultiPosition()); 
      return readSingleCharArray(position);
    } finally {
      this.in.position(currentPos);
    } 
  }
  
  private char[] readMultiCharArray(List<PortablePosition> positions) throws IOException {
    char[] result = new char[positions.size()];
    for (int i = 0; i < result.length; i++) {
      PortablePosition position = (PortablePosition)positions.get(i);
      validateNonNullOrEmptyPosition(position);
      validateType(position, FieldType.CHAR);
      result[i] = this.in.readChar(position.getStreamPosition());
    } 
    return result;
  }
  
  private char[] readSingleCharArray(PortablePosition position) throws IOException {
    validateType(position, FieldType.CHAR_ARRAY);
    this.in.position(position.getStreamPosition());
    return this.in.readCharArray();
  }
  
  public int[] readIntArray(String path) throws IOException {
    currentPos = this.in.position();
    try {
      PortablePosition position = findPositionForReading(path);
      if (position.isNullOrEmpty())
        return null; 
      if (position.isMultiPosition())
        return readMultiIntArray(position.asMultiPosition()); 
      return readSingleIntArray(position);
    } finally {
      this.in.position(currentPos);
    } 
  }
  
  private int[] readMultiIntArray(List<PortablePosition> positions) throws IOException {
    int[] result = new int[positions.size()];
    for (int i = 0; i < result.length; i++) {
      PortablePosition position = (PortablePosition)positions.get(i);
      validateNonNullOrEmptyPosition(position);
      validateType(position, FieldType.INT);
      result[i] = this.in.readInt(position.getStreamPosition());
    } 
    return result;
  }
  
  private int[] readSingleIntArray(PortablePosition position) throws IOException {
    validateType(position, FieldType.INT_ARRAY);
    this.in.position(position.getStreamPosition());
    return this.in.readIntArray();
  }
  
  public long[] readLongArray(String path) throws IOException {
    currentPos = this.in.position();
    try {
      PortablePosition position = findPositionForReading(path);
      if (position.isNullOrEmpty())
        return null; 
      if (position.isMultiPosition())
        return readMultiLongArray(position.asMultiPosition()); 
      return readSingleLongArray(position);
    } finally {
      this.in.position(currentPos);
    } 
  }
  
  private long[] readMultiLongArray(List<PortablePosition> positions) throws IOException {
    long[] result = new long[positions.size()];
    for (int i = 0; i < result.length; i++) {
      PortablePosition position = (PortablePosition)positions.get(i);
      validateNonNullOrEmptyPosition(position);
      validateType(position, FieldType.LONG);
      result[i] = this.in.readLong(position.getStreamPosition());
    } 
    return result;
  }
  
  private long[] readSingleLongArray(PortablePosition position) throws IOException {
    validateType(position, FieldType.LONG_ARRAY);
    this.in.position(position.getStreamPosition());
    return this.in.readLongArray();
  }
  
  public double[] readDoubleArray(String path) throws IOException {
    currentPos = this.in.position();
    try {
      PortablePosition position = findPositionForReading(path);
      if (position.isNullOrEmpty())
        return null; 
      if (position.isMultiPosition())
        return readMultiDoubleArray(position.asMultiPosition()); 
      return readSingleDoubleArray(position);
    } finally {
      this.in.position(currentPos);
    } 
  }
  
  private double[] readMultiDoubleArray(List<PortablePosition> positions) throws IOException {
    double[] result = new double[positions.size()];
    for (int i = 0; i < result.length; i++) {
      PortablePosition position = (PortablePosition)positions.get(i);
      validateNonNullOrEmptyPosition(position);
      validateType(position, FieldType.DOUBLE);
      result[i] = this.in.readDouble(position.getStreamPosition());
    } 
    return result;
  }
  
  private double[] readSingleDoubleArray(PortablePosition position) throws IOException {
    validateType(position, FieldType.DOUBLE_ARRAY);
    this.in.position(position.getStreamPosition());
    return this.in.readDoubleArray();
  }
  
  public float[] readFloatArray(String path) throws IOException {
    currentPos = this.in.position();
    try {
      PortablePosition position = findPositionForReading(path);
      if (position.isNullOrEmpty())
        return null; 
      if (position.isMultiPosition())
        return readMultiFloatArray(position.asMultiPosition()); 
      return readSingleFloatArray(position);
    } finally {
      this.in.position(currentPos);
    } 
  }
  
  private float[] readMultiFloatArray(List<PortablePosition> positions) throws IOException {
    float[] result = new float[positions.size()];
    for (int i = 0; i < result.length; i++) {
      PortablePosition position = (PortablePosition)positions.get(i);
      validateNonNullOrEmptyPosition(position);
      validateType(position, FieldType.FLOAT);
      result[i] = this.in.readFloat(position.getStreamPosition());
    } 
    return result;
  }
  
  private float[] readSingleFloatArray(PortablePosition position) throws IOException {
    validateType(position, FieldType.FLOAT_ARRAY);
    this.in.position(position.getStreamPosition());
    return this.in.readFloatArray();
  }
  
  public short[] readShortArray(String path) throws IOException {
    currentPos = this.in.position();
    try {
      PortablePosition position = findPositionForReading(path);
      if (position.isNullOrEmpty())
        return null; 
      if (position.isMultiPosition())
        return readMultiShortArray(position.asMultiPosition()); 
      return readSingleShortArray(position);
    } finally {
      this.in.position(currentPos);
    } 
  }
  
  private short[] readMultiShortArray(List<PortablePosition> positions) throws IOException {
    short[] result = new short[positions.size()];
    for (int i = 0; i < result.length; i++) {
      PortablePosition position = (PortablePosition)positions.get(i);
      validateNonNullOrEmptyPosition(position);
      validateType(position, FieldType.SHORT);
      result[i] = this.in.readShort(position.getStreamPosition());
    } 
    return result;
  }
  
  private short[] readSingleShortArray(PortablePosition position) throws IOException {
    validateType(position, FieldType.SHORT_ARRAY);
    this.in.position(position.getStreamPosition());
    return this.in.readShortArray();
  }
  
  public String[] readUTFArray(String path) throws IOException {
    currentPos = this.in.position();
    try {
      PortablePosition position = findPositionForReading(path);
      if (position.isNullOrEmpty())
        return null; 
      if (position.isMultiPosition())
        return readMultiUTFArray(position.asMultiPosition()); 
      return readSingleUTFArray(position);
    } finally {
      this.in.position(currentPos);
    } 
  }
  
  private String[] readMultiUTFArray(List<PortablePosition> positions) throws IOException {
    String[] result = new String[positions.size()];
    for (int i = 0; i < result.length; i++) {
      PortablePosition position = (PortablePosition)positions.get(i);
      if (!position.isNullOrEmpty()) {
        validateType(position, FieldType.UTF);
        this.in.position(position.getStreamPosition());
        result[i] = this.in.readUTF();
      } 
    } 
    return result;
  }
  
  private String[] readSingleUTFArray(PortablePosition position) throws IOException {
    validateType(position, FieldType.UTF_ARRAY);
    this.in.position(position.getStreamPosition());
    return this.in.readUTFArray();
  }
  
  public Portable[] readPortableArray(String fieldName) throws IOException {
    currentPos = this.in.position();
    try {
      PortablePosition position = findPositionForReading(fieldName);
      if (position.isMultiPosition())
        return readMultiPortableArray(position.asMultiPosition()); 
      if (position.isNull())
        return null; 
      if (position.isEmpty() && position.isAny())
        return null; 
      return readSinglePortableArray(position);
    } finally {
      this.in.position(currentPos);
    } 
  }
  
  private Portable[] readSinglePortableArray(PortablePosition position) throws IOException {
    this.in.position(position.getStreamPosition());
    if (position.getLen() == -1)
      return null; 
    validateType(position, FieldType.PORTABLE_ARRAY);
    Portable[] portables = new Portable[position.getLen()];
    for (int index = 0; index < position.getLen(); index++) {
      this.in.position(PortableUtils.getPortableArrayCellPosition(this.in, position.getStreamPosition(), index));
      portables[index] = this.serializer.readAndInitialize(this.in, position.getFactoryId(), position.getClassId());
    } 
    return portables;
  }
  
  private Portable[] readMultiPortableArray(List<PortablePosition> positions) throws IOException {
    Portable[] portables = new Portable[positions.size()];
    for (int i = 0; i < portables.length; i++) {
      PortablePosition position = (PortablePosition)positions.get(i);
      if (!position.isNullOrEmpty()) {
        validateType(position, FieldType.PORTABLE);
        this.in.position(position.getStreamPosition());
        portables[i] = this.serializer.readAndInitialize(this.in, position.getFactoryId(), position.getClassId());
      } 
    } 
    return portables;
  }
  
  public void read(String path, ValueCallback callback) {
    try {
      Object result = read(path);
      if (result instanceof MultiResult) {
        MultiResult multiResult = (MultiResult)result;
        for (Object singleResult : multiResult.getResults())
          callback.onResult(singleResult); 
      } else {
        callback.onResult(result);
      } 
    } catch (IOException e) {
      throw new ValueReadingException(e.getMessage(), e);
    } catch (RuntimeException e) {
      throw new ValueReadingException(e.getMessage(), e);
    } 
  }
  
  public void read(String path, ValueCollector collector) {
    try {
      Object result = read(path);
      if (result instanceof MultiResult) {
        MultiResult multiResult = (MultiResult)result;
        for (Object singleResult : multiResult.getResults())
          collector.addObject(singleResult); 
      } else {
        collector.addObject(result);
      } 
    } catch (IOException e) {
      throw new ValueReadingException(e.getMessage(), e);
    } catch (RuntimeException e) {
      throw new ValueReadingException(e.getMessage(), e);
    } 
  }
  
  public Object read(String path) throws IOException {
    currentPos = this.in.position();
    try {
      PortablePosition position = findPositionForReading(path);
      if (position.isMultiPosition())
        return readMultiPosition(position.asMultiPosition()); 
      if (position.isNull()) {
        if (position.isAny())
          return NULL_EMPTY_TARGET_MULTIRESULT; 
        return null;
      } 
      if (position.isEmpty()) {
        if (position.isLeaf() && position.getType() != null)
          return readSinglePosition(position); 
        if (position.isAny())
          return NULL_EMPTY_TARGET_MULTIRESULT; 
        return null;
      } 
      return readSinglePosition(position);
    } finally {
      this.in.position(currentPos);
    } 
  }
  
  private <T> MultiResult<T> readMultiPosition(List<PortablePosition> positions) throws IOException {
    MultiResult<T> result = new MultiResult<T>();
    for (PortablePosition position : positions) {
      if (!position.isNullOrEmpty()) {
        T read = (T)readSinglePosition(position);
        result.add(read);
        continue;
      } 
      result.addNullOrEmptyTarget();
    } 
    return result;
  }
  
  private <T> T readSinglePosition(PortablePosition position) throws IOException {
    if (position.getIndex() >= 0)
      return (T)readSinglePositionFromArray(position); 
    return (T)readSinglePositionFromNonArray(position);
  }
  
  private PortablePosition findPositionForReading(String path) throws IOException {
    if (this.raw)
      throw new HazelcastSerializationException("Cannot read Portable fields after getRawDataInput() is called!"); 
    try {
      return PortablePositionNavigator.findPositionForReading(this.ctx, path, this.pathCursor);
    } finally {
      this.ctx.reset();
    } 
  }
  
  private <T> T readSinglePositionFromArray(PortablePosition position) throws IOException {
    assert position.getType() != null : "Unsupported type read: null";
    switch (null.$SwitchMap$com$hazelcast$nio$serialization$FieldType[position.getType().ordinal()]) {
      case 1:
      case 2:
        return (T)Byte.valueOf(this.in.readByte(position.getStreamPosition()));
      case 3:
      case 4:
        return (T)Short.valueOf(this.in.readShort(position.getStreamPosition()));
      case 5:
      case 6:
        return (T)Integer.valueOf(this.in.readInt(position.getStreamPosition()));
      case 7:
      case 8:
        return (T)Long.valueOf(this.in.readLong(position.getStreamPosition()));
      case 9:
      case 10:
        return (T)Float.valueOf(this.in.readFloat(position.getStreamPosition()));
      case 11:
      case 12:
        return (T)Double.valueOf(this.in.readDouble(position.getStreamPosition()));
      case 13:
      case 14:
        return (T)Boolean.valueOf(this.in.readBoolean(position.getStreamPosition()));
      case 15:
      case 16:
        return (T)Character.valueOf(this.in.readChar(position.getStreamPosition()));
      case 17:
      case 18:
        this.in.position(position.getStreamPosition());
        return (T)this.in.readUTF();
      case 19:
      case 20:
        this.in.position(position.getStreamPosition());
        return (T)this.serializer.readAndInitialize(this.in, position.getFactoryId(), position.getClassId());
    } 
    throw new IllegalArgumentException("Unsupported type: " + position.getType());
  }
  
  private <T> T readSinglePositionFromNonArray(PortablePosition position) throws IOException {
    assert position.getType() != null : "Unsupported type read: null";
    switch (null.$SwitchMap$com$hazelcast$nio$serialization$FieldType[position.getType().ordinal()]) {
      case 1:
        return (T)Byte.valueOf(this.in.readByte(position.getStreamPosition()));
      case 2:
        return (T)readSingleByteArray(position);
      case 3:
        return (T)Short.valueOf(this.in.readShort(position.getStreamPosition()));
      case 4:
        return (T)readSingleShortArray(position);
      case 5:
        return (T)Integer.valueOf(this.in.readInt(position.getStreamPosition()));
      case 6:
        return (T)readSingleIntArray(position);
      case 7:
        return (T)Long.valueOf(this.in.readLong(position.getStreamPosition()));
      case 8:
        return (T)readSingleLongArray(position);
      case 9:
        return (T)Float.valueOf(this.in.readFloat(position.getStreamPosition()));
      case 10:
        return (T)readSingleFloatArray(position);
      case 11:
        return (T)Double.valueOf(this.in.readDouble(position.getStreamPosition()));
      case 12:
        return (T)readSingleDoubleArray(position);
      case 13:
        return (T)Boolean.valueOf(this.in.readBoolean(position.getStreamPosition()));
      case 14:
        return (T)readSingleBooleanArray(position);
      case 15:
        return (T)Character.valueOf(this.in.readChar(position.getStreamPosition()));
      case 16:
        return (T)readSingleCharArray(position);
      case 17:
        this.in.position(position.getStreamPosition());
        return (T)this.in.readUTF();
      case 18:
        return (T)readSingleUTFArray(position);
      case 19:
        this.in.position(position.getStreamPosition());
        return (T)this.serializer.readAndInitialize(this.in, position.getFactoryId(), position.getClassId());
      case 20:
        return (T)readSinglePortableArray(position);
    } 
    throw new IllegalArgumentException("Unsupported type " + position.getType());
  }
  
  private void validatePrimitive(PortablePosition position, FieldType expectedType) {
    validateNonNullOrEmptyPosition(position);
    validateNotMultiPosition(position);
    validateType(position, expectedType);
  }
  
  private void validateNonNullOrEmptyPosition(PortablePosition position) {
    if (position.isNullOrEmpty())
      throw new IllegalArgumentException("Primitive type cannot be returned since the result is/contains null."); 
  }
  
  private void validateNotMultiPosition(PortablePosition position) {
    if (position.isMultiPosition())
      throw new IllegalArgumentException("The method expected a single result but multiple results have been returned. Did you use the [any] quantifier? If so, use the readArray method family."); 
  }
  
  private void validateType(PortablePosition position, FieldType expectedType) {
    FieldType returnedType = position.getType();
    if (position.getIndex() >= 0)
      returnedType = (returnedType != null) ? returnedType.getSingleType() : null; 
    if (expectedType != returnedType) {
      String name = (returnedType != null) ? returnedType.name() : null;
      throw new IllegalArgumentException("Wrong type read! Actual: " + name + " Expected: " + expectedType.name() + ". Did you use a correct read method? E.g. readInt() for int.");
    } 
  }
}
