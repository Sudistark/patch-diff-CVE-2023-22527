package com.hazelcast.internal.serialization.impl;

import com.hazelcast.internal.memory.GlobalMemoryAccessorRegistry;
import com.hazelcast.internal.memory.HeapMemoryAccessor;
import com.hazelcast.internal.serialization.InternalSerializationService;
import java.io.EOFException;
import java.nio.ByteOrder;

class UnsafeObjectDataInput extends ByteArrayObjectDataInput {
  UnsafeObjectDataInput(byte[] buffer, InternalSerializationService service) { super(buffer, service, ByteOrder.nativeOrder()); }
  
  UnsafeObjectDataInput(byte[] buffer, int offset, InternalSerializationService service) { super(buffer, offset, service, ByteOrder.nativeOrder()); }
  
  public int read() { return (this.pos < this.size) ? (GlobalMemoryAccessorRegistry.MEM.getByte(this.data, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + this.pos++)) & 0xFF) : -1; }
  
  public int read(int position) { return (position < this.size) ? GlobalMemoryAccessorRegistry.MEM.getByte(this.data, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + position)) : -1; }
  
  public char readChar(int position) throws EOFException {
    checkAvailable(position, 2);
    return GlobalMemoryAccessorRegistry.MEM.getChar(this.data, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + position));
  }
  
  public double readDouble() throws EOFException {
    double d = readDouble(this.pos);
    this.pos += 8;
    return d;
  }
  
  public double readDouble(int position) throws EOFException {
    checkAvailable(position, 8);
    return GlobalMemoryAccessorRegistry.MEM.getDouble(this.data, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + position));
  }
  
  public float readFloat() throws EOFException {
    float f = readFloat(this.pos);
    this.pos += 4;
    return f;
  }
  
  public float readFloat(int position) throws EOFException {
    checkAvailable(position, 4);
    return GlobalMemoryAccessorRegistry.MEM.getFloat(this.data, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + position));
  }
  
  public int readInt(int position) {
    checkAvailable(position, 4);
    return GlobalMemoryAccessorRegistry.MEM.getInt(this.data, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + position));
  }
  
  public int readInt(int position, ByteOrder byteOrder) throws EOFException {
    int v = readInt(position);
    if (byteOrder != ByteOrder.nativeOrder())
      v = Integer.reverseBytes(v); 
    return v;
  }
  
  public long readLong(int position) throws EOFException {
    checkAvailable(position, 8);
    return GlobalMemoryAccessorRegistry.MEM.getLong(this.data, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + position));
  }
  
  public long readLong(int position, ByteOrder byteOrder) throws EOFException {
    long v = readLong(position);
    if (byteOrder != ByteOrder.nativeOrder())
      v = Long.reverseBytes(v); 
    return v;
  }
  
  public short readShort(int position) throws EOFException {
    checkAvailable(position, 2);
    return GlobalMemoryAccessorRegistry.MEM.getShort(this.data, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + position));
  }
  
  public short readShort(int position, ByteOrder byteOrder) throws EOFException {
    short v = readShort(position);
    if (byteOrder != ByteOrder.nativeOrder())
      v = Short.reverseBytes(v); 
    return v;
  }
  
  public char[] readCharArray() throws EOFException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      char[] values = new char[len];
      memCopy(values, HeapMemoryAccessor.ARRAY_CHAR_BASE_OFFSET, len, HeapMemoryAccessor.ARRAY_CHAR_INDEX_SCALE);
      return values;
    } 
    return new char[0];
  }
  
  public boolean[] readBooleanArray() throws EOFException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      boolean[] values = new boolean[len];
      memCopy(values, HeapMemoryAccessor.ARRAY_BOOLEAN_BASE_OFFSET, len, HeapMemoryAccessor.ARRAY_BOOLEAN_INDEX_SCALE);
      return values;
    } 
    return new boolean[0];
  }
  
  public byte[] readByteArray() throws EOFException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      byte[] values = new byte[len];
      memCopy(values, HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET, len, HeapMemoryAccessor.ARRAY_BYTE_INDEX_SCALE);
      return values;
    } 
    return new byte[0];
  }
  
  public int[] readIntArray() throws EOFException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      int[] values = new int[len];
      memCopy(values, HeapMemoryAccessor.ARRAY_INT_BASE_OFFSET, len, HeapMemoryAccessor.ARRAY_INT_INDEX_SCALE);
      return values;
    } 
    return new int[0];
  }
  
  public long[] readLongArray() throws EOFException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      long[] values = new long[len];
      memCopy(values, HeapMemoryAccessor.ARRAY_LONG_BASE_OFFSET, len, HeapMemoryAccessor.ARRAY_LONG_INDEX_SCALE);
      return values;
    } 
    return new long[0];
  }
  
  public double[] readDoubleArray() throws EOFException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      double[] values = new double[len];
      memCopy(values, HeapMemoryAccessor.ARRAY_DOUBLE_BASE_OFFSET, len, HeapMemoryAccessor.ARRAY_DOUBLE_INDEX_SCALE);
      return values;
    } 
    return new double[0];
  }
  
  public float[] readFloatArray() throws EOFException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      float[] values = new float[len];
      memCopy(values, HeapMemoryAccessor.ARRAY_FLOAT_BASE_OFFSET, len, HeapMemoryAccessor.ARRAY_FLOAT_INDEX_SCALE);
      return values;
    } 
    return new float[0];
  }
  
  public short[] readShortArray() throws EOFException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      short[] values = new short[len];
      memCopy(values, HeapMemoryAccessor.ARRAY_SHORT_BASE_OFFSET, len, HeapMemoryAccessor.ARRAY_SHORT_INDEX_SCALE);
      return values;
    } 
    return new short[0];
  }
  
  private void memCopy(Object dest, long destOffset, int length, int indexScale) throws EOFException {
    if (length < 0)
      throw new NegativeArraySizeException("Destination length is negative: " + length); 
    int remaining = length * indexScale;
    checkAvailable(this.pos, remaining);
    long offset = destOffset;
    while (remaining > 0) {
      int chunk = (remaining > 1048576) ? 1048576 : remaining;
      GlobalMemoryAccessorRegistry.MEM.copyMemory(this.data, (HeapMemoryAccessor.ARRAY_BYTE_BASE_OFFSET + this.pos), dest, offset, chunk);
      remaining -= chunk;
      offset += chunk;
      this.pos += chunk;
    } 
  }
  
  public ByteOrder getByteOrder() { return ByteOrder.nativeOrder(); }
  
  public String toString() {
    return "UnsafeObjectDataInput{size=" + this.size + ", pos=" + this.pos + ", mark=" + this.mark + ", byteOrder=" + 


      
      getByteOrder() + '}';
  }
}
