package com.hazelcast.internal.serialization.impl;

import com.hazelcast.internal.serialization.InternalSerializationService;
import com.hazelcast.nio.Bits;
import com.hazelcast.nio.BufferObjectDataInput;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.util.collection.ArrayUtils;
import com.hazelcast.version.Version;
import java.io.EOFException;
import java.io.IOException;
import java.nio.ByteOrder;

class ByteArrayObjectDataInput extends VersionedObjectDataInput implements BufferObjectDataInput {
  private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
  
  byte[] data;
  
  int size;
  
  int pos;
  
  int mark;
  
  char[] charBuffer;
  
  private final InternalSerializationService service;
  
  private final boolean bigEndian;
  
  ByteArrayObjectDataInput(byte[] data, InternalSerializationService service, ByteOrder byteOrder) { this(data, 0, service, byteOrder); }
  
  ByteArrayObjectDataInput(byte[] data, int offset, InternalSerializationService service, ByteOrder byteOrder) {
    this.data = data;
    this.size = (data != null) ? data.length : 0;
    this.pos = offset;
    this.service = service;
    this.bigEndian = (byteOrder == ByteOrder.BIG_ENDIAN);
  }
  
  public void init(byte[] data, int offset) {
    this.data = data;
    this.size = (data != null) ? data.length : 0;
    this.pos = offset;
  }
  
  public void clear() {
    this.data = null;
    this.size = 0;
    this.pos = 0;
    this.mark = 0;
    if (this.charBuffer != null && this.charBuffer.length > 8192)
      this.charBuffer = new char[8192]; 
    this.version = Version.UNKNOWN;
  }
  
  public int read() throws EOFException { return (this.pos < this.size) ? (this.data[this.pos++] & 0xFF) : -1; }
  
  public int read(int position) throws EOFException { return (position < this.size) ? (this.data[position] & 0xFF) : -1; }
  
  public final int read(byte[] b, int off, int len) throws EOFException {
    if (b == null)
      throw new NullPointerException(); 
    ArrayUtils.boundsCheck(b.length, off, len);
    if (len == 0)
      return 0; 
    if (this.pos >= this.size)
      return -1; 
    if (this.pos + len > this.size)
      len = this.size - this.pos; 
    System.arraycopy(this.data, this.pos, b, off, len);
    this.pos += len;
    return len;
  }
  
  public final boolean readBoolean() throws EOFException {
    int ch = read();
    if (ch < 0)
      throw new EOFException(); 
    return (ch != 0);
  }
  
  public final boolean readBoolean(int position) throws EOFException {
    int ch = read(position);
    if (ch < 0)
      throw new EOFException(); 
    return (ch != 0);
  }
  
  public final byte readByte() throws EOFException {
    int ch = read();
    if (ch < 0)
      throw new EOFException(); 
    return (byte)ch;
  }
  
  public final byte readByte(int position) throws EOFException {
    int ch = read(position);
    if (ch < 0)
      throw new EOFException(); 
    return (byte)ch;
  }
  
  public final char readChar() throws EOFException {
    char c = readChar(this.pos);
    this.pos += 2;
    return c;
  }
  
  public char readChar(int position) throws EOFException {
    checkAvailable(position, 2);
    return Bits.readChar(this.data, position, this.bigEndian);
  }
  
  public double readDouble() throws EOFException { return Double.longBitsToDouble(readLong()); }
  
  public double readDouble(int position) throws EOFException { return Double.longBitsToDouble(readLong(position)); }
  
  public double readDouble(ByteOrder byteOrder) throws EOFException { return Double.longBitsToDouble(readLong(byteOrder)); }
  
  public double readDouble(int position, ByteOrder byteOrder) throws EOFException { return Double.longBitsToDouble(readLong(position, byteOrder)); }
  
  public float readFloat() throws EOFException { return Float.intBitsToFloat(readInt()); }
  
  public float readFloat(int position) throws EOFException { return Float.intBitsToFloat(readInt(position)); }
  
  public float readFloat(ByteOrder byteOrder) throws EOFException { return Float.intBitsToFloat(readInt(byteOrder)); }
  
  public float readFloat(int position, ByteOrder byteOrder) throws EOFException { return Float.intBitsToFloat(readInt(position, byteOrder)); }
  
  public void readFully(byte[] b) throws IOException {
    if (read(b) == -1)
      throw new EOFException("End of stream reached"); 
  }
  
  public void readFully(byte[] b, int off, int len) throws EOFException {
    if (read(b, off, len) == -1)
      throw new EOFException("End of stream reached"); 
  }
  
  public final int readInt() throws EOFException {
    int i = readInt(this.pos);
    this.pos += 4;
    return i;
  }
  
  public int readInt(int position) throws EOFException {
    checkAvailable(position, 4);
    return Bits.readInt(this.data, position, this.bigEndian);
  }
  
  public final int readInt(ByteOrder byteOrder) throws EOFException {
    int i = readInt(this.pos, byteOrder);
    this.pos += 4;
    return i;
  }
  
  public int readInt(int position, ByteOrder byteOrder) throws EOFException {
    checkAvailable(position, 4);
    return Bits.readInt(this.data, position, (byteOrder == ByteOrder.BIG_ENDIAN));
  }
  
  @Deprecated
  public final String readLine() throws EOFException { throw new UnsupportedOperationException(); }
  
  public final long readLong() throws EOFException {
    long l = readLong(this.pos);
    this.pos += 8;
    return l;
  }
  
  public long readLong(int position) throws EOFException {
    checkAvailable(position, 8);
    return Bits.readLong(this.data, position, this.bigEndian);
  }
  
  public final long readLong(ByteOrder byteOrder) throws EOFException {
    long l = readLong(this.pos, byteOrder);
    this.pos += 8;
    return l;
  }
  
  public long readLong(int position, ByteOrder byteOrder) throws EOFException {
    checkAvailable(position, 8);
    return Bits.readLong(this.data, position, (byteOrder == ByteOrder.BIG_ENDIAN));
  }
  
  public final short readShort() throws EOFException {
    short s = readShort(this.pos);
    this.pos += 2;
    return s;
  }
  
  public short readShort(int position) throws EOFException {
    checkAvailable(position, 2);
    return Bits.readShort(this.data, position, this.bigEndian);
  }
  
  public final short readShort(ByteOrder byteOrder) throws EOFException {
    short s = readShort(this.pos, byteOrder);
    this.pos += 2;
    return s;
  }
  
  public short readShort(int position, ByteOrder byteOrder) throws EOFException {
    checkAvailable(position, 2);
    return Bits.readShort(this.data, position, (byteOrder == ByteOrder.BIG_ENDIAN));
  }
  
  public byte[] readByteArray() throws IOException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      byte[] b = new byte[len];
      readFully(b);
      return b;
    } 
    return EMPTY_BYTE_ARRAY;
  }
  
  public boolean[] readBooleanArray() throws EOFException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      boolean[] values = new boolean[len];
      for (int i = 0; i < len; i++)
        values[i] = readBoolean(); 
      return values;
    } 
    return new boolean[0];
  }
  
  public char[] readCharArray() throws EOFException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      char[] values = new char[len];
      for (int i = 0; i < len; i++)
        values[i] = readChar(); 
      return values;
    } 
    return new char[0];
  }
  
  public int[] readIntArray() throws EOFException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      int[] values = new int[len];
      for (int i = 0; i < len; i++)
        values[i] = readInt(); 
      return values;
    } 
    return new int[0];
  }
  
  public long[] readLongArray() throws EOFException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      long[] values = new long[len];
      for (int i = 0; i < len; i++)
        values[i] = readLong(); 
      return values;
    } 
    return new long[0];
  }
  
  public double[] readDoubleArray() throws EOFException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      double[] values = new double[len];
      for (int i = 0; i < len; i++)
        values[i] = readDouble(); 
      return values;
    } 
    return new double[0];
  }
  
  public float[] readFloatArray() throws EOFException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      float[] values = new float[len];
      for (int i = 0; i < len; i++)
        values[i] = readFloat(); 
      return values;
    } 
    return new float[0];
  }
  
  public short[] readShortArray() throws EOFException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      short[] values = new short[len];
      for (int i = 0; i < len; i++)
        values[i] = readShort(); 
      return values;
    } 
    return new short[0];
  }
  
  public String[] readUTFArray() throws IOException {
    int len = readInt();
    if (len == -1)
      return null; 
    if (len > 0) {
      String[] values = new String[len];
      for (int i = 0; i < len; i++)
        values[i] = readUTF(); 
      return values;
    } 
    return new String[0];
  }
  
  public int readUnsignedByte() throws EOFException { return readByte() & 0xFF; }
  
  public int readUnsignedShort() throws EOFException { return readShort() & 0xFFFF; }
  
  public final String readUTF() throws EOFException {
    int charCount = readInt();
    if (charCount == -1)
      return null; 
    if (this.charBuffer == null || charCount > this.charBuffer.length)
      this.charBuffer = new char[charCount]; 
    for (int i = 0; i < charCount; i++) {
      byte b = readByte();
      if (b < 0) {
        this.charBuffer[i] = Bits.readUtf8Char(this, b);
      } else {
        this.charBuffer[i] = (char)b;
      } 
    } 
    return new String(this.charBuffer, 0, charCount);
  }
  
  public final Object readObject() throws EOFException { return this.service.readObject(this); }
  
  public <T> T readObject(Class aClass) throws IOException { return (T)this.service.readObject(this, aClass); }
  
  public <T> T readDataAsObject() throws IOException {
    Data data = readData();
    return (T)((data == null) ? null : this.service.toObject(data));
  }
  
  public final Data readData() throws IOException {
    byte[] bytes = readByteArray();
    return (bytes == null) ? null : new HeapData(bytes);
  }
  
  public final long skip(long n) {
    if (n <= 0L || n >= 2147483647L)
      return 0L; 
    return skipBytes((int)n);
  }
  
  public final int skipBytes(int n) throws EOFException {
    if (n <= 0)
      return 0; 
    int skip = n;
    int pos = position();
    if (pos + skip > this.size)
      skip = this.size - pos; 
    position(pos + skip);
    return skip;
  }
  
  public final int position() throws EOFException { return this.pos; }
  
  public final void position(int newPos) {
    if (newPos > this.size || newPos < 0)
      throw new IllegalArgumentException(); 
    this.pos = newPos;
    if (this.mark > this.pos)
      this.mark = -1; 
  }
  
  final void checkAvailable(int pos, int k) throws EOFException {
    if (pos < 0)
      throw new IllegalArgumentException("Negative pos! -> " + pos); 
    if (this.size - pos < k)
      throw new EOFException("Cannot read " + k + " bytes!"); 
  }
  
  public final int available() throws EOFException { return this.size - this.pos; }
  
  public final boolean markSupported() throws EOFException { return true; }
  
  public final void mark(int readlimit) { this.mark = this.pos; }
  
  public final void reset() { this.pos = this.mark; }
  
  public final void close() {
    this.data = null;
    this.charBuffer = null;
  }
  
  public final ClassLoader getClassLoader() { return this.service.getClassLoader(); }
  
  public InternalSerializationService getSerializationService() { return this.service; }
  
  public ByteOrder getByteOrder() { return this.bigEndian ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN; }
  
  public String toString() throws EOFException { return "ByteArrayObjectDataInput{size=" + this.size + ", pos=" + this.pos + ", mark=" + this.mark + '}'; }
}
