package com.hazelcast.internal.partition.impl;

import com.hazelcast.core.Member;
import com.hazelcast.internal.partition.InternalPartition;
import com.hazelcast.internal.partition.PartitionReplica;
import com.hazelcast.internal.partition.PartitionStateGenerator;
import com.hazelcast.logging.ILogger;
import com.hazelcast.logging.Logger;
import com.hazelcast.partition.membergroup.MemberGroup;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Set;

final class PartitionStateGeneratorImpl implements PartitionStateGenerator {
  private static final ILogger LOGGER = Logger.getLogger(PartitionStateGenerator.class);
  
  private static final int DEFAULT_RETRY_MULTIPLIER = 10;
  
  private static final float RANGE_CHECK_RATIO = 1.1F;
  
  private static final int MAX_RETRY_COUNT = 3;
  
  private static final int AGGRESSIVE_RETRY_THRESHOLD = 1;
  
  private static final int AGGRESSIVE_INDEX_THRESHOLD = 3;
  
  private static final int MIN_AVG_OWNER_DIFF = 3;
  
  public PartitionReplica[][] arrange(Collection<MemberGroup> memberGroups, InternalPartition[] currentState) { return arrange(memberGroups, currentState, null); }
  
  public PartitionReplica[][] arrange(Collection<MemberGroup> memberGroups, InternalPartition[] currentState, Collection<Integer> partitions) {
    Queue<NodeGroup> groups = createNodeGroups(memberGroups);
    if (groups.isEmpty())
      return (PartitionReplica[][])null; 
    int partitionCount = currentState.length;
    PartitionReplica[][] state = new PartitionReplica[partitionCount][7];
    initialize(currentState, state, partitions);
    int tryCount = 0;
    do {
      boolean aggressive = (tryCount >= 1);
      tryArrange(state, groups, partitionCount, aggressive, partitions);
      if (tryCount++ <= 0 || 
        !LOGGER.isFineEnabled())
        continue; 
      LOGGER.fine("Re-trying partition arrangement. Count: " + tryCount);
    } while (tryCount < 3 && !areGroupsBalanced(groups, partitionCount));
    return state;
  }
  
  private void initialize(InternalPartition[] currentState, PartitionReplica[][] state, Collection<Integer> partitions) {
    int partitionCount = currentState.length;
    for (int partitionId = 0; partitionId < partitionCount; partitionId++) {
      InternalPartition p = currentState[partitionId];
      PartitionReplica[] replicas = state[partitionId];
      boolean empty = true;
      for (int index = 0; index < 7; index++) {
        replicas[index] = p.getReplica(index);
        empty &= ((replicas[index] == null));
      } 
      if (!empty && (partitions == null || partitions.contains(Integer.valueOf(partitionId)))) {
        int maxReplicaIndex = 6;
        for (int index = 0; index < 7; index++) {
          if (replicas[index] == null)
            for (int k = maxReplicaIndex; k > index; k--) {
              if (replicas[k] != null) {
                replicas[index] = replicas[k];
                replicas[k] = null;
                maxReplicaIndex = k - 1;
                break;
              } 
            }  
        } 
      } 
    } 
  }
  
  private void tryArrange(PartitionReplica[][] state, Queue<NodeGroup> groups, int partitionCount, boolean aggressive, Collection<Integer> toBeArrangedPartitions) {
    int groupSize = groups.size();
    int replicaCount = Math.min(groupSize, 7);
    int avgPartitionPerGroup = partitionCount / groupSize;
    initializeGroupPartitions(state, groups, replicaCount, aggressive, toBeArrangedPartitions);
    for (int index = 0; index < replicaCount; index++) {
      Queue<Integer> freePartitions = getUnownedPartitions(state, index);
      if (toBeArrangedPartitions != null)
        freePartitions.retainAll(toBeArrangedPartitions); 
      Queue<NodeGroup> underLoadedGroups = new LinkedList<NodeGroup>();
      List<NodeGroup> overLoadedGroups = new LinkedList<NodeGroup>();
      int plusOneGroupCount = partitionCount - avgPartitionPerGroup * groupSize;
      for (NodeGroup nodeGroup : groups) {
        int size = nodeGroup.getPartitionCount(index);
        if (size < avgPartitionPerGroup) {
          underLoadedGroups.add(nodeGroup);
          continue;
        } 
        if (size > avgPartitionPerGroup)
          overLoadedGroups.add(nodeGroup); 
      } 
      plusOneGroupCount = tryToDistributeUnownedPartitions(underLoadedGroups, freePartitions, avgPartitionPerGroup, index, plusOneGroupCount);
      if (!freePartitions.isEmpty())
        distributeUnownedPartitions(groups, freePartitions, index); 
      assert freePartitions.isEmpty() : "There are partitions not-owned yet: " + freePartitions;
      if (toBeArrangedPartitions == null)
        transferPartitionsBetweenGroups(underLoadedGroups, overLoadedGroups, index, avgPartitionPerGroup, plusOneGroupCount); 
      updatePartitionState(state, groups, index);
    } 
  }
  
  private void transferPartitionsBetweenGroups(Queue<NodeGroup> underLoadedGroups, Collection<NodeGroup> overLoadedGroups, int index, int avgPartitionPerGroup, int plusOneGroupCount) {
    int maxPartitionPerGroup = avgPartitionPerGroup + 1;
    int maxTries = underLoadedGroups.size() * overLoadedGroups.size() * 10;
    int tries = 0;
    int expectedPartitionCount = (plusOneGroupCount > 0) ? maxPartitionPerGroup : avgPartitionPerGroup;
    while (tries++ < maxTries && !underLoadedGroups.isEmpty()) {
      NodeGroup toGroup = (NodeGroup)underLoadedGroups.poll();
      Iterator<NodeGroup> overLoadedGroupsIterator = overLoadedGroups.iterator();
      while (overLoadedGroupsIterator.hasNext()) {
        NodeGroup fromGroup = (NodeGroup)overLoadedGroupsIterator.next();
        selectToGroupPartitions(index, expectedPartitionCount, toGroup, fromGroup);
        int fromCount = fromGroup.getPartitionCount(index);
        if (plusOneGroupCount > 0 && fromCount == maxPartitionPerGroup && 
          --plusOneGroupCount == 0)
          expectedPartitionCount = avgPartitionPerGroup; 
        if (fromCount <= expectedPartitionCount)
          overLoadedGroupsIterator.remove(); 
        int toCount = toGroup.getPartitionCount(index);
        if (plusOneGroupCount > 0 && toCount == maxPartitionPerGroup && 
          --plusOneGroupCount == 0)
          expectedPartitionCount = avgPartitionPerGroup; 
        if (toCount >= expectedPartitionCount)
          break; 
      } 
      if (toGroup.getPartitionCount(index) < avgPartitionPerGroup)
        underLoadedGroups.offer(toGroup); 
    } 
  }
  
  private void selectToGroupPartitions(int index, int expectedPartitionCount, NodeGroup toGroup, NodeGroup fromGroup) {
    Iterator<Integer> partitionsIterator = fromGroup.getPartitionsIterator(index);
    while (partitionsIterator.hasNext() && fromGroup
      .getPartitionCount(index) > expectedPartitionCount && toGroup
      .getPartitionCount(index) < expectedPartitionCount) {
      Integer partitionId = (Integer)partitionsIterator.next();
      if (toGroup.addPartition(index, partitionId))
        partitionsIterator.remove(); 
    } 
  }
  
  private void updatePartitionState(PartitionReplica[][] state, Collection<NodeGroup> groups, int index) {
    for (NodeGroup group : groups) {
      group.postProcessPartitionTable(index);
      for (PartitionReplica replica : group.getReplicas()) {
        PartitionTable table = group.getPartitionTable(replica);
        Set<Integer> set = table.getPartitions(index);
        for (Integer partitionId : set)
          state[partitionId.intValue()][index] = replica; 
      } 
    } 
  }
  
  private void distributeUnownedPartitions(Queue<NodeGroup> groups, Queue<Integer> freePartitions, int index) {
    int groupSize = groups.size();
    int maxTries = freePartitions.size() * groupSize * 10;
    int tries = 0;
    Integer partitionId = (Integer)freePartitions.poll();
    while (partitionId != null && tries++ < maxTries) {
      NodeGroup group = (NodeGroup)groups.poll();
      if (group.addPartition(index, partitionId))
        partitionId = (Integer)freePartitions.poll(); 
      groups.offer(group);
    } 
  }
  
  private int tryToDistributeUnownedPartitions(Queue<NodeGroup> underLoadedGroups, Queue<Integer> freePartitions, int avgPartitionPerGroup, int index, int plusOneGroupCount) {
    int maxPartitionPerGroup = avgPartitionPerGroup + 1;
    int maxTries = freePartitions.size() * underLoadedGroups.size();
    int tries = 0;
    while (tries++ < maxTries && !freePartitions.isEmpty() && !underLoadedGroups.isEmpty()) {
      NodeGroup group = (NodeGroup)underLoadedGroups.poll();
      assignFreePartitionsToNodeGroup(freePartitions, index, group);
      int count = group.getPartitionCount(index);
      if (plusOneGroupCount > 0 && count == maxPartitionPerGroup) {
        if (--plusOneGroupCount == 0) {
          Iterator<NodeGroup> underLoaded = underLoadedGroups.iterator();
          while (underLoaded.hasNext()) {
            if (((NodeGroup)underLoaded.next()).getPartitionCount(index) >= avgPartitionPerGroup)
              underLoaded.remove(); 
          } 
        } 
        continue;
      } 
      if ((plusOneGroupCount > 0 && count < maxPartitionPerGroup) || count < avgPartitionPerGroup)
        underLoadedGroups.offer(group); 
    } 
    return plusOneGroupCount;
  }
  
  private void assignFreePartitionsToNodeGroup(Queue<Integer> freePartitions, int index, NodeGroup group) {
    int size = freePartitions.size();
    for (int i = 0; i < size; ) {
      Integer partitionId = (Integer)freePartitions.poll();
      if (!group.addPartition(index, partitionId)) {
        freePartitions.offer(partitionId);
        i++;
      } 
    } 
  }
  
  private Queue<Integer> getUnownedPartitions(PartitionReplica[][] state, int replicaIndex) {
    LinkedList<Integer> freePartitions = new LinkedList<Integer>();
    for (int partitionId = 0; partitionId < state.length; partitionId++) {
      PartitionReplica[] replicas = state[partitionId];
      if (replicas[replicaIndex] == null)
        freePartitions.add(Integer.valueOf(partitionId)); 
    } 
    Collections.shuffle(freePartitions);
    return freePartitions;
  }
  
  private void initializeGroupPartitions(PartitionReplica[][] state, Queue<NodeGroup> groups, int replicaCount, boolean aggressive, Collection<Integer> toBeArrangedPartitions) {
    for (NodeGroup nodeGroup : groups)
      nodeGroup.resetPartitions(); 
    for (int partitionId = 0; partitionId < state.length; partitionId++) {
      PartitionReplica[] replicas = state[partitionId];
      for (int replicaIndex = 0; replicaIndex < 7; replicaIndex++) {
        if (replicaIndex >= replicaCount) {
          replicas[replicaIndex] = null;
        } else {
          PartitionReplica owner = replicas[replicaIndex];
          boolean valid = false;
          if (owner != null)
            valid = partitionOwnerAvailable(groups, partitionId, replicaIndex, owner); 
          if (!valid) {
            replicas[replicaIndex] = null;
          } else if (aggressive && replicaIndex < 3 && (toBeArrangedPartitions == null || toBeArrangedPartitions
            .contains(Integer.valueOf(partitionId)))) {
            for (int i = 3; i < replicaCount; i++)
              replicas[i] = null; 
          } 
        } 
      } 
    } 
  }
  
  private boolean partitionOwnerAvailable(Queue<NodeGroup> groups, int partitionId, int replicaIndex, PartitionReplica owner) {
    for (NodeGroup nodeGroup : groups) {
      if (nodeGroup.hasNode(owner)) {
        if (nodeGroup.ownPartition(owner, replicaIndex, Integer.valueOf(partitionId)))
          return true; 
        break;
      } 
    } 
    return false;
  }
  
  private Queue<NodeGroup> createNodeGroups(Collection<MemberGroup> memberGroups) {
    Queue<NodeGroup> nodeGroups = new LinkedList<NodeGroup>();
    if (memberGroups == null || memberGroups.isEmpty())
      return nodeGroups; 
    for (MemberGroup memberGroup : memberGroups) {
      DefaultNodeGroup defaultNodeGroup;
      if (memberGroup.size() == 0)
        continue; 
      if (memberGroup instanceof com.hazelcast.partition.membergroup.SingleMemberGroup || memberGroup.size() == 1) {
        defaultNodeGroup = new SingleNodeGroup(null);
        Member next = (Member)memberGroup.iterator().next();
        defaultNodeGroup.addNode(PartitionReplica.from(next));
      } else {
        defaultNodeGroup = new DefaultNodeGroup(null);
        Iterator<Member> iter = memberGroup.iterator();
        while (iter.hasNext()) {
          Member next = (Member)iter.next();
          defaultNodeGroup.addNode(PartitionReplica.from(next));
        } 
      } 
      nodeGroups.add(defaultNodeGroup);
    } 
    return nodeGroups;
  }
  
  private boolean areGroupsBalanced(Collection<NodeGroup> groups, int partitionCount) {
    float ratio = 1.1F;
    int avgPartitionPerGroup = partitionCount / groups.size();
    int replicaCount = Math.min(groups.size(), 7);
    for (NodeGroup group : groups) {
      for (int i = 0; i < replicaCount; i++) {
        int partitionCountOfGroup = group.getPartitionCount(i);
        if (Math.abs(partitionCountOfGroup - avgPartitionPerGroup) > 3)
          if (partitionCountOfGroup < avgPartitionPerGroup / ratio || partitionCountOfGroup > avgPartitionPerGroup * ratio) {
            if (LOGGER.isFineEnabled())
              LOGGER.fine("Not well balanced! Replica: " + i + ", PartitionCount: " + partitionCountOfGroup + ", AvgPartitionCount: " + avgPartitionPerGroup); 
            return false;
          }  
      } 
    } 
    return true;
  }
}
