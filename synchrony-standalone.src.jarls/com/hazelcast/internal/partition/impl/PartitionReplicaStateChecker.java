package com.hazelcast.internal.partition.impl;

import com.hazelcast.cluster.ClusterState;
import com.hazelcast.instance.MemberImpl;
import com.hazelcast.instance.Node;
import com.hazelcast.internal.cluster.impl.ClusterServiceImpl;
import com.hazelcast.internal.partition.InternalPartition;
import com.hazelcast.internal.partition.PartitionReplica;
import com.hazelcast.internal.partition.operation.HasOngoingMigration;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.impl.operationservice.InternalOperationService;
import com.hazelcast.util.Clock;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.logging.Level;

public class PartitionReplicaStateChecker {
  private static final int DEFAULT_PAUSE_MILLIS = 1000;
  
  private static final int REPLICA_SYNC_CHECK_TIMEOUT_SECONDS = 10;
  
  private static final int INVOCATION_TRY_COUNT = 10;
  
  private static final int INVOCATION_TRY_PAUSE_MILLIS = 100;
  
  private final Node node;
  
  private final NodeEngineImpl nodeEngine;
  
  private final InternalPartitionServiceImpl partitionService;
  
  private final ILogger logger;
  
  private final PartitionStateManager partitionStateManager;
  
  private final MigrationManager migrationManager;
  
  PartitionReplicaStateChecker(Node node, InternalPartitionServiceImpl partitionService) {
    this.node = node;
    this.nodeEngine = node.getNodeEngine();
    this.partitionService = partitionService;
    this.logger = node.getLogger(getClass());
    this.partitionStateManager = partitionService.getPartitionStateManager();
    this.migrationManager = partitionService.getMigrationManager();
  }
  
  public PartitionServiceState getPartitionServiceState() {
    if (this.partitionService.isFetchMostRecentPartitionTableTaskRequired())
      return PartitionServiceState.FETCHING_PARTITION_TABLE; 
    if (hasMissingReplicaOwners())
      return PartitionServiceState.REPLICA_NOT_OWNED; 
    if (this.migrationManager.hasOnGoingMigration())
      return PartitionServiceState.MIGRATION_LOCAL; 
    if (!this.partitionService.isLocalMemberMaster() && hasOnGoingMigrationMaster(Level.OFF))
      return PartitionServiceState.MIGRATION_ON_MASTER; 
    if (!checkAndTriggerReplicaSync())
      return PartitionServiceState.REPLICA_NOT_SYNC; 
    return PartitionServiceState.SAFE;
  }
  
  public boolean triggerAndWaitForReplicaSync(long timeout, TimeUnit unit) { return triggerAndWaitForReplicaSync(timeout, unit, 1000L); }
  
  boolean triggerAndWaitForReplicaSync(long timeout, TimeUnit unit, long sleepMillis) {
    long timeoutInMillis = unit.toMillis(timeout);
    while (timeoutInMillis > 0L) {
      timeoutInMillis = waitForMissingReplicaOwners(Level.FINE, timeoutInMillis, sleepMillis);
      if (timeoutInMillis <= 0L)
        break; 
      timeoutInMillis = waitForOngoingMigrations(Level.FINE, timeoutInMillis, sleepMillis);
      if (timeoutInMillis <= 0L)
        break; 
      long start = Clock.currentTimeMillis();
      boolean syncResult = checkAndTriggerReplicaSync();
      timeoutInMillis -= Clock.currentTimeMillis() - start;
      if (syncResult) {
        this.logger.finest("Replica sync state is OK");
        return true;
      } 
      if (timeoutInMillis <= 0L)
        break; 
      this.logger.info("Some backup replicas are inconsistent with primary, waiting for synchronization. Timeout: " + timeoutInMillis + "ms");
      timeoutInMillis = sleepWithBusyWait(timeoutInMillis, sleepMillis);
    } 
    return false;
  }
  
  private long waitForMissingReplicaOwners(Level level, long timeoutInMillis, long sleep) {
    long timeout = timeoutInMillis;
    while (timeout > 0L && hasMissingReplicaOwners()) {
      if (this.logger.isLoggable(level))
        this.logger.log(level, "Waiting for ownership assignments of missing replica owners..."); 
      timeout = sleepWithBusyWait(timeout, sleep);
    } 
    return timeout;
  }
  
  private boolean hasMissingReplicaOwners() {
    if (!needsReplicaStateCheck())
      return false; 
    int memberGroupsSize = this.partitionStateManager.getMemberGroupsSize();
    int replicaCount = Math.min(7, memberGroupsSize);
    ClusterServiceImpl clusterService = this.node.getClusterService();
    ClusterState clusterState = clusterService.getClusterState();
    for (InternalPartition partition : this.partitionStateManager.getPartitions()) {
      for (int index = 0; index < replicaCount; index++) {
        PartitionReplica replica = partition.getReplica(index);
        if (replica == null) {
          if (this.logger.isFinestEnabled())
            this.logger.finest("Missing replica=" + index + " for partitionId=" + partition.getPartitionId()); 
          return true;
        } 
        if (clusterService.getMember(replica.address(), replica.uuid()) == null && (clusterState
          .isJoinAllowed() || 
          !clusterService.isMissingMember(replica.address(), replica.uuid()))) {
          if (this.logger.isFinestEnabled())
            this.logger.finest("Unknown replica owner= " + replica + ", partitionId=" + partition
                .getPartitionId() + ", replica=" + index); 
          return true;
        } 
      } 
    } 
    return false;
  }
  
  private long waitForOngoingMigrations(Level level, long timeoutInMillis, long sleep) {
    long timeout = timeoutInMillis;
    while (timeout > 0L && (this.migrationManager.hasOnGoingMigration() || hasOnGoingMigrationMaster(level))) {
      if (this.logger.isLoggable(level))
        this.logger.log(level, "Waiting for the master node to complete remaining migrations..."); 
      timeout = sleepWithBusyWait(timeout, sleep);
    } 
    return timeout;
  }
  
  private long sleepWithBusyWait(long timeoutInMillis, long sleep) {
    try {
      Thread.sleep(sleep);
    } catch (InterruptedException ie) {
      Thread.currentThread().interrupt();
      this.logger.finest("Busy wait interrupted", ie);
    } 
    return timeoutInMillis - sleep;
  }
  
  private boolean checkAndTriggerReplicaSync() {
    if (!needsReplicaStateCheck())
      return true; 
    Semaphore semaphore = new Semaphore(0);
    AtomicBoolean ok = new AtomicBoolean(true);
    int maxBackupCount = this.partitionService.getMaxAllowedBackupCount();
    int ownedPartitionCount = invokeReplicaSyncOperations(maxBackupCount, semaphore, ok);
    try {
      if (!ok.get())
        return false; 
      int permits = ownedPartitionCount * maxBackupCount;
      boolean receivedAllResponses = semaphore.tryAcquire(permits, 10L, TimeUnit.SECONDS);
      return (receivedAllResponses && ok.get());
    } catch (InterruptedException ignored) {
      Thread.currentThread().interrupt();
      return false;
    } 
  }
  
  private int invokeReplicaSyncOperations(int maxBackupCount, Semaphore semaphore, AtomicBoolean result) {
    MemberImpl localMember = this.node.getLocalMember();
    ReplicaSyncResponseCallback replicaSyncResponseCallback = new ReplicaSyncResponseCallback(result, semaphore);
    ClusterServiceImpl clusterService = this.node.getClusterService();
    ClusterState clusterState = clusterService.getClusterState();
    int ownedCount = 0;
    for (InternalPartition partition : this.partitionStateManager.getPartitions()) {
      PartitionReplica owner = partition.getOwnerReplicaOrNull();
      if (owner == null) {
        result.set(false);
      } else if (owner.isIdentical(localMember)) {
        ownedCount++;
        if (maxBackupCount == 0) {
          if (partition.isMigrating())
            result.set(false); 
        } else {
          for (int index = 1; index <= maxBackupCount; index++) {
            PartitionReplica replicaOwner = partition.getReplica(index);
            if (replicaOwner == null) {
              result.set(false);
              semaphore.release();
            } else if (!clusterState.isJoinAllowed() && clusterService
              .isMissingMember(replicaOwner.address(), replicaOwner.uuid())) {
              semaphore.release();
            } else {
              int partitionId = partition.getPartitionId();
              CheckPartitionReplicaVersionTask checkPartitionReplicaVersionTask = new CheckPartitionReplicaVersionTask(this.nodeEngine, partitionId, index, replicaSyncResponseCallback);
              this.nodeEngine.getOperationService().execute(checkPartitionReplicaVersionTask);
            } 
          } 
        } 
      } 
    } 
    return ownedCount;
  }
  
  private boolean needsReplicaStateCheck() { return (this.partitionStateManager.isInitialized() && this.partitionStateManager.getMemberGroupsSize() > 0); }
  
  boolean hasOnGoingMigrationMaster(Level level) {
    ClusterServiceImpl clusterServiceImpl = this.node.getClusterService();
    Address masterAddress = clusterServiceImpl.getMasterAddress();
    if (masterAddress == null)
      return clusterServiceImpl.isJoined(); 
    HasOngoingMigration hasOngoingMigration = new HasOngoingMigration();
    InternalOperationService internalOperationService = this.nodeEngine.getOperationService();
    InternalCompletableFuture<Boolean> future = internalOperationService.createInvocationBuilder("hz:core:partitionService", hasOngoingMigration, masterAddress).setTryCount(10).setTryPauseMillis(100L).invoke();
    try {
      return ((Boolean)future.join()).booleanValue();
    } catch (Exception e) {
      this.logger.log(level, "Could not get a response from master about migrations! -> " + e.toString());
      return false;
    } 
  }
}
