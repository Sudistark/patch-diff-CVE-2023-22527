package com.hazelcast.internal.partition.impl;

import com.hazelcast.internal.partition.InternalPartition;
import com.hazelcast.internal.partition.PartitionListener;
import com.hazelcast.internal.partition.PartitionReplica;
import com.hazelcast.nio.Address;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.Arrays;

public class InternalPartitionImpl implements InternalPartition {
  private final int partitionId;
  
  private final PartitionListener partitionListener;
  
  InternalPartitionImpl(int partitionId, PartitionListener partitionListener, PartitionReplica localReplica) {
    assert localReplica != null;
    this.partitionId = partitionId;
    this.partitionListener = partitionListener;
    this.localReplica = localReplica;
  }
  
  @SuppressFBWarnings({"EI_EXPOSE_REP"})
  public InternalPartitionImpl(int partitionId, PartitionListener listener, PartitionReplica localReplica, PartitionReplica[] replicas) {
    this(partitionId, listener, localReplica);
    this.replicas = replicas;
  }
  
  public int getPartitionId() { return this.partitionId; }
  
  public boolean isMigrating() { return this.isMigrating; }
  
  public boolean setMigrating() {
    if (this.isMigrating)
      return false; 
    this.isMigrating = true;
    return true;
  }
  
  public void resetMigrating() { this.isMigrating = false; }
  
  public boolean isLocal() { return this.localReplica.equals(getOwnerReplicaOrNull()); }
  
  public Address getOwnerOrNull() { return getAddress(this.replicas[0]); }
  
  public PartitionReplica getOwnerReplicaOrNull() { return this.replicas[0]; }
  
  public Address getReplicaAddress(int replicaIndex) {
    PartitionReplica member = this.replicas[replicaIndex];
    return getAddress(member);
  }
  
  public PartitionReplica getReplica(int replicaIndex) { return this.replicas[replicaIndex]; }
  
  void swapReplicas(int index1, int index2) {
    PartitionReplica[] newReplicas = (PartitionReplica[])Arrays.copyOf(this.replicas, 7);
    PartitionReplica a1 = newReplicas[index1];
    PartitionReplica a2 = newReplicas[index2];
    newReplicas[index1] = a2;
    newReplicas[index2] = a1;
    this.replicas = newReplicas;
    callPartitionListener(index1, a1, a2);
    callPartitionListener(index2, a2, a1);
  }
  
  void setInitialReplicas(PartitionReplica[] newReplicas) {
    PartitionReplica[] oldReplicas = this.replicas;
    for (int replicaIndex = 0; replicaIndex < 7; replicaIndex++) {
      if (oldReplicas[replicaIndex] != null)
        throw new IllegalStateException("Partition is already initialized!"); 
    } 
    this.replicas = newReplicas;
  }
  
  void setReplicas(PartitionReplica[] newReplicas) {
    PartitionReplica[] oldReplicas = this.replicas;
    this.replicas = newReplicas;
    callPartitionListener(newReplicas, oldReplicas);
  }
  
  void setReplica(int replicaIndex, PartitionReplica newReplica) {
    PartitionReplica[] newReplicas = (PartitionReplica[])Arrays.copyOf(this.replicas, 7);
    PartitionReplica oldReplica = newReplicas[replicaIndex];
    newReplicas[replicaIndex] = newReplica;
    this.replicas = newReplicas;
    callPartitionListener(replicaIndex, oldReplica, newReplica);
  }
  
  private void callPartitionListener(PartitionReplica[] newReplicas, PartitionReplica[] oldReplicas) {
    if (this.partitionListener != null)
      for (int replicaIndex = 0; replicaIndex < 7; replicaIndex++) {
        PartitionReplica oldReplicasId = oldReplicas[replicaIndex];
        PartitionReplica newReplicasId = newReplicas[replicaIndex];
        callPartitionListener(replicaIndex, oldReplicasId, newReplicasId);
      }  
  }
  
  private void callPartitionListener(int replicaIndex, PartitionReplica oldReplica, PartitionReplica newReplica) {
    boolean changed;
    if (oldReplica == null) {
      changed = (newReplica != null);
    } else {
      changed = !oldReplica.equals(newReplica);
    } 
    if (changed) {
      PartitionReplicaChangeEvent event = new PartitionReplicaChangeEvent(this.partitionId, replicaIndex, getAddress(oldReplica), getAddress(newReplica));
      this.partitionListener.replicaChanged(event);
    } 
  }
  
  private static Address getAddress(PartitionReplica replica) { return (replica != null) ? replica.address() : null; }
  
  InternalPartitionImpl copy(PartitionListener listener) { return new InternalPartitionImpl(this.partitionId, listener, this.localReplica, (PartitionReplica[])Arrays.copyOf(this.replicas, 7)); }
  
  PartitionReplica[] getReplicas() { return this.replicas; }
  
  public boolean isOwnerOrBackup(Address address) {
    if (address == null)
      return false; 
    for (int i = 0; i < 7; i++) {
      if (address.equals(getAddress(this.replicas[i])))
        return true; 
    } 
    return false;
  }
  
  public int getReplicaIndex(PartitionReplica replica) { return getReplicaIndex(this.replicas, replica); }
  
  public boolean isOwnerOrBackup(PartitionReplica replica) { return (getReplicaIndex(this.replicas, replica) >= 0); }
  
  static int getReplicaIndex(PartitionReplica[] replicas, PartitionReplica replica) {
    if (replica == null)
      return -1; 
    for (int i = 0; i < 7; i++) {
      if (replica.equals(replicas[i]))
        return i; 
    } 
    return -1;
  }
  
  int replaceReplica(PartitionReplica oldReplica, PartitionReplica newReplica) {
    for (int i = 0; i < 7; i++) {
      PartitionReplica currentReplica = this.replicas[i];
      if (currentReplica == null)
        break; 
      if (currentReplica.equals(oldReplica)) {
        PartitionReplica[] newReplicas = (PartitionReplica[])Arrays.copyOf(this.replicas, 7);
        newReplicas[i] = newReplica;
        this.replicas = newReplicas;
        callPartitionListener(i, oldReplica, newReplica);
        return i;
      } 
    } 
    return -1;
  }
  
  void reset(PartitionReplica localReplica) {
    assert localReplica != null;
    this.replicas = new PartitionReplica[7];
    this.localReplica = localReplica;
    resetMigrating();
  }
  
  public String toString() {
    StringBuilder sb = (new StringBuilder("Partition [")).append(this.partitionId).append("]{\n");
    for (int i = 0; i < 7; i++) {
      PartitionReplica replica = this.replicas[i];
      if (replica != null) {
        sb.append('\t');
        sb.append(i).append(":").append(replica);
        sb.append("\n");
      } 
    } 
    sb.append("}");
    return sb.toString();
  }
}
