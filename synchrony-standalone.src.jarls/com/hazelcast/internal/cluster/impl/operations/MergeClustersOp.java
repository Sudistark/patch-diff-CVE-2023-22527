package com.hazelcast.internal.cluster.impl.operations;

import com.hazelcast.instance.Node;
import com.hazelcast.internal.cluster.impl.ClusterServiceImpl;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.spi.impl.NodeEngineImpl;
import java.io.IOException;

public class MergeClustersOp extends AbstractClusterOperation {
  private Address newTargetAddress;
  
  public MergeClustersOp() {}
  
  public MergeClustersOp(Address newTargetAddress) { this.newTargetAddress = newTargetAddress; }
  
  public void run() {
    Address caller = getCallerAddress();
    NodeEngineImpl nodeEngine = (NodeEngineImpl)getNodeEngine();
    Node node = nodeEngine.getNode();
    ClusterServiceImpl clusterService = node.getClusterService();
    Address masterAddress = clusterService.getMasterAddress();
    ILogger logger = node.loggingService.getLogger(getClass().getName());
    boolean local = (caller == null);
    if (!local && !caller.equals(masterAddress)) {
      logger.warning("Ignoring merge instruction sent from non-master endpoint: " + caller);
      return;
    } 
    logger.warning(node.getThisAddress() + " is merging to " + this.newTargetAddress + ", because: instructed by master " + masterAddress);
    nodeEngine.getExecutionService().execute("hz:cluster:splitbrain", new Object(this, clusterService));
  }
  
  public boolean returnsResponse() { return true; }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    this.newTargetAddress = new Address();
    this.newTargetAddress.readData(in);
  }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException { this.newTargetAddress.writeData(out); }
  
  public int getId() { return 21; }
}
