package com.hazelcast.internal.cluster.impl;

import com.hazelcast.cluster.ClusterState;
import com.hazelcast.core.Member;
import com.hazelcast.instance.MemberImpl;
import com.hazelcast.instance.Node;
import com.hazelcast.internal.cluster.impl.operations.LockClusterStateOp;
import com.hazelcast.internal.partition.InternalPartitionService;
import com.hazelcast.internal.util.LockGuard;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.transaction.TransactionException;
import com.hazelcast.transaction.TransactionOptions;
import com.hazelcast.transaction.impl.Transaction;
import com.hazelcast.transaction.impl.TransactionManagerServiceImpl;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.FutureUtil;
import com.hazelcast.util.Preconditions;
import com.hazelcast.version.Version;
import java.util.ArrayList;
import java.util.Collection;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.Lock;

public class ClusterStateManager {
  private static final TransactionOptions DEFAULT_TX_OPTIONS = (new TransactionOptions())
    .setDurability(1)
    .setTimeout(1L, TimeUnit.MINUTES)
    .setTransactionType(TransactionOptions.TransactionType.TWO_PHASE);
  
  private static final long LOCK_LEASE_EXTENSION_MILLIS = TimeUnit.SECONDS.toMillis(20L);
  
  private final Node node;
  
  private final ILogger logger;
  
  private final Lock clusterServiceLock;
  
  private final AtomicReference<LockGuard> stateLockRef;
  
  ClusterStateManager(Node node, Lock clusterServiceLock) {
    this.clusterVersion = Version.UNKNOWN;
    this.stateLockRef = new AtomicReference(LockGuard.NOT_LOCKED);
    this.state = ClusterState.ACTIVE;
    this.node = node;
    this.clusterServiceLock = clusterServiceLock;
    this.logger = node.getLogger(getClass());
  }
  
  public ClusterState getState() {
    LockGuard stateLock = getStateLock();
    return stateLock.isLocked() ? ClusterState.IN_TRANSITION : this.state;
  }
  
  public Version getClusterVersion() { return this.clusterVersion; }
  
  LockGuard getStateLock() {
    LockGuard stateLock = (LockGuard)this.stateLockRef.get();
    while (stateLock.isLeaseExpired()) {
      if (this.stateLockRef.compareAndSet(stateLock, LockGuard.NOT_LOCKED)) {
        this.logger.fine("Cluster state lock: " + stateLock + " is expired.");
        stateLock = LockGuard.NOT_LOCKED;
        break;
      } 
      stateLock = (LockGuard)this.stateLockRef.get();
    } 
    return stateLock;
  }
  
  void initialClusterState(ClusterState initialState, Version version) {
    this.clusterServiceLock.lock();
    try {
      this.node.getNodeExtension().onInitialClusterState(initialState);
      ClusterState currentState = getState();
      if (currentState != ClusterState.ACTIVE && currentState != initialState) {
        this.logger.warning("Initial state is already set! Current state: " + currentState + ", Given state: " + initialState);
        return;
      } 
      this.logger.fine("Setting initial cluster state: " + initialState + " and version: " + version);
      validateNodeCompatibleWith(version);
      setClusterStateAndVersion(initialState, version, true);
    } finally {
      this.clusterServiceLock.unlock();
    } 
  }
  
  void setClusterState(ClusterState newState, boolean isTransient) {
    this.clusterServiceLock.lock();
    try {
      doSetClusterState(newState, isTransient);
    } finally {
      this.clusterServiceLock.unlock();
    } 
  }
  
  public void setClusterVersion(Version newVersion) {
    this.clusterServiceLock.lock();
    try {
      doSetClusterVersion(newVersion);
    } finally {
      this.clusterServiceLock.unlock();
    } 
  }
  
  private void setClusterStateAndVersion(ClusterState newState, Version newVersion, boolean isTransient) {
    this.state = newState;
    this.clusterVersion = newVersion;
    this.stateLockRef.set(LockGuard.NOT_LOCKED);
    changeNodeState(newState);
    this.node.getNodeExtension().onClusterStateChange(newState, isTransient);
    this.node.getNodeExtension().onClusterVersionChange(newVersion);
  }
  
  private void doSetClusterState(ClusterState newState, boolean isTransient) {
    this.state = newState;
    this.stateLockRef.set(LockGuard.NOT_LOCKED);
    changeNodeState(newState);
    this.node.getNodeExtension().onClusterStateChange(newState, isTransient);
  }
  
  private void doSetClusterVersion(Version newVersion) {
    this.clusterVersion = newVersion;
    this.stateLockRef.set(LockGuard.NOT_LOCKED);
    this.node.getNodeExtension().onClusterVersionChange(newVersion);
  }
  
  void reset() {
    this.clusterServiceLock.lock();
    try {
      this.state = ClusterState.ACTIVE;
      this.clusterVersion = Version.UNKNOWN;
      this.stateLockRef.set(LockGuard.NOT_LOCKED);
    } finally {
      this.clusterServiceLock.unlock();
    } 
  }
  
  public void lockClusterState(ClusterStateChange stateChange, Address initiator, String txnId, long leaseTime, int memberListVersion, int partitionStateVersion) {
    Preconditions.checkNotNull(stateChange);
    this.clusterServiceLock.lock();
    try {
      if (!this.node.getNodeExtension().isStartCompleted())
        throw new IllegalStateException("Can not lock cluster state! Startup is not completed yet!"); 
      if (this.node.getClusterService().getClusterJoinManager().isMastershipClaimInProgress())
        throw new IllegalStateException("Can not lock cluster state! Mastership claim is in progress!"); 
      if (stateChange.isOfType(Version.class)) {
        validateNodeCompatibleWith((Version)stateChange.getNewState());
        validateClusterVersionChange((Version)stateChange.getNewState());
      } 
      checkMemberListVersion(memberListVersion);
      checkMigrationsAndPartitionStateVersion(stateChange, partitionStateVersion);
      lockOrExtendClusterState(initiator, txnId, leaseTime);
      try {
        checkMigrationsAndPartitionStateVersion(stateChange, partitionStateVersion);
      } catch (IllegalStateException e) {
        this.stateLockRef.set(LockGuard.NOT_LOCKED);
        throw e;
      } 
    } finally {
      this.clusterServiceLock.unlock();
    } 
  }
  
  private void checkMemberListVersion(int memberListVersion) {
    int thisMemberListVersion = this.node.getClusterService().getMemberListVersion();
    if (memberListVersion != thisMemberListVersion)
      throw new IllegalStateException("Can not lock cluster state! Member list versions are not matching! Expected version: " + memberListVersion + ", Current version: " + thisMemberListVersion); 
  }
  
  private void lockOrExtendClusterState(Address initiator, String txnId, long leaseTime) {
    Preconditions.checkPositive(leaseTime, "Lease time should be positive!");
    LockGuard currentLock = getStateLock();
    if (!currentLock.allowsLock(txnId))
      throw new TransactionException("Locking failed for " + initiator + ", tx: " + txnId + ", current state: " + 
          toString()); 
    long newLeaseTime = currentLock.getRemainingTime() + leaseTime;
    if (newLeaseTime < 0L)
      newLeaseTime = Float.MAX_VALUE; 
    this.stateLockRef.set(new LockGuard(initiator, txnId, newLeaseTime));
  }
  
  private void validateNodeCompatibleWith(Version clusterVersion) {
    if (!this.node.getNodeExtension().isNodeVersionCompatibleWith(clusterVersion))
      throw new VersionMismatchException("Node's codebase version " + this.node.getVersion() + " is incompatible with the requested cluster version " + clusterVersion); 
  }
  
  private void validateClusterVersionChange(Version newClusterVersion) {
    if (!this.clusterVersion.isUnknown() && this.clusterVersion.getMajor() != newClusterVersion.getMajor())
      throw new IllegalArgumentException("Transition to requested version " + newClusterVersion + " not allowed for current cluster version " + this.clusterVersion); 
  }
  
  private void checkMigrationsAndPartitionStateVersion(ClusterStateChange stateChange, int partitionStateVersion) {
    InternalPartitionService partitionService = this.node.getPartitionService();
    int thisPartitionStateVersion = partitionService.getPartitionStateVersion();
    if (partitionService.hasOnGoingMigrationLocal())
      throw new IllegalStateException("Still have pending migration tasks, cannot lock cluster state! New state: " + stateChange + ", current state: " + 
          
          getState()); 
    if (partitionStateVersion != thisPartitionStateVersion)
      throw new IllegalStateException("Can not lock cluster state! Partition tables have different versions! Expected version: " + partitionStateVersion + " Current version: " + thisPartitionStateVersion); 
  }
  
  public boolean rollbackClusterState(String txnId) {
    this.clusterServiceLock.lock();
    try {
      LockGuard currentLock = getStateLock();
      if (!currentLock.allowsUnlock(txnId))
        return false; 
      this.logger.fine("Rolling back cluster state transaction: " + txnId);
      this.stateLockRef.set(LockGuard.NOT_LOCKED);
      if (this.state.isJoinAllowed())
        this.node.getClusterService().getMembershipManager().removeAllMissingMembers(); 
      return true;
    } finally {
      this.clusterServiceLock.unlock();
    } 
  }
  
  void commitClusterState(ClusterStateChange newState, Address initiator, String txnId) { commitClusterState(newState, initiator, txnId, false); }
  
  public void commitClusterState(ClusterStateChange stateChange, Address initiator, String txnId, boolean isTransient) {
    Preconditions.checkNotNull(stateChange);
    stateChange.validate();
    this.clusterServiceLock.lock();
    try {
      LockGuard stateLock = getStateLock();
      if (!stateLock.allowsUnlock(txnId))
        throw new TransactionException("Cluster state change [" + this.state + " -> " + stateChange + "] failed for " + initiator + ", current state: " + 
            
            stateToString()); 
      if (stateChange.isOfType(ClusterState.class)) {
        ClusterState newState = (ClusterState)stateChange.getNewState();
        doSetClusterState(newState, isTransient);
        if (newState.isJoinAllowed())
          this.node.getClusterService().getMembershipManager().removeAllMissingMembers(); 
      } else if (stateChange.isOfType(Version.class)) {
        Version newVersion = (Version)stateChange.getNewState();
        this.logger.info("Cluster version set to " + newVersion);
        doSetClusterVersion(newVersion);
      } else {
        throw new IllegalArgumentException("Illegal ClusterStateChange of type " + stateChange.getType() + ".");
      } 
    } finally {
      this.clusterServiceLock.unlock();
    } 
  }
  
  private void changeNodeState(ClusterState newState) {
    if (newState == ClusterState.PASSIVE) {
      this.node.changeNodeStateToPassive();
    } else {
      this.node.changeNodeStateToActive();
    } 
  }
  
  void changeClusterState(ClusterStateChange stateChange, MemberMap memberMap, int partitionStateVersion, boolean isTransient) { changeClusterState(stateChange, memberMap, DEFAULT_TX_OPTIONS, partitionStateVersion, isTransient); }
  
  void changeClusterState(ClusterStateChange stateChange, MemberMap memberMap, TransactionOptions options, int partitionStateVersion, boolean isTransient) {
    checkParameters(stateChange, options);
    if (isCurrentStateEqualToRequestedOne(stateChange))
      return; 
    oldState = getState();
    requestedState = stateChange.getClusterStateOrNull();
    NodeEngineImpl nodeEngine = this.node.getNodeEngine();
    TransactionManagerServiceImpl txManagerService = (TransactionManagerServiceImpl)nodeEngine.getTransactionManagerService();
    Transaction tx = txManagerService.newAllowedDuringPassiveStateTransaction(options);
    notifyBeforeStateChange(oldState, requestedState, isTransient);
    tx.begin();
    try {
      String txnId = tx.getTxnId();
      Collection<MemberImpl> members = memberMap.getMembers();
      int memberListVersion = memberMap.getVersion();
      addTransactionRecords(stateChange, tx, members, memberListVersion, partitionStateVersion, isTransient);
      lockClusterStateOnAllMembers(stateChange, nodeEngine, options.getTimeoutMillis(), txnId, members, memberListVersion, partitionStateVersion);
      checkMemberListChange(memberListVersion);
      tx.prepare();
    } catch (Throwable e) {
      tx.rollback();
      notifyAfterStateChange(oldState, requestedState, isTransient);
      if (e instanceof com.hazelcast.spi.exception.TargetNotMemberException || e.getCause() instanceof com.hazelcast.core.MemberLeftException)
        throw new IllegalStateException("Cluster members changed during state change!", e); 
      throw ExceptionUtil.rethrow(e);
    } 
    try {
      tx.commit();
    } catch (Throwable e) {
      if (e instanceof com.hazelcast.spi.exception.TargetNotMemberException || e.getCause() instanceof com.hazelcast.core.MemberLeftException)
        return; 
      throw ExceptionUtil.rethrow(e);
    } finally {
      notifyAfterStateChange(oldState, requestedState, isTransient);
    } 
  }
  
  private void notifyBeforeStateChange(ClusterState oldState, ClusterState requestedState, boolean isTransient) {
    if (requestedState != null)
      this.node.getNodeExtension().beforeClusterStateChange(oldState, requestedState, isTransient); 
  }
  
  private void notifyAfterStateChange(ClusterState oldState, ClusterState requestedState, boolean isTransient) {
    if (requestedState != null)
      this.node.getNodeExtension().afterClusterStateChange(oldState, getState(), isTransient); 
  }
  
  private boolean isCurrentStateEqualToRequestedOne(ClusterStateChange change) {
    if (change.isOfType(ClusterState.class))
      return (getState() == change.getNewState()); 
    if (change.isOfType(Version.class))
      return (this.clusterVersion != null && this.clusterVersion.equals(change.getNewState())); 
    return false;
  }
  
  private void lockClusterStateOnAllMembers(ClusterStateChange stateChange, NodeEngineImpl nodeEngine, long leaseTime, String txnId, Collection<MemberImpl> members, int memberListVersion, int partitionStateVersion) {
    Collection<Future> futures = new ArrayList<Future>(members.size());
    Address thisAddress = this.node.getThisAddress();
    for (Member member : members) {
      LockClusterStateOp lockClusterStateOp = new LockClusterStateOp(stateChange, thisAddress, txnId, leaseTime, memberListVersion, partitionStateVersion);
      InternalCompletableFuture internalCompletableFuture = nodeEngine.getOperationService().invokeOnTarget("hz:core:clusterService", lockClusterStateOp, member.getAddress());
      futures.add(internalCompletableFuture);
    } 
    StateManagerExceptionHandler exceptionHandler = new StateManagerExceptionHandler(this.logger, null);
    FutureUtil.waitWithDeadline(futures, leaseTime, TimeUnit.MILLISECONDS, exceptionHandler);
    exceptionHandler.rethrowIfFailed();
  }
  
  private void addTransactionRecords(ClusterStateChange stateChange, Transaction tx, Collection<MemberImpl> members, int memberListVersion, int partitionStateVersion, boolean isTransient) {
    long leaseTime = Math.min(tx.getTimeoutMillis(), LOCK_LEASE_EXTENSION_MILLIS);
    for (Member member : members)
      tx.add(new ClusterStateTransactionLogRecord(stateChange, this.node.getThisAddress(), member
            .getAddress(), tx.getTxnId(), leaseTime, memberListVersion, partitionStateVersion, isTransient)); 
  }
  
  private void checkMemberListChange(int initialMemberListVersion) {
    int currentMemberListVersion = this.node.getClusterService().getMembershipManager().getMemberListVersion();
    if (initialMemberListVersion != currentMemberListVersion)
      throw new IllegalStateException("Cluster members changed during state change! Initial version: " + initialMemberListVersion + ", Current version: " + currentMemberListVersion); 
  }
  
  private void checkParameters(ClusterStateChange newState, TransactionOptions options) {
    Preconditions.checkNotNull(newState);
    Preconditions.checkNotNull(options);
    newState.validate();
    if (options.getTransactionType() != TransactionOptions.TransactionType.TWO_PHASE)
      throw new IllegalArgumentException("Changing cluster state requires 2PC transaction!"); 
  }
  
  public String stateToString() { return "ClusterState{state=" + this.state + ", lock=" + this.stateLockRef.get() + '}'; }
  
  public String toString() { return "ClusterStateManager{stateLockRef=" + this.stateLockRef + ", state=" + this.state + '}'; }
}
