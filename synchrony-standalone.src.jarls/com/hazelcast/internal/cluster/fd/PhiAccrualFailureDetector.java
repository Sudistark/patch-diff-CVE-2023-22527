package com.hazelcast.internal.cluster.fd;

import com.hazelcast.util.Preconditions;

public class PhiAccrualFailureDetector implements FailureDetector {
  static final long NO_HEARTBEAT_TIMESTAMP = -1L;
  
  private final double threshold;
  
  private final double minStdDeviationMillis;
  
  private final long acceptableHeartbeatPauseMillis;
  
  private final HeartbeatHistory heartbeatHistory;
  
  public PhiAccrualFailureDetector(double threshold, int maxSampleSize, double minStdDeviationMillis, long acceptableHeartbeatPauseMillis, long firstHeartbeatEstimateMillis) {
    this.lastHeartbeatMillis = -1L;
    this.threshold = Preconditions.checkPositive(threshold, "Threshold must be positive: " + threshold);
    this.minStdDeviationMillis = Preconditions.checkPositive(minStdDeviationMillis, "Minimum standard deviation must be positive: " + minStdDeviationMillis);
    this.acceptableHeartbeatPauseMillis = Preconditions.checkNotNegative(acceptableHeartbeatPauseMillis, "Acceptable heartbeat pause millis must be >= 0: " + acceptableHeartbeatPauseMillis);
    Preconditions.checkPositive(firstHeartbeatEstimateMillis, "First heartbeat value must be > 0: " + firstHeartbeatEstimateMillis);
    this.heartbeatHistory = new HeartbeatHistory(maxSampleSize);
    firstHeartbeat(firstHeartbeatEstimateMillis);
  }
  
  private void firstHeartbeat(long firstHeartbeatEstimateMillis) {
    long stdDeviationMillis = firstHeartbeatEstimateMillis / 4L;
    this.heartbeatHistory.add(firstHeartbeatEstimateMillis - stdDeviationMillis);
    this.heartbeatHistory.add(firstHeartbeatEstimateMillis + stdDeviationMillis);
  }
  
  private double ensureValidStdDeviation(double stdDeviationMillis) { return Math.max(stdDeviationMillis, this.minStdDeviationMillis); }
  
  private double phi(long timestampMillis) {
    double stdDeviationMillis;
    double meanMillis;
    long timeDiffMillis;
    synchronized (this.heartbeatHistory) {
      long lastTimestampMillis = this.lastHeartbeatMillis;
      if (lastTimestampMillis == -1L)
        return 0.0D; 
      timeDiffMillis = timestampMillis - lastTimestampMillis;
      meanMillis = this.heartbeatHistory.mean();
      stdDeviationMillis = ensureValidStdDeviation(this.heartbeatHistory.stdDeviation());
    } 
    return phi(timeDiffMillis, meanMillis + this.acceptableHeartbeatPauseMillis, stdDeviationMillis);
  }
  
  private static double phi(long timeDiffMillis, double meanMillis, double stdDeviationMillis) {
    double y = (timeDiffMillis - meanMillis) / stdDeviationMillis;
    double e = Math.exp(-y * (1.5976D + 0.070566D * y * y));
    if (timeDiffMillis > meanMillis)
      return -Math.log10(e / (1.0D + e)); 
    return -Math.log10(1.0D - 1.0D / (1.0D + e));
  }
  
  public boolean isAlive(long timestampMillis) {
    double phi = phi(timestampMillis);
    return (phi < this.threshold);
  }
  
  public void heartbeat(long timestampMillis) {
    synchronized (this.heartbeatHistory) {
      long lastTimestampMillis = getAndSetLastHeartbeat(timestampMillis);
      if (lastTimestampMillis == -1L)
        return; 
      if (isAlive(timestampMillis))
        this.heartbeatHistory.add(timestampMillis - lastTimestampMillis); 
    } 
  }
  
  private long getAndSetLastHeartbeat(long timestampMillis) {
    long lastTimestampMillis = this.lastHeartbeatMillis;
    this.lastHeartbeatMillis = timestampMillis;
    return lastTimestampMillis;
  }
  
  public long lastHeartbeat() { return this.lastHeartbeatMillis; }
  
  public double suspicionLevel(long timestamp) { return phi(timestamp); }
}
