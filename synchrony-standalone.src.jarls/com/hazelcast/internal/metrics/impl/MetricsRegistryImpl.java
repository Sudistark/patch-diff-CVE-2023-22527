package com.hazelcast.internal.metrics.impl;

import com.hazelcast.internal.metrics.DiscardableMetricsProvider;
import com.hazelcast.internal.metrics.DoubleGauge;
import com.hazelcast.internal.metrics.DoubleProbeFunction;
import com.hazelcast.internal.metrics.LongGauge;
import com.hazelcast.internal.metrics.LongProbeFunction;
import com.hazelcast.internal.metrics.MetricsProvider;
import com.hazelcast.internal.metrics.MetricsRegistry;
import com.hazelcast.internal.metrics.ProbeBuilder;
import com.hazelcast.internal.metrics.ProbeFunction;
import com.hazelcast.internal.metrics.ProbeLevel;
import com.hazelcast.internal.metrics.renderers.ProbeRenderer;
import com.hazelcast.internal.util.concurrent.ThreadFactoryImpl;
import com.hazelcast.logging.ILogger;
import com.hazelcast.util.ConcurrentReferenceHashMap;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.ThreadUtil;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;

public class MetricsRegistryImpl implements MetricsRegistry {
  private static final Comparator<ProbeInstance> COMPARATOR = new Object();
  
  final ILogger logger;
  
  private final ProbeLevel minimumLevel;
  
  private final ScheduledExecutorService scheduler;
  
  private final ConcurrentMap<String, ProbeInstance> probeInstances;
  
  private final ConcurrentMap<Class<?>, SourceMetadata> metadataMap;
  
  private final LockStripe lockStripe;
  
  private final AtomicLong modCount;
  
  private final AtomicReference<SortedProbeInstances> sortedProbeInstances;
  
  public MetricsRegistryImpl(ILogger logger, ProbeLevel minimumLevel) { this("default", logger, minimumLevel); }
  
  public MetricsRegistryImpl(String name, ILogger logger, ProbeLevel minimumLevel) {
    this.probeInstances = new ConcurrentHashMap();
    this.metadataMap = new ConcurrentReferenceHashMap();
    this.lockStripe = new LockStripe();
    this.modCount = new AtomicLong();
    this.sortedProbeInstances = new AtomicReference(new SortedProbeInstances(0L, Collections.emptyList()));
    this.logger = (ILogger)Preconditions.checkNotNull(logger, "logger can't be null");
    this.minimumLevel = (ProbeLevel)Preconditions.checkNotNull(minimumLevel, "minimumLevel can't be null");
    this
      .scheduler = new ScheduledThreadPoolExecutor(2, new ThreadFactoryImpl(ThreadUtil.createThreadPoolName(name, "MetricsRegistry")));
    if (logger.isFinestEnabled())
      logger.finest("MetricsRegistry minimumLevel:" + minimumLevel); 
  }
  
  public ProbeLevel minimumLevel() { return this.minimumLevel; }
  
  long modCount() { return this.modCount.get(); }
  
  public Set<String> getNames() {
    Set<String> names = new HashSet<String>(this.probeInstances.keySet());
    return Collections.unmodifiableSet(names);
  }
  
  SourceMetadata loadSourceMetadata(Class<?> clazz) {
    SourceMetadata metadata = (SourceMetadata)this.metadataMap.get(clazz);
    if (metadata == null) {
      metadata = new SourceMetadata(clazz);
      SourceMetadata found = (SourceMetadata)this.metadataMap.putIfAbsent(clazz, metadata);
      metadata = (found == null) ? metadata : found;
    } 
    return metadata;
  }
  
  public <S> void scanAndRegister(S source, String namePrefix) {
    Preconditions.checkNotNull(source, "source can't be null");
    Preconditions.checkNotNull(namePrefix, "namePrefix can't be null");
    SourceMetadata metadata = loadSourceMetadata(source.getClass());
    metadata.register(this, source, namePrefix);
  }
  
  public <S> void register(S source, String name, ProbeLevel level, LongProbeFunction<S> function) {
    Preconditions.checkNotNull(source, "source can't be null");
    Preconditions.checkNotNull(name, "name can't be null");
    Preconditions.checkNotNull(function, "function can't be null");
    Preconditions.checkNotNull(level, "level can't be null");
    registerInternal(source, name, level, function);
  }
  
  public <S> void register(S source, String name, ProbeLevel level, DoubleProbeFunction<S> function) {
    Preconditions.checkNotNull(source, "source can't be null");
    Preconditions.checkNotNull(name, "name can't be null");
    Preconditions.checkNotNull(function, "function can't be null");
    Preconditions.checkNotNull(level, "level can't be null");
    registerInternal(source, name, level, function);
  }
  
  ProbeInstance getProbeInstance(String name) {
    Preconditions.checkNotNull(name, "name can't be null");
    return (ProbeInstance)this.probeInstances.get(name);
  }
  
  <S> void registerInternal(S source, String name, ProbeLevel probeLevel, ProbeFunction function) {
    if (!probeLevel.isEnabled(this.minimumLevel))
      return; 
    ProbeInstance probeInstance = (ProbeInstance)this.probeInstances.putIfAbsent(name, new ProbeInstance(name, source, function));
    if (probeInstance != null) {
      logOverwrite(probeInstance);
      synchronized (this.lockStripe.getLock(source)) {
        probeInstance.source = source;
        probeInstance.function = function;
      } 
    } 
    if (this.logger.isFinestEnabled())
      this.logger.finest("Registered probeInstance " + name); 
    this.modCount.incrementAndGet();
  }
  
  private void logOverwrite(ProbeInstance probeInstance) {
    if (probeInstance.function != null || probeInstance.source != null)
      this.logger.warning(String.format("Overwriting existing probe '%s'", new Object[] { probeInstance.name })); 
  }
  
  public LongGaugeImpl newLongGauge(String name) {
    Preconditions.checkNotNull(name, "name can't be null");
    return new LongGaugeImpl(this, name);
  }
  
  public DoubleGauge newDoubleGauge(String name) {
    Preconditions.checkNotNull(name, "name can't be null");
    return new DoubleGaugeImpl(this, name);
  }
  
  public <S> void deregister(S source) {
    if (source == null)
      return; 
    boolean changed = false;
    for (Map.Entry<String, ProbeInstance> entry : this.probeInstances.entrySet()) {
      ProbeInstance probeInstance = (ProbeInstance)entry.getValue();
      if (probeInstance.source != source)
        continue; 
      String name = (String)entry.getKey();
      boolean destroyed = false;
      synchronized (this.lockStripe.getLock(source)) {
        if (probeInstance.source == source) {
          changed = true;
          this.probeInstances.remove(name);
          probeInstance.source = null;
          probeInstance.function = null;
          destroyed = true;
        } 
      } 
      if (destroyed && this.logger.isFinestEnabled())
        this.logger.finest("Destroying probeInstance " + name); 
    } 
    if (changed)
      this.modCount.incrementAndGet(); 
  }
  
  public void render(ProbeRenderer renderer) {
    Preconditions.checkNotNull(renderer, "renderer can't be null");
    for (ProbeInstance probeInstance : getSortedProbeInstances())
      render(renderer, probeInstance); 
  }
  
  public void collectMetrics(Object... objects) {
    for (Object object : objects) {
      if (object instanceof MetricsProvider)
        ((MetricsProvider)object).provideMetrics(this); 
    } 
  }
  
  public void discardMetrics(Object... objects) {
    for (Object object : objects) {
      if (object instanceof DiscardableMetricsProvider)
        ((DiscardableMetricsProvider)object).discardMetrics(this); 
    } 
  }
  
  List<ProbeInstance> getSortedProbeInstances() {
    SortedProbeInstances sortedInstances;
    long modCountLocal = this.modCount.get();
    SortedProbeInstances sortedInstancesOld = (SortedProbeInstances)this.sortedProbeInstances.get();
    if (SortedProbeInstances.access$000(sortedInstancesOld) < modCountLocal) {
      List<ProbeInstance> sorted = new ArrayList<ProbeInstance>(this.probeInstances.values());
      Collections.sort(sorted, COMPARATOR);
      sortedInstances = new SortedProbeInstances(modCountLocal, sorted);
      this.sortedProbeInstances.compareAndSet(sortedInstancesOld, sortedInstances);
    } else {
      sortedInstances = sortedInstancesOld;
    } 
    return SortedProbeInstances.access$100(sortedInstances);
  }
  
  private void render(ProbeRenderer renderer, ProbeInstance probeInstance) {
    ProbeFunction function = probeInstance.function;
    Object source = probeInstance.source;
    String name = probeInstance.name;
    if (function == null || source == null) {
      renderer.renderNoValue(name);
      return;
    } 
    try {
      if (function instanceof LongProbeFunction) {
        LongProbeFunction longFunction = (LongProbeFunction)function;
        renderer.renderLong(name, longFunction.get(source));
      } else {
        DoubleProbeFunction doubleFunction = (DoubleProbeFunction)function;
        renderer.renderDouble(name, doubleFunction.get(source));
      } 
    } catch (Exception e) {
      renderer.renderException(name, e);
    } 
  }
  
  public void scheduleAtFixedRate(Runnable publisher, long period, TimeUnit timeUnit, ProbeLevel probeLevel) {
    if (!probeLevel.isEnabled(this.minimumLevel))
      return; 
    this.scheduler.scheduleAtFixedRate(publisher, 0L, period, timeUnit);
  }
  
  public void shutdown() { this.scheduler.shutdownNow(); }
  
  public ProbeBuilder newProbeBuilder() { return new ProbeBuilderImpl(this); }
}
