package com.hazelcast.internal.metrics.impl;

import com.hazelcast.util.MapUtil;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;

final class ProbeUtils {
  static final int TYPE_PRIMITIVE_LONG = 1;
  
  static final int TYPE_LONG_NUMBER = 2;
  
  static final int TYPE_DOUBLE_PRIMITIVE = 3;
  
  static final int TYPE_DOUBLE_NUMBER = 4;
  
  static final int TYPE_COLLECTION = 5;
  
  static final int TYPE_MAP = 6;
  
  static final int TYPE_COUNTER = 7;
  
  static final int TYPE_SEMAPHORE = 8;
  
  private static final Map<Class<?>, Integer> TYPES;
  
  static  {
    types = MapUtil.createHashMap(18);
    types.put(byte.class, Integer.valueOf(1));
    types.put(short.class, Integer.valueOf(1));
    types.put(int.class, Integer.valueOf(1));
    types.put(long.class, Integer.valueOf(1));
    types.put(Byte.class, Integer.valueOf(2));
    types.put(Short.class, Integer.valueOf(2));
    types.put(Integer.class, Integer.valueOf(2));
    types.put(Long.class, Integer.valueOf(2));
    types.put(java.util.concurrent.atomic.AtomicInteger.class, Integer.valueOf(2));
    types.put(java.util.concurrent.atomic.AtomicLong.class, Integer.valueOf(2));
    types.put(double.class, Integer.valueOf(3));
    types.put(float.class, Integer.valueOf(3));
    types.put(Double.class, Integer.valueOf(4));
    types.put(Float.class, Integer.valueOf(4));
    types.put(java.util.Collection.class, Integer.valueOf(5));
    types.put(Map.class, Integer.valueOf(6));
    types.put(com.hazelcast.internal.util.counters.Counter.class, Integer.valueOf(7));
    types.put(java.util.concurrent.Semaphore.class, Integer.valueOf(8));
    TYPES = Collections.unmodifiableMap(types);
  }
  
  static boolean isDouble(int type) { return (type == 3 || type == 4); }
  
  static int getType(Class classType) {
    Integer type = (Integer)TYPES.get(classType);
    if (type != null)
      return type.intValue(); 
    List<Class<?>> flattenedClasses = new ArrayList<Class<?>>();
    flatten(classType, flattenedClasses);
    for (Class<?> clazz : flattenedClasses) {
      type = (Integer)TYPES.get(clazz);
      if (type != null)
        return type.intValue(); 
    } 
    return -1;
  }
  
  static void flatten(Class clazz, List<Class<?>> result) {
    if (!result.contains(clazz))
      result.add(clazz); 
    if (clazz.getSuperclass() != null)
      flatten(clazz.getSuperclass(), result); 
    for (Class interfaze : clazz.getInterfaces()) {
      if (!result.contains(interfaze))
        result.add(interfaze); 
      flatten(interfaze, result);
    } 
  }
}
