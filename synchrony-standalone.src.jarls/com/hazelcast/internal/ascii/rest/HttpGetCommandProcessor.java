package com.hazelcast.internal.ascii.rest;

import com.hazelcast.cluster.ClusterState;
import com.hazelcast.core.ICompletableFuture;
import com.hazelcast.cp.CPGroup;
import com.hazelcast.cp.CPGroupId;
import com.hazelcast.cp.CPMember;
import com.hazelcast.cp.CPSubsystem;
import com.hazelcast.cp.CPSubsystemManagementService;
import com.hazelcast.cp.session.CPSession;
import com.hazelcast.instance.EndpointQualifier;
import com.hazelcast.instance.Node;
import com.hazelcast.instance.NodeState;
import com.hazelcast.internal.ascii.TextCommandConstants;
import com.hazelcast.internal.ascii.TextCommandService;
import com.hazelcast.internal.cluster.impl.ClusterServiceImpl;
import com.hazelcast.internal.json.JsonObject;
import com.hazelcast.internal.partition.InternalPartitionService;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.AggregateEndpointManager;
import com.hazelcast.nio.EndpointManager;
import com.hazelcast.nio.NetworkingService;
import com.hazelcast.util.StringUtil;
import java.util.Collection;

public class HttpGetCommandProcessor extends HttpCommandProcessor<HttpGetCommand> {
  public static final String QUEUE_SIZE_COMMAND = "size";
  
  private static final String HEALTH_PATH_PARAM_NODE_STATE = "/node-state";
  
  private static final String HEALTH_PATH_PARAM_CLUSTER_STATE = "/cluster-state";
  
  private static final String HEALTH_PATH_PARAM_CLUSTER_SAFE = "/cluster-safe";
  
  private static final String HEALTH_PATH_PARAM_MIGRATION_QUEUE_SIZE = "/migration-queue-size";
  
  private static final String HEALTH_PATH_PARAM_CLUSTER_SIZE = "/cluster-size";
  
  public HttpGetCommandProcessor(TextCommandService textCommandService) { super(textCommandService); }
  
  public void handle(HttpGetCommand command) {
    boolean sendResponse = true;
    try {
      String uri = command.getURI();
      if (uri.startsWith("/hazelcast/rest/maps/")) {
        handleMap(command, uri);
      } else if (uri.startsWith("/hazelcast/rest/queues/")) {
        handleQueue(command, uri);
      } else if (uri.startsWith("/hazelcast/rest/cluster")) {
        handleCluster(command);
      } else if (uri.startsWith("/hazelcast/health/ready")) {
        handleHealthReady(command);
      } else if (uri.startsWith("/hazelcast/health")) {
        handleHealthcheck(command, uri);
      } else if (uri.startsWith("/hazelcast/rest/management/cluster/version")) {
        handleGetClusterVersion(command);
      } else if (uri.startsWith("/hazelcast/rest/license")) {
        handleLicense(command);
      } else if (uri.startsWith("/hazelcast/rest/cp-subsystem/groups")) {
        handleCPGroupRequest(command);
        sendResponse = false;
      } else if (uri.startsWith("/hazelcast/rest/cp-subsystem/members/local")) {
        handleGetLocalCPMember(command);
      } else if (uri.startsWith("/hazelcast/rest/cp-subsystem/members")) {
        handleGetCPMembers(command);
        sendResponse = false;
      } else {
        command.send404();
      } 
    } catch (IndexOutOfBoundsException e) {
      command.send400();
    } catch (Exception e) {
      command.send500();
    } 
    if (sendResponse)
      this.textCommandService.sendResponse(command); 
  }
  
  private void handleHealthReady(HttpGetCommand command) {
    Node node = this.textCommandService.getNode();
    if (node.isRunning() && node
      .getNodeExtension().isStartCompleted()) {
      command.setResponse(HttpCommand.RES_200_WITH_NO_CONTENT);
    } else {
      command.setResponse(HttpCommand.RES_503);
    } 
  }
  
  private void handleHealthcheck(HttpGetCommand command, String uri) {
    Node node = this.textCommandService.getNode();
    NodeState nodeState = node.getState();
    ClusterServiceImpl clusterService = node.getClusterService();
    ClusterState clusterState = clusterService.getClusterState();
    int clusterSize = clusterService.getMembers().size();
    InternalPartitionService partitionService = node.getPartitionService();
    boolean memberStateSafe = partitionService.isMemberStateSafe();
    boolean clusterSafe = (memberStateSafe && !partitionService.hasOnGoingMigration());
    long migrationQueueSize = partitionService.getMigrationQueueSize();
    String healthParameter = uri.substring("/hazelcast/health".length());
    if (healthParameter.equals("/node-state")) {
      if (NodeState.SHUT_DOWN.equals(nodeState)) {
        command.setResponse(HttpCommand.RES_503);
      } else {
        command.setResponse(null, StringUtil.stringToBytes(nodeState.toString()));
      } 
    } else if (healthParameter.equals("/cluster-state")) {
      command.setResponse(null, StringUtil.stringToBytes(clusterState.toString()));
    } else if (healthParameter.equals("/cluster-safe")) {
      if (clusterSafe) {
        command.send200();
      } else {
        command.setResponse(HttpCommand.RES_503);
      } 
    } else if (healthParameter.equals("/migration-queue-size")) {
      command.setResponse(null, StringUtil.stringToBytes(Long.toString(migrationQueueSize)));
    } else if (healthParameter.equals("/cluster-size")) {
      command.setResponse(null, StringUtil.stringToBytes(Integer.toString(clusterSize)));
    } else if (healthParameter.isEmpty()) {
      StringBuilder res = new StringBuilder();
      res.append("Hazelcast::NodeState=").append(nodeState).append("\n");
      res.append("Hazelcast::ClusterState=").append(clusterState).append("\n");
      res.append("Hazelcast::ClusterSafe=").append(booleanToString(clusterSafe)).append("\n");
      res.append("Hazelcast::MigrationQueueSize=").append(migrationQueueSize).append("\n");
      res.append("Hazelcast::ClusterSize=").append(clusterSize).append("\n");
      command.setResponse(TextCommandConstants.MIME_TEXT_PLAIN, StringUtil.stringToBytes(res.toString()));
    } else {
      command.send400();
    } 
  }
  
  private static String booleanToString(boolean b) { return Boolean.toString(b).toUpperCase(StringUtil.LOCALE_INTERNAL); }
  
  private void handleGetClusterVersion(HttpGetCommand command) {
    String res = "{\"status\":\"${STATUS}\",\"version\":\"${VERSION}\"}";
    Node node = this.textCommandService.getNode();
    ClusterServiceImpl clusterServiceImpl = node.getClusterService();
    res = res.replace("${STATUS}", "success");
    res = res.replace("${VERSION}", clusterServiceImpl.getClusterVersion().toString());
    command.setResponse(HttpCommand.CONTENT_TYPE_JSON, StringUtil.stringToBytes(res));
  }
  
  private void handleCPGroupRequest(HttpGetCommand command) {
    String uri = command.getURI();
    if (uri.contains("/sessions")) {
      handleGetCPSessions(command);
    } else if (uri.endsWith("/hazelcast/rest/cp-subsystem/groups") || uri.endsWith("/hazelcast/rest/cp-subsystem/groups/")) {
      handleGetCPGroupIds(command);
    } else {
      handleGetCPGroupByName(command);
    } 
  }
  
  private void handleGetCPGroupIds(HttpGetCommand command) {
    ICompletableFuture<Collection<CPGroupId>> f = getCpSubsystemManagementService().getCPGroupIds();
    f.andThen(new Object(this, command));
  }
  
  private void handleGetCPSessions(HttpGetCommand command) {
    String uri = command.getURI();
    String prefix = "/hazelcast/rest/cp-subsystem/groups/";
    int i = uri.indexOf("/sessions");
    String groupName = uri.substring(prefix.length(), i).trim();
    getCpSubsystem().getCPSessionManagementService()
      .getAllSessions(groupName)
      .andThen(new Object(this, command));
  }
  
  private void handleGetCPGroupByName(HttpGetCommand command) {
    String prefix = "/hazelcast/rest/cp-subsystem/groups/";
    String groupName = command.getURI().substring(prefix.length()).trim();
    ICompletableFuture<CPGroup> f = getCpSubsystemManagementService().getCPGroup(groupName);
    f.andThen(new Object(this, command));
  }
  
  private void handleGetCPMembers(HttpGetCommand command) {
    ICompletableFuture<Collection<CPMember>> f = getCpSubsystemManagementService().getCPMembers();
    f.andThen(new Object(this, command));
  }
  
  private void handleGetLocalCPMember(HttpGetCommand command) {
    CPMember localCPMember = getCpSubsystem().getLocalCPMember();
    if (localCPMember != null) {
      command.setResponse(HttpCommand.CONTENT_TYPE_JSON, StringUtil.stringToBytes(toJson(localCPMember).toString()));
    } else {
      command.send404();
    } 
  }
  
  private CPSubsystemManagementService getCpSubsystemManagementService() { return getCpSubsystem().getCPSubsystemManagementService(); }
  
  private CPSubsystem getCpSubsystem() { return this.textCommandService.getNode().getNodeEngine().getHazelcastInstance().getCPSubsystem(); }
  
  private JsonObject toJson(CPGroupId groupId) { return (new JsonObject()).add("name", groupId.name()).add("id", groupId.id()); }
  
  private JsonObject toJson(CPMember cpMember) {
    Address address = cpMember.getAddress();
    return (new JsonObject())
      .add("uuid", cpMember.getUuid())
      .add("address", "[" + address.getHost() + "]:" + address.getPort());
  }
  
  private JsonObject toJson(CPSession cpSession) {
    Address address = cpSession.endpoint();
    return (new JsonObject())
      .add("id", cpSession.id())
      .add("creationTime", cpSession.creationTime())
      .add("expirationTime", cpSession.expirationTime())
      .add("version", cpSession.version())
      .add("endpoint", "[" + address.getHost() + "]:" + address.getPort())
      .add("endpointType", cpSession.endpointType().name())
      .add("endpointName", cpSession.endpointName());
  }
  
  private void handleCluster(HttpGetCommand command) {
    Node node = this.textCommandService.getNode();
    StringBuilder res = new StringBuilder(node.getClusterService().getMemberListString());
    res.append("\n");
    NetworkingService ns = node.getNetworkingService();
    EndpointManager cem = ns.getEndpointManager(EndpointQualifier.CLIENT);
    AggregateEndpointManager aem = ns.getAggregateEndpointManager();
    res.append("ConnectionCount: ").append((cem == null) ? "0" : Integer.valueOf(cem.getActiveConnections().size()));
    res.append("\n");
    res.append("AllConnectionCount: ").append(aem.getActiveConnections().size());
    res.append("\n");
    command.setResponse(null, StringUtil.stringToBytes(res.toString()));
  }
  
  private void handleQueue(HttpGetCommand command, String uri) {
    int indexEnd = uri.indexOf('/', "/hazelcast/rest/queues/".length());
    String queueName = uri.substring("/hazelcast/rest/queues/".length(), indexEnd);
    String secondStr = (uri.length() > indexEnd + 1) ? uri.substring(indexEnd + 1) : null;
    if ("size".equalsIgnoreCase(secondStr)) {
      int size = this.textCommandService.size(queueName);
      prepareResponse(command, Integer.toString(size));
    } else {
      int seconds = (secondStr == null) ? 0 : Integer.parseInt(secondStr);
      Object value = this.textCommandService.poll(queueName, seconds);
      prepareResponse(command, value);
    } 
  }
  
  private void handleMap(HttpGetCommand command, String uri) {
    int indexEnd = uri.indexOf('/', "/hazelcast/rest/maps/".length());
    String mapName = uri.substring("/hazelcast/rest/maps/".length(), indexEnd);
    String key = uri.substring(indexEnd + 1);
    Object value = this.textCommandService.get(mapName, key);
    prepareResponse(command, value);
  }
  
  public void handleRejection(HttpGetCommand command) { handle(command); }
  
  private void prepareResponse(HttpGetCommand command, Object value) {
    if (value == null) {
      command.send204();
    } else if (value instanceof byte[]) {
      command.setResponse(HttpCommand.CONTENT_TYPE_BINARY, (byte[])value);
    } else if (value instanceof RestValue) {
      RestValue restValue = (RestValue)value;
      command.setResponse(restValue.getContentType(), restValue.getValue());
    } else if (value instanceof String) {
      command.setResponse(HttpCommand.CONTENT_TYPE_PLAIN_TEXT, StringUtil.stringToBytes((String)value));
    } else {
      command.setResponse(HttpCommand.CONTENT_TYPE_BINARY, this.textCommandService.toByteArray(value));
    } 
  }
  
  protected void handleLicense(HttpGetCommand command) { command.send404(); }
}
