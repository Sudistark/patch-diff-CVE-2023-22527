package com.hazelcast.internal.dynamicconfig;

import com.hazelcast.config.AtomicLongConfig;
import com.hazelcast.config.AtomicReferenceConfig;
import com.hazelcast.config.CacheSimpleConfig;
import com.hazelcast.config.CardinalityEstimatorConfig;
import com.hazelcast.config.ConfigPatternMatcher;
import com.hazelcast.config.ConfigurationException;
import com.hazelcast.config.CountDownLatchConfig;
import com.hazelcast.config.DurableExecutorConfig;
import com.hazelcast.config.EventJournalConfig;
import com.hazelcast.config.ExecutorConfig;
import com.hazelcast.config.FlakeIdGeneratorConfig;
import com.hazelcast.config.ListConfig;
import com.hazelcast.config.LockConfig;
import com.hazelcast.config.MapConfig;
import com.hazelcast.config.MerkleTreeConfig;
import com.hazelcast.config.MultiMapConfig;
import com.hazelcast.config.PNCounterConfig;
import com.hazelcast.config.QueueConfig;
import com.hazelcast.config.ReliableTopicConfig;
import com.hazelcast.config.ReplicatedMapConfig;
import com.hazelcast.config.RingbufferConfig;
import com.hazelcast.config.ScheduledExecutorConfig;
import com.hazelcast.config.SemaphoreConfig;
import com.hazelcast.config.SetConfig;
import com.hazelcast.config.TopicConfig;
import com.hazelcast.core.ICompletableFuture;
import com.hazelcast.internal.cluster.ClusterService;
import com.hazelcast.internal.cluster.ClusterVersionListener;
import com.hazelcast.internal.cluster.Versions;
import com.hazelcast.internal.config.ConfigUtils;
import com.hazelcast.internal.util.InvocationUtil;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.nio.serialization.IdentifiedDataSerializable;
import com.hazelcast.spi.CoreService;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.PreJoinAwareService;
import com.hazelcast.spi.SplitBrainHandlerService;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.version.Version;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutionException;

public class ClusterWideConfigurationService implements PreJoinAwareService, CoreService, ClusterVersionListener, ManagedService, ConfigurationService, SplitBrainHandlerService {
  public static final String SERVICE_NAME = "configuration-service";
  
  public static final int CONFIG_PUBLISH_MAX_ATTEMPT_COUNT = 100;
  
  static final Map<Class<? extends IdentifiedDataSerializable>, Version> CONFIG_TO_VERSION;
  
  private static final boolean IGNORE_CONFLICTING_CONFIGS_WORKAROUND = Boolean.getBoolean("hazelcast.dynamicconfig.ignore.conflicts");
  
  private final DynamicConfigListener listener;
  
  private final Object journalMutex;
  
  private NodeEngine nodeEngine;
  
  private final ConcurrentMap<String, MapConfig> mapConfigs;
  
  private final ConcurrentMap<String, MultiMapConfig> multiMapConfigs;
  
  private final ConcurrentMap<String, CardinalityEstimatorConfig> cardinalityEstimatorConfigs;
  
  private final ConcurrentMap<String, PNCounterConfig> pnCounterConfigs;
  
  private final ConcurrentMap<String, RingbufferConfig> ringbufferConfigs;
  
  private final ConcurrentMap<String, AtomicLongConfig> atomicLongConfigs;
  
  private final ConcurrentMap<String, AtomicReferenceConfig> atomicReferenceConfigs;
  
  private final ConcurrentMap<String, CountDownLatchConfig> countDownLatchConfigs;
  
  private final ConcurrentMap<String, LockConfig> lockConfigs;
  
  private final ConcurrentMap<String, ListConfig> listConfigs;
  
  private final ConcurrentMap<String, SetConfig> setConfigs;
  
  private final ConcurrentMap<String, ReplicatedMapConfig> replicatedMapConfigs;
  
  private final ConcurrentMap<String, TopicConfig> topicConfigs;
  
  private final ConcurrentMap<String, ExecutorConfig> executorConfigs;
  
  private final ConcurrentMap<String, DurableExecutorConfig> durableExecutorConfigs;
  
  private final ConcurrentMap<String, ScheduledExecutorConfig> scheduledExecutorConfigs;
  
  private final ConcurrentMap<String, SemaphoreConfig> semaphoreConfigs;
  
  private final ConcurrentMap<String, QueueConfig> queueConfigs;
  
  private final ConcurrentMap<String, ReliableTopicConfig> reliableTopicConfigs;
  
  private final ConcurrentMap<String, CacheSimpleConfig> cacheSimpleConfigs;
  
  private final ConcurrentMap<String, EventJournalConfig> cacheEventJournalConfigs;
  
  private final ConcurrentMap<String, EventJournalConfig> mapEventJournalConfigs;
  
  private final ConcurrentMap<String, MerkleTreeConfig> mapMerkleTreeConfigs;
  
  private final ConcurrentMap<String, FlakeIdGeneratorConfig> flakeIdGeneratorConfigs;
  
  private final ConfigPatternMatcher configPatternMatcher;
  
  private final ILogger logger;
  
  private final Map<?, ? extends IdentifiedDataSerializable>[] allConfigurations;
  
  static  {
    CONFIG_TO_VERSION = initializeConfigToVersionMap();
  }
  
  public ClusterWideConfigurationService(NodeEngine nodeEngine, DynamicConfigListener dynamicConfigListener) {
    this.journalMutex = new Object();
    this.mapConfigs = new ConcurrentHashMap();
    this.multiMapConfigs = new ConcurrentHashMap();
    this.cardinalityEstimatorConfigs = new ConcurrentHashMap();
    this.pnCounterConfigs = new ConcurrentHashMap();
    this.ringbufferConfigs = new ConcurrentHashMap();
    this.atomicLongConfigs = new ConcurrentHashMap();
    this.atomicReferenceConfigs = new ConcurrentHashMap();
    this.countDownLatchConfigs = new ConcurrentHashMap();
    this.lockConfigs = new ConcurrentHashMap();
    this.listConfigs = new ConcurrentHashMap();
    this.setConfigs = new ConcurrentHashMap();
    this.replicatedMapConfigs = new ConcurrentHashMap();
    this.topicConfigs = new ConcurrentHashMap();
    this.executorConfigs = new ConcurrentHashMap();
    this.durableExecutorConfigs = new ConcurrentHashMap();
    this.scheduledExecutorConfigs = new ConcurrentHashMap();
    this.semaphoreConfigs = new ConcurrentHashMap();
    this.queueConfigs = new ConcurrentHashMap();
    this.reliableTopicConfigs = new ConcurrentHashMap();
    this.cacheSimpleConfigs = new ConcurrentHashMap();
    this.cacheEventJournalConfigs = new ConcurrentHashMap();
    this.mapEventJournalConfigs = new ConcurrentHashMap();
    this.mapMerkleTreeConfigs = new ConcurrentHashMap();
    this.flakeIdGeneratorConfigs = new ConcurrentHashMap();
    this.allConfigurations = new Map[] { 
        this.mapConfigs, this.multiMapConfigs, this.cardinalityEstimatorConfigs, this.ringbufferConfigs, this.lockConfigs, this.listConfigs, this.setConfigs, this.atomicLongConfigs, this.atomicReferenceConfigs, this.countDownLatchConfigs, 
        this.replicatedMapConfigs, this.topicConfigs, this.executorConfigs, this.durableExecutorConfigs, this.scheduledExecutorConfigs, this.semaphoreConfigs, this.queueConfigs, this.reliableTopicConfigs, this.cacheSimpleConfigs, this.cacheEventJournalConfigs, 
        this.mapEventJournalConfigs, this.mapMerkleTreeConfigs, this.flakeIdGeneratorConfigs, this.pnCounterConfigs };
    this.nodeEngine = nodeEngine;
    this.listener = dynamicConfigListener;
    this.configPatternMatcher = nodeEngine.getConfig().getConfigPatternMatcher();
    this.logger = nodeEngine.getLogger(ClusterWideConfigurationService.class);
  }
  
  public Operation getPreJoinOperation() {
    IdentifiedDataSerializable[] allConfigurations = collectAllDynamicConfigs();
    if (noConfigurationExist(allConfigurations))
      return null; 
    return new DynamicConfigPreJoinOperation(allConfigurations, ConfigCheckMode.WARNING);
  }
  
  private boolean noConfigurationExist(IdentifiedDataSerializable[] configurations) { return (configurations.length == 0); }
  
  private IdentifiedDataSerializable[] collectAllDynamicConfigs() {
    List<IdentifiedDataSerializable> all = new ArrayList<IdentifiedDataSerializable>();
    for (Map<?, ? extends IdentifiedDataSerializable> entry : this.allConfigurations) {
      Collection<? extends IdentifiedDataSerializable> values = entry.values();
      all.addAll(values);
    } 
    return (IdentifiedDataSerializable[])all.toArray(new IdentifiedDataSerializable[0]);
  }
  
  public void onClusterVersionChange(Version newVersion) { this.version = newVersion; }
  
  public void init(NodeEngine nodeEngine, Properties properties) { this.listener.onServiceInitialized(this); }
  
  public void reset() {
    for (Map<?, ?> entry : this.allConfigurations)
      entry.clear(); 
  }
  
  public void shutdown(boolean terminate) {}
  
  public void broadcastConfig(IdentifiedDataSerializable config) {
    ICompletableFuture<Object> future = broadcastConfigAsync(config);
    try {
      future.get();
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      ExceptionUtil.rethrow(e);
    } catch (ExecutionException e) {
      ExceptionUtil.rethrow(e);
    } 
  }
  
  public ICompletableFuture<Object> broadcastConfigAsync(IdentifiedDataSerializable config) {
    checkConfigVersion(config);
    IdentifiedDataSerializable clonedConfig = cloneConfig(config);
    ClusterService clusterService = this.nodeEngine.getClusterService();
    return InvocationUtil.invokeOnStableClusterSerial(this.nodeEngine, new AddDynamicConfigOperationSupplier(clusterService, clonedConfig), 100);
  }
  
  private void checkConfigVersion(IdentifiedDataSerializable config) {
    Class<? extends IdentifiedDataSerializable> configClass = config.getClass();
    Version currentClusterVersion = this.version;
    Version introducedIn = (Version)CONFIG_TO_VERSION.get(configClass);
    if (currentClusterVersion.isLessThan(introducedIn))
      throw new UnsupportedOperationException(String.format("Config '%s' is available since version '%s'. Current cluster version '%s' does not allow dynamically adding '%1$s'.", new Object[] { configClass
              
              .getSimpleName(), introducedIn
              .toString(), currentClusterVersion
              .toString() })); 
  }
  
  private IdentifiedDataSerializable cloneConfig(IdentifiedDataSerializable config) {
    SerializationService serializationService = this.nodeEngine.getSerializationService();
    Data data = serializationService.toData(config);
    return (IdentifiedDataSerializable)serializationService.toObject(data);
  }
  
  public void registerConfigLocally(IdentifiedDataSerializable newConfig, ConfigCheckMode configCheckMode) {
    IdentifiedDataSerializable currentConfig = null;
    if (newConfig instanceof MultiMapConfig) {
      MultiMapConfig multiMapConfig = (MultiMapConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.multiMapConfigs.putIfAbsent(multiMapConfig.getName(), multiMapConfig);
    } else if (newConfig instanceof MapConfig) {
      MapConfig newMapConfig = (MapConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.mapConfigs.putIfAbsent(newMapConfig.getName(), newMapConfig);
      if (currentConfig == null)
        this.listener.onConfigRegistered(newMapConfig); 
    } else if (newConfig instanceof CardinalityEstimatorConfig) {
      CardinalityEstimatorConfig cardinalityEstimatorConfig = (CardinalityEstimatorConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.cardinalityEstimatorConfigs.putIfAbsent(cardinalityEstimatorConfig.getName(), cardinalityEstimatorConfig);
    } else if (newConfig instanceof RingbufferConfig) {
      RingbufferConfig ringbufferConfig = (RingbufferConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.ringbufferConfigs.putIfAbsent(ringbufferConfig.getName(), ringbufferConfig);
    } else if (newConfig instanceof LockConfig) {
      LockConfig lockConfig = (LockConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.lockConfigs.putIfAbsent(lockConfig.getName(), lockConfig);
    } else if (newConfig instanceof AtomicLongConfig) {
      AtomicLongConfig atomicLongConfig = (AtomicLongConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.atomicLongConfigs.putIfAbsent(atomicLongConfig.getName(), atomicLongConfig);
    } else if (newConfig instanceof AtomicReferenceConfig) {
      AtomicReferenceConfig atomicReferenceConfig = (AtomicReferenceConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.atomicReferenceConfigs.putIfAbsent(atomicReferenceConfig.getName(), atomicReferenceConfig);
    } else if (newConfig instanceof CountDownLatchConfig) {
      CountDownLatchConfig countDownLatchConfig = (CountDownLatchConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.countDownLatchConfigs.putIfAbsent(countDownLatchConfig.getName(), countDownLatchConfig);
    } else if (newConfig instanceof ListConfig) {
      ListConfig listConfig = (ListConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.listConfigs.putIfAbsent(listConfig.getName(), listConfig);
    } else if (newConfig instanceof SetConfig) {
      SetConfig setConfig = (SetConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.setConfigs.putIfAbsent(setConfig.getName(), setConfig);
    } else if (newConfig instanceof ReplicatedMapConfig) {
      ReplicatedMapConfig replicatedMapConfig = (ReplicatedMapConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.replicatedMapConfigs.putIfAbsent(replicatedMapConfig.getName(), replicatedMapConfig);
    } else if (newConfig instanceof TopicConfig) {
      TopicConfig topicConfig = (TopicConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.topicConfigs.putIfAbsent(topicConfig.getName(), topicConfig);
    } else if (newConfig instanceof ExecutorConfig) {
      ExecutorConfig executorConfig = (ExecutorConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.executorConfigs.putIfAbsent(executorConfig.getName(), executorConfig);
    } else if (newConfig instanceof DurableExecutorConfig) {
      DurableExecutorConfig durableExecutorConfig = (DurableExecutorConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.durableExecutorConfigs.putIfAbsent(durableExecutorConfig.getName(), durableExecutorConfig);
    } else if (newConfig instanceof ScheduledExecutorConfig) {
      ScheduledExecutorConfig scheduledExecutorConfig = (ScheduledExecutorConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.scheduledExecutorConfigs.putIfAbsent(scheduledExecutorConfig.getName(), scheduledExecutorConfig);
    } else if (newConfig instanceof QueueConfig) {
      QueueConfig queueConfig = (QueueConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.queueConfigs.putIfAbsent(queueConfig.getName(), queueConfig);
    } else if (newConfig instanceof ReliableTopicConfig) {
      ReliableTopicConfig reliableTopicConfig = (ReliableTopicConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.reliableTopicConfigs.putIfAbsent(reliableTopicConfig.getName(), reliableTopicConfig);
    } else if (newConfig instanceof CacheSimpleConfig) {
      CacheSimpleConfig cacheSimpleConfig = (CacheSimpleConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.cacheSimpleConfigs.putIfAbsent(cacheSimpleConfig.getName(), cacheSimpleConfig);
      if (currentConfig == null)
        this.listener.onConfigRegistered(cacheSimpleConfig); 
    } else if (newConfig instanceof EventJournalConfig) {
      EventJournalConfig eventJournalConfig = (EventJournalConfig)newConfig;
      registerEventJournalConfig(eventJournalConfig, configCheckMode);
    } else if (newConfig instanceof MerkleTreeConfig) {
      MerkleTreeConfig config = (MerkleTreeConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.mapMerkleTreeConfigs.putIfAbsent(config.getMapName(), config);
    } else if (newConfig instanceof SemaphoreConfig) {
      SemaphoreConfig semaphoreConfig = (SemaphoreConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.semaphoreConfigs.putIfAbsent(semaphoreConfig.getName(), semaphoreConfig);
    } else if (newConfig instanceof FlakeIdGeneratorConfig) {
      FlakeIdGeneratorConfig config = (FlakeIdGeneratorConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.flakeIdGeneratorConfigs.putIfAbsent(config.getName(), config);
    } else if (newConfig instanceof PNCounterConfig) {
      PNCounterConfig config = (PNCounterConfig)newConfig;
      currentConfig = (IdentifiedDataSerializable)this.pnCounterConfigs.putIfAbsent(config.getName(), config);
    } else {
      throw new UnsupportedOperationException("Unsupported config type: " + newConfig);
    } 
    checkCurrentConfigNullOrEqual(configCheckMode, currentConfig, newConfig);
  }
  
  private void registerEventJournalConfig(EventJournalConfig eventJournalConfig, ConfigCheckMode configCheckMode) {
    String mapName = eventJournalConfig.getMapName();
    String cacheName = eventJournalConfig.getCacheName();
    synchronized (this.journalMutex) {
      EventJournalConfig currentMapJournalConfig = null;
      if (mapName != null) {
        currentMapJournalConfig = (EventJournalConfig)this.mapEventJournalConfigs.putIfAbsent(mapName, eventJournalConfig);
        checkCurrentConfigNullOrEqual(configCheckMode, currentMapJournalConfig, eventJournalConfig);
      } 
      if (cacheName != null) {
        EventJournalConfig currentCacheJournalConfig = (EventJournalConfig)this.cacheEventJournalConfigs.putIfAbsent(cacheName, eventJournalConfig);
        try {
          checkCurrentConfigNullOrEqual(configCheckMode, currentCacheJournalConfig, eventJournalConfig);
        } catch (ConfigurationException e) {
          if (mapName != null && currentMapJournalConfig == null)
            this.mapEventJournalConfigs.remove(mapName); 
          throw e;
        } 
      } 
    } 
  }
  
  private void checkCurrentConfigNullOrEqual(ConfigCheckMode checkMode, Object currentConfig, Object newConfig) {
    if (IGNORE_CONFLICTING_CONFIGS_WORKAROUND)
      return; 
    if (currentConfig == null)
      return; 
    if (!currentConfig.equals(newConfig)) {
      String message = "Cannot add a dynamic configuration '" + newConfig + "' as there is already a conflicting configuration '" + currentConfig + "'";
      switch (null.$SwitchMap$com$hazelcast$internal$dynamicconfig$ConfigCheckMode[checkMode.ordinal()]) {
        case 1:
          throw new ConfigurationException(message);
        case 2:
          this.logger.warning(message);
          return;
        case 3:
          this.logger.finest(message);
          return;
      } 
      throw new UnsupportedOperationException("Unknown consistency check mode: " + checkMode);
    } 
  }
  
  public MultiMapConfig findMultiMapConfig(String name) { return (MultiMapConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.multiMapConfigs, name); }
  
  public ConcurrentMap<String, MultiMapConfig> getMultiMapConfigs() { return this.multiMapConfigs; }
  
  public MapConfig findMapConfig(String name) { return (MapConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.mapConfigs, name); }
  
  public Map<String, MapConfig> getMapConfigs() { return this.mapConfigs; }
  
  public TopicConfig findTopicConfig(String name) { return (TopicConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.topicConfigs, name); }
  
  public ConcurrentMap<String, TopicConfig> getTopicConfigs() { return this.topicConfigs; }
  
  public CardinalityEstimatorConfig findCardinalityEstimatorConfig(String name) { return (CardinalityEstimatorConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.cardinalityEstimatorConfigs, name); }
  
  public ConcurrentMap<String, CardinalityEstimatorConfig> getCardinalityEstimatorConfigs() { return this.cardinalityEstimatorConfigs; }
  
  public PNCounterConfig findPNCounterConfig(String name) { return (PNCounterConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.pnCounterConfigs, name); }
  
  public ConcurrentMap<String, PNCounterConfig> getPNCounterConfigs() { return this.pnCounterConfigs; }
  
  public ExecutorConfig findExecutorConfig(String name) { return (ExecutorConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.executorConfigs, name); }
  
  public ConcurrentMap<String, ExecutorConfig> getExecutorConfigs() { return this.executorConfigs; }
  
  public ScheduledExecutorConfig findScheduledExecutorConfig(String name) { return (ScheduledExecutorConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.scheduledExecutorConfigs, name); }
  
  public ConcurrentMap<String, ScheduledExecutorConfig> getScheduledExecutorConfigs() { return this.scheduledExecutorConfigs; }
  
  public DurableExecutorConfig findDurableExecutorConfig(String name) { return (DurableExecutorConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.durableExecutorConfigs, name); }
  
  public ConcurrentMap<String, DurableExecutorConfig> getDurableExecutorConfigs() { return this.durableExecutorConfigs; }
  
  public SemaphoreConfig findSemaphoreConfig(String name) { return (SemaphoreConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.semaphoreConfigs, name); }
  
  public ConcurrentMap<String, SemaphoreConfig> getSemaphoreConfigs() { return this.semaphoreConfigs; }
  
  public RingbufferConfig findRingbufferConfig(String name) { return (RingbufferConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.ringbufferConfigs, name); }
  
  public ConcurrentMap<String, RingbufferConfig> getRingbufferConfigs() { return this.ringbufferConfigs; }
  
  public AtomicLongConfig findAtomicLongConfig(String name) { return (AtomicLongConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.atomicLongConfigs, name); }
  
  public Map<String, AtomicLongConfig> getAtomicLongConfigs() { return this.atomicLongConfigs; }
  
  public AtomicReferenceConfig findAtomicReferenceConfig(String name) { return (AtomicReferenceConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.atomicReferenceConfigs, name); }
  
  public CountDownLatchConfig findCountDownLatchConfig(String name) { return (CountDownLatchConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.countDownLatchConfigs, name); }
  
  public Map<String, AtomicReferenceConfig> getAtomicReferenceConfigs() { return this.atomicReferenceConfigs; }
  
  public Map<String, CountDownLatchConfig> getCountDownLatchConfigs() { return this.countDownLatchConfigs; }
  
  public LockConfig findLockConfig(String name) { return (LockConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.lockConfigs, name); }
  
  public Map<String, LockConfig> getLockConfigs() { return this.lockConfigs; }
  
  public ListConfig findListConfig(String name) { return (ListConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.listConfigs, name); }
  
  public ConcurrentMap<String, ListConfig> getListConfigs() { return this.listConfigs; }
  
  public QueueConfig findQueueConfig(String name) { return (QueueConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.queueConfigs, name); }
  
  public Map<String, QueueConfig> getQueueConfigs() { return this.queueConfigs; }
  
  public SetConfig findSetConfig(String name) { return (SetConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.setConfigs, name); }
  
  public ConcurrentMap<String, SetConfig> getSetConfigs() { return this.setConfigs; }
  
  public ReplicatedMapConfig findReplicatedMapConfig(String name) { return (ReplicatedMapConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.replicatedMapConfigs, name); }
  
  public ConcurrentMap<String, ReplicatedMapConfig> getReplicatedMapConfigs() { return this.replicatedMapConfigs; }
  
  public ReliableTopicConfig findReliableTopicConfig(String name) { return (ReliableTopicConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.reliableTopicConfigs, name); }
  
  public ConcurrentMap<String, ReliableTopicConfig> getReliableTopicConfigs() { return this.reliableTopicConfigs; }
  
  public CacheSimpleConfig findCacheSimpleConfig(String name) { return (CacheSimpleConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.cacheSimpleConfigs, name); }
  
  public Map<String, CacheSimpleConfig> getCacheSimpleConfigs() { return this.cacheSimpleConfigs; }
  
  public EventJournalConfig findCacheEventJournalConfig(String name) { return (EventJournalConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.cacheEventJournalConfigs, name); }
  
  public Map<String, EventJournalConfig> getCacheEventJournalConfigs() { return this.cacheEventJournalConfigs; }
  
  public EventJournalConfig findMapEventJournalConfig(String name) { return (EventJournalConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.mapEventJournalConfigs, name); }
  
  public Map<String, EventJournalConfig> getMapEventJournalConfigs() { return this.mapEventJournalConfigs; }
  
  public MerkleTreeConfig findMapMerkleTreeConfig(String name) { return (MerkleTreeConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.mapMerkleTreeConfigs, name); }
  
  public Map<String, MerkleTreeConfig> getMapMerkleTreeConfigs() { return this.mapMerkleTreeConfigs; }
  
  public FlakeIdGeneratorConfig findFlakeIdGeneratorConfig(String baseName) { return (FlakeIdGeneratorConfig)ConfigUtils.lookupByPattern(this.configPatternMatcher, this.flakeIdGeneratorConfigs, baseName); }
  
  public Map<String, FlakeIdGeneratorConfig> getFlakeIdGeneratorConfigs() { return this.flakeIdGeneratorConfigs; }
  
  public Runnable prepareMergeRunnable() {
    if (this.version.isLessOrEqual(Versions.V3_8))
      return null; 
    IdentifiedDataSerializable[] allConfigurations = collectAllDynamicConfigs();
    if (noConfigurationExist(allConfigurations))
      return null; 
    return new Merger(this.nodeEngine, new DynamicConfigPreJoinOperation(allConfigurations, ConfigCheckMode.SILENT));
  }
  
  private static Map<Class<? extends IdentifiedDataSerializable>, Version> initializeConfigToVersionMap() {
    configToVersion = new HashMap();
    configToVersion.put(MapConfig.class, Versions.V3_9);
    configToVersion.put(MultiMapConfig.class, Versions.V3_9);
    configToVersion.put(CardinalityEstimatorConfig.class, Versions.V3_9);
    configToVersion.put(RingbufferConfig.class, Versions.V3_9);
    configToVersion.put(LockConfig.class, Versions.V3_9);
    configToVersion.put(ListConfig.class, Versions.V3_9);
    configToVersion.put(SetConfig.class, Versions.V3_9);
    configToVersion.put(ReplicatedMapConfig.class, Versions.V3_9);
    configToVersion.put(TopicConfig.class, Versions.V3_9);
    configToVersion.put(ExecutorConfig.class, Versions.V3_9);
    configToVersion.put(DurableExecutorConfig.class, Versions.V3_9);
    configToVersion.put(ScheduledExecutorConfig.class, Versions.V3_9);
    configToVersion.put(SemaphoreConfig.class, Versions.V3_9);
    configToVersion.put(QueueConfig.class, Versions.V3_9);
    configToVersion.put(ReliableTopicConfig.class, Versions.V3_9);
    configToVersion.put(CacheSimpleConfig.class, Versions.V3_9);
    configToVersion.put(EventJournalConfig.class, Versions.V3_9);
    configToVersion.put(AtomicLongConfig.class, Versions.V3_10);
    configToVersion.put(AtomicReferenceConfig.class, Versions.V3_10);
    configToVersion.put(CountDownLatchConfig.class, Versions.V3_10);
    configToVersion.put(FlakeIdGeneratorConfig.class, Versions.V3_10);
    configToVersion.put(PNCounterConfig.class, Versions.V3_10);
    configToVersion.put(MerkleTreeConfig.class, Versions.V3_11);
    return Collections.unmodifiableMap(configToVersion);
  }
}
