package com.hazelcast.internal.dynamicconfig;

import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public final class AggregatingMap<K, V> extends Object implements Map<K, V> {
  private final Map<K, V> map1;
  
  private final Map<K, V> map2;
  
  private AggregatingMap(Map<K, V> map1, Map<K, V> map2) {
    if (map1 == null)
      map1 = Collections.emptyMap(); 
    if (map2 == null)
      map2 = Collections.emptyMap(); 
    this.map1 = map1;
    this.map2 = map2;
  }
  
  public static <K, V> Map<K, V> aggregate(Map<K, V> map1, Map<K, V> map2) { return new AggregatingMap(map1, map2); }
  
  public int size() { return this.map1.size() + this.map2.size(); }
  
  public boolean isEmpty() { return (this.map1.isEmpty() && this.map2.isEmpty()); }
  
  public boolean containsKey(Object key) { return (this.map1.containsKey(key) || this.map2.containsKey(key)); }
  
  public boolean containsValue(Object value) { return (this.map1.containsValue(value) || this.map2.containsValue(value)); }
  
  public V get(Object key) {
    V v = (V)this.map1.get(key);
    return (V)((v == null) ? this.map2.get(key) : v);
  }
  
  public V put(K key, V value) { throw new UnsupportedOperationException("aggregating map is read only"); }
  
  public V remove(Object key) { throw new UnsupportedOperationException("aggregating map is read only"); }
  
  public void putAll(Map<? extends K, ? extends V> m) { throw new UnsupportedOperationException("aggregating map is read only"); }
  
  public void clear() { throw new UnsupportedOperationException("aggregating map is read only"); }
  
  public Set<K> keySet() {
    HashSet<K> keys = new HashSet<K>(this.map1.keySet());
    keys.addAll(this.map2.keySet());
    return Collections.unmodifiableSet(keys);
  }
  
  public Collection<V> values() {
    ArrayList<V> values = new ArrayList<V>(this.map1.values());
    values.addAll(this.map2.values());
    return Collections.unmodifiableCollection(values);
  }
  
  public Set<Map.Entry<K, V>> entrySet() {
    Set<Map.Entry<K, V>> entrySet1 = this.map1.entrySet();
    Set<Map.Entry<K, V>> entrySet2 = this.map2.entrySet();
    HashSet<Map.Entry<K, V>> aggregatedEntrySet = new HashSet<Map.Entry<K, V>>();
    copyEntries(entrySet1, aggregatedEntrySet);
    copyEntries(entrySet2, aggregatedEntrySet);
    return Collections.unmodifiableSet(aggregatedEntrySet);
  }
  
  private void copyEntries(Set<Map.Entry<K, V>> source, Set<Map.Entry<K, V>> destination) {
    for (Map.Entry<K, V> entry : source) {
      K key = (K)entry.getKey();
      V value = (V)entry.getValue();
      destination.add(new AbstractMap.SimpleEntry(key, value));
    } 
  }
}
