package com.hazelcast.internal.yaml;

import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

public class YamlMappingImpl extends AbstractYamlNode implements MutableYamlMapping {
  private Map<String, YamlNode> children = Collections.emptyMap();
  
  YamlMappingImpl(YamlNode parent, String nodeName) { super(parent, nodeName); }
  
  public YamlNode child(String name) { return (YamlNode)this.children.get(name); }
  
  public YamlMapping childAsMapping(String name) { return YamlUtil.asMapping(child(name)); }
  
  public YamlSequence childAsSequence(String name) { return YamlUtil.asSequence(child(name)); }
  
  public YamlScalar childAsScalar(String name) { return YamlUtil.asScalar(child(name)); }
  
  public <T> T childAsScalarValue(String name) { return (T)childAsScalar(name).nodeValue(); }
  
  public <T> T childAsScalarValue(String name, Class<T> type) { return (T)childAsScalar(name).nodeValue(type); }
  
  public Iterable<YamlNode> children() { return this.children.values(); }
  
  public Iterable<YamlNameNodePair> childrenPairs() {
    List<YamlNameNodePair> pairs = new LinkedList<YamlNameNodePair>();
    for (Map.Entry<String, YamlNode> child : this.children.entrySet())
      pairs.add(new YamlNameNodePair((String)child.getKey(), (YamlNode)child.getValue())); 
    return pairs;
  }
  
  public void addChild(String name, YamlNode node) { getOrCreateChildren().put(name, node); }
  
  public void removeChild(String name) { this.children.remove(name); }
  
  private Map<String, YamlNode> getOrCreateChildren() {
    if (this.children == Collections.emptyMap())
      this.children = new LinkedHashMap(); 
    return this.children;
  }
  
  public int childCount() { return this.children.size(); }
  
  public String toString() {
    return "YamlMappingImpl{nodeName=" + 
      nodeName() + ", children=" + this.children + '}';
  }
}
