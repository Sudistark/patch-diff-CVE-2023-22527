package com.hazelcast.internal.usercodedeployment.impl;

import com.hazelcast.config.UserCodeDeploymentConfig;
import com.hazelcast.core.Member;
import com.hazelcast.internal.cluster.ClusterService;
import com.hazelcast.internal.usercodedeployment.impl.operation.ClassDataFinderOperation;
import com.hazelcast.internal.util.filter.Filter;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.IOUtil;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.OperationService;
import java.io.Closeable;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutionException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public final class ClassLocator {
  private static final Pattern CLASS_PATTERN = Pattern.compile("^(.*)\\$.*");
  
  private final ConcurrentMap<String, ClassSource> classSourceMap;
  
  private final ConcurrentMap<String, ClassSource> clientClassSourceMap;
  
  private final ClassLoader parent;
  
  private final Filter<String> classNameFilter;
  
  private final Filter<Member> memberFilter;
  
  private final UserCodeDeploymentConfig.ClassCacheMode classCacheMode;
  
  private final NodeEngine nodeEngine;
  
  private final ClassloadingMutexProvider mutexFactory;
  
  private final ILogger logger;
  
  public ClassLocator(ConcurrentMap<String, ClassSource> classSourceMap, ConcurrentMap<String, ClassSource> clientClassSourceMap, ClassLoader parent, Filter<String> classNameFilter, Filter<Member> memberFilter, UserCodeDeploymentConfig.ClassCacheMode classCacheMode, NodeEngine nodeEngine) {
    this.mutexFactory = new ClassloadingMutexProvider();
    this.classSourceMap = classSourceMap;
    this.clientClassSourceMap = clientClassSourceMap;
    this.parent = parent;
    this.classNameFilter = classNameFilter;
    this.memberFilter = memberFilter;
    this.classCacheMode = classCacheMode;
    this.nodeEngine = nodeEngine;
    this.logger = nodeEngine.getLogger(ClassLocator.class);
  }
  
  public static void onStartDeserialization() { ThreadLocalClassCache.onStartDeserialization(); }
  
  public static void onFinishDeserialization() { ThreadLocalClassCache.onFinishDeserialization(); }
  
  public Class<?> handleClassNotFoundException(String name) throws ClassNotFoundException {
    if (!this.classNameFilter.accept(name))
      throw new ClassNotFoundException("Class " + name + " is not allowed to be loaded from other members"); 
    Class<?> clazz = tryToGetClassFromLocalCache(name);
    if (clazz != null)
      return clazz; 
    return tryToGetClassFromRemote(name);
  }
  
  public void defineClassesFromClient(List<Map.Entry<String, byte[]>> bundledClassDefinitions) {
    Map<String, byte[]> bundledClassDefMap = new HashMap<String, byte[]>();
    for (Map.Entry<String, byte[]> bundledClassDefinition : bundledClassDefinitions)
      bundledClassDefMap.put(bundledClassDefinition.getKey(), bundledClassDefinition.getValue()); 
    for (Map.Entry<String, byte[]> bundledClassDefinition : bundledClassDefinitions)
      defineClassFromClient((String)bundledClassDefinition.getKey(), (byte[])bundledClassDefinition.getValue(), bundledClassDefMap); 
  }
  
  public Class<?> defineClassFromClient(String name, byte[] classDef, Map<String, byte[]> bundledClassDefMap) {
    mainClassName = extractMainClassName(name);
    classMutex = this.mutexFactory.getMutexForClass(mainClassName);
    try {
    
    } finally {
      IOUtil.closeResource(classMutex);
    } 
  }
  
  private Class<?> tryToGetClassFromRemote(String name) throws ClassNotFoundException {
    mainClassName = extractMainClassName(name);
    classMutex = this.mutexFactory.getMutexForClass(mainClassName);
    try {
    
    } finally {
      IOUtil.closeResource(classMutex);
    } 
  }
  
  private Class<?> tryToGetClassFromLocalCache(String name) throws ClassNotFoundException {
    String mainClassDefinition = extractMainClassName(name);
    ClassSource classSource = (ClassSource)this.classSourceMap.get(mainClassDefinition);
    if (classSource != null) {
      Class clazz = classSource.getClazz(name);
      if (clazz != null) {
        if (this.logger.isFineEnabled())
          this.logger.finest("Class " + name + " is already in local cache"); 
        return clazz;
      } 
    } 
    classSource = (ClassSource)this.clientClassSourceMap.get(mainClassDefinition);
    if (classSource != null) {
      Class clazz = classSource.getClazz(name);
      if (clazz != null) {
        if (this.logger.isFineEnabled())
          this.logger.finest("Class " + name + " is already in local cache"); 
        return clazz;
      } 
    } 
    classSource = ThreadLocalClassCache.getFromCache(mainClassDefinition);
    if (classSource != null)
      return classSource.getClazz(name); 
    return null;
  }
  
  static String extractMainClassName(String className) {
    Matcher matcher = CLASS_PATTERN.matcher(className);
    if (matcher.matches())
      return matcher.group(1); 
    return className;
  }
  
  private void cacheClass(ClassSource classSource, String outerClassName) {
    if (this.classCacheMode != UserCodeDeploymentConfig.ClassCacheMode.OFF) {
      this.classSourceMap.put(outerClassName, classSource);
    } else {
      ThreadLocalClassCache.store(outerClassName, classSource);
    } 
  }
  
  private ClassData fetchBytecodeFromRemote(String className) {
    ClusterService cluster = this.nodeEngine.getClusterService();
    boolean interrupted = false;
    for (Member member : cluster.getMembers()) {
      if (isCandidateMember(member))
        continue; 
      try {
        ClassData classData = tryToFetchClassDataFromMember(className, member);
        if (classData != null) {
          if (this.logger.isFineEnabled())
            this.logger.finest("Loaded class " + className + " from " + member); 
          return classData;
        } 
      } catch (InterruptedException e) {
        interrupted = true;
      } catch (Exception e) {
        if (this.logger.isFinestEnabled())
          this.logger.finest("Unable to get class data for class " + className + " from member " + member, e); 
      } 
    } 
    if (interrupted)
      Thread.currentThread().interrupt(); 
    return null;
  }
  
  private ClassData tryToFetchClassDataFromMember(String className, Member member) throws ExecutionException, InterruptedException {
    OperationService operationService = this.nodeEngine.getOperationService();
    ClassDataFinderOperation op = new ClassDataFinderOperation(className);
    InternalCompletableFuture internalCompletableFuture = operationService.invokeOnTarget("user-code-deployment-service", op, member
        .getAddress());
    return (ClassData)internalCompletableFuture.get();
  }
  
  private boolean isCandidateMember(Member member) {
    if (member.localMember())
      return true; 
    if (!this.memberFilter.accept(member))
      return true; 
    return false;
  }
  
  public Class<?> findLoadedClass(String name) throws ClassNotFoundException {
    ClassSource classSource = (ClassSource)this.classSourceMap.get(extractMainClassName(name));
    if (classSource == null)
      return null; 
    return classSource.getClazz(name);
  }
}
