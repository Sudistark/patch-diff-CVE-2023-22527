package com.hazelcast.internal.util.concurrent;

import com.hazelcast.util.function.Predicate;
import java.util.Collection;
import java.util.Iterator;
import java.util.concurrent.atomic.AtomicReferenceArray;

public class ManyToOneConcurrentArrayQueue<E> extends AbstractConcurrentArrayQueue<E> {
  public ManyToOneConcurrentArrayQueue(int requestedCapacity) { super(requestedCapacity); }
  
  public boolean offer(E e) {
    long acquiredTail;
    assert e != null : "attempt to offer a null element";
    int capacity = this.capacity;
    long acquiredHead = this.sharedHeadCache;
    long bufferLimit = acquiredHead + capacity;
    do {
      acquiredTail = this.tail;
      if (acquiredTail < bufferLimit)
        continue; 
      acquiredHead = this.head;
      bufferLimit = acquiredHead + capacity;
      if (acquiredTail >= bufferLimit)
        return false; 
      SHARED_HEAD_CACHE.lazySet(this, acquiredHead);
    } while (!TAIL.compareAndSet(this, acquiredTail, acquiredTail + 1L));
    this.buffer.lazySet(seqToArrayIndex(acquiredTail, (capacity - 1)), e);
    return true;
  }
  
  public E poll() {
    long head = this.head;
    AtomicReferenceArray<E> buffer = this.buffer;
    int arrayIndex = seqToArrayIndex(head, (this.capacity - 1));
    E item = (E)buffer.get(arrayIndex);
    if (item != null) {
      buffer.lazySet(arrayIndex, null);
      HEAD.lazySet(this, head + 1L);
    } 
    return item;
  }
  
  public int drain(Predicate<? super E> itemHandler) {
    AtomicReferenceArray<E> buffer = this.buffer;
    long mask = (this.capacity - 1);
    long acquiredHead = this.head;
    long limit = acquiredHead + mask + 1L;
    long nextSequence = acquiredHead;
    while (nextSequence < limit) {
      int arrayIndex = seqToArrayIndex(nextSequence, mask);
      E item = (E)buffer.get(arrayIndex);
      if (item == null)
        break; 
      buffer.lazySet(arrayIndex, null);
      nextSequence++;
      HEAD.lazySet(this, nextSequence);
      if (!itemHandler.test(item))
        break; 
    } 
    return (int)(nextSequence - acquiredHead);
  }
  
  public int drainTo(Collection<? super E> target, int limit) {
    AtomicReferenceArray<E> buffer = this.buffer;
    long mask = (this.capacity - 1);
    long nextSequence = this.head;
    int count = 0;
    while (count < limit) {
      int arrayIndex = seqToArrayIndex(nextSequence, mask);
      E item = (E)buffer.get(arrayIndex);
      if (item == null)
        break; 
      buffer.lazySet(arrayIndex, null);
      nextSequence++;
      HEAD.lazySet(this, nextSequence);
      count++;
      target.add(item);
    } 
    return count;
  }
}
