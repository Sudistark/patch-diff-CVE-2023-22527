package com.hazelcast.internal.nearcache.impl.invalidation;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IFunction;
import com.hazelcast.core.LifecycleService;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.EventRegistration;
import com.hazelcast.spi.ExecutionService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

public class BatchInvalidator extends Invalidator {
  private final String invalidationExecutorName;
  
  private final ConstructorFunction<String, InvalidationQueue<Invalidation>> invalidationQueueConstructor = new Object(this);
  
  private final ConcurrentMap<String, InvalidationQueue<Invalidation>> invalidationQueues = new ConcurrentHashMap();
  
  private final int batchSize;
  
  private final int batchFrequencySeconds;
  
  private final String nodeShutdownListenerId;
  
  private final AtomicBoolean runningBackgroundTask = new AtomicBoolean(false);
  
  public BatchInvalidator(String serviceName, int batchSize, int batchFrequencySeconds, IFunction<EventRegistration, Boolean> eventFilter, NodeEngine nodeEngine) {
    super(serviceName, eventFilter, nodeEngine);
    this.batchSize = batchSize;
    this.batchFrequencySeconds = batchFrequencySeconds;
    this.nodeShutdownListenerId = registerNodeShutdownListener();
    this.invalidationExecutorName = serviceName + getClass();
  }
  
  protected Invalidation newInvalidation(Data key, String dataStructureName, String sourceUuid, int partitionId) {
    checkBackgroundTaskIsRunning();
    return super.newInvalidation(key, dataStructureName, sourceUuid, partitionId);
  }
  
  protected void invalidateInternal(Invalidation invalidation, int orderKey) {
    String dataStructureName = invalidation.getName();
    InvalidationQueue<Invalidation> invalidationQueue = invalidationQueueOf(dataStructureName);
    invalidationQueue.offer(invalidation);
    if (invalidationQueue.size() >= this.batchSize)
      pollAndSendInvalidations(dataStructureName, invalidationQueue); 
  }
  
  private InvalidationQueue<Invalidation> invalidationQueueOf(String dataStructureName) { return (InvalidationQueue)ConcurrencyUtil.getOrPutIfAbsent(this.invalidationQueues, dataStructureName, this.invalidationQueueConstructor); }
  
  private void pollAndSendInvalidations(String dataStructureName, InvalidationQueue<Invalidation> invalidationQueue) {
    List<Invalidation> invalidations;
    assert invalidationQueue != null;
    if (!invalidationQueue.tryAcquire())
      return; 
    try {
      invalidations = pollInvalidations(invalidationQueue);
    } finally {
      invalidationQueue.release();
    } 
    sendInvalidations(dataStructureName, invalidations);
  }
  
  private List<Invalidation> pollInvalidations(InvalidationQueue<Invalidation> invalidationQueue) {
    int size = invalidationQueue.size();
    List<Invalidation> invalidations = new ArrayList<Invalidation>(size);
    for (int i = 0; i < size; i++) {
      Invalidation invalidation = (Invalidation)invalidationQueue.poll();
      if (invalidation == null)
        break; 
      invalidations.add(invalidation);
    } 
    return invalidations;
  }
  
  private void sendInvalidations(String dataStructureName, List<Invalidation> invalidations) {
    BatchNearCacheInvalidation batchNearCacheInvalidation = new BatchNearCacheInvalidation(dataStructureName, invalidations);
    Collection<EventRegistration> registrations = this.eventService.getRegistrations(this.serviceName, dataStructureName);
    for (EventRegistration registration : registrations) {
      if (((Boolean)this.eventFilter.apply(registration)).booleanValue()) {
        int orderKey = registration.getSubscriber().hashCode();
        this.eventService.publishEvent(this.serviceName, registration, batchNearCacheInvalidation, orderKey);
      } 
    } 
  }
  
  private String registerNodeShutdownListener() {
    HazelcastInstance node = this.nodeEngine.getHazelcastInstance();
    LifecycleService lifecycleService = node.getLifecycleService();
    return lifecycleService.addLifecycleListener(new Object(this));
  }
  
  private void checkBackgroundTaskIsRunning() {
    if (this.runningBackgroundTask.get())
      return; 
    if (this.runningBackgroundTask.compareAndSet(false, true)) {
      ExecutionService executionService = this.nodeEngine.getExecutionService();
      executionService.scheduleWithRepetition(this.invalidationExecutorName, new BatchInvalidationEventSender(this, null), this.batchFrequencySeconds, this.batchFrequencySeconds, TimeUnit.SECONDS);
    } 
  }
  
  public void destroy(String dataStructureName, String sourceUuid) {
    this.invalidationQueues.remove(dataStructureName);
    super.destroy(dataStructureName, sourceUuid);
  }
  
  public void shutdown() {
    ExecutionService executionService = this.nodeEngine.getExecutionService();
    executionService.shutdownExecutor(this.invalidationExecutorName);
    HazelcastInstance node = this.nodeEngine.getHazelcastInstance();
    LifecycleService lifecycleService = node.getLifecycleService();
    lifecycleService.removeLifecycleListener(this.nodeShutdownListenerId);
    this.invalidationQueues.clear();
    super.shutdown();
  }
  
  public void reset() {
    this.invalidationQueues.clear();
    super.reset();
  }
}
