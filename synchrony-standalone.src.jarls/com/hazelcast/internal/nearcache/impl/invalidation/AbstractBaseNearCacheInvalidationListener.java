package com.hazelcast.internal.nearcache.impl.invalidation;

import com.hazelcast.client.impl.protocol.ClientMessage;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.util.HashUtil;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public abstract class AbstractBaseNearCacheInvalidationListener {
  private final int batchOrderKey;
  
  public AbstractBaseNearCacheInvalidationListener(String localMemberUuid, long correlationId) { this.batchOrderKey = HashUtil.hashCode(new Object[] { localMemberUuid, Long.valueOf(correlationId) }); }
  
  protected abstract ClientMessage encodeBatchInvalidation(String paramString, List<Data> paramList1, List<String> paramList2, List<UUID> paramList3, List<Long> paramList4);
  
  protected abstract ClientMessage encodeSingleInvalidation(String paramString1, Data paramData, String paramString2, UUID paramUUID, long paramLong);
  
  protected abstract void sendMessageWithOrderKey(ClientMessage paramClientMessage, Object paramObject);
  
  protected abstract boolean canSendInvalidation(Invalidation paramInvalidation);
  
  protected final void sendInvalidation(Invalidation invalidation) {
    if (invalidation instanceof BatchNearCacheInvalidation) {
      ExtractedParams params = extractParams((BatchNearCacheInvalidation)invalidation);
      ClientMessage message = encodeBatchInvalidation(invalidation.getName(), ExtractedParams.access$000(params), 
          ExtractedParams.access$100(params), ExtractedParams.access$200(params), ExtractedParams.access$300(params));
      sendMessageWithOrderKey(message, Integer.valueOf(this.batchOrderKey));
      return;
    } 
    if (invalidation instanceof SingleNearCacheInvalidation) {
      if (canSendInvalidation(invalidation)) {
        ClientMessage message = encodeSingleInvalidation(invalidation.getName(), invalidation.getKey(), invalidation
            .getSourceUuid(), invalidation.getPartitionUuid(), invalidation.getSequence());
        sendMessageWithOrderKey(message, invalidation.getKey());
      } 
      return;
    } 
    throw new IllegalArgumentException("Unknown invalidation message type " + invalidation);
  }
  
  private ExtractedParams extractParams(BatchNearCacheInvalidation batch) {
    List<Invalidation> invalidations = batch.getInvalidations();
    int size = invalidations.size();
    List<Data> keys = new ArrayList<Data>(size);
    List<String> sourceUuids = new ArrayList<String>(size);
    List<UUID> partitionUuids = new ArrayList<UUID>(size);
    List<Long> sequences = new ArrayList<Long>(size);
    for (Invalidation invalidation : invalidations) {
      if (canSendInvalidation(invalidation)) {
        keys.add(invalidation.getKey());
        sourceUuids.add(invalidation.getSourceUuid());
        partitionUuids.add(invalidation.getPartitionUuid());
        sequences.add(Long.valueOf(invalidation.getSequence()));
      } 
    } 
    return new ExtractedParams(keys, sourceUuids, partitionUuids, sequences);
  }
}
