package com.hazelcast.internal.nearcache.impl.invalidation;

import com.hazelcast.nio.serialization.SerializableByConvention;
import java.util.Collection;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

@SerializableByConvention
public final class InvalidationQueue<T> extends ConcurrentLinkedQueue<T> {
  private final AtomicInteger elementCount = new AtomicInteger(0);
  
  private final AtomicBoolean flushingInProgress = new AtomicBoolean(false);
  
  public int size() { return this.elementCount.get(); }
  
  public boolean offer(T invalidation) {
    boolean offered = super.offer(invalidation);
    if (offered)
      this.elementCount.incrementAndGet(); 
    return offered;
  }
  
  public T poll() {
    T invalidation = (T)super.poll();
    if (invalidation != null)
      this.elementCount.decrementAndGet(); 
    return invalidation;
  }
  
  public boolean tryAcquire() { return this.flushingInProgress.compareAndSet(false, true); }
  
  public void release() { this.flushingInProgress.set(false); }
  
  public boolean add(T invalidation) { throw new UnsupportedOperationException(); }
  
  public T remove() { throw new UnsupportedOperationException(); }
  
  public boolean remove(Object o) { throw new UnsupportedOperationException(); }
  
  public boolean addAll(Collection<? extends T> c) { throw new UnsupportedOperationException(); }
  
  public boolean removeAll(Collection<?> c) { throw new UnsupportedOperationException(); }
  
  public boolean retainAll(Collection<?> c) { throw new UnsupportedOperationException(); }
}
