package com.hazelcast.internal.nearcache.impl.invalidation;

import com.hazelcast.internal.nearcache.NearCache;
import com.hazelcast.logging.ILogger;
import com.hazelcast.spi.TaskScheduler;
import com.hazelcast.spi.properties.HazelcastProperties;
import com.hazelcast.spi.properties.HazelcastProperty;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ContextMutexFactory;
import com.hazelcast.util.Preconditions;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

public final class RepairingTask implements Runnable {
  public static final HazelcastProperty MAX_TOLERATED_MISS_COUNT = new HazelcastProperty("hazelcast.invalidation.max.tolerated.miss.count", 
      Integer.valueOf(10));
  
  public static final HazelcastProperty RECONCILIATION_INTERVAL_SECONDS = new HazelcastProperty("hazelcast.invalidation.reconciliation.interval.seconds", 
      Integer.valueOf(60), TimeUnit.SECONDS);
  
  public static final HazelcastProperty MIN_RECONCILIATION_INTERVAL_SECONDS = new HazelcastProperty("hazelcast.invalidation.min.reconciliation.interval.seconds", 
      Integer.valueOf(30), TimeUnit.SECONDS);
  
  private static final long RESCHEDULE_FAILED_INITIALIZATION_AFTER_MILLIS = 500L;
  
  final int maxToleratedMissCount;
  
  final long reconciliationIntervalNanos;
  
  private final int partitionCount;
  
  private final String localUuid;
  
  private final ILogger logger;
  
  private final TaskScheduler scheduler;
  
  private final InvalidationMetaDataFetcher invalidationMetaDataFetcher;
  
  private final SerializationService serializationService;
  
  private final MinimalPartitionService partitionService;
  
  private final AtomicBoolean running;
  
  private final ConcurrentMap<String, RepairingHandler> handlers;
  
  private final ContextMutexFactory contextMutexFactory;
  
  public RepairingTask(HazelcastProperties properties, InvalidationMetaDataFetcher invalidationMetaDataFetcher, TaskScheduler scheduler, SerializationService serializationService, MinimalPartitionService partitionService, String localUuid, ILogger logger) {
    this.running = new AtomicBoolean(false);
    this.handlers = new ConcurrentHashMap();
    this.contextMutexFactory = new ContextMutexFactory();
    this.reconciliationIntervalNanos = TimeUnit.SECONDS.toNanos(getReconciliationIntervalSeconds(properties));
    this.maxToleratedMissCount = getMaxToleratedMissCount(properties);
    this.invalidationMetaDataFetcher = invalidationMetaDataFetcher;
    this.scheduler = scheduler;
    this.serializationService = serializationService;
    this.partitionService = partitionService;
    this.partitionCount = partitionService.getPartitionCount();
    this.localUuid = localUuid;
    this.logger = logger;
  }
  
  private int getMaxToleratedMissCount(HazelcastProperties properties) {
    int maxToleratedMissCount = properties.getInteger(MAX_TOLERATED_MISS_COUNT);
    return Preconditions.checkNotNegative(maxToleratedMissCount, 
        String.format("max-tolerated-miss-count cannot be < 0 but found %d", new Object[] { Integer.valueOf(maxToleratedMissCount) }));
  }
  
  private int getReconciliationIntervalSeconds(HazelcastProperties properties) {
    int reconciliationIntervalSeconds = properties.getInteger(RECONCILIATION_INTERVAL_SECONDS);
    int minReconciliationIntervalSeconds = properties.getInteger(MIN_RECONCILIATION_INTERVAL_SECONDS);
    if (reconciliationIntervalSeconds < 0 || (reconciliationIntervalSeconds > 0 && reconciliationIntervalSeconds < minReconciliationIntervalSeconds)) {
      String msg = String.format("Reconciliation interval can be at least %s seconds if it is not zero, but %d was configured. Note: Configuring a value of zero seconds disables the reconciliation task.", new Object[] { MIN_RECONCILIATION_INTERVAL_SECONDS
            
            .getDefaultValue(), Integer.valueOf(reconciliationIntervalSeconds) });
      throw new IllegalArgumentException(msg);
    } 
    return reconciliationIntervalSeconds;
  }
  
  public void run() {
    try {
      fixSequenceGaps();
      if (isAntiEntropyNeeded())
        runAntiEntropy(); 
    } finally {
      if (this.running.get())
        scheduleNextRun(); 
    } 
  }
  
  private void fixSequenceGaps() {
    for (RepairingHandler handler : this.handlers.values()) {
      if (isAboveMaxToleratedMissCount(handler))
        updateLastKnownStaleSequences(handler); 
    } 
  }
  
  private void runAntiEntropy() {
    this.invalidationMetaDataFetcher.fetchMetadata(this.handlers);
    this.lastAntiEntropyRunNanos = System.nanoTime();
  }
  
  private boolean isAntiEntropyNeeded() {
    if (this.reconciliationIntervalNanos == 0L)
      return false; 
    long sinceLastRunNanos = System.nanoTime() - this.lastAntiEntropyRunNanos;
    return (sinceLastRunNanos >= this.reconciliationIntervalNanos);
  }
  
  private void scheduleNextRun() {
    try {
      this.scheduler.schedule(this, 1L, TimeUnit.SECONDS);
    } catch (RejectedExecutionException e) {
      if (this.logger.isFinestEnabled())
        this.logger.finest(e.getMessage()); 
    } 
  }
  
  public <K, V> RepairingHandler registerAndGetHandler(String dataStructureName, NearCache<K, V> nearCache) {
    RepairingHandler handler = (RepairingHandler)ConcurrencyUtil.getOrPutSynchronized(this.handlers, dataStructureName, this.contextMutexFactory, new HandlerConstructor(this, nearCache));
    if (this.running.compareAndSet(false, true)) {
      scheduleNextRun();
      this.lastAntiEntropyRunNanos = System.nanoTime();
    } 
    return handler;
  }
  
  public void deregisterHandler(String dataStructureName) { this.handlers.remove(dataStructureName); }
  
  private void initRepairingHandler(RepairingHandler handler) {
    this.logger.finest("Initializing repairing handler");
    initialized = false;
    try {
      this.invalidationMetaDataFetcher.init(handler);
      initialized = true;
    } catch (Exception e) {
      this.logger.warning(e);
    } finally {
      if (!initialized)
        initRepairingHandlerAsync(handler); 
    } 
  }
  
  private void initRepairingHandlerAsync(RepairingHandler handler) { this.scheduler.schedule(new Object(this, handler), 500L, TimeUnit.MILLISECONDS); }
  
  private static long totalDelaySoFarNanos(int roundNumber) {
    long totalDelayMillis = 0L;
    for (int i = 1; i < roundNumber; i++)
      totalDelayMillis += roundNumber * 500L; 
    return TimeUnit.MILLISECONDS.toNanos(totalDelayMillis);
  }
  
  private boolean isAboveMaxToleratedMissCount(RepairingHandler handler) {
    long totalMissCount = 0L;
    for (int partitionId = 0; partitionId < this.partitionCount; partitionId++) {
      MetaDataContainer metaData = handler.getMetaDataContainer(partitionId);
      totalMissCount += metaData.getMissedSequenceCount();
      if (totalMissCount > this.maxToleratedMissCount) {
        if (this.logger.isFinestEnabled())
          this.logger.finest(String.format("Above tolerated miss count:[map=%s,missCount=%d,maxToleratedMissCount=%d]", new Object[] { handler
                  .getName(), Long.valueOf(totalMissCount), Integer.valueOf(this.maxToleratedMissCount) })); 
        return true;
      } 
    } 
    return false;
  }
  
  private void updateLastKnownStaleSequences(RepairingHandler handler) {
    for (int partition = 0; partition < this.partitionCount; partition++) {
      MetaDataContainer metaData = handler.getMetaDataContainer(partition);
      long missCount = metaData.getMissedSequenceCount();
      if (missCount != 0L) {
        metaData.addAndGetMissedSequenceCount(-missCount);
        handler.updateLastKnownStaleSequence(metaData, partition);
      } 
    } 
  }
  
  public InvalidationMetaDataFetcher getInvalidationMetaDataFetcher() { return this.invalidationMetaDataFetcher; }
  
  public ConcurrentMap<String, RepairingHandler> getHandlers() { return this.handlers; }
  
  public String toString() { return "RepairingTask{}"; }
}
