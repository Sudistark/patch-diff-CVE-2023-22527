package com.hazelcast.internal.nearcache.impl.record;

import com.hazelcast.internal.nearcache.NearCacheRecord;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.atomic.AtomicLongFieldUpdater;

public abstract class AbstractNearCacheRecord<V> extends Object implements NearCacheRecord<V> {
  public static final int NUMBER_OF_LONG_FIELD_TYPES = 5;
  
  public static final int NUMBER_OF_INTEGER_FIELD_TYPES = 1;
  
  private static final AtomicIntegerFieldUpdater<AbstractNearCacheRecord> ACCESS_HIT = AtomicIntegerFieldUpdater.newUpdater(AbstractNearCacheRecord.class, "accessHit");
  
  private static final AtomicLongFieldUpdater<AbstractNearCacheRecord> RECORD_STATE = AtomicLongFieldUpdater.newUpdater(AbstractNearCacheRecord.class, "recordState");
  
  protected long creationTime;
  
  public AbstractNearCacheRecord(V value, long creationTime, long expirationTime) {
    this.creationTime = -1L;
    this.expirationTime = -1L;
    this.accessTime = -1L;
    this.recordState = -4L;
    this.value = value;
    this.creationTime = creationTime;
    this.expirationTime = expirationTime;
  }
  
  public V getValue() { return (V)this.value; }
  
  public void setValue(V value) { this.value = value; }
  
  public long getExpirationTime() { return this.expirationTime; }
  
  public void setExpirationTime(long expirationTime) { this.expirationTime = expirationTime; }
  
  public long getCreationTime() { return this.creationTime; }
  
  public void setCreationTime(long creationTime) { this.creationTime = creationTime; }
  
  public long getLastAccessTime() { return this.accessTime; }
  
  public void setAccessTime(long accessTime) { this.accessTime = accessTime; }
  
  public int getAccessHit() { return this.accessHit; }
  
  public void setAccessHit(int accessHit) { ACCESS_HIT.set(this, accessHit); }
  
  public void incrementAccessHit() { ACCESS_HIT.addAndGet(this, 1); }
  
  public void resetAccessHit() { ACCESS_HIT.set(this, 0); }
  
  public boolean isExpiredAt(long now) { return (this.expirationTime > -1L && this.expirationTime <= now); }
  
  public boolean isIdleAt(long maxIdleMilliSeconds, long now) {
    if (maxIdleMilliSeconds > 0L) {
      if (this.accessTime > -1L)
        return (this.accessTime + maxIdleMilliSeconds < now); 
      return (this.creationTime + maxIdleMilliSeconds < now);
    } 
    return false;
  }
  
  public long getRecordState() { return this.recordState; }
  
  public boolean casRecordState(long expect, long update) { return RECORD_STATE.compareAndSet(this, expect, update); }
  
  public int getPartitionId() { return this.partitionId; }
  
  public void setPartitionId(int partitionId) { this.partitionId = partitionId; }
  
  public long getInvalidationSequence() { return this.sequence; }
  
  public void setInvalidationSequence(long sequence) { this.sequence = sequence; }
  
  public void setUuid(UUID uuid) { this.uuid = uuid; }
  
  public boolean hasSameUuid(UUID thatUuid) { return (this.uuid != null && thatUuid != null && this.uuid.equals(thatUuid)); }
  
  public String toString() { return "creationTime=" + this.creationTime + ", sequence=" + this.sequence + ", uuid=" + this.uuid + ", expirationTime=" + this.expirationTime + ", accessTime=" + this.accessTime + ", accessHit=" + this.accessHit + ", recordState=" + this.recordState + ", value=" + this.value; }
}
