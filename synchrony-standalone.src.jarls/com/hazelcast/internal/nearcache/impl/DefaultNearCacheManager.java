package com.hazelcast.internal.nearcache.impl;

import com.hazelcast.config.NearCacheConfig;
import com.hazelcast.config.NearCacheConfigAccessor;
import com.hazelcast.config.NearCachePreloaderConfig;
import com.hazelcast.internal.adapter.DataStructureAdapter;
import com.hazelcast.internal.nearcache.NearCache;
import com.hazelcast.internal.nearcache.NearCacheManager;
import com.hazelcast.spi.TaskScheduler;
import com.hazelcast.spi.properties.HazelcastProperties;
import com.hazelcast.spi.serialization.SerializationService;
import java.util.Collection;
import java.util.HashSet;
import java.util.Queue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

public class DefaultNearCacheManager implements NearCacheManager {
  protected final TaskScheduler scheduler;
  
  protected final ClassLoader classLoader;
  
  protected final HazelcastProperties properties;
  
  protected final SerializationService serializationService;
  
  private final Object mutex = new Object();
  
  private final Queue<ScheduledFuture> preloadTaskFutures = new ConcurrentLinkedQueue();
  
  private final ConcurrentMap<String, NearCache> nearCacheMap = new ConcurrentHashMap();
  
  public DefaultNearCacheManager(SerializationService ss, TaskScheduler es, ClassLoader classLoader, HazelcastProperties properties) {
    assert ss != null;
    assert es != null;
    this.serializationService = ss;
    this.scheduler = es;
    this.classLoader = classLoader;
    this.properties = properties;
  }
  
  public <K, V> NearCache<K, V> getNearCache(String name) { return (NearCache)this.nearCacheMap.get(name); }
  
  public <K, V> NearCache<K, V> getOrCreateNearCache(String name, NearCacheConfig nearCacheConfig) { return getOrCreateNearCache(name, nearCacheConfig, null); }
  
  public <K, V> NearCache<K, V> getOrCreateNearCache(String name, NearCacheConfig nearCacheConfig, DataStructureAdapter dataStructureAdapter) {
    NearCache<K, V> nearCache = (NearCache)this.nearCacheMap.get(name);
    if (nearCache == null)
      synchronized (this.mutex) {
        nearCache = (NearCache)this.nearCacheMap.get(name);
        if (nearCache == null) {
          nearCache = createNearCache(name, nearCacheConfig);
          nearCache.initialize();
          this.nearCacheMap.put(name, nearCache);
          NearCachePreloaderConfig preloaderConfig = nearCacheConfig.getPreloaderConfig();
          if (preloaderConfig.isEnabled()) {
            createAndSchedulePreloadTask(nearCache, dataStructureAdapter);
            createAndScheduleStorageTask(preloaderConfig);
          } 
        } 
      }  
    return nearCache;
  }
  
  protected <K, V> NearCache<K, V> createNearCache(String name, NearCacheConfig nearCacheConfig) {
    NearCacheConfig copy = NearCacheConfigAccessor.copyWithInitializedDefaultMaxSizeForOnHeapMaps(nearCacheConfig);
    return new DefaultNearCache(name, copy, this.serializationService, this.scheduler, this.classLoader, this.properties);
  }
  
  public Collection<NearCache> listAllNearCaches() { return this.nearCacheMap.values(); }
  
  public boolean clearNearCache(String name) {
    NearCache nearCache = (NearCache)this.nearCacheMap.get(name);
    if (nearCache != null)
      nearCache.clear(); 
    return (nearCache != null);
  }
  
  public void clearAllNearCaches() {
    for (NearCache nearCache : this.nearCacheMap.values())
      nearCache.clear(); 
  }
  
  public boolean destroyNearCache(String name) {
    NearCache nearCache = (NearCache)this.nearCacheMap.get(name);
    if (nearCache != null)
      synchronized (this.mutex) {
        nearCache = (NearCache)this.nearCacheMap.remove(name);
        if (nearCache != null) {
          nearCache.destroy();
          return true;
        } 
        return false;
      }  
    return false;
  }
  
  public void destroyAllNearCaches() {
    for (NearCache nearCache : new HashSet(this.nearCacheMap.values()))
      destroyNearCache(nearCache.getName()); 
    for (ScheduledFuture preloadTaskFuture : this.preloadTaskFutures)
      preloadTaskFuture.cancel(true); 
    if (this.storageTaskFuture != null)
      this.storageTaskFuture.cancel(true); 
  }
  
  private void createAndSchedulePreloadTask(NearCache nearCache, DataStructureAdapter adapter) {
    if (adapter != null) {
      PreloadTask preloadTask = new PreloadTask(this, nearCache, adapter);
      ScheduledFuture<?> scheduledFuture = this.scheduler.schedule(preloadTask, 3L, TimeUnit.SECONDS);
      PreloadTask.access$002(preloadTask, scheduledFuture);
      this.preloadTaskFutures.add(scheduledFuture);
    } 
  }
  
  private void createAndScheduleStorageTask(NearCachePreloaderConfig preloaderConfig) {
    if (this.storageTaskFuture == null) {
      StorageTask storageTask = new StorageTask(this, preloaderConfig);
      this.storageTaskFuture = this.scheduler.scheduleWithRepetition(storageTask, 0L, 1L, TimeUnit.SECONDS);
    } 
  }
  
  protected SerializationService getSerializationService() { return this.serializationService; }
  
  protected TaskScheduler getScheduler() { return this.scheduler; }
  
  protected ClassLoader getClassLoader() { return this.classLoader; }
}
