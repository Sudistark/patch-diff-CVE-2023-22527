package com.hazelcast.internal.nearcache.impl.store;

import com.hazelcast.internal.eviction.EvictionListener;
import com.hazelcast.internal.nearcache.NearCacheRecord;
import com.hazelcast.internal.nearcache.impl.SampleableNearCacheRecordMap;
import com.hazelcast.nio.serialization.SerializableByConvention;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.SampleableConcurrentHashMap;

@SerializableByConvention
public class HeapNearCacheRecordMap<K, V extends NearCacheRecord> extends SampleableConcurrentHashMap<K, V> implements SampleableNearCacheRecordMap<K, V> {
  private final SerializationService serializationService;
  
  HeapNearCacheRecordMap(SerializationService serializationService, int initialCapacity) {
    super(initialCapacity);
    this.serializationService = serializationService;
  }
  
  protected <E extends SampleableConcurrentHashMap.SamplingEntry> E createSamplingEntry(K key, V value) { return (E)new NearCacheEvictableSamplingEntry(this, key, value); }
  
  public <C extends com.hazelcast.internal.eviction.EvictionCandidate<K, V>> boolean tryEvict(C evictionCandidate, EvictionListener<K, V> evictionListener) {
    if (evictionCandidate == null)
      return false; 
    if (remove(evictionCandidate.getAccessor()) == null)
      return false; 
    if (evictionListener != null)
      evictionListener.onEvict(evictionCandidate.getAccessor(), evictionCandidate.getEvictable(), false); 
    return true;
  }
  
  public Iterable<NearCacheEvictableSamplingEntry> sample(int sampleCount) { return getRandomSamples(sampleCount); }
}
