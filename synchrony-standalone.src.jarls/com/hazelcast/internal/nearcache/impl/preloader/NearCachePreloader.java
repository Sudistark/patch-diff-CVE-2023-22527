package com.hazelcast.internal.nearcache.impl.preloader;

import com.hazelcast.config.NearCachePreloaderConfig;
import com.hazelcast.internal.adapter.DataStructureAdapter;
import com.hazelcast.internal.serialization.impl.HeapData;
import com.hazelcast.internal.util.BufferingInputStream;
import com.hazelcast.logging.ILogger;
import com.hazelcast.logging.Logger;
import com.hazelcast.memory.MemoryUnit;
import com.hazelcast.monitor.impl.NearCacheStatsImpl;
import com.hazelcast.nio.Bits;
import com.hazelcast.nio.IOUtil;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.StringUtil;
import com.hazelcast.util.collection.InflatableSet;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.Iterator;
import java.util.concurrent.TimeUnit;

public class NearCachePreloader<K> extends Object {
  private static final int MAGIC_BYTES = -365122482;
  
  private static final int LOG_OF_BUFFER_SIZE = 16;
  
  private static final int BUFFER_SIZE = 65536;
  
  private static final int LOAD_BATCH_SIZE = 100;
  
  private final ILogger logger;
  
  private final byte[] tmpBytes;
  
  private final String nearCacheName;
  
  private final NearCacheStatsImpl nearCacheStats;
  
  private final SerializationService serializationService;
  
  private final NearCachePreloaderLock lock;
  
  private final File storeFile;
  
  private final File tmpStoreFile;
  
  private ByteBuffer buf;
  
  private int lastWrittenBytes;
  
  private int lastKeyCount;
  
  public NearCachePreloader(String nearCacheName, NearCachePreloaderConfig preloaderConfig, NearCacheStatsImpl nearCacheStats, SerializationService serializationService) {
    this.logger = Logger.getLogger(NearCachePreloader.class);
    this.tmpBytes = new byte[4];
    this.nearCacheName = nearCacheName;
    this.nearCacheStats = nearCacheStats;
    this.serializationService = serializationService;
    String filename = getFilename(preloaderConfig.getDirectory(), nearCacheName);
    this.lock = new NearCachePreloaderLock(this.logger, filename + ".lock");
    this.storeFile = new File(filename);
    this.tmpStoreFile = new File(filename + "~");
  }
  
  public void destroy() { this.lock.release(); }
  
  public void loadKeys(DataStructureAdapter<Object, ?> adapter) {
    if (!this.storeFile.exists()) {
      this.logger.info(String.format("Skipped loading keys of Near Cache %s since storage file doesn't exist (%s)", new Object[] { this.nearCacheName, this.storeFile
              .getAbsolutePath() }));
      return;
    } 
    long startedNanos = System.nanoTime();
    bis = null;
    try {
      bis = new BufferingInputStream(new FileInputStream(this.storeFile), 65536);
      if (!checkHeader(bis))
        return; 
      int loadedKeys = loadKeySet(bis, adapter);
      long elapsedMillis = getElapsedMillis(startedNanos);
      this.logger.info(String.format("Loaded %d keys of Near Cache %s in %d ms", new Object[] { Integer.valueOf(loadedKeys), this.nearCacheName, Long.valueOf(elapsedMillis) }));
    } catch (Exception e) {
      this.logger.warning(String.format("Could not pre-load Near Cache %s (%s)", new Object[] { this.nearCacheName, this.storeFile.getAbsolutePath() }), e);
    } finally {
      IOUtil.closeResource(bis);
    } 
  }
  
  private boolean checkHeader(BufferingInputStream bis) throws IOException {
    int magicBytes = readInt(bis);
    if (magicBytes != -365122482) {
      this.logger.warning(String.format("Found invalid header for Near Cache %s (%s)", new Object[] { this.nearCacheName, this.storeFile.getAbsolutePath() }));
      return false;
    } 
    int fileFormat = readInt(bis);
    if (fileFormat < 0 || fileFormat > FileFormat.values().length - 1) {
      this.logger.warning(String.format("Found invalid file format for Near Cache %s (%s)", new Object[] { this.nearCacheName, this.storeFile
              .getAbsolutePath() }));
      return false;
    } 
    return true;
  }
  
  public void storeKeys(Iterator<K> iterator) {
    long startedNanos = System.nanoTime();
    fos = null;
    try {
      this.buf = ByteBuffer.allocate(65536);
      this.lastWrittenBytes = 0;
      this.lastKeyCount = 0;
      fos = new FileOutputStream(this.tmpStoreFile, false);
      writeInt(fos, -365122482);
      writeInt(fos, FileFormat.INTERLEAVED_LENGTH_FIELD.ordinal());
      writeKeySet(fos, fos.getChannel(), iterator);
      if (this.lastKeyCount == 0) {
        IOUtil.deleteQuietly(this.storeFile);
        updatePersistenceStats(startedNanos);
        return;
      } 
      fos.flush();
      IOUtil.closeResource(fos);
      IOUtil.rename(this.tmpStoreFile, this.storeFile);
      updatePersistenceStats(startedNanos);
    } catch (Exception e) {
      this.logger.warning(String.format("Could not store keys of Near Cache %s (%s)", new Object[] { this.nearCacheName, this.storeFile.getAbsolutePath() }), e);
      this.nearCacheStats.addPersistenceFailure(e);
    } finally {
      IOUtil.closeResource(fos);
      IOUtil.deleteQuietly(this.tmpStoreFile);
    } 
  }
  
  private void updatePersistenceStats(long startedNanos) {
    long elapsedMillis = getElapsedMillis(startedNanos);
    this.nearCacheStats.addPersistence(elapsedMillis, this.lastWrittenBytes, this.lastKeyCount);
    this.logger.info(String.format("Stored %d keys of Near Cache %s in %d ms (%d kB)", new Object[] { Integer.valueOf(this.lastKeyCount), this.nearCacheName, Long.valueOf(elapsedMillis), 
            Long.valueOf(MemoryUnit.BYTES.toKiloBytes(this.lastWrittenBytes)) }));
  }
  
  private int loadKeySet(BufferingInputStream bis, DataStructureAdapter<Object, ?> adapter) throws IOException {
    int loadedKeys = 0;
    InflatableSet.Builder<Object> builder = InflatableSet.newBuilder(100);
    while (IOUtil.readFullyOrNothing(bis, this.tmpBytes)) {
      int dataSize = Bits.readIntB(this.tmpBytes, 0);
      byte[] payload = new byte[dataSize];
      if (!IOUtil.readFullyOrNothing(bis, payload))
        break; 
      HeapData heapData = new HeapData(payload);
      builder.add(this.serializationService.toObject(heapData));
      if (builder.size() == 100) {
        adapter.getAll(builder.build());
        builder = InflatableSet.newBuilder(100);
      } 
      loadedKeys++;
    } 
    if (builder.size() > 0)
      adapter.getAll(builder.build()); 
    return loadedKeys;
  }
  
  private void writeKeySet(FileOutputStream fos, FileChannel outChannel, Iterator<K> iterator) throws IOException {
    while (iterator.hasNext()) {
      K key = (K)iterator.next();
      Data dataKey = this.serializationService.toData(key);
      if (dataKey != null) {
        int dataSize = dataKey.totalSize();
        writeInt(fos, dataSize);
        int position = 0;
        int remaining = dataSize;
        while (remaining > 0) {
          int transferredCount = Math.min(65536 - this.buf.position(), remaining);
          ensureBufHasRoom(fos, transferredCount);
          this.buf.put(dataKey.toByteArray(), position, transferredCount);
          position += transferredCount;
          remaining -= transferredCount;
        } 
        this.lastWrittenBytes += 4 + dataSize;
        this.lastKeyCount++;
      } 
      flushLocalBuffer(outChannel);
    } 
  }
  
  private int readInt(BufferingInputStream bis) throws IOException {
    IOUtil.readFullyOrNothing(bis, this.tmpBytes);
    return Bits.readIntB(this.tmpBytes, 0);
  }
  
  private void writeInt(FileOutputStream fos, int dataSize) throws IOException {
    ensureBufHasRoom(fos, 4);
    Bits.writeIntB(this.tmpBytes, 0, dataSize);
    this.buf.put(this.tmpBytes);
  }
  
  private void ensureBufHasRoom(FileOutputStream fos, int expectedSize) throws IOException {
    if (this.buf.position() < 65536 - expectedSize)
      return; 
    fos.write(this.buf.array());
    this.buf.position(0);
  }
  
  private void flushLocalBuffer(FileChannel outChannel) throws IOException {
    if (this.buf.position() == 0)
      return; 
    this.buf.flip();
    while (this.buf.hasRemaining())
      outChannel.write(this.buf); 
    this.buf.clear();
  }
  
  private static String getFilename(String directory, String nearCacheName) {
    String filename = IOUtil.toFileName("nearCache-" + nearCacheName + ".store");
    if (StringUtil.isNullOrEmpty(directory))
      return filename; 
    return IOUtil.getPath(new String[] { directory, filename });
  }
  
  private static long getElapsedMillis(long startedNanos) { return TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startedNanos); }
}
