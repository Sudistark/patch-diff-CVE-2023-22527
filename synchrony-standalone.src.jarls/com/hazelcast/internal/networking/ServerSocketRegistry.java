package com.hazelcast.internal.networking;

import com.hazelcast.instance.EndpointQualifier;
import com.hazelcast.nio.IOUtil;
import java.nio.channels.ServerSocketChannel;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

public class ServerSocketRegistry extends Object implements Iterable<ServerSocketRegistry.Pair> {
  private final boolean unifiedSocket;
  
  private final AtomicBoolean isOpen;
  
  private final Map<EndpointQualifier, ServerSocketChannel> serverSocketChannelMap;
  
  private final Set<Pair> entries;
  
  public ServerSocketRegistry(Map<EndpointQualifier, ServerSocketChannel> map, boolean unifiedSocket) {
    this.isOpen = new AtomicBoolean(true);
    this.entries = new HashSet();
    this.unifiedSocket = unifiedSocket;
    this
      .serverSocketChannelMap = (map == null) ? Collections.emptyMap() : map;
    buildEntries();
  }
  
  public boolean isOpen() { return this.isOpen.get(); }
  
  public boolean holdsUnifiedSocket() { return this.unifiedSocket; }
  
  private void buildEntries() {
    if (!this.serverSocketChannelMap.isEmpty())
      for (Map.Entry<EndpointQualifier, ServerSocketChannel> entry : this.serverSocketChannelMap.entrySet())
        this.entries.add(new Pair((ServerSocketChannel)entry.getValue(), (EndpointQualifier)entry.getKey(), null));  
  }
  
  public Iterator<Pair> iterator() { return this.entries.iterator(); }
  
  public void destroy() {
    if (this.isOpen.compareAndSet(true, false))
      for (ServerSocketChannel channel : this.serverSocketChannelMap.values())
        IOUtil.closeResource(channel);  
  }
  
  public String toString() { return "ServerSocketRegistry{" + this.serverSocketChannelMap + "}"; }
}
