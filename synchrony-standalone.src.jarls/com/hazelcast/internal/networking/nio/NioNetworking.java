package com.hazelcast.internal.networking.nio;

import com.hazelcast.instance.EndpointQualifier;
import com.hazelcast.internal.metrics.MetricsRegistry;
import com.hazelcast.internal.metrics.Probe;
import com.hazelcast.internal.metrics.ProbeLevel;
import com.hazelcast.internal.networking.Channel;
import com.hazelcast.internal.networking.ChannelCloseListener;
import com.hazelcast.internal.networking.ChannelErrorHandler;
import com.hazelcast.internal.networking.ChannelInitializer;
import com.hazelcast.internal.networking.ChannelInitializerProvider;
import com.hazelcast.internal.networking.Networking;
import com.hazelcast.internal.networking.nio.iobalancer.IOBalancer;
import com.hazelcast.logging.ILogger;
import com.hazelcast.logging.LoggingService;
import com.hazelcast.util.HashUtil;
import com.hazelcast.util.ThreadUtil;
import com.hazelcast.util.concurrent.BackoffIdleStrategy;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.IOException;
import java.nio.channels.SocketChannel;
import java.util.Collections;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Level;

public final class NioNetworking implements Networking {
  private final AtomicInteger nextInputThreadIndex;
  
  private final AtomicInteger nextOutputThreadIndex;
  
  private final ILogger logger;
  
  private final MetricsRegistry metricsRegistry;
  
  private final AtomicBoolean metricsRegistryScheduled;
  
  private final LoggingService loggingService;
  
  private final String threadNamePrefix;
  
  private final ChannelErrorHandler errorHandler;
  
  private final int balancerIntervalSeconds;
  
  private final int inputThreadCount;
  
  private final int outputThreadCount;
  
  private final Set<NioChannel> channels;
  
  private final ChannelCloseListener channelCloseListener;
  
  private final SelectorMode selectorMode;
  
  private final BackoffIdleStrategy idleStrategy;
  
  private final boolean selectorWorkaroundTest;
  
  public NioNetworking(Context ctx) {
    this.nextInputThreadIndex = new AtomicInteger();
    this.nextOutputThreadIndex = new AtomicInteger();
    this.metricsRegistryScheduled = new AtomicBoolean(false);
    this.channels = Collections.newSetFromMap(new ConcurrentHashMap());
    this.channelCloseListener = new ChannelCloseListenerImpl(this, null);
    this.threadNamePrefix = Context.access$100(ctx);
    this.metricsRegistry = Context.access$200(ctx);
    this.loggingService = Context.access$300(ctx);
    this.inputThreadCount = Context.access$400(ctx);
    this.outputThreadCount = Context.access$500(ctx);
    this.logger = this.loggingService.getLogger(NioNetworking.class);
    this.errorHandler = Context.access$600(ctx);
    this.balancerIntervalSeconds = Context.access$700(ctx);
    this.selectorMode = Context.access$800(ctx);
    this.selectorWorkaroundTest = Context.access$900(ctx);
    this.idleStrategy = Context.access$1000(ctx);
    this.metricsRegistry.scanAndRegister(this, "tcp");
  }
  
  @SuppressFBWarnings(value = {"EI_EXPOSE_REP"}, justification = "used only for testing")
  public NioThread[] getInputThreads() { return this.inputThreads; }
  
  @SuppressFBWarnings(value = {"EI_EXPOSE_REP"}, justification = "used only for testing")
  public NioThread[] getOutputThreads() { return this.outputThreads; }
  
  @SuppressFBWarnings(value = {"EI_EXPOSE_REP"}, justification = "used only for testing")
  public Set<NioChannel> getChannels() { return this.channels; }
  
  public IOBalancer getIOBalancer() { return this.ioBalancer; }
  
  public void start() {
    if (this.logger.isFineEnabled())
      this.logger.fine("TcpIpConnectionManager configured with Non Blocking IO-threading model: " + this.inputThreadCount + " input threads and " + this.outputThreadCount + " output threads"); 
    this.logger.log((this.selectorMode != SelectorMode.SELECT) ? Level.INFO : Level.FINE, "IO threads selector mode is " + this.selectorMode);
    if (this.metricsRegistryScheduled.compareAndSet(false, true) && this.metricsRegistry.minimumLevel().isEnabled(ProbeLevel.DEBUG))
      this.metricsRegistry.scheduleAtFixedRate(new PublishAllTask(this, null), 1L, TimeUnit.SECONDS, ProbeLevel.INFO); 
    this.closeListenerExecutor = Executors.newSingleThreadExecutor(new Object(this));
    NioThread[] inThreads = new NioThread[this.inputThreadCount];
    for (int i = 0; i < inThreads.length; i++) {
      NioThread thread = new NioThread(ThreadUtil.createThreadPoolName(this.threadNamePrefix, "IO") + "in-" + i, this.loggingService.getLogger(NioThread.class), this.errorHandler, this.selectorMode, this.idleStrategy);
      thread.id = i;
      thread.setSelectorWorkaroundTest(this.selectorWorkaroundTest);
      inThreads[i] = thread;
      this.metricsRegistry.scanAndRegister(thread, "tcp.inputThread[" + thread.getName() + "]");
      thread.start();
    } 
    this.inputThreads = inThreads;
    NioThread[] outThreads = new NioThread[this.outputThreadCount];
    for (int i = 0; i < outThreads.length; i++) {
      NioThread thread = new NioThread(ThreadUtil.createThreadPoolName(this.threadNamePrefix, "IO") + "out-" + i, this.loggingService.getLogger(NioThread.class), this.errorHandler, this.selectorMode, this.idleStrategy);
      thread.id = i;
      thread.setSelectorWorkaroundTest(this.selectorWorkaroundTest);
      outThreads[i] = thread;
      this.metricsRegistry.scanAndRegister(thread, "tcp.outputThread[" + thread.getName() + "]");
      thread.start();
    } 
    this.outputThreads = outThreads;
    startIOBalancer();
  }
  
  private void startIOBalancer() {
    this.ioBalancer = new IOBalancer(this.inputThreads, this.outputThreads, this.threadNamePrefix, this.balancerIntervalSeconds, this.loggingService);
    this.ioBalancer.start();
    this.metricsRegistry.scanAndRegister(this.ioBalancer, "tcp.balancer");
  }
  
  public void shutdown() {
    this.ioBalancer.stop();
    if (this.logger.isFinestEnabled())
      this.logger.finest("Shutting down IO Threads... Total: " + (this.inputThreads.length + this.outputThreads.length)); 
    shutdown(this.inputThreads);
    this.inputThreads = null;
    shutdown(this.outputThreads);
    this.outputThreads = null;
    this.closeListenerExecutor.shutdown();
    this.metricsRegistry.deregister(this.ioBalancer);
  }
  
  private void shutdown(NioThread[] threads) {
    if (threads == null)
      return; 
    for (NioThread thread : threads) {
      thread.shutdown();
      this.metricsRegistry.deregister(thread);
    } 
  }
  
  public Channel register(EndpointQualifier endpointQualifier, ChannelInitializerProvider channelInitializerProvider, SocketChannel socketChannel, boolean clientMode) throws IOException {
    ChannelInitializer initializer = channelInitializerProvider.provide(endpointQualifier);
    assert initializer != null : "Found NULL channel initializer for endpoint-qualifier " + endpointQualifier;
    NioChannel channel = new NioChannel(socketChannel, clientMode, initializer, this.metricsRegistry, this.closeListenerExecutor);
    socketChannel.configureBlocking(false);
    NioInboundPipeline inboundPipeline = newInboundPipeline(channel);
    NioOutboundPipeline outboundPipeline = newOutboundPipeline(channel);
    channel.init(inboundPipeline, outboundPipeline);
    this.ioBalancer.channelAdded(inboundPipeline, outboundPipeline);
    channel.addCloseListener(this.channelCloseListener);
    this.channels.add(channel);
    return channel;
  }
  
  private NioOutboundPipeline newOutboundPipeline(NioChannel channel) {
    int index = HashUtil.hashToIndex(this.nextOutputThreadIndex.getAndIncrement(), this.outputThreadCount);
    NioThread[] threads = this.outputThreads;
    if (threads == null)
      throw new IllegalStateException("NioNetworking is shutdown!"); 
    return new NioOutboundPipeline(channel, threads[index], this.errorHandler, this.loggingService


        
        .getLogger(NioOutboundPipeline.class), this.ioBalancer);
  }
  
  private NioInboundPipeline newInboundPipeline(NioChannel channel) {
    int index = HashUtil.hashToIndex(this.nextInputThreadIndex.getAndIncrement(), this.inputThreadCount);
    NioThread[] threads = this.inputThreads;
    if (threads == null)
      throw new IllegalStateException("NioNetworking is shutdown!"); 
    return new NioInboundPipeline(channel, threads[index], this.errorHandler, this.loggingService


        
        .getLogger(NioInboundPipeline.class), this.ioBalancer);
  }
}
