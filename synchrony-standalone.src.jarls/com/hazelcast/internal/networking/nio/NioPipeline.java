package com.hazelcast.internal.networking.nio;

import com.hazelcast.internal.metrics.Probe;
import com.hazelcast.internal.metrics.ProbeLevel;
import com.hazelcast.internal.networking.Channel;
import com.hazelcast.internal.networking.ChannelErrorHandler;
import com.hazelcast.internal.networking.ChannelHandler;
import com.hazelcast.internal.networking.nio.iobalancer.IOBalancer;
import com.hazelcast.internal.util.counters.SwCounter;
import com.hazelcast.logging.ILogger;
import java.io.IOException;
import java.nio.channels.SelectionKey;
import java.nio.channels.SocketChannel;
import java.util.concurrent.atomic.AtomicReference;

public abstract class NioPipeline implements MigratablePipeline, Runnable {
  protected static final int LOAD_BALANCING_HANDLE = 0;
  
  protected static final int LOAD_BALANCING_BYTE = 1;
  
  protected static final int LOAD_BALANCING_FRAME = 2;
  
  protected final int loadType;
  
  @Probe
  protected final SwCounter processCount;
  
  protected final ILogger logger;
  
  protected final NioChannel channel;
  
  protected final SocketChannel socketChannel;
  
  protected SelectionKey selectionKey;
  
  private final ChannelErrorHandler errorHandler;
  
  private final int initialOps;
  
  private final IOBalancer ioBalancer;
  
  private final AtomicReference<TaskNode> delayedTaskStack;
  
  @Probe
  private final SwCounter startedMigrations;
  
  @Probe
  private final SwCounter completedMigrations;
  
  NioPipeline(NioChannel channel, NioThread owner, ChannelErrorHandler errorHandler, int initialOps, ILogger logger, IOBalancer ioBalancer) {
    this.loadType = Integer.getInteger("hazelcast.io.load", 1).intValue();
    this
      .processCount = SwCounter.newSwCounter();
    this.delayedTaskStack = new AtomicReference();
    this
      .startedMigrations = SwCounter.newSwCounter();
    this
      .completedMigrations = SwCounter.newSwCounter();
    this.channel = channel;
    this.socketChannel = channel.socketChannel();
    this.owner = owner;
    this.ownerId = owner.id;
    this.logger = logger;
    this.initialOps = initialOps;
    this.ioBalancer = ioBalancer;
    this.errorHandler = errorHandler;
  }
  
  public Channel getChannel() { return this.channel; }
  
  @Probe(level = ProbeLevel.DEBUG)
  private long opsInterested() {
    SelectionKey selectionKey = this.selectionKey;
    return (selectionKey == null) ? -1L : selectionKey.interestOps();
  }
  
  @Probe(level = ProbeLevel.DEBUG)
  private long opsReady() {
    SelectionKey selectionKey = this.selectionKey;
    return (selectionKey == null) ? -1L : selectionKey.readyOps();
  }
  
  public NioThread owner() { return this.owner; }
  
  void start() { addTaskAndWakeup(new Object(this, this)); }
  
  private SelectionKey getSelectionKey() throws IOException {
    if (this.selectionKey == null)
      this.selectionKey = this.socketChannel.register(this.owner.getSelector(), this.initialOps, this); 
    return this.selectionKey;
  }
  
  final void setSelectionKey(SelectionKey selectionKey) { this.selectionKey = selectionKey; }
  
  final void registerOp(int operation) throws IOException {
    SelectionKey selectionKey = getSelectionKey();
    selectionKey.interestOps(selectionKey.interestOps() | operation);
  }
  
  final void unregisterOp(int operation) throws IOException {
    SelectionKey selectionKey = getSelectionKey();
    int interestOps = selectionKey.interestOps();
    if ((interestOps & operation) != 0)
      selectionKey.interestOps(interestOps & (operation ^ 0xFFFFFFFF)); 
  }
  
  final void addTaskAndWakeup(Runnable task) {
    TaskNode update, old;
    do {
      NioThread localOwner = this.owner;
      if (localOwner != null) {
        localOwner.addTaskAndWakeup(task);
        return;
      } 
      old = (TaskNode)this.delayedTaskStack.get();
      update = new TaskNode(task, old);
    } while (!this.delayedTaskStack.compareAndSet(old, update));
    NioThread localOwner = this.owner;
    if (localOwner != null)
      restoreTasks(localOwner, (TaskNode)this.delayedTaskStack.getAndSet(null), true); 
  }
  
  private void restoreTasks(NioThread owner, TaskNode node, boolean wakeup) {
    if (node == null)
      return; 
    restoreTasks(owner, TaskNode.access$100(node), false);
    if (wakeup) {
      owner.addTaskAndWakeup(TaskNode.access$200(node));
    } else {
      owner.addTask(TaskNode.access$200(node));
    } 
  }
  
  public final void run() {
    if (this.owner == Thread.currentThread()) {
      try {
        process();
      } catch (Throwable t) {
        onError(t);
      } 
    } else {
      addTaskAndWakeup(this);
    } 
  }
  
  public void onError(Throwable error) {
    if (error instanceof InterruptedException)
      Thread.currentThread().interrupt(); 
    if (this.selectionKey != null)
      this.selectionKey.cancel(); 
    try {
      for (ChannelHandler handler : handlers())
        handler.interceptError(error); 
    } catch (Throwable newError) {
      error = newError;
    } 
    this.errorHandler.onError(this.channel, error);
  }
  
  public final void requestMigration(NioThread newOwner) { this.owner.addTaskAndWakeup(new StartMigrationTask(this, newOwner)); }
  
  abstract void publishMetrics();
  
  abstract void process();
  
  protected abstract Iterable<? extends ChannelHandler> handlers();
}
