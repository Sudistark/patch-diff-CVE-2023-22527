package com.hazelcast.internal.networking.nio.iobalancer;

import com.hazelcast.internal.networking.nio.MigratablePipeline;
import java.util.Set;

class LoadMigrationStrategy implements MigrationStrategy {
  private static final double MIN_MAX_RATIO_MIGRATION_THRESHOLD = 0.8D;
  
  private static final double MAXIMUM_NO_OF_EVENTS_AFTER_MIGRATION_COEFFICIENT = 0.9D;
  
  public boolean imbalanceDetected(LoadImbalance imbalance) {
    long min = imbalance.minimumLoad;
    long max = imbalance.maximumLoad;
    if (min == Float.MIN_VALUE || max == Float.MAX_VALUE)
      return false; 
    long lowerBound = (long)(0.8D * max);
    return (min < lowerBound);
  }
  
  public MigratablePipeline findPipelineToMigrate(LoadImbalance imbalance) {
    Set<? extends MigratablePipeline> candidates = imbalance.getPipelinesOwnedBy(imbalance.srcOwner);
    long migrationThreshold = (long)((imbalance.maximumLoad - imbalance.minimumLoad) * 0.9D);
    MigratablePipeline candidate = null;
    long loadInSelectedPipeline = 0L;
    for (MigratablePipeline pipeline : candidates) {
      long load = imbalance.getLoad(pipeline);
      if (load > loadInSelectedPipeline && 
        load < migrationThreshold) {
        loadInSelectedPipeline = load;
        candidate = pipeline;
      } 
    } 
    return candidate;
  }
}
