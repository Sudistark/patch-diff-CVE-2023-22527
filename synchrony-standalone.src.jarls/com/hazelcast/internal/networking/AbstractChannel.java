package com.hazelcast.internal.networking;

import com.hazelcast.logging.ILogger;
import com.hazelcast.logging.Logger;
import com.hazelcast.nio.IOUtil;
import com.hazelcast.util.Preconditions;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.nio.channels.SocketChannel;
import java.util.Collections;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

public abstract class AbstractChannel implements Channel {
  private static final int FALSE = 0;
  
  private static final int TRUE = 1;
  
  private static final AtomicIntegerFieldUpdater<AbstractChannel> CLOSED = AtomicIntegerFieldUpdater.newUpdater(AbstractChannel.class, "closed");
  
  private static final AtomicReferenceFieldUpdater<AbstractChannel, SocketAddress> LOCAL_ADDRESS = AtomicReferenceFieldUpdater.newUpdater(AbstractChannel.class, SocketAddress.class, "localAddress");
  
  private static final AtomicReferenceFieldUpdater<AbstractChannel, SocketAddress> REMOTE_ADDRESS = AtomicReferenceFieldUpdater.newUpdater(AbstractChannel.class, SocketAddress.class, "remoteAddress");
  
  protected final SocketChannel socketChannel;
  
  protected final ILogger logger;
  
  private final ConcurrentMap<?, ?> attributeMap;
  
  private final Set<ChannelCloseListener> closeListeners;
  
  private final boolean clientMode;
  
  public AbstractChannel(SocketChannel socketChannel, boolean clientMode) {
    this.attributeMap = new ConcurrentHashMap();
    this
      .closeListeners = Collections.newSetFromMap(new ConcurrentHashMap());
    this.closed = 0;
    this.socketChannel = socketChannel;
    this.clientMode = clientMode;
    this.logger = Logger.getLogger(getClass());
  }
  
  public boolean isClientMode() { return this.clientMode; }
  
  public ConcurrentMap attributeMap() { return this.attributeMap; }
  
  public Socket socket() { return this.socketChannel.socket(); }
  
  public SocketChannel socketChannel() { return this.socketChannel; }
  
  public SocketAddress remoteSocketAddress() {
    if (this.remoteAddress == null) {
      Socket socket = socket();
      if (socket != null)
        REMOTE_ADDRESS.compareAndSet(this, null, socket.getRemoteSocketAddress()); 
    } 
    return this.remoteAddress;
  }
  
  public SocketAddress localSocketAddress() {
    if (this.localAddress == null) {
      Socket socket = socket();
      if (socket != null)
        LOCAL_ADDRESS.compareAndSet(this, null, socket().getLocalSocketAddress()); 
    } 
    return this.localAddress;
  }
  
  public void connect(InetSocketAddress address, int timeoutMillis) throws IOException {
    try {
      Preconditions.checkNotNull(address, "address");
      Preconditions.checkNotNegative(timeoutMillis, "timeoutMillis can't be negative");
      this.socketChannel.configureBlocking(true);
      try {
        if (timeoutMillis > 0) {
          this.socketChannel.socket().connect(address, timeoutMillis);
        } else {
          this.socketChannel.connect(address);
        } 
      } catch (SocketException ex) {
        SocketException newEx = new SocketException(ex.getMessage() + " to address " + address);
        newEx.setStackTrace(ex.getStackTrace());
        throw newEx;
      } 
      onConnect();
      if (this.logger.isFinestEnabled())
        this.logger.finest("Successfully connected to: " + address + " using socket " + this.socketChannel.socket()); 
    } catch (RuntimeException e) {
      IOUtil.closeResource(this);
      throw e;
    } catch (IOException e) {
      IOUtil.closeResource(this);
      throw e;
    } 
  }
  
  protected void onConnect() {}
  
  public boolean isClosed() { return (this.closed == 1); }
  
  public void close() {
    if (!CLOSED.compareAndSet(this, 0, 1))
      return; 
    close0();
  }
  
  protected void close0() {}
  
  public void addCloseListener(ChannelCloseListener listener) { this.closeListeners.add(Preconditions.checkNotNull(listener, "listener")); }
  
  protected final void notifyCloseListeners() {
    for (ChannelCloseListener closeListener : this.closeListeners) {
      try {
        closeListener.onClose(this);
      } catch (Exception e) {
        this.logger.severe(String.format("Failed to process closeListener [%s] on channel [%s]", new Object[] { closeListener, this }), e);
      } 
    } 
  }
}
