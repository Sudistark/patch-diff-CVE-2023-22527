package com.hazelcast.logging;

import com.hazelcast.instance.BuildInfo;
import com.hazelcast.instance.JetBuildInfo;
import com.hazelcast.instance.MemberImpl;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.logging.Level;

public class LoggingServiceImpl implements LoggingService {
  private final CopyOnWriteArrayList<LogListenerRegistration> listeners;
  
  private final ConcurrentMap<String, ILogger> mapLoggers;
  
  private final ConstructorFunction<String, ILogger> loggerConstructor;
  
  private final LoggerFactory loggerFactory;
  
  private final String versionMessage;
  
  public LoggingServiceImpl(String groupName, String loggingType, BuildInfo buildInfo) {
    this.listeners = new CopyOnWriteArrayList();
    this.mapLoggers = new ConcurrentHashMap(100);
    this.loggerConstructor = new Object(this);
    this.thisMember = new MemberImpl();
    this.thisAddressString = "[LOCAL] ";
    this.minLevel = Level.OFF;
    this.loggerFactory = Logger.newLoggerFactory(loggingType);
    JetBuildInfo jetBuildInfo = buildInfo.getJetBuildInfo();
    this
      .versionMessage = "[" + groupName + "] [" + ((jetBuildInfo != null) ? jetBuildInfo.getVersion() : buildInfo.getVersion()) + "] ";
  }
  
  public void setThisMember(MemberImpl thisMember) {
    this.thisMember = thisMember;
    this
      .thisAddressString = "[" + thisMember.getAddress().getHost() + "]:" + thisMember.getAddress().getPort() + " ";
  }
  
  public ILogger getLogger(String name) { return (ILogger)ConcurrencyUtil.getOrPutIfAbsent(this.mapLoggers, name, this.loggerConstructor); }
  
  public ILogger getLogger(Class clazz) { return (ILogger)ConcurrencyUtil.getOrPutIfAbsent(this.mapLoggers, clazz.getName(), this.loggerConstructor); }
  
  public void addLogListener(Level level, LogListener logListener) {
    this.listeners.add(new LogListenerRegistration(level, logListener));
    if (level.intValue() < this.minLevel.intValue())
      this.minLevel = level; 
  }
  
  public void removeLogListener(LogListener logListener) { this.listeners.remove(new LogListenerRegistration(Level.ALL, logListener)); }
  
  void handleLogEvent(LogEvent logEvent) {
    for (LogListenerRegistration logListenerRegistration : this.listeners) {
      if (logEvent.getLogRecord().getLevel().intValue() >= logListenerRegistration.getLevel().intValue())
        logListenerRegistration.getLogListener().log(logEvent); 
    } 
  }
}
