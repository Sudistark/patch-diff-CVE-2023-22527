package com.hazelcast.instance;

import com.hazelcast.config.Config;
import com.hazelcast.config.XmlConfigBuilder;
import com.hazelcast.core.DuplicateInstanceNameException;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.LifecycleEvent;
import com.hazelcast.core.Member;
import com.hazelcast.internal.jmx.ManagementService;
import com.hazelcast.internal.util.ModularJavaUtils;
import com.hazelcast.logging.Logger;
import com.hazelcast.spi.annotation.PrivateApi;
import com.hazelcast.spi.properties.GroupProperty;
import com.hazelcast.util.EmptyStatement;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.SetUtil;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

@PrivateApi
public final class HazelcastInstanceFactory {
  private static final int ADDITIONAL_SLEEP_SECONDS_FOR_NON_FIRST_MEMBERS = 4;
  
  private static final AtomicInteger FACTORY_ID_GEN = new AtomicInteger();
  
  private static final ConcurrentMap<String, InstanceFuture<HazelcastInstanceProxy>> INSTANCE_MAP = new ConcurrentHashMap(5);
  
  static  {
    ModularJavaUtils.checkJavaInternalAccess(Logger.getLogger(HazelcastInstanceFactory.class));
  }
  
  public static Set<HazelcastInstance> getAllHazelcastInstances() {
    result = SetUtil.createHashSet(INSTANCE_MAP.size());
    for (InstanceFuture<HazelcastInstanceProxy> f : INSTANCE_MAP.values())
      result.add(f.get()); 
    return result;
  }
  
  public static HazelcastInstance getHazelcastInstance(String instanceName) {
    InstanceFuture<HazelcastInstanceProxy> instanceFuture = (InstanceFuture)INSTANCE_MAP.get(instanceName);
    if (instanceFuture == null)
      return null; 
    try {
      return (HazelcastInstance)instanceFuture.get();
    } catch (IllegalStateException t) {
      return null;
    } 
  }
  
  public static HazelcastInstance getOrCreateHazelcastInstance(Config config) {
    if (config == null)
      config = (new XmlConfigBuilder()).build(); 
    String name = config.getInstanceName();
    Preconditions.checkHasText(name, "instanceName must contain text");
    InstanceFuture<HazelcastInstanceProxy> future = (InstanceFuture)INSTANCE_MAP.get(name);
    if (future != null)
      return (HazelcastInstance)future.get(); 
    future = new InstanceFuture<HazelcastInstanceProxy>();
    InstanceFuture<HazelcastInstanceProxy> found = (InstanceFuture)INSTANCE_MAP.putIfAbsent(name, future);
    if (found != null)
      return (HazelcastInstance)found.get(); 
    try {
      return constructHazelcastInstance(config, name, new DefaultNodeContext(), future);
    } catch (Throwable t) {
      INSTANCE_MAP.remove(name, future);
      future.setFailure(t);
      throw ExceptionUtil.rethrow(t);
    } 
  }
  
  public static HazelcastInstance newHazelcastInstance(Config config) {
    if (config == null)
      config = Config.load(); 
    return newHazelcastInstance(config, config
        
        .getInstanceName(), new DefaultNodeContext());
  }
  
  public static String createInstanceName(Config config) { return "_hzInstance_" + FACTORY_ID_GEN.incrementAndGet() + "_" + config.getGroupConfig().getName(); }
  
  public static String getInstanceName(String instanceName, Config config) {
    String name = instanceName;
    if (name == null || name.trim().length() == 0)
      name = createInstanceName(config); 
    return name;
  }
  
  public static HazelcastInstance newHazelcastInstance(Config config, String instanceName, NodeContext nodeContext) {
    if (config == null)
      config = (new XmlConfigBuilder()).build(); 
    String name = getInstanceName(instanceName, config);
    InstanceFuture<HazelcastInstanceProxy> future = new InstanceFuture<HazelcastInstanceProxy>();
    if (INSTANCE_MAP.putIfAbsent(name, future) != null)
      throw new DuplicateInstanceNameException("HazelcastInstance with name '" + name + "' already exists!"); 
    try {
      return constructHazelcastInstance(config, name, nodeContext, future);
    } catch (Throwable t) {
      INSTANCE_MAP.remove(name, future);
      future.setFailure(t);
      throw ExceptionUtil.rethrow(t);
    } 
  }
  
  private static HazelcastInstanceProxy newHazelcastProxy(HazelcastInstanceImpl hazelcastInstance) { return new HazelcastInstanceProxy(hazelcastInstance); }
  
  private static HazelcastInstanceProxy constructHazelcastInstance(Config config, String instanceName, NodeContext nodeContext, InstanceFuture<HazelcastInstanceProxy> future) {
    HazelcastInstanceProxy proxy;
    classLoader = Thread.currentThread().getContextClassLoader();
    try {
      if (classLoader == null)
        Thread.currentThread().setContextClassLoader(HazelcastInstanceFactory.class.getClassLoader()); 
      HazelcastInstanceImpl hazelcastInstance = new HazelcastInstanceImpl(instanceName, config, nodeContext);
      OutOfMemoryErrorDispatcher.registerServer(hazelcastInstance);
      proxy = newHazelcastProxy(hazelcastInstance);
      Node node = hazelcastInstance.node;
      boolean firstMember = isFirstMember(node);
      long initialWaitSeconds = node.getProperties().getSeconds(GroupProperty.INITIAL_WAIT_SECONDS);
      if (initialWaitSeconds > 0L) {
        hazelcastInstance.logger.info(String.format("Waiting %d seconds before completing HazelcastInstance startup...", new Object[] { Long.valueOf(initialWaitSeconds) }));
        try {
          TimeUnit.SECONDS.sleep(initialWaitSeconds);
          if (firstMember) {
            node.partitionService.firstArrangement();
          } else {
            TimeUnit.SECONDS.sleep(4L);
          } 
        } catch (InterruptedException ignored) {
          Thread.currentThread().interrupt();
        } 
      } 
      awaitMinimalClusterSize(hazelcastInstance, node, firstMember);
      future.set(proxy);
      hazelcastInstance.lifecycleService.fireLifecycleEvent(LifecycleEvent.LifecycleState.STARTED);
    } catch (Throwable t) {
      throw ExceptionUtil.rethrow(t);
    } finally {
      Thread.currentThread().setContextClassLoader(classLoader);
    } 
    return proxy;
  }
  
  private static boolean isFirstMember(Node node) {
    Iterator<Member> iterator = node.getClusterService().getMembers().iterator();
    return (iterator.hasNext() && ((Member)iterator.next()).localMember());
  }
  
  private static void awaitMinimalClusterSize(HazelcastInstanceImpl hazelcastInstance, Node node, boolean firstMember) throws InterruptedException {
    int initialMinClusterSize = node.getProperties().getInteger(GroupProperty.INITIAL_MIN_CLUSTER_SIZE);
    while (node.getClusterService().getSize() < initialMinClusterSize) {
      try {
        hazelcastInstance.logger.info("HazelcastInstance waiting for cluster size of " + initialMinClusterSize);
        TimeUnit.SECONDS.sleep(1L);
      } catch (InterruptedException ignored) {
        Thread.currentThread().interrupt();
      } 
    } 
    if (initialMinClusterSize > 1) {
      if (firstMember) {
        node.partitionService.firstArrangement();
      } else {
        TimeUnit.SECONDS.sleep(3L);
      } 
      hazelcastInstance.logger.info("HazelcastInstance starting after waiting for cluster size of " + initialMinClusterSize);
    } 
  }
  
  public static void shutdownAll() { shutdownAll(false); }
  
  public static void terminateAll() { shutdownAll(true); }
  
  private static void shutdownAll(boolean terminate) {
    List<HazelcastInstanceProxy> instances = new LinkedList<HazelcastInstanceProxy>();
    for (InstanceFuture<HazelcastInstanceProxy> future : INSTANCE_MAP.values()) {
      try {
        HazelcastInstanceProxy instanceProxy = (HazelcastInstanceProxy)future.get();
        instances.add(instanceProxy);
      } catch (RuntimeException ignored) {
        EmptyStatement.ignore(ignored);
      } 
    } 
    INSTANCE_MAP.clear();
    OutOfMemoryErrorDispatcher.clearServers();
    ManagementService.shutdownAll(instances);
    Collections.sort(instances, new Object());
    for (HazelcastInstanceProxy proxy : instances) {
      if (terminate) {
        proxy.getLifecycleService().terminate();
      } else {
        proxy.getLifecycleService().shutdown();
      } 
      proxy.original = null;
    } 
  }
  
  public static void remove(HazelcastInstanceImpl instance) {
    OutOfMemoryErrorDispatcher.deregisterServer(instance);
    InstanceFuture<HazelcastInstanceProxy> future = (InstanceFuture)INSTANCE_MAP.remove(instance.getName());
    if (future != null && future.isSet())
      ((HazelcastInstanceProxy)future.get()).original = null; 
    if (INSTANCE_MAP.size() == 0)
      ManagementService.shutdown(instance.getName()); 
  }
}
