package com.hazelcast.instance;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.OutOfMemoryHandler;
import com.hazelcast.spi.annotation.PrivateApi;
import com.hazelcast.util.EmptyStatement;
import com.hazelcast.util.Preconditions;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

@PrivateApi
public final class OutOfMemoryErrorDispatcher {
  private static final int MAX_REGISTERED_INSTANCES = 50;
  
  private static final HazelcastInstance[] EMPTY_INSTANCES = new HazelcastInstance[0];
  
  private static final AtomicReference<HazelcastInstance[]> SERVER_INSTANCES_REF = new AtomicReference(EMPTY_INSTANCES);
  
  private static final AtomicReference<HazelcastInstance[]> CLIENT_INSTANCES_REF = new AtomicReference(EMPTY_INSTANCES);
  
  private static final AtomicInteger OUT_OF_MEMORY_ERROR_COUNT = new AtomicInteger();
  
  static HazelcastInstance[] current() { return (HazelcastInstance[])SERVER_INSTANCES_REF.get(); }
  
  public static int getOutOfMemoryErrorCount() { return OUT_OF_MEMORY_ERROR_COUNT.get(); }
  
  public static void setServerHandler(OutOfMemoryHandler outOfMemoryHandler) { handler = outOfMemoryHandler; }
  
  public static void setClientHandler(OutOfMemoryHandler outOfMemoryHandler) { clientHandler = outOfMemoryHandler; }
  
  public static void registerServer(HazelcastInstance instance) { register(SERVER_INSTANCES_REF, instance); }
  
  public static void registerClient(HazelcastInstance instance) { register(CLIENT_INSTANCES_REF, instance); }
  
  private static void register(AtomicReference<HazelcastInstance[]> ref, HazelcastInstance instance) {
    HazelcastInstance[] newInstances, oldInstances;
    Preconditions.isNotNull(instance, "instance");
    do {
      oldInstances = (HazelcastInstance[])ref.get();
      if (oldInstances.length == 50)
        return; 
      newInstances = new HazelcastInstance[oldInstances.length + 1];
      System.arraycopy(oldInstances, 0, newInstances, 0, oldInstances.length);
      newInstances[oldInstances.length] = instance;
    } while (!ref.compareAndSet(oldInstances, newInstances));
  }
  
  public static void deregisterServer(HazelcastInstance instance) { deregister(SERVER_INSTANCES_REF, instance); }
  
  public static void deregisterClient(HazelcastInstance instance) { deregister(CLIENT_INSTANCES_REF, instance); }
  
  private static void deregister(AtomicReference<HazelcastInstance[]> ref, HazelcastInstance instance) {
    HazelcastInstance[] newInstances, oldInstances;
    Preconditions.isNotNull(instance, "instance");
    do {
      oldInstances = (HazelcastInstance[])ref.get();
      int indexOf = indexOf(oldInstances, instance);
      if (indexOf == -1)
        return; 
      if (oldInstances.length == 1) {
        newInstances = EMPTY_INSTANCES;
      } else {
        newInstances = new HazelcastInstance[oldInstances.length - 1];
        System.arraycopy(oldInstances, 0, newInstances, 0, indexOf);
        if (indexOf < newInstances.length)
          System.arraycopy(oldInstances, indexOf + 1, newInstances, indexOf, newInstances.length - indexOf); 
      } 
    } while (!ref.compareAndSet(oldInstances, newInstances));
  }
  
  private static int indexOf(HazelcastInstance[] instances, HazelcastInstance instance) {
    for (int k = 0; k < instances.length; k++) {
      if (instance == instances[k])
        return k; 
    } 
    return -1;
  }
  
  public static void clearServers() { SERVER_INSTANCES_REF.set(EMPTY_INSTANCES); }
  
  public static void clearClients() { CLIENT_INSTANCES_REF.set(EMPTY_INSTANCES); }
  
  public static void inspectOutOfMemoryError(Throwable throwable) {
    if (throwable == null)
      return; 
    if (throwable instanceof OutOfMemoryError)
      onOutOfMemory((OutOfMemoryError)throwable); 
  }
  
  public static void onOutOfMemory(OutOfMemoryError outOfMemoryError) {
    Preconditions.isNotNull(outOfMemoryError, "outOfMemoryError");
    OUT_OF_MEMORY_ERROR_COUNT.incrementAndGet();
    OutOfMemoryHandler h = clientHandler;
    if (h != null && h.shouldHandle(outOfMemoryError))
      try {
        HazelcastInstance[] clients = removeRegisteredClients();
        h.onOutOfMemory(outOfMemoryError, clients);
      } catch (Throwable ignored) {
        EmptyStatement.ignore(ignored);
      }  
    h = handler;
    if (h != null && h.shouldHandle(outOfMemoryError))
      try {
        HazelcastInstance[] instances = removeRegisteredServers();
        h.onOutOfMemory(outOfMemoryError, instances);
      } catch (Throwable ignored) {
        EmptyStatement.ignore(ignored);
      }  
  }
  
  private static HazelcastInstance[] removeRegisteredServers() { return removeRegisteredInstances(SERVER_INSTANCES_REF); }
  
  private static HazelcastInstance[] removeRegisteredClients() { return removeRegisteredInstances(CLIENT_INSTANCES_REF); }
  
  private static HazelcastInstance[] removeRegisteredInstances(AtomicReference<HazelcastInstance[]> ref) {
    HazelcastInstance[] instances;
    do {
      instances = (HazelcastInstance[])ref.get();
    } while (!ref.compareAndSet(instances, EMPTY_INSTANCES));
    return instances;
  }
}
