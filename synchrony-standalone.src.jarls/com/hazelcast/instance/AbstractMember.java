package com.hazelcast.instance;

import com.hazelcast.cluster.MemberAttributeOperationType;
import com.hazelcast.core.Member;
import com.hazelcast.internal.cluster.Versions;
import com.hazelcast.internal.serialization.impl.SerializationUtil;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.IOUtil;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.impl.Versioned;
import com.hazelcast.spi.annotation.PrivateApi;
import com.hazelcast.util.Preconditions;
import com.hazelcast.version.MemberVersion;
import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.net.UnknownHostException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@PrivateApi
public abstract class AbstractMember implements Member, Versioned {
  protected final Map<String, Object> attributes = new ConcurrentHashMap();
  
  protected Address address;
  
  protected Map<EndpointQualifier, Address> addressMap;
  
  protected String uuid;
  
  protected boolean liteMember;
  
  protected MemberVersion version;
  
  protected AbstractMember(Map<EndpointQualifier, Address> addresses, MemberVersion version, String uuid, Map<String, Object> attributes, boolean liteMember) {
    this.address = (Address)addresses.get(EndpointQualifier.MEMBER);
    this.addressMap = addresses;
    assert this.address != null : "Address is required!";
    this.version = version;
    this.uuid = (uuid != null) ? uuid : ("<" + this.address.toString() + ">");
    if (attributes != null)
      this.attributes.putAll(attributes); 
    this.liteMember = liteMember;
  }
  
  protected AbstractMember(AbstractMember member) {
    this.address = member.address;
    this.addressMap = member.addressMap;
    this.version = member.version;
    this.uuid = member.uuid;
    this.attributes.putAll(member.attributes);
    this.liteMember = member.liteMember;
  }
  
  public Address getAddress() { return this.address; }
  
  public Map<EndpointQualifier, Address> getAddressMap() { return this.addressMap; }
  
  public int getPort() { return this.address.getPort(); }
  
  public InetAddress getInetAddress() {
    try {
      return this.address.getInetAddress();
    } catch (UnknownHostException e) {
      if (getLogger() != null)
        getLogger().warning(e); 
      return null;
    } 
  }
  
  public InetSocketAddress getInetSocketAddress() { return getSocketAddress(); }
  
  public InetSocketAddress getSocketAddress() { return getSocketAddress(EndpointQualifier.MEMBER); }
  
  public InetSocketAddress getSocketAddress(EndpointQualifier qualifier) {
    Address addr = (Address)this.addressMap.get(qualifier);
    if (addr == null && !qualifier.getType().equals(ProtocolType.MEMBER))
      addr = (Address)this.addressMap.get(EndpointQualifier.MEMBER); 
    Preconditions.checkNotNull(addr);
    try {
      return addr.getInetSocketAddress();
    } catch (UnknownHostException e) {
      if (getLogger() != null)
        getLogger().warning(e); 
      return null;
    } 
  }
  
  void setUuid(String uuid) { this.uuid = uuid; }
  
  public String getUuid() { return this.uuid; }
  
  public boolean isLiteMember() { return this.liteMember; }
  
  public Map<String, Object> getAttributes() { return Collections.unmodifiableMap(this.attributes); }
  
  public void updateAttribute(MemberAttributeOperationType operationType, String key, Object value) {
    switch (null.$SwitchMap$com$hazelcast$cluster$MemberAttributeOperationType[operationType.ordinal()]) {
      case 1:
        this.attributes.put(key, value);
        return;
      case 2:
        this.attributes.remove(key);
        return;
    } 
    throw new IllegalArgumentException("Not a known OperationType " + operationType);
  }
  
  protected Object getAttribute(String key) { return this.attributes.get(key); }
  
  public MemberVersion getVersion() { return this.version; }
  
  public void readData(ObjectDataInput in) throws IOException {
    this.address = new Address();
    this.address.readData(in);
    this.uuid = in.readUTF();
    this.liteMember = in.readBoolean();
    this.version = (MemberVersion)in.readObject();
    int size = in.readInt();
    for (int i = 0; i < size; i++) {
      String key = in.readUTF();
      Object value = IOUtil.readAttributeValue(in);
      this.attributes.put(key, value);
    } 
    this.addressMap = readAddressMap(in);
  }
  
  public void writeData(ObjectDataOutput out) throws IOException {
    this.address.writeData(out);
    out.writeUTF(this.uuid);
    out.writeBoolean(this.liteMember);
    out.writeObject(this.version);
    Map<String, Object> attributes = new HashMap<String, Object>(this.attributes);
    out.writeInt(attributes.size());
    for (Map.Entry<String, Object> entry : attributes.entrySet()) {
      out.writeUTF((String)entry.getKey());
      IOUtil.writeAttributeValue(entry.getValue(), out);
    } 
    writeAddressMap(out);
  }
  
  public String toString() {
    StringBuilder sb = new StringBuilder("Member [");
    sb.append(this.address.getHost());
    sb.append("]");
    sb.append(":");
    sb.append(this.address.getPort());
    sb.append(" - ").append(this.uuid);
    if (localMember())
      sb.append(" this"); 
    if (isLiteMember())
      sb.append(" lite"); 
    return sb.toString();
  }
  
  public int hashCode() {
    result = this.address.hashCode();
    return 31 * result + this.uuid.hashCode();
  }
  
  public boolean equals(Object obj) {
    if (this == obj)
      return true; 
    if (obj == null)
      return false; 
    if (!(obj instanceof Member))
      return false; 
    Member that = (Member)obj;
    return (this.address.equals(that.getAddress()) && this.uuid.equals(that.getUuid()));
  }
  
  private void writeAddressMap(ObjectDataOutput out) throws IOException {
    if (out.getVersion().isUnknownOrLessThan(Versions.V3_12))
      return; 
    SerializationUtil.writeNullableMap(this.addressMap, out);
  }
  
  private Map<EndpointQualifier, Address> readAddressMap(ObjectDataInput in) throws IOException {
    if (in.getVersion().isUnknownOrLessThan(Versions.V3_12))
      return null; 
    return SerializationUtil.readNullableMap(in);
  }
  
  protected AbstractMember() {}
  
  protected abstract ILogger getLogger();
}
