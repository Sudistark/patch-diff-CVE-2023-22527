package com.hazelcast.executor.impl;

import com.hazelcast.config.ExecutorConfig;
import com.hazelcast.core.DistributedObject;
import com.hazelcast.logging.ILogger;
import com.hazelcast.monitor.LocalExecutorStats;
import com.hazelcast.monitor.impl.LocalExecutorStatsImpl;
import com.hazelcast.spi.ExecutionService;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.QuorumAwareService;
import com.hazelcast.spi.RemoteService;
import com.hazelcast.spi.StatisticsAwareService;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.ContextMutexFactory;
import com.hazelcast.util.MapUtil;
import java.util.Collections;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

public class DistributedExecutorService extends Object implements ManagedService, RemoteService, StatisticsAwareService<LocalExecutorStats>, QuorumAwareService {
  public static final String SERVICE_NAME = "hz:impl:executorService";
  
  private static final Object NULL_OBJECT = new Object();
  
  private static final AtomicReferenceFieldUpdater<CallableProcessor, Boolean> RESPONSE_FLAG = AtomicReferenceFieldUpdater.newUpdater(CallableProcessor.class, Boolean.class, "responseFlag");
  
  final ConcurrentMap<String, ExecutorConfig> executorConfigCache = new ConcurrentHashMap();
  
  private NodeEngine nodeEngine;
  
  private ExecutionService executionService;
  
  private final ConcurrentMap<String, CallableProcessor> submittedTasks = new ConcurrentHashMap(100);
  
  private final Set<String> shutdownExecutors = Collections.newSetFromMap(new ConcurrentHashMap());
  
  private final ConcurrentHashMap<String, LocalExecutorStatsImpl> statsMap = new ConcurrentHashMap();
  
  private final ConstructorFunction<String, LocalExecutorStatsImpl> localExecutorStatsConstructorFunction = new Object(this);
  
  private final ConcurrentMap<String, Object> quorumConfigCache = new ConcurrentHashMap();
  
  private final ContextMutexFactory quorumConfigCacheMutexFactory = new ContextMutexFactory();
  
  private final ConstructorFunction<String, Object> quorumConfigConstructor = new Object(this);
  
  private ILogger logger;
  
  public void init(NodeEngine nodeEngine, Properties properties) {
    this.nodeEngine = nodeEngine;
    this.executionService = nodeEngine.getExecutionService();
    this.logger = nodeEngine.getLogger(DistributedExecutorService.class);
  }
  
  public void reset() {
    this.shutdownExecutors.clear();
    this.submittedTasks.clear();
    this.statsMap.clear();
    this.executorConfigCache.clear();
  }
  
  public void shutdown(boolean terminate) { reset(); }
  
  public void execute(String name, String uuid, Callable callable, Operation op) {
    ExecutorConfig cfg = getOrFindExecutorConfig(name);
    if (cfg.isStatisticsEnabled())
      startPending(name); 
    CallableProcessor processor = new CallableProcessor(this, name, uuid, callable, op, cfg.isStatisticsEnabled(), null);
    if (uuid != null)
      this.submittedTasks.put(uuid, processor); 
    try {
      this.executionService.execute(name, processor);
    } catch (RejectedExecutionException e) {
      if (cfg.isStatisticsEnabled())
        rejectExecution(name); 
      this.logger.warning("While executing " + callable + " on Executor[" + name + "]", e);
      if (uuid != null)
        this.submittedTasks.remove(uuid); 
      CallableProcessor.access$300(processor, e);
    } 
  }
  
  public boolean cancel(String uuid, boolean interrupt) {
    CallableProcessor processor = (CallableProcessor)this.submittedTasks.remove(uuid);
    if (processor != null && processor.cancel(interrupt) && 
      CallableProcessor.access$300(processor, new CancellationException())) {
      if (processor.isStatisticsEnabled())
        getLocalExecutorStats(CallableProcessor.access$400(processor)).cancelExecution(); 
      return true;
    } 
    return false;
  }
  
  public String getName(String uuid) {
    CallableProcessor proc = (CallableProcessor)this.submittedTasks.get(uuid);
    if (proc != null)
      return CallableProcessor.access$400(proc); 
    return null;
  }
  
  public void shutdownExecutor(String name) {
    this.executionService.shutdownExecutor(name);
    this.shutdownExecutors.add(name);
    this.executorConfigCache.remove(name);
  }
  
  public boolean isShutdown(String name) { return this.shutdownExecutors.contains(name); }
  
  public ExecutorServiceProxy createDistributedObject(String name) { return new ExecutorServiceProxy(name, this.nodeEngine, this); }
  
  public void destroyDistributedObject(String name) {
    this.shutdownExecutors.remove(name);
    this.executionService.shutdownExecutor(name);
    this.statsMap.remove(name);
    this.executorConfigCache.remove(name);
    this.quorumConfigCache.remove(name);
  }
  
  LocalExecutorStatsImpl getLocalExecutorStats(String name) { return (LocalExecutorStatsImpl)ConcurrencyUtil.getOrPutIfAbsent(this.statsMap, name, this.localExecutorStatsConstructorFunction); }
  
  private void startExecution(String name, long elapsed) { getLocalExecutorStats(name).startExecution(elapsed); }
  
  private void finishExecution(String name, long elapsed) { getLocalExecutorStats(name).finishExecution(elapsed); }
  
  private void startPending(String name) { getLocalExecutorStats(name).startPending(); }
  
  private void rejectExecution(String name) { getLocalExecutorStats(name).rejectExecution(); }
  
  public Map<String, LocalExecutorStats> getStats() {
    Map<String, LocalExecutorStats> executorStats = MapUtil.createHashMap(this.statsMap.size());
    for (Map.Entry<String, LocalExecutorStatsImpl> queueStat : this.statsMap.entrySet())
      executorStats.put(queueStat.getKey(), queueStat.getValue()); 
    return executorStats;
  }
  
  private ExecutorConfig getOrFindExecutorConfig(String name) {
    ExecutorConfig cfg = (ExecutorConfig)this.executorConfigCache.get(name);
    if (cfg != null)
      return cfg; 
    cfg = this.nodeEngine.getConfig().findExecutorConfig(name);
    ExecutorConfig executorConfig = (ExecutorConfig)this.executorConfigCache.putIfAbsent(name, cfg);
    return (executorConfig == null) ? cfg : executorConfig;
  }
  
  public String getQuorumName(String name) {
    if (name == null)
      return null; 
    Object quorumName = ConcurrencyUtil.getOrPutSynchronized(this.quorumConfigCache, name, this.quorumConfigCacheMutexFactory, this.quorumConfigConstructor);
    return (quorumName == NULL_OBJECT) ? null : (String)quorumName;
  }
}
