package com.hazelcast.durableexecutor.impl;

import com.hazelcast.core.DistributedObject;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.MigrationAwareService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.PartitionMigrationEvent;
import com.hazelcast.spi.PartitionReplicationEvent;
import com.hazelcast.spi.QuorumAwareService;
import com.hazelcast.spi.RemoteService;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.partition.MigrationEndpoint;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.ContextMutexFactory;
import java.util.Collections;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class DistributedDurableExecutorService implements ManagedService, RemoteService, MigrationAwareService, QuorumAwareService {
  public static final String SERVICE_NAME = "hz:impl:durableExecutorService";
  
  private static final Object NULL_OBJECT = new Object();
  
  private final NodeEngineImpl nodeEngine;
  
  private final DurableExecutorPartitionContainer[] partitionContainers;
  
  private final Set<String> shutdownExecutors;
  
  private final ConcurrentMap<String, Object> quorumConfigCache;
  
  private final ContextMutexFactory quorumConfigCacheMutexFactory;
  
  private final ConstructorFunction<String, Object> quorumConfigConstructor;
  
  public DistributedDurableExecutorService(NodeEngineImpl nodeEngine) {
    this
      .shutdownExecutors = Collections.newSetFromMap(new ConcurrentHashMap());
    this.quorumConfigCache = new ConcurrentHashMap();
    this.quorumConfigCacheMutexFactory = new ContextMutexFactory();
    this.quorumConfigConstructor = new Object(this);
    this.nodeEngine = nodeEngine;
    int partitionCount = nodeEngine.getPartitionService().getPartitionCount();
    this.partitionContainers = new DurableExecutorPartitionContainer[partitionCount];
    for (int partitionId = 0; partitionId < partitionCount; partitionId++)
      this.partitionContainers[partitionId] = new DurableExecutorPartitionContainer(nodeEngine, partitionId); 
  }
  
  public void init(NodeEngine nodeEngine, Properties properties) {}
  
  public DurableExecutorPartitionContainer getPartitionContainer(int partitionId) { return this.partitionContainers[partitionId]; }
  
  public NodeEngine getNodeEngine() { return this.nodeEngine; }
  
  public void reset() {
    this.shutdownExecutors.clear();
    for (int partitionId = 0; partitionId < this.partitionContainers.length; partitionId++)
      this.partitionContainers[partitionId] = new DurableExecutorPartitionContainer(this.nodeEngine, partitionId); 
  }
  
  public void shutdown(boolean terminate) { reset(); }
  
  public DistributedObject createDistributedObject(String name) { return new DurableExecutorServiceProxy(this.nodeEngine, this, name); }
  
  public void destroyDistributedObject(String name) {
    this.shutdownExecutors.remove(name);
    this.nodeEngine.getExecutionService().shutdownDurableExecutor(name);
    removeAllContainers(name);
    this.quorumConfigCache.remove(name);
  }
  
  public void shutdownExecutor(String name) {
    this.nodeEngine.getExecutionService().shutdownDurableExecutor(name);
    this.shutdownExecutors.add(name);
  }
  
  public boolean isShutdown(String name) { return this.shutdownExecutors.contains(name); }
  
  public Operation prepareReplicationOperation(PartitionReplicationEvent event) {
    int partitionId = event.getPartitionId();
    DurableExecutorPartitionContainer partitionContainer = this.partitionContainers[partitionId];
    return partitionContainer.prepareReplicationOperation(event.getReplicaIndex());
  }
  
  public void beforeMigration(PartitionMigrationEvent event) {}
  
  public void commitMigration(PartitionMigrationEvent event) {
    int partitionId = event.getPartitionId();
    if (event.getMigrationEndpoint() == MigrationEndpoint.SOURCE) {
      clearRingBuffersHavingLesserBackupCountThan(partitionId, event.getNewReplicaIndex());
    } else if (event.getNewReplicaIndex() == 0) {
      DurableExecutorPartitionContainer partitionContainer = this.partitionContainers[partitionId];
      partitionContainer.executeAll();
    } 
  }
  
  public void rollbackMigration(PartitionMigrationEvent event) {
    if (event.getMigrationEndpoint() == MigrationEndpoint.DESTINATION)
      clearRingBuffersHavingLesserBackupCountThan(event.getPartitionId(), event.getCurrentReplicaIndex()); 
  }
  
  private void clearRingBuffersHavingLesserBackupCountThan(int partitionId, int thresholdReplicaIndex) {
    DurableExecutorPartitionContainer partitionContainer = this.partitionContainers[partitionId];
    partitionContainer.clearRingBuffersHavingLesserBackupCountThan(thresholdReplicaIndex);
  }
  
  public String getQuorumName(String name) {
    Object quorumName = ConcurrencyUtil.getOrPutSynchronized(this.quorumConfigCache, name, this.quorumConfigCacheMutexFactory, this.quorumConfigConstructor);
    return (quorumName == NULL_OBJECT) ? null : (String)quorumName;
  }
  
  private void removeAllContainers(String name) {
    for (int i = 0; i < this.partitionContainers.length; i++)
      getPartitionContainer(i).removeContainer(name); 
  }
}
