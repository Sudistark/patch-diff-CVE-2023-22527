package com.hazelcast.spi.impl.servicemanager.impl;

import com.hazelcast.cache.impl.ICacheService;
import com.hazelcast.cache.impl.JCacheDetector;
import com.hazelcast.cardinality.impl.CardinalityEstimatorService;
import com.hazelcast.collection.impl.list.ListService;
import com.hazelcast.collection.impl.queue.QueueService;
import com.hazelcast.collection.impl.set.SetService;
import com.hazelcast.concurrent.atomiclong.AtomicLongService;
import com.hazelcast.concurrent.atomicreference.AtomicReferenceService;
import com.hazelcast.concurrent.countdownlatch.CountDownLatchService;
import com.hazelcast.concurrent.idgen.IdGeneratorService;
import com.hazelcast.concurrent.lock.LockServiceImpl;
import com.hazelcast.concurrent.semaphore.SemaphoreService;
import com.hazelcast.config.ServiceConfig;
import com.hazelcast.config.ServicesConfig;
import com.hazelcast.core.HazelcastException;
import com.hazelcast.crdt.CRDTReplicationMigrationService;
import com.hazelcast.crdt.pncounter.PNCounterService;
import com.hazelcast.durableexecutor.impl.DistributedDurableExecutorService;
import com.hazelcast.executor.impl.DistributedExecutorService;
import com.hazelcast.flakeidgen.impl.FlakeIdGeneratorService;
import com.hazelcast.instance.Node;
import com.hazelcast.instance.NodeExtension;
import com.hazelcast.logging.ILogger;
import com.hazelcast.mapreduce.impl.MapReduceService;
import com.hazelcast.multimap.impl.MultiMapService;
import com.hazelcast.nio.ClassLoaderUtil;
import com.hazelcast.replicatedmap.impl.ReplicatedMapService;
import com.hazelcast.ringbuffer.impl.RingbufferService;
import com.hazelcast.scheduledexecutor.impl.DistributedScheduledExecutorService;
import com.hazelcast.spi.ConfigurableService;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.SharedService;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.impl.servicemanager.ServiceDescriptor;
import com.hazelcast.spi.impl.servicemanager.ServiceDescriptorProvider;
import com.hazelcast.spi.impl.servicemanager.ServiceInfo;
import com.hazelcast.spi.impl.servicemanager.ServiceManager;
import com.hazelcast.topic.impl.TopicService;
import com.hazelcast.topic.impl.reliable.ReliableTopicService;
import com.hazelcast.transaction.impl.xa.XAService;
import com.hazelcast.util.EmptyStatement;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.ServiceLoader;
import java.lang.reflect.Constructor;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public final class ServiceManagerImpl implements ServiceManager {
  private static final String PROVIDER_ID = ServiceDescriptorProvider.class.getName();
  
  private final NodeEngineImpl nodeEngine;
  
  private final ILogger logger;
  
  private final ConcurrentMap<String, ServiceInfo> services;
  
  public ServiceManagerImpl(NodeEngineImpl nodeEngine) {
    this.services = new ConcurrentHashMap(20, 0.75F, 1);
    this.nodeEngine = nodeEngine;
    this.logger = nodeEngine.getLogger(ServiceManagerImpl.class);
  }
  
  public void start() {
    Map<String, Properties> serviceProps = new HashMap<String, Properties>();
    Map<String, Object> serviceConfigObjects = new HashMap<String, Object>();
    registerServices(serviceProps, serviceConfigObjects);
    initServices(serviceProps, serviceConfigObjects);
  }
  
  private void registerServices(Map<String, Properties> serviceProps, Map<String, Object> serviceConfigObjects) {
    registerCoreServices();
    registerExtensionServices();
    Node node = this.nodeEngine.getNode();
    ServicesConfig servicesConfig = node.getConfig().getServicesConfig();
    if (servicesConfig != null) {
      registerDefaultServices(servicesConfig);
      registerUserServices(servicesConfig, serviceProps, serviceConfigObjects);
    } 
  }
  
  private void registerCoreServices() {
    this.logger.finest("Registering core services...");
    Node node = this.nodeEngine.getNode();
    registerService("hz:core:clusterService", node.getClusterService());
    registerService("hz:core:partitionService", node.getPartitionService());
    registerService("hz:core:proxyService", this.nodeEngine.getProxyService());
    registerService("hz:core:txManagerService", this.nodeEngine.getTransactionManagerService());
    registerService("hz:core:clientEngine", node.clientEngine);
    registerService("hz:impl:quorumService", this.nodeEngine.getQuorumService());
    registerService("hz:core:wanReplicationService", this.nodeEngine.getWanReplicationService());
    registerService("hz:core:eventService", this.nodeEngine.getEventService());
  }
  
  private void registerExtensionServices() {
    this.logger.finest("Registering extension services...");
    NodeExtension nodeExtension = this.nodeEngine.getNode().getNodeExtension();
    Map<String, Object> services = nodeExtension.createExtensionServices();
    for (Map.Entry<String, Object> entry : services.entrySet())
      registerService((String)entry.getKey(), entry.getValue()); 
  }
  
  private void registerDefaultServices(ServicesConfig servicesConfig) {
    if (!servicesConfig.isEnableDefaults())
      return; 
    this.logger.finest("Registering default services...");
    registerService("hz:impl:mapService", createService(com.hazelcast.map.impl.MapService.class));
    registerService("hz:impl:lockService", new LockServiceImpl(this.nodeEngine));
    registerService("hz:impl:queueService", new QueueService(this.nodeEngine));
    registerService("hz:impl:topicService", new TopicService());
    registerService("hz:impl:reliableTopicService", new ReliableTopicService(this.nodeEngine));
    registerService("hz:impl:multiMapService", new MultiMapService(this.nodeEngine));
    registerService("hz:impl:listService", new ListService(this.nodeEngine));
    registerService("hz:impl:setService", new SetService(this.nodeEngine));
    registerService("hz:impl:executorService", new DistributedExecutorService());
    registerService("hz:impl:durableExecutorService", new DistributedDurableExecutorService(this.nodeEngine));
    registerService("hz:impl:atomicLongService", new AtomicLongService());
    registerService("hz:impl:atomicReferenceService", new AtomicReferenceService());
    registerService("hz:impl:countDownLatchService", new CountDownLatchService());
    registerService("hz:impl:semaphoreService", new SemaphoreService(this.nodeEngine));
    registerService("hz:impl:idGeneratorService", new IdGeneratorService(this.nodeEngine));
    registerService("hz:impl:flakeIdGeneratorService", new FlakeIdGeneratorService(this.nodeEngine));
    registerService("hz:impl:mapReduceService", new MapReduceService(this.nodeEngine));
    registerService("hz:impl:replicatedMapService", new ReplicatedMapService(this.nodeEngine));
    registerService("hz:impl:ringbufferService", new RingbufferService(this.nodeEngine));
    registerService("hz:impl:xaService", new XAService(this.nodeEngine));
    registerService("hz:impl:cardinalityEstimatorService", new CardinalityEstimatorService());
    registerService("hz:impl:PNCounterService", new PNCounterService());
    registerService("hz:impl:CRDTReplicationMigrationService", new CRDTReplicationMigrationService());
    registerService("hz:impl:scheduledExecutorService", new DistributedScheduledExecutorService());
    registerCacheServiceIfAvailable();
    readServiceDescriptors();
  }
  
  private void readServiceDescriptors() {
    Node node = this.nodeEngine.getNode();
    try {
      ClassLoader classLoader = node.getConfigClassLoader();
      Iterator<Class<ServiceDescriptorProvider>> iterator = ServiceLoader.classIterator(ServiceDescriptorProvider.class, PROVIDER_ID, classLoader);
      while (iterator.hasNext()) {
        Class<ServiceDescriptorProvider> clazz = (Class)iterator.next();
        Constructor<ServiceDescriptorProvider> constructor = clazz.getDeclaredConstructor(new Class[0]);
        ServiceDescriptorProvider provider = (ServiceDescriptorProvider)constructor.newInstance(new Object[0]);
        ServiceDescriptor[] services = provider.createServiceDescriptors();
        for (ServiceDescriptor serviceDescriptor : services)
          registerService(serviceDescriptor.getServiceName(), serviceDescriptor.getService(this.nodeEngine)); 
      } 
    } catch (Exception e) {
      throw ExceptionUtil.rethrow(e);
    } 
  }
  
  private <T> T createService(Class<T> service) {
    Node node = this.nodeEngine.getNode();
    NodeExtension nodeExtension = node.getNodeExtension();
    return (T)nodeExtension.createService(service);
  }
  
  private void registerCacheServiceIfAvailable() {
    if (JCacheDetector.isJCacheAvailable(this.nodeEngine.getConfigClassLoader(), this.logger)) {
      ICacheService service = (ICacheService)createService(ICacheService.class);
      registerService("hz:impl:cacheService", service);
    } else {
      this.logger.finest("javax.cache api is not detected on classpath. Skipping CacheService...");
    } 
  }
  
  private void initServices(Map<String, Properties> serviceProps, Map<String, Object> serviceConfigObjects) {
    for (ServiceInfo serviceInfo : this.services.values())
      initService(serviceProps, serviceConfigObjects, serviceInfo); 
  }
  
  private void initService(Map<String, Properties> serviceProps, Map<String, Object> serviceConfigObjects, ServiceInfo serviceInfo) {
    Object service = serviceInfo.getService();
    if (serviceInfo.isConfigurableService())
      try {
        if (this.logger.isFinestEnabled())
          this.logger.finest("Configuring service -> " + service); 
        Object configObject = serviceConfigObjects.get(serviceInfo.getName());
        ((ConfigurableService)service).configure(configObject);
      } catch (Throwable t) {
        this.logger.severe("Error while configuring service: " + t.getMessage(), t);
      }  
    if (serviceInfo.isManagedService())
      try {
        if (this.logger.isFinestEnabled())
          this.logger.finest("Initializing service -> " + service); 
        Properties props = (Properties)serviceProps.get(serviceInfo.getName());
        ((ManagedService)service).init(this.nodeEngine, (props != null) ? props : new Properties());
      } catch (Throwable t) {
        this.logger.severe("Error while initializing service: " + t.getMessage(), t);
      }  
  }
  
  private void registerUserServices(ServicesConfig servicesConfig, Map<String, Properties> serviceProps, Map<String, Object> serviceConfigObjects) {
    this.logger.finest("Registering user defined services...");
    Collection<ServiceConfig> serviceConfigs = servicesConfig.getServiceConfigs();
    for (ServiceConfig serviceConfig : serviceConfigs)
      registerUserService(serviceProps, serviceConfigObjects, serviceConfig); 
  }
  
  private void registerUserService(Map<String, Properties> serviceProps, Map<String, Object> serviceConfigObjects, ServiceConfig serviceConfig) {
    if (!serviceConfig.isEnabled())
      return; 
    Object service = serviceConfig.getImplementation();
    if (service == null)
      service = createServiceObject(serviceConfig.getClassName()); 
    if (service != null) {
      registerService(serviceConfig.getName(), service);
      serviceProps.put(serviceConfig.getName(), serviceConfig.getProperties());
      if (serviceConfig.getConfigObject() != null)
        serviceConfigObjects.put(serviceConfig.getName(), serviceConfig.getConfigObject()); 
    } 
  }
  
  private Object createServiceObject(String className) {
    try {
      ClassLoader classLoader = this.nodeEngine.getConfigClassLoader();
      Class serviceClass = ClassLoaderUtil.loadClass(classLoader, className);
      try {
        Constructor constructor = serviceClass.getConstructor(new Class[] { com.hazelcast.spi.NodeEngine.class });
        return constructor.newInstance(new Object[] { this.nodeEngine });
      } catch (NoSuchMethodException ignored) {
        EmptyStatement.ignore(ignored);
        Constructor constructor = serviceClass.getDeclaredConstructor(new Class[0]);
        if (!constructor.isAccessible())
          constructor.setAccessible(true); 
        return constructor.newInstance(new Object[0]);
      } 
    } catch (Exception e) {
      this.logger.severe(e);
      return null;
    } 
  }
  
  public void shutdown(boolean terminate) {
    this.logger.finest("Stopping services...");
    List<ManagedService> managedServices = getServices(ManagedService.class);
    Collections.reverse(managedServices);
    this.services.clear();
    for (ManagedService service : managedServices)
      shutdownService(service, terminate); 
  }
  
  private void shutdownService(ManagedService service, boolean terminate) {
    try {
      if (this.logger.isFinestEnabled())
        this.logger.finest("Shutting down service -> " + service); 
      service.shutdown(terminate);
    } catch (Throwable t) {
      this.logger.severe("Error while shutting down service[" + service + "]: " + t.getMessage(), t);
    } 
  }
  
  public void registerService(String serviceName, Object service) {
    if (this.logger.isFinestEnabled())
      this.logger.finest("Registering service: '" + serviceName + "'"); 
    ServiceInfo serviceInfo = new ServiceInfo(serviceName, service);
    ServiceInfo currentServiceInfo = (ServiceInfo)this.services.putIfAbsent(serviceName, serviceInfo);
    if (currentServiceInfo != null) {
      this.logger.warning("Replacing " + currentServiceInfo + " with " + serviceInfo);
      if (currentServiceInfo.isCoreService())
        throw new HazelcastException("Can not replace a CoreService! Name: " + serviceName + ", Service: " + currentServiceInfo
            .getService()); 
      if (currentServiceInfo.isManagedService())
        shutdownService((ManagedService)currentServiceInfo.getService(), false); 
      this.services.put(serviceName, serviceInfo);
    } 
  }
  
  public ServiceInfo getServiceInfo(String serviceName) { return (ServiceInfo)this.services.get(serviceName); }
  
  public <S> List<S> getServices(Class<S> serviceClass) {
    LinkedList<S> result = new LinkedList<S>();
    for (ServiceInfo serviceInfo : this.services.values()) {
      if (serviceInfo.isInstanceOf(serviceClass)) {
        S service = (S)serviceInfo.getService();
        if (serviceInfo.isCoreService()) {
          result.addFirst(service);
          continue;
        } 
        result.addLast(service);
      } 
    } 
    return result;
  }
  
  public <T> T getService(String serviceName) {
    ServiceInfo serviceInfo = getServiceInfo(serviceName);
    return (T)((serviceInfo != null) ? serviceInfo.getService() : null);
  }
  
  public <T extends SharedService> T getSharedService(String serviceName) {
    Object service = getService(serviceName);
    if (service == null)
      return null; 
    if (service instanceof SharedService)
      return (T)(SharedService)service; 
    throw new IllegalArgumentException("No SharedService registered with name: " + serviceName);
  }
  
  public List<ServiceInfo> getServiceInfos(Class serviceClass) {
    LinkedList<ServiceInfo> result = new LinkedList<ServiceInfo>();
    for (ServiceInfo serviceInfo : this.services.values()) {
      if (serviceInfo.isInstanceOf(serviceClass)) {
        if (serviceInfo.isCoreService()) {
          result.addFirst(serviceInfo);
          continue;
        } 
        result.addLast(serviceInfo);
      } 
    } 
    return result;
  }
}
