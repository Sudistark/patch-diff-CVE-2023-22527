package com.hazelcast.spi.impl.operationparker.impl;

import com.hazelcast.instance.MemberImpl;
import com.hazelcast.instance.Node;
import com.hazelcast.internal.metrics.MetricsProvider;
import com.hazelcast.internal.metrics.MetricsRegistry;
import com.hazelcast.internal.metrics.Probe;
import com.hazelcast.internal.partition.MigrationInfo;
import com.hazelcast.logging.ILogger;
import com.hazelcast.spi.BlockingOperation;
import com.hazelcast.spi.LiveOperations;
import com.hazelcast.spi.LiveOperationsTracker;
import com.hazelcast.spi.Notifier;
import com.hazelcast.spi.WaitNotifyKey;
import com.hazelcast.spi.exception.TargetDisconnectedException;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.impl.operationparker.OperationParker;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.ThreadUtil;
import com.hazelcast.util.executor.SingleExecutorThreadFactory;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.DelayQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class OperationParkerImpl implements OperationParker, LiveOperationsTracker, MetricsProvider {
  private static final long FIRST_WAIT_TIME = 1000L;
  
  private final ConcurrentMap<WaitNotifyKey, WaitSet> waitSetMap;
  
  private final DelayQueue delayQueue;
  
  private final ExecutorService expirationExecutor;
  
  private final Future expirationTaskFuture;
  
  private final NodeEngineImpl nodeEngine;
  
  private final ILogger logger;
  
  private final ConstructorFunction<WaitNotifyKey, WaitSet> waitSetConstructor;
  
  public OperationParkerImpl(NodeEngineImpl nodeEngine) {
    this.waitSetMap = new ConcurrentHashMap(100);
    this.delayQueue = new DelayQueue();
    this.waitSetConstructor = new Object(this);
    this.nodeEngine = nodeEngine;
    Node node = nodeEngine.getNode();
    this.logger = node.getLogger(OperationParker.class);
    this.expirationExecutor = Executors.newSingleThreadExecutor(new SingleExecutorThreadFactory(node
          .getConfigClassLoader(), 
          ThreadUtil.createThreadName(nodeEngine.getHazelcastInstance().getName(), "operation-parker")));
    this.expirationTaskFuture = this.expirationExecutor.submit(new ExpirationTask(this, null));
  }
  
  public void provideMetrics(MetricsRegistry registry) { registry.scanAndRegister(this, "operation-parker"); }
  
  public void populate(LiveOperations liveOperations) {
    for (WaitSet waitSet : this.waitSetMap.values())
      waitSet.populate(liveOperations); 
  }
  
  public void park(BlockingOperation op) {
    WaitSet waitSet = (WaitSet)ConcurrencyUtil.getOrPutIfAbsent(this.waitSetMap, op.getWaitKey(), this.waitSetConstructor);
    waitSet.park(op);
  }
  
  public void unpark(Notifier notifier) {
    WaitNotifyKey waitNotifyKey = notifier.getNotifiedKey();
    WaitSet waitSet = (WaitSet)this.waitSetMap.get(waitNotifyKey);
    if (waitSet != null)
      waitSet.unpark(notifier, waitNotifyKey); 
  }
  
  @Probe
  public int getParkQueueCount() { return this.waitSetMap.size(); }
  
  @Probe
  public int getTotalParkedOperationCount() {
    int count = 0;
    for (WaitSet waitSet : this.waitSetMap.values())
      count += waitSet.size(); 
    return count;
  }
  
  public int getTotalValidWaitingOperationCount() {
    int count = 0;
    for (WaitSet waitSet : this.waitSetMap.values())
      count += waitSet.totalValidWaitingOperationCount(); 
    return count;
  }
  
  public void onMemberLeft(MemberImpl leftMember) {
    for (WaitSet waitSet : this.waitSetMap.values())
      waitSet.invalidateAll(leftMember.getUuid()); 
  }
  
  public void onClientDisconnected(String clientUuid) {
    for (WaitSet waitSet : this.waitSetMap.values())
      waitSet.cancelAll(clientUuid, new TargetDisconnectedException("Client disconnected: " + clientUuid)); 
  }
  
  public void onPartitionMigrate(MigrationInfo migrationInfo) {
    if (migrationInfo.getSource() == null || !migrationInfo.getSource().isIdentical(this.nodeEngine.getLocalMember()))
      return; 
    for (WaitSet waitSet : this.waitSetMap.values())
      waitSet.onPartitionMigrate(migrationInfo); 
  }
  
  public void cancelParkedOperations(String serviceName, Object objectId, Throwable cause) {
    for (WaitSet waitSet : this.waitSetMap.values())
      waitSet.cancelAll(serviceName, objectId, cause); 
  }
  
  public void reset() {
    this.delayQueue.clear();
    this.waitSetMap.clear();
  }
  
  public void shutdown() {
    this.logger.finest("Stopping tasks...");
    this.expirationTaskFuture.cancel(true);
    this.expirationExecutor.shutdown();
    for (WaitSet waitSet : this.waitSetMap.values())
      waitSet.onShutdown(); 
    this.waitSetMap.clear();
  }
  
  public String toString() {
    StringBuilder sb = new StringBuilder("OperationParker{");
    sb.append("delayQueue=");
    sb.append(this.delayQueue.size());
    sb.append(" \n[");
    for (WaitSet waitSet : this.waitSetMap.values()) {
      sb.append("\t");
      sb.append(waitSet.size());
      sb.append(", ");
    } 
    sb.append("]\n}");
    return sb.toString();
  }
}
