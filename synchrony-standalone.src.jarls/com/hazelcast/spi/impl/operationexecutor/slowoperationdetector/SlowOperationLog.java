package com.hazelcast.spi.impl.operationexecutor.slowoperationdetector;

import com.hazelcast.internal.diagnostics.OperationDescriptors;
import com.hazelcast.internal.management.dto.SlowOperationDTO;
import com.hazelcast.internal.management.dto.SlowOperationInvocationDTO;
import com.hazelcast.spi.Operation;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

final class SlowOperationLog {
  private static final int SHORT_STACKTRACE_LENGTH = 200;
  
  final AtomicInteger totalInvocations = new AtomicInteger(0);
  
  final String operation;
  
  final String stackTrace;
  
  final String shortStackTrace;
  
  private final ConcurrentHashMap<Integer, Invocation> invocations = new ConcurrentHashMap();
  
  SlowOperationLog(String stackTrace, Object task) {
    if (task instanceof Operation) {
      this.operation = OperationDescriptors.toOperationDesc((Operation)task);
    } else {
      this.operation = task.getClass().getName();
    } 
    this.stackTrace = stackTrace;
    if (stackTrace.length() <= 200) {
      this.shortStackTrace = stackTrace;
    } else {
      this.shortStackTrace = stackTrace.substring(0, stackTrace.indexOf('\n', 200)) + "\n\t(...)";
    } 
  }
  
  Invocation getOrCreate(Integer operationHashCode, Object operation, long lastDurationNanos, long nowNanos, long nowMillis) {
    Invocation candidate = (Invocation)this.invocations.get(operationHashCode);
    if (candidate != null)
      return candidate; 
    int durationMs = (int)TimeUnit.NANOSECONDS.toMillis(lastDurationNanos);
    long startedAt = nowMillis - durationMs;
    candidate = new Invocation(operation.toString(), startedAt, nowNanos, durationMs, null);
    this.invocations.put(operationHashCode, candidate);
    return candidate;
  }
  
  boolean purgeInvocations(long nowNanos, long slowOperationLogLifetimeNanos) {
    for (Map.Entry<Integer, Invocation> invocationEntry : this.invocations.entrySet()) {
      if (nowNanos - Invocation.access$100((Invocation)invocationEntry.getValue()) > slowOperationLogLifetimeNanos)
        this.invocations.remove(invocationEntry.getKey()); 
    } 
    return this.invocations.isEmpty();
  }
  
  SlowOperationDTO createDTO() {
    List<SlowOperationInvocationDTO> invocationDTOList = new ArrayList<SlowOperationInvocationDTO>(this.invocations.size());
    for (Map.Entry<Integer, Invocation> invocationEntry : this.invocations.entrySet()) {
      int id = ((Integer)invocationEntry.getKey()).intValue();
      invocationDTOList.add(((Invocation)invocationEntry.getValue()).createDTO(id));
    } 
    return new SlowOperationDTO(this.operation, this.stackTrace, this.totalInvocations.get(), invocationDTOList);
  }
}
