package com.hazelcast.spi.impl.merge;

import com.hazelcast.config.MergePolicyConfig;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.impl.operationexecutor.OperationExecutor;
import com.hazelcast.spi.impl.operationservice.impl.OperationServiceImpl;
import com.hazelcast.spi.merge.SplitBrainMergePolicyProvider;
import com.hazelcast.spi.partition.IPartitionService;
import java.util.Collection;
import java.util.Iterator;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CountDownLatch;

public abstract class AbstractContainerCollector<C> extends Object {
  private final ConcurrentMap<Integer, Collection<C>> containersByPartitionId;
  
  private final OperationExecutor operationExecutor;
  
  private final IPartitionService partitionService;
  
  private final SplitBrainMergePolicyProvider mergePolicyProvider;
  
  private CountDownLatch latch;
  
  protected AbstractContainerCollector(NodeEngine nodeEngine) {
    this.containersByPartitionId = new ConcurrentHashMap();
    this.operationExecutor = ((OperationServiceImpl)nodeEngine.getOperationService()).getOperationExecutor();
    this.partitionService = nodeEngine.getPartitionService();
    this.mergePolicyProvider = nodeEngine.getSplitBrainMergePolicyProvider();
  }
  
  public final void run() {
    int partitionCount = this.partitionService.getPartitionCount();
    this.latch = new CountDownLatch(partitionCount);
    for (partitionId = 0; partitionId < partitionCount; partitionId++)
      this.operationExecutor.execute(new CollectContainerRunnable(this, partitionId)); 
    try {
      this.latch.await();
    } catch (InterruptedException partitionId) {
      InterruptedException e;
      Thread.currentThread().interrupt();
    } 
  }
  
  public final ConcurrentMap<Integer, Collection<C>> getCollectedContainers() { return this.containersByPartitionId; }
  
  public final void destroy() {
    for (Collection<C> containers : this.containersByPartitionId.values()) {
      for (C container : containers)
        destroy(container); 
    } 
    this.containersByPartitionId.clear();
    onDestroy();
  }
  
  protected void onDestroy() {}
  
  protected boolean isMergeable(C container) { return true; }
  
  protected abstract Iterator<C> containerIterator(int paramInt);
  
  protected abstract MergePolicyConfig getMergePolicyConfig(C paramC);
  
  protected abstract void destroy(C paramC);
  
  protected abstract void destroyBackup(C paramC);
  
  protected abstract int getMergingValueCount();
}
