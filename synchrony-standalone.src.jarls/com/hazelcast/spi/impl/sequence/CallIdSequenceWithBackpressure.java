package com.hazelcast.spi.impl.sequence;

import com.hazelcast.core.HazelcastOverloadException;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.concurrent.BackoffIdleStrategy;
import com.hazelcast.util.concurrent.IdleStrategy;
import java.util.concurrent.TimeUnit;

public final class CallIdSequenceWithBackpressure extends AbstractCallIdSequence {
  static final int MAX_DELAY_MS = 500;
  
  private static final IdleStrategy IDLER = new BackoffIdleStrategy(0L, 0L, TimeUnit.MILLISECONDS
      .toNanos(1L), TimeUnit.MILLISECONDS.toNanos(500L));
  
  private final long backoffTimeoutNanos;
  
  public CallIdSequenceWithBackpressure(int maxConcurrentInvocations, long backoffTimeoutMs) {
    super(maxConcurrentInvocations);
    Preconditions.checkPositive(backoffTimeoutMs, "backoffTimeoutMs should be a positive number. backoffTimeoutMs=" + backoffTimeoutMs);
    this.backoffTimeoutNanos = TimeUnit.MILLISECONDS.toNanos(backoffTimeoutMs);
  }
  
  protected void handleNoSpaceLeft() {
    long start = System.nanoTime();
    for (long idleCount = 0L;; idleCount++) {
      long elapsedNanos = System.nanoTime() - start;
      if (elapsedNanos > this.backoffTimeoutNanos)
        throw new HazelcastOverloadException(String.format("Timed out trying to acquire another call ID. maxConcurrentInvocations = %d, backoffTimeout = %d msecs, elapsed:%d msecs", new Object[] { Integer.valueOf(getMaxConcurrentInvocations()), Long.valueOf(TimeUnit.NANOSECONDS.toMillis(this.backoffTimeoutNanos)), 
                Long.valueOf(TimeUnit.NANOSECONDS.toMillis(elapsedNanos)) })); 
      IDLER.idle(idleCount);
      if (hasSpace())
        return; 
    } 
  }
}
