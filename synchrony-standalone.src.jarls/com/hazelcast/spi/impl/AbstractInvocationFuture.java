package com.hazelcast.spi.impl;

import com.hazelcast.core.ExecutionCallback;
import com.hazelcast.logging.ILogger;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.Preconditions;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import java.util.concurrent.locks.LockSupport;

@SuppressFBWarnings(value = {"DLS_DEAD_STORE_OF_CLASS_LITERAL"}, justification = "Recommended way to prevent classloading bug")
public abstract class AbstractInvocationFuture<V> extends Object implements InternalCompletableFuture<V> {
  static final Object VOID = "VOID";
  
  private static final AtomicReferenceFieldUpdater<AbstractInvocationFuture, Object> STATE;
  
  protected final Executor defaultExecutor;
  
  protected final ILogger logger;
  
  static  {
    Class clazz = LockSupport.class;
    STATE = AtomicReferenceFieldUpdater.newUpdater(AbstractInvocationFuture.class, Object.class, "state");
  }
  
  protected AbstractInvocationFuture(Executor defaultExecutor, ILogger logger) {
    this.state = VOID;
    this.defaultExecutor = defaultExecutor;
    this.logger = logger;
  }
  
  boolean compareAndSetState(Object oldState, Object newState) { return STATE.compareAndSet(this, oldState, newState); }
  
  protected final Object getState() { return this.state; }
  
  public final boolean isDone() { return isDone(this.state); }
  
  private static boolean isDone(Object state) {
    if (state == null)
      return true; 
    return (state != VOID && !(state instanceof WaitNode) && !(state instanceof Thread) && !(state instanceof ExecutionCallback));
  }
  
  protected void onInterruptDetected() {}
  
  public boolean cancel(boolean mayInterruptIfRunning) { return complete(new CancellationException()); }
  
  public boolean isCancelled() { return this.state instanceof CancellationException; }
  
  public final V join() {
    try {
      return (V)get();
    } catch (Throwable throwable) {
      throw ExceptionUtil.rethrow(throwable);
    } 
  }
  
  public final V get() {
    Object response = registerWaiter(Thread.currentThread(), null);
    if (response != VOID)
      return (V)resolveAndThrowIfException(response); 
    interrupted = false;
    try {
      while (true) {
        LockSupport.park();
        if (isDone()) {
          object = resolveAndThrowIfException(this.state);
          return (V)object;
        } 
        if (Thread.interrupted()) {
          interrupted = true;
          onInterruptDetected();
        } 
      } 
    } finally {
      restoreInterrupt(interrupted);
    } 
  }
  
  public final V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
    Object response = registerWaiter(Thread.currentThread(), null);
    if (response != VOID)
      return (V)resolveAndThrowIfException(response); 
    long deadlineNanos = System.nanoTime() + unit.toNanos(timeout);
    interrupted = false;
    try {
      long timeoutNanos = unit.toNanos(timeout);
      while (timeoutNanos > 0L) {
        LockSupport.parkNanos(timeoutNanos);
        timeoutNanos = deadlineNanos - System.nanoTime();
        if (isDone()) {
          object = resolveAndThrowIfException(this.state);
          return (V)object;
        } 
        if (Thread.interrupted()) {
          interrupted = true;
          onInterruptDetected();
        } 
      } 
    } finally {
      restoreInterrupt(interrupted);
    } 
    unregisterWaiter(Thread.currentThread());
    throw newTimeoutException(timeout, unit);
  }
  
  private static void restoreInterrupt(boolean interrupted) {
    if (interrupted)
      Thread.currentThread().interrupt(); 
  }
  
  public void andThen(ExecutionCallback<V> callback) { andThen(callback, this.defaultExecutor); }
  
  public void andThen(ExecutionCallback<V> callback, Executor executor) {
    Preconditions.isNotNull(callback, "callback");
    Preconditions.isNotNull(executor, "executor");
    Object response = registerWaiter(callback, executor);
    if (response != VOID)
      unblock(callback, executor); 
  }
  
  private void unblockAll(Object waiter, Executor executor) {
    while (waiter != null) {
      if (waiter instanceof Thread) {
        LockSupport.unpark((Thread)waiter);
        return;
      } 
      if (waiter instanceof ExecutionCallback) {
        unblock((ExecutionCallback)waiter, executor);
        return;
      } 
      if (waiter.getClass() == WaitNode.class) {
        WaitNode waitNode = (WaitNode)waiter;
        unblockAll(waitNode.waiter, WaitNode.access$000(waitNode));
        waiter = waitNode.next;
        continue;
      } 
      return;
    } 
  }
  
  private void unblock(ExecutionCallback<V> callback, Executor executor) {
    try {
      executor.execute(new Object(this, callback));
    } catch (RejectedExecutionException e) {
      callback.onFailure(e);
    } 
  }
  
  protected Throwable unwrap(Throwable throwable) {
    if (throwable instanceof ExecutionException && throwable.getCause() != null)
      return throwable.getCause(); 
    return throwable;
  }
  
  protected Object resolve(Object value) { return value; }
  
  private Object registerWaiter(Object waiter, Executor executor) {
    Object newState, oldState;
    assert !(waiter instanceof com.hazelcast.internal.util.executor.UnblockableThread) : "Waiting for response on this thread is illegal";
    WaitNode waitNode = null;
    do {
      oldState = this.state;
      if (isDone(oldState))
        return oldState; 
      if (oldState == VOID && (executor == null || executor == this.defaultExecutor)) {
        newState = waiter;
      } else {
        if (waitNode == null)
          waitNode = new WaitNode(waiter, executor); 
        waitNode.next = oldState;
        newState = waitNode;
      } 
    } while (!compareAndSetState(oldState, newState));
    return VOID;
  }
  
  void unregisterWaiter(Thread waiter) {
    WaitNode prev = null;
    Object current = this.state;
    while (current != null) {
      Object currentWaiter = (current.getClass() == WaitNode.class) ? ((WaitNode)current).waiter : current;
      Object next = (current.getClass() == WaitNode.class) ? ((WaitNode)current).next : null;
      if (currentWaiter == waiter) {
        if (prev == null) {
          Object n = (next == null) ? VOID : next;
          current = compareAndSetState(current, n) ? null : this.state;
          continue;
        } 
        prev.next = next;
        current = null;
        continue;
      } 
      prev = (current.getClass() == WaitNode.class) ? (WaitNode)current : null;
      current = next;
    } 
  }
  
  public final boolean complete(Object value) {
    Object oldState;
    do {
      oldState = this.state;
      if (isDone(oldState)) {
        warnIfSuspiciousDoubleCompletion(oldState, value);
        return false;
      } 
    } while (!compareAndSetState(oldState, value));
    onComplete();
    unblockAll(oldState, this.defaultExecutor);
    return true;
  }
  
  protected void onComplete() {}
  
  private void warnIfSuspiciousDoubleCompletion(Object s0, Object s1) {
    if (s0 != s1 && !(s0 instanceof CancellationException) && !(s1 instanceof CancellationException))
      this.logger.warning(String.format("Future.complete(Object) on completed future. Request: %s, current value: %s, offered value: %s", new Object[] { invocationToString(), s0, s1 })); 
  }
  
  public String toString() {
    Object state = getState();
    if (isDone(state))
      return "InvocationFuture{invocation=" + invocationToString() + ", value=" + state + '}'; 
    return "InvocationFuture{invocation=" + invocationToString() + ", done=false}";
  }
  
  protected abstract String invocationToString();
  
  protected abstract V resolveAndThrowIfException(Object paramObject) throws ExecutionException, InterruptedException;
  
  protected abstract TimeoutException newTimeoutException(long paramLong, TimeUnit paramTimeUnit);
}
