package com.hazelcast.spi.impl.executionservice.impl;

import com.hazelcast.config.ExecutorConfig;
import com.hazelcast.core.ICompletableFuture;
import com.hazelcast.instance.Node;
import com.hazelcast.internal.metrics.MetricsRegistry;
import com.hazelcast.internal.util.RuntimeAvailableProcessors;
import com.hazelcast.logging.ILogger;
import com.hazelcast.spi.TaskScheduler;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.impl.executionservice.InternalExecutionService;
import com.hazelcast.spi.properties.GroupProperty;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.ThreadUtil;
import com.hazelcast.util.executor.CachedExecutorServiceDelegate;
import com.hazelcast.util.executor.ExecutorType;
import com.hazelcast.util.executor.LoggingScheduledExecutor;
import com.hazelcast.util.executor.ManagedExecutorService;
import com.hazelcast.util.executor.NamedThreadPoolExecutor;
import com.hazelcast.util.executor.PoolExecutorThreadFactory;
import com.hazelcast.util.executor.SingleExecutorThreadFactory;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public final class ExecutionServiceImpl implements InternalExecutionService {
  private static final int CORE_POOL_SIZE = 3;
  
  private static final long KEEP_ALIVE_TIME = 60L;
  
  private static final long INITIAL_DELAY = 1000L;
  
  private static final long PERIOD = 100L;
  
  private static final int BEGIN_INDEX = 3;
  
  private static final long AWAIT_TIME = 3L;
  
  private static final int POOL_MULTIPLIER = 2;
  
  private static final int QUEUE_MULTIPLIER = 100000;
  
  private static final int ASYNC_QUEUE_CAPACITY = 100000;
  
  private static final int OFFLOADABLE_QUEUE_CAPACITY = 100000;
  
  private final NodeEngineImpl nodeEngine;
  
  private final ExecutorService cachedExecutorService;
  
  private final LoggingScheduledExecutor scheduledExecutorService;
  
  private final TaskScheduler globalTaskScheduler;
  
  private final ILogger logger;
  
  private final CompletableFutureTask completableFutureTask;
  
  private final ConcurrentMap<String, ManagedExecutorService> executors;
  
  private final ConcurrentMap<String, ManagedExecutorService> durableExecutors;
  
  private final ConcurrentMap<String, ManagedExecutorService> scheduleDurableExecutors;
  
  private final ConstructorFunction<String, ManagedExecutorService> constructor;
  
  private final ConstructorFunction<String, ManagedExecutorService> durableConstructor;
  
  private final ConstructorFunction<String, ManagedExecutorService> scheduledDurableConstructor;
  
  private final MetricsRegistry metricsRegistry;
  
  public ExecutionServiceImpl(NodeEngineImpl nodeEngine) {
    this.executors = new ConcurrentHashMap();
    this.durableExecutors = new ConcurrentHashMap();
    this.scheduleDurableExecutors = new ConcurrentHashMap();
    this.constructor = new Object(this);
    this.durableConstructor = new Object(this);
    this.scheduledDurableConstructor = new Object(this);
    this.nodeEngine = nodeEngine;
    this.metricsRegistry = nodeEngine.getMetricsRegistry();
    Node node = nodeEngine.getNode();
    this.logger = node.getLogger(com.hazelcast.spi.ExecutionService.class.getName());
    String hzName = nodeEngine.getHazelcastInstance().getName();
    ClassLoader configClassLoader = node.getConfigClassLoader();
    PoolExecutorThreadFactory poolExecutorThreadFactory = new PoolExecutorThreadFactory(ThreadUtil.createThreadPoolName(hzName, "cached"), configClassLoader);
    this.cachedExecutorService = new ThreadPoolExecutor(3, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue(), poolExecutorThreadFactory, new Object(this));
    SingleExecutorThreadFactory singleExecutorThreadFactory1 = new SingleExecutorThreadFactory(configClassLoader, ThreadUtil.createThreadPoolName(hzName, "scheduled"));
    this
      
      .scheduledExecutorService = new LoggingScheduledExecutor(this.logger, 1, singleExecutorThreadFactory1, nodeEngine.getProperties().getBoolean(GroupProperty.TASK_SCHEDULER_REMOVE_ON_CANCEL));
    int coreSize = Math.max(RuntimeAvailableProcessors.get(), 2);
    register("hz:system", coreSize, 2147483647, ExecutorType.CACHED);
    register("hz:scheduled", coreSize * 2, coreSize * 100000, ExecutorType.CACHED);
    register("hz:async", coreSize, 100000, ExecutorType.CONCRETE);
    register("hz:offloadable", coreSize, 100000, ExecutorType.CACHED);
    this.globalTaskScheduler = getTaskScheduler("hz:scheduled");
    this.completableFutureTask = new CompletableFutureTask();
    scheduleWithRepetition(this.completableFutureTask, 1000L, 100L, TimeUnit.MILLISECONDS);
  }
  
  public LoggingScheduledExecutor getScheduledExecutorService() { return this.scheduledExecutorService; }
  
  public ManagedExecutorService register(String name, int defaultPoolSize, int defaultQueueCapacity, ExecutorType type) { return register(name, defaultPoolSize, defaultQueueCapacity, type, null); }
  
  public ManagedExecutorService register(String name, int defaultPoolSize, int defaultQueueCapacity, ThreadFactory threadFactory) { return register(name, defaultPoolSize, defaultQueueCapacity, ExecutorType.CONCRETE, threadFactory); }
  
  private ManagedExecutorService register(String name, int defaultPoolSize, int defaultQueueCapacity, ExecutorType type, ThreadFactory threadFactory) {
    ExecutorConfig config = (ExecutorConfig)this.nodeEngine.getConfig().getExecutorConfigs().get(name);
    int poolSize = defaultPoolSize;
    int queueCapacity = defaultQueueCapacity;
    if (config != null) {
      poolSize = config.getPoolSize();
      if (config.getQueueCapacity() <= 0) {
        queueCapacity = Integer.MAX_VALUE;
      } else {
        queueCapacity = config.getQueueCapacity();
      } 
    } 
    ManagedExecutorService executor = createExecutor(name, poolSize, queueCapacity, type, threadFactory);
    if (this.executors.putIfAbsent(name, executor) != null)
      throw new IllegalArgumentException("ExecutorService['" + name + "'] already exists!"); 
    this.metricsRegistry.scanAndRegister(executor, "internal-executor[" + name + "]");
    return executor;
  }
  
  private ManagedExecutorService createExecutor(String name, int poolSize, int queueCapacity, ExecutorType type, ThreadFactory threadFactory) {
    NamedThreadPoolExecutor namedThreadPoolExecutor;
    if (type == ExecutorType.CACHED) {
      if (threadFactory != null)
        throw new IllegalArgumentException("Cached executor can not be used with external thread factory"); 
      namedThreadPoolExecutor = new CachedExecutorServiceDelegate(this.nodeEngine, name, this.cachedExecutorService, poolSize, queueCapacity);
    } else if (type == ExecutorType.CONCRETE) {
      PoolExecutorThreadFactory poolExecutorThreadFactory;
      if (threadFactory == null) {
        ClassLoader classLoader = this.nodeEngine.getConfigClassLoader();
        String hzName = this.nodeEngine.getHazelcastInstance().getName();
        String internalName = name.startsWith("hz:") ? name.substring(3) : name;
        String threadNamePrefix = ThreadUtil.createThreadPoolName(hzName, internalName);
        poolExecutorThreadFactory = new PoolExecutorThreadFactory(threadNamePrefix, classLoader);
      } 
      NamedThreadPoolExecutor pool = new NamedThreadPoolExecutor(name, poolSize, poolSize, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue(queueCapacity), poolExecutorThreadFactory);
      pool.allowCoreThreadTimeOut(true);
      namedThreadPoolExecutor = pool;
    } else {
      throw new IllegalArgumentException("Unknown executor type: " + type);
    } 
    return namedThreadPoolExecutor;
  }
  
  public ManagedExecutorService getExecutor(String name) { return (ManagedExecutorService)ConcurrencyUtil.getOrPutIfAbsent(this.executors, name, this.constructor); }
  
  public ManagedExecutorService getDurable(String name) { return (ManagedExecutorService)ConcurrencyUtil.getOrPutIfAbsent(this.durableExecutors, name, this.durableConstructor); }
  
  public ExecutorService getScheduledDurable(String name) { return (ExecutorService)ConcurrencyUtil.getOrPutIfAbsent(this.scheduleDurableExecutors, name, this.scheduledDurableConstructor); }
  
  public <V> ICompletableFuture<V> asCompletableFuture(Future<V> future) {
    if (future == null)
      throw new IllegalArgumentException("future must not be null"); 
    if (future instanceof ICompletableFuture)
      return (ICompletableFuture)future; 
    return registerCompletableFuture(future);
  }
  
  public void execute(String name, Runnable command) { getExecutor(name).execute(command); }
  
  public void executeDurable(String name, Runnable command) { getDurable(name).execute(command); }
  
  public Future<?> submit(String name, Runnable task) { return getExecutor(name).submit(task); }
  
  public <T> Future<T> submit(String name, Callable<T> task) { return getExecutor(name).submit(task); }
  
  public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) { return this.globalTaskScheduler.schedule(command, delay, unit); }
  
  public ScheduledFuture<?> schedule(String name, Runnable command, long delay, TimeUnit unit) { return getTaskScheduler(name).schedule(command, delay, unit); }
  
  public ScheduledFuture<?> scheduleDurable(String name, Runnable command, long delay, TimeUnit unit) { return getDurableTaskScheduler(name).schedule(command, delay, unit); }
  
  public <V> ScheduledFuture<Future<V>> scheduleDurable(String name, Callable<V> command, long delay, TimeUnit unit) { return getDurableTaskScheduler(name).schedule(command, delay, unit); }
  
  public ScheduledFuture<?> scheduleWithRepetition(Runnable command, long initialDelay, long period, TimeUnit unit) { return this.globalTaskScheduler.scheduleWithRepetition(command, initialDelay, period, unit); }
  
  public ScheduledFuture<?> scheduleWithRepetition(String name, Runnable command, long initialDelay, long period, TimeUnit unit) { return getTaskScheduler(name).scheduleWithRepetition(command, initialDelay, period, unit); }
  
  public ScheduledFuture<?> scheduleDurableWithRepetition(String name, Runnable command, long initialDelay, long period, TimeUnit unit) { return getDurableTaskScheduler(name).scheduleWithRepetition(command, initialDelay, period, unit); }
  
  public TaskScheduler getGlobalTaskScheduler() { return this.globalTaskScheduler; }
  
  public TaskScheduler getTaskScheduler(String name) { return new DelegatingTaskScheduler(this.scheduledExecutorService, getExecutor(name)); }
  
  public void shutdown() {
    this.logger.finest("Stopping executors...");
    this.scheduledExecutorService.notifyShutdownInitiated();
    for (ExecutorService executorService : this.executors.values())
      executorService.shutdown(); 
    for (ExecutorService executorService : this.durableExecutors.values())
      executorService.shutdown(); 
    for (ExecutorService executorService : this.scheduleDurableExecutors.values())
      executorService.shutdown(); 
    this.scheduledExecutorService.shutdownNow();
    this.cachedExecutorService.shutdown();
    try {
      this.scheduledExecutorService.awaitTermination(3L, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      this.logger.finest(e);
    } 
    try {
      this.cachedExecutorService.awaitTermination(3L, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      this.logger.finest(e);
    } 
    this.executors.clear();
    this.durableExecutors.clear();
    this.scheduleDurableExecutors.clear();
  }
  
  public void shutdownExecutor(String name) {
    ExecutorService executorService = (ExecutorService)this.executors.remove(name);
    if (executorService != null)
      executorService.shutdown(); 
  }
  
  public void shutdownDurableExecutor(String name) {
    ExecutorService executorService = (ExecutorService)this.durableExecutors.remove(name);
    if (executorService != null)
      executorService.shutdown(); 
  }
  
  public void shutdownScheduledDurableExecutor(String name) {
    ExecutorService executorService = (ExecutorService)this.scheduleDurableExecutors.remove(name);
    if (executorService != null)
      executorService.shutdown(); 
  }
  
  private <V> ICompletableFuture<V> registerCompletableFuture(Future<V> future) {
    CompletableFutureEntry<V> entry = new CompletableFutureEntry<V>(future, this.nodeEngine);
    this.completableFutureTask.registerCompletableFutureEntry(entry);
    return entry.completableFuture;
  }
  
  private TaskScheduler getDurableTaskScheduler(String name) { return new DelegatingTaskScheduler(this.scheduledExecutorService, getScheduledDurable(name)); }
}
