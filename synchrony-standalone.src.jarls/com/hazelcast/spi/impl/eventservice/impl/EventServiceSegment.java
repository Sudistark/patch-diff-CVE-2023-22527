package com.hazelcast.spi.impl.eventservice.impl;

import com.hazelcast.internal.metrics.Probe;
import com.hazelcast.nio.Address;
import com.hazelcast.spi.EventFilter;
import com.hazelcast.spi.ListenerWrapperEventFilter;
import com.hazelcast.spi.NotifiableEventListener;
import com.hazelcast.util.ConcurrencyUtil;
import java.util.Collection;
import java.util.Iterator;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicLong;

public class EventServiceSegment<S> extends Object {
  private final String serviceName;
  
  private final S service;
  
  private final ConcurrentMap<String, Collection<Registration>> registrations;
  
  @Probe(name = "listenerCount")
  private final ConcurrentMap<String, Registration> registrationIdMap;
  
  @Probe(name = "publicationCount")
  private final AtomicLong totalPublishes;
  
  public EventServiceSegment(String serviceName, S service) {
    this.registrations = new ConcurrentHashMap();
    this.registrationIdMap = new ConcurrentHashMap();
    this.totalPublishes = new AtomicLong();
    this.serviceName = serviceName;
    this.service = service;
  }
  
  private void pingNotifiableEventListener(String topic, Registration registration, boolean register) {
    Object listener = registration.getListener();
    if (!(listener instanceof NotifiableEventListener)) {
      EventFilter filter = registration.getFilter();
      if (filter instanceof ListenerWrapperEventFilter)
        listener = ((ListenerWrapperEventFilter)filter).getListener(); 
    } 
    pingNotifiableEventListenerInternal(listener, topic, registration, register);
    pingNotifiableEventListenerInternal(this.service, topic, registration, register);
  }
  
  private void pingNotifiableEventListenerInternal(Object object, String topic, Registration registration, boolean register) {
    if (!(object instanceof NotifiableEventListener))
      return; 
    NotifiableEventListener listener = (NotifiableEventListener)object;
    if (register) {
      listener.onRegister(this.service, this.serviceName, topic, registration);
    } else {
      listener.onDeregister(this.service, this.serviceName, topic, registration);
    } 
  }
  
  public Collection<Registration> getRegistrations(String topic, boolean forceCreate) {
    Collection<Registration> listenerList = (Collection)this.registrations.get(topic);
    if (listenerList == null && forceCreate) {
      Object object = new Object(this);
      return (Collection)ConcurrencyUtil.getOrPutIfAbsent(this.registrations, topic, object);
    } 
    return listenerList;
  }
  
  public ConcurrentMap<String, Registration> getRegistrationIdMap() { return this.registrationIdMap; }
  
  public ConcurrentMap<String, Collection<Registration>> getRegistrations() { return this.registrations; }
  
  public boolean addRegistration(String topic, Registration registration) {
    Collection<Registration> registrations = getRegistrations(topic, true);
    if (registrations.add(registration)) {
      this.registrationIdMap.put(registration.getId(), registration);
      pingNotifiableEventListener(topic, registration, true);
      return true;
    } 
    return false;
  }
  
  public Registration removeRegistration(String topic, String id) {
    Registration registration = (Registration)this.registrationIdMap.remove(id);
    if (registration != null) {
      Collection<Registration> all = (Collection)this.registrations.get(topic);
      if (all != null)
        all.remove(registration); 
      pingNotifiableEventListener(topic, registration, false);
    } 
    return registration;
  }
  
  void removeRegistrations(String topic) {
    Collection<Registration> all = (Collection)this.registrations.remove(topic);
    if (all == null)
      return; 
    for (Registration reg : all) {
      this.registrationIdMap.remove(reg.getId());
      pingNotifiableEventListener(topic, reg, false);
    } 
  }
  
  void clear() {
    for (Collection<Registration> all : this.registrations.values()) {
      Iterator<Registration> iter = all.iterator();
      while (iter.hasNext()) {
        Registration reg = (Registration)iter.next();
        iter.remove();
        this.registrationIdMap.remove(reg.getId());
        pingNotifiableEventListener(reg.getTopic(), reg, false);
      } 
    } 
  }
  
  void onMemberLeft(Address address) {
    for (Collection<Registration> all : this.registrations.values()) {
      Iterator<Registration> iter = all.iterator();
      while (iter.hasNext()) {
        Registration reg = (Registration)iter.next();
        if (address.equals(reg.getSubscriber())) {
          iter.remove();
          this.registrationIdMap.remove(reg.getId());
          pingNotifiableEventListener(reg.getTopic(), reg, false);
        } 
      } 
    } 
  }
  
  long incrementPublish() { return this.totalPublishes.incrementAndGet(); }
  
  boolean hasRegistration(String topic) {
    Collection<Registration> topicRegistrations = (Collection)this.registrations.get(topic);
    return (topicRegistrations != null && !topicRegistrations.isEmpty());
  }
  
  void collectRemoteRegistrations(Collection<Registration> result) {
    for (Registration registration : this.registrationIdMap.values()) {
      if (!registration.isLocalOnly())
        result.add(registration); 
    } 
  }
}
