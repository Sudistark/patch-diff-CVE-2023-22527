package com.hazelcast.spi.impl.operationservice.impl;

import com.hazelcast.cp.CPGroupId;
import com.hazelcast.cp.CPMember;
import com.hazelcast.cp.exception.CPSubsystemException;
import com.hazelcast.cp.internal.CPGroupInfo;
import com.hazelcast.cp.internal.CPMemberInfo;
import com.hazelcast.cp.internal.RaftService;
import com.hazelcast.logging.ILogger;
import java.util.Collection;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicReference;

public class RaftInvocationContext {
  private final ILogger logger;
  
  private final RaftService raftService;
  
  private final ConcurrentMap<CPGroupId, CPMember> knownLeaders;
  
  private final boolean failOnIndeterminateOperationState;
  
  private AtomicReference<ActiveCPMembersContainer> membersContainer;
  
  public RaftInvocationContext(ILogger logger, RaftService raftService) {
    this.knownLeaders = new ConcurrentHashMap();
    this.membersContainer = new AtomicReference(null);
    this.logger = logger;
    this.raftService = raftService;
    this.failOnIndeterminateOperationState = raftService.getConfig().isFailOnIndeterminateOperationState();
  }
  
  public void reset() {
    this.membersContainer.set(null);
    this.knownLeaders.clear();
  }
  
  public void setMembers(long groupIdSeed, long membersCommitIndex, Collection<CPMemberInfo> members) {
    ActiveCPMembersVersion version = new ActiveCPMembersVersion(groupIdSeed, membersCommitIndex);
    ActiveCPMembersContainer newContainer = new ActiveCPMembersContainer(version, (CPMemberInfo[])members.toArray(new CPMemberInfo[0]));
    while (true) {
      ActiveCPMembersContainer currentContainer = (ActiveCPMembersContainer)this.membersContainer.get();
      if (currentContainer == null || newContainer.version.compareTo(currentContainer.version) > 0) {
        if (this.membersContainer.compareAndSet(currentContainer, newContainer))
          return; 
        continue;
      } 
      break;
    } 
  }
  
  CPMember getKnownLeader(CPGroupId groupId) { return (CPMember)this.knownLeaders.get(groupId); }
  
  boolean setKnownLeader(CPGroupId groupId, CPMember leader) {
    if (leader != null) {
      this.logger.fine("Setting known leader for raft: " + groupId + " to " + leader);
      this.knownLeaders.put(groupId, leader);
      return true;
    } 
    return false;
  }
  
  void updateKnownLeaderOnFailure(CPGroupId groupId, Throwable cause) {
    if (cause instanceof CPSubsystemException) {
      CPSubsystemException e = (CPSubsystemException)cause;
      CPMember leader = (CPMember)e.getLeader();
      if (!setKnownLeader(groupId, leader))
        resetKnownLeader(groupId); 
    } else {
      resetKnownLeader(groupId);
    } 
  }
  
  boolean shouldFailOnIndeterminateOperationState() { return this.failOnIndeterminateOperationState; }
  
  private void resetKnownLeader(CPGroupId groupId) {
    this.logger.fine("Resetting known leader for raft: " + groupId);
    this.knownLeaders.remove(groupId);
  }
  
  MemberCursor newMemberCursor(CPGroupId groupId) {
    CPGroupInfo group = this.raftService.getCPGroupLocally(groupId);
    if (group != null)
      return new MemberCursor(group.membersArray()); 
    ActiveCPMembersContainer container = (ActiveCPMembersContainer)this.membersContainer.get();
    CPMemberInfo[] arrayOfCPMemberInfo = (container != null) ? container.members : new CPMember[0];
    return new MemberCursor(arrayOfCPMemberInfo);
  }
}
