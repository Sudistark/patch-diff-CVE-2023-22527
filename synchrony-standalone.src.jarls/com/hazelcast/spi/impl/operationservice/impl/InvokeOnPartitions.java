package com.hazelcast.spi.impl.operationservice.impl;

import com.hazelcast.core.ICompletableFuture;
import com.hazelcast.internal.util.SimpleCompletableFuture;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.OperationFactory;
import com.hazelcast.spi.impl.operationservice.impl.operations.PartitionAwareFactoryAccessor;
import com.hazelcast.spi.impl.operationservice.impl.operations.PartitionAwareOperationFactory;
import com.hazelcast.spi.impl.operationservice.impl.operations.PartitionIteratingOperation;
import com.hazelcast.util.CollectionUtil;
import com.hazelcast.util.MapUtil;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReferenceArray;

final class InvokeOnPartitions {
  private static final int TRY_COUNT = 10;
  
  private static final int TRY_PAUSE_MILLIS = 300;
  
  private static final Object NULL_RESULT = new Object();
  
  private final OperationServiceImpl operationService;
  
  private final String serviceName;
  
  private final OperationFactory operationFactory;
  
  private final Map<Address, List<Integer>> memberPartitions;
  
  private final ILogger logger;
  
  private final AtomicReferenceArray<Object> partitionResults;
  
  private final AtomicInteger latch;
  
  private final SimpleCompletableFuture future;
  
  private boolean invoked;
  
  InvokeOnPartitions(OperationServiceImpl operationService, String serviceName, OperationFactory operationFactory, Map<Address, List<Integer>> memberPartitions) {
    this.operationService = operationService;
    this.serviceName = serviceName;
    this.operationFactory = operationFactory;
    this.memberPartitions = memberPartitions;
    this.logger = operationService.node.loggingService.getLogger(getClass());
    int partitionCount = operationService.nodeEngine.getPartitionService().getPartitionCount();
    int actualPartitionCount = 0;
    for (List<Integer> mp : memberPartitions.values())
      actualPartitionCount += mp.size(); 
    this.partitionResults = new AtomicReferenceArray(partitionCount);
    this.latch = new AtomicInteger(actualPartitionCount);
    this.future = new SimpleCompletableFuture(operationService.nodeEngine);
  }
  
  <T> Map<Integer, T> invoke() throws Exception { return (Map)invokeAsync().get(); }
  
  <T> ICompletableFuture<Map<Integer, T>> invokeAsync() {
    assert !this.invoked : "already invoked";
    this.invoked = true;
    ensureNotCallingFromPartitionOperationThread();
    invokeOnAllPartitions();
    return this.future;
  }
  
  private void ensureNotCallingFromPartitionOperationThread() {
    if (Thread.currentThread() instanceof com.hazelcast.spi.impl.operationexecutor.impl.PartitionOperationThread)
      throw new IllegalThreadStateException(Thread.currentThread() + " cannot make invocation on multiple partitions!"); 
  }
  
  private void invokeOnAllPartitions() {
    if (this.memberPartitions.isEmpty()) {
      this.future.setResult(Collections.EMPTY_MAP);
      return;
    } 
    for (Map.Entry<Address, List<Integer>> mp : this.memberPartitions.entrySet()) {
      Address address = (Address)mp.getKey();
      List<Integer> partitions = (List)mp.getValue();
      PartitionIteratingOperation op = new PartitionIteratingOperation(this.operationFactory, CollectionUtil.toIntArray(partitions));
      this.operationService.createInvocationBuilder(this.serviceName, op, address)
        .setTryCount(10)
        .setTryPauseMillis(300L)
        .invoke()
        .andThen(new FirstAttemptExecutionCallback(this, partitions));
    } 
  }
  
  private void retryPartition(int partitionId) {
    Operation operation;
    PartitionAwareOperationFactory partitionAwareFactory = PartitionAwareFactoryAccessor.extractPartitionAware(this.operationFactory);
    if (partitionAwareFactory != null) {
      operation = partitionAwareFactory.createPartitionOperation(partitionId);
    } else {
      operation = this.operationFactory.createOperation();
    } 
    this.operationService.createInvocationBuilder(this.serviceName, operation, partitionId)
      .invoke()
      .andThen(new Object(this, partitionId));
  }
  
  private void decrementLatchAndHandle(int count) {
    if (this.latch.addAndGet(-count) > 0)
      return; 
    Map<Integer, Object> result = MapUtil.createHashMap(this.partitionResults.length());
    for (int partitionId = 0; partitionId < this.partitionResults.length(); partitionId++) {
      Object partitionResult = this.partitionResults.get(partitionId);
      if (partitionResult instanceof Throwable) {
        this.future.setResult(partitionResult);
        return;
      } 
      if (partitionResult != null)
        result.put(Integer.valueOf(partitionId), (partitionResult == NULL_RESULT) ? null : partitionResult); 
    } 
    this.future.setResult(result);
  }
  
  private void setPartitionResult(int partition, Object result) {
    if (result == null)
      result = NULL_RESULT; 
    boolean success = this.partitionResults.compareAndSet(partition, null, result);
    assert success : "two results for same partition: old=" + this.partitionResults.get(partition) + ", new=" + result;
  }
}
