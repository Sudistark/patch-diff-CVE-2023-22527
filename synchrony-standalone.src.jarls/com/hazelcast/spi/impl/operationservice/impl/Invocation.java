package com.hazelcast.spi.impl.operationservice.impl;

import com.hazelcast.core.HazelcastInstanceNotActiveException;
import com.hazelcast.core.IndeterminateOperationStateException;
import com.hazelcast.core.Member;
import com.hazelcast.core.MemberLeftException;
import com.hazelcast.instance.NodeState;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.Connection;
import com.hazelcast.nio.EndpointManager;
import com.hazelcast.spi.ExceptionAction;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.OperationAccessor;
import com.hazelcast.spi.OperationResponseHandler;
import com.hazelcast.spi.exception.ResponseAlreadySentException;
import com.hazelcast.spi.exception.RetryableIOException;
import com.hazelcast.spi.exception.TargetNotMemberException;
import com.hazelcast.spi.exception.WrongTargetException;
import com.hazelcast.spi.impl.operationservice.TargetAware;
import com.hazelcast.spi.impl.operationservice.impl.responses.ErrorResponse;
import com.hazelcast.spi.impl.operationservice.impl.responses.NormalResponse;
import com.hazelcast.spi.impl.operationutil.Operations;
import com.hazelcast.util.Clock;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.StringUtil;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import java.util.logging.Level;

public abstract class Invocation<T> extends Object implements OperationResponseHandler {
  private static final AtomicReferenceFieldUpdater<Invocation, Boolean> RESPONSE_RECEIVED = AtomicReferenceFieldUpdater.newUpdater(Invocation.class, Boolean.class, "responseReceived");
  
  private static final AtomicIntegerFieldUpdater<Invocation> BACKUP_ACKS_RECEIVED = AtomicIntegerFieldUpdater.newUpdater(Invocation.class, "backupsAcksReceived");
  
  private static final long MIN_TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10L);
  
  private static final int MAX_FAST_INVOCATION_COUNT = 5;
  
  private static final int LOG_MAX_INVOCATION_COUNT = 99;
  
  private static final int LOG_INVOCATION_COUNT_MOD = 10;
  
  public final Operation op;
  
  public final long firstInvocationTimeMillis;
  
  final Context context;
  
  final InvocationFuture future;
  
  final long callTimeoutMillis;
  
  private Address targetAddress;
  
  private Member targetMember;
  
  private Connection connection;
  
  private int memberListVersion;
  
  private final EndpointManager endpointManager;
  
  private final int tryCount;
  
  private final long tryPauseMillis;
  
  private final Runnable taskDoneCallback;
  
  Invocation(Context context, Operation op, Runnable taskDoneCallback, int tryCount, long tryPauseMillis, long callTimeoutMillis, boolean deserialize, EndpointManager endpointManager) {
    this
      .firstInvocationTimeMillis = Clock.currentTimeMillis();
    this.pendingResponse = InvocationConstant.VOID;
    this.pendingResponseReceivedMillis = -1L;
    this.responseReceived = Boolean.FALSE;
    this.context = context;
    this.op = op;
    this.taskDoneCallback = taskDoneCallback;
    this.tryCount = tryCount;
    this.tryPauseMillis = tryPauseMillis;
    this.callTimeoutMillis = getCallTimeoutMillis(callTimeoutMillis);
    this.future = new InvocationFuture(this, deserialize);
    this.endpointManager = getEndpointManager(endpointManager);
  }
  
  public void sendResponse(Operation op, Object response) {
    if (!RESPONSE_RECEIVED.compareAndSet(this, Boolean.FALSE, Boolean.TRUE))
      throw new ResponseAlreadySentException("NormalResponse already responseReceived for callback: " + this + ", current-response: " + response); 
    if (response instanceof com.hazelcast.spi.impl.operationservice.impl.responses.CallTimeoutResponse) {
      notifyCallTimeout();
    } else if (response instanceof ErrorResponse || response instanceof Throwable) {
      notifyError(response);
    } else if (response instanceof NormalResponse) {
      NormalResponse normalResponse = (NormalResponse)response;
      notifyNormalResponse(normalResponse.getValue(), normalResponse.getBackupAcks());
    } else {
      complete(response);
    } 
  }
  
  public final InvocationFuture invoke() {
    invoke0(false);
    return this.future;
  }
  
  public final InvocationFuture invokeAsync() {
    invoke0(true);
    return this.future;
  }
  
  protected boolean shouldFailOnIndeterminateOperationState() { return false; }
  
  boolean isActive() { return OperationAccessor.hasActiveInvocation(this.op); }
  
  boolean isRetryCandidate() { return (this.op.getCallId() != 0L); }
  
  final void initInvocationTarget() throws Exception {
    Member previousTargetMember = this.targetMember;
    T target = (T)getInvocationTarget();
    if (target == null)
      throw newTargetNullException(); 
    this.targetMember = toTargetMember(target);
    if (this.targetMember != null) {
      this.targetAddress = this.targetMember.getAddress();
    } else {
      this.targetAddress = toTargetAddress(target);
    } 
    this.memberListVersion = this.context.clusterService.getMemberListVersion();
    if (this.targetMember == null) {
      if (previousTargetMember != null)
        throw new MemberLeftException(previousTargetMember); 
      if (!Operations.isJoinOperation(this.op) && !Operations.isWanReplicationOperation(this.op))
        throw new TargetNotMemberException(target, this.op.getPartitionId(), this.op.getClass().getName(), this.op.getServiceName()); 
    } 
    if (this.op instanceof TargetAware)
      ((TargetAware)this.op).setTarget(this.targetAddress); 
  }
  
  Exception newTargetNullException() {
    return new WrongTargetException(this.context.clusterService.getLocalMember(), null, this.op.getPartitionId(), this.op
        .getReplicaIndex(), this.op.getClass().getName(), this.op.getServiceName());
  }
  
  void notifyError(Object error) {
    assert error != null;
    Throwable cause = (error instanceof Throwable) ? (Throwable)error : ((ErrorResponse)error).getCause();
    switch (null.$SwitchMap$com$hazelcast$spi$ExceptionAction[onException(cause).ordinal()]) {
      case 1:
        notifyNormalResponse(cause, 0);
        return;
      case 2:
        if (this.invokeCount < this.tryCount) {
          handleRetry(cause);
        } else {
          notifyNormalResponse(cause, 0);
        } 
        return;
    } 
    throw new IllegalStateException("Unhandled ExceptionAction");
  }
  
  void notifyNormalResponse(Object value, int expectedBackups) {
    if (expectedBackups > this.backupsAcksReceived) {
      this.pendingResponseReceivedMillis = Clock.currentTimeMillis();
      this.backupsAcksExpected = expectedBackups;
      this.pendingResponse = value;
      if (this.backupsAcksReceived != expectedBackups)
        return; 
    } 
    complete(value);
  }
  
  @SuppressFBWarnings(value = {"VO_VOLATILE_INCREMENT"}, justification = "We have the guarantee that only a single thread at any given time can change the volatile field")
  void notifyCallTimeout() throws Exception {
    long newWaitTimeout;
    if (!(this.op instanceof com.hazelcast.spi.BlockingOperation)) {
      complete(InvocationConstant.CALL_TIMEOUT);
      return;
    } 
    if (this.context.logger.isFinestEnabled())
      this.context.logger.finest("Call timed-out either in operation queue or during wait-notify phase, retrying call: " + this); 
    long oldWaitTimeout = this.op.getWaitTimeout();
    if (oldWaitTimeout < 0L) {
      newWaitTimeout = oldWaitTimeout;
    } else {
      long elapsedTime = Math.max(0L, this.context.clusterClock.getClusterTime() - this.op.getInvocationTime());
      newWaitTimeout = Math.max(0L, oldWaitTimeout - elapsedTime);
    } 
    this.op.setWaitTimeout(newWaitTimeout);
    this.invokeCount--;
    handleRetry("invocation timeout");
  }
  
  void notifyBackupComplete() throws Exception {
    int newBackupAcksCompleted = BACKUP_ACKS_RECEIVED.incrementAndGet(this);
    Object pendingResponse = this.pendingResponse;
    if (pendingResponse == InvocationConstant.VOID)
      return; 
    int backupAcksExpected = this.backupsAcksExpected;
    if (backupAcksExpected < newBackupAcksCompleted)
      return; 
    if (backupAcksExpected != newBackupAcksCompleted)
      return; 
    complete(pendingResponse);
  }
  
  boolean detectAndHandleTimeout(long heartbeatTimeoutMillis) {
    if (skipTimeoutDetection())
      return false; 
    HeartbeatTimeout heartbeatTimeout = detectTimeout(heartbeatTimeoutMillis);
    if (heartbeatTimeout == HeartbeatTimeout.TIMEOUT) {
      complete(InvocationConstant.HEARTBEAT_TIMEOUT);
      return true;
    } 
    return false;
  }
  
  boolean skipTimeoutDetection() { return (isLocal() && !(this.op instanceof com.hazelcast.spi.BackupAwareOperation)); }
  
  HeartbeatTimeout detectTimeout(long heartbeatTimeoutMillis) {
    if (this.pendingResponse != InvocationConstant.VOID)
      return HeartbeatTimeout.NO_TIMEOUT__RESPONSE_AVAILABLE; 
    long callTimeoutMillis = this.op.getCallTimeout();
    if (callTimeoutMillis <= 0L || callTimeoutMillis == Float.MAX_VALUE)
      return HeartbeatTimeout.NO_TIMEOUT__CALL_TIMEOUT_DISABLED; 
    long deadlineMillis = this.op.getInvocationTime() + callTimeoutMillis;
    if (deadlineMillis > this.context.clusterClock.getClusterTime())
      return HeartbeatTimeout.NO_TIMEOUT__CALL_TIMEOUT_NOT_EXPIRED; 
    long lastHeartbeatMillis = this.lastHeartbeatMillis;
    long heartbeatExpirationTimeMillis = (lastHeartbeatMillis == 0L) ? (this.op.getInvocationTime() + callTimeoutMillis + heartbeatTimeoutMillis) : (lastHeartbeatMillis + heartbeatTimeoutMillis);
    if (heartbeatExpirationTimeMillis > Clock.currentTimeMillis())
      return HeartbeatTimeout.NO_TIMEOUT__HEARTBEAT_TIMEOUT_NOT_EXPIRED; 
    return HeartbeatTimeout.TIMEOUT;
  }
  
  boolean detectAndHandleBackupTimeout(long timeoutMillis) {
    boolean backupsCompleted = (this.backupsAcksExpected == this.backupsAcksReceived);
    long responseReceivedMillis = this.pendingResponseReceivedMillis;
    long expirationTime = responseReceivedMillis + timeoutMillis;
    boolean timeout = (expirationTime > 0L && expirationTime < Clock.currentTimeMillis());
    boolean responseReceived = (this.pendingResponse != InvocationConstant.VOID);
    if (backupsCompleted || !responseReceived || !timeout)
      return false; 
    if (shouldFailOnIndeterminateOperationState()) {
      complete(new IndeterminateOperationStateException(this + " failed because backup acks missed."));
      return true;
    } 
    boolean targetDead = (this.context.clusterService.getMember(this.targetAddress) == null);
    if (targetDead) {
      resetAndReInvoke();
      return false;
    } 
    complete(this.pendingResponse);
    return true;
  }
  
  private boolean engineActive() {
    NodeState state = this.context.node.getState();
    if (state == NodeState.ACTIVE)
      return true; 
    boolean allowed = (state == NodeState.PASSIVE && this.op instanceof com.hazelcast.spi.impl.AllowedDuringPassiveState);
    if (!allowed)
      notifyError(new HazelcastInstanceNotActiveException("State: " + state + " Operation: " + this.op.getClass())); 
    return allowed;
  }
  
  private void invoke0(boolean isAsync) {
    if (this.invokeCount > 0)
      throw new IllegalStateException("This invocation is already in progress"); 
    if (isActive())
      throw new IllegalStateException("Attempt to reuse the same operation in multiple invocations. Operation is " + this.op); 
    try {
      OperationAccessor.setCallTimeout(this.op, this.callTimeoutMillis);
      OperationAccessor.setCallerAddress(this.op, this.context.thisAddress);
      this.op.setNodeEngine(this.context.nodeEngine);
      boolean isAllowed = this.context.operationExecutor.isInvocationAllowed(this.op, isAsync);
      if (!isAllowed && !Operations.isMigrationOperation(this.op))
        throw new IllegalThreadStateException(Thread.currentThread() + " cannot make remote call: " + this.op); 
      doInvoke(isAsync);
    } catch (Exception e) {
      handleInvocationException(e);
    } 
  }
  
  @SuppressFBWarnings(value = {"VO_VOLATILE_INCREMENT"}, justification = "We have the guarantee that only a single thread at any given time can change the volatile field")
  private void doInvoke(boolean isAsync) {
    if (!engineActive())
      return; 
    this.invokeCount++;
    OperationAccessor.setInvocationTime(this.op, this.context.clusterClock.getClusterTime());
    Exception initializationFailure = null;
    try {
      initInvocationTarget();
    } catch (Exception e) {
      initializationFailure = e;
    } 
    if (!this.context.invocationRegistry.register(this))
      return; 
    if (initializationFailure != null) {
      notifyError(initializationFailure);
      return;
    } 
    if (isLocal()) {
      doInvokeLocal(isAsync);
    } else {
      doInvokeRemote();
    } 
  }
  
  private boolean isLocal() { return this.context.thisAddress.equals(this.targetAddress); }
  
  private void doInvokeLocal(boolean isAsync) {
    if (this.op.getCallerUuid() == null)
      this.op.setCallerUuid(this.context.node.getThisUuid()); 
    this.responseReceived = Boolean.FALSE;
    this.op.setOperationResponseHandler(this);
    if (isAsync) {
      this.context.operationExecutor.execute(this.op);
    } else {
      this.context.operationExecutor.runOrExecute(this.op);
    } 
  }
  
  private void doInvokeRemote() throws Exception {
    assert this.endpointManager != null : "Endpoint manager was null";
    Connection connection = this.endpointManager.getOrConnect(this.targetAddress);
    this.connection = connection;
    if (!this.context.outboundOperationHandler.send(this.op, connection))
      notifyError(new RetryableIOException("Packet not sent to -> " + this.targetAddress + " over " + connection)); 
  }
  
  private EndpointManager getEndpointManager(EndpointManager endpointManager) { return (endpointManager != null) ? endpointManager : this.context.defaultEndpointManager; }
  
  private long getCallTimeoutMillis(long callTimeoutMillis) {
    if (callTimeoutMillis > 0L)
      return callTimeoutMillis; 
    long defaultCallTimeoutMillis = this.context.defaultCallTimeoutMillis;
    if (!(this.op instanceof com.hazelcast.spi.BlockingOperation))
      return defaultCallTimeoutMillis; 
    long waitTimeoutMillis = this.op.getWaitTimeout();
    if (waitTimeoutMillis > 0L && waitTimeoutMillis < Float.MAX_VALUE) {
      long max = Math.max(waitTimeoutMillis, MIN_TIMEOUT_MILLIS);
      return Math.min(max, defaultCallTimeoutMillis);
    } 
    return defaultCallTimeoutMillis;
  }
  
  private void handleInvocationException(Exception e) {
    if (e instanceof com.hazelcast.spi.exception.RetryableException) {
      notifyError(e);
    } else {
      throw ExceptionUtil.rethrow(e);
    } 
  }
  
  private void complete(Object value) {
    this.future.complete(value);
    if (this.context.invocationRegistry.deregister(this) && this.taskDoneCallback != null)
      this.context.asyncExecutor.execute(this.taskDoneCallback); 
  }
  
  private void handleRetry(Object cause) {
    this.context.retryCount.inc();
    if (this.invokeCount % 10 == 0) {
      Level level = (this.invokeCount > 99) ? Level.WARNING : Level.FINEST;
      if (this.context.logger.isLoggable(level))
        this.context.logger.log(level, "Retrying invocation: " + toString() + ", Reason: " + cause); 
    } 
    if (this.future.interrupted) {
      complete(InvocationConstant.INTERRUPTED);
    } else {
      try {
        InvocationRetryTask retryTask = new InvocationRetryTask(this, null);
        if (this.invokeCount < 5) {
          this.context.invocationMonitor.execute(retryTask);
        } else {
          long delayMillis = Math.min((1 << this.invokeCount - 5), this.tryPauseMillis);
          this.context.invocationMonitor.schedule(retryTask, delayMillis);
        } 
      } catch (RejectedExecutionException e) {
        completeWhenRetryRejected(e);
      } 
    } 
  }
  
  private void completeWhenRetryRejected(RejectedExecutionException e) {
    if (this.context.logger.isFinestEnabled())
      this.context.logger.finest(e); 
    complete(new HazelcastInstanceNotActiveException(e.getMessage()));
  }
  
  private void resetAndReInvoke() throws Exception {
    if (!this.context.invocationRegistry.deregister(this))
      return; 
    this.invokeCount = 0;
    this.pendingResponse = InvocationConstant.VOID;
    this.pendingResponseReceivedMillis = -1L;
    this.backupsAcksExpected = 0;
    this.backupsAcksReceived = 0;
    this.lastHeartbeatMillis = 0L;
    doInvoke(false);
  }
  
  Address getTargetAddress() { return this.targetAddress; }
  
  Member getTargetMember() { return this.targetMember; }
  
  int getMemberListVersion() { return this.memberListVersion; }
  
  public String toString() {
    return "Invocation{op=" + this.op + ", tryCount=" + this.tryCount + ", tryPauseMillis=" + this.tryPauseMillis + ", invokeCount=" + this.invokeCount + ", callTimeoutMillis=" + this.callTimeoutMillis + ", firstInvocationTimeMs=" + this.firstInvocationTimeMillis + ", firstInvocationTime='" + 





      
      StringUtil.timeToString(this.firstInvocationTimeMillis) + '\'' + ", lastHeartbeatMillis=" + this.lastHeartbeatMillis + ", lastHeartbeatTime='" + 
      
      StringUtil.timeToString(this.lastHeartbeatMillis) + '\'' + ", target=" + this.targetAddress + ", pendingResponse={" + this.pendingResponse + '}' + ", backupsAcksExpected=" + this.backupsAcksExpected + ", backupsAcksReceived=" + this.backupsAcksReceived + ", connection=" + this.connection + '}';
  }
  
  abstract ExceptionAction onException(Throwable paramThrowable);
  
  abstract T getInvocationTarget();
  
  abstract Address toTargetAddress(T paramT);
  
  abstract Member toTargetMember(T paramT);
}
