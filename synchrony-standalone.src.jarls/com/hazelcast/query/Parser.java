package com.hazelcast.query;

import com.hazelcast.util.MapUtil;
import com.hazelcast.util.StringUtil;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;

class Parser {
  private static final String SPLIT_EXPRESSION = " ";
  
  private static final int PARENTHESIS_PRECEDENCE = 15;
  
  private static final int NOT_PRECEDENCE = 8;
  
  private static final int EQUAL_PRECEDENCE = 10;
  
  private static final int GREATER_PRECEDENCE = 10;
  
  private static final int LESS_PRECEDENCE = 10;
  
  private static final int GREATER_EQUAL_PRECEDENCE = 10;
  
  private static final int LESS_EQUAL_PRECEDENCE = 10;
  
  private static final int ASSIGN_PRECEDENCE = 10;
  
  private static final int NOT_EQUAL_PRECEDENCE = 10;
  
  private static final int BETWEEN_PRECEDENCE = 10;
  
  private static final int IN_PRECEDENCE = 10;
  
  private static final int LIKE_PRECEDENCE = 10;
  
  private static final int ILIKE_PRECEDENCE = 10;
  
  private static final int REGEX_PRECEDENCE = 10;
  
  private static final int AND_PRECEDENCE = 5;
  
  private static final int OR_PRECEDENCE = 3;
  
  private static final Map<String, Integer> PRECEDENCE;
  
  private static final List<String> CHAR_OPERATORS;
  
  private static final int NO_INDEX = -1;
  
  private static final String IN_LOWER = " in ";
  
  private static final String IN_LOWER_P = " in(";
  
  private static final String IN_UPPER = " IN ";
  
  private static final String IN_UPPER_P = " IN(";
  
  static  {
    precedence = MapUtil.createHashMap(18);
    precedence.put("(", Integer.valueOf(15));
    precedence.put(")", Integer.valueOf(15));
    precedence.put("not", Integer.valueOf(8));
    precedence.put("=", Integer.valueOf(10));
    precedence.put(">", Integer.valueOf(10));
    precedence.put("<", Integer.valueOf(10));
    precedence.put(">=", Integer.valueOf(10));
    precedence.put("<=", Integer.valueOf(10));
    precedence.put("==", Integer.valueOf(10));
    precedence.put("!=", Integer.valueOf(10));
    precedence.put("<>", Integer.valueOf(10));
    precedence.put("between", Integer.valueOf(10));
    precedence.put("in", Integer.valueOf(10));
    precedence.put("like", Integer.valueOf(10));
    precedence.put("ilike", Integer.valueOf(10));
    precedence.put("regex", Integer.valueOf(10));
    precedence.put("and", Integer.valueOf(5));
    precedence.put("or", Integer.valueOf(3));
    PRECEDENCE = Collections.unmodifiableMap(precedence);
    CHAR_OPERATORS = Arrays.asList(new String[] { "(", ")", " + ", " - ", "=", "<", ">", " * ", " / ", "!" });
  }
  
  public List<String> toPrefix(String in) {
    List<String> tokens = buildTokens(alignINClause(in));
    List<String> output = new ArrayList<String>();
    List<String> stack = new ArrayList<String>();
    for (String token : tokens) {
      if (isOperand(token)) {
        if (token.equals(")")) {
          while (openParanthesesFound(stack))
            output.add(stack.remove(stack.size() - 1)); 
          if (stack.size() > 0)
            stack.remove(stack.size() - 1); 
          continue;
        } 
        while (openParanthesesFound(stack) && !hasHigherPrecedence(token, (String)stack.get(stack.size() - 1)))
          output.add(stack.remove(stack.size() - 1)); 
        stack.add(token);
        continue;
      } 
      output.add(token);
    } 
    while (stack.size() > 0)
      output.add(stack.remove(stack.size() - 1)); 
    return output;
  }
  
  private List<String> buildTokens(String in) {
    List<String> tokens = split(in);
    if (tokens.contains("between") || tokens.contains("BETWEEN")) {
      boolean found = true;
      boolean dirty = false;
      label26: while (found) {
        for (int i = 0; i < tokens.size(); i++) {
          if ("between".equalsIgnoreCase((String)tokens.get(i))) {
            tokens.set(i, "betweenAnd");
            tokens.remove(i + 2);
            dirty = true;
            continue label26;
          } 
        } 
        found = false;
      } 
      if (dirty)
        for (int i = 0; i < tokens.size(); i++) {
          if ("betweenAnd".equals(tokens.get(i)))
            tokens.set(i, "between"); 
        }  
    } 
    return tokens;
  }
  
  public List<String> split(String in) {
    StringBuilder result = new StringBuilder();
    char[] chars = in.toCharArray();
    for (int i = 0; i < chars.length; i++) {
      char c = chars[i];
      if (CHAR_OPERATORS.contains(String.valueOf(c))) {
        if (i < chars.length - 2 && CHAR_OPERATORS.contains(String.valueOf(chars[i + 1])) && 
          !"(".equals(String.valueOf(chars[i + 1])) && !")".equals(String.valueOf(chars[i + 1]))) {
          result.append(" ").append(c).append(chars[i + 1]).append(" ");
          i++;
        } else {
          result.append(" ").append(c).append(" ");
        } 
      } else {
        result.append(c);
      } 
    } 
    String[] tokens = result.toString().split(" ");
    List<String> list = new ArrayList<String>();
    for (int i = 0; i < tokens.length; i++) {
      tokens[i] = tokens[i].trim();
      if (!tokens[i].equals(""))
        list.add(tokens[i]); 
    } 
    return list;
  }
  
  boolean hasHigherPrecedence(String operator1, String operator2) { return (((Integer)PRECEDENCE.get(StringUtil.lowerCaseInternal(operator1))).intValue() > ((Integer)PRECEDENCE.get(StringUtil.lowerCaseInternal(operator2))).intValue()); }
  
  boolean isOperand(String string) { return PRECEDENCE.containsKey(StringUtil.lowerCaseInternal(string)); }
  
  private boolean openParanthesesFound(List<String> stack) { return (stack.size() > 0 && !((String)stack.get(stack.size() - 1)).equals("(")); }
  
  private String alignINClause(String in) {
    String paramIn = in;
    int indexLowerIn = paramIn.indexOf(" in ");
    int indexLowerInWithParentheses = paramIn.indexOf(" in(");
    int indexUpperIn = paramIn.indexOf(" IN ");
    int indexUpperInWithParentheses = paramIn.indexOf(" IN(");
    int indexIn = findMinIfNot(indexUpperInWithParentheses, 
        findMinIfNot(indexUpperIn, 
          findMinIfNot(indexLowerIn, indexLowerInWithParentheses, -1), -1), -1);
    if (indexIn > -1 && (indexIn == indexLowerInWithParentheses || indexIn == indexUpperInWithParentheses))
      paramIn = paramIn.substring(0, indexIn + 3) + " " + paramIn.substring(indexIn + 3); 
    String sql = paramIn;
    if (indexIn != -1) {
      int indexOpen = paramIn.indexOf('(', indexIn);
      int indexClose = paramIn.indexOf(')', indexOpen);
      String sub = paramIn.substring(indexOpen, indexClose + 1);
      sub = sub.replaceAll(" ", "");
      sql = paramIn.substring(0, indexOpen) + sub + alignINClause(paramIn.substring(indexClose + 1));
    } 
    return sql;
  }
  
  private int findMinIfNot(int a, int b, int notMin) {
    if (a <= notMin)
      return b; 
    if (b <= notMin)
      return a; 
    return Math.min(a, b);
  }
}
