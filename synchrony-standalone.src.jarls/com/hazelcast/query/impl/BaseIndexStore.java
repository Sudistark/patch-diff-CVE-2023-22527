package com.hazelcast.query.impl;

import com.hazelcast.nio.serialization.Data;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public abstract class BaseIndexStore implements IndexStore {
  static final float LOAD_FACTOR = 0.75F;
  
  private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
  
  private final ReentrantReadWriteLock.ReadLock readLock = this.lock.readLock();
  
  private final ReentrantReadWriteLock.WriteLock writeLock = this.lock.writeLock();
  
  private final CopyFunctor<Data, QueryableEntry> resultCopyFunctor;
  
  BaseIndexStore(IndexCopyBehavior copyOn) {
    if (copyOn == IndexCopyBehavior.COPY_ON_WRITE || copyOn == IndexCopyBehavior.NEVER) {
      this.resultCopyFunctor = new PassThroughFunctor(null);
    } else {
      this.resultCopyFunctor = new CopyInputFunctor(null);
    } 
  }
  
  abstract Comparable canonicalizeScalarForStorage(Comparable paramComparable);
  
  void takeWriteLock() { this.writeLock.lock(); }
  
  void releaseWriteLock() { this.writeLock.unlock(); }
  
  void takeReadLock() { this.readLock.lock(); }
  
  void releaseReadLock() { this.readLock.unlock(); }
  
  final void copyToMultiResultSet(MultiResultSet resultSet, Map<Data, QueryableEntry> records) { resultSet.addResultSet(this.resultCopyFunctor.invoke(records)); }
  
  final Set<QueryableEntry> toSingleResultSet(Map<Data, QueryableEntry> records) { return new SingleResultSet(this.resultCopyFunctor.invoke(records)); }
  
  public void destroy() {}
  
  Comparable sanitizeValue(Object input) {
    if (input instanceof CompositeValue) {
      CompositeValue compositeValue = (CompositeValue)input;
      Comparable[] components = compositeValue.getComponents();
      for (int i = 0; i < components.length; i++)
        components[i] = sanitizeScalar(components[i]); 
      return compositeValue;
    } 
    return sanitizeScalar(input);
  }
  
  private Comparable sanitizeScalar(Object input) {
    if (input == null || input instanceof Comparable) {
      Comparable comparable = (Comparable)input;
      if (comparable == null) {
        comparable = AbstractIndex.NULL;
      } else if (comparable.getClass().isEnum()) {
        comparable = TypeConverters.ENUM_CONVERTER.convert(comparable);
      } 
      return canonicalizeScalarForStorage(comparable);
    } 
    throw new IllegalArgumentException("It is not allowed to use a type that is not Comparable: " + input.getClass());
  }
}
