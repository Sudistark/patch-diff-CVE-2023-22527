package com.hazelcast.query.impl.predicates;

import com.hazelcast.core.TypeConverter;
import com.hazelcast.query.Predicate;
import com.hazelcast.query.impl.Indexes;
import com.hazelcast.query.impl.InternalIndex;
import com.hazelcast.query.impl.QueryContext;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class EvaluateVisitor extends AbstractVisitor {
  private static final Predicate[] EMPTY_PREDICATES = new Predicate[0];
  
  public Predicate visit(AndPredicate andPredicate, Indexes indexes) {
    Predicate[] predicates = andPredicate.predicates;
    Map<String, List<EvaluatePredicate>> evaluable = null;
    boolean requiresGeneration = false;
    for (Predicate subPredicate : predicates) {
      if (subPredicate instanceof EvaluatePredicate) {
        EvaluatePredicate evaluatePredicate = (EvaluatePredicate)subPredicate;
        String indexName = evaluatePredicate.getIndexName();
        InternalIndex internalIndex = indexes.matchIndex(indexName, andPredicate.getClass(), QueryContext.IndexMatchHint.EXACT_NAME, -1);
        if (internalIndex != null) {
          if (evaluable == null)
            evaluable = new HashMap<String, List<EvaluatePredicate>>(predicates.length); 
          List<EvaluatePredicate> group = (List)evaluable.get(indexName);
          if (group == null) {
            group = new ArrayList<EvaluatePredicate>(predicates.length);
            evaluable.put(indexName, group);
          } else {
            requiresGeneration = true;
          } 
          group.add(evaluatePredicate);
        } 
      } 
    } 
    if (!requiresGeneration)
      return andPredicate; 
    List<Predicate> output = new ArrayList<Predicate>();
    for (Predicate subPredicate : predicates) {
      if (!(subPredicate instanceof EvaluatePredicate)) {
        output.add(subPredicate);
      } else {
        EvaluatePredicate evaluatePredicate = (EvaluatePredicate)subPredicate;
        String indexName = evaluatePredicate.getIndexName();
        InternalIndex internalIndex = indexes.matchIndex(indexName, andPredicate.getClass(), QueryContext.IndexMatchHint.EXACT_NAME, -1);
        if (internalIndex == null)
          output.add(subPredicate); 
      } 
    } 
    for (Map.Entry<String, List<EvaluatePredicate>> groupEntry : evaluable.entrySet()) {
      String indexName = (String)groupEntry.getKey();
      List<EvaluatePredicate> group = (List)groupEntry.getValue();
      if (group.size() == 1) {
        output.add(group.get(0));
        continue;
      } 
      Predicate[] groupPredicates = new Predicate[group.size()];
      for (int i = 0; i < groupPredicates.length; i++)
        groupPredicates[i] = ((EvaluatePredicate)group.get(i)).getPredicate(); 
      output.add(new EvaluatePredicate(new AndPredicate(groupPredicates), indexName));
    } 
    return (output.size() == 1) ? (Predicate)output.get(0) : new AndPredicate((Predicate[])output.toArray(EMPTY_PREDICATES));
  }
  
  public Predicate visit(OrPredicate orPredicate, Indexes indexes) {
    Predicate[] predicates = orPredicate.predicates;
    Map<String, List<EvaluatePredicate>> evaluable = null;
    boolean requiresGeneration = false;
    for (Predicate subPredicate : predicates) {
      if (subPredicate instanceof EvaluatePredicate) {
        EvaluatePredicate evaluatePredicate = (EvaluatePredicate)subPredicate;
        String indexName = evaluatePredicate.getIndexName();
        InternalIndex internalIndex = indexes.matchIndex(indexName, orPredicate.getClass(), QueryContext.IndexMatchHint.EXACT_NAME, -1);
        if (internalIndex != null) {
          if (evaluable == null)
            evaluable = new HashMap<String, List<EvaluatePredicate>>(predicates.length); 
          List<EvaluatePredicate> group = (List)evaluable.get(indexName);
          if (group == null) {
            group = new ArrayList<EvaluatePredicate>(predicates.length);
            evaluable.put(indexName, group);
          } else {
            requiresGeneration = true;
          } 
          group.add(evaluatePredicate);
        } 
      } 
    } 
    if (!requiresGeneration)
      return orPredicate; 
    List<Predicate> output = new ArrayList<Predicate>();
    for (Predicate subPredicate : predicates) {
      if (!(subPredicate instanceof EvaluatePredicate)) {
        output.add(subPredicate);
      } else {
        EvaluatePredicate evaluatePredicate = (EvaluatePredicate)subPredicate;
        String indexName = evaluatePredicate.getIndexName();
        InternalIndex internalIndex = indexes.matchIndex(indexName, orPredicate.getClass(), QueryContext.IndexMatchHint.EXACT_NAME, -1);
        if (internalIndex == null)
          output.add(subPredicate); 
      } 
    } 
    for (Map.Entry<String, List<EvaluatePredicate>> groupEntry : evaluable.entrySet()) {
      String indexName = (String)groupEntry.getKey();
      List<EvaluatePredicate> group = (List)groupEntry.getValue();
      if (group.size() == 1) {
        output.add(group.get(0));
        continue;
      } 
      Predicate[] groupPredicates = new Predicate[group.size()];
      for (int i = 0; i < groupPredicates.length; i++)
        groupPredicates[i] = ((EvaluatePredicate)group.get(i)).getPredicate(); 
      output.add(new EvaluatePredicate(new OrPredicate(groupPredicates), indexName));
    } 
    return (output.size() == 1) ? (Predicate)output.get(0) : new OrPredicate((Predicate[])output.toArray(EMPTY_PREDICATES));
  }
  
  public Predicate visit(NotPredicate notPredicate, Indexes indexes) {
    Predicate subPredicate = notPredicate.getPredicate();
    if (!(subPredicate instanceof EvaluatePredicate))
      return notPredicate; 
    EvaluatePredicate evaluatePredicate = (EvaluatePredicate)subPredicate;
    String indexName = evaluatePredicate.getIndexName();
    InternalIndex internalIndex = indexes.matchIndex(indexName, notPredicate.getClass(), QueryContext.IndexMatchHint.EXACT_NAME, -1);
    if (internalIndex == null)
      return notPredicate; 
    return new EvaluatePredicate(new NotPredicate(evaluatePredicate.getPredicate()), indexName);
  }
  
  public Predicate visit(EqualPredicate predicate, Indexes indexes) {
    InternalIndex internalIndex = indexes.matchIndex(predicate.attributeName, predicate.getClass(), QueryContext.IndexMatchHint.PREFER_UNORDERED, -1);
    if (internalIndex == null)
      return predicate; 
    TypeConverter converter = internalIndex.getConverter();
    if (converter == null)
      return predicate; 
    return new EvaluatePredicate(predicate, internalIndex.getName());
  }
  
  public Predicate visit(NotEqualPredicate predicate, Indexes indexes) {
    InternalIndex internalIndex = indexes.matchIndex(predicate.attributeName, predicate.getClass(), QueryContext.IndexMatchHint.PREFER_UNORDERED, -1);
    if (internalIndex == null)
      return predicate; 
    TypeConverter converter = internalIndex.getConverter();
    if (converter == null)
      return predicate; 
    return new EvaluatePredicate(predicate, internalIndex.getName());
  }
  
  public Predicate visit(InPredicate predicate, Indexes indexes) {
    InternalIndex internalIndex = indexes.matchIndex(predicate.attributeName, predicate.getClass(), QueryContext.IndexMatchHint.PREFER_UNORDERED, -1);
    if (internalIndex == null)
      return predicate; 
    TypeConverter converter = internalIndex.getConverter();
    if (converter == null)
      return predicate; 
    return new EvaluatePredicate(predicate, internalIndex.getName());
  }
}
