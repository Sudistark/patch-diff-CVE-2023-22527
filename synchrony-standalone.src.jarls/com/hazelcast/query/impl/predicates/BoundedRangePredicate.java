package com.hazelcast.query.impl.predicates;

import com.hazelcast.query.impl.Comparables;
import com.hazelcast.query.impl.Index;
import com.hazelcast.query.impl.QueryContext;
import com.hazelcast.query.impl.QueryableEntry;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.util.Set;

public class BoundedRangePredicate extends AbstractIndexAwarePredicate implements RangePredicate {
  private final Comparable from;
  
  private final boolean fromInclusive;
  
  private final Comparable to;
  
  private final boolean toInclusive;
  
  public BoundedRangePredicate(String attribute, Comparable from, boolean fromInclusive, Comparable to, boolean toInclusive) {
    super(attribute);
    if (PredicateUtils.isNull(from) || PredicateUtils.isNull(to))
      throw new IllegalArgumentException("range must be bounded"); 
    this.from = from;
    this.fromInclusive = fromInclusive;
    this.to = to;
    this.toInclusive = toInclusive;
  }
  
  public Set<QueryableEntry> filter(QueryContext queryContext) {
    Index index = matchIndex(queryContext, QueryContext.IndexMatchHint.PREFER_ORDERED);
    if (index == null)
      return null; 
    return index.getRecords(this.from, this.fromInclusive, this.to, this.toInclusive);
  }
  
  protected boolean applyForSingleAttributeValue(Comparable value) {
    if (value == null)
      return false; 
    Comparable convertedValue = (Comparable)convertEnumValue(value);
    Comparable from = convert(value, this.from);
    int order = Comparables.compare(convertedValue, from);
    if (order < 0 || (!this.fromInclusive && order == 0))
      return false; 
    Comparable to = convert(value, this.to);
    order = Comparables.compare(convertedValue, to);
    return (order < 0 || (this.toInclusive && order == 0));
  }
  
  public int getId() { throw new UnsupportedOperationException("can't be serialized"); }
  
  public String getAttribute() { return this.attributeName; }
  
  public Comparable getFrom() { return this.from; }
  
  public boolean isFromInclusive() { return this.fromInclusive; }
  
  public Comparable getTo() { return this.to; }
  
  public boolean isToInclusive() { return this.toInclusive; }
  
  public String toString() { return this.from + (this.fromInclusive ? " >= " : " > ") + this.attributeName + (this.toInclusive ? " <= " : " < ") + this.to; }
  
  private void writeObject(ObjectOutputStream stream) throws IOException { throw new UnsupportedOperationException("can't be serialized"); }
}
