package com.hazelcast.query.impl.predicates;

import com.hazelcast.core.TypeConverter;
import com.hazelcast.query.Predicate;
import com.hazelcast.query.impl.Comparables;
import com.hazelcast.query.impl.FalsePredicate;
import com.hazelcast.query.impl.Indexes;

public class RangeVisitor extends AbstractVisitor {
  public Predicate visit(AndPredicate predicate, Indexes indexes) {
    Predicate[] predicates = predicate.predicates;
    Ranges ranges = null;
    for (int i = 0; i < predicates.length; i++) {
      ranges = intersect(predicates, i, ranges, indexes);
      if (ranges == Ranges.UNSATISFIABLE)
        return FalsePredicate.INSTANCE; 
    } 
    return (ranges == null) ? predicate : ranges.generate(predicate);
  }
  
  public Predicate visit(BetweenPredicate predicate, Indexes indexes) {
    TypeConverter converter = indexes.getConverter(predicate.attributeName);
    if (converter == null)
      return predicate; 
    Comparable from = converter.convert(predicate.from);
    Comparable to = converter.convert(predicate.to);
    Order order = compare(from, to);
    switch (null.$SwitchMap$com$hazelcast$query$impl$predicates$RangeVisitor$Order[order.ordinal()]) {
      case 1:
        return predicate;
      case 2:
        return new EqualPredicate(predicate.attributeName, from);
      case 3:
        return FalsePredicate.INSTANCE;
    } 
    throw new IllegalStateException("Unexpected order: " + order);
  }
  
  private static Ranges intersect(Predicate[] predicates, int predicateIndex, Ranges ranges, Indexes indexes) {
    Predicate predicate = predicates[predicateIndex];
    if (predicate instanceof FalsePredicate)
      return Ranges.UNSATISFIABLE; 
    if (!isSupportedPredicate(predicate))
      return ranges; 
    RangePredicate rangePredicate = (RangePredicate)predicate;
    String attribute = rangePredicate.getAttribute();
    Range existingRange = Ranges.getRange(attribute, ranges);
    Range range = intersect(rangePredicate, existingRange, indexes);
    if (range == Range.UNKNOWN)
      return ranges; 
    if (range == Range.UNSATISFIABLE)
      return Ranges.UNSATISFIABLE; 
    if (ranges == null)
      ranges = new Ranges(predicates.length); 
    ranges.addRange(attribute, range, existingRange, predicateIndex);
    return ranges;
  }
  
  private static boolean isSupportedPredicate(Predicate predicate) {
    if (!PredicateUtils.isRangePredicate(predicate))
      return false; 
    RangePredicate rangePredicate = (RangePredicate)predicate;
    return !rangePredicate.getAttribute().contains("[any]");
  }
  
  private static Range intersect(RangePredicate predicate, Range range, Indexes indexes) {
    if (range == null) {
      TypeConverter converter = indexes.getConverter(predicate.getAttribute());
      if (converter == null)
        return Range.UNKNOWN; 
      return new Range(predicate, converter);
    } 
    return range.intersect(predicate);
  }
  
  private static Order compare(Comparable lhs, Comparable rhs) {
    int order = Comparables.compare(lhs, rhs);
    if (order < 0)
      return Order.LESS; 
    if (order == 0)
      return Order.EQUAL; 
    return Order.GREATER;
  }
}
