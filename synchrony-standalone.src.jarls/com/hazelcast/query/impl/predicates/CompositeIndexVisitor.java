package com.hazelcast.query.impl.predicates;

import com.hazelcast.query.Predicate;
import com.hazelcast.query.impl.AbstractIndex;
import com.hazelcast.query.impl.CompositeValue;
import com.hazelcast.query.impl.Indexes;
import com.hazelcast.query.impl.InternalIndex;
import java.util.HashMap;
import java.util.Map;

public class CompositeIndexVisitor extends AbstractVisitor {
  public Predicate visit(AndPredicate andPredicate, Indexes indexes) {
    int originalSize = andPredicate.predicates.length;
    if (originalSize < 2)
      return andPredicate; 
    InternalIndex[] compositeIndexes = indexes.getCompositeIndexes();
    if (compositeIndexes.length == 0)
      return andPredicate; 
    Map<String, EqualPredicate> prefixes = null;
    Map<String, RangePredicate> comparisons = null;
    Output output = null;
    for (Predicate predicate : andPredicate.predicates) {
      if (PredicateUtils.isEqualPredicate(predicate)) {
        EqualPredicate equalPredicate = (EqualPredicate)predicate;
        prefixes = obtainHashMap(prefixes, originalSize);
        EqualPredicate replaced = (EqualPredicate)prefixes.put(equalPredicate.attributeName, equalPredicate);
        if (replaced != null) {
          output = obtainOutput(output, originalSize);
          output.add(replaced);
        } 
      } else if (PredicateUtils.isRangePredicate(predicate)) {
        RangePredicate rangePredicate = (RangePredicate)predicate;
        comparisons = obtainHashMap(comparisons, originalSize);
        RangePredicate replaced = (RangePredicate)comparisons.put(rangePredicate.getAttribute(), rangePredicate);
        if (replaced != null) {
          output = obtainOutput(output, originalSize);
          output.add(replaced);
        } 
      } else {
        output = obtainOutput(output, originalSize);
        output.add(predicate);
      } 
    } 
    if (prefixes == null || (comparisons == null && prefixes.size() == 1))
      return andPredicate; 
    assert !prefixes.isEmpty();
    while (!prefixes.isEmpty()) {
      int bestPrefix = 0;
      InternalIndex bestIndex = null;
      RangePredicate bestComparison = null;
      for (InternalIndex index : compositeIndexes) {
        String[] components = index.getComponents();
        if (components.length >= bestPrefix && (index.isOrdered() || prefixes.size() >= components.length)) {
          int prefix = 0;
          while (prefix < components.length && prefixes.containsKey(components[prefix]))
            prefix++; 
          if (prefix != 0)
            if (index.isOrdered()) {
              RangePredicate comparison = (prefix < components.length && comparisons != null) ? (RangePredicate)comparisons.get(components[prefix]) : null;
              if (comparison != null)
                prefix++; 
              if (prefix > bestPrefix) {
                bestPrefix = prefix;
                bestIndex = index;
                bestComparison = comparison;
              } else if (prefix == bestPrefix) {
                assert bestIndex != null;
                if (bestIndex.isOrdered() && bestIndex.getComponents().length > components.length) {
                  bestIndex = index;
                  bestComparison = comparison;
                } 
              } 
            } else if (prefix == components.length && prefix >= bestPrefix) {
              bestPrefix = prefix;
              bestIndex = index;
              bestComparison = null;
            }  
        } 
      } 
      if (bestIndex == null || bestPrefix == 1)
        break; 
      int equalPrefixLength = (bestComparison == null) ? bestPrefix : (bestPrefix - 1);
      if (output == null) {
        Predicate generated = tryGenerateFast(prefixes, comparisons, equalPrefixLength, bestComparison, bestIndex);
        if (generated != null)
          return generated; 
      } 
      output = obtainOutput(output, originalSize);
      addToOutput(prefixes, comparisons, output, equalPrefixLength, bestComparison, bestIndex);
    } 
    return (output == null) ? andPredicate : output.generate(prefixes, comparisons, andPredicate);
  }
  
  private static Predicate tryGenerateFast(Map<String, EqualPredicate> prefixes, Map<String, RangePredicate> comparisons, int prefixLength, RangePredicate comparison, InternalIndex index) {
    if (index.isOrdered()) {
      assert prefixLength <= index.getComponents().length;
      return tryGenerateFastOrdered(prefixes, comparisons, prefixLength, comparison, index);
    } 
    assert comparison == null;
    assert prefixLength == index.getComponents().length;
    return tryGenerateFastUnordered(prefixes, comparisons, prefixLength, index);
  }
  
  private static Predicate tryGenerateFastOrdered(Map<String, EqualPredicate> prefixes, Map<String, RangePredicate> comparisons, int prefixLength, RangePredicate comparison, InternalIndex index) {
    assert index.isOrdered();
    String[] components = index.getComponents();
    if (prefixes.size() != prefixLength)
      return null; 
    if (comparison == null) {
      if (comparisons != null) {
        assert !comparisons.isEmpty();
        return null;
      } 
      if (prefixLength == components.length)
        return generateEqualPredicate(index, prefixes, true); 
      return generateRangePredicate(index, prefixes, prefixLength, true);
    } 
    if (comparisons.size() != 1)
      return null; 
    return generateRangePredicate(index, prefixes, prefixLength, comparison, true);
  }
  
  private static Predicate tryGenerateFastUnordered(Map<String, EqualPredicate> prefixes, Map<String, RangePredicate> comparisons, int prefixLength, InternalIndex index) {
    assert !index.isOrdered();
    if (comparisons != null) {
      assert !comparisons.isEmpty();
      return null;
    } 
    if (prefixLength != prefixes.size())
      return null; 
    return generateEqualPredicate(index, prefixes, true);
  }
  
  private static void addToOutput(Map<String, EqualPredicate> prefixes, Map<String, RangePredicate> comparisons, Output output, int prefixLength, RangePredicate comparison, InternalIndex index) {
    if (index.isOrdered()) {
      assert prefixLength <= index.getComponents().length;
      addToOutputOrdered(prefixes, comparisons, output, prefixLength, comparison, index);
    } else {
      assert comparison == null;
      assert prefixLength == index.getComponents().length;
      addToOutputUnordered(prefixes, output, index);
    } 
  }
  
  private static void addToOutputOrdered(Map<String, EqualPredicate> prefixes, Map<String, RangePredicate> comparisons, Output output, int prefixLength, RangePredicate comparison, InternalIndex index) {
    assert index.isOrdered();
    String[] components = index.getComponents();
    if (prefixLength == components.length) {
      output.addGenerated(generateEqualPredicate(index, prefixes, false));
      return;
    } 
    if (comparison == null) {
      output.addGenerated(generateRangePredicate(index, prefixes, prefixLength, false));
    } else {
      comparisons.remove(comparison.getAttribute());
      output.addGenerated(generateRangePredicate(index, prefixes, prefixLength, comparison, false));
    } 
  }
  
  private static void addToOutputUnordered(Map<String, EqualPredicate> prefixes, Output output, InternalIndex index) {
    assert !index.isOrdered();
    output.addGenerated(generateEqualPredicate(index, prefixes, false));
  }
  
  private static Predicate generateEqualPredicate(InternalIndex index, Map<String, EqualPredicate> prefixes, boolean fast) {
    String[] components = index.getComponents();
    Comparable[] values = new Comparable[components.length];
    for (int i = 0; i < components.length; i++)
      values[i] = fast ? ((EqualPredicate)prefixes.get(components[i])).value : ((EqualPredicate)prefixes.remove(components[i])).value; 
    return new CompositeEqualPredicate(index, new CompositeValue(values));
  }
  
  private static Predicate generateRangePredicate(InternalIndex index, Map<String, EqualPredicate> prefixes, int prefixLength, boolean fast) {
    String[] components = index.getComponents();
    Comparable[] from = new Comparable[components.length];
    Comparable[] to = new Comparable[components.length];
    for (int i = 0; i < prefixLength; i++) {
      Comparable value = fast ? ((EqualPredicate)prefixes.get(components[i])).value : ((EqualPredicate)prefixes.remove(components[i])).value;
      from[i] = value;
      to[i] = value;
    } 
    for (int i = prefixLength; i < components.length; i++) {
      from[i] = CompositeValue.NEGATIVE_INFINITY;
      to[i] = CompositeValue.POSITIVE_INFINITY;
    } 
    return new CompositeRangePredicate(index, new CompositeValue(from), false, new CompositeValue(to), false, prefixLength);
  }
  
  private static Predicate generateRangePredicate(InternalIndex index, Map<String, EqualPredicate> prefixes, int prefixLength, RangePredicate comparison, boolean fast) {
    assert !(comparison instanceof EqualPredicate);
    assert comparison.getFrom() != AbstractIndex.NULL && comparison.getTo() != AbstractIndex.NULL;
    String[] components = index.getComponents();
    boolean fullyMatched = (components.length == prefixLength + 1);
    boolean hasFrom = (comparison.getFrom() != null);
    boolean hasTo = (comparison.getTo() != null);
    assert hasFrom || hasTo;
    assert hasFrom || !comparison.isFromInclusive();
    assert hasTo || !comparison.isToInclusive();
    Comparable[] from = new Comparable[components.length];
    Comparable[] to = new Comparable[components.length];
    for (int i = 0; i < prefixLength; i++) {
      Comparable value = fast ? ((EqualPredicate)prefixes.get(components[i])).value : ((EqualPredicate)prefixes.remove(components[i])).value;
      from[i] = value;
      to[i] = value;
    } 
    from[prefixLength] = hasFrom ? comparison.getFrom() : AbstractIndex.NULL;
    to[prefixLength] = hasTo ? comparison.getTo() : CompositeValue.POSITIVE_INFINITY;
    for (int i = prefixLength + 1; i < components.length; i++) {
      from[i] = (!hasFrom || comparison.isFromInclusive()) ? CompositeValue.NEGATIVE_INFINITY : CompositeValue.POSITIVE_INFINITY;
      to[i] = (!hasTo || comparison.isToInclusive()) ? CompositeValue.POSITIVE_INFINITY : CompositeValue.NEGATIVE_INFINITY;
    } 
    return new CompositeRangePredicate(index, new CompositeValue(from), (fullyMatched && comparison.isFromInclusive()), new CompositeValue(to), (fullyMatched && comparison
        .isToInclusive()), prefixLength);
  }
  
  private static <K, V> Map<K, V> obtainHashMap(Map<K, V> map, int capacity) { return (map == null) ? new HashMap(capacity) : map; }
  
  private static Output obtainOutput(Output output, int capacity) { return (output == null) ? new Output(capacity) : output; }
}
