package com.hazelcast.query.impl;

import com.hazelcast.query.QueryConstants;
import com.hazelcast.query.impl.predicates.PredicateUtils;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Pattern;

public final class IndexDefinition {
  private static final int MAX_INDEX_COMPONENTS = 255;
  
  private static final Pattern COMMA_PATTERN = Pattern.compile("\\s*,\\s*");
  
  private static final String BITMAP_PREFIX = "BITMAP(";
  
  private static final String BITMAP_POSTFIX = ")";
  
  private final String name;
  
  private final boolean ordered;
  
  private final String uniqueKey;
  
  private final UniqueKeyTransform uniqueKeyTransform;
  
  private final String[] components;
  
  private IndexDefinition(String name, boolean ordered, String... components) {
    this.name = name;
    this.ordered = ordered;
    this.uniqueKey = null;
    this.uniqueKeyTransform = UniqueKeyTransform.OBJECT;
    this.components = components;
  }
  
  private IndexDefinition(String name, boolean ordered, String uniqueKey, UniqueKeyTransform uniqueKeyTransform, String... components) {
    this.name = name;
    this.ordered = ordered;
    this.uniqueKey = uniqueKey;
    this.uniqueKeyTransform = uniqueKeyTransform;
    this.components = components;
  }
  
  public static IndexDefinition parse(String definition, boolean ordered) {
    IndexDefinition parsedDefinition = tryParseBitmap(definition, ordered);
    if (parsedDefinition != null)
      return parsedDefinition; 
    parsedDefinition = tryParseComposite(definition, ordered);
    if (parsedDefinition != null)
      return parsedDefinition; 
    String attribute = PredicateUtils.canonicalizeAttribute(definition);
    return new IndexDefinition(attribute, ordered, new String[] { attribute });
  }
  
  private static IndexDefinition tryParseBitmap(String definition, boolean ordered) {
    if (definition == null || !definition.toUpperCase().startsWith("BITMAP("))
      return null; 
    if (!definition.endsWith(")"))
      throw makeInvalidBitmapIndexDefinitionException(definition); 
    String innerText = definition.substring("BITMAP(".length(), definition.length() - 1);
    String[] parts = COMMA_PATTERN.split(innerText, -1);
    if (parts.length == 0 || parts.length > 3)
      throw makeInvalidBitmapIndexDefinitionException(definition); 
    String attribute = PredicateUtils.canonicalizeAttribute(parts[0]);
    String uniqueKey = (parts.length >= 2) ? PredicateUtils.canonicalizeAttribute(parts[1]) : QueryConstants.KEY_ATTRIBUTE_NAME.value();
    UniqueKeyTransform uniqueKeyTransform = (parts.length == 3) ? UniqueKeyTransform.access$000(parts[2]) : UniqueKeyTransform.OBJECT;
    if (attribute.isEmpty() || uniqueKey.isEmpty() || attribute.equals(uniqueKey))
      throw makeInvalidBitmapIndexDefinitionException(definition); 
    String canonicalName = "BITMAP(" + attribute + ", " + uniqueKey + ", " + uniqueKeyTransform + ")";
    return new IndexDefinition(canonicalName, ordered, uniqueKey, uniqueKeyTransform, new String[] { attribute });
  }
  
  private static IllegalArgumentException makeInvalidBitmapIndexDefinitionException(String definition) { return new IllegalArgumentException("Invalid bitmap index definition: " + definition); }
  
  private static IndexDefinition tryParseComposite(String definition, boolean ordered) {
    String[] attributes = COMMA_PATTERN.split(definition, -1);
    if (attributes.length == 1)
      return null; 
    if (attributes.length > 255)
      throw new IllegalArgumentException("Too many composite index attributes: " + definition); 
    Set<String> seenAttributes = new HashSet<String>(attributes.length);
    for (int i = 0; i < attributes.length; i++) {
      String component = PredicateUtils.canonicalizeAttribute(attributes[i]);
      attributes[i] = component;
      if (component.isEmpty())
        throw new IllegalArgumentException("Empty composite index attribute: " + definition); 
      if (!seenAttributes.add(component))
        throw new IllegalArgumentException("Duplicate composite index attribute: " + definition); 
    } 
    return new IndexDefinition(PredicateUtils.constructCanonicalCompositeIndexName(attributes), ordered, attributes);
  }
  
  public String getName() { return this.name; }
  
  public boolean isOrdered() { return this.ordered; }
  
  public String getUniqueKey() { return this.uniqueKey; }
  
  public UniqueKeyTransform getUniqueKeyTransform() { return this.uniqueKeyTransform; }
  
  @SuppressFBWarnings({"EI_EXPOSE_REP"})
  public String[] getComponents() { return this.components; }
}
