package com.hazelcast.query.impl;

import com.hazelcast.core.TypeConverter;
import com.hazelcast.internal.json.NonTerminalJsonValue;
import com.hazelcast.internal.serialization.InternalSerializationService;
import com.hazelcast.monitor.impl.IndexOperationStats;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.query.Predicate;
import com.hazelcast.query.impl.bitmap.Bitmap;
import com.hazelcast.query.impl.getters.Extractors;
import com.hazelcast.query.impl.getters.MultiResult;
import com.hazelcast.util.collection.Long2LongHashMap;
import com.hazelcast.util.collection.Object2LongHashMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public final class BitmapIndexStore extends BaseIndexStore {
  private static final long NO_KEY = -1L;
  
  private static final int INITIAL_CAPACITY = 8;
  
  private static final float LOAD_FACTOR = 0.75F;
  
  private static final Object CONSUMED = new Object();
  
  private static final Set<Class<? extends Predicate>> EVALUABLE_PREDICATES = new HashSet();
  
  private final String keyAttribute;
  
  private final InternalSerializationService serializationService;
  
  private final Extractors extractors;
  
  static  {
    EVALUABLE_PREDICATES.add(com.hazelcast.query.impl.predicates.AndPredicate.class);
    EVALUABLE_PREDICATES.add(com.hazelcast.query.impl.predicates.OrPredicate.class);
    EVALUABLE_PREDICATES.add(com.hazelcast.query.impl.predicates.NotPredicate.class);
    EVALUABLE_PREDICATES.add(com.hazelcast.query.impl.predicates.EqualPredicate.class);
    EVALUABLE_PREDICATES.add(com.hazelcast.query.impl.predicates.NotEqualPredicate.class);
    EVALUABLE_PREDICATES.add(com.hazelcast.query.impl.predicates.InPredicate.class);
  }
  
  private final Bitmap<QueryableEntry> bitmap = new Bitmap();
  
  private final Long2LongHashMap internalKeys;
  
  private final Object2LongHashMap internalObjectKeys;
  
  private long internalKeyCounter;
  
  public BitmapIndexStore(IndexDefinition definition, InternalSerializationService serializationService, Extractors extractors) {
    super(IndexCopyBehavior.NEVER);
    if (definition.isOrdered())
      throw new IllegalArgumentException("Ordered bitmap indexes are not supported"); 
    this.keyAttribute = definition.getUniqueKey();
    this.serializationService = serializationService;
    this.extractors = extractors;
    switch (null.$SwitchMap$com$hazelcast$query$impl$IndexDefinition$UniqueKeyTransform[definition.getUniqueKeyTransform().ordinal()]) {
      case 1:
        this.internalObjectKeys = new Object2LongHashMap(8, 0.75F, -1L);
        this.internalKeys = null;
        return;
      case 2:
        this.internalKeys = new Long2LongHashMap(8, 0.75D, -1L);
        this.internalObjectKeys = null;
        return;
      case 3:
        this.internalKeys = null;
        this.internalObjectKeys = null;
        return;
    } 
    throw new IllegalArgumentException("unexpected unique key transform: " + definition.getUniqueKeyTransform());
  }
  
  public Comparable canonicalizeQueryArgumentScalar(Comparable value) { return canonicalizeScalarForStorage(value); }
  
  public void insert(Object value, QueryableEntry entry, IndexOperationStats operationStats) {
    if (value == NonTerminalJsonValue.INSTANCE)
      return; 
    if (this.internalObjectKeys == null) {
      long key = extractLongKey(entry);
      Iterator values = makeIterator(value);
      takeWriteLock();
      try {
        if (this.internalKeys != null) {
          long internalKey = this.internalKeyCounter++;
          long replaced = this.internalKeys.put(key, internalKey);
          if (!$assertionsDisabled && replaced != -1L)
            throw new AssertionError(); 
          key = internalKey;
        } else if (key < 0L) {
          throw makeNegativeKeyException(key);
        } 
        this.bitmap.insert(values, key, entry);
      } finally {
        releaseWriteLock();
      } 
    } else {
      Object key = extractObjectKey(entry);
      Iterator values = makeIterator(value);
      takeWriteLock();
      try {
        long internalKey = this.internalKeyCounter++;
        long replaced = this.internalObjectKeys.put(key, internalKey);
        if (!$assertionsDisabled && replaced != -1L)
          throw new AssertionError(); 
        this.bitmap.insert(values, internalKey, entry);
      } finally {
        releaseWriteLock();
      } 
    } 
  }
  
  public void update(Object oldValue, Object newValue, QueryableEntry entry, IndexOperationStats operationStats) {
    if (oldValue == NonTerminalJsonValue.INSTANCE) {
      insert(newValue, entry, operationStats);
      return;
    } 
    if (this.internalObjectKeys == null) {
      long key = extractLongKey(entry);
      Iterator oldValues = makeIterator(oldValue);
      Iterator newValues = makeIterator(newValue);
      takeWriteLock();
      try {
        if (this.internalKeys != null) {
          key = this.internalKeys.get(key);
          assert key != -1L;
        } else if (key < 0L) {
          throw makeNegativeKeyException(key);
        } 
        this.bitmap.update(oldValues, newValues, key, entry);
      } finally {
        releaseWriteLock();
      } 
    } else {
      Object key = extractObjectKey(entry);
      Iterator oldValues = makeIterator(oldValue);
      Iterator newValues = makeIterator(newValue);
      takeWriteLock();
      try {
        long internalKey = this.internalObjectKeys.getValue(key);
        assert internalKey != -1L;
        this.bitmap.update(oldValues, newValues, internalKey, entry);
      } finally {
        releaseWriteLock();
      } 
    } 
  }
  
  public void remove(Object value, Data entryKey, Object entryValue, IndexOperationStats operationStats) {
    if (value == NonTerminalJsonValue.INSTANCE)
      return; 
    if (this.internalObjectKeys == null) {
      long key = extractLongKey(entryKey, entryValue);
      Iterator values = makeIterator(value);
      takeWriteLock();
      try {
        if (this.internalKeys != null) {
          key = this.internalKeys.remove(key);
          if (key != -1L)
            this.bitmap.remove(values, key); 
        } else {
          if (key < 0L)
            throw makeNegativeKeyException(key); 
          this.bitmap.remove(values, key);
        } 
      } finally {
        releaseWriteLock();
      } 
    } else {
      Object key = extractObjectKey(entryKey, entryValue);
      Iterator values = makeIterator(value);
      takeWriteLock();
      try {
        long internalKey = this.internalObjectKeys.removeKey(key);
        if (internalKey != -1L)
          this.bitmap.remove(values, internalKey); 
      } finally {
        releaseWriteLock();
      } 
    } 
  }
  
  public void clear() {
    takeWriteLock();
    try {
      this.bitmap.clear();
      if (this.internalKeys != null)
        this.internalKeys.clear(); 
      if (this.internalObjectKeys != null)
        this.internalObjectKeys.clear(); 
      this.internalKeyCounter = 0L;
    } finally {
      releaseWriteLock();
    } 
  }
  
  public boolean isEvaluateOnly() { return true; }
  
  public boolean canEvaluate(Class<? extends Predicate> predicateClass) { return EVALUABLE_PREDICATES.contains(predicateClass); }
  
  public Set<QueryableEntry> evaluate(Predicate predicate, TypeConverter converter) {
    takeReadLock();
    try {
      return toSingleResultSet(toMap(this.bitmap.evaluate(predicate, new CanonicalizingConverter(this, converter))));
    } finally {
      releaseReadLock();
    } 
  }
  
  public Set<QueryableEntry> getRecords(Comparable value) { throw makeUnsupportedOperationException(); }
  
  public Set<QueryableEntry> getRecords(Set<Comparable> values) { throw makeUnsupportedOperationException(); }
  
  public Set<QueryableEntry> getRecords(Comparison comparison, Comparable value) { throw makeUnsupportedOperationException(); }
  
  public Set<QueryableEntry> getRecords(Comparable from, boolean fromInclusive, Comparable to, boolean toInclusive) { throw makeUnsupportedOperationException(); }
  
  Comparable canonicalizeScalarForStorage(Comparable value) {
    if (!(value instanceof Number))
      return value; 
    Class clazz = value.getClass();
    Number number = (Number)value;
    if (clazz == Double.class) {
      double doubleValue = number.doubleValue();
      long longValue = number.longValue();
      if (Numbers.equalDoubles(doubleValue, longValue))
        return canonicalizeLongRepresentable(longValue); 
      float floatValue = number.floatValue();
      if (doubleValue == floatValue)
        return Float.valueOf(floatValue); 
    } else if (clazz == Float.class) {
      float floatValue = number.floatValue();
      long longValue = number.longValue();
      if (Numbers.equalFloats(floatValue, (float)longValue))
        return canonicalizeLongRepresentable(longValue); 
    } else if (Numbers.isLongRepresentable(clazz)) {
      return canonicalizeLongRepresentable(number.longValue());
    } 
    return value;
  }
  
  private Map<Data, QueryableEntry> toMap(Iterator<QueryableEntry> iterator) {
    Map<Data, QueryableEntry> map = new HashMap<Data, QueryableEntry>();
    while (iterator.hasNext()) {
      QueryableEntry entry = (QueryableEntry)iterator.next();
      map.put(entry.getKeyData(), entry);
    } 
    return map;
  }
  
  private long extractLongKey(Data entryKey, Object entryValue) {
    Object key = QueryableEntry.extractAttributeValue(this.extractors, this.serializationService, this.keyAttribute, entryKey, entryValue, null);
    return extractLongKey(key);
  }
  
  private long extractLongKey(QueryableEntry entry) {
    Object key = entry.getAttributeValue(this.keyAttribute);
    return extractLongKey(key);
  }
  
  private Object extractObjectKey(Data entryKey, Object entryValue) {
    Object key = QueryableEntry.extractAttributeValue(this.extractors, this.serializationService, this.keyAttribute, entryKey, entryValue, null);
    return extractObjectKey(key);
  }
  
  private Object extractObjectKey(QueryableEntry entry) {
    Object key = entry.getAttributeValue(this.keyAttribute);
    return extractObjectKey(key);
  }
  
  private Iterator makeIterator(Object value) { return (value instanceof MultiResult) ? new MultiValueIterator(this, (MultiResult)value) : new SingleValueIterator(this, value); }
  
  private static Comparable canonicalizeLongRepresentable(long value) {
    if (value == (int)value)
      return Integer.valueOf((int)value); 
    return Long.valueOf(value);
  }
  
  private Comparable canonicalize(Comparable value) { return canonicalizeScalarForStorage(value); }
  
  private static UnsupportedOperationException makeUnsupportedOperationException() { return new UnsupportedOperationException("bitmap indexes support only direct predicate evaluation"); }
  
  private static long extractLongKey(Object key) {
    if (key == null)
      throw new NullPointerException("non-null unique key value is required"); 
    if (!Numbers.isLongRepresentable(key.getClass()))
      throw new IllegalArgumentException("integer-valued unique key value is required"); 
    return ((Number)key).longValue();
  }
  
  private static Object extractObjectKey(Object key) {
    if (key == null)
      throw new NullPointerException("non-null unique key value is required"); 
    return key;
  }
  
  private IllegalArgumentException makeNegativeKeyException(long key) { return new IllegalArgumentException("negative keys are not supported: " + this.keyAttribute + " = " + key); }
}
