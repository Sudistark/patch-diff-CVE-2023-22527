package com.hazelcast.query.impl.bitmap;

import com.hazelcast.core.TypeConverter;
import com.hazelcast.query.Predicate;
import com.hazelcast.query.impl.predicates.AndPredicate;
import com.hazelcast.query.impl.predicates.EqualPredicate;
import com.hazelcast.query.impl.predicates.InPredicate;
import com.hazelcast.query.impl.predicates.NotEqualPredicate;
import com.hazelcast.query.impl.predicates.NotPredicate;
import com.hazelcast.query.impl.predicates.OrPredicate;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public final class Bitmap<E> extends Object {
  private final Map<Object, SparseBitSet> bitSets = new HashMap();
  
  private final SparseArray<E> entries = new SparseArray();
  
  public void insert(Iterator values, long key, E entry) {
    while (values.hasNext()) {
      Object value = values.next();
      assert value != null;
      SparseBitSet bitSet = (SparseBitSet)this.bitSets.get(value);
      if (bitSet == null) {
        bitSet = new SparseBitSet();
        this.bitSets.put(value, bitSet);
      } 
      bitSet.add(key);
    } 
    this.entries.set(key, entry);
  }
  
  public void update(Iterator oldValues, Iterator newValues, long key, E entry) {
    while (oldValues.hasNext()) {
      Object value = oldValues.next();
      assert value != null;
      SparseBitSet bitSet = (SparseBitSet)this.bitSets.get(value);
      if (bitSet != null)
        bitSet.remove(key); 
    } 
    while (newValues.hasNext()) {
      Object value = newValues.next();
      assert value != null;
      SparseBitSet bitSet = (SparseBitSet)this.bitSets.get(value);
      if (bitSet == null) {
        bitSet = new SparseBitSet();
        this.bitSets.put(value, bitSet);
      } 
      bitSet.add(key);
    } 
    this.entries.set(key, entry);
  }
  
  public void remove(Iterator values, long key) {
    while (values.hasNext()) {
      Object value = values.next();
      assert value != null;
      SparseBitSet bitSet = (SparseBitSet)this.bitSets.get(value);
      if (bitSet != null && 
        bitSet.remove(key))
        this.bitSets.remove(value); 
    } 
    this.entries.clear(key);
  }
  
  public void clear() {
    this.bitSets.clear();
    this.entries.clear();
  }
  
  public Iterator<E> evaluate(Predicate predicate, TypeConverter converter) { return new EntryIterator(predicateIterator(predicate, converter), this.entries.iterator()); }
  
  private AscendingLongIterator predicateIterator(Predicate predicate, TypeConverter converter) {
    if (predicate instanceof AndPredicate) {
      Predicate[] predicates = ((AndPredicate)predicate).getPredicates();
      assert predicates.length > 0;
      if (predicates.length == 1)
        return predicateIterator(predicates[0], converter); 
      return BitmapAlgorithms.and(predicateIterators(predicates, converter));
    } 
    if (predicate instanceof OrPredicate) {
      Predicate[] predicates = ((OrPredicate)predicate).getPredicates();
      assert predicates.length > 0;
      if (predicates.length == 1)
        return predicateIterator(predicates[0], converter); 
      return BitmapAlgorithms.or(predicateIterators(predicates, converter));
    } 
    if (predicate instanceof NotPredicate) {
      Predicate subPredicate = ((NotPredicate)predicate).getPredicate();
      return BitmapAlgorithms.not(predicateIterator(subPredicate, converter), this.entries);
    } 
    if (predicate instanceof NotEqualPredicate) {
      Comparable value = ((NotEqualPredicate)predicate).getFrom();
      return BitmapAlgorithms.not(valueIterator(value, converter), this.entries);
    } 
    if (predicate instanceof EqualPredicate) {
      Comparable value = ((EqualPredicate)predicate).getFrom();
      return valueIterator(value, converter);
    } 
    if (predicate instanceof InPredicate) {
      Comparable[] values = ((InPredicate)predicate).getValues();
      return BitmapAlgorithms.or(valueIterators(values, converter));
    } 
    throw new IllegalArgumentException("unexpected predicate: " + predicate);
  }
  
  private AscendingLongIterator[] predicateIterators(Predicate[] predicates, TypeConverter converter) {
    AscendingLongIterator[] iterators = new AscendingLongIterator[predicates.length];
    for (int i = 0; i < predicates.length; i++)
      iterators[i] = predicateIterator(predicates[i], converter); 
    return iterators;
  }
  
  private AscendingLongIterator valueIterator(Comparable value, TypeConverter converter) {
    SparseBitSet bitSet = (SparseBitSet)this.bitSets.get(converter.convert(value));
    return (bitSet == null) ? AscendingLongIterator.EMPTY : bitSet.iterator();
  }
  
  private AscendingLongIterator[] valueIterators(Comparable[] values, TypeConverter converter) {
    AscendingLongIterator[] iterators = new AscendingLongIterator[values.length];
    for (int i = 0; i < values.length; i++)
      iterators[i] = valueIterator(values[i], converter); 
    return iterators;
  }
}
