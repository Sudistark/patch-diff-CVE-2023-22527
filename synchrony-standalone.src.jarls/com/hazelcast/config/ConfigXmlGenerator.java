package com.hazelcast.config;

import com.hazelcast.config.cp.CPSemaphoreConfig;
import com.hazelcast.config.cp.CPSubsystemConfig;
import com.hazelcast.config.cp.FencedLockConfig;
import com.hazelcast.config.cp.RaftAlgorithmConfig;
import com.hazelcast.logging.ILogger;
import com.hazelcast.logging.Logger;
import com.hazelcast.nio.serialization.DataSerializableFactory;
import com.hazelcast.nio.serialization.PortableFactory;
import com.hazelcast.quorum.impl.ProbabilisticQuorumFunction;
import com.hazelcast.quorum.impl.RecentlyActiveQuorumFunction;
import com.hazelcast.util.CollectionUtil;
import com.hazelcast.util.MapUtil;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.StringUtil;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

public class ConfigXmlGenerator {
  protected static final String MASK_FOR_SENSITIVE_DATA = "****";
  
  private static final int INDENT = 5;
  
  private static final ILogger LOGGER = Logger.getLogger(ConfigXmlGenerator.class);
  
  private final boolean formatted;
  
  private final boolean maskSensitiveFields;
  
  public ConfigXmlGenerator() { this(true); }
  
  public ConfigXmlGenerator(boolean formatted) { this(formatted, true); }
  
  public ConfigXmlGenerator(boolean formatted, boolean maskSensitiveFields) {
    this.formatted = formatted;
    this.maskSensitiveFields = maskSensitiveFields;
  }
  
  public String generate(Config config) {
    Preconditions.isNotNull(config, "Config");
    StringBuilder xml = new StringBuilder();
    XmlGenerator gen = new XmlGenerator(xml);
    xml.append("<hazelcast ")
      .append("xmlns=\"http://www.hazelcast.com/schema/config\"\n")
      .append("xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n")
      .append("xsi:schemaLocation=\"http://www.hazelcast.com/schema/config ")
      .append("http://www.hazelcast.com/schema/config/hazelcast-config-3.12.xsd\">");
    gen.open("group", new Object[0])
      .node("name", config.getGroupConfig().getName(), new Object[0])
      .node("password", getOrMaskValue(config.getGroupConfig().getPassword()), new Object[0])
      .close()
      .node("license-key", getOrMaskValue(config.getLicenseKey()), new Object[0])
      .node("instance-name", config.getInstanceName(), new Object[0]);
    manCenterXmlGenerator(gen, config);
    gen.appendProperties(config.getProperties());
    securityXmlGenerator(gen, config);
    wanReplicationXmlGenerator(gen, config);
    networkConfigXmlGenerator(gen, config);
    advancedNetworkConfigXmlGenerator(gen, config);
    mapConfigXmlGenerator(gen, config);
    replicatedMapConfigXmlGenerator(gen, config);
    cacheConfigXmlGenerator(gen, config);
    queueXmlGenerator(gen, config);
    multiMapXmlGenerator(gen, config);
    collectionXmlGenerator(gen, "list", config.getListConfigs().values());
    collectionXmlGenerator(gen, "set", config.getSetConfigs().values());
    topicXmlGenerator(gen, config);
    semaphoreXmlGenerator(gen, config);
    lockXmlGenerator(gen, config);
    countDownLatchXmlGenerator(gen, config);
    ringbufferXmlGenerator(gen, config);
    atomicLongXmlGenerator(gen, config);
    atomicReferenceXmlGenerator(gen, config);
    executorXmlGenerator(gen, config);
    durableExecutorXmlGenerator(gen, config);
    scheduledExecutorXmlGenerator(gen, config);
    eventJournalXmlGenerator(gen, config);
    merkleTreeXmlGenerator(gen, config);
    partitionGroupXmlGenerator(gen, config);
    cardinalityEstimatorXmlGenerator(gen, config);
    listenerXmlGenerator(gen, config);
    serializationXmlGenerator(gen, config);
    reliableTopicXmlGenerator(gen, config);
    liteMemberXmlGenerator(gen, config);
    nativeMemoryXmlGenerator(gen, config);
    servicesXmlGenerator(gen, config);
    hotRestartXmlGenerator(gen, config);
    flakeIdGeneratorXmlGenerator(gen, config);
    crdtReplicationXmlGenerator(gen, config);
    pnCounterXmlGenerator(gen, config);
    quorumXmlGenerator(gen, config);
    cpSubsystemConfig(gen, config);
    userCodeDeploymentConfig(gen, config);
    xml.append("</hazelcast>");
    String xmlString = xml.toString();
    return this.formatted ? StringUtil.formatXml(xmlString, 5) : xmlString;
  }
  
  private String getOrMaskValue(String value) { return this.maskSensitiveFields ? "****" : value; }
  
  private void manCenterXmlGenerator(XmlGenerator gen, Config config) {
    if (config.getManagementCenterConfig() != null) {
      ManagementCenterConfig mcConfig = config.getManagementCenterConfig();
      gen.open("management-center", new Object[] { "enabled", 
            Boolean.valueOf(mcConfig.isEnabled()), "scripting-enabled", 
            Boolean.valueOf(mcConfig.isScriptingEnabled()), "update-interval", 
            Integer.valueOf(mcConfig.getUpdateInterval()) });
      gen.node("url", mcConfig.getUrl(), new Object[0]);
      if (mcConfig.getUrl() != null)
        mcMutualAuthConfigXmlGenerator(gen, config.getManagementCenterConfig()); 
      gen.close();
    } 
  }
  
  private static void collectionXmlGenerator(XmlGenerator gen, String type, Collection<? extends CollectionConfig> configs) {
    if (CollectionUtil.isNotEmpty(configs))
      for (CollectionConfig<? extends CollectionConfig> config : configs) {
        gen.open(type, new Object[] { "name", config.getName() }).node("statistics-enabled", Boolean.valueOf(config.isStatisticsEnabled()), new Object[0])
          .node("max-size", Integer.valueOf(config.getMaxSize()), new Object[0])
          .node("backup-count", Integer.valueOf(config.getBackupCount()), new Object[0])
          .node("async-backup-count", Integer.valueOf(config.getAsyncBackupCount()), new Object[0])
          .node("quorum-ref", config.getQuorumName(), new Object[0]);
        appendItemListenerConfigs(gen, config.getItemListenerConfigs());
        MergePolicyConfig mergePolicyConfig = config.getMergePolicyConfig();
        gen.node("merge-policy", mergePolicyConfig.getPolicy(), new Object[] { "batch-size", Integer.valueOf(mergePolicyConfig.getBatchSize()) }).close();
      }  
  }
  
  private static void replicatedMapConfigXmlGenerator(XmlGenerator gen, Config config) {
    for (ReplicatedMapConfig r : config.getReplicatedMapConfigs().values()) {
      MergePolicyConfig mergePolicyConfig = r.getMergePolicyConfig();
      gen.open("replicatedmap", new Object[] { "name", r.getName() }).node("in-memory-format", r.getInMemoryFormat(), new Object[0])
        .node("concurrency-level", Integer.valueOf(r.getConcurrencyLevel()), new Object[0])
        .node("replication-delay-millis", Long.valueOf(r.getReplicationDelayMillis()), new Object[0])
        .node("async-fillup", Boolean.valueOf(r.isAsyncFillup()), new Object[0])
        .node("statistics-enabled", Boolean.valueOf(r.isStatisticsEnabled()), new Object[0])
        .node("quorum-ref", r.getQuorumName(), new Object[0])
        .node("merge-policy", mergePolicyConfig.getPolicy(), new Object[] { "batch-size", Integer.valueOf(mergePolicyConfig.getBatchSize()) });
      if (!r.getListenerConfigs().isEmpty()) {
        gen.open("entry-listeners", new Object[0]);
        for (ListenerConfig lc : r.getListenerConfigs()) {
          gen.node("entry-listener", classNameOrImplClass(lc.getClassName(), lc.getImplementation()), new Object[] { "include-value", 
                Boolean.valueOf(lc.isIncludeValue()), "local", 
                Boolean.valueOf(lc.isLocal()) });
        } 
        gen.close();
      } 
      gen.close();
    } 
  }
  
  private static void listenerXmlGenerator(XmlGenerator gen, Config config) {
    if (config.getListenerConfigs().isEmpty())
      return; 
    gen.open("listeners", new Object[0]);
    for (ListenerConfig lc : config.getListenerConfigs())
      gen.node("listener", classNameOrImplClass(lc.getClassName(), lc.getImplementation()), new Object[0]); 
    gen.close();
  }
  
  private static void eventJournalXmlGenerator(XmlGenerator gen, Config config) {
    Collection<EventJournalConfig> mapJournalConfigs = config.getMapEventJournalConfigs().values();
    Collection<EventJournalConfig> cacheJournalConfigs = config.getCacheEventJournalConfigs().values();
    for (EventJournalConfig c : mapJournalConfigs) {
      gen.open("event-journal", new Object[] { "enabled", Boolean.valueOf(c.isEnabled()) }).node("mapName", c.getMapName(), new Object[0])
        .node("capacity", Integer.valueOf(c.getCapacity()), new Object[0])
        .node("time-to-live-seconds", Integer.valueOf(c.getTimeToLiveSeconds()), new Object[0])
        .close();
    } 
    for (EventJournalConfig c : cacheJournalConfigs) {
      gen.open("event-journal", new Object[] { "enabled", Boolean.valueOf(c.isEnabled()) }).node("cacheName", c.getCacheName(), new Object[0])
        .node("capacity", Integer.valueOf(c.getCapacity()), new Object[0])
        .node("time-to-live-seconds", Integer.valueOf(c.getTimeToLiveSeconds()), new Object[0])
        .close();
    } 
  }
  
  private static void securityXmlGenerator(XmlGenerator gen, Config config) {
    SecurityConfig c = config.getSecurityConfig();
    if (c == null)
      return; 
    gen.open("security", new Object[] { "enabled", Boolean.valueOf(c.isEnabled()) }).node("client-block-unmapped-actions", Boolean.valueOf(c.getClientBlockUnmappedActions()), new Object[0]);
    PermissionPolicyConfig ppc = c.getClientPolicyConfig();
    if (ppc.getClassName() != null)
      gen.open("client-permission-policy", new Object[] { "class-name", ppc.getClassName() }).appendProperties(ppc.getProperties())
        .close(); 
    appendLoginModules(gen, "client-login-modules", c.getClientLoginModuleConfigs());
    appendLoginModules(gen, "member-login-modules", c.getMemberLoginModuleConfigs());
    CredentialsFactoryConfig cfc = c.getMemberCredentialsConfig();
    if (cfc.getClassName() != null)
      gen.open("member-credentials-factory", new Object[] { "class-name", cfc.getClassName() }).appendProperties(cfc.getProperties())
        .close(); 
    List<SecurityInterceptorConfig> sic = c.getSecurityInterceptorConfigs();
    if (!sic.isEmpty()) {
      gen.open("security-interceptors", new Object[0]);
      for (SecurityInterceptorConfig s : sic) {
        gen.open("interceptor", new Object[] { "class-name", s.getClassName() }).close();
      } 
      gen.close();
    } 
    appendSecurityPermissions(gen, "client-permissions", c.getClientPermissionConfigs(), new Object[] { "on-join-operation", c
          .getOnJoinPermissionOperation() });
    gen.close();
  }
  
  private static void appendSecurityPermissions(XmlGenerator gen, String tag, Set<PermissionConfig> cpc, Object... attributes) {
    List<PermissionConfig.PermissionType> clusterPermTypes = Arrays.asList(new PermissionConfig.PermissionType[] { PermissionConfig.PermissionType.ALL, PermissionConfig.PermissionType.CONFIG, PermissionConfig.PermissionType.TRANSACTION });
    if (!cpc.isEmpty()) {
      gen.open(tag, attributes);
      for (PermissionConfig p : cpc) {
        if (clusterPermTypes.contains(p.getType())) {
          gen.open(p.getType().getNodeName(), new Object[] { "principal", p.getPrincipal() });
        } else {
          gen.open(p.getType().getNodeName(), new Object[] { "principal", p.getPrincipal(), "name", p.getName() });
        } 
        if (!p.getEndpoints().isEmpty()) {
          gen.open("endpoints", new Object[0]);
          for (String endpoint : p.getEndpoints())
            gen.node("endpoint", endpoint, new Object[0]); 
          gen.close();
        } 
        if (!p.getActions().isEmpty()) {
          gen.open("actions", new Object[0]);
          for (String action : p.getActions())
            gen.node("action", action, new Object[0]); 
          gen.close();
        } 
        gen.close();
      } 
      gen.close();
    } 
  }
  
  private static void appendLoginModules(XmlGenerator gen, String tag, List<LoginModuleConfig> loginModuleConfigs) {
    if (!loginModuleConfigs.isEmpty()) {
      gen.open(tag, new Object[0]);
      for (LoginModuleConfig lm : loginModuleConfigs) {
        List<String> attrs = new ArrayList<String>();
        attrs.add("class-name");
        attrs.add(lm.getClassName());
        if (lm.getUsage() != null) {
          attrs.add("usage");
          attrs.add(lm.getUsage().name());
        } 
        gen.open("login-module", attrs.toArray())
          .appendProperties(lm.getProperties())
          .close();
      } 
      gen.close();
    } 
  }
  
  private static void serializationXmlGenerator(XmlGenerator gen, Config config) {
    SerializationConfig c = config.getSerializationConfig();
    if (c == null)
      return; 
    gen.open("serialization", new Object[0])
      .node("portable-version", Integer.valueOf(c.getPortableVersion()), new Object[0])
      .node("use-native-byte-order", Boolean.valueOf(c.isUseNativeByteOrder()), new Object[0])
      .node("byte-order", c.getByteOrder(), new Object[0])
      .node("enable-compression", Boolean.valueOf(c.isEnableCompression()), new Object[0])
      .node("enable-shared-object", Boolean.valueOf(c.isEnableSharedObject()), new Object[0])
      .node("allow-unsafe", Boolean.valueOf(c.isAllowUnsafe()), new Object[0]);
    Map<Integer, String> dsfClasses = c.getDataSerializableFactoryClasses();
    Map<Integer, DataSerializableFactory> dsfImpls = c.getDataSerializableFactories();
    if (!MapUtil.isNullOrEmpty(dsfClasses) || !MapUtil.isNullOrEmpty(dsfImpls)) {
      gen.open("data-serializable-factories", new Object[0]);
      appendSerializationFactory(gen, "data-serializable-factory", dsfClasses);
      appendSerializationFactory(gen, "data-serializable-factory", dsfImpls);
      gen.close();
    } 
    Map<Integer, String> portableClasses = c.getPortableFactoryClasses();
    Map<Integer, PortableFactory> portableImpls = c.getPortableFactories();
    if (!MapUtil.isNullOrEmpty(portableClasses) || !MapUtil.isNullOrEmpty(portableImpls)) {
      gen.open("portable-factories", new Object[0]);
      appendSerializationFactory(gen, "portable-factory", portableClasses);
      appendSerializationFactory(gen, "portable-factory", portableImpls);
      gen.close();
    } 
    Collection<SerializerConfig> serializers = c.getSerializerConfigs();
    GlobalSerializerConfig globalSerializerConfig = c.getGlobalSerializerConfig();
    if (CollectionUtil.isNotEmpty(serializers) || globalSerializerConfig != null) {
      gen.open("serializers", new Object[0]);
      if (globalSerializerConfig != null)
        gen.node("global-serializer", 
            classNameOrImplClass(globalSerializerConfig
              .getClassName(), globalSerializerConfig.getImplementation()), new Object[] { "override-java-serialization", Boolean.valueOf(globalSerializerConfig.isOverrideJavaSerialization()) }); 
      if (CollectionUtil.isNotEmpty(serializers))
        for (SerializerConfig serializer : serializers) {
          gen.node("serializer", null, new Object[] { "type-class", 
                classNameOrClass(serializer.getTypeClassName(), serializer.getTypeClass()), "class-name", 
                classNameOrImplClass(serializer.getClassName(), serializer.getImplementation()) });
        }  
      gen.close();
    } 
    gen.node("check-class-def-errors", Boolean.valueOf(c.isCheckClassDefErrors()), new Object[0]);
    JavaSerializationFilterConfig javaSerializationFilterConfig = c.getJavaSerializationFilterConfig();
    if (javaSerializationFilterConfig != null) {
      gen.open("java-serialization-filter", new Object[] { "defaults-disabled", Boolean.valueOf(javaSerializationFilterConfig.isDefaultsDisabled()) });
      appendFilterList(gen, "blacklist", javaSerializationFilterConfig.getBlacklist());
      appendFilterList(gen, "whitelist", javaSerializationFilterConfig.getWhitelist());
      gen.close();
    } 
    gen.close();
  }
  
  private static String classNameOrClass(String className, Class clazz) {
    return !StringUtil.isNullOrEmpty(className) ? className : ((clazz != null) ? clazz
      .getName() : null);
  }
  
  private static String classNameOrImplClass(String className, Object impl) {
    return !StringUtil.isNullOrEmpty(className) ? className : ((impl != null) ? impl
      .getClass().getName() : null);
  }
  
  private static void partitionGroupXmlGenerator(XmlGenerator gen, Config config) {
    PartitionGroupConfig pg = config.getPartitionGroupConfig();
    if (pg == null)
      return; 
    gen.open("partition-group", new Object[] { "enabled", Boolean.valueOf(pg.isEnabled()), "group-type", pg.getGroupType() });
    Collection<MemberGroupConfig> configs = pg.getMemberGroupConfigs();
    if (CollectionUtil.isNotEmpty(configs))
      for (MemberGroupConfig mgConfig : configs) {
        gen.open("member-group", new Object[0]);
        for (String iface : mgConfig.getInterfaces())
          gen.node("interface", iface, new Object[0]); 
        gen.close();
      }  
    gen.close();
  }
  
  private static void executorXmlGenerator(XmlGenerator gen, Config config) {
    for (ExecutorConfig ex : config.getExecutorConfigs().values()) {
      gen.open("executor-service", new Object[] { "name", ex.getName() }).node("statistics-enabled", Boolean.valueOf(ex.isStatisticsEnabled()), new Object[0])
        .node("pool-size", Integer.valueOf(ex.getPoolSize()), new Object[0])
        .node("queue-capacity", Integer.valueOf(ex.getQueueCapacity()), new Object[0])
        .node("quorum-ref", ex.getQuorumName(), new Object[0])
        .close();
    } 
  }
  
  private static void durableExecutorXmlGenerator(XmlGenerator gen, Config config) {
    for (DurableExecutorConfig ex : config.getDurableExecutorConfigs().values()) {
      gen.open("durable-executor-service", new Object[] { "name", ex.getName() }).node("pool-size", Integer.valueOf(ex.getPoolSize()), new Object[0])
        .node("durability", Integer.valueOf(ex.getDurability()), new Object[0])
        .node("capacity", Integer.valueOf(ex.getCapacity()), new Object[0])
        .node("quorum-ref", ex.getQuorumName(), new Object[0])
        .close();
    } 
  }
  
  private static void scheduledExecutorXmlGenerator(XmlGenerator gen, Config config) {
    for (ScheduledExecutorConfig ex : config.getScheduledExecutorConfigs().values()) {
      MergePolicyConfig mergePolicyConfig = ex.getMergePolicyConfig();
      gen.open("scheduled-executor-service", new Object[] { "name", ex.getName() }).node("pool-size", Integer.valueOf(ex.getPoolSize()), new Object[0])
        .node("durability", Integer.valueOf(ex.getDurability()), new Object[0])
        .node("capacity", Integer.valueOf(ex.getCapacity()), new Object[0])
        .node("quorum-ref", ex.getQuorumName(), new Object[0])
        .node("merge-policy", mergePolicyConfig.getPolicy(), new Object[] { "batch-size", Integer.valueOf(mergePolicyConfig.getBatchSize()) }).close();
    } 
  }
  
  private static void cardinalityEstimatorXmlGenerator(XmlGenerator gen, Config config) {
    for (CardinalityEstimatorConfig ex : config.getCardinalityEstimatorConfigs().values()) {
      MergePolicyConfig mergePolicyConfig = ex.getMergePolicyConfig();
      gen.open("cardinality-estimator", new Object[] { "name", ex.getName() }).node("backup-count", Integer.valueOf(ex.getBackupCount()), new Object[0])
        .node("async-backup-count", Integer.valueOf(ex.getAsyncBackupCount()), new Object[0])
        .node("quorum-ref", ex.getQuorumName(), new Object[0])
        .node("merge-policy", mergePolicyConfig.getPolicy(), new Object[] { "batch-size", Integer.valueOf(mergePolicyConfig.getBatchSize()) }).close();
    } 
  }
  
  private static void pnCounterXmlGenerator(XmlGenerator gen, Config config) {
    for (PNCounterConfig counterConfig : config.getPNCounterConfigs().values()) {
      gen.open("pn-counter", new Object[] { "name", counterConfig.getName() }).node("replica-count", Integer.valueOf(counterConfig.getReplicaCount()), new Object[0])
        .node("quorum-ref", counterConfig.getQuorumName(), new Object[0])
        .node("statistics-enabled", Boolean.valueOf(counterConfig.isStatisticsEnabled()), new Object[0])
        .close();
    } 
  }
  
  private static void semaphoreXmlGenerator(XmlGenerator gen, Config config) {
    for (SemaphoreConfig sc : config.getSemaphoreConfigs()) {
      gen.open("semaphore", new Object[] { "name", sc.getName() }).node("initial-permits", Integer.valueOf(sc.getInitialPermits()), new Object[0])
        .node("backup-count", Integer.valueOf(sc.getBackupCount()), new Object[0])
        .node("async-backup-count", Integer.valueOf(sc.getAsyncBackupCount()), new Object[0])
        .node("quorum-ref", sc.getQuorumName(), new Object[0])
        .close();
    } 
  }
  
  private static void countDownLatchXmlGenerator(XmlGenerator gen, Config config) {
    for (CountDownLatchConfig lc : config.getCountDownLatchConfigs().values()) {
      gen.open("count-down-latch", new Object[] { "name", lc.getName() }).node("quorum-ref", lc.getQuorumName(), new Object[0])
        .close();
    } 
  }
  
  private static void topicXmlGenerator(XmlGenerator gen, Config config) {
    for (TopicConfig t : config.getTopicConfigs().values()) {
      gen.open("topic", new Object[] { "name", t.getName() }).node("statistics-enabled", Boolean.valueOf(t.isStatisticsEnabled()), new Object[0])
        .node("global-ordering-enabled", Boolean.valueOf(t.isGlobalOrderingEnabled()), new Object[0]);
      if (!t.getMessageListenerConfigs().isEmpty()) {
        gen.open("message-listeners", new Object[0]);
        for (ListenerConfig lc : t.getMessageListenerConfigs())
          gen.node("message-listener", classNameOrImplClass(lc.getClassName(), lc.getImplementation()), new Object[0]); 
        gen.close();
      } 
      gen.node("multi-threading-enabled", Boolean.valueOf(t.isMultiThreadingEnabled()), new Object[0]);
      gen.close();
    } 
  }
  
  private static void reliableTopicXmlGenerator(XmlGenerator gen, Config config) {
    for (ReliableTopicConfig t : config.getReliableTopicConfigs().values()) {
      gen.open("reliable-topic", new Object[] { "name", t.getName() }).node("statistics-enabled", Boolean.valueOf(t.isStatisticsEnabled()), new Object[0])
        .node("read-batch-size", Integer.valueOf(t.getReadBatchSize()), new Object[0])
        .node("topic-overload-policy", t.getTopicOverloadPolicy(), new Object[0]);
      if (!t.getMessageListenerConfigs().isEmpty()) {
        gen.open("message-listeners", new Object[0]);
        for (ListenerConfig lc : t.getMessageListenerConfigs())
          gen.node("message-listener", classNameOrImplClass(lc.getClassName(), lc.getImplementation()), new Object[0]); 
        gen.close();
      } 
      gen.close();
    } 
  }
  
  private static void multiMapXmlGenerator(XmlGenerator gen, Config config) {
    for (MultiMapConfig mm : config.getMultiMapConfigs().values()) {
      gen.open("multimap", new Object[] { "name", mm.getName() }).node("backup-count", Integer.valueOf(mm.getBackupCount()), new Object[0])
        .node("async-backup-count", Integer.valueOf(mm.getAsyncBackupCount()), new Object[0])
        .node("statistics-enabled", Boolean.valueOf(mm.isStatisticsEnabled()), new Object[0])
        .node("binary", Boolean.valueOf(mm.isBinary()), new Object[0])
        .node("quorum-ref", mm.getQuorumName(), new Object[0])
        .node("value-collection-type", mm.getValueCollectionType(), new Object[0]);
      entryListenerConfigXmlGenerator(gen, mm.getEntryListenerConfigs());
      MergePolicyConfig mergePolicyConfig = mm.getMergePolicyConfig();
      gen.node("merge-policy", mergePolicyConfig.getPolicy(), new Object[] { "batch-size", Integer.valueOf(mergePolicyConfig.getBatchSize()) }).close();
    } 
  }
  
  private static void queueXmlGenerator(XmlGenerator gen, Config config) {
    Collection<QueueConfig> qCfgs = config.getQueueConfigs().values();
    for (QueueConfig q : qCfgs) {
      gen.open("queue", new Object[] { "name", q.getName() }).node("statistics-enabled", Boolean.valueOf(q.isStatisticsEnabled()), new Object[0])
        .node("max-size", Integer.valueOf(q.getMaxSize()), new Object[0])
        .node("backup-count", Integer.valueOf(q.getBackupCount()), new Object[0])
        .node("async-backup-count", Integer.valueOf(q.getAsyncBackupCount()), new Object[0])
        .node("empty-queue-ttl", Integer.valueOf(q.getEmptyQueueTtl()), new Object[0]);
      appendItemListenerConfigs(gen, q.getItemListenerConfigs());
      QueueStoreConfig storeConfig = q.getQueueStoreConfig();
      if (storeConfig != null)
        gen.open("queue-store", new Object[] { "enabled", Boolean.valueOf(storeConfig.isEnabled()) }).node("class-name", storeConfig.getClassName(), new Object[0])
          .node("factory-class-name", storeConfig.getFactoryClassName(), new Object[0])
          .appendProperties(storeConfig.getProperties())
          .close(); 
      MergePolicyConfig mergePolicyConfig = q.getMergePolicyConfig();
      gen.node("quorum-ref", q.getQuorumName(), new Object[0])
        .node("merge-policy", mergePolicyConfig.getPolicy(), new Object[] { "batch-size", Integer.valueOf(mergePolicyConfig.getBatchSize()) }).close();
    } 
  }
  
  private static void lockXmlGenerator(XmlGenerator gen, Config config) {
    for (LockConfig c : config.getLockConfigs().values()) {
      gen.open("lock", new Object[] { "name", c.getName() }).node("quorum-ref", c.getQuorumName(), new Object[0])
        .close();
    } 
  }
  
  private static void ringbufferXmlGenerator(XmlGenerator gen, Config config) {
    Collection<RingbufferConfig> configs = config.getRingbufferConfigs().values();
    for (RingbufferConfig rbConfig : configs) {
      gen.open("ringbuffer", new Object[] { "name", rbConfig.getName() }).node("capacity", Integer.valueOf(rbConfig.getCapacity()), new Object[0])
        .node("time-to-live-seconds", Integer.valueOf(rbConfig.getTimeToLiveSeconds()), new Object[0])
        .node("backup-count", Integer.valueOf(rbConfig.getBackupCount()), new Object[0])
        .node("async-backup-count", Integer.valueOf(rbConfig.getAsyncBackupCount()), new Object[0])
        .node("quorum-ref", rbConfig.getQuorumName(), new Object[0])
        .node("in-memory-format", rbConfig.getInMemoryFormat(), new Object[0]);
      RingbufferStoreConfig storeConfig = rbConfig.getRingbufferStoreConfig();
      if (storeConfig != null) {
        gen.open("ringbuffer-store", new Object[] { "enabled", Boolean.valueOf(storeConfig.isEnabled()) }).node("class-name", storeConfig.getClassName(), new Object[0])
          .node("factory-class-name", storeConfig.getFactoryClassName(), new Object[0])
          .appendProperties(storeConfig.getProperties());
        gen.close();
      } 
      MergePolicyConfig mergePolicyConfig = rbConfig.getMergePolicyConfig();
      gen.node("merge-policy", mergePolicyConfig.getPolicy(), new Object[] { "batch-size", Integer.valueOf(mergePolicyConfig.getBatchSize()) }).close();
    } 
  }
  
  private static void atomicLongXmlGenerator(XmlGenerator gen, Config config) {
    Collection<AtomicLongConfig> configs = config.getAtomicLongConfigs().values();
    for (AtomicLongConfig atomicLongConfig : configs) {
      MergePolicyConfig mergePolicyConfig = atomicLongConfig.getMergePolicyConfig();
      gen.open("atomic-long", new Object[] { "name", atomicLongConfig.getName() }).node("merge-policy", mergePolicyConfig.getPolicy(), new Object[] { "batch-size", Integer.valueOf(mergePolicyConfig.getBatchSize()) }).node("quorum-ref", atomicLongConfig.getQuorumName(), new Object[0])
        .close();
    } 
  }
  
  private static void atomicReferenceXmlGenerator(XmlGenerator gen, Config config) {
    Collection<AtomicReferenceConfig> configs = config.getAtomicReferenceConfigs().values();
    for (AtomicReferenceConfig atomicReferenceConfig : configs) {
      MergePolicyConfig mergePolicyConfig = atomicReferenceConfig.getMergePolicyConfig();
      gen.open("atomic-reference", new Object[] { "name", atomicReferenceConfig.getName() }).node("merge-policy", mergePolicyConfig.getPolicy(), new Object[] { "batch-size", Integer.valueOf(mergePolicyConfig.getBatchSize()) }).node("quorum-ref", atomicReferenceConfig.getQuorumName(), new Object[0])
        .close();
    } 
  }
  
  private static void wanReplicationXmlGenerator(XmlGenerator gen, Config config) {
    for (WanReplicationConfig wan : config.getWanReplicationConfigs().values()) {
      gen.open("wan-replication", new Object[] { "name", wan.getName() });
      for (WanPublisherConfig p : wan.getWanPublisherConfigs())
        wanReplicationPublisherXmlGenerator(gen, p); 
      WanConsumerConfig consumerConfig = wan.getWanConsumerConfig();
      if (consumerConfig != null)
        wanReplicationConsumerGenerator(gen, consumerConfig); 
      gen.close();
    } 
  }
  
  private static void wanReplicationConsumerGenerator(XmlGenerator gen, WanConsumerConfig consumerConfig) {
    gen.open("wan-consumer", new Object[0]);
    String consumerClassName = classNameOrImplClass(consumerConfig
        .getClassName(), consumerConfig.getImplementation());
    if (consumerClassName != null)
      gen.node("class-name", consumerClassName, new Object[0]); 
    gen.node("persist-wan-replicated-data", Boolean.valueOf(consumerConfig.isPersistWanReplicatedData()), new Object[0])
      .appendProperties(consumerConfig.getProperties())
      .close();
  }
  
  private static void wanReplicationPublisherXmlGenerator(XmlGenerator gen, WanPublisherConfig p) {
    String publisherId = !StringUtil.isNullOrEmptyAfterTrim(p.getPublisherId()) ? p.getPublisherId() : "";
    gen.open("wan-publisher", new Object[] { "group-name", p.getGroupName(), "publisher-id", publisherId }).node("class-name", p.getClassName(), new Object[0])
      .node("queue-full-behavior", p.getQueueFullBehavior(), new Object[0])
      .node("initial-publisher-state", p.getInitialPublisherState(), new Object[0])
      .node("queue-capacity", Integer.valueOf(p.getQueueCapacity()), new Object[0])
      .appendProperties(p.getProperties());
    if (p.getEndpoint() != null)
      gen.node("endpoint", p.getEndpoint(), new Object[0]); 
    wanReplicationSyncGenerator(gen, p.getWanSyncConfig());
    aliasedDiscoveryConfigsGenerator(gen, AliasedDiscoveryConfigUtils.aliasedDiscoveryConfigsFrom(p));
    discoveryStrategyConfigXmlGenerator(gen, p.getDiscoveryConfig());
    gen.close();
  }
  
  private static void wanReplicationSyncGenerator(XmlGenerator gen, WanSyncConfig c) { gen.open("wan-sync", new Object[0])
      .node("consistency-check-strategy", c.getConsistencyCheckStrategy(), new Object[0])
      .close(); }
  
  private static void merkleTreeXmlGenerator(XmlGenerator gen, Config config) {
    Collection<MerkleTreeConfig> mapMerkleTreeConfigs = config.getMapMerkleTreeConfigs().values();
    for (MerkleTreeConfig c : mapMerkleTreeConfigs) {
      gen.open("merkle-tree", new Object[] { "enabled", Boolean.valueOf(c.isEnabled()) }).node("mapName", c.getMapName(), new Object[0])
        .node("depth", Integer.valueOf(c.getDepth()), new Object[0])
        .close();
    } 
  }
  
  private void networkConfigXmlGenerator(XmlGenerator gen, Config config) {
    if (config.getAdvancedNetworkConfig().isEnabled())
      return; 
    NetworkConfig netCfg = config.getNetworkConfig();
    gen.open("network", new Object[0])
      .node("public-address", netCfg.getPublicAddress(), new Object[0])
      .node("port", Integer.valueOf(netCfg.getPort()), new Object[] { "port-count", 
          Integer.valueOf(netCfg.getPortCount()), "auto-increment", 
          Boolean.valueOf(netCfg.isPortAutoIncrement()) }).node("reuse-address", Boolean.valueOf(netCfg.isReuseAddress()), new Object[0]);
    Collection<String> outboundPortDefinitions = netCfg.getOutboundPortDefinitions();
    if (CollectionUtil.isNotEmpty(outboundPortDefinitions)) {
      gen.open("outbound-ports", new Object[0]);
      for (String def : outboundPortDefinitions)
        gen.node("ports", def, new Object[0]); 
      gen.close();
    } 
    JoinConfig join = netCfg.getJoin();
    gen.open("join", new Object[0]);
    multicastConfigXmlGenerator(gen, join);
    tcpConfigXmlGenerator(gen, join);
    aliasedDiscoveryConfigsGenerator(gen, AliasedDiscoveryConfigUtils.aliasedDiscoveryConfigsFrom(join));
    discoveryStrategyConfigXmlGenerator(gen, join.getDiscoveryConfig());
    gen.close();
    interfacesConfigXmlGenerator(gen, netCfg.getInterfaces());
    sslConfigXmlGenerator(gen, netCfg.getSSLConfig());
    socketInterceptorConfigXmlGenerator(gen, netCfg.getSocketInterceptorConfig());
    symmetricEncInterceptorConfigXmlGenerator(gen, netCfg.getSymmetricEncryptionConfig());
    memberAddressProviderConfigXmlGenerator(gen, netCfg.getMemberAddressProviderConfig());
    failureDetectorConfigXmlGenerator(gen, netCfg.getIcmpFailureDetectorConfig());
    restApiXmlGenerator(gen, netCfg);
    memcacheProtocolXmlGenerator(gen, netCfg);
    gen.close();
  }
  
  private void advancedNetworkConfigXmlGenerator(XmlGenerator gen, Config config) {
    AdvancedNetworkConfig netCfg = config.getAdvancedNetworkConfig();
    if (!netCfg.isEnabled())
      return; 
    gen.open("advanced-network", new Object[] { "enabled", Boolean.valueOf(netCfg.isEnabled()) });
    JoinConfig join = netCfg.getJoin();
    gen.open("join", new Object[0]);
    multicastConfigXmlGenerator(gen, join);
    tcpConfigXmlGenerator(gen, join);
    aliasedDiscoveryConfigsGenerator(gen, AliasedDiscoveryConfigUtils.aliasedDiscoveryConfigsFrom(join));
    discoveryStrategyConfigXmlGenerator(gen, join.getDiscoveryConfig());
    gen.close();
    failureDetectorConfigXmlGenerator(gen, netCfg.getIcmpFailureDetectorConfig());
    memberAddressProviderConfigXmlGenerator(gen, netCfg.getMemberAddressProviderConfig());
    for (EndpointConfig endpointConfig : netCfg.getEndpointConfigs().values())
      endpointConfigXmlGenerator(gen, endpointConfig); 
    gen.close();
  }
  
  private void endpointConfigXmlGenerator(XmlGenerator gen, EndpointConfig endpointConfig) {
    if (endpointConfig.getName() != null) {
      gen.open(endpointConfigElementName(endpointConfig), new Object[] { "name", endpointConfig.getName() });
    } else {
      gen.open(endpointConfigElementName(endpointConfig), new Object[0]);
    } 
    Collection<String> outboundPortDefinitions = endpointConfig.getOutboundPortDefinitions();
    if (CollectionUtil.isNotEmpty(outboundPortDefinitions)) {
      gen.open("outbound-ports", new Object[0]);
      for (String def : outboundPortDefinitions)
        gen.node("ports", def, new Object[0]); 
      gen.close();
    } 
    interfacesConfigXmlGenerator(gen, endpointConfig.getInterfaces());
    sslConfigXmlGenerator(gen, endpointConfig.getSSLConfig());
    socketInterceptorConfigXmlGenerator(gen, endpointConfig.getSocketInterceptorConfig());
    symmetricEncInterceptorConfigXmlGenerator(gen, endpointConfig.getSymmetricEncryptionConfig());
    if (endpointConfig instanceof RestServerEndpointConfig) {
      RestServerEndpointConfig rsec = (RestServerEndpointConfig)endpointConfig;
      gen.open("endpoint-groups", new Object[0]);
      for (RestEndpointGroup group : RestEndpointGroup.values()) {
        gen.node("endpoint-group", null, new Object[] { "name", group.name(), "enabled", 
              Boolean.valueOf(rsec.isGroupEnabled(group)) });
      } 
      gen.close();
    } 
    gen.open("socket-options", new Object[0]);
    gen.node("buffer-direct", Boolean.valueOf(endpointConfig.isSocketBufferDirect()), new Object[0]);
    gen.node("tcp-no-delay", Boolean.valueOf(endpointConfig.isSocketTcpNoDelay()), new Object[0]);
    gen.node("keep-alive", Boolean.valueOf(endpointConfig.isSocketKeepAlive()), new Object[0]);
    gen.node("connect-timeout-seconds", Integer.valueOf(endpointConfig.getSocketConnectTimeoutSeconds()), new Object[0]);
    gen.node("send-buffer-size-kb", Integer.valueOf(endpointConfig.getSocketSendBufferSizeKb()), new Object[0]);
    gen.node("receive-buffer-size-kb", Integer.valueOf(endpointConfig.getSocketRcvBufferSizeKb()), new Object[0]);
    gen.node("linger-seconds", Integer.valueOf(endpointConfig.getSocketLingerSeconds()), new Object[0]);
    gen.close();
    if (endpointConfig instanceof ServerSocketEndpointConfig) {
      ServerSocketEndpointConfig serverSocketEndpointConfig = (ServerSocketEndpointConfig)endpointConfig;
      gen.node("port", Integer.valueOf(serverSocketEndpointConfig.getPort()), new Object[] { "port-count", 
            Integer.valueOf(serverSocketEndpointConfig.getPortCount()), "auto-increment", 
            Boolean.valueOf(serverSocketEndpointConfig.isPortAutoIncrement()) }).node("public-address", serverSocketEndpointConfig.getPublicAddress(), new Object[0])
        .node("reuse-address", Boolean.valueOf(serverSocketEndpointConfig.isReuseAddress()), new Object[0]);
    } 
    gen.close();
  }
  
  private String endpointConfigElementName(EndpointConfig endpointConfig) {
    if (endpointConfig instanceof ServerSocketEndpointConfig) {
      switch (null.$SwitchMap$com$hazelcast$instance$ProtocolType[endpointConfig.getProtocolType().ordinal()]) {
        case 1:
          return "rest-server-socket-endpoint-config";
        case 2:
          return "wan-server-socket-endpoint-config";
        case 3:
          return "client-server-socket-endpoint-config";
        case 4:
          return "member-server-socket-endpoint-config";
        case 5:
          return "memcache-server-socket-endpoint-config";
      } 
      throw new IllegalStateException("Not recognised protocol type");
    } 
    return "wan-endpoint-config";
  }
  
  private static void mapConfigXmlGenerator(XmlGenerator gen, Config config) {
    Collection<MapConfig> mapConfigs = config.getMapConfigs().values();
    for (MapConfig m : mapConfigs) {
      String cacheDeserializedVal = (m.getCacheDeserializedValues() != null) ? m.getCacheDeserializedValues().name().replaceAll("_", "-") : null;
      MergePolicyConfig mergePolicyConfig = m.getMergePolicyConfig();
      gen.open("map", new Object[] { "name", m.getName() }).node("in-memory-format", m.getInMemoryFormat(), new Object[0])
        .node("statistics-enabled", Boolean.valueOf(m.isStatisticsEnabled()), new Object[0])
        .node("cache-deserialized-values", cacheDeserializedVal, new Object[0])
        .node("backup-count", Integer.valueOf(m.getBackupCount()), new Object[0])
        .node("async-backup-count", Integer.valueOf(m.getAsyncBackupCount()), new Object[0])
        .node("time-to-live-seconds", Integer.valueOf(m.getTimeToLiveSeconds()), new Object[0])
        .node("max-idle-seconds", Integer.valueOf(m.getMaxIdleSeconds()), new Object[0])
        .node("eviction-policy", m.getEvictionPolicy(), new Object[0])
        .node("max-size", Integer.valueOf(m.getMaxSizeConfig().getSize()), new Object[] { "policy", m.getMaxSizeConfig().getMaxSizePolicy() }).node("eviction-percentage", Integer.valueOf(m.getEvictionPercentage()), new Object[0])
        .node("min-eviction-check-millis", Long.valueOf(m.getMinEvictionCheckMillis()), new Object[0])
        .node("merge-policy", mergePolicyConfig.getPolicy(), new Object[] { "batch-size", Integer.valueOf(mergePolicyConfig.getBatchSize()) }).node("quorum-ref", m.getQuorumName(), new Object[0])
        .node("read-backup-data", Boolean.valueOf(m.isReadBackupData()), new Object[0])
        .node("metadata-policy", m.getMetadataPolicy(), new Object[0]);
      appendHotRestartConfig(gen, m.getHotRestartConfig());
      mapStoreConfigXmlGenerator(gen, m);
      mapNearCacheConfigXmlGenerator(gen, m.getNearCacheConfig());
      wanReplicationConfigXmlGenerator(gen, m.getWanReplicationRef());
      mapIndexConfigXmlGenerator(gen, m);
      mapAttributeConfigXmlGenerator(gen, m);
      entryListenerConfigXmlGenerator(gen, m);
      mapPartitionLostListenerConfigXmlGenerator(gen, m);
      mapPartitionStrategyConfigXmlGenerator(gen, m);
      mapQueryCachesConfigXmlGenerator(gen, m);
      gen.close();
    } 
  }
  
  private static void appendHotRestartConfig(XmlGenerator gen, HotRestartConfig m) { gen.open("hot-restart", new Object[] { "enabled", Boolean.valueOf((m != null && m.isEnabled())) }).node("fsync", Boolean.valueOf((m != null && m.isFsync())), new Object[0])
      .close(); }
  
  private static void cacheConfigXmlGenerator(XmlGenerator gen, Config config) {
    for (CacheSimpleConfig c : config.getCacheConfigs().values()) {
      gen.open("cache", new Object[] { "name", c.getName() });
      if (c.getKeyType() != null)
        gen.node("key-type", null, new Object[] { "class-name", c.getKeyType() }); 
      if (c.getValueType() != null)
        gen.node("value-type", null, new Object[] { "class-name", c.getValueType() }); 
      gen.node("statistics-enabled", Boolean.valueOf(c.isStatisticsEnabled()), new Object[0])
        .node("management-enabled", Boolean.valueOf(c.isManagementEnabled()), new Object[0])
        .node("read-through", Boolean.valueOf(c.isReadThrough()), new Object[0])
        .node("write-through", Boolean.valueOf(c.isWriteThrough()), new Object[0]);
      checkAndFillCacheLoaderFactoryConfigXml(gen, c.getCacheLoaderFactory());
      checkAndFillCacheLoaderConfigXml(gen, c.getCacheLoader());
      checkAndFillCacheWriterFactoryConfigXml(gen, c.getCacheWriterFactory());
      checkAndFillCacheWriterConfigXml(gen, c.getCacheWriter());
      cacheExpiryPolicyFactoryConfigXmlGenerator(gen, c.getExpiryPolicyFactoryConfig());
      gen.open("cache-entry-listeners", new Object[0]);
      for (CacheSimpleEntryListenerConfig el : c.getCacheEntryListeners()) {
        gen.open("cache-entry-listener", new Object[] { "old-value-required", 
              Boolean.valueOf(el.isOldValueRequired()), "synchronous", 
              Boolean.valueOf(el.isSynchronous()) }).node("cache-entry-listener-factory", null, new Object[] { "class-name", el.getCacheEntryListenerFactory() }).node("cache-entry-event-filter-factory", null, new Object[] { "class-name", el.getCacheEntryEventFilterFactory() }).close();
      } 
      gen.close()
        .node("in-memory-format", c.getInMemoryFormat(), new Object[0])
        .node("backup-count", Integer.valueOf(c.getBackupCount()), new Object[0])
        .node("async-backup-count", Integer.valueOf(c.getAsyncBackupCount()), new Object[0]);
      evictionConfigXmlGenerator(gen, c.getEvictionConfig());
      wanReplicationConfigXmlGenerator(gen, c.getWanReplicationRef());
      gen.node("quorum-ref", c.getQuorumName(), new Object[0]);
      cachePartitionLostListenerConfigXmlGenerator(gen, c.getPartitionLostListenerConfigs());
      gen.node("merge-policy", c.getMergePolicy(), new Object[0]);
      appendHotRestartConfig(gen, c.getHotRestartConfig());
      gen.node("disable-per-entry-invalidation-events", Boolean.valueOf(c.isDisablePerEntryInvalidationEvents()), new Object[0])
        .close();
    } 
  }
  
  private static void checkAndFillCacheWriterFactoryConfigXml(XmlGenerator gen, String cacheWriter) {
    if (StringUtil.isNullOrEmpty(cacheWriter))
      return; 
    gen.node("cache-writer-factory", null, new Object[] { "class-name", cacheWriter });
  }
  
  private static void checkAndFillCacheWriterConfigXml(XmlGenerator gen, String cacheWriter) {
    if (StringUtil.isNullOrEmpty(cacheWriter))
      return; 
    gen.node("cache-writer", null, new Object[] { "class-name", cacheWriter });
  }
  
  private static void checkAndFillCacheLoaderFactoryConfigXml(XmlGenerator gen, String cacheLoader) {
    if (StringUtil.isNullOrEmpty(cacheLoader))
      return; 
    gen.node("cache-loader-factory", null, new Object[] { "class-name", cacheLoader });
  }
  
  private static void checkAndFillCacheLoaderConfigXml(XmlGenerator gen, String cacheLoader) {
    if (StringUtil.isNullOrEmpty(cacheLoader))
      return; 
    gen.node("cache-loader", null, new Object[] { "class-name", cacheLoader });
  }
  
  private static void cacheExpiryPolicyFactoryConfigXmlGenerator(XmlGenerator gen, CacheSimpleConfig.ExpiryPolicyFactoryConfig config) {
    if (config == null)
      return; 
    if (!StringUtil.isNullOrEmpty(config.getClassName())) {
      gen.node("expiry-policy-factory", null, new Object[] { "class-name", config.getClassName() });
    } else {
      CacheSimpleConfig.ExpiryPolicyFactoryConfig.TimedExpiryPolicyFactoryConfig timedConfig = config.getTimedExpiryPolicyFactoryConfig();
      if (timedConfig != null && timedConfig.getExpiryPolicyType() != null && timedConfig.getDurationConfig() != null) {
        CacheSimpleConfig.ExpiryPolicyFactoryConfig.DurationConfig duration = timedConfig.getDurationConfig();
        gen.open("expiry-policy-factory", new Object[0])
          .node("timed-expiry-policy-factory", null, new Object[] { "expiry-policy-type", timedConfig.getExpiryPolicyType(), "duration-amount", 
              Long.valueOf(duration.getDurationAmount()), "time-unit", duration
              .getTimeUnit().name() }).close();
      } 
    } 
  }
  
  private static void cachePartitionLostListenerConfigXmlGenerator(XmlGenerator gen, List<CachePartitionLostListenerConfig> configs) {
    if (configs.isEmpty())
      return; 
    gen.open("partition-lost-listeners", new Object[0]);
    for (CachePartitionLostListenerConfig c : configs)
      gen.node("partition-lost-listener", classNameOrImplClass(c.getClassName(), c.getImplementation()), new Object[0]); 
    gen.close();
  }
  
  private static void mapPartitionStrategyConfigXmlGenerator(XmlGenerator gen, MapConfig m) {
    if (m.getPartitioningStrategyConfig() != null) {
      PartitioningStrategyConfig psc = m.getPartitioningStrategyConfig();
      gen.node("partition-strategy", 
          classNameOrImplClass(psc.getPartitioningStrategyClass(), psc.getPartitioningStrategy()), new Object[0]);
    } 
  }
  
  private static void mapQueryCachesConfigXmlGenerator(XmlGenerator gen, MapConfig mapConfig) {
    List<QueryCacheConfig> queryCacheConfigs = mapConfig.getQueryCacheConfigs();
    if (queryCacheConfigs != null && !queryCacheConfigs.isEmpty()) {
      gen.open("query-caches", new Object[0]);
      for (QueryCacheConfig queryCacheConfig : queryCacheConfigs) {
        gen.open("query-cache", new Object[] { "name", queryCacheConfig.getName() });
        gen.node("include-value", Boolean.valueOf(queryCacheConfig.isIncludeValue()), new Object[0]);
        gen.node("in-memory-format", queryCacheConfig.getInMemoryFormat(), new Object[0]);
        gen.node("populate", Boolean.valueOf(queryCacheConfig.isPopulate()), new Object[0]);
        gen.node("coalesce", Boolean.valueOf(queryCacheConfig.isCoalesce()), new Object[0]);
        gen.node("delay-seconds", Integer.valueOf(queryCacheConfig.getDelaySeconds()), new Object[0]);
        gen.node("batch-size", Integer.valueOf(queryCacheConfig.getBatchSize()), new Object[0]);
        gen.node("buffer-size", Integer.valueOf(queryCacheConfig.getBufferSize()), new Object[0]);
        evictionConfigXmlGenerator(gen, queryCacheConfig.getEvictionConfig());
        mapIndexConfigXmlGenerator(gen, queryCacheConfig.getIndexConfigs());
        mapQueryCachePredicateConfigXmlGenerator(gen, queryCacheConfig);
        entryListenerConfigXmlGenerator(gen, queryCacheConfig.getEntryListenerConfigs());
        gen.close();
      } 
      gen.close();
    } 
  }
  
  private static void mapQueryCachePredicateConfigXmlGenerator(XmlGenerator gen, QueryCacheConfig queryCacheConfig) {
    PredicateConfig predicateConfig = queryCacheConfig.getPredicateConfig();
    String type = (predicateConfig.getClassName() != null) ? "class-name" : "sql";
    String content = (predicateConfig.getClassName() != null) ? predicateConfig.getClassName() : predicateConfig.getSql();
    gen.node("predicate", content, new Object[] { "type", type });
  }
  
  private static void entryListenerConfigXmlGenerator(XmlGenerator gen, MapConfig m) { entryListenerConfigXmlGenerator(gen, m.getEntryListenerConfigs()); }
  
  private static void entryListenerConfigXmlGenerator(XmlGenerator gen, List<EntryListenerConfig> entryListenerConfigs) {
    if (!entryListenerConfigs.isEmpty()) {
      gen.open("entry-listeners", new Object[0]);
      for (EntryListenerConfig lc : entryListenerConfigs) {
        gen.node("entry-listener", classNameOrImplClass(lc.getClassName(), lc.getImplementation()), new Object[] { "include-value", 
              Boolean.valueOf(lc.isIncludeValue()), "local", Boolean.valueOf(lc.isLocal()) });
      } 
      gen.close();
    } 
  }
  
  private static void mapPartitionLostListenerConfigXmlGenerator(XmlGenerator gen, MapConfig m) {
    if (!m.getPartitionLostListenerConfigs().isEmpty()) {
      gen.open("partition-lost-listeners", new Object[0]);
      for (MapPartitionLostListenerConfig c : m.getPartitionLostListenerConfigs())
        gen.node("partition-lost-listener", 
            classNameOrImplClass(c.getClassName(), c.getImplementation()), new Object[0]); 
      gen.close();
    } 
  }
  
  private static void mapIndexConfigXmlGenerator(XmlGenerator gen, MapConfig m) { mapIndexConfigXmlGenerator(gen, m.getMapIndexConfigs()); }
  
  private static void mapIndexConfigXmlGenerator(XmlGenerator gen, List<MapIndexConfig> mapIndexConfigs) {
    if (!mapIndexConfigs.isEmpty()) {
      gen.open("indexes", new Object[0]);
      for (MapIndexConfig indexCfg : mapIndexConfigs) {
        gen.node("index", indexCfg.getAttribute(), new Object[] { "ordered", Boolean.valueOf(indexCfg.isOrdered()) });
      } 
      gen.close();
    } 
  }
  
  private static void mapAttributeConfigXmlGenerator(XmlGenerator gen, MapConfig m) {
    if (!m.getMapAttributeConfigs().isEmpty()) {
      gen.open("attributes", new Object[0]);
      for (MapAttributeConfig attributeCfg : m.getMapAttributeConfigs()) {
        gen.node("attribute", attributeCfg.getName(), new Object[] { "extractor", attributeCfg.getExtractor() });
      } 
      gen.close();
    } 
  }
  
  private static void wanReplicationConfigXmlGenerator(XmlGenerator gen, WanReplicationRef wan) {
    if (wan != null) {
      gen.open("wan-replication-ref", new Object[] { "name", wan.getName() });
      String mergePolicy = wan.getMergePolicy();
      if (!StringUtil.isNullOrEmpty(mergePolicy))
        gen.node("merge-policy", mergePolicy, new Object[0]); 
      List<String> filters = wan.getFilters();
      if (CollectionUtil.isNotEmpty(filters)) {
        gen.open("filters", new Object[0]);
        for (String f : filters)
          gen.node("filter-impl", f, new Object[0]); 
        gen.close();
      } 
      gen.node("republishing-enabled", Boolean.valueOf(wan.isRepublishingEnabled()), new Object[0])
        .close();
    } 
  }
  
  private static void mapStoreConfigXmlGenerator(XmlGenerator gen, MapConfig m) {
    if (m.getMapStoreConfig() != null) {
      MapStoreConfig s = m.getMapStoreConfig();
      String clazz = (s.getImplementation() != null) ? s.getImplementation().getClass().getName() : s.getClassName();
      String factoryClass = (s.getFactoryImplementation() != null) ? s.getFactoryImplementation().getClass().getName() : s.getFactoryClassName();
      MapStoreConfig.InitialLoadMode initialMode = s.getInitialLoadMode();
      gen.open("map-store", new Object[] { "enabled", Boolean.valueOf(s.isEnabled()), "initial-mode", initialMode.toString() }).node("class-name", clazz, new Object[0])
        .node("factory-class-name", factoryClass, new Object[0])
        .node("write-delay-seconds", Integer.valueOf(s.getWriteDelaySeconds()), new Object[0])
        .node("write-batch-size", Integer.valueOf(s.getWriteBatchSize()), new Object[0])
        .appendProperties(s.getProperties())
        .close();
    } 
  }
  
  private static void mapNearCacheConfigXmlGenerator(XmlGenerator gen, NearCacheConfig n) {
    if (n != null) {
      if (n.getName() != null) {
        gen.open("near-cache", new Object[] { "name", n.getName() });
      } else {
        gen.open("near-cache", new Object[0]);
      } 
      gen.node("in-memory-format", n.getInMemoryFormat(), new Object[0])
        .node("invalidate-on-change", Boolean.valueOf(n.isInvalidateOnChange()), new Object[0])
        .node("time-to-live-seconds", Integer.valueOf(n.getTimeToLiveSeconds()), new Object[0])
        .node("max-idle-seconds", Integer.valueOf(n.getMaxIdleSeconds()), new Object[0])
        .node("serialize-keys", Boolean.valueOf(n.isSerializeKeys()), new Object[0])
        .node("cache-local-entries", Boolean.valueOf(n.isCacheLocalEntries()), new Object[0])
        .node("max-size", Integer.valueOf(n.getMaxSize()), new Object[0])
        .node("eviction-policy", n.getEvictionPolicy(), new Object[0]);
      evictionConfigXmlGenerator(gen, n.getEvictionConfig());
      gen.close();
    } 
  }
  
  private static void evictionConfigXmlGenerator(XmlGenerator gen, EvictionConfig e) {
    if (e == null)
      return; 
    String comparatorClassName = !StringUtil.isNullOrEmpty(e.getComparatorClassName()) ? e.getComparatorClassName() : null;
    gen.node("eviction", null, new Object[] { "size", 
          Integer.valueOf(e.getSize()), "max-size-policy", e
          .getMaximumSizePolicy(), "eviction-policy", e
          .getEvictionPolicy(), "comparator-class-name", comparatorClassName });
  }
  
  private static void multicastConfigXmlGenerator(XmlGenerator gen, JoinConfig join) {
    MulticastConfig mcConfig = join.getMulticastConfig();
    gen.open("multicast", new Object[] { "enabled", Boolean.valueOf(mcConfig.isEnabled()), "loopbackModeEnabled", Boolean.valueOf(mcConfig.isLoopbackModeEnabled()) }).node("multicast-group", mcConfig.getMulticastGroup(), new Object[0])
      .node("multicast-port", Integer.valueOf(mcConfig.getMulticastPort()), new Object[0])
      .node("multicast-timeout-seconds", Integer.valueOf(mcConfig.getMulticastTimeoutSeconds()), new Object[0])
      .node("multicast-time-to-live", Integer.valueOf(mcConfig.getMulticastTimeToLive()), new Object[0]);
    if (!mcConfig.getTrustedInterfaces().isEmpty()) {
      gen.open("trusted-interfaces", new Object[0]);
      for (String trustedInterface : mcConfig.getTrustedInterfaces())
        gen.node("interface", trustedInterface, new Object[0]); 
      gen.close();
    } 
    gen.close();
  }
  
  private static void tcpConfigXmlGenerator(XmlGenerator gen, JoinConfig join) {
    TcpIpConfig c = join.getTcpIpConfig();
    gen.open("tcp-ip", new Object[] { "enabled", Boolean.valueOf(c.isEnabled()), "connection-timeout-seconds", Integer.valueOf(c.getConnectionTimeoutSeconds()) }).open("member-list", new Object[0]);
    for (String m : c.getMembers())
      gen.node("member", m, new Object[0]); 
    gen.close()
      .node("required-member", c.getRequiredMember(), new Object[0])
      .close();
  }
  
  private static void aliasedDiscoveryConfigsGenerator(XmlGenerator gen, List<AliasedDiscoveryConfig<?>> configs) {
    if (configs == null)
      return; 
    for (AliasedDiscoveryConfig<?> c : configs) {
      gen.open(AliasedDiscoveryConfigUtils.tagFor(c), new Object[] { "enabled", Boolean.valueOf(c.isEnabled()) });
      if (c.isUsePublicIp())
        gen.node("use-public-ip", "true", new Object[0]); 
      for (String key : c.getProperties().keySet())
        gen.node(key, c.getProperties().get(key), new Object[0]); 
      gen.close();
    } 
  }
  
  private static void discoveryStrategyConfigXmlGenerator(XmlGenerator gen, DiscoveryConfig c) {
    if (c == null)
      return; 
    gen.open("discovery-strategies", new Object[0]);
    String nodeFilterClass = classNameOrImplClass(c.getNodeFilterClass(), c.getNodeFilter());
    if (nodeFilterClass != null)
      gen.node("node-filter", null, new Object[] { "class", nodeFilterClass }); 
    Collection<DiscoveryStrategyConfig> configs = c.getDiscoveryStrategyConfigs();
    if (CollectionUtil.isNotEmpty(configs))
      for (DiscoveryStrategyConfig config : configs) {
        gen.open("discovery-strategy", new Object[] { "class", 
              classNameOrImplClass(config.getClassName(), config.getDiscoveryStrategyFactory()), "enabled", "true" }).appendProperties(config.getProperties())
          .close();
      }  
    gen.close();
  }
  
  private static void interfacesConfigXmlGenerator(XmlGenerator gen, InterfacesConfig interfaces) {
    gen.open("interfaces", new Object[] { "enabled", Boolean.valueOf(interfaces.isEnabled()) });
    for (String i : interfaces.getInterfaces())
      gen.node("interface", i, new Object[0]); 
    gen.close();
  }
  
  private void sslConfigXmlGenerator(XmlGenerator gen, SSLConfig ssl) {
    gen.open("ssl", new Object[] { "enabled", Boolean.valueOf((ssl != null && ssl.isEnabled())) });
    if (ssl != null) {
      Properties props = new Properties();
      props.putAll(ssl.getProperties());
      if (this.maskSensitiveFields && props.containsKey("trustStorePassword"))
        props.setProperty("trustStorePassword", "****"); 
      if (this.maskSensitiveFields && props.containsKey("keyStorePassword"))
        props.setProperty("keyStorePassword", "****"); 
      gen.node("factory-class-name", 
          classNameOrImplClass(ssl.getFactoryClassName(), ssl.getFactoryImplementation()), new Object[0])
        .appendProperties(props);
    } 
    gen.close();
  }
  
  private void mcMutualAuthConfigXmlGenerator(XmlGenerator gen, ManagementCenterConfig mcConfig) {
    MCMutualAuthConfig mutualAuthConfig = mcConfig.getMutualAuthConfig();
    gen.open("mutual-auth", new Object[] { "enabled", Boolean.valueOf((mutualAuthConfig != null && mutualAuthConfig.isEnabled())) });
    if (mutualAuthConfig != null) {
      Properties props = new Properties();
      props.putAll(mutualAuthConfig.getProperties());
      if (this.maskSensitiveFields && props.containsKey("trustStorePassword"))
        props.setProperty("trustStorePassword", "****"); 
      if (this.maskSensitiveFields && props.containsKey("keyStorePassword"))
        props.setProperty("keyStorePassword", "****"); 
      gen.node("factory-class-name", 
          classNameOrImplClass(mutualAuthConfig.getFactoryClassName(), mutualAuthConfig.getFactoryImplementation()), new Object[0])
        .appendProperties(props);
    } 
    gen.close();
  }
  
  private static void socketInterceptorConfigXmlGenerator(XmlGenerator gen, SocketInterceptorConfig socket) {
    gen.open("socket-interceptor", new Object[] { "enabled", Boolean.valueOf((socket != null && socket.isEnabled())) });
    if (socket != null)
      gen.node("class-name", classNameOrImplClass(socket.getClassName(), socket.getImplementation()), new Object[0])
        .appendProperties(socket.getProperties()); 
    gen.close();
  }
  
  private void symmetricEncInterceptorConfigXmlGenerator(XmlGenerator gen, SymmetricEncryptionConfig sec) {
    if (sec == null)
      return; 
    gen.open("symmetric-encryption", new Object[] { "enabled", Boolean.valueOf(sec.isEnabled()) }).node("algorithm", sec.getAlgorithm(), new Object[0])
      .node("salt", getOrMaskValue(sec.getSalt()), new Object[0])
      .node("password", getOrMaskValue(sec.getPassword()), new Object[0])
      .node("iteration-count", Integer.valueOf(sec.getIterationCount()), new Object[0])
      .close();
  }
  
  private static void memberAddressProviderConfigXmlGenerator(XmlGenerator gen, MemberAddressProviderConfig memberAddressProviderConfig) {
    if (memberAddressProviderConfig == null)
      return; 
    String className = classNameOrImplClass(memberAddressProviderConfig.getClassName(), memberAddressProviderConfig
        .getImplementation());
    if (StringUtil.isNullOrEmpty(className))
      return; 
    gen.open("member-address-provider", new Object[] { "enabled", Boolean.valueOf(memberAddressProviderConfig.isEnabled()) }).node("class-name", className, new Object[0])
      .appendProperties(memberAddressProviderConfig.getProperties())
      .close();
  }
  
  private static void failureDetectorConfigXmlGenerator(XmlGenerator gen, IcmpFailureDetectorConfig icmpFailureDetectorConfig) {
    if (icmpFailureDetectorConfig == null)
      return; 
    gen.open("failure-detector", new Object[0]);
    gen.open("icmp", new Object[] { "enabled", Boolean.valueOf(icmpFailureDetectorConfig.isEnabled()) }).node("ttl", Integer.valueOf(icmpFailureDetectorConfig.getTtl()), new Object[0])
      .node("interval-milliseconds", Integer.valueOf(icmpFailureDetectorConfig.getIntervalMilliseconds()), new Object[0])
      .node("max-attempts", Integer.valueOf(icmpFailureDetectorConfig.getMaxAttempts()), new Object[0])
      .node("timeout-milliseconds", Integer.valueOf(icmpFailureDetectorConfig.getTimeoutMilliseconds()), new Object[0])
      .node("fail-fast-on-startup", Boolean.valueOf(icmpFailureDetectorConfig.isFailFastOnStartup()), new Object[0])
      .node("parallel-mode", Boolean.valueOf(icmpFailureDetectorConfig.isParallelMode()), new Object[0])
      .close();
    gen.close();
  }
  
  private static void hotRestartXmlGenerator(XmlGenerator gen, Config config) {
    HotRestartPersistenceConfig hrCfg = config.getHotRestartPersistenceConfig();
    if (hrCfg == null) {
      gen.node("hot-restart-persistence", "enabled", new Object[] { "false" });
      return;
    } 
    gen.open("hot-restart-persistence", new Object[] { "enabled", Boolean.valueOf(hrCfg.isEnabled()) }).node("base-dir", hrCfg.getBaseDir().getAbsolutePath(), new Object[0]);
    if (hrCfg.getBackupDir() != null)
      gen.node("backup-dir", hrCfg.getBackupDir().getAbsolutePath(), new Object[0]); 
    gen.node("parallelism", Integer.valueOf(hrCfg.getParallelism()), new Object[0])
      .node("validation-timeout-seconds", Integer.valueOf(hrCfg.getValidationTimeoutSeconds()), new Object[0])
      .node("data-load-timeout-seconds", Integer.valueOf(hrCfg.getDataLoadTimeoutSeconds()), new Object[0])
      .node("cluster-data-recovery-policy", hrCfg.getClusterDataRecoveryPolicy(), new Object[0])
      .node("auto-remove-stale-data", Boolean.valueOf(hrCfg.isAutoRemoveStaleData()), new Object[0])
      .close();
  }
  
  private static void flakeIdGeneratorXmlGenerator(XmlGenerator gen, Config config) {
    for (FlakeIdGeneratorConfig m : config.getFlakeIdGeneratorConfigs().values()) {
      gen.open("flake-id-generator", new Object[] { "name", m.getName() }).node("prefetch-count", Integer.valueOf(m.getPrefetchCount()), new Object[0])
        .node("prefetch-validity-millis", Long.valueOf(m.getPrefetchValidityMillis()), new Object[0])
        .node("id-offset", Long.valueOf(m.getIdOffset()), new Object[0])
        .node("node-id-offset", Long.valueOf(m.getNodeIdOffset()), new Object[0])
        .node("statistics-enabled", Boolean.valueOf(m.isStatisticsEnabled()), new Object[0]);
      gen.close();
    } 
  }
  
  private static void crdtReplicationXmlGenerator(XmlGenerator gen, Config config) {
    CRDTReplicationConfig replicationConfig = config.getCRDTReplicationConfig();
    gen.open("crdt-replication", new Object[0]);
    if (replicationConfig != null)
      gen.node("replication-period-millis", Integer.valueOf(replicationConfig.getReplicationPeriodMillis()), new Object[0])
        .node("max-concurrent-replication-targets", Integer.valueOf(replicationConfig.getMaxConcurrentReplicationTargets()), new Object[0]); 
    gen.close();
  }
  
  private static void quorumXmlGenerator(XmlGenerator gen, Config config) {
    for (QuorumConfig quorumConfig : config.getQuorumConfigs().values()) {
      gen.open("quorum", new Object[] { "name", quorumConfig.getName(), "enabled", 
            Boolean.valueOf(quorumConfig.isEnabled()) }).node("quorum-size", Integer.valueOf(quorumConfig.getSize()), new Object[0])
        .node("quorum-type", quorumConfig.getType(), new Object[0]);
      if (!quorumConfig.getListenerConfigs().isEmpty()) {
        gen.open("quorum-listeners", new Object[0]);
        for (QuorumListenerConfig listenerConfig : quorumConfig.getListenerConfigs())
          gen.node("quorum-listener", classNameOrImplClass(listenerConfig.getClassName(), listenerConfig
                .getImplementation()), new Object[0]); 
        gen.close();
      } 
      handleQuorumFunction(gen, quorumConfig);
      gen.close();
    } 
  }
  
  private static void cpSubsystemConfig(XmlGenerator gen, Config config) {
    CPSubsystemConfig cpSubsystemConfig = config.getCPSubsystemConfig();
    gen.open("cp-subsystem", new Object[0])
      .node("cp-member-count", Integer.valueOf(cpSubsystemConfig.getCPMemberCount()), new Object[0])
      .node("group-size", Integer.valueOf(cpSubsystemConfig.getGroupSize()), new Object[0])
      .node("session-time-to-live-seconds", Integer.valueOf(cpSubsystemConfig.getSessionTimeToLiveSeconds()), new Object[0])
      .node("session-heartbeat-interval-seconds", Integer.valueOf(cpSubsystemConfig.getSessionHeartbeatIntervalSeconds()), new Object[0])
      .node("missing-cp-member-auto-removal-seconds", Integer.valueOf(cpSubsystemConfig.getMissingCPMemberAutoRemovalSeconds()), new Object[0])
      .node("fail-on-indeterminate-operation-state", Boolean.valueOf(cpSubsystemConfig.isFailOnIndeterminateOperationState()), new Object[0]);
    RaftAlgorithmConfig raftAlgorithmConfig = cpSubsystemConfig.getRaftAlgorithmConfig();
    gen.open("raft-algorithm", new Object[0])
      .node("leader-election-timeout-in-millis", Long.valueOf(raftAlgorithmConfig.getLeaderElectionTimeoutInMillis()), new Object[0])
      .node("leader-heartbeat-period-in-millis", Long.valueOf(raftAlgorithmConfig.getLeaderHeartbeatPeriodInMillis()), new Object[0])
      .node("max-missed-leader-heartbeat-count", Integer.valueOf(raftAlgorithmConfig.getMaxMissedLeaderHeartbeatCount()), new Object[0])
      .node("append-request-max-entry-count", Integer.valueOf(raftAlgorithmConfig.getAppendRequestMaxEntryCount()), new Object[0])
      .node("commit-index-advance-count-to-snapshot", Integer.valueOf(raftAlgorithmConfig.getCommitIndexAdvanceCountToSnapshot()), new Object[0])
      .node("uncommitted-entry-count-to-reject-new-appends", 
        Integer.valueOf(raftAlgorithmConfig.getUncommittedEntryCountToRejectNewAppends()), new Object[0])
      .node("append-request-backoff-timeout-in-millis", Long.valueOf(raftAlgorithmConfig.getAppendRequestBackoffTimeoutInMillis()), new Object[0])
      .close();
    gen.open("semaphores", new Object[0]);
    for (CPSemaphoreConfig semaphoreConfig : cpSubsystemConfig.getSemaphoreConfigs().values())
      gen.open("cp-semaphore", new Object[0])
        .node("name", semaphoreConfig.getName(), new Object[0])
        .node("jdk-compatible", Boolean.valueOf(semaphoreConfig.isJDKCompatible()), new Object[0])
        .close(); 
    gen.close().open("locks", new Object[0]);
    for (FencedLockConfig lockConfig : cpSubsystemConfig.getLockConfigs().values())
      gen.open("fenced-lock", new Object[0])
        .node("name", lockConfig.getName(), new Object[0])
        .node("lock-acquire-limit", Integer.valueOf(lockConfig.getLockAcquireLimit()), new Object[0])
        .close(); 
    gen.close().close();
  }
  
  private static void userCodeDeploymentConfig(XmlGenerator gen, Config config) {
    UserCodeDeploymentConfig ucdConfig = config.getUserCodeDeploymentConfig();
    gen.open("user-code-deployment", new Object[] { "enabled", Boolean.valueOf(ucdConfig.isEnabled()) }).node("class-cache-mode", ucdConfig.getClassCacheMode(), new Object[0])
      .node("provider-mode", ucdConfig.getProviderMode(), new Object[0])
      .node("blacklist-prefixes", ucdConfig.getBlacklistedPrefixes(), new Object[0])
      .node("whitelist-prefixes", ucdConfig.getWhitelistedPrefixes(), new Object[0])
      .node("provider-filter", ucdConfig.getProviderFilter(), new Object[0])
      .close();
  }
  
  private static void handleQuorumFunction(XmlGenerator gen, QuorumConfig quorumConfig) {
    if (quorumConfig.getQuorumFunctionImplementation() instanceof ProbabilisticQuorumFunction) {
      ProbabilisticQuorumFunction qf = (ProbabilisticQuorumFunction)quorumConfig.getQuorumFunctionImplementation();
      long acceptableHeartbeatPause = qf.getAcceptableHeartbeatPauseMillis();
      double threshold = qf.getSuspicionThreshold();
      int maxSampleSize = qf.getMaxSampleSize();
      long minStdDeviation = qf.getMinStdDeviationMillis();
      long firstHeartbeatEstimate = qf.getHeartbeatIntervalMillis();
      gen.open("probabilistic-quorum", new Object[] { "acceptable-heartbeat-pause-millis", Long.valueOf(acceptableHeartbeatPause), "suspicion-threshold", 
            Double.valueOf(threshold), "max-sample-size", 
            Integer.valueOf(maxSampleSize), "min-std-deviation-millis", 
            Long.valueOf(minStdDeviation), "heartbeat-interval-millis", 
            Long.valueOf(firstHeartbeatEstimate) });
      gen.close();
    } else if (quorumConfig.getQuorumFunctionImplementation() instanceof RecentlyActiveQuorumFunction) {
      RecentlyActiveQuorumFunction qf = (RecentlyActiveQuorumFunction)quorumConfig.getQuorumFunctionImplementation();
      gen.open("recently-active-quorum", new Object[] { "heartbeat-tolerance-millis", Integer.valueOf(qf.getHeartbeatToleranceMillis()) });
      gen.close();
    } else {
      gen.node("quorum-function-class-name", classNameOrImplClass(quorumConfig.getQuorumFunctionClassName(), quorumConfig
            .getQuorumFunctionImplementation()), new Object[0]);
    } 
  }
  
  private static void nativeMemoryXmlGenerator(XmlGenerator gen, Config config) {
    NativeMemoryConfig nativeMemoryConfig = config.getNativeMemoryConfig();
    if (nativeMemoryConfig == null) {
      gen.node("native-memory", null, new Object[] { "enabled", "false" });
      return;
    } 
    gen.open("native-memory", new Object[] { "enabled", 
          Boolean.valueOf(nativeMemoryConfig.isEnabled()), "allocator-type", nativeMemoryConfig
          .getAllocatorType() }).node("size", null, new Object[] { "unit", nativeMemoryConfig.getSize().getUnit(), "value", 
          Long.valueOf(nativeMemoryConfig.getSize().getValue()) }).node("min-block-size", Integer.valueOf(nativeMemoryConfig.getMinBlockSize()), new Object[0])
      .node("page-size", Integer.valueOf(nativeMemoryConfig.getPageSize()), new Object[0])
      .node("metadata-space-percentage", Float.valueOf(nativeMemoryConfig.getMetadataSpacePercentage()), new Object[0])
      .close();
  }
  
  private static void servicesXmlGenerator(XmlGenerator gen, Config config) {
    ServicesConfig c = config.getServicesConfig();
    if (c == null)
      return; 
    gen.open("services", new Object[] { "enable-defaults", Boolean.valueOf(c.isEnableDefaults()) });
    if (CollectionUtil.isNotEmpty(c.getServiceConfigs()))
      for (ServiceConfig serviceConfig : c.getServiceConfigs()) {
        gen.open("service", new Object[] { "enabled", Boolean.valueOf(serviceConfig.isEnabled()) }).node("name", serviceConfig.getName(), new Object[0])
          .node("class-name", classNameOrImplClass(serviceConfig.getClassName(), serviceConfig.getImplementation()), new Object[0])
          .appendProperties(serviceConfig.getProperties())
          .close();
      }  
    gen.close();
  }
  
  private static void liteMemberXmlGenerator(XmlGenerator gen, Config config) { gen.node("lite-member", null, new Object[] { "enabled", Boolean.valueOf(config.isLiteMember()) }); }
  
  private static void restApiXmlGenerator(XmlGenerator gen, NetworkConfig config) {
    RestApiConfig c = config.getRestApiConfig();
    if (c == null)
      return; 
    gen.open("rest-api", new Object[] { "enabled", Boolean.valueOf(c.isEnabled()) });
    for (RestEndpointGroup group : RestEndpointGroup.values()) {
      gen.node("endpoint-group", null, new Object[] { "name", group.name(), "enabled", Boolean.valueOf(c.isGroupEnabled(group)) });
    } 
    gen.close();
  }
  
  private static void memcacheProtocolXmlGenerator(XmlGenerator gen, NetworkConfig config) {
    MemcacheProtocolConfig c = config.getMemcacheProtocolConfig();
    if (c == null)
      return; 
    gen.node("memcache-protocol", null, new Object[] { "enabled", Boolean.valueOf(c.isEnabled()) });
  }
  
  private static void appendItemListenerConfigs(XmlGenerator gen, Collection<ItemListenerConfig> configs) {
    if (CollectionUtil.isNotEmpty(configs)) {
      gen.open("item-listeners", new Object[0]);
      for (ItemListenerConfig lc : configs) {
        gen.node("item-listener", lc.getClassName(), new Object[] { "include-value", Boolean.valueOf(lc.isIncludeValue()) });
      } 
      gen.close();
    } 
  }
  
  private static void appendSerializationFactory(XmlGenerator gen, String elementName, Map<Integer, ?> factoryMap) {
    if (MapUtil.isNullOrEmpty(factoryMap))
      return; 
    for (Map.Entry<Integer, ?> factory : factoryMap.entrySet()) {
      Object value = factory.getValue();
      String className = (value instanceof String) ? (String)value : value.getClass().getName();
      gen.node(elementName, className, new Object[] { "factory-id", ((Integer)factory.getKey()).toString() });
    } 
  }
  
  private static void appendFilterList(XmlGenerator gen, String listName, ClassFilter classFilterList) {
    if (classFilterList.isEmpty())
      return; 
    gen.open(listName, new Object[0]);
    for (String className : classFilterList.getClasses())
      gen.node("class", className, new Object[0]); 
    for (String packageName : classFilterList.getPackages())
      gen.node("package", packageName, new Object[0]); 
    for (String prefix : classFilterList.getPrefixes())
      gen.node("prefix", prefix, new Object[0]); 
    gen.close();
  }
}
