package com.hazelcast.console;

import com.hazelcast.config.Config;
import com.hazelcast.config.ExecutorConfig;
import com.hazelcast.config.FileSystemXmlConfig;
import com.hazelcast.core.DistributedObject;
import com.hazelcast.core.EntryEvent;
import com.hazelcast.core.EntryListener;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IAtomicLong;
import com.hazelcast.core.IExecutorService;
import com.hazelcast.core.IList;
import com.hazelcast.core.ILock;
import com.hazelcast.core.IMap;
import com.hazelcast.core.IQueue;
import com.hazelcast.core.ISet;
import com.hazelcast.core.ITopic;
import com.hazelcast.core.ItemEvent;
import com.hazelcast.core.ItemListener;
import com.hazelcast.core.MapEvent;
import com.hazelcast.core.Member;
import com.hazelcast.core.Message;
import com.hazelcast.core.MessageListener;
import com.hazelcast.core.MultiMap;
import com.hazelcast.core.Partition;
import com.hazelcast.internal.util.RuntimeAvailableProcessors;
import com.hazelcast.memory.MemoryUnit;
import com.hazelcast.nio.IOUtil;
import com.hazelcast.util.Clock;
import com.hazelcast.util.MapUtil;
import com.hazelcast.util.StringUtil;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.management.ManagementFactory;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class ConsoleApp extends Object implements EntryListener<Object, Object>, ItemListener<Object>, MessageListener<Object> {
  private static final String EXECUTOR_NAMESPACE = "Sample Executor";
  
  private static final int LOAD_EXECUTORS_COUNT = 16;
  
  private static final int ONE_HUNDRED = 100;
  
  private IQueue<Object> queue;
  
  private ITopic<Object> topic;
  
  private IMap<Object, Object> map;
  
  private MultiMap<Object, Object> multiMap;
  
  private ISet<Object> set;
  
  private IList<Object> list;
  
  private IAtomicLong atomicNumber;
  
  private String namespace;
  
  private boolean silent;
  
  private boolean echo;
  
  public ConsoleApp(HazelcastInstance hazelcast) {
    this.namespace = "default";
    this.hazelcast = hazelcast;
  }
  
  public IQueue<Object> getQueue() {
    this.queue = this.hazelcast.getQueue(this.namespace);
    return this.queue;
  }
  
  public ITopic<Object> getTopic() {
    this.topic = this.hazelcast.getTopic(this.namespace);
    return this.topic;
  }
  
  public IMap<Object, Object> getMap() {
    this.map = this.hazelcast.getMap(this.namespace);
    return this.map;
  }
  
  public MultiMap<Object, Object> getMultiMap() {
    this.multiMap = this.hazelcast.getMultiMap(this.namespace);
    return this.multiMap;
  }
  
  public IAtomicLong getAtomicNumber() {
    this.atomicNumber = this.hazelcast.getAtomicLong(this.namespace);
    return this.atomicNumber;
  }
  
  public ISet<Object> getSet() {
    this.set = this.hazelcast.getSet(this.namespace);
    return this.set;
  }
  
  public IList<Object> getList() {
    this.list = this.hazelcast.getList(this.namespace);
    return this.list;
  }
  
  public void setHazelcast(HazelcastInstance hazelcast) {
    this.hazelcast = hazelcast;
    this.map = null;
    this.list = null;
    this.set = null;
    this.queue = null;
    this.topic = null;
  }
  
  public void stop() { this.running = false; }
  
  public void start() {
    getMap().size();
    getList().size();
    getSet().size();
    getQueue().size();
    getTopic().getLocalTopicStats();
    getMultiMap().size();
    this.hazelcast.getExecutorService("default").getLocalExecutorStats();
    for (i = 1; i <= 16; i++)
      this.hazelcast.getExecutorService("Sample Executor " + i).getLocalExecutorStats(); 
    if (this.lineReader == null)
      this.lineReader = new DefaultLineReader(); 
    this.running = true;
    while (this.running) {
      print("hazelcast[" + this.namespace + "] > ");
      try {
        String command = this.lineReader.readLine();
        handleCommand(command);
      } catch (Throwable i) {
        Throwable e;
        e.printStackTrace();
      } 
    } 
  }
  
  public void handleCommand(String inputCommand) {
    String command = inputCommand;
    if (command == null)
      return; 
    command = StringUtil.trim(command);
    if (command.length() == 0)
      return; 
    if (command.contains("__")) {
      this.namespace = command.split("__")[0];
      command = command.substring(command.indexOf("__") + 2);
    } 
    if (this.echo)
      handleEcho(command); 
    if (command.startsWith("//"))
      return; 
    String first = command;
    int spaceIndex = command.indexOf(' ');
    String[] argsSplit = command.split(" ");
    String[] args = new String[argsSplit.length];
    for (int i = 0; i < argsSplit.length; i++)
      args[i] = StringUtil.trim(argsSplit[i]); 
    if (spaceIndex != -1)
      first = args[0]; 
    if (command.startsWith("help")) {
      handleHelp(command);
    } else if (first.startsWith("#") && first.length() > 1) {
      int repeat = Integer.parseInt(first.substring(1));
      long started = Clock.currentTimeMillis();
      for (int i = 0; i < repeat; i++)
        handleCommand(command.substring(first.length()).replaceAll("\\$i", "" + i)); 
      long elapsedMilliSeconds = Clock.currentTimeMillis() - started;
      if (elapsedMilliSeconds > 0L) {
        println(String.format("ops/s = %.2f", new Object[] { Double.valueOf(repeat * 1000.0D / elapsedMilliSeconds) }));
      } else {
        println("Bingo, all the operations finished in no time!");
      } 
    } else if (first.startsWith("&") && first.length() > 1) {
      int fork = Integer.parseInt(first.substring(1));
      String threadCommand = command.substring(first.length());
      ExecutorService pool = Executors.newFixedThreadPool(fork);
      for (i = 0; i < fork; i++) {
        int threadID = i;
        pool.submit(new Object(this, threadCommand, threadID));
      } 
      pool.shutdown();
      try {
        pool.awaitTermination(1L, TimeUnit.HOURS);
      } catch (Exception i) {
        Exception e;
        e.printStackTrace();
      } 
    } else if (first.startsWith("@")) {
      handleAt(first);
    } else if (command.indexOf(';') != -1) {
      handleColon(command);
    } else if ("silent".equals(first)) {
      this.silent = Boolean.parseBoolean(args[1]);
    } else if (StringUtil.equalsIgnoreCase("shutdown", first)) {
      handleShutdown();
    } else if ("echo".equals(first)) {
      this.echo = Boolean.parseBoolean(args[1]);
      println("echo: " + this.echo);
    } else if ("ns".equals(first)) {
      handleNamespace(StringUtil.trim(command.substring(first.length())));
    } else if ("whoami".equals(first)) {
      handleWhoami();
    } else if ("who".equals(first)) {
      handleWho();
    } else if ("jvm".equals(first)) {
      handleJvm();
    } else if (first.contains("ock") && !first.contains(".")) {
      handleLock(args);
    } else if (first.contains(".size")) {
      handleSize(args);
    } else if (first.contains(".clear")) {
      handleClear(args);
    } else if (first.contains(".destroy")) {
      handleDestroy(args);
    } else if (first.contains(".iterator")) {
      handleIterator(args);
    } else if (first.contains(".contains")) {
      handleContains(args);
    } else if (first.contains(".stats")) {
      handStats(args);
    } else if ("t.publish".equals(first)) {
      handleTopicPublish(args);
    } else if ("q.offer".equals(first)) {
      handleQOffer(args);
    } else if ("q.take".equals(first)) {
      handleQTake(args);
    } else if ("q.poll".equals(first)) {
      handleQPoll(args);
    } else if ("q.peek".equals(first)) {
      handleQPeek(args);
    } else if ("q.capacity".equals(first)) {
      handleQCapacity(args);
    } else if ("q.offermany".equals(first)) {
      handleQOfferMany(args);
    } else if ("q.pollmany".equals(first)) {
      handleQPollMany(args);
    } else if ("s.add".equals(first)) {
      handleSetAdd(args);
    } else if ("s.remove".equals(first)) {
      handleSetRemove(args);
    } else if ("s.addmany".equals(first)) {
      handleSetAddMany(args);
    } else if ("s.removemany".equals(first)) {
      handleSetRemoveMany(args);
    } else if (first.equals("m.replace")) {
      handleMapReplace(args);
    } else if (StringUtil.equalsIgnoreCase(first, "m.putIfAbsent")) {
      handleMapPutIfAbsent(args);
    } else if (first.equals("m.putAsync")) {
      handleMapPutAsync(args);
    } else if (first.equals("m.getAsync")) {
      handleMapGetAsync(args);
    } else if (first.equals("m.put")) {
      handleMapPut(args);
    } else if (first.equals("m.get")) {
      handleMapGet(args);
    } else if (StringUtil.equalsIgnoreCase(first, "m.getMapEntry")) {
      handleMapGetMapEntry(args);
    } else if (first.equals("m.remove")) {
      handleMapRemove(args);
    } else if (first.equals("m.delete")) {
      handleMapDelete(args);
    } else if (first.equals("m.evict")) {
      handleMapEvict(args);
    } else if (first.equals("m.putmany") || StringUtil.equalsIgnoreCase(first, "m.putAll")) {
      handleMapPutMany(args);
    } else if (first.equals("m.getmany")) {
      handleMapGetMany(args);
    } else if (first.equals("m.removemany")) {
      handleMapRemoveMany(args);
    } else if (StringUtil.equalsIgnoreCase(command, "m.localKeys")) {
      handleMapLocalKeys();
    } else if (StringUtil.equalsIgnoreCase(command, "m.localSize")) {
      handleMapLocalSize();
    } else if (command.equals("m.keys")) {
      handleMapKeys();
    } else if (command.equals("m.values")) {
      handleMapValues();
    } else if (command.equals("m.entries")) {
      handleMapEntries();
    } else if (first.equals("m.lock")) {
      handleMapLock(args);
    } else if (StringUtil.equalsIgnoreCase(first, "m.tryLock")) {
      handleMapTryLock(args);
    } else if (first.equals("m.unlock")) {
      handleMapUnlock(args);
    } else if (first.contains(".addListener")) {
      handleAddListener(args);
    } else if (first.equals("m.removeMapListener")) {
      handleRemoveListener(args);
    } else if (first.equals("mm.put")) {
      handleMultiMapPut(args);
    } else if (first.equals("mm.get")) {
      handleMultiMapGet(args);
    } else if (first.equals("mm.remove")) {
      handleMultiMapRemove(args);
    } else if (command.equals("mm.keys")) {
      handleMultiMapKeys();
    } else if (command.equals("mm.values")) {
      handleMultiMapValues();
    } else if (command.equals("mm.entries")) {
      handleMultiMapEntries();
    } else if (first.equals("mm.lock")) {
      handleMultiMapLock(args);
    } else if (StringUtil.equalsIgnoreCase(first, "mm.tryLock")) {
      handleMultiMapTryLock(args);
    } else if (first.equals("mm.unlock")) {
      handleMultiMapUnlock(args);
    } else if (first.equals("l.add")) {
      handleListAdd(args);
    } else if (first.equals("l.set")) {
      handleListSet(args);
    } else if ("l.addmany".equals(first)) {
      handleListAddMany(args);
    } else if (first.equals("l.remove")) {
      handleListRemove(args);
    } else if (first.equals("l.contains")) {
      handleListContains(args);
    } else if ("a.get".equals(first)) {
      handleAtomicNumberGet(args);
    } else if ("a.set".equals(first)) {
      handleAtomicNumberSet(args);
    } else if ("a.inc".equals(first)) {
      handleAtomicNumberInc(args);
    } else if ("a.dec".equals(first)) {
      handleAtomicNumberDec(args);
    } else if (first.equals("execute")) {
      execute(args);
    } else if (first.equals("partitions")) {
      handlePartitions(args);
    } else if (StringUtil.equalsIgnoreCase(first, "executeOnKey")) {
      executeOnKey(args);
    } else if (StringUtil.equalsIgnoreCase(first, "executeOnMember")) {
      executeOnMember(args);
    } else if (StringUtil.equalsIgnoreCase(first, "executeOnMembers")) {
      executeOnMembers(args);
    } else if (StringUtil.equalsIgnoreCase(first, "instances")) {
      handleInstances(args);
    } else if (StringUtil.equalsIgnoreCase(first, "quit") || StringUtil.equalsIgnoreCase(first, "exit")) {
      handleExit();
    } else if (first.startsWith("e") && first.endsWith(".simulateLoad")) {
      handleExecutorSimulate(args);
    } else {
      println("type 'help' for help");
    } 
  }
  
  protected void handleShutdown() { this.hazelcast.getLifecycleService().shutdown(); }
  
  protected void handleExit() { System.exit(0); }
  
  private void handleExecutorSimulate(String[] args) {
    String first = args[0];
    int threadCount = Integer.parseInt(first.substring(1, first.indexOf(".")));
    if (threadCount < 1 || threadCount > 16)
      throw new RuntimeException("threadCount can't be smaller than 1 or larger than 16"); 
    int taskCount = Integer.parseInt(args[1]);
    int durationSec = Integer.parseInt(args[2]);
    long startMs = System.currentTimeMillis();
    IExecutorService executor = this.hazelcast.getExecutorService("Sample Executor " + threadCount);
    List<Future> futures = new LinkedList<Future>();
    List<Member> members = new LinkedList<Member>(this.hazelcast.getCluster().getMembers());
    int totalThreadCount = this.hazelcast.getCluster().getMembers().size() * threadCount;
    int latchId = 0;
    for (int i = 0; i < taskCount; i++) {
      Member member = (Member)members.get(i % members.size());
      if (taskCount % totalThreadCount == 0) {
        latchId = taskCount / totalThreadCount;
        this.hazelcast.getCountDownLatch("latch" + latchId).trySetCount(totalThreadCount);
      } 
      Future f = executor.submitToMember(new SimulateLoadTask(durationSec, i + 1, "latch" + latchId), member);
      futures.add(f);
    } 
    for (Future f : futures) {
      try {
        f.get();
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        e.printStackTrace();
      } catch (ExecutionException e) {
        e.printStackTrace();
      } 
    } 
    long durationMs = System.currentTimeMillis() - startMs;
    println(String.format("Executed %s tasks in %s ms", new Object[] { Integer.valueOf(taskCount), Long.valueOf(durationMs) }));
  }
  
  private void handleColon(String command) {
    StringTokenizer st = new StringTokenizer(command, ";");
    while (st.hasMoreTokens())
      handleCommand(st.nextToken()); 
  }
  
  private void handleAt(String first) {
    if (first.length() == 1) {
      println("usage: @<file-name>");
      return;
    } 
    File f = new File(first.substring(1));
    println("Executing script file " + f.getAbsolutePath());
    if (f.exists()) {
      br = null;
      try {
        br = new BufferedReader(new InputStreamReader(new FileInputStream(f), "UTF-8"));
        String l = br.readLine();
        while (l != null) {
          handleCommand(l);
          l = br.readLine();
        } 
      } catch (IOException e) {
        e.printStackTrace();
      } finally {
        IOUtil.closeResource(br);
      } 
    } else {
      println("File not found! " + f.getAbsolutePath());
    } 
  }
  
  private void handleEcho(String command) {
    String threadName = StringUtil.lowerCaseInternal(Thread.currentThread().getName());
    if (!threadName.contains("main")) {
      println(" [" + Thread.currentThread().getName() + "] " + command);
    } else {
      println(command);
    } 
  }
  
  private void handleNamespace(String namespace) {
    if (!namespace.isEmpty())
      this.namespace = namespace; 
    println("namespace: " + namespace);
  }
  
  @SuppressFBWarnings({"DM_GC"})
  private void handleJvm() {
    System.gc();
    long max = Runtime.getRuntime().maxMemory();
    long total = Runtime.getRuntime().totalMemory();
    long free = Runtime.getRuntime().freeMemory();
    println("Memory max: " + MemoryUnit.BYTES.toMegaBytes(max) + "MB");
    println("Memory free: " + MemoryUnit.BYTES.toMegaBytes(free) + "MB " + (int)(free * 100L / max) + "%");
    println("Used Memory:" + MemoryUnit.BYTES.toMegaBytes(total - free) + "MB");
    println("# procs: " + RuntimeAvailableProcessors.get());
    println("OS info: " + ManagementFactory.getOperatingSystemMXBean().getArch() + " " + 
        ManagementFactory.getOperatingSystemMXBean().getName() + " " + 
        ManagementFactory.getOperatingSystemMXBean().getVersion());
    println("JVM: " + ManagementFactory.getRuntimeMXBean().getVmVendor() + " " + 
        ManagementFactory.getRuntimeMXBean().getVmName() + " " + 
        ManagementFactory.getRuntimeMXBean().getVmVersion());
  }
  
  private void handleWhoami() { println(this.hazelcast.getCluster().getLocalMember()); }
  
  private void handleWho() {
    StringBuilder sb = new StringBuilder("\n\nMembers [");
    Collection<Member> members = this.hazelcast.getCluster().getMembers();
    sb.append((members != null) ? members.size() : 0);
    sb.append("] {");
    if (members != null)
      for (Member member : members)
        sb.append("\n\t").append(member);  
    sb.append("\n}\n");
    println(sb.toString());
  }
  
  private void handleAtomicNumberGet(String[] args) { println(Long.valueOf(getAtomicNumber().get())); }
  
  private void handleAtomicNumberSet(String[] args) {
    long v = 0L;
    if (args.length > 1)
      v = Long.parseLong(args[1]); 
    getAtomicNumber().set(v);
    println(Long.valueOf(getAtomicNumber().get()));
  }
  
  private void handleAtomicNumberInc(String[] args) { println(Long.valueOf(getAtomicNumber().incrementAndGet())); }
  
  private void handleAtomicNumberDec(String[] args) { println(Long.valueOf(getAtomicNumber().decrementAndGet())); }
  
  protected void handlePartitions(String[] args) {
    Set<Partition> partitions = this.hazelcast.getPartitionService().getPartitions();
    Map<Member, Integer> partitionCounts = new HashMap<Member, Integer>();
    for (Partition partition : partitions) {
      Member owner = partition.getOwner();
      if (owner != null) {
        Integer count = (Integer)partitionCounts.get(owner);
        int newCount = 1;
        if (count != null)
          newCount = count.intValue() + 1; 
        partitionCounts.put(owner, Integer.valueOf(newCount));
      } 
      println(partition);
    } 
    Set<Map.Entry<Member, Integer>> entries = partitionCounts.entrySet();
    for (Map.Entry<Member, Integer> entry : entries)
      println(entry.getKey() + ": " + entry.getValue()); 
  }
  
  protected void handleInstances(String[] args) {
    Collection<DistributedObject> distributedObjects = this.hazelcast.getDistributedObjects();
    for (DistributedObject distributedObject : distributedObjects)
      println(distributedObject); 
  }
  
  protected void handleListContains(String[] args) { println(Boolean.valueOf(getList().contains(args[1]))); }
  
  protected void handleListRemove(String[] args) {
    int index;
    try {
      index = Integer.parseInt(args[1]);
    } catch (NumberFormatException e) {
      throw new RuntimeException(e);
    } 
    if (index >= 0) {
      println(getList().remove(index));
    } else {
      println(Boolean.valueOf(getList().remove(args[1])));
    } 
  }
  
  protected void handleListAdd(String[] args) {
    if (args.length == 3) {
      int index = Integer.parseInt(args[1]);
      getList().add(index, args[2]);
      println("true");
    } else {
      println(Boolean.valueOf(getList().add(args[1])));
    } 
  }
  
  protected void handleListSet(String[] args) {
    int index = Integer.parseInt(args[1]);
    println(getList().set(index, args[2]));
  }
  
  protected void handleListAddMany(String[] args) {
    int count = 1;
    if (args.length > 1)
      count = Integer.parseInt(args[1]); 
    int successCount = 0;
    long started = Clock.currentTimeMillis();
    for (int i = 0; i < count; i++) {
      boolean success = getList().add("obj" + i);
      if (success)
        successCount++; 
    } 
    long elapsedMillis = Clock.currentTimeMillis() - started;
    println("Added " + successCount + " objects.");
    if (elapsedMillis > 0L)
      println("size = " + this.list.size() + ", " + TimeUnit.MILLISECONDS.toSeconds(successCount / elapsedMillis) + " evt/s"); 
  }
  
  protected void handleMapPut(String[] args) {
    if (args.length == 1) {
      println("m.put requires a key and a value. You have not specified either.");
    } else if (args.length == 2) {
      println("m.put requires a key and a value. You have only specified the key " + args[1]);
    } else if (args.length > 3) {
      println("m.put takes two arguments, a key and a value. You have specified more than two arguments.");
    } else {
      println(getMap().put(args[1], args[2]));
    } 
  }
  
  protected void handleMapPutAsync(String[] args) {
    try {
      println(getMap().putAsync(args[1], args[2]).get());
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      e.printStackTrace();
    } catch (ExecutionException e) {
      e.printStackTrace();
    } 
  }
  
  protected void handleMapPutIfAbsent(String[] args) { println(getMap().putIfAbsent(args[1], args[2])); }
  
  protected void handleMapReplace(String[] args) { println(getMap().replace(args[1], args[2])); }
  
  protected void handleMapGet(String[] args) { println(getMap().get(args[1])); }
  
  protected void handleMapGetAsync(String[] args) {
    try {
      println(getMap().getAsync(args[1]).get());
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      e.printStackTrace();
    } catch (ExecutionException e) {
      e.printStackTrace();
    } 
  }
  
  protected void handleMapGetMapEntry(String[] args) { println(getMap().getEntryView(args[1])); }
  
  protected void handleMapRemove(String[] args) { println(getMap().remove(args[1])); }
  
  protected void handleMapDelete(String[] args) {
    getMap().delete(args[1]);
    println("true");
  }
  
  protected void handleMapEvict(String[] args) { println(Boolean.valueOf(getMap().evict(args[1]))); }
  
  protected void handleMapPutMany(String[] args) {
    int count = 1;
    if (args.length > 1)
      count = Integer.parseInt(args[1]); 
    int b = 100;
    byte[] value = new byte[b];
    if (args.length > 2) {
      b = Integer.parseInt(args[2]);
      value = new byte[b];
    } 
    int start = getMap().size();
    if (args.length > 3)
      start = Integer.parseInt(args[3]); 
    Map<String, byte[]> theMap = MapUtil.createHashMap(count);
    for (int i = 0; i < count; i++)
      theMap.put("key" + (start + i), value); 
    long started = Clock.currentTimeMillis();
    getMap().putAll(theMap);
    long elapsedMillis = Clock.currentTimeMillis() - started;
    if (elapsedMillis > 0L) {
      long addedKiloBytes = count * MemoryUnit.BYTES.toKiloBytes(b);
      println("size = " + getMap().size() + ", " + TimeUnit.MILLISECONDS.toSeconds(count / elapsedMillis) + " evt/s, " + TimeUnit.MILLISECONDS
          .toSeconds(addedKiloBytes * 8L / elapsedMillis) + " KBit/s, " + addedKiloBytes + " KB added");
    } 
  }
  
  protected void handleMapGetMany(String[] args) {
    int count = 1;
    if (args.length > 1)
      count = Integer.parseInt(args[1]); 
    for (int i = 0; i < count; i++)
      println(getMap().get("key" + i)); 
  }
  
  protected void handleMapRemoveMany(String[] args) {
    int count = 1;
    if (args.length > 1)
      count = Integer.parseInt(args[1]); 
    int start = 0;
    if (args.length > 2)
      start = Integer.parseInt(args[2]); 
    long started = Clock.currentTimeMillis();
    for (int i = 0; i < count; i++)
      getMap().remove("key" + (start + i)); 
    long elapsedMillis = Clock.currentTimeMillis() - started;
    if (elapsedMillis > 0L)
      println("size = " + getMap().size() + ", " + TimeUnit.MILLISECONDS.toSeconds(count / elapsedMillis) + " evt/s"); 
  }
  
  protected void handleMapLock(String[] args) {
    getMap().lock(args[1]);
    println("true");
  }
  
  protected void handleMapTryLock(String[] args) {
    boolean locked;
    String key = args[1];
    long time = (args.length > 2) ? Long.parseLong(args[2]) : 0L;
    if (time == 0L) {
      locked = getMap().tryLock(key);
    } else {
      try {
        locked = getMap().tryLock(key, time, TimeUnit.SECONDS);
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        locked = false;
      } 
    } 
    println(Boolean.valueOf(locked));
  }
  
  protected void handleMapUnlock(String[] args) {
    getMap().unlock(args[1]);
    println("true");
  }
  
  protected void handleMapLocalKeys() {
    Set set = getMap().localKeySet();
    Iterator it = set.iterator();
    int count = 0;
    while (it.hasNext()) {
      count++;
      println(it.next());
    } 
    println("Total " + count);
  }
  
  protected void handleMapLocalSize() { println("Local Size = " + getMap().localKeySet().size()); }
  
  protected void handleMapKeys() {
    Set set = getMap().keySet();
    Iterator it = set.iterator();
    int count = 0;
    while (it.hasNext()) {
      count++;
      println(it.next());
    } 
    println("Total " + count);
  }
  
  protected void handleMapEntries() {
    Set set = getMap().entrySet();
    Iterator it = set.iterator();
    int count = 0;
    while (it.hasNext()) {
      count++;
      Map.Entry entry = (Map.Entry)it.next();
      println(entry.getKey() + ": " + entry.getValue());
    } 
    println("Total " + count);
  }
  
  protected void handleMapValues() {
    Collection set = getMap().values();
    Iterator it = set.iterator();
    int count = 0;
    while (it.hasNext()) {
      count++;
      println(it.next());
    } 
    println("Total " + count);
  }
  
  protected void handleMultiMapPut(String[] args) { println(Boolean.valueOf(getMultiMap().put(args[1], args[2]))); }
  
  protected void handleMultiMapGet(String[] args) { println(getMultiMap().get(args[1])); }
  
  protected void handleMultiMapRemove(String[] args) { println(getMultiMap().remove(args[1])); }
  
  protected void handleMultiMapKeys() {
    Set set = getMultiMap().keySet();
    Iterator it = set.iterator();
    int count = 0;
    while (it.hasNext()) {
      count++;
      println(it.next());
    } 
    println("Total " + count);
  }
  
  protected void handleMultiMapEntries() {
    Set set = getMultiMap().entrySet();
    Iterator it = set.iterator();
    int count = 0;
    while (it.hasNext()) {
      count++;
      Map.Entry entry = (Map.Entry)it.next();
      println(entry.getKey() + ": " + entry.getValue());
    } 
    println("Total " + count);
  }
  
  protected void handleMultiMapValues() {
    Collection set = getMultiMap().values();
    Iterator it = set.iterator();
    int count = 0;
    while (it.hasNext()) {
      count++;
      println(it.next());
    } 
    println("Total " + count);
  }
  
  protected void handleMultiMapLock(String[] args) {
    getMultiMap().lock(args[1]);
    println("true");
  }
  
  protected void handleMultiMapTryLock(String[] args) {
    boolean locked;
    String key = args[1];
    long time = (args.length > 2) ? Long.parseLong(args[2]) : 0L;
    if (time == 0L) {
      locked = getMultiMap().tryLock(key);
    } else {
      try {
        locked = getMultiMap().tryLock(key, time, TimeUnit.SECONDS);
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        locked = false;
      } 
    } 
    println(Boolean.valueOf(locked));
  }
  
  protected void handleMultiMapUnlock(String[] args) {
    getMultiMap().unlock(args[1]);
    println("true");
  }
  
  private void handStats(String[] args) {
    String iteratorStr = args[0];
    if (iteratorStr.startsWith("m.")) {
      println(getMap().getLocalMapStats());
    } else if (iteratorStr.startsWith("mm.")) {
      println(getMultiMap().getLocalMultiMapStats());
    } else if (iteratorStr.startsWith("q.")) {
      println(getQueue().getLocalQueueStats());
    } 
  }
  
  protected void handleLock(String[] args) {
    String lockStr = args[0];
    String key = args[1];
    ILock iLock = this.hazelcast.getLock(key);
    if (StringUtil.equalsIgnoreCase(lockStr, "lock")) {
      iLock.lock();
      println("true");
    } else if (StringUtil.equalsIgnoreCase(lockStr, "unlock")) {
      iLock.unlock();
      println("true");
    } else if (StringUtil.equalsIgnoreCase(lockStr, "trylock")) {
      String timeout = (args.length > 2) ? args[2] : null;
      if (timeout == null) {
        println(Boolean.valueOf(iLock.tryLock()));
      } else {
        long time = Long.parseLong(timeout);
        try {
          println(Boolean.valueOf(iLock.tryLock(time, TimeUnit.SECONDS)));
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
          e.printStackTrace();
        } 
      } 
    } 
  }
  
  protected void handleAddListener(String[] args) {
    String first = args[0];
    if (first.startsWith("s.")) {
      getSet().addItemListener(this, true);
    } else if (first.startsWith("m.")) {
      if (args.length > 1) {
        getMap().addEntryListener(this, args[1], true);
      } else {
        getMap().addEntryListener(this, true);
      } 
    } else if (first.startsWith("mm.")) {
      if (args.length > 1) {
        getMultiMap().addEntryListener(this, args[1], true);
      } else {
        getMultiMap().addEntryListener(this, true);
      } 
    } else if (first.startsWith("q.")) {
      getQueue().addItemListener(this, true);
    } else if (first.startsWith("t.")) {
      getTopic().addMessageListener(this);
    } else if (first.startsWith("l.")) {
      getList().addItemListener(this, true);
    } 
  }
  
  protected void handleRemoveListener(String[] args) {}
  
  protected void handleSetAdd(String[] args) { println(Boolean.valueOf(getSet().add(args[1]))); }
  
  protected void handleSetRemove(String[] args) { println(Boolean.valueOf(getSet().remove(args[1]))); }
  
  protected void handleSetAddMany(String[] args) {
    int count = 1;
    if (args.length > 1)
      count = Integer.parseInt(args[1]); 
    int successCount = 0;
    long started = Clock.currentTimeMillis();
    for (int i = 0; i < count; i++) {
      boolean success = getSet().add("obj" + i);
      if (success)
        successCount++; 
    } 
    long elapsedMillis = Clock.currentTimeMillis() - started;
    println("Added " + successCount + " objects.");
    if (elapsedMillis > 0L)
      println("size = " + getSet().size() + ", " + TimeUnit.MILLISECONDS.toSeconds(successCount / elapsedMillis) + " evt/s"); 
  }
  
  protected void handleSetRemoveMany(String[] args) {
    int count = 1;
    if (args.length > 1)
      count = Integer.parseInt(args[1]); 
    int successCount = 0;
    long started = Clock.currentTimeMillis();
    for (int i = 0; i < count; i++) {
      boolean success = getSet().remove("obj" + i);
      if (success)
        successCount++; 
    } 
    long elapsedMillis = Clock.currentTimeMillis() - started;
    println("Removed " + successCount + " objects.");
    if (elapsedMillis > 0L)
      println("size = " + getSet().size() + ", " + TimeUnit.MILLISECONDS.toSeconds(successCount / elapsedMillis) + " evt/s"); 
  }
  
  protected void handleIterator(String[] args) {
    Iterator it = null;
    String iteratorStr = args[0];
    if (iteratorStr.startsWith("s.")) {
      it = getSet().iterator();
    } else if (iteratorStr.startsWith("m.")) {
      it = getMap().keySet().iterator();
    } else if (iteratorStr.startsWith("mm.")) {
      it = getMultiMap().keySet().iterator();
    } else if (iteratorStr.startsWith("q.")) {
      it = getQueue().iterator();
    } else if (iteratorStr.startsWith("l.")) {
      it = getList().iterator();
    } 
    if (it != null) {
      boolean remove = false;
      if (args.length > 1) {
        String removeStr = args[1];
        remove = removeStr.equals("remove");
      } 
      int count = 1;
      while (it.hasNext()) {
        print(count++ + " " + it.next());
        if (remove) {
          it.remove();
          print(" removed");
        } 
        println("");
      } 
    } 
  }
  
  protected void handleContains(String[] args) {
    String iteratorStr = args[0];
    boolean key = StringUtil.lowerCaseInternal(iteratorStr).endsWith("key");
    String data = args[1];
    boolean result = false;
    if (iteratorStr.startsWith("s.")) {
      result = getSet().contains(data);
    } else if (iteratorStr.startsWith("m.")) {
      result = key ? getMap().containsKey(data) : getMap().containsValue(data);
    } else if (iteratorStr.startsWith("mmm.")) {
      result = key ? getMultiMap().containsKey(data) : getMultiMap().containsValue(data);
    } else if (iteratorStr.startsWith("q.")) {
      result = getQueue().contains(data);
    } else if (iteratorStr.startsWith("l.")) {
      result = getList().contains(data);
    } 
    println("Contains: " + result);
  }
  
  protected void handleSize(String[] args) {
    int size = 0;
    String iteratorStr = args[0];
    if (iteratorStr.startsWith("s.")) {
      size = getSet().size();
    } else if (iteratorStr.startsWith("m.")) {
      size = getMap().size();
    } else if (iteratorStr.startsWith("mm.")) {
      size = getMultiMap().size();
    } else if (iteratorStr.startsWith("q.")) {
      size = getQueue().size();
    } else if (iteratorStr.startsWith("l.")) {
      size = getList().size();
    } 
    println("Size: " + size);
  }
  
  protected void handleClear(String[] args) {
    String iteratorStr = args[0];
    if (iteratorStr.startsWith("s.")) {
      getSet().clear();
    } else if (iteratorStr.startsWith("m.")) {
      getMap().clear();
    } else if (iteratorStr.startsWith("mm.")) {
      getMultiMap().clear();
    } else if (iteratorStr.startsWith("q.")) {
      getQueue().clear();
    } else if (iteratorStr.startsWith("l.")) {
      getList().clear();
    } 
    println("Cleared all.");
  }
  
  protected void handleDestroy(String[] args) {
    String iteratorStr = args[0];
    if (iteratorStr.startsWith("s.")) {
      getSet().destroy();
    } else if (iteratorStr.startsWith("m.")) {
      getMap().destroy();
    } else if (iteratorStr.startsWith("mm.")) {
      getMultiMap().destroy();
    } else if (iteratorStr.startsWith("q.")) {
      getQueue().destroy();
    } else if (iteratorStr.startsWith("l.")) {
      getList().destroy();
    } else if (iteratorStr.startsWith("t.")) {
      getTopic().destroy();
    } 
    println("Destroyed!");
  }
  
  protected void handleQOffer(String[] args) {
    long timeout = 0L;
    if (args.length > 2)
      timeout = Long.parseLong(args[2]); 
    try {
      boolean offered = getQueue().offer(args[1], timeout, TimeUnit.SECONDS);
      println(Boolean.valueOf(offered));
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      e.printStackTrace();
    } 
  }
  
  protected void handleQTake(String[] args) {
    try {
      println(getQueue().take());
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      e.printStackTrace();
    } 
  }
  
  protected void handleQPoll(String[] args) {
    long timeout = 0L;
    if (args.length > 1)
      timeout = Long.parseLong(args[1]); 
    try {
      println(getQueue().poll(timeout, TimeUnit.SECONDS));
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      e.printStackTrace();
    } 
  }
  
  protected void handleTopicPublish(String[] args) { getTopic().publish(args[1]); }
  
  protected void handleQOfferMany(String[] args) {
    int count = 1;
    if (args.length > 1)
      count = Integer.parseInt(args[1]); 
    byte[] arrayOfByte = null;
    if (args.length > 2)
      arrayOfByte = new byte[Integer.parseInt(args[2])]; 
    long started = Clock.currentTimeMillis();
    for (int i = 0; i < count; i++) {
      if (arrayOfByte == null) {
        getQueue().offer("obj");
      } else {
        getQueue().offer(arrayOfByte);
      } 
    } 
    long elapsedMillis = Clock.currentTimeMillis() - started;
    print("size = " + getQueue().size() + ", " + TimeUnit.MILLISECONDS.toSeconds(count / elapsedMillis) + " evt/s");
    if (arrayOfByte == null) {
      println("");
    } else if (elapsedMillis > 0L) {
      int b = Integer.parseInt(args[2]);
      long addedKiloBytes = count * MemoryUnit.BYTES.toKiloBytes(b);
      println(", " + TimeUnit.MILLISECONDS.toSeconds(addedKiloBytes * 8L / elapsedMillis) + " KBit/s, " + addedKiloBytes + " KB added");
    } 
  }
  
  protected void handleQPollMany(String[] args) {
    int count = 1;
    if (args.length > 1)
      count = Integer.parseInt(args[1]); 
    int c = 1;
    for (int i = 0; i < count; i++) {
      Object obj = getQueue().poll();
      if (obj instanceof byte[]) {
        println(c++ + " " + (byte[])obj.length);
      } else {
        println(c++ + " " + obj);
      } 
    } 
  }
  
  protected void handleQPeek(String[] args) { println(getQueue().peek()); }
  
  protected void handleQCapacity(String[] args) { println(Integer.valueOf(getQueue().remainingCapacity())); }
  
  private void execute(String[] args) { doExecute(false, false, args); }
  
  private void executeOnKey(String[] args) { doExecute(true, false, args); }
  
  private void executeOnMember(String[] args) { doExecute(false, true, args); }
  
  private void doExecute(boolean onKey, boolean onMember, String[] args) {
    try {
      Future<String> future;
      IExecutorService executorService = this.hazelcast.getExecutorService("default");
      Echo callable = new Echo(args[1]);
      if (onKey) {
        String key = args[2];
        future = executorService.submitToKeyOwner(callable, key);
      } else if (onMember) {
        int memberIndex = Integer.parseInt(args[2]);
        List<Member> members = new LinkedList<Member>(this.hazelcast.getCluster().getMembers());
        if (memberIndex >= members.size())
          throw new IndexOutOfBoundsException("Member index: " + memberIndex + " must be smaller than " + members
              .size()); 
        Member member = (Member)members.get(memberIndex);
        future = executorService.submitToMember(callable, member);
      } else {
        future = executorService.submit(callable);
      } 
      println("Result: " + (String)future.get());
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      e.printStackTrace();
    } catch (ExecutionException e) {
      e.printStackTrace();
    } 
  }
  
  private void executeOnMembers(String[] args) {
    try {
      IExecutorService executorService = this.hazelcast.getExecutorService("default");
      Echo task = new Echo(args[1]);
      Map<Member, Future<String>> results = executorService.submitToAllMembers(task);
      for (Future f : results.values())
        println(f.get()); 
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      e.printStackTrace();
    } catch (ExecutionException e) {
      e.printStackTrace();
    } 
  }
  
  public void entryAdded(EntryEvent event) { println(event); }
  
  public void entryRemoved(EntryEvent event) { println(event); }
  
  public void entryUpdated(EntryEvent event) { println(event); }
  
  public void entryEvicted(EntryEvent event) { println(event); }
  
  public void mapEvicted(MapEvent event) { println(event); }
  
  public void mapCleared(MapEvent event) { println(event); }
  
  public void itemAdded(ItemEvent itemEvent) { println("Item added = " + itemEvent.getItem()); }
  
  public void itemRemoved(ItemEvent itemEvent) { println("Item removed = " + itemEvent.getItem()); }
  
  public void onMessage(Message msg) { println("Topic received = " + msg.getMessageObject()); }
  
  private void handleHelp(String command) {
    boolean silentBefore = this.silent;
    this.silent = false;
    println("Commands:");
    printGeneralCommands();
    printQueueCommands();
    printSetCommands();
    printLockCommands();
    printMapCommands();
    printMulitiMapCommands();
    printListCommands();
    printAtomicLongCommands();
    printExecutorServiceCommands();
    this.silent = silentBefore;
  }
  
  private void printGeneralCommands() {
    println("-- General commands");
    println("echo true|false                      //turns on/off echo of commands (default false)");
    println("silent true|false                    //turns on/off silent of command output (default false)");
    println("#<number> <command>                  //repeats <number> time <command>, replace $i in <command> with current iteration (0..<number-1>)");
    println("&<number> <command>                  //forks <number> threads to execute <command>, replace $t in <command> with current thread number (0..<number-1>");
    println("     When using #x or &x, is is advised to use silent true as well.");
    println("     When using &x with m.putmany and m.removemany, each thread will get a different share of keys unless a start key index is specified");
    println("jvm                                  //displays info about the runtime");
    println("who                                  //displays info about the cluster");
    println("whoami                               //displays info about this cluster member");
    println("ns <string>                          //switch the namespace for using the distributed queue/map/set/list <string> (defaults to \"default\"");
    println("@<file>                              //executes the given <file> script. Use '//' for comments in the script");
    println("");
  }
  
  private void printQueueCommands() {
    println("-- Queue commands");
    println("q.offer <string>                     //adds a string object to the queue");
    println("q.poll                               //takes an object from the queue");
    println("q.offermany <number> [<size>]        //adds indicated number of string objects to the queue ('obj<i>' or byte[<size>]) ");
    println("q.pollmany <number>                  //takes indicated number of objects from the queue");
    println("q.iterator [remove]                  //iterates the queue, remove if specified");
    println("q.size                               //size of the queue");
    println("q.clear                              //clears the queue");
    println("");
  }
  
  private void printSetCommands() {
    println("-- Set commands");
    println("s.add <string>                       //adds a string object to the set");
    println("s.remove <string>                    //removes the string object from the set");
    println("s.addmany <number>                   //adds indicated number of string objects to the set ('obj<i>')");
    println("s.removemany <number>                //takes indicated number of objects from the set");
    println("s.iterator [remove]                  //iterates the set, removes if specified");
    println("s.size                               //size of the set");
    println("s.clear                              //clears the set");
    println("");
  }
  
  private void printLockCommands() {
    println("-- Lock commands");
    println("lock <key>                           //same as Hazelcast.getLock(key).lock()");
    println("tryLock <key>                        //same as Hazelcast.getLock(key).tryLock()");
    println("tryLock <key> <time>                 //same as tryLock <key> with timeout in seconds");
    println("unlock <key>                         //same as Hazelcast.getLock(key).unlock()");
    println("");
  }
  
  private void printMapCommands() {
    println("-- Map commands");
    println("m.put <key> <value>                  //puts an entry to the map");
    println("m.remove <key>                       //removes the entry of given key from the map");
    println("m.get <key>                          //returns the value of given key from the map");
    println("m.putmany <number> [<size>] [<index>]//puts indicated number of entries to the map ('key<i>':byte[<size>], <index>+(0..<number>)");
    println("m.removemany <number> [<index>]      //removes indicated number of entries from the map ('key<i>', <index>+(0..<number>)");
    println("     When using &x with m.putmany and m.removemany, each thread will get a different share of keys unless a start key <index> is specified");
    println("m.keys                               //iterates the keys of the map");
    println("m.values                             //iterates the values of the map");
    println("m.entries                            //iterates the entries of the map");
    println("m.iterator [remove]                  //iterates the keys of the map, remove if specified");
    println("m.size                               //size of the map");
    println("m.localSize                          //local size of the map");
    println("m.clear                              //clears the map");
    println("m.destroy                            //destroys the map");
    println("m.lock <key>                         //locks the key");
    println("m.tryLock <key>                      //tries to lock the key and returns immediately");
    println("m.tryLock <key> <time>               //tries to lock the key within given seconds");
    println("m.unlock <key>                       //unlocks the key");
    println("m.stats                              //shows the local stats of the map");
    println("");
  }
  
  private void printMulitiMapCommands() {
    println("-- MultiMap commands");
    println("mm.put <key> <value>                  //puts an entry to the multimap");
    println("mm.get <key>                          //returns the value of given key from the multimap");
    println("mm.remove <key>                       //removes the entry of given key from the multimap");
    println("mm.size                               //size of the multimap");
    println("mm.clear                              //clears the multimap");
    println("mm.destroy                            //destroys the multimap");
    println("mm.iterator [remove]                  //iterates the keys of the multimap, remove if specified");
    println("mm.keys                               //iterates the keys of the multimap");
    println("mm.values                             //iterates the values of the multimap");
    println("mm.entries                            //iterates the entries of the multimap");
    println("mm.lock <key>                         //locks the key");
    println("mm.tryLock <key>                      //tries to lock the key and returns immediately");
    println("mm.tryLock <key> <time>               //tries to lock the key within given seconds");
    println("mm.unlock <key>                       //unlocks the key");
    println("mm.stats                              //shows the local stats of the multimap");
    println("");
  }
  
  private void printExecutorServiceCommands() {
    println("-- Executor Service commands:");
    println("execute <echo-input>                            //executes an echo task on random member");
    println("executeOnKey <echo-input> <key>                  //executes an echo task on the member that owns the given key");
    println("executeOnMember <echo-input> <memberIndex>         //executes an echo task on the member with given index");
    println("executeOnMembers <echo-input>                      //executes an echo task on all of the members");
    println("e<threadcount>.simulateLoad <task-count> <delaySeconds>        //simulates load on executor with given number of thread (e1..e16)");
    println("");
  }
  
  private void printAtomicLongCommands() {
    println("-- IAtomicLong commands:");
    println("a.get");
    println("a.set <long>");
    println("a.inc");
    println("a.dec");
    print("");
  }
  
  private void printListCommands() {
    println("-- List commands:");
    println("l.add <string>");
    println("l.add <index> <string>");
    println("l.contains <string>");
    println("l.remove <string>");
    println("l.remove <index>");
    println("l.set <index> <string>");
    println("l.iterator [remove]");
    println("l.size");
    println("l.clear");
    print("");
  }
  
  public void println(Object obj) {
    if (!this.silent)
      System.out.println(obj); 
  }
  
  public void print(Object obj) {
    if (!this.silent)
      System.out.print(obj); 
  }
  
  public static void main(String[] args) {
    Config config;
    try {
      config = new FileSystemXmlConfig("hazelcast.xml");
    } catch (FileNotFoundException e) {
      config = new Config();
    } 
    for (int i = 1; i <= 16; i++)
      config.addExecutorConfig((new ExecutorConfig("Sample Executor " + i)).setPoolSize(i)); 
    ConsoleApp consoleApp = new ConsoleApp(Hazelcast.newHazelcastInstance(config));
    consoleApp.start();
  }
}
