package com.hazelcast.flakeidgen.impl;

import com.hazelcast.config.FlakeIdGeneratorConfig;
import com.hazelcast.core.HazelcastException;
import com.hazelcast.core.Member;
import com.hazelcast.flakeidgen.FlakeIdGenerator;
import com.hazelcast.internal.util.ThreadLocalRandomProvider;
import com.hazelcast.logging.ILogger;
import com.hazelcast.spi.AbstractDistributedObject;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.util.Clock;
import com.hazelcast.util.Preconditions;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

public class FlakeIdGeneratorProxy extends AbstractDistributedObject<FlakeIdGeneratorService> implements FlakeIdGenerator {
  public static final int BITS_TIMESTAMP = 41;
  
  public static final int BITS_SEQUENCE = 6;
  
  public static final int BITS_NODE_ID = 16;
  
  public static final long INCREMENT = 65536L;
  
  static final long ALLOWED_FUTURE_MILLIS = 15000L;
  
  static final long EPOCH_START = 1514764800000L;
  
  static final long NODE_ID_UPDATE_INTERVAL_NS = TimeUnit.SECONDS.toNanos(2L);
  
  private static final int NODE_ID_NOT_YET_SET = -1;
  
  private static final int NODE_ID_OUT_OF_RANGE = -2;
  
  private final String name;
  
  private final long epochStart;
  
  private final long nodeIdOffset;
  
  private final ILogger logger;
  
  private final AtomicLong generatedValue = new AtomicLong(Float.MIN_VALUE);
  
  private AutoBatcher batcher;
  
  private final Set<String> outOfRangeMembers = Collections.newSetFromMap(new ConcurrentHashMap());
  
  FlakeIdGeneratorProxy(String name, NodeEngine nodeEngine, FlakeIdGeneratorService service) {
    super(nodeEngine, service);
    this.name = name;
    this.logger = nodeEngine.getLogger(getClass());
    FlakeIdGeneratorConfig config = nodeEngine.getConfig().findFlakeIdGeneratorConfig(getName());
    this.epochStart = 1514764800000L - (config.getIdOffset() >> 22);
    this.nodeIdOffset = config.getNodeIdOffset();
    this.batcher = new AutoBatcher(config.getPrefetchCount(), config.getPrefetchValidityMillis(), new Object(this));
    if (this.logger.isFinestEnabled())
      this.logger.finest("Created FlakeIdGeneratorProxy, name='" + name + "'"); 
  }
  
  public long newId() { return this.batcher.newId(); }
  
  public boolean init(long id) {
    long reserve = TimeUnit.HOURS.toMillis(1L) << 22;
    return (newId() >= id + reserve);
  }
  
  public IdBatchAndWaitTime newIdBatch(int batchSize) {
    int nodeId = getNodeId();
    if (nodeId >= 0)
      return newIdBaseLocal(Clock.currentTimeMillis(), nodeId, batchSize); 
    while (true) {
      NewIdBatchOperation op = new NewIdBatchOperation(this.name, batchSize);
      Member target = getRandomMember();
      InternalCompletableFuture<Long> future = getNodeEngine().getOperationService().invokeOnTarget(getServiceName(), op, target.getAddress());
      try {
        long base = ((Long)future.join()).longValue();
        return new IdBatchAndWaitTime(new IdBatch(base, 65536L, batchSize), 0L);
      } catch (NodeIdOutOfRangeException e) {
        this.outOfRangeMembers.add(target.getUuid());
        this.randomMember = null;
      } 
    } 
  }
  
  IdBatchAndWaitTime newIdBaseLocal(int batchSize) { return newIdBaseLocal(Clock.currentTimeMillis(), getNodeId(), batchSize); }
  
  IdBatchAndWaitTime newIdBaseLocal(long now, int nodeId, int batchSize) {
    long oldGeneratedValue;
    Preconditions.checkPositive(batchSize, "batchSize");
    if (nodeId == -2)
      throw new NodeIdOutOfRangeException("NodeID overflow, this member cannot generate IDs"); 
    assert (nodeId & 0xFFFF0000) == 0 : "nodeId out of range: " + nodeId;
    now -= this.epochStart;
    if (now < -2199023255552L || now >= 2199023255552L)
      throw new HazelcastException("Current time out of allowed range"); 
    now <<= 6;
    do {
      oldGeneratedValue = this.generatedValue.get();
      base = Math.max(now, oldGeneratedValue);
    } while (!this.generatedValue.compareAndSet(oldGeneratedValue, base + batchSize));
    long waitTime = Math.max(0L, (base + batchSize - now >> 6) - 15000L);
    long base = base << 16 | nodeId;
    ((FlakeIdGeneratorService)getService()).updateStatsForBatch(this.name, batchSize);
    return new IdBatchAndWaitTime(new IdBatch(base, 65536L, batchSize), waitTime);
  }
  
  private int getNodeId() { return getNodeId(System.nanoTime()); }
  
  int getNodeId(long nanoTime) {
    int nodeId = this.nodeId;
    if (nodeId != -2 && this.nextNodeIdUpdate <= nanoTime) {
      int newNodeId = getNodeEngine().getClusterService().getMemberListJoinVersion();
      assert newNodeId >= 0 : "newNodeId=" + newNodeId;
      newNodeId = (int)(newNodeId + this.nodeIdOffset);
      this.nextNodeIdUpdate = nanoTime + NODE_ID_UPDATE_INTERVAL_NS;
      if (newNodeId != nodeId) {
        nodeId = newNodeId;
        if ((nodeId & 0xFFFF0000) != 0) {
          this.outOfRangeMembers.add(getNodeEngine().getClusterService().getLocalMember().getUuid());
          this.logger.severe("Node ID is out of range (" + nodeId + "), this member won't be able to generate IDs. Cluster restart is recommended.");
          nodeId = -2;
        } 
        this.nodeId = nodeId;
        if (this.logger.isFineEnabled())
          this.logger.fine("Node ID assigned to '" + this.name + "': " + nodeId); 
      } 
    } 
    return nodeId;
  }
  
  private Member getRandomMember() {
    Member member = this.randomMember;
    if (member == null) {
      Set<Member> members = getNodeEngine().getClusterService().getMembers();
      List<Member> filteredMembers = new ArrayList<Member>(members.size());
      for (Member m : members) {
        if (!this.outOfRangeMembers.contains(m.getUuid()))
          filteredMembers.add(m); 
      } 
      if (filteredMembers.isEmpty())
        throw new HazelcastException("All members have node ID out of range. Cluster restart is required"); 
      member = (Member)filteredMembers.get(ThreadLocalRandomProvider.get().nextInt(filteredMembers.size()));
      this.randomMember = member;
    } 
    return member;
  }
  
  public String getName() { return this.name; }
  
  public String getServiceName() { return "hz:impl:flakeIdGeneratorService"; }
}
