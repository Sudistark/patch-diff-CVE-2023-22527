package com.hazelcast.com.fasterxml.jackson.core;

import com.hazelcast.com.fasterxml.jackson.core.async.NonBlockingInputFeeder;
import com.hazelcast.com.fasterxml.jackson.core.exc.InputCoercionException;
import com.hazelcast.com.fasterxml.jackson.core.type.TypeReference;
import com.hazelcast.com.fasterxml.jackson.core.util.RequestPayload;
import java.io.Closeable;
import java.io.IOException;
import java.io.OutputStream;
import java.io.Writer;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Iterator;

public abstract class JsonParser implements Closeable, Versioned {
  private static final int MIN_BYTE_I = -128;
  
  private static final int MAX_BYTE_I = 255;
  
  private static final int MIN_SHORT_I = -32768;
  
  private static final int MAX_SHORT_I = 32767;
  
  protected int _features;
  
  protected RequestPayload _requestPayload;
  
  protected JsonParser() {}
  
  protected JsonParser(int features) { this._features = features; }
  
  public abstract ObjectCodec getCodec();
  
  public abstract void setCodec(ObjectCodec paramObjectCodec);
  
  public Object getInputSource() { return null; }
  
  public Object getCurrentValue() {
    JsonStreamContext ctxt = getParsingContext();
    return (ctxt == null) ? null : ctxt.getCurrentValue();
  }
  
  public void setCurrentValue(Object v) {
    JsonStreamContext ctxt = getParsingContext();
    if (ctxt != null)
      ctxt.setCurrentValue(v); 
  }
  
  public void setRequestPayloadOnError(RequestPayload payload) { this._requestPayload = payload; }
  
  public void setRequestPayloadOnError(byte[] payload, String charset) { this._requestPayload = (payload == null) ? null : new RequestPayload(payload, charset); }
  
  public void setRequestPayloadOnError(String payload) { this._requestPayload = (payload == null) ? null : new RequestPayload(payload); }
  
  public void setSchema(FormatSchema schema) {
    throw new UnsupportedOperationException("Parser of type " + getClass().getName() + " does not support schema of type '" + schema
        .getSchemaType() + "'");
  }
  
  public FormatSchema getSchema() { return null; }
  
  public boolean canUseSchema(FormatSchema schema) { return false; }
  
  public boolean requiresCustomCodec() { return false; }
  
  public boolean canParseAsync() { return false; }
  
  public NonBlockingInputFeeder getNonBlockingInputFeeder() { return null; }
  
  public abstract Version version();
  
  public abstract void close();
  
  public abstract boolean isClosed();
  
  public abstract JsonStreamContext getParsingContext();
  
  public abstract JsonLocation getTokenLocation();
  
  public abstract JsonLocation getCurrentLocation();
  
  public int releaseBuffered(OutputStream out) throws IOException { return -1; }
  
  public int releaseBuffered(Writer w) throws IOException { return -1; }
  
  public JsonParser enable(Feature f) {
    this._features |= f.getMask();
    return this;
  }
  
  public JsonParser disable(Feature f) {
    this._features &= (f.getMask() ^ 0xFFFFFFFF);
    return this;
  }
  
  public JsonParser configure(Feature f, boolean state) {
    if (state) {
      enable(f);
    } else {
      disable(f);
    } 
    return this;
  }
  
  public boolean isEnabled(Feature f) { return f.enabledIn(this._features); }
  
  public boolean isEnabled(StreamReadFeature f) { return f.mappedFeature().enabledIn(this._features); }
  
  public int getFeatureMask() { return this._features; }
  
  @Deprecated
  public JsonParser setFeatureMask(int mask) {
    this._features = mask;
    return this;
  }
  
  public JsonParser overrideStdFeatures(int values, int mask) {
    int newState = this._features & (mask ^ 0xFFFFFFFF) | values & mask;
    return setFeatureMask(newState);
  }
  
  public int getFormatFeatures() { return 0; }
  
  public JsonParser overrideFormatFeatures(int values, int mask) { return this; }
  
  public abstract JsonToken nextToken() throws IOException;
  
  public abstract JsonToken nextValue() throws IOException;
  
  public boolean nextFieldName(SerializableString str) throws IOException { return (nextToken() == JsonToken.FIELD_NAME && str.getValue().equals(getCurrentName())); }
  
  public String nextFieldName() throws IOException { return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null; }
  
  public String nextTextValue() throws IOException { return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; }
  
  public int nextIntValue(int defaultValue) throws IOException { return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; }
  
  public long nextLongValue(long defaultValue) throws IOException { return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; }
  
  public Boolean nextBooleanValue() throws IOException {
    JsonToken t = nextToken();
    if (t == JsonToken.VALUE_TRUE)
      return Boolean.TRUE; 
    if (t == JsonToken.VALUE_FALSE)
      return Boolean.FALSE; 
    return null;
  }
  
  public abstract JsonParser skipChildren() throws IOException;
  
  public void finishToken() {}
  
  public JsonToken currentToken() throws IOException { return getCurrentToken(); }
  
  public int currentTokenId() { return getCurrentTokenId(); }
  
  public abstract JsonToken getCurrentToken() throws IOException;
  
  public abstract int getCurrentTokenId();
  
  public abstract boolean hasCurrentToken();
  
  public abstract boolean hasTokenId(int paramInt);
  
  public abstract boolean hasToken(JsonToken paramJsonToken);
  
  public boolean isExpectedStartArrayToken() { return (currentToken() == JsonToken.START_ARRAY); }
  
  public boolean isExpectedStartObjectToken() { return (currentToken() == JsonToken.START_OBJECT); }
  
  public boolean isNaN() { return false; }
  
  public abstract void clearCurrentToken();
  
  public abstract JsonToken getLastClearedToken() throws IOException;
  
  public abstract void overrideCurrentName(String paramString);
  
  public abstract String getCurrentName() throws IOException;
  
  public String currentName() throws IOException { return getCurrentName(); }
  
  public abstract String getText() throws IOException;
  
  public int getText(Writer writer) throws IOException {
    String str = getText();
    if (str == null)
      return 0; 
    writer.write(str);
    return str.length();
  }
  
  public abstract char[] getTextCharacters() throws IOException;
  
  public abstract int getTextLength();
  
  public abstract int getTextOffset();
  
  public abstract boolean hasTextCharacters();
  
  public abstract Number getNumberValue() throws IOException;
  
  public abstract NumberType getNumberType() throws IOException;
  
  public byte getByteValue() throws IOException {
    int value = getIntValue();
    if (value < -128 || value > 255)
      throw new InputCoercionException(this, 
          String.format("Numeric value (%s) out of range of Java byte", new Object[] { getText() }), JsonToken.VALUE_NUMBER_INT, byte.class); 
    return (byte)value;
  }
  
  public short getShortValue() throws IOException {
    int value = getIntValue();
    if (value < -32768 || value > 32767)
      throw new InputCoercionException(this, 
          String.format("Numeric value (%s) out of range of Java short", new Object[] { getText() }), JsonToken.VALUE_NUMBER_INT, short.class); 
    return (short)value;
  }
  
  public abstract int getIntValue();
  
  public abstract long getLongValue() throws IOException;
  
  public abstract BigInteger getBigIntegerValue() throws IOException;
  
  public abstract float getFloatValue() throws IOException;
  
  public abstract double getDoubleValue() throws IOException;
  
  public abstract BigDecimal getDecimalValue() throws IOException;
  
  public boolean getBooleanValue() {
    JsonToken t = currentToken();
    if (t == JsonToken.VALUE_TRUE)
      return true; 
    if (t == JsonToken.VALUE_FALSE)
      return false; 
    throw (new JsonParseException(this, 
        String.format("Current token (%s) not of boolean type", new Object[] { t }))).withRequestPayload(this._requestPayload);
  }
  
  public Object getEmbeddedObject() { return null; }
  
  public abstract byte[] getBinaryValue(Base64Variant paramBase64Variant) throws IOException;
  
  public byte[] getBinaryValue() throws IOException { return getBinaryValue(Base64Variants.getDefaultVariant()); }
  
  public int readBinaryValue(OutputStream out) throws IOException { return readBinaryValue(Base64Variants.getDefaultVariant(), out); }
  
  public int readBinaryValue(Base64Variant bv, OutputStream out) throws IOException {
    _reportUnsupportedOperation();
    return 0;
  }
  
  public int getValueAsInt() { return getValueAsInt(0); }
  
  public int getValueAsInt(int def) throws IOException { return def; }
  
  public long getValueAsLong() throws IOException { return getValueAsLong(0L); }
  
  public long getValueAsLong(long def) throws IOException { return def; }
  
  public double getValueAsDouble() throws IOException { return getValueAsDouble(0.0D); }
  
  public double getValueAsDouble(double def) throws IOException { return def; }
  
  public boolean getValueAsBoolean() { return getValueAsBoolean(false); }
  
  public boolean getValueAsBoolean(boolean def) throws IOException { return def; }
  
  public String getValueAsString() throws IOException { return getValueAsString(null); }
  
  public abstract String getValueAsString(String paramString) throws IOException;
  
  public boolean canReadObjectId() { return false; }
  
  public boolean canReadTypeId() { return false; }
  
  public Object getObjectId() { return null; }
  
  public Object getTypeId() { return null; }
  
  public <T> T readValueAs(Class<T> valueType) throws IOException { return (T)_codec().readValue(this, valueType); }
  
  public <T> T readValueAs(TypeReference<?> valueTypeRef) throws IOException { return (T)_codec().readValue(this, valueTypeRef); }
  
  public <T> Iterator<T> readValuesAs(Class<T> valueType) throws IOException { return _codec().readValues(this, valueType); }
  
  public <T> Iterator<T> readValuesAs(TypeReference<T> valueTypeRef) throws IOException { return _codec().readValues(this, valueTypeRef); }
  
  public <T extends TreeNode> T readValueAsTree() throws IOException { return (T)_codec().readTree(this); }
  
  protected ObjectCodec _codec() {
    ObjectCodec c = getCodec();
    if (c == null)
      throw new IllegalStateException("No ObjectCodec defined for parser, needed for deserialization"); 
    return c;
  }
  
  protected JsonParseException _constructError(String msg) {
    return (new JsonParseException(this, msg))
      .withRequestPayload(this._requestPayload);
  }
  
  protected void _reportUnsupportedOperation() { throw new UnsupportedOperationException("Operation not supported by parser of type " + getClass().getName()); }
}
