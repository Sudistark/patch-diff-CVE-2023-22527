package com.hazelcast.replicatedmap.merge;

import com.hazelcast.config.InvalidConfigurationException;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.merge.SplitBrainMergePolicyProvider;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public final class MergePolicyProvider {
  private final ConcurrentMap<String, ReplicatedMapMergePolicy> mergePolicyMap;
  
  private final ConstructorFunction<String, ReplicatedMapMergePolicy> policyConstructorFunction;
  
  private final NodeEngine nodeEngine;
  
  private final SplitBrainMergePolicyProvider policyProvider;
  
  public MergePolicyProvider(NodeEngine nodeEngine) {
    this.mergePolicyMap = new ConcurrentHashMap();
    this.policyConstructorFunction = new Object(this);
    this.nodeEngine = nodeEngine;
    this.policyProvider = nodeEngine.getSplitBrainMergePolicyProvider();
    addOutOfBoxPolicies();
  }
  
  private void addOutOfBoxPolicies() {
    this.mergePolicyMap.put(PutIfAbsentMapMergePolicy.class.getName(), PutIfAbsentMapMergePolicy.INSTANCE);
    this.mergePolicyMap.put(HigherHitsMapMergePolicy.class.getName(), HigherHitsMapMergePolicy.INSTANCE);
    this.mergePolicyMap.put(PassThroughMergePolicy.class.getName(), PassThroughMergePolicy.INSTANCE);
    this.mergePolicyMap.put(LatestUpdateMapMergePolicy.class.getName(), LatestUpdateMapMergePolicy.INSTANCE);
  }
  
  public Object getMergePolicy(String className) {
    if (className == null)
      throw new InvalidConfigurationException("Class name is mandatory!"); 
    try {
      return this.policyProvider.getMergePolicy(className);
    } catch (InvalidConfigurationException e) {
      return ConcurrencyUtil.getOrPutIfAbsent(this.mergePolicyMap, className, this.policyConstructorFunction);
    } 
  }
}
