package com.hazelcast.replicatedmap.impl.operation;

import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.replicatedmap.impl.PartitionContainer;
import com.hazelcast.replicatedmap.impl.ReplicatedMapService;
import com.hazelcast.replicatedmap.impl.record.AbstractReplicatedRecordStore;
import com.hazelcast.replicatedmap.impl.record.RecordMigrationInfo;
import com.hazelcast.replicatedmap.impl.record.ReplicatedRecord;
import com.hazelcast.replicatedmap.impl.record.ReplicatedRecordStore;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.MapUtil;
import com.hazelcast.util.SetUtil;
import java.io.IOException;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class ReplicationOperation extends AbstractSerializableOperation {
  private SerializationService serializationService;
  
  private Map<String, Set<RecordMigrationInfo>> data;
  
  private Map<String, Long> versions;
  
  public ReplicationOperation() {}
  
  public ReplicationOperation(SerializationService serializationService, PartitionContainer container, int partitionId) {
    this.serializationService = serializationService;
    setPartitionId(partitionId);
    fetchReplicatedMapRecords(container);
  }
  
  public void run() {
    ILogger logger = getLogger();
    if (logger.isFineEnabled())
      logger.fine("Moving replicated map (partitionId " + getPartitionId() + ") from " + getCallerAddress() + " to the new owner " + 
          getNodeEngine().getThisAddress()); 
    ReplicatedMapService service = (ReplicatedMapService)getService();
    if (this.data == null)
      return; 
    fillRecordStoreWithRecords(service);
  }
  
  public String getServiceName() { return "hz:impl:replicatedMapService"; }
  
  private void fetchReplicatedMapRecords(PartitionContainer container) {
    int storeCount = container.getStores().size();
    this.data = MapUtil.createHashMap(storeCount);
    this.versions = MapUtil.createHashMap(storeCount);
    for (Map.Entry<String, ReplicatedRecordStore> entry : container.getStores().entrySet()) {
      String name = (String)entry.getKey();
      ReplicatedRecordStore store = (ReplicatedRecordStore)entry.getValue();
      Set<RecordMigrationInfo> recordSet = SetUtil.createHashSet(store.size());
      Iterator<ReplicatedRecord> iterator = store.recordIterator();
      while (iterator.hasNext()) {
        ReplicatedRecord record = (ReplicatedRecord)iterator.next();
        Data dataKey = this.serializationService.toData(record.getKeyInternal());
        Data dataValue = this.serializationService.toData(record.getValueInternal());
        RecordMigrationInfo migrationInfo = new RecordMigrationInfo();
        migrationInfo.setKey(dataKey);
        migrationInfo.setValue(dataValue);
        migrationInfo.setTtl(record.getTtlMillis());
        migrationInfo.setHits(record.getHits());
        migrationInfo.setCreationTime(record.getCreationTime());
        migrationInfo.setLastAccessTime(record.getLastAccessTime());
        migrationInfo.setLastUpdateTime(record.getUpdateTime());
        recordSet.add(migrationInfo);
      } 
      this.data.put(name, recordSet);
      this.versions.put(name, Long.valueOf(store.getVersion()));
    } 
  }
  
  private void fillRecordStoreWithRecords(ReplicatedMapService service) {
    for (Map.Entry<String, Set<RecordMigrationInfo>> dataEntry : this.data.entrySet()) {
      Set<RecordMigrationInfo> recordSet = (Set)dataEntry.getValue();
      String name = (String)dataEntry.getKey();
      AbstractReplicatedRecordStore store = (AbstractReplicatedRecordStore)service.getReplicatedRecordStore(name, true, getPartitionId());
      long version = ((Long)this.versions.get(name)).longValue();
      store.putRecords(recordSet, version);
      store.setLoaded(true);
    } 
  }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException {
    out.writeInt(this.data.size());
    for (Map.Entry<String, Set<RecordMigrationInfo>> entry : this.data.entrySet()) {
      out.writeUTF((String)entry.getKey());
      Set<RecordMigrationInfo> recordSet = (Set)entry.getValue();
      out.writeInt(recordSet.size());
      for (RecordMigrationInfo record : recordSet)
        record.writeData(out); 
    } 
    out.writeInt(this.versions.size());
    for (Map.Entry<String, Long> entry : this.versions.entrySet()) {
      out.writeUTF((String)entry.getKey());
      out.writeLong(((Long)entry.getValue()).longValue());
    } 
  }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    int size = in.readInt();
    this.data = MapUtil.createHashMap(size);
    for (int i = 0; i < size; i++) {
      String name = in.readUTF();
      int mapSize = in.readInt();
      Set<RecordMigrationInfo> recordSet = SetUtil.createHashSet(mapSize);
      for (int j = 0; j < mapSize; j++) {
        RecordMigrationInfo record = new RecordMigrationInfo();
        record.readData(in);
        recordSet.add(record);
      } 
      this.data.put(name, recordSet);
    } 
    int versionsSize = in.readInt();
    this.versions = MapUtil.createHashMap(versionsSize);
    for (int i = 0; i < versionsSize; i++) {
      String name = in.readUTF();
      long version = in.readLong();
      this.versions.put(name, Long.valueOf(version));
    } 
  }
  
  public boolean isEmpty() { return (this.data == null || this.data.isEmpty()); }
  
  public int getId() { return 19; }
}
