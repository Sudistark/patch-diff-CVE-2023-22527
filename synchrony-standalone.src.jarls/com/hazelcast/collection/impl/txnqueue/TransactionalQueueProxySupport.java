package com.hazelcast.collection.impl.txnqueue;

import com.hazelcast.collection.impl.queue.QueueItem;
import com.hazelcast.collection.impl.queue.QueueService;
import com.hazelcast.collection.impl.queue.operations.SizeOperation;
import com.hazelcast.collection.impl.txnqueue.operations.BaseTxnQueueOperation;
import com.hazelcast.collection.impl.txnqueue.operations.TxnOfferOperation;
import com.hazelcast.collection.impl.txnqueue.operations.TxnPeekOperation;
import com.hazelcast.collection.impl.txnqueue.operations.TxnPollOperation;
import com.hazelcast.collection.impl.txnqueue.operations.TxnReserveOfferOperation;
import com.hazelcast.collection.impl.txnqueue.operations.TxnReservePollOperation;
import com.hazelcast.config.QueueConfig;
import com.hazelcast.core.TransactionalQueue;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.OperationService;
import com.hazelcast.spi.TransactionalDistributedObject;
import com.hazelcast.transaction.TransactionException;
import com.hazelcast.transaction.TransactionNotActiveException;
import com.hazelcast.transaction.impl.Transaction;
import com.hazelcast.util.ExceptionUtil;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Set;

public abstract class TransactionalQueueProxySupport<E> extends TransactionalDistributedObject<QueueService> implements TransactionalQueue<E> {
  protected final String name;
  
  protected final int partitionId;
  
  protected final QueueConfig config;
  
  private final LinkedList<QueueItem> offeredQueue = new LinkedList();
  
  private final Set<Long> itemIdSet = new HashSet();
  
  TransactionalQueueProxySupport(NodeEngine nodeEngine, QueueService service, String name, Transaction tx) {
    super(nodeEngine, service, tx);
    this.name = name;
    this.partitionId = nodeEngine.getPartitionService().getPartitionId(getNameAsPartitionAwareData());
    this.config = nodeEngine.getConfig().findQueueConfig(name);
  }
  
  public String getName() { return this.name; }
  
  public final String getServiceName() { return "hz:impl:queueService"; }
  
  public int size() {
    checkTransactionState();
    SizeOperation operation = new SizeOperation(this.name);
    try {
      InternalCompletableFuture internalCompletableFuture = invoke(operation);
      Integer size = (Integer)internalCompletableFuture.get();
      return size.intValue() + this.offeredQueue.size();
    } catch (Throwable t) {
      throw ExceptionUtil.rethrow(t);
    } 
  }
  
  void checkTransactionState() {
    if (!this.tx.getState().equals(Transaction.State.ACTIVE))
      throw new TransactionNotActiveException("Transaction is not active!"); 
  }
  
  boolean offerInternal(Data data, long timeout) {
    TxnReserveOfferOperation operation = new TxnReserveOfferOperation(this.name, timeout, this.offeredQueue.size(), this.tx.getTxnId());
    operation.setCallerUuid(this.tx.getOwnerUuid());
    try {
      InternalCompletableFuture internalCompletableFuture = invoke(operation);
      Long itemId = (Long)internalCompletableFuture.get();
      if (itemId != null) {
        if (!this.itemIdSet.add(itemId))
          throw new TransactionException("Duplicate itemId: " + itemId); 
        this.offeredQueue.offer(new QueueItem(null, itemId.longValue(), data));
        TxnOfferOperation txnOfferOperation = new TxnOfferOperation(this.name, itemId.longValue(), data);
        putToRecord(txnOfferOperation);
        return true;
      } 
    } catch (Throwable t) {
      throw ExceptionUtil.rethrow(t);
    } 
    return false;
  }
  
  Data pollInternal(long timeout) {
    QueueItem reservedOffer = (QueueItem)this.offeredQueue.peek();
    long itemId = (reservedOffer == null) ? -1L : reservedOffer.getItemId();
    TxnReservePollOperation operation = new TxnReservePollOperation(this.name, timeout, itemId, this.tx.getTxnId());
    operation.setCallerUuid(this.tx.getOwnerUuid());
    try {
      InternalCompletableFuture internalCompletableFuture = invoke(operation);
      QueueItem item = (QueueItem)internalCompletableFuture.get();
      if (item != null) {
        if (reservedOffer != null && item.getItemId() == reservedOffer.getItemId()) {
          this.offeredQueue.poll();
          removeFromRecord(reservedOffer.getItemId());
          this.itemIdSet.remove(Long.valueOf(reservedOffer.getItemId()));
          return reservedOffer.getData();
        } 
        if (!this.itemIdSet.add(Long.valueOf(item.getItemId())))
          throw new TransactionException("Duplicate itemId: " + item.getItemId()); 
        TxnPollOperation txnPollOperation = new TxnPollOperation(this.name, item.getItemId());
        putToRecord(txnPollOperation);
        return item.getData();
      } 
    } catch (Throwable t) {
      throw ExceptionUtil.rethrow(t);
    } 
    return null;
  }
  
  Data peekInternal(long timeout) {
    QueueItem offer = (QueueItem)this.offeredQueue.peek();
    long itemId = (offer == null) ? -1L : offer.getItemId();
    TxnPeekOperation operation = new TxnPeekOperation(this.name, timeout, itemId, this.tx.getTxnId());
    try {
      InternalCompletableFuture internalCompletableFuture = invoke(operation);
      QueueItem item = (QueueItem)internalCompletableFuture.get();
      if (item != null) {
        if (offer != null && item.getItemId() == offer.getItemId())
          return offer.getData(); 
        return item.getData();
      } 
    } catch (Throwable t) {
      throw ExceptionUtil.rethrow(t);
    } 
    return null;
  }
  
  private void putToRecord(BaseTxnQueueOperation operation) {
    QueueTransactionLogRecord logRecord = (QueueTransactionLogRecord)this.tx.get(this.name);
    if (logRecord == null) {
      logRecord = new QueueTransactionLogRecord(this.tx.getTxnId(), this.name, this.partitionId);
      this.tx.add(logRecord);
    } 
    logRecord.addOperation(operation);
  }
  
  private void removeFromRecord(long itemId) {
    QueueTransactionLogRecord logRecord = (QueueTransactionLogRecord)this.tx.get(this.name);
    int size = logRecord.removeOperation(itemId);
    if (size == 0)
      this.tx.remove(this.name); 
  }
  
  private <T> InternalCompletableFuture<T> invoke(Operation operation) {
    OperationService operationService = getNodeEngine().getOperationService();
    return operationService.invokeOnPartition("hz:impl:queueService", operation, this.partitionId);
  }
}
