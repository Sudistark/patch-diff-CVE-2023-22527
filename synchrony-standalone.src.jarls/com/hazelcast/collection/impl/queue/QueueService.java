package com.hazelcast.collection.impl.queue;

import com.hazelcast.collection.impl.common.DataAwareItemEvent;
import com.hazelcast.collection.impl.queue.operations.QueueReplicationOperation;
import com.hazelcast.collection.impl.txnqueue.TransactionalQueueProxy;
import com.hazelcast.collection.impl.txnqueue.operations.QueueTransactionRollbackOperation;
import com.hazelcast.config.QueueConfig;
import com.hazelcast.core.DistributedObject;
import com.hazelcast.core.ItemEventType;
import com.hazelcast.core.ItemListener;
import com.hazelcast.instance.MemberImpl;
import com.hazelcast.internal.config.ConfigValidator;
import com.hazelcast.logging.ILogger;
import com.hazelcast.monitor.LocalQueueStats;
import com.hazelcast.monitor.impl.LocalQueueStatsImpl;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.partition.strategy.StringPartitioningStrategy;
import com.hazelcast.spi.EventPublishingService;
import com.hazelcast.spi.EventRegistration;
import com.hazelcast.spi.EventService;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.MigrationAwareService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.OperationService;
import com.hazelcast.spi.PartitionMigrationEvent;
import com.hazelcast.spi.PartitionReplicationEvent;
import com.hazelcast.spi.QuorumAwareService;
import com.hazelcast.spi.RemoteService;
import com.hazelcast.spi.SplitBrainHandlerService;
import com.hazelcast.spi.StatisticsAwareService;
import com.hazelcast.spi.TaskScheduler;
import com.hazelcast.spi.TransactionalService;
import com.hazelcast.spi.partition.IPartition;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.spi.partition.MigrationEndpoint;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.transaction.TransactionalObject;
import com.hazelcast.transaction.impl.Transaction;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.ContextMutexFactory;
import com.hazelcast.util.MapUtil;
import com.hazelcast.util.scheduler.EntryTaskScheduler;
import com.hazelcast.util.scheduler.EntryTaskSchedulerFactory;
import com.hazelcast.util.scheduler.ScheduleType;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class QueueService extends Object implements ManagedService, MigrationAwareService, TransactionalService, RemoteService, EventPublishingService<QueueEvent, ItemListener>, StatisticsAwareService<LocalQueueStats>, QuorumAwareService, SplitBrainHandlerService {
  public static final String SERVICE_NAME = "hz:impl:queueService";
  
  private static final Object NULL_OBJECT = new Object();
  
  private final ConcurrentMap<String, QueueContainer> containerMap;
  
  private final ConcurrentMap<String, LocalQueueStatsImpl> statsMap;
  
  private final ConstructorFunction<String, LocalQueueStatsImpl> localQueueStatsConstructorFunction;
  
  private final ConcurrentMap<String, Object> quorumConfigCache;
  
  private final ContextMutexFactory quorumConfigCacheMutexFactory;
  
  private final ConstructorFunction<String, Object> quorumConfigConstructor;
  
  private final NodeEngine nodeEngine;
  
  private final SerializationService serializationService;
  
  private final IPartitionService partitionService;
  
  private final ILogger logger;
  
  private final EntryTaskScheduler<String, Void> queueEvictionScheduler;
  
  public QueueService(NodeEngine nodeEngine) {
    this.containerMap = new ConcurrentHashMap();
    this.statsMap = new ConcurrentHashMap(1000);
    this.localQueueStatsConstructorFunction = new Object(this);
    this.quorumConfigCache = new ConcurrentHashMap();
    this.quorumConfigCacheMutexFactory = new ContextMutexFactory();
    this.quorumConfigConstructor = new Object(this);
    this.nodeEngine = nodeEngine;
    this.serializationService = nodeEngine.getSerializationService();
    this.partitionService = nodeEngine.getPartitionService();
    this.logger = nodeEngine.getLogger(QueueService.class);
    TaskScheduler globalScheduler = nodeEngine.getExecutionService().getGlobalTaskScheduler();
    QueueEvictionProcessor entryProcessor = new QueueEvictionProcessor(nodeEngine);
    this.queueEvictionScheduler = EntryTaskSchedulerFactory.newScheduler(globalScheduler, entryProcessor, ScheduleType.POSTPONE);
  }
  
  public void scheduleEviction(String name, long delay) { this.queueEvictionScheduler.schedule(delay, name, null); }
  
  public void cancelEviction(String name) { this.queueEvictionScheduler.cancel(name); }
  
  public void init(NodeEngine nodeEngine, Properties properties) {}
  
  public void reset() { this.containerMap.clear(); }
  
  public void shutdown(boolean terminate) { reset(); }
  
  public QueueContainer getOrCreateContainer(String name, boolean fromBackup) {
    QueueContainer container = (QueueContainer)this.containerMap.get(name);
    if (container != null)
      return container; 
    container = new QueueContainer(name, this.nodeEngine.getConfig().findQueueConfig(name), this.nodeEngine, this);
    QueueContainer existing = (QueueContainer)this.containerMap.putIfAbsent(name, container);
    if (existing != null) {
      container = existing;
    } else {
      container.init(fromBackup);
      container.getStore().instrument(this.nodeEngine);
    } 
    return container;
  }
  
  public void addContainer(String name, QueueContainer container) { this.containerMap.put(name, container); }
  
  public boolean containsQueue(String name) { return this.containerMap.containsKey(name); }
  
  public void beforeMigration(PartitionMigrationEvent partitionMigrationEvent) {}
  
  public Operation prepareReplicationOperation(PartitionReplicationEvent event) {
    Map<String, QueueContainer> migrationData = new HashMap<String, QueueContainer>();
    for (Map.Entry<String, QueueContainer> entry : this.containerMap.entrySet()) {
      String name = (String)entry.getKey();
      int partitionId = this.partitionService.getPartitionId(StringPartitioningStrategy.getPartitionKey(name));
      QueueContainer container = (QueueContainer)entry.getValue();
      if (partitionId == event.getPartitionId() && container.getConfig().getTotalBackupCount() >= event.getReplicaIndex())
        migrationData.put(name, container); 
    } 
    if (migrationData.isEmpty())
      return null; 
    return new QueueReplicationOperation(migrationData, event.getPartitionId(), event.getReplicaIndex());
  }
  
  public void commitMigration(PartitionMigrationEvent event) {
    if (event.getMigrationEndpoint() == MigrationEndpoint.SOURCE)
      clearQueuesHavingLesserBackupCountThan(event.getPartitionId(), event.getNewReplicaIndex()); 
  }
  
  public void rollbackMigration(PartitionMigrationEvent event) {
    if (event.getMigrationEndpoint() == MigrationEndpoint.DESTINATION)
      clearQueuesHavingLesserBackupCountThan(event.getPartitionId(), event.getCurrentReplicaIndex()); 
  }
  
  private void clearQueuesHavingLesserBackupCountThan(int partitionId, int thresholdReplicaIndex) {
    Iterator<Map.Entry<String, QueueContainer>> iterator = this.containerMap.entrySet().iterator();
    while (iterator.hasNext()) {
      Map.Entry<String, QueueContainer> entry = (Map.Entry)iterator.next();
      String name = (String)entry.getKey();
      QueueContainer container = (QueueContainer)entry.getValue();
      int containerPartitionId = this.partitionService.getPartitionId(StringPartitioningStrategy.getPartitionKey(name));
      if (containerPartitionId != partitionId)
        continue; 
      if (thresholdReplicaIndex < 0 || thresholdReplicaIndex > container.getConfig().getTotalBackupCount()) {
        container.destroy();
        iterator.remove();
      } 
    } 
  }
  
  public void dispatchEvent(QueueEvent event, ItemListener listener) {
    MemberImpl member = this.nodeEngine.getClusterService().getMember(event.caller);
    DataAwareItemEvent dataAwareItemEvent = new DataAwareItemEvent(event.name, event.eventType, event.data, member, this.serializationService);
    if (member == null) {
      if (this.logger.isInfoEnabled())
        this.logger.info("Dropping event " + dataAwareItemEvent + " from unknown address:" + event.caller); 
      return;
    } 
    if (event.eventType.equals(ItemEventType.ADDED)) {
      listener.itemAdded(dataAwareItemEvent);
    } else {
      listener.itemRemoved(dataAwareItemEvent);
    } 
    getLocalQueueStatsImpl(event.name).incrementReceivedEvents();
  }
  
  public QueueProxyImpl createDistributedObject(String objectId) {
    QueueConfig queueConfig = this.nodeEngine.getConfig().findQueueConfig(objectId);
    ConfigValidator.checkQueueConfig(queueConfig, this.nodeEngine.getSplitBrainMergePolicyProvider());
    return new QueueProxyImpl(objectId, this, this.nodeEngine, queueConfig);
  }
  
  public void destroyDistributedObject(String name) {
    QueueContainer container = (QueueContainer)this.containerMap.remove(name);
    if (container != null)
      container.destroy(); 
    this.nodeEngine.getEventService().deregisterAllListeners("hz:impl:queueService", name);
    this.quorumConfigCache.remove(name);
  }
  
  public String addItemListener(String name, ItemListener listener, boolean includeValue, boolean isLocal) {
    EventRegistration registration;
    EventService eventService = this.nodeEngine.getEventService();
    QueueEventFilter filter = new QueueEventFilter(includeValue);
    if (isLocal) {
      registration = eventService.registerLocalListener("hz:impl:queueService", name, filter, listener);
    } else {
      registration = eventService.registerListener("hz:impl:queueService", name, filter, listener);
    } 
    return registration.getId();
  }
  
  public boolean removeItemListener(String name, String registrationId) {
    EventService eventService = this.nodeEngine.getEventService();
    return eventService.deregisterListener("hz:impl:queueService", name, registrationId);
  }
  
  public NodeEngine getNodeEngine() { return this.nodeEngine; }
  
  public LocalQueueStats createLocalQueueStats(String name, int partitionId) {
    LocalQueueStatsImpl stats = getLocalQueueStatsImpl(name);
    stats.setOwnedItemCount(0);
    stats.setBackupItemCount(0);
    QueueContainer container = (QueueContainer)this.containerMap.get(name);
    if (container == null)
      return stats; 
    Address thisAddress = this.nodeEngine.getClusterService().getThisAddress();
    IPartition partition = this.partitionService.getPartition(partitionId, false);
    Address owner = partition.getOwnerOrNull();
    if (thisAddress.equals(owner)) {
      stats.setOwnedItemCount(container.size());
    } else if (owner != null) {
      stats.setBackupItemCount(container.backupSize());
    } 
    container.setStats(stats);
    return stats;
  }
  
  public LocalQueueStats createLocalQueueStats(String name) { return createLocalQueueStats(name, getPartitionId(name)); }
  
  public LocalQueueStatsImpl getLocalQueueStatsImpl(String name) { return (LocalQueueStatsImpl)ConcurrencyUtil.getOrPutIfAbsent(this.statsMap, name, this.localQueueStatsConstructorFunction); }
  
  public TransactionalQueueProxy createTransactionalObject(String name, Transaction transaction) { return new TransactionalQueueProxy(this.nodeEngine, this, name, transaction); }
  
  public void rollbackTransaction(String transactionId) {
    Set<String> queueNames = this.containerMap.keySet();
    OperationService operationService = this.nodeEngine.getOperationService();
    for (String name : queueNames) {
      int partitionId = this.partitionService.getPartitionId(StringPartitioningStrategy.getPartitionKey(name));
      Operation operation = (new QueueTransactionRollbackOperation(name, transactionId)).setPartitionId(partitionId).setService(this).setNodeEngine(this.nodeEngine);
      operationService.invokeOnPartition(operation);
    } 
  }
  
  public Map<String, LocalQueueStats> getStats() {
    Map<String, LocalQueueStats> queueStats = MapUtil.createHashMap(this.containerMap.size());
    for (Map.Entry<String, QueueContainer> entry : this.containerMap.entrySet()) {
      String name = (String)entry.getKey();
      LocalQueueStats queueStat = createLocalQueueStats(name);
      queueStats.put(name, queueStat);
    } 
    return queueStats;
  }
  
  public String getQuorumName(String name) {
    Object quorumName = ConcurrencyUtil.getOrPutSynchronized(this.quorumConfigCache, name, this.quorumConfigCacheMutexFactory, this.quorumConfigConstructor);
    return (quorumName == NULL_OBJECT) ? null : (String)quorumName;
  }
  
  public Runnable prepareMergeRunnable() {
    QueueContainerCollector collector = new QueueContainerCollector(this.nodeEngine, this.containerMap);
    collector.run();
    return new Merger(this, collector);
  }
  
  private int getPartitionId(String name) {
    Data keyData = this.serializationService.toData(name, StringPartitioningStrategy.INSTANCE);
    return this.partitionService.getPartitionId(keyData);
  }
}
