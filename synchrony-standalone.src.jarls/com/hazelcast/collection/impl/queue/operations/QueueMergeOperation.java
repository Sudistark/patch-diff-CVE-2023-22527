package com.hazelcast.collection.impl.queue.operations;

import com.hazelcast.collection.impl.queue.QueueContainer;
import com.hazelcast.collection.impl.queue.QueueItem;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.impl.MutatingOperation;
import com.hazelcast.spi.impl.merge.MergingValueFactory;
import com.hazelcast.spi.merge.SplitBrainMergePolicy;
import com.hazelcast.spi.merge.SplitBrainMergeTypes;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.CollectionUtil;
import java.io.IOException;
import java.util.Collection;
import java.util.Queue;

public class QueueMergeOperation extends QueueBackupAwareOperation implements MutatingOperation {
  private SplitBrainMergePolicy<Collection<Object>, SplitBrainMergeTypes.QueueMergeTypes> mergePolicy;
  
  private SplitBrainMergeTypes.QueueMergeTypes mergingValue;
  
  private Collection<QueueItem> backupCollection;
  
  private boolean shouldBackup;
  
  public QueueMergeOperation() {}
  
  public QueueMergeOperation(String name, SplitBrainMergePolicy<Collection<Object>, SplitBrainMergeTypes.QueueMergeTypes> mergePolicy, SplitBrainMergeTypes.QueueMergeTypes mergingValue) {
    super(name);
    this.mergePolicy = mergePolicy;
    this.mergingValue = mergingValue;
  }
  
  public void run() {
    QueueContainer container = getContainer();
    boolean currentCollectionIsEmpty = container.getItemQueue().isEmpty();
    long currentItemId = container.getCurrentId();
    this.backupCollection = merge(container, this.mergingValue, this.mergePolicy);
    this.shouldBackup = (currentCollectionIsEmpty != this.backupCollection.isEmpty() || currentItemId != container.getCurrentId());
  }
  
  private Queue<QueueItem> merge(QueueContainer container, SplitBrainMergeTypes.QueueMergeTypes mergingValue, SplitBrainMergePolicy<Collection<Object>, SplitBrainMergeTypes.QueueMergeTypes> mergePolicy) {
    SerializationService serializationService = getNodeEngine().getSerializationService();
    serializationService.getManagedContext().initialize(mergingValue);
    serializationService.getManagedContext().initialize(mergePolicy);
    Queue<QueueItem> existingItems = container.getItemQueue();
    SplitBrainMergeTypes.QueueMergeTypes existingValue = createMergingValueOrNull(serializationService, existingItems);
    Collection<Object> newValues = (Collection)mergePolicy.merge(mergingValue, existingValue);
    if (CollectionUtil.isEmpty(newValues)) {
      if (existingValue != null)
        container.clear(); 
      getQueueService().destroyDistributedObject(this.name);
    } else if (existingValue == null) {
      createNewQueueItems(container, newValues, serializationService);
    } else if (!newValues.equals(existingValue.getValue())) {
      container.clear();
      createNewQueueItems(container, newValues, serializationService);
    } 
    return existingItems;
  }
  
  private SplitBrainMergeTypes.QueueMergeTypes createMergingValueOrNull(SerializationService serializationService, Queue<QueueItem> existingItems) { return existingItems.isEmpty() ? null : MergingValueFactory.createMergingValue(serializationService, existingItems); }
  
  private void createNewQueueItems(QueueContainer container, Collection<Object> values, SerializationService serializationService) {
    for (Object value : values)
      container.offer(serializationService.toData(value)); 
  }
  
  public void afterRun() { getQueueService().getLocalQueueStatsImpl(this.name).incrementOtherOperations(); }
  
  public boolean shouldBackup() { return this.shouldBackup; }
  
  public Operation getBackupOperation() { return new QueueMergeBackupOperation(this.name, this.backupCollection); }
  
  public int getId() { return 44; }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException {
    super.writeInternal(out);
    out.writeObject(this.mergePolicy);
    out.writeObject(this.mergingValue);
  }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    super.readInternal(in);
    this.mergePolicy = (SplitBrainMergePolicy)in.readObject();
    this.mergingValue = (SplitBrainMergeTypes.QueueMergeTypes)in.readObject();
  }
}
