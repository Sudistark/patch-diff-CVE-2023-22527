package com.hazelcast.collection.impl.queue.operations;

import com.hazelcast.collection.impl.queue.QueueContainer;
import com.hazelcast.collection.impl.queue.QueueItem;
import com.hazelcast.collection.impl.queue.QueueService;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.spi.impl.MutatingOperation;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Map;

public class QueueMergeBackupOperation extends QueueOperation implements MutatingOperation {
  private Collection<QueueItem> backupItems;
  
  public QueueMergeBackupOperation() {}
  
  public QueueMergeBackupOperation(String name, Collection<QueueItem> backupItems) {
    super(name);
    this.backupItems = backupItems;
  }
  
  public void run() {
    if (this.backupItems.isEmpty()) {
      QueueService service = (QueueService)getService();
      service.destroyDistributedObject(this.name);
      return;
    } 
    QueueContainer container = getContainer();
    container.clear();
    Map<Long, QueueItem> backupMap = container.getBackupMap();
    for (QueueItem backupItem : this.backupItems)
      backupMap.put(Long.valueOf(backupItem.getItemId()), backupItem); 
  }
  
  public void afterRun() { getQueueService().getLocalQueueStatsImpl(this.name).incrementOtherOperations(); }
  
  public int getId() { return 45; }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException {
    super.writeInternal(out);
    out.writeInt(this.backupItems.size());
    for (QueueItem backupItem : this.backupItems)
      out.writeObject(backupItem); 
  }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    super.readInternal(in);
    int size = in.readInt();
    this.backupItems = new ArrayList(size);
    for (int i = 0; i < size; i++) {
      QueueItem backupItem = (QueueItem)in.readObject();
      this.backupItems.add(backupItem);
    } 
  }
}
