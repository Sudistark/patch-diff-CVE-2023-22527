package com.hazelcast.cp.internal.session;

import com.hazelcast.core.ICompletableFuture;
import com.hazelcast.cp.CPGroupId;
import com.hazelcast.cp.internal.RaftNodeLifecycleAwareService;
import com.hazelcast.cp.internal.RaftService;
import com.hazelcast.cp.internal.TermChangeAwareService;
import com.hazelcast.cp.internal.raft.SnapshotAwareService;
import com.hazelcast.cp.internal.util.PartitionSpecificRunnableAdaptor;
import com.hazelcast.cp.internal.util.Tuple2;
import com.hazelcast.cp.session.CPSession;
import com.hazelcast.cp.session.CPSessionManagementService;
import com.hazelcast.internal.util.SimpleCompletableFuture;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.spi.ExecutionService;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.impl.operationservice.impl.OperationServiceImpl;
import com.hazelcast.util.Clock;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.executor.ManagedExecutorService;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class RaftSessionService extends Object implements ManagedService, SnapshotAwareService<RaftSessionRegistry>, SessionAccessor, TermChangeAwareService, RaftNodeLifecycleAwareService, CPSessionManagementService {
  public static final String SERVICE_NAME = "hz:core:raftSession";
  
  private static final long CHECK_EXPIRED_SESSIONS_TASK_PERIOD_IN_MILLIS = TimeUnit.SECONDS.toMillis(1L);
  
  private static final long CHECK_INACTIVE_SESSIONS_TASK_PERIOD_IN_MILLIS = TimeUnit.SECONDS.toMillis(30L);
  
  private static final long COLLECT_INACTIVE_SESSIONS_TASK_TIMEOUT_SECONDS = 5L;
  
  private final NodeEngineImpl nodeEngine;
  
  private final ILogger logger;
  
  private final Map<CPGroupId, RaftSessionRegistry> registries;
  
  public RaftSessionService(NodeEngine nodeEngine) {
    this.registries = new ConcurrentHashMap();
    this.nodeEngine = (NodeEngineImpl)nodeEngine;
    this.logger = nodeEngine.getLogger(getClass());
  }
  
  public void init(NodeEngine nodeEngine, Properties properties) {
    this.raftService = (RaftService)nodeEngine.getService("hz:core:raft");
    for (SessionAwareService service : nodeEngine.getServices(SessionAwareService.class))
      service.setSessionAccessor(this); 
    ExecutionService executionService = nodeEngine.getExecutionService();
    executionService.scheduleWithRepetition(new CheckSessionsToExpire(this, null), CHECK_EXPIRED_SESSIONS_TASK_PERIOD_IN_MILLIS, CHECK_EXPIRED_SESSIONS_TASK_PERIOD_IN_MILLIS, TimeUnit.MILLISECONDS);
    executionService.scheduleWithRepetition(new CheckInactiveSessions(this, null), CHECK_INACTIVE_SESSIONS_TASK_PERIOD_IN_MILLIS, CHECK_INACTIVE_SESSIONS_TASK_PERIOD_IN_MILLIS, TimeUnit.MILLISECONDS);
  }
  
  public void reset() {}
  
  public void shutdown(boolean terminate) { this.registries.clear(); }
  
  public RaftSessionRegistry takeSnapshot(CPGroupId groupId, long commitIndex) {
    RaftSessionRegistry registry = (RaftSessionRegistry)this.registries.get(groupId);
    return (registry != null) ? registry.cloneForSnapshot() : null;
  }
  
  public void restoreSnapshot(CPGroupId groupId, long commitIndex, RaftSessionRegistry registry) {
    if (registry != null)
      this.registries.put(groupId, registry); 
  }
  
  public void onNewTermCommit(CPGroupId groupId, long commitIndex) {
    RaftSessionRegistry registry = (RaftSessionRegistry)this.registries.get(groupId);
    if (registry != null) {
      registry.shiftExpirationTimes(getHeartbeatIntervalMillis());
      if (this.logger.isFineEnabled())
        this.logger.fine("Session expiration times are shifted in " + groupId); 
    } 
  }
  
  public void onRaftGroupDestroyed(CPGroupId groupId) { this.registries.remove(groupId); }
  
  public void onRaftNodeSteppedDown(CPGroupId groupId) {}
  
  public ICompletableFuture<Collection<CPSession>> getAllSessions(String groupName) {
    Preconditions.checkTrue(!"METADATA".equals(groupName), "Cannot query CP sessions on the METADATA CP group!");
    ManagedExecutorService executor = this.nodeEngine.getExecutionService().getExecutor("hz:system");
    SimpleCompletableFuture<Collection<CPSession>> future = new SimpleCompletableFuture<Collection<CPSession>>(executor, this.logger);
    Object object = new Object(this, future);
    this.raftService.getCPGroup(groupName).andThen(new Object(this, object, future));
    return future;
  }
  
  public ICompletableFuture<Boolean> forceCloseSession(String groupName, long sessionId) {
    ManagedExecutorService executor = this.nodeEngine.getExecutionService().getExecutor("hz:system");
    SimpleCompletableFuture<Boolean> future = new SimpleCompletableFuture<Boolean>(executor, this.logger);
    Object object = new Object(this, future);
    this.raftService.getCPGroup(groupName).andThen(new Object(this, sessionId, object, future));
    return future;
  }
  
  public SessionResponse createNewSession(CPGroupId groupId, Address endpoint, String endpointName, CPSession.CPSessionOwnerType endpointType) {
    RaftSessionRegistry registry = getOrInitRegistry(groupId);
    long creationTime = Clock.currentTimeMillis();
    long sessionTTLMillis = getSessionTTLMillis();
    long sessionId = registry.createNewSession(sessionTTLMillis, endpoint, endpointName, endpointType, creationTime);
    this.logger.info("Created new session: " + sessionId + " in " + groupId + " for " + endpointType + " -> " + endpoint);
    return new SessionResponse(sessionId, sessionTTLMillis, getHeartbeatIntervalMillis());
  }
  
  private RaftSessionRegistry getOrInitRegistry(CPGroupId groupId) {
    RaftSessionRegistry registry = (RaftSessionRegistry)this.registries.get(groupId);
    if (registry == null) {
      registry = new RaftSessionRegistry(groupId);
      this.registries.put(groupId, registry);
      if (this.logger.isFineEnabled())
        this.logger.fine("Created new session registry for " + groupId); 
    } 
    return registry;
  }
  
  public void heartbeat(CPGroupId groupId, long sessionId) {
    RaftSessionRegistry registry = (RaftSessionRegistry)this.registries.get(groupId);
    if (registry == null)
      throw new IllegalStateException("No session: " + sessionId + " for CP group: " + groupId); 
    registry.heartbeat(sessionId, getSessionTTLMillis());
    if (this.logger.isFineEnabled())
      this.logger.fine("Session: " + sessionId + " heartbeat in " + groupId); 
  }
  
  public boolean closeSession(CPGroupId groupId, long sessionId) {
    RaftSessionRegistry registry = (RaftSessionRegistry)this.registries.get(groupId);
    if (registry == null)
      return false; 
    if (registry.closeSession(sessionId)) {
      this.logger.info("Session: " + sessionId + " is closed in " + groupId);
      notifyServices(groupId, Collections.singleton(Long.valueOf(sessionId)));
      return true;
    } 
    return false;
  }
  
  public void expireSessions(CPGroupId groupId, Collection<Tuple2<Long, Long>> sessionsToExpire) {
    RaftSessionRegistry registry = (RaftSessionRegistry)this.registries.get(groupId);
    if (registry == null)
      return; 
    List<Long> expired = new ArrayList<Long>();
    for (Tuple2<Long, Long> s : sessionsToExpire) {
      long sessionId = ((Long)s.element1).longValue();
      long version = ((Long)s.element2).longValue();
      if (registry.expireSession(sessionId, version))
        expired.add(Long.valueOf(sessionId)); 
    } 
    if (expired.size() > 0) {
      if (this.logger.isFineEnabled())
        this.logger.fine("Sessions: " + expired + " are expired in " + groupId); 
      notifyServices(groupId, expired);
    } 
  }
  
  public void closeInactiveSessions(CPGroupId groupId, Collection<Long> inactiveSessions) {
    RaftSessionRegistry registry = (RaftSessionRegistry)this.registries.get(groupId);
    if (registry == null)
      return; 
    Collection<Long> closed = new HashSet<Long>(inactiveSessions);
    for (SessionAwareService service : this.nodeEngine.getServices(SessionAwareService.class))
      closed.removeAll(service.getAttachedSessions(groupId)); 
    for (Iterator iterator = closed.iterator(); iterator.hasNext(); ) {
      long sessionId = ((Long)iterator.next()).longValue();
      registry.closeSession(sessionId);
    } 
    if (closed.size() > 0) {
      if (this.logger.isFineEnabled())
        this.logger.fine("Inactive sessions: " + closed + " are closed in " + groupId); 
      notifyServices(groupId, closed);
    } 
  }
  
  public long generateThreadId(CPGroupId groupId) { return getOrInitRegistry(groupId).generateThreadId(); }
  
  public Collection<CPSession> getSessionsLocally(CPGroupId groupId) {
    RaftSessionRegistry registry = getSessionRegistryOrNull(groupId);
    if (registry == null)
      return Collections.emptyList(); 
    return Collections.unmodifiableCollection(registry.getSessions());
  }
  
  RaftSessionRegistry getSessionRegistryOrNull(CPGroupId groupId) { return (RaftSessionRegistry)this.registries.get(groupId); }
  
  private long getHeartbeatIntervalMillis() { return TimeUnit.SECONDS.toMillis(this.raftService.getConfig().getSessionHeartbeatIntervalSeconds()); }
  
  private long getSessionTTLMillis() { return TimeUnit.SECONDS.toMillis(this.raftService.getConfig().getSessionTimeToLiveSeconds()); }
  
  private void notifyServices(CPGroupId groupId, Collection<Long> sessionIds) {
    Collection<SessionAwareService> services = this.nodeEngine.getServices(SessionAwareService.class);
    for (SessionAwareService sessionAwareService : services) {
      for (Iterator iterator = sessionIds.iterator(); iterator.hasNext(); ) {
        long sessionId = ((Long)iterator.next()).longValue();
        sessionAwareService.onSessionClose(groupId, sessionId);
      } 
    } 
  }
  
  public boolean isActive(CPGroupId groupId, long sessionId) {
    RaftSessionRegistry sessionRegistry = (RaftSessionRegistry)this.registries.get(groupId);
    if (sessionRegistry == null)
      return false; 
    CPSessionInfo session = sessionRegistry.getSession(sessionId);
    return (session != null);
  }
  
  private Map<CPGroupId, Collection<Tuple2<Long, Long>>> getSessionsToExpire() {
    Map<CPGroupId, Collection<Tuple2<Long, Long>>> expired = new HashMap<CPGroupId, Collection<Tuple2<Long, Long>>>();
    for (RaftSessionRegistry registry : this.registries.values()) {
      Collection<Tuple2<Long, Long>> e = registry.getSessionsToExpire();
      if (!e.isEmpty())
        expired.put(registry.groupId(), e); 
    } 
    return expired;
  }
  
  private Map<CPGroupId, Collection<Long>> getInactiveSessions() {
    Map<CPGroupId, Collection<Long>> response = new ConcurrentHashMap<CPGroupId, Collection<Long>>();
    Semaphore semaphore = new Semaphore(0);
    OperationServiceImpl operationService = (OperationServiceImpl)this.nodeEngine.getOperationService();
    Collection<RaftSessionRegistry> registries = new ArrayList<RaftSessionRegistry>(this.registries.values());
    for (RaftSessionRegistry registry : registries) {
      CPGroupId groupId = registry.groupId();
      operationService.execute(new PartitionSpecificRunnableAdaptor(new Object(this, groupId, registry, response, semaphore), this.nodeEngine




















            
            .getPartitionService().getPartitionId(groupId)));
    } 
    try {
      semaphore.tryAcquire(registries.size(), 5L, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
    } 
    return response;
  }
}
