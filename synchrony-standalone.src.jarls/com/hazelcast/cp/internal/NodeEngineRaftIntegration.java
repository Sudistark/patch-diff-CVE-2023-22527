package com.hazelcast.cp.internal;

import com.hazelcast.core.Endpoint;
import com.hazelcast.cp.CPGroupId;
import com.hazelcast.cp.CPMember;
import com.hazelcast.cp.internal.operation.integration.AppendFailureResponseOp;
import com.hazelcast.cp.internal.operation.integration.AppendRequestOp;
import com.hazelcast.cp.internal.operation.integration.AppendSuccessResponseOp;
import com.hazelcast.cp.internal.operation.integration.AsyncRaftOp;
import com.hazelcast.cp.internal.operation.integration.InstallSnapshotOp;
import com.hazelcast.cp.internal.operation.integration.PreVoteRequestOp;
import com.hazelcast.cp.internal.operation.integration.PreVoteResponseOp;
import com.hazelcast.cp.internal.operation.integration.VoteRequestOp;
import com.hazelcast.cp.internal.operation.integration.VoteResponseOp;
import com.hazelcast.cp.internal.raft.SnapshotAwareService;
import com.hazelcast.cp.internal.raft.impl.RaftIntegration;
import com.hazelcast.cp.internal.raft.impl.RaftNodeStatus;
import com.hazelcast.cp.internal.raft.impl.dto.AppendFailureResponse;
import com.hazelcast.cp.internal.raft.impl.dto.AppendRequest;
import com.hazelcast.cp.internal.raft.impl.dto.AppendSuccessResponse;
import com.hazelcast.cp.internal.raft.impl.dto.InstallSnapshot;
import com.hazelcast.cp.internal.raft.impl.dto.PreVoteRequest;
import com.hazelcast.cp.internal.raft.impl.dto.PreVoteResponse;
import com.hazelcast.cp.internal.raft.impl.dto.VoteRequest;
import com.hazelcast.cp.internal.raft.impl.dto.VoteResponse;
import com.hazelcast.cp.internal.raftop.NotifyTermChangeOp;
import com.hazelcast.cp.internal.raftop.snapshot.RestoreSnapshotOp;
import com.hazelcast.cp.internal.util.PartitionSpecificRunnableAdaptor;
import com.hazelcast.internal.util.SimpleCompletableFuture;
import com.hazelcast.logging.ILogger;
import com.hazelcast.spi.TaskScheduler;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.impl.operationexecutor.impl.OperationExecutorImpl;
import com.hazelcast.spi.impl.operationexecutor.impl.PartitionOperationThread;
import com.hazelcast.spi.impl.operationservice.InternalOperationService;
import com.hazelcast.spi.impl.operationservice.impl.OperationServiceImpl;
import com.hazelcast.spi.impl.servicemanager.ServiceInfo;
import com.hazelcast.util.executor.ManagedExecutorService;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.TimeUnit;

final class NodeEngineRaftIntegration implements RaftIntegration {
  private final NodeEngineImpl nodeEngine;
  
  private final CPGroupId groupId;
  
  private final CPMember localCPMember;
  
  private final InternalOperationService operationService;
  
  private final TaskScheduler taskScheduler;
  
  private final int partitionId;
  
  private final int threadId;
  
  NodeEngineRaftIntegration(NodeEngineImpl nodeEngine, CPGroupId groupId, CPMember localCPMember) {
    this.nodeEngine = nodeEngine;
    this.groupId = groupId;
    this.localCPMember = localCPMember;
    OperationServiceImpl operationService = (OperationServiceImpl)nodeEngine.getOperationService();
    this.operationService = operationService;
    this.partitionId = nodeEngine.getPartitionService().getPartitionId(groupId);
    OperationExecutorImpl operationExecutor = (OperationExecutorImpl)operationService.getOperationExecutor();
    this.threadId = operationExecutor.toPartitionThreadIndex(this.partitionId);
    this.taskScheduler = nodeEngine.getExecutionService().getGlobalTaskScheduler();
  }
  
  public void execute(Runnable task) {
    Thread currentThread = Thread.currentThread();
    if (currentThread instanceof PartitionOperationThread && ((PartitionOperationThread)currentThread)
      .getThreadId() == this.threadId) {
      task.run();
    } else {
      this.operationService.execute(new PartitionSpecificRunnableAdaptor(task, this.partitionId));
    } 
  }
  
  public void schedule(Runnable task, long delay, TimeUnit timeUnit) { this.taskScheduler.schedule(new Object(this, task), delay, timeUnit); }
  
  public SimpleCompletableFuture newCompletableFuture() {
    ManagedExecutorService managedExecutorService = this.nodeEngine.getExecutionService().getExecutor("hz:async");
    return new SimpleCompletableFuture(managedExecutorService, this.nodeEngine.getLogger(getClass()));
  }
  
  public Object getAppendedEntryOnLeaderElection() { return new NotifyTermChangeOp(); }
  
  public ILogger getLogger(String name) { return this.nodeEngine.getLogger(name); }
  
  public boolean isReady() { return this.nodeEngine.getClusterService().isJoined(); }
  
  public boolean isReachable(Endpoint member) { return (this.nodeEngine.getClusterService().getMember(((CPMember)member).getAddress()) != null); }
  
  public boolean send(PreVoteRequest request, Endpoint target) { return send(new PreVoteRequestOp(this.groupId, request), target); }
  
  public boolean send(PreVoteResponse response, Endpoint target) { return send(new PreVoteResponseOp(this.groupId, response), target); }
  
  public boolean send(VoteRequest request, Endpoint target) { return send(new VoteRequestOp(this.groupId, request), target); }
  
  public boolean send(VoteResponse response, Endpoint target) { return send(new VoteResponseOp(this.groupId, response), target); }
  
  public boolean send(AppendRequest request, Endpoint target) { return send(new AppendRequestOp(this.groupId, request), target); }
  
  public boolean send(AppendSuccessResponse response, Endpoint target) { return send(new AppendSuccessResponseOp(this.groupId, response), target); }
  
  public boolean send(AppendFailureResponse response, Endpoint target) { return send(new AppendFailureResponseOp(this.groupId, response), target); }
  
  public boolean send(InstallSnapshot request, Endpoint target) { return send(new InstallSnapshotOp(this.groupId, request), target); }
  
  public Object runOperation(Object op, long commitIndex) {
    RaftOp operation = (RaftOp)op;
    operation.setNodeEngine(this.nodeEngine);
    try {
      return operation.run(this.groupId, commitIndex);
    } catch (Throwable t) {
      operation.logFailure(t);
      return t;
    } 
  }
  
  public Object takeSnapshot(long commitIndex) {
    try {
      List<RestoreSnapshotOp> snapshotOps = new ArrayList<RestoreSnapshotOp>();
      for (ServiceInfo serviceInfo : this.nodeEngine.getServiceInfos(SnapshotAwareService.class)) {
        SnapshotAwareService service = (SnapshotAwareService)serviceInfo.getService();
        Object snapshot = service.takeSnapshot(this.groupId, commitIndex);
        if (snapshot != null)
          snapshotOps.add(new RestoreSnapshotOp(serviceInfo.getName(), snapshot)); 
      } 
      return snapshotOps;
    } catch (Throwable t) {
      return t;
    } 
  }
  
  public void restoreSnapshot(Object op, long commitIndex) {
    ILogger logger = this.nodeEngine.getLogger(getClass());
    List<RestoreSnapshotOp> snapshotOps = (List)op;
    for (RestoreSnapshotOp snapshotOp : snapshotOps) {
      Object result = runOperation(snapshotOp, commitIndex);
      if (result instanceof Throwable)
        logger.severe("Restore of " + snapshotOp + " failed...", (Throwable)result); 
    } 
  }
  
  private boolean send(AsyncRaftOp operation, Endpoint target) {
    CPMember targetMember = (CPMember)target;
    if (this.localCPMember.getAddress().equals(targetMember.getAddress())) {
      if (this.localCPMember.getUuid().equals(target.getUuid()))
        throw new IllegalStateException("Cannot send " + operation + " to " + target + " because it's same with the local CP member!"); 
      return false;
    } 
    operation.setTargetMember(targetMember).setPartitionId(this.partitionId);
    return this.operationService.send(operation, targetMember.getAddress());
  }
  
  public void onNodeStatusChange(RaftNodeStatus status) {
    if (status == RaftNodeStatus.TERMINATED) {
      Collection<RaftNodeLifecycleAwareService> services = this.nodeEngine.getServices(RaftNodeLifecycleAwareService.class);
      for (RaftNodeLifecycleAwareService service : services)
        service.onRaftGroupDestroyed(this.groupId); 
    } else if (status == RaftNodeStatus.STEPPED_DOWN) {
      Collection<RaftNodeLifecycleAwareService> services = this.nodeEngine.getServices(RaftNodeLifecycleAwareService.class);
      for (RaftNodeLifecycleAwareService service : services)
        service.onRaftNodeSteppedDown(this.groupId); 
    } 
  }
}
