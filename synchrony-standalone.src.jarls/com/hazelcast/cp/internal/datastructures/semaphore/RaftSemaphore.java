package com.hazelcast.cp.internal.datastructures.semaphore;

import com.hazelcast.cp.CPGroupId;
import com.hazelcast.cp.internal.datastructures.spi.blocking.BlockingResource;
import com.hazelcast.cp.internal.datastructures.spi.blocking.WaitKey;
import com.hazelcast.cp.internal.datastructures.spi.blocking.WaitKeyContainer;
import com.hazelcast.cp.internal.util.Tuple2;
import com.hazelcast.cp.internal.util.UUIDSerializationUtil;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.IdentifiedDataSerializable;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.UuidUtil;
import com.hazelcast.util.collection.Long2ObjectHashMap;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

public class RaftSemaphore extends BlockingResource<AcquireInvocationKey> implements IdentifiedDataSerializable {
  private boolean initialized;
  
  private int available;
  
  private final Long2ObjectHashMap<SessionSemaphoreState> sessionStates = new Long2ObjectHashMap();
  
  RaftSemaphore(CPGroupId groupId, String name) { super(groupId, name); }
  
  Collection<AcquireInvocationKey> init(int permits) {
    if (this.initialized || this.available != 0)
      throw new IllegalStateException(); 
    this.available = permits;
    this.initialized = true;
    return assignPermitsToWaitKeys();
  }
  
  int getAvailable() { return this.available; }
  
  boolean isAvailable(int permits) {
    Preconditions.checkPositive(permits, "Permits should be positive!");
    return (this.available >= permits);
  }
  
  AcquireResult acquire(AcquireInvocationKey key, boolean wait) {
    SemaphoreEndpoint endpoint = key.endpoint();
    SessionSemaphoreState state = (SessionSemaphoreState)this.sessionStates.get(key.sessionId());
    if (state != null) {
      Integer acquired = state.getInvocationResponse(endpoint.threadId(), key.invocationUid());
      if (acquired != null) {
        AcquireResult.AcquireStatus status = (acquired.intValue() > 0) ? AcquireResult.AcquireStatus.SUCCESSFUL : AcquireResult.AcquireStatus.FAILED;
        return new AcquireResult(status, acquired.intValue(), Collections.emptyList());
      } 
    } 
    Collection<AcquireInvocationKey> cancelled = cancelWaitKeys(endpoint, key.invocationUid());
    if (!isAvailable(key.permits())) {
      AcquireResult.AcquireStatus status;
      if (wait) {
        addWaitKey(endpoint, key);
        status = AcquireResult.AcquireStatus.WAIT_KEY_ADDED;
      } else {
        assignPermitsToInvocation(endpoint, key.invocationUid(), 0);
        status = AcquireResult.AcquireStatus.FAILED;
      } 
      return new AcquireResult(status, 0, cancelled);
    } 
    assignPermitsToInvocation(endpoint, key.invocationUid(), key.permits());
    return new AcquireResult(AcquireResult.AcquireStatus.SUCCESSFUL, key.permits(), cancelled);
  }
  
  private void assignPermitsToInvocation(SemaphoreEndpoint endpoint, UUID invocationUid, int permits) {
    long sessionId = endpoint.sessionId();
    if (sessionId == -1L) {
      this.available -= permits;
      return;
    } 
    SessionSemaphoreState state = (SessionSemaphoreState)this.sessionStates.get(sessionId);
    if (state == null) {
      state = new SessionSemaphoreState(null);
      this.sessionStates.put(sessionId, state);
    } 
    Tuple2<UUID, Integer> prev = (Tuple2)SessionSemaphoreState.access$100(state).put(endpoint.threadId(), Tuple2.of(invocationUid, Integer.valueOf(permits)));
    if (prev == null || !((UUID)prev.element1).equals(invocationUid)) {
      SessionSemaphoreState sessionSemaphoreState;
      SessionSemaphoreState.access$202(sessionSemaphoreState, (sessionSemaphoreState = state).access$200(sessionSemaphoreState) + permits);
      this.available -= permits;
    } 
  }
  
  ReleaseResult release(SemaphoreEndpoint endpoint, UUID invocationUid, int permits) {
    Preconditions.checkPositive(permits, "Permits should be positive!");
    long sessionId = endpoint.sessionId();
    if (sessionId != -1L) {
      SessionSemaphoreState state = (SessionSemaphoreState)this.sessionStates.get(sessionId);
      if (state == null)
        return ReleaseResult.failed(cancelWaitKeys(endpoint, invocationUid)); 
      Integer response = state.getInvocationResponse(endpoint.threadId(), invocationUid);
      if (response != null) {
        if (response.intValue() > 0)
          return ReleaseResult.successful(Collections.emptyList(), 
              Collections.emptyList()); 
        return ReleaseResult.failed(cancelWaitKeys(endpoint, invocationUid));
      } 
      if (SessionSemaphoreState.access$200(state) < permits) {
        SessionSemaphoreState.access$100(state).put(endpoint.threadId(), Tuple2.of(invocationUid, Integer.valueOf(0)));
        return ReleaseResult.failed(cancelWaitKeys(endpoint, invocationUid));
      } 
      SessionSemaphoreState sessionSemaphoreState;
      SessionSemaphoreState.access$202(sessionSemaphoreState, (sessionSemaphoreState = state).access$200(sessionSemaphoreState) - permits);
      SessionSemaphoreState.access$100(state).put(endpoint.threadId(), Tuple2.of(invocationUid, Integer.valueOf(permits)));
    } 
    this.available += permits;
    Collection<AcquireInvocationKey> cancelled = cancelWaitKeys(endpoint, invocationUid);
    Collection<AcquireInvocationKey> acquired = assignPermitsToWaitKeys();
    return ReleaseResult.successful(acquired, cancelled);
  }
  
  RaftSemaphore cloneForSnapshot() {
    RaftSemaphore clone = new RaftSemaphore();
    cloneForSnapshot(clone);
    clone.initialized = this.initialized;
    clone.available = this.available;
    for (Map.Entry<Long, SessionSemaphoreState> e : this.sessionStates.entrySet()) {
      SessionSemaphoreState s = new SessionSemaphoreState(null);
      SessionSemaphoreState.access$202(s, SessionSemaphoreState.access$200((SessionSemaphoreState)e.getValue()));
      SessionSemaphoreState.access$100(s).putAll(SessionSemaphoreState.access$100((SessionSemaphoreState)e.getValue()));
      clone.sessionStates.put((Long)e.getKey(), s);
    } 
    return clone;
  }
  
  private Collection<AcquireInvocationKey> cancelWaitKeys(SemaphoreEndpoint endpoint, UUID invocationUid) {
    Collection<AcquireInvocationKey> cancelled = null;
    WaitKeyContainer<AcquireInvocationKey> container = getWaitKeyContainer(endpoint);
    if (container != null && ((AcquireInvocationKey)container.key()).isDifferentInvocationOf(endpoint, invocationUid)) {
      cancelled = container.keyAndRetries();
      removeWaitKey(endpoint);
    } 
    return (cancelled != null) ? cancelled : Collections.emptyList();
  }
  
  private Collection<AcquireInvocationKey> assignPermitsToWaitKeys() {
    List<AcquireInvocationKey> assigned = new ArrayList<AcquireInvocationKey>();
    Iterator<WaitKeyContainer<AcquireInvocationKey>> iterator = waitKeyContainersIterator();
    while (iterator.hasNext() && this.available > 0) {
      WaitKeyContainer<AcquireInvocationKey> container = (WaitKeyContainer)iterator.next();
      AcquireInvocationKey key = (AcquireInvocationKey)container.key();
      if (key.permits() <= this.available) {
        iterator.remove();
        assigned.addAll(container.keyAndRetries());
        assignPermitsToInvocation(key.endpoint(), key.invocationUid(), key.permits());
      } 
    } 
    return assigned;
  }
  
  AcquireResult drain(SemaphoreEndpoint endpoint, UUID invocationUid) {
    SessionSemaphoreState state = (SessionSemaphoreState)this.sessionStates.get(endpoint.sessionId());
    if (state != null) {
      Integer permits = state.getInvocationResponse(endpoint.threadId(), invocationUid);
      if (permits != null)
        return new AcquireResult(AcquireResult.AcquireStatus.SUCCESSFUL, permits.intValue(), Collections.emptyList()); 
    } 
    Collection<AcquireInvocationKey> cancelled = cancelWaitKeys(endpoint, invocationUid);
    int drained = this.available;
    assignPermitsToInvocation(endpoint, invocationUid, drained);
    this.available = 0;
    return new AcquireResult(AcquireResult.AcquireStatus.SUCCESSFUL, drained, cancelled);
  }
  
  ReleaseResult change(SemaphoreEndpoint endpoint, UUID invocationUid, int permits) {
    if (permits == 0)
      return ReleaseResult.failed(Collections.emptyList()); 
    Collection<AcquireInvocationKey> cancelled = cancelWaitKeys(endpoint, invocationUid);
    long sessionId = endpoint.sessionId();
    if (sessionId != -1L) {
      SessionSemaphoreState state = (SessionSemaphoreState)this.sessionStates.get(sessionId);
      if (state == null) {
        state = new SessionSemaphoreState(null);
        this.sessionStates.put(sessionId, state);
      } 
      long threadId = endpoint.threadId();
      Integer response = state.getInvocationResponse(threadId, invocationUid);
      if (response != null) {
        Collection<AcquireInvocationKey> c = Collections.emptyList();
        return ReleaseResult.successful(c, c);
      } 
      SessionSemaphoreState.access$100(state).put(threadId, Tuple2.of(invocationUid, Integer.valueOf(permits)));
    } 
    this.available += permits;
    this.initialized = true;
    Collection<AcquireInvocationKey> acquired = (permits > 0) ? assignPermitsToWaitKeys() : Collections.emptyList();
    return ReleaseResult.successful(acquired, cancelled);
  }
  
  protected void onSessionClose(long sessionId, Map<Long, Object> responses) {
    SessionSemaphoreState state = (SessionSemaphoreState)this.sessionStates.get(sessionId);
    if (state != null) {
      if (SessionSemaphoreState.access$200(state) > 0) {
        SemaphoreEndpoint endpoint = new SemaphoreEndpoint(sessionId, 0L);
        ReleaseResult result = release(endpoint, UuidUtil.newUnsecureUUID(), SessionSemaphoreState.access$200(state));
        assert result.cancelledWaitKeys().isEmpty();
        for (AcquireInvocationKey key : result.acquiredWaitKeys())
          responses.put(Long.valueOf(key.commitIndex()), Boolean.TRUE); 
      } 
      this.sessionStates.remove(sessionId);
    } 
  }
  
  protected Collection<Long> getActivelyAttachedSessions() {
    Set<Long> activeSessionIds = new HashSet<Long>();
    for (Map.Entry<Long, SessionSemaphoreState> e : this.sessionStates.entrySet()) {
      if (SessionSemaphoreState.access$200((SessionSemaphoreState)e.getValue()) > 0)
        activeSessionIds.add(e.getKey()); 
    } 
    return activeSessionIds;
  }
  
  protected void onWaitKeyExpire(AcquireInvocationKey key) { assignPermitsToInvocation(key.endpoint(), key.invocationUid(), 0); }
  
  public int getFactoryId() { return RaftSemaphoreDataSerializerHook.F_ID; }
  
  public int getId() { return 2; }
  
  public void writeData(ObjectDataOutput out) throws IOException {
    super.writeData(out);
    out.writeBoolean(this.initialized);
    out.writeInt(this.available);
    out.writeInt(this.sessionStates.size());
    for (Map.Entry<Long, SessionSemaphoreState> e1 : this.sessionStates.entrySet()) {
      out.writeLong(((Long)e1.getKey()).longValue());
      SessionSemaphoreState state = (SessionSemaphoreState)e1.getValue();
      out.writeInt(SessionSemaphoreState.access$100(state).size());
      for (Map.Entry<Long, Tuple2<UUID, Integer>> e2 : SessionSemaphoreState.access$100(state).entrySet()) {
        out.writeLong(((Long)e2.getKey()).longValue());
        Tuple2<UUID, Integer> t = (Tuple2)e2.getValue();
        UUIDSerializationUtil.writeUUID(out, (UUID)t.element1);
        out.writeInt(((Integer)t.element2).intValue());
      } 
      out.writeInt(SessionSemaphoreState.access$200(state));
    } 
  }
  
  public void readData(ObjectDataInput in) throws IOException {
    super.readData(in);
    this.initialized = in.readBoolean();
    this.available = in.readInt();
    int count = in.readInt();
    for (int i = 0; i < count; i++) {
      long sessionId = in.readLong();
      SessionSemaphoreState state = new SessionSemaphoreState(null);
      int refUidCount = in.readInt();
      for (int j = 0; j < refUidCount; j++) {
        long threadId = in.readLong();
        UUID invocationUid = UUIDSerializationUtil.readUUID(in);
        int permits = in.readInt();
        SessionSemaphoreState.access$100(state).put(threadId, Tuple2.of(invocationUid, Integer.valueOf(permits)));
      } 
      SessionSemaphoreState.access$202(state, in.readInt());
      this.sessionStates.put(sessionId, state);
    } 
  }
  
  public String toString() { return "RaftSemaphore{" + internalToString() + ", initialized=" + this.initialized + ", available=" + this.available + ", sessionStates=" + this.sessionStates + '}'; }
  
  RaftSemaphore() {}
}
