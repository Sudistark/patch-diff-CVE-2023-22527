package com.hazelcast.cp.internal.datastructures.semaphore.proxy;

import com.hazelcast.core.ISemaphore;
import com.hazelcast.cp.internal.RaftGroupId;
import com.hazelcast.cp.internal.RaftInvocationManager;
import com.hazelcast.cp.internal.RaftService;
import com.hazelcast.cp.internal.datastructures.semaphore.operation.AcquirePermitsOp;
import com.hazelcast.cp.internal.datastructures.semaphore.operation.AvailablePermitsOp;
import com.hazelcast.cp.internal.datastructures.semaphore.operation.ChangePermitsOp;
import com.hazelcast.cp.internal.datastructures.semaphore.operation.DrainPermitsOp;
import com.hazelcast.cp.internal.datastructures.semaphore.operation.InitSemaphoreOp;
import com.hazelcast.cp.internal.datastructures.semaphore.operation.ReleasePermitsOp;
import com.hazelcast.cp.internal.datastructures.spi.operation.DestroyRaftObjectOp;
import com.hazelcast.cp.internal.session.ProxySessionManagerService;
import com.hazelcast.cp.internal.session.SessionAwareProxy;
import com.hazelcast.cp.internal.session.SessionExpiredException;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.util.Clock;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.ThreadUtil;
import com.hazelcast.util.UuidUtil;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

public class RaftSessionAwareSemaphoreProxy extends SessionAwareProxy implements ISemaphore {
  public static final int DRAIN_SESSION_ACQ_COUNT = 1024;
  
  private final RaftInvocationManager invocationManager;
  
  private final String proxyName;
  
  private final String objectName;
  
  public RaftSessionAwareSemaphoreProxy(NodeEngine nodeEngine, RaftGroupId groupId, String proxyName, String objectName) {
    super((ProxySessionManagerService)nodeEngine.getService("hz:raft:proxySessionManagerService"), groupId);
    RaftService service = (RaftService)nodeEngine.getService("hz:core:raft");
    this.invocationManager = service.getInvocationManager();
    this.proxyName = proxyName;
    this.objectName = objectName;
  }
  
  public boolean init(int permits) {
    Preconditions.checkNotNegative(permits, "Permits must be non-negative!");
    return ((Boolean)this.invocationManager.invoke(this.groupId, new InitSemaphoreOp(this.objectName, permits)).join()).booleanValue();
  }
  
  public void acquire() { acquire(1); }
  
  public void acquire(int permits) {
    Preconditions.checkPositive(permits, "Permits must be positive!");
    long threadId = ThreadUtil.getThreadId();
    UUID invocationUid = UuidUtil.newUnsecureUUID();
    while (true) {
      long sessionId = acquireSession(permits);
      AcquirePermitsOp acquirePermitsOp = new AcquirePermitsOp(this.objectName, sessionId, threadId, invocationUid, permits, -1L);
      try {
        this.invocationManager.invoke(this.groupId, acquirePermitsOp).join();
        return;
      } catch (SessionExpiredException e) {
        invalidateSession(sessionId);
      } 
    } 
  }
  
  public boolean tryAcquire() { return tryAcquire(1); }
  
  public boolean tryAcquire(int permits) { return tryAcquire(permits, 0L, TimeUnit.MILLISECONDS); }
  
  public boolean tryAcquire(long timeout, TimeUnit unit) { return tryAcquire(1, timeout, unit); }
  
  public boolean tryAcquire(int permits, long timeout, TimeUnit unit) {
    Preconditions.checkPositive(permits, "Permits must be positive!");
    long timeoutMs = Math.max(0L, unit.toMillis(timeout));
    long threadId = ThreadUtil.getThreadId();
    UUID invocationUid = UuidUtil.newUnsecureUUID();
    while (true) {
      long start = Clock.currentTimeMillis();
      long sessionId = acquireSession(permits);
      AcquirePermitsOp acquirePermitsOp = new AcquirePermitsOp(this.objectName, sessionId, threadId, invocationUid, permits, timeoutMs);
      try {
        InternalCompletableFuture<Boolean> f = this.invocationManager.invoke(this.groupId, acquirePermitsOp);
        boolean acquired = ((Boolean)f.join()).booleanValue();
        if (!acquired)
          releaseSession(sessionId, permits); 
        return acquired;
      } catch (SessionExpiredException e) {
        invalidateSession(sessionId);
        timeoutMs -= Clock.currentTimeMillis() - start;
        if (timeoutMs <= 0L)
          break; 
      } 
    } 
    return false;
  }
  
  public void release() { release(1); }
  
  public void release(int permits) {
    Preconditions.checkPositive(permits, "Permits must be positive!");
    sessionId = getSession();
    if (sessionId == -1L)
      throw newIllegalStateException(null); 
    long threadId = ThreadUtil.getThreadId();
    UUID invocationUid = UuidUtil.newUnsecureUUID();
    ReleasePermitsOp releasePermitsOp = new ReleasePermitsOp(this.objectName, sessionId, threadId, invocationUid, permits);
    try {
      this.invocationManager.invoke(this.groupId, releasePermitsOp).join();
    } catch (SessionExpiredException e) {
      invalidateSession(sessionId);
      throw newIllegalStateException(e);
    } finally {
      releaseSession(sessionId, permits);
    } 
  }
  
  public int availablePermits() { return ((Integer)this.invocationManager.invoke(this.groupId, new AvailablePermitsOp(this.objectName)).join()).intValue(); }
  
  public int drainPermits() {
    long threadId = ThreadUtil.getThreadId();
    UUID invocationUid = UuidUtil.newUnsecureUUID();
    while (true) {
      long sessionId = acquireSession(1024);
      DrainPermitsOp drainPermitsOp = new DrainPermitsOp(this.objectName, sessionId, threadId, invocationUid);
      try {
        InternalCompletableFuture<Integer> future = this.invocationManager.invoke(this.groupId, drainPermitsOp);
        int count = ((Integer)future.join()).intValue();
        releaseSession(sessionId, 1024 - count);
        return count;
      } catch (SessionExpiredException e) {
        invalidateSession(sessionId);
      } 
    } 
  }
  
  public void reducePermits(int reduction) {
    Preconditions.checkNotNegative(reduction, "Reduction must be non-negative!");
    if (reduction == 0)
      return; 
    sessionId = acquireSession();
    if (sessionId == -1L)
      throw newIllegalStateException(null); 
    long threadId = ThreadUtil.getThreadId();
    UUID invocationUid = UuidUtil.newUnsecureUUID();
    try {
      ChangePermitsOp changePermitsOp = new ChangePermitsOp(this.objectName, sessionId, threadId, invocationUid, -reduction);
      this.invocationManager.invoke(this.groupId, changePermitsOp).join();
    } catch (SessionExpiredException e) {
      invalidateSession(sessionId);
      throw newIllegalStateException(e);
    } finally {
      releaseSession(sessionId);
    } 
  }
  
  public void increasePermits(int increase) {
    Preconditions.checkNotNegative(increase, "Increase must be non-negative!");
    if (increase == 0)
      return; 
    sessionId = acquireSession();
    if (sessionId == -1L)
      throw newIllegalStateException(null); 
    long threadId = ThreadUtil.getThreadId();
    UUID invocationUid = UuidUtil.newUnsecureUUID();
    try {
      ChangePermitsOp changePermitsOp = new ChangePermitsOp(this.objectName, sessionId, threadId, invocationUid, increase);
      this.invocationManager.invoke(this.groupId, changePermitsOp).join();
    } catch (SessionExpiredException e) {
      invalidateSession(sessionId);
      throw newIllegalStateException(e);
    } finally {
      releaseSession(sessionId);
    } 
  }
  
  private IllegalStateException newIllegalStateException(SessionExpiredException e) { return new IllegalStateException("No valid session!", e); }
  
  public String getName() { return this.proxyName; }
  
  public String getPartitionKey() { throw new UnsupportedOperationException(); }
  
  public String getServiceName() { return "hz:raft:semaphoreService"; }
  
  public void destroy() { this.invocationManager.invoke(this.groupId, new DestroyRaftObjectOp(getServiceName(), this.objectName)).join(); }
}
