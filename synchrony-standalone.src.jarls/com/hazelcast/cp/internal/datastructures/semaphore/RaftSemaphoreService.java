package com.hazelcast.cp.internal.datastructures.semaphore;

import com.hazelcast.config.cp.CPSemaphoreConfig;
import com.hazelcast.core.DistributedObject;
import com.hazelcast.core.ISemaphore;
import com.hazelcast.cp.CPGroupId;
import com.hazelcast.cp.internal.RaftGroupId;
import com.hazelcast.cp.internal.RaftService;
import com.hazelcast.cp.internal.datastructures.exception.WaitKeyCancelledException;
import com.hazelcast.cp.internal.datastructures.semaphore.proxy.RaftSessionAwareSemaphoreProxy;
import com.hazelcast.cp.internal.datastructures.semaphore.proxy.RaftSessionlessSemaphoreProxy;
import com.hazelcast.cp.internal.datastructures.spi.blocking.AbstractBlockingService;
import com.hazelcast.cp.internal.datastructures.spi.blocking.ResourceRegistry;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.util.ExceptionUtil;
import java.util.Collection;
import java.util.UUID;

public class RaftSemaphoreService extends AbstractBlockingService<AcquireInvocationKey, RaftSemaphore, RaftSemaphoreRegistry> {
  public static final String SERVICE_NAME = "hz:raft:semaphoreService";
  
  public RaftSemaphoreService(NodeEngine nodeEngine) { super(nodeEngine); }
  
  private CPSemaphoreConfig getConfig(String name) { return this.nodeEngine.getConfig().getCPSubsystemConfig().findSemaphoreConfig(name); }
  
  public boolean initSemaphore(CPGroupId groupId, String name, int permits) {
    try {
      Collection<AcquireInvocationKey> acquired = ((RaftSemaphoreRegistry)getOrInitRegistry(groupId)).init(name, permits);
      notifyWaitKeys(groupId, name, acquired, Boolean.valueOf(true));
      return true;
    } catch (IllegalStateException ignored) {
      return false;
    } 
  }
  
  public int availablePermits(CPGroupId groupId, String name) {
    RaftSemaphoreRegistry registry = (RaftSemaphoreRegistry)getRegistryOrNull(groupId);
    return (registry != null) ? registry.availablePermits(name) : 0;
  }
  
  public AcquireResult acquirePermits(CPGroupId groupId, String name, AcquireInvocationKey key, long timeoutMs) {
    heartbeatSession(groupId, key.sessionId());
    AcquireResult result = ((RaftSemaphoreRegistry)getOrInitRegistry(groupId)).acquire(name, key, timeoutMs);
    if (this.logger.isFineEnabled())
      if (result.status() == AcquireResult.AcquireStatus.SUCCESSFUL) {
        this.logger.fine("Semaphore[" + name + "] in " + groupId + " acquired permits: " + key.permits() + " by <" + key
            .endpoint() + ", " + key.invocationUid() + "> at commit index: " + key.commitIndex());
      } else if (result.status() == AcquireResult.AcquireStatus.WAIT_KEY_ADDED) {
        this.logger.fine("Semaphore[" + name + "] in " + groupId + " wait key added for permits: " + key.permits() + " by <" + key
            .endpoint() + ", " + key.invocationUid() + "> at commit index: " + key.commitIndex());
      } else if (result.status() == AcquireResult.AcquireStatus.FAILED) {
        this.logger.fine("Semaphore[" + name + "] in " + groupId + " not acquired permits: " + key.permits() + " by <" + key
            .endpoint() + ", " + key.invocationUid() + "> at commit index: " + key.commitIndex());
      }  
    notifyCancelledWaitKeys(groupId, name, result.cancelledWaitKeys());
    if (result.status() == AcquireResult.AcquireStatus.WAIT_KEY_ADDED)
      scheduleTimeout(groupId, name, key.invocationUid(), timeoutMs); 
    return result;
  }
  
  public void releasePermits(CPGroupId groupId, long commitIndex, String name, SemaphoreEndpoint endpoint, UUID invocationUid, int permits) {
    heartbeatSession(groupId, endpoint.sessionId());
    ReleaseResult result = ((RaftSemaphoreRegistry)getOrInitRegistry(groupId)).release(name, endpoint, invocationUid, permits);
    notifyCancelledWaitKeys(groupId, name, result.cancelledWaitKeys());
    notifyWaitKeys(groupId, name, result.acquiredWaitKeys(), Boolean.valueOf(true));
    if (this.logger.isFineEnabled())
      if (result.success()) {
        this.logger.fine("Semaphore[" + name + "] in " + groupId + " released permits: " + permits + " by <" + endpoint + ", " + invocationUid + "> at commit index: " + commitIndex + " new acquires: " + result
            .acquiredWaitKeys());
      } else {
        this.logger.fine("Semaphore[" + name + "] in " + groupId + " not-released permits: " + permits + " by <" + endpoint + ", " + invocationUid + "> at commit index: " + commitIndex);
      }  
    if (!result.success())
      throw new IllegalArgumentException(); 
  }
  
  public int drainPermits(CPGroupId groupId, String name, long commitIndex, SemaphoreEndpoint endpoint, UUID invocationUid) {
    heartbeatSession(groupId, endpoint.sessionId());
    AcquireResult result = ((RaftSemaphoreRegistry)getOrInitRegistry(groupId)).drainPermits(name, endpoint, invocationUid);
    notifyCancelledWaitKeys(groupId, name, result.cancelledWaitKeys());
    if (this.logger.isFineEnabled())
      this.logger.fine("Semaphore[" + name + "] in " + groupId + " drained permits: " + result.permits() + " by <" + endpoint + ", " + invocationUid + "> at commit index: " + commitIndex); 
    return result.permits();
  }
  
  public boolean changePermits(CPGroupId groupId, long commitIndex, String name, SemaphoreEndpoint endpoint, UUID invocationUid, int permits) {
    heartbeatSession(groupId, endpoint.sessionId());
    ReleaseResult result = ((RaftSemaphoreRegistry)getOrInitRegistry(groupId)).changePermits(name, endpoint, invocationUid, permits);
    notifyCancelledWaitKeys(groupId, name, result.cancelledWaitKeys());
    notifyWaitKeys(groupId, name, result.acquiredWaitKeys(), Boolean.valueOf(true));
    if (this.logger.isFineEnabled())
      this.logger.fine("Semaphore[" + name + "] in " + groupId + " changed permits: " + permits + " by <" + endpoint + ", " + invocationUid + "> at commit index: " + commitIndex + ". new acquires: " + result
          .acquiredWaitKeys()); 
    return result.success();
  }
  
  private void notifyCancelledWaitKeys(CPGroupId groupId, String name, Collection<AcquireInvocationKey> keys) {
    if (keys.isEmpty())
      return; 
    notifyWaitKeys(groupId, name, keys, new WaitKeyCancelledException());
  }
  
  protected RaftSemaphoreRegistry createNewRegistry(CPGroupId groupId) { return new RaftSemaphoreRegistry(groupId); }
  
  protected Object expiredWaitKeyResponse() { return Boolean.valueOf(false); }
  
  protected String serviceName() { return "hz:raft:semaphoreService"; }
  
  public ISemaphore createProxy(String proxyName) {
    try {
      proxyName = RaftService.withoutDefaultGroupName(proxyName);
      RaftGroupId groupId = this.raftService.createRaftGroupForProxy(proxyName);
      String objectName = RaftService.getObjectNameForProxy(proxyName);
      CPSemaphoreConfig config = getConfig(proxyName);
      return (config != null && config.isJDKCompatible()) ? new RaftSessionlessSemaphoreProxy(this.nodeEngine, groupId, proxyName, objectName) : new RaftSessionAwareSemaphoreProxy(this.nodeEngine, groupId, proxyName, objectName);
    } catch (Exception e) {
      throw ExceptionUtil.rethrow(e);
    } 
  }
}
