package com.hazelcast.cp.internal.datastructures.lock;

import com.hazelcast.cp.CPGroupId;
import com.hazelcast.cp.internal.datastructures.spi.blocking.BlockingResource;
import com.hazelcast.cp.internal.datastructures.spi.blocking.WaitKey;
import com.hazelcast.cp.internal.datastructures.spi.blocking.WaitKeyContainer;
import com.hazelcast.cp.internal.util.Tuple2;
import com.hazelcast.cp.internal.util.UUIDSerializationUtil;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.IdentifiedDataSerializable;
import com.hazelcast.util.UuidUtil;
import java.io.IOException;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.UUID;

public class RaftLock extends BlockingResource<LockInvocationKey> implements IdentifiedDataSerializable {
  private int lockCountLimit;
  
  private LockInvocationKey owner;
  
  private int lockCount;
  
  private Map<Tuple2<LockEndpoint, UUID>, RaftLockOwnershipState> ownerInvocationRefUids = new HashMap();
  
  RaftLock(CPGroupId groupId, String name, int lockCountLimit) {
    super(groupId, name);
    this.lockCountLimit = (lockCountLimit > 0) ? lockCountLimit : Integer.MAX_VALUE;
  }
  
  AcquireResult acquire(LockInvocationKey key, boolean wait) {
    LockEndpoint endpoint = key.endpoint();
    UUID invocationUid = key.invocationUid();
    RaftLockOwnershipState memorized = (RaftLockOwnershipState)this.ownerInvocationRefUids.get(Tuple2.of(endpoint, invocationUid));
    if (memorized != null) {
      AcquireResult.AcquireStatus status = memorized.isLocked() ? AcquireResult.AcquireStatus.SUCCESSFUL : AcquireResult.AcquireStatus.FAILED;
      return new AcquireResult(status, memorized.getFence(), Collections.emptyList());
    } 
    if (this.owner == null)
      this.owner = key; 
    if (endpoint.equals(this.owner.endpoint())) {
      if (this.lockCount == this.lockCountLimit) {
        this.ownerInvocationRefUids.put(Tuple2.of(endpoint, invocationUid), RaftLockOwnershipState.NOT_LOCKED);
        return AcquireResult.failed(Collections.emptyList());
      } 
      this.lockCount++;
      this.ownerInvocationRefUids.put(Tuple2.of(endpoint, invocationUid), lockOwnershipState());
      return AcquireResult.acquired(this.owner.commitIndex());
    } 
    Collection<LockInvocationKey> cancelledWaitKeys = cancelWaitKeys(endpoint, invocationUid);
    if (wait) {
      addWaitKey(endpoint, key);
      return AcquireResult.waitKeyAdded(cancelledWaitKeys);
    } 
    return AcquireResult.failed(cancelledWaitKeys);
  }
  
  private Collection<LockInvocationKey> cancelWaitKeys(LockEndpoint endpoint, UUID invocationUid) {
    Collection<LockInvocationKey> cancelled = null;
    WaitKeyContainer<LockInvocationKey> container = getWaitKeyContainer(endpoint);
    if (container != null && ((LockInvocationKey)container.key()).isDifferentInvocationOf(endpoint, invocationUid)) {
      cancelled = container.keyAndRetries();
      removeWaitKey(endpoint);
    } 
    return (cancelled != null) ? cancelled : Collections.emptyList();
  }
  
  ReleaseResult release(LockEndpoint endpoint, UUID invocationUid) { return doRelease(endpoint, invocationUid, 1); }
  
  private ReleaseResult doRelease(LockEndpoint endpoint, UUID invocationUid, int releaseCount) {
    RaftLockOwnershipState memorized = (RaftLockOwnershipState)this.ownerInvocationRefUids.get(Tuple2.of(endpoint, invocationUid));
    if (memorized != null)
      return ReleaseResult.successful(memorized); 
    if (this.owner == null || !this.owner.endpoint().equals(endpoint))
      return ReleaseResult.failed(cancelWaitKeys(endpoint, invocationUid)); 
    this.lockCount -= Math.min(this.lockCount, releaseCount);
    if (this.lockCount > 0) {
      RaftLockOwnershipState ownership = lockOwnershipState();
      this.ownerInvocationRefUids.put(Tuple2.of(endpoint, invocationUid), ownership);
      return ReleaseResult.successful(ownership);
    } 
    removeInvocationRefUids(endpoint);
    Collection<LockInvocationKey> newOwnerWaitKeys = setNewLockOwner();
    this.ownerInvocationRefUids.put(Tuple2.of(endpoint, invocationUid), lockOwnershipState());
    return ReleaseResult.successful(lockOwnershipState(), newOwnerWaitKeys);
  }
  
  private void removeInvocationRefUids(LockEndpoint endpoint) {
    Iterator<Tuple2<LockEndpoint, UUID>> it = this.ownerInvocationRefUids.keySet().iterator();
    while (it.hasNext()) {
      if (((LockEndpoint)((Tuple2)it.next()).element1).equals(endpoint))
        it.remove(); 
    } 
  }
  
  private Collection<LockInvocationKey> setNewLockOwner() {
    Collection<LockInvocationKey> newOwnerWaitKeys;
    Iterator<WaitKeyContainer<LockInvocationKey>> iter = waitKeyContainersIterator();
    if (iter.hasNext()) {
      WaitKeyContainer<LockInvocationKey> container = (WaitKeyContainer)iter.next();
      LockInvocationKey newOwner = (LockInvocationKey)container.key();
      newOwnerWaitKeys = container.keyAndRetries();
      iter.remove();
      this.owner = newOwner;
      this.lockCount = 1;
      this.ownerInvocationRefUids.put(Tuple2.of(this.owner.endpoint(), this.owner.invocationUid()), lockOwnershipState());
    } else {
      this.owner = null;
      newOwnerWaitKeys = Collections.emptyList();
    } 
    return newOwnerWaitKeys;
  }
  
  RaftLockOwnershipState lockOwnershipState() {
    if (this.owner == null)
      return RaftLockOwnershipState.NOT_LOCKED; 
    return new RaftLockOwnershipState(this.owner.commitIndex(), this.lockCount, this.owner.sessionId(), this.owner.endpoint().threadId());
  }
  
  RaftLock cloneForSnapshot() {
    RaftLock clone = new RaftLock();
    cloneForSnapshot(clone);
    clone.lockCountLimit = this.lockCountLimit;
    clone.owner = this.owner;
    clone.lockCount = this.lockCount;
    clone.ownerInvocationRefUids.putAll(this.ownerInvocationRefUids);
    return clone;
  }
  
  protected void onSessionClose(long sessionId, Map<Long, Object> responses) {
    removeInvocationRefUids(sessionId);
    if (this.owner != null && this.owner.sessionId() == sessionId) {
      ReleaseResult result = doRelease(this.owner.endpoint(), UuidUtil.newUnsecureUUID(), this.lockCount);
      for (LockInvocationKey key : result.completedWaitKeys())
        responses.put(Long.valueOf(key.commitIndex()), Long.valueOf(result.ownership().getFence())); 
    } 
  }
  
  private void removeInvocationRefUids(long sessionId) {
    Iterator<Tuple2<LockEndpoint, UUID>> it = this.ownerInvocationRefUids.keySet().iterator();
    while (it.hasNext()) {
      if (((LockEndpoint)((Tuple2)it.next()).element1).sessionId() == sessionId)
        it.remove(); 
    } 
  }
  
  protected Collection<Long> getActivelyAttachedSessions() { return (this.owner != null) ? Collections.singleton(Long.valueOf(this.owner.sessionId())) : Collections.emptyList(); }
  
  protected void onWaitKeyExpire(LockInvocationKey key) { this.ownerInvocationRefUids.put(Tuple2.of(key.endpoint(), key.invocationUid()), RaftLockOwnershipState.NOT_LOCKED); }
  
  public int getFactoryId() { return RaftLockDataSerializerHook.F_ID; }
  
  public int getId() { return 2; }
  
  public void writeData(ObjectDataOutput out) throws IOException {
    super.writeData(out);
    out.writeInt(this.lockCountLimit);
    boolean hasOwner = (this.owner != null);
    out.writeBoolean(hasOwner);
    if (hasOwner)
      out.writeObject(this.owner); 
    out.writeInt(this.lockCount);
    out.writeInt(this.ownerInvocationRefUids.size());
    for (Map.Entry<Tuple2<LockEndpoint, UUID>, RaftLockOwnershipState> e : this.ownerInvocationRefUids.entrySet()) {
      out.writeObject(((Tuple2)e.getKey()).element1);
      UUIDSerializationUtil.writeUUID(out, (UUID)((Tuple2)e.getKey()).element2);
      out.writeObject(e.getValue());
    } 
  }
  
  public void readData(ObjectDataInput in) throws IOException {
    super.readData(in);
    this.lockCountLimit = in.readInt();
    boolean hasOwner = in.readBoolean();
    if (hasOwner)
      this.owner = (LockInvocationKey)in.readObject(); 
    this.lockCount = in.readInt();
    int ownerInvocationRefUidCount = in.readInt();
    for (int i = 0; i < ownerInvocationRefUidCount; i++) {
      LockEndpoint endpoint = (LockEndpoint)in.readObject();
      UUID invocationUid = UUIDSerializationUtil.readUUID(in);
      RaftLockOwnershipState ownership = (RaftLockOwnershipState)in.readObject();
      this.ownerInvocationRefUids.put(Tuple2.of(endpoint, invocationUid), ownership);
    } 
  }
  
  public String toString() { return "RaftLock{" + internalToString() + ", lockCountLimit=" + this.lockCountLimit + ", owner=" + this.owner + ", lockCount=" + this.lockCount + ", ownerInvocationRefUids=" + this.ownerInvocationRefUids + '}'; }
  
  RaftLock() {}
}
