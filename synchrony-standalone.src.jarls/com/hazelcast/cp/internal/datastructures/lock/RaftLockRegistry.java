package com.hazelcast.cp.internal.datastructures.lock;

import com.hazelcast.config.cp.CPSubsystemConfig;
import com.hazelcast.config.cp.FencedLockConfig;
import com.hazelcast.cp.CPGroupId;
import com.hazelcast.cp.internal.datastructures.spi.blocking.BlockingResource;
import com.hazelcast.cp.internal.datastructures.spi.blocking.ResourceRegistry;
import com.hazelcast.nio.serialization.IdentifiedDataSerializable;
import java.util.Map;
import java.util.UUID;

class RaftLockRegistry extends ResourceRegistry<LockInvocationKey, RaftLock> implements IdentifiedDataSerializable {
  private CPSubsystemConfig cpSubsystemConfig;
  
  RaftLockRegistry() {}
  
  RaftLockRegistry(CPSubsystemConfig cpSubsystemConfig, CPGroupId groupId) {
    super(groupId);
    this.cpSubsystemConfig = cpSubsystemConfig;
  }
  
  public void setCpSubsystemConfig(CPSubsystemConfig cpSubsystemConfig) { this.cpSubsystemConfig = cpSubsystemConfig; }
  
  protected RaftLock createNewResource(CPGroupId groupId, String name) {
    FencedLockConfig lockConfig = this.cpSubsystemConfig.findLockConfig(name);
    int lockCountLimit = (lockConfig != null) ? lockConfig.getLockAcquireLimit() : 0;
    return new RaftLock(groupId, name, lockCountLimit);
  }
  
  protected RaftLockRegistry cloneForSnapshot() {
    RaftLockRegistry clone = new RaftLockRegistry();
    clone.groupId = this.groupId;
    for (Map.Entry<String, RaftLock> e : this.resources.entrySet())
      clone.resources.put(e.getKey(), ((RaftLock)e.getValue()).cloneForSnapshot()); 
    clone.destroyedNames.addAll(this.destroyedNames);
    clone.waitTimeouts.putAll(this.waitTimeouts);
    return clone;
  }
  
  AcquireResult acquire(String name, LockInvocationKey key, long timeoutMs) {
    AcquireResult result = ((RaftLock)getOrInitResource(name)).acquire(key, (timeoutMs != 0L));
    for (LockInvocationKey cancelled : result.cancelledWaitKeys())
      removeWaitKey(name, cancelled); 
    if (result.status() == AcquireResult.AcquireStatus.WAIT_KEY_ADDED)
      addWaitKey(name, key, timeoutMs); 
    return result;
  }
  
  ReleaseResult release(String name, LockEndpoint endpoint, UUID invocationUid) {
    RaftLock lock = (RaftLock)getResourceOrNull(name);
    if (lock == null)
      return ReleaseResult.FAILED; 
    ReleaseResult result = lock.release(endpoint, invocationUid);
    for (LockInvocationKey key : result.completedWaitKeys())
      removeWaitKey(name, key); 
    return result;
  }
  
  RaftLockOwnershipState getLockOwnershipState(String name) {
    RaftLock lock = (RaftLock)getResourceOrNull(name);
    return (lock != null) ? lock.lockOwnershipState() : RaftLockOwnershipState.NOT_LOCKED;
  }
  
  public int getFactoryId() { return RaftLockDataSerializerHook.F_ID; }
  
  public int getId() { return 1; }
}
