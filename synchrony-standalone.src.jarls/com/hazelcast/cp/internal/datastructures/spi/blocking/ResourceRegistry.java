package com.hazelcast.cp.internal.datastructures.spi.blocking;

import com.hazelcast.cp.CPGroupId;
import com.hazelcast.cp.internal.util.Tuple2;
import com.hazelcast.cp.internal.util.UUIDSerializationUtil;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.DataSerializable;
import com.hazelcast.spi.LiveOperations;
import com.hazelcast.spi.exception.DistributedObjectDestroyedException;
import com.hazelcast.util.Clock;
import com.hazelcast.util.Preconditions;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;

public abstract class ResourceRegistry<W extends WaitKey, R extends BlockingResource<W>> extends Object implements DataSerializable {
  private static final long OPERATION_TIMEOUT_EXTENSION_MS = TimeUnit.SECONDS.toMillis(5L);
  
  private static final long NO_WAIT_KEY_DEADLINE = 9223372036854775807L;
  
  protected CPGroupId groupId;
  
  protected final Map<String, R> resources = new ConcurrentHashMap();
  
  protected final Set<String> destroyedNames = new HashSet();
  
  protected final ConcurrentMap<Tuple2<String, UUID>, Tuple2<Long, Long>> waitTimeouts = new ConcurrentHashMap();
  
  private final Map<Tuple2<Address, Long>, Long> liveOperationMap = new ConcurrentHashMap();
  
  protected ResourceRegistry() {}
  
  protected ResourceRegistry(CPGroupId groupId) { this.groupId = groupId; }
  
  protected abstract R createNewResource(CPGroupId paramCPGroupId, String paramString);
  
  protected abstract ResourceRegistry<W, R> cloneForSnapshot();
  
  public final R getResourceOrNull(String name) {
    checkNotDestroyed(name);
    return (R)(BlockingResource)this.resources.get(name);
  }
  
  protected final R getOrInitResource(String name) {
    checkNotDestroyed(name);
    R resource = (R)(BlockingResource)this.resources.get(name);
    if (resource == null) {
      resource = (R)createNewResource(this.groupId, name);
      this.resources.put(name, resource);
    } 
    return resource;
  }
  
  private void checkNotDestroyed(String name) {
    Preconditions.checkNotNull(name);
    if (this.destroyedNames.contains(name))
      throw new DistributedObjectDestroyedException("Resource[" + name + "] is already destroyed!"); 
  }
  
  protected final void addWaitKey(String name, W key, long timeoutMs) {
    long deadline;
    if (timeoutMs > 0L) {
      long now = Clock.currentTimeMillis();
      deadline = (Float.MAX_VALUE - now >= timeoutMs) ? (now + timeoutMs) : Float.MAX_VALUE;
      this.waitTimeouts.putIfAbsent(Tuple2.of(name, key.invocationUid), Tuple2.of(Long.valueOf(timeoutMs), Long.valueOf(deadline)));
    } else {
      deadline = Float.MAX_VALUE;
    } 
    if (timeoutMs != 0L)
      addLiveOperation(key, deadline); 
  }
  
  protected final void removeWaitKey(String name, W key) {
    this.waitTimeouts.remove(Tuple2.of(name, key.invocationUid()));
    removeLiveOperation(key);
  }
  
  final void expireWaitKey(String name, UUID invocationUid, List<W> expired) {
    this.waitTimeouts.remove(Tuple2.of(name, invocationUid));
    BlockingResource<W> resource = getResourceOrNull(name);
    if (resource != null)
      resource.expireWaitKeys(invocationUid, expired); 
  }
  
  final Collection<Tuple2<String, UUID>> getWaitKeysToExpire(long now) {
    List<Tuple2<String, UUID>> expired = new ArrayList<Tuple2<String, UUID>>();
    for (Map.Entry<Tuple2<String, UUID>, Tuple2<Long, Long>> e : this.waitTimeouts.entrySet()) {
      long deadline = ((Long)((Tuple2)e.getValue()).element2).longValue();
      if (deadline <= now)
        expired.add(e.getKey()); 
    } 
    return expired;
  }
  
  final Map<Tuple2<String, UUID>, Long> overwriteWaitTimeouts(Map<Tuple2<String, UUID>, Tuple2<Long, Long>> existingWaitTimeouts) {
    for (Map.Entry<Tuple2<String, UUID>, Tuple2<Long, Long>> e : existingWaitTimeouts.entrySet())
      this.waitTimeouts.put(e.getKey(), e.getValue()); 
    Map<Tuple2<String, UUID>, Long> newKeys = new HashMap<Tuple2<String, UUID>, Long>();
    for (Map.Entry<Tuple2<String, UUID>, Tuple2<Long, Long>> e : this.waitTimeouts.entrySet()) {
      Tuple2<String, UUID> key = (Tuple2)e.getKey();
      if (!existingWaitTimeouts.containsKey(key)) {
        Long timeout = (Long)((Tuple2)e.getValue()).element1;
        newKeys.put(key, timeout);
      } 
    } 
    return newKeys;
  }
  
  final void closeSession(long sessionId, List<Long> expiredWaitKeys, Map<Long, Object> result) {
    for (Iterator iterator = this.resources.values().iterator(); iterator.hasNext(); ) {
      R resource = (R)(BlockingResource)iterator.next();
      resource.closeSession(sessionId, expiredWaitKeys, result);
    } 
  }
  
  final Collection<Long> getAttachedSessions() {
    Set<Long> sessions = new HashSet<Long>();
    for (Iterator iterator = this.resources.values().iterator(); iterator.hasNext(); ) {
      R res = (R)(BlockingResource)iterator.next();
      res.collectAttachedSessions(sessions);
    } 
    return sessions;
  }
  
  final Collection<W> destroyResource(String name) {
    this.destroyedNames.add(name);
    BlockingResource<W> resource = (BlockingResource)this.resources.remove(name);
    if (resource == null)
      return null; 
    Collection<W> keys = resource.getAllWaitKeys();
    for (Iterator iterator = keys.iterator(); iterator.hasNext(); ) {
      W key = (W)(WaitKey)iterator.next();
      removeWaitKey(name, key);
    } 
    return keys;
  }
  
  public final CPGroupId getGroupId() { return this.groupId; }
  
  public final Map<Tuple2<String, UUID>, Tuple2<Long, Long>> getWaitTimeouts() { return Collections.unmodifiableMap(this.waitTimeouts); }
  
  public final Collection<Long> destroy() {
    this.destroyedNames.addAll(this.resources.keySet());
    Collection<Long> indices = new ArrayList<Long>();
    for (BlockingResource<W> raftLock : this.resources.values()) {
      for (Iterator iterator = raftLock.getAllWaitKeys().iterator(); iterator.hasNext(); ) {
        W key = (W)(WaitKey)iterator.next();
        indices.add(Long.valueOf(key.commitIndex()));
      } 
    } 
    this.resources.clear();
    this.waitTimeouts.clear();
    return indices;
  }
  
  public void populate(LiveOperations liveOperations, long now) {
    Iterator<Map.Entry<Tuple2<Address, Long>, Long>> it = this.liveOperationMap.entrySet().iterator();
    while (it.hasNext()) {
      Map.Entry<Tuple2<Address, Long>, Long> e = (Map.Entry)it.next();
      long deadline = ((Long)e.getValue()).longValue();
      if (deadline >= now) {
        Tuple2<Address, Long> t = (Tuple2)e.getKey();
        liveOperations.add((Address)t.element1, ((Long)t.element2).longValue());
        continue;
      } 
      it.remove();
    } 
  }
  
  private void addLiveOperation(W key, long deadline) {
    if (Float.MAX_VALUE - deadline >= OPERATION_TIMEOUT_EXTENSION_MS)
      deadline += OPERATION_TIMEOUT_EXTENSION_MS; 
    this.liveOperationMap.put(Tuple2.of(key.callerAddress(), Long.valueOf(key.callId())), Long.valueOf(deadline));
  }
  
  final void removeLiveOperation(W key) { this.liveOperationMap.remove(Tuple2.of(key.callerAddress(), Long.valueOf(key.callId()))); }
  
  public final Collection<Tuple2<Address, Long>> getLiveOperations() { return this.liveOperationMap.keySet(); }
  
  final void onSnapshotRestore() {
    for (Iterator iterator = this.resources.values().iterator(); iterator.hasNext(); ) {
      R resource = (R)(BlockingResource)iterator.next();
      for (Iterator iterator1 = resource.getAllWaitKeys().iterator(); iterator1.hasNext(); ) {
        W key = (W)(WaitKey)iterator1.next();
        Tuple2<Long, Long> t = (Tuple2)this.waitTimeouts.get(Tuple2.of(resource.getName(), key.invocationUid));
        long deadline = (t != null) ? ((Long)t.element1).longValue() : Float.MAX_VALUE;
        addLiveOperation(key, deadline);
      } 
    } 
  }
  
  public void writeData(ObjectDataOutput out) throws IOException {
    out.writeObject(this.groupId);
    out.writeInt(this.resources.size());
    for (Map.Entry<String, R> e : this.resources.entrySet()) {
      out.writeUTF((String)e.getKey());
      out.writeObject(e.getValue());
    } 
    out.writeInt(this.destroyedNames.size());
    for (String name : this.destroyedNames)
      out.writeUTF(name); 
    out.writeInt(this.waitTimeouts.size());
    for (Map.Entry<Tuple2<String, UUID>, Tuple2<Long, Long>> e : this.waitTimeouts.entrySet()) {
      Tuple2<String, UUID> t = (Tuple2)e.getKey();
      out.writeUTF((String)t.element1);
      UUIDSerializationUtil.writeUUID(out, (UUID)t.element2);
      out.writeLong(((Long)((Tuple2)e.getValue()).element1).longValue());
    } 
  }
  
  public void readData(ObjectDataInput in) throws IOException {
    this.groupId = (CPGroupId)in.readObject();
    int count = in.readInt();
    for (int i = 0; i < count; i++) {
      String name = in.readUTF();
      R res = (R)(BlockingResource)in.readObject();
      this.resources.put(name, res);
    } 
    count = in.readInt();
    for (int i = 0; i < count; i++) {
      String name = in.readUTF();
      this.destroyedNames.add(name);
    } 
    long now = Clock.currentTimeMillis();
    count = in.readInt();
    for (int i = 0; i < count; i++) {
      String name = in.readUTF();
      UUID invocationUid = UUIDSerializationUtil.readUUID(in);
      long timeout = in.readLong();
      this.waitTimeouts.put(Tuple2.of(name, invocationUid), Tuple2.of(Long.valueOf(timeout), Long.valueOf(now + timeout)));
    } 
  }
  
  public String toString() { return "ResourceRegistry{groupId=" + this.groupId + ", resources=" + this.resources + ", destroyedNames=" + this.destroyedNames + ", waitTimeouts=" + this.waitTimeouts + '}'; }
}
