package com.hazelcast.cp.internal.datastructures.spi.blocking;

import com.hazelcast.cp.CPGroupId;
import com.hazelcast.cp.internal.RaftNodeLifecycleAwareService;
import com.hazelcast.cp.internal.RaftService;
import com.hazelcast.cp.internal.datastructures.spi.RaftManagedService;
import com.hazelcast.cp.internal.datastructures.spi.RaftRemoteService;
import com.hazelcast.cp.internal.datastructures.spi.blocking.operation.ExpireWaitKeysOp;
import com.hazelcast.cp.internal.raft.SnapshotAwareService;
import com.hazelcast.cp.internal.raft.impl.RaftNode;
import com.hazelcast.cp.internal.raft.impl.RaftNodeImpl;
import com.hazelcast.cp.internal.session.SessionAccessor;
import com.hazelcast.cp.internal.session.SessionAwareService;
import com.hazelcast.cp.internal.session.SessionExpiredException;
import com.hazelcast.cp.internal.util.Tuple2;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.spi.ExecutionService;
import com.hazelcast.spi.LiveOperations;
import com.hazelcast.spi.LiveOperationsTracker;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.exception.DistributedObjectDestroyedException;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.impl.executionservice.InternalExecutionService;
import com.hazelcast.util.Clock;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.collection.Long2ObjectHashMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;

public abstract class AbstractBlockingService<W extends WaitKey, R extends BlockingResource<W>, RR extends ResourceRegistry<W, R>> extends Object implements RaftManagedService, RaftNodeLifecycleAwareService, RaftRemoteService, SessionAwareService, SnapshotAwareService<RR>, LiveOperationsTracker {
  public static final long WAIT_TIMEOUT_TASK_UPPER_BOUND_MILLIS = 1500L;
  
  private static final long WAIT_TIMEOUT_TASK_PERIOD_MILLIS = 500L;
  
  protected final NodeEngineImpl nodeEngine;
  
  protected final ILogger logger;
  
  private final ConcurrentMap<CPGroupId, RR> registries;
  
  protected AbstractBlockingService(NodeEngine nodeEngine) {
    this.registries = new ConcurrentHashMap();
    this.nodeEngine = (NodeEngineImpl)nodeEngine;
    this.logger = nodeEngine.getLogger(getClass());
  }
  
  public final void init(NodeEngine nodeEngine, Properties properties) {
    this.raftService = (RaftService)nodeEngine.getService("hz:core:raft");
    ExecutionService executionService = nodeEngine.getExecutionService();
    executionService.scheduleWithRepetition(new ExpireWaitKeysPeriodicTask(this, null), 500L, 500L, TimeUnit.MILLISECONDS);
    initImpl();
  }
  
  protected void initImpl() {}
  
  public void reset() {}
  
  public void onCPSubsystemRestart() { this.registries.clear(); }
  
  public final void shutdown(boolean terminate) {
    this.registries.clear();
    shutdownImpl(terminate);
  }
  
  protected void shutdownImpl(boolean terminate) {}
  
  protected void onRegistryRestored(RR registry) {}
  
  public boolean destroyRaftObject(CPGroupId groupId, String name) {
    Collection<W> keys = getOrInitRegistry(groupId).destroyResource(name);
    if (keys == null)
      return false; 
    List<Long> commitIndices = new ArrayList<Long>();
    for (Iterator iterator = keys.iterator(); iterator.hasNext(); ) {
      W key = (W)(WaitKey)iterator.next();
      commitIndices.add(Long.valueOf(key.commitIndex()));
    } 
    completeFutures(groupId, commitIndices, new DistributedObjectDestroyedException(name + " is destroyed"));
    return true;
  }
  
  public final RR takeSnapshot(CPGroupId groupId, long commitIndex) {
    RR registry = (RR)getRegistryOrNull(groupId);
    return (RR)((registry != null) ? registry.cloneForSnapshot() : null);
  }
  
  public final void restoreSnapshot(CPGroupId groupId, long commitIndex, RR registry) {
    RR prev = (RR)(ResourceRegistry)this.registries.put(registry.getGroupId(), registry);
    Map<Tuple2<String, UUID>, Tuple2<Long, Long>> existingWaitTimeouts = (prev != null) ? prev.getWaitTimeouts() : Collections.emptyMap();
    Map<Tuple2<String, UUID>, Long> newWaitKeys = registry.overwriteWaitTimeouts(existingWaitTimeouts);
    for (Map.Entry<Tuple2<String, UUID>, Long> e : newWaitKeys.entrySet())
      scheduleTimeout(groupId, (String)((Tuple2)e.getKey()).element1, (UUID)((Tuple2)e.getKey()).element2, ((Long)e.getValue()).longValue()); 
    registry.onSnapshotRestore();
    onRegistryRestored(registry);
  }
  
  public void setSessionAccessor(SessionAccessor accessor) { this.sessionAccessor = accessor; }
  
  public final void onSessionClose(CPGroupId groupId, long sessionId) {
    ResourceRegistry<W, R> registry = (ResourceRegistry)this.registries.get(groupId);
    if (registry == null) {
      if (this.logger.isFineEnabled())
        this.logger.fine("Resource registry of " + groupId + " not found to handle closed Session[" + sessionId + "]"); 
      return;
    } 
    List<Long> expiredWaitKeys = new ArrayList<Long>();
    Long2ObjectHashMap<Object> completedWaitKeys = new Long2ObjectHashMap<Object>();
    registry.closeSession(sessionId, expiredWaitKeys, completedWaitKeys);
    if (this.logger.isFineEnabled() && (expiredWaitKeys.size() > 0 || completedWaitKeys.size() > 0))
      this.logger.fine("Closed Session[" + sessionId + "] in " + groupId + " expired wait key commit indices: " + expiredWaitKeys + " completed wait keys: " + completedWaitKeys); 
    completeFutures(groupId, expiredWaitKeys, new SessionExpiredException());
    RaftNodeImpl raftNode = (RaftNodeImpl)this.raftService.getRaftNode(groupId);
    for (Map.Entry<Long, Object> entry : completedWaitKeys.entrySet())
      raftNode.completeFuture(((Long)entry.getKey()).longValue(), entry.getValue()); 
  }
  
  public final Collection<Long> getAttachedSessions(CPGroupId groupId) {
    RR registry = (RR)getRegistryOrNull(groupId);
    return (registry != null) ? registry.getAttachedSessions() : Collections.emptyList();
  }
  
  public final void onRaftGroupDestroyed(CPGroupId groupId) {
    ResourceRegistry<W, R> registry = (ResourceRegistry)this.registries.get(groupId);
    if (registry != null) {
      Collection<Long> indices = registry.destroy();
      completeFutures(groupId, indices, new DistributedObjectDestroyedException(groupId + " is destroyed"));
    } 
  }
  
  public final void onRaftNodeSteppedDown(CPGroupId groupId) {}
  
  public final void populate(LiveOperations liveOperations) {
    long now = Clock.currentTimeMillis();
    for (Iterator iterator = this.registries.values().iterator(); iterator.hasNext(); ) {
      RR registry = (RR)(ResourceRegistry)iterator.next();
      registry.populate(liveOperations, now);
    } 
  }
  
  public final void expireWaitKeys(CPGroupId groupId, Collection<Tuple2<String, UUID>> keys) {
    ResourceRegistry<W, R> registry = (ResourceRegistry)this.registries.get(groupId);
    if (registry == null) {
      this.logger.severe("Registry of " + groupId + " not found to expire wait keys: " + keys);
      return;
    } 
    List<W> expired = new ArrayList<W>();
    for (Tuple2<String, UUID> key : keys)
      registry.expireWaitKey((String)key.element1, (UUID)key.element2, expired); 
    List<Long> commitIndices = new ArrayList<Long>();
    for (Iterator iterator = expired.iterator(); iterator.hasNext(); ) {
      W key = (W)(WaitKey)iterator.next();
      commitIndices.add(Long.valueOf(key.commitIndex()));
      registry.removeLiveOperation(key);
    } 
    completeFutures(groupId, commitIndices, expiredWaitKeyResponse());
  }
  
  public final RR getRegistryOrNull(CPGroupId groupId) { return (RR)(ResourceRegistry)this.registries.get(groupId); }
  
  public Collection<Tuple2<Address, Long>> getLiveOperations(CPGroupId groupId) {
    RR registry = (RR)(ResourceRegistry)this.registries.get(groupId);
    if (registry == null)
      return Collections.emptySet(); 
    return Collections.unmodifiableCollection(registry.getLiveOperations());
  }
  
  protected final RR getOrInitRegistry(CPGroupId groupId) {
    Preconditions.checkNotNull(groupId);
    RR registry = (RR)(ResourceRegistry)this.registries.get(groupId);
    if (registry == null) {
      registry = (RR)createNewRegistry(groupId);
      this.registries.put(groupId, registry);
    } 
    return registry;
  }
  
  protected final void scheduleTimeout(CPGroupId groupId, String name, UUID invocationUid, long timeoutMs) {
    if (timeoutMs > 0L && timeoutMs <= 1500L) {
      InternalExecutionService internalExecutionService = this.nodeEngine.getExecutionService();
      internalExecutionService.schedule(new ExpireWaitKeysTask(this, groupId, Tuple2.of(name, invocationUid)), timeoutMs, TimeUnit.MILLISECONDS);
    } 
  }
  
  protected final void heartbeatSession(CPGroupId groupId, long sessionId) {
    if (sessionId == -1L)
      return; 
    if (this.sessionAccessor.isActive(groupId, sessionId)) {
      this.sessionAccessor.heartbeat(groupId, sessionId);
      return;
    } 
    throw new SessionExpiredException("active session: " + sessionId + " does not exist in " + groupId);
  }
  
  protected final void notifyWaitKeys(CPGroupId groupId, String name, Collection<W> keys, Object result) {
    if (keys.isEmpty())
      return; 
    if (this.logger.isFineEnabled())
      this.logger.fine("Resource[" + name + "] in " + groupId + " completed wait keys: " + keys + " result: " + result); 
    List<Long> indices = new ArrayList<Long>(keys.size());
    for (Iterator iterator = keys.iterator(); iterator.hasNext(); ) {
      W key = (W)(WaitKey)iterator.next();
      indices.add(Long.valueOf(key.commitIndex()));
    } 
    completeFutures(groupId, indices, result);
  }
  
  private void completeFutures(CPGroupId groupId, Collection<Long> indices, Object result) {
    if (!indices.isEmpty()) {
      RaftNodeImpl raftNode = (RaftNodeImpl)this.raftService.getRaftNode(groupId);
      if (raftNode != null) {
        for (Long index : indices)
          raftNode.completeFuture(index.longValue(), result); 
      } else {
        this.logger.severe("RaftNode not found for " + groupId + " to notify commit indices " + indices + " with " + result);
      } 
    } 
  }
  
  private void tryReplicateExpiredWaitKeys(CPGroupId groupId, Collection<Tuple2<String, UUID>> keys) {
    try {
      RaftNode raftNode = this.raftService.getRaftNode(groupId);
      if (raftNode != null)
        raftNode.replicate(new ExpireWaitKeysOp(serviceName(), keys)).get(); 
    } catch (Exception e) {
      if (this.logger.isFineEnabled())
        this.logger.fine("Could not expire wait keys: " + keys + " in " + groupId, e); 
    } 
  }
  
  protected abstract String serviceName();
  
  protected abstract RR createNewRegistry(CPGroupId paramCPGroupId);
  
  protected abstract Object expiredWaitKeyResponse();
}
