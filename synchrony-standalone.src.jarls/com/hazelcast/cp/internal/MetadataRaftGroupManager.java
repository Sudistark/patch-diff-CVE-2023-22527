package com.hazelcast.cp.internal;

import com.hazelcast.config.cp.CPSubsystemConfig;
import com.hazelcast.core.Member;
import com.hazelcast.cp.CPGroup;
import com.hazelcast.cp.CPGroupId;
import com.hazelcast.cp.CPMember;
import com.hazelcast.cp.exception.CPGroupDestroyedException;
import com.hazelcast.cp.internal.exception.CannotCreateRaftGroupException;
import com.hazelcast.cp.internal.exception.CannotRemoveCPMemberException;
import com.hazelcast.cp.internal.exception.MetadataRaftGroupInitInProgressException;
import com.hazelcast.cp.internal.raft.SnapshotAwareService;
import com.hazelcast.cp.internal.raft.impl.RaftNode;
import com.hazelcast.cp.internal.raft.impl.RaftNodeImpl;
import com.hazelcast.cp.internal.raftop.metadata.CreateRaftNodeOp;
import com.hazelcast.cp.internal.raftop.metadata.DestroyRaftNodesOp;
import com.hazelcast.cp.internal.raftop.metadata.PublishActiveCPMembersOp;
import com.hazelcast.cp.internal.util.Tuple2;
import com.hazelcast.logging.ILogger;
import com.hazelcast.spi.ExecutionService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.OperationService;
import com.hazelcast.spi.exception.RetryableHazelcastException;
import com.hazelcast.spi.impl.operationservice.impl.RaftInvocationContext;
import com.hazelcast.util.Preconditions;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

public class MetadataRaftGroupManager extends Object implements SnapshotAwareService<MetadataRaftGroupSnapshot> {
  public static final RaftGroupId INITIAL_METADATA_GROUP_ID = new RaftGroupId("METADATA", 0L, 0L);
  
  private static final int RANDOM_COMMIT_RANGE = 20;
  
  private static final int RANDOM_COMMIT_TIMEOUT_SECS = 60;
  
  private static final long DISCOVER_INITIAL_CP_MEMBERS_TASK_DELAY_MILLIS = 1000L;
  
  private static final long DISCOVER_INITIAL_CP_MEMBERS_TASK_LOGGING_DELAY_MILLIS = 5000L;
  
  private static final long BROADCAST_ACTIVE_CP_MEMBERS_TASK_PERIOD_SECONDS = 10L;
  
  private final NodeEngine nodeEngine;
  
  private final RaftService raftService;
  
  private final ILogger logger;
  
  private final CPSubsystemConfig config;
  
  private final AtomicReference<CPMemberInfo> localCPMember;
  
  private final AtomicReference<RaftGroupId> metadataGroupIdRef;
  
  private final AtomicBoolean discoveryCompleted;
  
  private final ConcurrentMap<CPGroupId, CPGroupInfo> groups;
  
  private final Set<CPMemberInfo> initializedCPMembers;
  
  private final Set<Long> initializationCommitIndices;
  
  MetadataRaftGroupManager(NodeEngine nodeEngine, RaftService raftService, CPSubsystemConfig config) {
    this.localCPMember = new AtomicReference();
    this.metadataGroupIdRef = new AtomicReference(INITIAL_METADATA_GROUP_ID);
    this.discoveryCompleted = new AtomicBoolean();
    this.groups = new ConcurrentHashMap();
    this.activeMembers = Collections.emptySet();
    this.initializationStatus = MetadataRaftGroupInitStatus.IN_PROGRESS;
    this.initializedCPMembers = Collections.newSetFromMap(new ConcurrentHashMap());
    this.initializationCommitIndices = Collections.newSetFromMap(new ConcurrentHashMap());
    this.nodeEngine = nodeEngine;
    this.raftService = raftService;
    this.logger = nodeEngine.getLogger(getClass());
    this.config = config;
  }
  
  boolean init() {
    boolean cpSubsystemEnabled = (this.config.getCPMemberCount() > 0);
    if (cpSubsystemEnabled) {
      scheduleDiscoverInitialCPMembersTask(true);
    } else {
      disableDiscovery();
    } 
    return cpSubsystemEnabled;
  }
  
  void initPromotedCPMember(CPMemberInfo member) {
    if (!this.localCPMember.compareAndSet(null, member))
      return; 
    scheduleRaftGroupMembershipManagementTasks();
  }
  
  private void scheduleRaftGroupMembershipManagementTasks() {
    ExecutionService executionService = this.nodeEngine.getExecutionService();
    executionService.scheduleWithRepetition(new BroadcastActiveCPMembersTask(this, null), 10L, 10L, TimeUnit.SECONDS);
    RaftGroupMembershipManager membershipManager = new RaftGroupMembershipManager(this.nodeEngine, this.raftService);
    membershipManager.init();
  }
  
  void restart(long seed) {
    this.activeMembers = Collections.emptySet();
    this.activeMembersCommitIndex = 0L;
    this.groups.clear();
    this.initialCPMembers = null;
    this.initializationStatus = MetadataRaftGroupInitStatus.IN_PROGRESS;
    this.initializedCPMembers.clear();
    this.initializationCommitIndices.clear();
    this.membershipChangeSchedule = null;
    this.metadataGroupIdRef.set(new RaftGroupId("METADATA", seed, 0L));
    this.localCPMember.set(null);
    DiscoverInitialCPMembersTask discoveryTask = this.currentDiscoveryTask;
    if (discoveryTask != null)
      discoveryTask.cancelAndAwaitCompletion(); 
    this.discoveryCompleted.set(false);
    scheduleDiscoverInitialCPMembersTask(false);
  }
  
  public MetadataRaftGroupSnapshot takeSnapshot(CPGroupId groupId, long commitIndex) {
    if (!getMetadataGroupId().equals(groupId))
      return null; 
    if (this.logger.isFineEnabled())
      this.logger.fine("Taking snapshot for commit-index: " + commitIndex); 
    MetadataRaftGroupSnapshot snapshot = new MetadataRaftGroupSnapshot();
    snapshot.setMembers(this.activeMembers);
    snapshot.setMembersCommitIndex(this.activeMembersCommitIndex);
    snapshot.setGroups(this.groups.values());
    snapshot.setMembershipChangeSchedule(this.membershipChangeSchedule);
    snapshot.setInitialCPMembers(this.initialCPMembers);
    snapshot.setInitializedCPMembers(this.initializedCPMembers);
    snapshot.setInitializationStatus(this.initializationStatus);
    snapshot.setInitializationCommitIndices(this.initializationCommitIndices);
    return snapshot;
  }
  
  public void restoreSnapshot(CPGroupId groupId, long commitIndex, MetadataRaftGroupSnapshot snapshot) {
    ensureMetadataGroupId(groupId);
    Preconditions.checkNotNull(snapshot);
    Set<CPGroupId> snapshotGroupIds = new HashSet<CPGroupId>();
    for (CPGroupInfo group : snapshot.getGroups()) {
      this.groups.put(group.id(), group);
      snapshotGroupIds.add(group.id());
    } 
    Iterator<CPGroupId> it = this.groups.keySet().iterator();
    while (it.hasNext()) {
      if (!snapshotGroupIds.contains(it.next()))
        it.remove(); 
    } 
    doSetActiveMembers(snapshot.getMembersCommitIndex(), new LinkedHashSet(snapshot.getMembers()));
    this.membershipChangeSchedule = snapshot.getMembershipChangeSchedule();
    this.initialCPMembers = snapshot.getInitialCPMembers();
    this.initializedCPMembers.clear();
    this.initializedCPMembers.addAll(snapshot.getInitializedCPMembers());
    this.initializationStatus = snapshot.getInitializationStatus();
    this.initializationCommitIndices.clear();
    this.initializationCommitIndices.addAll(snapshot.getInitializationCommitIndices());
    if (this.logger.isFineEnabled())
      this.logger.fine("Restored snapshot at commit-index: " + commitIndex); 
  }
  
  private void ensureMetadataGroupId(CPGroupId groupId) {
    RaftGroupId raftGroupId = getMetadataGroupId();
    Preconditions.checkTrue(raftGroupId.equals(groupId), "Invalid RaftGroupId! Expected: " + raftGroupId + ", Actual: " + groupId);
  }
  
  CPMemberInfo getLocalCPMember() { return (CPMemberInfo)this.localCPMember.get(); }
  
  public RaftGroupId getMetadataGroupId() { return (RaftGroupId)this.metadataGroupIdRef.get(); }
  
  long getGroupIdSeed() { return getMetadataGroupId().seed(); }
  
  public Collection<CPGroupId> getGroupIds() {
    List<CPGroupId> groupIds = new ArrayList<CPGroupId>(this.groups.keySet());
    Collections.sort(groupIds, new CPGroupIdComparator(null));
    return groupIds;
  }
  
  public Collection<CPGroupId> getActiveGroupIds() {
    List<CPGroupId> activeGroupIds = new ArrayList<CPGroupId>(1);
    for (CPGroupInfo group : this.groups.values()) {
      if (group.status() == CPGroup.CPGroupStatus.ACTIVE)
        activeGroupIds.add(group.id()); 
    } 
    Collections.sort(activeGroupIds, new CPGroupIdComparator(null));
    return activeGroupIds;
  }
  
  public CPGroupInfo getGroup(CPGroupId groupId) {
    Preconditions.checkNotNull(groupId);
    if (groupId instanceof RaftGroupId && ((RaftGroupId)groupId).seed() < getGroupIdSeed())
      throw new CPGroupDestroyedException(groupId); 
    return (CPGroupInfo)this.groups.get(groupId);
  }
  
  public CPGroupInfo getActiveGroup(String groupName) {
    for (CPGroupInfo group : this.groups.values()) {
      if (group.status() == CPGroup.CPGroupStatus.ACTIVE && group.name().equals(groupName))
        return group; 
    } 
    return null;
  }
  
  public boolean initMetadataGroup(long commitIndex, CPMemberInfo callerCPMember, List<CPMemberInfo> discoveredCPMembers, long expectedGroupIdSeed) {
    Preconditions.checkNotNull(discoveredCPMembers);
    if (this.initializationStatus == MetadataRaftGroupInitStatus.FAILED) {
      String msg = callerCPMember + "committed CP member list: " + discoveredCPMembers + " after CP subsystem discovery has already failed.";
      this.logger.severe(msg);
      throw new IllegalArgumentException(msg);
    } 
    if (discoveredCPMembers.size() != this.config.getCPMemberCount()) {
      String msg = callerCPMember + "'s discovered CP member list: " + discoveredCPMembers + " must consist of " + this.config.getCPMemberCount() + " CP members";
      failMetadataRaftGroupInitializationIfNotCompletedAndThrow(msg);
    } 
    if (this.initialCPMembers != null && (this.initialCPMembers
      .size() != discoveredCPMembers.size() || 
      !this.initialCPMembers.containsAll(discoveredCPMembers))) {
      String msg = "Invalid initial CP members! Expected: " + this.initialCPMembers + ", Actual: " + discoveredCPMembers;
      failMetadataRaftGroupInitializationIfNotCompletedAndThrow(msg);
    } 
    long groupIdSeed = getGroupIdSeed();
    if (groupIdSeed != expectedGroupIdSeed) {
      String msg = "Cannot create METADATA CP group. Local groupId seed: " + groupIdSeed + ", expected groupId seed: " + expectedGroupIdSeed;
      failMetadataRaftGroupInitializationIfNotCompletedAndThrow(msg);
    } 
    List<CPMemberInfo> discoveredMetadataMembers = discoveredCPMembers.subList(0, this.config.getGroupSize());
    CPGroupInfo metadataGroup = new CPGroupInfo(getMetadataGroupId(), discoveredMetadataMembers);
    CPGroupInfo existingMetadataGroup = (CPGroupInfo)this.groups.putIfAbsent(getMetadataGroupId(), metadataGroup);
    if (existingMetadataGroup != null) {
      Collection<CPMember> metadataMembers = existingMetadataGroup.initialMembers();
      if (discoveredMetadataMembers.size() != metadataMembers.size() || 
        !metadataMembers.containsAll(discoveredMetadataMembers)) {
        String msg = "Cannot create METADATA CP group with " + this.config.getCPMemberCount() + " because it already exists with a different member list: " + existingMetadataGroup;
        failMetadataRaftGroupInitializationIfNotCompletedAndThrow(msg);
      } 
    } 
    if (this.initializationStatus == MetadataRaftGroupInitStatus.SUCCESSFUL)
      return true; 
    this.initializationCommitIndices.add(Long.valueOf(commitIndex));
    if (!this.initializedCPMembers.add(callerCPMember))
      return false; 
    this.logger.fine("METADATA " + metadataGroup + " initialization is committed for " + callerCPMember + " with seed: " + expectedGroupIdSeed + " and discovered CP members: " + discoveredCPMembers);
    if (this.initializedCPMembers.size() == this.config.getCPMemberCount()) {
      this.initializationCommitIndices.remove(Long.valueOf(commitIndex));
      this.logger.fine("METADATA " + metadataGroup + " initialization is completed with: " + this.initializedCPMembers);
      this.initializationStatus = MetadataRaftGroupInitStatus.SUCCESSFUL;
      completeFutures(getMetadataGroupId(), this.initializationCommitIndices, null);
      this.initializedCPMembers.clear();
      this.initializationCommitIndices.clear();
      return true;
    } 
    if (this.initialCPMembers != null)
      return false; 
    Collection<CPMemberInfo> cpMembers = new LinkedHashSet<CPMemberInfo>(discoveredCPMembers);
    this.initialCPMembers = Collections.unmodifiableList(new ArrayList(cpMembers));
    doSetActiveMembers(commitIndex, cpMembers);
    return false;
  }
  
  private void failMetadataRaftGroupInitializationIfNotCompletedAndThrow(String error) {
    this.logger.severe(error);
    RuntimeException exception = new IllegalArgumentException(error);
    if (this.initializationStatus == MetadataRaftGroupInitStatus.IN_PROGRESS) {
      this.initializationStatus = MetadataRaftGroupInitStatus.FAILED;
      completeFutures(getMetadataGroupId(), this.initializationCommitIndices, exception);
      this.initializedCPMembers.clear();
      this.initializationCommitIndices.clear();
    } 
    throw exception;
  }
  
  public CPGroupId createRaftGroup(String groupName, Collection<CPMemberInfo> members, long commitIndex) {
    Preconditions.checkFalse("METADATA".equalsIgnoreCase(groupName), groupName + " is reserved for internal usage!");
    checkMetadataGroupInitSuccessful();
    CPGroupInfo group = getRaftGroupByName(groupName);
    if (group != null) {
      if (group.memberCount() == members.size()) {
        if (this.logger.isFineEnabled())
          this.logger.fine("CP group " + groupName + " already exists."); 
        return group.id();
      } 
      String msg = group.getId() + " already exists with a different size: " + group.memberCount();
      this.logger.severe(msg);
      throw new IllegalStateException(msg);
    } 
    CPMemberInfo leavingMember = (this.membershipChangeSchedule != null) ? this.membershipChangeSchedule.getLeavingMember() : null;
    for (CPMemberInfo member : members) {
      if (member.equals(leavingMember) || !this.activeMembers.contains(member)) {
        String msg = "Cannot create CP group: " + groupName + " since " + member + " is not active";
        if (this.logger.isFineEnabled())
          this.logger.fine(msg); 
        throw new CannotCreateRaftGroupException(msg);
      } 
    } 
    return createRaftGroup(new CPGroupInfo(new RaftGroupId(groupName, getGroupIdSeed(), commitIndex), members));
  }
  
  private CPGroupId createRaftGroup(CPGroupInfo group) {
    addRaftGroup(group);
    this.logger.info("New " + group.id() + " is created with " + group.members());
    RaftGroupId groupId = group.id();
    if (group.containsMember(getLocalCPMember())) {
      this.raftService.createRaftNode(groupId, group.memberImpls());
    } else {
      OperationService operationService = this.nodeEngine.getOperationService();
      CPGroupInfo metadataGroup = (CPGroupInfo)this.groups.get(getMetadataGroupId());
      for (CPMemberInfo member : group.memberImpls()) {
        if (!metadataGroup.containsMember(member)) {
          CreateRaftNodeOp createRaftNodeOp = new CreateRaftNodeOp(group.id(), group.initialMembers());
          operationService.send(createRaftNodeOp, member.getAddress());
        } 
      } 
    } 
    return groupId;
  }
  
  private void addRaftGroup(CPGroupInfo group) {
    RaftGroupId raftGroupId = group.id();
    if (this.groups.containsKey(raftGroupId)) {
      String msg = group + " already exists!";
      if (this.logger.isFineEnabled())
        this.logger.warning(msg); 
      throw new IllegalStateException(msg);
    } 
    this.groups.put(raftGroupId, group);
  }
  
  private CPGroupInfo getRaftGroupByName(String name) {
    for (CPGroupInfo group : this.groups.values()) {
      if (group.status() != CPGroup.CPGroupStatus.DESTROYED && group.name().equals(name))
        return group; 
    } 
    return null;
  }
  
  public void triggerDestroyRaftGroup(CPGroupId groupId) {
    Preconditions.checkNotNull(groupId);
    checkMetadataGroupInitSuccessful();
    if (this.membershipChangeSchedule != null) {
      String msg = "Cannot destroy " + groupId + " while there are ongoing CP membership changes!";
      if (this.logger.isFineEnabled())
        this.logger.warning(msg); 
      throw new IllegalStateException(msg);
    } 
    CPGroupInfo group = (CPGroupInfo)this.groups.get(groupId);
    if (group == null) {
      String msg = "No CP group exists for " + groupId + " to destroy!";
      if (this.logger.isFineEnabled())
        this.logger.warning(msg); 
      throw new IllegalArgumentException(msg);
    } 
    if (group.setDestroying()) {
      this.logger.info("Destroying " + groupId);
    } else if (this.logger.isFineEnabled()) {
      this.logger.fine(groupId + " is already " + group.status());
    } 
  }
  
  public void completeDestroyRaftGroups(Set<CPGroupId> groupIds) {
    Preconditions.checkNotNull(groupIds);
    for (CPGroupId groupId : groupIds) {
      Preconditions.checkNotNull(groupId);
      if (!this.groups.containsKey(groupId)) {
        String msg = groupId + " does not exist to complete destroy";
        this.logger.warning(msg);
        throw new IllegalArgumentException(msg);
      } 
    } 
    for (CPGroupId groupId : groupIds)
      completeDestroyRaftGroup((CPGroupInfo)this.groups.get(groupId)); 
  }
  
  private void completeDestroyRaftGroup(CPGroupInfo group) {
    RaftGroupId raftGroupId = group.id();
    if (group.setDestroyed()) {
      this.logger.info(raftGroupId + " is destroyed.");
      sendDestroyRaftNodeOps(group);
    } else if (this.logger.isFineEnabled()) {
      this.logger.fine(raftGroupId + " is already destroyed.");
    } 
  }
  
  public void forceDestroyRaftGroup(String groupName) {
    Preconditions.checkNotNull(groupName);
    Preconditions.checkFalse("METADATA".equalsIgnoreCase(groupName), "Cannot force-destroy the METADATA CP group!");
    checkMetadataGroupInitSuccessful();
    boolean found = false;
    for (CPGroupInfo group : this.groups.values()) {
      if (group.name().equals(groupName)) {
        if (group.forceSetDestroyed()) {
          this.logger.info(group.id() + " is force-destroyed.");
          sendDestroyRaftNodeOps(group);
        } else if (this.logger.isFineEnabled()) {
          this.logger.fine(group.id() + " is already force-destroyed.");
        } 
        found = true;
      } 
    } 
    if (!found)
      throw new IllegalArgumentException("CP group with name: " + groupName + " does not exist to force-destroy!"); 
  }
  
  private void sendDestroyRaftNodeOps(CPGroupInfo group) {
    OperationService operationService = this.nodeEngine.getOperationService();
    DestroyRaftNodesOp destroyRaftNodesOp = new DestroyRaftNodesOp(Collections.singleton(group.id()));
    for (CPMemberInfo member : group.memberImpls()) {
      if (member.equals(getLocalCPMember())) {
        this.raftService.destroyRaftNode(group.id());
        continue;
      } 
      operationService.send(destroyRaftNodesOp, member.getAddress());
    } 
  }
  
  public boolean removeMember(long commitIndex, CPMemberInfo leavingMember) {
    Preconditions.checkNotNull(leavingMember);
    checkMetadataGroupInitSuccessful();
    if (!this.activeMembers.contains(leavingMember)) {
      this.logger.fine("Not removing " + leavingMember + " since it is not an active CP member");
      return true;
    } 
    if (this.membershipChangeSchedule != null) {
      if (leavingMember.equals(this.membershipChangeSchedule.getLeavingMember())) {
        this.membershipChangeSchedule = this.membershipChangeSchedule.addRetriedCommitIndex(commitIndex);
        if (this.logger.isFineEnabled())
          this.logger.fine(leavingMember + " is already marked as leaving."); 
        return false;
      } 
      String msg = "There is already an ongoing CP membership change process. Cannot process remove request of " + leavingMember;
      if (this.logger.isFineEnabled())
        this.logger.fine(msg); 
      throw new CannotRemoveCPMemberException(msg);
    } 
    if (this.activeMembers.size() == 2) {
      this.logger.warning(leavingMember + " is directly removed as there are only " + this.activeMembers.size() + " CP members.");
      removeActiveMember(commitIndex, leavingMember);
      throw new RetryableHazelcastException();
    } 
    if (this.activeMembers.size() == 1) {
      this.logger.fine("Not removing the last active CP member: " + leavingMember + " to help it complete its shutdown");
      return true;
    } 
    return initMembershipChangeScheduleForLeavingMember(commitIndex, leavingMember);
  }
  
  private boolean initMembershipChangeScheduleForLeavingMember(long commitIndex, CPMemberInfo leavingMember) {
    List<CPGroupId> leavingGroupIds = new ArrayList<CPGroupId>();
    List<MembershipChangeSchedule.CPGroupMembershipChange> changes = new ArrayList<MembershipChangeSchedule.CPGroupMembershipChange>();
    for (CPGroupInfo group : this.groups.values()) {
      RaftGroupId raftGroupId = group.id();
      if (!group.containsMember(leavingMember) || group.status() == CPGroup.CPGroupStatus.DESTROYED)
        continue; 
      CPMemberInfo substitute = findSubstitute(group);
      if (substitute != null) {
        leavingGroupIds.add(raftGroupId);
        changes.add(new MembershipChangeSchedule.CPGroupMembershipChange(raftGroupId, group.getMembersCommitIndex(), group
              .memberImpls(), substitute, leavingMember));
        continue;
      } 
      leavingGroupIds.add(raftGroupId);
      changes.add(new MembershipChangeSchedule.CPGroupMembershipChange(raftGroupId, group.getMembersCommitIndex(), group
            .memberImpls(), null, leavingMember));
    } 
    if (changes.isEmpty()) {
      if (this.logger.isFineEnabled())
        this.logger.fine("Removing " + leavingMember + " directly since it is not present in any CP group."); 
      removeActiveMember(commitIndex, leavingMember);
      return true;
    } 
    this.membershipChangeSchedule = MembershipChangeSchedule.forLeavingMember(Collections.singletonList(Long.valueOf(commitIndex)), leavingMember, changes);
    if (this.logger.isFineEnabled()) {
      this.logger.info(leavingMember + " will be removed from " + changes);
    } else {
      this.logger.info(leavingMember + " will be removed from " + leavingGroupIds);
    } 
    return false;
  }
  
  private CPMemberInfo findSubstitute(CPGroupInfo group) {
    for (CPMemberInfo substitute : this.activeMembers) {
      if (this.activeMembers.contains(substitute) && !group.containsMember(substitute))
        return substitute; 
    } 
    return null;
  }
  
  public MembershipChangeSchedule completeRaftGroupMembershipChanges(long commitIndex, Map<CPGroupId, Tuple2<Long, Long>> changedGroups) {
    Preconditions.checkNotNull(changedGroups);
    if (this.membershipChangeSchedule == null) {
      String msg = "Cannot apply CP membership changes: " + changedGroups + " since there is no membership change context!";
      this.logger.warning(msg);
      throw new IllegalStateException(msg);
    } 
    for (MembershipChangeSchedule.CPGroupMembershipChange change : this.membershipChangeSchedule.getChanges()) {
      CPGroupId groupId = change.getGroupId();
      CPGroupInfo group = (CPGroupInfo)this.groups.get(groupId);
      Preconditions.checkState((group != null), groupId + "not found in CP groups: " + this.groups.keySet() + "to apply " + change);
      Tuple2<Long, Long> t = (Tuple2)changedGroups.get(groupId);
      if (t != null) {
        if (!applyMembershipChange(change, group, ((Long)t.element1).longValue(), ((Long)t.element2).longValue()))
          changedGroups.remove(groupId); 
        continue;
      } 
      if (group.status() == CPGroup.CPGroupStatus.DESTROYED && !changedGroups.containsKey(groupId)) {
        if (this.logger.isFineEnabled())
          this.logger.warning(groupId + " is already destroyed so will skip: " + change); 
        changedGroups.put(groupId, Tuple2.of(Long.valueOf(0L), Long.valueOf(0L)));
      } 
    } 
    this.membershipChangeSchedule = this.membershipChangeSchedule.excludeCompletedChanges(changedGroups.keySet());
    if (checkSafeToRemoveIfCPMemberLeaving(this.membershipChangeSchedule)) {
      CPMemberInfo leavingMember = this.membershipChangeSchedule.getLeavingMember();
      removeActiveMember(commitIndex, leavingMember);
      completeFutures(getMetadataGroupId(), this.membershipChangeSchedule.getMembershipChangeCommitIndices(), null);
      this.membershipChangeSchedule = null;
      this.logger.info(leavingMember + " is removed from the CP subsystem.");
    } else if (this.membershipChangeSchedule.getChanges().isEmpty()) {
      completeFutures(getMetadataGroupId(), this.membershipChangeSchedule.getMembershipChangeCommitIndices(), null);
      this.membershipChangeSchedule = null;
      this.logger.info("Rebalancing is completed.");
    } 
    return this.membershipChangeSchedule;
  }
  
  private void completeFutures(CPGroupId groupId, Collection<Long> indices, Object result) {
    if (!indices.isEmpty()) {
      RaftNodeImpl raftNode = (RaftNodeImpl)this.raftService.getRaftNode(groupId);
      if (raftNode != null) {
        for (Long index : indices)
          raftNode.completeFuture(index.longValue(), result); 
      } else {
        this.logger.severe("RaftNode not found for " + groupId + " to notify commit indices " + indices + " with " + result);
      } 
    } 
  }
  
  private boolean applyMembershipChange(MembershipChangeSchedule.CPGroupMembershipChange change, CPGroupInfo group, long expectedMembersCommitIndex, long newMembersCommitIndex) {
    CPMemberInfo addedMember = change.getMemberToAdd();
    CPMemberInfo removedMember = change.getMemberToRemove();
    if (group.applyMembershipChange(removedMember, addedMember, expectedMembersCommitIndex, newMembersCommitIndex)) {
      if (this.logger.isFineEnabled())
        this.logger.fine("Applied add-member: " + ((addedMember != null) ? addedMember : "-") + " and remove-member: " + ((removedMember != null) ? removedMember : "-") + " in " + group
            .id() + " with new members commit index: " + newMembersCommitIndex); 
      if (getLocalCPMember().equals(addedMember))
        this.raftService.createRaftNode(group.id(), group.memberImpls()); 
      return true;
    } 
    this.logger.severe("Could not apply add-member: " + ((addedMember != null) ? addedMember : "-") + " and remove-member: " + ((removedMember != null) ? removedMember : "-") + " in " + group + " with new members commit index: " + newMembersCommitIndex + ", expected members commit index: " + expectedMembersCommitIndex + ", known members commit index: " + group

        
        .getMembersCommitIndex());
    return false;
  }
  
  private boolean checkSafeToRemoveIfCPMemberLeaving(MembershipChangeSchedule schedule) {
    CPMemberInfo leavingMember = schedule.getLeavingMember();
    if (leavingMember == null)
      return false; 
    if (schedule.getChanges().size() > 0)
      return false; 
    for (CPGroupInfo group : this.groups.values()) {
      if (group.containsMember(leavingMember)) {
        if (group.status() != CPGroup.CPGroupStatus.DESTROYED)
          return false; 
        if (this.logger.isFineEnabled())
          this.logger.warning("Leaving " + leavingMember + " was in the destroyed " + group.id()); 
      } 
    } 
    return true;
  }
  
  private List<MembershipChangeSchedule.CPGroupMembershipChange> getGroupMembershipChangesForNewMember(CPMemberInfo newMember) {
    List<MembershipChangeSchedule.CPGroupMembershipChange> changes = new ArrayList<MembershipChangeSchedule.CPGroupMembershipChange>();
    for (CPGroupInfo group : this.groups.values()) {
      if (group.status() == CPGroup.CPGroupStatus.ACTIVE && group.initialMemberCount() > group.memberCount()) {
        Preconditions.checkState(!group.memberImpls().contains(newMember), group + " already contains: " + newMember);
        changes.add(new MembershipChangeSchedule.CPGroupMembershipChange(group.id(), group.getMembersCommitIndex(), group.memberImpls(), newMember, null));
      } 
    } 
    return changes;
  }
  
  public Collection<CPMemberInfo> getActiveMembers() { return this.activeMembers; }
  
  public void handleMetadataGroupId(RaftGroupId newMetadataGroupId) {
    Preconditions.checkNotNull(newMetadataGroupId);
    RaftGroupId metadataGroupId = getMetadataGroupId();
    while (metadataGroupId.seed() < newMetadataGroupId.seed()) {
      if (this.metadataGroupIdRef.compareAndSet(metadataGroupId, newMetadataGroupId)) {
        if (this.logger.isFineEnabled())
          this.logger.fine("Updated METADATA groupId: " + newMetadataGroupId); 
        return;
      } 
      metadataGroupId = getMetadataGroupId();
    } 
  }
  
  private void updateInvocationManagerMembers(long groupIdSeed, long membersCommitIndex, Collection<CPMemberInfo> members) {
    RaftInvocationContext context = this.raftService.getInvocationManager().getRaftInvocationContext();
    context.setMembers(groupIdSeed, membersCommitIndex, members);
  }
  
  public Collection<CPGroupId> getDestroyingGroupIds() {
    Collection<CPGroupId> groupIds = new ArrayList<CPGroupId>();
    for (CPGroupInfo group : this.groups.values()) {
      if (group.status() == CPGroup.CPGroupStatus.DESTROYING)
        groupIds.add(group.id()); 
    } 
    return groupIds;
  }
  
  public MembershipChangeSchedule getMembershipChangeSchedule() { return this.membershipChangeSchedule; }
  
  boolean isMetadataGroupLeader() {
    CPMemberInfo localCPMember = getLocalCPMember();
    if (localCPMember == null)
      return false; 
    RaftNode raftNode = this.raftService.getRaftNode(getMetadataGroupId());
    return (raftNode != null && !raftNode.isTerminatedOrSteppedDown() && localCPMember.equals(raftNode.getLeader()));
  }
  
  public boolean addMember(long commitIndex, CPMemberInfo member) {
    Preconditions.checkNotNull(member);
    checkMetadataGroupInitSuccessful();
    for (CPMemberInfo existingMember : this.activeMembers) {
      if (existingMember.getAddress().equals(member.getAddress())) {
        if (existingMember.getUuid().equals(member.getUuid())) {
          if (this.logger.isFineEnabled())
            this.logger.fine(member + " already exists."); 
          if (this.membershipChangeSchedule != null && member.equals(this.membershipChangeSchedule.getAddedMember())) {
            this.membershipChangeSchedule = this.membershipChangeSchedule.addRetriedCommitIndex(commitIndex);
            this.logger.info("CP groups are already being rebalanced for " + member);
            return false;
          } 
          return true;
        } 
        throw new IllegalStateException(member + " cannot be added to the CP subsystem because another " + existingMember + " exists with the same address!");
      } 
    } 
    Preconditions.checkState((this.membershipChangeSchedule == null), "Cannot rebalance CP groups because there is ongoing " + this.membershipChangeSchedule);
    Collection<CPMemberInfo> newMembers = new LinkedHashSet<CPMemberInfo>(this.activeMembers);
    newMembers.add(member);
    doSetActiveMembers(commitIndex, newMembers);
    this.logger.info("Added new " + member + ". New active CP members list: " + newMembers);
    List<MembershipChangeSchedule.CPGroupMembershipChange> changes = getGroupMembershipChangesForNewMember(member);
    if (changes.size() > 0) {
      this.membershipChangeSchedule = MembershipChangeSchedule.forJoiningMember(Collections.singletonList(Long.valueOf(commitIndex)), member, changes);
      if (this.logger.isFineEnabled())
        this.logger.fine("CP group rebalancing is triggered for " + member + ", changes: " + this.membershipChangeSchedule); 
      return false;
    } 
    return true;
  }
  
  private void removeActiveMember(long commitIndex, CPMemberInfo member) {
    Collection<CPMemberInfo> newMembers = new LinkedHashSet<CPMemberInfo>(this.activeMembers);
    newMembers.remove(member);
    doSetActiveMembers(commitIndex, newMembers);
  }
  
  private void doSetActiveMembers(long commitIndex, Collection<CPMemberInfo> members) {
    this.activeMembers = Collections.unmodifiableCollection(members);
    this.activeMembersCommitIndex = commitIndex;
    updateInvocationManagerMembers(getMetadataGroupId().seed(), commitIndex, this.activeMembers);
    this.raftService.updateMissingMembers();
    broadcastActiveCPMembers();
  }
  
  public void checkMetadataGroupInitSuccessful() {
    switch (null.$SwitchMap$com$hazelcast$cp$internal$MetadataRaftGroupManager$MetadataRaftGroupInitStatus[this.initializationStatus.ordinal()]) {
      case 1:
        return;
      case 2:
        throw new MetadataRaftGroupInitInProgressException();
      case 3:
        throw new IllegalStateException("CP subsystem initialization failed!");
    } 
    throw new IllegalStateException("Illegal initialization status: " + this.initializationStatus);
  }
  
  void broadcastActiveCPMembers() {
    if (!isDiscoveryCompleted() || !isMetadataGroupLeader())
      return; 
    RaftGroupId metadataGroupId = getMetadataGroupId();
    long commitIndex = this.activeMembersCommitIndex;
    Collection<CPMemberInfo> cpMembers = this.activeMembers;
    if (cpMembers.isEmpty())
      return; 
    Set<Member> clusterMembers = this.nodeEngine.getClusterService().getMembers();
    OperationService operationService = this.nodeEngine.getOperationService();
    PublishActiveCPMembersOp publishActiveCPMembersOp = new PublishActiveCPMembersOp(metadataGroupId, commitIndex, cpMembers);
    for (Member member : clusterMembers) {
      if (member.localMember())
        continue; 
      operationService.send(publishActiveCPMembersOp, member.getAddress());
    } 
  }
  
  boolean isDiscoveryCompleted() { return this.discoveryCompleted.get(); }
  
  List<CPMemberInfo> getInitialCPMembers() { return this.initialCPMembers; }
  
  MetadataRaftGroupInitStatus getInitializationStatus() { return this.initializationStatus; }
  
  Set<CPMemberInfo> getInitializedCPMembers() { return this.initializedCPMembers; }
  
  Set<Long> getInitializationCommitIndices() { return this.initializationCommitIndices; }
  
  public void disableDiscovery() {
    if (this.config.getCPMemberCount() > 0)
      this.logger.info("Disabling discovery of initial CP members since it is already completed..."); 
    this.discoveryCompleted.set(true);
  }
  
  private void scheduleDiscoverInitialCPMembersTask(boolean terminateOnDiscoveryFailure) {
    DiscoverInitialCPMembersTask task = new DiscoverInitialCPMembersTask(this, terminateOnDiscoveryFailure);
    this.currentDiscoveryTask = task;
    ExecutionService executionService = this.nodeEngine.getExecutionService();
    executionService.schedule(task, 1000L, TimeUnit.MILLISECONDS);
  }
}
