package com.hazelcast.transaction.impl.xa;

import com.hazelcast.config.GroupConfig;
import com.hazelcast.core.Member;
import com.hazelcast.core.MemberLeftException;
import com.hazelcast.internal.cluster.ClusterService;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.AbstractDistributedObject;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.OperationService;
import com.hazelcast.spi.impl.SerializableList;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.transaction.HazelcastXAResource;
import com.hazelcast.transaction.TransactionContext;
import com.hazelcast.transaction.TransactionOptions;
import com.hazelcast.transaction.impl.Transaction;
import com.hazelcast.transaction.impl.xa.operations.ClearRemoteTransactionOperation;
import com.hazelcast.transaction.impl.xa.operations.CollectRemoteTransactionsOperation;
import com.hazelcast.transaction.impl.xa.operations.FinalizeRemoteTransactionOperation;
import com.hazelcast.util.ExceptionUtil;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import javax.transaction.xa.XAException;
import javax.transaction.xa.XAResource;
import javax.transaction.xa.Xid;

public final class XAResourceImpl extends AbstractDistributedObject<XAService> implements HazelcastXAResource {
  private static final int DEFAULT_TIMEOUT_SECONDS = (int)TimeUnit.MILLISECONDS.toSeconds(TransactionOptions.DEFAULT_TIMEOUT_MILLIS);
  
  private final ConcurrentMap<Long, TransactionContext> threadContextMap = new ConcurrentHashMap();
  
  private final ConcurrentMap<Xid, List<TransactionContext>> xidContextMap = new ConcurrentHashMap();
  
  private final String groupName;
  
  private final AtomicInteger timeoutInSeconds = new AtomicInteger(DEFAULT_TIMEOUT_SECONDS);
  
  private final ILogger logger;
  
  public XAResourceImpl(NodeEngine nodeEngine, XAService service) {
    super(nodeEngine, service);
    GroupConfig groupConfig = nodeEngine.getConfig().getGroupConfig();
    this.groupName = groupConfig.getName();
    this.logger = nodeEngine.getLogger(getClass());
  }
  
  public void start(Xid xid, int flags) throws XAException {
    List<TransactionContext> contextList;
    TransactionContext context;
    List<TransactionContext> currentContexts, contexts;
    long threadId = currentThreadId();
    TransactionContext threadContext = (TransactionContext)this.threadContextMap.get(Long.valueOf(currentThreadId()));
    switch (flags) {
      case 0:
        contexts = new CopyOnWriteArrayList<TransactionContext>();
        currentContexts = (List)this.xidContextMap.putIfAbsent(xid, contexts);
        if (currentContexts != null)
          throw new XAException("There is already TransactionContexts for the given xid: " + xid); 
        context = createTransactionContext(xid);
        contexts.add(context);
        this.threadContextMap.put(Long.valueOf(threadId), context);
        return;
      case 2097152:
      case 134217728:
        contextList = (List)this.xidContextMap.get(xid);
        if (contextList == null)
          throw new XAException("There is no TransactionContexts for the given xid: " + xid); 
        if (threadContext == null) {
          threadContext = createTransactionContext(xid);
          this.threadContextMap.put(Long.valueOf(threadId), threadContext);
          contextList.add(threadContext);
        } 
        return;
    } 
    throw new XAException("Unknown flag! " + flags);
  }
  
  private TransactionContext createTransactionContext(Xid xid) {
    XAService xaService = (XAService)getService();
    TransactionContext context = xaService.newXATransactionContext(xid, null, this.timeoutInSeconds.get(), false);
    getTransaction(context).begin();
    return context;
  }
  
  public void end(Xid xid, int flags) throws XAException {
    long threadId = currentThreadId();
    TransactionContext threadContext = (TransactionContext)this.threadContextMap.remove(Long.valueOf(threadId));
    if (threadContext == null && this.logger.isFinestEnabled())
      this.logger.finest("There is no TransactionContext for the current thread: " + threadId); 
    List<TransactionContext> contexts = (List)this.xidContextMap.get(xid);
    if (contexts == null && this.logger.isFinestEnabled())
      this.logger.finest("There is no TransactionContexts for the given xid: " + xid); 
  }
  
  public int prepare(Xid xid) throws XAException {
    List<TransactionContext> contexts = (List)this.xidContextMap.get(xid);
    if (contexts == null)
      throw new XAException("There is no TransactionContexts for the given xid: " + xid); 
    for (TransactionContext context : contexts) {
      Transaction transaction = getTransaction(context);
      transaction.prepare();
    } 
    return 0;
  }
  
  public void commit(Xid xid, boolean onePhase) throws XAException {
    List<TransactionContext> contexts = (List)this.xidContextMap.remove(xid);
    if (contexts == null && onePhase)
      throw new XAException("There is no TransactionContexts for the given xid: " + xid); 
    if (contexts == null) {
      finalizeTransactionRemotely(xid, true);
      return;
    } 
    for (TransactionContext context : contexts) {
      Transaction transaction = getTransaction(context);
      if (onePhase)
        transaction.prepare(); 
      transaction.commit();
    } 
    clearRemoteTransactions(xid);
  }
  
  public void rollback(Xid xid) throws XAException {
    List<TransactionContext> contexts = (List)this.xidContextMap.remove(xid);
    if (contexts == null) {
      finalizeTransactionRemotely(xid, false);
      return;
    } 
    for (TransactionContext context : contexts)
      getTransaction(context).rollback(); 
    clearRemoteTransactions(xid);
  }
  
  private void finalizeTransactionRemotely(Xid xid, boolean isCommit) throws XAException {
    Integer errorCode;
    NodeEngine nodeEngine = getNodeEngine();
    IPartitionService partitionService = nodeEngine.getPartitionService();
    OperationService operationService = nodeEngine.getOperationService();
    SerializableXID serializableXID = new SerializableXID(xid.getFormatId(), xid.getGlobalTransactionId(), xid.getBranchQualifier());
    Data xidData = nodeEngine.toData(serializableXID);
    int partitionId = partitionService.getPartitionId(xidData);
    FinalizeRemoteTransactionOperation operation = new FinalizeRemoteTransactionOperation(xidData, isCommit);
    InternalCompletableFuture<Integer> future = operationService.invokeOnPartition("hz:impl:xaService", operation, partitionId);
    try {
      errorCode = (Integer)future.get();
    } catch (Exception e) {
      throw ExceptionUtil.rethrow(e);
    } 
    if (errorCode != null)
      throw new XAException(errorCode.intValue()); 
  }
  
  private void clearRemoteTransactions(Xid xid) throws XAException {
    NodeEngine nodeEngine = getNodeEngine();
    IPartitionService partitionService = nodeEngine.getPartitionService();
    OperationService operationService = nodeEngine.getOperationService();
    SerializableXID serializableXID = new SerializableXID(xid.getFormatId(), xid.getGlobalTransactionId(), xid.getBranchQualifier());
    Data xidData = nodeEngine.toData(serializableXID);
    int partitionId = partitionService.getPartitionId(xidData);
    ClearRemoteTransactionOperation operation = new ClearRemoteTransactionOperation(xidData);
    operationService.invokeOnPartition("hz:impl:xaService", operation, partitionId);
  }
  
  public void forget(Xid xid) throws XAException {
    List<TransactionContext> contexts = (List)this.xidContextMap.remove(xid);
    if (contexts == null)
      throw new XAException("No context with the given xid: " + xid); 
    clearRemoteTransactions(xid);
  }
  
  public boolean isSameRM(XAResource xaResource) throws XAException {
    if (this == xaResource)
      return true; 
    if (xaResource instanceof XAResourceImpl) {
      XAResourceImpl otherXaResource = (XAResourceImpl)xaResource;
      return this.groupName.equals(otherXaResource.groupName);
    } 
    return xaResource.isSameRM(this);
  }
  
  public Xid[] recover(int flag) throws XAException {
    NodeEngine nodeEngine = getNodeEngine();
    XAService xaService = (XAService)getService();
    OperationService operationService = nodeEngine.getOperationService();
    ClusterService clusterService = nodeEngine.getClusterService();
    Collection<Member> memberList = clusterService.getMembers();
    List<Future<SerializableList>> futureList = new ArrayList<Future<SerializableList>>();
    for (Member member : memberList) {
      if (member.localMember())
        continue; 
      CollectRemoteTransactionsOperation op = new CollectRemoteTransactionsOperation();
      Address address = member.getAddress();
      InternalCompletableFuture<SerializableList> future = operationService.invokeOnTarget("hz:impl:xaService", op, address);
      futureList.add(future);
    } 
    Set<SerializableXID> xids = new HashSet<SerializableXID>(xaService.getPreparedXids());
    for (Future<SerializableList> future : futureList) {
      try {
        SerializableList xidSet = (SerializableList)future.get();
        for (Data xidData : xidSet) {
          SerializableXID xid = (SerializableXID)nodeEngine.toObject(xidData);
          xids.add(xid);
        } 
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new XAException(-3);
      } catch (MemberLeftException e) {
        this.logger.warning("Member left while recovering", e);
      } catch (ExecutionException e) {
        Throwable cause = e.getCause();
        if (cause instanceof com.hazelcast.core.HazelcastInstanceNotActiveException || cause instanceof com.hazelcast.spi.exception.TargetNotMemberException) {
          this.logger.warning("Member left while recovering", e);
          continue;
        } 
        throw new XAException(-3);
      } 
    } 
    return (Xid[])xids.toArray(new SerializableXID[0]);
  }
  
  public int getTransactionTimeout() throws XAException { return this.timeoutInSeconds.get(); }
  
  public boolean setTransactionTimeout(int seconds) throws XAException {
    this.timeoutInSeconds.set((seconds == 0) ? DEFAULT_TIMEOUT_SECONDS : seconds);
    return true;
  }
  
  public String getServiceName() { return "hz:impl:xaService"; }
  
  public String getName() { return "hz:impl:xaService"; }
  
  public TransactionContext getTransactionContext() {
    long threadId = Thread.currentThread().getId();
    TransactionContext transactionContext = (TransactionContext)this.threadContextMap.get(Long.valueOf(threadId));
    if (transactionContext == null)
      throw new IllegalStateException("No TransactionContext associated with current thread: " + threadId); 
    return transactionContext;
  }
  
  public String getGroupName() { return this.groupName; }
  
  private Transaction getTransaction(TransactionContext context) { return ((XATransactionContextImpl)context).getTransaction(); }
  
  private long currentThreadId() { return Thread.currentThread().getId(); }
  
  public String toString() { return "HazelcastXaResource {" + this.groupName + '}'; }
}
