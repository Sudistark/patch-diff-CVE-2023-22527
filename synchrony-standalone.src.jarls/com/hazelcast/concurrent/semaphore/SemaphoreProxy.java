package com.hazelcast.concurrent.semaphore;

import com.hazelcast.concurrent.semaphore.operations.AcquireOperation;
import com.hazelcast.concurrent.semaphore.operations.AvailableOperation;
import com.hazelcast.concurrent.semaphore.operations.DrainOperation;
import com.hazelcast.concurrent.semaphore.operations.IncreaseOperation;
import com.hazelcast.concurrent.semaphore.operations.InitOperation;
import com.hazelcast.concurrent.semaphore.operations.ReduceOperation;
import com.hazelcast.concurrent.semaphore.operations.ReleaseOperation;
import com.hazelcast.core.ISemaphore;
import com.hazelcast.internal.cluster.Versions;
import com.hazelcast.spi.AbstractDistributedObject;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.Preconditions;
import java.util.concurrent.TimeUnit;

public class SemaphoreProxy extends AbstractDistributedObject<SemaphoreService> implements ISemaphore {
  private final String name;
  
  private final int partitionId;
  
  public SemaphoreProxy(String name, SemaphoreService service, NodeEngine nodeEngine) {
    super(nodeEngine, service);
    this.name = name;
    this.partitionId = nodeEngine.getPartitionService().getPartitionId(getNameAsPartitionAwareData());
  }
  
  public String getName() { return this.name; }
  
  public boolean init(int permits) {
    Preconditions.checkNotNegative(permits, "permits can't be negative");
    Operation operation = (new InitOperation(this.name, permits)).setPartitionId(this.partitionId);
    InternalCompletableFuture<Boolean> future = invokeOnPartition(operation);
    return ((Boolean)future.join()).booleanValue();
  }
  
  public void acquire() throws InterruptedException { acquire(1); }
  
  public void acquire(int permits) throws InterruptedException {
    Preconditions.checkNotNegative(permits, "permits can't be negative");
    try {
      Operation operation = (new AcquireOperation(this.name, permits, -1L)).setPartitionId(this.partitionId);
      InternalCompletableFuture<Object> future = invokeOnPartition(operation);
      future.get();
    } catch (Throwable t) {
      throw ExceptionUtil.rethrowAllowInterrupted(t);
    } 
  }
  
  public int availablePermits() {
    Operation operation = (new AvailableOperation(this.name)).setPartitionId(this.partitionId);
    InternalCompletableFuture<Integer> future = invokeOnPartition(operation);
    return ((Integer)future.join()).intValue();
  }
  
  public int drainPermits() {
    Operation operation = (new DrainOperation(this.name)).setPartitionId(this.partitionId);
    InternalCompletableFuture<Integer> future = invokeOnPartition(operation);
    return ((Integer)future.join()).intValue();
  }
  
  public void reducePermits(int reduction) throws InterruptedException {
    Preconditions.checkNotNegative(reduction, "reduction can't be negative");
    Operation operation = (new ReduceOperation(this.name, reduction)).setPartitionId(this.partitionId);
    InternalCompletableFuture<Object> future = invokeOnPartition(operation);
    future.join();
  }
  
  public void increasePermits(int increase) throws InterruptedException {
    if (getNodeEngine().getClusterService().getClusterVersion().isLessThan(Versions.V3_10))
      throw new UnsupportedOperationException("Increasing permits is available when cluster version is 3.10 or higher"); 
    Preconditions.checkNotNegative(increase, "increase can't be negative");
    Operation operation = (new IncreaseOperation(this.name, increase)).setPartitionId(this.partitionId);
    InternalCompletableFuture<Object> future = invokeOnPartition(operation);
    future.join();
  }
  
  public void release() throws InterruptedException { release(1); }
  
  public void release(int permits) throws InterruptedException {
    Preconditions.checkNotNegative(permits, "permits can't be negative");
    Operation operation = (new ReleaseOperation(this.name, permits)).setPartitionId(this.partitionId);
    InternalCompletableFuture future = invokeOnPartition(operation);
    future.join();
  }
  
  public boolean tryAcquire() {
    try {
      return tryAcquire(1, 0L, TimeUnit.MILLISECONDS);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      return false;
    } 
  }
  
  public boolean tryAcquire(int permits) {
    try {
      return tryAcquire(permits, 0L, TimeUnit.MILLISECONDS);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      return false;
    } 
  }
  
  public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException { return tryAcquire(1, timeout, unit); }
  
  public boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException {
    Preconditions.checkNotNegative(permits, "permits can't be negative");
    try {
      Operation operation = (new AcquireOperation(this.name, permits, unit.toMillis(timeout))).setPartitionId(this.partitionId);
      InternalCompletableFuture internalCompletableFuture = invokeOnPartition(operation);
      return ((Boolean)internalCompletableFuture.get()).booleanValue();
    } catch (Throwable t) {
      throw ExceptionUtil.rethrowAllowInterrupted(t);
    } 
  }
  
  public String getServiceName() { return "hz:impl:semaphoreService"; }
  
  public String toString() { return "ISemaphore{name='" + this.name + '\'' + '}'; }
}
