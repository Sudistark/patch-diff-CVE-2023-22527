package com.hazelcast.concurrent.lock.operations;

import com.hazelcast.concurrent.lock.LockStoreImpl;
import com.hazelcast.concurrent.lock.LockWaitNotifyKey;
import com.hazelcast.core.OperationTimeoutException;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.BackupAwareOperation;
import com.hazelcast.spi.BlockingOperation;
import com.hazelcast.spi.ObjectNamespace;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.WaitNotifyKey;
import com.hazelcast.spi.impl.MutatingOperation;

public class LockOperation extends AbstractLockOperation implements BlockingOperation, BackupAwareOperation, MutatingOperation {
  public LockOperation() {}
  
  public LockOperation(ObjectNamespace namespace, Data key, long threadId, long leaseTime, long timeout) { super(namespace, key, threadId, leaseTime, timeout); }
  
  public LockOperation(ObjectNamespace namespace, Data key, long threadId, long leaseTime, long timeout, long referenceId) {
    super(namespace, key, threadId, leaseTime, timeout);
    setReferenceCallId(referenceId);
  }
  
  public void run() {
    interceptLockOperation();
    boolean lockResult = getLockStore().lock(this.key, getCallerUuid(), this.threadId, getReferenceCallId(), this.leaseTime);
    this.response = Boolean.valueOf(lockResult);
    ILogger logger = getLogger();
    if (logger.isFinestEnabled())
      if (lockResult) {
        logger.finest("Acquired lock " + this.namespace.getObjectName() + " for " + 
            getCallerAddress() + " - " + getCallerUuid() + ", thread ID: " + this.threadId);
      } else {
        logger.finest("Could not acquire lock " + this.namespace.getObjectName() + " as owned by " + 
            getLockStore().getOwnerInfo(this.key));
      }  
  }
  
  public Operation getBackupOperation() {
    LockBackupOperation operation = new LockBackupOperation(this.namespace, this.key, this.threadId, this.leaseTime, getCallerUuid());
    operation.setReferenceCallId(getReferenceCallId());
    return operation;
  }
  
  public boolean shouldBackup() { return Boolean.TRUE.equals(this.response); }
  
  public final WaitNotifyKey getWaitKey() { return new LockWaitNotifyKey(this.namespace, this.key); }
  
  public final boolean shouldWait() {
    LockStoreImpl lockStore = getLockStore();
    return (getWaitTimeout() != 0L && !lockStore.canAcquireLock(this.key, getCallerUuid(), this.threadId));
  }
  
  public final void onWaitExpire() {
    Object response;
    long timeout = getWaitTimeout();
    if (timeout < 0L || timeout == Float.MAX_VALUE) {
      response = new OperationTimeoutException();
    } else {
      response = Boolean.FALSE;
    } 
    sendResponse(response);
  }
  
  public int getId() { return 11; }
}
