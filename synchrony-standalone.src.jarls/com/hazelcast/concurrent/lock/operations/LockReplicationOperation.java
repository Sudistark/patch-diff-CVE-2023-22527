package com.hazelcast.concurrent.lock.operations;

import com.hazelcast.concurrent.lock.LockDataSerializerHook;
import com.hazelcast.concurrent.lock.LockServiceImpl;
import com.hazelcast.concurrent.lock.LockStoreContainer;
import com.hazelcast.concurrent.lock.LockStoreImpl;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.IdentifiedDataSerializable;
import com.hazelcast.nio.serialization.impl.Versioned;
import com.hazelcast.spi.ObjectNamespace;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.ServiceNamespace;
import java.io.IOException;
import java.util.Collection;
import java.util.LinkedList;

public class LockReplicationOperation extends Operation implements IdentifiedDataSerializable, Versioned {
  private final Collection<LockStoreImpl> locks = new LinkedList();
  
  public LockReplicationOperation() {}
  
  public LockReplicationOperation(LockStoreContainer container, int partitionId, int replicaIndex) { this(container, partitionId, replicaIndex, container.getAllNamespaces(replicaIndex)); }
  
  public LockReplicationOperation(LockStoreContainer container, int partitionId, int replicaIndex, Collection<ServiceNamespace> namespaces) {
    setPartitionId(partitionId).setReplicaIndex(replicaIndex);
    for (ServiceNamespace namespace : namespaces) {
      LockStoreImpl ls = container.getLockStore((ObjectNamespace)namespace);
      if (ls == null)
        continue; 
      if (ls.getTotalBackupCount() < replicaIndex)
        continue; 
      this.locks.add(ls);
    } 
  }
  
  public void run() {
    LockServiceImpl lockService = (LockServiceImpl)getService();
    LockStoreContainer container = lockService.getLockContainer(getPartitionId());
    for (LockStoreImpl ls : this.locks)
      container.put(ls); 
  }
  
  public String getServiceName() { return "hz:impl:lockService"; }
  
  public boolean isEmpty() { return this.locks.isEmpty(); }
  
  public int getFactoryId() { return LockDataSerializerHook.F_ID; }
  
  public int getId() { return 12; }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException {
    super.writeInternal(out);
    int len = this.locks.size();
    out.writeInt(len);
    if (len > 0)
      for (LockStoreImpl ls : this.locks)
        ls.writeData(out);  
  }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    super.readInternal(in);
    int len = in.readInt();
    if (len > 0)
      for (int i = 0; i < len; i++) {
        LockStoreImpl ls = new LockStoreImpl();
        ls.readData(in);
        this.locks.add(ls);
      }  
  }
}
