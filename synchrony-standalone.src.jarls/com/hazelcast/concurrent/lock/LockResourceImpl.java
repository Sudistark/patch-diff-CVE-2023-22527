package com.hazelcast.concurrent.lock;

import com.hazelcast.concurrent.lock.operations.AwaitOperation;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.nio.serialization.IdentifiedDataSerializable;
import com.hazelcast.util.Clock;
import com.hazelcast.util.MapUtil;
import com.hazelcast.util.SetUtil;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

final class LockResourceImpl implements IdentifiedDataSerializable, LockResource {
  private Data key;
  
  private String owner;
  
  private long threadId;
  
  private long referenceId;
  
  private int lockCount;
  
  private long expirationTime = -1L;
  
  private long acquireTime = -1L;
  
  private boolean transactional;
  
  private boolean blockReads;
  
  private boolean local;
  
  private Map<String, WaitersInfo> waiters;
  
  private Set<ConditionKey> conditionKeys;
  
  private List<AwaitOperation> expiredAwaitOps;
  
  private LockStoreImpl lockStore;
  
  private int version;
  
  public LockResourceImpl() {}
  
  public LockResourceImpl(Data key, LockStoreImpl lockStore) {
    this.key = key;
    this.lockStore = lockStore;
  }
  
  public Data getKey() { return this.key; }
  
  public boolean isLocked() { return (this.lockCount > 0); }
  
  public boolean isLockedBy(String owner, long threadId) { return (this.threadId == threadId && owner != null && owner.equals(this.owner)); }
  
  boolean lock(String owner, long threadId, long referenceId, long leaseTime, boolean transactional, boolean blockReads, boolean local) {
    if (this.lockCount == 0) {
      this.owner = owner;
      this.threadId = threadId;
      this.referenceId = referenceId;
      this.lockCount = 1;
      this.acquireTime = Clock.currentTimeMillis();
      setExpirationTime(leaseTime);
      this.transactional = transactional;
      this.blockReads = blockReads;
      this.local = local;
      return true;
    } 
    if (isLockedBy(owner, threadId)) {
      if (!transactional && !local && this.referenceId == referenceId)
        return true; 
      this.referenceId = referenceId;
      this.lockCount++;
      setExpirationTime(leaseTime);
      this.transactional = transactional;
      this.blockReads = blockReads;
      this.local = local;
      return true;
    } 
    return false;
  }
  
  boolean extendLeaseTime(String caller, long threadId, long leaseTime) {
    if (!isLockedBy(caller, threadId))
      return false; 
    this.blockReads = true;
    if (this.expirationTime < Float.MAX_VALUE)
      setExpirationTime(this.expirationTime - Clock.currentTimeMillis() + leaseTime); 
    return true;
  }
  
  private void setExpirationTime(long leaseTime) {
    this.version++;
    if (leaseTime < 0L) {
      this.expirationTime = Float.MAX_VALUE;
      this.lockStore.cancelEviction(this.key);
    } else {
      this.expirationTime = Clock.currentTimeMillis() + leaseTime;
      if (this.expirationTime < 0L) {
        this.expirationTime = Float.MAX_VALUE;
        this.lockStore.cancelEviction(this.key);
      } else {
        this.lockStore.scheduleEviction(this.key, this.version, leaseTime);
      } 
    } 
  }
  
  boolean unlock(String owner, long threadId, long referenceId) {
    if (this.lockCount == 0)
      return false; 
    if (!isLockedBy(owner, threadId))
      return false; 
    if (!this.transactional && !this.local && this.referenceId == referenceId)
      return true; 
    this.referenceId = referenceId;
    this.lockCount--;
    if (this.lockCount == 0)
      clear(); 
    return true;
  }
  
  boolean canAcquireLock(String caller, long threadId) { return (this.lockCount == 0 || (getThreadId() == threadId && getOwner().equals(caller))); }
  
  void addAwait(String conditionId, String caller, long threadId) {
    if (this.waiters == null)
      this.waiters = MapUtil.createHashMap(2); 
    WaitersInfo condition = (WaitersInfo)this.waiters.get(conditionId);
    if (condition == null) {
      condition = new WaitersInfo(conditionId);
      this.waiters.put(conditionId, condition);
    } 
    condition.addWaiter(caller, threadId);
  }
  
  void removeAwait(String conditionId, String caller, long threadId) {
    if (this.waiters == null)
      return; 
    WaitersInfo condition = (WaitersInfo)this.waiters.get(conditionId);
    if (condition == null)
      return; 
    condition.removeWaiter(caller, threadId);
    if (!condition.hasWaiter())
      this.waiters.remove(conditionId); 
  }
  
  public void signal(String conditionId, int maxSignalCount, String objectName) {
    if (this.waiters == null)
      return; 
    WaitersInfo condition = (WaitersInfo)this.waiters.get(conditionId);
    if (condition == null)
      return; 
    Set<WaitersInfo.ConditionWaiter> waiters = condition.getWaiters();
    if (waiters == null)
      return; 
    Iterator<WaitersInfo.ConditionWaiter> iterator = waiters.iterator();
    for (int i = 0; iterator.hasNext() && i < maxSignalCount; i++) {
      WaitersInfo.ConditionWaiter waiter = (WaitersInfo.ConditionWaiter)iterator.next();
      ConditionKey signalKey = new ConditionKey(objectName, this.key, conditionId, waiter.getCaller(), waiter.getThreadId());
      registerSignalKey(signalKey);
      iterator.remove();
    } 
    if (!condition.hasWaiter())
      this.waiters.remove(conditionId); 
  }
  
  private void registerSignalKey(ConditionKey conditionKey) {
    if (this.conditionKeys == null)
      this.conditionKeys = new HashSet(); 
    this.conditionKeys.add(conditionKey);
  }
  
  ConditionKey getSignalKey() {
    Set<ConditionKey> keys = this.conditionKeys;
    if (isNullOrEmpty(keys))
      return null; 
    return (ConditionKey)keys.iterator().next();
  }
  
  void removeSignalKey(ConditionKey conditionKey) {
    if (this.conditionKeys != null)
      this.conditionKeys.remove(conditionKey); 
  }
  
  boolean hasSignalKey(ConditionKey conditionKey) {
    if (this.conditionKeys == null)
      return false; 
    return this.conditionKeys.contains(conditionKey);
  }
  
  void registerExpiredAwaitOp(AwaitOperation awaitResponse) {
    if (this.expiredAwaitOps == null)
      this.expiredAwaitOps = new LinkedList(); 
    this.expiredAwaitOps.add(awaitResponse);
  }
  
  AwaitOperation pollExpiredAwaitOp() {
    List<AwaitOperation> ops = this.expiredAwaitOps;
    if (isNullOrEmpty(ops))
      return null; 
    Iterator<AwaitOperation> iterator = ops.iterator();
    AwaitOperation awaitResponse = (AwaitOperation)iterator.next();
    iterator.remove();
    return awaitResponse;
  }
  
  void clear() {
    this.threadId = 0L;
    this.lockCount = 0;
    this.owner = null;
    this.referenceId = 0L;
    this.expirationTime = 0L;
    this.acquireTime = -1L;
    cancelEviction();
    this.version = 0;
    this.transactional = false;
    this.blockReads = false;
    this.local = false;
  }
  
  void cancelEviction() { this.lockStore.cancelEviction(this.key); }
  
  boolean isRemovable() {
    return (!isLocked() && 
      isNullOrEmpty(this.waiters) && 
      isNullOrEmpty(this.expiredAwaitOps) && 
      isNullOrEmpty(this.conditionKeys));
  }
  
  public String getOwner() { return this.owner; }
  
  public boolean isTransactional() { return this.transactional; }
  
  public boolean isLocal() { return this.local; }
  
  public boolean shouldBlockReads() { return this.blockReads; }
  
  public long getThreadId() { return this.threadId; }
  
  public int getLockCount() { return this.lockCount; }
  
  public long getAcquireTime() { return this.acquireTime; }
  
  public long getRemainingLeaseTime() {
    if (!isLocked())
      return -1L; 
    if (this.expirationTime < 0L)
      return Float.MAX_VALUE; 
    long now = Clock.currentTimeMillis();
    if (now >= this.expirationTime)
      return 0L; 
    return this.expirationTime - now;
  }
  
  public long getExpirationTime() { return this.expirationTime; }
  
  public int getVersion() { return this.version; }
  
  void setLockStore(LockStoreImpl lockStore) { this.lockStore = lockStore; }
  
  public int getFactoryId() { return LockDataSerializerHook.F_ID; }
  
  public int getId() { return 0; }
  
  public void writeData(ObjectDataOutput out) throws IOException {
    out.writeData(this.key);
    out.writeUTF(this.owner);
    out.writeLong(this.threadId);
    out.writeLong(this.referenceId);
    out.writeInt(this.lockCount);
    out.writeLong(this.expirationTime);
    out.writeLong(this.acquireTime);
    out.writeBoolean(this.transactional);
    out.writeBoolean(this.blockReads);
    int conditionCount = getConditionCount();
    out.writeInt(conditionCount);
    if (conditionCount > 0)
      for (WaitersInfo condition : this.waiters.values())
        condition.writeData(out);  
    int signalCount = getSignalCount();
    out.writeInt(signalCount);
    if (signalCount > 0)
      for (ConditionKey signalKey : this.conditionKeys) {
        out.writeUTF(signalKey.getObjectName());
        out.writeUTF(signalKey.getConditionId());
        out.writeUTF(signalKey.getUuid());
        out.writeLong(signalKey.getThreadId());
      }  
    int expiredAwaitOpsCount = getExpiredAwaitsOpsCount();
    out.writeInt(expiredAwaitOpsCount);
    if (expiredAwaitOpsCount > 0)
      for (AwaitOperation op : this.expiredAwaitOps)
        op.writeData(out);  
  }
  
  private int getExpiredAwaitsOpsCount() { return (this.expiredAwaitOps == null) ? 0 : this.expiredAwaitOps.size(); }
  
  private int getSignalCount() { return (this.conditionKeys == null) ? 0 : this.conditionKeys.size(); }
  
  private int getConditionCount() { return (this.waiters == null) ? 0 : this.waiters.size(); }
  
  public void readData(ObjectDataInput in) throws IOException {
    this.key = in.readData();
    this.owner = in.readUTF();
    this.threadId = in.readLong();
    this.referenceId = in.readLong();
    this.lockCount = in.readInt();
    this.expirationTime = in.readLong();
    this.acquireTime = in.readLong();
    this.transactional = in.readBoolean();
    this.blockReads = in.readBoolean();
    int len = in.readInt();
    if (len > 0) {
      this.waiters = MapUtil.createHashMap(len);
      for (int i = 0; i < len; i++) {
        WaitersInfo condition = new WaitersInfo();
        condition.readData(in);
        this.waiters.put(condition.getConditionId(), condition);
      } 
    } 
    len = in.readInt();
    if (len > 0) {
      this.conditionKeys = SetUtil.createHashSet(len);
      for (int i = 0; i < len; i++)
        this.conditionKeys.add(new ConditionKey(in.readUTF(), this.key, in.readUTF(), in.readUTF(), in.readLong())); 
    } 
    len = in.readInt();
    if (len > 0) {
      this.expiredAwaitOps = new ArrayList(len);
      for (int i = 0; i < len; i++) {
        AwaitOperation op = new AwaitOperation();
        op.readData(in);
        this.expiredAwaitOps.add(op);
      } 
    } 
  }
  
  public boolean equals(Object o) {
    if (this == o)
      return true; 
    if (o == null || getClass() != o.getClass())
      return false; 
    LockResourceImpl that = (LockResourceImpl)o;
    if (this.threadId != that.threadId)
      return false; 
    if ((this.owner != null) ? !this.owner.equals(that.owner) : (that.owner != null))
      return false; 
    return true;
  }
  
  public int hashCode() {
    result = (this.owner != null) ? this.owner.hashCode() : 0;
    return 31 * result + (int)(this.threadId ^ this.threadId >>> 32);
  }
  
  public String toString() { return "LockResource{owner='" + this.owner + '\'' + ", threadId=" + this.threadId + ", lockCount=" + this.lockCount + ", acquireTime=" + this.acquireTime + ", expirationTime=" + this.expirationTime + '}'; }
  
  private static boolean isNullOrEmpty(Collection c) { return (c == null || c.isEmpty()); }
  
  private static boolean isNullOrEmpty(Map m) { return (m == null || m.isEmpty()); }
  
  void cleanWaitersAndSignalsFor(String uuid) {
    if (this.conditionKeys != null) {
      Iterator<ConditionKey> iter = this.conditionKeys.iterator();
      while (iter.hasNext()) {
        ConditionKey conditionKey = (ConditionKey)iter.next();
        if (conditionKey.getUuid().equals(uuid))
          iter.remove(); 
      } 
    } 
    if (this.waiters != null)
      for (WaitersInfo waitersInfo : this.waiters.values()) {
        Iterator<WaitersInfo.ConditionWaiter> iter = waitersInfo.getWaiters().iterator();
        while (iter.hasNext()) {
          WaitersInfo.ConditionWaiter waiter = (WaitersInfo.ConditionWaiter)iter.next();
          if (waiter.getCaller().equals(uuid))
            iter.remove(); 
        } 
      }  
  }
}
