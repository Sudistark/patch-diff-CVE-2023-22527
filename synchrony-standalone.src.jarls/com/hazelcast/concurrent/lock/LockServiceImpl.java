package com.hazelcast.concurrent.lock;

import com.hazelcast.concurrent.lock.operations.LocalLockCleanupOperation;
import com.hazelcast.concurrent.lock.operations.LockReplicationOperation;
import com.hazelcast.concurrent.lock.operations.UnlockOperation;
import com.hazelcast.core.DistributedObject;
import com.hazelcast.instance.MemberImpl;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.partition.strategy.StringPartitioningStrategy;
import com.hazelcast.spi.ClientAwareService;
import com.hazelcast.spi.FragmentedMigrationAwareService;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.MemberAttributeServiceEvent;
import com.hazelcast.spi.MembershipAwareService;
import com.hazelcast.spi.MembershipServiceEvent;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.ObjectNamespace;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.OperationService;
import com.hazelcast.spi.PartitionMigrationEvent;
import com.hazelcast.spi.PartitionReplicationEvent;
import com.hazelcast.spi.QuorumAwareService;
import com.hazelcast.spi.RemoteService;
import com.hazelcast.spi.ServiceNamespace;
import com.hazelcast.spi.impl.operationservice.InternalOperationService;
import com.hazelcast.spi.partition.MigrationEndpoint;
import com.hazelcast.spi.properties.GroupProperty;
import com.hazelcast.spi.properties.HazelcastProperties;
import com.hazelcast.util.Clock;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.ContextMutexFactory;
import java.util.Collection;
import java.util.LinkedList;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public final class LockServiceImpl implements LockService, ManagedService, RemoteService, MembershipAwareService, FragmentedMigrationAwareService, ClientAwareService, QuorumAwareService {
  private static final Object NULL_OBJECT = new Object();
  
  private final NodeEngine nodeEngine;
  
  private final LockStoreContainer[] containers;
  
  private final ConcurrentMap<String, ConstructorFunction<ObjectNamespace, LockStoreInfo>> constructors;
  
  private final ConcurrentMap<String, Object> quorumConfigCache;
  
  private final ContextMutexFactory quorumConfigCacheMutexFactory;
  
  private final ConstructorFunction<String, Object> quorumConfigConstructor;
  
  private final long maxLeaseTimeInMillis;
  
  public LockServiceImpl(NodeEngine nodeEngine) {
    this.constructors = new ConcurrentHashMap();
    this.quorumConfigCache = new ConcurrentHashMap();
    this.quorumConfigCacheMutexFactory = new ContextMutexFactory();
    this.quorumConfigConstructor = new Object(this);
    this.nodeEngine = nodeEngine;
    this.containers = new LockStoreContainer[nodeEngine.getPartitionService().getPartitionCount()];
    for (int i = 0; i < this.containers.length; i++)
      this.containers[i] = new LockStoreContainer(this, i); 
    this.maxLeaseTimeInMillis = getMaxLeaseTimeInMillis(nodeEngine.getProperties());
  }
  
  NodeEngine getNodeEngine() { return this.nodeEngine; }
  
  public void init(NodeEngine nodeEngine, Properties properties) { registerLockStoreConstructor("hz:impl:lockService", new Object(this)); }
  
  public void reset() {
    for (LockStoreContainer container : this.containers) {
      for (LockStoreImpl lockStore : container.getLockStores())
        lockStore.clear(); 
    } 
  }
  
  public void shutdown(boolean terminate) {
    for (LockStoreContainer container : this.containers)
      container.clear(); 
  }
  
  public long getMaxLeaseTimeInMillis() { return this.maxLeaseTimeInMillis; }
  
  public void registerLockStoreConstructor(String serviceName, ConstructorFunction<ObjectNamespace, LockStoreInfo> constructorFunction) {
    boolean put = (this.constructors.putIfAbsent(serviceName, constructorFunction) == null);
    if (!put)
      throw new IllegalArgumentException("LockStore constructor for service[" + serviceName + "] is already registered!"); 
  }
  
  ConstructorFunction<ObjectNamespace, LockStoreInfo> getConstructor(String serviceName) { return (ConstructorFunction)this.constructors.get(serviceName); }
  
  public LockStore createLockStore(int partitionId, ObjectNamespace namespace) {
    LockStoreContainer container = getLockContainer(partitionId);
    container.getOrCreateLockStore(namespace);
    return new LockStoreProxy(container, namespace);
  }
  
  public void clearLockStore(int partitionId, ObjectNamespace namespace) {
    LockStoreContainer container = getLockContainer(partitionId);
    container.clearLockStore(namespace);
  }
  
  public LockStoreContainer getLockContainer(int partitionId) { return this.containers[partitionId]; }
  
  public LockStoreImpl getLockStore(int partitionId, ObjectNamespace namespace) { return getLockContainer(partitionId).getOrCreateLockStore(namespace); }
  
  public void memberAdded(MembershipServiceEvent event) {}
  
  public void memberRemoved(MembershipServiceEvent event) {
    MemberImpl member = event.getMember();
    String uuid = member.getUuid();
    releaseLocksOwnedBy(uuid);
  }
  
  public void memberAttributeChanged(MemberAttributeServiceEvent event) {}
  
  private void releaseLocksOwnedBy(String uuid) {
    InternalOperationService operationService = (InternalOperationService)this.nodeEngine.getOperationService();
    for (LockStoreContainer container : this.containers)
      operationService.execute(new Object(this, container, operationService, uuid)); 
  }
  
  private void cleanUpLock(OperationService operationService, String uuid, int partitionId, LockStoreImpl lockStore) {
    Collection<LockResource> locks = lockStore.getLocks();
    for (LockResource lock : locks) {
      Data key = lock.getKey();
      if (uuid.equals(lock.getOwner()) && !lock.isTransactional()) {
        UnlockOperation op = createLockCleanupOperation(partitionId, lockStore.getNamespace(), key, uuid);
        operationService.invokeOnTarget("hz:impl:lockService", op, this.nodeEngine.getThisAddress());
      } 
      lockStore.cleanWaitersAndSignalsFor(key, uuid);
    } 
  }
  
  private UnlockOperation createLockCleanupOperation(int partitionId, ObjectNamespace namespace, Data key, String uuid) {
    LocalLockCleanupOperation localLockCleanupOperation = new LocalLockCleanupOperation(namespace, key, uuid);
    localLockCleanupOperation.setAsyncBackup(true);
    localLockCleanupOperation.setNodeEngine(this.nodeEngine);
    localLockCleanupOperation.setServiceName("hz:impl:lockService");
    localLockCleanupOperation.setService(this);
    localLockCleanupOperation.setPartitionId(partitionId);
    localLockCleanupOperation.setValidateTarget(false);
    return localLockCleanupOperation;
  }
  
  public Collection<LockResource> getAllLocks() {
    Collection<LockResource> locks = new LinkedList<LockResource>();
    for (LockStoreContainer container : this.containers) {
      for (LockStoreImpl lockStore : container.getLockStores())
        locks.addAll(lockStore.getLocks()); 
    } 
    return locks;
  }
  
  public Collection<ServiceNamespace> getAllServiceNamespaces(PartitionReplicationEvent event) {
    int partitionId = event.getPartitionId();
    LockStoreContainer container = this.containers[partitionId];
    return container.getAllNamespaces(event.getReplicaIndex());
  }
  
  public boolean isKnownServiceNamespace(ServiceNamespace namespace) { return namespace instanceof ObjectNamespace; }
  
  public void beforeMigration(PartitionMigrationEvent partitionMigrationEvent) {}
  
  public Operation prepareReplicationOperation(PartitionReplicationEvent event) {
    int partitionId = event.getPartitionId();
    LockStoreContainer container = this.containers[partitionId];
    int replicaIndex = event.getReplicaIndex();
    LockReplicationOperation op = new LockReplicationOperation(container, partitionId, replicaIndex);
    return op.isEmpty() ? null : op;
  }
  
  public Operation prepareReplicationOperation(PartitionReplicationEvent event, Collection<ServiceNamespace> namespaces) {
    int partitionId = event.getPartitionId();
    LockStoreContainer container = this.containers[partitionId];
    int replicaIndex = event.getReplicaIndex();
    LockReplicationOperation op = new LockReplicationOperation(container, partitionId, replicaIndex, namespaces);
    return op.isEmpty() ? null : op;
  }
  
  public void commitMigration(PartitionMigrationEvent event) {
    if (event.getMigrationEndpoint() == MigrationEndpoint.SOURCE) {
      clearLockStoresHavingLesserBackupCountThan(event.getPartitionId(), event.getNewReplicaIndex());
    } else {
      scheduleEvictions(event.getPartitionId());
    } 
    removeLocalLocks(event.getPartitionId());
  }
  
  private void removeLocalLocks(int partitionId) {
    LockStoreContainer container = this.containers[partitionId];
    for (LockStoreImpl lockStore : container.getLockStores())
      lockStore.removeLocalLocks(); 
  }
  
  private void scheduleEvictions(int partitionId) {
    long now = Clock.currentTimeMillis();
    LockStoreContainer container = this.containers[partitionId];
    for (LockStoreImpl ls : container.getLockStores()) {
      for (LockResource lock : ls.getLocks()) {
        long expirationTime = lock.getExpirationTime();
        if (expirationTime == Float.MAX_VALUE || expirationTime < 0L)
          continue; 
        long leaseTime = expirationTime - now;
        if (leaseTime <= 0L) {
          ls.forceUnlock(lock.getKey());
          continue;
        } 
        ls.scheduleEviction(lock.getKey(), lock.getVersion(), leaseTime);
      } 
    } 
  }
  
  public void rollbackMigration(PartitionMigrationEvent event) {
    if (event.getMigrationEndpoint() == MigrationEndpoint.DESTINATION)
      clearLockStoresHavingLesserBackupCountThan(event.getPartitionId(), event.getCurrentReplicaIndex()); 
  }
  
  private void clearLockStoresHavingLesserBackupCountThan(int partitionId, int thresholdReplicaIndex) {
    LockStoreContainer container = this.containers[partitionId];
    for (LockStoreImpl lockStore : container.getLockStores()) {
      if (thresholdReplicaIndex < 0 || thresholdReplicaIndex > lockStore.getTotalBackupCount())
        lockStore.clear(); 
    } 
  }
  
  public DistributedObject createDistributedObject(String objectId) { return new LockProxy(this.nodeEngine, this, objectId); }
  
  public void destroyDistributedObject(String objectId) {
    Data key = this.nodeEngine.getSerializationService().toData(objectId, StringPartitioningStrategy.INSTANCE);
    int partitionId = this.nodeEngine.getPartitionService().getPartitionId(key);
    LockStoreImpl lockStore = this.containers[partitionId].getLockStore(new InternalLockNamespace(objectId));
    if (lockStore != null) {
      InternalOperationService operationService = (InternalOperationService)this.nodeEngine.getOperationService();
      operationService.execute(new Object(this, lockStore, key, partitionId));
    } 
    this.quorumConfigCache.remove(objectId);
  }
  
  public void clientDisconnected(String clientUuid) { releaseLocksOwnedBy(clientUuid); }
  
  public static long getMaxLeaseTimeInMillis(HazelcastProperties hazelcastProperties) { return hazelcastProperties.getMillis(GroupProperty.LOCK_MAX_LEASE_TIME_SECONDS); }
  
  public String getQuorumName(String name) {
    Object quorumName = ConcurrencyUtil.getOrPutSynchronized(this.quorumConfigCache, name, this.quorumConfigCacheMutexFactory, this.quorumConfigConstructor);
    return (quorumName == NULL_OBJECT) ? null : (String)quorumName;
  }
}
