package com.hazelcast.concurrent.lock;

import com.hazelcast.core.ICondition;
import com.hazelcast.core.ILock;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.AbstractDistributedObject;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.ObjectNamespace;
import com.hazelcast.util.Preconditions;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;

public class LockProxy extends AbstractDistributedObject<LockServiceImpl> implements ILock {
  private final String name;
  
  private final LockProxySupport lockSupport;
  
  private final Data key;
  
  private final int partitionId;
  
  public LockProxy(NodeEngine nodeEngine, LockServiceImpl lockService, String name) {
    super(nodeEngine, lockService);
    this.name = name;
    this.key = getNameAsPartitionAwareData();
    this.lockSupport = new LockProxySupport(new InternalLockNamespace(name), lockService.getMaxLeaseTimeInMillis());
    this.partitionId = getNodeEngine().getPartitionService().getPartitionId(this.key);
  }
  
  public boolean isLocked() { return this.lockSupport.isLocked(getNodeEngine(), this.key); }
  
  public boolean isLockedByCurrentThread() { return this.lockSupport.isLockedByCurrentThread(getNodeEngine(), this.key); }
  
  public int getLockCount() { return this.lockSupport.getLockCount(getNodeEngine(), this.key); }
  
  public long getRemainingLeaseTime() { return this.lockSupport.getRemainingLeaseTime(getNodeEngine(), this.key); }
  
  public void lock() { this.lockSupport.lock(getNodeEngine(), this.key); }
  
  public void lock(long leaseTime, TimeUnit timeUnit) {
    Preconditions.checkPositive(leaseTime, "leaseTime should be positive");
    this.lockSupport.lock(getNodeEngine(), this.key, timeUnit.toMillis(leaseTime));
  }
  
  public void lockInterruptibly() { this.lockSupport.lockInterruptly(getNodeEngine(), this.key); }
  
  public boolean tryLock() { return this.lockSupport.tryLock(getNodeEngine(), this.key); }
  
  public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
    Preconditions.checkNotNull(unit, "unit can't be null");
    return this.lockSupport.tryLock(getNodeEngine(), this.key, time, unit);
  }
  
  public boolean tryLock(long time, TimeUnit unit, long leaseTime, TimeUnit leaseUnit) throws InterruptedException {
    Preconditions.checkNotNull(unit, "unit can't be null");
    Preconditions.checkNotNull(leaseUnit, "lease unit can't be null");
    return this.lockSupport.tryLock(getNodeEngine(), this.key, time, unit, leaseTime, leaseUnit);
  }
  
  public void unlock() { this.lockSupport.unlock(getNodeEngine(), this.key); }
  
  public void forceUnlock() { this.lockSupport.forceUnlock(getNodeEngine(), this.key); }
  
  public Condition newCondition() { throw new UnsupportedOperationException("Use ILock.newCondition(String name) instead!"); }
  
  public ICondition newCondition(String name) {
    Preconditions.checkNotNull(name, "Condition name can't be null");
    return new ConditionImpl(this, name);
  }
  
  public String getName() { return this.name; }
  
  public String getServiceName() { return "hz:impl:lockService"; }
  
  @Deprecated
  public Object getKey() { return getName(); }
  
  public Data getKeyData() { return this.key; }
  
  public int getPartitionId() { return this.partitionId; }
  
  ObjectNamespace getNamespace() { return this.lockSupport.getNamespace(); }
  
  public String toString() { return "ILock{name='" + this.name + '\'' + '}'; }
}
