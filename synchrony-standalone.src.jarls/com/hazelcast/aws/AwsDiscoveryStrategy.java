package com.hazelcast.aws;

import com.hazelcast.config.InvalidConfigurationException;
import com.hazelcast.logging.ILogger;
import com.hazelcast.logging.Logger;
import com.hazelcast.nio.Address;
import com.hazelcast.spi.discovery.AbstractDiscoveryStrategy;
import com.hazelcast.spi.discovery.DiscoveryNode;
import com.hazelcast.spi.discovery.SimpleDiscoveryNode;
import com.hazelcast.util.StringUtil;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public class AwsDiscoveryStrategy extends AbstractDiscoveryStrategy {
  private static final ILogger LOGGER = Logger.getLogger(AwsDiscoveryStrategy.class);
  
  private static final String DEFAULT_PORT_RANGE = "5701-5708";
  
  private static final Integer DEFAULT_CONNECTION_RETRIES = Integer.valueOf(10);
  
  private static final int DEFAULT_CONNECTION_TIMEOUT_SECONDS = 10;
  
  private static final String DEFAULT_REGION = "us-east-1";
  
  private static final String DEFAULT_HOST_HEADER = "ec2.amazonaws.com";
  
  private final AwsConfig awsConfig;
  
  private final AWSClient awsClient;
  
  private final Map<String, Object> memberMetadata = new HashMap();
  
  public AwsDiscoveryStrategy(Map<String, Comparable> properties) {
    super(LOGGER, properties);
    this.awsConfig = getAwsConfig();
    try {
      this.awsClient = new AWSClient(this.awsConfig);
    } catch (IllegalArgumentException e) {
      throw new InvalidConfigurationException("AWS configuration is not valid", e);
    } 
  }
  
  AwsDiscoveryStrategy(Map<String, Comparable> properties, AWSClient client) {
    super(LOGGER, properties);
    this.awsConfig = getAwsConfig();
    this.awsClient = client;
  }
  
  private AwsConfig getAwsConfig() throws IllegalArgumentException {
    AwsConfig config = AwsConfig.builder().setAccessKey(getOrNull(AwsProperties.ACCESS_KEY)).setSecretKey(getOrNull(AwsProperties.SECRET_KEY)).setRegion((String)getOrDefault(AwsProperties.REGION.getDefinition(), "us-east-1")).setIamRole(getOrNull(AwsProperties.IAM_ROLE)).setHostHeader((String)getOrDefault(AwsProperties.HOST_HEADER.getDefinition(), "ec2.amazonaws.com")).setSecurityGroupName(getOrNull(AwsProperties.SECURITY_GROUP_NAME)).setTagKey(getOrNull(AwsProperties.TAG_KEY)).setTagValue(getOrNull(AwsProperties.TAG_VALUE)).setConnectionTimeoutSeconds(((Integer)getOrDefault(AwsProperties.CONNECTION_TIMEOUT_SECONDS.getDefinition(), Integer.valueOf(10))).intValue()).setConnectionRetries(((Integer)getOrDefault(AwsProperties.CONNECTION_RETRIES.getDefinition(), DEFAULT_CONNECTION_RETRIES)).intValue()).setHzPort(new PortRange(getPortRange())).build();
    reviewConfiguration(config);
    return config;
  }
  
  private String getPortRange() {
    Object portRange = getOrNull(AwsProperties.PORT.getDefinition());
    if (portRange == null)
      return "5701-5708"; 
    return portRange.toString();
  }
  
  private void reviewConfiguration(AwsConfig config) {
    if (StringUtil.isNullOrEmptyAfterTrim(config.getSecretKey()) || 
      StringUtil.isNullOrEmptyAfterTrim(config.getAccessKey())) {
      if (!StringUtil.isNullOrEmptyAfterTrim(config.getIamRole())) {
        getLogger().info("Describe instances will be queried with iam-role, please make sure given iam-role have ec2:DescribeInstances policy attached.");
      } else {
        getLogger().warning("Describe instances will be queried with iam-role assigned to EC2 instance, please make sure given iam-role have ec2:DescribeInstances policy attached.");
      } 
    } else if (!StringUtil.isNullOrEmptyAfterTrim(config.getIamRole())) {
      getLogger().info("No need to define iam-role, when access and secret keys are configured!");
    } 
  }
  
  public Map<String, Object> discoverLocalMetadata() {
    if (this.memberMetadata.isEmpty())
      this.memberMetadata.put("hazelcast.partition.group.zone", this.awsClient.getAvailabilityZone()); 
    return this.memberMetadata;
  }
  
  public Iterable<DiscoveryNode> discoverNodes() {
    try {
      Map<String, String> privatePublicIpAddressPairs = this.awsClient.getAddresses();
      if (privatePublicIpAddressPairs.isEmpty()) {
        getLogger().warning("No EC2 instances found!");
        return Collections.emptyList();
      } 
      if (getLogger().isFinestEnabled()) {
        StringBuilder sb = new StringBuilder("Found the following EC2 instances:\n");
        for (Map.Entry<String, String> entry : privatePublicIpAddressPairs.entrySet())
          sb.append("    ").append((String)entry.getKey()).append(" : ").append((String)entry.getValue()).append("\n"); 
        getLogger().finest(sb.toString());
      } 
      ArrayList<DiscoveryNode> nodes = new ArrayList<DiscoveryNode>(privatePublicIpAddressPairs.size());
      for (Map.Entry<String, String> entry : privatePublicIpAddressPairs.entrySet()) {
        for (int port = this.awsConfig.getHzPort().getFromPort(); port <= this.awsConfig.getHzPort().getToPort(); port++)
          nodes.add(new SimpleDiscoveryNode(new Address((String)entry.getKey(), port), new Address((String)entry.getValue(), port))); 
      } 
      return nodes;
    } catch (Exception e) {
      LOGGER.warning("Cannot discover nodes, returning empty list", e);
      return Collections.emptyList();
    } 
  }
  
  private String getOrNull(AwsProperties awsProperties) { return (String)getOrNull(awsProperties.getDefinition()); }
}
