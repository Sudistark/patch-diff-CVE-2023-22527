package com.hazelcast.multimap.impl;

import com.hazelcast.config.EntryListenerConfig;
import com.hazelcast.config.MultiMapConfig;
import com.hazelcast.core.EntryListener;
import com.hazelcast.core.HazelcastException;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.HazelcastInstanceAware;
import com.hazelcast.core.MultiMap;
import com.hazelcast.mapreduce.Collator;
import com.hazelcast.mapreduce.CombinerFactory;
import com.hazelcast.mapreduce.Job;
import com.hazelcast.mapreduce.JobCompletableFuture;
import com.hazelcast.mapreduce.JobTracker;
import com.hazelcast.mapreduce.KeyValueSource;
import com.hazelcast.mapreduce.Mapper;
import com.hazelcast.mapreduce.MappingJob;
import com.hazelcast.mapreduce.ReducerFactory;
import com.hazelcast.mapreduce.ReducingSubmittableJob;
import com.hazelcast.mapreduce.aggregation.Aggregation;
import com.hazelcast.mapreduce.aggregation.Supplier;
import com.hazelcast.monitor.LocalMultiMapStats;
import com.hazelcast.multimap.impl.operations.EntrySetResponse;
import com.hazelcast.multimap.impl.operations.MultiMapResponse;
import com.hazelcast.nio.ClassLoaderUtil;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.quorum.QuorumType;
import com.hazelcast.spi.InitializingObject;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.SetUtil;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

public class ObjectMultiMapProxy<K, V> extends MultiMapProxySupport implements MultiMap<K, V>, InitializingObject {
  protected static final String NULL_KEY_IS_NOT_ALLOWED = "Null key is not allowed!";
  
  protected static final String NULL_VALUE_IS_NOT_ALLOWED = "Null value is not allowed!";
  
  public ObjectMultiMapProxy(MultiMapConfig config, MultiMapService service, NodeEngine nodeEngine, String name) { super(config, service, nodeEngine, name); }
  
  public void initialize() {
    NodeEngine nodeEngine = getNodeEngine();
    List<EntryListenerConfig> listenerConfigs = this.config.getEntryListenerConfigs();
    for (EntryListenerConfig listenerConfig : listenerConfigs) {
      EntryListener listener = null;
      if (listenerConfig.getImplementation() != null) {
        listener = listenerConfig.getImplementation();
      } else if (listenerConfig.getClassName() != null) {
        try {
          listener = (EntryListener)ClassLoaderUtil.newInstance(nodeEngine.getConfigClassLoader(), listenerConfig.getClassName());
        } catch (Exception e) {
          throw ExceptionUtil.rethrow(e);
        } 
      } 
      if (listener != null) {
        if (listener instanceof HazelcastInstanceAware)
          ((HazelcastInstanceAware)listener).setHazelcastInstance(nodeEngine.getHazelcastInstance()); 
        if (listenerConfig.isLocal()) {
          addLocalEntryListener(listener);
          continue;
        } 
        addEntryListener(listener, listenerConfig.isIncludeValue());
      } 
    } 
  }
  
  public boolean put(K key, V value) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    NodeEngine nodeEngine = getNodeEngine();
    Data dataKey = nodeEngine.toData(key);
    Data dataValue = nodeEngine.toData(value);
    return putInternal(dataKey, dataValue, -1).booleanValue();
  }
  
  public Collection<V> get(K key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    NodeEngine nodeEngine = getNodeEngine();
    Data dataKey = nodeEngine.toData(key);
    MultiMapResponse result = getAllInternal(dataKey);
    return result.getObjectCollection(nodeEngine);
  }
  
  public boolean remove(Object key, Object value) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    NodeEngine nodeEngine = getNodeEngine();
    Data dataKey = nodeEngine.toData(key);
    Data dataValue = nodeEngine.toData(value);
    return removeInternal(dataKey, dataValue).booleanValue();
  }
  
  public Collection<V> remove(Object key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    NodeEngine nodeEngine = getNodeEngine();
    Data dataKey = nodeEngine.toData(key);
    MultiMapResponse result = removeInternal(dataKey);
    return result.getObjectCollection(nodeEngine);
  }
  
  public void delete(Object key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    NodeEngine nodeEngine = getNodeEngine();
    Data dataKey = nodeEngine.toData(key);
    deleteInternal(dataKey);
  }
  
  public Set<K> localKeySet() {
    ensureQuorumPresent(QuorumType.READ);
    Set<Data> dataKeySet = localKeySetInternal();
    return toObjectSet(dataKeySet);
  }
  
  public Set<K> keySet() {
    Set<Data> dataKeySet = keySetInternal();
    return toObjectSet(dataKeySet);
  }
  
  public Collection<V> values() {
    NodeEngine nodeEngine = getNodeEngine();
    Map map = valuesInternal();
    Collection values = new LinkedList();
    for (Object obj : map.values()) {
      if (obj == null)
        continue; 
      MultiMapResponse response = (MultiMapResponse)nodeEngine.toObject(obj);
      values.addAll(response.getObjectCollection(nodeEngine));
    } 
    return values;
  }
  
  public Set<Map.Entry<K, V>> entrySet() {
    NodeEngine nodeEngine = getNodeEngine();
    Map map = entrySetInternal();
    Set<Map.Entry<K, V>> entrySet = new HashSet<Map.Entry<K, V>>();
    for (Object obj : map.values()) {
      if (obj == null)
        continue; 
      EntrySetResponse response = (EntrySetResponse)nodeEngine.toObject(obj);
      Set<Map.Entry<K, V>> entries = response.getObjectEntrySet(nodeEngine);
      entrySet.addAll(entries);
    } 
    return entrySet;
  }
  
  public boolean containsKey(K key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    NodeEngine nodeEngine = getNodeEngine();
    Data dataKey = nodeEngine.toData(key);
    return containsInternal(dataKey, null);
  }
  
  public boolean containsValue(Object value) {
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    NodeEngine nodeEngine = getNodeEngine();
    Data valueKey = nodeEngine.toData(value);
    return containsInternal(null, valueKey);
  }
  
  public boolean containsEntry(K key, V value) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkNotNull(value, "Null value is not allowed!");
    NodeEngine nodeEngine = getNodeEngine();
    Data dataKey = nodeEngine.toData(key);
    Data valueKey = nodeEngine.toData(value);
    return containsInternal(dataKey, valueKey);
  }
  
  public int valueCount(K key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    NodeEngine nodeEngine = getNodeEngine();
    Data dataKey = nodeEngine.toData(key);
    return countInternal(dataKey).intValue();
  }
  
  public String addLocalEntryListener(EntryListener<K, V> listener) { return ((MultiMapService)getService()).addListener(this.name, listener, null, false, true); }
  
  public String addEntryListener(EntryListener<K, V> listener, boolean includeValue) { return ((MultiMapService)getService()).addListener(this.name, listener, null, includeValue, false); }
  
  public boolean removeEntryListener(String registrationId) { return ((MultiMapService)getService()).removeListener(this.name, registrationId); }
  
  public String addEntryListener(EntryListener<K, V> listener, K key, boolean includeValue) {
    NodeEngine nodeEngine = getNodeEngine();
    Data dataKey = nodeEngine.toData(key);
    return ((MultiMapService)getService()).addListener(this.name, listener, dataKey, includeValue, false);
  }
  
  public void lock(K key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    NodeEngine nodeEngine = getNodeEngine();
    Data dataKey = nodeEngine.toData(key);
    this.lockSupport.lock(nodeEngine, dataKey);
  }
  
  public void lock(K key, long leaseTime, TimeUnit timeUnit) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    Preconditions.checkPositive(leaseTime, "leaseTime should be positive");
    NodeEngine nodeEngine = getNodeEngine();
    Data dataKey = nodeEngine.toData(key);
    this.lockSupport.lock(nodeEngine, dataKey, timeUnit.toMillis(leaseTime));
  }
  
  public boolean isLocked(K key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    NodeEngine nodeEngine = getNodeEngine();
    Data dataKey = nodeEngine.toData(key);
    return this.lockSupport.isLocked(nodeEngine, dataKey);
  }
  
  public boolean tryLock(K key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    NodeEngine nodeEngine = getNodeEngine();
    Data dataKey = nodeEngine.toData(key);
    return this.lockSupport.tryLock(nodeEngine, dataKey);
  }
  
  public boolean tryLock(K key, long time, TimeUnit timeunit) throws InterruptedException {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    NodeEngine nodeEngine = getNodeEngine();
    Data dataKey = nodeEngine.toData(key);
    return this.lockSupport.tryLock(nodeEngine, dataKey, time, timeunit);
  }
  
  public boolean tryLock(K key, long time, TimeUnit timeunit, long leaseTime, TimeUnit leaseUnit) throws InterruptedException {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    NodeEngine nodeEngine = getNodeEngine();
    Data dataKey = nodeEngine.toData(key);
    return this.lockSupport.tryLock(nodeEngine, dataKey, time, timeunit, leaseTime, leaseUnit);
  }
  
  public void unlock(K key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    NodeEngine nodeEngine = getNodeEngine();
    Data dataKey = nodeEngine.toData(key);
    this.lockSupport.unlock(nodeEngine, dataKey);
  }
  
  public void forceUnlock(K key) {
    Preconditions.checkNotNull(key, "Null key is not allowed!");
    NodeEngine nodeEngine = getNodeEngine();
    Data dataKey = nodeEngine.toData(key);
    this.lockSupport.forceUnlock(nodeEngine, dataKey);
  }
  
  public LocalMultiMapStats getLocalMultiMapStats() { return ((MultiMapService)getService()).createStats(this.name); }
  
  public <SuppliedValue, Result> Result aggregate(Supplier<K, V, SuppliedValue> supplier, Aggregation<K, SuppliedValue, Result> aggregation) {
    HazelcastInstance hazelcastInstance = getNodeEngine().getHazelcastInstance();
    JobTracker jobTracker = hazelcastInstance.getJobTracker("hz::aggregation-multimap-" + getName());
    return (Result)aggregate(supplier, aggregation, jobTracker);
  }
  
  public <SuppliedValue, Result> Result aggregate(Supplier<K, V, SuppliedValue> supplier, Aggregation<K, SuppliedValue, Result> aggregation, JobTracker jobTracker) {
    try {
      ReducingSubmittableJob reducingJob;
      Preconditions.isNotNull(jobTracker, "jobTracker");
      KeyValueSource<K, V> keyValueSource = KeyValueSource.fromMultiMap(this);
      Job<K, V> job = jobTracker.newJob(keyValueSource);
      Mapper mapper = aggregation.getMapper(supplier);
      CombinerFactory combinerFactory = aggregation.getCombinerFactory();
      ReducerFactory reducerFactory = aggregation.getReducerFactory();
      Collator collator = aggregation.getCollator();
      MappingJob mappingJob = job.mapper(mapper);
      if (combinerFactory != null) {
        reducingJob = mappingJob.combiner(combinerFactory).reducer(reducerFactory);
      } else {
        reducingJob = mappingJob.reducer(reducerFactory);
      } 
      JobCompletableFuture jobCompletableFuture = reducingJob.submit(collator);
      return (Result)jobCompletableFuture.get();
    } catch (Exception e) {
      throw new HazelcastException(e);
    } 
  }
  
  private Set<K> toObjectSet(Set<Data> dataSet) {
    NodeEngine nodeEngine = getNodeEngine();
    Set<K> keySet = SetUtil.createHashSet(dataSet.size());
    for (Data dataKey : dataSet)
      keySet.add(nodeEngine.toObject(dataKey)); 
    return keySet;
  }
  
  private void ensureQuorumPresent(QuorumType requiredQuorumPermissionType) { ((MultiMapService)getService()).ensureQuorumPresent(this.name, requiredQuorumPermissionType); }
}
