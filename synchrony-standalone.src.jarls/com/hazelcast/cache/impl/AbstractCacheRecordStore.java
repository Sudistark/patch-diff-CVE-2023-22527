package com.hazelcast.cache.impl;

import com.hazelcast.cache.CacheEntryView;
import com.hazelcast.cache.CacheEventType;
import com.hazelcast.cache.CacheMergePolicy;
import com.hazelcast.cache.CacheNotExistsException;
import com.hazelcast.cache.impl.maxsize.impl.EntryCountCacheEvictionChecker;
import com.hazelcast.cache.impl.merge.entry.LazyCacheEntryView;
import com.hazelcast.cache.impl.record.CacheRecord;
import com.hazelcast.cache.impl.record.CacheRecordFactory;
import com.hazelcast.cache.impl.record.SampleableCacheRecordMap;
import com.hazelcast.config.CacheConfig;
import com.hazelcast.config.CacheConfigAccessor;
import com.hazelcast.config.Config;
import com.hazelcast.config.EventJournalConfig;
import com.hazelcast.config.EvictionConfig;
import com.hazelcast.config.InMemoryFormat;
import com.hazelcast.config.WanConsumerConfig;
import com.hazelcast.config.WanReplicationConfig;
import com.hazelcast.config.WanReplicationRef;
import com.hazelcast.core.ManagedContext;
import com.hazelcast.internal.cluster.Versions;
import com.hazelcast.internal.config.ConfigValidator;
import com.hazelcast.internal.diagnostics.StoreLatencyPlugin;
import com.hazelcast.internal.eviction.ClearExpiredRecordsTask;
import com.hazelcast.internal.eviction.Evictable;
import com.hazelcast.internal.eviction.EvictionCandidate;
import com.hazelcast.internal.eviction.EvictionChecker;
import com.hazelcast.internal.eviction.EvictionListener;
import com.hazelcast.internal.eviction.EvictionPolicyEvaluatorProvider;
import com.hazelcast.internal.eviction.ExpiredKey;
import com.hazelcast.internal.eviction.impl.evaluator.EvictionPolicyEvaluator;
import com.hazelcast.internal.eviction.impl.strategy.sampling.SamplingEvictionStrategy;
import com.hazelcast.internal.nearcache.impl.invalidation.InvalidationQueue;
import com.hazelcast.internal.util.comparators.ValueComparator;
import com.hazelcast.internal.util.comparators.ValueComparatorUtil;
import com.hazelcast.map.impl.MapEntries;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.IOUtil;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.EventRegistration;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.ObjectNamespace;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.impl.eventservice.InternalEventService;
import com.hazelcast.spi.impl.merge.MergingValueFactory;
import com.hazelcast.spi.merge.SplitBrainMergePolicy;
import com.hazelcast.spi.merge.SplitBrainMergeTypes;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.Clock;
import com.hazelcast.util.EmptyStatement;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.MapUtil;
import com.hazelcast.util.SetUtil;
import com.hazelcast.util.ThreadUtil;
import com.hazelcast.wan.impl.CallerProvenance;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.Closeable;
import java.io.IOException;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import javax.annotation.Nonnull;
import javax.cache.configuration.Factory;
import javax.cache.expiry.Duration;
import javax.cache.expiry.ExpiryPolicy;
import javax.cache.integration.CacheLoader;
import javax.cache.integration.CacheLoaderException;
import javax.cache.integration.CacheWriter;
import javax.cache.integration.CacheWriterException;
import javax.cache.processor.EntryProcessor;

public abstract class AbstractCacheRecordStore<R extends CacheRecord, CRM extends SampleableCacheRecordMap<Data, R>> extends Object implements ICacheRecordStore, EvictionListener<Data, R> {
  public static final String SOURCE_NOT_AVAILABLE = "<NA>";
  
  protected static final int DEFAULT_INITIAL_CAPACITY = 256;
  
  protected final int partitionId;
  
  protected final int partitionCount;
  
  protected final boolean wanReplicationEnabled;
  
  protected final boolean persistWanReplicatedData;
  
  protected final boolean disablePerEntryInvalidationEvents;
  
  protected final String name;
  
  protected final NodeEngine nodeEngine;
  
  protected final CacheConfig cacheConfig;
  
  protected final SerializationService ss;
  
  protected final EvictionConfig evictionConfig;
  
  protected final ValueComparator valueComparator;
  
  protected final EvictionChecker evictionChecker;
  
  protected final ObjectNamespace objectNamespace;
  
  protected final AbstractCacheService cacheService;
  
  protected final CacheRecordFactory cacheRecordFactory;
  
  protected final EventJournalConfig eventJournalConfig;
  
  protected final ClearExpiredRecordsTask clearExpiredRecordsTask;
  
  protected final SamplingEvictionStrategy<Data, R, CRM> evictionStrategy;
  
  protected final EvictionPolicyEvaluator<Data, R> evictionPolicyEvaluator;
  
  protected final Map<CacheEventType, Set<CacheEventData>> batchEvent;
  
  protected boolean primary;
  
  protected boolean eventsEnabled;
  
  protected boolean eventsBatchingEnabled;
  
  protected CRM records;
  
  protected CacheLoader cacheLoader;
  
  protected CacheWriter cacheWriter;
  
  protected CacheContext cacheContext;
  
  protected CacheStatisticsImpl statistics;
  
  protected ExpiryPolicy defaultExpiryPolicy;
  
  protected Iterator<Map.Entry<Data, R>> expirationIterator;
  
  protected InvalidationQueue<ExpiredKey> expiredKeys;
  
  protected boolean hasEntryWithExpiration;
  
  public AbstractCacheRecordStore(String cacheNameWithPrefix, int partitionId, NodeEngine nodeEngine, AbstractCacheService cacheService) {
    this.batchEvent = new HashMap();
    this.eventsEnabled = true;
    this.expiredKeys = new InvalidationQueue();
    this.name = cacheNameWithPrefix;
    this.partitionId = partitionId;
    this.nodeEngine = nodeEngine;
    this.ss = nodeEngine.getSerializationService();
    this.partitionCount = nodeEngine.getPartitionService().getPartitionCount();
    this.cacheService = cacheService;
    this.cacheConfig = cacheService.getCacheConfig(cacheNameWithPrefix);
    if (this.cacheConfig == null)
      throw new CacheNotExistsException("Cache " + cacheNameWithPrefix + " is already destroyed or not created yet, on " + nodeEngine
          .getLocalMember()); 
    tenantContext = CacheConfigAccessor.getTenantControl(this.cacheConfig).setTenant(true);
    try {
      this.eventJournalConfig = nodeEngine.getConfig().findCacheEventJournalConfig(this.cacheConfig.getName());
      this.evictionConfig = this.cacheConfig.getEvictionConfig();
      if (this.evictionConfig == null)
        throw new IllegalStateException("Eviction config cannot be null!"); 
      this.wanReplicationEnabled = cacheService.isWanReplicationEnabled(cacheNameWithPrefix);
      this.disablePerEntryInvalidationEvents = this.cacheConfig.isDisablePerEntryInvalidationEvents();
      initializeStatisticsAndFactories(cacheNameWithPrefix);
      this.cacheContext = cacheService.getOrCreateCacheContext(cacheNameWithPrefix);
      this.records = createRecordCacheMap();
      this.evictionChecker = createCacheEvictionChecker(this.evictionConfig.getSize(), this.evictionConfig.getMaximumSizePolicy());
      this.evictionPolicyEvaluator = createEvictionPolicyEvaluator(this.evictionConfig);
      this.evictionStrategy = createEvictionStrategy(this.evictionConfig);
      this.objectNamespace = CacheService.getObjectNamespace(cacheNameWithPrefix);
      this.persistWanReplicatedData = canPersistWanReplicatedData(this.cacheConfig, nodeEngine);
      this.cacheRecordFactory = new CacheRecordFactory(this.cacheConfig.getInMemoryFormat(), this.ss);
      this.valueComparator = getValueComparatorOf(this.cacheConfig.getInMemoryFormat());
      this.clearExpiredRecordsTask = cacheService.getExpirationManager().getTask();
      injectDependencies(this.evictionPolicyEvaluator.getEvictionPolicyComparator());
      registerResourceIfItIsClosable(this.cacheWriter);
      registerResourceIfItIsClosable(this.cacheLoader);
      registerResourceIfItIsClosable(this.defaultExpiryPolicy);
      init();
    } finally {
      try {
        tenantContext.close();
      } catch (IOException ex) {
        ExceptionUtil.rethrow(ex);
      } 
    } 
  }
  
  private void initializeStatisticsAndFactories(String cacheNameWithPrefix) {
    if (this.cacheConfig.isStatisticsEnabled())
      this.statistics = this.cacheService.createCacheStatIfAbsent(cacheNameWithPrefix); 
    if (this.cacheConfig.getCacheLoaderFactory() != null) {
      Factory<CacheLoader> cacheLoaderFactory = this.cacheConfig.getCacheLoaderFactory();
      injectDependencies(cacheLoaderFactory);
      this.cacheLoader = (CacheLoader)cacheLoaderFactory.create();
      injectDependencies(this.cacheLoader);
    } 
    if (this.cacheConfig.getCacheWriterFactory() != null) {
      Factory<CacheWriter> cacheWriterFactory = this.cacheConfig.getCacheWriterFactory();
      injectDependencies(cacheWriterFactory);
      this.cacheWriter = (CacheWriter)cacheWriterFactory.create();
      injectDependencies(this.cacheWriter);
    } 
    if (this.cacheConfig.getExpiryPolicyFactory() != null) {
      Factory<ExpiryPolicy> expiryPolicyFactory = this.cacheConfig.getExpiryPolicyFactory();
      injectDependencies(expiryPolicyFactory);
      this.defaultExpiryPolicy = (ExpiryPolicy)expiryPolicyFactory.create();
      injectDependencies(this.defaultExpiryPolicy);
    } else {
      throw new IllegalStateException("Expiry policy factory cannot be null!");
    } 
  }
  
  protected ValueComparator getValueComparatorOf(InMemoryFormat inMemoryFormat) { return ValueComparatorUtil.getValueComparatorOf(inMemoryFormat); }
  
  private boolean canPersistWanReplicatedData(CacheConfig cacheConfig, NodeEngine nodeEngine) {
    boolean persistWanReplicatedData = false;
    WanReplicationRef wanReplicationRef = cacheConfig.getWanReplicationRef();
    if (wanReplicationRef != null) {
      String wanReplicationRefName = wanReplicationRef.getName();
      Config config = nodeEngine.getConfig();
      WanReplicationConfig wanReplicationConfig = config.getWanReplicationConfig(wanReplicationRefName);
      if (wanReplicationConfig != null) {
        WanConsumerConfig wanConsumerConfig = wanReplicationConfig.getWanConsumerConfig();
        if (wanConsumerConfig != null)
          persistWanReplicatedData = wanConsumerConfig.isPersistWanReplicatedData(); 
      } 
    } 
    return persistWanReplicatedData;
  }
  
  private boolean persistenceEnabledFor(@Nonnull CallerProvenance provenance) {
    switch (null.$SwitchMap$com$hazelcast$wan$impl$CallerProvenance[provenance.ordinal()]) {
      case 1:
        return this.persistWanReplicatedData;
      case 2:
        return true;
    } 
    throw new IllegalArgumentException("Unexpected provenance: `" + provenance + "`");
  }
  
  public void instrument(NodeEngine nodeEngine) {
    StoreLatencyPlugin plugin = (StoreLatencyPlugin)((NodeEngineImpl)nodeEngine).getDiagnostics().getPlugin(StoreLatencyPlugin.class);
    if (plugin == null)
      return; 
    if (this.cacheLoader != null)
      this.cacheLoader = new LatencyTrackingCacheLoader(this.cacheLoader, plugin, this.cacheConfig.getName()); 
    if (this.cacheWriter != null)
      this.cacheWriter = new LatencyTrackingCacheWriter(this.cacheWriter, plugin, this.cacheConfig.getName()); 
  }
  
  private boolean isPrimary() {
    Address owner = this.nodeEngine.getPartitionService().getPartition(this.partitionId, false).getOwnerOrNull();
    Address thisAddress = this.nodeEngine.getThisAddress();
    return (owner != null && owner.equals(thisAddress));
  }
  
  private void injectDependencies(Object obj) {
    ManagedContext managedContext = this.ss.getManagedContext();
    managedContext.initialize(obj);
  }
  
  private void registerResourceIfItIsClosable(Object resource) {
    if (resource instanceof Closeable)
      this.cacheService.addCacheResource(this.name, (Closeable)resource); 
  }
  
  public void init() {
    this.primary = isPrimary();
    this.records.setEntryCounting(this.primary);
    markExpirable(-1L);
  }
  
  protected boolean isReadThrough() { return this.cacheConfig.isReadThrough(); }
  
  protected boolean isWriteThrough() { return this.cacheConfig.isWriteThrough(); }
  
  protected boolean isStatisticsEnabled() { return (this.statistics != null); }
  
  protected EvictionChecker createCacheEvictionChecker(int size, EvictionConfig.MaxSizePolicy maxSizePolicy) {
    if (maxSizePolicy == null)
      throw new IllegalArgumentException("Max-Size policy cannot be null"); 
    if (maxSizePolicy == EvictionConfig.MaxSizePolicy.ENTRY_COUNT)
      return new EntryCountCacheEvictionChecker(size, this.records, this.partitionCount); 
    return null;
  }
  
  protected EvictionPolicyEvaluator<Data, R> createEvictionPolicyEvaluator(EvictionConfig evictionConfig) {
    ConfigValidator.checkEvictionConfig(evictionConfig, false);
    tenantContext = CacheConfigAccessor.getTenantControl(this.cacheConfig).setTenant(false);
    try {
      return EvictionPolicyEvaluatorProvider.getEvictionPolicyEvaluator(evictionConfig, this.nodeEngine.getConfigClassLoader());
    } finally {
      IOUtil.closeResource(tenantContext);
    } 
  }
  
  protected SamplingEvictionStrategy<Data, R, CRM> createEvictionStrategy(EvictionConfig cacheEvictionConfig) { return SamplingEvictionStrategy.INSTANCE; }
  
  protected boolean isEvictionEnabled() { return (this.evictionStrategy != null && this.evictionPolicyEvaluator != null); }
  
  protected boolean isEventsEnabled() { return (this.eventsEnabled && (this.cacheContext.getCacheEntryListenerCount() > 0 || this.wanReplicationEnabled)); }
  
  protected boolean isInvalidationEnabled() { return (this.primary && this.cacheContext.getInvalidationListenerCount() > 0); }
  
  public boolean evictIfRequired() {
    if (!isEvictionEnabled())
      return false; 
    boolean evicted = this.evictionStrategy.evict(this.records, this.evictionPolicyEvaluator, this.evictionChecker, this);
    if (isStatisticsEnabled() && evicted && this.primary)
      this.statistics.increaseCacheEvictions(1L); 
    return evicted;
  }
  
  public void sampleAndForceRemoveEntries(int entryCountToRemove) {
    ThreadUtil.assertRunningOnPartitionThread();
    Queue<Data> keysToRemove = new LinkedList<Data>();
    Iterable<EvictionCandidate<Data, R>> entries = this.records.sample(entryCountToRemove);
    for (EvictionCandidate<Data, R> entry : entries)
      keysToRemove.add(entry.getAccessor()); 
    Data dataKey;
    while ((dataKey = (Data)keysToRemove.poll()) != null)
      forceRemoveRecord(dataKey); 
  }
  
  protected void forceRemoveRecord(Data key) { removeRecord(key); }
  
  protected Data toData(Object obj) {
    if (obj instanceof Data)
      return (Data)obj; 
    if (obj instanceof CacheRecord)
      return recordToData((CacheRecord)obj); 
    return valueToData(obj);
  }
  
  protected Object toValue(Object obj) {
    if (obj instanceof Data)
      return dataToValue((Data)obj); 
    if (obj instanceof CacheRecord)
      return recordToValue((CacheRecord)obj); 
    return obj;
  }
  
  protected Object toStorageValue(Object obj) {
    if (obj instanceof Data) {
      if (this.cacheConfig.getInMemoryFormat() == InMemoryFormat.OBJECT)
        return dataToValue((Data)obj); 
      return obj;
    } 
    if (obj instanceof CacheRecord)
      return recordToValue((CacheRecord)obj); 
    return obj;
  }
  
  public Data toEventData(Object obj) { return isEventsEnabled() ? toHeapData(obj) : null; }
  
  private long getAdjustedExpireTime(Duration duration, long now) { return duration.getAdjustedTime(now); }
  
  protected ExpiryPolicy getExpiryPolicy(CacheRecord record, ExpiryPolicy expiryPolicy) {
    if (expiryPolicy != null)
      return expiryPolicy; 
    if (record != null && record.getExpiryPolicy() != null)
      return (ExpiryPolicy)toValue(record.getExpiryPolicy()); 
    return this.defaultExpiryPolicy;
  }
  
  protected boolean evictIfExpired(Data key, R record, long now) { return processExpiredEntry(key, record, now); }
  
  protected boolean processExpiredEntry(Data key, R record, long now) { return processExpiredEntry(key, record, now, "<NA>"); }
  
  protected boolean processExpiredEntry(Data key, R record, long now, String source) { return processExpiredEntry(key, record, now, source, null); }
  
  protected boolean processExpiredEntry(Data key, R record, long now, String source, String origin) {
    boolean isExpired = (record != null && record.isExpiredAt(now));
    if (!isExpired)
      return false; 
    if (isStatisticsEnabled())
      this.statistics.increaseCacheExpiries(1L); 
    R removedRecord = (R)doRemoveRecord(key, source);
    Data keyEventData = toEventData(key);
    Data recordEventData = toEventData(removedRecord);
    if (removedRecord != null) {
      onProcessExpiredEntry(key, removedRecord, removedRecord.getExpirationTime(), now, source, origin);
      if (isEventsEnabled())
        publishEvent(CacheEventContextUtil.createCacheExpiredEvent(keyEventData, recordEventData, -1L, origin, -1)); 
    } 
    return true;
  }
  
  protected R processExpiredEntry(Data key, R record, long expiryTime, long now, String source) { return (R)processExpiredEntry(key, record, expiryTime, now, source, null); }
  
  protected R processExpiredEntry(Data key, R record, long expiryTime, long now, String source, String origin) {
    if (!CacheRecordFactory.isExpiredAt(expiryTime, now))
      return record; 
    if (isStatisticsEnabled())
      this.statistics.increaseCacheExpiries(1L); 
    R removedRecord = (R)doRemoveRecord(key, source);
    Data keyEventData = toEventData(key);
    Data recordEventData = toEventData(removedRecord);
    onProcessExpiredEntry(key, removedRecord, expiryTime, now, source, origin);
    if (isEventsEnabled())
      publishEvent(CacheEventContextUtil.createCacheExpiredEvent(keyEventData, recordEventData, -1L, origin, -1)); 
    return null;
  }
  
  protected void onProcessExpiredEntry(Data key, R record, long expiryTime, long now, String source, String origin) { accumulateOrSendExpiredKeysToBackup(key, record); }
  
  protected void accumulateOrSendExpiredKeysToBackup(Data key, R record) {
    if (this.cacheConfig.getTotalBackupCount() == 0)
      return; 
    if (key != null && record != null)
      this.expiredKeys.offer(new ExpiredKey(toHeapData(key), record.getCreationTime())); 
    this.clearExpiredRecordsTask.tryToSendBackupExpiryOp(this, true);
  }
  
  public boolean isExpirable() { return (this.hasEntryWithExpiration || getConfig().getExpiryPolicyFactory() != null); }
  
  public R accessRecord(Data key, R record, ExpiryPolicy expiryPolicy, long now) {
    onRecordAccess(key, record, getExpiryPolicy(record, expiryPolicy), now);
    return record;
  }
  
  public void onEvict(Data key, R record, boolean wasExpired) {
    if (wasExpired) {
      this.cacheService.eventJournal.writeExpiredEvent(this.eventJournalConfig, this.objectNamespace, this.partitionId, key, record.getValue());
    } else {
      this.cacheService.eventJournal.writeEvictEvent(this.eventJournalConfig, this.objectNamespace, this.partitionId, key, record.getValue());
    } 
    invalidateEntry(key);
  }
  
  protected void invalidateEntry(Data key, String source) {
    if (isInvalidationEnabled())
      if (key == null) {
        this.cacheService.sendInvalidationEvent(this.name, null, source);
      } else if (!this.disablePerEntryInvalidationEvents) {
        this.cacheService.sendInvalidationEvent(this.name, toHeapData(key), source);
      }  
  }
  
  protected void invalidateEntry(Data key) { invalidateEntry(key, "<NA>"); }
  
  protected void updateGetAndPutStat(boolean isPutSucceed, boolean getValue, boolean oldValueNull, long start) {
    if (isStatisticsEnabled()) {
      if (isPutSucceed) {
        this.statistics.increaseCachePuts(1L);
        this.statistics.addPutTimeNanos(System.nanoTime() - start);
      } 
      if (getValue) {
        if (oldValueNull) {
          this.statistics.increaseCacheMisses(1L);
        } else {
          this.statistics.increaseCacheHits(1L);
        } 
        this.statistics.addGetTimeNanos(System.nanoTime() - start);
      } 
    } 
  }
  
  protected long updateAccessDuration(Data key, R record, ExpiryPolicy expiryPolicy, long now) {
    long expiryTime = -1L;
    try {
      Duration expiryDuration = expiryPolicy.getExpiryForAccess();
      if (expiryDuration != null) {
        expiryTime = getAdjustedExpireTime(expiryDuration, now);
        record.setExpirationTime(expiryTime);
        if (isEventsEnabled()) {
          CacheEventContext cacheEventContext = CacheEventContextUtil.createBaseEventContext(CacheEventType.EXPIRATION_TIME_UPDATED, toEventData(key), 
              toEventData(record.getValue()), expiryTime, null, -1);
          cacheEventContext.setAccessHit(record.getAccessHit());
          publishEvent(cacheEventContext);
        } 
      } 
    } catch (Exception e) {
      EmptyStatement.ignore(e);
    } 
    return expiryTime;
  }
  
  protected long onRecordAccess(Data key, R record, ExpiryPolicy expiryPolicy, long now) {
    record.setAccessTime(now);
    record.incrementAccessHit();
    return updateAccessDuration(key, record, expiryPolicy, now);
  }
  
  protected void updateReplaceStat(boolean result, boolean isHit, long start) {
    if (isStatisticsEnabled()) {
      if (result) {
        this.statistics.increaseCachePuts(1L);
        this.statistics.addPutTimeNanos(System.nanoTime() - start);
      } 
      if (isHit) {
        this.statistics.increaseCacheHits(1L);
      } else {
        this.statistics.increaseCacheMisses(1L);
      } 
    } 
  }
  
  protected void publishEvent(CacheEventContext cacheEventContext) {
    if (isEventsEnabled()) {
      cacheEventContext.setCacheName(this.name);
      if (this.eventsBatchingEnabled) {
        CacheEventDataImpl cacheEventData = new CacheEventDataImpl(this.name, cacheEventContext.getEventType(), cacheEventContext.getDataKey(), cacheEventContext.getDataValue(), cacheEventContext.getDataOldValue(), cacheEventContext.isOldValueAvailable());
        Set<CacheEventData> cacheEventDataSet = (Set)this.batchEvent.remove(cacheEventContext.getEventType());
        if (cacheEventDataSet == null) {
          cacheEventDataSet = new HashSet<CacheEventData>();
          this.batchEvent.put(cacheEventContext.getEventType(), cacheEventDataSet);
        } 
        cacheEventDataSet.add(cacheEventData);
      } else {
        this.cacheService.publishEvent(cacheEventContext);
      } 
    } 
  }
  
  protected void publishBatchedEvents(String cacheName, CacheEventType cacheEventType, int orderKey) {
    if (isEventsEnabled()) {
      Set<CacheEventData> cacheEventDatas = (Set)this.batchEvent.remove(cacheEventType);
      if (cacheEventDatas != null)
        this.cacheService.publishEvent(cacheName, new CacheEventSet(cacheEventType, cacheEventDatas), orderKey); 
    } 
  }
  
  protected boolean compare(Object v1, Object v2) {
    if (v1 == null && v2 == null)
      return true; 
    if (v1 == null || v2 == null)
      return false; 
    return v1.equals(v2);
  }
  
  protected R createRecord(long expiryTime) { return (R)createRecord(null, Clock.currentTimeMillis(), expiryTime); }
  
  protected R createRecord(Object value, long expiryTime) { return (R)createRecord(value, Clock.currentTimeMillis(), expiryTime); }
  
  protected R createRecord(Data keyData, Object value, long expirationTime, int completionId) {
    R record = (R)createRecord(value, expirationTime);
    if (isEventsEnabled())
      publishEvent(CacheEventContextUtil.createCacheCreatedEvent(toEventData(keyData), toEventData(value), expirationTime, null, completionId)); 
    return record;
  }
  
  protected void onCreateRecordError(Data key, Object value, long expiryTime, long now, boolean disableWriteThrough, int completionId, String origin, R record, Throwable error) {}
  
  protected R createRecord(Data key, Object value, long expiryTime, long now, boolean disableWriteThrough, int completionId, String origin) {
    R record = (R)createRecord(value, now, expiryTime);
    try {
      doPutRecord(key, record, origin, true);
    } catch (Throwable error) {
      onCreateRecordError(key, value, expiryTime, now, disableWriteThrough, completionId, origin, record, error);
      throw ExceptionUtil.rethrow(error);
    } 
    try {
      if (!disableWriteThrough)
        writeThroughCache(key, value); 
    } catch (Throwable error) {
      R removed = (R)(CacheRecord)this.records.remove(key);
      if (removed != null)
        this.cacheService.eventJournal.writeRemoveEvent(this.eventJournalConfig, this.objectNamespace, this.partitionId, key, removed
            .getValue()); 
      onCreateRecordError(key, value, expiryTime, now, disableWriteThrough, completionId, origin, record, error);
      throw ExceptionUtil.rethrow(error);
    } 
    if (isEventsEnabled())
      publishEvent(CacheEventContextUtil.createCacheCreatedEvent(toEventData(key), toEventData(value), expiryTime, origin, completionId)); 
    return record;
  }
  
  protected R createRecordWithExpiry(Data key, Object value, long expiryTime, long now, boolean disableWriteThrough, int completionId, String origin) {
    if (!CacheRecordFactory.isExpiredAt(expiryTime, now))
      return (R)createRecord(key, value, expiryTime, now, disableWriteThrough, completionId, origin); 
    if (isEventsEnabled())
      publishEvent(CacheEventContextUtil.createCacheCompleteEvent(toEventData(key), -1L, origin, completionId)); 
    return null;
  }
  
  protected R createRecordWithExpiry(Data key, Object value, long expiryTime, long now, boolean disableWriteThrough, int completionId) { return (R)createRecordWithExpiry(key, value, expiryTime, now, disableWriteThrough, completionId, "<NA>"); }
  
  protected R createRecordWithExpiry(Data key, Object value, ExpiryPolicy expiryPolicy, long now, boolean disableWriteThrough, int completionId) { return (R)createRecordWithExpiry(key, value, expiryPolicy, now, disableWriteThrough, completionId, "<NA>"); }
  
  protected R createRecordWithExpiry(Data key, Object value, ExpiryPolicy expiryPolicy, long now, boolean disableWriteThrough, int completionId, String origin) {
    Duration expiryDuration;
    expiryPolicy = getExpiryPolicy(null, expiryPolicy);
    try {
      expiryDuration = expiryPolicy.getExpiryForCreation();
    } catch (Exception e) {
      expiryDuration = Duration.ETERNAL;
    } 
    long expiryTime = getAdjustedExpireTime(expiryDuration, now);
    return (R)createRecordWithExpiry(key, value, expiryTime, now, disableWriteThrough, completionId, origin);
  }
  
  protected void onUpdateRecord(Data key, R record, Object value, Data oldDataValue) { this.cacheService.eventJournal.writeUpdateEvent(this.eventJournalConfig, this.objectNamespace, this.partitionId, key, oldDataValue, value); }
  
  protected void onUpdateRecordError(Data key, R record, Object value, Data newDataValue, Data oldDataValue, Throwable error) {}
  
  protected void onUpdateExpiryPolicy(Data key, R record, Data oldDataExpiryPolicy) {}
  
  protected void onUpdateExpiryPolicyError(Data key, R record, Data oldDataExpiryPolicy) {}
  
  protected void updateRecord(Data key, CacheRecord record, long expiryTime, long now, String origin) {
    record.setExpirationTime(expiryTime);
    invalidateEntry(key, origin);
  }
  
  protected void updateRecord(Data key, R record, Object value, long expiryTime, long now, boolean disableWriteThrough, int completionId, String source, String origin) {
    Data dataOldValue = null;
    Data dataValue = null;
    Object recordValue = value;
    try {
      updateExpiryTime(record, expiryTime);
      if (CacheRecordFactory.isExpiredAt(expiryTime, now)) {
        if (!disableWriteThrough)
          writeThroughCache(key, value); 
      } else {
        switch (null.$SwitchMap$com$hazelcast$config$InMemoryFormat[this.cacheConfig.getInMemoryFormat().ordinal()]) {
          case 1:
            recordValue = toData(value);
            dataValue = (Data)recordValue;
            dataOldValue = toData(record);
            break;
          case 2:
            if (value instanceof Data) {
              recordValue = dataToValue((Data)value);
              dataValue = (Data)value;
            } else {
              dataValue = valueToData(value);
            } 
            dataOldValue = toData(record);
            break;
          case 3:
            recordValue = toData(value);
            dataValue = (Data)recordValue;
            dataOldValue = toData(record);
            break;
          default:
            throw new IllegalArgumentException("Invalid storage format: " + this.cacheConfig.getInMemoryFormat());
        } 
        if (!disableWriteThrough)
          writeThroughCache(key, value); 
        Data eventDataKey = toEventData(key);
        Data eventDataValue = toEventData(dataValue);
        Data eventDataOldValue = toEventData(dataOldValue);
        Data eventDataExpiryPolicy = toEventData(record.getExpiryPolicy());
        updateRecordValue(record, recordValue);
        onUpdateRecord(key, record, value, dataOldValue);
        invalidateEntry(key, source);
        if (isEventsEnabled())
          publishEvent(CacheEventContextUtil.createCacheUpdatedEvent(eventDataKey, eventDataValue, eventDataOldValue, record
                .getCreationTime(), record.getExpirationTime(), record
                .getLastAccessTime(), record.getAccessHit(), origin, completionId, eventDataExpiryPolicy)); 
      } 
    } catch (Throwable error) {
      onUpdateRecordError(key, record, value, dataValue, dataOldValue, error);
      throw ExceptionUtil.rethrow(error);
    } 
  }
  
  private void updateExpiryTime(R record, long expiryTime) {
    if (expiryTime == -1L)
      return; 
    markExpirable(expiryTime);
    record.setExpirationTime(expiryTime);
  }
  
  protected void updateExpiryPolicyOfRecord(Data key, R record, Object expiryPolicy) {
    Object inMemoryExpiryPolicy, inMemoryExpiryPolicy;
    Data dataOldExpiryPolicy = null;
    switch (null.$SwitchMap$com$hazelcast$config$InMemoryFormat[this.cacheConfig.getInMemoryFormat().ordinal()]) {
      case 2:
        inMemoryExpiryPolicy = toValue(expiryPolicy);
        dataOldExpiryPolicy = toData(getExpiryPolicyOrNull(record));
        break;
      case 1:
      case 3:
        inMemoryExpiryPolicy = toData(expiryPolicy);
        dataOldExpiryPolicy = toData(getExpiryPolicyOrNull(record));
        break;
      default:
        throw new IllegalArgumentException("Invalid storage format: " + this.cacheConfig.getInMemoryFormat());
    } 
    try {
      onUpdateExpiryPolicy(key, record, dataOldExpiryPolicy);
      record.setExpiryPolicy(inMemoryExpiryPolicy);
    } catch (Throwable error) {
      onUpdateExpiryPolicyError(key, record, dataOldExpiryPolicy);
      throw ExceptionUtil.rethrow(error);
    } 
  }
  
  protected Object extractExpiryPolicyOfRecord(CacheRecord record) {
    Object policyData = record.getExpiryPolicy();
    if (policyData == null)
      return null; 
    switch (null.$SwitchMap$com$hazelcast$config$InMemoryFormat[this.cacheConfig.getInMemoryFormat().ordinal()]) {
      case 1:
      case 3:
        return policyData;
      case 2:
        return toValue(policyData);
    } 
    throw new IllegalArgumentException("Invalid storage format: " + this.cacheConfig.getInMemoryFormat());
  }
  
  protected void updateRecordValue(R record, Object recordValue) { record.setValue(recordValue); }
  
  protected boolean updateRecordWithExpiry(Data key, Object value, R record, long expiryTime, long now, boolean disableWriteThrough, int completionId, String source, String origin) {
    updateRecord(key, record, value, expiryTime, now, disableWriteThrough, completionId, source, origin);
    return (processExpiredEntry(key, record, expiryTime, now, source) != null);
  }
  
  protected boolean updateRecordWithExpiry(Data key, Object value, R record, long expiryTime, long now, boolean disableWriteThrough, int completionId) { return updateRecordWithExpiry(key, value, record, expiryTime, now, disableWriteThrough, completionId, "<NA>"); }
  
  protected boolean updateRecordWithExpiry(Data key, Object value, R record, long expiryTime, long now, boolean disableWriteThrough, int completionId, String source) { return updateRecordWithExpiry(key, value, record, expiryTime, now, disableWriteThrough, completionId, source, null); }
  
  protected boolean updateRecordWithExpiry(Data key, Object value, R record, ExpiryPolicy expiryPolicy, long now, boolean disableWriteThrough, int completionId) { return updateRecordWithExpiry(key, value, record, expiryPolicy, now, disableWriteThrough, completionId, "<NA>"); }
  
  protected boolean updateRecordWithExpiry(Data key, Object value, R record, ExpiryPolicy expiryPolicy, long now, boolean disableWriteThrough, int completionId, String source) { return updateRecordWithExpiry(key, value, record, expiryPolicy, now, disableWriteThrough, completionId, source, null); }
  
  protected boolean updateRecordWithExpiry(Data key, Object value, R record, ExpiryPolicy expiryPolicy, long now, boolean disableWriteThrough, int completionId, String source, String origin) {
    expiryPolicy = getExpiryPolicy(record, expiryPolicy);
    long expiryTime = -1L;
    try {
      Duration expiryDuration = expiryPolicy.getExpiryForUpdate();
      if (expiryDuration != null)
        expiryTime = getAdjustedExpireTime(expiryDuration, now); 
    } catch (Exception e) {
      EmptyStatement.ignore(e);
    } 
    return updateRecordWithExpiry(key, value, record, expiryTime, now, disableWriteThrough, completionId, source, origin);
  }
  
  protected void updateRecordWithExpiry(Data key, CacheRecord record, ExpiryPolicy expiryPolicy, long now, String source) {
    expiryPolicy = getExpiryPolicy(record, expiryPolicy);
    long expiryTime = -1L;
    try {
      Duration expiryDuration = expiryPolicy.getExpiryForUpdate();
      if (expiryDuration != null)
        expiryTime = getAdjustedExpireTime(expiryDuration, now); 
    } catch (Exception e) {
      EmptyStatement.ignore(e);
    } 
    updateRecord(key, record, expiryTime, now, source);
  }
  
  protected void onDeleteRecord(Data key, R record, boolean deleted) {}
  
  protected boolean deleteRecord(Data key, int completionId) { return deleteRecord(key, completionId, "<NA>"); }
  
  protected boolean deleteRecord(Data key, int completionId, String source) { return deleteRecord(key, completionId, source, null); }
  
  protected boolean deleteRecord(Data key, int completionId, String source, String origin) {
    removedRecord = null;
    try {
      removedRecord = (R)doRemoveRecord(key, source);
      if (isEventsEnabled()) {
        Data eventDataKey = toEventData(key);
        Data eventDataValue = toEventData(removedRecord);
        publishEvent(CacheEventContextUtil.createCacheRemovedEvent(eventDataKey, eventDataValue, -1L, origin, completionId));
      } 
    } finally {
      onDeleteRecord(key, removedRecord, (removedRecord != null));
    } 
    return (removedRecord != null);
  }
  
  public R readThroughRecord(Data key, long now) {
    Duration expiryDuration;
    Object value = readThroughCache(key);
    if (value == null)
      return null; 
    try {
      expiryDuration = this.defaultExpiryPolicy.getExpiryForCreation();
    } catch (Exception e) {
      expiryDuration = Duration.ETERNAL;
    } 
    long expiryTime = getAdjustedExpireTime(expiryDuration, now);
    if (CacheRecordFactory.isExpiredAt(expiryTime, now))
      return null; 
    return (R)createRecord(key, value, expiryTime, -1);
  }
  
  public Object readThroughCache(Data key) {
    if (isReadThrough() && this.cacheLoader != null)
      try {
        Object o = dataToValue(key);
        return this.cacheLoader.load(o);
      } catch (Exception e) {
        if (!(e instanceof CacheLoaderException))
          throw new CacheLoaderException("Exception in CacheLoader during load", e); 
        throw (CacheLoaderException)e;
      }  
    return null;
  }
  
  public void writeThroughCache(Data key, Object value) throws CacheWriterException {
    if (isWriteThrough() && this.cacheWriter != null)
      try {
        Object objKey = dataToValue(key);
        Object objValue = toValue(value);
        this.cacheWriter.write(new CacheEntry(objKey, objValue));
      } catch (Exception e) {
        if (!(e instanceof CacheWriterException))
          throw new CacheWriterException("Exception in CacheWriter during write", e); 
        throw (CacheWriterException)e;
      }  
  }
  
  protected void deleteCacheEntry(Data key) { deleteCacheEntry(key, CallerProvenance.NOT_WAN); }
  
  protected void deleteCacheEntry(Data key, CallerProvenance provenance) {
    if (persistenceEnabledFor(provenance) && isWriteThrough() && this.cacheWriter != null)
      try {
        Object objKey = dataToValue(key);
        this.cacheWriter.delete(objKey);
      } catch (Exception e) {
        if (!(e instanceof CacheWriterException))
          throw new CacheWriterException("Exception in CacheWriter during delete", e); 
        throw (CacheWriterException)e;
      }  
  }
  
  @SuppressFBWarnings({"WMI_WRONG_MAP_ITERATOR"})
  protected void deleteAllCacheEntry(Set<Data> keys) {
    if (isWriteThrough() && this.cacheWriter != null && keys != null && !keys.isEmpty()) {
      keysToDelete = MapUtil.createHashMap(keys.size());
      for (Data key : keys) {
        Object localKeyObj = dataToValue(key);
        keysToDelete.put(localKeyObj, key);
      } 
      keysObject = keysToDelete.keySet();
      try {
        this.cacheWriter.deleteAll(keysObject);
      } catch (Exception e) {
        if (!(e instanceof CacheWriterException))
          throw new CacheWriterException("Exception in CacheWriter during deleteAll", e); 
        throw (CacheWriterException)e;
      } finally {
        for (Object undeletedKey : keysObject) {
          Data undeletedKeyData = (Data)keysToDelete.get(undeletedKey);
          keys.remove(undeletedKeyData);
        } 
      } 
    } 
  }
  
  protected Map<Data, Object> loadAllCacheEntry(Set<Data> keys) {
    if (this.cacheLoader != null) {
      Map<Object, Object> loaded, keysToLoad = MapUtil.createHashMap(keys.size());
      for (Data key : keys) {
        Object localKeyObj = dataToValue(key);
        keysToLoad.put(localKeyObj, key);
      } 
      try {
        loaded = this.cacheLoader.loadAll(keysToLoad.keySet());
      } catch (Throwable e) {
        if (!(e instanceof CacheLoaderException))
          throw new CacheLoaderException("Exception in CacheLoader during loadAll", e); 
        throw (CacheLoaderException)e;
      } 
      Map<Data, Object> result = MapUtil.createHashMap(keysToLoad.size());
      for (Map.Entry<Object, Data> entry : keysToLoad.entrySet()) {
        Object keyObj = entry.getKey();
        Object valueObject = loaded.get(keyObj);
        Data keyData = (Data)entry.getValue();
        result.put(keyData, valueObject);
      } 
      return result;
    } 
    return null;
  }
  
  public CacheRecord getRecord(Data key) { return (CacheRecord)this.records.get(key); }
  
  public void putRecord(Data key, CacheRecord record, boolean updateJournal) {
    evictIfRequired();
    doPutRecord(key, record, "<NA>", updateJournal);
  }
  
  protected R doPutRecord(Data key, R record, String source, boolean updateJournal) {
    markExpirable(record.getExpirationTime());
    R oldRecord = (R)(CacheRecord)this.records.put(key, record);
    if (updateJournal)
      if (oldRecord != null) {
        this.cacheService.eventJournal.writeUpdateEvent(this.eventJournalConfig, this.objectNamespace, this.partitionId, key, oldRecord
            .getValue(), record.getValue());
      } else {
        this.cacheService.eventJournal.writeCreatedEvent(this.eventJournalConfig, this.objectNamespace, this.partitionId, key, record
            .getValue());
      }  
    invalidateEntry(key, source);
    return oldRecord;
  }
  
  public CacheRecord removeRecord(Data key) { return doRemoveRecord(key, "<NA>"); }
  
  protected R doRemoveRecord(Data key, String source) {
    R removedRecord = (R)(CacheRecord)this.records.remove(key);
    if (removedRecord != null) {
      this.cacheService.eventJournal.writeRemoveEvent(this.eventJournalConfig, this.objectNamespace, this.partitionId, key, removedRecord
          .getValue());
      invalidateEntry(key, source);
    } 
    return removedRecord;
  }
  
  protected void onGet(Data key, ExpiryPolicy expiryPolicy, Object value, R record) {}
  
  protected void onGetError(Data key, ExpiryPolicy expiryPolicy, Object value, R record, Throwable error) {}
  
  public Object get(Data key, ExpiryPolicy expiryPolicy) {
    long start = isStatisticsEnabled() ? System.nanoTime() : 0L;
    long now = Clock.currentTimeMillis();
    Object value = null;
    R record = (R)(CacheRecord)this.records.get(key);
    expiryPolicy = getExpiryPolicy(record, expiryPolicy);
    boolean isExpired = processExpiredEntry(key, record, now);
    try {
      if (recordNotExistOrExpired(record, isExpired)) {
        if (isStatisticsEnabled())
          this.statistics.increaseCacheMisses(1L); 
        value = readThroughCache(key);
        if (value == null) {
          if (isStatisticsEnabled())
            this.statistics.addGetTimeNanos(System.nanoTime() - start); 
          return null;
        } 
        record = (R)createRecordWithExpiry(key, value, expiryPolicy, now, true, -1);
      } else {
        value = recordToValue(record);
        onRecordAccess(key, record, expiryPolicy, now);
        if (isStatisticsEnabled())
          this.statistics.increaseCacheHits(1L); 
      } 
      if (isStatisticsEnabled())
        this.statistics.addGetTimeNanos(System.nanoTime() - start); 
      onGet(key, expiryPolicy, value, record);
      return value;
    } catch (Throwable error) {
      onGetError(key, expiryPolicy, value, record, error);
      throw ExceptionUtil.rethrow(error);
    } 
  }
  
  public void evictExpiredEntries(int expirationPercentage) {
    long now = Clock.currentTimeMillis();
    int maxIterationCount = getMaxIterationCount(size(), expirationPercentage);
    int evictedCount = 0;
    int maxRetry = 3;
    int loop = 0;
    while (loop < maxRetry) {
      evictedCount += evictExpiredInternal(maxIterationCount, now);
      if (evictedCount >= maxIterationCount)
        break; 
      loop++;
    } 
  }
  
  protected void initExpirationIterator() {
    if (this.expirationIterator == null || !this.expirationIterator.hasNext())
      this.expirationIterator = this.records.entrySet().iterator(); 
  }
  
  private int evictExpiredInternal(int maxIterationCount, long now) {
    initExpirationIterator();
    int processedCount = 0;
    LinkedList<Map.Entry<Data, R>> records = new LinkedList<Map.Entry<Data, R>>();
    while (this.expirationIterator.hasNext() && processedCount < maxIterationCount) {
      Map.Entry<Data, R> record = (Map.Entry)this.expirationIterator.next();
      records.add(record);
      processedCount++;
    } 
    int evictedCount = 0;
    while (!records.isEmpty()) {
      Map.Entry<Data, R> record = (Map.Entry)records.poll();
      Data key = (Data)record.getKey();
      R value = (R)(CacheRecord)record.getValue();
      boolean expired = evictIfExpired(key, value, now);
      if (expired) {
        accumulateOrSendExpiredKeysToBackup(key, value);
        evictedCount++;
      } 
    } 
    return evictedCount;
  }
  
  private int getMaxIterationCount(int size, int percentage) {
    int defaultMaxIterationCount = 100;
    float oneHundred = 100.0F;
    float maxIterationCount = size * percentage / 100.0F;
    if (maxIterationCount <= 100.0F)
      return 100; 
    return Math.round(maxIterationCount);
  }
  
  public boolean contains(Data key) {
    long now = Clock.currentTimeMillis();
    R record = (R)(CacheRecord)this.records.get(key);
    boolean isExpired = processExpiredEntry(key, record, now);
    return (record != null && !isExpired);
  }
  
  protected void onPut(Data key, Object value, ExpiryPolicy expiryPolicy, String source, boolean getValue, boolean disableWriteThrough, R record, Object oldValue, boolean isExpired, boolean isNewPut, boolean isSaveSucceed) {}
  
  protected void onPutError(Data key, Object value, ExpiryPolicy expiryPolicy, String source, boolean getValue, boolean disableWriteThrough, R record, Object oldValue, boolean wouldBeNewPut, Throwable error) {}
  
  protected Object put(Data key, Object value, ExpiryPolicy expiryPolicy, String source, boolean getValue, boolean disableWriteThrough, int completionId) {
    long now = Clock.currentTimeMillis();
    long start = isStatisticsEnabled() ? System.nanoTime() : 0L;
    boolean isOnNewPut = false;
    Object oldValue = null;
    R record = (R)(CacheRecord)this.records.get(key);
    expiryPolicy = getExpiryPolicy(record, expiryPolicy);
    boolean isExpired = processExpiredEntry(key, record, now, source);
    try {
      boolean isSaveSucceed;
      if (recordNotExistOrExpired(record, isExpired)) {
        isOnNewPut = true;
        record = (R)createRecordWithExpiry(key, value, expiryPolicy, now, disableWriteThrough, completionId, source);
        isSaveSucceed = (record != null);
      } else {
        if (getValue)
          oldValue = toValue(record); 
        isSaveSucceed = updateRecordWithExpiry(key, value, record, expiryPolicy, now, disableWriteThrough, completionId, source);
      } 
      onPut(key, value, expiryPolicy, source, getValue, disableWriteThrough, record, oldValue, isExpired, isOnNewPut, isSaveSucceed);
      updateGetAndPutStat(isSaveSucceed, getValue, (oldValue == null), start);
      if (getValue)
        return oldValue; 
      return record;
    } catch (Throwable error) {
      onPutError(key, value, expiryPolicy, source, getValue, disableWriteThrough, record, oldValue, isOnNewPut, error);
      throw ExceptionUtil.rethrow(error);
    } 
  }
  
  protected Object put(Data key, Object value, ExpiryPolicy expiryPolicy, String source, boolean getValue, int completionId) { return put(key, value, expiryPolicy, source, getValue, false, completionId); }
  
  public R put(Data key, Object value, ExpiryPolicy expiryPolicy, String source, int completionId) { return (R)(CacheRecord)put(key, value, expiryPolicy, source, false, false, completionId); }
  
  public Object getAndPut(Data key, Object value, ExpiryPolicy expiryPolicy, String source, int completionId) { return put(key, value, expiryPolicy, source, true, false, completionId); }
  
  protected void onPutIfAbsent(Data key, Object value, ExpiryPolicy expiryPolicy, String source, boolean disableWriteThrough, R record, boolean isExpired, boolean isSaveSucceed) {}
  
  protected void onPutIfAbsentError(Data key, Object value, ExpiryPolicy expiryPolicy, String source, boolean disableWriteThrough, R record, Throwable error) {}
  
  protected boolean putIfAbsent(Data key, Object value, ExpiryPolicy expiryPolicy, String source, boolean disableWriteThrough, int completionId) {
    long now = Clock.currentTimeMillis();
    long start = isStatisticsEnabled() ? System.nanoTime() : 0L;
    boolean saved = false;
    R record = (R)(CacheRecord)this.records.get(key);
    expiryPolicy = getExpiryPolicy(record, expiryPolicy);
    boolean isExpired = processExpiredEntry(key, record, now, source);
    boolean cacheMiss = recordNotExistOrExpired(record, isExpired);
    try {
      if (cacheMiss) {
        saved = (createRecordWithExpiry(key, value, expiryPolicy, now, disableWriteThrough, completionId, source) != null);
      } else if (isEventsEnabled()) {
        publishEvent(CacheEventContextUtil.createCacheCompleteEvent(toEventData(key), completionId));
      } 
      onPutIfAbsent(key, value, expiryPolicy, source, disableWriteThrough, record, isExpired, saved);
      if (isStatisticsEnabled()) {
        if (saved) {
          this.statistics.increaseCachePuts();
          this.statistics.addPutTimeNanos(System.nanoTime() - start);
        } 
        if (cacheMiss) {
          this.statistics.increaseCacheMisses();
        } else {
          this.statistics.increaseCacheHits();
        } 
      } 
      return saved;
    } catch (Throwable error) {
      onPutIfAbsentError(key, value, expiryPolicy, source, disableWriteThrough, record, error);
      throw ExceptionUtil.rethrow(error);
    } 
  }
  
  public boolean putIfAbsent(Data key, Object value, ExpiryPolicy expiryPolicy, String source, int completionId) { return putIfAbsent(key, value, expiryPolicy, source, false, completionId); }
  
  protected void onReplace(Data key, Object oldValue, Object newValue, ExpiryPolicy expiryPolicy, String source, boolean getValue, R record, boolean isExpired, boolean replaced) {}
  
  protected void onReplaceError(Data key, Object oldValue, Object newValue, ExpiryPolicy expiryPolicy, String source, boolean getValue, R record, boolean isExpired, boolean replaced, Throwable error) {}
  
  public boolean replace(Data key, Object value, ExpiryPolicy expiryPolicy, String source, int completionId) {
    long now = Clock.currentTimeMillis();
    long start = isStatisticsEnabled() ? System.nanoTime() : 0L;
    boolean replaced = false;
    R record = (R)(CacheRecord)this.records.get(key);
    expiryPolicy = getExpiryPolicy(record, expiryPolicy);
    boolean isExpired = (record != null && record.isExpiredAt(now));
    try {
      if (recordNotExistOrExpired(record, isExpired)) {
        if (isEventsEnabled())
          publishEvent(CacheEventContextUtil.createCacheCompleteEvent(toEventData(key), completionId)); 
      } else {
        replaced = updateRecordWithExpiry(key, value, record, expiryPolicy, now, false, completionId, source);
      } 
      onReplace(key, null, value, expiryPolicy, source, false, record, isExpired, replaced);
      if (isStatisticsEnabled())
        if (replaced) {
          this.statistics.increaseCachePuts(1L);
          this.statistics.increaseCacheHits(1L);
          this.statistics.addPutTimeNanos(System.nanoTime() - start);
        } else {
          this.statistics.increaseCacheMisses(1L);
        }  
      return replaced;
    } catch (Throwable error) {
      onReplaceError(key, null, value, expiryPolicy, source, false, record, isExpired, replaced, error);
      throw ExceptionUtil.rethrow(error);
    } 
  }
  
  public boolean replace(Data key, Object oldValue, Object newValue, ExpiryPolicy expiryPolicy, String source, int completionId) {
    long now = Clock.currentTimeMillis();
    long start = isStatisticsEnabled() ? System.nanoTime() : 0L;
    boolean isHit = false;
    boolean replaced = false;
    R record = (R)(CacheRecord)this.records.get(key);
    expiryPolicy = getExpiryPolicy(record, expiryPolicy);
    boolean isExpired = (record != null && record.isExpiredAt(now));
    try {
      if (record != null && !isExpired) {
        isHit = true;
        Object currentValue = toStorageValue(record);
        if (compare(currentValue, toStorageValue(oldValue))) {
          replaced = updateRecordWithExpiry(key, newValue, record, expiryPolicy, now, false, completionId, source);
        } else {
          onRecordAccess(key, record, expiryPolicy, now);
        } 
      } 
      if (!replaced && 
        isEventsEnabled())
        publishEvent(CacheEventContextUtil.createCacheCompleteEvent(toEventData(key), completionId)); 
      onReplace(key, oldValue, newValue, expiryPolicy, source, false, record, isExpired, replaced);
      updateReplaceStat(replaced, isHit, start);
      return replaced;
    } catch (Throwable error) {
      onReplaceError(key, oldValue, newValue, expiryPolicy, source, false, record, isExpired, replaced, error);
      throw ExceptionUtil.rethrow(error);
    } 
  }
  
  public Object getAndReplace(Data key, Object value, ExpiryPolicy expiryPolicy, String source, int completionId) {
    long now = Clock.currentTimeMillis();
    long start = isStatisticsEnabled() ? System.nanoTime() : 0L;
    boolean replaced = false;
    R record = (R)(CacheRecord)this.records.get(key);
    expiryPolicy = getExpiryPolicy(record, expiryPolicy);
    boolean isExpired = (record != null && record.isExpiredAt(now));
    try {
      Object obj = toValue(record);
      if (recordNotExistOrExpired(record, isExpired)) {
        obj = null;
        if (isEventsEnabled())
          publishEvent(CacheEventContextUtil.createCacheCompleteEvent(toEventData(key), completionId)); 
      } else {
        replaced = updateRecordWithExpiry(key, value, record, expiryPolicy, now, false, completionId, source);
      } 
      onReplace(key, null, value, expiryPolicy, source, false, record, isExpired, replaced);
      if (isStatisticsEnabled()) {
        this.statistics.addGetTimeNanos(System.nanoTime() - start);
        if (obj != null) {
          this.statistics.increaseCacheHits(1L);
          this.statistics.increaseCachePuts(1L);
          this.statistics.addPutTimeNanos(System.nanoTime() - start);
        } else {
          this.statistics.increaseCacheMisses(1L);
        } 
      } 
      return obj;
    } catch (Throwable error) {
      onReplaceError(key, null, value, expiryPolicy, source, false, record, isExpired, replaced, error);
      throw ExceptionUtil.rethrow(error);
    } 
  }
  
  public boolean setExpiryPolicy(Collection<Data> keys, Object expiryPolicy, String source) {
    if (this.nodeEngine.getClusterService().getClusterVersion().isLessThan(Versions.V3_11))
      throw new UnsupportedOperationException("Modifying expiry policy is available when cluster version is at least 3.11"); 
    ExpiryPolicy expiryPolicyInstance = null;
    if (expiryPolicy instanceof Data)
      expiryPolicyInstance = (ExpiryPolicy)toValue(expiryPolicy); 
    boolean atLeastOneKey = false;
    long now = System.currentTimeMillis();
    for (Data key : keys) {
      R record = (R)(CacheRecord)this.records.get(key);
      if (record != null && !processExpiredEntry(key, record, now)) {
        updateExpiryPolicyOfRecord(key, record, expiryPolicy);
        updateRecordWithExpiry(key, record, expiryPolicyInstance, System.currentTimeMillis(), source);
        atLeastOneKey = true;
      } 
    } 
    return atLeastOneKey;
  }
  
  public Object getExpiryPolicy(Data key) {
    CacheRecord record = getRecord(key);
    if (record != null)
      return extractExpiryPolicyOfRecord(record); 
    return null;
  }
  
  protected void onRemove(Data key, Object value, String source, boolean getValue, R record, boolean removed) {}
  
  protected void onRemoveError(Data key, Object value, String source, boolean getValue, R record, boolean removed, Throwable error) {}
  
  public boolean remove(Data key, String source, String origin, int completionId) { return remove(key, source, origin, completionId, CallerProvenance.NOT_WAN); }
  
  public boolean remove(Data key, String source, String origin, int completionId, CallerProvenance provenance) {
    long now = Clock.currentTimeMillis();
    long start = isStatisticsEnabled() ? System.nanoTime() : 0L;
    deleteCacheEntry(key, provenance);
    R record = (R)(CacheRecord)this.records.get(key);
    boolean removed = false;
    try {
      if (recordNotExistOrExpired(record, now)) {
        if (isEventsEnabled())
          publishEvent(CacheEventContextUtil.createCacheCompleteEvent(toEventData(key), -1L, origin, completionId)); 
      } else {
        removed = deleteRecord(key, completionId, source, origin);
      } 
      onRemove(key, null, source, false, record, removed);
      if (removed && isStatisticsEnabled()) {
        this.statistics.increaseCacheRemovals(1L);
        this.statistics.addRemoveTimeNanos(System.nanoTime() - start);
      } 
      return removed;
    } catch (Throwable error) {
      onRemoveError(key, null, source, false, record, removed, error);
      throw ExceptionUtil.rethrow(error);
    } 
  }
  
  public InvalidationQueue<ExpiredKey> getExpiredKeysQueue() { return this.expiredKeys; }
  
  public boolean remove(Data key, Object value, String source, String origin, int completionId) {
    long now = Clock.currentTimeMillis();
    long start = System.nanoTime();
    R record = (R)(CacheRecord)this.records.get(key);
    int hitCount = 0;
    boolean removed = false;
    try {
      if (recordNotExistOrExpired(record, now)) {
        if (isStatisticsEnabled())
          this.statistics.increaseCacheMisses(1L); 
      } else {
        hitCount++;
        if (compare(toStorageValue(record), toStorageValue(value))) {
          deleteCacheEntry(key);
          removed = deleteRecord(key, completionId, source, origin);
        } else {
          long expiryTime = onRecordAccess(key, record, this.defaultExpiryPolicy, now);
          processExpiredEntry(key, record, expiryTime, now, source, origin);
        } 
      } 
      if (!removed && 
        isEventsEnabled())
        publishEvent(CacheEventContextUtil.createCacheCompleteEvent(toEventData(key), -1L, origin, completionId)); 
      onRemove(key, value, source, false, record, removed);
      updateRemoveStatistics(removed, hitCount, start);
      return removed;
    } catch (Throwable error) {
      onRemoveError(key, null, source, false, record, removed, error);
      throw ExceptionUtil.rethrow(error);
    } 
  }
  
  private void updateRemoveStatistics(boolean result, int hitCount, long start) {
    if (result && isStatisticsEnabled()) {
      this.statistics.increaseCacheRemovals(1L);
      this.statistics.addRemoveTimeNanos(System.nanoTime() - start);
      if (hitCount == 1) {
        this.statistics.increaseCacheHits(hitCount);
      } else {
        this.statistics.increaseCacheMisses(1L);
      } 
    } 
  }
  
  protected void markExpirable(long expiryTime) {
    if (expiryTime > 0L && expiryTime < Float.MAX_VALUE)
      this.hasEntryWithExpiration = true; 
    if (isPrimary() && this.hasEntryWithExpiration)
      this.cacheService.getExpirationManager().scheduleExpirationTask(); 
  }
  
  public Object getAndRemove(Data key, String source, int completionId) { return getAndRemove(key, source, completionId, null); }
  
  public Object getAndRemove(Data key, String source, int completionId, String origin) {
    long now = Clock.currentTimeMillis();
    long start = isStatisticsEnabled() ? System.nanoTime() : 0L;
    deleteCacheEntry(key);
    R record = (R)(CacheRecord)this.records.get(key);
    boolean removed = false;
    try {
      Object obj;
      if (recordNotExistOrExpired(record, now)) {
        obj = null;
        if (isEventsEnabled())
          publishEvent(CacheEventContextUtil.createCacheCompleteEvent(toEventData(key), -1L, origin, completionId)); 
      } else {
        obj = toValue(record);
        removed = deleteRecord(key, completionId, source, origin);
      } 
      onRemove(key, null, source, false, record, removed);
      if (isStatisticsEnabled()) {
        this.statistics.addGetTimeNanos(System.nanoTime() - start);
        if (obj != null) {
          this.statistics.increaseCacheHits(1L);
          this.statistics.increaseCacheRemovals(1L);
          this.statistics.addRemoveTimeNanos(System.nanoTime() - start);
        } else {
          this.statistics.increaseCacheMisses(1L);
        } 
      } 
      return obj;
    } catch (Throwable error) {
      onRemoveError(key, null, source, false, record, removed, error);
      throw ExceptionUtil.rethrow(error);
    } 
  }
  
  public MapEntries getAll(Set<Data> keySet, ExpiryPolicy expiryPolicy) {
    MapEntries result = new MapEntries(keySet.size());
    for (Data key : keySet) {
      Object value = get(key, expiryPolicy);
      if (value != null)
        result.add(key, toHeapData(value)); 
    } 
    return result;
  }
  
  public void removeAll(Set<Data> keys, int completionId) {
    now = Clock.currentTimeMillis();
    localKeys = new HashSet<Data>(keys.isEmpty() ? this.records.keySet() : keys);
    try {
      deleteAllCacheEntry(localKeys);
    } finally {
      Set<Data> keysToClean = new HashSet<Data>(keys.isEmpty() ? this.records.keySet() : keys);
      for (Data key : keysToClean) {
        this.eventsBatchingEnabled = true;
        R record = (R)(CacheRecord)this.records.get(key);
        if (localKeys.contains(key) && record != null) {
          boolean isExpired = processExpiredEntry(key, record, now);
          if (!isExpired) {
            deleteRecord(key, -1);
            if (isStatisticsEnabled())
              this.statistics.increaseCacheRemovals(1L); 
          } 
          keys.add(key);
        } else {
          keys.remove(key);
        } 
        this.eventsBatchingEnabled = false;
      } 
      int orderKey = keys.hashCode();
      publishBatchedEvents(this.name, CacheEventType.REMOVED, orderKey);
      if (isEventsEnabled())
        publishEvent(CacheEventContextUtil.createCacheCompleteEvent(completionId)); 
    } 
  }
  
  public Set<Data> loadAll(Set<Data> keys, boolean replaceExistingValues) {
    Map<Data, Object> loaded = loadAllCacheEntry(keys);
    if (loaded == null || loaded.isEmpty())
      return Collections.emptySet(); 
    Set<Data> keysLoaded = SetUtil.createHashSet(loaded.size());
    if (replaceExistingValues) {
      for (Map.Entry<Data, Object> entry : loaded.entrySet()) {
        Data key = (Data)entry.getKey();
        Object value = entry.getValue();
        if (value != null) {
          put(key, value, null, "<NA>", false, true, -1);
          keysLoaded.add(key);
        } 
      } 
    } else {
      for (Map.Entry<Data, Object> entry : loaded.entrySet()) {
        Data key = (Data)entry.getKey();
        Object value = entry.getValue();
        if (value != null) {
          boolean hasPut = putIfAbsent(key, value, null, "<NA>", true, -1);
          if (hasPut)
            keysLoaded.add(key); 
        } 
      } 
    } 
    return keysLoaded;
  }
  
  public CacheRecord merge(SplitBrainMergeTypes.CacheMergeTypes mergingEntry, SplitBrainMergePolicy<Data, SplitBrainMergeTypes.CacheMergeTypes> mergePolicy, CallerProvenance callerProvenance) {
    long now = Clock.currentTimeMillis();
    long start = isStatisticsEnabled() ? System.nanoTime() : 0L;
    injectDependencies(mergingEntry);
    injectDependencies(mergePolicy);
    boolean merged = false;
    Data key = (Data)mergingEntry.getKey();
    long expiryTime = mergingEntry.getExpirationTime();
    R record = (R)(CacheRecord)this.records.get(key);
    boolean isExpired = processExpiredEntry(key, record, now);
    boolean disableWriteThrough = !persistenceEnabledFor(callerProvenance);
    if (record == null || isExpired) {
      Data newValue = (Data)mergePolicy.merge(mergingEntry, null);
      if (newValue != null) {
        record = (R)createRecordWithExpiry(key, newValue, expiryTime, now, disableWriteThrough, -1);
        merged = (record != null);
      } 
    } else {
      Data oldValue = this.ss.toData(record.getValue());
      SplitBrainMergeTypes.CacheMergeTypes existingEntry = MergingValueFactory.createMergingEntry(this.ss, key, oldValue, record);
      Data newValue = (Data)mergePolicy.merge(mergingEntry, existingEntry);
      merged = updateWithMergingValue(key, oldValue, newValue, record, expiryTime, now, disableWriteThrough);
    } 
    if (merged && isStatisticsEnabled()) {
      this.statistics.increaseCachePuts(1L);
      this.statistics.addPutTimeNanos(System.nanoTime() - start);
    } 
    return merged ? record : null;
  }
  
  public CacheRecord merge(CacheEntryView<Data, Data> cacheEntryView, CacheMergePolicy mergePolicy, String caller, String origin, int completionId, CallerProvenance callerProvenance) {
    long now = Clock.currentTimeMillis();
    long start = isStatisticsEnabled() ? System.nanoTime() : 0L;
    boolean merged = false;
    Data key = (Data)cacheEntryView.getKey();
    Data value = (Data)cacheEntryView.getValue();
    long expiryTime = cacheEntryView.getExpirationTime();
    R record = (R)(CacheRecord)this.records.get(key);
    boolean isExpired = processExpiredEntry(key, record, now);
    boolean disableWriteThrough = !persistenceEnabledFor(callerProvenance);
    if (record == null || isExpired) {
      Object newValue = mergePolicy.merge(this.name, createCacheEntryView(key, value, cacheEntryView

            
            .getCreationTime(), cacheEntryView
            .getExpirationTime(), cacheEntryView
            .getLastAccessTime(), cacheEntryView
            .getAccessHit(), cacheEntryView
            .getExpiryPolicy(), mergePolicy), null);
      if (newValue != null) {
        record = (R)createRecordWithExpiry(key, newValue, expiryTime, now, disableWriteThrough, -1);
        merged = (record != null);
      } 
    } else {
      Object oldValue = record.getValue();
      Object newValue = mergePolicy.merge(this.name, 
          createCacheEntryView(key, value, cacheEntryView

            
            .getCreationTime(), cacheEntryView
            .getExpirationTime(), cacheEntryView
            .getLastAccessTime(), cacheEntryView
            .getAccessHit(), cacheEntryView
            .getExpiryPolicy(), mergePolicy), 
          
          createCacheEntryView(key, oldValue, cacheEntryView

            
            .getCreationTime(), record
            .getExpirationTime(), record
            .getLastAccessTime(), record
            .getAccessHit(), record
            .getExpiryPolicy(), mergePolicy));
      merged = updateWithMergingValue(key, oldValue, newValue, record, expiryTime, now, disableWriteThrough);
    } 
    if (merged && isStatisticsEnabled()) {
      this.statistics.increaseCachePuts(1L);
      this.statistics.addPutTimeNanos(System.nanoTime() - start);
    } 
    return merged ? record : null;
  }
  
  private boolean updateWithMergingValue(Data key, Object existingValue, Object mergingValue, R record, long expiryTime, long now, boolean disableWriteThrough) {
    if (this.valueComparator.isEqual(existingValue, mergingValue, this.ss)) {
      updateExpiryTime(record, expiryTime);
      processExpiredEntry(key, record, now);
      return true;
    } 
    return updateRecordWithExpiry(key, mergingValue, record, -1L, now, disableWriteThrough, -1);
  }
  
  private Object getExpiryPolicyOrNull(R record) {
    if (record != null)
      return record.getExpiryPolicy(); 
    return null;
  }
  
  private CacheEntryView createCacheEntryView(Object key, Object value, long creationTime, long expirationTime, long lastAccessTime, long accessHit, Object expiryPolicy, CacheMergePolicy mergePolicy) {
    SerializationService ss = (mergePolicy instanceof com.hazelcast.cache.StorageTypeAwareCacheMergePolicy) ? null : this.ss;
    return new LazyCacheEntryView(key, value, creationTime, expirationTime, lastAccessTime, accessHit, expiryPolicy, ss);
  }
  
  public CacheKeyIterationResult fetchKeys(int tableIndex, int size) { return this.records.fetchKeys(tableIndex, size); }
  
  public CacheEntryIterationResult fetchEntries(int tableIndex, int size) { return this.records.fetchEntries(tableIndex, size); }
  
  public Object invoke(Data key, EntryProcessor entryProcessor, Object[] arguments, int completionId) {
    long now = Clock.currentTimeMillis();
    long start = isStatisticsEnabled() ? System.nanoTime() : 0L;
    R record = (R)(CacheRecord)this.records.get(key);
    boolean isExpired = processExpiredEntry(key, record, now);
    if (isExpired)
      record = null; 
    if (isStatisticsEnabled()) {
      if (recordNotExistOrExpired(record, isExpired)) {
        this.statistics.increaseCacheMisses(1L);
      } else {
        this.statistics.increaseCacheHits(1L);
      } 
      this.statistics.addGetTimeNanos(System.nanoTime() - start);
    } 
    CacheEntryProcessorEntry entry = createCacheEntryProcessorEntry(key, record, now, completionId);
    injectDependencies(entryProcessor);
    Object result = entryProcessor.process(entry, arguments);
    entry.applyChanges();
    return result;
  }
  
  private boolean recordNotExistOrExpired(R record, boolean isExpired) { return (record == null || isExpired); }
  
  private boolean recordNotExistOrExpired(R record, long now) { return (record == null || record.isExpiredAt(now)); }
  
  public int size() { return this.records.size(); }
  
  public CacheStatisticsImpl getCacheStats() { return this.statistics; }
  
  public CacheConfig getConfig() { return this.cacheConfig; }
  
  public String getName() { return this.name; }
  
  public Map<Data, CacheRecord> getReadOnlyRecords() { return Collections.unmodifiableMap(this.records); }
  
  public void clear() {
    reset();
    destroyEventJournal();
  }
  
  protected void destroyEventJournal() { this.cacheService.eventJournal.destroy(this.objectNamespace, this.partitionId); }
  
  public void reset() { this.records.clear(); }
  
  public void close(boolean onShutdown) {
    clear();
    closeListeners();
  }
  
  public void destroy() {
    clear();
    closeListeners();
    onDestroy();
  }
  
  public void destroyInternals() {
    reset();
    closeListeners();
    onDestroy();
  }
  
  protected void onDestroy() {}
  
  protected void closeListeners() {
    InternalEventService eventService = (InternalEventService)this.cacheService.getNodeEngine().getEventService();
    Collection<EventRegistration> candidates = eventService.getRegistrations("hz:impl:cacheService", this.name);
    for (EventRegistration eventRegistration : candidates)
      eventService.close(eventRegistration); 
  }
  
  public boolean isWanReplicationEnabled() { return this.wanReplicationEnabled; }
  
  public ObjectNamespace getObjectNamespace() { return this.objectNamespace; }
  
  public int getPartitionId() { return this.partitionId; }
  
  protected abstract CRM createRecordCacheMap();
  
  protected abstract CacheEntryProcessorEntry createCacheEntryProcessorEntry(Data paramData, R paramR, long paramLong, int paramInt);
  
  protected abstract R createRecord(Object paramObject, long paramLong1, long paramLong2);
  
  protected abstract Data valueToData(Object paramObject);
  
  protected abstract Object dataToValue(Data paramData);
  
  protected abstract Object recordToValue(R paramR);
  
  protected abstract Data recordToData(R paramR);
  
  protected abstract Data toHeapData(Object paramObject);
}
