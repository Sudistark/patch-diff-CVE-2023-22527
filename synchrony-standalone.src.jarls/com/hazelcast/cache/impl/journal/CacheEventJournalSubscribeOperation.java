package com.hazelcast.cache.impl.journal;

import com.hazelcast.cache.impl.CacheDataSerializerHook;
import com.hazelcast.cache.impl.CacheService;
import com.hazelcast.internal.journal.EventJournalInitialSubscriberState;
import com.hazelcast.nio.serialization.IdentifiedDataSerializable;
import com.hazelcast.spi.ObjectNamespace;
import com.hazelcast.spi.PartitionAwareOperation;
import com.hazelcast.spi.ReadonlyOperation;
import com.hazelcast.spi.impl.AbstractNamedOperation;

public class CacheEventJournalSubscribeOperation extends AbstractNamedOperation implements PartitionAwareOperation, IdentifiedDataSerializable, ReadonlyOperation {
  private EventJournalInitialSubscriberState response;
  
  private ObjectNamespace namespace;
  
  public CacheEventJournalSubscribeOperation() {}
  
  public CacheEventJournalSubscribeOperation(String name) { super(name); }
  
  public void beforeRun() {
    super.beforeRun();
    this.namespace = CacheService.getObjectNamespace(this.name);
    CacheService service = (CacheService)getService();
    if (!service.getEventJournal().hasEventJournal(this.namespace))
      throw new UnsupportedOperationException("Cannot subscribe to event journal because it is either not configured or disabled for cache " + this.name); 
  }
  
  public void run() {
    CacheService service = (CacheService)getService();
    CacheEventJournal eventJournal = service.getEventJournal();
    long newestSequence = eventJournal.newestSequence(this.namespace, getPartitionId());
    long oldestSequence = eventJournal.oldestSequence(this.namespace, getPartitionId());
    this.response = new EventJournalInitialSubscriberState(oldestSequence, newestSequence);
  }
  
  public int getFactoryId() { return CacheDataSerializerHook.F_ID; }
  
  public int getId() { return 56; }
  
  public String getServiceName() { return "hz:impl:cacheService"; }
  
  public EventJournalInitialSubscriberState getResponse() { return this.response; }
}
