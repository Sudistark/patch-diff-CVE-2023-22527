package com.hazelcast.cache.impl.operation;

import com.hazelcast.cache.CacheEntryView;
import com.hazelcast.cache.CacheNotExistsException;
import com.hazelcast.cache.impl.CacheDataSerializerHook;
import com.hazelcast.cache.impl.CacheEntryViews;
import com.hazelcast.cache.impl.ICacheRecordStore;
import com.hazelcast.cache.impl.ICacheService;
import com.hazelcast.cache.impl.event.CacheWanEventPublisher;
import com.hazelcast.cache.impl.record.CacheRecord;
import com.hazelcast.config.CacheConfig;
import com.hazelcast.config.CacheConfigAccessor;
import com.hazelcast.internal.util.ToHeapDataConverter;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.nio.serialization.IdentifiedDataSerializable;
import com.hazelcast.spi.ExceptionAction;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.ObjectNamespace;
import com.hazelcast.spi.PartitionAwareOperation;
import com.hazelcast.spi.ServiceNamespace;
import com.hazelcast.spi.ServiceNamespaceAware;
import com.hazelcast.spi.impl.AbstractNamedOperation;
import com.hazelcast.spi.serialization.SerializationService;
import com.hazelcast.util.ExceptionUtil;
import java.io.Closeable;

public abstract class CacheOperation extends AbstractNamedOperation implements PartitionAwareOperation, ServiceNamespaceAware, IdentifiedDataSerializable {
  protected boolean dontCreateCacheRecordStoreIfNotExist;
  
  protected ICacheService cacheService;
  
  protected ICacheRecordStore recordStore;
  
  protected CacheWanEventPublisher wanEventPublisher;
  
  protected Closeable tenantContext;
  
  protected CacheOperation() {}
  
  protected CacheOperation(String name) { this(name, false); }
  
  protected CacheOperation(String name, boolean dontCreateCacheRecordStoreIfNotExist) {
    super(name);
    this.dontCreateCacheRecordStoreIfNotExist = dontCreateCacheRecordStoreIfNotExist;
  }
  
  public final String getServiceName() { return "hz:impl:cacheService"; }
  
  public final void beforeRun() {
    this.cacheService = (ICacheService)getService();
    try {
      CacheConfig<?, ?> cacheConfig;
      this.recordStore = getOrCreateStoreIfAllowed();
      if (this.recordStore != null) {
        cacheConfig = this.recordStore.getConfig();
      } else {
        cacheConfig = this.cacheService.getCacheConfig(this.name);
      } 
      if (cacheConfig != null)
        this.tenantContext = CacheConfigAccessor.getTenantControl(cacheConfig).setTenant(true); 
    } catch (CacheNotExistsException e) {
      dispose();
      rethrowOrSwallowIfBackup(e);
    } catch (Throwable t) {
      dispose();
      throw ExceptionUtil.rethrow(t, Exception.class);
    } 
    if (this.recordStore != null && this.recordStore.isWanReplicationEnabled())
      this.wanEventPublisher = this.cacheService.getCacheWanEventPublisher(); 
    beforeRunInternal();
  }
  
  public void afterRun() {
    if (this.tenantContext != null)
      this.tenantContext.close(); 
  }
  
  private void rethrowOrSwallowIfBackup(CacheNotExistsException e) throws Exception {
    if (this instanceof com.hazelcast.spi.BackupOperation) {
      getLogger().finest("Error while getting a cache", e);
    } else {
      throw ExceptionUtil.rethrow(e, Exception.class);
    } 
  }
  
  private ICacheRecordStore getOrCreateStoreIfAllowed() {
    if (this.dontCreateCacheRecordStoreIfNotExist)
      return this.cacheService.getRecordStore(this.name, getPartitionId()); 
    return this.cacheService.getOrCreateRecordStore(this.name, getPartitionId());
  }
  
  protected void dispose() {}
  
  protected void beforeRunInternal() {}
  
  public ExceptionAction onInvocationException(Throwable throwable) {
    if (throwable instanceof CacheNotExistsException) {
      ICacheService cacheService = (ICacheService)getService();
      if (cacheService.getCacheConfig(this.name) != null) {
        getLogger().finest("Retry Cache Operation from node " + getNodeEngine().getLocalMember());
        return ExceptionAction.RETRY_INVOCATION;
      } 
    } 
    return super.onInvocationException(throwable);
  }
  
  public void logError(Throwable e) {
    if (e instanceof CacheNotExistsException) {
      ILogger logger = getLogger();
      if (logger.isFinestEnabled())
        logger.finest("failed to execute: " + this, e); 
      return;
    } 
    super.logError(e);
  }
  
  public final ObjectNamespace getServiceNamespace() {
    if (this.recordStore == null) {
      ICacheService service = (ICacheService)getService();
      this.recordStore = service.getOrCreateRecordStore(this.name, getPartitionId());
    } 
    return this.recordStore.getObjectNamespace();
  }
  
  public int getFactoryId() { return CacheDataSerializerHook.F_ID; }
  
  public final int getSyncBackupCount() { return (this.recordStore != null) ? this.recordStore.getConfig().getBackupCount() : 0; }
  
  public final int getAsyncBackupCount() { return (this.recordStore != null) ? this.recordStore.getConfig().getAsyncBackupCount() : 0; }
  
  protected final void publishWanUpdate(Data dataKey, CacheRecord record) {
    if (!this.recordStore.isWanReplicationEnabled() || record == null)
      return; 
    NodeEngine nodeEngine = getNodeEngine();
    SerializationService serializationService = nodeEngine.getSerializationService();
    Data dataValue = ToHeapDataConverter.toHeapData(serializationService.toData(record.getValue()));
    publishWanUpdate(dataKey, dataValue, record);
  }
  
  protected final void publishWanUpdate(Data dataKey, Data dataValue, CacheRecord record) {
    if (!this.recordStore.isWanReplicationEnabled() || record == null)
      return; 
    NodeEngine nodeEngine = getNodeEngine();
    SerializationService serializationService = nodeEngine.getSerializationService();
    Data dataExpiryPolicy = ToHeapDataConverter.toHeapData(serializationService.toData(record.getExpiryPolicy()));
    publishWanUpdate(dataKey, dataValue, dataExpiryPolicy, record);
  }
  
  protected final void publishWanUpdate(Data dataKey, Data dataValue, Data dataExpiryPolicy, CacheRecord record) {
    assert dataValue != null;
    if (!this.recordStore.isWanReplicationEnabled() || record == null)
      return; 
    CacheEntryView<Data, Data> entryView = CacheEntryViews.createDefaultEntryView(ToHeapDataConverter.toHeapData(dataKey), 
        ToHeapDataConverter.toHeapData(dataValue), ToHeapDataConverter.toHeapData(dataExpiryPolicy), record);
    this.wanEventPublisher.publishWanUpdate(this.name, entryView);
  }
  
  protected final void publishWanRemove(Data dataKey) {
    if (!this.recordStore.isWanReplicationEnabled())
      return; 
    this.wanEventPublisher.publishWanRemove(this.name, ToHeapDataConverter.toHeapData(dataKey));
  }
}
