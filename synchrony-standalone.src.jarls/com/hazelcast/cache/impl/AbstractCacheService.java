package com.hazelcast.cache.impl;

import com.hazelcast.cache.CacheNotExistsException;
import com.hazelcast.cache.CacheStatistics;
import com.hazelcast.cache.impl.eviction.CacheClearExpiredRecordsTask;
import com.hazelcast.cache.impl.journal.CacheEventJournal;
import com.hazelcast.cache.impl.journal.RingbufferCacheEventJournalImpl;
import com.hazelcast.cache.impl.merge.policy.CacheMergePolicyProvider;
import com.hazelcast.cache.impl.operation.AddCacheConfigOperationSupplier;
import com.hazelcast.cache.impl.operation.OnJoinCacheOperation;
import com.hazelcast.cache.impl.tenantcontrol.CacheDestroyEventContext;
import com.hazelcast.cluster.ClusterState;
import com.hazelcast.config.CacheConfig;
import com.hazelcast.config.CacheConfigAccessor;
import com.hazelcast.config.CacheSimpleConfig;
import com.hazelcast.config.InMemoryFormat;
import com.hazelcast.core.DistributedObject;
import com.hazelcast.core.ICompletableFuture;
import com.hazelcast.core.Member;
import com.hazelcast.internal.cluster.ClusterStateListener;
import com.hazelcast.internal.config.ConfigValidator;
import com.hazelcast.internal.config.MergePolicyValidator;
import com.hazelcast.internal.eviction.ExpirationManager;
import com.hazelcast.internal.util.InvocationUtil;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.IOUtil;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.EventFilter;
import com.hazelcast.spi.EventRegistration;
import com.hazelcast.spi.EventService;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.PartitionAwareService;
import com.hazelcast.spi.PartitionMigrationEvent;
import com.hazelcast.spi.PreJoinAwareService;
import com.hazelcast.spi.QuorumAwareService;
import com.hazelcast.spi.SplitBrainHandlerService;
import com.hazelcast.spi.partition.IPartitionLostEvent;
import com.hazelcast.spi.partition.MigrationEndpoint;
import com.hazelcast.spi.tenantcontrol.TenantControl;
import com.hazelcast.spi.tenantcontrol.TenantControlFactory;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.ContextMutexFactory;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.FutureUtil;
import com.hazelcast.util.ServiceLoader;
import com.hazelcast.wan.WanReplicationService;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.Closeable;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import javax.cache.CacheException;
import javax.cache.configuration.CacheEntryListenerConfiguration;
import javax.cache.event.CacheEntryListener;

public abstract class AbstractCacheService implements ICacheService, PreJoinAwareService, PartitionAwareService, QuorumAwareService, SplitBrainHandlerService, ClusterStateListener {
  public static final String TENANT_CONTROL_FACTORY = "com.hazelcast.spi.tenantcontrol.TenantControlFactory";
  
  private static final String SETUP_REF = "setupRef";
  
  protected final ConcurrentMap<String, CacheConfig> configs = new ConcurrentHashMap();
  
  protected final ConcurrentMap<String, CacheContext> cacheContexts = new ConcurrentHashMap();
  
  protected final ConcurrentMap<String, CacheStatisticsImpl> statistics = new ConcurrentHashMap();
  
  protected final ConcurrentMap<String, Set<Closeable>> resources = new ConcurrentHashMap();
  
  protected final ConcurrentMap<String, Closeable> closeableListeners = new ConcurrentHashMap();
  
  protected final ConcurrentMap<String, CacheOperationProvider> operationProviderCache = new ConcurrentHashMap();
  
  protected final ConstructorFunction<String, CacheContext> cacheContextsConstructorFunction = new Object(this);
  
  protected final ConstructorFunction<String, CacheStatisticsImpl> cacheStatisticsConstructorFunction = new Object(this);
  
  protected final ContextMutexFactory cacheResourcesMutexFactory = new ContextMutexFactory();
  
  protected final ConstructorFunction<String, Set<Closeable>> cacheResourcesConstructorFunction = new Object(this);
  
  protected ILogger logger;
  
  protected NodeEngine nodeEngine;
  
  protected CachePartitionSegment[] segments;
  
  protected CacheEventHandler cacheEventHandler;
  
  protected RingbufferCacheEventJournalImpl eventJournal;
  
  protected CacheMergePolicyProvider mergePolicyProvider;
  
  protected CacheSplitBrainHandlerService splitBrainHandlerService;
  
  protected CacheClearExpiredRecordsTask clearExpiredRecordsTask;
  
  protected ExpirationManager expirationManager;
  
  public final void init(NodeEngine nodeEngine, Properties properties) {
    this.nodeEngine = nodeEngine;
    int partitionCount = nodeEngine.getPartitionService().getPartitionCount();
    this.segments = new CachePartitionSegment[partitionCount];
    for (int i = 0; i < partitionCount; i++)
      this.segments[i] = newPartitionSegment(i); 
    this.clearExpiredRecordsTask = new CacheClearExpiredRecordsTask(this.segments, nodeEngine);
    this.expirationManager = new ExpirationManager(this.clearExpiredRecordsTask, nodeEngine);
    this.cacheEventHandler = new CacheEventHandler(nodeEngine);
    this.splitBrainHandlerService = new CacheSplitBrainHandlerService(nodeEngine, this.segments);
    this.logger = nodeEngine.getLogger(getClass());
    this.eventJournal = new RingbufferCacheEventJournalImpl(nodeEngine);
    this.mergePolicyProvider = new CacheMergePolicyProvider(nodeEngine);
    postInit(nodeEngine, properties);
  }
  
  public CacheMergePolicyProvider getMergePolicyProvider() { return this.mergePolicyProvider; }
  
  public Object getMergePolicy(String name) {
    CacheConfig cacheConfig = (CacheConfig)this.configs.get(name);
    String mergePolicyName = cacheConfig.getMergePolicy();
    return this.mergePolicyProvider.getMergePolicy(mergePolicyName);
  }
  
  public ConcurrentMap<String, CacheConfig> getConfigs() { return this.configs; }
  
  protected void postInit(NodeEngine nodeEngine, Properties properties) {}
  
  public void reset() { reset(false); }
  
  private void reset(boolean onShutdown) {
    for (String objectName : this.configs.keySet())
      deleteCache(objectName, null, false); 
    CachePartitionSegment[] partitionSegments = this.segments;
    for (CachePartitionSegment partitionSegment : partitionSegments) {
      if (partitionSegment != null)
        if (onShutdown) {
          partitionSegment.shutdown();
        } else {
          partitionSegment.reset();
          partitionSegment.init();
        }  
    } 
    for (String objectName : this.configs.keySet())
      sendInvalidationEvent(objectName, null, "<NA>"); 
  }
  
  public void shutdown(boolean terminate) {
    if (!terminate) {
      this.expirationManager.onShutdown();
      this.cacheEventHandler.shutdown();
      reset(true);
    } 
  }
  
  @SuppressFBWarnings({"EI_EXPOSE_REP"})
  public CachePartitionSegment[] getPartitionSegments() { return this.segments; }
  
  public DistributedObject createDistributedObject(String cacheNameWithPrefix) {
    try {
      if (cacheNameWithPrefix.equals("setupRef")) {
        CacheSimpleConfig cacheSimpleConfig = new CacheSimpleConfig();
        cacheSimpleConfig.setName("setupRef");
        CacheConfig cacheConfig = new CacheConfig(cacheSimpleConfig);
        cacheConfig.setManagerPrefix("/hz/");
        return new CacheProxy(cacheConfig, this.nodeEngine, this);
      } 
      CacheConfig cacheConfig = getCacheConfig(cacheNameWithPrefix);
      if (cacheConfig == null) {
        String cacheName = cacheNameWithPrefix.substring("/hz/".length());
        cacheConfig = findCacheConfig(cacheName);
        if (cacheConfig == null)
          throw new CacheNotExistsException("Couldn't find cache config with name " + cacheNameWithPrefix); 
        cacheConfig.setManagerPrefix("/hz/");
      } 
      ConfigValidator.checkCacheConfig(cacheConfig, this.mergePolicyProvider);
      Object mergePolicy = this.mergePolicyProvider.getMergePolicy(cacheConfig.getMergePolicy());
      MergePolicyValidator.checkMergePolicySupportsInMemoryFormat(cacheConfig.getName(), mergePolicy, cacheConfig.getInMemoryFormat(), true, this.logger);
      if (putCacheConfigIfAbsent(cacheConfig) == null)
        createCacheConfigOnAllMembers(PreJoinCacheConfig.of(cacheConfig)); 
      return new CacheProxy(cacheConfig, this.nodeEngine, this);
    } catch (Throwable t) {
      throw ExceptionUtil.rethrow(t);
    } 
  }
  
  public void destroyDistributedObject(String objectName) { deleteCache(objectName, null, true); }
  
  public void beforeMigration(PartitionMigrationEvent event) {}
  
  public void commitMigration(PartitionMigrationEvent event) {
    if (event.getMigrationEndpoint() == MigrationEndpoint.SOURCE)
      clearCachesHavingLesserBackupCountThan(event.getPartitionId(), event.getNewReplicaIndex()); 
    initPartitionReplica(event.getPartitionId());
  }
  
  public void rollbackMigration(PartitionMigrationEvent event) {
    if (event.getMigrationEndpoint() == MigrationEndpoint.DESTINATION)
      clearCachesHavingLesserBackupCountThan(event.getPartitionId(), event.getCurrentReplicaIndex()); 
    initPartitionReplica(event.getPartitionId());
  }
  
  private void clearCachesHavingLesserBackupCountThan(int partitionId, int thresholdReplicaIndex) {
    if (thresholdReplicaIndex == -1) {
      clearPartitionReplica(partitionId);
      return;
    } 
    CachePartitionSegment segment = this.segments[partitionId];
    segment.clearHavingLesserBackupCountThan(thresholdReplicaIndex);
  }
  
  private void initPartitionReplica(int partitionId) { this.segments[partitionId].init(); }
  
  private void clearPartitionReplica(int partitionId) { this.segments[partitionId].reset(); }
  
  public ICacheRecordStore getOrCreateRecordStore(String cacheNameWithPrefix, int partitionId) { return this.segments[partitionId].getOrCreateRecordStore(cacheNameWithPrefix); }
  
  public ICacheRecordStore getRecordStore(String cacheNameWithPrefix, int partitionId) { return this.segments[partitionId].getRecordStore(cacheNameWithPrefix); }
  
  public CachePartitionSegment getSegment(int partitionId) { return this.segments[partitionId]; }
  
  protected void destroySegments(CacheConfig cacheConfig) {
    String name = cacheConfig.getNameWithPrefix();
    for (CachePartitionSegment segment : this.segments)
      segment.deleteRecordStore(name, true); 
  }
  
  protected void closeSegments(String name) {
    for (CachePartitionSegment segment : this.segments)
      segment.deleteRecordStore(name, false); 
  }
  
  public void deleteCache(String cacheNameWithPrefix, String callerUuid, boolean destroy) {
    CacheConfig config = deleteCacheConfig(cacheNameWithPrefix);
    if (config == null)
      return; 
    if (destroy) {
      this.cacheEventHandler.destroy(cacheNameWithPrefix, "<NA>");
      destroySegments(config);
    } else {
      closeSegments(cacheNameWithPrefix);
    } 
    WanReplicationService wanService = this.nodeEngine.getWanReplicationService();
    wanService.removeWanEventCounters("hz:impl:cacheService", cacheNameWithPrefix);
    this.cacheContexts.remove(cacheNameWithPrefix);
    this.operationProviderCache.remove(cacheNameWithPrefix);
    deregisterAllListener(cacheNameWithPrefix);
    setStatisticsEnabled(config, cacheNameWithPrefix, false);
    setManagementEnabled(config, cacheNameWithPrefix, false);
    deleteCacheStat(cacheNameWithPrefix);
    deleteCacheResources(cacheNameWithPrefix);
  }
  
  public CacheConfig putCacheConfigIfAbsent(CacheConfig config) {
    CacheConfig cacheConfig = PreJoinCacheConfig.asCacheConfig(config);
    CacheConfig localConfig = (CacheConfig)this.configs.putIfAbsent(cacheConfig.getNameWithPrefix(), cacheConfig);
    if (localConfig == null) {
      if (cacheConfig.isStatisticsEnabled())
        setStatisticsEnabled(cacheConfig, cacheConfig.getNameWithPrefix(), true); 
      if (cacheConfig.isManagementEnabled())
        setManagementEnabled(cacheConfig, cacheConfig.getNameWithPrefix(), true); 
    } 
    if (localConfig == null)
      this.logger.info("Added cache config: " + cacheConfig); 
    return localConfig;
  }
  
  public CacheConfig deleteCacheConfig(String cacheNameWithPrefix) {
    CacheConfig config = (CacheConfig)this.configs.remove(cacheNameWithPrefix);
    if (config != null) {
      CacheConfigAccessor.getTenantControl(config).unregister();
      this.logger.info("Removed cache config: " + config);
    } 
    return config;
  }
  
  public ExpirationManager getExpirationManager() { return this.expirationManager; }
  
  public CacheStatisticsImpl createCacheStatIfAbsent(String cacheNameWithPrefix) { return (CacheStatisticsImpl)ConcurrencyUtil.getOrPutIfAbsent(this.statistics, cacheNameWithPrefix, this.cacheStatisticsConstructorFunction); }
  
  public CacheContext getCacheContext(String name) { return (CacheContext)this.cacheContexts.get(name); }
  
  public CacheContext getOrCreateCacheContext(String cacheNameWithPrefix) { return (CacheContext)ConcurrencyUtil.getOrPutIfAbsent(this.cacheContexts, cacheNameWithPrefix, this.cacheContextsConstructorFunction); }
  
  public void deleteCacheStat(String cacheNameWithPrefix) { this.statistics.remove(cacheNameWithPrefix); }
  
  public void setStatisticsEnabled(CacheConfig cacheConfig, String cacheNameWithPrefix, boolean enabled) {
    cacheConfig = (cacheConfig != null) ? cacheConfig : (CacheConfig)this.configs.get(cacheNameWithPrefix);
    if (cacheConfig != null) {
      String cacheManagerName = cacheConfig.getUriString();
      cacheConfig.setStatisticsEnabled(enabled);
      if (enabled) {
        CacheStatisticsImpl cacheStatistics = createCacheStatIfAbsent(cacheNameWithPrefix);
        CacheStatisticsMXBeanImpl mxBean = new CacheStatisticsMXBeanImpl(cacheStatistics);
        MXBeanUtil.registerCacheObject(mxBean, cacheManagerName, cacheConfig.getName(), true);
      } else {
        MXBeanUtil.unregisterCacheObject(cacheManagerName, cacheConfig.getName(), true);
        deleteCacheStat(cacheNameWithPrefix);
      } 
    } 
  }
  
  public void setManagementEnabled(CacheConfig cacheConfig, String cacheNameWithPrefix, boolean enabled) {
    cacheConfig = (cacheConfig != null) ? cacheConfig : (CacheConfig)this.configs.get(cacheNameWithPrefix);
    if (cacheConfig != null) {
      String cacheManagerName = cacheConfig.getUriString();
      cacheConfig.setManagementEnabled(enabled);
      if (enabled) {
        CacheMXBeanImpl mxBean = new CacheMXBeanImpl(cacheConfig);
        MXBeanUtil.registerCacheObject(mxBean, cacheManagerName, cacheConfig.getName(), false);
      } else {
        MXBeanUtil.unregisterCacheObject(cacheManagerName, cacheConfig.getName(), false);
        deleteCacheStat(cacheNameWithPrefix);
      } 
    } 
  }
  
  public CacheConfig getCacheConfig(String cacheNameWithPrefix) { return (CacheConfig)this.configs.get(cacheNameWithPrefix); }
  
  public CacheConfig findCacheConfig(String simpleName) {
    if (simpleName == null)
      return null; 
    CacheSimpleConfig cacheSimpleConfig = this.nodeEngine.getConfig().findCacheConfigOrNull(simpleName);
    if (cacheSimpleConfig == null)
      return null; 
    try {
      CacheConfig cacheConfig = (new CacheConfig(cacheSimpleConfig)).setName(simpleName);
      setTenantControl(cacheConfig);
      return cacheConfig;
    } catch (Exception e) {
      throw new CacheException(e);
    } 
  }
  
  public void setTenantControl(CacheConfig cacheConfig) {
    if (!TenantControl.NOOP_TENANT_CONTROL.equals(CacheConfigAccessor.getTenantControl(cacheConfig)))
      return; 
    TenantControlFactory tenantControlFactory = null;
    try {
      tenantControlFactory = (TenantControlFactory)ServiceLoader.load(TenantControlFactory.class, "com.hazelcast.spi.tenantcontrol.TenantControlFactory", this.nodeEngine
          .getConfigClassLoader());
    } catch (Exception e) {
      if (this.logger.isFinestEnabled())
        this.logger.finest("Could not load service provider for TenantControl", e); 
    } 
    if (tenantControlFactory == null)
      tenantControlFactory = TenantControlFactory.NOOP_TENANT_CONTROL_FACTORY; 
    CacheConfigAccessor.setTenantControl(cacheConfig, tenantControlFactory.saveCurrentTenant(new CacheDestroyEventContext(cacheConfig
            .getName())));
  }
  
  public Collection<CacheConfig> getCacheConfigs() { return this.configs.values(); }
  
  public Object toObject(Object data) {
    if (data == null)
      return null; 
    if (data instanceof Data)
      return this.nodeEngine.toObject(data); 
    return data;
  }
  
  public Data toData(Object object) {
    if (object == null)
      return null; 
    if (object instanceof Data)
      return (Data)object; 
    return this.nodeEngine.getSerializationService().toData(object);
  }
  
  public void publishEvent(CacheEventContext cacheEventContext) { this.cacheEventHandler.publishEvent(cacheEventContext); }
  
  public void publishEvent(String cacheNameWithPrefix, CacheEventSet eventSet, int orderKey) { this.cacheEventHandler.publishEvent(cacheNameWithPrefix, eventSet, orderKey); }
  
  public NodeEngine getNodeEngine() { return this.nodeEngine; }
  
  public void dispatchEvent(Object event, CacheEventListener listener) { listener.handleEvent(event); }
  
  public String registerListener(String cacheNameWithPrefix, CacheEventListener listener, boolean isLocal) { return registerListenerInternal(cacheNameWithPrefix, listener, null, isLocal); }
  
  public String registerListener(String cacheNameWithPrefix, CacheEventListener listener, EventFilter eventFilter, boolean isLocal) { return registerListenerInternal(cacheNameWithPrefix, listener, eventFilter, isLocal); }
  
  protected String registerListenerInternal(String cacheNameWithPrefix, CacheEventListener listener, EventFilter eventFilter, boolean isLocal) {
    EventRegistration reg;
    EventService eventService = getNodeEngine().getEventService();
    if (isLocal) {
      if (eventFilter == null) {
        reg = eventService.registerLocalListener("hz:impl:cacheService", cacheNameWithPrefix, listener);
      } else {
        reg = eventService.registerLocalListener("hz:impl:cacheService", cacheNameWithPrefix, eventFilter, listener);
      } 
    } else if (eventFilter == null) {
      reg = eventService.registerListener("hz:impl:cacheService", cacheNameWithPrefix, listener);
    } else {
      reg = eventService.registerListener("hz:impl:cacheService", cacheNameWithPrefix, eventFilter, listener);
    } 
    String id = reg.getId();
    if (listener instanceof Closeable) {
      this.closeableListeners.put(id, (Closeable)listener);
    } else if (listener instanceof CacheEntryListenerProvider) {
      CacheEntryListener cacheEntryListener = ((CacheEntryListenerProvider)listener).getCacheEntryListener();
      if (cacheEntryListener instanceof Closeable)
        this.closeableListeners.put(id, (Closeable)cacheEntryListener); 
    } 
    return id;
  }
  
  public boolean deregisterListener(String cacheNameWithPrefix, String registrationId) {
    EventService eventService = getNodeEngine().getEventService();
    boolean result = eventService.deregisterListener("hz:impl:cacheService", cacheNameWithPrefix, registrationId);
    Closeable listener = (Closeable)this.closeableListeners.remove(registrationId);
    if (listener != null)
      IOUtil.closeResource(listener); 
    return result;
  }
  
  public void deregisterAllListener(String cacheNameWithPrefix) {
    EventService eventService = getNodeEngine().getEventService();
    Collection<EventRegistration> registrations = eventService.getRegistrations("hz:impl:cacheService", cacheNameWithPrefix);
    if (registrations != null)
      for (EventRegistration registration : registrations) {
        Closeable listener = (Closeable)this.closeableListeners.remove(registration.getId());
        if (listener != null)
          IOUtil.closeResource(listener); 
      }  
    eventService.deregisterAllListeners("hz:impl:cacheService", cacheNameWithPrefix);
    CacheContext cacheContext = (CacheContext)this.cacheContexts.get(cacheNameWithPrefix);
    if (cacheContext != null) {
      cacheContext.resetCacheEntryListenerCount();
      cacheContext.resetInvalidationListenerCount();
    } 
  }
  
  public CacheStatisticsImpl getStatistics(String cacheNameWithPrefix) { return (CacheStatisticsImpl)this.statistics.get(cacheNameWithPrefix); }
  
  public CacheOperationProvider getCacheOperationProvider(String cacheNameWithPrefix, InMemoryFormat inMemoryFormat) {
    if (InMemoryFormat.NATIVE.equals(inMemoryFormat))
      throw new IllegalArgumentException("Native memory is available only in Hazelcast Enterprise.Make sure you have Hazelcast Enterprise JARs on your classpath!"); 
    CacheOperationProvider cacheOperationProvider = (CacheOperationProvider)this.operationProviderCache.get(cacheNameWithPrefix);
    if (cacheOperationProvider != null)
      return cacheOperationProvider; 
    cacheOperationProvider = createOperationProvider(cacheNameWithPrefix, inMemoryFormat);
    CacheOperationProvider current = (CacheOperationProvider)this.operationProviderCache.putIfAbsent(cacheNameWithPrefix, cacheOperationProvider);
    return (current == null) ? cacheOperationProvider : current;
  }
  
  public void addCacheResource(String cacheNameWithPrefix, Closeable resource) {
    Set<Closeable> cacheResources = (Set)ConcurrencyUtil.getOrPutSynchronized(this.resources, cacheNameWithPrefix, this.cacheResourcesMutexFactory, this.cacheResourcesConstructorFunction);
    cacheResources.add(resource);
  }
  
  protected void deleteCacheResources(String name) {
    Set<Closeable> cacheResources;
    mutex = this.cacheResourcesMutexFactory.mutexFor(name);
    try {
      synchronized (mutex) {
        cacheResources = (Set)this.resources.remove(name);
      } 
    } finally {
      mutex.close();
    } 
    if (cacheResources != null) {
      for (Closeable resource : cacheResources)
        IOUtil.closeResource(resource); 
      cacheResources.clear();
    } 
  }
  
  public Operation getPreJoinOperation() {
    OnJoinCacheOperation preJoinCacheOperation = new OnJoinCacheOperation();
    for (Map.Entry<String, CacheConfig> cacheConfigEntry : this.configs.entrySet()) {
      PreJoinCacheConfig preJoinCacheConfig = new PreJoinCacheConfig((CacheConfig)cacheConfigEntry.getValue(), false);
      preJoinCacheOperation.addCacheConfig(preJoinCacheConfig);
    } 
    return preJoinCacheOperation;
  }
  
  protected void publishCachePartitionLostEvent(String cacheName, int partitionId) {
    Collection<EventRegistration> registrations = new LinkedList<EventRegistration>();
    for (EventRegistration registration : getRegistrations(cacheName)) {
      if (registration.getFilter() instanceof com.hazelcast.cache.impl.event.CachePartitionLostEventFilter)
        registrations.add(registration); 
    } 
    if (registrations.isEmpty())
      return; 
    Member member = this.nodeEngine.getLocalMember();
    CachePartitionEventData cachePartitionEventData = new CachePartitionEventData(cacheName, partitionId, member);
    EventService eventService = this.nodeEngine.getEventService();
    eventService.publishEvent("hz:impl:cacheService", registrations, cachePartitionEventData, partitionId);
  }
  
  Collection<EventRegistration> getRegistrations(String cacheName) {
    EventService eventService = this.nodeEngine.getEventService();
    return eventService.getRegistrations("hz:impl:cacheService", cacheName);
  }
  
  public void onPartitionLost(IPartitionLostEvent partitionLostEvent) {
    int partitionId = partitionLostEvent.getPartitionId();
    for (CacheConfig config : getCacheConfigs()) {
      String cacheName = config.getName();
      if (config.getTotalBackupCount() <= partitionLostEvent.getLostReplicaIndex())
        publishCachePartitionLostEvent(cacheName, partitionId); 
    } 
  }
  
  public void cacheEntryListenerRegistered(String name, CacheEntryListenerConfiguration cacheEntryListenerConfiguration) {
    CacheConfig cacheConfig = getCacheConfig(name);
    if (cacheConfig == null)
      throw new IllegalStateException("CacheConfig does not exist for cache " + name); 
    cacheConfig.addCacheEntryListenerConfiguration(cacheEntryListenerConfiguration);
  }
  
  public void cacheEntryListenerDeregistered(String name, CacheEntryListenerConfiguration cacheEntryListenerConfiguration) {
    CacheConfig cacheConfig = getCacheConfig(name);
    if (cacheConfig == null)
      throw new IllegalStateException("CacheConfig does not exist for cache " + name); 
    cacheConfig.removeCacheEntryListenerConfiguration(cacheEntryListenerConfiguration);
  }
  
  public String getQuorumName(String cacheName) {
    CacheConfig cacheConfig = (CacheConfig)this.configs.get(cacheName);
    if (cacheConfig == null)
      return null; 
    return cacheConfig.getQuorumName();
  }
  
  public String addInvalidationListener(String cacheNameWithPrefix, CacheEventListener listener, boolean localOnly) {
    EventRegistration registration;
    EventService eventService = this.nodeEngine.getEventService();
    if (localOnly) {
      registration = eventService.registerLocalListener("hz:impl:cacheService", cacheNameWithPrefix, listener);
    } else {
      registration = eventService.registerListener("hz:impl:cacheService", cacheNameWithPrefix, listener);
    } 
    return registration.getId();
  }
  
  public void sendInvalidationEvent(String cacheNameWithPrefix, Data key, String sourceUuid) { this.cacheEventHandler.sendInvalidationEvent(cacheNameWithPrefix, key, sourceUuid); }
  
  public Runnable prepareMergeRunnable() { return this.splitBrainHandlerService.prepareMergeRunnable(); }
  
  public CacheEventHandler getCacheEventHandler() { return this.cacheEventHandler; }
  
  public CacheEventJournal getEventJournal() { return this.eventJournal; }
  
  public <K, V> void createCacheConfigOnAllMembers(PreJoinCacheConfig<K, V> cacheConfig) {
    ICompletableFuture future = createCacheConfigOnAllMembersAsync(cacheConfig);
    FutureUtil.waitForever(Collections.singleton(future), FutureUtil.RETHROW_EVERYTHING);
  }
  
  public <K, V> ICompletableFuture createCacheConfigOnAllMembersAsync(PreJoinCacheConfig<K, V> cacheConfig) { return InvocationUtil.invokeOnStableClusterSerial(getNodeEngine(), new AddCacheConfigOperationSupplier(cacheConfig), 100); }
  
  public void onClusterStateChange(ClusterState newState) {
    ExpirationManager expManager = this.expirationManager;
    if (expManager != null)
      expManager.onClusterStateChange(newState); 
  }
  
  protected abstract CachePartitionSegment newPartitionSegment(int paramInt);
  
  protected abstract ICacheRecordStore createNewRecordStore(String paramString, int paramInt);
  
  protected abstract CacheOperationProvider createOperationProvider(String paramString, InMemoryFormat paramInMemoryFormat);
}
