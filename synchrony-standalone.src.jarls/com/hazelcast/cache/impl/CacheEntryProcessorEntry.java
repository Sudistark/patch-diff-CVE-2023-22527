package com.hazelcast.cache.impl;

import com.hazelcast.cache.impl.record.CacheRecord;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.util.Preconditions;
import javax.cache.configuration.Factory;
import javax.cache.expiry.ExpiryPolicy;
import javax.cache.processor.MutableEntry;

public class CacheEntryProcessorEntry<K, V, R extends CacheRecord> extends Object implements MutableEntry<K, V> {
  protected K key;
  
  protected V value;
  
  protected State state;
  
  protected final Data keyData;
  
  protected R record;
  
  protected R recordLoaded;
  
  protected V valueLoaded;
  
  protected final AbstractCacheRecordStore cacheRecordStore;
  
  protected final long now;
  
  protected final long start;
  
  protected final ExpiryPolicy expiryPolicy;
  
  protected final int completionId;
  
  public CacheEntryProcessorEntry(Data keyData, R record, AbstractCacheRecordStore cacheRecordStore, long now, int completionId) {
    this.state = State.NONE;
    this.keyData = keyData;
    this.record = record;
    this.cacheRecordStore = cacheRecordStore;
    this.now = now;
    this.completionId = completionId;
    this.start = cacheRecordStore.cacheConfig.isStatisticsEnabled() ? System.nanoTime() : 0L;
    Factory<ExpiryPolicy> expiryPolicyFactory = cacheRecordStore.cacheConfig.getExpiryPolicyFactory();
    this.expiryPolicy = (ExpiryPolicy)expiryPolicyFactory.create();
  }
  
  public boolean exists() { return ((this.record != null && this.state == State.NONE) || this.value != null); }
  
  public void remove() {
    this.value = null;
    this.state = (this.state == State.CREATE || this.state == State.LOAD) ? State.NONE : State.REMOVE;
  }
  
  public void setValue(V value) {
    Preconditions.checkNotNull(value, "Null value not allowed");
    if (this.record == null) {
      this.state = State.CREATE;
    } else {
      this.state = State.UPDATE;
    } 
    this.value = value;
  }
  
  public K getKey() {
    if (this.key == null)
      this.key = this.cacheRecordStore.cacheService.toObject(this.keyData); 
    return (K)this.key;
  }
  
  public V getValue() {
    if (this.state == State.REMOVE)
      return null; 
    if (this.value != null)
      return (V)this.value; 
    if (this.record != null) {
      this.state = State.ACCESS;
      this.value = getRecordValue(this.record);
      return (V)this.value;
    } 
    if (this.recordLoaded == null)
      this.recordLoaded = this.cacheRecordStore.readThroughRecord(this.keyData, this.now); 
    if (this.recordLoaded != null) {
      this.state = State.LOAD;
      this.valueLoaded = getRecordValue(this.recordLoaded);
      return (V)this.valueLoaded;
    } 
    return null;
  }
  
  protected V getRecordValue(R record) {
    Object objValue;
    Object objValue;
    switch (null.$SwitchMap$com$hazelcast$config$InMemoryFormat[this.cacheRecordStore.cacheConfig.getInMemoryFormat().ordinal()]) {
      case 1:
        objValue = this.cacheRecordStore.cacheService.toObject(record.getValue());
        return (V)objValue;
      case 2:
        objValue = record.getValue();
        return (V)objValue;
    } 
    throw new IllegalArgumentException("Invalid storage format: " + this.cacheRecordStore.cacheConfig.getInMemoryFormat());
  }
  
  public R getRecord() {
    assert Thread.currentThread() instanceof com.hazelcast.spi.impl.operationexecutor.impl.PartitionOperationThread;
    return (R)this.record;
  }
  
  public void applyChanges() {
    boolean removed, saved, saved, saved, isStatisticsEnabled = this.cacheRecordStore.cacheConfig.isStatisticsEnabled();
    CacheStatisticsImpl statistics = this.cacheRecordStore.statistics;
    switch (null.$SwitchMap$com$hazelcast$cache$impl$CacheEntryProcessorEntry$State[this.state.ordinal()]) {
      case 1:
        this.cacheRecordStore.accessRecord(this.keyData, this.record, this.expiryPolicy, this.now);
        break;
      case 2:
        if (isStatisticsEnabled) {
          statistics.increaseCachePuts(1L);
          statistics.addGetTimeNanos(System.nanoTime() - this.start);
        } 
        saved = (this.cacheRecordStore.createRecordWithExpiry(this.keyData, this.value, this.expiryPolicy, this.now, false, this.completionId) != null);
        onCreate(this.keyData, this.value, this.expiryPolicy, this.now, false, this.completionId, saved);
        break;
      case 3:
        saved = (this.cacheRecordStore.createRecordWithExpiry(this.keyData, this.valueLoaded, this.expiryPolicy, this.now, true, this.completionId) != null);
        onLoad(this.keyData, this.valueLoaded, this.expiryPolicy, this.now, true, this.completionId, saved);
        break;
      case 4:
        saved = this.cacheRecordStore.updateRecordWithExpiry(this.keyData, this.value, this.record, this.expiryPolicy, this.now, false, this.completionId);
        onUpdate(this.keyData, this.value, this.record, this.expiryPolicy, this.now, false, this.completionId, saved);
        if (isStatisticsEnabled) {
          statistics.increaseCachePuts(1L);
          statistics.addGetTimeNanos(System.nanoTime() - this.start);
        } 
        break;
      case 5:
        removed = this.cacheRecordStore.remove(this.keyData, null, null, this.completionId);
        onRemove(this.keyData, null, this.completionId, removed);
        break;
      case 6:
        this.cacheRecordStore.publishEvent(
            CacheEventContextUtil.createCacheCompleteEvent(this.cacheRecordStore
              .toEventData(this.keyData), this.completionId));
        break;
    } 
  }
  
  protected void onCreate(Data key, Object value, ExpiryPolicy expiryPolicy, long now, boolean disableWriteThrough, int completionId, boolean saved) {}
  
  protected void onLoad(Data key, Object value, ExpiryPolicy expiryPolicy, long now, boolean disableWriteThrough, int completionId, boolean saved) {}
  
  protected void onUpdate(Data key, Object value, R record, ExpiryPolicy expiryPolicy, long now, boolean disableWriteThrough, int completionId, boolean saved) {}
  
  protected void onRemove(Data key, String source, int completionId, boolean removed) {}
  
  public <T> T unwrap(Class<T> clazz) {
    if (clazz.isAssignableFrom(getClass()))
      return (T)clazz.cast(this); 
    throw new IllegalArgumentException("Unwrapping to " + clazz + " is not supported by this implementation");
  }
}
