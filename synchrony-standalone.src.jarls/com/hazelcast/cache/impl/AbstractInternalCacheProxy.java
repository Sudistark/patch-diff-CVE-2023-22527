package com.hazelcast.cache.impl;

import com.hazelcast.cache.CacheStatistics;
import com.hazelcast.cache.HazelcastCacheManager;
import com.hazelcast.cache.impl.event.CachePartitionLostEventFilter;
import com.hazelcast.cache.impl.event.CachePartitionLostListener;
import com.hazelcast.cache.impl.event.InternalCachePartitionLostListenerAdapter;
import com.hazelcast.cache.impl.operation.MutableOperation;
import com.hazelcast.config.CacheConfig;
import com.hazelcast.config.CachePartitionLostListenerConfig;
import com.hazelcast.config.ListenerConfig;
import com.hazelcast.core.HazelcastInstanceNotActiveException;
import com.hazelcast.nio.ClassLoaderUtil;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.OperationFactory;
import com.hazelcast.spi.OperationService;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.SetUtil;
import java.util.Collection;
import java.util.EventListener;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import javax.cache.CacheManager;
import javax.cache.configuration.CacheEntryListenerConfiguration;
import javax.cache.expiry.ExpiryPolicy;

abstract class AbstractInternalCacheProxy<K, V> extends AbstractCacheProxyBase<K, V> implements CacheSyncListenerCompleter {
  private static final long MAX_COMPLETION_LATCH_WAIT_TIME = TimeUnit.MINUTES.toMillis(5L);
  
  private static final long COMPLETION_LATCH_WAIT_TIME_STEP = TimeUnit.SECONDS.toMillis(1L);
  
  private final AtomicInteger completionIdCounter = new AtomicInteger();
  
  private final ConcurrentMap<CacheEntryListenerConfiguration, String> asyncListenerRegistrations;
  
  private final ConcurrentMap<CacheEntryListenerConfiguration, String> syncListenerRegistrations;
  
  private final ConcurrentMap<Integer, CountDownLatch> syncLocks;
  
  private AtomicReference<HazelcastServerCacheManager> cacheManagerRef = new AtomicReference();
  
  AbstractInternalCacheProxy(CacheConfig<K, V> cacheConfig, NodeEngine nodeEngine, ICacheService cacheService) {
    super(cacheConfig, nodeEngine, cacheService);
    this.asyncListenerRegistrations = new ConcurrentHashMap();
    this.syncListenerRegistrations = new ConcurrentHashMap();
    this.syncLocks = new ConcurrentHashMap();
    List<CachePartitionLostListenerConfig> configs = cacheConfig.getPartitionLostListenerConfigs();
    for (CachePartitionLostListenerConfig listenerConfig : configs) {
      CachePartitionLostListener listener = (CachePartitionLostListener)initializeListener(listenerConfig);
      if (listener != null) {
        CachePartitionLostEventFilter cachePartitionLostEventFilter = new CachePartitionLostEventFilter();
        InternalCachePartitionLostListenerAdapter internalCachePartitionLostListenerAdapter = new InternalCachePartitionLostListenerAdapter(listener);
        ((ICacheService)getService()).getNodeEngine().getEventService()
          .registerListener("hz:impl:cacheService", this.name, cachePartitionLostEventFilter, internalCachePartitionLostListenerAdapter);
      } 
    } 
  }
  
  public CacheManager getCacheManager() { return (CacheManager)this.cacheManagerRef.get(); }
  
  public void setCacheManager(HazelcastCacheManager cacheManager) {
    assert cacheManager instanceof HazelcastServerCacheManager;
    if (this.cacheManagerRef.get() == cacheManager)
      return; 
    if (!this.cacheManagerRef.compareAndSet(null, (HazelcastServerCacheManager)cacheManager)) {
      if (this.cacheManagerRef.get() == cacheManager)
        return; 
      throw new IllegalStateException("Cannot overwrite a Cache's CacheManager.");
    } 
  }
  
  public void resetCacheManager() { this.cacheManagerRef.set(null); }
  
  protected void postDestroy() {
    CacheManager cacheManager = (CacheManager)this.cacheManagerRef.get();
    if (cacheManager != null)
      cacheManager.destroyCache(getName()); 
    resetCacheManager();
  }
  
  public void countDownCompletionLatch(int countDownLatchId) {
    if (countDownLatchId != -1) {
      CountDownLatch countDownLatch = (CountDownLatch)this.syncLocks.get(Integer.valueOf(countDownLatchId));
      if (countDownLatch == null)
        return; 
      countDownLatch.countDown();
      if (countDownLatch.getCount() == 0L)
        deregisterCompletionLatch(Integer.valueOf(countDownLatchId)); 
    } 
  }
  
  protected void closeListeners() {
    deregisterAllCacheEntryListener(this.syncListenerRegistrations.values());
    deregisterAllCacheEntryListener(this.asyncListenerRegistrations.values());
    this.syncListenerRegistrations.clear();
    this.asyncListenerRegistrations.clear();
    notifyAndClearSyncListenerLatches();
  }
  
  public CacheStatistics getLocalCacheStatistics() { return ((ICacheService)getService()).createCacheStatIfAbsent(this.cacheConfig.getNameWithPrefix()); }
  
  <T> InternalCompletableFuture<T> invoke(Operation op, int partitionId, boolean completionOperation) {
    completionId = null;
    if (completionOperation) {
      completionId = registerCompletionLatch(1);
      if (op instanceof MutableOperation)
        ((MutableOperation)op).setCompletionId(completionId.intValue()); 
    } 
    try {
      InternalCompletableFuture<T> future = getNodeEngine().getOperationService().invokeOnPartition(getServiceName(), op, partitionId);
      if (completionOperation)
        waitCompletionLatch(completionId); 
      return future;
    } catch (Throwable e) {
      if (e instanceof IllegalStateException)
        close(); 
      throw ExceptionUtil.rethrowAllowedTypeFirst(e, javax.cache.CacheException.class);
    } finally {
      if (completionOperation)
        deregisterCompletionLatch(completionId); 
    } 
  }
  
  <T> InternalCompletableFuture<T> invoke(Operation op, Data keyData, boolean completionOperation) {
    int partitionId = getPartitionId(keyData);
    return invoke(op, partitionId, completionOperation);
  }
  
  <T> InternalCompletableFuture<T> removeAsyncInternal(K key, V oldValue, boolean hasOldValue, boolean isGet, boolean withCompletionEvent) {
    Operation operation;
    ensureOpen();
    if (hasOldValue) {
      CacheProxyUtil.validateNotNull(key, oldValue);
      CacheProxyUtil.validateConfiguredTypes(this.cacheConfig, key, oldValue);
    } else {
      CacheProxyUtil.validateNotNull(key);
      CacheProxyUtil.validateConfiguredTypes(this.cacheConfig, key);
    } 
    Data keyData = this.serializationService.toData(key);
    Data valueData = this.serializationService.toData(oldValue);
    if (isGet) {
      operation = this.operationProvider.createGetAndRemoveOperation(keyData, -1);
    } else {
      operation = this.operationProvider.createRemoveOperation(keyData, valueData, -1);
    } 
    return invoke(operation, keyData, withCompletionEvent);
  }
  
  <T> InternalCompletableFuture<T> replaceAsyncInternal(K key, V oldValue, V newValue, ExpiryPolicy expiryPolicy, boolean hasOldValue, boolean isGet, boolean withCompletionEvent) {
    Operation operation;
    ensureOpen();
    if (hasOldValue) {
      CacheProxyUtil.validateNotNull(key, oldValue, newValue);
      CacheProxyUtil.validateConfiguredTypes(this.cacheConfig, key, oldValue, newValue);
    } else {
      CacheProxyUtil.validateNotNull(key, newValue);
      CacheProxyUtil.validateConfiguredTypes(this.cacheConfig, key, newValue);
    } 
    Data keyData = this.serializationService.toData(key);
    Data oldValueData = this.serializationService.toData(oldValue);
    Data newValueData = this.serializationService.toData(newValue);
    if (isGet) {
      operation = this.operationProvider.createGetAndReplaceOperation(keyData, newValueData, expiryPolicy, -1);
    } else {
      operation = this.operationProvider.createReplaceOperation(keyData, oldValueData, newValueData, expiryPolicy, -1);
    } 
    return invoke(operation, keyData, withCompletionEvent);
  }
  
  <T> InternalCompletableFuture<T> putAsyncInternal(K key, V value, ExpiryPolicy expiryPolicy, boolean isGet, boolean withCompletionEvent) {
    ensureOpen();
    CacheProxyUtil.validateNotNull(key, value);
    CacheProxyUtil.validateConfiguredTypes(this.cacheConfig, key, value);
    Data keyData = this.serializationService.toData(key);
    Data valueData = this.serializationService.toData(value);
    Operation op = this.operationProvider.createPutOperation(keyData, valueData, expiryPolicy, isGet, -1);
    return invoke(op, keyData, withCompletionEvent);
  }
  
  InternalCompletableFuture<Boolean> putIfAbsentAsyncInternal(K key, V value, ExpiryPolicy expiryPolicy, boolean withCompletionEvent) {
    ensureOpen();
    CacheProxyUtil.validateNotNull(key, value);
    CacheProxyUtil.validateConfiguredTypes(this.cacheConfig, key, value);
    Data keyData = this.serializationService.toData(key);
    Data valueData = this.serializationService.toData(value);
    Operation operation = this.operationProvider.createPutIfAbsentOperation(keyData, valueData, expiryPolicy, -1);
    return invoke(operation, keyData, withCompletionEvent);
  }
  
  void clearInternal() {
    try {
      OperationService operationService = getNodeEngine().getOperationService();
      OperationFactory operationFactory = this.operationProvider.createClearOperationFactory();
      Map<Integer, Object> results = operationService.invokeOnAllPartitions(getServiceName(), operationFactory);
      for (Object result : results.values()) {
        if (result != null && result instanceof CacheClearResponse) {
          Object response = ((CacheClearResponse)result).getResponse();
          if (response instanceof Throwable)
            throw (Throwable)response; 
        } 
      } 
    } catch (Throwable t) {
      throw ExceptionUtil.rethrowAllowedTypeFirst(t, javax.cache.CacheException.class);
    } 
  }
  
  void removeAllInternal(Set<? extends K> keys) {
    Set<Data> keysData = null;
    if (keys != null) {
      keysData = SetUtil.createHashSet(keys.size());
      for (K key : keys) {
        CacheProxyUtil.validateNotNull(key);
        keysData.add(this.serializationService.toData(key));
      } 
    } 
    int partitionCount = getNodeEngine().getPartitionService().getPartitionCount();
    Integer completionId = registerCompletionLatch(partitionCount);
    OperationService operationService = getNodeEngine().getOperationService();
    OperationFactory operationFactory = this.operationProvider.createRemoveAllOperationFactory(keysData, completionId);
    try {
      Map<Integer, Object> results = operationService.invokeOnAllPartitions(getServiceName(), operationFactory);
      int completionCount = 0;
      for (Object result : results.values()) {
        if (result != null && result instanceof CacheClearResponse) {
          Object response = ((CacheClearResponse)result).getResponse();
          if (response instanceof Boolean)
            completionCount++; 
          if (response instanceof Throwable)
            throw (Throwable)response; 
        } 
      } 
      waitCompletionLatch(completionId, partitionCount - completionCount);
    } catch (Throwable t) {
      deregisterCompletionLatch(completionId);
      throw ExceptionUtil.rethrowAllowedTypeFirst(t, javax.cache.CacheException.class);
    } 
  }
  
  void addListenerLocally(String regId, CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration) {
    if (cacheEntryListenerConfiguration.isSynchronous()) {
      this.syncListenerRegistrations.putIfAbsent(cacheEntryListenerConfiguration, regId);
    } else {
      this.asyncListenerRegistrations.putIfAbsent(cacheEntryListenerConfiguration, regId);
    } 
  }
  
  String removeListenerLocally(CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration) {
    ConcurrentMap<CacheEntryListenerConfiguration, String> regs;
    if (cacheEntryListenerConfiguration.isSynchronous()) {
      regs = this.syncListenerRegistrations;
    } else {
      regs = this.asyncListenerRegistrations;
    } 
    return (String)regs.remove(cacheEntryListenerConfiguration);
  }
  
  String getListenerIdLocal(CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration) {
    ConcurrentMap<CacheEntryListenerConfiguration, String> regs;
    if (cacheEntryListenerConfiguration.isSynchronous()) {
      regs = this.syncListenerRegistrations;
    } else {
      regs = this.asyncListenerRegistrations;
    } 
    return (String)regs.get(cacheEntryListenerConfiguration);
  }
  
  private void deregisterAllCacheEntryListener(Collection<String> listenerRegistrations) {
    ICacheService service = (ICacheService)getService();
    for (String regId : listenerRegistrations)
      service.deregisterListener(this.nameWithPrefix, regId); 
  }
  
  private void notifyAndClearSyncListenerLatches() {
    Collection<CountDownLatch> latches = this.syncLocks.values();
    Iterator<CountDownLatch> iterator = latches.iterator();
    while (iterator.hasNext()) {
      CountDownLatch latch = (CountDownLatch)iterator.next();
      iterator.remove();
      while (latch.getCount() > 0L)
        latch.countDown(); 
    } 
  }
  
  Integer registerCompletionLatch(int count) {
    if (!this.syncListenerRegistrations.isEmpty()) {
      int id = this.completionIdCounter.incrementAndGet();
      int size = this.syncListenerRegistrations.size();
      CountDownLatch countDownLatch = new CountDownLatch(count * size);
      this.syncLocks.put(Integer.valueOf(id), countDownLatch);
      return Integer.valueOf(id);
    } 
    return Integer.valueOf(-1);
  }
  
  void deregisterCompletionLatch(Integer countDownLatchId) {
    if (countDownLatchId.intValue() != -1)
      this.syncLocks.remove(countDownLatchId); 
  }
  
  void waitCompletionLatch(Integer countDownLatchId) {
    if (countDownLatchId.intValue() != -1) {
      CountDownLatch countDownLatch = (CountDownLatch)this.syncLocks.get(countDownLatchId);
      if (countDownLatch != null)
        awaitLatch(countDownLatch); 
    } 
  }
  
  private void waitCompletionLatch(Integer countDownLatchId, int offset) {
    if (countDownLatchId.intValue() != -1) {
      CountDownLatch countDownLatch = (CountDownLatch)this.syncLocks.get(countDownLatchId);
      if (countDownLatch != null) {
        for (int i = 0; i < offset; i++)
          countDownLatch.countDown(); 
        awaitLatch(countDownLatch);
      } 
    } 
  }
  
  private void awaitLatch(CountDownLatch countDownLatch) {
    try {
      long currentTimeoutMs = MAX_COMPLETION_LATCH_WAIT_TIME;
      while (currentTimeoutMs > 0L && 
        !countDownLatch.await(COMPLETION_LATCH_WAIT_TIME_STEP, TimeUnit.MILLISECONDS)) {
        currentTimeoutMs -= COMPLETION_LATCH_WAIT_TIME_STEP;
        if (!getNodeEngine().isRunning())
          throw new HazelcastInstanceNotActiveException(); 
        if (isClosed())
          throw new IllegalStateException("Cache (" + this.nameWithPrefix + ") is closed!"); 
        if (isDestroyed())
          throw new IllegalStateException("Cache (" + this.nameWithPrefix + ") is destroyed!"); 
      } 
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      ExceptionUtil.sneakyThrow(e);
    } 
  }
  
  private <T extends EventListener> T initializeListener(ListenerConfig listenerConfig) {
    T listener = null;
    if (listenerConfig.getImplementation() != null) {
      listener = (T)listenerConfig.getImplementation();
    } else if (listenerConfig.getClassName() != null) {
      try {
        listener = (T)(EventListener)ClassLoaderUtil.newInstance(getNodeEngine().getConfigClassLoader(), listenerConfig
            .getClassName());
      } catch (Exception e) {
        throw ExceptionUtil.rethrow(e);
      } 
    } 
    injectDependencies(listener);
    return listener;
  }
}
