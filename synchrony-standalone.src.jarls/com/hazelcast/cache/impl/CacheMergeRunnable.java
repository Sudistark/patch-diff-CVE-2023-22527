package com.hazelcast.cache.impl;

import com.hazelcast.cache.CacheMergePolicy;
import com.hazelcast.cache.impl.merge.entry.DefaultCacheEntryView;
import com.hazelcast.cache.impl.operation.CacheLegacyMergeOperation;
import com.hazelcast.cache.impl.record.CacheRecord;
import com.hazelcast.config.CacheConfig;
import com.hazelcast.config.InMemoryFormat;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.OperationFactory;
import com.hazelcast.spi.impl.merge.AbstractMergeRunnable;
import com.hazelcast.spi.impl.merge.MergingValueFactory;
import com.hazelcast.spi.merge.SplitBrainMergePolicy;
import com.hazelcast.spi.merge.SplitBrainMergeTypes;
import com.hazelcast.util.function.BiConsumer;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

class CacheMergeRunnable extends AbstractMergeRunnable<Data, Data, ICacheRecordStore, SplitBrainMergeTypes.CacheMergeTypes> {
  private final CacheService cacheService;
  
  private final ConcurrentMap<String, CacheConfig> configs;
  
  CacheMergeRunnable(Collection<ICacheRecordStore> mergingStores, CacheSplitBrainHandlerService splitBrainHandlerService, NodeEngine nodeEngine) {
    super("hz:impl:cacheService", mergingStores, splitBrainHandlerService, nodeEngine);
    this.cacheService = (CacheService)nodeEngine.getService("hz:impl:cacheService");
    this.configs = new ConcurrentHashMap(this.cacheService.getConfigs());
  }
  
  protected void onRunStart() {
    super.onRunStart();
    for (CacheConfig cacheConfig : this.configs.values())
      this.cacheService.putCacheConfigIfAbsent(cacheConfig); 
  }
  
  protected void onMerge(String cacheName) { this.cacheService.sendInvalidationEvent(cacheName, null, "<NA>"); }
  
  protected void mergeStore(ICacheRecordStore store, BiConsumer<Integer, SplitBrainMergeTypes.CacheMergeTypes> consumer) {
    int partitionId = store.getPartitionId();
    for (Map.Entry<Data, CacheRecord> entry : store.getReadOnlyRecords().entrySet()) {
      Data key = toHeapData(entry.getKey());
      CacheRecord record = (CacheRecord)entry.getValue();
      Data dataValue = toHeapData(record.getValue());
      consumer.accept(Integer.valueOf(partitionId), MergingValueFactory.createMergingEntry(getSerializationService(), key, dataValue, record));
    } 
  }
  
  protected void mergeStoreLegacy(ICacheRecordStore recordStore, BiConsumer<Integer, Operation> consumer) {
    int partitionId = recordStore.getPartitionId();
    String name = recordStore.getName();
    CacheMergePolicy mergePolicy = (CacheMergePolicy)getMergePolicy(name);
    for (Map.Entry<Data, CacheRecord> entry : recordStore.getReadOnlyRecords().entrySet()) {
      Data key = (Data)entry.getKey();
      CacheRecord record = (CacheRecord)entry.getValue();
      DefaultCacheEntryView defaultCacheEntryView = new DefaultCacheEntryView(key, toData(record.getValue()), record.getCreationTime(), record.getExpirationTime(), record.getLastAccessTime(), record.getAccessHit(), toData(record.getExpiryPolicy()));
      consumer.accept(Integer.valueOf(partitionId), new CacheLegacyMergeOperation(name, key, defaultCacheEntryView, mergePolicy));
    } 
  }
  
  protected InMemoryFormat getInMemoryFormat(String dataStructureName) { return ((CacheConfig)this.cacheService.getConfigs().get(dataStructureName)).getInMemoryFormat(); }
  
  protected int getBatchSize(String dataStructureName) { return 100; }
  
  protected Object getMergePolicy(String dataStructureName) { return this.cacheService.getMergePolicy(dataStructureName); }
  
  protected String getDataStructureName(ICacheRecordStore iCacheRecordStore) { return iCacheRecordStore.getName(); }
  
  protected int getPartitionId(ICacheRecordStore store) { return store.getPartitionId(); }
  
  protected OperationFactory createMergeOperationFactory(String dataStructureName, SplitBrainMergePolicy<Data, SplitBrainMergeTypes.CacheMergeTypes> mergePolicy, int[] partitions, List[] entries) {
    CacheConfig cacheConfig = this.cacheService.getCacheConfig(dataStructureName);
    CacheOperationProvider operationProvider = this.cacheService.getCacheOperationProvider(dataStructureName, cacheConfig.getInMemoryFormat());
    return operationProvider.createMergeOperationFactory(dataStructureName, partitions, entries, mergePolicy);
  }
}
