package com.hazelcast.cache.impl;

import com.hazelcast.cache.CacheStatistics;
import com.hazelcast.cache.HazelcastCacheManager;
import com.hazelcast.cache.impl.event.CachePartitionLostEventFilter;
import com.hazelcast.cache.impl.event.CachePartitionLostListener;
import com.hazelcast.cache.impl.event.InternalCachePartitionLostListenerAdapter;
import com.hazelcast.cache.impl.journal.CacheEventJournalReadOperation;
import com.hazelcast.cache.impl.journal.CacheEventJournalSubscribeOperation;
import com.hazelcast.cache.impl.operation.CacheListenerRegistrationOperation;
import com.hazelcast.cache.journal.EventJournalCacheEvent;
import com.hazelcast.config.CacheConfig;
import com.hazelcast.core.ICompletableFuture;
import com.hazelcast.core.Member;
import com.hazelcast.internal.journal.EventJournalInitialSubscriberState;
import com.hazelcast.internal.journal.EventJournalReader;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.ringbuffer.ReadResultSet;
import com.hazelcast.spi.EventRegistration;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.OperationService;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.MapUtil;
import com.hazelcast.util.Preconditions;
import com.hazelcast.util.SetUtil;
import com.hazelcast.util.function.Function;
import com.hazelcast.util.function.Predicate;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import javax.cache.Cache;
import javax.cache.CacheException;
import javax.cache.CacheManager;
import javax.cache.configuration.CacheEntryListenerConfiguration;
import javax.cache.configuration.Configuration;
import javax.cache.expiry.ExpiryPolicy;
import javax.cache.integration.CompletionListener;
import javax.cache.processor.EntryProcessor;
import javax.cache.processor.EntryProcessorException;
import javax.cache.processor.EntryProcessorResult;

public class CacheProxy<K, V> extends AbstractCacheProxy<K, V> implements EventJournalReader<EventJournalCacheEvent<K, V>> {
  CacheProxy(CacheConfig<K, V> cacheConfig, NodeEngine nodeEngine, ICacheService cacheService) { super(cacheConfig, nodeEngine, cacheService); }
  
  public V get(K key) { return (V)get(key, null); }
  
  public Map<K, V> getAll(Set<? extends K> keys) { return getAll(keys, null); }
  
  public boolean containsKey(K key) {
    ensureOpen();
    CacheProxyUtil.validateNotNull(key);
    Data dataKey = this.serializationService.toData(key);
    Operation operation = this.operationProvider.createContainsKeyOperation(dataKey);
    OperationService operationService = getNodeEngine().getOperationService();
    int partitionId = getPartitionId(dataKey);
    InternalCompletableFuture<Boolean> future = operationService.invokeOnPartition(getServiceName(), operation, partitionId);
    return ((Boolean)future.join()).booleanValue();
  }
  
  public void loadAll(Set<? extends K> keys, boolean replaceExistingValues, CompletionListener completionListener) {
    ensureOpen();
    CacheProxyUtil.validateNotNull(keys);
    for (K key : keys)
      CacheProxyUtil.validateConfiguredTypes(this.cacheConfig, key); 
    Set<Data> keysData = SetUtil.createHashSet(keys.size());
    for (K key : keys) {
      CacheProxyUtil.validateNotNull(key);
      keysData.add(this.serializationService.toData(key));
    } 
    AbstractCacheProxyBase<K, V>.LoadAllTask loadAllTask = new AbstractCacheProxyBase.LoadAllTask(this, this.operationProvider, keysData, replaceExistingValues, completionListener);
    try {
      submitLoadAllTask(loadAllTask);
    } catch (Exception e) {
      if (completionListener != null)
        completionListener.onException(e); 
      throw new CacheException(e);
    } 
  }
  
  public void put(K key, V value) { put(key, value, null); }
  
  public V getAndPut(K key, V value) { return (V)getAndPut(key, value, null); }
  
  public void putAll(Map<? extends K, ? extends V> map) { putAll(map, null); }
  
  public boolean putIfAbsent(K key, V value) { return putIfAbsent(key, value, null); }
  
  public boolean remove(K key) {
    try {
      InternalCompletableFuture<Boolean> future = removeAsyncInternal(key, null, false, false, true);
      return ((Boolean)future.get()).booleanValue();
    } catch (Throwable e) {
      throw ExceptionUtil.rethrowAllowedTypeFirst(e, CacheException.class);
    } 
  }
  
  public boolean remove(K key, V oldValue) {
    try {
      InternalCompletableFuture<Boolean> future = removeAsyncInternal(key, oldValue, true, false, true);
      return ((Boolean)future.get()).booleanValue();
    } catch (Throwable e) {
      throw ExceptionUtil.rethrowAllowedTypeFirst(e, CacheException.class);
    } 
  }
  
  public V getAndRemove(K key) {
    try {
      InternalCompletableFuture<V> future = removeAsyncInternal(key, null, false, true, true);
      return (V)future.get();
    } catch (Throwable e) {
      throw ExceptionUtil.rethrowAllowedTypeFirst(e, CacheException.class);
    } 
  }
  
  public boolean replace(K key, V oldValue, V newValue) { return replace(key, oldValue, newValue, null); }
  
  public boolean replace(K key, V value) { return replace(key, value, (ExpiryPolicy)null); }
  
  public V getAndReplace(K key, V value) { return (V)getAndReplace(key, value, null); }
  
  public void removeAll(Set<? extends K> keys) {
    ensureOpen();
    CacheProxyUtil.validateNotNull(keys);
    if (keys.isEmpty())
      return; 
    removeAllInternal(keys);
  }
  
  public void removeAll() {
    ensureOpen();
    removeAllInternal(null);
  }
  
  public void clear() {
    ensureOpen();
    clearInternal();
  }
  
  public <C extends Configuration<K, V>> C getConfiguration(Class<C> clazz) {
    if (clazz.isInstance(this.cacheConfig))
      return (C)(Configuration)clazz.cast(this.cacheConfig.getAsReadOnly()); 
    throw new IllegalArgumentException("The configuration class " + clazz + " is not supported by this implementation");
  }
  
  public <T> T invoke(K key, EntryProcessor<K, V, T> entryProcessor, Object... arguments) throws EntryProcessorException {
    ensureOpen();
    CacheProxyUtil.validateNotNull(key);
    Preconditions.checkNotNull(entryProcessor, "Entry Processor is null");
    Data keyData = this.serializationService.toData(key);
    Integer completionId = registerCompletionLatch(1);
    Operation op = this.operationProvider.createEntryProcessorOperation(keyData, completionId, entryProcessor, arguments);
    try {
      OperationService operationService = getNodeEngine().getOperationService();
      int partitionId = getPartitionId(keyData);
      InternalCompletableFuture<T> future = operationService.invokeOnPartition(getServiceName(), op, partitionId);
      T safely = (T)future.join();
      waitCompletionLatch(completionId);
      return safely;
    } catch (CacheException ce) {
      deregisterCompletionLatch(completionId);
      throw ce;
    } catch (Exception e) {
      deregisterCompletionLatch(completionId);
      throw new EntryProcessorException(e);
    } 
  }
  
  public <T> Map<K, EntryProcessorResult<T>> invokeAll(Set<? extends K> keys, EntryProcessor<K, V, T> entryProcessor, Object... arguments) {
    ensureOpen();
    CacheProxyUtil.validateNotNull(keys);
    Preconditions.checkNotNull(entryProcessor, "Entry Processor is null");
    Map<K, EntryProcessorResult<T>> allResult = MapUtil.createHashMap(keys.size());
    for (K key : keys) {
      CacheEntryProcessorResult<T> ceResult;
      CacheProxyUtil.validateNotNull(key);
      try {
        T result = (T)invoke(key, entryProcessor, arguments);
        ceResult = (result != null) ? new CacheEntryProcessorResult(result) : null;
      } catch (Exception e) {
        ceResult = new CacheEntryProcessorResult<T>(e);
      } 
      if (ceResult != null)
        allResult.put(key, ceResult); 
    } 
    return allResult;
  }
  
  public <T> T unwrap(Class<T> clazz) {
    if (clazz.isAssignableFrom(getClass()))
      return (T)clazz.cast(this); 
    throw new IllegalArgumentException("Unwrapping to " + clazz + " is not supported by this implementation");
  }
  
  public void registerCacheEntryListener(CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration) { registerCacheEntryListener(cacheEntryListenerConfiguration, true); }
  
  public void registerCacheEntryListener(CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration, boolean addToConfig) {
    ensureOpen();
    Preconditions.checkNotNull(cacheEntryListenerConfiguration, "CacheEntryListenerConfiguration can't be null");
    CacheEventListenerAdaptor<K, V> entryListener = new CacheEventListenerAdaptor<K, V>(this, cacheEntryListenerConfiguration, getNodeEngine().getSerializationService());
    String regId = ((ICacheService)getService()).registerListener(getDistributedObjectName(), entryListener, entryListener, false);
    if (regId != null) {
      if (addToConfig)
        this.cacheConfig.addCacheEntryListenerConfiguration(cacheEntryListenerConfiguration); 
      addListenerLocally(regId, cacheEntryListenerConfiguration);
      if (addToConfig)
        updateCacheListenerConfigOnOtherNodes(cacheEntryListenerConfiguration, true); 
    } 
  }
  
  public void deregisterCacheEntryListener(CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration) {
    Preconditions.checkNotNull(cacheEntryListenerConfiguration, "CacheEntryListenerConfiguration can't be null");
    String regId = getListenerIdLocal(cacheEntryListenerConfiguration);
    if (regId != null && (
      (ICacheService)getService()).deregisterListener(getDistributedObjectName(), regId)) {
      removeListenerLocally(cacheEntryListenerConfiguration);
      this.cacheConfig.removeCacheEntryListenerConfiguration(cacheEntryListenerConfiguration);
      updateCacheListenerConfigOnOtherNodes(cacheEntryListenerConfiguration, false);
    } 
  }
  
  private void updateCacheListenerConfigOnOtherNodes(CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration, boolean isRegister) {
    OperationService operationService = getNodeEngine().getOperationService();
    Collection<Member> members = getNodeEngine().getClusterService().getMembers();
    for (Member member : members) {
      if (!member.localMember()) {
        CacheListenerRegistrationOperation cacheListenerRegistrationOperation = new CacheListenerRegistrationOperation(getDistributedObjectName(), cacheEntryListenerConfiguration, isRegister);
        operationService.invokeOnTarget("hz:impl:cacheService", cacheListenerRegistrationOperation, member.getAddress());
      } 
    } 
  }
  
  public Iterator<Cache.Entry<K, V>> iterator() {
    ensureOpen();
    return new ClusterWideIterator(this, false);
  }
  
  public Iterator<Cache.Entry<K, V>> iterator(int fetchSize) {
    ensureOpen();
    return new ClusterWideIterator(this, fetchSize, false);
  }
  
  public Iterator<Cache.Entry<K, V>> iterator(int fetchSize, int partitionId, boolean prefetchValues) {
    ensureOpen();
    return new CachePartitionIterator(this, fetchSize, partitionId, prefetchValues);
  }
  
  public String addPartitionLostListener(CachePartitionLostListener listener) {
    Preconditions.checkNotNull(listener, "CachePartitionLostListener can't be null");
    CachePartitionLostEventFilter cachePartitionLostEventFilter = new CachePartitionLostEventFilter();
    InternalCachePartitionLostListenerAdapter listenerAdapter = new InternalCachePartitionLostListenerAdapter(listener);
    injectDependencies(listener);
    EventRegistration registration = ((ICacheService)getService()).getNodeEngine().getEventService().registerListener("hz:impl:cacheService", this.name, cachePartitionLostEventFilter, listenerAdapter);
    return registration.getId();
  }
  
  public boolean removePartitionLostListener(String id) {
    Preconditions.checkNotNull(id, "Listener ID should not be null!");
    return ((ICacheService)getService()).getNodeEngine().getEventService()
      .deregisterListener("hz:impl:cacheService", this.name, id);
  }
  
  public ICompletableFuture<EventJournalInitialSubscriberState> subscribeToEventJournal(int partitionId) {
    CacheEventJournalSubscribeOperation op = new CacheEventJournalSubscribeOperation(this.nameWithPrefix);
    op.setPartitionId(partitionId);
    return getNodeEngine().getOperationService().invokeOnPartition(op);
  }
  
  public <T> ICompletableFuture<ReadResultSet<T>> readFromEventJournal(long startSequence, int minSize, int maxSize, int partitionId, Predicate<? super EventJournalCacheEvent<K, V>> predicate, Function<? super EventJournalCacheEvent<K, V>, ? extends T> projection) {
    if (maxSize < minSize)
      throw new IllegalArgumentException("maxSize " + maxSize + " must be greater or equal to minSize " + minSize); 
    CacheEventJournalReadOperation<K, V, T> op = new CacheEventJournalReadOperation<K, V, T>(this.nameWithPrefix, startSequence, minSize, maxSize, predicate, projection);
    op.setPartitionId(partitionId);
    return getNodeEngine().getOperationService().invokeOnPartition(op);
  }
}
