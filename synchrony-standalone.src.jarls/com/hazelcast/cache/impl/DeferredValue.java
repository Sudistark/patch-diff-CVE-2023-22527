package com.hazelcast.cache.impl;

import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.serialization.SerializationService;
import java.util.Collections;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

public final class DeferredValue<V> extends Object {
  private static final DeferredValue NULL_VALUE;
  
  static  {
    nullValue = new DeferredValue();
    nullValue.valueExists = true;
    nullValue.serializedValueExists = true;
    NULL_VALUE = nullValue;
  }
  
  public V get(SerializationService serializationService) {
    if (!this.valueExists) {
      assert serializationService != null;
      this.value = serializationService.toObject(this.serializedValue);
      this.valueExists = true;
    } 
    return (V)this.value;
  }
  
  public Data getSerializedValue(SerializationService serializationService) {
    if (!this.serializedValueExists) {
      assert serializationService != null;
      this.serializedValue = serializationService.toData(this.value);
      this.serializedValueExists = true;
    } 
    return this.serializedValue;
  }
  
  public DeferredValue<V> shallowCopy() {
    if (this == NULL_VALUE)
      return NULL_VALUE; 
    DeferredValue<V> copy = new DeferredValue<V>();
    if (this.serializedValueExists) {
      copy.serializedValueExists = true;
      copy.serializedValue = this.serializedValue;
    } 
    if (this.valueExists) {
      copy.valueExists = true;
      copy.value = this.value;
    } 
    return copy;
  }
  
  public boolean equals(Object o) {
    if (this == o)
      return true; 
    if (o == null || getClass() != o.getClass())
      return false; 
    DeferredValue<?> deferredValue = (DeferredValue)o;
    if (this.valueExists && deferredValue.valueExists)
      return (this.value != null) ? this.value.equals(deferredValue.value) : ((deferredValue.value == null) ? 1 : 0); 
    if (this.serializedValueExists && deferredValue.serializedValueExists)
      return (this.serializedValue != null) ? this.serializedValue.equals(deferredValue.serializedValue) : ((deferredValue.serializedValue == null) ? 1 : 0); 
    throw new IllegalArgumentException("Cannot compare serialized vs deserialized value");
  }
  
  public int hashCode() {
    result = (this.serializedValue != null) ? this.serializedValue.hashCode() : 0;
    result = 31 * result + ((this.value != null) ? this.value.hashCode() : 0);
    result = 31 * result + (this.valueExists ? 1 : 0);
    return 31 * result + (this.serializedValueExists ? 1 : 0);
  }
  
  public static <V> DeferredValue<V> withSerializedValue(Data serializedValue) {
    if (serializedValue == null)
      return NULL_VALUE; 
    DeferredValue<V> deferredValue = new DeferredValue<V>();
    deferredValue.serializedValue = serializedValue;
    deferredValue.serializedValueExists = true;
    return deferredValue;
  }
  
  public static <V> DeferredValue<V> withValue(V value) {
    if (value == null)
      return NULL_VALUE; 
    DeferredValue<V> deferredValue = new DeferredValue<V>();
    deferredValue.value = value;
    deferredValue.valueExists = true;
    return deferredValue;
  }
  
  public static <V> DeferredValue<V> withNullValue() { return NULL_VALUE; }
  
  public static <V> Set<DeferredValue<V>> concurrentSetOfValues(Set<V> values) {
    Set<DeferredValue<V>> result = Collections.newSetFromMap(new ConcurrentHashMap());
    for (V value : values)
      result.add(withValue(value)); 
    return result;
  }
  
  public static <V> Set<V> asPassThroughSet(Set<DeferredValue<V>> deferredValues, SerializationService serializationService) { return new DeferredValueSet(serializationService, deferredValues); }
}
