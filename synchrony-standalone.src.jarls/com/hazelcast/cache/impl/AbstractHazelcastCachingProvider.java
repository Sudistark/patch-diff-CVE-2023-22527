package com.hazelcast.cache.impl;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.logging.ILogger;
import com.hazelcast.logging.Logger;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.StringUtil;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.WeakHashMap;
import javax.cache.CacheException;
import javax.cache.CacheManager;
import javax.cache.configuration.OptionalFeature;
import javax.cache.spi.CachingProvider;

public abstract class AbstractHazelcastCachingProvider implements CachingProvider {
  protected static final ILogger LOGGER = Logger.getLogger(com.hazelcast.cache.HazelcastCachingProvider.class);
  
  static  {
    supportedSchemes = new HashSet();
    supportedSchemes.add("classpath");
    supportedSchemes.add("file");
    supportedSchemes.add("http");
    supportedSchemes.add("https");
    SUPPORTED_SCHEMES = supportedSchemes;
  }
  
  protected final boolean namedDefaultHzInstance = Boolean.parseBoolean(System.getProperty("hazelcast.named.jcache.instance", "true"));
  
  private final Map<ClassLoader, Map<URI, AbstractHazelcastCacheManager>> cacheManagers = new WeakHashMap();
  
  private final ClassLoader defaultClassLoader = getClass().getClassLoader();
  
  public static final String SHARED_JCACHE_INSTANCE_NAME = "_hzinstance_jcache_shared";
  
  public static final String NAMED_JCACHE_HZ_INSTANCE = "hazelcast.named.jcache.instance";
  
  private static final String INVALID_HZ_INSTANCE_SPECIFICATION_MESSAGE = "No available Hazelcast instance. Please specify your Hazelcast configuration file path via \"HazelcastCachingProvider.HAZELCAST_CONFIG_LOCATION\" property or specify Hazelcast instance name via \"HazelcastCachingProvider.HAZELCAST_INSTANCE_NAME\" property in the \"properties\" parameter.";
  
  private static final Set<String> SUPPORTED_SCHEMES;
  
  private final URI defaultURI;
  
  protected AbstractHazelcastCachingProvider() {
    try {
      this.defaultURI = new URI("hazelcast");
    } catch (URISyntaxException e) {
      throw new CacheException("Cannot create default URI", e);
    } 
  }
  
  public CacheManager getCacheManager(URI uri, ClassLoader classLoader, Properties properties) {
    URI managerURI = getManagerUri(uri);
    ClassLoader managerClassLoader = getManagerClassLoader(classLoader);
    Properties managerProperties = (properties == null) ? new Properties() : properties;
    synchronized (this.cacheManagers) {
      Map<URI, AbstractHazelcastCacheManager> cacheManagersByURI = (Map)this.cacheManagers.get(managerClassLoader);
      if (cacheManagersByURI == null) {
        cacheManagersByURI = new HashMap<URI, AbstractHazelcastCacheManager>();
        this.cacheManagers.put(managerClassLoader, cacheManagersByURI);
      } 
      AbstractHazelcastCacheManager cacheManager = (AbstractHazelcastCacheManager)cacheManagersByURI.get(managerURI);
      if (cacheManager == null || cacheManager.isClosed())
        try {
          cacheManager = createHazelcastCacheManager(uri, classLoader, managerProperties);
          cacheManagersByURI.put(managerURI, cacheManager);
        } catch (Exception e) {
          throw new CacheException("Error opening URI [" + managerURI.toString() + ']', e);
        }  
      return cacheManager;
    } 
  }
  
  public ClassLoader getDefaultClassLoader() { return this.defaultClassLoader; }
  
  public URI getDefaultURI() { return this.defaultURI; }
  
  public Properties getDefaultProperties() { return null; }
  
  public CacheManager getCacheManager(URI uri, ClassLoader classLoader) { return getCacheManager(uri, classLoader, null); }
  
  public CacheManager getCacheManager() { return getCacheManager(null, null, null); }
  
  public void close() {
    synchronized (this.cacheManagers) {
      for (Map<URI, AbstractHazelcastCacheManager> cacheManagersByURI : this.cacheManagers.values()) {
        for (AbstractHazelcastCacheManager cacheManager : cacheManagersByURI.values()) {
          if (cacheManager.isDefaultClassLoader) {
            cacheManager.close();
            continue;
          } 
          cacheManager.destroy();
        } 
      } 
    } 
    this.cacheManagers.clear();
    shutdownHazelcastInstance();
  }
  
  private void shutdownHazelcastInstance() {
    HazelcastInstance localInstanceRef = this.hazelcastInstance;
    if (localInstanceRef != null)
      localInstanceRef.shutdown(); 
    this.hazelcastInstance = null;
  }
  
  public void close(ClassLoader classLoader) {
    ClassLoader managerClassLoader = getManagerClassLoader(classLoader);
    synchronized (this.cacheManagers) {
      Map<URI, AbstractHazelcastCacheManager> cacheManagersByURI = (Map)this.cacheManagers.get(managerClassLoader);
      if (cacheManagersByURI != null)
        for (CacheManager cacheManager : cacheManagersByURI.values())
          cacheManager.close();  
    } 
  }
  
  public void close(URI uri, ClassLoader classLoader) {
    URI managerURI = getManagerUri(uri);
    ClassLoader managerClassLoader = getManagerClassLoader(classLoader);
    synchronized (this.cacheManagers) {
      Map<URI, AbstractHazelcastCacheManager> cacheManagersByURI = (Map)this.cacheManagers.get(managerClassLoader);
      if (cacheManagersByURI != null) {
        CacheManager cacheManager = (CacheManager)cacheManagersByURI.remove(managerURI);
        if (cacheManager != null)
          cacheManager.close(); 
        if (cacheManagersByURI.isEmpty())
          this.cacheManagers.remove(classLoader); 
      } 
    } 
  }
  
  public boolean isSupported(OptionalFeature optionalFeature) {
    switch (null.$SwitchMap$javax$cache$configuration$OptionalFeature[optionalFeature.ordinal()]) {
      case 1:
        return false;
    } 
    return false;
  }
  
  private URI getManagerUri(URI uri) { return (uri == null) ? this.defaultURI : uri; }
  
  private ClassLoader getManagerClassLoader(ClassLoader classLoader) { return (classLoader == null) ? this.defaultClassLoader : classLoader; }
  
  private <T extends AbstractHazelcastCacheManager> T createHazelcastCacheManager(URI uri, ClassLoader classLoader, Properties managerProperties) {
    HazelcastInstance instance;
    try {
      instance = getOrCreateInstance(uri, classLoader, managerProperties);
      if (instance == null)
        throw new IllegalArgumentException("No available Hazelcast instance. Please specify your Hazelcast configuration file path via \"HazelcastCachingProvider.HAZELCAST_CONFIG_LOCATION\" property or specify Hazelcast instance name via \"HazelcastCachingProvider.HAZELCAST_INSTANCE_NAME\" property in the \"properties\" parameter."); 
    } catch (Exception e) {
      throw ExceptionUtil.rethrow(e);
    } 
    return (T)createCacheManager(instance, uri, classLoader, managerProperties);
  }
  
  protected boolean isConfigLocation(URI location) {
    String scheme = location.getScheme();
    if (scheme == null)
      try {
        String resolvedPlaceholder = System.getProperty(location.getRawSchemeSpecificPart());
        if (resolvedPlaceholder == null)
          return false; 
        location = new URI(resolvedPlaceholder);
        scheme = location.getScheme();
      } catch (URISyntaxException e) {
        return false;
      }  
    return (scheme != null && SUPPORTED_SCHEMES.contains(scheme.toLowerCase(StringUtil.LOCALE_INTERNAL)));
  }
  
  protected abstract HazelcastInstance getOrCreateInstance(URI paramURI, ClassLoader paramClassLoader, Properties paramProperties) throws URISyntaxException, IOException;
  
  protected abstract <T extends AbstractHazelcastCacheManager> T createCacheManager(HazelcastInstance paramHazelcastInstance, URI paramURI, ClassLoader paramClassLoader, Properties paramProperties);
}
