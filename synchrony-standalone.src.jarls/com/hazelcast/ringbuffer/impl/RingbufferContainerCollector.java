package com.hazelcast.ringbuffer.impl;

import com.hazelcast.config.MergePolicyConfig;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.ObjectNamespace;
import com.hazelcast.spi.impl.merge.AbstractContainerCollector;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;

class RingbufferContainerCollector extends AbstractContainerCollector<RingbufferContainer> {
  private final Map<Integer, Map<ObjectNamespace, RingbufferContainer>> containers;
  
  RingbufferContainerCollector(NodeEngine nodeEngine, Map<Integer, Map<ObjectNamespace, RingbufferContainer>> containers) {
    super(nodeEngine);
    this.containers = containers;
  }
  
  protected Iterator<RingbufferContainer> containerIterator(int partitionId) {
    Map<ObjectNamespace, RingbufferContainer> containerMap = (Map)this.containers.get(Integer.valueOf(partitionId));
    if (containerMap == null)
      return new AbstractContainerCollector.EmptyIterator(this); 
    return containerMap.values().iterator();
  }
  
  protected MergePolicyConfig getMergePolicyConfig(RingbufferContainer container) { return container.getConfig().getMergePolicyConfig(); }
  
  protected void destroy(RingbufferContainer container) { container.clear(); }
  
  protected void destroyBackup(RingbufferContainer container) { container.clear(); }
  
  protected boolean isMergeable(RingbufferContainer container) {
    String containerServiceName = container.getNamespace().getServiceName();
    return "hz:impl:ringbufferService".equals(containerServiceName);
  }
  
  protected int getMergingValueCount() {
    int size = 0;
    for (Collection<RingbufferContainer> containers : getCollectedContainers().values()) {
      for (RingbufferContainer container : containers)
        size = (int)(size + container.size()); 
    } 
    return size;
  }
}
