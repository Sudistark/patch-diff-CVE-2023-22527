package com.hazelcast.ringbuffer.impl.operations;

import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.ringbuffer.OverflowPolicy;
import com.hazelcast.ringbuffer.impl.RingbufferContainer;
import com.hazelcast.spi.BackupAwareOperation;
import com.hazelcast.spi.Notifier;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.WaitNotifyKey;
import com.hazelcast.spi.impl.MutatingOperation;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.IOException;

public class AddAllOperation extends AbstractRingBufferOperation implements Notifier, BackupAwareOperation, MutatingOperation {
  private OverflowPolicy overflowPolicy;
  
  private Data[] items;
  
  private long lastSequence;
  
  public AddAllOperation() {}
  
  @SuppressFBWarnings({"EI_EXPOSE_REP"})
  public AddAllOperation(String name, Data[] items, OverflowPolicy overflowPolicy) {
    super(name);
    this.items = items;
    this.overflowPolicy = overflowPolicy;
  }
  
  public void run() {
    RingbufferContainer ringbuffer = getRingBufferContainer();
    if (this.overflowPolicy == OverflowPolicy.FAIL && 
      ringbuffer.remainingCapacity() < this.items.length) {
      this.lastSequence = -1L;
      return;
    } 
    this.lastSequence = ringbuffer.addAll(this.items);
  }
  
  public Object getResponse() { return Long.valueOf(this.lastSequence); }
  
  public boolean shouldNotify() { return (this.lastSequence != -1L); }
  
  public WaitNotifyKey getNotifiedKey() {
    RingbufferContainer ringbuffer = getRingBufferContainer();
    return ringbuffer.getRingEmptyWaitNotifyKey();
  }
  
  public boolean shouldBackup() { return (this.lastSequence != -1L); }
  
  public int getSyncBackupCount() {
    RingbufferContainer ringbuffer = getRingBufferContainer();
    return ringbuffer.getConfig().getBackupCount();
  }
  
  public int getAsyncBackupCount() {
    RingbufferContainer ringbuffer = getRingBufferContainer();
    return ringbuffer.getConfig().getAsyncBackupCount();
  }
  
  public Operation getBackupOperation() { return new AddAllBackupOperation(this.name, this.lastSequence, this.items); }
  
  public int getId() { return 7; }
  
  protected void writeInternal(ObjectDataOutput out) throws IOException {
    super.writeInternal(out);
    out.writeInt(this.overflowPolicy.getId());
    out.writeInt(this.items.length);
    for (Data item : this.items)
      out.writeData(item); 
  }
  
  protected void readInternal(ObjectDataInput in) throws IOException {
    super.readInternal(in);
    this.overflowPolicy = OverflowPolicy.getById(in.readInt());
    int length = in.readInt();
    this.items = new Data[length];
    for (int k = 0; k < this.items.length; k++)
      this.items[k] = in.readData(); 
  }
}
