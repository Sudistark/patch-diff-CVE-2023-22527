package com.hazelcast.ringbuffer.impl;

import com.hazelcast.config.InMemoryFormat;
import com.hazelcast.config.RingbufferConfig;
import com.hazelcast.core.HazelcastException;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.nio.serialization.IdentifiedDataSerializable;
import com.hazelcast.nio.serialization.impl.Versioned;
import com.hazelcast.ringbuffer.StaleSequenceException;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Notifier;
import com.hazelcast.spi.ObjectNamespace;
import com.hazelcast.spi.WaitNotifyKey;
import com.hazelcast.spi.serialization.SerializationService;
import java.io.IOException;
import java.util.concurrent.TimeUnit;

public class RingbufferContainer<T, E> extends Object implements IdentifiedDataSerializable, Notifier, Versioned {
  private static final long TTL_DISABLED = 0L;
  
  private ObjectNamespace namespace;
  
  private RingbufferWaitNotifyKey emptyRingWaitNotifyKey;
  
  private RingbufferExpirationPolicy expirationPolicy;
  
  private InMemoryFormat inMemoryFormat;
  
  private RingbufferConfig config;
  
  private RingbufferStoreWrapper store;
  
  private SerializationService serializationService;
  
  private Ringbuffer<E> ringbuffer;
  
  public RingbufferContainer() {}
  
  public RingbufferContainer(ObjectNamespace namespace, int partitionId) {
    this.namespace = namespace;
    this.emptyRingWaitNotifyKey = new RingbufferWaitNotifyKey(namespace, partitionId);
  }
  
  public RingbufferContainer(ObjectNamespace namespace, RingbufferConfig config, NodeEngine nodeEngine, int partitionId) {
    this(namespace, partitionId);
    this.inMemoryFormat = config.getInMemoryFormat();
    this.ringbuffer = new ArrayRingbuffer(config.getCapacity());
    long ttlMs = TimeUnit.SECONDS.toMillis(config.getTimeToLiveSeconds());
    if (ttlMs != 0L)
      this.expirationPolicy = new RingbufferExpirationPolicy(this.ringbuffer.getCapacity(), ttlMs); 
    init(config, nodeEngine);
  }
  
  public void init(RingbufferConfig config, NodeEngine nodeEngine) {
    this.config = config;
    this.serializationService = nodeEngine.getSerializationService();
    initRingbufferStore(nodeEngine.getConfigClassLoader());
  }
  
  private void initRingbufferStore(ClassLoader configClassLoader) {
    this.store = RingbufferStoreWrapper.create(this.namespace, this.config
        .getRingbufferStoreConfig(), this.config
        .getInMemoryFormat(), this.serializationService, configClassLoader);
    if (this.store.isEnabled())
      try {
        long storeSequence = this.store.getLargestSequence();
        if (tailSequence() < storeSequence) {
          this.ringbuffer.setTailSequence(storeSequence);
          this.ringbuffer.setHeadSequence(storeSequence + 1L);
        } 
      } catch (Exception e) {
        throw new HazelcastException(e);
      }  
  }
  
  public RingbufferStoreWrapper getStore() { return this.store; }
  
  public RingbufferWaitNotifyKey getRingEmptyWaitNotifyKey() { return this.emptyRingWaitNotifyKey; }
  
  public RingbufferConfig getConfig() { return this.config; }
  
  public long tailSequence() { return this.ringbuffer.tailSequence(); }
  
  public long headSequence() { return this.ringbuffer.headSequence(); }
  
  public void setHeadSequence(long sequence) { this.ringbuffer.setHeadSequence(sequence); }
  
  public void setTailSequence(long sequence) { this.ringbuffer.setTailSequence(sequence); }
  
  public long getCapacity() { return this.ringbuffer.getCapacity(); }
  
  public long size() { return this.ringbuffer.size(); }
  
  public boolean isEmpty() { return this.ringbuffer.isEmpty(); }
  
  public boolean shouldWait(long sequence) {
    checkBlockableReadSequence(sequence);
    return (sequence == this.ringbuffer.tailSequence() + 1L);
  }
  
  public long remainingCapacity() {
    if (this.expirationPolicy != null)
      return this.ringbuffer.getCapacity() - size(); 
    return this.ringbuffer.getCapacity();
  }
  
  public long add(T item) {
    long nextSequence = this.ringbuffer.peekNextTailSequence();
    if (this.store.isEnabled())
      try {
        this.store.store(nextSequence, convertToData(item));
      } catch (Exception e) {
        throw new HazelcastException(e);
      }  
    long storedSequence = addInternal(item);
    if (storedSequence != nextSequence)
      throw new IllegalStateException("Sequence we stored the item with and Ringbuffer sequence differs. Was the Ringbuffer mutated from multiple threads?"); 
    return storedSequence;
  }
  
  public long addAll(T[] items) {
    long firstSequence = this.ringbuffer.peekNextTailSequence();
    long lastSequence = this.ringbuffer.peekNextTailSequence();
    if (this.store.isEnabled() && items.length != 0)
      try {
        this.store.storeAll(firstSequence, convertToData(items));
      } catch (Exception e) {
        throw new HazelcastException(e);
      }  
    for (int i = 0; i < items.length; i++)
      lastSequence = addInternal(items[i]); 
    return lastSequence;
  }
  
  public void set(long sequenceId, T item) {
    E rbItem = (E)convertToRingbufferFormat(item);
    this.ringbuffer.set(sequenceId, rbItem);
    if (sequenceId > tailSequence()) {
      this.ringbuffer.setTailSequence(sequenceId);
      if (this.ringbuffer.size() > this.ringbuffer.getCapacity())
        this.ringbuffer.setHeadSequence(this.ringbuffer.tailSequence() - this.ringbuffer.getCapacity() + 1L); 
    } 
    if (sequenceId < headSequence())
      this.ringbuffer.setHeadSequence(sequenceId); 
    if (this.expirationPolicy != null)
      this.expirationPolicy.setExpirationAt(sequenceId); 
  }
  
  public Data readAsData(long sequence) {
    checkReadSequence(sequence);
    Object rbItem = readOrLoadItem(sequence);
    return this.serializationService.toData(rbItem);
  }
  
  public long readMany(long beginSequence, ReadResultSetImpl result) {
    checkReadSequence(beginSequence);
    long seq = beginSequence;
    while (seq <= this.ringbuffer.tailSequence()) {
      result.addItem(seq, readOrLoadItem(seq));
      seq++;
      if (result.isMaxSizeReached())
        break; 
    } 
    return seq;
  }
  
  public void cleanup() {
    if (this.expirationPolicy != null)
      this.expirationPolicy.cleanup(this.ringbuffer); 
  }
  
  public boolean isStaleSequence(long sequence) { return (sequence < headSequence() && !this.store.isEnabled()); }
  
  public boolean isTooLargeSequence(long sequence) { return (sequence > tailSequence() + 1L); }
  
  public void checkBlockableReadSequence(long readSequence) {
    if (isTooLargeSequence(readSequence))
      throw new IllegalArgumentException("sequence:" + readSequence + " is too large. The current tailSequence is:" + 
          tailSequence()); 
    if (isStaleSequence(readSequence))
      throw new StaleSequenceException("sequence:" + readSequence + " is too small and data store is disabled. The current headSequence is:" + 
          
          headSequence() + " tailSequence is:" + 
          tailSequence(), headSequence()); 
  }
  
  private void checkReadSequence(long sequence) {
    long tailSequence = this.ringbuffer.tailSequence();
    if (sequence > tailSequence)
      throw new IllegalArgumentException("sequence:" + sequence + " is too large. The current tailSequence is:" + tailSequence); 
    if (isStaleSequence(sequence))
      throw new StaleSequenceException("sequence:" + sequence + " is too small and data store is disabled. The current headSequence is:" + 
          
          headSequence() + " tailSequence is:" + tailSequence, 
          headSequence()); 
  }
  
  private Object readOrLoadItem(long sequence) {
    Object item;
    if (sequence < this.ringbuffer.headSequence() && this.store.isEnabled()) {
      item = this.store.load(sequence);
    } else {
      item = this.ringbuffer.read(sequence);
    } 
    return item;
  }
  
  private long addInternal(T item) {
    E rbItem = (E)convertToRingbufferFormat(item);
    long tailSequence = this.ringbuffer.add(rbItem);
    if (this.expirationPolicy != null)
      this.expirationPolicy.setExpirationAt(tailSequence); 
    return tailSequence;
  }
  
  private E convertToRingbufferFormat(Object item) { return (E)((this.inMemoryFormat == InMemoryFormat.OBJECT) ? this.serializationService
      .toObject(item) : this.serializationService
      .toData(item)); }
  
  private Data convertToData(Object item) { return this.serializationService.toData(item); }
  
  private Data[] convertToData(T[] items) {
    if (items == null || items.length == 0)
      return new Data[0]; 
    if (items[0] instanceof Data)
      return (Data[])items; 
    Data[] ret = new Data[items.length];
    for (int i = 0; i < items.length; i++)
      ret[i] = convertToData(items[i]); 
    return ret;
  }
  
  public void writeData(ObjectDataOutput out) throws IOException {
    boolean ttlEnabled = (this.expirationPolicy != null);
    out.writeLong(this.ringbuffer.tailSequence());
    out.writeLong(this.ringbuffer.headSequence());
    out.writeInt((int)this.ringbuffer.getCapacity());
    out.writeLong(ttlEnabled ? this.expirationPolicy.getTtlMs() : 0L);
    out.writeInt(this.inMemoryFormat.ordinal());
    long now = System.currentTimeMillis();
    long seq;
    for (seq = this.ringbuffer.headSequence(); seq <= this.ringbuffer.tailSequence(); seq++) {
      if (this.inMemoryFormat == InMemoryFormat.BINARY) {
        out.writeData((Data)this.ringbuffer.read(seq));
      } else {
        out.writeObject(this.ringbuffer.read(seq));
      } 
      if (ttlEnabled) {
        long deltaMs = this.expirationPolicy.getExpirationAt(seq) - now;
        out.writeLong(deltaMs);
      } 
    } 
  }
  
  public void readData(ObjectDataInput in) throws IOException {
    long tailSequence = in.readLong();
    long headSequence = in.readLong();
    int capacity = in.readInt();
    long ttlMs = in.readLong();
    this.inMemoryFormat = InMemoryFormat.values()[in.readInt()];
    this.ringbuffer = new ArrayRingbuffer(capacity);
    this.ringbuffer.setTailSequence(tailSequence);
    this.ringbuffer.setHeadSequence(headSequence);
    boolean ttlEnabled = (ttlMs != 0L);
    if (ttlEnabled)
      this.expirationPolicy = new RingbufferExpirationPolicy(capacity, ttlMs); 
    long now = System.currentTimeMillis();
    long seq;
    for (seq = headSequence; seq <= tailSequence; seq++) {
      if (this.inMemoryFormat == InMemoryFormat.BINARY) {
        this.ringbuffer.set(seq, in.readData());
      } else {
        this.ringbuffer.set(seq, in.readObject());
      } 
      if (ttlEnabled) {
        long delta = in.readLong();
        this.expirationPolicy.setExpirationAt(seq, delta + now);
      } 
    } 
  }
  
  public Ringbuffer<E> getRingbuffer() { return this.ringbuffer; }
  
  RingbufferExpirationPolicy getExpirationPolicy() { return this.expirationPolicy; }
  
  public ObjectNamespace getNamespace() { return this.namespace; }
  
  public int getFactoryId() { return RingbufferDataSerializerHook.F_ID; }
  
  public int getId() { return 10; }
  
  public boolean shouldNotify() { return true; }
  
  public WaitNotifyKey getNotifiedKey() { return this.emptyRingWaitNotifyKey; }
  
  public void clear() {
    this.ringbuffer.clear();
    if (this.expirationPolicy != null)
      this.expirationPolicy.clear(); 
  }
}
