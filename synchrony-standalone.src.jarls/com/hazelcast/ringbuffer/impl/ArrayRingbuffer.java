package com.hazelcast.ringbuffer.impl;

import com.hazelcast.ringbuffer.StaleSequenceException;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.Arrays;
import java.util.Iterator;

public class ArrayRingbuffer<E> extends Object implements Ringbuffer<E> {
  private E[] ringItems;
  
  private long tailSequence;
  
  private long headSequence;
  
  private int capacity;
  
  public ArrayRingbuffer(int capacity) {
    this.tailSequence = -1L;
    this.headSequence = this.tailSequence + 1L;
    this.capacity = capacity;
    this.ringItems = (Object[])new Object[capacity];
  }
  
  public long tailSequence() { return this.tailSequence; }
  
  public long peekNextTailSequence() { return this.tailSequence + 1L; }
  
  public void setTailSequence(long sequence) { this.tailSequence = sequence; }
  
  public long headSequence() { return this.headSequence; }
  
  public void setHeadSequence(long sequence) { this.headSequence = sequence; }
  
  public long getCapacity() { return this.capacity; }
  
  public long size() { return this.tailSequence - this.headSequence + 1L; }
  
  public boolean isEmpty() { return (size() == 0L); }
  
  public long add(E item) {
    this.tailSequence++;
    if (this.tailSequence - this.capacity == this.headSequence)
      this.headSequence++; 
    int index = toIndex(this.tailSequence);
    this.ringItems[index] = item;
    return this.tailSequence;
  }
  
  public E read(long sequence) {
    checkReadSequence(sequence);
    return (E)this.ringItems[toIndex(sequence)];
  }
  
  public void checkBlockableReadSequence(long readSequence) {
    if (readSequence > this.tailSequence + 1L)
      throw new IllegalArgumentException("sequence:" + readSequence + " is too large. The current tailSequence is:" + this.tailSequence); 
    if (readSequence < this.headSequence)
      throw new StaleSequenceException("sequence:" + readSequence + " is too small. The current headSequence is:" + this.headSequence + " tailSequence is:" + this.tailSequence, this.headSequence); 
  }
  
  public void checkReadSequence(long sequence) {
    if (sequence > this.tailSequence)
      throw new IllegalArgumentException("sequence:" + sequence + " is too large. The current tailSequence is:" + this.tailSequence); 
    if (sequence < this.headSequence)
      throw new StaleSequenceException("sequence:" + sequence + " is too small. The current headSequence is:" + this.headSequence + " tailSequence is:" + this.tailSequence, this.headSequence); 
  }
  
  private int toIndex(long sequence) { return (int)(sequence % this.ringItems.length); }
  
  public void set(long seq, E data) { this.ringItems[toIndex(seq)] = data; }
  
  public void clear() {
    Arrays.fill(this.ringItems, null);
    this.tailSequence = -1L;
    this.headSequence = this.tailSequence + 1L;
  }
  
  public Iterator<E> iterator() { return new ReadOnlyRingbufferIterator(this); }
  
  @SuppressFBWarnings({"EI_EXPOSE_REP"})
  public E[] getItems() { return (E[])this.ringItems; }
}
