package com.hazelcast.client.impl;

import com.hazelcast.cache.impl.JCacheDetector;
import com.hazelcast.client.impl.operations.GetConnectedClientsOperation;
import com.hazelcast.client.impl.operations.OnJoinClientOperation;
import com.hazelcast.client.impl.protocol.ClientExceptions;
import com.hazelcast.client.impl.protocol.ClientMessage;
import com.hazelcast.client.impl.protocol.MessageTaskFactory;
import com.hazelcast.client.impl.protocol.task.MessageTask;
import com.hazelcast.core.Client;
import com.hazelcast.core.ClientListener;
import com.hazelcast.core.ClientType;
import com.hazelcast.core.Member;
import com.hazelcast.instance.EndpointQualifier;
import com.hazelcast.instance.MemberImpl;
import com.hazelcast.instance.Node;
import com.hazelcast.internal.cluster.ClusterService;
import com.hazelcast.internal.util.RuntimeAvailableProcessors;
import com.hazelcast.internal.util.executor.UnblockablePoolExecutorThreadFactory;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.Connection;
import com.hazelcast.nio.ConnectionListener;
import com.hazelcast.nio.tcp.TcpIpConnection;
import com.hazelcast.security.SecurityContext;
import com.hazelcast.spi.CoreService;
import com.hazelcast.spi.EventPublishingService;
import com.hazelcast.spi.EventService;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.ManagedService;
import com.hazelcast.spi.MemberAttributeServiceEvent;
import com.hazelcast.spi.MembershipAwareService;
import com.hazelcast.spi.MembershipServiceEvent;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.PreJoinAwareService;
import com.hazelcast.spi.ProxyService;
import com.hazelcast.spi.exception.TargetNotMemberException;
import com.hazelcast.spi.impl.NodeEngineImpl;
import com.hazelcast.spi.impl.executionservice.InternalExecutionService;
import com.hazelcast.spi.impl.operationservice.InternalOperationService;
import com.hazelcast.spi.partition.IPartitionService;
import com.hazelcast.spi.properties.GroupProperty;
import com.hazelcast.transaction.TransactionManagerService;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.ConstructorFunction;
import com.hazelcast.util.SetUtil;
import com.hazelcast.util.ThreadUtil;
import com.hazelcast.util.executor.ExecutorType;
import java.net.InetSocketAddress;
import java.util.Collection;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import javax.security.auth.login.LoginException;

public class ClientEngineImpl extends Object implements ClientEngine, CoreService, PreJoinAwareService, ManagedService, MembershipAwareService, EventPublishingService<ClientEvent, ClientListener> {
  public static final String SERVICE_NAME = "hz:core:clientEngine";
  
  private static final int EXECUTOR_QUEUE_CAPACITY_PER_CORE = 100000;
  
  private static final int BLOCKING_THREADS_PER_CORE = 20;
  
  private static final int THREADS_PER_CORE = 1;
  
  private static final int QUERY_THREADS_PER_CORE = 1;
  
  private static final ConstructorFunction<String, AtomicLong> LAST_AUTH_CORRELATION_ID_CONSTRUCTOR_FUNC = new Object();
  
  private final Node node;
  
  private final NodeEngineImpl nodeEngine;
  
  private final Executor executor;
  
  private final Executor blockingExecutor;
  
  private final ExecutorService clientManagementExecutor;
  
  private final Executor queryExecutor;
  
  private final ConcurrentMap<String, String> ownershipMappings;
  
  private final ConcurrentMap<String, AtomicLong> lastAuthenticationCorrelationIds;
  
  private final Map<Address, Address> clientMemberAddressMap;
  
  private final ClientEndpointManagerImpl endpointManager;
  
  private final ILogger logger;
  
  private final ConnectionListener connectionListener;
  
  private final MessageTaskFactory messageTaskFactory;
  
  private final ClientExceptions clientExceptions;
  
  private final int endpointRemoveDelaySeconds;
  
  private final ClientPartitionListenerService partitionListenerService;
  
  private final boolean advancedNetworkConfigEnabled;
  
  public ClientEngineImpl(Node node) {
    this.ownershipMappings = new ConcurrentHashMap();
    this.lastAuthenticationCorrelationIds = new ConcurrentHashMap();
    this.clientMemberAddressMap = new ConcurrentHashMap();
    this.clientSelector = ClientSelectors.any();
    this.connectionListener = new ConnectionListenerImpl(this, null);
    this.logger = node.getLogger(ClientEngine.class);
    this.node = node;
    this.nodeEngine = node.nodeEngine;
    this.endpointManager = new ClientEndpointManagerImpl(this.nodeEngine);
    this.executor = newClientExecutor();
    this.queryExecutor = newClientQueryExecutor();
    this.blockingExecutor = newBlockingExecutor();
    this.clientManagementExecutor = newClientsManagementExecutor();
    this.messageTaskFactory = new CompositeMessageTaskFactory(this.nodeEngine);
    this.clientExceptions = initClientExceptionFactory();
    this.endpointRemoveDelaySeconds = node.getProperties().getInteger(GroupProperty.CLIENT_ENDPOINT_REMOVE_DELAY_SECONDS);
    this.partitionListenerService = new ClientPartitionListenerService(this.nodeEngine);
    this.advancedNetworkConfigEnabled = node.getConfig().getAdvancedNetworkConfig().isEnabled();
  }
  
  private ClientExceptions initClientExceptionFactory() {
    boolean jcacheAvailable = JCacheDetector.isJCacheAvailable(this.nodeEngine.getConfigClassLoader());
    return new ClientExceptions(jcacheAvailable);
  }
  
  private ExecutorService newClientsManagementExecutor() {
    InternalExecutionService executionService = this.nodeEngine.getExecutionService();
    return executionService.register("hz:client-management", 1, 2147483647, ExecutorType.CACHED);
  }
  
  public ExecutorService getClientManagementExecutor() { return this.clientManagementExecutor; }
  
  private Executor newClientExecutor() {
    boolean userCodeDeploymentEnabled = this.nodeEngine.getConfig().getUserCodeDeploymentConfig().isEnabled();
    int threadsPerCore = userCodeDeploymentEnabled ? 20 : 1;
    InternalExecutionService internalExecutionService = this.nodeEngine.getExecutionService();
    int coreSize = RuntimeAvailableProcessors.get();
    int threadCount = this.node.getProperties().getInteger(GroupProperty.CLIENT_ENGINE_THREAD_COUNT);
    if (threadCount <= 0)
      threadCount = coreSize * threadsPerCore; 
    this.logger.finest("Creating new client executor with threadCount=" + threadCount);
    if (userCodeDeploymentEnabled)
      return internalExecutionService.register("hz:client", threadCount, coreSize * 100000, ExecutorType.CONCRETE); 
    String name = "hz:client";
    ClassLoader classLoader = this.nodeEngine.getConfigClassLoader();
    String hzName = this.nodeEngine.getHazelcastInstance().getName();
    String internalName = name.substring("hz:".length());
    String threadNamePrefix = ThreadUtil.createThreadPoolName(hzName, internalName);
    UnblockablePoolExecutorThreadFactory factory = new UnblockablePoolExecutorThreadFactory(threadNamePrefix, classLoader);
    return internalExecutionService.register("hz:client", threadCount, coreSize * 100000, factory);
  }
  
  private Executor newClientQueryExecutor() {
    InternalExecutionService internalExecutionService = this.nodeEngine.getExecutionService();
    int coreSize = RuntimeAvailableProcessors.get();
    int threadCount = this.node.getProperties().getInteger(GroupProperty.CLIENT_ENGINE_QUERY_THREAD_COUNT);
    if (threadCount <= 0)
      threadCount = coreSize * 1; 
    this.logger.finest("Creating new client query executor with threadCount=" + threadCount);
    return internalExecutionService.register("hz:client-query", threadCount, coreSize * 100000, ExecutorType.CONCRETE);
  }
  
  private Executor newBlockingExecutor() {
    InternalExecutionService internalExecutionService = this.nodeEngine.getExecutionService();
    int coreSize = Runtime.getRuntime().availableProcessors();
    int threadCount = this.node.getProperties().getInteger(GroupProperty.CLIENT_ENGINE_BLOCKING_THREAD_COUNT);
    if (threadCount <= 0)
      threadCount = coreSize * 20; 
    this.logger.finest("Creating new client executor for blocking tasks with threadCount=" + threadCount);
    return internalExecutionService.register("hz:client-blocking-tasks", threadCount, coreSize * 100000, ExecutorType.CONCRETE);
  }
  
  public int getClientEndpointCount() { return this.endpointManager.size(); }
  
  public void accept(ClientMessage clientMessage) {
    int partitionId = clientMessage.getPartitionId();
    Connection connection = clientMessage.getConnection();
    MessageTask messageTask = this.messageTaskFactory.create(clientMessage, connection);
    InternalOperationService operationService = this.nodeEngine.getOperationService();
    if (partitionId < 0) {
      if (isUrgent(messageTask)) {
        operationService.execute(new PriorityPartitionSpecificRunnable(messageTask));
      } else if (isQuery(messageTask)) {
        this.queryExecutor.execute(messageTask);
      } else if (messageTask instanceof com.hazelcast.client.impl.protocol.task.TransactionalMessageTask) {
        this.blockingExecutor.execute(messageTask);
      } else if (messageTask instanceof com.hazelcast.client.impl.protocol.task.BlockingMessageTask) {
        this.blockingExecutor.execute(messageTask);
      } else if (messageTask instanceof com.hazelcast.client.impl.protocol.task.ListenerMessageTask) {
        this.blockingExecutor.execute(messageTask);
      } else {
        this.executor.execute(messageTask);
      } 
    } else {
      operationService.execute(messageTask);
    } 
  }
  
  private boolean isUrgent(MessageTask messageTask) {
    Class clazz = messageTask.getClass();
    return (clazz == com.hazelcast.client.impl.protocol.task.PingMessageTask.class || clazz == com.hazelcast.client.impl.protocol.task.GetPartitionsMessageTask.class || ((clazz == com.hazelcast.client.impl.protocol.task.AuthenticationMessageTask.class || clazz == com.hazelcast.client.impl.protocol.task.AuthenticationCustomCredentialsMessageTask.class) && this.node.securityContext == null));
  }
  
  private boolean isQuery(MessageTask messageTask) { return messageTask instanceof com.hazelcast.client.impl.protocol.task.map.AbstractMapQueryMessageTask; }
  
  public IPartitionService getPartitionService() { return this.nodeEngine.getPartitionService(); }
  
  public ClusterService getClusterService() { return this.nodeEngine.getClusterService(); }
  
  public EventService getEventService() { return this.nodeEngine.getEventService(); }
  
  public ProxyService getProxyService() { return this.nodeEngine.getProxyService(); }
  
  public Address getThisAddress() {
    if (this.advancedNetworkConfigEnabled) {
      Address clientServerSocketAddress = (Address)this.node.getLocalMember().getAddressMap().get(EndpointQualifier.CLIENT);
      assert clientServerSocketAddress != null;
      return clientServerSocketAddress;
    } 
    return this.node.getThisAddress();
  }
  
  public String getThisUuid() { return this.node.getThisUuid(); }
  
  public ILogger getLogger(Class clazz) { return this.node.getLogger(clazz); }
  
  public ClientEndpointManager getEndpointManager() { return this.endpointManager; }
  
  public ClientExceptions getClientExceptions() { return this.clientExceptions; }
  
  public SecurityContext getSecurityContext() { return this.node.securityContext; }
  
  public boolean bind(ClientEndpoint endpoint) {
    if (!this.clientSelector.select(endpoint))
      return false; 
    if (!this.endpointManager.registerEndpoint(endpoint))
      return true; 
    Connection conn = endpoint.getConnection();
    if (conn instanceof TcpIpConnection) {
      InetSocketAddress socketAddress = conn.getRemoteSocketAddress();
      if (socketAddress != null) {
        Address address = new Address(socketAddress);
        ((TcpIpConnection)conn).setEndPoint(address);
      } 
    } 
    if (!this.clientSelector.select(endpoint)) {
      this.endpointManager.removeEndpoint(endpoint);
      return false;
    } 
    return true;
  }
  
  public void applySelector(ClientSelector newSelector) {
    this.logger.info("Applying a new client selector :" + newSelector);
    this.clientSelector = newSelector;
    for (ClientEndpoint endpoint : this.endpointManager.getEndpoints()) {
      if (!this.clientSelector.select(endpoint))
        endpoint.getConnection().close("Client disconnected from cluster via Management Center", null); 
    } 
  }
  
  public void dispatchEvent(ClientEvent event, ClientListener listener) {
    if (event.getEventType() == ClientEventType.CONNECTED) {
      listener.clientConnected(event);
    } else {
      listener.clientDisconnected(event);
    } 
  }
  
  public void memberAdded(MembershipServiceEvent event) {
    if (this.advancedNetworkConfigEnabled) {
      Map<EndpointQualifier, Address> newMemberAddressMap = event.getMember().getAddressMap();
      Address memberAddress = (Address)newMemberAddressMap.get(EndpointQualifier.MEMBER);
      Address clientAddress = (Address)newMemberAddressMap.get(EndpointQualifier.CLIENT);
      if (clientAddress != null)
        this.clientMemberAddressMap.put(clientAddress, memberAddress); 
    } 
  }
  
  public void memberRemoved(MembershipServiceEvent event) {
    if (event.getMember().localMember())
      return; 
    if (this.advancedNetworkConfigEnabled) {
      Address clientAddress = (Address)event.getMember().getAddressMap().get(EndpointQualifier.CLIENT);
      if (clientAddress != null)
        this.clientMemberAddressMap.remove(clientAddress); 
    } 
    String deadMemberUuid = event.getMember().getUuid();
    try {
      this.nodeEngine.getExecutionService().schedule(new DestroyEndpointTask(this, deadMemberUuid), this.endpointRemoveDelaySeconds, TimeUnit.SECONDS);
    } catch (RejectedExecutionException e) {
      if (this.logger.isFinestEnabled())
        this.logger.finest(e); 
    } 
  }
  
  public void memberAttributeChanged(MemberAttributeServiceEvent event) {}
  
  public Collection<Client> getClients() {
    Collection<ClientEndpoint> endpoints = this.endpointManager.getEndpoints();
    Set<Client> clients = SetUtil.createHashSet(endpoints.size());
    clients.addAll(endpoints);
    return clients;
  }
  
  public void init(NodeEngine nodeEngine, Properties properties) {
    this.node.getEndpointManager(EndpointQualifier.CLIENT).addConnectionListener(this.connectionListener);
    ClientHeartbeatMonitor heartbeatMonitor = new ClientHeartbeatMonitor(this.endpointManager, getLogger(ClientHeartbeatMonitor.class), nodeEngine.getExecutionService(), this.node.getProperties());
    heartbeatMonitor.start();
  }
  
  public void reset() { clear("Resetting clientEngine"); }
  
  public void shutdown(boolean terminate) { clear("Shutting down clientEngine"); }
  
  private void clear(String reason) {
    for (ClientEndpoint ce : this.endpointManager.getEndpoints()) {
      ClientEndpointImpl endpoint = (ClientEndpointImpl)ce;
      try {
        endpoint.destroy();
      } catch (LoginException e) {
        this.logger.finest(e.getMessage());
      } 
      try {
        Connection conn = endpoint.getConnection();
        if (conn.isAlive())
          conn.close(reason, null); 
      } catch (Exception e) {
        this.logger.finest(e);
      } 
    } 
    this.endpointManager.clear();
    this.ownershipMappings.clear();
  }
  
  public boolean trySetLastAuthenticationCorrelationId(String clientUuid, long newCorrelationId) {
    AtomicLong lastCorrelationId = (AtomicLong)ConcurrencyUtil.getOrPutIfAbsent(this.lastAuthenticationCorrelationIds, clientUuid, LAST_AUTH_CORRELATION_ID_CONSTRUCTOR_FUNC);
    return ConcurrencyUtil.setIfEqualOrGreaterThan(lastCorrelationId, newCorrelationId);
  }
  
  public String addOwnershipMapping(String clientUuid, String ownerUuid) { return (String)this.ownershipMappings.put(clientUuid, ownerUuid); }
  
  public boolean removeOwnershipMapping(String clientUuid, String memberUuid) {
    this.lastAuthenticationCorrelationIds.remove(clientUuid);
    return this.ownershipMappings.remove(clientUuid, memberUuid);
  }
  
  public String getOwnerUuid(String clientUuid) { return (String)this.ownershipMappings.get(clientUuid); }
  
  public TransactionManagerService getTransactionManagerService() { return this.node.nodeEngine.getTransactionManagerService(); }
  
  public ClientPartitionListenerService getPartitionListenerService() { return this.partitionListenerService; }
  
  public boolean isClientAllowed(Client client) { return this.clientSelector.select(client); }
  
  public Operation getPreJoinOperation() {
    Set<Member> members = this.nodeEngine.getClusterService().getMembers();
    HashSet<String> liveMemberUUIDs = new HashSet<String>();
    for (Member member : members)
      liveMemberUUIDs.add(member.getUuid()); 
    Map<String, String> liveMappings = new HashMap<String, String>(this.ownershipMappings);
    liveMappings.values().retainAll(liveMemberUUIDs);
    return liveMappings.isEmpty() ? null : new OnJoinClientOperation(liveMappings);
  }
  
  public Map<ClientType, Integer> getConnectedClientStats() {
    int numberOfCppClients = 0;
    int numberOfDotNetClients = 0;
    int numberOfJavaClients = 0;
    int numberOfNodeJSClients = 0;
    int numberOfPythonClients = 0;
    int numberOfGoClients = 0;
    int numberOfOtherClients = 0;
    InternalOperationService internalOperationService = this.node.nodeEngine.getOperationService();
    Map<String, ClientType> clientsMap = new HashMap<String, ClientType>();
    for (Member member : this.node.getClusterService().getMembers()) {
      Address target = member.getAddress();
      GetConnectedClientsOperation getConnectedClientsOperation = new GetConnectedClientsOperation();
      InternalCompletableFuture internalCompletableFuture = internalOperationService.invokeOnTarget("hz:core:clientEngine", getConnectedClientsOperation, target);
      try {
        Map<String, ClientType> endpoints = (Map)internalCompletableFuture.get();
        if (endpoints == null)
          continue; 
        for (Map.Entry<String, ClientType> entry : endpoints.entrySet())
          clientsMap.put(entry.getKey(), entry.getValue()); 
      } catch (Exception e) {
        this.logger.warning("Cannot get client information from: " + target.toString(), e);
      } 
    } 
    for (ClientType clientType : clientsMap.values()) {
      switch (null.$SwitchMap$com$hazelcast$core$ClientType[clientType.ordinal()]) {
        case 1:
          numberOfJavaClients++;
          continue;
        case 2:
          numberOfDotNetClients++;
          continue;
        case 3:
          numberOfCppClients++;
          continue;
        case 4:
          numberOfNodeJSClients++;
          continue;
        case 5:
          numberOfPythonClients++;
          continue;
        case 6:
          numberOfGoClients++;
          continue;
      } 
      numberOfOtherClients++;
    } 
    Map<ClientType, Integer> resultMap = new EnumMap<ClientType, Integer>(ClientType.class);
    resultMap.put(ClientType.CPP, Integer.valueOf(numberOfCppClients));
    resultMap.put(ClientType.CSHARP, Integer.valueOf(numberOfDotNetClients));
    resultMap.put(ClientType.JAVA, Integer.valueOf(numberOfJavaClients));
    resultMap.put(ClientType.NODEJS, Integer.valueOf(numberOfNodeJSClients));
    resultMap.put(ClientType.PYTHON, Integer.valueOf(numberOfPythonClients));
    resultMap.put(ClientType.GO, Integer.valueOf(numberOfGoClients));
    resultMap.put(ClientType.OTHER, Integer.valueOf(numberOfOtherClients));
    return resultMap;
  }
  
  public Map<String, String> getClientStatistics() {
    Collection<ClientEndpoint> clientEndpoints = this.endpointManager.getEndpoints();
    Map<String, String> statsMap = new HashMap<String, String>(clientEndpoints.size());
    for (ClientEndpoint e : clientEndpoints) {
      String statistics = e.getClientStatistics();
      if (null != statistics)
        statsMap.put(e.getUuid(), statistics); 
    } 
    return statsMap;
  }
  
  public Address memberAddressOf(Address clientAddress) {
    if (!this.advancedNetworkConfigEnabled)
      return clientAddress; 
    Address memberAddress = (Address)this.clientMemberAddressMap.get(clientAddress);
    if (memberAddress != null)
      return memberAddress; 
    Set<Member> clusterMembers = this.node.getClusterService().getMembers();
    for (Member member : clusterMembers) {
      if (((Address)member.getAddressMap().get(EndpointQualifier.CLIENT)).equals(clientAddress)) {
        memberAddress = member.getAddress();
        this.clientMemberAddressMap.put(clientAddress, memberAddress);
        return memberAddress;
      } 
    } 
    throw new TargetNotMemberException("Could not locate member with client address " + clientAddress);
  }
  
  public Address clientAddressOf(Address memberAddress) {
    if (!this.advancedNetworkConfigEnabled)
      return memberAddress; 
    MemberImpl memberImpl = this.node.getClusterService().getMember(memberAddress);
    if (memberImpl != null)
      return (Address)memberImpl.getAddressMap().get(EndpointQualifier.CLIENT); 
    throw new TargetNotMemberException("Could not locate member with member address " + memberAddress);
  }
}
