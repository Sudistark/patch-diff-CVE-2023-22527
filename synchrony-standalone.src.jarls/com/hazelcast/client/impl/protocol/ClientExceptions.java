package com.hazelcast.client.impl.protocol;

import com.hazelcast.client.impl.protocol.codec.ErrorCodec;
import com.hazelcast.core.HazelcastException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ClientExceptions {
  private static final String CAUSED_BY_STACKTRACE_MARKER = "###### Caused by:";
  
  private final Map<Class, Integer> classToInt = new HashMap();
  
  public ClientExceptions(boolean jcacheAvailable) {
    if (jcacheAvailable) {
      register(4, javax.cache.CacheException.class);
      register(5, javax.cache.integration.CacheLoaderException.class);
      register(7, javax.cache.integration.CacheWriterException.class);
      register(18, javax.cache.processor.EntryProcessorException.class);
    } 
    register(1, ArrayIndexOutOfBoundsException.class);
    register(2, ArrayStoreException.class);
    register(3, com.hazelcast.client.impl.StubAuthenticationException.class);
    register(6, com.hazelcast.cache.CacheNotExistsException.class);
    register(8, com.hazelcast.spi.exception.CallerNotMemberException.class);
    register(9, java.util.concurrent.CancellationException.class);
    register(10, ClassCastException.class);
    register(11, ClassNotFoundException.class);
    register(12, java.util.ConcurrentModificationException.class);
    register(13, com.hazelcast.internal.cluster.impl.ConfigMismatchException.class);
    register(14, com.hazelcast.config.ConfigurationException.class);
    register(15, com.hazelcast.spi.exception.DistributedObjectDestroyedException.class);
    register(16, com.hazelcast.core.DuplicateInstanceNameException.class);
    register(17, java.io.EOFException.class);
    register(19, java.util.concurrent.ExecutionException.class);
    register(20, HazelcastException.class);
    register(21, com.hazelcast.core.HazelcastInstanceNotActiveException.class);
    register(22, com.hazelcast.core.HazelcastOverloadException.class);
    register(23, com.hazelcast.nio.serialization.HazelcastSerializationException.class);
    register(24, java.io.IOException.class);
    register(25, IllegalArgumentException.class);
    register(26, IllegalAccessException.class);
    register(27, IllegalAccessError.class);
    register(28, IllegalMonitorStateException.class);
    register(29, IllegalStateException.class);
    register(30, IllegalThreadStateException.class);
    register(31, IndexOutOfBoundsException.class);
    register(32, InterruptedException.class);
    register(33, com.hazelcast.util.AddressUtil.InvalidAddressException.class);
    register(34, com.hazelcast.config.InvalidConfigurationException.class);
    register(35, com.hazelcast.core.MemberLeftException.class);
    register(36, NegativeArraySizeException.class);
    register(37, java.util.NoSuchElementException.class);
    register(38, java.io.NotSerializableException.class);
    register(39, NullPointerException.class);
    register(40, com.hazelcast.core.OperationTimeoutException.class);
    register(41, com.hazelcast.spi.exception.PartitionMigratingException.class);
    register(42, com.hazelcast.query.QueryException.class);
    register(43, com.hazelcast.map.QueryResultSizeExceededException.class);
    register(44, com.hazelcast.quorum.QuorumException.class);
    register(45, com.hazelcast.map.ReachedMaxSizeException.class);
    register(46, java.util.concurrent.RejectedExecutionException.class);
    register(47, com.hazelcast.mapreduce.RemoteMapReduceException.class);
    register(48, com.hazelcast.spi.exception.ResponseAlreadySentException.class);
    register(49, com.hazelcast.spi.exception.RetryableHazelcastException.class);
    register(50, com.hazelcast.spi.exception.RetryableIOException.class);
    register(51, RuntimeException.class);
    register(52, SecurityException.class);
    register(53, java.net.SocketException.class);
    register(54, com.hazelcast.ringbuffer.StaleSequenceException.class);
    register(55, com.hazelcast.spi.exception.TargetDisconnectedException.class);
    register(56, com.hazelcast.spi.exception.TargetNotMemberException.class);
    register(57, java.util.concurrent.TimeoutException.class);
    register(58, com.hazelcast.topic.TopicOverloadException.class);
    register(59, com.hazelcast.mapreduce.TopologyChangedException.class);
    register(60, com.hazelcast.transaction.TransactionException.class);
    register(61, com.hazelcast.transaction.TransactionNotActiveException.class);
    register(62, com.hazelcast.transaction.TransactionTimedOutException.class);
    register(63, java.net.URISyntaxException.class);
    register(64, java.io.UTFDataFormatException.class);
    register(65, UnsupportedOperationException.class);
    register(66, com.hazelcast.spi.exception.WrongTargetException.class);
    register(67, javax.transaction.xa.XAException.class);
    register(68, java.security.AccessControlException.class);
    register(69, javax.security.auth.login.LoginException.class);
    register(70, javax.security.auth.callback.UnsupportedCallbackException.class);
    register(71, com.hazelcast.partition.NoDataMemberInClusterException.class);
    register(72, com.hazelcast.replicatedmap.ReplicatedMapCantBeCreatedOnLiteMemberException.class);
    register(73, com.hazelcast.client.impl.protocol.exception.MaxMessageSizeExceeded.class);
    register(74, com.hazelcast.wan.WANReplicationQueueFullException.class);
    register(75, AssertionError.class);
    register(76, OutOfMemoryError.class);
    register(77, StackOverflowError.class);
    register(78, com.hazelcast.memory.NativeOutOfMemoryError.class);
    register(79, com.hazelcast.spi.exception.ServiceNotFoundException.class);
    register(80, com.hazelcast.durableexecutor.StaleTaskIdException.class);
    register(81, com.hazelcast.scheduledexecutor.DuplicateTaskException.class);
    register(82, com.hazelcast.scheduledexecutor.StaleTaskException.class);
    register(83, com.hazelcast.core.LocalMemberResetException.class);
    register(84, com.hazelcast.core.IndeterminateOperationStateException.class);
    register(85, com.hazelcast.flakeidgen.impl.NodeIdOutOfRangeException.class);
    register(86, com.hazelcast.crdt.TargetNotReplicaException.class);
    register(87, com.hazelcast.crdt.MutationDisallowedException.class);
    register(88, com.hazelcast.core.ConsistencyLostException.class);
    register(89, com.hazelcast.cp.internal.session.SessionExpiredException.class);
    register(90, com.hazelcast.cp.internal.datastructures.exception.WaitKeyCancelledException.class);
    register(91, com.hazelcast.cp.lock.exception.LockAcquireLimitReachedException.class);
    register(92, com.hazelcast.cp.lock.exception.LockOwnershipLostException.class);
    register(93, com.hazelcast.cp.exception.CPGroupDestroyedException.class);
    register(94, com.hazelcast.cp.exception.CannotReplicateException.class);
    register(95, com.hazelcast.cp.exception.LeaderDemotedException.class);
    register(96, com.hazelcast.cp.exception.StaleAppendRequestException.class);
    register(97, com.hazelcast.cp.exception.NotLeaderException.class);
    register(98, NoSuchMethodError.class);
    register(99, NoSuchMethodException.class);
    register(100, NoSuchFieldError.class);
    register(101, NoSuchFieldException.class);
    register(102, NoClassDefFoundError.class);
  }
  
  public ClientMessage createExceptionMessage(Throwable throwable) {
    String causeClassName;
    int causeErrorCode, errorCode = getErrorCode(throwable);
    String message = throwable.getMessage();
    List<StackTraceElement> combinedStackTrace = new ArrayList<StackTraceElement>();
    Throwable t = throwable;
    while (t != null) {
      combinedStackTrace.addAll(Arrays.asList(t.getStackTrace()));
      t = t.getCause();
      if (t != null) {
        String throwableToString = t.getClass().getName() + ((t.getLocalizedMessage() != null) ? (": " + t.getLocalizedMessage()) : "");
        combinedStackTrace.add(new StackTraceElement("###### Caused by: (" + 
              getErrorCode(t) + ") " + throwableToString + " ------", "", null, -1));
      } 
    } 
    Throwable cause = throwable.getCause();
    if (cause != null) {
      causeErrorCode = getErrorCode(cause);
      causeClassName = cause.getClass().getName();
    } else {
      causeErrorCode = 0;
      causeClassName = null;
    } 
    StackTraceElement[] combinedStackTraceArray = (StackTraceElement[])combinedStackTrace.toArray(new StackTraceElement[combinedStackTrace.size()]);
    return ErrorCodec.encode(errorCode, throwable.getClass().getName(), message, combinedStackTraceArray, causeErrorCode, causeClassName);
  }
  
  public void register(int errorCode, Class clazz) {
    Integer currentCode = (Integer)this.classToInt.get(clazz);
    if (currentCode != null)
      throw new HazelcastException("Class " + clazz.getName() + " already added with code: " + currentCode); 
    this.classToInt.put(clazz, Integer.valueOf(errorCode));
  }
  
  private int getErrorCode(Throwable e) {
    Integer errorCode = (Integer)this.classToInt.get(e.getClass());
    if (errorCode == null)
      return 0; 
    return errorCode.intValue();
  }
  
  boolean isKnownClass(Class<? extends Throwable> aClass) { return this.classToInt.containsKey(aClass); }
}
