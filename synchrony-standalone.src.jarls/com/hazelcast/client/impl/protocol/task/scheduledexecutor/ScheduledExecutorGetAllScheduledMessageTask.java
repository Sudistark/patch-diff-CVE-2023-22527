package com.hazelcast.client.impl.protocol.task.scheduledexecutor;

import com.hazelcast.client.impl.ClientEndpoint;
import com.hazelcast.client.impl.protocol.ClientMessage;
import com.hazelcast.client.impl.protocol.codec.ScheduledExecutorGetAllScheduledFuturesCodec;
import com.hazelcast.client.impl.protocol.task.AbstractMessageTask;
import com.hazelcast.client.impl.protocol.task.BlockingMessageTask;
import com.hazelcast.core.Member;
import com.hazelcast.instance.EndpointQualifier;
import com.hazelcast.instance.MemberImpl;
import com.hazelcast.instance.Node;
import com.hazelcast.internal.cluster.ClusterService;
import com.hazelcast.internal.partition.InternalPartitionService;
import com.hazelcast.nio.Address;
import com.hazelcast.nio.Connection;
import com.hazelcast.scheduledexecutor.ScheduledTaskHandler;
import com.hazelcast.scheduledexecutor.impl.InvokeOnMembers;
import com.hazelcast.scheduledexecutor.impl.ScheduledTaskHandlerAccessor;
import com.hazelcast.scheduledexecutor.impl.operations.GetAllScheduledOnPartitionOperationFactory;
import com.hazelcast.security.permission.ScheduledExecutorPermission;
import com.hazelcast.util.ExceptionUtil;
import java.security.Permission;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class ScheduledExecutorGetAllScheduledMessageTask extends AbstractMessageTask<ScheduledExecutorGetAllScheduledFuturesCodec.RequestParameters> implements BlockingMessageTask {
  private final boolean advancedNetworkEnabled;
  
  public ScheduledExecutorGetAllScheduledMessageTask(ClientMessage clientMessage, Node node, Connection connection) {
    super(clientMessage, node, connection);
    this.advancedNetworkEnabled = isAdvancedNetworkEnabled();
  }
  
  protected void processMessage() throws Throwable {
    Map<Member, List<ScheduledTaskHandler>> scheduledTasks = new LinkedHashMap<Member, List<ScheduledTaskHandler>>();
    retrieveAllMemberOwnedScheduled(scheduledTasks);
    retrieveAllPartitionOwnedScheduled(scheduledTasks);
    sendResponse(scheduledTasks.entrySet());
  }
  
  protected ScheduledExecutorGetAllScheduledFuturesCodec.RequestParameters decodeClientMessage(ClientMessage clientMessage) { return ScheduledExecutorGetAllScheduledFuturesCodec.decodeRequest(clientMessage); }
  
  protected ClientMessage encodeResponse(Object response) {
    return 
      ScheduledExecutorGetAllScheduledFuturesCodec.encodeResponse((Collection)response);
  }
  
  public String getServiceName() { return "hz:impl:scheduledExecutorService"; }
  
  public Permission getRequiredPermission() { return new ScheduledExecutorPermission(((ScheduledExecutorGetAllScheduledFuturesCodec.RequestParameters)this.parameters).schedulerName, new String[] { "read" }); }
  
  public String getDistributedObjectName() { return ((ScheduledExecutorGetAllScheduledFuturesCodec.RequestParameters)this.parameters).schedulerName; }
  
  public String getMethodName() { return "getAllScheduled"; }
  
  public Object[] getParameters() { return new Object[] { ((ScheduledExecutorGetAllScheduledFuturesCodec.RequestParameters)this.parameters).schedulerName }; }
  
  private void retrieveAllMemberOwnedScheduled(Map<Member, List<ScheduledTaskHandler>> accumulator) {
    try {
      InvokeOnMembers invokeOnMembers = new InvokeOnMembers(this.nodeEngine, getServiceName(), new GetAllScheduledOnMemberOperationFactory(this, ((ScheduledExecutorGetAllScheduledFuturesCodec.RequestParameters)this.parameters).schedulerName), this.nodeEngine.getClusterService().getMembers());
      accumulateTaskHandlersAsUrnValues(accumulator, invokeOnMembers.invoke());
    } catch (Exception e) {
      throw ExceptionUtil.rethrow(e);
    } 
  }
  
  private void retrieveAllPartitionOwnedScheduled(Map<Member, List<ScheduledTaskHandler>> accumulator) {
    try {
      accumulateTaskHandlersAsUrnValues(accumulator, this.nodeEngine.getOperationService().invokeOnAllPartitions(
            getServiceName(), new GetAllScheduledOnPartitionOperationFactory(((ScheduledExecutorGetAllScheduledFuturesCodec.RequestParameters)this.parameters).schedulerName)));
    } catch (Throwable t) {
      throw ExceptionUtil.rethrow(t);
    } 
  }
  
  private void accumulateTaskHandlersAsUrnValues(Map<Member, List<ScheduledTaskHandler>> accumulator, Map<?, ?> taskHandlersMap) {
    ClusterService clusterService = this.nodeEngine.getClusterService();
    InternalPartitionService internalPartitionService = this.nodeEngine.getPartitionService();
    for (Map.Entry<?, ?> entry : taskHandlersMap.entrySet()) {
      Object key = entry.getKey();
      if (key instanceof Number) {
        owner = clusterService.getMember(internalPartitionService.getPartitionOwner(((Integer)key).intValue()));
      } else {
        owner = (MemberImpl)key;
      } 
      MemberImpl owner = translateMemberAddress(owner);
      List<ScheduledTaskHandler> handlers = (List)entry.getValue();
      translateTaskHandlerAddresses(handlers);
      if (accumulator.containsKey(owner)) {
        List<ScheduledTaskHandler> memberUrns = (List)accumulator.get(owner);
        memberUrns.addAll(handlers);
        continue;
      } 
      accumulator.put(owner, handlers);
    } 
  }
  
  private MemberImpl translateMemberAddress(MemberImpl member) {
    if (!this.advancedNetworkEnabled)
      return member; 
    Address clientAddress = (Address)member.getAddressMap().get(EndpointQualifier.CLIENT);
    return (new MemberImpl.Builder(clientAddress)).version(member.getVersion()).uuid(member.getUuid()).localMember(member.localMember()).liteMember(member.isLiteMember()).memberListJoinVersion(member.getMemberListJoinVersion()).attributes(member.getAttributes()).build();
  }
  
  private void translateTaskHandlerAddresses(List<ScheduledTaskHandler> handlers) {
    if (!this.advancedNetworkEnabled)
      return; 
    for (ScheduledTaskHandler handler : handlers) {
      if (handler.getAddress() != null)
        ScheduledTaskHandlerAccessor.setAddress(handler, this.clientEngine
            .clientAddressOf(handler.getAddress())); 
    } 
  }
}
