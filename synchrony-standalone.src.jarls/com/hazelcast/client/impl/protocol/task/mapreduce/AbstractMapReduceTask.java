package com.hazelcast.client.impl.protocol.task.mapreduce;

import com.hazelcast.client.impl.protocol.ClientMessage;
import com.hazelcast.client.impl.protocol.task.AbstractMessageTask;
import com.hazelcast.client.impl.protocol.task.BlockingMessageTask;
import com.hazelcast.cluster.memberselector.MemberSelectors;
import com.hazelcast.config.JobTrackerConfig;
import com.hazelcast.core.ExecutionCallback;
import com.hazelcast.core.Member;
import com.hazelcast.instance.Node;
import com.hazelcast.internal.cluster.ClusterService;
import com.hazelcast.mapreduce.CombinerFactory;
import com.hazelcast.mapreduce.JobTracker;
import com.hazelcast.mapreduce.KeyPredicate;
import com.hazelcast.mapreduce.KeyValueSource;
import com.hazelcast.mapreduce.Mapper;
import com.hazelcast.mapreduce.ReducerFactory;
import com.hazelcast.mapreduce.TopologyChangedStrategy;
import com.hazelcast.mapreduce.impl.AbstractJobTracker;
import com.hazelcast.mapreduce.impl.MapReduceService;
import com.hazelcast.mapreduce.impl.MapReduceUtil;
import com.hazelcast.mapreduce.impl.operation.KeyValueJobOperation;
import com.hazelcast.mapreduce.impl.operation.StartProcessingJobOperation;
import com.hazelcast.mapreduce.impl.task.TrackableJobFuture;
import com.hazelcast.nio.Connection;
import com.hazelcast.nio.serialization.Data;
import com.hazelcast.spi.NodeEngine;
import com.hazelcast.util.StringUtil;
import java.security.Permission;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;

public abstract class AbstractMapReduceTask<Parameters> extends AbstractMessageTask<Parameters> implements ExecutionCallback, BlockingMessageTask {
  public AbstractMapReduceTask(ClientMessage clientMessage, Node node, Connection connection) { super(clientMessage, node, connection); }
  
  protected void processMessage() {
    MapReduceService mapReduceService = (MapReduceService)getService("hz:impl:mapReduceService");
    NodeEngine nodeEngine = mapReduceService.getNodeEngine();
    ClusterService clusterService = nodeEngine.getClusterService();
    if (clusterService.getSize(MemberSelectors.DATA_MEMBER_SELECTOR) == 0)
      throw new IllegalStateException("Could not register map reduce job since there are no nodes owning a partition"); 
    String objectName = getDistributedObjectName();
    AbstractJobTracker jobTracker = (AbstractJobTracker)mapReduceService.createDistributedObject(objectName);
    TrackableJobFuture jobFuture = new TrackableJobFuture(objectName, getJobId(), jobTracker, nodeEngine, null);
    if (jobTracker.registerTrackableJob(jobFuture)) {
      startSupervisionTask(jobTracker);
      jobFuture.andThen(this);
    } 
  }
  
  protected abstract String getJobId();
  
  protected abstract int getChunkSize();
  
  protected abstract String getTopologyChangedStrategy();
  
  protected abstract KeyValueSource getKeyValueSource();
  
  protected abstract Mapper getMapper();
  
  protected abstract CombinerFactory getCombinerFactory();
  
  protected abstract ReducerFactory getReducerFactory();
  
  protected abstract Collection getKeys();
  
  protected abstract KeyPredicate getPredicate();
  
  private void startSupervisionTask(JobTracker jobTracker) {
    MapReduceService mapReduceService = (MapReduceService)getService("hz:impl:mapReduceService");
    JobTrackerConfig config = ((AbstractJobTracker)jobTracker).getJobTrackerConfig();
    boolean communicateStats = config.isCommunicateStats();
    int chunkSize = getChunkSizeOrConfigChunkSize(config);
    TopologyChangedStrategy topologyChangedStrategy = getTopologyChangedStrategyOrConfigTopologyChangedStrategy(config);
    String name = getDistributedObjectName();
    String jobId = getJobId();
    KeyValueSource keyValueSource = getKeyValueSource();
    Mapper mapper = getMapper();
    CombinerFactory combinerFactory = getCombinerFactory();
    ReducerFactory reducerFactory = getReducerFactory();
    Collection keys = getKeys();
    Collection<Object> keyObjects = getKeyObjects(keys);
    KeyPredicate predicate = getPredicate();
    ClusterService clusterService = this.nodeEngine.getClusterService();
    for (Member member : clusterService.getMembers(KeyValueJobOperation.MEMBER_SELECTOR)) {
      KeyValueJobOperation keyValueJobOperation = new KeyValueJobOperation(name, jobId, chunkSize, keyValueSource, mapper, combinerFactory, reducerFactory, communicateStats, topologyChangedStrategy);
      MapReduceUtil.executeOperation(keyValueJobOperation, member.getAddress(), mapReduceService, this.nodeEngine);
    } 
    for (Member member : clusterService.getMembers(MemberSelectors.DATA_MEMBER_SELECTOR)) {
      StartProcessingJobOperation startProcessingJobOperation = new StartProcessingJobOperation(name, jobId, keyObjects, predicate);
      MapReduceUtil.executeOperation(startProcessingJobOperation, member.getAddress(), mapReduceService, this.nodeEngine);
    } 
  }
  
  private int getChunkSizeOrConfigChunkSize(JobTrackerConfig config) {
    int chunkSize = getChunkSize();
    if (chunkSize == -1)
      chunkSize = config.getChunkSize(); 
    return chunkSize;
  }
  
  private TopologyChangedStrategy getTopologyChangedStrategyOrConfigTopologyChangedStrategy(JobTrackerConfig config) {
    TopologyChangedStrategy topologyChangedStrategy;
    String topologyChangedStrategyStr = getTopologyChangedStrategy();
    if (topologyChangedStrategyStr == null) {
      topologyChangedStrategy = config.getTopologyChangedStrategy();
    } else {
      topologyChangedStrategy = TopologyChangedStrategy.valueOf(topologyChangedStrategyStr.toUpperCase(StringUtil.LOCALE_INTERNAL));
    } 
    return topologyChangedStrategy;
  }
  
  private Collection<Object> getKeyObjects(Collection keys) {
    Collection<Object> keyObjects = null;
    if (keys != null) {
      keyObjects = new ArrayList<Object>(keys.size());
      for (Object key : keys)
        keyObjects.add(this.serializationService.toObject(key)); 
    } 
    return keyObjects;
  }
  
  public void onResponse(Object response) {
    Map<Object, Object> m = (Map)response;
    List<Map.Entry<Data, Data>> entries = new ArrayList<Map.Entry<Data, Data>>();
    for (Map.Entry<Object, Object> entry : m.entrySet()) {
      Data key = this.serializationService.toData(entry.getKey());
      Data value = this.serializationService.toData(entry.getValue());
      entries.add(new AbstractMap.SimpleEntry(key, value));
    } 
    sendResponse(entries);
  }
  
  public void onFailure(Throwable t) { handleProcessingFailure(t); }
  
  public String getServiceName() { return "hz:impl:mapReduceService"; }
  
  public Permission getRequiredPermission() { return null; }
  
  public String getMethodName() { return null; }
  
  public Object[] getParameters() { return null; }
}
