package com.hazelcast.client.impl.protocol.task.map;

import com.hazelcast.aggregation.Aggregator;
import com.hazelcast.client.impl.protocol.ClientMessage;
import com.hazelcast.client.impl.protocol.task.AbstractCallableMessageTask;
import com.hazelcast.cluster.memberselector.MemberSelectors;
import com.hazelcast.core.Member;
import com.hazelcast.instance.Node;
import com.hazelcast.map.impl.MapService;
import com.hazelcast.map.impl.MapServiceContext;
import com.hazelcast.map.impl.operation.MapOperation;
import com.hazelcast.map.impl.query.Query;
import com.hazelcast.map.impl.query.Result;
import com.hazelcast.nio.Connection;
import com.hazelcast.projection.Projection;
import com.hazelcast.query.PartitionPredicate;
import com.hazelcast.query.Predicate;
import com.hazelcast.query.QueryException;
import com.hazelcast.security.permission.MapPermission;
import com.hazelcast.spi.InternalCompletableFuture;
import com.hazelcast.spi.impl.operationservice.InternalOperationService;
import com.hazelcast.util.BitSetUtils;
import com.hazelcast.util.ExceptionUtil;
import com.hazelcast.util.IterationType;
import java.security.Permission;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

public abstract class AbstractMapQueryMessageTask<P, QueryResult extends Result, AccumulatedResults, ReducedResult> extends AbstractCallableMessageTask<P> {
  protected AbstractMapQueryMessageTask(ClientMessage clientMessage, Node node, Connection connection) { super(clientMessage, node, connection); }
  
  public final String getServiceName() { return "hz:impl:mapService"; }
  
  public Permission getRequiredPermission() { return new MapPermission(getDistributedObjectName(), new String[] { "read" }); }
  
  protected abstract Predicate getPredicate();
  
  protected abstract Aggregator<?, ?> getAggregator();
  
  protected abstract Projection<?, ?> getProjection();
  
  protected abstract void extractAndAppendResult(Collection<AccumulatedResults> paramCollection, QueryResult paramQueryResult);
  
  protected abstract ReducedResult reduce(Collection<AccumulatedResults> paramCollection);
  
  protected abstract IterationType getIterationType();
  
  protected final Object call() throws Exception {
    Collection<AccumulatedResults> result = new LinkedList<AccumulatedResults>();
    try {
      Predicate predicate = getPredicate();
      if (predicate instanceof PartitionPredicate) {
        int partitionId = getPartitionId();
        QueryResult queryResult = (QueryResult)invokeOnPartition((PartitionPredicate)predicate, partitionId);
        extractAndAppendResult(result, queryResult);
        return reduce(result);
      } 
      int partitionCount = this.clientEngine.getPartitionService().getPartitionCount();
      BitSet finishedPartitions = invokeOnMembers(result, predicate, partitionCount);
      invokeOnMissingPartitions(result, predicate, finishedPartitions, partitionCount);
    } catch (Throwable t) {
      throw ExceptionUtil.rethrow(t);
    } 
    return reduce(result);
  }
  
  private QueryResult invokeOnPartition(PartitionPredicate predicate, int partitionId) {
    InternalOperationService operationService = this.nodeEngine.getOperationService();
    MapService mapService = (MapService)this.nodeEngine.getService(getServiceName());
    MapServiceContext mapServiceContext = mapService.getMapServiceContext();
    Query query = buildQuery(predicate);
    MapOperation queryPartitionOperation = createQueryPartitionOperation(query, mapServiceContext);
    queryPartitionOperation.setPartitionId(partitionId);
    try {
      return (QueryResult)(Result)operationService.invokeOnPartition("hz:impl:mapService", queryPartitionOperation, partitionId).get();
    } catch (Throwable t) {
      throw ExceptionUtil.rethrow(t);
    } 
  }
  
  private BitSet invokeOnMembers(Collection<AccumulatedResults> result, Predicate predicate, int partitionCount) throws InterruptedException, ExecutionException {
    Collection<Member> members = this.clientEngine.getClusterService().getMembers(MemberSelectors.DATA_MEMBER_SELECTOR);
    List<Future> futures = createInvocations(members, predicate);
    return collectResults(result, futures, partitionCount);
  }
  
  private void invokeOnMissingPartitions(Collection<AccumulatedResults> result, Predicate predicate, BitSet finishedPartitions, int partitionCount) throws InterruptedException, ExecutionException {
    if (hasMissingPartitions(finishedPartitions, partitionCount)) {
      List<Integer> missingList = findMissingPartitions(finishedPartitions, partitionCount);
      List<Future> missingFutures = new ArrayList<Future>(missingList.size());
      createInvocationsForMissingPartitions(missingList, missingFutures, predicate);
      collectResultsFromMissingPartitions(finishedPartitions, result, missingFutures);
    } 
    assertAllPartitionsQueried(finishedPartitions, partitionCount);
  }
  
  private List<Future> createInvocations(Collection<Member> members, Predicate predicate) {
    List<Future> futures = new ArrayList<Future>(members.size());
    InternalOperationService operationService = this.nodeEngine.getOperationService();
    Query query = buildQuery(predicate);
    MapService mapService = (MapService)this.nodeEngine.getService(getServiceName());
    MapServiceContext mapServiceContext = mapService.getMapServiceContext();
    for (Member member : members) {
      try {
        InternalCompletableFuture internalCompletableFuture = operationService.createInvocationBuilder("hz:impl:mapService", createQueryOperation(query, mapServiceContext), member.getAddress()).invoke();
        futures.add(internalCompletableFuture);
      } catch (Throwable t) {
        if (!(t instanceof com.hazelcast.core.HazelcastException))
          throw ExceptionUtil.rethrow(t); 
        if (t.getCause() instanceof com.hazelcast.map.QueryResultSizeExceededException)
          throw ExceptionUtil.rethrow(t); 
        if (this.logger.isFineEnabled())
          this.logger.fine("Query invocation failed on member " + member, t); 
      } 
    } 
    return futures;
  }
  
  private Query buildQuery(Predicate predicate) {
    Query.QueryBuilder builder = Query.of().mapName(getDistributedObjectName()).predicate((predicate instanceof PartitionPredicate) ? ((PartitionPredicate)predicate).getTarget() : predicate).iterationType(getIterationType());
    if (getAggregator() != null)
      builder = builder.aggregator(getAggregator()); 
    if (getProjection() != null)
      builder = builder.projection(getProjection()); 
    return builder.build();
  }
  
  private BitSet collectResults(Collection<AccumulatedResults> result, List<Future> futures, int partitionCount) throws InterruptedException, ExecutionException {
    BitSet finishedPartitions = new BitSet(partitionCount);
    for (Future future : futures) {
      try {
        QueryResult queryResult = (QueryResult)(Result)future.get();
        if (queryResult != null) {
          Collection<Integer> partitionIds = queryResult.getPartitionIds();
          if (partitionIds != null && !BitSetUtils.hasAtLeastOneBitSet(finishedPartitions, partitionIds)) {
            BitSetUtils.setBits(finishedPartitions, partitionIds);
            extractAndAppendResult(result, queryResult);
          } 
        } 
      } catch (Throwable t) {
        if (t.getCause() instanceof com.hazelcast.map.QueryResultSizeExceededException)
          throw ExceptionUtil.rethrow(t); 
        if (this.logger.isFineEnabled())
          this.logger.fine("Query on member failed with exception", t); 
      } 
    } 
    return finishedPartitions;
  }
  
  private boolean hasMissingPartitions(BitSet finishedPartitions, int partitionCount) { return (finishedPartitions.nextClearBit(0) < partitionCount); }
  
  private List<Integer> findMissingPartitions(BitSet finishedPartitions, int partitionCount) {
    List<Integer> missingList = new ArrayList<Integer>();
    for (int i = 0; i < partitionCount; i++) {
      if (!finishedPartitions.get(i))
        missingList.add(Integer.valueOf(i)); 
    } 
    return missingList;
  }
  
  private void createInvocationsForMissingPartitions(List<Integer> missingPartitionsList, List<Future> futures, Predicate predicate) {
    InternalOperationService operationService = this.nodeEngine.getOperationService();
    MapService mapService = (MapService)this.nodeEngine.getService(getServiceName());
    MapServiceContext mapServiceContext = mapService.getMapServiceContext();
    Query query = buildQuery(predicate);
    for (Integer partitionId : missingPartitionsList) {
      MapOperation queryPartitionOperation = createQueryPartitionOperation(query, mapServiceContext);
      queryPartitionOperation.setPartitionId(partitionId.intValue());
      try {
        InternalCompletableFuture internalCompletableFuture = operationService.invokeOnPartition("hz:impl:mapService", queryPartitionOperation, partitionId
            .intValue());
        futures.add(internalCompletableFuture);
      } catch (Throwable t) {
        throw ExceptionUtil.rethrow(t);
      } 
    } 
  }
  
  private void collectResultsFromMissingPartitions(BitSet finishedPartitions, Collection<AccumulatedResults> result, List<Future> futures) throws InterruptedException, ExecutionException {
    for (Future future : futures) {
      QueryResult queryResult = (QueryResult)(Result)future.get();
      if (queryResult.getPartitionIds() != null && queryResult.getPartitionIds().size() > 0 && 
        !BitSetUtils.hasAtLeastOneBitSet(finishedPartitions, queryResult.getPartitionIds())) {
        extractAndAppendResult(result, queryResult);
        BitSetUtils.setBits(finishedPartitions, queryResult.getPartitionIds());
      } 
    } 
  }
  
  private MapOperation createQueryOperation(Query query, MapServiceContext mapServiceContext) { return mapServiceContext.getMapOperationProvider(query.getMapName()).createQueryOperation(query); }
  
  private MapOperation createQueryPartitionOperation(Query query, MapServiceContext mapServiceContext) {
    return mapServiceContext.getMapOperationProvider(query
        .getMapName()).createQueryPartitionOperation(query);
  }
  
  private void assertAllPartitionsQueried(BitSet finishedPartitions, int partitionCount) {
    if (hasMissingPartitions(finishedPartitions, partitionCount)) {
      int missedPartitionsCount = 0;
      for (int i = 0; i < partitionCount; i++) {
        if (!finishedPartitions.get(i))
          missedPartitionsCount++; 
      } 
      throw new QueryException("Query aborted. Could not execute query for all partitions. Missed " + missedPartitionsCount + " partitions");
    } 
  }
}
