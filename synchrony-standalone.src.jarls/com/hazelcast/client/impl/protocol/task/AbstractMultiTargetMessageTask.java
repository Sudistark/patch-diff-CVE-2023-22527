package com.hazelcast.client.impl.protocol.task;

import com.hazelcast.client.impl.protocol.ClientMessage;
import com.hazelcast.core.Member;
import com.hazelcast.instance.Node;
import com.hazelcast.nio.Connection;
import com.hazelcast.spi.InvocationBuilder;
import com.hazelcast.spi.Operation;
import com.hazelcast.spi.impl.operationservice.InternalOperationService;
import com.hazelcast.util.function.Supplier;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;

public abstract class AbstractMultiTargetMessageTask<P> extends AbstractMessageTask<P> {
  protected AbstractMultiTargetMessageTask(ClientMessage clientMessage, Node node, Connection connection) { super(clientMessage, node, connection); }
  
  protected void processMessage() throws Throwable {
    Supplier<Operation> operationSupplier = createOperationSupplier();
    Collection<Member> targets = getTargets();
    returnResponseIfNoTargetLeft(targets, Collections.EMPTY_MAP);
    InternalOperationService operationService = this.nodeEngine.getOperationService();
    MultiTargetCallback callback = new MultiTargetCallback(this, targets, null);
    for (Member target : targets) {
      Operation op = (Operation)operationSupplier.get();
      InvocationBuilder builder = operationService.createInvocationBuilder(getServiceName(), op, target.getAddress()).setResultDeserialized(false).setExecutionCallback(new SingleTargetCallback(this, target, callback, null));
      builder.invoke();
    } 
  }
  
  private void returnResponseIfNoTargetLeft(Collection<Member> targets, Map<Member, Object> results) throws Throwable {
    if (targets.isEmpty())
      sendResponse(reduce(results)); 
  }
  
  protected abstract Supplier<Operation> createOperationSupplier();
  
  protected abstract Object reduce(Map<Member, Object> paramMap) throws Throwable;
  
  public abstract Collection<Member> getTargets();
}
