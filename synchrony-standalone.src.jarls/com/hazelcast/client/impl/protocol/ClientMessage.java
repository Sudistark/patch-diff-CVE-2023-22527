package com.hazelcast.client.impl.protocol;

import com.hazelcast.client.impl.protocol.exception.MaxMessageSizeExceeded;
import com.hazelcast.client.impl.protocol.util.BufferBuilder;
import com.hazelcast.client.impl.protocol.util.ClientProtocolBuffer;
import com.hazelcast.client.impl.protocol.util.MessageFlyweight;
import com.hazelcast.client.impl.protocol.util.SafeBuffer;
import com.hazelcast.client.impl.protocol.util.UnsafeBuffer;
import com.hazelcast.internal.networking.OutboundFrame;
import com.hazelcast.nio.Bits;
import com.hazelcast.nio.Connection;
import java.nio.ByteBuffer;
import java.util.Arrays;

public class ClientMessage extends MessageFlyweight implements OutboundFrame {
  public static final short VERSION = 1;
  
  public static final short BEGIN_FLAG = 128;
  
  public static final short END_FLAG = 64;
  
  public static final short BEGIN_AND_END_FLAGS = 192;
  
  public static final short LISTENER_EVENT_FLAG = 1;
  
  public static final int HEADER_SIZE;
  
  private static final String PROP_HAZELCAST_PROTOCOL_UNSAFE = "hazelcast.protocol.unsafe.enabled";
  
  private static final boolean USE_UNSAFE = Boolean.getBoolean("hazelcast.protocol.unsafe.enabled");
  
  private static final int FRAME_LENGTH_FIELD_OFFSET = 0;
  
  private static final int VERSION_FIELD_OFFSET = 4;
  
  private static final int FLAGS_FIELD_OFFSET = 5;
  
  private static final int TYPE_FIELD_OFFSET = 6;
  
  private static final int CORRELATION_ID_FIELD_OFFSET = 8;
  
  private static final int PARTITION_ID_FIELD_OFFSET = 16;
  
  private static final int DATA_OFFSET_FIELD_OFFSET = 20;
  
  private int writeOffset;
  
  private boolean isRetryable;
  
  private boolean acquiresResource;
  
  private String operationName;
  
  private Connection connection;
  
  static  {
    HEADER_SIZE = 22;
  }
  
  public Connection getConnection() { return this.connection; }
  
  public void setConnection(Connection connection) { this.connection = connection; }
  
  protected void wrapForEncode(ClientProtocolBuffer buffer, int offset) {
    ensureHeaderSize(offset, buffer.capacity());
    wrap(buffer.byteArray(), offset, USE_UNSAFE);
    setDataOffset(HEADER_SIZE);
    setFrameLength(HEADER_SIZE);
    index(getDataOffset());
    setPartitionId(-1);
  }
  
  private void ensureHeaderSize(int offset, int length) {
    if (length - offset < HEADER_SIZE)
      throw new IndexOutOfBoundsException("ClientMessage buffer must contain at least " + HEADER_SIZE + " bytes! length: " + length + ", offset: " + offset); 
  }
  
  protected void wrapForDecode(ClientProtocolBuffer buffer, int offset) {
    ensureHeaderSize(offset, buffer.capacity());
    wrap(buffer.byteArray(), offset, USE_UNSAFE);
    index(getDataOffset());
  }
  
  public short getVersion() { return uint8Get(4); }
  
  public ClientMessage setVersion(short version) {
    uint8Put(4, version);
    return this;
  }
  
  public boolean isFlagSet(short flag) {
    int i = getFlags() & flag;
    return (i == flag);
  }
  
  public short getFlags() { return uint8Get(5); }
  
  public ClientMessage addFlag(short flags) {
    uint8Put(5, (short)(getFlags() | flags));
    return this;
  }
  
  public int getMessageType() { return uint16Get(6); }
  
  public ClientMessage setMessageType(int type) {
    uint16Put(6, type);
    return this;
  }
  
  public int getFrameLength() { return int32Get(0); }
  
  public ClientMessage setFrameLength(int length) {
    int32Set(0, length);
    return this;
  }
  
  public long getCorrelationId() { return int64Get(8); }
  
  public ClientMessage setCorrelationId(long correlationId) {
    int64Set(8, correlationId);
    return this;
  }
  
  public int getPartitionId() { return int32Get(16); }
  
  public ClientMessage setPartitionId(int partitionId) {
    int32Set(16, partitionId);
    return this;
  }
  
  public int getDataOffset() { return uint16Get(20); }
  
  public ClientMessage setDataOffset(int dataOffset) {
    uint16Put(20, dataOffset);
    return this;
  }
  
  public ClientMessage updateFrameLength() {
    setFrameLength(index());
    return this;
  }
  
  public boolean writeTo(ByteBuffer dst) {
    boolean done;
    int bytesWrite;
    byte[] byteArray = this.buffer.byteArray();
    int size = getFrameLength();
    int bytesWritable = dst.remaining();
    int bytesNeeded = size - this.writeOffset;
    if (bytesWritable >= bytesNeeded) {
      bytesWrite = bytesNeeded;
      done = true;
    } else {
      bytesWrite = bytesWritable;
      done = false;
    } 
    dst.put(byteArray, this.writeOffset, bytesWrite);
    this.writeOffset += bytesWrite;
    if (done)
      this.writeOffset = 0; 
    return done;
  }
  
  public boolean readFrom(ByteBuffer src) {
    int frameLength = 0;
    if (this.buffer == null) {
      int remaining = src.remaining();
      if (remaining < 4)
        return false; 
      frameLength = Bits.readIntL(src);
      src.position(src.position() - 4);
      if (frameLength < HEADER_SIZE)
        throw new IllegalArgumentException("Client message frame length cannot be smaller than header size."); 
      wrap(new byte[frameLength], 0, USE_UNSAFE);
    } 
    frameLength = (frameLength > 0) ? frameLength : getFrameLength();
    accumulate(src, frameLength - index());
    return isComplete();
  }
  
  private int accumulate(ByteBuffer src, int length) {
    int remaining = src.remaining();
    int readLength = (remaining < length) ? remaining : length;
    if (readLength > 0) {
      this.buffer.putBytes(index(), src, readLength);
      index(index() + readLength);
      return readLength;
    } 
    return 0;
  }
  
  public boolean isComplete() { return (index() >= HEADER_SIZE && index() == getFrameLength()); }
  
  public boolean isUrgent() { return false; }
  
  public boolean isRetryable() { return this.isRetryable; }
  
  public boolean acquiresResource() { return this.acquiresResource; }
  
  public void setAcquiresResource(boolean acquiresResource) { this.acquiresResource = acquiresResource; }
  
  public void setRetryable(boolean isRetryable) { this.isRetryable = isRetryable; }
  
  public void setOperationName(String operationName) { this.operationName = operationName; }
  
  public String getOperationName() { return this.operationName; }
  
  public String toString() {
    int len = index();
    StringBuilder sb = new StringBuilder("ClientMessage{");
    sb.append("connection=").append(this.connection);
    sb.append(", length=").append(len);
    if (len >= HEADER_SIZE) {
      sb.append(", correlationId=").append(getCorrelationId());
      sb.append(", operation=").append(this.operationName);
      sb.append(", messageType=").append(Integer.toHexString(getMessageType()));
      sb.append(", partitionId=").append(getPartitionId());
      sb.append(", isComplete=").append(isComplete());
      sb.append(", isRetryable=").append(isRetryable());
      sb.append(", isEvent=").append(isFlagSet((short)1));
      sb.append(", writeOffset=").append(this.writeOffset);
    } 
    sb.append('}');
    return sb.toString();
  }
  
  public static ClientMessage create() { return new ClientMessage(); }
  
  public static ClientMessage createForEncode(int initialCapacity) {
    if (initialCapacity < 0)
      throw new MaxMessageSizeExceeded(); 
    if (USE_UNSAFE)
      return createForEncode(new UnsafeBuffer(new byte[initialCapacity]), 0); 
    return createForEncode(new SafeBuffer(new byte[initialCapacity]), 0);
  }
  
  public static ClientMessage createForEncode(ClientProtocolBuffer buffer, int offset) {
    ClientMessage clientMessage = new ClientMessage();
    clientMessage.wrapForEncode(buffer, offset);
    return clientMessage;
  }
  
  public static ClientMessage createForDecode(ClientProtocolBuffer buffer, int offset) {
    ClientMessage clientMessage = new ClientMessage();
    clientMessage.wrapForDecode(buffer, offset);
    return clientMessage;
  }
  
  public ClientMessage copy() {
    byte[] oldBinary = buffer().byteArray();
    byte[] bytes = Arrays.copyOf(oldBinary, oldBinary.length);
    ClientMessage newMessage = createForDecode(BufferBuilder.createBuffer(bytes), 0);
    newMessage.isRetryable = this.isRetryable;
    newMessage.acquiresResource = this.acquiresResource;
    newMessage.operationName = this.operationName;
    return newMessage;
  }
  
  public int hashCode() { return ByteBuffer.wrap(buffer().byteArray(), 0, getFrameLength()).hashCode(); }
  
  public boolean equals(Object o) {
    if (this == o)
      return true; 
    if (o == null || getClass() != o.getClass())
      return false; 
    ClientMessage that = (ClientMessage)o;
    byte[] thisBytes = buffer().byteArray();
    byte[] thatBytes = that.buffer().byteArray();
    if (getFrameLength() != that.getFrameLength())
      return false; 
    for (int i = 0; i < getFrameLength(); i++) {
      if (thisBytes[i] != thatBytes[i])
        return false; 
    } 
    return true;
  }
}
