package com.hazelcast.core;

import com.hazelcast.spi.annotation.Beta;
import com.hazelcast.util.ConcurrencyUtil;
import com.hazelcast.util.Preconditions;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.LockSupport;

@Beta
public class Pipelining<E> extends Object {
  private final AtomicInteger permits;
  
  private final List<ICompletableFuture<E>> futures;
  
  private Thread thread;
  
  public Pipelining(int depth) {
    this.permits = new AtomicInteger();
    this.futures = new ArrayList();
    Preconditions.checkPositive(depth, "depth must be positive");
    this.permits.set(depth);
  }
  
  public List<E> results() throws Exception {
    List<E> result = new ArrayList<E>(this.futures.size());
    for (ICompletableFuture<E> f : this.futures)
      result.add(f.get()); 
    return result;
  }
  
  public ICompletableFuture<E> add(ICompletableFuture<E> future) throws InterruptedException {
    Preconditions.checkNotNull(future, "future can't be null");
    this.thread = Thread.currentThread();
    down();
    this.futures.add(future);
    future.andThen(new Object(this), ConcurrencyUtil.CALLER_RUNS);
    return future;
  }
  
  private void down() throws InterruptedException {
    while (true) {
      int current = this.permits.get();
      int update = current - 1;
      if (!this.permits.compareAndSet(current, update))
        continue; 
      break;
    } 
    while (this.permits.get() == -1) {
      LockSupport.park();
      if (Thread.interrupted())
        throw new InterruptedException(); 
    } 
  }
  
  private void up() throws InterruptedException {
    int update;
    int current;
    do {
      current = this.permits.get();
      update = current + 1;
    } while (!this.permits.compareAndSet(current, update));
    if (current == -1)
      LockSupport.unpark(this.thread); 
  }
}
