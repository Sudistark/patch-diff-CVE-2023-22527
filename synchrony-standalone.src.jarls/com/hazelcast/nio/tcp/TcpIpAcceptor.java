package com.hazelcast.nio.tcp;

import com.hazelcast.internal.metrics.MetricsProvider;
import com.hazelcast.internal.metrics.MetricsRegistry;
import com.hazelcast.internal.metrics.Probe;
import com.hazelcast.internal.networking.ServerSocketRegistry;
import com.hazelcast.internal.networking.nio.SelectorMode;
import com.hazelcast.internal.util.counters.SwCounter;
import com.hazelcast.logging.ILogger;
import com.hazelcast.nio.IOService;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.util.Collections;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

public class TcpIpAcceptor implements MetricsProvider {
  private static final long SHUTDOWN_TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10L);
  
  private static final long SELECT_TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(60L);
  
  private static final int SELECT_IDLE_COUNT_THRESHOLD = 10;
  
  private final ServerSocketRegistry registry;
  
  private final TcpIpNetworkingService networkingService;
  
  private final ILogger logger;
  
  private final IOService ioService;
  
  @Probe
  private final SwCounter eventCount;
  
  @Probe
  private final SwCounter exceptionCount;
  
  @Probe
  private final SwCounter selectorRecreateCount;
  
  private final AcceptorIOThread acceptorThread;
  
  private final boolean selectorWorkaround;
  
  private final Set<SelectionKey> selectionKeys;
  
  TcpIpAcceptor(ServerSocketRegistry registry, TcpIpNetworkingService networkingService, IOService ioService) {
    this
      .eventCount = SwCounter.newSwCounter();
    this
      .exceptionCount = SwCounter.newSwCounter();
    this
      .selectorRecreateCount = SwCounter.newSwCounter();
    this.selectorWorkaround = (SelectorMode.getConfiguredValue() == SelectorMode.SELECT_WITH_FIX);
    this
      .selectionKeys = Collections.newSetFromMap(new ConcurrentHashMap());
    this.registry = registry;
    this.networkingService = networkingService;
    this.ioService = networkingService.getIoService();
    this.logger = ioService.getLoggingService().getLogger(getClass());
    this.acceptorThread = new AcceptorIOThread(this, null);
  }
  
  @Probe
  private long idleTimeMs() { return Math.max(System.currentTimeMillis() - this.lastSelectTimeMs, 0L); }
  
  public void provideMetrics(MetricsRegistry registry) { registry.scanAndRegister(this, "tcp." + this.acceptorThread.getName()); }
  
  public TcpIpAcceptor start() {
    this.acceptorThread.start();
    return this;
  }
  
  public void shutdown() {
    if (this.stop)
      return; 
    this.logger.finest("Shutting down SocketAcceptor thread.");
    this.stop = true;
    Selector sel = this.selector;
    if (sel != null)
      sel.wakeup(); 
    try {
      this.acceptorThread.join(SHUTDOWN_TIMEOUT_MILLIS);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      this.logger.finest(e);
    } 
  }
}
