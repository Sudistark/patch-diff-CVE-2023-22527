package com.hazelcast.nio.tcp;

import com.hazelcast.config.EndpointConfig;
import com.hazelcast.instance.ProtocolType;
import com.hazelcast.internal.metrics.MetricsRegistry;
import com.hazelcast.internal.metrics.Probe;
import com.hazelcast.internal.metrics.ProbeLevel;
import com.hazelcast.internal.networking.ChannelInitializerProvider;
import com.hazelcast.logging.LoggingService;
import com.hazelcast.nio.ConnectionType;
import com.hazelcast.nio.IOService;
import com.hazelcast.nio.NetworkingService;
import com.hazelcast.spi.properties.HazelcastProperties;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

class TcpIpUnifiedEndpointManager extends TcpIpEndpointManager {
  TcpIpUnifiedEndpointManager(NetworkingService root, EndpointConfig endpointConfig, ChannelInitializerProvider channelInitializerProvider, IOService ioService, LoggingService loggingService, MetricsRegistry metricsRegistry, HazelcastProperties properties) {
    super(root, endpointConfig, channelInitializerProvider, ioService, loggingService, metricsRegistry, properties, 
        ProtocolType.valuesAsSet());
  }
  
  Set<TcpIpConnection> getRestConnections() {
    Set<TcpIpConnection> connections = this.activeConnections.isEmpty() ? Collections.emptySet() : new HashSet(this.activeConnections.size());
    for (TcpIpConnection conn : this.activeConnections) {
      if (conn.isAlive() && conn.getType() == ConnectionType.REST_CLIENT)
        connections.add(conn); 
    } 
    return connections;
  }
  
  Set<TcpIpConnection> getMemachedConnections() {
    Set<TcpIpConnection> connections = this.activeConnections.isEmpty() ? Collections.emptySet() : new HashSet(this.activeConnections.size());
    for (TcpIpConnection conn : this.activeConnections) {
      if (conn.isAlive() && conn.getType() == ConnectionType.MEMCACHE_CLIENT)
        connections.add(conn); 
    } 
    return connections;
  }
  
  Set<TcpIpConnection> getTextConnections() {
    Set<TcpIpConnection> connections = this.activeConnections.isEmpty() ? Collections.emptySet() : new HashSet(this.activeConnections.size());
    for (TcpIpConnection conn : this.activeConnections) {
      if ((conn.isAlive() && conn.getType() == ConnectionType.REST_CLIENT) || conn.getType() == ConnectionType.MEMCACHE_CLIENT)
        connections.add(conn); 
    } 
    return connections;
  }
  
  Set<TcpIpConnection> getCurrentClientConnections() {
    Set<TcpIpConnection> connections = this.activeConnections.isEmpty() ? Collections.emptySet() : new HashSet(this.activeConnections.size());
    for (TcpIpConnection conn : this.activeConnections) {
      if (conn.isAlive() && conn.isClient())
        connections.add(conn); 
    } 
    return connections;
  }
  
  @Probe(name = "clientCount", level = ProbeLevel.MANDATORY)
  public int getCurrentClientConnectionsCount() { return getCurrentClientConnections().size(); }
  
  @Probe(name = "textCount", level = ProbeLevel.MANDATORY)
  public int getCurrentTextConnections() { return getTextConnections().size(); }
}
