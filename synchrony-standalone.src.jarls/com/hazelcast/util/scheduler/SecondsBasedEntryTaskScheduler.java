package com.hazelcast.util.scheduler;

import com.hazelcast.spi.TaskScheduler;
import com.hazelcast.util.Clock;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

public final class SecondsBasedEntryTaskScheduler<K, V> extends Object implements EntryTaskScheduler<K, V> {
  public static final double FACTOR = 1000.0D;
  
  private static final long INITIAL_TIME_MILLIS = Clock.currentTimeMillis();
  
  private static final Comparator<ScheduledEntry> SCHEDULED_ENTRIES_COMPARATOR = new Object();
  
  private HashMap<K, PerKeyScheduler> keys;
  
  private HashMap<Integer, ScheduledGroup> groups;
  
  private final AtomicLong uniqueIdGenerator;
  
  private final Object mutex;
  
  private final TaskScheduler taskScheduler;
  
  private final ScheduledEntryProcessor<K, V> entryProcessor;
  
  private final ScheduleType scheduleType;
  
  SecondsBasedEntryTaskScheduler(TaskScheduler taskScheduler, ScheduledEntryProcessor<K, V> entryProcessor, ScheduleType scheduleType) {
    this.keys = new HashMap();
    this.groups = new HashMap();
    this.uniqueIdGenerator = new AtomicLong();
    this.mutex = new Object();
    this.taskScheduler = taskScheduler;
    this.entryProcessor = entryProcessor;
    this.scheduleType = scheduleType;
  }
  
  public boolean schedule(long delayMillis, K key, V value) {
    int delaySeconds = ceilToSecond(delayMillis);
    int second = findRelativeSecond(delayMillis);
    long id = this.uniqueIdGenerator.incrementAndGet();
    synchronized (this.mutex) {
      ScheduledEntry<K, V> entry = new ScheduledEntry<K, V>(key, value, delayMillis, delaySeconds, id);
      PerKeyForEachScheduler perKeyForEachScheduler = (PerKeyScheduler)this.keys.get(key);
      if (perKeyForEachScheduler == null) {
        PerKeyPostponeScheduler perKeyPostponeScheduler;
        switch (null.$SwitchMap$com$hazelcast$util$scheduler$ScheduleType[this.scheduleType.ordinal()]) {
          case 1:
            perKeyPostponeScheduler = new PerKeyPostponeScheduler(this, key);
            break;
          case 2:
            perKeyForEachScheduler = new PerKeyForEachScheduler(this, key);
            break;
          default:
            throw new RuntimeException("Undefined schedule type.");
        } 
        this.keys.put(key, perKeyForEachScheduler);
      } 
      ScheduledGroup group = (ScheduledGroup)this.groups.get(Integer.valueOf(second));
      if (group == null) {
        Object object = new Object(this, second);
        ScheduledFuture executorFuture = this.taskScheduler.schedule(object, delaySeconds, TimeUnit.SECONDS);
        group = new ScheduledGroup(this, second, executorFuture, null);
        this.groups.put(Integer.valueOf(second), group);
      } 
      return perKeyForEachScheduler.schedule(entry, group);
    } 
  }
  
  private void executeGroup(int second) {
    List<ScheduledEntry<K, V>> entries;
    synchronized (this.mutex) {
      ScheduledGroup group = (ScheduledGroup)this.groups.remove(Integer.valueOf(second));
      if (group == null)
        return; 
      entries = new ArrayList<ScheduledEntry<K, V>>(ScheduledGroup.access$200(group));
      for (ScheduledEntry<K, V> entry : entries)
        ((PerKeyScheduler)this.keys.get(entry.getKey())).executed(entry); 
    } 
    Collections.sort(entries, SCHEDULED_ENTRIES_COMPARATOR);
    this.entryProcessor.process(this, entries);
  }
  
  public ScheduledEntry<K, V> get(K key) {
    synchronized (this.mutex) {
      PerKeyScheduler keyScheduler = (PerKeyScheduler)this.keys.get(key);
      return (keyScheduler != null) ? keyScheduler.get() : null;
    } 
  }
  
  public ScheduledEntry<K, V> cancel(K key) {
    synchronized (this.mutex) {
      PerKeyScheduler keyScheduler = (PerKeyScheduler)this.keys.get(key);
      return (keyScheduler != null) ? keyScheduler.cancel() : null;
    } 
  }
  
  public int cancelIfExists(K key, V value) {
    synchronized (this.mutex) {
      PerKeyScheduler keyScheduler = (PerKeyScheduler)this.keys.get(key);
      return (keyScheduler != null) ? keyScheduler.cancelIfExists(value) : 0;
    } 
  }
  
  public void cancelAll() {
    synchronized (this.mutex) {
      for (ScheduledGroup group : this.groups.values())
        group.executor.cancel(false); 
      this.groups.clear();
      this.keys.clear();
    } 
  }
  
  public String toString() {
    return "EntryTaskScheduler{numberOfEntries=" + 
      
      size() + ", numberOfKeys=" + this.keys
      
      .size() + ", numberOfGroups=" + this.groups
      
      .size() + '}';
  }
  
  int size() {
    synchronized (this.mutex) {
      int size = 0;
      for (ScheduledGroup group : this.groups.values())
        size += ScheduledGroup.access$1000(group); 
      return size;
    } 
  }
  
  public boolean isEmpty() {
    synchronized (this.mutex) {
      return (this.groups.isEmpty() && this.keys.isEmpty());
    } 
  }
  
  static int findRelativeSecond(long delayMillis) {
    long now = Clock.currentTimeMillis();
    long d = now + delayMillis - INITIAL_TIME_MILLIS;
    return ceilToSecond(d);
  }
  
  private static int ceilToSecond(long delayMillis) { return (int)Math.ceil(delayMillis / 1000.0D); }
  
  private static boolean areEqual(Object a, Object b) { return (a == b || (a != null && a.equals(b))); }
}
