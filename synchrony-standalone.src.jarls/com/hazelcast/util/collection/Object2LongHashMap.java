package com.hazelcast.util.collection;

import com.hazelcast.util.QuickMath;
import java.util.Arrays;
import java.util.Collection;
import java.util.Map;
import java.util.Set;

public class Object2LongHashMap<K> extends Object implements Map<K, Long> {
  private static final float DEFAULT_LOAD_FACTOR = 0.6F;
  
  private static final int MIN_CAPACITY = 8;
  
  private final float loadFactor;
  
  private final long missingValue;
  
  private int resizeThreshold;
  
  private int size;
  
  private final boolean shouldAvoidAllocation;
  
  private K[] keys;
  
  private long[] values;
  
  private ValueCollection valueCollection;
  
  private KeySet keySet;
  
  private EntrySet entrySet;
  
  public Object2LongHashMap(long missingValue) { this(8, 0.6F, missingValue); }
  
  public Object2LongHashMap(int initialCapacity, float loadFactor, long missingValue) { this(initialCapacity, loadFactor, missingValue, true); }
  
  public Object2LongHashMap(int initialCapacity, float loadFactor, long missingValue, boolean shouldAvoidAllocation) {
    this.loadFactor = loadFactor;
    int capacity = QuickMath.nextPowerOfTwo(Math.max(8, initialCapacity));
    this.resizeThreshold = (int)(capacity * loadFactor);
    this.missingValue = missingValue;
    this.shouldAvoidAllocation = shouldAvoidAllocation;
    this.keys = (Object[])new Object[capacity];
    this.values = new long[capacity];
    Arrays.fill(this.values, missingValue);
  }
  
  public Object2LongHashMap(Object2LongHashMap<K> mapToCopy) {
    this.loadFactor = mapToCopy.loadFactor;
    this.resizeThreshold = mapToCopy.resizeThreshold;
    this.size = mapToCopy.size;
    this.missingValue = mapToCopy.missingValue;
    this.shouldAvoidAllocation = mapToCopy.shouldAvoidAllocation;
    this.keys = (Object[])mapToCopy.keys.clone();
    this.values = (long[])mapToCopy.values.clone();
  }
  
  public long missingValue() { return this.missingValue; }
  
  public float loadFactor() { return this.loadFactor; }
  
  public int capacity() { return this.values.length; }
  
  public int resizeThreshold() { return this.resizeThreshold; }
  
  public int size() { return this.size; }
  
  public boolean isEmpty() { return (0 == this.size); }
  
  public boolean containsKey(Object key) {
    int mask = this.values.length - 1;
    int index = Hashing.hash(key, mask);
    boolean found = false;
    while (this.missingValue != this.values[index]) {
      if (key.equals(this.keys[index])) {
        found = true;
        break;
      } 
      index = ++index & mask;
    } 
    return found;
  }
  
  public boolean containsValue(Object value) { return containsValue(((Long)value).longValue()); }
  
  public boolean containsValue(long value) {
    if (value == this.missingValue)
      return false; 
    boolean found = false;
    for (long v : this.values) {
      if (value == v) {
        found = true;
        break;
      } 
    } 
    return found;
  }
  
  public Long get(Object key) { return valOrNull(getValue(key)); }
  
  public long getValue(K key) {
    int mask = this.values.length - 1;
    int index = Hashing.hash(key, mask);
    long value;
    while (this.missingValue != (value = this.values[index])) {
      if (key.equals(this.keys[index]))
        break; 
      index = ++index & mask;
    } 
    return value;
  }
  
  public Long put(K key, Long value) { return valOrNull(put(key, value.longValue())); }
  
  public long put(K key, long value) {
    if (value == this.missingValue)
      throw new IllegalArgumentException("cannot accept missingValue"); 
    long oldValue = this.missingValue;
    int mask = this.values.length - 1;
    int index = Hashing.hash(key, mask);
    while (this.missingValue != this.values[index]) {
      if (key.equals(this.keys[index])) {
        oldValue = this.values[index];
        break;
      } 
      index = ++index & mask;
    } 
    if (this.missingValue == oldValue) {
      this.size++;
      this.keys[index] = key;
    } 
    this.values[index] = value;
    if (this.size > this.resizeThreshold)
      increaseCapacity(); 
    return oldValue;
  }
  
  public Long remove(Object key) { return valOrNull(removeKey(key)); }
  
  public long removeKey(K key) {
    int mask = this.values.length - 1;
    int index = Hashing.hash(key, mask);
    long value;
    while (this.missingValue != (value = this.values[index])) {
      if (key.equals(this.keys[index])) {
        this.keys[index] = null;
        this.values[index] = this.missingValue;
        this.size--;
        compactChain(index);
        break;
      } 
      index = ++index & mask;
    } 
    return value;
  }
  
  public void clear() {
    if (this.size > 0) {
      Arrays.fill(this.keys, null);
      Arrays.fill(this.values, this.missingValue);
      this.size = 0;
    } 
  }
  
  public void compact() {
    int idealCapacity = (int)Math.round(size() * 1.0D / this.loadFactor);
    rehash(QuickMath.nextPowerOfTwo(Math.max(8, idealCapacity)));
  }
  
  public void putAll(Map<? extends K, ? extends Long> map) {
    for (Map.Entry<? extends K, ? extends Long> entry : map.entrySet())
      put(entry.getKey(), (Long)entry.getValue()); 
  }
  
  public KeySet keySet() {
    if (null == this.keySet)
      this.keySet = new KeySet(this); 
    return this.keySet;
  }
  
  public ValueCollection values() {
    if (null == this.valueCollection)
      this.valueCollection = new ValueCollection(this); 
    return this.valueCollection;
  }
  
  public EntrySet entrySet() {
    if (null == this.entrySet)
      this.entrySet = new EntrySet(this); 
    return this.entrySet;
  }
  
  public String toString() {
    if (isEmpty())
      return "{}"; 
    EntryIterator entryIterator = new EntryIterator(this);
    entryIterator.reset();
    StringBuilder sb = (new StringBuilder()).append('{');
    while (true) {
      entryIterator.next();
      sb.append(entryIterator.getKey()).append('=').append(entryIterator.getLongValue());
      if (!entryIterator.hasNext())
        return sb.append('}').toString(); 
      sb.append(',').append(' ');
    } 
  }
  
  public boolean equals(Object o) {
    if (this == o)
      return true; 
    if (!(o instanceof Map))
      return false; 
    Map<?, ?> that = (Map)o;
    if (this.size != that.size())
      return false; 
    for (int i = 0, length = this.values.length; i < length; i++) {
      long thisValue = this.values[i];
      if (this.missingValue != thisValue) {
        Object thatValueObject = that.get(this.keys[i]);
        if (!(thatValueObject instanceof Long))
          return false; 
        long thatValue = ((Long)thatValueObject).longValue();
        if (this.missingValue == thatValue || thisValue != thatValue)
          return false; 
      } 
    } 
    return true;
  }
  
  public int hashCode() {
    int result = 0;
    for (int i = 0, length = this.values.length; i < length; i++) {
      long value = this.values[i];
      if (this.missingValue != value)
        result += (this.keys[i].hashCode() ^ Hashing.hashCode(value)); 
    } 
    return result;
  }
  
  public long replace(K key, long value) {
    long curValue = getValue(key);
    if (curValue != this.missingValue)
      curValue = put(key, value); 
    return curValue;
  }
  
  public boolean replace(K key, long oldValue, long newValue) {
    long curValue = getValue(key);
    if (curValue == this.missingValue || curValue != oldValue)
      return false; 
    put(key, newValue);
    return true;
  }
  
  private void increaseCapacity() {
    int newCapacity = this.values.length << 1;
    if (newCapacity < 0)
      throw new IllegalStateException("max capacity reached at size=" + this.size); 
    rehash(newCapacity);
  }
  
  private void rehash(int newCapacity) {
    int mask = newCapacity - 1;
    this.resizeThreshold = (int)(newCapacity * this.loadFactor);
    K[] tempKeys = (K[])(Object[])new Object[newCapacity];
    long[] tempValues = new long[newCapacity];
    Arrays.fill(tempValues, this.missingValue);
    for (int i = 0, size = this.values.length; i < size; i++) {
      long value = this.values[i];
      if (this.missingValue != value) {
        K key = (K)this.keys[i];
        int index = Hashing.hash(key, mask);
        while (this.missingValue != tempValues[index])
          index = ++index & mask; 
        tempKeys[index] = key;
        tempValues[index] = value;
      } 
    } 
    this.keys = tempKeys;
    this.values = tempValues;
  }
  
  private void compactChain(int deleteIndex) {
    int mask = this.values.length - 1;
    int index = deleteIndex;
    while (true) {
      index = ++index & mask;
      if (this.missingValue == this.values[index])
        break; 
      int hash = Hashing.hash(this.keys[index], mask);
      if ((index < hash && (hash <= deleteIndex || deleteIndex <= index)) || (hash <= deleteIndex && deleteIndex <= index)) {
        this.keys[deleteIndex] = this.keys[index];
        this.values[deleteIndex] = this.values[index];
        this.keys[index] = null;
        this.values[index] = this.missingValue;
        deleteIndex = index;
      } 
    } 
  }
  
  private Long valOrNull(long value) { return (value == this.missingValue) ? null : Long.valueOf(value); }
}
