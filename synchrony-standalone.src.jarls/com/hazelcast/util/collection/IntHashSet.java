package com.hazelcast.util.collection;

import com.hazelcast.util.Preconditions;
import com.hazelcast.util.QuickMath;
import com.hazelcast.util.function.Predicate;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.Set;

public final class IntHashSet extends Object implements Set<Integer> {
  public static final int MAX_CAPACITY = 536870912;
  
  private final int[] values;
  
  private final IntIterator iterator;
  
  private final int capacity;
  
  private final int mask;
  
  private final int missingValue;
  
  private int size;
  
  public IntHashSet(int capacity, int missingValue) {
    Preconditions.checkTrue((capacity <= 536870912), "Maximum capacity is 2^29");
    this.capacity = capacity;
    this.size = 0;
    this.missingValue = missingValue;
    int arraySize = QuickMath.nextPowerOfTwo(2 * capacity);
    this.mask = arraySize - 1;
    this.values = new int[arraySize];
    Arrays.fill(this.values, missingValue);
    this.iterator = new IntIterator(missingValue, this.values);
  }
  
  public boolean add(Integer value) { return add(value.intValue()); }
  
  public boolean add(int value) {
    if (this.size == this.capacity)
      throw new IllegalStateException("This IntHashSet of capacity " + this.capacity + " is full"); 
    int index = Hashing.intHash(value, this.mask);
    while (this.values[index] != this.missingValue) {
      if (this.values[index] == value)
        return false; 
      index = next(index);
    } 
    this.values[index] = value;
    this.size++;
    return true;
  }
  
  public boolean remove(Object value) { return (value instanceof Integer && remove(((Integer)value).intValue())); }
  
  public boolean remove(int value) {
    int index = Hashing.intHash(value, this.mask);
    while (this.values[index] != this.missingValue) {
      if (this.values[index] == value) {
        this.values[index] = this.missingValue;
        compactChain(index);
        return true;
      } 
      index = next(index);
    } 
    return false;
  }
  
  private int next(int index) { return ++index & this.mask; }
  
  private void compactChain(int deleteIndex) {
    int[] values = this.values;
    int index = deleteIndex;
    while (true) {
      index = next(index);
      if (values[index] == this.missingValue)
        return; 
      int hash = Hashing.intHash(values[index], this.mask);
      if ((index < hash && (hash <= deleteIndex || deleteIndex <= index)) || (hash <= deleteIndex && deleteIndex <= index)) {
        values[deleteIndex] = values[index];
        values[index] = this.missingValue;
        deleteIndex = index;
      } 
    } 
  }
  
  public boolean contains(Object value) { return (value instanceof Integer && contains(((Integer)value).intValue())); }
  
  public boolean contains(int value) {
    int index = Hashing.intHash(value, this.mask);
    while (this.values[index] != this.missingValue) {
      if (this.values[index] == value)
        return true; 
      index = next(index);
    } 
    return false;
  }
  
  public int size() { return this.size; }
  
  public boolean isEmpty() { return (size() == 0); }
  
  public void clear() {
    int[] values = this.values;
    int length = values.length;
    for (int i = 0; i < length; i++)
      values[i] = this.missingValue; 
    this.size = 0;
  }
  
  public boolean addAll(Collection<? extends Integer> coll) { return addAllCapture(coll); }
  
  private <E extends Integer> boolean addAllCapture(Collection<E> coll) {
    Object object = new Object(this);
    return conjunction(coll, object);
  }
  
  public boolean containsAll(Collection<?> coll) { return containsAllCapture(coll); }
  
  private <E> boolean containsAllCapture(Collection<E> coll) { return conjunction(coll, new Object(this)); }
  
  public boolean containsAll(IntHashSet other) {
    IntIterator iterator = other.iterator();
    while (iterator.hasNext()) {
      if (!contains(iterator.nextValue()))
        return false; 
    } 
    return true;
  }
  
  public IntHashSet difference(IntHashSet collection) {
    Preconditions.checkNotNull(collection, "Collection must not be null");
    IntHashSet difference = null;
    IntIterator it = iterator();
    while (it.hasNext()) {
      int value = it.nextValue();
      if (!collection.contains(value)) {
        if (difference == null)
          difference = new IntHashSet(this.size, this.missingValue); 
        difference.add(value);
      } 
    } 
    return difference;
  }
  
  public boolean removeAll(Collection<?> coll) { return removeAllCapture(coll); }
  
  private <E> boolean removeAllCapture(Collection<E> coll) { return conjunction(coll, new Object(this)); }
  
  private static <E> boolean conjunction(Collection<E> collection, Predicate<E> predicate) {
    Preconditions.checkNotNull(collection);
    boolean acc = false;
    for (E e : collection)
      acc |= predicate.test(e); 
    return acc;
  }
  
  public IntIterator iterator() {
    this.iterator.reset();
    return this.iterator;
  }
  
  public void copy(IntHashSet obj) {
    if (this.mask != obj.mask)
      throw new IllegalArgumentException("Cannot copy object: masks not equal"); 
    if (this.missingValue != obj.missingValue)
      throw new IllegalArgumentException("Cannot copy object: missingValues not equal"); 
    System.arraycopy(obj.values, 0, this.values, 0, this.values.length);
    this.size = obj.size;
  }
  
  public String toString() {
    StringBuilder b = new StringBuilder(size() * 3 + 2);
    b.append('{');
    String separator = "";
    for (int i : this.values) {
      b.append(i).append(separator);
      separator = ",";
    } 
    return b.append('}').toString();
  }
  
  public Object[] toArray() {
    int[] values = this.values;
    Object[] array = new Object[this.size];
    int i = 0;
    for (int value : values) {
      if (value != this.missingValue)
        array[i++] = Integer.valueOf(value); 
    } 
    return array;
  }
  
  public <T> T[] toArray(T[] into) {
    Preconditions.checkNotNull(into);
    Class<?> aryType = into.getClass().getComponentType();
    if (!aryType.isAssignableFrom(Integer.class))
      throw new ArrayStoreException("Cannot store Integers in array of type " + aryType); 
    int[] values = this.values;
    T[] arrayOfT = (into.length >= this.size) ? into : (Object[])Array.newInstance(aryType, this.size);
    int i = 0;
    for (int value : values) {
      if (value != this.missingValue)
        arrayOfT[i++] = Integer.valueOf(value); 
    } 
    if (arrayOfT.length > this.size)
      arrayOfT[values.length] = null; 
    return (T[])(Object[])arrayOfT;
  }
  
  public boolean equals(Object other) {
    if (other == this)
      return true; 
    if (other instanceof IntHashSet) {
      IntHashSet otherSet = (IntHashSet)other;
      return (otherSet.missingValue == this.missingValue && otherSet.size() == size() && containsAll(otherSet));
    } 
    return false;
  }
  
  public int hashCode() {
    IntIterator iterator = iterator();
    int total = 0;
    while (iterator.hasNext())
      total += iterator.nextValue(); 
    return total;
  }
  
  public boolean retainAll(Collection<?> coll) { throw new UnsupportedOperationException("Not implemented"); }
}
