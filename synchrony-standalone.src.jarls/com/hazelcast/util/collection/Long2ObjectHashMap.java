package com.hazelcast.util.collection;

import com.hazelcast.util.Preconditions;
import com.hazelcast.util.QuickMath;
import com.hazelcast.util.function.LongFunction;
import java.util.Arrays;
import java.util.Collection;
import java.util.Map;
import java.util.Set;

public class Long2ObjectHashMap<V> extends Object implements Map<Long, V> {
  public static final double DEFAULT_LOAD_FACTOR = 0.6D;
  
  public static final int DEFAULT_INITIAL_CAPACITY = 8;
  
  private final double loadFactor;
  
  private int resizeThreshold;
  
  private int capacity;
  
  private int mask;
  
  private int size;
  
  private long[] keys;
  
  private Object[] values;
  
  private final ValueCollection valueCollection;
  
  private final KeySet keySet;
  
  private final EntrySet entrySet;
  
  public Long2ObjectHashMap() { this(8, 0.6D); }
  
  public Long2ObjectHashMap(int initialCapacity) { this(initialCapacity, 0.6D); }
  
  public Long2ObjectHashMap(int initialCapacity, double loadFactor) {
    this.valueCollection = new ValueCollection(this, null);
    this.keySet = new KeySet(this);
    this.entrySet = new EntrySet(this, null);
    this.loadFactor = loadFactor;
    this.capacity = QuickMath.nextPowerOfTwo(initialCapacity);
    this.mask = this.capacity - 1;
    this.resizeThreshold = (int)(this.capacity * loadFactor);
    this.keys = new long[this.capacity];
    this.values = new Object[this.capacity];
  }
  
  public double loadFactor() { return this.loadFactor; }
  
  public int capacity() { return this.capacity; }
  
  public int resizeThreshold() { return this.resizeThreshold; }
  
  public int size() { return this.size; }
  
  public boolean isEmpty() { return (0 == this.size); }
  
  public boolean containsKey(Object key) {
    Preconditions.checkNotNull(key, "Null keys are not permitted");
    return containsKey(((Long)key).longValue());
  }
  
  public boolean containsKey(long key) {
    int index = Hashing.longHash(key, this.mask);
    while (null != this.values[index]) {
      if (key == this.keys[index])
        return true; 
      index = ++index & this.mask;
    } 
    return false;
  }
  
  public boolean containsValue(Object value) {
    Preconditions.checkNotNull(value, "Null values are not permitted");
    for (Object v : this.values) {
      if (null != v && value.equals(v))
        return true; 
    } 
    return false;
  }
  
  public V get(Object key) { return (V)get(((Long)key).longValue()); }
  
  public V get(long key) {
    int index = Hashing.longHash(key, this.mask);
    Object value;
    while (null != (value = this.values[index])) {
      if (key == this.keys[index])
        return (V)value; 
      index = ++index & this.mask;
    } 
    return null;
  }
  
  public V computeIfAbsent(long key, LongFunction<? extends V> mappingFunction) {
    Preconditions.checkNotNull(mappingFunction, "mappingFunction cannot be null");
    V value = (V)get(key);
    if (value == null) {
      value = (V)mappingFunction.apply(key);
      if (value != null)
        put(key, value); 
    } 
    return value;
  }
  
  public V put(Long key, V value) { return (V)put(key.longValue(), value); }
  
  public V put(long key, V value) {
    Preconditions.checkNotNull(value, "Value cannot be null");
    V oldValue = null;
    int index = Hashing.longHash(key, this.mask);
    while (null != this.values[index]) {
      if (key == this.keys[index]) {
        oldValue = (V)this.values[index];
        break;
      } 
      index = ++index & this.mask;
    } 
    if (null == oldValue) {
      this.size++;
      this.keys[index] = key;
    } 
    this.values[index] = value;
    if (this.size > this.resizeThreshold)
      increaseCapacity(); 
    return oldValue;
  }
  
  public V remove(Object key) { return (V)remove(((Long)key).longValue()); }
  
  public V remove(long key) {
    int index = Hashing.longHash(key, this.mask);
    Object value;
    while (null != (value = this.values[index])) {
      if (key == this.keys[index]) {
        this.values[index] = null;
        this.size--;
        compactChain(index);
        return (V)value;
      } 
      index = ++index & this.mask;
    } 
    return null;
  }
  
  public void clear() {
    this.size = 0;
    Arrays.fill(this.values, null);
  }
  
  public void compact() {
    int idealCapacity = (int)Math.round(size() * 1.0D / this.loadFactor);
    rehash(QuickMath.nextPowerOfTwo(idealCapacity));
  }
  
  public void putAll(Map<? extends Long, ? extends V> map) {
    for (Map.Entry<? extends Long, ? extends V> entry : map.entrySet())
      put((Long)entry.getKey(), entry.getValue()); 
  }
  
  public KeySet keySet() { return this.keySet; }
  
  public Collection<V> values() { return this.valueCollection; }
  
  public Set<Map.Entry<Long, V>> entrySet() { return this.entrySet; }
  
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append('{');
    for (Map.Entry<Long, V> entry : entrySet()) {
      sb.append(((Long)entry.getKey()).longValue());
      sb.append('=');
      sb.append(entry.getValue());
      sb.append(", ");
    } 
    if (sb.length() > 1)
      sb.setLength(sb.length() - 2); 
    sb.append('}');
    return sb.toString();
  }
  
  private void increaseCapacity() {
    int newCapacity = this.capacity << 1;
    if (newCapacity < 0)
      throw new IllegalStateException("Max capacity reached at size=" + this.size); 
    rehash(newCapacity);
  }
  
  private void rehash(int newCapacity) {
    if (1 != Integer.bitCount(newCapacity))
      throw new IllegalStateException("New capacity must be a power of two"); 
    this.capacity = newCapacity;
    this.mask = newCapacity - 1;
    this.resizeThreshold = (int)(newCapacity * this.loadFactor);
    long[] tempKeys = new long[this.capacity];
    Object[] tempValues = new Object[this.capacity];
    for (int i = 0, size = this.values.length; i < size; i++) {
      Object value = this.values[i];
      if (null != value) {
        long key = this.keys[i];
        int newHash = Hashing.longHash(key, this.mask);
        while (null != tempValues[newHash])
          newHash = ++newHash & this.mask; 
        tempKeys[newHash] = key;
        tempValues[newHash] = value;
      } 
    } 
    this.keys = tempKeys;
    this.values = tempValues;
  }
  
  private void compactChain(int deleteIndex) {
    int index = deleteIndex;
    while (true) {
      index = ++index & this.mask;
      if (null == this.values[index])
        return; 
      int hash = Hashing.longHash(this.keys[index], this.mask);
      if ((index < hash && (hash <= deleteIndex || deleteIndex <= index)) || (hash <= deleteIndex && deleteIndex <= index)) {
        this.keys[deleteIndex] = this.keys[index];
        this.values[deleteIndex] = this.values[index];
        this.values[index] = null;
        deleteIndex = index;
      } 
    } 
  }
}
