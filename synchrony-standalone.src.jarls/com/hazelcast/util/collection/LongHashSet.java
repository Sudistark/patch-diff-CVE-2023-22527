package com.hazelcast.util.collection;

import com.hazelcast.util.Preconditions;
import com.hazelcast.util.QuickMath;
import com.hazelcast.util.function.Predicate;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.Set;

public final class LongHashSet extends Object implements Set<Long> {
  public static final int MAX_CAPACITY = 536870912;
  
  private final long[] values;
  
  private final LongIterator iterator;
  
  private final int capacity;
  
  private final int mask;
  
  private final long missingValue;
  
  private int size;
  
  public LongHashSet(int capacity, long missingValue) {
    Preconditions.checkTrue((capacity <= 536870912), "Maximum capacity is 2^29");
    this.capacity = capacity;
    this.size = 0;
    this.missingValue = missingValue;
    int arraySize = QuickMath.nextPowerOfTwo(2 * capacity);
    this.mask = arraySize - 1;
    this.values = new long[arraySize];
    Arrays.fill(this.values, missingValue);
    this.iterator = new LongIterator(missingValue, this.values);
  }
  
  public LongHashSet(long[] items, long missingValue) {
    this(items.length, missingValue);
    for (long item : items)
      add(item); 
  }
  
  public boolean add(Long value) { return add(value.longValue()); }
  
  public boolean add(long value) {
    if (this.size == this.capacity)
      throw new IllegalStateException("This LongHashSet of capacity " + this.capacity + " is full"); 
    int index = Hashing.longHash(value, this.mask);
    while (this.values[index] != this.missingValue) {
      if (this.values[index] == value)
        return false; 
      index = next(index);
    } 
    this.values[index] = value;
    this.size++;
    return true;
  }
  
  public boolean remove(Object value) { return (value instanceof Long && remove(((Long)value).longValue())); }
  
  public boolean remove(long value) {
    int index = Hashing.longHash(value, this.mask);
    while (this.values[index] != this.missingValue) {
      if (this.values[index] == value) {
        this.values[index] = this.missingValue;
        compactChain(index);
        this.size--;
        return true;
      } 
      index = next(index);
    } 
    return false;
  }
  
  private int next(int index) { return index + 1 & this.mask; }
  
  private void compactChain(int deleteIndex) {
    long[] values = this.values;
    int index = deleteIndex;
    while (true) {
      index = next(index);
      if (values[index] == this.missingValue)
        return; 
      int hash = Hashing.longHash(values[index], this.mask);
      if ((index < hash && (hash <= deleteIndex || deleteIndex <= index)) || (hash <= deleteIndex && deleteIndex <= index)) {
        values[deleteIndex] = values[index];
        values[index] = this.missingValue;
        deleteIndex = index;
      } 
    } 
  }
  
  public boolean contains(Object value) { return (value instanceof Long && contains(((Long)value).longValue())); }
  
  public boolean contains(long value) {
    int index = Hashing.longHash(value, this.mask);
    while (this.values[index] != this.missingValue) {
      if (this.values[index] == value)
        return true; 
      index = next(index);
    } 
    return false;
  }
  
  public int size() { return this.size; }
  
  public boolean isEmpty() { return (size() == 0); }
  
  public void clear() {
    long[] values = this.values;
    int length = values.length;
    for (int i = 0; i < length; i++)
      values[i] = this.missingValue; 
    this.size = 0;
  }
  
  public boolean addAll(Collection<? extends Long> coll) { return addAllCapture(coll); }
  
  private <E extends Long> boolean addAllCapture(Collection<E> coll) {
    Object object = new Object(this);
    return conjunction(coll, object);
  }
  
  public boolean containsAll(Collection<?> coll) { return containsAllCapture(coll); }
  
  private <E> boolean containsAllCapture(Collection<E> coll) { return conjunction(coll, new Object(this)); }
  
  public boolean containsAll(LongHashSet other) {
    LongIterator iterator = other.iterator();
    while (iterator.hasNext()) {
      if (!contains(iterator.nextValue()))
        return false; 
    } 
    return true;
  }
  
  public LongHashSet difference(LongHashSet collection) {
    Preconditions.checkNotNull(collection);
    LongHashSet difference = null;
    LongIterator it = iterator();
    while (it.hasNext()) {
      long value = it.nextValue();
      if (!collection.contains(value)) {
        if (difference == null)
          difference = new LongHashSet(this.size, this.missingValue); 
        difference.add(value);
      } 
    } 
    return difference;
  }
  
  public boolean removeAll(Collection<?> coll) { return removeAllCapture(coll); }
  
  private <E> boolean removeAllCapture(Collection<E> coll) { return conjunction(coll, new Object(this)); }
  
  private static <T> boolean conjunction(Collection<T> collection, Predicate<T> predicate) {
    Preconditions.checkNotNull(collection);
    boolean acc = false;
    for (T t : collection)
      acc |= predicate.test(t); 
    return acc;
  }
  
  public LongIterator iterator() {
    this.iterator.reset();
    return this.iterator;
  }
  
  public void copy(LongHashSet obj) {
    if (this.mask != obj.mask)
      throw new IllegalArgumentException("Cannot copy object: masks not equal"); 
    if (this.missingValue != obj.missingValue)
      throw new IllegalArgumentException("Cannot copy object: missingValues not equal"); 
    System.arraycopy(obj.values, 0, this.values, 0, this.values.length);
    this.size = obj.size;
  }
  
  public String toString() {
    StringBuilder b = new StringBuilder(size() * 3 + 2);
    b.append('{');
    String separator = "";
    for (long i : this.values) {
      if (i != this.missingValue) {
        b.append(separator).append(i);
        separator = ",";
      } 
    } 
    return b.append('}').toString();
  }
  
  public Object[] toArray() {
    long[] values = this.values;
    Object[] array = new Object[this.size];
    int i = 0;
    for (long value : values) {
      if (value != this.missingValue)
        array[i++] = Long.valueOf(value); 
    } 
    return array;
  }
  
  public <T> T[] toArray(T[] into) {
    Preconditions.checkNotNull(into);
    Class<?> aryType = into.getClass().getComponentType();
    if (!aryType.isAssignableFrom(Long.class))
      throw new ArrayStoreException("Cannot store Longs in array of type " + aryType); 
    long[] values = this.values;
    T[] arrayOfT = (into.length >= this.size) ? into : (Object[])Array.newInstance(aryType, this.size);
    int i = 0;
    for (long value : values) {
      if (value != this.missingValue)
        arrayOfT[i++] = Long.valueOf(value); 
    } 
    if (arrayOfT.length > this.size)
      arrayOfT[values.length] = null; 
    return (T[])(Object[])arrayOfT;
  }
  
  public boolean equals(Object other) {
    if (other == this)
      return true; 
    if (other instanceof LongHashSet) {
      LongHashSet otherSet = (LongHashSet)other;
      return (otherSet.missingValue == this.missingValue && otherSet.size() == size() && containsAll(otherSet));
    } 
    return false;
  }
  
  public int hashCode() {
    LongIterator iterator = iterator();
    int total = 0;
    while (iterator.hasNext())
      total = (int)(total + iterator.nextValue()); 
    return total;
  }
  
  public boolean retainAll(Collection<?> coll) { throw new UnsupportedOperationException("Not implemented"); }
}
