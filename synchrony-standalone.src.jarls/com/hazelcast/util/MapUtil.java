package com.hazelcast.util;

import com.hazelcast.mapreduce.impl.HashMapAdapter;
import com.hazelcast.util.collection.Int2ObjectHashMap;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public final class MapUtil {
  private static final float HASHMAP_DEFAULT_LOAD_FACTOR = 0.75F;
  
  public static <K, V> Map<K, V> createHashMap(int expectedMapSize) {
    int initialCapacity = calculateInitialCapacity(expectedMapSize);
    return new HashMap(initialCapacity, 0.75F);
  }
  
  public static <K, V> Map<K, V> createHashMapAdapter(int expectedMapSize) {
    int initialCapacity = calculateInitialCapacity(expectedMapSize);
    return new HashMapAdapter(initialCapacity, 0.75F);
  }
  
  public static <K, V> Map<K, V> createLinkedHashMap(int expectedMapSize) {
    int initialCapacity = calculateInitialCapacity(expectedMapSize);
    return new LinkedHashMap(initialCapacity, 0.75F);
  }
  
  public static <K, V> ConcurrentMap<K, V> createConcurrentHashMap(int expectedMapSize) { return new ConcurrentHashMap(expectedMapSize); }
  
  public static <V> Int2ObjectHashMap<V> createInt2ObjectHashMap(int expectedMapSize) {
    int initialCapacity = (int)(expectedMapSize / 0.6D) + 1;
    return new Int2ObjectHashMap(initialCapacity, 0.6D);
  }
  
  public static int calculateInitialCapacity(int expectedMapSize) { return (int)(expectedMapSize / 0.75F) + 1; }
  
  public static boolean isNullOrEmpty(Map map) { return (map == null || map.isEmpty()); }
  
  public static int toIntSize(long size) {
    assert size >= 0L : "Invalid size value: " + size;
    return (size > 2147483647L) ? Integer.MAX_VALUE : (int)size;
  }
}
