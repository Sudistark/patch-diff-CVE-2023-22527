package com.hazelcast.util.executor;

import com.hazelcast.logging.ILogger;
import com.hazelcast.util.Preconditions;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.lang.reflect.Method;
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.RunnableScheduledFuture;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadFactory;
import java.util.logging.Level;

public class LoggingScheduledExecutor extends ScheduledThreadPoolExecutor {
  boolean manualRemoveOnCancel;
  
  private final ILogger logger;
  
  public LoggingScheduledExecutor(ILogger logger, int corePoolSize, ThreadFactory threadFactory) { this(logger, corePoolSize, threadFactory, false); }
  
  public LoggingScheduledExecutor(ILogger logger, int corePoolSize, ThreadFactory threadFactory, boolean removeOnCancel) {
    super(corePoolSize, threadFactory);
    this.logger = (ILogger)Preconditions.checkNotNull(logger, "logger cannot be null");
    this.manualRemoveOnCancel = manualRemoveOnCancel(removeOnCancel);
  }
  
  public LoggingScheduledExecutor(ILogger logger, int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler) { this(logger, corePoolSize, threadFactory, false, handler); }
  
  public LoggingScheduledExecutor(ILogger logger, int corePoolSize, ThreadFactory threadFactory, boolean removeOnCancel, RejectedExecutionHandler handler) {
    super(corePoolSize, threadFactory, handler);
    this.logger = (ILogger)Preconditions.checkNotNull(logger, "logger cannot be null");
    this.manualRemoveOnCancel = manualRemoveOnCancel(removeOnCancel);
  }
  
  private boolean manualRemoveOnCancel(boolean removeOnCancel) {
    if (trySetRemoveOnCancelPolicy())
      return false; 
    return removeOnCancel;
  }
  
  @SuppressFBWarnings({"REC_CATCH_EXCEPTION"})
  private boolean trySetRemoveOnCancelPolicy() {
    try {
      Method method = ScheduledThreadPoolExecutor.class.getMethod("setRemoveOnCancelPolicy", new Class[] { boolean.class });
      method.invoke(this, new Object[] { Boolean.valueOf(true) });
      return true;
    } catch (Exception e) {
      return false;
    } 
  }
  
  protected <V> RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> task) {
    if (!this.manualRemoveOnCancel)
      return super.decorateTask(runnable, task); 
    return new RemoveOnCancelFuture(runnable, task, this);
  }
  
  protected <V> RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task) {
    if (!this.manualRemoveOnCancel)
      return super.decorateTask(callable, task); 
    return new RemoveOnCancelFuture(callable, task, this);
  }
  
  protected void afterExecute(Runnable runnable, Throwable throwable) {
    super.afterExecute(runnable, throwable);
    Level level = Level.FINE;
    if (throwable == null && runnable instanceof ScheduledFuture && ((ScheduledFuture)runnable).isDone())
      try {
        ((Future)runnable).get();
      } catch (CancellationException ce) {
        throwable = ce;
      } catch (ExecutionException ee) {
        level = Level.SEVERE;
        throwable = ee.getCause();
      } catch (InterruptedException ie) {
        throwable = ie;
        Thread.currentThread().interrupt();
      }  
    if (throwable instanceof java.util.concurrent.RejectedExecutionException && this.shutdownInitiated)
      level = Level.FINE; 
    if (throwable != null)
      this.logger.log(level, "Failed to execute " + runnable, throwable); 
  }
  
  public void notifyShutdownInitiated() { this.shutdownInitiated = true; }
}
