package com.hazelcast.util;

import com.hazelcast.instance.OutOfMemoryErrorDispatcher;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Constructor;
import javax.annotation.Nullable;

public final class ExceptionUtil {
  private static final String EXCEPTION_SEPARATOR = "------ submitted from ------";
  
  private static final String EXCEPTION_MESSAGE_SEPARATOR = "------ %MSG% ------";
  
  private static final ExceptionWrapper<RuntimeException> HAZELCAST_EXCEPTION_WRAPPER = new Object();
  
  public static String toString(Throwable cause) {
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    cause.printStackTrace(pw);
    return sw.toString();
  }
  
  public static RuntimeException peel(Throwable t) { return (RuntimeException)peel(t, null, null, HAZELCAST_EXCEPTION_WRAPPER); }
  
  public static <T extends Throwable> Throwable peel(Throwable t, Class<T> allowedType, String message) { return peel(t, allowedType, message, HAZELCAST_EXCEPTION_WRAPPER); }
  
  public static <T, W extends Throwable> Throwable peel(Throwable t, Class<T> allowedType, String message, ExceptionWrapper<W> exceptionWrapper) {
    if (t instanceof RuntimeException)
      return t; 
    if (t instanceof java.util.concurrent.ExecutionException || t instanceof java.lang.reflect.InvocationTargetException) {
      Throwable cause = t.getCause();
      if (cause != null)
        return peel(cause, allowedType, message, exceptionWrapper); 
      return exceptionWrapper.create(t, message);
    } 
    if (allowedType != null && allowedType.isAssignableFrom(t.getClass()))
      return t; 
    return exceptionWrapper.create(t, message);
  }
  
  public static RuntimeException rethrow(Throwable t) {
    rethrowIfError(t);
    throw peel(t);
  }
  
  public static RuntimeException rethrow(Throwable t, ExceptionWrapper<RuntimeException> exceptionWrapper) {
    rethrowIfError(t);
    throw (RuntimeException)peel(t, null, null, exceptionWrapper);
  }
  
  public static <T extends Throwable> RuntimeException rethrow(Throwable t, Class<T> allowedType) throws T {
    rethrowIfError(t);
    throw peel(t, allowedType, null);
  }
  
  public static <T extends Throwable> RuntimeException rethrowAllowedTypeFirst(Throwable t, Class<T> allowedType) throws T {
    rethrowIfError(t);
    if (allowedType.isAssignableFrom(t.getClass()))
      throw t; 
    throw peel(t);
  }
  
  private static void rethrowIfError(Throwable t) {
    if (t instanceof Error) {
      if (t instanceof OutOfMemoryError)
        OutOfMemoryErrorDispatcher.onOutOfMemory((OutOfMemoryError)t); 
      throw (Error)t;
    } 
  }
  
  public static RuntimeException rethrowAllowInterrupted(Throwable t) { return rethrow(t, InterruptedException.class); }
  
  public static <T> T sneakyThrow(Throwable t) {
    sneakyThrowInternal(t);
    return (T)t;
  }
  
  private static <T extends Throwable> void sneakyThrowInternal(Throwable t) throws T { throw t; }
  
  public static void fixAsyncStackTrace(Throwable asyncCause, StackTraceElement[] localSideStackTrace) {
    Throwable throwable = asyncCause;
    if (asyncCause instanceof java.util.concurrent.ExecutionException && throwable.getCause() != null)
      throwable = throwable.getCause(); 
    StackTraceElement[] remoteStackTrace = throwable.getStackTrace();
    StackTraceElement[] newStackTrace = new StackTraceElement[localSideStackTrace.length + remoteStackTrace.length];
    System.arraycopy(remoteStackTrace, 0, newStackTrace, 0, remoteStackTrace.length);
    newStackTrace[remoteStackTrace.length] = new StackTraceElement("------ submitted from ------", "", null, -1);
    System.arraycopy(localSideStackTrace, 1, newStackTrace, remoteStackTrace.length + 1, localSideStackTrace.length - 1);
    throwable.setStackTrace(newStackTrace);
  }
  
  public static void fixAsyncStackTrace(Throwable asyncCause, StackTraceElement[] localSideStackTrace, String localExceptionMessage) {
    Throwable throwable = asyncCause;
    if (asyncCause instanceof java.util.concurrent.ExecutionException && throwable.getCause() != null)
      throwable = throwable.getCause(); 
    String msg = "------ %MSG% ------".replace("%MSG%", localExceptionMessage);
    StackTraceElement[] remoteStackTrace = throwable.getStackTrace();
    StackTraceElement[] newStackTrace = new StackTraceElement[localSideStackTrace.length + remoteStackTrace.length + 1];
    System.arraycopy(remoteStackTrace, 0, newStackTrace, 0, remoteStackTrace.length);
    newStackTrace[remoteStackTrace.length] = new StackTraceElement("------ submitted from ------", "", null, -1);
    StackTraceElement nextElement = localSideStackTrace[1];
    newStackTrace[remoteStackTrace.length + 1] = new StackTraceElement(msg, nextElement.getMethodName(), nextElement
        .getFileName(), nextElement.getLineNumber());
    System.arraycopy(localSideStackTrace, 1, newStackTrace, remoteStackTrace.length + 2, localSideStackTrace.length - 1);
    throwable.setStackTrace(newStackTrace);
  }
  
  public static <T extends Throwable> T tryCreateExceptionWithMessageAndCause(Class<? extends Throwable> exceptionClass, String message, @Nullable Throwable cause) {
    try {
      Constructor<? extends Throwable> constructor = exceptionClass.getConstructor(new Class[] { String.class, Throwable.class });
      return (T)(Throwable)constructor.newInstance(new Object[] { message, cause });
    } catch (Throwable ignored) {
      EmptyStatement.ignore(ignored);
      try {
        Constructor<? extends Throwable> constructor = exceptionClass.getConstructor(new Class[] { Throwable.class });
        return (T)(Throwable)constructor.newInstance(new Object[] { cause });
      } catch (Throwable ignored) {
        EmptyStatement.ignore(ignored);
        try {
          Constructor<? extends Throwable> constructor = exceptionClass.getConstructor(new Class[] { String.class });
          T clone = (T)(Throwable)constructor.newInstance(new Object[] { message });
          clone.initCause(cause);
          return clone;
        } catch (Throwable ignored) {
          EmptyStatement.ignore(ignored);
          try {
            Constructor<? extends Throwable> constructor = exceptionClass.getConstructor(new Class[0]);
            T clone = (T)(Throwable)constructor.newInstance(new Object[0]);
            clone.initCause(cause);
            return clone;
          } catch (Throwable ignored) {
            Throwable ignored;
            EmptyStatement.ignore(ignored);
            return null;
          } 
        } 
      } 
    } 
  }
}
