package com.fasterxml.jackson.core.io.doubleparser;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.NavigableMap;

final class JavaBigDecimalFromByteArray extends AbstractNumberParser {
  public static final int MAX_INPUT_LENGTH = 1292782635;
  
  public static final int MANY_DIGITS_THRESHOLD = 32;
  
  private static final long MAX_EXPONENT_NUMBER = 2147483647L;
  
  private static final int MAX_DIGIT_COUNT = 1292782621;
  
  public BigDecimal parseBigDecimalString(byte[] str, int offset, int length) {
    try {
      long exponent;
      int digitCount, exponentIndicatorIndex;
      if (length >= 32)
        return parseBigDecimalStringWithManyDigits(str, offset, length); 
      long significand = 0L;
      int decimalPointIndex = -1;
      int endIndex = offset + length;
      int index = offset;
      byte ch = charAt(str, index, endIndex);
      boolean illegal = false;
      boolean isNegative = (ch == 45);
      if (isNegative || ch == 43) {
        ch = charAt(str, ++index, endIndex);
        if (ch == 0)
          throw new NumberFormatException("illegal syntax"); 
      } 
      int integerPartIndex = index;
      for (; index < endIndex; index++) {
        ch = str[index];
        if (FastDoubleSwar.isDigit(ch)) {
          significand = 10L * significand + ch - 48L;
        } else if (ch == 46) {
          illegal |= ((decimalPointIndex >= 0));
          decimalPointIndex = index;
          for (; index < endIndex - 4; index += 4) {
            digitCount = FastDoubleSwar.tryToParseFourDigits(str, index + 1);
            if (digitCount < 0)
              break; 
            significand = 10000L * significand + digitCount;
          } 
        } else {
          break;
        } 
      } 
      int significandEndIndex = index;
      if (decimalPointIndex < 0) {
        digitCount = significandEndIndex - integerPartIndex;
        decimalPointIndex = significandEndIndex;
        exponent = 0L;
      } else {
        digitCount = significandEndIndex - integerPartIndex - 1;
        exponent = (decimalPointIndex - significandEndIndex + 1);
      } 
      long expNumber = 0L;
      if ((ch | 0x20) == 101) {
        exponentIndicatorIndex = index;
        ch = charAt(str, ++index, endIndex);
        boolean isExponentNegative = (ch == 45);
        if (isExponentNegative || ch == 43)
          ch = charAt(str, ++index, endIndex); 
        illegal |= (!FastDoubleSwar.isDigit(ch));
        do {
          if (expNumber < 2147483647L)
            expNumber = 10L * expNumber + ch - 48L; 
          ch = charAt(str, ++index, endIndex);
        } while (FastDoubleSwar.isDigit(ch));
        if (isExponentNegative)
          expNumber = -expNumber; 
        exponent += expNumber;
      } else {
        exponentIndicatorIndex = endIndex;
      } 
      if (illegal || index < endIndex || digitCount == 0 || digitCount > 1292782621)
        throw new NumberFormatException("illegal syntax"); 
      if (exponent <= -2147483648L || exponent > 2147483647L)
        throw new NumberFormatException("value exceeds limits"); 
      if (digitCount <= 18)
        return (new BigDecimal(isNegative ? -significand : significand)).scaleByPowerOfTen((int)exponent); 
      return valueOfBigDecimalString(str, integerPartIndex, decimalPointIndex, decimalPointIndex + 1, exponentIndicatorIndex, isNegative, (int)exponent);
    } catch (ArithmeticException e) {
      NumberFormatException nfe = new NumberFormatException("value exceeds limits");
      nfe.initCause(e);
      throw nfe;
    } 
  }
  
  BigDecimal parseBigDecimalStringWithManyDigits(byte[] str, int offset, int length) {
    long exponent;
    int digitCount, exponentIndicatorIndex;
    if (length > 1292782635)
      throw new NumberFormatException("illegal syntax"); 
    int decimalPointIndex = -1;
    int nonZeroFractionalPartIndex = -1;
    int endIndex = offset + length;
    int index = offset;
    byte ch = charAt(str, index, endIndex);
    boolean illegal = false;
    boolean isNegative = (ch == 45);
    if (isNegative || ch == 43) {
      ch = charAt(str, ++index, endIndex);
      if (ch == 0)
        throw new NumberFormatException("illegal syntax"); 
    } 
    int integerPartIndex = index;
    while (index < endIndex - 8 && FastDoubleSwar.isEightZeroes(str, index))
      index += 8; 
    while (index < endIndex && str[index] == 48)
      index++; 
    int nonZeroIntegerPartIndex = index;
    while (index < endIndex - 8 && FastDoubleSwar.isEightDigits(str, index))
      index += 8; 
    while (index < endIndex && FastDoubleSwar.isDigit(ch = str[index]))
      index++; 
    if (ch == 46) {
      decimalPointIndex = index++;
      while (index < endIndex - 8 && FastDoubleSwar.isEightZeroes(str, index))
        index += 8; 
      while (index < endIndex && str[index] == 48)
        index++; 
      nonZeroFractionalPartIndex = index;
      while (index < endIndex - 8 && FastDoubleSwar.isEightDigits(str, index))
        index += 8; 
      while (index < endIndex && FastDoubleSwar.isDigit(ch = str[index]))
        index++; 
    } 
    int significandEndIndex = index;
    if (decimalPointIndex < 0) {
      digitCount = significandEndIndex - nonZeroIntegerPartIndex;
      decimalPointIndex = significandEndIndex;
      nonZeroFractionalPartIndex = significandEndIndex;
      exponent = 0L;
    } else {
      digitCount = (nonZeroIntegerPartIndex == decimalPointIndex) ? (significandEndIndex - nonZeroFractionalPartIndex) : (significandEndIndex - nonZeroIntegerPartIndex - 1);
      exponent = (decimalPointIndex - significandEndIndex + 1);
    } 
    long expNumber = 0L;
    if ((ch | 0x20) == 101) {
      exponentIndicatorIndex = index;
      ch = charAt(str, ++index, endIndex);
      boolean isExponentNegative = (ch == 45);
      if (isExponentNegative || ch == 43)
        ch = charAt(str, ++index, endIndex); 
      illegal = !FastDoubleSwar.isDigit(ch);
      do {
        if (expNumber < 2147483647L)
          expNumber = 10L * expNumber + ch - 48L; 
        ch = charAt(str, ++index, endIndex);
      } while (FastDoubleSwar.isDigit(ch));
      if (isExponentNegative)
        expNumber = -expNumber; 
      exponent += expNumber;
    } else {
      exponentIndicatorIndex = endIndex;
    } 
    if (illegal || index < endIndex)
      throw new NumberFormatException("illegal syntax"); 
    if (exponentIndicatorIndex - integerPartIndex == 0)
      throw new NumberFormatException("illegal syntax"); 
    if (exponent < -2147483648L || exponent > 2147483647L || digitCount > 1292782621)
      throw new NumberFormatException("value exceeds limits"); 
    return valueOfBigDecimalString(str, nonZeroIntegerPartIndex, decimalPointIndex, nonZeroFractionalPartIndex, exponentIndicatorIndex, isNegative, (int)exponent);
  }
  
  private BigDecimal valueOfBigDecimalString(byte[] str, int integerPartIndex, int decimalPointIndex, int nonZeroFractionalPartIndex, int exponentIndicatorIndex, boolean isNegative, int exponent) {
    BigInteger integerPart, significand;
    int fractionDigitsCount = exponentIndicatorIndex - decimalPointIndex - 1;
    int nonZeroFractionDigitsCount = exponentIndicatorIndex - nonZeroFractionalPartIndex;
    int integerDigitsCount = decimalPointIndex - integerPartIndex;
    NavigableMap<Integer, BigInteger> powersOfTen = null;
    if (integerDigitsCount > 0) {
      if (integerDigitsCount > 400) {
        powersOfTen = FastIntegerMath.createPowersOfTenFloor16Map();
        FastIntegerMath.fillPowersOfNFloor16Recursive(powersOfTen, integerPartIndex, decimalPointIndex);
        integerPart = ParseDigitsTaskByteArray.parseDigitsRecursive(str, integerPartIndex, decimalPointIndex, powersOfTen);
      } else {
        integerPart = ParseDigitsTaskByteArray.parseDigitsRecursive(str, integerPartIndex, decimalPointIndex, null);
      } 
    } else {
      integerPart = BigInteger.ZERO;
    } 
    if (fractionDigitsCount > 0) {
      BigInteger fractionalPart;
      if (nonZeroFractionDigitsCount > 400) {
        if (powersOfTen == null)
          powersOfTen = FastIntegerMath.createPowersOfTenFloor16Map(); 
        FastIntegerMath.fillPowersOfNFloor16Recursive(powersOfTen, nonZeroFractionalPartIndex, exponentIndicatorIndex);
        fractionalPart = ParseDigitsTaskByteArray.parseDigitsRecursive(str, nonZeroFractionalPartIndex, exponentIndicatorIndex, powersOfTen);
      } else {
        fractionalPart = ParseDigitsTaskByteArray.parseDigitsRecursive(str, nonZeroFractionalPartIndex, exponentIndicatorIndex, null);
      } 
      if (integerPart.signum() == 0) {
        significand = fractionalPart;
      } else {
        BigInteger integerFactor = FastIntegerMath.computePowerOfTen(powersOfTen, fractionDigitsCount);
        significand = FftMultiplier.multiply(integerPart, integerFactor).add(fractionalPart);
      } 
    } else {
      significand = integerPart;
    } 
    return new BigDecimal(isNegative ? significand.negate() : significand, -exponent);
  }
}
