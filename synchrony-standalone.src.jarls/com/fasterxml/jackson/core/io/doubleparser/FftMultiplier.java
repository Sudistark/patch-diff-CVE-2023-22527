package com.fasterxml.jackson.core.io.doubleparser;

import java.math.BigInteger;

class FftMultiplier {
  public static final double COS_0_25 = Math.cos(0.7853981633974483D);
  
  public static final double SIN_0_25 = Math.sin(0.7853981633974483D);
  
  private static final int FFT_THRESHOLD = 33220;
  
  private static final int MAX_MAG_LENGTH = 67108864;
  
  private static final int ROOTS3_CACHE_SIZE = 20;
  
  private static final int ROOTS_CACHE2_SIZE = 20;
  
  private static final int TOOM_COOK_THRESHOLD = 1920;
  
  static int bitsPerFftPoint(int bitLen) {
    if (bitLen <= 9728)
      return 19; 
    if (bitLen <= 18432)
      return 18; 
    if (bitLen <= 69632)
      return 17; 
    if (bitLen <= 262144)
      return 16; 
    if (bitLen <= 983040)
      return 15; 
    if (bitLen <= 3670016)
      return 14; 
    if (bitLen <= 13631488)
      return 13; 
    if (bitLen <= 25165824)
      return 12; 
    if (bitLen <= 92274688)
      return 11; 
    if (bitLen <= 335544320)
      return 10; 
    if (bitLen <= 1207959552)
      return 9; 
    return 8;
  }
  
  private static ComplexVector calculateRootsOfUnity(int n) {
    if (n == 1) {
      ComplexVector v = new ComplexVector(1);
      v.real(0, 1.0D);
      v.imag(0, 0.0D);
      return v;
    } 
    ComplexVector roots = new ComplexVector(n);
    roots.set(0, 1.0D, 0.0D);
    double cos = COS_0_25;
    double sin = SIN_0_25;
    roots.set(n / 2, cos, sin);
    double angleTerm = 1.5707963267948966D / n;
    for (int i = 1; i < n / 2; i++) {
      double angle = angleTerm * i;
      cos = Math.cos(angle);
      sin = Math.sin(angle);
      roots.set(i, cos, sin);
      roots.set(n - i, sin, cos);
    } 
    return roots;
  }
  
  private static void fft(ComplexVector a, ComplexVector[] roots) {
    int n = ComplexVector.access$000(a);
    int logN = 31 - Integer.numberOfLeadingZeros(n);
    MutableComplex a0 = new MutableComplex();
    MutableComplex a1 = new MutableComplex();
    MutableComplex a2 = new MutableComplex();
    MutableComplex a3 = new MutableComplex();
    MutableComplex omega1 = new MutableComplex();
    MutableComplex omega2 = new MutableComplex();
    int s = logN;
    for (; s >= 2; s -= 2) {
      ComplexVector rootsS = roots[s - 2];
      int m = 1 << s;
      int i;
      for (i = 0; i < n; i += m) {
        for (int j = 0; j < m / 4; j++) {
          omega1.set(rootsS, j);
          omega1.squareInto(omega2);
          int idx0 = i + j;
          int idx1 = i + j + m / 4;
          int idx2 = i + j + m / 2;
          int idx3 = i + j + m * 3 / 4;
          a.addInto(idx0, a, idx1, a0);
          a0.add(a, idx2);
          a0.add(a, idx3);
          a.subtractTimesIInto(idx0, a, idx1, a1);
          a1.subtract(a, idx2);
          a1.addTimesI(a, idx3);
          a1.multiplyConjugate(omega1);
          a.subtractInto(idx0, a, idx1, a2);
          a2.add(a, idx2);
          a2.subtract(a, idx3);
          a2.multiplyConjugate(omega2);
          a.addTimesIInto(idx0, a, idx1, a3);
          a3.subtract(a, idx2);
          a3.subtractTimesI(a, idx3);
          a3.multiply(omega1);
          a0.copyInto(a, idx0);
          a1.copyInto(a, idx1);
          a2.copyInto(a, idx2);
          a3.copyInto(a, idx3);
        } 
      } 
    } 
    if (s > 0)
      for (int i = 0; i < n; i += 2) {
        a.copyInto(i, a0);
        a.copyInto(i + 1, a1);
        a.add(i, a1);
        a0.subtractInto(a1, a, i + 1);
      }  
  }
  
  private static void fft3(ComplexVector a0, ComplexVector a1, ComplexVector a2, int sign, double scale) {
    double omegaImag = sign * -0.5D * Math.sqrt(3.0D);
    for (int i = 0; i < ComplexVector.access$000(a0); i++) {
      double a0Real = a0.real(i) + a1.real(i) + a2.real(i);
      double a0Imag = a0.imag(i) + a1.imag(i) + a2.imag(i);
      double c = omegaImag * (a2.imag(i) - a1.imag(i));
      double d = omegaImag * (a1.real(i) - a2.real(i));
      double e = 0.5D * (a1.real(i) + a2.real(i));
      double f = 0.5D * (a1.imag(i) + a2.imag(i));
      double a1Real = a0.real(i) - e + c;
      double a1Imag = a0.imag(i) + d - f;
      double a2Real = a0.real(i) - e - c;
      double a2Imag = a0.imag(i) - d - f;
      a0.real(i, a0Real * scale);
      a0.imag(i, a0Imag * scale);
      a1.real(i, a1Real * scale);
      a1.imag(i, a1Imag * scale);
      a2.real(i, a2Real * scale);
      a2.imag(i, a2Imag * scale);
    } 
  }
  
  private static void fftMixedRadix(ComplexVector a, ComplexVector[] roots2, ComplexVector roots3) {
    int oneThird = ComplexVector.access$000(a) / 3;
    ComplexVector a0 = new ComplexVector(a, 0, oneThird);
    ComplexVector a1 = new ComplexVector(a, oneThird, oneThird * 2);
    ComplexVector a2 = new ComplexVector(a, oneThird * 2, ComplexVector.access$000(a));
    fft3(a0, a1, a2, 1, 1.0D);
    MutableComplex omega = new MutableComplex();
    for (int i = 0; i < ComplexVector.access$000(a) / 4; i++) {
      omega.set(roots3, i);
      a1.multiplyConjugate(i, omega);
      a2.multiplyConjugate(i, omega);
      a2.multiplyConjugate(i, omega);
    } 
    for (int i = ComplexVector.access$000(a) / 4; i < oneThird; i++) {
      omega.set(roots3, i - ComplexVector.access$000(a) / 4);
      a1.multiplyConjugateTimesI(i, omega);
      a2.multiplyConjugateTimesI(i, omega);
      a2.multiplyConjugateTimesI(i, omega);
    } 
    fft(a0, roots2);
    fft(a1, roots2);
    fft(a2, roots2);
  }
  
  static BigInteger fromFftVector(ComplexVector fftVec, int signum, int bitsPerFftPoint) {
    assert bitsPerFftPoint <= 25 : bitsPerFftPoint + " does not fit into an int with slack";
    int fftLen = (int)Math.min(ComplexVector.access$000(fftVec), 2147483648L / bitsPerFftPoint + 1L);
    int magLen = (int)(8L * (fftLen * bitsPerFftPoint + 31L) / 32L);
    byte[] mag = new byte[magLen];
    int base = 1 << bitsPerFftPoint;
    int bitMask = base - 1;
    int bitPadding = 32 - bitsPerFftPoint;
    long carry = 0L;
    int bitLength = mag.length * 8;
    int bitIdx = bitLength - bitsPerFftPoint;
    int magComponent = 0;
    int prevIdx = Math.min(Math.max(0, bitIdx >> 3), mag.length - 4);
    for (int part = 0; part <= 1; part++) {
      for (int fftIdx = 0; fftIdx < fftLen; fftIdx++) {
        long fftElem = Math.round(fftVec.part(fftIdx, part)) + carry;
        carry = fftElem >> bitsPerFftPoint;
        int idx = Math.min(Math.max(0, bitIdx >> 3), mag.length - 4);
        magComponent >>>= prevIdx - idx << 3;
        int shift = bitPadding - bitIdx + (idx << 3);
        magComponent = (int)(magComponent | (fftElem & bitMask) << shift);
        FastDoubleSwar.writeIntBE(mag, idx, magComponent);
        prevIdx = idx;
        bitIdx -= bitsPerFftPoint;
      } 
    } 
    return new BigInteger(signum, mag);
  }
  
  private static ComplexVector[] getRootsOfUnity2(int logN) {
    ComplexVector[] arrayOfComplexVector = new ComplexVector[logN + 1];
    for (int i = logN; i >= 0; i -= 2) {
      if (i < 20) {
        if (ROOTS2_CACHE[i] == null)
          ROOTS2_CACHE[i] = calculateRootsOfUnity(1 << i); 
        arrayOfComplexVector[i] = ROOTS2_CACHE[i];
      } else {
        arrayOfComplexVector[i] = calculateRootsOfUnity(1 << i);
      } 
    } 
    return arrayOfComplexVector;
  }
  
  private static ComplexVector getRootsOfUnity3(int logN) {
    if (logN < 20) {
      if (ROOTS3_CACHE[logN] == null)
        ROOTS3_CACHE[logN] = calculateRootsOfUnity(3 << logN); 
      return ROOTS3_CACHE[logN];
    } 
    return calculateRootsOfUnity(3 << logN);
  }
  
  private static void ifft(ComplexVector a, ComplexVector[] roots) {
    int n = ComplexVector.access$000(a);
    int logN = 31 - Integer.numberOfLeadingZeros(n);
    MutableComplex a0 = new MutableComplex();
    MutableComplex a1 = new MutableComplex();
    MutableComplex a2 = new MutableComplex();
    MutableComplex a3 = new MutableComplex();
    MutableComplex b0 = new MutableComplex();
    MutableComplex b1 = new MutableComplex();
    MutableComplex b2 = new MutableComplex();
    MutableComplex b3 = new MutableComplex();
    int s = 1;
    if (logN % 2 != 0) {
      for (int i = 0; i < n; i += 2) {
        a.copyInto(i + 1, a2);
        a.copyInto(i, a0);
        a.add(i, a2);
        a0.subtractInto(a2, a, i + 1);
      } 
      s++;
    } 
    MutableComplex omega1 = new MutableComplex();
    MutableComplex omega2 = new MutableComplex();
    for (; s <= logN; s += 2) {
      ComplexVector rootsS = roots[s - 1];
      int m = 1 << s + 1;
      int i;
      for (i = 0; i < n; i += m) {
        for (int j = 0; j < m / 4; j++) {
          omega1.set(rootsS, j);
          omega1.squareInto(omega2);
          int idx0 = i + j;
          int idx1 = i + j + m / 4;
          int idx2 = i + j + m / 2;
          int idx3 = i + j + m * 3 / 4;
          a.copyInto(idx0, a0);
          a.multiplyInto(idx1, omega1, a1);
          a.multiplyInto(idx2, omega2, a2);
          a.multiplyConjugateInto(idx3, omega1, a3);
          a0.addInto(a1, b0);
          b0.add(a2);
          b0.add(a3);
          a0.addTimesIInto(a1, b1);
          b1.subtract(a2);
          b1.subtractTimesI(a3);
          a0.subtractInto(a1, b2);
          b2.add(a2);
          b2.subtract(a3);
          a0.subtractTimesIInto(a1, b3);
          b3.subtract(a2);
          b3.addTimesI(a3);
          b0.copyInto(a, idx0);
          b1.copyInto(a, idx1);
          b2.copyInto(a, idx2);
          b3.copyInto(a, idx3);
        } 
      } 
    } 
    for (int i = 0; i < n; i++)
      a.timesTwoToThe(i, -logN); 
  }
  
  private static void ifftMixedRadix(ComplexVector a, ComplexVector[] roots2, ComplexVector roots3) {
    int oneThird = ComplexVector.access$000(a) / 3;
    ComplexVector a0 = new ComplexVector(a, 0, oneThird);
    ComplexVector a1 = new ComplexVector(a, oneThird, oneThird * 2);
    ComplexVector a2 = new ComplexVector(a, oneThird * 2, ComplexVector.access$000(a));
    ifft(a0, roots2);
    ifft(a1, roots2);
    ifft(a2, roots2);
    MutableComplex omega = new MutableComplex();
    for (int i = 0; i < ComplexVector.access$000(a) / 4; i++) {
      omega.set(roots3, i);
      a1.multiply(i, omega);
      a2.multiply(i, omega);
      a2.multiply(i, omega);
    } 
    for (int i = ComplexVector.access$000(a) / 4; i < oneThird; i++) {
      omega.set(roots3, i - ComplexVector.access$000(a) / 4);
      a1.multiplyByIAnd(i, omega);
      a2.multiplyByIAnd(i, omega);
      a2.multiplyByIAnd(i, omega);
    } 
    fft3(a0, a1, a2, -1, 0.3333333333333333D);
  }
  
  static BigInteger multiply(BigInteger a, BigInteger b) {
    if (b.signum() == 0 || a.signum() == 0)
      return BigInteger.ZERO; 
    if (b == a)
      return square(b); 
    int xlen = a.bitLength();
    int ylen = b.bitLength();
    if (xlen + ylen > 2147483648L)
      throw new ArithmeticException("BigInteger would overflow supported range"); 
    if (xlen > 1920 && ylen > 1920 && (xlen > 33220 || ylen > 33220))
      return multiplyFft(a, b); 
    return a.multiply(b);
  }
  
  static BigInteger multiplyFft(BigInteger a, BigInteger b) {
    int signum = a.signum() * b.signum();
    byte[] aMag = ((a.signum() < 0) ? a.negate() : a).toByteArray();
    byte[] bMag = ((b.signum() < 0) ? b.negate() : b).toByteArray();
    int bitLen = Math.max(aMag.length, bMag.length) * 8;
    int bitsPerPoint = bitsPerFftPoint(bitLen);
    int fftLen = (bitLen + bitsPerPoint - 1) / bitsPerPoint + 1;
    int logFFTLen = 32 - Integer.numberOfLeadingZeros(fftLen - 1);
    int fftLen2 = 1 << logFFTLen;
    int fftLen3 = fftLen2 * 3 / 4;
    if (fftLen < fftLen3 && logFFTLen > 3) {
      ComplexVector[] arrayOfComplexVector1 = getRootsOfUnity2(logFFTLen - 2);
      ComplexVector weights = getRootsOfUnity3(logFFTLen - 2);
      ComplexVector twiddles = getRootsOfUnity3(logFFTLen - 4);
      ComplexVector aVec = toFftVector(aMag, fftLen3, bitsPerPoint);
      aVec.applyWeights(weights);
      fftMixedRadix(aVec, arrayOfComplexVector1, twiddles);
      ComplexVector bVec = toFftVector(bMag, fftLen3, bitsPerPoint);
      bVec.applyWeights(weights);
      fftMixedRadix(bVec, arrayOfComplexVector1, twiddles);
      aVec.multiplyPointwise(bVec);
      ifftMixedRadix(aVec, arrayOfComplexVector1, twiddles);
      aVec.applyInverseWeights(weights);
      return fromFftVector(aVec, signum, bitsPerPoint);
    } 
    ComplexVector[] arrayOfComplexVector = getRootsOfUnity2(logFFTLen);
    ComplexVector aVec = toFftVector(aMag, fftLen2, bitsPerPoint);
    aVec.applyWeights(arrayOfComplexVector[logFFTLen]);
    fft(aVec, arrayOfComplexVector);
    ComplexVector bVec = toFftVector(bMag, fftLen2, bitsPerPoint);
    bVec.applyWeights(arrayOfComplexVector[logFFTLen]);
    fft(bVec, arrayOfComplexVector);
    aVec.multiplyPointwise(bVec);
    ifft(aVec, arrayOfComplexVector);
    aVec.applyInverseWeights(arrayOfComplexVector[logFFTLen]);
    return fromFftVector(aVec, signum, bitsPerPoint);
  }
  
  static BigInteger square(BigInteger a) {
    if (a.signum() == 0)
      return BigInteger.ZERO; 
    return (a.bitLength() < 33220) ? a.multiply(a) : squareFft(a);
  }
  
  static BigInteger squareFft(BigInteger a) {
    byte[] mag = a.toByteArray();
    int bitLen = mag.length * 8;
    int bitsPerPoint = bitsPerFftPoint(bitLen);
    int fftLen = (bitLen + bitsPerPoint - 1) / bitsPerPoint + 1;
    int logFFTLen = 32 - Integer.numberOfLeadingZeros(fftLen - 1);
    int fftLen2 = 1 << logFFTLen;
    int fftLen3 = fftLen2 * 3 / 4;
    if (fftLen < fftLen3) {
      fftLen = fftLen3;
      ComplexVector vec = toFftVector(mag, fftLen, bitsPerPoint);
      ComplexVector[] arrayOfComplexVector1 = getRootsOfUnity2(logFFTLen - 2);
      ComplexVector weights = getRootsOfUnity3(logFFTLen - 2);
      ComplexVector twiddles = getRootsOfUnity3(logFFTLen - 4);
      vec.applyWeights(weights);
      fftMixedRadix(vec, arrayOfComplexVector1, twiddles);
      vec.squarePointwise();
      ifftMixedRadix(vec, arrayOfComplexVector1, twiddles);
      vec.applyInverseWeights(weights);
      return fromFftVector(vec, 1, bitsPerPoint);
    } 
    fftLen = fftLen2;
    ComplexVector vec = toFftVector(mag, fftLen, bitsPerPoint);
    ComplexVector[] arrayOfComplexVector = getRootsOfUnity2(logFFTLen);
    vec.applyWeights(arrayOfComplexVector[logFFTLen]);
    fft(vec, arrayOfComplexVector);
    vec.squarePointwise();
    ifft(vec, arrayOfComplexVector);
    vec.applyInverseWeights(arrayOfComplexVector[logFFTLen]);
    return fromFftVector(vec, 1, bitsPerPoint);
  }
  
  static ComplexVector toFftVector(byte[] mag, int fftLen, int bitsPerFftPoint) {
    assert bitsPerFftPoint <= 25 : bitsPerFftPoint + " does not fit into an int with slack";
    ComplexVector fftVec = new ComplexVector(fftLen);
    if (mag.length < 4) {
      byte[] paddedMag = new byte[4];
      System.arraycopy(mag, 0, paddedMag, 4 - mag.length, mag.length);
      mag = paddedMag;
    } 
    int base = 1 << bitsPerFftPoint;
    int halfBase = base / 2;
    int bitMask = base - 1;
    int bitPadding = 32 - bitsPerFftPoint;
    int bitLength = mag.length * 8;
    int carry = 0;
    int fftIdx = 0;
    int bitIdx;
    for (bitIdx = bitLength - bitsPerFftPoint; bitIdx > -bitsPerFftPoint; bitIdx -= bitsPerFftPoint) {
      int idx = Math.min(Math.max(0, bitIdx >> 3), mag.length - 4);
      int shift = bitPadding - bitIdx + (idx << 3);
      int fftPoint = FastDoubleSwar.readIntBE(mag, idx) >>> shift & bitMask;
      fftPoint += carry;
      carry = halfBase - fftPoint >>> 31;
      fftPoint -= (base & -carry);
      fftVec.real(fftIdx, fftPoint);
      fftIdx++;
    } 
    if (carry > 0)
      fftVec.real(fftIdx, carry); 
    return fftVec;
  }
}
