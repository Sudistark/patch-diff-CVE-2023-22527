package com.fasterxml.jackson.core;

import com.fasterxml.jackson.core.exc.StreamConstraintsException;
import java.io.Serializable;

public class StreamReadConstraints implements Serializable {
  private static final long serialVersionUID = 1L;
  
  public static final int DEFAULT_MAX_DEPTH = 1000;
  
  public static final int DEFAULT_MAX_NUM_LEN = 1000;
  
  public static final int DEFAULT_MAX_STRING_LEN = 20000000;
  
  private static final int MAX_BIGINT_SCALE_MAGNITUDE = 100000;
  
  protected final int _maxNestingDepth;
  
  protected final int _maxNumLen;
  
  protected final int _maxStringLen;
  
  private static StreamReadConstraints DEFAULT = new StreamReadConstraints(1000, 1000, 20000000);
  
  public static void overrideDefaultStreamReadConstraints(StreamReadConstraints streamReadConstraints) {
    if (streamReadConstraints == null) {
      DEFAULT = new StreamReadConstraints(1000, 1000, 20000000);
    } else {
      DEFAULT = streamReadConstraints;
    } 
  }
  
  protected StreamReadConstraints(int maxNestingDepth, int maxNumLen, int maxStringLen) {
    this._maxNestingDepth = maxNestingDepth;
    this._maxNumLen = maxNumLen;
    this._maxStringLen = maxStringLen;
  }
  
  public static Builder builder() { return new Builder(); }
  
  public static StreamReadConstraints defaults() { return DEFAULT; }
  
  public Builder rebuild() { return new Builder(this); }
  
  public int getMaxNestingDepth() { return this._maxNestingDepth; }
  
  public int getMaxNumberLength() { return this._maxNumLen; }
  
  public int getMaxStringLength() { return this._maxStringLen; }
  
  public void validateNestingDepth(int depth) throws StreamConstraintsException {
    if (depth > this._maxNestingDepth)
      throw new StreamConstraintsException(String.format("Depth (%d) exceeds the maximum allowed nesting depth (%d)", new Object[] { Integer.valueOf(depth), Integer.valueOf(this._maxNestingDepth) })); 
  }
  
  public void validateFPLength(int length) throws StreamConstraintsException {
    if (length > this._maxNumLen)
      throw new StreamConstraintsException(String.format("Number length (%d) exceeds the maximum length (%d)", new Object[] { Integer.valueOf(length), Integer.valueOf(this._maxNumLen) })); 
  }
  
  public void validateIntegerLength(int length) throws StreamConstraintsException {
    if (length > this._maxNumLen)
      throw new StreamConstraintsException(String.format("Number length (%d) exceeds the maximum length (%d)", new Object[] { Integer.valueOf(length), Integer.valueOf(this._maxNumLen) })); 
  }
  
  public void validateStringLength(int length) throws StreamConstraintsException {
    if (length > this._maxStringLen)
      throw new StreamConstraintsException(String.format("String length (%d) exceeds the maximum length (%d)", new Object[] { Integer.valueOf(length), Integer.valueOf(this._maxStringLen) })); 
  }
  
  public void validateBigIntegerScale(int scale) throws StreamConstraintsException {
    int absScale = Math.abs(scale);
    int limit = 100000;
    if (absScale > 100000)
      throw new StreamConstraintsException(String.format("BigDecimal scale (%d) magnitude exceeds maximum allowed (%d)", new Object[] { Integer.valueOf(scale), Integer.valueOf(100000) })); 
  }
}
