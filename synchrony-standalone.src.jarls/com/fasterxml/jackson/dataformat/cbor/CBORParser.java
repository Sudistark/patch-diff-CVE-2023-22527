package com.fasterxml.jackson.dataformat.cbor;

import com.fasterxml.jackson.core.Base64Variant;
import com.fasterxml.jackson.core.JsonLocation;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonStreamContext;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.core.ObjectCodec;
import com.fasterxml.jackson.core.SerializableString;
import com.fasterxml.jackson.core.StreamReadCapability;
import com.fasterxml.jackson.core.StreamReadConstraints;
import com.fasterxml.jackson.core.StreamReadFeature;
import com.fasterxml.jackson.core.Version;
import com.fasterxml.jackson.core.base.ParserMinimalBase;
import com.fasterxml.jackson.core.io.IOContext;
import com.fasterxml.jackson.core.io.NumberInput;
import com.fasterxml.jackson.core.json.DupDetector;
import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;
import com.fasterxml.jackson.core.util.ByteArrayBuilder;
import com.fasterxml.jackson.core.util.JacksonFeatureSet;
import com.fasterxml.jackson.core.util.TextBuffer;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Writer;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;

public class CBORParser extends ParserMinimalBase {
  private static final Charset UTF8 = StandardCharsets.UTF_8;
  
  private static final int[] UTF8_UNIT_CODES = CBORConstants.sUtf8UnitLengths;
  
  private static final double MATH_POW_2_10 = Math.pow(2.0D, 10.0D);
  
  private static final double MATH_POW_2_NEG14 = Math.pow(2.0D, -14.0D);
  
  protected static final int LONGEST_NON_CHUNKED_BINARY = 250000;
  
  protected static final JacksonFeatureSet<StreamReadCapability> CBOR_READ_CAPABILITIES = DEFAULT_READ_CAPABILITIES
    .with(StreamReadCapability.EXACT_FLOATS);
  
  protected ObjectCodec _objectCodec;
  
  protected final IOContext _ioContext;
  
  protected boolean _closed;
  
  protected int _inputPtr = 0;
  
  protected int _inputEnd = 0;
  
  protected long _currInputProcessed = 0L;
  
  protected int _currInputRow = 1;
  
  protected int _currInputRowStart = 0;
  
  protected long _tokenInputTotal = 0L;
  
  protected int _tokenInputRow = 1;
  
  protected int _tokenInputCol = 0;
  
  protected CBORReadContext _streamReadContext;
  
  protected final TextBuffer _textBuffer;
  
  protected char[] _nameCopyBuffer = null;
  
  protected boolean _nameCopied = false;
  
  protected ByteArrayBuilder _byteArrayBuilder = null;
  
  protected byte[] _binaryValue;
  
  private int _chunkLeft;
  
  private int _chunkEnd;
  
  protected TagList _tagValues = new TagList();
  
  protected boolean _tokenIncomplete = false;
  
  protected int _typeByte;
  
  protected StringRefListStack _stringRefs = new StringRefListStack();
  
  protected String _sharedString;
  
  protected InputStream _inputStream;
  
  protected byte[] _inputBuffer;
  
  protected boolean _bufferRecyclable;
  
  protected final ByteQuadsCanonicalizer _symbols;
  
  protected int[] _quadBuffer = NO_INTS;
  
  protected int _quad1;
  
  protected int _quad2;
  
  protected int _quad3;
  
  protected final boolean _symbolsCanonical;
  
  static final BigInteger BI_MIN_INT = BigInteger.valueOf(-2147483648L);
  
  static final BigInteger BI_MAX_INT = BigInteger.valueOf(2147483647L);
  
  static final BigInteger BI_MIN_LONG = BigInteger.valueOf(Float.MIN_VALUE);
  
  static final BigInteger BI_MAX_LONG = BigInteger.valueOf(Float.MAX_VALUE);
  
  static final BigDecimal BD_MIN_LONG = new BigDecimal(BI_MIN_LONG);
  
  static final BigDecimal BD_MAX_LONG = new BigDecimal(BI_MAX_LONG);
  
  static final BigDecimal BD_MIN_INT = new BigDecimal(BI_MIN_INT);
  
  static final BigDecimal BD_MAX_INT = new BigDecimal(BI_MAX_INT);
  
  protected int _numTypesValid = 0;
  
  protected int _numberInt;
  
  protected long _numberLong;
  
  protected float _numberFloat;
  
  protected double _numberDouble;
  
  protected BigInteger _numberBigInt;
  
  protected BigDecimal _numberBigDecimal;
  
  public CBORParser(IOContext ctxt, int parserFeatures, int cborFeatures, ObjectCodec codec, ByteQuadsCanonicalizer sym, InputStream in, byte[] inputBuffer, int start, int end, boolean bufferRecyclable) {
    super(parserFeatures);
    this._ioContext = ctxt;
    this._objectCodec = codec;
    this._symbols = sym;
    this._symbolsCanonical = sym.isCanonicalizing();
    this._inputStream = in;
    this._inputBuffer = inputBuffer;
    this._inputPtr = start;
    this._inputEnd = end;
    this._bufferRecyclable = bufferRecyclable;
    this._textBuffer = ctxt.constructReadConstrainedTextBuffer();
    DupDetector dups = JsonParser.Feature.STRICT_DUPLICATE_DETECTION.enabledIn(parserFeatures) ? DupDetector.rootDetector(this) : null;
    this._streamReadContext = CBORReadContext.createRootContext(dups);
    this._tokenInputRow = -1;
    this._tokenInputCol = -1;
  }
  
  public StreamReadConstraints streamReadConstraints() { return this._ioContext.streamReadConstraints(); }
  
  public ObjectCodec getCodec() { return this._objectCodec; }
  
  public void setCodec(ObjectCodec c) { this._objectCodec = c; }
  
  public Version version() { return PackageVersion.VERSION; }
  
  public int getFormatFeatures() { return 0; }
  
  public JacksonFeatureSet<StreamReadCapability> getReadCapabilities() { return CBOR_READ_CAPABILITIES; }
  
  public int getCurrentTag() { return this._tagValues.getFirstTag(); }
  
  public TagList getCurrentTags() { return this._tagValues; }
  
  public int releaseBuffered(OutputStream out) throws IOException {
    int count = this._inputEnd - this._inputPtr;
    if (count < 1)
      return 0; 
    int origPtr = this._inputPtr;
    out.write(this._inputBuffer, origPtr, count);
    return count;
  }
  
  public Object getInputSource() { return this._inputStream; }
  
  public JsonLocation getTokenLocation() { return new JsonLocation(this._ioContext.contentReference(), this._tokenInputTotal, -1L, -1, (int)this._tokenInputTotal); }
  
  public JsonLocation getCurrentLocation() {
    long offset = this._currInputProcessed + this._inputPtr;
    return new JsonLocation(this._ioContext.contentReference(), offset, -1L, -1, (int)offset);
  }
  
  public String getCurrentName() throws IOException {
    if (this._currToken == JsonToken.START_OBJECT || this._currToken == JsonToken.START_ARRAY) {
      CBORReadContext parent = this._streamReadContext.getParent();
      return parent.getCurrentName();
    } 
    return this._streamReadContext.getCurrentName();
  }
  
  public void overrideCurrentName(String name) {
    CBORReadContext ctxt = this._streamReadContext;
    if (this._currToken == JsonToken.START_OBJECT || this._currToken == JsonToken.START_ARRAY)
      ctxt = ctxt.getParent(); 
    try {
      ctxt.setCurrentName(name);
    } catch (IOException e) {
      throw new IllegalStateException(e);
    } 
  }
  
  public void close() throws IOException {
    if (!this._closed) {
      this._closed = true;
      this._symbols.release();
      try {
        _closeInput();
      } finally {
        _releaseBuffers();
      } 
    } 
  }
  
  public boolean isClosed() { return this._closed; }
  
  public CBORReadContext getParsingContext() { return this._streamReadContext; }
  
  public boolean hasTextCharacters() {
    if (this._currToken == JsonToken.VALUE_STRING)
      return (this._sharedString != null || this._textBuffer.hasTextAsCharacters()); 
    if (this._currToken == JsonToken.FIELD_NAME)
      return this._nameCopied; 
    return false;
  }
  
  protected void _releaseBuffers() throws IOException {
    if (this._bufferRecyclable) {
      byte[] buf = this._inputBuffer;
      if (buf != null) {
        this._inputBuffer = null;
        this._ioContext.releaseReadIOBuffer(buf);
      } 
    } 
    this._textBuffer.releaseBuffers();
    char[] buf = this._nameCopyBuffer;
    if (buf != null) {
      this._nameCopyBuffer = null;
      this._ioContext.releaseNameCopyBuffer(buf);
    } 
  }
  
  public JsonToken nextToken() throws IOException {
    int len, len;
    this._numTypesValid = 0;
    if (this._tokenIncomplete)
      _skipIncomplete(); 
    this._tokenInputTotal = this._currInputProcessed + this._inputPtr;
    this._binaryValue = null;
    if (this._streamReadContext.inObject()) {
      if (this._currToken != JsonToken.FIELD_NAME) {
        this._tagValues.clear();
        if (!this._streamReadContext.expectMoreValues()) {
          this._stringRefs.pop();
          this._streamReadContext = this._streamReadContext.getParent();
          return this._currToken = JsonToken.END_OBJECT;
        } 
        return this._currToken = _decodePropertyName();
      } 
    } else if (!this._streamReadContext.expectMoreValues()) {
      this._stringRefs.pop();
      this._tagValues.clear();
      this._streamReadContext = this._streamReadContext.getParent();
      return this._currToken = JsonToken.END_ARRAY;
    } 
    if (this._inputPtr >= this._inputEnd && 
      !loadMore())
      return _eofAsNextToken(); 
    int ch = this._inputBuffer[this._inputPtr++] & 0xFF;
    int type = ch >> 5;
    int lowBits = ch & 0x1F;
    this._tagValues.clear();
    while (type == 6) {
      this._tagValues.add(_decodeTag(lowBits));
      if (this._inputPtr >= this._inputEnd && 
        !loadMore())
        return _eofAsNextToken(); 
      ch = this._inputBuffer[this._inputPtr++] & 0xFF;
      type = ch >> 5;
      lowBits = ch & 0x1F;
    } 
    boolean stringrefNamespace = this._tagValues.contains(256);
    switch (type) {
      case 0:
        this._numTypesValid = 1;
        if (lowBits <= 23) {
          this._numberInt = lowBits;
        } else {
          long l;
          long l;
          int v;
          switch (lowBits - 24) {
            case 0:
              this._numberInt = _decode8Bits();
              break;
            case 1:
              this._numberInt = _decode16Bits();
              break;
            case 2:
              v = _decode32Bits();
              if (v >= 0) {
                this._numberInt = v;
                break;
              } 
              l = v;
              this._numberLong = l & 0xFFFFFFFFL;
              this._numTypesValid = 2;
              break;
            case 3:
              l = _decode64Bits();
              if (l >= 0L) {
                this._numberLong = l;
                this._numTypesValid = 2;
                break;
              } 
              this._numberBigInt = _bigPositive(l);
              this._numTypesValid = 4;
              break;
            default:
              _invalidToken(ch);
              break;
          } 
        } 
        if (!this._tagValues.isEmpty())
          return _handleTaggedInt(this._tagValues); 
        return this._currToken = JsonToken.VALUE_NUMBER_INT;
      case 1:
        this._numTypesValid = 1;
        if (lowBits <= 23) {
          this._numberInt = -lowBits - 1;
        } else {
          long l;
          int v;
          switch (lowBits - 24) {
            case 0:
              this._numberInt = -_decode8Bits() - 1;
              return this._currToken = JsonToken.VALUE_NUMBER_INT;
            case 1:
              this._numberInt = -_decode16Bits() - 1;
              return this._currToken = JsonToken.VALUE_NUMBER_INT;
            case 2:
              v = _decode32Bits();
              if (v < 0) {
                long unsignedBase = v & 0xFFFFFFFFL;
                this._numberLong = -unsignedBase - 1L;
                this._numTypesValid = 2;
              } else {
                this._numberInt = -v - 1;
              } 
              return this._currToken = JsonToken.VALUE_NUMBER_INT;
            case 3:
              l = _decode64Bits();
              if (l >= 0L) {
                this._numberLong = -l - 1L;
                this._numTypesValid = 2;
              } else {
                this._numberBigInt = _bigNegative(l);
                this._numTypesValid = 4;
              } 
              return this._currToken = JsonToken.VALUE_NUMBER_INT;
          } 
          _invalidToken(ch);
        } 
        return this._currToken = JsonToken.VALUE_NUMBER_INT;
      case 2:
        this._typeByte = ch;
        this._tokenIncomplete = true;
        if (!this._tagValues.isEmpty())
          return _handleTaggedBinary(this._tagValues); 
        return this._currToken = JsonToken.VALUE_EMBEDDED_OBJECT;
      case 3:
        this._typeByte = ch;
        this._tokenIncomplete = true;
        return this._currToken = JsonToken.VALUE_STRING;
      case 4:
        this._stringRefs.push(stringrefNamespace);
        len = _decodeExplicitLength(lowBits);
        if (!this._tagValues.isEmpty())
          return _handleTaggedArray(this._tagValues, len); 
        createChildArrayContext(len);
        return this._currToken = JsonToken.START_ARRAY;
      case 5:
        this._stringRefs.push(stringrefNamespace);
        this._currToken = JsonToken.START_OBJECT;
        len = _decodeExplicitLength(lowBits);
        createChildObjectContext(len);
        return this._currToken;
    } 
    switch (lowBits) {
      case 20:
        return this._currToken = JsonToken.VALUE_FALSE;
      case 21:
        return this._currToken = JsonToken.VALUE_TRUE;
      case 22:
        return this._currToken = JsonToken.VALUE_NULL;
      case 23:
        return this._currToken = _decodeUndefinedValue();
      case 25:
        this._numberFloat = _decodeHalfSizeFloat();
        this._numTypesValid = 32;
        return this._currToken = JsonToken.VALUE_NUMBER_FLOAT;
      case 26:
        this._numberFloat = Float.intBitsToFloat(_decode32Bits());
        this._numTypesValid = 32;
        return this._currToken = JsonToken.VALUE_NUMBER_FLOAT;
      case 27:
        this._numberDouble = Double.longBitsToDouble(_decode64Bits());
        this._numTypesValid = 8;
        return this._currToken = JsonToken.VALUE_NUMBER_FLOAT;
      case 31:
        if (this._streamReadContext.inArray() && 
          !this._streamReadContext.hasExpectedLength()) {
          this._stringRefs.pop();
          this._streamReadContext = this._streamReadContext.getParent();
          return this._currToken = JsonToken.END_ARRAY;
        } 
        _reportUnexpectedBreak();
        break;
    } 
    return this._currToken = _decodeSimpleValue(lowBits, ch);
  }
  
  protected String _numberToName(int ch, boolean neg, TagList tags) throws IOException {
    int i;
    boolean isStringref = tags.contains(25);
    int lowBits = ch & 0x1F;
    if (lowBits <= 23) {
      i = lowBits;
    } else {
      long l;
      int i;
      int i;
      switch (lowBits) {
        case 24:
          i = _decode8Bits();
          break;
        case 25:
          i = _decode16Bits();
          break;
        case 26:
          i = _decode32Bits();
          if (i < 0) {
            long l;
            if (isStringref)
              _reportError("String reference index too large"); 
            if (neg) {
              long unsignedBase = i & 0xFFFFFFFFL;
              l = -unsignedBase - 1L;
            } else {
              l = i;
              l &= 0xFFFFFFFFL;
            } 
            return String.valueOf(l);
          } 
          break;
        case 27:
          if (isStringref)
            _reportError("String reference index too large"); 
          l = _decode64Bits();
          if (neg)
            l = -l - 1L; 
          return String.valueOf(l);
        default:
          throw _constructReadException("Invalid length indicator for ints (%d), token 0x%s", 
              Integer.valueOf(lowBits), Integer.toHexString(ch));
      } 
    } 
    if (neg)
      i = -i - 1; 
    if (isStringref) {
      if (this._stringRefs.empty())
        _reportError("String reference outside of a namespace"); 
      StringRefList stringRefs = this._stringRefs.peek();
      if (i < 0 || i >= stringRefs.stringRefs.size())
        _reportError("String reference (" + i + ") out of range"); 
      Object str = stringRefs.stringRefs.get(i);
      if (str instanceof String)
        return (String)str; 
      return new String((byte[])str, UTF8);
    } 
    return String.valueOf(i);
  }
  
  protected JsonToken _handleTaggedInt(TagList tags) throws IOException {
    if (!tags.contains(25))
      return this._currToken = JsonToken.VALUE_NUMBER_INT; 
    if (this._stringRefs.empty()) {
      _reportError("String reference outside of a namespace");
    } else if (this._numTypesValid != 1) {
      _reportError("String reference index too large");
    } 
    StringRefList stringRefs = this._stringRefs.peek();
    if (this._numberInt < 0 || this._numberInt >= stringRefs.stringRefs.size())
      _reportError("String reference (" + this._numberInt + ") out of range"); 
    Object str = stringRefs.stringRefs.get(this._numberInt);
    if (str instanceof String) {
      this._sharedString = (String)str;
      return this._currToken = JsonToken.VALUE_STRING;
    } 
    this._binaryValue = (byte[])str;
    return _handleTaggedBinary(tags);
  }
  
  protected JsonToken _handleTaggedBinary(TagList tags) throws IOException {
    boolean neg;
    if (tags.contains(2)) {
      neg = false;
    } else if (tags.contains(3)) {
      neg = true;
    } else {
      return this._currToken = JsonToken.VALUE_EMBEDDED_OBJECT;
    } 
    if (this._tokenIncomplete)
      _finishToken(); 
    if (this._binaryValue.length == 0) {
      this._numberBigInt = BigInteger.ZERO;
    } else {
      streamReadConstraints().validateIntegerLength(this._binaryValue.length);
      BigInteger nr = new BigInteger(this._binaryValue);
      if (neg)
        nr = nr.negate(); 
      this._numberBigInt = nr;
    } 
    this._numTypesValid = 4;
    this._tagValues.clear();
    return this._currToken = JsonToken.VALUE_NUMBER_INT;
  }
  
  protected JsonToken _handleTaggedArray(TagList tags, int len) throws IOException {
    BigDecimal dec;
    createChildArrayContext(len);
    if (!tags.contains(4))
      return this._currToken = JsonToken.START_ARRAY; 
    this._currToken = JsonToken.START_ARRAY;
    if (len != 2)
      _reportError("Unexpected array size (" + len + ") for tagged 'bigfloat' value; should have exactly 2 number elements"); 
    if (!_checkNextIsIntInArray("bigfloat"))
      _reportError("Unexpected token (" + currentToken() + ") as the first part of 'bigfloat' value: should get VALUE_NUMBER_INT"); 
    int exp = -getIntValue();
    if (!_checkNextIsIntInArray("bigfloat"))
      _reportError("Unexpected token (" + currentToken() + ") as the second part of 'bigfloat' value: should get VALUE_NUMBER_INT"); 
    JsonParser.NumberType numberType = getNumberType();
    if (numberType == JsonParser.NumberType.BIG_INTEGER) {
      dec = new BigDecimal(getBigIntegerValue(), exp);
    } else {
      dec = BigDecimal.valueOf(getLongValue(), exp);
    } 
    if (!_checkNextIsEndArray())
      _reportError("Unexpected token (" + currentToken() + ") after 2 elements of 'bigfloat' value"); 
    this._numberBigDecimal = dec;
    this._numTypesValid = 16;
    return this._currToken = JsonToken.VALUE_NUMBER_FLOAT;
  }
  
  protected final boolean _checkNextIsIntInArray(String typeDesc) throws IOException {
    if (!this._streamReadContext.expectMoreValues()) {
      this._tagValues.clear();
      this._stringRefs.pop();
      this._streamReadContext = this._streamReadContext.getParent();
      this._currToken = JsonToken.END_ARRAY;
      return false;
    } 
    if (this._inputPtr >= this._inputEnd && 
      !loadMore()) {
      _eofAsNextToken();
      return false;
    } 
    int ch = this._inputBuffer[this._inputPtr++] & 0xFF;
    int type = ch >> 5;
    int lowBits = ch & 0x1F;
    TagList tagValues = null;
    while (type == 6) {
      if (tagValues == null)
        tagValues = new TagList(); 
      tagValues.add(_decodeTag(lowBits));
      if (this._inputPtr >= this._inputEnd && !loadMore()) {
        _eofAsNextToken();
        return false;
      } 
      ch = this._inputBuffer[this._inputPtr++] & 0xFF;
      type = ch >> 5;
      lowBits = ch & 0x1F;
    } 
    switch (type) {
      case 0:
        this._numTypesValid = 1;
        if (lowBits <= 23) {
          this._numberInt = lowBits;
        } else {
          long l;
          int v;
          long l;
          switch (lowBits - 24) {
            case 0:
              this._numberInt = _decode8Bits();
              break;
            case 1:
              this._numberInt = _decode16Bits();
              break;
            case 2:
              v = _decode32Bits();
              if (v >= 0) {
                this._numberInt = v;
                break;
              } 
              l = v;
              this._numberLong = l & 0xFFFFFFFFL;
              this._numTypesValid = 2;
              break;
            case 3:
              l = _decode64Bits();
              if (l >= 0L) {
                this._numberLong = l;
                this._numTypesValid = 2;
                break;
              } 
              this._numberBigInt = _bigPositive(l);
              this._numTypesValid = 4;
              break;
            default:
              _invalidToken(ch);
              break;
          } 
        } 
        if (tagValues == null) {
          this._currToken = JsonToken.VALUE_NUMBER_INT;
        } else {
          _handleTaggedInt(tagValues);
        } 
        return true;
      case 1:
        this._numTypesValid = 1;
        if (lowBits <= 23) {
          this._numberInt = -lowBits - 1;
        } else {
          int v;
          long l;
          switch (lowBits - 24) {
            case 0:
              this._numberInt = -_decode8Bits() - 1;
              this._currToken = JsonToken.VALUE_NUMBER_INT;
              return true;
            case 1:
              this._numberInt = -_decode16Bits() - 1;
              this._currToken = JsonToken.VALUE_NUMBER_INT;
              return true;
            case 2:
              v = _decode32Bits();
              if (v < 0) {
                long unsignedBase = v & 0xFFFFFFFFL;
                this._numberLong = -unsignedBase - 1L;
                this._numTypesValid = 2;
              } else {
                this._numberInt = -v - 1;
              } 
              this._currToken = JsonToken.VALUE_NUMBER_INT;
              return true;
            case 3:
              l = _decode64Bits();
              if (l >= 0L) {
                this._numberLong = -l - 1L;
                this._numTypesValid = 2;
              } else {
                this._numberBigInt = _bigNegative(l);
                this._numTypesValid = 4;
              } 
              this._currToken = JsonToken.VALUE_NUMBER_INT;
              return true;
          } 
          _invalidToken(ch);
        } 
        this._currToken = JsonToken.VALUE_NUMBER_INT;
        return true;
      case 2:
        if (tagValues == null)
          break; 
        this._typeByte = ch;
        this._tokenIncomplete = true;
        this._currToken = _handleTaggedBinary(tagValues);
        return (this._currToken == JsonToken.VALUE_NUMBER_INT);
    } 
    this._inputPtr--;
    nextToken();
    return false;
  }
  
  protected final boolean _checkNextIsEndArray() {
    if (!this._streamReadContext.expectMoreValues()) {
      this._tagValues.clear();
      this._stringRefs.pop();
      this._streamReadContext = this._streamReadContext.getParent();
      this._currToken = JsonToken.END_ARRAY;
      return true;
    } 
    int ch = this._inputBuffer[this._inputPtr++];
    int type = ch >> 5 & 0x7;
    while (type == 6) {
      if (this._inputPtr >= this._inputEnd && !loadMore()) {
        _eofAsNextToken();
        return false;
      } 
      ch = this._inputBuffer[this._inputPtr++];
      type = ch >> 5 & 0x7;
    } 
    this._inputPtr--;
    return (nextToken() == JsonToken.END_ARRAY);
  }
  
  public void finishToken() throws IOException {
    if (this._tokenIncomplete)
      _finishToken(); 
  }
  
  public boolean nextFieldName(SerializableString str) throws IOException {
    if (this._streamReadContext.inObject() && this._currToken != JsonToken.FIELD_NAME) {
      this._numTypesValid = 0;
      if (this._tokenIncomplete)
        _skipIncomplete(); 
      this._tokenInputTotal = this._currInputProcessed + this._inputPtr;
      this._binaryValue = null;
      this._tagValues.clear();
      if (!this._streamReadContext.expectMoreValues()) {
        this._stringRefs.pop();
        this._streamReadContext = this._streamReadContext.getParent();
        this._currToken = JsonToken.END_OBJECT;
        return false;
      } 
      byte[] nameBytes = str.asQuotedUTF8();
      int byteLen = nameBytes.length;
      int ptr = this._inputPtr;
      if (ptr + byteLen + 1 < this._inputEnd) {
        int ch = this._inputBuffer[ptr++];
        if ((ch >> 5 & 0x7) == 3) {
          int lenMarker = ch & 0x1F;
          if (lenMarker <= 24) {
            if (lenMarker == 23)
              lenMarker = this._inputBuffer[ptr++] & 0xFF; 
            if (lenMarker == byteLen) {
              int i = 0;
              while (true) {
                if (i == lenMarker) {
                  this._inputPtr = ptr + i;
                  String strValue = str.getValue();
                  if (!this._stringRefs.empty() && 
                    CBORConstants.shouldReferenceString((this._stringRefs.peek()).stringRefs.size(), byteLen))
                    (this._stringRefs.peek()).stringRefs.add(strValue); 
                  this._streamReadContext.setCurrentName(strValue);
                  this._currToken = JsonToken.FIELD_NAME;
                  return true;
                } 
                if (nameBytes[i] != this._inputBuffer[ptr + i])
                  break; 
                i++;
              } 
            } 
          } 
        } 
      } 
    } 
    return (nextToken() == JsonToken.FIELD_NAME && str.getValue().equals(getCurrentName()));
  }
  
  public String nextFieldName() throws IOException {
    if (this._streamReadContext.inObject() && this._currToken != JsonToken.FIELD_NAME) {
      String name;
      this._numTypesValid = 0;
      if (this._tokenIncomplete)
        _skipIncomplete(); 
      this._tokenInputTotal = this._currInputProcessed + this._inputPtr;
      this._binaryValue = null;
      this._tagValues.clear();
      if (!this._streamReadContext.expectMoreValues()) {
        this._stringRefs.pop();
        this._streamReadContext = this._streamReadContext.getParent();
        this._currToken = JsonToken.END_OBJECT;
        return null;
      } 
      if (this._inputPtr >= this._inputEnd && 
        !loadMore())
        _eofAsNextToken(); 
      int ch = this._inputBuffer[this._inputPtr++] & 0xFF;
      int type = ch >> 5;
      int lowBits = ch & 0x1F;
      while (type == 6) {
        this._tagValues.add(_decodeTag(lowBits));
        if (this._inputPtr >= this._inputEnd && 
          !loadMore()) {
          _eofAsNextToken();
          return null;
        } 
        ch = this._inputBuffer[this._inputPtr++] & 0xFF;
        type = ch >> 5;
        lowBits = ch & 0x1F;
      } 
      if (type != 3) {
        if (ch == 255) {
          if (!this._streamReadContext.hasExpectedLength()) {
            this._stringRefs.pop();
            this._streamReadContext = this._streamReadContext.getParent();
            this._currToken = JsonToken.END_OBJECT;
            return null;
          } 
          _reportUnexpectedBreak();
        } 
        _decodeNonStringName(ch, this._tagValues);
        this._currToken = JsonToken.FIELD_NAME;
        return getText();
      } 
      int lenMarker = ch & 0x1F;
      this._sharedString = null;
      boolean chunked = false;
      if (lenMarker <= 23) {
        if (lenMarker == 0) {
          name = "";
        } else {
          if (this._inputEnd - this._inputPtr < lenMarker)
            _loadToHaveAtLeast(lenMarker); 
          if (this._symbolsCanonical) {
            name = _findDecodedFromSymbols(lenMarker);
            if (name != null) {
              this._inputPtr += lenMarker;
            } else {
              name = _decodeContiguousName(lenMarker);
              name = _addDecodedToSymbols(lenMarker, name);
            } 
          } else {
            name = _decodeContiguousName(lenMarker);
          } 
        } 
      } else {
        int actualLen = _decodeExplicitLength(lenMarker);
        if (actualLen < 0) {
          chunked = true;
          name = _decodeChunkedName();
        } else {
          name = _decodeLongerName(actualLen);
        } 
      } 
      if (!chunked && !this._stringRefs.empty() && 
        CBORConstants.shouldReferenceString((this._stringRefs.peek()).stringRefs.size(), lenMarker)) {
        (this._stringRefs.peek()).stringRefs.add(name);
        this._sharedString = name;
      } 
      this._streamReadContext.setCurrentName(name);
      this._currToken = JsonToken.FIELD_NAME;
      return name;
    } 
    return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null;
  }
  
  public String nextTextValue() throws IOException {
    if (nextToken() == JsonToken.VALUE_STRING)
      return getText(); 
    return null;
  }
  
  public int nextIntValue(int defaultValue) throws IOException {
    if (nextToken() == JsonToken.VALUE_NUMBER_INT)
      return getIntValue(); 
    return defaultValue;
  }
  
  public long nextLongValue(long defaultValue) throws IOException {
    if (nextToken() == JsonToken.VALUE_NUMBER_INT)
      return getLongValue(); 
    return defaultValue;
  }
  
  public Boolean nextBooleanValue() throws IOException {
    JsonToken t = nextToken();
    if (t == JsonToken.VALUE_TRUE)
      return Boolean.TRUE; 
    if (t == JsonToken.VALUE_FALSE)
      return Boolean.FALSE; 
    return null;
  }
  
  public String getText() throws IOException {
    JsonToken t = this._currToken;
    if (this._tokenIncomplete && 
      t == JsonToken.VALUE_STRING)
      return _finishTextToken(this._typeByte); 
    if (t == JsonToken.VALUE_STRING)
      return (this._sharedString == null) ? this._textBuffer.contentsAsString() : this._sharedString; 
    if (t == null)
      return null; 
    if (t == JsonToken.FIELD_NAME)
      return this._streamReadContext.getCurrentName(); 
    if (t.isNumeric())
      return getNumberValue().toString(); 
    return this._currToken.asString();
  }
  
  public char[] getTextCharacters() throws IOException {
    if (this._currToken != null) {
      if (this._tokenIncomplete)
        _finishToken(); 
      if (this._currToken == JsonToken.VALUE_STRING)
        return (this._sharedString == null) ? this._textBuffer.getTextBuffer() : this._sharedString.toCharArray(); 
      if (this._currToken == JsonToken.FIELD_NAME)
        return this._streamReadContext.getCurrentName().toCharArray(); 
      if (this._currToken == JsonToken.VALUE_NUMBER_INT || this._currToken == JsonToken.VALUE_NUMBER_FLOAT)
        return getNumberValue().toString().toCharArray(); 
      return this._currToken.asCharArray();
    } 
    return null;
  }
  
  public int getTextLength() {
    if (this._currToken != null) {
      if (this._tokenIncomplete)
        _finishToken(); 
      if (this._currToken == JsonToken.VALUE_STRING)
        return (this._sharedString == null) ? this._textBuffer.size() : this._sharedString.length(); 
      if (this._currToken == JsonToken.FIELD_NAME)
        return this._streamReadContext.getCurrentName().length(); 
      if (this._currToken == JsonToken.VALUE_NUMBER_INT || this._currToken == JsonToken.VALUE_NUMBER_FLOAT)
        return getNumberValue().toString().length(); 
      return this._currToken.asCharArray().length;
    } 
    return 0;
  }
  
  public int getTextOffset() { return 0; }
  
  public String getValueAsString() throws IOException {
    if (this._tokenIncomplete && 
      this._currToken == JsonToken.VALUE_STRING)
      return _finishTextToken(this._typeByte); 
    if (this._currToken == JsonToken.VALUE_STRING)
      return (this._sharedString == null) ? this._textBuffer.contentsAsString() : this._sharedString; 
    if (this._currToken == null || this._currToken == JsonToken.VALUE_NULL || !this._currToken.isScalarValue())
      return null; 
    return getText();
  }
  
  public String getValueAsString(String defaultValue) throws IOException {
    if (this._currToken != JsonToken.VALUE_STRING && (
      this._currToken == null || this._currToken == JsonToken.VALUE_NULL || !this._currToken.isScalarValue()))
      return defaultValue; 
    return getText();
  }
  
  public int getText(Writer writer) throws IOException {
    if (this._tokenIncomplete)
      _finishToken(); 
    JsonToken t = this._currToken;
    if (t == JsonToken.VALUE_STRING) {
      if (this._sharedString == null)
        return this._textBuffer.contentsToWriter(writer); 
      writer.write(this._sharedString);
      return this._sharedString.length();
    } 
    if (t == JsonToken.FIELD_NAME) {
      String n = this._streamReadContext.getCurrentName();
      writer.write(n);
      return n.length();
    } 
    if (t != null) {
      if (t.isNumeric()) {
        if (this._sharedString == null)
          return this._textBuffer.contentsToWriter(writer); 
        writer.write(this._sharedString);
        return this._sharedString.length();
      } 
      char[] ch = t.asCharArray();
      writer.write(ch);
      return ch.length;
    } 
    return 0;
  }
  
  public byte[] getBinaryValue(Base64Variant b64variant) throws IOException {
    if (this._currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {
      if (this._tokenIncomplete)
        _finishToken(); 
    } else {
      if (this._currToken == JsonToken.VALUE_STRING)
        return _getBinaryFromString(b64variant); 
      throw _constructReadException("Current token (%s) not VALUE_EMBEDDED_OBJECT or VALUE_STRING, can not access as binary", 
          
          currentToken());
    } 
    return this._binaryValue;
  }
  
  public Object getEmbeddedObject() {
    if (this._tokenIncomplete)
      _finishToken(); 
    if (this._currToken == JsonToken.VALUE_EMBEDDED_OBJECT)
      return this._binaryValue; 
    return null;
  }
  
  public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException {
    if (this._currToken != JsonToken.VALUE_EMBEDDED_OBJECT) {
      if (this._currToken == JsonToken.VALUE_STRING) {
        byte[] b = _getBinaryFromString(b64variant);
        int len = b.length;
        out.write(b, 0, len);
        return len;
      } 
      throw _constructReadException("Current token (%s) not VALUE_EMBEDDED_OBJECT or VALUE_STRING, can not access as binary", 
          
          currentToken());
    } 
    if (!this._tokenIncomplete) {
      if (this._binaryValue == null)
        return 0; 
      int len = this._binaryValue.length;
      out.write(this._binaryValue, 0, len);
      return len;
    } 
    this._tokenIncomplete = false;
    int len = _decodeExplicitLength(this._typeByte & 0x1F);
    if (!this._stringRefs.empty()) {
      out.write(_finishBytes(len));
      return len;
    } 
    if (len >= 0)
      return _readAndWriteBytes(out, len); 
    int total = 0;
    while (true) {
      len = _decodeChunkLength(2);
      if (len < 0)
        return total; 
      total += _readAndWriteBytes(out, len);
    } 
  }
  
  private int _readAndWriteBytes(OutputStream out, int total) throws IOException {
    int left = total;
    while (left > 0) {
      int avail = this._inputEnd - this._inputPtr;
      if (this._inputPtr >= this._inputEnd) {
        if (!loadMore())
          _reportIncompleteBinaryRead(total, total - left); 
        avail = this._inputEnd - this._inputPtr;
      } 
      int count = Math.min(avail, left);
      out.write(this._inputBuffer, this._inputPtr, count);
      this._inputPtr += count;
      left -= count;
    } 
    this._tokenIncomplete = false;
    return total;
  }
  
  private final byte[] _getBinaryFromString(Base64Variant variant) throws IOException {
    if (this._tokenIncomplete)
      _finishToken(); 
    if (this._binaryValue == null) {
      ByteArrayBuilder builder = _getByteArrayBuilder();
      _decodeBase64(getText(), builder, variant);
      this._binaryValue = builder.toByteArray();
    } 
    return this._binaryValue;
  }
  
  public boolean isNaN() {
    if (this._currToken == JsonToken.VALUE_NUMBER_FLOAT) {
      if ((this._numTypesValid & 0x8) != 0) {
        double d = this._numberDouble;
        return (Double.isNaN(d) || Double.isInfinite(d));
      } 
      if ((this._numTypesValid & 0x20) != 0) {
        float f = this._numberFloat;
        return (Float.isNaN(f) || Float.isInfinite(f));
      } 
    } 
    return false;
  }
  
  public Number getNumberValue() throws IOException {
    if (this._numTypesValid == 0)
      _checkNumericValue(0); 
    if (this._currToken == JsonToken.VALUE_NUMBER_INT) {
      if ((this._numTypesValid & true) != 0)
        return Integer.valueOf(this._numberInt); 
      if ((this._numTypesValid & 0x2) != 0)
        return Long.valueOf(this._numberLong); 
      if ((this._numTypesValid & 0x4) != 0)
        return this._numberBigInt; 
      return this._numberBigDecimal;
    } 
    if ((this._numTypesValid & 0x10) != 0)
      return this._numberBigDecimal; 
    if ((this._numTypesValid & 0x8) != 0)
      return Double.valueOf(this._numberDouble); 
    if ((this._numTypesValid & 0x20) == 0)
      _throwInternal(); 
    return Float.valueOf(this._numberFloat);
  }
  
  public final Number getNumberValueExact() throws IOException { return getNumberValue(); }
  
  public JsonParser.NumberType getNumberType() throws IOException {
    if (this._numTypesValid == 0)
      _checkNumericValue(0); 
    if (this._currToken == JsonToken.VALUE_NUMBER_INT) {
      if ((this._numTypesValid & true) != 0)
        return JsonParser.NumberType.INT; 
      if ((this._numTypesValid & 0x2) != 0)
        return JsonParser.NumberType.LONG; 
      return JsonParser.NumberType.BIG_INTEGER;
    } 
    if ((this._numTypesValid & 0x10) != 0)
      return JsonParser.NumberType.BIG_DECIMAL; 
    if ((this._numTypesValid & 0x8) != 0)
      return JsonParser.NumberType.DOUBLE; 
    return JsonParser.NumberType.FLOAT;
  }
  
  public int getIntValue() {
    if ((this._numTypesValid & true) == 0) {
      if (this._numTypesValid == 0)
        _checkNumericValue(1); 
      if ((this._numTypesValid & true) == 0)
        convertNumberToInt(); 
    } 
    return this._numberInt;
  }
  
  public long getLongValue() throws IOException {
    if ((this._numTypesValid & 0x2) == 0) {
      if (this._numTypesValid == 0)
        _checkNumericValue(2); 
      if ((this._numTypesValid & 0x2) == 0)
        convertNumberToLong(); 
    } 
    return this._numberLong;
  }
  
  public BigInteger getBigIntegerValue() throws IOException {
    if ((this._numTypesValid & 0x4) == 0) {
      if (this._numTypesValid == 0)
        _checkNumericValue(4); 
      if ((this._numTypesValid & 0x4) == 0)
        convertNumberToBigInteger(); 
    } 
    return this._numberBigInt;
  }
  
  public float getFloatValue() throws IOException {
    if ((this._numTypesValid & 0x20) == 0) {
      if (this._numTypesValid == 0)
        _checkNumericValue(32); 
      if ((this._numTypesValid & 0x20) == 0)
        convertNumberToFloat(); 
    } 
    return this._numberFloat;
  }
  
  public double getDoubleValue() throws IOException {
    if ((this._numTypesValid & 0x8) == 0) {
      if (this._numTypesValid == 0)
        _checkNumericValue(8); 
      if ((this._numTypesValid & 0x8) == 0)
        convertNumberToDouble(); 
    } 
    return this._numberDouble;
  }
  
  public BigDecimal getDecimalValue() throws IOException {
    if ((this._numTypesValid & 0x10) == 0) {
      if (this._numTypesValid == 0)
        _checkNumericValue(16); 
      if ((this._numTypesValid & 0x10) == 0)
        convertNumberToBigDecimal(); 
    } 
    return this._numberBigDecimal;
  }
  
  protected void _checkNumericValue(int expType) throws IOException {
    if (this._currToken == JsonToken.VALUE_NUMBER_INT || this._currToken == JsonToken.VALUE_NUMBER_FLOAT)
      return; 
    _reportError("Current token (" + currentToken() + ") not numeric, can not use numeric value accessors");
  }
  
  protected void convertNumberToInt() throws IOException {
    if ((this._numTypesValid & 0x2) != 0) {
      int result = (int)this._numberLong;
      if (result != this._numberLong)
        _reportError("Numeric value (" + getText() + ") out of range of int"); 
      this._numberInt = result;
    } else if ((this._numTypesValid & 0x4) != 0) {
      if (BI_MIN_INT.compareTo(this._numberBigInt) > 0 || BI_MAX_INT
        .compareTo(this._numberBigInt) < 0)
        reportOverflowInt(); 
      this._numberInt = this._numberBigInt.intValue();
    } else if ((this._numTypesValid & 0x8) != 0) {
      if (this._numberDouble < -2.147483648E9D || this._numberDouble > 2.147483647E9D)
        reportOverflowInt(); 
      this._numberInt = (int)this._numberDouble;
    } else if ((this._numTypesValid & 0x20) != 0) {
      if (this._numberFloat < -2.147483648E9D || this._numberFloat > 2.147483647E9D)
        reportOverflowInt(); 
      this._numberInt = (int)this._numberFloat;
    } else if ((this._numTypesValid & 0x10) != 0) {
      if (BD_MIN_INT.compareTo(this._numberBigDecimal) > 0 || BD_MAX_INT
        .compareTo(this._numberBigDecimal) < 0)
        reportOverflowInt(); 
      this._numberInt = this._numberBigDecimal.intValue();
    } else {
      _throwInternal();
    } 
    this._numTypesValid |= 0x1;
  }
  
  protected void convertNumberToLong() throws IOException {
    if ((this._numTypesValid & true) != 0) {
      this._numberLong = this._numberInt;
    } else if ((this._numTypesValid & 0x4) != 0) {
      if (BI_MIN_LONG.compareTo(this._numberBigInt) > 0 || BI_MAX_LONG
        .compareTo(this._numberBigInt) < 0)
        reportOverflowLong(); 
      this._numberLong = this._numberBigInt.longValue();
    } else if ((this._numTypesValid & 0x8) != 0) {
      if (this._numberDouble < -9.223372036854776E18D || this._numberDouble > 9.223372036854776E18D)
        reportOverflowLong(); 
      this._numberLong = (long)this._numberDouble;
    } else if ((this._numTypesValid & 0x20) != 0) {
      if (this._numberFloat < -9.223372036854776E18D || this._numberFloat > 9.223372036854776E18D)
        reportOverflowInt(); 
      this._numberLong = (long)this._numberFloat;
    } else if ((this._numTypesValid & 0x10) != 0) {
      if (BD_MIN_LONG.compareTo(this._numberBigDecimal) > 0 || BD_MAX_LONG
        .compareTo(this._numberBigDecimal) < 0)
        reportOverflowLong(); 
      this._numberLong = this._numberBigDecimal.longValue();
    } else {
      _throwInternal();
    } 
    this._numTypesValid |= 0x2;
  }
  
  protected void convertNumberToBigInteger() throws IOException {
    if ((this._numTypesValid & 0x10) != 0) {
      streamReadConstraints().validateBigIntegerScale(this._numberBigDecimal.scale());
      this._numberBigInt = this._numberBigDecimal.toBigInteger();
    } else if ((this._numTypesValid & 0x2) != 0) {
      this._numberBigInt = BigInteger.valueOf(this._numberLong);
    } else if ((this._numTypesValid & true) != 0) {
      this._numberBigInt = BigInteger.valueOf(this._numberInt);
    } else if ((this._numTypesValid & 0x8) != 0) {
      this._numberBigInt = BigDecimal.valueOf(this._numberDouble).toBigInteger();
    } else if ((this._numTypesValid & 0x20) != 0) {
      this._numberBigInt = BigDecimal.valueOf(this._numberFloat).toBigInteger();
    } else {
      _throwInternal();
    } 
    this._numTypesValid |= 0x4;
  }
  
  protected void convertNumberToFloat() throws IOException {
    if ((this._numTypesValid & 0x10) != 0) {
      this._numberFloat = this._numberBigDecimal.floatValue();
    } else if ((this._numTypesValid & 0x4) != 0) {
      this._numberFloat = this._numberBigInt.floatValue();
    } else if ((this._numTypesValid & 0x8) != 0) {
      this._numberFloat = (float)this._numberDouble;
    } else if ((this._numTypesValid & 0x2) != 0) {
      this._numberFloat = (float)this._numberLong;
    } else if ((this._numTypesValid & true) != 0) {
      this._numberFloat = this._numberInt;
    } else {
      _throwInternal();
    } 
    this._numTypesValid |= 0x20;
  }
  
  protected void convertNumberToDouble() throws IOException {
    if ((this._numTypesValid & 0x10) != 0) {
      this._numberDouble = this._numberBigDecimal.doubleValue();
    } else if ((this._numTypesValid & 0x20) != 0) {
      this._numberDouble = this._numberFloat;
    } else if ((this._numTypesValid & 0x4) != 0) {
      this._numberDouble = this._numberBigInt.doubleValue();
    } else if ((this._numTypesValid & 0x2) != 0) {
      this._numberDouble = this._numberLong;
    } else if ((this._numTypesValid & true) != 0) {
      this._numberDouble = this._numberInt;
    } else {
      _throwInternal();
    } 
    this._numTypesValid |= 0x8;
  }
  
  protected void convertNumberToBigDecimal() throws IOException {
    if ((this._numTypesValid & 0x28) != 0) {
      String text = getText();
      streamReadConstraints().validateFPLength(text.length());
      this._numberBigDecimal = NumberInput.parseBigDecimal(text, 
          isEnabled(StreamReadFeature.USE_FAST_BIG_NUMBER_PARSER));
    } else if ((this._numTypesValid & 0x4) != 0) {
      this._numberBigDecimal = new BigDecimal(this._numberBigInt);
    } else if ((this._numTypesValid & 0x2) != 0) {
      this._numberBigDecimal = BigDecimal.valueOf(this._numberLong);
    } else if ((this._numTypesValid & true) != 0) {
      this._numberBigDecimal = BigDecimal.valueOf(this._numberInt);
    } else {
      _throwInternal();
    } 
    this._numTypesValid |= 0x10;
  }
  
  protected void _finishToken() throws IOException {
    this._tokenIncomplete = false;
    this._sharedString = null;
    int ch = this._typeByte;
    int type = ch >> 5 & 0x7;
    ch &= 0x1F;
    if (type != 3) {
      if (type == 2) {
        this._binaryValue = _finishBytes(_decodeExplicitLength(ch));
        return;
      } 
      _throwInternal();
    } 
    int len = _decodeExplicitLength(ch);
    if (len <= 0) {
      if (len < 0) {
        _finishChunkedText();
      } else {
        this._textBuffer.resetWithEmpty();
      } 
      return;
    } 
    int needed = len + 3;
    int available = this._inputEnd - this._inputPtr;
    if (available >= needed || (this._inputBuffer.length >= needed && 

      
      _tryToLoadToHaveAtLeast(needed))) {
      _finishShortText(len);
      return;
    } 
    _finishLongText(len);
  }
  
  protected String _finishTextToken(int ch) throws IOException {
    this._tokenIncomplete = false;
    this._sharedString = null;
    int type = ch >> 5 & 0x7;
    ch &= 0x1F;
    if (type != 3)
      _throwInternal(); 
    int len = _decodeExplicitLength(ch);
    if (len <= 0) {
      if (len == 0) {
        this._textBuffer.resetWithEmpty();
        return "";
      } 
      _finishChunkedText();
      return this._textBuffer.contentsAsString();
    } 
    int needed = Math.max(len + 3, len);
    int available = this._inputEnd - this._inputPtr;
    if (available >= needed || (this._inputBuffer.length >= needed && 

      
      _tryToLoadToHaveAtLeast(needed)))
      return _finishShortText(len); 
    return _finishLongText(len);
  }
  
  private final String _finishShortText(int len) throws IOException {
    char[] outBuf = this._textBuffer.emptyAndGetCurrentSegment();
    if (outBuf.length < len)
      outBuf = this._textBuffer.expandCurrentSegment(len); 
    StringRefList stringRefs = null;
    if (!this._stringRefs.empty() && 
      CBORConstants.shouldReferenceString((this._stringRefs.peek()).stringRefs.size(), len))
      stringRefs = this._stringRefs.peek(); 
    int outPtr = 0;
    int inPtr = this._inputPtr;
    this._inputPtr += len;
    byte[] inputBuf = this._inputBuffer;
    int end = inPtr + len;
    int i;
    while ((i = inputBuf[inPtr]) >= 0) {
      outBuf[outPtr++] = (char)i;
      if (++inPtr == end) {
        String str = this._textBuffer.setCurrentAndReturn(outPtr);
        if (stringRefs != null) {
          stringRefs.stringRefs.add(str);
          this._sharedString = str;
        } 
        return str;
      } 
    } 
    int[] codes = UTF8_UNIT_CODES;
    do {
      int c3, c2, c2;
      i = inputBuf[inPtr++] & 0xFF;
      switch (codes[i]) {
        case 0:
          break;
        case 1:
          c2 = inputBuf[inPtr++];
          if ((c2 & 0xC0) != 128)
            _reportInvalidOther(c2 & 0xFF, inPtr); 
          i = (i & 0x1F) << 6 | c2 & 0x3F;
          break;
        case 2:
          c2 = inputBuf[inPtr++];
          if ((c2 & 0xC0) != 128)
            _reportInvalidOther(c2 & 0xFF, inPtr); 
          c3 = inputBuf[inPtr++];
          if ((c3 & 0xC0) != 128)
            _reportInvalidOther(c3 & 0xFF, inPtr); 
          i = (i & 0xF) << 12 | (c2 & 0x3F) << 6 | c3 & 0x3F;
          break;
        case 3:
          i = (i & 0x7) << 18 | (inputBuf[inPtr++] & 0x3F) << 12 | (inputBuf[inPtr++] & 0x3F) << 6 | inputBuf[inPtr++] & 0x3F;
          i -= 65536;
          outBuf[outPtr++] = (char)(0xD800 | i >> 10);
          i = 0xDC00 | i & 0x3FF;
          break;
        default:
          _reportInvalidInitial(i);
          break;
      } 
      outBuf[outPtr++] = (char)i;
    } while (inPtr < end);
    String str = this._textBuffer.setCurrentAndReturn(outPtr);
    if (stringRefs != null) {
      stringRefs.stringRefs.add(str);
      this._sharedString = str;
    } 
    return str;
  }
  
  private final String _finishLongText(int len) throws IOException {
    char[] outBuf = this._textBuffer.emptyAndGetCurrentSegment();
    int outPtr = 0;
    int[] codes = UTF8_UNIT_CODES;
    int outEnd = outBuf.length;
    while (--len >= 0) {
      int d, c = _nextByte() & 0xFF;
      int code = codes[c];
      if (code == 0 && outPtr < outEnd) {
        outBuf[outPtr++] = (char)c;
        continue;
      } 
      if (len -= code < 0)
        throw _constructReadException("Malformed UTF-8 character at the end of a (non-chunked) text segment"); 
      switch (code) {
        case 0:
          break;
        case 1:
          d = _nextByte();
          if ((d & 0xC0) != 128)
            _reportInvalidOther(d & 0xFF, this._inputPtr); 
          c = (c & 0x1F) << 6 | d & 0x3F;
          break;
        case 2:
          c = _decodeUTF8_3(c);
          break;
        case 3:
          c = _decodeUTF8_4(c);
          if (outPtr >= outBuf.length) {
            outBuf = this._textBuffer.finishCurrentSegment();
            outPtr = 0;
            outEnd = outBuf.length;
          } 
          outBuf[outPtr++] = (char)(0xD800 | c >> 10);
          c = 0xDC00 | c & 0x3FF;
          break;
        default:
          _reportInvalidChar(c);
          break;
      } 
      if (outPtr >= outEnd) {
        outBuf = this._textBuffer.finishCurrentSegment();
        outPtr = 0;
        outEnd = outBuf.length;
      } 
      outBuf[outPtr++] = (char)c;
    } 
    String str = this._textBuffer.setCurrentAndReturn(outPtr);
    if (!this._stringRefs.empty() && 
      CBORConstants.shouldReferenceString((this._stringRefs.peek()).stringRefs.size(), len)) {
      (this._stringRefs.peek()).stringRefs.add(str);
      this._sharedString = str;
    } 
    return str;
  }
  
  private final void _finishChunkedText() throws IOException {
    char[] outBuf = this._textBuffer.emptyAndGetCurrentSegment();
    int outPtr = 0;
    int[] codes = UTF8_UNIT_CODES;
    int outEnd = outBuf.length;
    byte[] input = this._inputBuffer;
    this._chunkEnd = this._inputPtr;
    this._chunkLeft = 0;
    while (true) {
      int d;
      if (this._inputPtr >= this._chunkEnd) {
        if (this._chunkLeft == 0) {
          int len = _decodeChunkLength(3);
          if (len <= 0) {
            if (len == 0)
              continue; 
            break;
          } 
          this._chunkLeft = len;
          int end = this._inputPtr + len;
          if (end <= this._inputEnd) {
            this._chunkLeft = 0;
            this._chunkEnd = end;
          } else {
            this._chunkLeft = end - this._inputEnd;
            this._chunkEnd = this._inputEnd;
          } 
        } 
        if (this._inputPtr >= this._inputEnd) {
          loadMoreGuaranteed();
          int end = this._inputPtr + this._chunkLeft;
          if (end <= this._inputEnd) {
            this._chunkLeft = 0;
            this._chunkEnd = end;
          } else {
            this._chunkLeft = end - this._inputEnd;
            this._chunkEnd = this._inputEnd;
          } 
        } 
      } 
      int c = input[this._inputPtr++] & 0xFF;
      int code = codes[c];
      if (code == 0 && outPtr < outEnd) {
        outBuf[outPtr++] = (char)c;
        continue;
      } 
      switch (code) {
        case 0:
          break;
        case 1:
          d = _nextChunkedByte();
          if ((d & 0xC0) != 128)
            _reportInvalidOther(d & 0xFF, this._inputPtr); 
          c = (c & 0x1F) << 6 | d & 0x3F;
          break;
        case 2:
          c = _decodeChunkedUTF8_3(c);
          break;
        case 3:
          c = _decodeChunkedUTF8_4(c);
          if (outPtr >= outBuf.length) {
            outBuf = this._textBuffer.finishCurrentSegment();
            outPtr = 0;
            outEnd = outBuf.length;
          } 
          outBuf[outPtr++] = (char)(0xD800 | c >> 10);
          c = 0xDC00 | c & 0x3FF;
          break;
        default:
          _reportInvalidChar(c);
          break;
      } 
      if (outPtr >= outEnd) {
        outBuf = this._textBuffer.finishCurrentSegment();
        outPtr = 0;
        outEnd = outBuf.length;
      } 
      outBuf[outPtr++] = (char)c;
    } 
    this._textBuffer.setCurrentLength(outPtr);
  }
  
  private final int _nextByte() {
    int inPtr = this._inputPtr;
    if (inPtr < this._inputEnd) {
      int ch = this._inputBuffer[inPtr];
      this._inputPtr = inPtr + 1;
      return ch;
    } 
    loadMoreGuaranteed();
    return this._inputBuffer[this._inputPtr++];
  }
  
  private final int _nextChunkedByte() {
    int inPtr = this._inputPtr;
    if (inPtr >= this._chunkEnd)
      return _nextChunkedByte2(); 
    int ch = this._inputBuffer[inPtr];
    this._inputPtr = inPtr + 1;
    return ch;
  }
  
  private final int _nextChunkedByte2() {
    if (this._inputPtr >= this._inputEnd) {
      loadMoreGuaranteed();
      if (this._chunkLeft > 0) {
        int end = this._inputPtr + this._chunkLeft;
        if (end <= this._inputEnd) {
          this._chunkLeft = 0;
          this._chunkEnd = end;
        } else {
          this._chunkLeft = end - this._inputEnd;
          this._chunkEnd = this._inputEnd;
        } 
        return this._inputBuffer[this._inputPtr++];
      } 
    } 
    int len = _decodeChunkLength(3);
    if (len <= 0)
      _reportInvalidEOF(": chunked Text ends with partial UTF-8 character", JsonToken.VALUE_STRING); 
    if (this._inputPtr >= this._inputEnd)
      loadMoreGuaranteed(); 
    int end = this._inputPtr + len;
    if (end <= this._inputEnd) {
      this._chunkLeft = 0;
      this._chunkEnd = end;
    } else {
      this._chunkLeft = end - this._inputEnd;
      this._chunkEnd = this._inputEnd;
    } 
    return this._inputBuffer[this._inputPtr++];
  }
  
  protected byte[] _finishBytes(int len) throws IOException {
    if (len <= 0) {
      if (len == 0)
        return NO_BYTES; 
      return _finishChunkedBytes();
    } 
    StringRefList stringRefs = null;
    if (!this._stringRefs.empty() && 
      CBORConstants.shouldReferenceString((this._stringRefs.peek()).stringRefs.size(), len))
      stringRefs = this._stringRefs.peek(); 
    if (len > 250000) {
      byte[] b = _finishLongContiguousBytes(len);
      if (stringRefs != null)
        stringRefs.stringRefs.add(b); 
      return b;
    } 
    byte[] b = new byte[len];
    int expLen = len;
    if (this._inputPtr >= this._inputEnd && 
      !loadMore())
      _reportIncompleteBinaryRead(expLen, 0); 
    int ptr = 0;
    while (true) {
      int toAdd = Math.min(len, this._inputEnd - this._inputPtr);
      System.arraycopy(this._inputBuffer, this._inputPtr, b, ptr, toAdd);
      this._inputPtr += toAdd;
      ptr += toAdd;
      len -= toAdd;
      if (len <= 0) {
        if (stringRefs != null)
          stringRefs.stringRefs.add(b); 
        return b;
      } 
      if (!loadMore())
        _reportIncompleteBinaryRead(expLen, ptr); 
    } 
  }
  
  protected byte[] _finishChunkedBytes() throws IOException {
    ByteArrayBuilder bb = _getByteArrayBuilder();
    while (true) {
      if (this._inputPtr >= this._inputEnd)
        loadMoreGuaranteed(); 
      int ch = this._inputBuffer[this._inputPtr++] & 0xFF;
      if (ch == 255)
        break; 
      int type = ch >> 5;
      if (type != 2)
        throw _constructReadException("Mismatched chunk in chunked content: expected %d but encountered %d", 
            
            Integer.valueOf(2), Integer.valueOf(type)); 
      int len = _decodeExplicitLength(ch & 0x1F);
      if (len < 0)
        throw _constructReadException("Illegal chunked-length indicator within chunked-length value (type %d)", 
            Integer.valueOf(2)); 
      int chunkLen = len;
      while (len > 0) {
        int avail = this._inputEnd - this._inputPtr;
        if (this._inputPtr >= this._inputEnd) {
          if (!loadMore())
            _reportIncompleteBinaryRead(chunkLen, chunkLen - len); 
          avail = this._inputEnd - this._inputPtr;
        } 
        int count = Math.min(avail, len);
        bb.write(this._inputBuffer, this._inputPtr, count);
        this._inputPtr += count;
        len -= count;
      } 
    } 
    return bb.toByteArray();
  }
  
  protected byte[] _finishLongContiguousBytes(int expLen) throws IOException {
    int left = expLen;
    try (ByteArrayBuilder bb = new ByteArrayBuilder(125000)) {
      while (left > 0) {
        int avail = this._inputEnd - this._inputPtr;
        if (avail <= 0) {
          if (!loadMore())
            _reportIncompleteBinaryRead(expLen, expLen - left); 
          avail = this._inputEnd - this._inputPtr;
        } 
        int count = Math.min(avail, left);
        bb.write(this._inputBuffer, this._inputPtr, count);
        this._inputPtr += count;
        left -= count;
      } 
      return bb.toByteArray();
    } 
  }
  
  protected final JsonToken _decodePropertyName() throws IOException {
    String name;
    if (this._inputPtr >= this._inputEnd)
      if (!loadMore())
        _eofAsNextToken();  
    int ch = this._inputBuffer[this._inputPtr++] & 0xFF;
    int type = ch >> 5;
    int lowBits = ch & 0x1F;
    while (type == 6) {
      this._tagValues.add(_decodeTag(lowBits));
      if (this._inputPtr >= this._inputEnd && 
        !loadMore()) {
        _eofAsNextToken();
        return null;
      } 
      ch = this._inputBuffer[this._inputPtr++] & 0xFF;
      type = ch >> 5;
      lowBits = ch & 0x1F;
    } 
    if (type != 3) {
      if (ch == 255) {
        if (!this._streamReadContext.hasExpectedLength()) {
          this._stringRefs.pop();
          this._streamReadContext = this._streamReadContext.getParent();
          return JsonToken.END_OBJECT;
        } 
        _reportUnexpectedBreak();
      } 
      _decodeNonStringName(ch, this._tagValues);
      return JsonToken.FIELD_NAME;
    } 
    int lenMarker = ch & 0x1F;
    boolean chunked = false;
    if (lenMarker <= 23) {
      if (lenMarker == 0) {
        name = "";
      } else {
        if (this._inputEnd - this._inputPtr < lenMarker)
          _loadToHaveAtLeast(lenMarker); 
        if (this._symbolsCanonical) {
          name = _findDecodedFromSymbols(lenMarker);
          if (name != null) {
            this._inputPtr += lenMarker;
          } else {
            name = _decodeContiguousName(lenMarker);
            name = _addDecodedToSymbols(lenMarker, name);
          } 
        } else {
          name = _decodeContiguousName(lenMarker);
        } 
      } 
    } else {
      int actualLen = _decodeExplicitLength(lenMarker);
      if (actualLen < 0) {
        chunked = true;
        name = _decodeChunkedName();
      } else {
        name = _decodeLongerName(actualLen);
      } 
    } 
    if (!chunked && !this._stringRefs.empty() && 
      CBORConstants.shouldReferenceString((this._stringRefs.peek()).stringRefs.size(), lenMarker)) {
      (this._stringRefs.peek()).stringRefs.add(name);
      this._sharedString = name;
    } 
    this._streamReadContext.setCurrentName(name);
    return JsonToken.FIELD_NAME;
  }
  
  private final String _decodeContiguousName(int len) throws IOException {
    int outPtr = 0;
    char[] outBuf = this._textBuffer.emptyAndGetCurrentSegment();
    if (outBuf.length < len)
      outBuf = this._textBuffer.expandCurrentSegment(len); 
    int inPtr = this._inputPtr;
    this._inputPtr += len;
    int[] codes = UTF8_UNIT_CODES;
    byte[] inBuf = this._inputBuffer;
    int end = inPtr + len;
    while (true) {
      int i = inBuf[inPtr] & 0xFF;
      int code = codes[i];
      if (code != 0)
        break; 
      outBuf[outPtr++] = (char)i;
      if (++inPtr == end)
        return this._textBuffer.setCurrentAndReturn(outPtr); 
    } 
    while (inPtr < end) {
      int i = inBuf[inPtr++] & 0xFF;
      int code = codes[i];
      if (code != 0) {
        int c3;
        int c2;
        int c2;
        if (inPtr + code > end) {
          int firstCharOffset = len - end - inPtr - 1;
          _reportTruncatedUTF8InName(len, firstCharOffset, i, code);
        } 
        switch (code) {
          case 1:
            c2 = inBuf[inPtr++];
            if ((c2 & 0xC0) != 128)
              _reportInvalidOther(c2 & 0xFF, inPtr); 
            i = (i & 0x1F) << 6 | c2 & 0x3F;
            break;
          case 2:
            c2 = inBuf[inPtr++];
            if ((c2 & 0xC0) != 128)
              _reportInvalidOther(c2 & 0xFF, inPtr); 
            c3 = inBuf[inPtr++];
            if ((c3 & 0xC0) != 128)
              _reportInvalidOther(c3 & 0xFF, inPtr); 
            i = (i & 0xF) << 12 | (c2 & 0x3F) << 6 | c3 & 0x3F;
            break;
          case 3:
            i = (i & 0x7) << 18 | (inBuf[inPtr++] & 0x3F) << 12 | (inBuf[inPtr++] & 0x3F) << 6 | inBuf[inPtr++] & 0x3F;
            i -= 65536;
            outBuf[outPtr++] = (char)(0xD800 | i >> 10);
            i = 0xDC00 | i & 0x3FF;
            break;
          default:
            throw _constructReadException("Invalid UTF-8 byte 0x%s in Object property name", 
                Integer.toHexString(i));
        } 
      } 
      outBuf[outPtr++] = (char)i;
    } 
    return this._textBuffer.setCurrentAndReturn(outPtr);
  }
  
  private final String _decodeLongerName(int len) throws IOException {
    if (len == 0)
      return ""; 
    if (this._inputEnd - this._inputPtr < len) {
      if (len >= this._inputBuffer.length)
        return _finishLongText(len); 
      _loadToHaveAtLeast(len);
    } 
    if (this._symbolsCanonical) {
      String name = _findDecodedFromSymbols(len);
      if (name != null) {
        this._inputPtr += len;
        return name;
      } 
      name = _decodeContiguousName(len);
      return _addDecodedToSymbols(len, name);
    } 
    return _decodeContiguousName(len);
  }
  
  private final String _decodeChunkedName() throws IOException {
    _finishChunkedText();
    return this._textBuffer.contentsAsString();
  }
  
  protected final void _decodeNonStringName(int ch, TagList tags) throws IOException {
    String name;
    int type = ch >> 5 & 0x7;
    if (type == 0) {
      name = _numberToName(ch, false, tags);
    } else if (type == 1) {
      name = _numberToName(ch, true, tags);
    } else if (type == 2) {
      int blen = _decodeExplicitLength(ch & 0x1F);
      byte[] b = _finishBytes(blen);
      name = new String(b, UTF8);
    } else {
      if ((ch & 0xFF) == 255)
        _reportUnexpectedBreak(); 
      throw _constructReadException("Unsupported major type (%d) for CBOR Objects, not (yet?) supported, only Strings", 
          Integer.valueOf(type));
    } 
    this._streamReadContext.setCurrentName(name);
  }
  
  private final String _findDecodedFromSymbols(int len) throws IOException {
    if (len < 5) {
      int inPtr = this._inputPtr;
      byte[] inBuf = this._inputBuffer;
      int q = _padQuadForNulls(inBuf[inPtr]);
      if (len > 1) {
        q = (q << 8) + (inBuf[++inPtr] & 0xFF);
        if (len > 2) {
          q = (q << 8) + (inBuf[++inPtr] & 0xFF);
          if (len > 3)
            q = (q << 8) + (inBuf[++inPtr] & 0xFF); 
        } 
      } 
      this._quad1 = q;
      return this._symbols.findName(q);
    } 
    byte[] inBuf = this._inputBuffer;
    int inPtr = this._inputPtr;
    int q1 = inBuf[inPtr++] & 0xFF;
    q1 = q1 << 8 | inBuf[inPtr++] & 0xFF;
    q1 = q1 << 8 | inBuf[inPtr++] & 0xFF;
    q1 = q1 << 8 | inBuf[inPtr++] & 0xFF;
    if (len < 9) {
      int q2 = _padQuadForNulls(inBuf[inPtr++]);
      int left = len - 5;
      if (left > 0) {
        q2 = (q2 << 8) + (inBuf[inPtr++] & 0xFF);
        if (left > 1) {
          q2 = (q2 << 8) + (inBuf[inPtr++] & 0xFF);
          if (left > 2)
            q2 = (q2 << 8) + (inBuf[inPtr++] & 0xFF); 
        } 
      } 
      this._quad1 = q1;
      this._quad2 = q2;
      return this._symbols.findName(q1, q2);
    } 
    int q2 = inBuf[inPtr++] & 0xFF;
    q2 = q2 << 8 | inBuf[inPtr++] & 0xFF;
    q2 = q2 << 8 | inBuf[inPtr++] & 0xFF;
    q2 = q2 << 8 | inBuf[inPtr++] & 0xFF;
    if (len < 13) {
      int q3 = _padQuadForNulls(inBuf[inPtr++]);
      int left = len - 9;
      if (left > 0) {
        q3 = (q3 << 8) + (inBuf[inPtr++] & 0xFF);
        if (left > 1) {
          q3 = (q3 << 8) + (inBuf[inPtr++] & 0xFF);
          if (left > 2)
            q3 = (q3 << 8) + (inBuf[inPtr++] & 0xFF); 
        } 
      } 
      this._quad1 = q1;
      this._quad2 = q2;
      this._quad3 = q3;
      return this._symbols.findName(q1, q2, q3);
    } 
    return _findDecodedLong(len, q1, q2);
  }
  
  private final String _findDecodedLong(int len, int q1, int q2) throws IOException {
    int bufLen = len + 3 >> 2;
    if (bufLen > this._quadBuffer.length)
      this._quadBuffer = _growArrayTo(this._quadBuffer, bufLen); 
    this._quadBuffer[0] = q1;
    this._quadBuffer[1] = q2;
    int offset = 2;
    int inPtr = this._inputPtr + 8;
    len -= 8;
    byte[] inBuf = this._inputBuffer;
    do {
      int q = inBuf[inPtr++] & 0xFF;
      q = q << 8 | inBuf[inPtr++] & 0xFF;
      q = q << 8 | inBuf[inPtr++] & 0xFF;
      q = q << 8 | inBuf[inPtr++] & 0xFF;
      this._quadBuffer[offset++] = q;
      len -= 4;
    } while (len > 3);
    if (len > 0) {
      int q = _padQuadForNulls(inBuf[inPtr]);
      if (len > 1) {
        q = (q << 8) + (inBuf[++inPtr] & 0xFF);
        if (len > 2)
          q = (q << 8) + (inBuf[++inPtr] & 0xFF); 
      } 
      this._quadBuffer[offset++] = q;
    } 
    return this._symbols.findName(this._quadBuffer, offset);
  }
  
  private final String _addDecodedToSymbols(int len, String name) throws IOException {
    if (len < 5)
      return this._symbols.addName(name, this._quad1); 
    if (len < 9)
      return this._symbols.addName(name, this._quad1, this._quad2); 
    if (len < 13)
      return this._symbols.addName(name, this._quad1, this._quad2, this._quad3); 
    int qlen = len + 3 >> 2;
    return this._symbols.addName(name, this._quadBuffer, qlen);
  }
  
  private static int[] _growArrayTo(int[] arr, int minSize) { return Arrays.copyOf(arr, minSize + 4); }
  
  private static final int _padQuadForNulls(int firstByte) throws IOException { return firstByte & 0xFF | 0xFFFFFF00; }
  
  protected void _skipIncomplete() throws IOException {
    this._tokenIncomplete = false;
    int type = this._typeByte >> 5 & 0x7;
    if (type != 3 && type != 2)
      _throwInternal(); 
    int lowBits = this._typeByte & 0x1F;
    if (lowBits <= 23) {
      if (lowBits > 0)
        _skipBytes(lowBits); 
      return;
    } 
    switch (lowBits) {
      case 24:
        _skipBytes(_decode8Bits());
        return;
      case 25:
        _skipBytes(_decode16Bits());
        return;
      case 26:
        _skipBytes(_decode32Bits());
        return;
      case 27:
        _skipBytesL(_decode64Bits());
        return;
      case 31:
        _skipChunked(type);
        return;
    } 
    _invalidToken(this._typeByte);
  }
  
  protected void _skipChunked(int expectedType) throws IOException {
    while (true) {
      if (this._inputPtr >= this._inputEnd)
        loadMoreGuaranteed(); 
      int ch = this._inputBuffer[this._inputPtr++] & 0xFF;
      if (ch == 255)
        return; 
      int type = ch >> 5;
      if (type != expectedType)
        throw _constructError("Mismatched chunk in chunked content: expected " + expectedType + " but encountered " + type); 
      int lowBits = ch & 0x1F;
      if (lowBits <= 23) {
        if (lowBits > 0)
          _skipBytes(lowBits); 
        continue;
      } 
      switch (lowBits) {
        case 24:
          _skipBytes(_decode8Bits());
          continue;
        case 25:
          _skipBytes(_decode16Bits());
          continue;
        case 26:
          _skipBytes(_decode32Bits());
          continue;
        case 27:
          _skipBytesL(_decode64Bits());
          continue;
        case 31:
          throw _constructReadException("Illegal chunked-length indicator within chunked-length value (type %d)", 
              
              Integer.valueOf(expectedType));
      } 
      _invalidToken(this._typeByte);
    } 
  }
  
  protected void _skipBytesL(long llen) throws IOException {
    while (llen > 2147483647L) {
      _skipBytes(2147483647);
      llen -= 2147483647L;
    } 
    _skipBytes((int)llen);
  }
  
  protected void _skipBytes(int len) throws IOException {
    while (true) {
      int toAdd = Math.min(len, this._inputEnd - this._inputPtr);
      this._inputPtr += toAdd;
      len -= toAdd;
      if (len <= 0)
        return; 
      loadMoreGuaranteed();
    } 
  }
  
  private final int _decodeTag(int lowBits) throws IOException {
    long l;
    if (lowBits <= 23)
      return lowBits; 
    switch (lowBits - 24) {
      case 0:
        return _decode8Bits();
      case 1:
        return _decode16Bits();
      case 2:
        return _decode32Bits();
      case 3:
        l = _decode64Bits();
        if (l < -2147483648L || l > 2147483647L)
          throw _constructReadException("Illegal Tag value: %d", Long.valueOf(l)); 
        return (int)l;
    } 
    throw _constructReadException("Invalid low bits for Tag token: 0x%s", 
        Integer.toHexString(lowBits));
  }
  
  private final int _decodeExplicitLength(int lowBits) throws IOException {
    long l;
    if (lowBits == 31)
      return -1; 
    if (lowBits <= 23)
      return lowBits; 
    switch (lowBits - 24) {
      case 0:
        return _decode8Bits();
      case 1:
        return _decode16Bits();
      case 2:
        return _decode32Bits();
      case 3:
        l = _decode64Bits();
        if (l < 0L || l > 2147483647L)
          throw _constructError("Illegal length for " + currentToken() + ": " + l); 
        return (int)l;
    } 
    throw _constructError(String.format("Invalid length for %s: 0x%02X,", new Object[] { currentToken(), Integer.valueOf(lowBits) }));
  }
  
  private int _decodeChunkLength(int expType) throws IOException {
    if (this._inputPtr >= this._inputEnd)
      loadMoreGuaranteed(); 
    int ch = this._inputBuffer[this._inputPtr++] & 0xFF;
    if (ch == 255)
      return -1; 
    int type = ch >> 5;
    if (type != expType)
      throw _constructError(String.format("Mismatched chunk in chunked content: expected major type %d but encountered %d (byte 0x%02X)", new Object[] { Integer.valueOf(expType), Integer.valueOf(type), Integer.valueOf(ch) })); 
    int len = _decodeExplicitLength(ch & 0x1F);
    if (len < 0)
      throw _constructReadException("Illegal chunked-length indicator within chunked-length value (major type %d)", 
          Integer.valueOf(expType)); 
    return len;
  }
  
  private float _decodeHalfSizeFloat() throws IOException {
    int i16 = _decode16Bits() & 0xFFFF;
    boolean neg = (i16 >> 15 != 0);
    int e = i16 >> 10 & 0x1F;
    int f = i16 & 0x3FF;
    if (e == 0) {
      float result = (float)(MATH_POW_2_NEG14 * f / MATH_POW_2_10);
      return neg ? -result : result;
    } 
    if (e == 31) {
      if (f != 0)
        return NaNF; 
      return neg ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;
    } 
    float result = (float)(Math.pow(2.0D, (e - 15)) * (1.0D + f / MATH_POW_2_10));
    return neg ? -result : result;
  }
  
  private final int _decode8Bits() {
    if (this._inputPtr >= this._inputEnd)
      loadMoreGuaranteed(); 
    return this._inputBuffer[this._inputPtr++] & 0xFF;
  }
  
  private final int _decode16Bits() {
    int ptr = this._inputPtr;
    if (ptr + 1 >= this._inputEnd)
      return _slow16(); 
    byte[] b = this._inputBuffer;
    int v = ((b[ptr] & 0xFF) << 8) + (b[ptr + 1] & 0xFF);
    this._inputPtr = ptr + 2;
    return v;
  }
  
  private final int _slow16() {
    if (this._inputPtr >= this._inputEnd)
      loadMoreGuaranteed(); 
    int v = this._inputBuffer[this._inputPtr++] & 0xFF;
    if (this._inputPtr >= this._inputEnd)
      loadMoreGuaranteed(); 
    return (v << 8) + (this._inputBuffer[this._inputPtr++] & 0xFF);
  }
  
  private final int _decode32Bits() {
    int ptr = this._inputPtr;
    if (ptr + 3 >= this._inputEnd)
      return _slow32(); 
    byte[] b = this._inputBuffer;
    int v = (b[ptr++] << 24) + ((b[ptr++] & 0xFF) << 16) + ((b[ptr++] & 0xFF) << 8) + (b[ptr++] & 0xFF);
    this._inputPtr = ptr;
    return v;
  }
  
  private final int _slow32() {
    if (this._inputPtr >= this._inputEnd)
      loadMoreGuaranteed(); 
    int v = this._inputBuffer[this._inputPtr++];
    if (this._inputPtr >= this._inputEnd)
      loadMoreGuaranteed(); 
    v = (v << 8) + (this._inputBuffer[this._inputPtr++] & 0xFF);
    if (this._inputPtr >= this._inputEnd)
      loadMoreGuaranteed(); 
    v = (v << 8) + (this._inputBuffer[this._inputPtr++] & 0xFF);
    if (this._inputPtr >= this._inputEnd)
      loadMoreGuaranteed(); 
    return (v << 8) + (this._inputBuffer[this._inputPtr++] & 0xFF);
  }
  
  private final long _decode64Bits() throws IOException {
    int ptr = this._inputPtr;
    if (ptr + 7 >= this._inputEnd)
      return _slow64(); 
    byte[] b = this._inputBuffer;
    int i1 = (b[ptr++] << 24) + ((b[ptr++] & 0xFF) << 16) + ((b[ptr++] & 0xFF) << 8) + (b[ptr++] & 0xFF);
    int i2 = (b[ptr++] << 24) + ((b[ptr++] & 0xFF) << 16) + ((b[ptr++] & 0xFF) << 8) + (b[ptr++] & 0xFF);
    this._inputPtr = ptr;
    return _long(i1, i2);
  }
  
  private final long _slow64() throws IOException { return _long(_decode32Bits(), _decode32Bits()); }
  
  private static final long _long(int i1, int i2) {
    long l1 = i1;
    long l2 = i2;
    l2 = l2 << 32 >>> 32;
    return (l1 << 32) + l2;
  }
  
  protected JsonToken _decodeUndefinedValue() throws IOException { return JsonToken.VALUE_NULL; }
  
  public JsonToken _decodeSimpleValue(int lowBits, int ch) throws IOException {
    if (lowBits > 24)
      _invalidToken(ch); 
    if (lowBits < 24) {
      this._numberInt = lowBits;
    } else {
      if (this._inputPtr >= this._inputEnd)
        loadMoreGuaranteed(); 
      this._numberInt = this._inputBuffer[this._inputPtr++] & 0xFF;
      if (this._numberInt < 32)
        throw _constructError("Invalid second byte for simple value: 0x" + 
            Integer.toHexString(this._numberInt) + " (only values 0x20 - 0xFF allowed)"); 
    } 
    this._numTypesValid = 1;
    return JsonToken.VALUE_NUMBER_INT;
  }
  
  private final int _decodeUTF8_3(int c1) throws IOException {
    c1 &= 0xF;
    int d = _nextByte();
    if ((d & 0xC0) != 128)
      _reportInvalidOther(d & 0xFF, this._inputPtr); 
    c = c1 << 6 | d & 0x3F;
    d = _nextByte();
    if ((d & 0xC0) != 128)
      _reportInvalidOther(d & 0xFF, this._inputPtr); 
    return c << 6 | d & 0x3F;
  }
  
  private final int _decodeChunkedUTF8_3(int c1) throws IOException {
    c1 &= 0xF;
    int d = _nextChunkedByte();
    if ((d & 0xC0) != 128)
      _reportInvalidOther(d & 0xFF, this._inputPtr); 
    c = c1 << 6 | d & 0x3F;
    d = _nextChunkedByte();
    if ((d & 0xC0) != 128)
      _reportInvalidOther(d & 0xFF, this._inputPtr); 
    return c << 6 | d & 0x3F;
  }
  
  private final int _decodeUTF8_4(int c) throws IOException {
    int d = _nextByte();
    if ((d & 0xC0) != 128)
      _reportInvalidOther(d & 0xFF, this._inputPtr); 
    c = (c & 0x7) << 6 | d & 0x3F;
    d = _nextByte();
    if ((d & 0xC0) != 128)
      _reportInvalidOther(d & 0xFF, this._inputPtr); 
    c = c << 6 | d & 0x3F;
    d = _nextByte();
    if ((d & 0xC0) != 128)
      _reportInvalidOther(d & 0xFF, this._inputPtr); 
    return (c << 6 | d & 0x3F) - 65536;
  }
  
  private final int _decodeChunkedUTF8_4(int c) throws IOException {
    int d = _nextChunkedByte();
    if ((d & 0xC0) != 128)
      _reportInvalidOther(d & 0xFF, this._inputPtr); 
    c = (c & 0x7) << 6 | d & 0x3F;
    d = _nextChunkedByte();
    if ((d & 0xC0) != 128)
      _reportInvalidOther(d & 0xFF, this._inputPtr); 
    c = c << 6 | d & 0x3F;
    d = _nextChunkedByte();
    if ((d & 0xC0) != 128)
      _reportInvalidOther(d & 0xFF, this._inputPtr); 
    return (c << 6 | d & 0x3F) - 65536;
  }
  
  protected boolean loadMore() {
    if (this._inputStream != null) {
      this._currInputProcessed += this._inputEnd;
      int count = this._inputStream.read(this._inputBuffer, 0, this._inputBuffer.length);
      if (count > 0) {
        this._inputPtr = 0;
        this._inputEnd = count;
        return true;
      } 
      _closeInput();
      if (count == 0)
        throw new IOException("InputStream.read() returned 0 characters when trying to read " + this._inputBuffer.length + " bytes"); 
    } 
    return false;
  }
  
  protected void loadMoreGuaranteed() throws IOException { if (!loadMore())
      _reportInvalidEOF();  }
  
  protected final void _loadToHaveAtLeast(int minAvailable) throws IOException {
    if (this._inputStream == null)
      throw _constructError("Needed to read " + minAvailable + " bytes, reached end-of-input"); 
    int amount = this._inputEnd - this._inputPtr;
    if (amount > 0 && this._inputPtr > 0) {
      System.arraycopy(this._inputBuffer, this._inputPtr, this._inputBuffer, 0, amount);
      this._inputEnd = amount;
    } else {
      this._inputEnd = 0;
    } 
    this._currInputProcessed += this._inputPtr;
    this._inputPtr = 0;
    while (this._inputEnd < minAvailable) {
      int count = this._inputStream.read(this._inputBuffer, this._inputEnd, this._inputBuffer.length - this._inputEnd);
      if (count < 1) {
        _closeInput();
        if (count == 0)
          throw new IOException("InputStream.read() returned 0 characters when trying to read " + amount + " bytes"); 
        throw _constructError("Needed to read " + minAvailable + " bytes, missed " + minAvailable + " before end-of-input");
      } 
      this._inputEnd += count;
    } 
  }
  
  protected final boolean _tryToLoadToHaveAtLeast(int minAvailable) throws IOException {
    if (this._inputStream == null)
      return false; 
    int amount = this._inputEnd - this._inputPtr;
    if (amount > 0 && this._inputPtr > 0) {
      System.arraycopy(this._inputBuffer, this._inputPtr, this._inputBuffer, 0, amount);
      this._inputEnd = amount;
    } else {
      this._inputEnd = 0;
    } 
    this._currInputProcessed += this._inputPtr;
    this._inputPtr = 0;
    while (this._inputEnd < minAvailable) {
      int count = this._inputStream.read(this._inputBuffer, this._inputEnd, this._inputBuffer.length - this._inputEnd);
      if (count < 1) {
        _closeInput();
        return false;
      } 
      this._inputEnd += count;
    } 
    return true;
  }
  
  protected ByteArrayBuilder _getByteArrayBuilder() {
    if (this._byteArrayBuilder == null) {
      this._byteArrayBuilder = new ByteArrayBuilder();
    } else {
      this._byteArrayBuilder.reset();
    } 
    return this._byteArrayBuilder;
  }
  
  protected void _closeInput() throws IOException {
    if (this._inputStream != null) {
      if (this._ioContext.isResourceManaged() || isEnabled(StreamReadFeature.AUTO_CLOSE_SOURCE))
        this._inputStream.close(); 
      this._inputStream = null;
    } 
  }
  
  protected void _handleEOF() throws IOException {
    if (this._streamReadContext.inRoot())
      return; 
    JsonLocation loc = this._streamReadContext.startLocation(this._ioContext.contentReference());
    String startLocDesc = (loc == null) ? "[N/A]" : loc.sourceDescription();
    if (this._streamReadContext.hasExpectedLength()) {
      int expMore = this._streamReadContext.getRemainingExpectedLength();
      if (this._streamReadContext.inArray()) {
        _reportInvalidEOF(String.format(" in Array value: expected %d more elements (start token at %s)", new Object[] { Integer.valueOf(expMore), startLocDesc }), null);
      } else {
        _reportInvalidEOF(String.format(" in Object value: expected %d more properties (start token at %s)", new Object[] { Integer.valueOf(expMore), startLocDesc }), null);
      } 
    } else if (this._streamReadContext.inArray()) {
      _reportInvalidEOF(String.format(" in Array value: expected an element or close marker (0xFF) (start token at %s)", new Object[] { startLocDesc }), null);
    } else {
      _reportInvalidEOF(String.format(" in Object value: expected a property or close marker (0xFF) (start token at %s)", new Object[] { startLocDesc }), null);
    } 
  }
  
  protected JsonToken _eofAsNextToken() throws IOException {
    this._tagValues.clear();
    close();
    _handleEOF();
    return this._currToken = null;
  }
  
  protected void _invalidToken(int ch) throws IOException {
    ch &= 0xFF;
    if (ch == 255)
      throw _constructError("Mismatched BREAK byte (0xFF): encountered where value expected"); 
    throw _constructError("Invalid CBOR value token (first byte): 0x" + Integer.toHexString(ch));
  }
  
  protected void _reportUnexpectedBreak() throws IOException {
    if (this._streamReadContext.inRoot())
      throw _constructError("Unexpected Break (0xFF) token in Root context"); 
    throw _constructError("Unexpected Break (0xFF) token in definite length (" + this._streamReadContext
        .getExpectedLength() + ") " + (
        this._streamReadContext.inObject() ? "Object" : "Array"));
  }
  
  protected void _reportInvalidChar(int c) throws IOException {
    if (c < 32)
      _throwInvalidSpace(c); 
    _reportInvalidInitial(c);
  }
  
  protected void _reportInvalidInitial(int mask) throws IOException { _reportError("Invalid UTF-8 start byte 0x" + Integer.toHexString(mask)); }
  
  protected void _reportInvalidOther(int mask) throws IOException { _reportError("Invalid UTF-8 middle byte 0x" + Integer.toHexString(mask)); }
  
  protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException {
    this._inputPtr = ptr;
    _reportInvalidOther(mask);
  }
  
  protected void _reportIncompleteBinaryRead(int expLen, int actLen) throws JsonParseException { _reportInvalidEOF(String.format(" for Binary value: expected %d bytes, only found %d", new Object[] { Integer.valueOf(expLen), Integer.valueOf(actLen) }), this._currToken); }
  
  private String _reportTruncatedUTF8InName(int strLenBytes, int truncatedCharOffset, int firstUTFByteValue, int bytesExpected) throws IOException {
    throw _constructReadException(String.format("Truncated UTF-8 character in Map key (%d bytes): byte 0x%02X at offset #%d indicated %d more bytes needed", new Object[] { Integer.valueOf(strLenBytes), Integer.valueOf(firstUTFByteValue), Integer.valueOf(truncatedCharOffset), Integer.valueOf(bytesExpected) }));
  }
  
  private static final BigInteger BIT_63 = BigInteger.ONE.shiftLeft(63);
  
  private final BigInteger _bigPositive(long l) {
    BigInteger biggie = BigInteger.valueOf(l << true >>> true);
    return biggie.or(BIT_63);
  }
  
  private final BigInteger _bigNegative(long l) {
    BigInteger unsignedBase = _bigPositive(l);
    return unsignedBase.negate().subtract(BigInteger.ONE);
  }
  
  private void createChildArrayContext(int len) throws IOException {
    this._streamReadContext = this._streamReadContext.createChildArrayContext(len);
    streamReadConstraints().validateNestingDepth(this._streamReadContext.getNestingDepth());
  }
  
  private void createChildObjectContext(int len) throws IOException {
    this._streamReadContext = this._streamReadContext.createChildObjectContext(len);
    streamReadConstraints().validateNestingDepth(this._streamReadContext.getNestingDepth());
  }
}
