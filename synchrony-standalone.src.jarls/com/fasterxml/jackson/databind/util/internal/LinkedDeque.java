package com.fasterxml.jackson.databind.util.internal;

import java.util.AbstractCollection;
import java.util.Collection;
import java.util.Deque;
import java.util.Iterator;
import java.util.NoSuchElementException;

final class LinkedDeque<E extends Linked<E>> extends AbstractCollection<E> implements Deque<E> {
  E first;
  
  E last;
  
  void linkFirst(E e) {
    E f = (E)this.first;
    this.first = e;
    if (f == null) {
      this.last = e;
    } else {
      f.setPrevious(e);
      e.setNext(f);
    } 
  }
  
  void linkLast(E e) {
    E l = (E)this.last;
    this.last = e;
    if (l == null) {
      this.first = e;
    } else {
      l.setNext(e);
      e.setPrevious(l);
    } 
  }
  
  E unlinkFirst() {
    E f = (E)this.first;
    E next = (E)f.getNext();
    f.setNext(null);
    this.first = next;
    if (next == null) {
      this.last = null;
    } else {
      next.setPrevious(null);
    } 
    return f;
  }
  
  E unlinkLast() {
    E l = (E)this.last;
    E prev = (E)l.getPrevious();
    l.setPrevious(null);
    this.last = prev;
    if (prev == null) {
      this.first = null;
    } else {
      prev.setNext(null);
    } 
    return l;
  }
  
  void unlink(E e) {
    E prev = (E)e.getPrevious();
    E next = (E)e.getNext();
    if (prev == null) {
      this.first = next;
    } else {
      prev.setNext(next);
      e.setPrevious(null);
    } 
    if (next == null) {
      this.last = prev;
    } else {
      next.setPrevious(prev);
      e.setNext(null);
    } 
  }
  
  public boolean isEmpty() { return (this.first == null); }
  
  void checkNotEmpty() {
    if (isEmpty())
      throw new NoSuchElementException(); 
  }
  
  public int size() {
    int size = 0;
    for (E e = (E)this.first; e != null; e = (E)e.getNext())
      size++; 
    return size;
  }
  
  public void clear() {
    for (E e = (E)this.first; e != null; ) {
      E next = (E)e.getNext();
      e.setPrevious(null);
      e.setNext(null);
      e = next;
    } 
    this.first = this.last = null;
  }
  
  public boolean contains(Object o) { return (o instanceof Linked && contains((Linked)o)); }
  
  boolean contains(Linked<?> e) {
    return (e.getPrevious() != null || e
      .getNext() != null || e == this.first);
  }
  
  public void moveToFront(E e) {
    if (e != this.first) {
      unlink(e);
      linkFirst(e);
    } 
  }
  
  public void moveToBack(E e) {
    if (e != this.last) {
      unlink(e);
      linkLast(e);
    } 
  }
  
  public E peek() { return (E)peekFirst(); }
  
  public E peekFirst() { return (E)this.first; }
  
  public E peekLast() { return (E)this.last; }
  
  public E getFirst() {
    checkNotEmpty();
    return (E)peekFirst();
  }
  
  public E getLast() {
    checkNotEmpty();
    return (E)peekLast();
  }
  
  public E element() { return (E)getFirst(); }
  
  public boolean offer(E e) { return offerLast(e); }
  
  public boolean offerFirst(E e) {
    if (contains(e))
      return false; 
    linkFirst(e);
    return true;
  }
  
  public boolean offerLast(E e) {
    if (contains(e))
      return false; 
    linkLast(e);
    return true;
  }
  
  public boolean add(E e) { return offerLast(e); }
  
  public void addFirst(E e) {
    if (!offerFirst(e))
      throw new IllegalArgumentException(); 
  }
  
  public void addLast(E e) {
    if (!offerLast(e))
      throw new IllegalArgumentException(); 
  }
  
  public E poll() { return (E)pollFirst(); }
  
  public E pollFirst() { return (E)(isEmpty() ? null : unlinkFirst()); }
  
  public E pollLast() { return (E)(isEmpty() ? null : unlinkLast()); }
  
  public E remove() { return (E)removeFirst(); }
  
  public boolean remove(Object o) { return (o instanceof Linked && remove((Linked)o)); }
  
  boolean remove(E e) {
    if (contains(e)) {
      unlink(e);
      return true;
    } 
    return false;
  }
  
  public E removeFirst() {
    checkNotEmpty();
    return (E)pollFirst();
  }
  
  public boolean removeFirstOccurrence(Object o) { return remove(o); }
  
  public E removeLast() {
    checkNotEmpty();
    return (E)pollLast();
  }
  
  public boolean removeLastOccurrence(Object o) { return remove(o); }
  
  public boolean removeAll(Collection<?> c) {
    boolean modified = false;
    for (Object o : c)
      modified |= remove(o); 
    return modified;
  }
  
  public void push(E e) { addFirst(e); }
  
  public E pop() { return (E)removeFirst(); }
  
  public Iterator<E> iterator() { return new Object(this, this.first); }
  
  public Iterator<E> descendingIterator() { return new Object(this, this.last); }
}
