package com.fasterxml.jackson.databind.util.internal;

import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.util.AbstractMap;
import java.util.Collection;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicLongArray;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public final class PrivateMaxEntriesMap<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>, Serializable {
  static final int NCPU = Runtime.getRuntime().availableProcessors();
  
  static final long MAXIMUM_CAPACITY = 9223372034707292160L;
  
  static final int NUMBER_OF_READ_BUFFERS = Math.min(4, ceilingNextPowerOfTwo(NCPU));
  
  static final int READ_BUFFERS_MASK = NUMBER_OF_READ_BUFFERS - 1;
  
  static final int READ_BUFFER_THRESHOLD = 4;
  
  static final int READ_BUFFER_DRAIN_THRESHOLD = 8;
  
  static final int READ_BUFFER_SIZE = 16;
  
  static final int READ_BUFFER_INDEX_MASK = 15;
  
  static final int WRITE_BUFFER_DRAIN_THRESHOLD = 16;
  
  final ConcurrentMap<K, Node<K, V>> data;
  
  final int concurrencyLevel;
  
  final long[] readBufferReadCount;
  
  final LinkedDeque<Node<K, V>> evictionDeque;
  
  final AtomicLong weightedSize;
  
  final AtomicLong capacity;
  
  final Lock evictionLock;
  
  final Queue<Runnable> writeBuffer;
  
  final AtomicLongArray readBufferWriteCount;
  
  final AtomicLongArray readBufferDrainAtWriteCount;
  
  final AtomicReferenceArray<Node<K, V>> readBuffers;
  
  final AtomicReference<DrainStatus> drainStatus;
  
  Set<K> keySet;
  
  Collection<V> values;
  
  Set<Map.Entry<K, V>> entrySet;
  
  static final long serialVersionUID = 1L;
  
  static int ceilingNextPowerOfTwo(int x) { return 1 << 32 - Integer.numberOfLeadingZeros(x - 1); }
  
  private static int readBufferIndex(int bufferIndex, int entryIndex) { return 16 * bufferIndex + entryIndex; }
  
  PrivateMaxEntriesMap(Builder<K, V> builder) {
    this.concurrencyLevel = builder.concurrencyLevel;
    this.capacity = new AtomicLong(Math.min(builder.capacity, 9223372034707292160L));
    this.data = new ConcurrentHashMap(builder.initialCapacity, 0.75F, this.concurrencyLevel);
    this.evictionLock = new ReentrantLock();
    this.weightedSize = new AtomicLong();
    this.evictionDeque = new LinkedDeque();
    this.writeBuffer = new ConcurrentLinkedQueue();
    this.drainStatus = new AtomicReference(DrainStatus.IDLE);
    this.readBufferReadCount = new long[NUMBER_OF_READ_BUFFERS];
    this.readBufferWriteCount = new AtomicLongArray(NUMBER_OF_READ_BUFFERS);
    this.readBufferDrainAtWriteCount = new AtomicLongArray(NUMBER_OF_READ_BUFFERS);
    this.readBuffers = new AtomicReferenceArray(NUMBER_OF_READ_BUFFERS * 16);
  }
  
  static void checkNotNull(Object o) {
    if (o == null)
      throw new NullPointerException(); 
  }
  
  static void checkArgument(boolean expression) {
    if (!expression)
      throw new IllegalArgumentException(); 
  }
  
  static void checkState(boolean expression) {
    if (!expression)
      throw new IllegalStateException(); 
  }
  
  public long capacity() { return this.capacity.get(); }
  
  public void setCapacity(long capacity) {
    checkArgument((capacity >= 0L));
    this.evictionLock.lock();
    try {
      this.capacity.lazySet(Math.min(capacity, 9223372034707292160L));
      drainBuffers();
      evict();
    } finally {
      this.evictionLock.unlock();
    } 
  }
  
  boolean hasOverflowed() { return (this.weightedSize.get() > this.capacity.get()); }
  
  void evict() {
    while (hasOverflowed()) {
      Node<K, V> node = (Node)this.evictionDeque.poll();
      if (node == null)
        return; 
      this.data.remove(node.key, node);
      makeDead(node);
    } 
  }
  
  void afterRead(Node<K, V> node) {
    int bufferIndex = readBufferIndex();
    long writeCount = recordRead(bufferIndex, node);
    drainOnReadIfNeeded(bufferIndex, writeCount);
  }
  
  static int readBufferIndex() { return (int)Thread.currentThread().getId() & READ_BUFFERS_MASK; }
  
  long recordRead(int bufferIndex, Node<K, V> node) {
    long writeCount = this.readBufferWriteCount.get(bufferIndex);
    this.readBufferWriteCount.lazySet(bufferIndex, writeCount + 1L);
    int index = (int)(writeCount & 0xFL);
    this.readBuffers.lazySet(readBufferIndex(bufferIndex, index), node);
    return writeCount;
  }
  
  void drainOnReadIfNeeded(int bufferIndex, long writeCount) {
    long pending = writeCount - this.readBufferDrainAtWriteCount.get(bufferIndex);
    boolean delayable = (pending < 4L);
    DrainStatus status = (DrainStatus)this.drainStatus.get();
    if (status.shouldDrainBuffers(delayable))
      tryToDrainBuffers(); 
  }
  
  void afterWrite(Runnable task) {
    this.writeBuffer.add(task);
    this.drainStatus.lazySet(DrainStatus.REQUIRED);
    tryToDrainBuffers();
  }
  
  void tryToDrainBuffers() {
    if (this.evictionLock.tryLock())
      try {
        this.drainStatus.lazySet(DrainStatus.PROCESSING);
        drainBuffers();
      } finally {
        this.drainStatus.compareAndSet(DrainStatus.PROCESSING, DrainStatus.IDLE);
        this.evictionLock.unlock();
      }  
  }
  
  void drainBuffers() {
    drainReadBuffers();
    drainWriteBuffer();
  }
  
  void drainReadBuffers() {
    int start = (int)Thread.currentThread().getId();
    int end = start + NUMBER_OF_READ_BUFFERS;
    for (int i = start; i < end; i++)
      drainReadBuffer(i & READ_BUFFERS_MASK); 
  }
  
  void drainReadBuffer(int bufferIndex) {
    long writeCount = this.readBufferWriteCount.get(bufferIndex);
    for (int i = 0; i < 8; i++) {
      int index = (int)(this.readBufferReadCount[bufferIndex] & 0xFL);
      int arrayIndex = readBufferIndex(bufferIndex, index);
      Node<K, V> node = (Node)this.readBuffers.get(arrayIndex);
      if (node == null)
        break; 
      this.readBuffers.lazySet(arrayIndex, null);
      applyRead(node);
      this.readBufferReadCount[bufferIndex] = this.readBufferReadCount[bufferIndex] + 1L;
    } 
    this.readBufferDrainAtWriteCount.lazySet(bufferIndex, writeCount);
  }
  
  void applyRead(Node<K, V> node) {
    if (this.evictionDeque.contains(node))
      this.evictionDeque.moveToBack(node); 
  }
  
  void drainWriteBuffer() {
    for (int i = 0; i < 16; i++) {
      Runnable task = (Runnable)this.writeBuffer.poll();
      if (task == null)
        break; 
      task.run();
    } 
  }
  
  boolean tryToRetire(Node<K, V> node, WeightedValue<V> expect) {
    if (expect.isAlive()) {
      WeightedValue<V> retired = new WeightedValue<V>(expect.value, -expect.weight);
      return node.compareAndSet(expect, retired);
    } 
    return false;
  }
  
  void makeRetired(Node<K, V> node) {
    WeightedValue<V> retired;
    WeightedValue<V> current;
    do {
      current = (WeightedValue)node.get();
      if (!current.isAlive())
        return; 
      retired = new WeightedValue<V>(current.value, -current.weight);
    } while (!node.compareAndSet(current, retired));
  }
  
  void makeDead(Node<K, V> node) {
    WeightedValue<V> dead, current;
    do {
      current = (WeightedValue)node.get();
      dead = new WeightedValue<V>(current.value, 0);
    } while (!node.compareAndSet(current, dead));
    this.weightedSize.lazySet(this.weightedSize.get() - Math.abs(current.weight));
  }
  
  public boolean isEmpty() { return this.data.isEmpty(); }
  
  public int size() { return this.data.size(); }
  
  public void clear() {
    this.evictionLock.lock();
    try {
      Node<K, V> node;
      while ((node = (Node)this.evictionDeque.poll()) != null) {
        this.data.remove(node.key, node);
        makeDead(node);
      } 
      for (int i = 0; i < this.readBuffers.length(); i++)
        this.readBuffers.lazySet(i, null); 
      Runnable task;
      while ((task = (Runnable)this.writeBuffer.poll()) != null)
        task.run(); 
    } finally {
      this.evictionLock.unlock();
    } 
  }
  
  public boolean containsKey(Object key) { return this.data.containsKey(key); }
  
  public boolean containsValue(Object value) {
    checkNotNull(value);
    for (Node<K, V> node : this.data.values()) {
      if (node.getValue().equals(value))
        return true; 
    } 
    return false;
  }
  
  public V get(Object key) {
    Node<K, V> node = (Node)this.data.get(key);
    if (node == null)
      return null; 
    afterRead(node);
    return (V)node.getValue();
  }
  
  public V put(K key, V value) { return (V)put(key, value, false); }
  
  public V putIfAbsent(K key, V value) { return (V)put(key, value, true); }
  
  V put(K key, V value, boolean onlyIfAbsent) {
    WeightedValue<V> oldWeightedValue;
    Node<K, V> prior;
    checkNotNull(key);
    checkNotNull(value);
    int weight = 1;
    WeightedValue<V> weightedValue = new WeightedValue<V>(value, 1);
    Node<K, V> node = new Node<K, V>(key, weightedValue);
    label21: while (true) {
      prior = (Node)this.data.putIfAbsent(node.key, node);
      if (prior == null) {
        afterWrite(new AddTask(this, node, 1));
        return null;
      } 
      if (onlyIfAbsent) {
        afterRead(prior);
        return (V)prior.getValue();
      } 
      do {
        oldWeightedValue = (WeightedValue)prior.get();
        if (!oldWeightedValue.isAlive())
          continue label21; 
      } while (!prior.compareAndSet(oldWeightedValue, weightedValue));
      break;
    } 
    int weightedDifference = 1 - oldWeightedValue.weight;
    if (weightedDifference == 0) {
      afterRead(prior);
    } else {
      afterWrite(new UpdateTask(this, prior, weightedDifference));
    } 
    return (V)oldWeightedValue.value;
  }
  
  public V remove(Object key) {
    Node<K, V> node = (Node)this.data.remove(key);
    if (node == null)
      return null; 
    makeRetired(node);
    afterWrite(new RemovalTask(this, node));
    return (V)node.getValue();
  }
  
  public boolean remove(Object key, Object value) {
    Node<K, V> node = (Node)this.data.get(key);
    if (node == null || value == null)
      return false; 
    WeightedValue<V> weightedValue = (WeightedValue)node.get();
    while (weightedValue.contains(value)) {
      if (tryToRetire(node, weightedValue)) {
        if (this.data.remove(key, node)) {
          afterWrite(new RemovalTask(this, node));
          return true;
        } 
        break;
      } 
      weightedValue = (WeightedValue)node.get();
      if (weightedValue.isAlive());
    } 
    return false;
  }
  
  public V replace(K key, V value) {
    WeightedValue<V> oldWeightedValue;
    checkNotNull(key);
    checkNotNull(value);
    int weight = 1;
    WeightedValue<V> weightedValue = new WeightedValue<V>(value, 1);
    Node<K, V> node = (Node)this.data.get(key);
    if (node == null)
      return null; 
    do {
      oldWeightedValue = (WeightedValue)node.get();
      if (!oldWeightedValue.isAlive())
        return null; 
    } while (!node.compareAndSet(oldWeightedValue, weightedValue));
    int weightedDifference = 1 - oldWeightedValue.weight;
    if (weightedDifference == 0) {
      afterRead(node);
    } else {
      afterWrite(new UpdateTask(this, node, weightedDifference));
    } 
    return (V)oldWeightedValue.value;
  }
  
  public boolean replace(K key, V oldValue, V newValue) {
    WeightedValue<V> weightedValue;
    checkNotNull(key);
    checkNotNull(oldValue);
    checkNotNull(newValue);
    int weight = 1;
    WeightedValue<V> newWeightedValue = new WeightedValue<V>(newValue, 1);
    Node<K, V> node = (Node)this.data.get(key);
    if (node == null)
      return false; 
    do {
      weightedValue = (WeightedValue)node.get();
      if (!weightedValue.isAlive() || !weightedValue.contains(oldValue))
        return false; 
    } while (!node.compareAndSet(weightedValue, newWeightedValue));
    int weightedDifference = 1 - weightedValue.weight;
    if (weightedDifference == 0) {
      afterRead(node);
    } else {
      afterWrite(new UpdateTask(this, node, weightedDifference));
    } 
    return true;
  }
  
  public Set<K> keySet() {
    Set<K> ks = this.keySet;
    return (ks == null) ? (this.keySet = new KeySet(this)) : ks;
  }
  
  public Collection<V> values() {
    Collection<V> vs = this.values;
    return (vs == null) ? (this.values = new Values(this)) : vs;
  }
  
  public Set<Map.Entry<K, V>> entrySet() {
    Set<Map.Entry<K, V>> es = this.entrySet;
    return (es == null) ? (this.entrySet = new EntrySet(this)) : es;
  }
  
  Object writeReplace() { return new SerializationProxy(this); }
  
  private void readObject(ObjectInputStream stream) throws InvalidObjectException { throw new InvalidObjectException("Proxy required"); }
}
