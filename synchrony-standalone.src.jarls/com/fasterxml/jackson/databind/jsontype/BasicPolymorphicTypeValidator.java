package com.fasterxml.jackson.databind.jsontype;

import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.cfg.MapperConfig;
import java.io.Serializable;
import java.util.Set;

public class BasicPolymorphicTypeValidator extends PolymorphicTypeValidator.Base implements Serializable {
  private static final long serialVersionUID = 1L;
  
  protected final Set<Class<?>> _invalidBaseTypes;
  
  protected final TypeMatcher[] _baseTypeMatchers;
  
  protected final NameMatcher[] _subTypeNameMatchers;
  
  protected final TypeMatcher[] _subClassMatchers;
  
  protected BasicPolymorphicTypeValidator(Set<Class<?>> invalidBaseTypes, TypeMatcher[] baseTypeMatchers, NameMatcher[] subTypeNameMatchers, TypeMatcher[] subClassMatchers) {
    this._invalidBaseTypes = invalidBaseTypes;
    this._baseTypeMatchers = baseTypeMatchers;
    this._subTypeNameMatchers = subTypeNameMatchers;
    this._subClassMatchers = subClassMatchers;
  }
  
  public static Builder builder() { return new Builder(); }
  
  public PolymorphicTypeValidator.Validity validateBaseType(MapperConfig<?> ctxt, JavaType baseType) {
    Class<?> rawBase = baseType.getRawClass();
    if (this._invalidBaseTypes != null && 
      this._invalidBaseTypes.contains(rawBase))
      return PolymorphicTypeValidator.Validity.DENIED; 
    if (this._baseTypeMatchers != null)
      for (TypeMatcher m : this._baseTypeMatchers) {
        if (m.match(ctxt, rawBase))
          return PolymorphicTypeValidator.Validity.ALLOWED; 
      }  
    return PolymorphicTypeValidator.Validity.INDETERMINATE;
  }
  
  public PolymorphicTypeValidator.Validity validateSubClassName(MapperConfig<?> ctxt, JavaType baseType, String subClassName) throws JsonMappingException {
    if (this._subTypeNameMatchers != null)
      for (NameMatcher m : this._subTypeNameMatchers) {
        if (m.match(ctxt, subClassName))
          return PolymorphicTypeValidator.Validity.ALLOWED; 
      }  
    return PolymorphicTypeValidator.Validity.INDETERMINATE;
  }
  
  public PolymorphicTypeValidator.Validity validateSubType(MapperConfig<?> ctxt, JavaType baseType, JavaType subType) throws JsonMappingException {
    if (this._subClassMatchers != null) {
      Class<?> subClass = subType.getRawClass();
      for (TypeMatcher m : this._subClassMatchers) {
        if (m.match(ctxt, subClass))
          return PolymorphicTypeValidator.Validity.ALLOWED; 
      } 
    } 
    return PolymorphicTypeValidator.Validity.INDETERMINATE;
  }
}
