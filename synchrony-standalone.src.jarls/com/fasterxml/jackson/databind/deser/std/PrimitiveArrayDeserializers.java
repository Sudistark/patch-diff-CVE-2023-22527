package com.fasterxml.jackson.databind.deser.std;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.BeanProperty;
import com.fasterxml.jackson.databind.DeserializationConfig;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.deser.ContextualDeserializer;
import com.fasterxml.jackson.databind.deser.NullValueProvider;
import com.fasterxml.jackson.databind.deser.impl.NullsConstantProvider;
import com.fasterxml.jackson.databind.deser.impl.NullsFailProvider;
import com.fasterxml.jackson.databind.exc.InvalidNullException;
import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
import com.fasterxml.jackson.databind.type.LogicalType;
import com.fasterxml.jackson.databind.util.AccessPattern;
import java.io.IOException;
import java.lang.reflect.Array;
import java.util.Objects;

public abstract class PrimitiveArrayDeserializers<T> extends StdDeserializer<T> implements ContextualDeserializer {
  protected final Boolean _unwrapSingle;
  
  private Object _emptyValue;
  
  protected final NullValueProvider _nuller;
  
  protected PrimitiveArrayDeserializers(Class<T> cls) {
    super(cls);
    this._unwrapSingle = null;
    this._nuller = null;
  }
  
  protected PrimitiveArrayDeserializers(PrimitiveArrayDeserializers<?> base, NullValueProvider nuller, Boolean unwrapSingle) {
    super(base._valueClass);
    this._unwrapSingle = unwrapSingle;
    this._nuller = nuller;
  }
  
  public static JsonDeserializer<?> forType(Class<?> rawType) {
    if (rawType == int.class)
      return IntDeser.instance; 
    if (rawType == long.class)
      return LongDeser.instance; 
    if (rawType == byte.class)
      return new ByteDeser(); 
    if (rawType == short.class)
      return new ShortDeser(); 
    if (rawType == float.class)
      return new FloatDeser(); 
    if (rawType == double.class)
      return new DoubleDeser(); 
    if (rawType == boolean.class)
      return new BooleanDeser(); 
    if (rawType == char.class)
      return new CharDeser(); 
    throw new IllegalStateException();
  }
  
  public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException {
    Boolean unwrapSingle = findFormatFeature(ctxt, property, this._valueClass, JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);
    NullsFailProvider nullsFailProvider = null;
    Nulls nullStyle = findContentNullStyle(ctxt, property);
    if (nullStyle == Nulls.SKIP) {
      NullsConstantProvider nullsConstantProvider = NullsConstantProvider.skipper();
    } else if (nullStyle == Nulls.FAIL) {
      if (property == null) {
        NullsFailProvider nullsFailProvider1 = NullsFailProvider.constructForRootValue(ctxt.constructType(this._valueClass.getComponentType()));
      } else {
        nullsFailProvider = NullsFailProvider.constructForProperty(property, property.getType().getContentType());
      } 
    } 
    if (Objects.equals(unwrapSingle, this._unwrapSingle) && nullsFailProvider == this._nuller)
      return this; 
    return withResolved(nullsFailProvider, unwrapSingle);
  }
  
  protected abstract T _concat(T paramT1, T paramT2);
  
  protected abstract T handleSingleElementUnwrapped(JsonParser paramJsonParser, DeserializationContext paramDeserializationContext) throws IOException;
  
  protected abstract PrimitiveArrayDeserializers<?> withResolved(NullValueProvider paramNullValueProvider, Boolean paramBoolean);
  
  protected abstract T _constructEmpty();
  
  public LogicalType logicalType() { return LogicalType.Array; }
  
  public Boolean supportsUpdate(DeserializationConfig config) { return Boolean.TRUE; }
  
  public AccessPattern getEmptyAccessPattern() { return AccessPattern.CONSTANT; }
  
  public Object getEmptyValue(DeserializationContext ctxt) throws JsonMappingException {
    Object empty = this._emptyValue;
    if (empty == null)
      this._emptyValue = empty = _constructEmpty(); 
    return empty;
  }
  
  public Object deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException { return typeDeserializer.deserializeTypedFromArray(p, ctxt); }
  
  public T deserialize(JsonParser p, DeserializationContext ctxt, T existing) throws IOException {
    T newValue = (T)deserialize(p, ctxt);
    if (existing == null)
      return newValue; 
    int len = Array.getLength(existing);
    if (len == 0)
      return newValue; 
    return (T)_concat(existing, newValue);
  }
  
  protected T handleNonArray(JsonParser p, DeserializationContext ctxt) throws IOException {
    if (p.hasToken(JsonToken.VALUE_STRING))
      return (T)_deserializeFromString(p, ctxt); 
    boolean canWrap = (this._unwrapSingle == Boolean.TRUE || (this._unwrapSingle == null && ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)));
    if (canWrap)
      return (T)handleSingleElementUnwrapped(p, ctxt); 
    return (T)ctxt.handleUnexpectedToken(this._valueClass, p);
  }
  
  protected void _failOnNull(DeserializationContext ctxt) throws IOException { throw InvalidNullException.from(ctxt, null, ctxt.constructType(this._valueClass)); }
}
