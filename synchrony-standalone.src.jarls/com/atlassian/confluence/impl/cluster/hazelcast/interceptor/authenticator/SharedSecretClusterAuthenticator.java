package com.atlassian.confluence.impl.cluster.hazelcast.interceptor.authenticator;

import com.atlassian.security.utils.ConstantTimeComparison;
import com.atlassian.util.profiling.Ticker;
import com.atlassian.util.profiling.Timers;
import com.hazelcast.nio.ObjectDataInput;
import com.hazelcast.nio.ObjectDataOutput;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.Random;
import javax.annotation.Nonnull;
import org.bouncycastle.crypto.generators.SCrypt;
import org.bouncycastle.util.encoders.Hex;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SharedSecretClusterAuthenticator implements ClusterAuthenticator {
  private static final int ITERATIONS = 32768;
  
  private static final int MAX_NETWORK_BYTEARRAY_SIZE = 1024;
  
  private static final int NONCE_BYTES = 16;
  
  private static final Random RND = new SecureRandom();
  
  private static final String VERIFICATION_FAILED_MESSAGE = "Cluster authentication failed. Please make sure all members share the same value for cluster name and shared secret.";
  
  private static final int VERSION = 2;
  
  private static final Logger log = LoggerFactory.getLogger(SharedSecretClusterAuthenticator.class);
  
  private final String groupName;
  
  private final String sharedSecret;
  
  public SharedSecretClusterAuthenticator(String groupName, String sharedSecret) {
    this.groupName = groupName;
    this.sharedSecret = sharedSecret;
  }
  
  public ClusterAuthenticationResult authenticate(@Nonnull ClusterJoinRequest request) {
    Ticker ignored = Timers.start("Cluster member authentication mode - " + request.getJoinMode());
    try {
      ClusterAuthenticationResult clusterAuthenticationResult = runMutualChallengeResponse(request);
      if (ignored != null)
        ignored.close(); 
      return clusterAuthenticationResult;
    } catch (Throwable throwable) {
      if (ignored != null)
        try {
          ignored.close();
        } catch (Throwable throwable1) {
          throwable.addSuppressed(throwable1);
        }  
      throw throwable;
    } 
  }
  
  private static byte[] readByteArray(ObjectDataInput in) throws IOException {
    int length = in.readInt();
    if (length > 1024 || length <= 0)
      throw new IOException("Unable to read array: invalid length: " + length); 
    byte[] array = new byte[length];
    in.readFully(array);
    return array;
  }
  
  private static void writeByteArray(ObjectDataOutput out, byte[] array) throws IOException {
    out.writeInt(array.length);
    out.write(array);
  }
  
  private byte[] generateSalt(byte[] firstNonce, byte[] secondNonce, String address, int port, boolean isConnect) throws IOException {
    ByteArrayOutputStream salt = new ByteArrayOutputStream();
    try {
      DataOutputStream data = new DataOutputStream(salt);
      try {
        data.write(firstNonce);
        data.write(secondNonce);
        data.writeBoolean(isConnect);
        data.writeInt(port);
        data.write(address.getBytes(StandardCharsets.UTF_8));
        byte[] arrayOfByte = salt.toByteArray();
        data.close();
        salt.close();
        return arrayOfByte;
      } catch (Throwable throwable) {
        try {
          data.close();
        } catch (Throwable throwable1) {
          throwable.addSuppressed(throwable1);
        } 
        throw throwable;
      } 
    } catch (Throwable throwable) {
      try {
        salt.close();
      } catch (Throwable throwable1) {
        throwable.addSuppressed(throwable1);
      } 
      throw throwable;
    } 
  }
  
  private byte[] generateKey(byte[] salt) throws UnsupportedEncodingException {
    Ticker ignored = Timers.start("Generate key");
    try {
      byte[] arrayOfByte = SCrypt.generate(this.sharedSecret.getBytes(StandardCharsets.UTF_8.name()), salt, 32768, 8, 1, 32);
      if (ignored != null)
        ignored.close(); 
      return arrayOfByte;
    } catch (Throwable throwable) {
      if (ignored != null)
        try {
          ignored.close();
        } catch (Throwable throwable1) {
          throwable.addSuppressed(throwable1);
        }  
      throw throwable;
    } 
  }
  
  private ClusterAuthenticationResult runMutualChallengeResponse(ClusterJoinRequest request) {
    try {
      log.debug("Inside runMutualChallengeResponse ... ClusterJoinRequest : {}", request);
      ObjectDataInput in = request.in();
      ObjectDataOutput out = request.out();
      boolean isConnecting = (request.getJoinMode() == ClusterJoinMode.CONNECT);
      if (!verifyGroupName(in, out, isConnecting))
        return new ClusterAuthenticationResult(false, "Cluster authentication failed. Please make sure all members share the same value for cluster name and shared secret."); 
      out.writeInt(2);
      int version = in.readInt();
      if (version == -100)
        return new ClusterAuthenticationResult(false, "Application version is incompatible. Zero Downtime Upgrades between this application version and older versions are not supported."); 
      if (version != 2)
        return new ClusterAuthenticationResult(false, "Cannot form a cluster with nodes using different Confluence versions"); 
      Nonce localNonce = generateNewNonce();
      log.trace("Generated: {}", localNonce);
      Nonce remoteNonce = new Nonce();
      Response response = new Response();
      if (isConnecting) {
        remoteNonce.readData(in);
        localNonce.writeData(out);
        response.readData(in);
        createResponse(localNonce, remoteNonce, request.getLocalAddress(), request.getLocalPort(), isConnecting)
          .writeData(out);
      } else {
        localNonce.writeData(out);
        remoteNonce.readData(in);
        createResponse(localNonce, remoteNonce, request.getLocalAddress(), request.getLocalPort(), isConnecting)
          .writeData(out);
        response.readData(in);
      } 
      return verifyResponse(response, localNonce, remoteNonce, isConnecting, request.getRemoteAddress(), request
          .getRemotePort());
    } catch (IOException e) {
      return new ClusterAuthenticationResult(false, "Unexpected bytes from remote node, closing socket");
    } 
  }
  
  private Response createResponse(Nonce localNonce, Nonce remoteNonce, String localAddress, int localPort, boolean isConnect) throws IOException {
    byte[] salt = generateSalt(Nonce.access$000(localNonce), Nonce.access$000(remoteNonce), localAddress, localPort, isConnect);
    byte[] key = generateKey(salt);
    Response response = new Response(key);
    log.debug("Created: {}", response);
    return response;
  }
  
  private Nonce generateNewNonce() {
    byte[] localNonce = new byte[16];
    RND.nextBytes(localNonce);
    return new Nonce(localNonce);
  }
  
  private ClusterAuthenticationResult verifyResponse(Response message, Nonce localNonce, Nonce remoteNonce, boolean isConnect, String address, int port) throws IOException {
    byte[] proof = Response.access$100(message);
    byte[] salt = generateSalt(Nonce.access$000(remoteNonce), Nonce.access$000(localNonce), address, port, !isConnect);
    byte[] key = generateKey(salt);
    if (log.isTraceEnabled()) {
      log.trace("Verification: remote proof: {}", Hex.toHexString(proof));
      log.trace("Verification: local proof:  {}", Hex.toHexString(key));
    } 
    return new ClusterAuthenticationResult(ConstantTimeComparison.isEqual(key, proof), "Cluster authentication failed. Please make sure all members share the same value for cluster name and shared secret.");
  }
  
  private boolean verifyGroupName(ObjectDataInput in, ObjectDataOutput out, boolean isConnecting) throws IOException {
    if (isConnecting) {
      out.writeUTF(this.groupName);
      String remoteGroup = in.readUTF();
      return this.groupName.equals(remoteGroup);
    } 
    String remoteGroup = in.readUTF();
    boolean result = this.groupName.equals(remoteGroup);
    if (result) {
      out.writeUTF(this.groupName);
    } else {
      out.writeUTF("");
    } 
    return result;
  }
}
