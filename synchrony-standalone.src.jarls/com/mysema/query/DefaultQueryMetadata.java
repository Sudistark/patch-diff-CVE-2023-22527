package com.mysema.query;

import com.google.common.base.Objects;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.mysema.query.types.Expression;
import com.mysema.query.types.ExpressionUtils;
import com.mysema.query.types.OrderSpecifier;
import com.mysema.query.types.ParamExpression;
import com.mysema.query.types.ParamsVisitor;
import com.mysema.query.types.Path;
import com.mysema.query.types.Predicate;
import com.mysema.query.types.ValidatingVisitor;
import com.mysema.query.util.CollectionUtils;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.Nullable;

public class DefaultQueryMetadata implements QueryMetadata, Cloneable {
  private static final long serialVersionUID = 317736313966701232L;
  
  private boolean distinct;
  
  private Set<Expression<?>> exprInJoins = ImmutableSet.of();
  
  private List<Expression<?>> groupBy = ImmutableList.of();
  
  @Nullable
  private Predicate having;
  
  private List<JoinExpression> joins = ImmutableList.of();
  
  private Expression<?> joinTarget;
  
  private JoinType joinType;
  
  @Nullable
  private Predicate joinCondition;
  
  private Set<JoinFlag> joinFlags = ImmutableSet.of();
  
  @Nullable
  private QueryModifiers modifiers = QueryModifiers.EMPTY;
  
  private List<OrderSpecifier<?>> orderBy = ImmutableList.of();
  
  private List<Expression<?>> projection = ImmutableList.of();
  
  private Map<ParamExpression<?>, Object> params = ImmutableMap.of();
  
  private boolean unique;
  
  @Nullable
  private Predicate where;
  
  private Set<QueryFlag> flags = ImmutableSet.of();
  
  private boolean extractParams = true;
  
  private boolean validate = true;
  
  private ValidatingVisitor validatingVisitor = ValidatingVisitor.DEFAULT;
  
  private static Predicate and(Predicate lhs, Predicate rhs) {
    if (lhs == null)
      return rhs; 
    return ExpressionUtils.and(lhs, rhs);
  }
  
  public DefaultQueryMetadata noValidate() {
    this.validate = false;
    return this;
  }
  
  public void addFlag(QueryFlag flag) { this.flags = CollectionUtils.addSorted(this.flags, flag); }
  
  public void addJoinFlag(JoinFlag flag) { this.joinFlags = CollectionUtils.addSorted(this.joinFlags, flag); }
  
  public void addGroupBy(Expression<?> o) { this.groupBy = CollectionUtils.add(this.groupBy, o); }
  
  public void addHaving(Predicate e) {
    if (e == null)
      return; 
    e = (Predicate)ExpressionUtils.extract(e);
    if (e != null)
      this.having = and(this.having, e); 
  }
  
  private void addLastJoin() {
    if (this.joinTarget != null) {
      this.joins = CollectionUtils.add(this.joins, new JoinExpression(this.joinType, this.joinTarget, this.joinCondition, this.joinFlags));
      this.joinType = null;
      this.joinTarget = null;
      this.joinCondition = null;
      this.joinFlags = ImmutableSet.of();
    } 
  }
  
  public void addJoin(JoinType joinType, Expression<?> expr) {
    addLastJoin();
    if (!this.exprInJoins.contains(expr)) {
      if (expr instanceof Path && ((Path)expr).getMetadata().isRoot()) {
        this.exprInJoins = CollectionUtils.add(this.exprInJoins, expr);
      } else {
        validate(expr);
      } 
      this.joinType = joinType;
      this.joinTarget = expr;
    } else if (this.validate) {
      throw new IllegalStateException(expr + " is already used");
    } 
  }
  
  public void addJoinCondition(Predicate o) {
    validate(o);
    this.joinCondition = and(this.joinCondition, o);
  }
  
  public void addOrderBy(OrderSpecifier<?> o) { this.orderBy = CollectionUtils.add(this.orderBy, o); }
  
  public void addProjection(Expression<?> o) {
    validate(o);
    this.projection = CollectionUtils.add(this.projection, o);
  }
  
  public void addWhere(Predicate e) {
    if (e == null)
      return; 
    e = (Predicate)ExpressionUtils.extract(e);
    if (e != null) {
      validate(e);
      this.where = and(this.where, e);
    } 
  }
  
  public void clearOrderBy() { this.orderBy = ImmutableList.of(); }
  
  public void clearProjection() { this.projection = ImmutableList.of(); }
  
  public void clearWhere() { this.where = new BooleanBuilder(); }
  
  public QueryMetadata clone() {
    try {
      DefaultQueryMetadata clone = (DefaultQueryMetadata)super.clone();
      clone.exprInJoins = CollectionUtils.copyOf(this.exprInJoins);
      clone.groupBy = CollectionUtils.copyOf(this.groupBy);
      clone.having = this.having;
      clone.joins = CollectionUtils.copyOf(this.joins);
      clone.joinTarget = this.joinTarget;
      clone.joinCondition = this.joinCondition;
      clone.joinFlags = CollectionUtils.copyOf(this.joinFlags);
      clone.joinType = this.joinType;
      clone.modifiers = this.modifiers;
      clone.orderBy = CollectionUtils.copyOf(this.orderBy);
      clone.projection = CollectionUtils.copyOf(this.projection);
      clone.params = CollectionUtils.copyOf(this.params);
      clone.where = this.where;
      clone.flags = CollectionUtils.copyOfSorted(this.flags);
      return clone;
    } catch (CloneNotSupportedException e) {
      throw new QueryException(e);
    } 
  }
  
  public List<Expression<?>> getGroupBy() { return this.groupBy; }
  
  public Predicate getHaving() { return this.having; }
  
  public List<JoinExpression> getJoins() {
    if (this.joinTarget == null)
      return this.joins; 
    List<JoinExpression> j = Lists.newArrayList(this.joins);
    j.add(new JoinExpression(this.joinType, this.joinTarget, this.joinCondition, this.joinFlags));
    return j;
  }
  
  @Nullable
  public QueryModifiers getModifiers() { return this.modifiers; }
  
  public Map<ParamExpression<?>, Object> getParams() { return this.params; }
  
  public List<OrderSpecifier<?>> getOrderBy() { return this.orderBy; }
  
  public List<Expression<?>> getProjection() { return this.projection; }
  
  public Predicate getWhere() { return this.where; }
  
  public boolean isDistinct() { return this.distinct; }
  
  public boolean isUnique() { return this.unique; }
  
  public void reset() {
    clearProjection();
    this.params = ImmutableMap.of();
    this.modifiers = QueryModifiers.EMPTY;
  }
  
  public void setDistinct(boolean distinct) { this.distinct = distinct; }
  
  public void setLimit(Long limit) {
    if (this.modifiers == null || this.modifiers.getOffset() == null) {
      this.modifiers = QueryModifiers.limit(limit.longValue());
    } else {
      this.modifiers = new QueryModifiers(limit, this.modifiers.getOffset());
    } 
  }
  
  public void setModifiers(@Nullable QueryModifiers restriction) { this.modifiers = restriction; }
  
  public void setOffset(Long offset) {
    if (this.modifiers == null || this.modifiers.getLimit() == null) {
      this.modifiers = QueryModifiers.offset(offset.longValue());
    } else {
      this.modifiers = new QueryModifiers(this.modifiers.getLimit(), offset);
    } 
  }
  
  public void setUnique(boolean unique) { this.unique = unique; }
  
  public <T> void setParam(ParamExpression<T> param, T value) { this.params = CollectionUtils.put(this.params, param, value); }
  
  public Set<QueryFlag> getFlags() { return this.flags; }
  
  public boolean hasFlag(QueryFlag flag) { return this.flags.contains(flag); }
  
  public void removeFlag(QueryFlag flag) { this.flags = CollectionUtils.removeSorted(this.flags, flag); }
  
  private void validate(Expression<?> expr) {
    if (this.extractParams)
      expr.accept(ParamsVisitor.DEFAULT, this); 
    if (this.validate)
      this.exprInJoins = (Set)expr.accept(this.validatingVisitor, this.exprInJoins); 
  }
  
  public void setValidate(boolean v) { this.validate = v; }
  
  public void setValidatingVisitor(ValidatingVisitor visitor) { this.validatingVisitor = visitor; }
  
  public boolean equals(Object o) {
    if (o instanceof QueryMetadata) {
      QueryMetadata q = (QueryMetadata)o;
      return (q.getFlags().equals(this.flags) && q
        .getGroupBy().equals(this.groupBy) && 
        Objects.equal(q.getHaving(), this.having) && q
        .isDistinct() == this.distinct && q
        .isUnique() == this.unique && q
        .getJoins().equals(getJoins()) && 
        Objects.equal(q.getModifiers(), this.modifiers) && q
        .getOrderBy().equals(this.orderBy) && q
        .getParams().equals(this.params) && q
        .getProjection().equals(this.projection) && 
        Objects.equal(q.getWhere(), this.where));
    } 
    return false;
  }
  
  public int hashCode() {
    return Objects.hashCode(new Object[] { this.flags, this.groupBy, this.having, getJoins(), this.modifiers, this.orderBy, this.params, this.projection, 
          Boolean.valueOf(this.unique), this.where });
  }
}
