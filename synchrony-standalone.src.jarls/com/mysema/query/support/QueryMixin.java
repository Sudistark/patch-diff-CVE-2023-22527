package com.mysema.query.support;

import com.mysema.query.DefaultQueryMetadata;
import com.mysema.query.JoinFlag;
import com.mysema.query.JoinType;
import com.mysema.query.QueryFlag;
import com.mysema.query.QueryMetadata;
import com.mysema.query.QueryModifiers;
import com.mysema.query.Tuple;
import com.mysema.query.types.CollectionExpression;
import com.mysema.query.types.Expression;
import com.mysema.query.types.ExpressionUtils;
import com.mysema.query.types.FactoryExpression;
import com.mysema.query.types.FactoryExpressionUtils;
import com.mysema.query.types.MapExpression;
import com.mysema.query.types.OrderSpecifier;
import com.mysema.query.types.ParamExpression;
import com.mysema.query.types.Path;
import com.mysema.query.types.Predicate;
import com.mysema.query.types.ProjectionRole;
import com.mysema.query.types.QTuple;
import com.mysema.query.types.SubQueryExpression;

public class QueryMixin<T> extends Object {
  private final QueryMetadata metadata;
  
  private final boolean expandAnyPaths;
  
  private ReplaceVisitor replaceVisitor;
  
  private T self;
  
  public QueryMixin() { this(null, new DefaultQueryMetadata(), true); }
  
  public QueryMixin(QueryMetadata metadata) { this(null, metadata, true); }
  
  public QueryMixin(QueryMetadata metadata, boolean expandAnyPaths) { this(null, metadata, expandAnyPaths); }
  
  public QueryMixin(T self) { this(self, new DefaultQueryMetadata(), true); }
  
  public QueryMixin(T self, QueryMetadata metadata) { this(self, metadata, true); }
  
  public QueryMixin(T self, QueryMetadata metadata, boolean expandAnyPaths) {
    this.self = self;
    this.metadata = metadata;
    this.expandAnyPaths = expandAnyPaths;
  }
  
  public T addJoin(JoinType joinType, Expression<?> target) {
    this.metadata.addJoin(joinType, target);
    return (T)this.self;
  }
  
  public T addFlag(QueryFlag queryFlag) {
    this.metadata.addFlag(queryFlag);
    return (T)this.self;
  }
  
  public T addJoinFlag(JoinFlag flag) {
    this.metadata.addJoinFlag(flag);
    return (T)this.self;
  }
  
  public T removeFlag(QueryFlag queryFlag) {
    this.metadata.removeFlag(queryFlag);
    return (T)this.self;
  }
  
  public <E> Expression<E> addProjection(Expression<E> e) {
    e = convert(e, false);
    this.metadata.addProjection(e);
    return e;
  }
  
  public T addProjection(Expression... o) {
    for (Expression<?> e : o)
      this.metadata.addProjection(convert(e, false)); 
    return (T)this.self;
  }
  
  private <P extends Path<?>> P assertRoot(P p) {
    if (!p.getRoot().equals(p))
      throw new IllegalArgumentException(p + " is not a root path"); 
    return p;
  }
  
  private Path<?> normalizePath(Path<?> expr) {
    Context context = new Context();
    Path<?> replaced = (Path)expr.accept(CollectionAnyVisitor.DEFAULT, context);
    if (!replaced.equals(expr)) {
      for (int i = 0; i < context.paths.size(); i++) {
        Path path = ((Path)context.paths.get(i)).getMetadata().getParent();
        Path replacement = (Path)context.replacements.get(i);
        innerJoin(path, replacement);
      } 
      return replaced;
    } 
    return expr;
  }
  
  public <RT> Expression<RT> convert(Expression<RT> expr, boolean forOrder) {
    Expression expression;
    if (this.expandAnyPaths)
      if (expr instanceof Path) {
        expression = normalizePath((Path)expr);
      } else if (expression != null) {
        if (this.replaceVisitor == null)
          this.replaceVisitor = new Object(this); 
        expression = (Expression)expression.accept(this.replaceVisitor, null);
      }  
    if (expression instanceof ProjectionRole)
      return convert(((ProjectionRole)expression).getProjection(), forOrder); 
    if (expression instanceof FactoryExpression && !(expression instanceof FactoryExpressionUtils.FactoryExpressionAdapter))
      return FactoryExpressionUtils.wrap((FactoryExpression)expression); 
    return expression;
  }
  
  public Expression<Tuple> createProjection(Expression[] args) { return new QTuple(args); }
  
  protected <D> Expression<D> createAlias(Expression<?> expr, Path<?> alias) {
    assertRoot(alias);
    return ExpressionUtils.as(expr, alias);
  }
  
  public final T distinct() {
    this.metadata.setDistinct(true);
    return (T)this.self;
  }
  
  public final T from(Expression<?> arg) {
    this.metadata.addJoin(JoinType.DEFAULT, arg);
    return (T)this.self;
  }
  
  public final T from(Expression... args) {
    for (Expression<?> arg : args)
      this.metadata.addJoin(JoinType.DEFAULT, arg); 
    return (T)this.self;
  }
  
  public final T fullJoin(Expression<?> target) {
    this.metadata.addJoin(JoinType.FULLJOIN, target);
    return (T)this.self;
  }
  
  public final <P> T fullJoin(Expression<P> target, Path<P> alias) {
    this.metadata.addJoin(JoinType.FULLJOIN, createAlias(target, alias));
    return (T)this.self;
  }
  
  public final <P> T fullJoin(CollectionExpression<?, P> target, Path<P> alias) {
    this.metadata.addJoin(JoinType.FULLJOIN, createAlias(target, alias));
    return (T)this.self;
  }
  
  public final <P> T fullJoin(MapExpression<?, P> target, Path<P> alias) {
    this.metadata.addJoin(JoinType.FULLJOIN, createAlias(target, alias));
    return (T)this.self;
  }
  
  public final <P> T fullJoin(SubQueryExpression<P> target, Path<?> alias) {
    this.metadata.addJoin(JoinType.FULLJOIN, createAlias(target, alias));
    return (T)this.self;
  }
  
  public final QueryMetadata getMetadata() { return this.metadata; }
  
  public final T getSelf() { return (T)this.self; }
  
  public final T groupBy(Expression<?> e) {
    this.metadata.addGroupBy(e);
    return (T)this.self;
  }
  
  public final T groupBy(Expression... o) {
    for (Expression<?> e : o)
      this.metadata.addGroupBy(e); 
    return (T)this.self;
  }
  
  public final T having(Predicate e) {
    this.metadata.addHaving(normalize(e, false));
    return (T)this.self;
  }
  
  public final T having(Predicate... o) {
    for (Predicate e : o)
      this.metadata.addHaving(normalize(e, false)); 
    return (T)this.self;
  }
  
  public final <P> T innerJoin(Expression<P> target) {
    this.metadata.addJoin(JoinType.INNERJOIN, target);
    return (T)this.self;
  }
  
  public final <P> T innerJoin(Expression<P> target, Path<P> alias) {
    this.metadata.addJoin(JoinType.INNERJOIN, createAlias(target, alias));
    return (T)this.self;
  }
  
  public final <P> T innerJoin(CollectionExpression<?, P> target, Path<P> alias) {
    this.metadata.addJoin(JoinType.INNERJOIN, createAlias(target, alias));
    return (T)this.self;
  }
  
  public final <P> T innerJoin(MapExpression<?, P> target, Path<P> alias) {
    this.metadata.addJoin(JoinType.INNERJOIN, createAlias(target, alias));
    return (T)this.self;
  }
  
  public final <P> T innerJoin(SubQueryExpression<P> target, Path<?> alias) {
    this.metadata.addJoin(JoinType.INNERJOIN, createAlias(target, alias));
    return (T)this.self;
  }
  
  public final boolean isDistinct() { return this.metadata.isDistinct(); }
  
  public final boolean isUnique() { return this.metadata.isUnique(); }
  
  public final <P> T join(Expression<P> target) {
    this.metadata.addJoin(JoinType.JOIN, target);
    return (T)this.self;
  }
  
  public final <P> T join(Expression<P> target, Path<P> alias) {
    this.metadata.addJoin(JoinType.JOIN, createAlias(target, alias));
    return (T)getSelf();
  }
  
  public final <P> T join(CollectionExpression<?, P> target, Path<P> alias) {
    this.metadata.addJoin(JoinType.JOIN, createAlias(target, alias));
    return (T)getSelf();
  }
  
  public final <P> T join(MapExpression<?, P> target, Path<P> alias) {
    this.metadata.addJoin(JoinType.JOIN, createAlias(target, alias));
    return (T)getSelf();
  }
  
  public final <P> T join(SubQueryExpression<P> target, Path<?> alias) {
    this.metadata.addJoin(JoinType.JOIN, createAlias(target, alias));
    return (T)this.self;
  }
  
  public final <P> T leftJoin(Expression<P> target) {
    this.metadata.addJoin(JoinType.LEFTJOIN, target);
    return (T)this.self;
  }
  
  public final <P> T leftJoin(Expression<P> target, Path<P> alias) {
    this.metadata.addJoin(JoinType.LEFTJOIN, createAlias(target, alias));
    return (T)getSelf();
  }
  
  public final <P> T leftJoin(CollectionExpression<?, P> target, Path<P> alias) {
    this.metadata.addJoin(JoinType.LEFTJOIN, createAlias(target, alias));
    return (T)getSelf();
  }
  
  public final <P> T leftJoin(MapExpression<?, P> target, Path<P> alias) {
    this.metadata.addJoin(JoinType.LEFTJOIN, createAlias(target, alias));
    return (T)getSelf();
  }
  
  public final <P> T leftJoin(SubQueryExpression<P> target, Path<?> alias) {
    this.metadata.addJoin(JoinType.LEFTJOIN, createAlias(target, alias));
    return (T)this.self;
  }
  
  public final T limit(long limit) {
    this.metadata.setLimit(Long.valueOf(limit));
    return (T)this.self;
  }
  
  public final T offset(long offset) {
    this.metadata.setOffset(Long.valueOf(offset));
    return (T)this.self;
  }
  
  public final T on(Predicate condition) {
    this.metadata.addJoinCondition(normalize(condition, false));
    return (T)this.self;
  }
  
  public final T on(Predicate... conditions) {
    for (Predicate condition : conditions)
      this.metadata.addJoinCondition(normalize(condition, false)); 
    return (T)this.self;
  }
  
  public final T orderBy(OrderSpecifier<?> spec) {
    Expression<?> e = convert(spec.getTarget(), true);
    if (!spec.getTarget().equals(e)) {
      this.metadata.addOrderBy(new OrderSpecifier(spec.getOrder(), e, spec.getNullHandling()));
    } else {
      this.metadata.addOrderBy(spec);
    } 
    return (T)this.self;
  }
  
  public final T orderBy(OrderSpecifier... o) {
    for (OrderSpecifier<?> spec : o)
      orderBy(spec); 
    return (T)this.self;
  }
  
  public final T restrict(QueryModifiers modifiers) {
    this.metadata.setModifiers(modifiers);
    return (T)this.self;
  }
  
  public final <P> T rightJoin(Expression<P> target) {
    this.metadata.addJoin(JoinType.RIGHTJOIN, target);
    return (T)this.self;
  }
  
  public final <P> T rightJoin(Expression<P> target, Path<P> alias) {
    this.metadata.addJoin(JoinType.RIGHTJOIN, createAlias(target, alias));
    return (T)getSelf();
  }
  
  public final <P> T rightJoin(CollectionExpression<?, P> target, Path<P> alias) {
    this.metadata.addJoin(JoinType.RIGHTJOIN, createAlias(target, alias));
    return (T)getSelf();
  }
  
  public final <P> T rightJoin(MapExpression<?, P> target, Path<P> alias) {
    this.metadata.addJoin(JoinType.RIGHTJOIN, createAlias(target, alias));
    return (T)getSelf();
  }
  
  public final <P> T rightJoin(SubQueryExpression<P> target, Path<?> alias) {
    this.metadata.addJoin(JoinType.RIGHTJOIN, createAlias(target, alias));
    return (T)this.self;
  }
  
  public final <P> T set(ParamExpression<P> param, P value) {
    this.metadata.setParam(param, value);
    return (T)this.self;
  }
  
  public final void setDistinct(boolean distinct) { this.metadata.setDistinct(distinct); }
  
  public final void setSelf(T self) { this.self = self; }
  
  public final void setUnique(boolean unique) { this.metadata.setUnique(unique); }
  
  public final T where(Predicate e) {
    this.metadata.addWhere(normalize(e, true));
    return (T)this.self;
  }
  
  public final T where(Predicate... o) {
    for (Predicate e : o)
      this.metadata.addWhere(normalize(e, true)); 
    return (T)this.self;
  }
  
  protected Predicate normalize(Predicate condition, boolean where) { return condition; }
  
  public final boolean equals(Object o) {
    if (o == this)
      return true; 
    if (o instanceof QueryMixin) {
      QueryMixin q = (QueryMixin)o;
      return q.metadata.equals(this.metadata);
    } 
    return false;
  }
  
  public int hashCode() { return this.metadata.hashCode(); }
  
  public String toString() { return this.metadata.toString(); }
}
