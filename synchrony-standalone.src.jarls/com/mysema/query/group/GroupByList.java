package com.mysema.query.group;

import com.google.common.base.Objects;
import com.google.common.collect.Lists;
import com.mysema.commons.lang.CloseableIterator;
import com.mysema.query.Projectable;
import com.mysema.query.Tuple;
import com.mysema.query.types.Expression;
import com.mysema.query.types.FactoryExpression;
import com.mysema.query.types.FactoryExpressionUtils;
import com.mysema.query.types.QTuple;
import java.util.List;

public class GroupByList<K, V> extends AbstractGroupByTransformer<K, List<V>> {
  GroupByList(Expression<K> key, Expression... expressions) { super(key, expressions); }
  
  public List<V> transform(Projectable projectable) {
    FactoryExpression<Tuple> expr = FactoryExpressionUtils.wrap(new QTuple(this.expressions));
    boolean hasGroups = false;
    for (Expression<?> e : expr.getArgs())
      hasGroups |= e instanceof GroupExpression; 
    if (hasGroups)
      expr = withoutGroupExpressions(expr); 
    CloseableIterator<Tuple> iter = projectable.iterate(expr);
    List<V> list = Lists.newArrayList();
    GroupImpl group = null;
    K groupId = null;
    while (iter.hasNext()) {
      Object[] row = ((Tuple)iter.next()).toArray();
      if (group == null) {
        group = new GroupImpl(this.groupExpressions, this.maps);
        groupId = (K)row[0];
      } else if (!Objects.equal(groupId, row[0])) {
        list.add(transform(group));
        group = new GroupImpl(this.groupExpressions, this.maps);
        groupId = (K)row[0];
      } 
      group.add(row);
    } 
    if (group != null)
      list.add(transform(group)); 
    iter.close();
    return list;
  }
  
  protected V transform(Group group) { return (V)group; }
}
