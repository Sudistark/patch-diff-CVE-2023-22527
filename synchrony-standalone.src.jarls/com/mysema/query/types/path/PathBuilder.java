package com.mysema.query.types.path;

import com.google.common.collect.Maps;
import com.mysema.query.types.EntityPath;
import com.mysema.query.types.Path;
import com.mysema.query.types.PathMetadata;
import com.mysema.query.types.PathMetadataFactory;
import java.lang.reflect.Array;
import java.util.Map;

public class PathBuilder<T> extends EntityPathBase<T> {
  private static final long serialVersionUID = -1666357914232685088L;
  
  private final Map<String, PathBuilder<?>> properties = Maps.newHashMap();
  
  private final Map<Path<?>, Object> propertyMetadata = Maps.newHashMap();
  
  private final PathBuilderValidator validator;
  
  public PathBuilder(Class<? extends T> type, PathMetadata<?> pathMetadata, PathBuilderValidator validator) {
    super(type, pathMetadata);
    this.validator = validator;
  }
  
  public PathBuilder(Class<? extends T> type, PathMetadata<?> pathMetadata) { this(type, pathMetadata, PathBuilderValidator.DEFAULT); }
  
  public PathBuilder(Class<? extends T> type, String variable, PathBuilderValidator validator) { this(type, PathMetadataFactory.forVariable(variable), validator); }
  
  public PathBuilder(Class<? extends T> type, String variable) { this(type, PathMetadataFactory.forVariable(variable), PathBuilderValidator.DEFAULT); }
  
  private <P extends Path<?>> P addMetadataOf(P newPath, Path<?> path) {
    if (path.getMetadata().getParent() instanceof EntityPath) {
      EntityPath<?> parent = (EntityPath)path.getMetadata().getParent();
      this.propertyMetadata.put(newPath, parent.getMetadata(path));
    } 
    return newPath;
  }
  
  protected <T> Class<? extends T> validate(String property, Class<T> propertyType) {
    Class<T> validatedType = this.validator.validate(getType(), property, propertyType);
    if (validatedType != null)
      return validatedType; 
    throw new IllegalArgumentException("Illegal property " + property);
  }
  
  public Object getMetadata(Path<?> property) { return this.propertyMetadata.get(property); }
  
  public PathBuilder<Object> get(String property) {
    PathBuilder<Object> path = (PathBuilder)this.properties.get(property);
    if (path == null) {
      Class<?> vtype = validate(property, Object.class);
      path = new PathBuilder<Object>(vtype, forProperty(property), this.validator);
      this.properties.put(property, path);
    } 
    return path;
  }
  
  public <A> PathBuilder<A> get(String property, Class<A> type) {
    PathBuilder<A> path = (PathBuilder)this.properties.get(property);
    if (path == null || !type.isAssignableFrom(path.getType())) {
      Class<? extends A> vtype = validate(property, type);
      path = new PathBuilder<A>(vtype, forProperty(property), this.validator);
      this.properties.put(property, path);
    } 
    return path;
  }
  
  public <A, E> ArrayPath<A, E> getArray(String property, Class<A> type) {
    validate(property, Array.newInstance(type, 0).getClass());
    return createArray(property, type);
  }
  
  public BooleanPath get(BooleanPath path) {
    BooleanPath newPath = getBoolean(toString(path));
    return (BooleanPath)addMetadataOf(newPath, path);
  }
  
  public BooleanPath getBoolean(String propertyName) {
    validate(propertyName, Boolean.class);
    return createBoolean(propertyName);
  }
  
  public <A> CollectionPath<A, PathBuilder<A>> getCollection(String property, Class<A> type) {
    validate(property, java.util.Collection.class);
    return createCollection(property, type, PathBuilder.class, PathInits.DIRECT);
  }
  
  public <A, E extends com.mysema.query.types.expr.SimpleExpression<A>> CollectionPath<A, E> getCollection(String property, Class<A> type, Class<E> queryType) {
    validate(property, java.util.Collection.class);
    return createCollection(property, type, queryType, PathInits.DIRECT);
  }
  
  public <A extends Comparable<?>> ComparablePath<A> get(ComparablePath<A> path) {
    ComparablePath<A> newPath = getComparable(toString(path), path.getType());
    return (ComparablePath)addMetadataOf(newPath, path);
  }
  
  public <A extends Comparable<?>> ComparablePath<A> getComparable(String property, Class<A> type) {
    Class<? extends A> vtype = validate(property, type);
    return createComparable(property, vtype);
  }
  
  public <A extends Comparable<?>> DatePath<A> get(DatePath<A> path) {
    DatePath<A> newPath = getDate(toString(path), path.getType());
    return (DatePath)addMetadataOf(newPath, path);
  }
  
  public <A extends Comparable<?>> DatePath<A> getDate(String property, Class<A> type) {
    Class<? extends A> vtype = validate(property, type);
    return createDate(property, vtype);
  }
  
  public <A extends Comparable<?>> DateTimePath<A> get(DateTimePath<A> path) {
    DateTimePath<A> newPath = getDateTime(toString(path), path.getType());
    return (DateTimePath)addMetadataOf(newPath, path);
  }
  
  public <A extends Comparable<?>> DateTimePath<A> getDateTime(String property, Class<A> type) {
    Class<? extends A> vtype = validate(property, type);
    return createDateTime(property, vtype);
  }
  
  public <A extends Enum<A>> EnumPath<A> getEnum(String property, Class<A> type) {
    validate(property, type);
    return createEnum(property, type);
  }
  
  public <A extends Enum<A>> EnumPath<A> get(EnumPath<A> path) {
    EnumPath<A> newPath = getEnum(toString(path), path.getType());
    return (EnumPath)addMetadataOf(newPath, path);
  }
  
  public <A> ListPath<A, PathBuilder<A>> getList(String property, Class<A> type) {
    validate(property, java.util.List.class);
    return createList(property, type, PathBuilder.class, PathInits.DIRECT);
  }
  
  public <A, E extends com.mysema.query.types.expr.SimpleExpression<A>> ListPath<A, E> getList(String property, Class<A> type, Class<E> queryType) {
    validate(property, java.util.List.class);
    return createList(property, type, queryType, PathInits.DIRECT);
  }
  
  public <K, V> MapPath<K, V, PathBuilder<V>> getMap(String property, Class<K> key, Class<V> value) {
    validate(property, Map.class);
    return createMap(property, key, value, PathBuilder.class);
  }
  
  public <K, V, E extends com.mysema.query.types.expr.SimpleExpression<V>> MapPath<K, V, E> getMap(String property, Class<K> key, Class<V> value, Class<E> queryType) {
    validate(property, Map.class);
    return createMap(property, key, value, queryType);
  }
  
  public <A extends Number & Comparable<?>> NumberPath<A> get(NumberPath<A> path) {
    NumberPath<A> newPath = getNumber(toString(path), path.getType());
    return (NumberPath)addMetadataOf(newPath, path);
  }
  
  public <A extends Number & Comparable<?>> NumberPath<A> getNumber(String property, Class<A> type) {
    Class<? extends A> vtype = validate(property, type);
    return createNumber(property, vtype);
  }
  
  public <A> SetPath<A, PathBuilder<A>> getSet(String property, Class<A> type) {
    validate(property, java.util.Set.class);
    return createSet(property, type, PathBuilder.class, PathInits.DIRECT);
  }
  
  public <A, E extends com.mysema.query.types.expr.SimpleExpression<A>> SetPath<A, E> getSet(String property, Class<A> type, Class<E> queryType) {
    validate(property, java.util.Set.class);
    return createSet(property, type, queryType, PathInits.DIRECT);
  }
  
  public <A> SimplePath<A> get(Path<A> path) {
    SimplePath<A> newPath = getSimple(toString(path), path.getType());
    return (SimplePath)addMetadataOf(newPath, path);
  }
  
  public <A> SimplePath<A> getSimple(String property, Class<A> type) {
    Class<? extends A> vtype = validate(property, type);
    return createSimple(property, vtype);
  }
  
  public StringPath get(StringPath path) {
    StringPath newPath = getString(toString(path));
    return (StringPath)addMetadataOf(newPath, path);
  }
  
  public StringPath getString(String property) {
    validate(property, String.class);
    return createString(property);
  }
  
  public <A extends Comparable<?>> TimePath<A> get(TimePath<A> path) {
    TimePath<A> newPath = getTime(toString(path), path.getType());
    return (TimePath)addMetadataOf(newPath, path);
  }
  
  public <A extends Comparable<?>> TimePath<A> getTime(String property, Class<A> type) {
    Class<? extends A> vtype = validate(property, type);
    return createTime(property, vtype);
  }
  
  private String toString(Path<?> path) { return path.getMetadata().getElement().toString(); }
}
