package com.mysema.query.types.path;

import com.mysema.query.types.Expression;
import com.mysema.query.types.ExpressionException;
import com.mysema.query.types.ParametrizedPathImpl;
import com.mysema.query.types.Path;
import com.mysema.query.types.PathImpl;
import com.mysema.query.types.PathMetadata;
import com.mysema.query.types.PathMetadataFactory;
import com.mysema.query.types.Visitor;
import com.mysema.query.types.expr.MapExpressionBase;
import com.mysema.query.types.expr.SimpleExpression;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.Map;
import javax.annotation.Nullable;

public class MapPath<K, V, E extends SimpleExpression<? super V>> extends MapExpressionBase<K, V, E> implements Path<Map<K, V>> {
  private static final long serialVersionUID = -9113333728412016832L;
  
  private final Class<K> keyType;
  
  private final PathImpl<Map<K, V>> pathMixin;
  
  private final Class<E> queryType;
  
  @Nullable
  private Constructor<E> constructor;
  
  private final Class<V> valueType;
  
  public MapPath(Class<? super K> keyType, Class<? super V> valueType, Class<E> queryType, String variable) { this(keyType, valueType, queryType, PathMetadataFactory.forVariable(variable)); }
  
  public MapPath(Class<? super K> keyType, Class<? super V> valueType, Class<E> queryType, Path<?> parent, String property) { this(keyType, valueType, queryType, PathMetadataFactory.forProperty(parent, property)); }
  
  public MapPath(Class<? super K> keyType, Class<? super V> valueType, Class<E> queryType, PathMetadata<?> metadata) {
    super(new ParametrizedPathImpl(Map.class, metadata, new Class[] { keyType, valueType }));
    this.keyType = keyType;
    this.valueType = valueType;
    this.queryType = queryType;
    this.pathMixin = (PathImpl)this.mixin;
  }
  
  public final <R, C> R accept(Visitor<R, C> v, C context) { return (R)v.visit(this.pathMixin, context); }
  
  protected PathMetadata<K> forMapAccess(K key) { return PathMetadataFactory.forMapAccess(this, key); }
  
  protected PathMetadata<K> forMapAccess(Expression<K> key) { return PathMetadataFactory.forMapAccess(this, key); }
  
  public E get(Expression<K> key) {
    try {
      PathMetadata<K> md = forMapAccess(key);
      return (E)newInstance(md);
    } catch (NoSuchMethodException e) {
      throw new ExpressionException(e);
    } catch (InstantiationException e) {
      throw new ExpressionException(e);
    } catch (IllegalAccessException e) {
      throw new ExpressionException(e);
    } catch (InvocationTargetException e) {
      throw new ExpressionException(e);
    } 
  }
  
  public E get(K key) {
    try {
      PathMetadata<K> md = forMapAccess(key);
      return (E)newInstance(md);
    } catch (NoSuchMethodException e) {
      throw new ExpressionException(e);
    } catch (InstantiationException e) {
      throw new ExpressionException(e);
    } catch (IllegalAccessException e) {
      throw new ExpressionException(e);
    } catch (InvocationTargetException e) {
      throw new ExpressionException(e);
    } 
  }
  
  public Class<K> getKeyType() { return this.keyType; }
  
  public PathMetadata<?> getMetadata() { return this.pathMixin.getMetadata(); }
  
  public Path<?> getRoot() { return this.pathMixin.getRoot(); }
  
  public Class<V> getValueType() { return this.valueType; }
  
  public AnnotatedElement getAnnotatedElement() { return this.pathMixin.getAnnotatedElement(); }
  
  private E newInstance(PathMetadata<?> pm) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    if (this.constructor == null)
      if (Constants.isTyped(this.queryType)) {
        this.constructor = this.queryType.getConstructor(new Class[] { Class.class, PathMetadata.class });
      } else {
        this.constructor = this.queryType.getConstructor(new Class[] { PathMetadata.class });
      }  
    if (Constants.isTyped(this.queryType))
      return (E)(SimpleExpression)this.constructor.newInstance(new Object[] { getValueType(), pm }); 
    return (E)(SimpleExpression)this.constructor.newInstance(new Object[] { pm });
  }
  
  public Class<?> getParameter(int index) {
    if (index == 0)
      return this.keyType; 
    if (index == 1)
      return this.valueType; 
    throw new IndexOutOfBoundsException(String.valueOf(index));
  }
}
