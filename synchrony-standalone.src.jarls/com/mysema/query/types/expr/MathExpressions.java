package com.mysema.query.types.expr;

import com.mysema.query.types.ConstantImpl;
import com.mysema.query.types.Expression;
import com.mysema.query.types.Ops;

public final class MathExpressions {
  public static <A extends Number & Comparable<?>> NumberExpression<Double> acos(Expression<A> num) { return NumberOperation.create(Double.class, Ops.MathOps.ACOS, num); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<Double> asin(Expression<A> num) { return NumberOperation.create(Double.class, Ops.MathOps.ASIN, num); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<Double> atan(Expression<A> num) { return NumberOperation.create(Double.class, Ops.MathOps.ATAN, num); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<Double> cos(Expression<A> num) { return NumberOperation.create(Double.class, Ops.MathOps.COS, num); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<Double> cosh(Expression<A> num) { return NumberOperation.create(Double.class, Ops.MathOps.COSH, num); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<Double> cot(Expression<A> num) { return NumberOperation.create(Double.class, Ops.MathOps.COT, num); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<Double> coth(Expression<A> num) { return NumberOperation.create(Double.class, Ops.MathOps.COTH, num); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<Double> degrees(Expression<A> num) { return NumberOperation.create(Double.class, Ops.MathOps.DEG, num); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<Double> exp(Expression<A> num) { return NumberOperation.create(Double.class, Ops.MathOps.EXP, num); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<Double> ln(Expression<A> num) { return NumberOperation.create(Double.class, Ops.MathOps.LN, num); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<Double> log(Expression<A> num, int base) { return NumberOperation.create(Double.class, Ops.MathOps.LOG, num, ConstantImpl.create(base)); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<A> max(Expression<A> left, Expression<A> right) { return NumberExpression.max(left, right); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<A> min(Expression<A> left, Expression<A> right) { return NumberExpression.min(left, right); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<Double> power(Expression<A> num, int exponent) { return NumberOperation.create(Double.class, Ops.MathOps.POWER, num, ConstantImpl.create(exponent)); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<Double> radians(Expression<A> num) { return NumberOperation.create(Double.class, Ops.MathOps.RAD, num); }
  
  public static NumberExpression<Double> random() { return NumberExpression.random(); }
  
  public static NumberExpression<Double> random(int seed) { return NumberOperation.create(Double.class, Ops.MathOps.RANDOM2, ConstantImpl.create(seed)); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<A> round(Expression<A> num) { return NumberOperation.create(num.getType(), Ops.MathOps.ROUND, num); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<A> round(Expression<A> num, int s) { return NumberOperation.create(num.getType(), Ops.MathOps.ROUND2, num, ConstantImpl.create(s)); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<Integer> sign(Expression<A> num) { return NumberOperation.create(Integer.class, Ops.MathOps.SIGN, num); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<Double> sin(Expression<A> num) { return NumberOperation.create(Double.class, Ops.MathOps.SIN, num); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<Double> sinh(Expression<A> num) { return NumberOperation.create(Double.class, Ops.MathOps.SINH, num); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<Double> tan(Expression<A> num) { return NumberOperation.create(Double.class, Ops.MathOps.TAN, num); }
  
  public static <A extends Number & Comparable<?>> NumberExpression<Double> tanh(Expression<A> num) { return NumberOperation.create(Double.class, Ops.MathOps.TANH, num); }
}
