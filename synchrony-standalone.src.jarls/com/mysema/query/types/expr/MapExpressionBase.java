package com.mysema.query.types.expr;

import com.mysema.query.types.ConstantImpl;
import com.mysema.query.types.Expression;
import com.mysema.query.types.MapExpression;
import com.mysema.query.types.Ops;
import java.util.Map;
import javax.annotation.Nullable;

public abstract class MapExpressionBase<K, V, Q extends SimpleExpression<? super V>> extends DslExpression<Map<K, V>> implements MapExpression<K, V> {
  private static final long serialVersionUID = 2856001983312366841L;
  
  public MapExpressionBase(Expression<Map<K, V>> mixin) { super(mixin); }
  
  public final BooleanExpression contains(K key, V value) { return get(key).eq(value); }
  
  public final BooleanExpression contains(Expression<K> key, Expression<V> value) { return get(key).eq(value); }
  
  public final BooleanExpression containsKey(Expression<K> key) { return BooleanOperation.create(Ops.CONTAINS_KEY, this.mixin, key); }
  
  public final BooleanExpression containsKey(K key) { return BooleanOperation.create(Ops.CONTAINS_KEY, this.mixin, ConstantImpl.create(key)); }
  
  public final BooleanExpression containsValue(Expression<V> value) { return BooleanOperation.create(Ops.CONTAINS_VALUE, this.mixin, value); }
  
  public final BooleanExpression containsValue(V value) { return BooleanOperation.create(Ops.CONTAINS_VALUE, this.mixin, ConstantImpl.create(value)); }
  
  public abstract Q get(Expression<K> paramExpression);
  
  public abstract Q get(K paramK);
  
  public final BooleanExpression isEmpty() {
    if (this.empty == null)
      this.empty = BooleanOperation.create(Ops.MAP_IS_EMPTY, this.mixin); 
    return this.empty;
  }
  
  public final BooleanExpression isNotEmpty() { return isEmpty().not(); }
  
  public final NumberExpression<Integer> size() {
    if (this.size == null)
      this.size = NumberOperation.create(Integer.class, Ops.MAP_SIZE, this.mixin); 
    return this.size;
  }
}
