package com.mysema.query.types.expr;

import com.google.common.collect.ImmutableList;
import com.mysema.query.types.CollectionExpression;
import com.mysema.query.types.ConstantImpl;
import com.mysema.query.types.Expression;
import com.mysema.query.types.ExpressionUtils;
import com.mysema.query.types.Ops;
import com.mysema.query.types.Path;
import com.mysema.query.types.PathImpl;
import java.util.Collection;
import javax.annotation.Nullable;

public abstract class SimpleExpression<T> extends DslExpression<T> {
  private static final long serialVersionUID = -4405387187738167105L;
  
  public SimpleExpression(Expression<T> mixin) { super(mixin); }
  
  public SimpleExpression<T> as(Path<T> alias) { return SimpleOperation.create(getType(), Ops.ALIAS, this.mixin, alias); }
  
  public SimpleExpression<T> as(String alias) { return as(new PathImpl(getType(), alias)); }
  
  public BooleanExpression isNotNull() {
    if (this.isnotnull == null)
      this.isnotnull = BooleanOperation.create(Ops.IS_NOT_NULL, this.mixin); 
    return this.isnotnull;
  }
  
  public BooleanExpression isNull() {
    if (this.isnull == null)
      this.isnull = BooleanOperation.create(Ops.IS_NULL, this.mixin); 
    return this.isnull;
  }
  
  public NumberExpression<Long> count() {
    if (this.count == null)
      this.count = NumberOperation.create(Long.class, Ops.AggOps.COUNT_AGG, this.mixin); 
    return this.count;
  }
  
  public NumberExpression<Long> countDistinct() {
    if (this.countDistinct == null)
      this.countDistinct = NumberOperation.create(Long.class, Ops.AggOps.COUNT_DISTINCT_AGG, this.mixin); 
    return this.countDistinct;
  }
  
  public BooleanExpression eq(T right) {
    if (right == null)
      throw new IllegalArgumentException("eq(null) is not allowed. Use isNull() instead"); 
    return eq(ConstantImpl.create(right));
  }
  
  public BooleanExpression eq(Expression<? super T> right) { return BooleanOperation.create(Ops.EQ, this.mixin, right); }
  
  public BooleanExpression eqAll(CollectionExpression<?, ? super T> right) { return eq(ExpressionUtils.all(right)); }
  
  public BooleanExpression eqAny(CollectionExpression<?, ? super T> right) { return eq(ExpressionUtils.any(right)); }
  
  public BooleanExpression in(Collection<? extends T> right) {
    if (right.size() == 1)
      return eq(right.iterator().next()); 
    return BooleanOperation.create(Ops.IN, this.mixin, ConstantImpl.create(right));
  }
  
  public BooleanExpression in(T... right) {
    if (right.length == 1)
      return eq(right[0]); 
    return BooleanOperation.create(Ops.IN, this.mixin, ConstantImpl.create(ImmutableList.copyOf(right)));
  }
  
  public BooleanExpression in(CollectionExpression<?, ? extends T> right) { return BooleanOperation.create(Ops.IN, this.mixin, right); }
  
  public BooleanExpression ne(T right) {
    if (right == null)
      throw new IllegalArgumentException("ne(null) is not allowed. Use isNotNull() instead"); 
    return ne(ConstantImpl.create(right));
  }
  
  public BooleanExpression ne(Expression<? super T> right) { return BooleanOperation.create(Ops.NE, this.mixin, right); }
  
  public BooleanExpression neAll(CollectionExpression<?, ? super T> right) { return ne(ExpressionUtils.all(right)); }
  
  public BooleanExpression neAny(CollectionExpression<?, ? super T> right) { return ne(ExpressionUtils.any(right)); }
  
  public BooleanExpression notIn(Collection<? extends T> right) {
    if (right.size() == 1)
      return ne(right.iterator().next()); 
    return BooleanOperation.create(Ops.NOT_IN, this.mixin, ConstantImpl.create(right));
  }
  
  public BooleanExpression notIn(T... right) {
    if (right.length == 1)
      return ne(right[0]); 
    return BooleanOperation.create(Ops.NOT_IN, this.mixin, ConstantImpl.create(ImmutableList.copyOf(right)));
  }
  
  public final BooleanExpression notIn(CollectionExpression<?, ? extends T> right) { return BooleanOperation.create(Ops.NOT_IN, this.mixin, right); }
  
  public SimpleExpression<T> nullif(Expression<T> other) { return SimpleOperation.create(getType(), Ops.NULLIF, this, other); }
  
  public SimpleExpression<T> nullif(T other) { return nullif(ConstantImpl.create(other)); }
  
  public CaseForEqBuilder<T> when(T other) { return new CaseForEqBuilder(this.mixin, ConstantImpl.create(other)); }
  
  public CaseForEqBuilder<T> when(Expression<? extends T> other) { return new CaseForEqBuilder(this.mixin, other); }
}
