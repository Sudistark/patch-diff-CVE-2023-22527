package com.mysema.query.types;

import com.google.common.collect.ImmutableList;
import com.mysema.query.BooleanBuilder;
import com.mysema.query.QueryException;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.UUID;
import javax.annotation.Nullable;

public final class ExpressionUtils {
  private static final Templates TEMPLATES = new UnderscoreTemplates(null);
  
  public static <T> Operation<T> operation(Class<? extends T> type, Operator<T> operator, Expression... args) { return operation(type, operator, ImmutableList.copyOf(args)); }
  
  public static <T> Operation<T> operation(Class<? extends T> type, Operator<T> operator, ImmutableList<Expression<?>> args) {
    if (type.equals(Boolean.class))
      return new PredicateOperation(operator, args); 
    return new OperationImpl(type, operator, args);
  }
  
  public static PredicateOperation predicate(Operator<Boolean> operator, Expression... args) { return predicate(operator, ImmutableList.copyOf(args)); }
  
  public static PredicateOperation predicate(Operator<Boolean> operator, ImmutableList<Expression<?>> args) { return new PredicateOperation(operator, args); }
  
  public static <T> Path<T> path(Class<? extends T> type, String variable) { return new PathImpl(type, variable); }
  
  public static <T> Path<T> path(Class<? extends T> type, Path<?> parent, String property) { return new PathImpl(type, parent, property); }
  
  public static <T> Path<T> path(Class<? extends T> type, PathMetadata metadata) { return new PathImpl(type, metadata); }
  
  public static PredicateTemplate predicateTemplate(String template, Object... args) { return predicateTemplate(TemplateFactory.DEFAULT.create(template), ImmutableList.copyOf(args)); }
  
  public static PredicateTemplate predicateTemplate(String template, ImmutableList<?> args) { return predicateTemplate(TemplateFactory.DEFAULT.create(template), args); }
  
  public static PredicateTemplate predicateTemplate(Template template, Object... args) { return predicateTemplate(template, ImmutableList.copyOf(args)); }
  
  public static PredicateTemplate predicateTemplate(Template template, ImmutableList<?> args) { return new PredicateTemplate(template, args); }
  
  public static <T> TemplateExpression<T> template(Class<? extends T> cl, String template, Object... args) { return template(cl, TemplateFactory.DEFAULT.create(template), ImmutableList.copyOf(args)); }
  
  public static <T> TemplateExpression<T> template(Class<? extends T> cl, String template, ImmutableList<?> args) { return template(cl, TemplateFactory.DEFAULT.create(template), args); }
  
  public static <T> TemplateExpression<T> template(Class<? extends T> cl, Template template, Object... args) { return template(cl, template, ImmutableList.copyOf(args)); }
  
  public static <T> TemplateExpression<T> template(Class<? extends T> cl, Template template, ImmutableList<?> args) {
    if (cl.equals(Boolean.class))
      return new PredicateTemplate(template, args); 
    return new TemplateExpressionImpl(cl, template, args);
  }
  
  public static <T> Expression<T> all(CollectionExpression<?, ? super T> col) { return OperationImpl.create(col.getParameter(0), Ops.QuantOps.ALL, col); }
  
  public static <T> Expression<T> any(CollectionExpression<?, ? super T> col) { return OperationImpl.create(col.getParameter(0), Ops.QuantOps.ANY, col); }
  
  @Nullable
  public static Predicate allOf(Collection<Predicate> exprs) {
    Predicate rv = null;
    for (Predicate b : exprs) {
      if (b != null)
        rv = (rv == null) ? b : and(rv, b); 
    } 
    return rv;
  }
  
  @Nullable
  public static Predicate allOf(Predicate... exprs) {
    Predicate rv = null;
    for (Predicate b : exprs) {
      if (b != null)
        rv = (rv == null) ? b : and(rv, b); 
    } 
    return rv;
  }
  
  public static Predicate and(Predicate left, Predicate right) {
    left = (Predicate)extract(left);
    right = (Predicate)extract(right);
    if (left == null)
      return right; 
    if (right == null)
      return left; 
    return PredicateOperation.create(Ops.AND, left, right);
  }
  
  @Nullable
  public static Predicate anyOf(Collection<Predicate> exprs) {
    Predicate rv = null;
    for (Predicate b : exprs) {
      if (b != null)
        rv = (rv == null) ? b : or(rv, b); 
    } 
    return rv;
  }
  
  @Nullable
  public static Predicate anyOf(Predicate... exprs) {
    Predicate rv = null;
    for (Predicate b : exprs) {
      if (b != null)
        rv = (rv == null) ? b : or(rv, b); 
    } 
    return rv;
  }
  
  public static <D> Expression<D> as(Expression<D> source, Path<D> alias) { return OperationImpl.create(alias.getType(), Ops.ALIAS, source, alias); }
  
  public static <D> Expression<D> as(Expression<D> source, String alias) { return as(source, new PathImpl(source.getType(), alias)); }
  
  public static Expression<Long> count(Expression<?> source) { return OperationImpl.create(Long.class, Ops.AggOps.COUNT_AGG, source); }
  
  public static <D> Predicate eqConst(Expression<D> left, D constant) { return eq(left, ConstantImpl.create(constant)); }
  
  public static <D> Predicate eq(Expression<D> left, Expression<? extends D> right) { return PredicateOperation.create(Ops.EQ, left, right); }
  
  public static <D> Predicate in(Expression<D> left, CollectionExpression<?, ? extends D> right) { return PredicateOperation.create(Ops.IN, left, right); }
  
  public static <D> Predicate in(Expression<D> left, Collection<? extends D> right) {
    if (right.size() == 1)
      return eqConst(left, right.iterator().next()); 
    return PredicateOperation.create(Ops.IN, left, ConstantImpl.create(right));
  }
  
  public static <D> Predicate inAny(Expression<D> left, Iterable<? extends Collection<? extends D>> lists) {
    BooleanBuilder rv = new BooleanBuilder();
    for (Collection<? extends D> list : lists)
      rv.or(in(left, list)); 
    return rv;
  }
  
  public static Predicate isNull(Expression<?> left) { return PredicateOperation.create(Ops.IS_NULL, left); }
  
  public static Predicate isNotNull(Expression<?> left) { return PredicateOperation.create(Ops.IS_NOT_NULL, left); }
  
  public static Expression<String> likeToRegex(Expression<String> expr) { return likeToRegex(expr, true); }
  
  public static Expression<String> likeToRegex(Expression<String> expr, boolean matchStartAndEnd) {
    if (expr instanceof Constant) {
      String like = expr.toString();
      StringBuilder rv = new StringBuilder(like.length() + 4);
      if (matchStartAndEnd && !like.startsWith("%"))
        rv.append('^'); 
      for (int i = 0; i < like.length(); i++) {
        char ch = like.charAt(i);
        if (ch == '.' || ch == '*' || ch == '?') {
          rv.append('\\');
        } else {
          if (ch == '%') {
            rv.append(".*");
            continue;
          } 
          if (ch == '_') {
            rv.append('.');
            continue;
          } 
        } 
        rv.append(ch);
        continue;
      } 
      if (matchStartAndEnd && !like.endsWith("%"))
        rv.append('$'); 
      if (!like.equals(rv.toString()))
        return ConstantImpl.create(rv.toString()); 
    } else if (expr instanceof Operation) {
      Operation<?> o = (Operation)expr;
      if (o.getOperator() == Ops.CONCAT) {
        Expression<String> lhs = likeToRegex(o.getArg(0), false);
        Expression<String> rhs = likeToRegex(o.getArg(1), false);
        if (lhs != o.getArg(false) || rhs != o.getArg(true))
          return OperationImpl.create(String.class, Ops.CONCAT, lhs, rhs); 
      } 
    } 
    return expr;
  }
  
  public static <T> Expression<T> list(Class<T> clazz, Expression... exprs) { return list(clazz, ImmutableList.copyOf(exprs)); }
  
  public static <T> Expression<T> list(Class<T> clazz, List<? extends Expression<?>> exprs) {
    Operation operation = (Expression)exprs.get(0);
    if (exprs.size() == 1) {
      operation = OperationImpl.create(clazz, Ops.SINGLETON, operation, (Expression)exprs.get(0));
    } else {
      for (int i = 1; i < exprs.size(); i++)
        operation = OperationImpl.create(clazz, Ops.LIST, operation, (Expression)exprs.get(i)); 
    } 
    return operation;
  }
  
  public static Expression<String> regexToLike(Expression<String> expr) {
    if (expr instanceof Constant) {
      String str = expr.toString();
      StringBuilder rv = new StringBuilder(str.length() + 2);
      boolean escape = false;
      for (int i = 0; i < str.length(); i++) {
        char ch = str.charAt(i);
        if (!escape && ch == '.') {
          if (i < str.length() - 1 && str.charAt(i + 1) == '*') {
            rv.append('%');
            i++;
          } else {
            rv.append('_');
          } 
        } else if (!escape && ch == '\\') {
          escape = true;
        } else {
          if (!escape && (ch == '[' || ch == ']' || ch == '^' || ch == '.' || ch == '*'))
            throw new QueryException("'" + str + "' can't be converted to like form"); 
          if (escape && (ch == 'd' || ch == 'D' || ch == 's' || ch == 'S' || ch == 'w' || ch == 'W'))
            throw new QueryException("'" + str + "' can't be converted to like form"); 
          rv.append(ch);
          escape = false;
        } 
      } 
      if (!rv.toString().equals(str))
        return ConstantImpl.create(rv.toString()); 
    } else if (expr instanceof Operation) {
      Operation<?> o = (Operation)expr;
      if (o.getOperator() == Ops.CONCAT) {
        Expression<String> lhs = regexToLike(o.getArg(0));
        Expression<String> rhs = regexToLike(o.getArg(1));
        if (lhs != o.getArg(false) || rhs != o.getArg(true))
          return OperationImpl.create(String.class, Ops.CONCAT, lhs, rhs); 
      } 
    } 
    return expr;
  }
  
  public static <D> Predicate neConst(Expression<D> left, D constant) { return ne(left, ConstantImpl.create(constant)); }
  
  public static <D> Predicate ne(Expression<D> left, Expression<? super D> right) { return PredicateOperation.create(Ops.NE, left, right); }
  
  public static <D> Predicate notIn(Expression<D> left, CollectionExpression<?, ? extends D> right) { return PredicateOperation.create(Ops.NOT_IN, left, right); }
  
  public static <D> Predicate notIn(Expression<D> left, Collection<? extends D> right) {
    if (right.size() == 1)
      return neConst(left, right.iterator().next()); 
    return PredicateOperation.create(Ops.NOT_IN, left, ConstantImpl.create(right));
  }
  
  public static <D> Predicate notInAny(Expression<D> left, Iterable<? extends Collection<? extends D>> lists) {
    BooleanBuilder rv = new BooleanBuilder();
    for (Collection<? extends D> list : lists)
      rv.and(notIn(left, list)); 
    return rv;
  }
  
  public static Predicate or(Predicate left, Predicate right) {
    left = (Predicate)extract(left);
    right = (Predicate)extract(right);
    if (left == null)
      return right; 
    if (right == null)
      return left; 
    return PredicateOperation.create(Ops.OR, left, right);
  }
  
  public static ImmutableList<Expression<?>> distinctList(Expression... args) {
    ImmutableList.Builder<Expression<?>> builder = ImmutableList.builder();
    Set<Expression<?>> set = new HashSet<Expression<?>>(args.length);
    for (Expression<?> arg : args) {
      if (set.add(arg))
        builder.add(arg); 
    } 
    return builder.build();
  }
  
  public static ImmutableList<Expression<?>> distinctList(Expression[]... args) {
    ImmutableList.Builder<Expression<?>> builder = ImmutableList.builder();
    Set<Expression<?>> set = new HashSet<Expression<?>>();
    for (Expression[] arr : args) {
      for (Expression<?> arg : arr) {
        if (set.add(arg))
          builder.add(arg); 
      } 
    } 
    return builder.build();
  }
  
  public static <T> Expression<T> extract(Expression<T> expr) {
    if (expr != null) {
      Class<?> clazz = expr.getClass();
      if (clazz == PathImpl.class || clazz == PredicateOperation.class || clazz == ConstantImpl.class)
        return expr; 
      return (Expression)expr.accept(ExtractorVisitor.DEFAULT, null);
    } 
    return null;
  }
  
  public static String createRootVariable(Path<?> path) {
    String variable = ((String)path.accept(ToStringVisitor.DEFAULT, TEMPLATES)).replace('.', '_');
    String suffix = UUID.randomUUID().toString().replace("-", "").substring(0, 5);
    return variable + "_" + suffix;
  }
  
  public static String createRootVariable(Path<?> path, int suffix) {
    String variable = ((String)path.accept(ToStringVisitor.DEFAULT, TEMPLATES)).replace('.', '_');
    return variable + "_" + suffix;
  }
  
  public static Expression<?> toExpression(Object o) {
    if (o instanceof Expression)
      return (Expression)o; 
    return ConstantImpl.create(o);
  }
  
  public static Expression<String> toLower(Expression<String> stringExpression) {
    if (stringExpression instanceof Constant) {
      Constant<String> constantExpression = (Constant)stringExpression;
      return ConstantImpl.create(((String)constantExpression.getConstant()).toLowerCase(Locale.ENGLISH));
    } 
    return operation(String.class, Ops.LOWER, new Expression[] { stringExpression });
  }
  
  public static Expression<?> orderBy(List<OrderSpecifier<?>> args) { return OperationImpl.create(Object.class, Ops.ORDER, ConstantImpl.create(args)); }
}
