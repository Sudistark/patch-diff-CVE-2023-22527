package com.mysema.query.sql;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Sets;
import com.infradna.tool.bridge_method_injector.BridgeMethodsAdded;
import com.infradna.tool.bridge_method_injector.WithBridgeMethods;
import com.mysema.commons.lang.CloseableIterator;
import com.mysema.query.FilteredClause;
import com.mysema.query.JoinFlag;
import com.mysema.query.Query;
import com.mysema.query.QueryFlag;
import com.mysema.query.QueryMetadata;
import com.mysema.query.QueryModifiers;
import com.mysema.query.SearchResults;
import com.mysema.query.SimpleQuery;
import com.mysema.query.Tuple;
import com.mysema.query.support.Expressions;
import com.mysema.query.support.ProjectableQuery;
import com.mysema.query.support.QueryMixin;
import com.mysema.query.types.EntityPath;
import com.mysema.query.types.Expression;
import com.mysema.query.types.ExpressionUtils;
import com.mysema.query.types.FactoryExpression;
import com.mysema.query.types.Operation;
import com.mysema.query.types.OperationImpl;
import com.mysema.query.types.OrderSpecifier;
import com.mysema.query.types.ParamExpression;
import com.mysema.query.types.ParamNotSetException;
import com.mysema.query.types.Path;
import com.mysema.query.types.PathExtractor;
import com.mysema.query.types.PathImpl;
import com.mysema.query.types.Predicate;
import com.mysema.query.types.SubQueryExpression;
import com.mysema.query.types.expr.SimpleExpression;
import com.mysema.query.types.expr.Wildcard;
import com.mysema.query.types.query.ListSubQuery;
import com.mysema.query.types.template.NumberTemplate;
import com.mysema.query.types.template.SimpleTemplate;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.Nonnegative;
import javax.annotation.Nullable;

@BridgeMethodsAdded
public abstract class ProjectableSQLQuery<Q extends ProjectableSQLQuery<Q> & Query<Q>> extends ProjectableQuery<Q> implements SQLCommonQuery<Q> {
  private static final Path<?> defaultQueryAlias = new PathImpl(Object.class, "query");
  
  protected final Configuration configuration;
  
  @Nullable
  protected Expression<?> union;
  
  protected SubQueryExpression<?> firstUnionSubQuery;
  
  protected boolean unionAll;
  
  public ProjectableSQLQuery(QueryMixin<Q> queryMixin, Configuration configuration) {
    super(queryMixin);
    this.queryMixin.setSelf(this);
    this.configuration = configuration;
  }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q addJoinFlag(String flag) { return (Q)addJoinFlag(flag, JoinFlag.Position.BEFORE_TARGET); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q addJoinFlag(String flag, JoinFlag.Position position) {
    this.queryMixin.addJoinFlag(new JoinFlag(flag, position));
    return (Q)this;
  }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q addFlag(QueryFlag.Position position, String prefix, Expression<?> expr) {
    SimpleExpression simpleExpression = SimpleTemplate.create(expr.getType(), prefix + "{0}", expr);
    return (Q)(ProjectableSQLQuery)this.queryMixin.addFlag(new QueryFlag(position, simpleExpression));
  }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q addFlag(QueryFlag flag) { return (Q)(ProjectableSQLQuery)this.queryMixin.addFlag(flag); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q addFlag(QueryFlag.Position position, String flag) { return (Q)(ProjectableSQLQuery)this.queryMixin.addFlag(new QueryFlag(position, flag)); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q addFlag(QueryFlag.Position position, Expression<?> flag) { return (Q)(ProjectableSQLQuery)this.queryMixin.addFlag(new QueryFlag(position, flag)); }
  
  public long count() {
    Number number = (Number)uniqueResult(Wildcard.countAsInt);
    return number.longValue();
  }
  
  public boolean exists() { return (singleResult(NumberTemplate.ONE) != null); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q from(Expression<?> arg) { return (Q)(ProjectableSQLQuery)this.queryMixin.from(arg); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q from(Expression... args) { return (Q)(ProjectableSQLQuery)this.queryMixin.from(args); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q from(SubQueryExpression<?> subQuery, Path<?> alias) { return (Q)(ProjectableSQLQuery)this.queryMixin.from(ExpressionUtils.as(subQuery, alias)); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q fullJoin(EntityPath<?> target) { return (Q)(ProjectableSQLQuery)this.queryMixin.fullJoin(target); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public <E> Q fullJoin(RelationalFunctionCall<E> target, Path<E> alias) { return (Q)(ProjectableSQLQuery)this.queryMixin.fullJoin(target, alias); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q fullJoin(SubQueryExpression<?> target, Path<?> alias) { return (Q)(ProjectableSQLQuery)this.queryMixin.fullJoin(target, alias); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public <E> Q fullJoin(ForeignKey<E> key, RelationalPath<E> entity) { return (Q)((ProjectableSQLQuery)this.queryMixin.fullJoin(entity)).on(key.on(entity)); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q innerJoin(EntityPath<?> target) { return (Q)(ProjectableSQLQuery)this.queryMixin.innerJoin(target); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public <E> Q innerJoin(RelationalFunctionCall<E> target, Path<E> alias) { return (Q)(ProjectableSQLQuery)this.queryMixin.innerJoin(target, alias); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q innerJoin(SubQueryExpression<?> target, Path<?> alias) { return (Q)(ProjectableSQLQuery)this.queryMixin.innerJoin(target, alias); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public <E> Q innerJoin(ForeignKey<E> key, RelationalPath<E> entity) { return (Q)((ProjectableSQLQuery)this.queryMixin.innerJoin(entity)).on(key.on(entity)); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q join(EntityPath<?> target) { return (Q)(ProjectableSQLQuery)this.queryMixin.join(target); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public <E> Q join(RelationalFunctionCall<E> target, Path<E> alias) { return (Q)(ProjectableSQLQuery)this.queryMixin.join(target, alias); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q join(SubQueryExpression<?> target, Path<?> alias) { return (Q)(ProjectableSQLQuery)this.queryMixin.join(target, alias); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public <E> Q join(ForeignKey<E> key, RelationalPath<E> entity) { return (Q)((ProjectableSQLQuery)this.queryMixin.join(entity)).on(key.on(entity)); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q leftJoin(EntityPath<?> target) { return (Q)(ProjectableSQLQuery)this.queryMixin.leftJoin(target); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public <E> Q leftJoin(RelationalFunctionCall<E> target, Path<E> alias) { return (Q)(ProjectableSQLQuery)this.queryMixin.leftJoin(target, alias); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q leftJoin(SubQueryExpression<?> target, Path<?> alias) { return (Q)(ProjectableSQLQuery)this.queryMixin.leftJoin(target, alias); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public <E> Q leftJoin(ForeignKey<E> key, RelationalPath<E> entity) { return (Q)((ProjectableSQLQuery)this.queryMixin.leftJoin(entity)).on(key.on(entity)); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q rightJoin(EntityPath<?> target) { return (Q)(ProjectableSQLQuery)this.queryMixin.rightJoin(target); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public <E> Q rightJoin(RelationalFunctionCall<E> target, Path<E> alias) { return (Q)(ProjectableSQLQuery)this.queryMixin.rightJoin(target, alias); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q rightJoin(SubQueryExpression<?> target, Path<?> alias) { return (Q)(ProjectableSQLQuery)this.queryMixin.rightJoin(target, alias); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public <E> Q rightJoin(ForeignKey<E> key, RelationalPath<E> entity) { return (Q)((ProjectableSQLQuery)this.queryMixin.rightJoin(entity)).on(key.on(entity)); }
  
  public QueryMetadata getMetadata() { return this.queryMixin.getMetadata(); }
  
  private <RT> Union<RT> innerUnion(SubQueryExpression... sq) {
    this.queryMixin.getMetadata().setValidate(false);
    if (!this.queryMixin.getMetadata().getJoins().isEmpty())
      throw new IllegalArgumentException("Don't mix union and from"); 
    this.union = UnionUtils.union(sq, this.unionAll);
    this.firstUnionSubQuery = sq[0];
    return new UnionImpl(this, sq[0].getMetadata().getProjection());
  }
  
  public CloseableIterator<Tuple> iterate(Expression... args) { return iterate(this.queryMixin.createProjection(args)); }
  
  public List<Tuple> list(Expression... args) { return list(this.queryMixin.createProjection(args)); }
  
  public SearchResults<Tuple> listResults(Expression... args) { return listResults(this.queryMixin.createProjection(args)); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q on(Predicate condition) { return (Q)(ProjectableSQLQuery)this.queryMixin.on(condition); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q on(Predicate... conditions) { return (Q)(ProjectableSQLQuery)this.queryMixin.on(conditions); }
  
  public <RT> Union<RT> union(ListSubQuery... sq) { return innerUnion(sq); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public <RT> Q union(Path<?> alias, ListSubQuery... sq) { return (Q)from(UnionUtils.union(sq, alias, false)); }
  
  public <RT> Union<RT> union(SubQueryExpression... sq) { return innerUnion(sq); }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public <RT> Q union(Path<?> alias, SubQueryExpression... sq) { return (Q)from(UnionUtils.union(sq, alias, false)); }
  
  public <RT> Union<RT> unionAll(ListSubQuery... sq) {
    this.unionAll = true;
    return innerUnion(sq);
  }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public <RT> Q unionAll(Path<?> alias, ListSubQuery... sq) { return (Q)from(UnionUtils.union(sq, alias, true)); }
  
  public <RT> Union<RT> unionAll(SubQueryExpression... sq) {
    this.unionAll = true;
    return innerUnion(sq);
  }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public <RT> Q unionAll(Path<?> alias, SubQueryExpression... sq) { return (Q)from(UnionUtils.union(sq, alias, true)); }
  
  public Tuple uniqueResult(Expression... args) { return (Tuple)uniqueResult(this.queryMixin.createProjection(args)); }
  
  public <RT> RT uniqueResult(Expression<RT> expr) {
    if (getMetadata().getModifiers().getLimit() == null && 
      !expr.toString().contains("count("))
      limit(2L); 
    CloseableIterator<RT> iterator = iterate(expr);
    return (RT)uniqueResult(iterator);
  }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q withRecursive(Path<?> alias, SubQueryExpression<?> query) {
    this.queryMixin.addFlag(new QueryFlag(QueryFlag.Position.WITH, SQLTemplates.RECURSIVE));
    return (Q)with(alias, query);
  }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q withRecursive(Path<?> alias, Expression<?> query) {
    this.queryMixin.addFlag(new QueryFlag(QueryFlag.Position.WITH, SQLTemplates.RECURSIVE));
    return (Q)with(alias, query);
  }
  
  public WithBuilder<Q> withRecursive(Path<?> alias, Path... columns) {
    this.queryMixin.addFlag(new QueryFlag(QueryFlag.Position.WITH, SQLTemplates.RECURSIVE));
    return with(alias, columns);
  }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q with(Path<?> alias, SubQueryExpression<?> query) {
    Operation operation = OperationImpl.create(alias.getType(), SQLOps.WITH_ALIAS, alias, query);
    return (Q)(ProjectableSQLQuery)this.queryMixin.addFlag(new QueryFlag(QueryFlag.Position.WITH, operation));
  }
  
  @WithBridgeMethods(value = {AbstractSQLQuery.class}, castRequired = true)
  public Q with(Path<?> alias, Expression<?> query) {
    Operation operation = OperationImpl.create(alias.getType(), SQLOps.WITH_ALIAS, alias, query);
    return (Q)(ProjectableSQLQuery)this.queryMixin.addFlag(new QueryFlag(QueryFlag.Position.WITH, operation));
  }
  
  public WithBuilder<Q> with(Path<?> alias, Path... columns) {
    Expression<?> columnsCombined = ExpressionUtils.list(Object.class, columns);
    SimpleExpression simpleExpression = Expressions.operation(alias.getType(), SQLOps.WITH_COLUMNS, new Expression[] { alias, columnsCombined });
    return new WithBuilder(this.queryMixin, simpleExpression);
  }
  
  protected void clone(Q query) {
    this.union = query.union;
    this.unionAll = query.unionAll;
    this.firstUnionSubQuery = query.firstUnionSubQuery;
  }
  
  private Set<Path<?>> getRootPaths(Collection<Expression<?>> exprs) {
    Set<Path<?>> paths = Sets.newHashSet();
    for (Expression<?> e : exprs) {
      Path<?> path = (Path)e.accept(PathExtractor.DEFAULT, null);
      if (path != null && !path.getMetadata().isRoot())
        paths.add(path.getMetadata().getRoot()); 
    } 
    return paths;
  }
  
  private Collection<Expression<?>> expandProjection(Collection<Expression<?>> exprs) {
    if (exprs.size() == 1 && exprs.iterator().next() instanceof FactoryExpression)
      return ((FactoryExpression)exprs.iterator().next()).getArgs(); 
    return exprs;
  }
  
  protected SQLSerializer serialize(boolean forCountRow) {
    SQLSerializer serializer = createSerializer();
    if (this.union != null) {
      if (this.queryMixin.getMetadata().getProjection().isEmpty() || 
        expandProjection(this.queryMixin.getMetadata().getProjection()).equals(
          expandProjection(this.firstUnionSubQuery.getMetadata().getProjection()))) {
        serializer.serializeUnion(this.union, this.queryMixin.getMetadata(), this.unionAll);
      } else {
        QueryMixin mixin2 = new QueryMixin(this.queryMixin.getMetadata().clone());
        Set<Path<?>> paths = getRootPaths(expandProjection(mixin2.getMetadata().getProjection()));
        if (paths.isEmpty()) {
          mixin2.from(ExpressionUtils.as(this.union, defaultQueryAlias));
        } else if (paths.size() == 1) {
          mixin2.from(ExpressionUtils.as(this.union, (Path)paths.iterator().next()));
        } else {
          throw new IllegalStateException("Unable to create serialize union");
        } 
        serializer.serialize(mixin2.getMetadata(), forCountRow);
      } 
    } else {
      serializer.serialize(this.queryMixin.getMetadata(), forCountRow);
    } 
    return serializer;
  }
  
  public SQLBindings getSQL(Expression... exprs) {
    this.queryMixin.addProjection(exprs);
    SQLSerializer serializer = serialize(false);
    ImmutableList.Builder<Object> args = ImmutableList.builder();
    Map<ParamExpression<?>, Object> params = getMetadata().getParams();
    for (Object o : serializer.getConstants()) {
      if (o instanceof ParamExpression) {
        if (!params.containsKey(o))
          throw new ParamNotSetException((ParamExpression)o); 
        o = this.queryMixin.getMetadata().getParams().get(o);
      } 
      args.add(o);
    } 
    return new SQLBindings(serializer.toString(), args.build());
  }
  
  public String toString() {
    SQLSerializer serializer = serialize(false);
    return serializer.toString().trim();
  }
  
  public abstract Q clone();
  
  protected abstract SQLSerializer createSerializer();
}
