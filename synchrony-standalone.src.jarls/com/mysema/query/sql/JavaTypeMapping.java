package com.mysema.query.sql;

import com.google.common.primitives.Primitives;
import com.mysema.query.sql.types.BigDecimalType;
import com.mysema.query.sql.types.BigIntegerType;
import com.mysema.query.sql.types.BlobType;
import com.mysema.query.sql.types.BooleanType;
import com.mysema.query.sql.types.ByteType;
import com.mysema.query.sql.types.BytesType;
import com.mysema.query.sql.types.CalendarType;
import com.mysema.query.sql.types.CharacterType;
import com.mysema.query.sql.types.ClobType;
import com.mysema.query.sql.types.CurrencyType;
import com.mysema.query.sql.types.DateType;
import com.mysema.query.sql.types.DoubleType;
import com.mysema.query.sql.types.FloatType;
import com.mysema.query.sql.types.IntegerType;
import com.mysema.query.sql.types.LocaleType;
import com.mysema.query.sql.types.LongType;
import com.mysema.query.sql.types.ObjectType;
import com.mysema.query.sql.types.ShortType;
import com.mysema.query.sql.types.StringType;
import com.mysema.query.sql.types.TimeType;
import com.mysema.query.sql.types.TimestampType;
import com.mysema.query.sql.types.Type;
import com.mysema.query.sql.types.URLType;
import com.mysema.query.sql.types.UtilDateType;
import com.mysema.query.sql.types.UtilUUIDType;
import com.mysema.util.ReflectionUtils;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import javax.annotation.Nullable;

public class JavaTypeMapping {
  private static final Type<Object> DEFAULT = new ObjectType();
  
  private static final Map<Class<?>, Type<?>> defaultTypes = new HashMap();
  
  static  {
    registerDefault(new BigIntegerType());
    registerDefault(new BigDecimalType());
    registerDefault(new BlobType());
    registerDefault(new BooleanType());
    registerDefault(new BytesType());
    registerDefault(new ByteType());
    registerDefault(new CharacterType());
    registerDefault(new CalendarType());
    registerDefault(new ClobType());
    registerDefault(new CurrencyType());
    registerDefault(new DateType());
    registerDefault(new DoubleType());
    registerDefault(new FloatType());
    registerDefault(new IntegerType());
    registerDefault(new LocaleType());
    registerDefault(new LongType());
    registerDefault(new ObjectType());
    registerDefault(new ShortType());
    registerDefault(new StringType());
    registerDefault(new TimestampType());
    registerDefault(new TimeType());
    registerDefault(new URLType());
    registerDefault(new UtilDateType());
    registerDefault(new UtilUUIDType(false));
    try {
      Class.forName("org.joda.time.DateTime");
      registerDefault((Type)Class.forName("com.mysema.query.sql.types.DateTimeType").newInstance());
      registerDefault((Type)Class.forName("com.mysema.query.sql.types.LocalDateTimeType").newInstance());
      registerDefault((Type)Class.forName("com.mysema.query.sql.types.LocalDateType").newInstance());
      registerDefault((Type)Class.forName("com.mysema.query.sql.types.LocalTimeType").newInstance());
    } catch (ClassNotFoundException e) {
    
    } catch (InstantiationException e) {
      throw new RuntimeException(e);
    } catch (IllegalAccessException e) {
      throw new RuntimeException(e);
    } 
  }
  
  private static void registerDefault(Type<?> type) {
    defaultTypes.put(type.getReturnedClass(), type);
    Class<?> primitive = Primitives.unwrap(type.getReturnedClass());
    if (primitive != null)
      defaultTypes.put(primitive, type); 
  }
  
  private final Map<Class<?>, Type<?>> typeByClass = new HashMap();
  
  private final Map<Class<?>, Type<?>> resolvedTypesByClass = new HashMap();
  
  private final Map<String, Map<String, Type<?>>> typeByColumn = new HashMap();
  
  @Nullable
  public Type<?> getType(String table, String column) {
    Map<String, Type<?>> columns = (Map)this.typeByColumn.get(table);
    if (columns != null)
      return (Type)columns.get(column); 
    return null;
  }
  
  public <T> Type<T> getType(Class<T> clazz) {
    Type<?> resolvedType = (Type)this.resolvedTypesByClass.get(clazz);
    if (resolvedType == null) {
      resolvedType = findType(clazz);
      if (resolvedType != null) {
        this.resolvedTypesByClass.put(clazz, resolvedType);
      } else {
        return DEFAULT;
      } 
    } 
    return resolvedType;
  }
  
  @Nullable
  private Type<?> findType(Class<?> clazz) {
    Class<?> cl = clazz;
    do {
      if (this.typeByClass.containsKey(cl))
        return (Type)this.typeByClass.get(cl); 
      if (defaultTypes.containsKey(cl))
        return (Type)defaultTypes.get(cl); 
      cl = cl.getSuperclass();
    } while (!cl.equals(Object.class));
    Set<Class<?>> interfaces = ReflectionUtils.getImplementedInterfaces(clazz);
    for (Class<?> itf : interfaces) {
      if (this.typeByClass.containsKey(itf))
        return (Type)this.typeByClass.get(itf); 
      if (defaultTypes.containsKey(itf))
        return (Type)defaultTypes.get(itf); 
    } 
    return null;
  }
  
  public void register(Type<?> type) {
    this.typeByClass.put(type.getReturnedClass(), type);
    Class<?> primitive = Primitives.unwrap(type.getReturnedClass());
    if (primitive != null)
      this.typeByClass.put(primitive, type); 
    this.resolvedTypesByClass.clear();
  }
  
  public void setType(String table, String column, Type<?> type) {
    Map<String, Type<?>> columns = (Map)this.typeByColumn.get(table);
    if (columns == null) {
      columns = new HashMap<String, Type<?>>();
      this.typeByColumn.put(table, columns);
    } 
    columns.put(column, type);
  }
}
