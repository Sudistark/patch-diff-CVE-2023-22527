package com.mysema.query.sql;

import com.mysema.commons.lang.Pair;
import com.mysema.query.QueryFlag;
import com.mysema.query.QueryMetadata;
import com.mysema.query.QueryModifiers;
import com.mysema.query.types.Expression;
import com.mysema.query.types.Operator;
import com.mysema.query.types.Ops;
import com.mysema.query.types.Path;
import java.util.List;

public class OracleTemplates extends SQLTemplates {
  public static final OracleTemplates DEFAULT = new OracleTemplates();
  
  public static SQLTemplates.Builder builder() { return new Object(); }
  
  private String outerQueryStart = "select * from (\n select a.*, rownum rn from (\n  ";
  
  private String outerQueryEnd = "\n ) a) where ";
  
  private String limitQueryStart = "select * from (\n  ";
  
  private String limitQueryEnd = "\n) where rownum <= {0}";
  
  private String limitOffsetTemplate = "rn > {0s} and rownum <= {1s}";
  
  private String offsetTemplate = "rn > {0}";
  
  public OracleTemplates() { this('\\', false); }
  
  public OracleTemplates(boolean quote) { this('\\', quote); }
  
  public OracleTemplates(char escape, boolean quote) {
    super("\"", escape, quote);
    setParameterMetadataAvailable(false);
    setBatchCountViaGetUpdateCount(true);
    setWithRecursive("with ");
    setCountViaAnalytics(true);
    setListMaxSize(1000);
    setPrecedence(50, new Operator[] { Ops.EQ, Ops.EQ_IGNORE_CASE, Ops.NE });
    setPrecedence(51, new Operator[] { Ops.IS_NULL, Ops.IS_NOT_NULL, Ops.LIKE, Ops.LIKE_ESCAPE, Ops.BETWEEN, Ops.IN, Ops.NOT_IN, Ops.EXISTS });
    setPrecedence(51, OTHER_LIKE_CASES);
    add(Ops.ALIAS, "{0} {1}");
    add(SQLOps.NEXTVAL, "{0s}.nextval");
    add(Ops.INDEX_OF, "instrb({0},{1})-1", 40);
    add(Ops.INDEX_OF_2ARGS, "instrb({0},{1},{2}+1)-1", 40);
    add(Ops.MATCHES, "regexp_like({0},{1})", -1);
    add(Ops.StringOps.LOCATE, "instr({1},{0})");
    add(Ops.StringOps.LOCATE2, "instr({1},{0},{2s})");
    add(Ops.StringOps.LEFT, "substr({0},1,{1})");
    add(Ops.StringOps.RIGHT, "substr({0},-{1s},length({0}))");
    add(Ops.MathOps.CEIL, "ceil({0})");
    add(Ops.MathOps.RANDOM, "dbms_random.value");
    add(Ops.MathOps.LN, "ln({0})");
    add(Ops.MathOps.LOG, "log({1},{0})");
    add(Ops.MathOps.COT, "(cos({0}) / sin({0}))");
    add(Ops.MathOps.COTH, "(exp({0} * 2) + 1) / (exp({0} * 2) - 1)");
    add(Ops.MathOps.DEG, "({0} * 180 / 3.141592653589793)");
    add(Ops.MathOps.RAD, "({0} * 3.141592653589793 / 180)");
    add(Ops.DateTimeOps.DATE, "trunc({0})");
    add(Ops.DateTimeOps.WEEK, "to_number(to_char({0},'WW'))");
    add(Ops.DateTimeOps.DAY_OF_WEEK, "to_number(to_char({0},'D')) + 1");
    add(Ops.DateTimeOps.DAY_OF_YEAR, "to_number(to_char({0},'DDD'))");
    add(Ops.DateTimeOps.YEAR_WEEK, "to_number(to_char({0},'IYYY') || to_char({0},'IW'))");
    add(Ops.DateTimeOps.ADD_YEARS, "{0} + interval '{1s}' year");
    add(Ops.DateTimeOps.ADD_MONTHS, "{0} + interval '{1s}' month");
    add(Ops.DateTimeOps.ADD_WEEKS, "{0} + interval '{1s}' week");
    add(Ops.DateTimeOps.ADD_DAYS, "{0} + interval '{1s}' day");
    add(Ops.DateTimeOps.ADD_HOURS, "{0} + interval '{1s}' hour");
    add(Ops.DateTimeOps.ADD_MINUTES, "{0} + interval '{1s}' minute");
    add(Ops.DateTimeOps.ADD_SECONDS, "{0} + interval '{1s}' second");
    add(Ops.DateTimeOps.DIFF_YEARS, "trunc(months_between({1}, {0}) / 12)");
    add(Ops.DateTimeOps.DIFF_MONTHS, "trunc(months_between({1}, {0}))");
    add(Ops.DateTimeOps.DIFF_WEEKS, "round(({1} - {0}) / 7)");
    add(Ops.DateTimeOps.DIFF_DAYS, "round({1} - {0})");
    add(Ops.DateTimeOps.DIFF_HOURS, "round(({1} - {0}) * 24)");
    add(Ops.DateTimeOps.DIFF_MINUTES, "round(({1} - {0}) * 1440)");
    add(Ops.DateTimeOps.DIFF_SECONDS, "round(({1} - {0}) * 86400)");
    add(Ops.DateTimeOps.TRUNC_YEAR, "trunc({0}, 'year')");
    add(Ops.DateTimeOps.TRUNC_MONTH, "trunc({0}, 'month')");
    add(Ops.DateTimeOps.TRUNC_WEEK, "trunc({0}, 'w')");
    add(Ops.DateTimeOps.TRUNC_DAY, "trunc({0}, 'dd')");
    add(Ops.DateTimeOps.TRUNC_HOUR, "trunc({0}, 'hh')");
    add(Ops.DateTimeOps.TRUNC_MINUTE, "trunc({0}, 'mi')");
    add(Ops.DateTimeOps.TRUNC_SECOND, "{0}");
    addTypeNameToCode("intervalds", -104);
    addTypeNameToCode("intervalym", -103);
    addTypeNameToCode("timestamp with local time zone", -102);
    addTypeNameToCode("timestamp with time zone", -101);
    addTypeNameToCode("long raw", -4);
    addTypeNameToCode("raw", -3);
    addTypeNameToCode("long", -1);
    addTypeNameToCode("varchar2", 12);
    addTypeNameToCode("number(1,0)", 16, true);
    addTypeNameToCode("number(3,0)", -6, true);
    addTypeNameToCode("number(5,0)", 5, true);
    addTypeNameToCode("number(10,0)", 4, true);
    addTypeNameToCode("number(19,0)", -5, true);
    addTypeNameToCode("binary_float", 6, true);
    addTypeNameToCode("binary_double", 8, true);
  }
  
  public String getCastTypeNameForCode(int code) {
    switch (code) {
      case 8:
        return "double precision";
      case 12:
        return "varchar(4000 char)";
    } 
    return super.getCastTypeNameForCode(code);
  }
  
  public String serialize(String literal, int jdbcType) {
    if (jdbcType == 91)
      return "date '" + literal + "'"; 
    if (jdbcType == 93)
      return "timestamp '" + literal + "'"; 
    if (jdbcType == 92)
      return "timestamp '1970-01-01 " + literal + "'"; 
    return super.serialize(literal, jdbcType);
  }
  
  public void serialize(QueryMetadata metadata, boolean forCountRow, SQLSerializer context) {
    if (!forCountRow && metadata.getModifiers().isRestricting() && !metadata.getJoins().isEmpty()) {
      QueryModifiers mod = metadata.getModifiers();
      if (mod.getOffset() == null) {
        context.append(this.limitQueryStart);
        context.serializeForQuery(metadata, forCountRow);
        context.handle(this.limitQueryEnd, new Object[] { mod.getLimit() });
      } else {
        context.append(this.outerQueryStart);
        context.serializeForQuery(metadata, forCountRow);
        context.append(this.outerQueryEnd);
        if (mod.getLimit() == null) {
          context.handle(this.offsetTemplate, new Object[] { mod.getOffset() });
        } else {
          context.handle(this.limitOffsetTemplate, new Object[] { mod.getOffset(), mod.getLimit() });
        } 
      } 
    } else {
      context.serializeForQuery(metadata, forCountRow);
    } 
    if (!metadata.getFlags().isEmpty())
      context.serialize(QueryFlag.Position.END, metadata.getFlags()); 
  }
  
  public void serializeDelete(QueryMetadata metadata, RelationalPath<?> entity, SQLSerializer context) {
    context.serializeForDelete(metadata, entity);
    if (metadata.getModifiers().isRestricting())
      serializeModifiersForDML(metadata, context); 
    if (!metadata.getFlags().isEmpty())
      context.serialize(QueryFlag.Position.END, metadata.getFlags()); 
  }
  
  public void serializeUpdate(QueryMetadata metadata, RelationalPath<?> entity, List<Pair<Path<?>, Expression<?>>> updates, SQLSerializer context) {
    context.serializeForUpdate(metadata, entity, updates);
    if (metadata.getModifiers().isRestricting())
      serializeModifiersForDML(metadata, context); 
    if (!metadata.getFlags().isEmpty())
      context.serialize(QueryFlag.Position.END, metadata.getFlags()); 
  }
  
  private void serializeModifiersForDML(QueryMetadata metadata, SQLSerializer context) {
    if (metadata.getWhere() != null) {
      context.append(" and ");
    } else {
      context.append(getWhere());
    } 
    context.append("rownum <= ");
    context.visitConstant(metadata.getModifiers().getLimit());
  }
  
  protected void serializeModifiers(QueryMetadata metadata, SQLSerializer context) {}
}
