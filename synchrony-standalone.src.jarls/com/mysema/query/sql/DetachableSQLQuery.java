package com.mysema.query.sql;

import com.google.common.collect.ImmutableList;
import com.infradna.tool.bridge_method_injector.BridgeMethodsAdded;
import com.infradna.tool.bridge_method_injector.WithBridgeMethods;
import com.mysema.query.DefaultQueryMetadata;
import com.mysema.query.FilteredClause;
import com.mysema.query.JoinFlag;
import com.mysema.query.Query;
import com.mysema.query.QueryFlag;
import com.mysema.query.QueryMetadata;
import com.mysema.query.QueryModifiers;
import com.mysema.query.SimpleQuery;
import com.mysema.query.support.DetachableQuery;
import com.mysema.query.support.Expressions;
import com.mysema.query.support.QueryMixin;
import com.mysema.query.types.CollectionExpression;
import com.mysema.query.types.EntityPath;
import com.mysema.query.types.Expression;
import com.mysema.query.types.ExpressionUtils;
import com.mysema.query.types.Operation;
import com.mysema.query.types.OperationImpl;
import com.mysema.query.types.Operator;
import com.mysema.query.types.OrderSpecifier;
import com.mysema.query.types.ParamExpression;
import com.mysema.query.types.ParamNotSetException;
import com.mysema.query.types.Path;
import com.mysema.query.types.Predicate;
import com.mysema.query.types.SubQueryExpression;
import com.mysema.query.types.TemplateExpressionImpl;
import com.mysema.query.types.expr.BooleanExpression;
import com.mysema.query.types.expr.CollectionExpressionBase;
import com.mysema.query.types.expr.CollectionOperation;
import com.mysema.query.types.expr.SimpleExpression;
import com.mysema.query.types.query.ListSubQuery;
import com.mysema.query.types.template.NumberTemplate;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import javax.annotation.Nonnegative;

@BridgeMethodsAdded
public abstract class DetachableSQLQuery<Q extends DetachableSQLQuery<Q>> extends DetachableQuery<Q> implements SQLCommonQuery<Q> {
  protected final Configuration configuration;
  
  public DetachableSQLQuery() { this((new DefaultQueryMetadata()).noValidate()); }
  
  public DetachableSQLQuery(QueryMetadata metadata) { this(Configuration.DEFAULT, metadata); }
  
  public DetachableSQLQuery(Configuration configuration, QueryMetadata metadata) {
    super(new QueryMixin(metadata));
    this.queryMixin.setSelf(this);
    this.configuration = configuration;
  }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q addFlag(QueryFlag.Position position, String prefix, Expression<?> expr) {
    Expression<?> flag = TemplateExpressionImpl.create(expr.getType(), prefix + "{0}", expr);
    return (Q)(DetachableSQLQuery)this.queryMixin.addFlag(new QueryFlag(position, flag));
  }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q addFlag(QueryFlag.Position position, String flag) { return (Q)(DetachableSQLQuery)this.queryMixin.addFlag(new QueryFlag(position, flag)); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q addFlag(QueryFlag.Position position, Expression<?> flag) { return (Q)(DetachableSQLQuery)this.queryMixin.addFlag(new QueryFlag(position, flag)); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q addJoinFlag(String flag) { return (Q)addJoinFlag(flag, JoinFlag.Position.BEFORE_TARGET); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q addJoinFlag(String flag, JoinFlag.Position position) {
    this.queryMixin.addJoinFlag(new JoinFlag(flag, position));
    return (Q)this;
  }
  
  public BooleanExpression exists() { return unique(NumberTemplate.ONE).exists(); }
  
  public BooleanExpression notExists() { return exists().not(); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q from(Expression<?> arg) { return (Q)(DetachableSQLQuery)this.queryMixin.from(arg); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q from(Expression... args) { return (Q)(DetachableSQLQuery)this.queryMixin.from(args); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q from(SubQueryExpression<?> subQuery, Path<?> alias) { return (Q)(DetachableSQLQuery)this.queryMixin.from(ExpressionUtils.as(subQuery, alias)); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q fullJoin(EntityPath<?> target) { return (Q)(DetachableSQLQuery)this.queryMixin.fullJoin(target); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public <E> Q fullJoin(RelationalFunctionCall<E> target, Path<E> alias) { return (Q)(DetachableSQLQuery)this.queryMixin.fullJoin(target, alias); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public <E> Q fullJoin(ForeignKey<E> key, RelationalPath<E> entity) { return (Q)((DetachableSQLQuery)this.queryMixin.fullJoin(entity)).on(key.on(entity)); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q fullJoin(SubQueryExpression<?> target, Path<?> alias) { return (Q)(DetachableSQLQuery)this.queryMixin.fullJoin(target, alias); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q innerJoin(EntityPath<?> target) { return (Q)(DetachableSQLQuery)this.queryMixin.innerJoin(target); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public <E> Q innerJoin(RelationalFunctionCall<E> target, Path<E> alias) { return (Q)(DetachableSQLQuery)this.queryMixin.innerJoin(target, alias); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public <E> Q innerJoin(ForeignKey<E> key, RelationalPath<E> entity) { return (Q)((DetachableSQLQuery)this.queryMixin.innerJoin(entity)).on(key.on(entity)); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q innerJoin(SubQueryExpression<?> target, Path<?> alias) { return (Q)(DetachableSQLQuery)this.queryMixin.innerJoin(target, alias); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q join(EntityPath<?> target) { return (Q)(DetachableSQLQuery)this.queryMixin.join(target); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public <E> Q join(RelationalFunctionCall<E> target, Path<E> alias) { return (Q)(DetachableSQLQuery)this.queryMixin.join(target, alias); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public <E> Q join(ForeignKey<E> key, RelationalPath<E> entity) { return (Q)((DetachableSQLQuery)this.queryMixin.join(entity)).on(key.on(entity)); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q join(SubQueryExpression<?> target, Path<?> alias) { return (Q)(DetachableSQLQuery)this.queryMixin.join(target, alias); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q leftJoin(EntityPath<?> target) { return (Q)(DetachableSQLQuery)this.queryMixin.leftJoin(target); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public <E> Q leftJoin(RelationalFunctionCall<E> target, Path<E> alias) { return (Q)(DetachableSQLQuery)this.queryMixin.leftJoin(target, alias); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public <E> Q leftJoin(ForeignKey<E> key, RelationalPath<E> entity) { return (Q)((DetachableSQLQuery)this.queryMixin.leftJoin(entity)).on(key.on(entity)); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q leftJoin(SubQueryExpression<?> target, Path<?> alias) { return (Q)(DetachableSQLQuery)this.queryMixin.leftJoin(target, alias); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q on(Predicate condition) { return (Q)(DetachableSQLQuery)this.queryMixin.on(condition); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q on(Predicate... conditions) { return (Q)(DetachableSQLQuery)this.queryMixin.on(conditions); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q rightJoin(EntityPath<?> target) { return (Q)(DetachableSQLQuery)this.queryMixin.rightJoin(target); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public <E> Q rightJoin(RelationalFunctionCall<E> target, Path<E> alias) { return (Q)(DetachableSQLQuery)this.queryMixin.fullJoin(target, alias); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public <E> Q rightJoin(ForeignKey<E> key, RelationalPath<E> entity) { return (Q)((DetachableSQLQuery)this.queryMixin.rightJoin(entity)).on(key.on(entity)); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q rightJoin(SubQueryExpression<?> target, Path<?> alias) { return (Q)(DetachableSQLQuery)this.queryMixin.rightJoin(target, alias); }
  
  private <T> CollectionExpressionBase<?, T> union(Operator<Object> op, List<? extends SubQueryExpression<?>> sq) {
    CollectionOperation collectionOperation = (Expression)sq.get(0);
    if (sq.size() == 1 && !CollectionExpression.class.isInstance(collectionOperation))
      return new ListSubQuery(collectionOperation.getType(), ((SubQueryExpression)sq.get(0)).getMetadata()); 
    Class<?> elementType = ((SubQueryExpression)sq.get(0)).getType();
    if (collectionOperation instanceof CollectionExpression)
      elementType = ((CollectionExpression)collectionOperation).getParameter(0); 
    for (int i = 1; i < sq.size(); i++)
      collectionOperation = CollectionOperation.create(op, elementType, collectionOperation, (Expression)sq.get(i)); 
    return (CollectionExpressionBase)collectionOperation;
  }
  
  public <T> CollectionExpressionBase<?, T> union(List<? extends SubQueryExpression<T>> sq) { return union(SQLOps.UNION, sq); }
  
  public <T> CollectionExpressionBase<?, T> union(ListSubQuery... sq) { return union(SQLOps.UNION, Arrays.asList(sq)); }
  
  public <T> CollectionExpressionBase<?, T> union(SubQueryExpression... sq) { return union(SQLOps.UNION, Arrays.asList(sq)); }
  
  public <T> CollectionExpressionBase<?, T> unionAll(List<? extends SubQueryExpression<T>> sq) { return union(SQLOps.UNION_ALL, sq); }
  
  public <T> CollectionExpressionBase<?, T> unionAll(ListSubQuery... sq) { return union(SQLOps.UNION_ALL, Arrays.asList(sq)); }
  
  public <T> CollectionExpressionBase<?, T> unionAll(SubQueryExpression... sq) { return union(SQLOps.UNION_ALL, Arrays.asList(sq)); }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q withRecursive(Path<?> alias, SubQueryExpression<?> query) {
    this.queryMixin.addFlag(new QueryFlag(QueryFlag.Position.WITH, SQLTemplates.RECURSIVE));
    return (Q)with(alias, query);
  }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q withRecursive(Path<?> alias, Expression<?> query) {
    this.queryMixin.addFlag(new QueryFlag(QueryFlag.Position.WITH, SQLTemplates.RECURSIVE));
    return (Q)with(alias, query);
  }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public WithBuilder<Q> withRecursive(Path<?> alias, Path... columns) {
    this.queryMixin.addFlag(new QueryFlag(QueryFlag.Position.WITH, SQLTemplates.RECURSIVE));
    return with(alias, columns);
  }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q with(Path<?> alias, SubQueryExpression<?> target) {
    Operation operation = OperationImpl.create(alias.getType(), SQLOps.WITH_ALIAS, alias, target);
    return (Q)(DetachableSQLQuery)this.queryMixin.addFlag(new QueryFlag(QueryFlag.Position.WITH, operation));
  }
  
  @WithBridgeMethods(value = {AbstractSQLSubQuery.class}, castRequired = true)
  public Q with(Path<?> alias, Expression<?> query) {
    Operation operation = OperationImpl.create(alias.getType(), SQLOps.WITH_ALIAS, alias, query);
    return (Q)(DetachableSQLQuery)this.queryMixin.addFlag(new QueryFlag(QueryFlag.Position.WITH, operation));
  }
  
  public WithBuilder<Q> with(Path<?> alias, Path... columns) {
    Expression<?> columnsCombined = ExpressionUtils.list(Object.class, columns);
    SimpleExpression simpleExpression = Expressions.operation(alias.getType(), SQLOps.WITH_COLUMNS, new Expression[] { alias, columnsCombined });
    return new WithBuilder(this.queryMixin, simpleExpression);
  }
  
  public QueryMetadata getMetadata() { return this.queryMixin.getMetadata(); }
  
  protected SQLSerializer serialize(boolean forCountRow) {
    SQLSerializer serializer = createSerializer();
    serializer.setStrict(false);
    serializer.serialize(this.queryMixin.getMetadata(), forCountRow);
    return serializer;
  }
  
  public SQLBindings getSQL(Expression... exprs) {
    this.queryMixin.addProjection(exprs);
    SQLSerializer serializer = serialize(false);
    ImmutableList.Builder<Object> args = ImmutableList.builder();
    Map<ParamExpression<?>, Object> params = getMetadata().getParams();
    for (Object o : serializer.getConstants()) {
      if (o instanceof ParamExpression) {
        if (!params.containsKey(o))
          throw new ParamNotSetException((ParamExpression)o); 
        o = this.queryMixin.getMetadata().getParams().get(o);
      } 
      args.add(o);
    } 
    return new SQLBindings(serializer.toString(), args.build());
  }
  
  public String toString() {
    if (!getMetadata().getJoins().isEmpty()) {
      SQLSerializer serializer = serialize(false);
      return serializer.toString().trim();
    } 
    return super.toString();
  }
  
  public abstract Q clone();
  
  protected abstract SQLSerializer createSerializer();
}
