package com.mysema.query.sql.dml;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.mysema.query.DefaultQueryMetadata;
import com.mysema.query.JoinType;
import com.mysema.query.QueryFlag;
import com.mysema.query.QueryMetadata;
import com.mysema.query.dml.InsertClause;
import com.mysema.query.dml.StoreClause;
import com.mysema.query.sql.AbstractSQLSubQuery;
import com.mysema.query.sql.ColumnMetadata;
import com.mysema.query.sql.Configuration;
import com.mysema.query.sql.RelationalPath;
import com.mysema.query.sql.SQLBindings;
import com.mysema.query.sql.SQLSerializer;
import com.mysema.query.sql.SQLTemplates;
import com.mysema.query.sql.types.Null;
import com.mysema.query.types.ConstantImpl;
import com.mysema.query.types.Expression;
import com.mysema.query.types.ParamExpression;
import com.mysema.query.types.Path;
import com.mysema.query.types.SubQueryExpression;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SQLInsertClause extends AbstractSQLClause<SQLInsertClause> implements InsertClause<SQLInsertClause> {
  private static final Logger logger = LoggerFactory.getLogger(SQLInsertClause.class);
  
  private final Connection connection;
  
  private final RelationalPath<?> entity;
  
  private final QueryMetadata metadata = new DefaultQueryMetadata();
  
  @Nullable
  private SubQueryExpression<?> subQuery;
  
  @Nullable
  private AbstractSQLSubQuery<?> subQueryBuilder;
  
  private final List<SQLInsertBatch> batches = new ArrayList();
  
  private final List<Path<?>> columns = new ArrayList();
  
  private final List<Expression<?>> values = new ArrayList();
  
  private String queryString;
  
  private List<Object> constants;
  
  public SQLInsertClause(Connection connection, SQLTemplates templates, RelationalPath<?> entity) { this(connection, new Configuration(templates), entity); }
  
  public SQLInsertClause(Connection connection, SQLTemplates templates, RelationalPath<?> entity, AbstractSQLSubQuery<?> subQuery) {
    this(connection, new Configuration(templates), entity);
    this.subQueryBuilder = subQuery;
  }
  
  public SQLInsertClause(Connection connection, Configuration configuration, RelationalPath<?> entity, AbstractSQLSubQuery<?> subQuery) {
    this(connection, configuration, entity);
    this.subQueryBuilder = subQuery;
  }
  
  public SQLInsertClause(Connection connection, Configuration configuration, RelationalPath<?> entity) {
    super(configuration);
    this.connection = connection;
    this.entity = entity;
    this.metadata.addJoin(JoinType.DEFAULT, entity);
  }
  
  public SQLInsertClause addFlag(QueryFlag.Position position, String flag) {
    this.metadata.addFlag(new QueryFlag(position, flag));
    return this;
  }
  
  public SQLInsertClause addFlag(QueryFlag.Position position, Expression<?> flag) {
    this.metadata.addFlag(new QueryFlag(position, flag));
    return this;
  }
  
  public SQLInsertClause addBatch() {
    if (this.subQueryBuilder != null) {
      this.subQuery = this.subQueryBuilder.list((Expression[])this.values.toArray(new Expression[this.values.size()]));
      this.values.clear();
    } 
    this.batches.add(new SQLInsertBatch(this.columns, this.values, this.subQuery));
    this.columns.clear();
    this.values.clear();
    this.subQuery = null;
    return this;
  }
  
  public SQLInsertClause columns(Path... columns) {
    this.columns.addAll(Arrays.asList(columns));
    return this;
  }
  
  @Nullable
  public <T> T executeWithKey(Path<T> path) { return (T)executeWithKey(path.getType(), path); }
  
  public <T> T executeWithKey(Class<T> type) { return (T)executeWithKey(type, null); }
  
  private <T> T executeWithKey(Class<T> type, @Nullable Path<T> path) {
    rs = null;
    try {
      rs = executeWithKeys();
      if (rs.next()) {
        object1 = this.configuration.get(rs, path, 1, type);
        return (T)object1;
      } 
      object = null;
      return (T)object;
    } catch (SQLException e) {
      throw this.configuration.translate(e);
    } finally {
      if (rs != null)
        close(rs); 
      reset();
    } 
  }
  
  public <T> List<T> executeWithKeys(Path<T> path) { return executeWithKeys(path.getType(), path); }
  
  public <T> List<T> executeWithKeys(Class<T> type) { return executeWithKeys(type, null); }
  
  private <T> List<T> executeWithKeys(Class<T> type, @Nullable Path<T> path) {
    rs = null;
    try {
      rs = executeWithKeys();
      List<T> rv = new ArrayList<T>();
      while (rs.next())
        rv.add(this.configuration.get(rs, path, 1, type)); 
      return rv;
    } catch (SQLException e) {
      throw this.configuration.translate(e);
    } finally {
      if (rs != null)
        close(rs); 
      reset();
    } 
  }
  
  private PreparedStatement createStatement(boolean withKeys) throws SQLException {
    this.listeners.preRender(this.context);
    SQLSerializer serializer = createSerializer();
    if (this.subQueryBuilder != null) {
      this.subQuery = this.subQueryBuilder.list((Expression[])this.values.toArray(new Expression[this.values.size()]));
      this.values.clear();
    } 
    serializer.serializeInsert(this.metadata, this.entity, this.columns, this.values, this.subQuery);
    this.context.addSQL(serializer.toString());
    this.listeners.rendered(this.context);
    return prepareStatementAndSetParameters(serializer, withKeys);
  }
  
  private Collection<PreparedStatement> createStatements(boolean withKeys) throws SQLException {
    boolean addBatches = !this.configuration.getUseLiterals();
    this.listeners.preRender(this.context);
    if (this.subQueryBuilder != null) {
      this.subQuery = this.subQueryBuilder.list((Expression[])this.values.toArray(new Expression[this.values.size()]));
      this.values.clear();
    } 
    Map<String, PreparedStatement> stmts = Maps.newHashMap();
    SQLSerializer serializer = createSerializer();
    serializer.serializeInsert(this.metadata, this.entity, ((SQLInsertBatch)this.batches.get(0)).getColumns(), ((SQLInsertBatch)this.batches
        .get(0)).getValues(), ((SQLInsertBatch)this.batches.get(0)).getSubQuery());
    PreparedStatement stmt = prepareStatementAndSetParameters(serializer, withKeys);
    if (addBatches)
      stmt.addBatch(); 
    stmts.put(serializer.toString(), stmt);
    this.context.addSQL(serializer.toString());
    this.listeners.rendered(this.context);
    for (int i = 1; i < this.batches.size(); i++) {
      SQLInsertBatch batch = (SQLInsertBatch)this.batches.get(i);
      this.listeners.preRender(this.context);
      serializer = createSerializer();
      serializer.serializeInsert(this.metadata, this.entity, batch.getColumns(), batch
          .getValues(), batch.getSubQuery());
      this.context.addSQL(serializer.toString());
      this.listeners.rendered(this.context);
      stmt = (PreparedStatement)stmts.get(serializer.toString());
      if (stmt == null) {
        stmt = prepareStatementAndSetParameters(serializer, withKeys);
        stmts.put(serializer.toString(), stmt);
      } else {
        setParameters(stmt, serializer.getConstants(), serializer.getConstantPaths(), this.metadata
            .getParams());
      } 
      if (addBatches)
        stmt.addBatch(); 
    } 
    return stmts.values();
  }
  
  private PreparedStatement prepareStatementAndSetParameters(SQLSerializer serializer, boolean withKeys) throws SQLException {
    PreparedStatement stmt;
    this.listeners.prePrepare(this.context);
    this.queryString = serializer.toString();
    this.constants = serializer.getConstants();
    logQuery(logger, this.queryString, this.constants);
    if (withKeys) {
      if (this.entity.getPrimaryKey() != null) {
        String[] target = new String[this.entity.getPrimaryKey().getLocalColumns().size()];
        for (int i = 0; i < target.length; i++) {
          Path<?> path = (Path)this.entity.getPrimaryKey().getLocalColumns().get(i);
          String column = ColumnMetadata.getName(path);
          target[i] = column;
        } 
        stmt = this.connection.prepareStatement(this.queryString, target);
      } else {
        stmt = this.connection.prepareStatement(this.queryString, 1);
      } 
    } else {
      stmt = this.connection.prepareStatement(this.queryString);
    } 
    setParameters(stmt, serializer.getConstants(), serializer.getConstantPaths(), this.metadata
        .getParams());
    this.context.addPreparedStatement(stmt);
    this.listeners.prepared(this.context);
    return stmt;
  }
  
  public ResultSet executeWithKeys() {
    this.context = startContext(this.connection, this.metadata, this.entity);
    try {
      PreparedStatement stmt = null;
      if (this.batches.isEmpty()) {
        stmt = createStatement(true);
        this.listeners.notifyInsert(this.entity, this.metadata, this.columns, this.values, this.subQuery);
        this.listeners.preExecute(this.context);
        stmt.executeUpdate();
        this.listeners.preExecute(this.context);
      } else {
        Collection<PreparedStatement> stmts = createStatements(true);
        if (stmts != null && stmts.size() > 1)
          throw new IllegalStateException("executeWithKeys called with batch statement and multiple SQL strings"); 
        stmt = (PreparedStatement)stmts.iterator().next();
        this.listeners.notifyInserts(this.entity, this.metadata, this.batches);
        this.listeners.preExecute(this.context);
        stmt.executeBatch();
        this.listeners.executed(this.context);
      } 
      Statement stmt2 = stmt;
      ResultSet rs = stmt.getGeneratedKeys();
      return new Object(this, rs, stmt2);
    } catch (SQLException e) {
      onException(this.context, e);
      throw this.configuration.translate(this.queryString, this.constants, e);
    } finally {
      reset();
      endContext(this.context);
    } 
  }
  
  public long execute() {
    this.context = startContext(this.connection, this.metadata, this.entity);
    stmt = null;
    stmts = null;
    try {
      if (this.batches.isEmpty()) {
        stmt = createStatement(false);
        this.listeners.notifyInsert(this.entity, this.metadata, this.columns, this.values, this.subQuery);
        this.listeners.preExecute(this.context);
        int rc = stmt.executeUpdate();
        this.listeners.executed(this.context);
        return rc;
      } 
      stmts = createStatements(false);
      this.listeners.notifyInserts(this.entity, this.metadata, this.batches);
      this.listeners.preExecute(this.context);
      long rc = executeBatch(stmts);
      this.listeners.executed(this.context);
      return rc;
    } catch (SQLException e) {
      onException(this.context, e);
      throw this.configuration.translate(this.queryString, this.constants, e);
    } finally {
      if (stmt != null)
        close(stmt); 
      if (stmts != null)
        close(stmts); 
      reset();
      endContext(this.context);
    } 
  }
  
  public List<SQLBindings> getSQL() {
    if (this.batches.isEmpty()) {
      SQLSerializer serializer = createSerializer();
      serializer.serializeInsert(this.metadata, this.entity, this.columns, this.values, this.subQuery);
      return ImmutableList.of(createBindings(this.metadata, serializer));
    } 
    ImmutableList.Builder<SQLBindings> builder = ImmutableList.builder();
    for (SQLInsertBatch batch : this.batches) {
      SQLSerializer serializer = createSerializer();
      serializer.serializeInsert(this.metadata, this.entity, batch.getColumns(), batch.getValues(), batch.getSubQuery());
      builder.add(createBindings(this.metadata, serializer));
    } 
    return builder.build();
  }
  
  public SQLInsertClause select(SubQueryExpression<?> sq) {
    this.subQuery = sq;
    for (Map.Entry<ParamExpression<?>, Object> entry : sq.getMetadata().getParams().entrySet())
      this.metadata.setParam((ParamExpression)entry.getKey(), entry.getValue()); 
    return this;
  }
  
  public <T> SQLInsertClause set(Path<T> path, T value) {
    this.columns.add(path);
    if (value instanceof Expression) {
      this.values.add((Expression)value);
    } else if (value != null) {
      this.values.add(ConstantImpl.create(value));
    } else {
      this.values.add(Null.CONSTANT);
    } 
    return this;
  }
  
  public <T> SQLInsertClause set(Path<T> path, Expression<? extends T> expression) {
    this.columns.add(path);
    this.values.add(expression);
    return this;
  }
  
  public <T> SQLInsertClause setNull(Path<T> path) {
    this.columns.add(path);
    this.values.add(Null.CONSTANT);
    return this;
  }
  
  public SQLInsertClause values(Object... v) {
    for (Object value : v) {
      if (value instanceof Expression) {
        this.values.add((Expression)value);
      } else if (value != null) {
        this.values.add(ConstantImpl.create(value));
      } else {
        this.values.add(Null.CONSTANT);
      } 
    } 
    return this;
  }
  
  public String toString() {
    SQLSerializer serializer = createSerializer();
    serializer.serializeInsert(this.metadata, this.entity, this.columns, this.values, this.subQuery);
    return serializer.toString();
  }
  
  public SQLInsertClause populate(Object bean) { return populate(bean, DefaultMapper.DEFAULT); }
  
  public <T> SQLInsertClause populate(T obj, Mapper<T> mapper) {
    Map<Path<?>, Object> values = mapper.createMap(this.entity, obj);
    for (Map.Entry<Path<?>, Object> entry : values.entrySet())
      set((Path)entry.getKey(), entry.getValue()); 
    return this;
  }
  
  public boolean isEmpty() { return (this.values.isEmpty() && this.batches.isEmpty()); }
  
  public int getBatchCount() { return this.batches.size(); }
}
