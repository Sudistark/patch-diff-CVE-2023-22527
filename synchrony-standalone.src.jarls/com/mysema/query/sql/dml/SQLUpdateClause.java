package com.mysema.query.sql.dml;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.mysema.commons.lang.Pair;
import com.mysema.query.DefaultQueryMetadata;
import com.mysema.query.FilteredClause;
import com.mysema.query.JoinType;
import com.mysema.query.QueryFlag;
import com.mysema.query.QueryMetadata;
import com.mysema.query.QueryModifiers;
import com.mysema.query.dml.StoreClause;
import com.mysema.query.dml.UpdateClause;
import com.mysema.query.sql.Configuration;
import com.mysema.query.sql.RelationalPath;
import com.mysema.query.sql.SQLBindings;
import com.mysema.query.sql.SQLSerializer;
import com.mysema.query.sql.SQLTemplates;
import com.mysema.query.sql.types.Null;
import com.mysema.query.types.ConstantImpl;
import com.mysema.query.types.Expression;
import com.mysema.query.types.Path;
import com.mysema.query.types.Predicate;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import javax.annotation.Nonnegative;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SQLUpdateClause extends AbstractSQLClause<SQLUpdateClause> implements UpdateClause<SQLUpdateClause> {
  private static final Logger logger = LoggerFactory.getLogger(SQLInsertClause.class);
  
  private final Connection connection;
  
  private final RelationalPath<?> entity;
  
  private final List<SQLUpdateBatch> batches = new ArrayList();
  
  private List<Pair<Path<?>, Expression<?>>> updates = new ArrayList();
  
  private QueryMetadata metadata = new DefaultQueryMetadata();
  
  private String queryString;
  
  private List<Object> constants;
  
  public SQLUpdateClause(Connection connection, SQLTemplates templates, RelationalPath<?> entity) { this(connection, new Configuration(templates), entity); }
  
  public SQLUpdateClause(Connection connection, Configuration configuration, RelationalPath<?> entity) {
    super(configuration);
    this.connection = connection;
    this.entity = entity;
    this.metadata.addJoin(JoinType.DEFAULT, entity);
  }
  
  public SQLUpdateClause addFlag(QueryFlag.Position position, String flag) {
    this.metadata.addFlag(new QueryFlag(position, flag));
    return this;
  }
  
  public SQLUpdateClause addFlag(QueryFlag.Position position, Expression<?> flag) {
    this.metadata.addFlag(new QueryFlag(position, flag));
    return this;
  }
  
  public SQLUpdateClause addBatch() {
    this.batches.add(new SQLUpdateBatch(this.metadata, this.updates));
    this.updates = new ArrayList();
    this.metadata = new DefaultQueryMetadata();
    this.metadata.addJoin(JoinType.DEFAULT, this.entity);
    return this;
  }
  
  private PreparedStatement createStatement() throws SQLException {
    this.listeners.preRender(this.context);
    SQLSerializer serializer = createSerializer();
    serializer.serializeUpdate(this.metadata, this.entity, this.updates);
    this.queryString = serializer.toString();
    this.constants = serializer.getConstants();
    logQuery(logger, this.queryString, this.constants);
    this.context.addSQL(this.queryString);
    this.listeners.prepared(this.context);
    this.listeners.prePrepare(this.context);
    PreparedStatement stmt = this.connection.prepareStatement(this.queryString);
    setParameters(stmt, serializer.getConstants(), serializer.getConstantPaths(), this.metadata.getParams());
    this.context.addPreparedStatement(stmt);
    this.listeners.prepared(this.context);
    return stmt;
  }
  
  private Collection<PreparedStatement> createStatements() throws SQLException {
    boolean addBatches = !this.configuration.getUseLiterals();
    this.listeners.preRender(this.context);
    SQLSerializer serializer = createSerializer();
    serializer.serializeUpdate(((SQLUpdateBatch)this.batches.get(0)).getMetadata(), this.entity, ((SQLUpdateBatch)this.batches.get(0)).getUpdates());
    this.queryString = serializer.toString();
    this.constants = serializer.getConstants();
    logQuery(logger, this.queryString, this.constants);
    this.context.addSQL(this.queryString);
    this.listeners.rendered(this.context);
    Map<String, PreparedStatement> stmts = Maps.newHashMap();
    this.listeners.prePrepare(this.context);
    PreparedStatement stmt = this.connection.prepareStatement(this.queryString);
    setParameters(stmt, serializer.getConstants(), serializer.getConstantPaths(), this.metadata.getParams());
    if (addBatches)
      stmt.addBatch(); 
    stmts.put(serializer.toString(), stmt);
    this.context.addPreparedStatement(stmt);
    this.listeners.prepared(this.context);
    for (int i = 1; i < this.batches.size(); i++) {
      this.listeners.preRender(this.context);
      serializer = createSerializer();
      serializer.serializeUpdate(((SQLUpdateBatch)this.batches.get(i)).getMetadata(), this.entity, ((SQLUpdateBatch)this.batches.get(i)).getUpdates());
      this.context.addSQL(serializer.toString());
      this.listeners.rendered(this.context);
      stmt = (PreparedStatement)stmts.get(serializer.toString());
      if (stmt == null) {
        this.listeners.prePrepare(this.context);
        stmt = this.connection.prepareStatement(serializer.toString());
        stmts.put(serializer.toString(), stmt);
        this.context.addPreparedStatement(stmt);
        this.listeners.prepared(this.context);
      } 
      setParameters(stmt, serializer.getConstants(), serializer.getConstantPaths(), this.metadata.getParams());
      if (addBatches)
        stmt.addBatch(); 
    } 
    return stmts.values();
  }
  
  public long execute() {
    this.context = startContext(this.connection, this.metadata, this.entity);
    stmt = null;
    stmts = null;
    try {
      if (this.batches.isEmpty()) {
        stmt = createStatement();
        this.listeners.notifyUpdate(this.entity, this.metadata, this.updates);
        this.listeners.preExecute(this.context);
        int rc = stmt.executeUpdate();
        this.listeners.executed(this.context);
        return rc;
      } 
      stmts = createStatements();
      this.listeners.notifyUpdates(this.entity, this.batches);
      this.listeners.preExecute(this.context);
      long rc = executeBatch(stmts);
      this.listeners.executed(this.context);
      return rc;
    } catch (SQLException e) {
      onException(this.context, e);
      throw this.configuration.translate(this.queryString, this.constants, e);
    } finally {
      if (stmt != null)
        close(stmt); 
      if (stmts != null)
        close(stmts); 
      reset();
      endContext(this.context);
    } 
  }
  
  public List<SQLBindings> getSQL() {
    if (this.batches.isEmpty()) {
      SQLSerializer serializer = createSerializer();
      serializer.serializeUpdate(this.metadata, this.entity, this.updates);
      return ImmutableList.of(createBindings(this.metadata, serializer));
    } 
    ImmutableList.Builder<SQLBindings> builder = ImmutableList.builder();
    for (SQLUpdateBatch batch : this.batches) {
      SQLSerializer serializer = createSerializer();
      serializer.serializeUpdate(batch.getMetadata(), this.entity, batch.getUpdates());
      builder.add(createBindings(this.metadata, serializer));
    } 
    return builder.build();
  }
  
  public <T> SQLUpdateClause set(Path<T> path, T value) {
    if (value instanceof Expression) {
      this.updates.add(Pair.of(path, (Expression)value));
    } else if (value != null) {
      this.updates.add(Pair.of(path, ConstantImpl.create(value)));
    } else {
      setNull(path);
    } 
    return this;
  }
  
  public <T> SQLUpdateClause set(Path<T> path, Expression<? extends T> expression) {
    if (expression != null) {
      this.updates.add(Pair.of(path, expression));
    } else {
      setNull(path);
    } 
    return this;
  }
  
  public <T> SQLUpdateClause setNull(Path<T> path) {
    this.updates.add(Pair.of(path, Null.CONSTANT));
    return this;
  }
  
  public SQLUpdateClause set(List<? extends Path<?>> paths, List<?> values) {
    for (int i = 0; i < paths.size(); i++) {
      if (values.get(i) instanceof Expression) {
        this.updates.add(Pair.of(paths.get(i), (Expression)values.get(i)));
      } else if (values.get(i) != null) {
        this.updates.add(Pair.of(paths.get(i), ConstantImpl.create(values.get(i))));
      } else {
        this.updates.add(Pair.of(paths.get(i), Null.CONSTANT));
      } 
    } 
    return this;
  }
  
  public SQLUpdateClause where(Predicate p) {
    this.metadata.addWhere(p);
    return this;
  }
  
  public SQLUpdateClause where(Predicate... o) {
    for (Predicate p : o)
      this.metadata.addWhere(p); 
    return this;
  }
  
  public SQLUpdateClause limit(@Nonnegative long limit) {
    this.metadata.setModifiers(QueryModifiers.limit(limit));
    return this;
  }
  
  public String toString() {
    SQLSerializer serializer = createSerializer();
    serializer.serializeUpdate(this.metadata, this.entity, this.updates);
    return serializer.toString();
  }
  
  public SQLUpdateClause populate(Object bean) { return populate(bean, DefaultMapper.DEFAULT); }
  
  public <T> SQLUpdateClause populate(T obj, Mapper<T> mapper) {
    Collection<? extends Path<?>> primaryKeyColumns = (this.entity.getPrimaryKey() != null) ? this.entity.getPrimaryKey().getLocalColumns() : Collections.emptyList();
    Map<Path<?>, Object> values = mapper.createMap(this.entity, obj);
    for (Map.Entry<Path<?>, Object> entry : values.entrySet()) {
      if (!primaryKeyColumns.contains(entry.getKey()))
        set((Path)entry.getKey(), entry.getValue()); 
    } 
    return this;
  }
  
  public boolean isEmpty() { return (this.updates.isEmpty() && this.batches.isEmpty()); }
  
  public int getBatchCount() { return this.batches.size(); }
}
