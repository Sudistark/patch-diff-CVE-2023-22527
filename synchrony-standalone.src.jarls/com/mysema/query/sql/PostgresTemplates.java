package com.mysema.query.sql;

import com.google.common.collect.ImmutableSet;
import com.mysema.query.types.Operator;
import com.mysema.query.types.Ops;
import java.util.Set;

public class PostgresTemplates extends SQLTemplates {
  protected static final Set<String> POSTGRES_RESERVED_WORDS = ImmutableSet.of("ALL", "ANALYSE", "ANALYZE", "AND", "ANY", "ARRAY", new String[] { 
        "AS", "ASC", "ASYMMETRIC", "AUTHORIZATION", "BINARY", "BOTH", "CASE", "CAST", "CHECK", "COLLATE", 
        "COLLATION", "COLUMN", "CONCURRENTLY", "CONSTRAINT", "CREATE", "CROSS", "CURRENT_CATALOG", "CURRENT_DATE", "CURRENT_ROLE", "CURRENT_SCHEMA", 
        "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "DEFAULT", "DEFERRABLE", "DESC", "DISTINCT", "DO", "ELSE", "END", 
        "EXCEPT", "FALSE", "FETCH", "FOR", "FOREIGN", "FREEZE", "FROM", "FULL", "GRANT", "GROUP", 
        "HAVING", "ILIKE", "IN", "INITIALLY", "INNER", "INTERSECT", "INTO", "IS", "ISNULL", "JOIN", 
        "LATERAL", "LEADING", "LEFT", "LIKE", "LIMIT", "LOCALTIME", "LOCALTIMESTAMP", "NATURAL", "NOT", "NOTNULL", 
        "NULL", "OFFSET", "ON", "ONLY", "OR", "ORDER", "OUTER", "OVER", "OVERLAPS", "PLACING", 
        "PRIMARY", "REFERENCES", "RETURNING", "RIGHT", "SELECT", "SESSION_USER", "SIMILAR", "SOME", "SYMMETRIC", "TABLE", 
        "THEN", "TO", "TRAILING", "TRUE", "UNION", "UNIQUE", "USER", "USING", "VARIADIC", "VERBOSE", 
        "WHEN", "WHERE", "WINDOW", "WITH" });
  
  public static final PostgresTemplates DEFAULT = new PostgresTemplates();
  
  public static SQLTemplates.Builder builder() { return new Object(); }
  
  public PostgresTemplates() { this('\\', false); }
  
  public PostgresTemplates(boolean quote) { this('\\', quote); }
  
  public PostgresTemplates(char escape, boolean quote) {
    super(POSTGRES_RESERVED_WORDS, "\"", escape, quote);
    setDummyTable(null);
    setCountDistinctMultipleColumns(true);
    setCountViaAnalytics(true);
    setDefaultValues("\ndefault values");
    setSupportsUnquotedReservedWordsAsIdentifier(true);
    setPrecedence(47, new Operator[] { Ops.IS_NULL, Ops.IS_NOT_NULL });
    setPrecedence(48, new Operator[] { Ops.CONCAT, Ops.MATCHES });
    setPrecedence(49, new Operator[] { Ops.IN });
    setPrecedence(50, new Operator[] { Ops.BETWEEN });
    setPrecedence(51, new Operator[] { Ops.LIKE, Ops.LIKE_ESCAPE });
    setPrecedence(52, new Operator[] { Ops.LT, Ops.GT, Ops.LOE, Ops.GOE });
    setPrecedence(53, new Operator[] { Ops.EQ, Ops.EQ_IGNORE_CASE });
    setPrecedence(51, OTHER_LIKE_CASES);
    add(Ops.MOD, "{0} % {1}", 30);
    add(Ops.MATCHES, "{0} ~ {1}");
    add(Ops.INDEX_OF, "strpos({0},{1})-1", 40);
    add(Ops.INDEX_OF_2ARGS, "strpos({0},{1})-1", 40);
    add(Ops.StringOps.LOCATE, "strpos({1},{0})");
    add(Ops.StringOps.LOCATE2, "strpos(repeat('^',{2s}-1) || substr({1},{2s}),{0})");
    add(Ops.LIKE_ESCAPE_IC, "{0} ilike {1} escape '{2s}'");
    if (escape == '\\') {
      add(Ops.LIKE, "{0} like {1}");
      add(Ops.LIKE_IC, "{0} ilike {1}");
      add(Ops.ENDS_WITH, "{0} like {%1}");
      add(Ops.ENDS_WITH_IC, "{0} ilike {%1}");
      add(Ops.STARTS_WITH, "{0} like {1%}");
      add(Ops.STARTS_WITH_IC, "{0} ilike {1%}");
      add(Ops.STRING_CONTAINS, "{0} like {%1%}");
      add(Ops.STRING_CONTAINS_IC, "{0} ilike {%1%}");
    } else {
      add(Ops.LIKE_IC, "{0} ilike {1} escape '" + escape + "'");
      add(Ops.ENDS_WITH_IC, "{0} ilike {%1} escape '" + escape + "'");
      add(Ops.STARTS_WITH_IC, "{0} ilike {1%} escape '" + escape + "'");
      add(Ops.STRING_CONTAINS_IC, "{0} ilike {%1%} escape '" + escape + "'");
    } 
    add(Ops.MathOps.RANDOM, "random()");
    add(Ops.MathOps.LN, "ln({0})");
    add(Ops.MathOps.LOG, "log({1},{0})");
    add(Ops.MathOps.COSH, "(exp({0}) + exp({0} * -1)) / 2");
    add(Ops.MathOps.COTH, "(exp({0} * 2) + 1) / (exp({0} * 2) - 1)");
    add(Ops.MathOps.SINH, "(exp({0}) - exp({0} * -1)) / 2");
    add(Ops.MathOps.TANH, "(exp({0} * 2) - 1) / (exp({0} * 2) + 1)");
    add(Ops.DateTimeOps.DAY_OF_WEEK, "extract(dow from {0}) + 1");
    add(Ops.DateTimeOps.DAY_OF_YEAR, "extract(doy from {0})");
    add(Ops.DateTimeOps.YEAR_WEEK, "(extract(isoyear from {0}) * 100 + extract(week from {0}))");
    add(Ops.AggOps.BOOLEAN_ANY, "bool_or({0})", 0);
    add(Ops.AggOps.BOOLEAN_ALL, "bool_and({0})", 0);
    add(Ops.DateTimeOps.ADD_YEARS, "{0} + interval '{1s} years'");
    add(Ops.DateTimeOps.ADD_MONTHS, "{0} + interval '{1s} months'");
    add(Ops.DateTimeOps.ADD_WEEKS, "{0} + interval '{1s} weeks'");
    add(Ops.DateTimeOps.ADD_DAYS, "{0} + interval '{1s} days'");
    add(Ops.DateTimeOps.ADD_HOURS, "{0} + interval '{1s} hours'");
    add(Ops.DateTimeOps.ADD_MINUTES, "{0} + interval '{1s} minutes'");
    add(Ops.DateTimeOps.ADD_SECONDS, "{0} + interval '{1s} seconds'");
    String yearsDiff = "date_part('year', age({1}, {0}))";
    String monthsDiff = "(" + yearsDiff + " * 12 + date_part('month', age({1}, {0})))";
    String weeksDiff = "trunc((cast({1} as date) - cast({0} as date))/7)";
    String daysDiff = "(cast({1} as date) - cast({0} as date))";
    String hoursDiff = "(" + daysDiff + " * 24 + date_part('hour', age({1}, {0})))";
    String minutesDiff = "(" + hoursDiff + " * 60 + date_part('minute', age({1}, {0})))";
    String secondsDiff = "(" + minutesDiff + " * 60 + date_part('second', age({1}, {0})))";
    add(Ops.DateTimeOps.DIFF_YEARS, yearsDiff);
    add(Ops.DateTimeOps.DIFF_MONTHS, monthsDiff);
    add(Ops.DateTimeOps.DIFF_WEEKS, weeksDiff);
    add(Ops.DateTimeOps.DIFF_DAYS, daysDiff);
    add(Ops.DateTimeOps.DIFF_HOURS, hoursDiff);
    add(Ops.DateTimeOps.DIFF_MINUTES, minutesDiff);
    add(Ops.DateTimeOps.DIFF_SECONDS, secondsDiff);
    addTypeNameToCode("bool", -7, true);
    addTypeNameToCode("bytea", -2);
    addTypeNameToCode("name", 12);
    addTypeNameToCode("int8", -5, true);
    addTypeNameToCode("bigserial", -5);
    addTypeNameToCode("int2", 5, true);
    addTypeNameToCode("int2", -6, true);
    addTypeNameToCode("int4", 4, true);
    addTypeNameToCode("serial", 4);
    addTypeNameToCode("text", 12);
    addTypeNameToCode("oid", -5);
    addTypeNameToCode("xml", 2009, true);
    addTypeNameToCode("float4", 7, true);
    addTypeNameToCode("float8", 8, true);
    addTypeNameToCode("bpchar", 1);
    addTypeNameToCode("timestamptz", 93);
  }
  
  public String serialize(String literal, int jdbcType) {
    if (jdbcType == 16)
      return "1".equals(literal) ? "true" : "false"; 
    return super.serialize(literal, jdbcType);
  }
}
