package com.mysema.query.util;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.ClassToInstanceMap;
import com.google.common.collect.ImmutableClassToInstanceMap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.primitives.Primitives;
import com.mysema.query.types.ExpressionException;
import com.mysema.util.ArrayUtils;
import java.lang.reflect.Constructor;
import java.util.Arrays;
import java.util.Iterator;

public class ConstructorUtils {
  private static final Class<?>[] NO_ARGS = new Class[0];
  
  private static final ClassToInstanceMap<Object> defaultPrimitives = ImmutableClassToInstanceMap.builder()
    .put(boolean.class, Boolean.valueOf(false))
    .put(byte.class, Byte.valueOf((byte)0))
    .put(char.class, Character.valueOf(false))
    .put(short.class, Short.valueOf((short)0))
    .put(int.class, Integer.valueOf(0))
    .put(long.class, Long.valueOf(0L))
    .put(float.class, Float.valueOf(0.0F))
    .put(double.class, Double.valueOf(0.0D))
    .build();
  
  public static <C> Constructor<C> getConstructor(Class<C> type, Class[] givenTypes) throws NoSuchMethodException { return type.getConstructor(givenTypes); }
  
  public static Class<?>[] getConstructorParameters(Class<?> type, Class[] givenTypes) {
    label33: for (Constructor<?> constructor : type.getConstructors()) {
      int matches = 0;
      Class[] parameters = constructor.getParameterTypes();
      Iterator<Class<?>> parameterIterator = Arrays.asList(parameters).iterator();
      if (!ArrayUtils.isEmpty(givenTypes) && 
        !ArrayUtils.isEmpty(parameters)) {
        Class<?> parameter = null;
        for (Class<?> argument : givenTypes) {
          if (parameterIterator.hasNext()) {
            parameter = (Class)parameterIterator.next();
            if (!compatible(parameter, argument))
              continue label33; 
            matches++;
          } else if (constructor.isVarArgs()) {
            if (!compatible(parameter, argument))
              continue label33; 
          } else {
            continue label33;
          } 
        } 
        if (matches == parameters.length)
          return parameters; 
      } else if (ArrayUtils.isEmpty(givenTypes) && 
        ArrayUtils.isEmpty(parameters)) {
        return NO_ARGS;
      } 
    } 
    throw new ExpressionException("No constructor found for " + type.toString() + " with parameters: " + 
        Arrays.deepToString(givenTypes));
  }
  
  public static Iterable<Function<Object[], Object[]>> getTransformers(Constructor<?> constructor) {
    Iterable<ArgumentTransformer> transformers = Lists.newArrayList(new ArgumentTransformer[] { new PrimitiveAwareVarArgsTransformer(constructor), new PrimitiveTransformer(constructor, null), new VarArgsTransformer(constructor, null) });
    return ImmutableList.copyOf(Iterables.filter(transformers, applicableFilter));
  }
  
  private static Class<?> normalize(Class<?> clazz) {
    if (clazz.isArray())
      clazz = clazz.getComponentType(); 
    return Primitives.wrap(clazz);
  }
  
  private static boolean compatible(Class<?> parameter, Class<?> argument) {
    return normalize(parameter).isAssignableFrom(normalize(argument));
  }
  
  private static final Predicate<ArgumentTransformer> applicableFilter = new Object();
}
