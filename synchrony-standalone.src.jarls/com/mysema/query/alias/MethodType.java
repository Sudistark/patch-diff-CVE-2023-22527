package com.mysema.query.alias;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.regex.Pattern;
import javax.annotation.Nullable;

public static enum MethodType {
  GET_MAPPED_PATH("__mappedPath", com.mysema.query.types.EntityPath.class, ManagedObject.class, new Class[0]),
  GETTER("(get|is).+", Object.class, Object.class, new Class[0]),
  HASH_CODE("hashCode", int.class, Object.class, new Class[0]),
  LIST_ACCESS("get", Object.class, java.util.List.class, new Class[] { int.class }),
  MAP_ACCESS("get", Object.class, java.util.Map.class, new Class[] { Object.class }),
  SIZE("size", int.class, Object.class, new Class[0]),
  TO_STRING("toString", String.class, Object.class, new Class[0]),
  SCALA_GETTER(".+", Object.class, Object.class, new Class[0]),
  SCALA_LIST_ACCESS("apply", Object.class, Object.class, new Class[] { int.class }),
  SCALA_MAP_ACCESS("apply", Object.class, Object.class, new Class[] { Object.class });
  
  private final Pattern pattern;
  
  private final Class<?> returnType;
  
  private final Class<?> ownerType;
  
  private final Class<?>[] paramTypes;
  
  MethodType(String namePattern, Class<?> returnType, Class<?> ownerType, Class... paramTypes) {
    this.pattern = Pattern.compile(namePattern);
    this.returnType = returnType;
    this.ownerType = ownerType;
    this.paramTypes = paramTypes;
  }
  
  @Nullable
  public static MethodType get(Method method) {
    for (MethodType methodType : values()) {
      if (methodType.pattern.matcher(method.getName()).matches() && (methodType.returnType == Object.class || methodType.returnType
        .isAssignableFrom(method.getReturnType())) && (methodType.ownerType == Object.class || methodType.ownerType
        .isAssignableFrom(method.getDeclaringClass())) && 
        Arrays.equals(methodType.paramTypes, method.getParameterTypes()))
        return methodType; 
    } 
    return null;
  }
}
