package com.mysema.util;

import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;
import java.util.HashSet;
import java.util.Set;
import javax.annotation.Nullable;

public final class ReflectionUtils {
  private static final AnnotatedElement EMPTY = new Annotations(new AnnotatedElement[0]);
  
  public static AnnotatedElement getAnnotatedElement(Class<?> beanClass, String propertyName, Class<?> propertyClass) {
    Field field = getFieldOrNull(beanClass, propertyName);
    Method method = getGetterOrNull(beanClass, propertyName, propertyClass);
    if (field == null || field.getAnnotations().length == 0)
      return (method != null && method.getAnnotations().length > 0) ? method : EMPTY; 
    if (method == null || method.getAnnotations().length == 0)
      return field; 
    return new Annotations(new AnnotatedElement[] { field, method });
  }
  
  @Nullable
  public static Field getFieldOrNull(Class<?> beanClass, String propertyName) {
    while (beanClass != null && !beanClass.equals(Object.class)) {
      try {
        return beanClass.getDeclaredField(propertyName);
      } catch (SecurityException securityException) {
      
      } catch (NoSuchFieldException noSuchFieldException) {}
      beanClass = beanClass.getSuperclass();
    } 
    return null;
  }
  
  @Nullable
  public static Method getGetterOrNull(Class<?> beanClass, String name) {
    Method method = getGetterOrNull(beanClass, name, Object.class);
    if (method != null)
      return method; 
    return getGetterOrNull(beanClass, name, Boolean.class);
  }
  
  @Nullable
  public static Method getGetterOrNull(Class<?> beanClass, String name, Class<?> type) {
    String methodName = ((type.equals(Boolean.class) || type.equals(boolean.class)) ? "is" : "get") + BeanUtils.capitalize(name);
    while (beanClass != null && !beanClass.equals(Object.class)) {
      try {
        return beanClass.getDeclaredMethod(methodName, new Class[0]);
      } catch (SecurityException securityException) {
      
      } catch (NoSuchMethodException noSuchMethodException) {}
      beanClass = beanClass.getSuperclass();
    } 
    return null;
  }
  
  public static int getTypeParameterCount(Type type) {
    if (type instanceof ParameterizedType)
      return ((ParameterizedType)type).getActualTypeArguments().length; 
    if (type instanceof TypeVariable)
      return getTypeParameterCount(((TypeVariable)type).getBounds()[0]); 
    return 0;
  }
  
  public static Class<?> getTypeParameterAsClass(Type type, int index) {
    Type parameter = getTypeParameter(type, index);
    if (parameter != null)
      return asClass(parameter); 
    return null;
  }
  
  @Nullable
  public static Type getTypeParameter(Type type, int index) {
    if (type instanceof ParameterizedType)
      return ((ParameterizedType)type).getActualTypeArguments()[index]; 
    if (type instanceof TypeVariable)
      return getTypeParameter(((TypeVariable)type).getBounds()[0], index); 
    return null;
  }
  
  private static Class<?> asClass(Type type) {
    if (type instanceof WildcardType) {
      WildcardType wildcardType = (WildcardType)type;
      if (wildcardType.getUpperBounds()[0] instanceof Class)
        return (Class)wildcardType.getUpperBounds()[0]; 
      if (wildcardType.getUpperBounds()[0] instanceof ParameterizedType)
        return (Class)((ParameterizedType)wildcardType.getUpperBounds()[0]).getRawType(); 
      return Object.class;
    } 
    if (type instanceof TypeVariable)
      return asClass(((TypeVariable)type).getBounds()[0]); 
    if (type instanceof ParameterizedType)
      return (Class)((ParameterizedType)type).getRawType(); 
    if (type instanceof GenericArrayType) {
      Type component = ((GenericArrayType)type).getGenericComponentType();
      return Array.newInstance(asClass(component), 0).getClass();
    } 
    if (type instanceof Class)
      return (Class)type; 
    throw new IllegalArgumentException(type.getClass().toString());
  }
  
  public static Set<Class<?>> getSuperClasses(Class<?> cl) {
    Set<Class<?>> classes = new HashSet<Class<?>>();
    Class<?> c = cl;
    while (c != null) {
      classes.add(c);
      c = c.getSuperclass();
    } 
    return classes;
  }
  
  public static Set<Field> getFields(Class<?> cl) {
    Set<Field> fields = new HashSet<Field>();
    Class<?> c = cl;
    while (c != null) {
      fields.addAll(Arrays.asList(c.getDeclaredFields()));
      c = c.getSuperclass();
    } 
    return fields;
  }
  
  public static Set<Class<?>> getImplementedInterfaces(Class<?> cl) {
    Set<Class<?>> interfaces = new HashSet<Class<?>>();
    Deque<Class<?>> classes = new ArrayDeque<Class<?>>();
    classes.add(cl);
    while (!classes.isEmpty()) {
      Class<?> c = (Class)classes.pop();
      interfaces.addAll(Arrays.asList(c.getInterfaces()));
      if (c.getSuperclass() != null)
        classes.add(c.getSuperclass()); 
      classes.addAll(Arrays.asList(c.getInterfaces()));
    } 
    return interfaces;
  }
}
