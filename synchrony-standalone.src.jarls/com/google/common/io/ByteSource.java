package com.google.common.io;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.hash.Funnels;
import com.google.common.hash.HashCode;
import com.google.common.hash.HashFunction;
import com.google.common.hash.Hasher;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.Iterator;

@ElementTypesAreNonnullByDefault
@J2ktIncompatible
@GwtIncompatible
public abstract class ByteSource {
  public CharSource asCharSource(Charset charset) { return new AsCharSource(this, charset); }
  
  public abstract InputStream openStream() throws IOException;
  
  public InputStream openBufferedStream() throws IOException {
    InputStream in = openStream();
    return (in instanceof BufferedInputStream) ? 
      (BufferedInputStream)in : 
      new BufferedInputStream(in);
  }
  
  public ByteSource slice(long offset, long length) { return new SlicedByteSource(this, offset, length); }
  
  public boolean isEmpty() throws IOException {
    Optional<Long> sizeIfKnown = sizeIfKnown();
    if (sizeIfKnown.isPresent())
      return (((Long)sizeIfKnown.get()).longValue() == 0L); 
    closer = Closer.create();
    try {
      InputStream in = (InputStream)closer.register(openStream());
      return (in.read() == -1);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    } 
  }
  
  public Optional<Long> sizeIfKnown() { return Optional.absent(); }
  
  public long size() throws IOException {
    Optional<Long> sizeIfKnown = sizeIfKnown();
    if (sizeIfKnown.isPresent())
      return ((Long)sizeIfKnown.get()).longValue(); 
    closer = Closer.create();
    try {
      InputStream in = (InputStream)closer.register(openStream());
      return countBySkipping(in);
    } catch (IOException iOException) {
    
    } finally {
      closer.close();
    } 
    closer = Closer.create();
    try {
      InputStream in = (InputStream)closer.register(openStream());
      return ByteStreams.exhaust(in);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    } 
  }
  
  private long countBySkipping(InputStream in) throws IOException {
    long count = 0L;
    long skipped;
    while ((skipped = ByteStreams.skipUpTo(in, 2147483647L)) > 0L)
      count += skipped; 
    return count;
  }
  
  @CanIgnoreReturnValue
  public long copyTo(OutputStream output) throws IOException {
    Preconditions.checkNotNull(output);
    closer = Closer.create();
    try {
      InputStream in = (InputStream)closer.register(openStream());
      return ByteStreams.copy(in, output);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    } 
  }
  
  @CanIgnoreReturnValue
  public long copyTo(ByteSink sink) throws IOException {
    Preconditions.checkNotNull(sink);
    closer = Closer.create();
    try {
      InputStream in = (InputStream)closer.register(openStream());
      OutputStream out = (OutputStream)closer.register(sink.openStream());
      return ByteStreams.copy(in, out);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    } 
  }
  
  public byte[] read() throws IOException {
    closer = Closer.create();
    try {
      InputStream in = (InputStream)closer.register(openStream());
      Optional<Long> size = sizeIfKnown();
      return size.isPresent() ? 
        ByteStreams.toByteArray(in, ((Long)size.get()).longValue()) : 
        ByteStreams.toByteArray(in);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    } 
  }
  
  @ParametricNullness
  @CanIgnoreReturnValue
  public <T> T read(ByteProcessor<T> processor) throws IOException {
    Preconditions.checkNotNull(processor);
    closer = Closer.create();
    try {
      InputStream in = (InputStream)closer.register(openStream());
      object = ByteStreams.readBytes(in, processor);
      return (T)object;
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    } 
  }
  
  public HashCode hash(HashFunction hashFunction) throws IOException {
    Hasher hasher = hashFunction.newHasher();
    copyTo(Funnels.asOutputStream(hasher));
    return hasher.hash();
  }
  
  public boolean contentEquals(ByteSource other) throws IOException {
    Preconditions.checkNotNull(other);
    byte[] buf1 = ByteStreams.createBuffer();
    byte[] buf2 = ByteStreams.createBuffer();
    closer = Closer.create();
    try {
      int read1;
      InputStream in1 = (InputStream)closer.register(openStream());
      InputStream in2 = (InputStream)closer.register(other.openStream());
      do {
        read1 = ByteStreams.read(in1, buf1, 0, buf1.length);
        int read2 = ByteStreams.read(in2, buf2, 0, buf2.length);
        if (read1 != read2 || !Arrays.equals(buf1, buf2))
          return false; 
      } while (read1 == buf1.length);
      return true;
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    } 
  }
  
  public static ByteSource concat(Iterable<? extends ByteSource> sources) { return new ConcatenatedByteSource(sources); }
  
  public static ByteSource concat(Iterator<? extends ByteSource> sources) { return concat(ImmutableList.copyOf(sources)); }
  
  public static ByteSource concat(ByteSource... sources) { return concat(ImmutableList.copyOf(sources)); }
  
  public static ByteSource wrap(byte[] b) { return new ByteArrayByteSource(b); }
  
  public static ByteSource empty() { return EmptyByteSource.INSTANCE; }
}
