package com.google.common.io;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.MustBeClosed;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.io.UncheckedIOException;
import java.io.Writer;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.List;
import java.util.function.Consumer;
import java.util.stream.Stream;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@J2ktIncompatible
@GwtIncompatible
public abstract class CharSource {
  public ByteSource asByteSource(Charset charset) { return new AsByteSource(this, charset); }
  
  public BufferedReader openBufferedStream() throws IOException {
    Reader reader = openStream();
    return (reader instanceof BufferedReader) ? 
      (BufferedReader)reader : 
      new BufferedReader(reader);
  }
  
  @MustBeClosed
  public Stream<String> lines() throws IOException {
    BufferedReader reader = openBufferedStream();
    return (Stream)reader
      .lines()
      .onClose(() -> {
          try {
            reader.close();
          } catch (IOException e) {
            throw new UncheckedIOException(e);
          } 
        });
  }
  
  public Optional<Long> lengthIfKnown() { return Optional.absent(); }
  
  public long length() throws IOException {
    Optional<Long> lengthIfKnown = lengthIfKnown();
    if (lengthIfKnown.isPresent())
      return ((Long)lengthIfKnown.get()).longValue(); 
    closer = Closer.create();
    try {
      Reader reader = (Reader)closer.register(openStream());
      return countBySkipping(reader);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    } 
  }
  
  private long countBySkipping(Reader reader) throws IOException {
    long count = 0L;
    long read;
    while ((read = reader.skip(Float.MAX_VALUE)) != 0L)
      count += read; 
    return count;
  }
  
  @CanIgnoreReturnValue
  public long copyTo(Appendable appendable) throws IOException {
    Preconditions.checkNotNull(appendable);
    closer = Closer.create();
    try {
      Reader reader = (Reader)closer.register(openStream());
      return CharStreams.copy(reader, appendable);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    } 
  }
  
  @CanIgnoreReturnValue
  public long copyTo(CharSink sink) throws IOException {
    Preconditions.checkNotNull(sink);
    closer = Closer.create();
    try {
      Reader reader = (Reader)closer.register(openStream());
      Writer writer = (Writer)closer.register(sink.openStream());
      return CharStreams.copy(reader, writer);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    } 
  }
  
  public String read() throws IOException {
    closer = Closer.create();
    try {
      Reader reader = (Reader)closer.register(openStream());
      return CharStreams.toString(reader);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    } 
  }
  
  @CheckForNull
  public String readFirstLine() throws IOException {
    closer = Closer.create();
    try {
      BufferedReader reader = (BufferedReader)closer.register(openBufferedStream());
      return reader.readLine();
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    } 
  }
  
  public ImmutableList<String> readLines() throws IOException {
    closer = Closer.create();
    try {
      BufferedReader reader = (BufferedReader)closer.register(openBufferedStream());
      List<String> result = Lists.newArrayList();
      String line;
      while ((line = reader.readLine()) != null)
        result.add(line); 
      return ImmutableList.copyOf(result);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    } 
  }
  
  @ParametricNullness
  @CanIgnoreReturnValue
  public <T> T readLines(LineProcessor<T> processor) throws IOException {
    Preconditions.checkNotNull(processor);
    closer = Closer.create();
    try {
      Reader reader = (Reader)closer.register(openStream());
      object = CharStreams.readLines(reader, processor);
      return (T)object;
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    } 
  }
  
  public void forEachLine(Consumer<? super String> action) throws IOException {
    try {
      Stream<String> lines = lines();
      try {
        lines.forEachOrdered(action);
        if (lines != null)
          lines.close(); 
      } catch (Throwable throwable) {
        if (lines != null)
          try {
            lines.close();
          } catch (Throwable throwable1) {
            throwable.addSuppressed(throwable1);
          }  
        throw throwable;
      } 
    } catch (UncheckedIOException e) {
      throw e.getCause();
    } 
  }
  
  public boolean isEmpty() throws IOException {
    Optional<Long> lengthIfKnown = lengthIfKnown();
    if (lengthIfKnown.isPresent())
      return (((Long)lengthIfKnown.get()).longValue() == 0L); 
    closer = Closer.create();
    try {
      Reader reader = (Reader)closer.register(openStream());
      return (reader.read() == -1);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    } 
  }
  
  public static CharSource concat(Iterable<? extends CharSource> sources) { return new ConcatenatedCharSource(sources); }
  
  public static CharSource concat(Iterator<? extends CharSource> sources) { return concat(ImmutableList.copyOf(sources)); }
  
  public static CharSource concat(CharSource... sources) { return concat(ImmutableList.copyOf(sources)); }
  
  public static CharSource wrap(CharSequence charSequence) {
    return (charSequence instanceof String) ? 
      new StringCharSource((String)charSequence) : 
      new CharSequenceCharSource(charSequence);
  }
  
  public static CharSource empty() { return EmptyCharSource.access$000(); }
  
  public abstract Reader openStream() throws IOException;
}
