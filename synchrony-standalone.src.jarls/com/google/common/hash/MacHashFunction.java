package com.google.common.hash;

import com.google.common.base.Preconditions;
import com.google.errorprone.annotations.Immutable;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import javax.crypto.Mac;

@Immutable
@ElementTypesAreNonnullByDefault
final class MacHashFunction extends AbstractHashFunction {
  private final Mac prototype;
  
  private final Key key;
  
  private final String toString;
  
  private final int bits;
  
  private final boolean supportsClone;
  
  MacHashFunction(String algorithmName, Key key, String toString) {
    this.prototype = getMac(algorithmName, key);
    this.key = (Key)Preconditions.checkNotNull(key);
    this.toString = (String)Preconditions.checkNotNull(toString);
    this.bits = this.prototype.getMacLength() * 8;
    this.supportsClone = supportsClone(this.prototype);
  }
  
  public int bits() { return this.bits; }
  
  private static boolean supportsClone(Mac mac) {
    try {
      Object unused = mac.clone();
      return true;
    } catch (CloneNotSupportedException e) {
      return false;
    } 
  }
  
  private static Mac getMac(String algorithmName, Key key) {
    try {
      Mac mac = Mac.getInstance(algorithmName);
      mac.init(key);
      return mac;
    } catch (NoSuchAlgorithmException e) {
      throw new IllegalStateException(e);
    } catch (InvalidKeyException e) {
      throw new IllegalArgumentException(e);
    } 
  }
  
  public Hasher newHasher() {
    if (this.supportsClone)
      try {
        return new MacHasher((Mac)this.prototype.clone(), null);
      } catch (CloneNotSupportedException cloneNotSupportedException) {} 
    return new MacHasher(getMac(this.prototype.getAlgorithm(), this.key), null);
  }
  
  public String toString() { return this.toString; }
}
