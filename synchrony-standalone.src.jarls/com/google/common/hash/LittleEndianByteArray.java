package com.google.common.hash;

import java.nio.ByteOrder;

@ElementTypesAreNonnullByDefault
final class LittleEndianByteArray {
  private static final LittleEndianBytes byteArray;
  
  static long load64(byte[] input, int offset) {
    assert input.length >= offset + 8;
    return byteArray.getLongLittleEndian(input, offset);
  }
  
  static long load64Safely(byte[] input, int offset, int length) {
    long result = 0L;
    int limit = Math.min(length, 8);
    for (int i = 0; i < limit; i++)
      result |= (input[offset + i] & 0xFFL) << i * 8; 
    return result;
  }
  
  static void store64(byte[] sink, int offset, long value) {
    assert offset >= 0 && offset + 8 <= sink.length;
    byteArray.putLongLittleEndian(sink, offset, value);
  }
  
  static int load32(byte[] source, int offset) { return source[offset] & 0xFF | (source[offset + 1] & 0xFF) << 8 | (source[offset + 2] & 0xFF) << 16 | (source[offset + 3] & 0xFF) << 24; }
  
  static boolean usingUnsafe() { return byteArray instanceof UnsafeByteArray; }
  
  static  {
    UnsafeByteArray unsafeByteArray = JavaLittleEndianBytes.INSTANCE;
    try {
      String arch = System.getProperty("os.arch");
      if ("amd64".equals(arch) || "aarch64".equals(arch))
        unsafeByteArray = ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN) ? UnsafeByteArray.UNSAFE_LITTLE_ENDIAN : UnsafeByteArray.UNSAFE_BIG_ENDIAN; 
    } catch (Throwable throwable) {}
    byteArray = unsafeByteArray;
  }
}
