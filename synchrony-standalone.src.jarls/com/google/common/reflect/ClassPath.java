package com.google.common.reflect;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.base.Splitter;
import com.google.common.base.StandardSystemProperty;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import com.google.common.collect.UnmodifiableIterator;
import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import java.util.jar.Attributes;
import java.util.jar.Manifest;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
public final class ClassPath {
  private static final Logger logger = Logger.getLogger(ClassPath.class.getName());
  
  private static final Splitter CLASS_PATH_ATTRIBUTE_SEPARATOR = Splitter.on(" ").omitEmptyStrings();
  
  private static final String CLASS_FILE_NAME_EXTENSION = ".class";
  
  private final ImmutableSet<ResourceInfo> resources;
  
  private ClassPath(ImmutableSet<ResourceInfo> resources) { this.resources = resources; }
  
  public static ClassPath from(ClassLoader classloader) throws IOException {
    ImmutableSet<LocationInfo> locations = locationsFrom(classloader);
    Set<File> scanned = new HashSet<File>();
    for (UnmodifiableIterator unmodifiableIterator1 = locations.iterator(); unmodifiableIterator1.hasNext(); ) {
      LocationInfo location = (LocationInfo)unmodifiableIterator1.next();
      scanned.add(location.file());
    } 
    ImmutableSet.Builder<ResourceInfo> builder = ImmutableSet.builder();
    for (UnmodifiableIterator unmodifiableIterator2 = locations.iterator(); unmodifiableIterator2.hasNext(); ) {
      LocationInfo location = (LocationInfo)unmodifiableIterator2.next();
      builder.addAll(location.scanResources(scanned));
    } 
    return new ClassPath(builder.build());
  }
  
  public ImmutableSet<ResourceInfo> getResources() { return this.resources; }
  
  public ImmutableSet<ClassInfo> getAllClasses() { return FluentIterable.from(this.resources).filter(ClassInfo.class).toSet(); }
  
  public ImmutableSet<ClassInfo> getTopLevelClasses() { return FluentIterable.from(this.resources)
      .filter(ClassInfo.class)
      .filter(ClassInfo::isTopLevel)
      .toSet(); }
  
  public ImmutableSet<ClassInfo> getTopLevelClasses(String packageName) {
    Preconditions.checkNotNull(packageName);
    ImmutableSet.Builder<ClassInfo> builder = ImmutableSet.builder();
    for (UnmodifiableIterator unmodifiableIterator = getTopLevelClasses().iterator(); unmodifiableIterator.hasNext(); ) {
      ClassInfo classInfo = (ClassInfo)unmodifiableIterator.next();
      if (classInfo.getPackageName().equals(packageName))
        builder.add(classInfo); 
    } 
    return builder.build();
  }
  
  public ImmutableSet<ClassInfo> getTopLevelClassesRecursive(String packageName) {
    Preconditions.checkNotNull(packageName);
    String packagePrefix = packageName + '.';
    ImmutableSet.Builder<ClassInfo> builder = ImmutableSet.builder();
    for (UnmodifiableIterator unmodifiableIterator = getTopLevelClasses().iterator(); unmodifiableIterator.hasNext(); ) {
      ClassInfo classInfo = (ClassInfo)unmodifiableIterator.next();
      if (classInfo.getName().startsWith(packagePrefix))
        builder.add(classInfo); 
    } 
    return builder.build();
  }
  
  static ImmutableSet<LocationInfo> locationsFrom(ClassLoader classloader) {
    ImmutableSet.Builder<LocationInfo> builder = ImmutableSet.builder();
    for (UnmodifiableIterator unmodifiableIterator = getClassPathEntries(classloader).entrySet().iterator(); unmodifiableIterator.hasNext(); ) {
      Map.Entry<File, ClassLoader> entry = (Map.Entry)unmodifiableIterator.next();
      builder.add(new LocationInfo((File)entry.getKey(), (ClassLoader)entry.getValue()));
    } 
    return builder.build();
  }
  
  @VisibleForTesting
  static ImmutableSet<File> getClassPathFromManifest(File jarFile, @CheckForNull Manifest manifest) {
    if (manifest == null)
      return ImmutableSet.of(); 
    ImmutableSet.Builder<File> builder = ImmutableSet.builder();
    String classpathAttribute = manifest.getMainAttributes().getValue(Attributes.Name.CLASS_PATH.toString());
    if (classpathAttribute != null)
      for (String path : CLASS_PATH_ATTRIBUTE_SEPARATOR.split(classpathAttribute)) {
        URL url;
        try {
          url = getClassPathEntry(jarFile, path);
        } catch (MalformedURLException e) {
          logger.warning("Invalid Class-Path entry: " + path);
          continue;
        } 
        if (url.getProtocol().equals("file"))
          builder.add(toFile(url)); 
      }  
    return builder.build();
  }
  
  @VisibleForTesting
  static ImmutableMap<File, ClassLoader> getClassPathEntries(ClassLoader classloader) {
    LinkedHashMap<File, ClassLoader> entries = Maps.newLinkedHashMap();
    ClassLoader parent = classloader.getParent();
    if (parent != null)
      entries.putAll(getClassPathEntries(parent)); 
    for (UnmodifiableIterator unmodifiableIterator = getClassLoaderUrls(classloader).iterator(); unmodifiableIterator.hasNext(); ) {
      URL url = (URL)unmodifiableIterator.next();
      if (url.getProtocol().equals("file")) {
        File file = toFile(url);
        if (!entries.containsKey(file))
          entries.put(file, classloader); 
      } 
    } 
    return ImmutableMap.copyOf(entries);
  }
  
  private static ImmutableList<URL> getClassLoaderUrls(ClassLoader classloader) {
    if (classloader instanceof URLClassLoader)
      return ImmutableList.copyOf(((URLClassLoader)classloader).getURLs()); 
    if (classloader.equals(ClassLoader.getSystemClassLoader()))
      return parseJavaClassPath(); 
    return ImmutableList.of();
  }
  
  @VisibleForTesting
  static ImmutableList<URL> parseJavaClassPath() {
    urls = ImmutableList.builder();
    for (String entry : Splitter.on(StandardSystemProperty.PATH_SEPARATOR.value()).split(StandardSystemProperty.JAVA_CLASS_PATH.value())) {
      try {
        try {
          urls.add((new File(entry)).toURI().toURL());
        } catch (SecurityException e) {
          urls.add(new URL("file", null, (new File(entry)).getAbsolutePath()));
        } 
      } catch (MalformedURLException e) {
        logger.log(Level.WARNING, "malformed classpath entry: " + entry, e);
      } 
    } 
    return urls.build();
  }
  
  @VisibleForTesting
  static URL getClassPathEntry(File jarFile, String path) throws MalformedURLException { return new URL(jarFile.toURI().toURL(), path); }
  
  @VisibleForTesting
  static String getClassName(String filename) {
    int classNameEnd = filename.length() - ".class".length();
    return filename.substring(0, classNameEnd).replace('/', '.');
  }
  
  @VisibleForTesting
  static File toFile(URL url) {
    Preconditions.checkArgument(url.getProtocol().equals("file"));
    try {
      return new File(url.toURI());
    } catch (URISyntaxException e) {
      return new File(url.getPath());
    } 
  }
}
