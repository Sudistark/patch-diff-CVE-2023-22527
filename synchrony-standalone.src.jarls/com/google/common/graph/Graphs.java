package com.google.common.graph;

import com.google.common.annotations.Beta;
import com.google.common.base.Objects;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Maps;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@Beta
public final class Graphs {
  public static <N> boolean hasCycle(Graph<N> graph) {
    int numEdges = graph.edges().size();
    if (numEdges == 0)
      return false; 
    if (!graph.isDirected() && numEdges >= graph.nodes().size())
      return true; 
    Map<Object, NodeVisitState> visitedNodes = Maps.newHashMapWithExpectedSize(graph.nodes().size());
    for (N node : graph.nodes()) {
      if (subgraphHasCycle(graph, visitedNodes, node, null))
        return true; 
    } 
    return false;
  }
  
  public static boolean hasCycle(Network<?, ?> network) {
    if (!network.isDirected() && network
      .allowsParallelEdges() && network
      .edges().size() > network.asGraph().edges().size())
      return true; 
    return hasCycle(network.asGraph());
  }
  
  private static <N> boolean subgraphHasCycle(Graph<N> graph, Map<Object, NodeVisitState> visitedNodes, N node, @CheckForNull N previousNode) {
    NodeVisitState state = (NodeVisitState)visitedNodes.get(node);
    if (state == NodeVisitState.COMPLETE)
      return false; 
    if (state == NodeVisitState.PENDING)
      return true; 
    visitedNodes.put(node, NodeVisitState.PENDING);
    for (N nextNode : graph.successors(node)) {
      if (canTraverseWithoutReusingEdge(graph, nextNode, previousNode) && 
        subgraphHasCycle(graph, visitedNodes, nextNode, node))
        return true; 
    } 
    visitedNodes.put(node, NodeVisitState.COMPLETE);
    return false;
  }
  
  private static boolean canTraverseWithoutReusingEdge(Graph<?> graph, Object nextNode, @CheckForNull Object previousNode) {
    if (graph.isDirected() || !Objects.equal(previousNode, nextNode))
      return true; 
    return false;
  }
  
  public static <N> Graph<N> transitiveClosure(Graph<N> graph) {
    MutableGraph<N> transitiveClosure = GraphBuilder.from(graph).allowsSelfLoops(true).build();
    if (graph.isDirected()) {
      for (N node : graph.nodes()) {
        for (N reachableNode : reachableNodes(graph, node))
          transitiveClosure.putEdge(node, reachableNode); 
      } 
    } else {
      Set<N> visitedNodes = new HashSet<N>();
      for (N node : graph.nodes()) {
        if (!visitedNodes.contains(node)) {
          Set<N> reachableNodes = reachableNodes(graph, node);
          visitedNodes.addAll(reachableNodes);
          int pairwiseMatch = 1;
          for (N nodeU : reachableNodes) {
            for (N nodeV : Iterables.limit(reachableNodes, pairwiseMatch++))
              transitiveClosure.putEdge(nodeU, nodeV); 
          } 
        } 
      } 
    } 
    return transitiveClosure;
  }
  
  public static <N> Set<N> reachableNodes(Graph<N> graph, N node) {
    Preconditions.checkArgument(graph.nodes().contains(node), "Node %s is not an element of this graph.", node);
    return ImmutableSet.copyOf(Traverser.forGraph(graph).breadthFirst(node));
  }
  
  public static <N> Graph<N> transpose(Graph<N> graph) {
    if (!graph.isDirected())
      return graph; 
    if (graph instanceof TransposedGraph)
      return TransposedGraph.access$000((TransposedGraph)graph); 
    return new TransposedGraph(graph);
  }
  
  public static <N, V> ValueGraph<N, V> transpose(ValueGraph<N, V> graph) {
    if (!graph.isDirected())
      return graph; 
    if (graph instanceof TransposedValueGraph)
      return TransposedValueGraph.access$100((TransposedValueGraph)graph); 
    return new TransposedValueGraph(graph);
  }
  
  public static <N, E> Network<N, E> transpose(Network<N, E> network) {
    if (!network.isDirected())
      return network; 
    if (network instanceof TransposedNetwork)
      return TransposedNetwork.access$200((TransposedNetwork)network); 
    return new TransposedNetwork(network);
  }
  
  static <N> EndpointPair<N> transpose(EndpointPair<N> endpoints) {
    if (endpoints.isOrdered())
      return EndpointPair.ordered(endpoints.target(), endpoints.source()); 
    return endpoints;
  }
  
  public static <N> MutableGraph<N> inducedSubgraph(Graph<N> graph, Iterable<? extends N> nodes) {
    MutableGraph<N> subgraph = (nodes instanceof Collection) ? GraphBuilder.from(graph).expectedNodeCount(((Collection)nodes).size()).build() : GraphBuilder.from(graph).build();
    for (N node : nodes)
      subgraph.addNode(node); 
    for (N node : subgraph.nodes()) {
      for (N successorNode : graph.successors(node)) {
        if (subgraph.nodes().contains(successorNode))
          subgraph.putEdge(node, successorNode); 
      } 
    } 
    return subgraph;
  }
  
  public static <N, V> MutableValueGraph<N, V> inducedSubgraph(ValueGraph<N, V> graph, Iterable<? extends N> nodes) {
    MutableValueGraph<N, V> subgraph = (nodes instanceof Collection) ? ValueGraphBuilder.from(graph).expectedNodeCount(((Collection)nodes).size()).build() : ValueGraphBuilder.from(graph).build();
    for (N node : nodes)
      subgraph.addNode(node); 
    for (N node : subgraph.nodes()) {
      for (N successorNode : graph.successors(node)) {
        if (subgraph.nodes().contains(successorNode))
          subgraph.putEdgeValue(node, successorNode, 

              
              Objects.requireNonNull(graph.edgeValueOrDefault(node, successorNode, null))); 
      } 
    } 
    return subgraph;
  }
  
  public static <N, E> MutableNetwork<N, E> inducedSubgraph(Network<N, E> network, Iterable<? extends N> nodes) {
    MutableNetwork<N, E> subgraph = (nodes instanceof Collection) ? NetworkBuilder.from(network).expectedNodeCount(((Collection)nodes).size()).build() : NetworkBuilder.from(network).build();
    for (N node : nodes)
      subgraph.addNode(node); 
    for (N node : subgraph.nodes()) {
      for (E edge : network.outEdges(node)) {
        N successorNode = (N)network.incidentNodes(edge).adjacentNode(node);
        if (subgraph.nodes().contains(successorNode))
          subgraph.addEdge(node, successorNode, edge); 
      } 
    } 
    return subgraph;
  }
  
  public static <N> MutableGraph<N> copyOf(Graph<N> graph) {
    MutableGraph<N> copy = GraphBuilder.from(graph).expectedNodeCount(graph.nodes().size()).build();
    for (N node : graph.nodes())
      copy.addNode(node); 
    for (EndpointPair<N> edge : graph.edges())
      copy.putEdge(edge.nodeU(), edge.nodeV()); 
    return copy;
  }
  
  public static <N, V> MutableValueGraph<N, V> copyOf(ValueGraph<N, V> graph) {
    MutableValueGraph<N, V> copy = ValueGraphBuilder.from(graph).expectedNodeCount(graph.nodes().size()).build();
    for (N node : graph.nodes())
      copy.addNode(node); 
    for (EndpointPair<N> edge : graph.edges())
      copy.putEdgeValue(edge
          .nodeU(), edge
          .nodeV(), 
          Objects.requireNonNull(graph.edgeValueOrDefault(edge.nodeU(), edge.nodeV(), null))); 
    return copy;
  }
  
  public static <N, E> MutableNetwork<N, E> copyOf(Network<N, E> network) {
    MutableNetwork<N, E> copy = NetworkBuilder.from(network).expectedNodeCount(network.nodes().size()).expectedEdgeCount(network.edges().size()).build();
    for (N node : network.nodes())
      copy.addNode(node); 
    for (E edge : network.edges()) {
      EndpointPair<N> endpointPair = network.incidentNodes(edge);
      copy.addEdge(endpointPair.nodeU(), endpointPair.nodeV(), edge);
    } 
    return copy;
  }
  
  @CanIgnoreReturnValue
  static int checkNonNegative(int value) {
    Preconditions.checkArgument((value >= 0), "Not true that %s is non-negative.", value);
    return value;
  }
  
  @CanIgnoreReturnValue
  static long checkNonNegative(long value) {
    Preconditions.checkArgument((value >= 0L), "Not true that %s is non-negative.", value);
    return value;
  }
  
  @CanIgnoreReturnValue
  static int checkPositive(int value) {
    Preconditions.checkArgument((value > 0), "Not true that %s is positive.", value);
    return value;
  }
  
  @CanIgnoreReturnValue
  static long checkPositive(long value) {
    Preconditions.checkArgument((value > 0L), "Not true that %s is positive.", value);
    return value;
  }
}
