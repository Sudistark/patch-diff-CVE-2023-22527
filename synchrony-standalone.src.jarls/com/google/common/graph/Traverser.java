package com.google.common.graph;

import com.google.common.annotations.Beta;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.UnmodifiableIterator;
import com.google.errorprone.annotations.DoNotMock;

@DoNotMock("Call forGraph or forTree, passing a lambda or a Graph with the desired edges (built with GraphBuilder)")
@ElementTypesAreNonnullByDefault
@Beta
public abstract class Traverser<N> extends Object {
  private final SuccessorsFunction<N> successorFunction;
  
  private Traverser(SuccessorsFunction<N> successorFunction) { this.successorFunction = (SuccessorsFunction)Preconditions.checkNotNull(successorFunction); }
  
  public static <N> Traverser<N> forGraph(SuccessorsFunction<N> graph) { return new Object(graph, graph); }
  
  public static <N> Traverser<N> forTree(SuccessorsFunction<N> tree) {
    if (tree instanceof BaseGraph)
      Preconditions.checkArgument(((BaseGraph)tree).isDirected(), "Undirected graphs can never be trees."); 
    if (tree instanceof Network)
      Preconditions.checkArgument(((Network)tree).isDirected(), "Undirected networks can never be trees."); 
    return new Object(tree, tree);
  }
  
  public final Iterable<N> breadthFirst(N startNode) { return breadthFirst(ImmutableSet.of(startNode)); }
  
  public final Iterable<N> breadthFirst(Iterable<? extends N> startNodes) {
    ImmutableSet<N> validated = validate(startNodes);
    return new Object(this, validated);
  }
  
  public final Iterable<N> depthFirstPreOrder(N startNode) { return depthFirstPreOrder(ImmutableSet.of(startNode)); }
  
  public final Iterable<N> depthFirstPreOrder(Iterable<? extends N> startNodes) {
    ImmutableSet<N> validated = validate(startNodes);
    return new Object(this, validated);
  }
  
  public final Iterable<N> depthFirstPostOrder(N startNode) { return depthFirstPostOrder(ImmutableSet.of(startNode)); }
  
  public final Iterable<N> depthFirstPostOrder(Iterable<? extends N> startNodes) {
    ImmutableSet<N> validated = validate(startNodes);
    return new Object(this, validated);
  }
  
  private ImmutableSet<N> validate(Iterable<? extends N> startNodes) {
    ImmutableSet<N> copy = ImmutableSet.copyOf(startNodes);
    for (UnmodifiableIterator unmodifiableIterator = copy.iterator(); unmodifiableIterator.hasNext(); ) {
      N node = (N)unmodifiableIterator.next();
      this.successorFunction.successors(node);
    } 
    return copy;
  }
  
  abstract Traversal<N> newTraversal();
}
