package com.google.common.graph;

import com.google.common.annotations.Beta;
import com.google.common.base.Preconditions;
import com.google.common.collect.Iterators;
import com.google.common.collect.UnmodifiableIterator;
import com.google.errorprone.annotations.Immutable;
import java.util.Iterator;
import javax.annotation.CheckForNull;

@Immutable(containerOf = {"N"})
@ElementTypesAreNonnullByDefault
@Beta
public abstract class EndpointPair<N> extends Object implements Iterable<N> {
  private final N nodeU;
  
  private final N nodeV;
  
  private EndpointPair(N nodeU, N nodeV) {
    this.nodeU = Preconditions.checkNotNull(nodeU);
    this.nodeV = Preconditions.checkNotNull(nodeV);
  }
  
  public static <N> EndpointPair<N> ordered(N source, N target) { return new Ordered(source, target, null); }
  
  public static <N> EndpointPair<N> unordered(N nodeU, N nodeV) { return new Unordered(nodeV, nodeU, null); }
  
  static <N> EndpointPair<N> of(Graph<?> graph, N nodeU, N nodeV) { return graph.isDirected() ? ordered(nodeU, nodeV) : unordered(nodeU, nodeV); }
  
  static <N> EndpointPair<N> of(Network<?, ?> network, N nodeU, N nodeV) { return network.isDirected() ? ordered(nodeU, nodeV) : unordered(nodeU, nodeV); }
  
  public final N nodeU() { return (N)this.nodeU; }
  
  public final N nodeV() { return (N)this.nodeV; }
  
  public final N adjacentNode(N node) {
    if (node.equals(this.nodeU))
      return (N)this.nodeV; 
    if (node.equals(this.nodeV))
      return (N)this.nodeU; 
    throw new IllegalArgumentException("EndpointPair " + this + " does not contain node " + node);
  }
  
  public final UnmodifiableIterator<N> iterator() { return Iterators.forArray(new Object[] { this.nodeU, this.nodeV }); }
  
  public abstract N source();
  
  public abstract N target();
  
  public abstract boolean isOrdered();
  
  public abstract boolean equals(@CheckForNull Object paramObject);
  
  public abstract int hashCode();
}
