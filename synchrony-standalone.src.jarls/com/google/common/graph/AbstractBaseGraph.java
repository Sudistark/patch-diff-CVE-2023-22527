package com.google.common.graph;

import com.google.common.base.Preconditions;
import com.google.common.math.IntMath;
import java.util.Set;

@ElementTypesAreNonnullByDefault
abstract class AbstractBaseGraph<N> extends Object implements BaseGraph<N> {
  protected long edgeCount() {
    long degreeSum = 0L;
    for (N node : nodes())
      degreeSum += degree(node); 
    Preconditions.checkState(((degreeSum & 0x1L) == 0L));
    return degreeSum >>> true;
  }
  
  public Set<EndpointPair<N>> edges() { return new Object(this); }
  
  public ElementOrder<N> incidentEdgeOrder() { return ElementOrder.unordered(); }
  
  public Set<EndpointPair<N>> incidentEdges(N node) {
    Preconditions.checkNotNull(node);
    Preconditions.checkArgument(nodes().contains(node), "Node %s is not an element of this graph.", node);
    return new Object(this, this, node);
  }
  
  public int degree(N node) {
    if (isDirected())
      return IntMath.saturatedAdd(predecessors(node).size(), successors(node).size()); 
    Set<N> neighbors = adjacentNodes(node);
    int selfLoopCount = (allowsSelfLoops() && neighbors.contains(node)) ? 1 : 0;
    return IntMath.saturatedAdd(neighbors.size(), selfLoopCount);
  }
  
  public int inDegree(N node) { return isDirected() ? predecessors(node).size() : degree(node); }
  
  public int outDegree(N node) { return isDirected() ? successors(node).size() : degree(node); }
  
  public boolean hasEdgeConnecting(N nodeU, N nodeV) {
    Preconditions.checkNotNull(nodeU);
    Preconditions.checkNotNull(nodeV);
    return (nodes().contains(nodeU) && successors(nodeU).contains(nodeV));
  }
  
  public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {
    Preconditions.checkNotNull(endpoints);
    if (!isOrderingCompatible(endpoints))
      return false; 
    N nodeU = (N)endpoints.nodeU();
    N nodeV = (N)endpoints.nodeV();
    return (nodes().contains(nodeU) && successors(nodeU).contains(nodeV));
  }
  
  protected final void validateEndpoints(EndpointPair<?> endpoints) {
    Preconditions.checkNotNull(endpoints);
    Preconditions.checkArgument(isOrderingCompatible(endpoints), "Mismatch: endpoints' ordering is not compatible with directionality of the graph");
  }
  
  protected final boolean isOrderingCompatible(EndpointPair<?> endpoints) { return (endpoints.isOrdered() == isDirected()); }
}
