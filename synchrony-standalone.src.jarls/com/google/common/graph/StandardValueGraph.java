package com.google.common.graph;

import com.google.common.base.Preconditions;
import java.util.Map;
import java.util.Set;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
class StandardValueGraph<N, V> extends AbstractValueGraph<N, V> {
  private final boolean isDirected;
  
  private final boolean allowsSelfLoops;
  
  private final ElementOrder<N> nodeOrder;
  
  final MapIteratorCache<N, GraphConnections<N, V>> nodeConnections;
  
  long edgeCount;
  
  StandardValueGraph(AbstractGraphBuilder<? super N> builder) {
    this(builder, builder.nodeOrder
        
        .createMap(((Integer)builder.expectedNodeCount
          .or(Integer.valueOf(10))).intValue()), 0L);
  }
  
  StandardValueGraph(AbstractGraphBuilder<? super N> builder, Map<N, GraphConnections<N, V>> nodeConnections, long edgeCount) {
    this.isDirected = builder.directed;
    this.allowsSelfLoops = builder.allowsSelfLoops;
    this.nodeOrder = builder.nodeOrder.cast();
    this

      
      .nodeConnections = (nodeConnections instanceof java.util.TreeMap) ? new MapRetrievalCache(nodeConnections) : new MapIteratorCache(nodeConnections);
    this.edgeCount = Graphs.checkNonNegative(edgeCount);
  }
  
  public Set<N> nodes() { return this.nodeConnections.unmodifiableKeySet(); }
  
  public boolean isDirected() { return this.isDirected; }
  
  public boolean allowsSelfLoops() { return this.allowsSelfLoops; }
  
  public ElementOrder<N> nodeOrder() { return this.nodeOrder; }
  
  public Set<N> adjacentNodes(N node) { return checkedConnections(node).adjacentNodes(); }
  
  public Set<N> predecessors(N node) { return checkedConnections(node).predecessors(); }
  
  public Set<N> successors(N node) { return checkedConnections(node).successors(); }
  
  public Set<EndpointPair<N>> incidentEdges(N node) {
    GraphConnections<N, V> connections = checkedConnections(node);
    return new Object(this, this, node, connections);
  }
  
  public boolean hasEdgeConnecting(N nodeU, N nodeV) { return hasEdgeConnectingInternal(Preconditions.checkNotNull(nodeU), Preconditions.checkNotNull(nodeV)); }
  
  public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {
    Preconditions.checkNotNull(endpoints);
    return (isOrderingCompatible(endpoints) && 
      hasEdgeConnectingInternal(endpoints.nodeU(), endpoints.nodeV()));
  }
  
  @CheckForNull
  public V edgeValueOrDefault(N nodeU, N nodeV, @CheckForNull V defaultValue) { return (V)edgeValueOrDefaultInternal(Preconditions.checkNotNull(nodeU), Preconditions.checkNotNull(nodeV), defaultValue); }
  
  @CheckForNull
  public V edgeValueOrDefault(EndpointPair<N> endpoints, @CheckForNull V defaultValue) {
    validateEndpoints(endpoints);
    return (V)edgeValueOrDefaultInternal(endpoints.nodeU(), endpoints.nodeV(), defaultValue);
  }
  
  protected long edgeCount() { return this.edgeCount; }
  
  private final GraphConnections<N, V> checkedConnections(N node) {
    GraphConnections<N, V> connections = (GraphConnections)this.nodeConnections.get(node);
    if (connections == null) {
      Preconditions.checkNotNull(node);
      throw new IllegalArgumentException("Node " + node + " is not an element of this graph.");
    } 
    return connections;
  }
  
  final boolean containsNode(@CheckForNull N node) { return this.nodeConnections.containsKey(node); }
  
  private final boolean hasEdgeConnectingInternal(N nodeU, N nodeV) {
    GraphConnections<N, V> connectionsU = (GraphConnections)this.nodeConnections.get(nodeU);
    return (connectionsU != null && connectionsU.successors().contains(nodeV));
  }
  
  @CheckForNull
  private final V edgeValueOrDefaultInternal(N nodeU, N nodeV, @CheckForNull V defaultValue) {
    GraphConnections<N, V> connectionsU = (GraphConnections)this.nodeConnections.get(nodeU);
    V value = (V)((connectionsU == null) ? null : connectionsU.value(nodeV));
    if (value == null)
      return defaultValue; 
    return value;
  }
}
