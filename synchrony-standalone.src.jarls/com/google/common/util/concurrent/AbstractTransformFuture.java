package com.google.common.util.concurrent;

import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.google.errorprone.annotations.ForOverride;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible
abstract class AbstractTransformFuture<I, O, F, T> extends FluentFuture.TrustedFuture<O> implements Runnable {
  @CheckForNull
  ListenableFuture<? extends I> inputFuture;
  
  @CheckForNull
  F function;
  
  static <I, O> ListenableFuture<O> create(ListenableFuture<I> input, AsyncFunction<? super I, ? extends O> function, Executor executor) {
    Preconditions.checkNotNull(executor);
    AsyncTransformFuture<I, O> output = new AsyncTransformFuture<I, O>(input, function);
    input.addListener(output, MoreExecutors.rejectionPropagatingExecutor(executor, output));
    return output;
  }
  
  static <I, O> ListenableFuture<O> create(ListenableFuture<I> input, Function<? super I, ? extends O> function, Executor executor) {
    Preconditions.checkNotNull(function);
    TransformFuture<I, O> output = new TransformFuture<I, O>(input, function);
    input.addListener(output, MoreExecutors.rejectionPropagatingExecutor(executor, output));
    return output;
  }
  
  AbstractTransformFuture(ListenableFuture<? extends I> inputFuture, F function) {
    this.inputFuture = (ListenableFuture)Preconditions.checkNotNull(inputFuture);
    this.function = Preconditions.checkNotNull(function);
  }
  
  public final void run() {
    T transformResult;
    I sourceResult;
    ListenableFuture<? extends I> localInputFuture = this.inputFuture;
    F localFunction = (F)this.function;
    if (isCancelled() | ((localInputFuture == null) ? 1 : 0) | ((localFunction == null) ? 1 : 0))
      return; 
    this.inputFuture = null;
    if (localInputFuture.isCancelled()) {
      boolean unused = setFuture(localInputFuture);
      return;
    } 
    try {
      sourceResult = (I)Futures.getDone(localInputFuture);
    } catch (CancellationException e) {
      cancel(false);
      return;
    } catch (ExecutionException e) {
      setException(e.getCause());
      return;
    } catch (RuntimeException e) {
      setException(e);
      return;
    } catch (Error e) {
      setException(e);
      return;
    } 
    try {
      transformResult = (T)doTransform(localFunction, sourceResult);
    } catch (Throwable t) {
      Platform.restoreInterruptIfIsInterruptedException(t);
      setException(t);
      return;
    } finally {
      this.function = null;
    } 
    setResult(transformResult);
  }
  
  @ParametricNullness
  @ForOverride
  abstract T doTransform(F paramF, @ParametricNullness I paramI) throws Exception;
  
  @ForOverride
  abstract void setResult(@ParametricNullness T paramT);
  
  protected final void afterDone() {
    maybePropagateCancellationTo(this.inputFuture);
    this.inputFuture = null;
    this.function = null;
  }
  
  @CheckForNull
  protected String pendingToString() {
    ListenableFuture<? extends I> localInputFuture = this.inputFuture;
    F localFunction = (F)this.function;
    String superString = super.pendingToString();
    String resultString = "";
    if (localInputFuture != null)
      resultString = "inputFuture=[" + localInputFuture + "], "; 
    if (localFunction != null)
      return resultString + "function=[" + localFunction + "]"; 
    if (superString != null)
      return resultString + superString; 
    return null;
  }
}
