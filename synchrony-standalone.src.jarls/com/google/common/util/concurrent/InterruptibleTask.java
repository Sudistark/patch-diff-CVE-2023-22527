package com.google.common.util.concurrent;

import com.google.common.annotations.GwtCompatible;
import com.google.j2objc.annotations.ReflectionSupport;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.LockSupport;

@ElementTypesAreNonnullByDefault
@GwtCompatible(emulated = true)
@ReflectionSupport(ReflectionSupport.Level.FULL)
abstract class InterruptibleTask<T> extends AtomicReference<Runnable> implements Runnable {
  private static final Runnable DONE;
  
  private static final Runnable PARKED;
  
  private static final int MAX_BUSY_WAIT_SPINS = 1000;
  
  static  {
    Class clazz = LockSupport.class;
    DONE = new DoNothingRunnable(null);
    PARKED = new DoNothingRunnable(null);
  }
  
  public final void run() {
    currentThread = Thread.currentThread();
    if (!compareAndSet(null, currentThread))
      return; 
    run = !isDone();
    result = null;
    error = null;
    try {
      if (run)
        result = (T)runInterruptibly(); 
    } catch (Throwable t) {
      Platform.restoreInterruptIfIsInterruptedException(t);
      error = t;
    } finally {
      if (!compareAndSet(currentThread, DONE))
        waitForInterrupt(currentThread); 
      if (run)
        if (error == null) {
          afterRanInterruptiblySuccess(NullnessCasts.uncheckedCastNullableTToT(result));
        } else {
          afterRanInterruptiblyFailure(error);
        }  
    } 
  }
  
  private void waitForInterrupt(Thread currentThread) {
    boolean restoreInterruptedBit = false;
    int spinCount = 0;
    Runnable state = (Runnable)get();
    Blocker blocker = null;
    while (state instanceof Blocker || state == PARKED) {
      if (state instanceof Blocker)
        blocker = (Blocker)state; 
      spinCount++;
      if (spinCount > 1000) {
        if (state == PARKED || compareAndSet(state, PARKED)) {
          restoreInterruptedBit = (Thread.interrupted() || restoreInterruptedBit);
          LockSupport.park(blocker);
        } 
      } else {
        Thread.yield();
      } 
      state = (Runnable)get();
    } 
    if (restoreInterruptedBit)
      currentThread.interrupt(); 
  }
  
  final void interruptTask() {
    currentRunner = (Runnable)get();
    if (currentRunner instanceof Thread) {
      Blocker blocker = new Blocker(this, null);
      Blocker.access$200(blocker, Thread.currentThread());
      if (compareAndSet(currentRunner, blocker))
        try {
          ((Thread)currentRunner).interrupt();
        } finally {
          Runnable prev = (Runnable)getAndSet(DONE);
          if (prev == PARKED)
            LockSupport.unpark((Thread)currentRunner); 
        }  
    } 
  }
  
  public final String toString() {
    String result;
    Runnable state = (Runnable)get();
    if (state == DONE) {
      result = "running=[DONE]";
    } else if (state instanceof Blocker) {
      result = "running=[INTERRUPTED]";
    } else if (state instanceof Thread) {
      result = "running=[RUNNING ON " + ((Thread)state).getName() + "]";
    } else {
      result = "running=[NOT STARTED YET]";
    } 
    return result + ", " + toPendingString();
  }
  
  abstract boolean isDone();
  
  @ParametricNullness
  abstract T runInterruptibly() throws Exception;
  
  abstract void afterRanInterruptiblySuccess(@ParametricNullness T paramT);
  
  abstract void afterRanInterruptiblyFailure(Throwable paramThrowable);
  
  abstract String toPendingString();
}
