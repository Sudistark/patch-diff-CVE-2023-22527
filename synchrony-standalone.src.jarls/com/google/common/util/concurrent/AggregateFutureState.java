package com.google.common.util.concurrent;

import com.google.common.annotations.GwtCompatible;
import com.google.common.collect.Sets;
import com.google.j2objc.annotations.ReflectionSupport;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible(emulated = true)
@ReflectionSupport(ReflectionSupport.Level.FULL)
abstract class AggregateFutureState<OutputT> extends AbstractFuture.TrustedFuture<OutputT> {
  private static final AtomicHelper ATOMIC_HELPER;
  
  private static final Logger log;
  
  static  {
    SynchronizedAtomicHelper synchronizedAtomicHelper;
    log = Logger.getLogger(AggregateFutureState.class.getName());
    Throwable thrownReflectionFailure = null;
    try {
      synchronizedAtomicHelper = new SafeAtomicHelper(AtomicReferenceFieldUpdater.newUpdater(AggregateFutureState.class, Set.class, "seenExceptions"), AtomicIntegerFieldUpdater.newUpdater(AggregateFutureState.class, "remaining"));
    } catch (RuntimeException|Error reflectionFailure) {
      thrownReflectionFailure = reflectionFailure;
      synchronizedAtomicHelper = new SynchronizedAtomicHelper(null);
    } 
    ATOMIC_HELPER = synchronizedAtomicHelper;
    if (thrownReflectionFailure != null)
      log.log(Level.SEVERE, "SafeAtomicHelper is broken!", thrownReflectionFailure); 
  }
  
  AggregateFutureState(int remainingFutures) {
    this.seenExceptions = null;
    this.remaining = remainingFutures;
  }
  
  final Set<Throwable> getOrInitSeenExceptions() {
    Set<Throwable> seenExceptionsLocal = this.seenExceptions;
    if (seenExceptionsLocal == null) {
      seenExceptionsLocal = Sets.newConcurrentHashSet();
      addInitialException(seenExceptionsLocal);
      ATOMIC_HELPER.compareAndSetSeenExceptions(this, null, seenExceptionsLocal);
      seenExceptionsLocal = (Set)Objects.requireNonNull(this.seenExceptions);
    } 
    return seenExceptionsLocal;
  }
  
  final int decrementRemainingAndGet() { return ATOMIC_HELPER.decrementAndGetRemainingCount(this); }
  
  final void clearSeenExceptions() { this.seenExceptions = null; }
  
  abstract void addInitialException(Set<Throwable> paramSet);
}
