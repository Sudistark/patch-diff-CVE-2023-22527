package com.google.common.util.concurrent;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.base.Preconditions;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.ForOverride;
import com.google.errorprone.annotations.concurrent.GuardedBy;
import java.time.Duration;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

@ElementTypesAreNonnullByDefault
@GwtIncompatible
@J2ktIncompatible
public abstract class AbstractService implements Service {
  private static final ListenerCallQueue.Event<Service.Listener> STARTING_EVENT = new Object();
  
  private static final ListenerCallQueue.Event<Service.Listener> RUNNING_EVENT = new Object();
  
  private static final ListenerCallQueue.Event<Service.Listener> STOPPING_FROM_STARTING_EVENT = stoppingEvent(Service.State.STARTING);
  
  private static final ListenerCallQueue.Event<Service.Listener> STOPPING_FROM_RUNNING_EVENT = stoppingEvent(Service.State.RUNNING);
  
  private static final ListenerCallQueue.Event<Service.Listener> TERMINATED_FROM_NEW_EVENT = terminatedEvent(Service.State.NEW);
  
  private static final ListenerCallQueue.Event<Service.Listener> TERMINATED_FROM_STARTING_EVENT = terminatedEvent(Service.State.STARTING);
  
  private static final ListenerCallQueue.Event<Service.Listener> TERMINATED_FROM_RUNNING_EVENT = terminatedEvent(Service.State.RUNNING);
  
  private static final ListenerCallQueue.Event<Service.Listener> TERMINATED_FROM_STOPPING_EVENT = terminatedEvent(Service.State.STOPPING);
  
  private static ListenerCallQueue.Event<Service.Listener> terminatedEvent(Service.State from) { return new Object(from); }
  
  private static ListenerCallQueue.Event<Service.Listener> stoppingEvent(Service.State from) { return new Object(from); }
  
  private final Monitor monitor = new Monitor();
  
  private final Monitor.Guard isStartable = new IsStartableGuard(this);
  
  private final Monitor.Guard isStoppable = new IsStoppableGuard(this);
  
  private final Monitor.Guard hasReachedRunning = new HasReachedRunningGuard(this);
  
  private final Monitor.Guard isStopped = new IsStoppedGuard(this);
  
  private final ListenerCallQueue<Service.Listener> listeners = new ListenerCallQueue();
  
  @ForOverride
  protected void doCancelStart() {}
  
  @CanIgnoreReturnValue
  public final Service startAsync() {
    if (this.monitor.enterIf(this.isStartable)) {
      try {
        this.snapshot = new StateSnapshot(Service.State.STARTING);
        enqueueStartingEvent();
        doStart();
      } catch (Throwable startupFailure) {
        Platform.restoreInterruptIfIsInterruptedException(startupFailure);
        notifyFailed(startupFailure);
      } finally {
        this.monitor.leave();
        dispatchListenerEvents();
      } 
    } else {
      throw new IllegalStateException("Service " + this + " has already been started");
    } 
    return this;
  }
  
  @CanIgnoreReturnValue
  public final Service stopAsync() {
    if (this.monitor.enterIf(this.isStoppable))
      try {
        Service.State previous = state();
        switch (null.$SwitchMap$com$google$common$util$concurrent$Service$State[previous.ordinal()]) {
          case 1:
            this.snapshot = new StateSnapshot(Service.State.TERMINATED);
            enqueueTerminatedEvent(Service.State.NEW);
            break;
          case 2:
            this.snapshot = new StateSnapshot(Service.State.STARTING, true, null);
            enqueueStoppingEvent(Service.State.STARTING);
            doCancelStart();
            break;
          case 3:
            this.snapshot = new StateSnapshot(Service.State.STOPPING);
            enqueueStoppingEvent(Service.State.RUNNING);
            doStop();
            break;
          case 4:
          case 5:
          case 6:
            throw new AssertionError("isStoppable is incorrectly implemented, saw: " + previous);
        } 
      } catch (Throwable shutdownFailure) {
        Platform.restoreInterruptIfIsInterruptedException(shutdownFailure);
        notifyFailed(shutdownFailure);
      } finally {
        this.monitor.leave();
        dispatchListenerEvents();
      }  
    return this;
  }
  
  public final void awaitRunning() {
    this.monitor.enterWhenUninterruptibly(this.hasReachedRunning);
    try {
      checkCurrentState(Service.State.RUNNING);
    } finally {
      this.monitor.leave();
    } 
  }
  
  public final void awaitRunning(Duration timeout) throws TimeoutException { super.awaitRunning(timeout); }
  
  public final void awaitRunning(long timeout, TimeUnit unit) throws TimeoutException {
    if (this.monitor.enterWhenUninterruptibly(this.hasReachedRunning, timeout, unit)) {
      try {
        checkCurrentState(Service.State.RUNNING);
      } finally {
        this.monitor.leave();
      } 
    } else {
      throw new TimeoutException("Timed out waiting for " + this + " to reach the RUNNING state.");
    } 
  }
  
  public final void awaitTerminated() {
    this.monitor.enterWhenUninterruptibly(this.isStopped);
    try {
      checkCurrentState(Service.State.TERMINATED);
    } finally {
      this.monitor.leave();
    } 
  }
  
  public final void awaitTerminated(Duration timeout) throws TimeoutException { super.awaitTerminated(timeout); }
  
  public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutException {
    if (this.monitor.enterWhenUninterruptibly(this.isStopped, timeout, unit)) {
      try {
        checkCurrentState(Service.State.TERMINATED);
      } finally {
        this.monitor.leave();
      } 
    } else {
      throw new TimeoutException("Timed out waiting for " + this + " to reach a terminal state. Current state: " + 



          
          state());
    } 
  }
  
  @GuardedBy("monitor")
  private void checkCurrentState(Service.State expected) {
    Service.State actual = state();
    if (actual != expected) {
      if (actual == Service.State.FAILED)
        throw new IllegalStateException("Expected the service " + this + " to be " + expected + ", but the service has FAILED", 
            
            failureCause()); 
      throw new IllegalStateException("Expected the service " + this + " to be " + expected + ", but was " + actual);
    } 
  }
  
  protected final void notifyStarted() {
    this.monitor.enter();
    try {
      if (this.snapshot.state != Service.State.STARTING) {
        IllegalStateException failure = new IllegalStateException("Cannot notifyStarted() when the service is " + this.snapshot.state);
        notifyFailed(failure);
        throw failure;
      } 
      if (this.snapshot.shutdownWhenStartupFinishes) {
        this.snapshot = new StateSnapshot(Service.State.STOPPING);
        doStop();
      } else {
        this.snapshot = new StateSnapshot(Service.State.RUNNING);
        enqueueRunningEvent();
      } 
    } finally {
      this.monitor.leave();
      dispatchListenerEvents();
    } 
  }
  
  protected final void notifyStopped() {
    this.monitor.enter();
    try {
      Service.State previous = state();
      switch (null.$SwitchMap$com$google$common$util$concurrent$Service$State[previous.ordinal()]) {
        case 1:
        case 5:
        case 6:
          throw new IllegalStateException("Cannot notifyStopped() when the service is " + previous);
        case 2:
        case 3:
        case 4:
          this.snapshot = new StateSnapshot(Service.State.TERMINATED);
          enqueueTerminatedEvent(previous);
          break;
      } 
    } finally {
      this.monitor.leave();
      dispatchListenerEvents();
    } 
  }
  
  protected final void notifyFailed(Throwable cause) {
    Preconditions.checkNotNull(cause);
    this.monitor.enter();
    try {
      Service.State previous = state();
      switch (null.$SwitchMap$com$google$common$util$concurrent$Service$State[previous.ordinal()]) {
        case 1:
        case 5:
          throw new IllegalStateException("Failed while in state:" + previous, cause);
        case 2:
        case 3:
        case 4:
          this.snapshot = new StateSnapshot(Service.State.FAILED, false, cause);
          enqueueFailedEvent(previous, cause);
          break;
      } 
    } finally {
      this.monitor.leave();
      dispatchListenerEvents();
    } 
  }
  
  public final boolean isRunning() { return (state() == Service.State.RUNNING); }
  
  public final Service.State state() { return this.snapshot.externalState(); }
  
  public final Throwable failureCause() { return this.snapshot.failureCause(); }
  
  public final void addListener(Service.Listener listener, Executor executor) { this.listeners.addListener(listener, executor); }
  
  public String toString() { return getClass().getSimpleName() + " [" + state() + "]"; }
  
  private void dispatchListenerEvents() {
    if (!this.monitor.isOccupiedByCurrentThread())
      this.listeners.dispatch(); 
  }
  
  private void enqueueStartingEvent() { this.listeners.enqueue(STARTING_EVENT); }
  
  private void enqueueRunningEvent() { this.listeners.enqueue(RUNNING_EVENT); }
  
  private void enqueueStoppingEvent(Service.State from) {
    if (from == Service.State.STARTING) {
      this.listeners.enqueue(STOPPING_FROM_STARTING_EVENT);
    } else if (from == Service.State.RUNNING) {
      this.listeners.enqueue(STOPPING_FROM_RUNNING_EVENT);
    } else {
      throw new AssertionError();
    } 
  }
  
  private void enqueueTerminatedEvent(Service.State from) {
    switch (null.$SwitchMap$com$google$common$util$concurrent$Service$State[from.ordinal()]) {
      case 1:
        this.listeners.enqueue(TERMINATED_FROM_NEW_EVENT);
        break;
      case 2:
        this.listeners.enqueue(TERMINATED_FROM_STARTING_EVENT);
        break;
      case 3:
        this.listeners.enqueue(TERMINATED_FROM_RUNNING_EVENT);
        break;
      case 4:
        this.listeners.enqueue(TERMINATED_FROM_STOPPING_EVENT);
        break;
      case 5:
      case 6:
        throw new AssertionError();
    } 
  }
  
  private void enqueueFailedEvent(Service.State from, Throwable cause) { this.listeners.enqueue(new Object(this, from, cause)); }
  
  @ForOverride
  protected abstract void doStart();
  
  @ForOverride
  protected abstract void doStop();
}
