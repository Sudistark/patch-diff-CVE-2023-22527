package com.google.common.collect;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.base.Preconditions;
import java.util.Iterator;
import java.util.Map;
import java.util.NavigableMap;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.function.BiFunction;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtIncompatible
public final class TreeRangeMap<K extends Comparable, V> extends Object implements RangeMap<K, V> {
  public static <K extends Comparable, V> TreeRangeMap<K, V> create() { return new TreeRangeMap(); }
  
  private final NavigableMap<Cut<K>, RangeMapEntry<K, V>> entriesByLowerBound = Maps.newTreeMap();
  
  @CheckForNull
  public V get(K key) {
    Map.Entry<Range<K>, V> entry = getEntry(key);
    return (V)((entry == null) ? null : entry.getValue());
  }
  
  @CheckForNull
  public Map.Entry<Range<K>, V> getEntry(K key) {
    Map.Entry<Cut<K>, RangeMapEntry<K, V>> mapEntry = this.entriesByLowerBound.floorEntry(Cut.belowValue(key));
    if (mapEntry != null && ((RangeMapEntry)mapEntry.getValue()).contains(key))
      return (Map.Entry)mapEntry.getValue(); 
    return null;
  }
  
  public void put(Range<K> range, V value) {
    if (!range.isEmpty()) {
      Preconditions.checkNotNull(value);
      remove(range);
      this.entriesByLowerBound.put(range.lowerBound, new RangeMapEntry(range, value));
    } 
  }
  
  public void putCoalescing(Range<K> range, V value) {
    if (this.entriesByLowerBound.isEmpty()) {
      put(range, value);
      return;
    } 
    Range<K> coalescedRange = coalescedRange(range, Preconditions.checkNotNull(value));
    put(coalescedRange, value);
  }
  
  private Range<K> coalescedRange(Range<K> range, V value) {
    coalescedRange = range;
    Map.Entry<Cut<K>, RangeMapEntry<K, V>> lowerEntry = this.entriesByLowerBound.lowerEntry(range.lowerBound);
    coalescedRange = coalesce(coalescedRange, value, lowerEntry);
    Map.Entry<Cut<K>, RangeMapEntry<K, V>> higherEntry = this.entriesByLowerBound.floorEntry(range.upperBound);
    return coalesce(coalescedRange, value, higherEntry);
  }
  
  private static <K extends Comparable, V> Range<K> coalesce(Range<K> range, V value, @CheckForNull Map.Entry<Cut<K>, RangeMapEntry<K, V>> entry) {
    if (entry != null && ((RangeMapEntry)entry
      .getValue()).getKey().isConnected(range) && ((RangeMapEntry)entry
      .getValue()).getValue().equals(value))
      return range.span(((RangeMapEntry)entry.getValue()).getKey()); 
    return range;
  }
  
  public void putAll(RangeMap<K, ? extends V> rangeMap) {
    for (Map.Entry<Range<K>, ? extends V> entry : rangeMap.asMapOfRanges().entrySet())
      put((Range)entry.getKey(), entry.getValue()); 
  }
  
  public void clear() { this.entriesByLowerBound.clear(); }
  
  public Range<K> span() {
    Map.Entry<Cut<K>, RangeMapEntry<K, V>> firstEntry = this.entriesByLowerBound.firstEntry();
    Map.Entry<Cut<K>, RangeMapEntry<K, V>> lastEntry = this.entriesByLowerBound.lastEntry();
    if (firstEntry == null || lastEntry == null)
      throw new NoSuchElementException(); 
    return Range.create(
        (((RangeMapEntry)firstEntry.getValue()).getKey()).lowerBound, (((RangeMapEntry)lastEntry.getValue()).getKey()).upperBound);
  }
  
  private void putRangeMapEntry(Cut<K> lowerBound, Cut<K> upperBound, V value) { this.entriesByLowerBound.put(lowerBound, new RangeMapEntry(lowerBound, upperBound, value)); }
  
  public void remove(Range<K> rangeToRemove) {
    if (rangeToRemove.isEmpty())
      return; 
    Map.Entry<Cut<K>, RangeMapEntry<K, V>> mapEntryBelowToTruncate = this.entriesByLowerBound.lowerEntry(rangeToRemove.lowerBound);
    if (mapEntryBelowToTruncate != null) {
      RangeMapEntry<K, V> rangeMapEntry = (RangeMapEntry)mapEntryBelowToTruncate.getValue();
      if (rangeMapEntry.getUpperBound().compareTo(rangeToRemove.lowerBound) > 0) {
        if (rangeMapEntry.getUpperBound().compareTo(rangeToRemove.upperBound) > 0)
          putRangeMapEntry(rangeToRemove.upperBound, rangeMapEntry
              
              .getUpperBound(), ((RangeMapEntry)mapEntryBelowToTruncate
              .getValue()).getValue()); 
        putRangeMapEntry(rangeMapEntry
            .getLowerBound(), rangeToRemove.lowerBound, ((RangeMapEntry)mapEntryBelowToTruncate
            
            .getValue()).getValue());
      } 
    } 
    Map.Entry<Cut<K>, RangeMapEntry<K, V>> mapEntryAboveToTruncate = this.entriesByLowerBound.lowerEntry(rangeToRemove.upperBound);
    if (mapEntryAboveToTruncate != null) {
      RangeMapEntry<K, V> rangeMapEntry = (RangeMapEntry)mapEntryAboveToTruncate.getValue();
      if (rangeMapEntry.getUpperBound().compareTo(rangeToRemove.upperBound) > 0)
        putRangeMapEntry(rangeToRemove.upperBound, rangeMapEntry
            
            .getUpperBound(), ((RangeMapEntry)mapEntryAboveToTruncate
            .getValue()).getValue()); 
    } 
    this.entriesByLowerBound.subMap(rangeToRemove.lowerBound, rangeToRemove.upperBound).clear();
  }
  
  private void split(Cut<K> cut) {
    Map.Entry<Cut<K>, RangeMapEntry<K, V>> mapEntryToSplit = this.entriesByLowerBound.lowerEntry(cut);
    if (mapEntryToSplit == null)
      return; 
    RangeMapEntry<K, V> rangeMapEntry = (RangeMapEntry)mapEntryToSplit.getValue();
    if (rangeMapEntry.getUpperBound().compareTo(cut) <= 0)
      return; 
    putRangeMapEntry(rangeMapEntry.getLowerBound(), cut, rangeMapEntry.getValue());
    putRangeMapEntry(cut, rangeMapEntry.getUpperBound(), rangeMapEntry.getValue());
  }
  
  public void merge(Range<K> range, @CheckForNull V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
    Preconditions.checkNotNull(range);
    Preconditions.checkNotNull(remappingFunction);
    if (range.isEmpty())
      return; 
    split(range.lowerBound);
    split(range.upperBound);
    Set<Map.Entry<Cut<K>, RangeMapEntry<K, V>>> entriesInMergeRange = this.entriesByLowerBound.subMap(range.lowerBound, range.upperBound).entrySet();
    ImmutableMap.Builder<Cut<K>, RangeMapEntry<K, V>> gaps = ImmutableMap.builder();
    if (value != null) {
      Iterator<Map.Entry<Cut<K>, RangeMapEntry<K, V>>> backingItr = entriesInMergeRange.iterator();
      Cut<K> lowerBound = range.lowerBound;
      while (backingItr.hasNext()) {
        RangeMapEntry<K, V> entry = (RangeMapEntry)((Map.Entry)backingItr.next()).getValue();
        Cut<K> upperBound = entry.getLowerBound();
        if (!lowerBound.equals(upperBound))
          gaps.put(lowerBound, new RangeMapEntry(lowerBound, upperBound, value)); 
        lowerBound = entry.getUpperBound();
      } 
      if (!lowerBound.equals(range.upperBound))
        gaps.put(lowerBound, new RangeMapEntry(lowerBound, range.upperBound, value)); 
    } 
    Iterator<Map.Entry<Cut<K>, RangeMapEntry<K, V>>> backingItr = entriesInMergeRange.iterator();
    while (backingItr.hasNext()) {
      Map.Entry<Cut<K>, RangeMapEntry<K, V>> entry = (Map.Entry)backingItr.next();
      V newValue = (V)remappingFunction.apply(((RangeMapEntry)entry.getValue()).getValue(), value);
      if (newValue == null) {
        backingItr.remove();
        continue;
      } 
      entry.setValue(new RangeMapEntry(((RangeMapEntry)entry
            
            .getValue()).getLowerBound(), ((RangeMapEntry)entry.getValue()).getUpperBound(), newValue));
    } 
    this.entriesByLowerBound.putAll(gaps.build());
  }
  
  public Map<Range<K>, V> asMapOfRanges() { return new AsMapOfRanges(this, this.entriesByLowerBound.values()); }
  
  public Map<Range<K>, V> asDescendingMapOfRanges() { return new AsMapOfRanges(this, this.entriesByLowerBound.descendingMap().values()); }
  
  public RangeMap<K, V> subRangeMap(Range<K> subRange) {
    if (subRange.equals(Range.all()))
      return this; 
    return new SubRangeMap(this, subRange);
  }
  
  private RangeMap<K, V> emptySubRangeMap() { return EMPTY_SUB_RANGE_MAP; }
  
  private static final RangeMap<Comparable<?>, Object> EMPTY_SUB_RANGE_MAP = new Object();
  
  public boolean equals(@CheckForNull Object o) {
    if (o instanceof RangeMap) {
      RangeMap<?, ?> rangeMap = (RangeMap)o;
      return asMapOfRanges().equals(rangeMap.asMapOfRanges());
    } 
    return false;
  }
  
  public int hashCode() { return asMapOfRanges().hashCode(); }
  
  public String toString() { return this.entriesByLowerBound.values().toString(); }
}
