package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.errorprone.annotations.concurrent.LazyInit;
import com.google.j2objc.annotations.RetainedWith;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.function.BiConsumer;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible(serializable = true, emulated = true)
class RegularImmutableBiMap<K, V> extends ImmutableBiMap<K, V> {
  static final RegularImmutableBiMap<Object, Object> EMPTY = new RegularImmutableBiMap(null, null, ImmutableMap.EMPTY_ENTRY_ARRAY, 0, 0);
  
  static final double MAX_LOAD_FACTOR = 1.2D;
  
  @CheckForNull
  private final ImmutableMapEntry<K, V>[] keyTable;
  
  @CheckForNull
  private final ImmutableMapEntry<K, V>[] valueTable;
  
  @VisibleForTesting
  final Map.Entry<K, V>[] entries;
  
  private final int mask;
  
  private final int hashCode;
  
  @LazyInit
  @CheckForNull
  @RetainedWith
  private ImmutableBiMap<V, K> inverse;
  
  static <K, V> ImmutableBiMap<K, V> fromEntries(Entry... entries) { return fromEntryArray(entries.length, entries); }
  
  static <K, V> ImmutableBiMap<K, V> fromEntryArray(int n, Entry[] entryArray) {
    Preconditions.checkPositionIndex(n, entryArray.length);
    int tableSize = Hashing.closedTableSize(n, 1.2D);
    int mask = tableSize - 1;
    ImmutableMapEntry[] keyTable = ImmutableMapEntry.createEntryArray(tableSize);
    ImmutableMapEntry[] valueTable = ImmutableMapEntry.createEntryArray(tableSize);
    Entry[] entries = (n == entryArray.length) ? entryArray : ImmutableMapEntry.createEntryArray(n);
    int hashCode = 0;
    for (int i = 0; i < n; i++) {
      Map.Entry<K, V> entry = (Map.Entry)Objects.requireNonNull(entryArray[i]);
      K key = (K)entry.getKey();
      V value = (V)entry.getValue();
      CollectPreconditions.checkEntryNotNull(key, value);
      int keyHash = key.hashCode();
      int valueHash = value.hashCode();
      int keyBucket = Hashing.smear(keyHash) & mask;
      int valueBucket = Hashing.smear(valueHash) & mask;
      ImmutableMapEntry<K, V> nextInKeyBucket = keyTable[keyBucket];
      ImmutableMapEntry<K, V> nextInValueBucket = valueTable[valueBucket];
      try {
        RegularImmutableMap.checkNoConflictInKeyBucket(key, value, nextInKeyBucket, true);
        checkNoConflictInValueBucket(value, entry, nextInValueBucket);
      } catch (BucketOverflowException e) {
        return JdkBackedImmutableBiMap.create(n, entryArray);
      } 
      ImmutableMapEntry<K, V> newEntry = (nextInValueBucket == null && nextInKeyBucket == null) ? RegularImmutableMap.makeImmutable(entry, key, value) : new ImmutableMapEntry.NonTerminalImmutableBiMapEntry(key, value, nextInKeyBucket, nextInValueBucket);
      keyTable[keyBucket] = newEntry;
      valueTable[valueBucket] = newEntry;
      entries[i] = newEntry;
      hashCode += (keyHash ^ valueHash);
    } 
    return new RegularImmutableBiMap(keyTable, valueTable, entries, mask, hashCode);
  }
  
  private RegularImmutableBiMap(@CheckForNull ImmutableMapEntry[] keyTable, @CheckForNull ImmutableMapEntry[] valueTable, Entry[] entries, int mask, int hashCode) {
    this.keyTable = keyTable;
    this.valueTable = valueTable;
    this.entries = entries;
    this.mask = mask;
    this.hashCode = hashCode;
  }
  
  private static void checkNoConflictInValueBucket(Object value, Map.Entry<?, ?> entry, @CheckForNull ImmutableMapEntry<?, ?> valueBucketHead) throws RegularImmutableMap.BucketOverflowException {
    int bucketSize = 0;
    for (; valueBucketHead != null; valueBucketHead = valueBucketHead.getNextInValueBucket()) {
      checkNoConflict(!value.equals(valueBucketHead.getValue()), "value", entry, valueBucketHead);
      if (++bucketSize > 8)
        throw new RegularImmutableMap.BucketOverflowException(); 
    } 
  }
  
  @CheckForNull
  public V get(@CheckForNull Object key) { return (V)RegularImmutableMap.get(key, this.keyTable, this.mask); }
  
  ImmutableSet<Map.Entry<K, V>> createEntrySet() {
    return isEmpty() ? 
      ImmutableSet.of() : 
      new ImmutableMapEntrySet.RegularEntrySet(this, this.entries);
  }
  
  ImmutableSet<K> createKeySet() { return new ImmutableMapKeySet(this); }
  
  public void forEach(BiConsumer<? super K, ? super V> action) {
    Preconditions.checkNotNull(action);
    for (Map.Entry<K, V> entry : this.entries)
      action.accept(entry.getKey(), entry.getValue()); 
  }
  
  boolean isHashCodeFast() { return true; }
  
  public int hashCode() { return this.hashCode; }
  
  boolean isPartialView() { return false; }
  
  public int size() { return this.entries.length; }
  
  public ImmutableBiMap<V, K> inverse() {
    if (isEmpty())
      return ImmutableBiMap.of(); 
    ImmutableBiMap<V, K> result = this.inverse;
    return (result == null) ? (this.inverse = new Inverse(this, null)) : result;
  }
}
