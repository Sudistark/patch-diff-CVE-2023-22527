package com.google.common.collect;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.base.Preconditions;
import com.google.errorprone.annotations.DoNotCall;
import com.google.errorprone.annotations.concurrent.LazyInit;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.stream.Collector;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtIncompatible
public final class ImmutableRangeSet<C extends Comparable> extends AbstractRangeSet<C> implements Serializable {
  private static final ImmutableRangeSet<Comparable<?>> EMPTY = new ImmutableRangeSet(
      ImmutableList.of());
  
  private static final ImmutableRangeSet<Comparable<?>> ALL = new ImmutableRangeSet(
      ImmutableList.of(Range.all()));
  
  private final ImmutableList<Range<C>> ranges;
  
  @LazyInit
  @CheckForNull
  private ImmutableRangeSet<C> complement;
  
  public static <E extends Comparable<? super E>> Collector<Range<E>, ?, ImmutableRangeSet<E>> toImmutableRangeSet() { return CollectCollectors.toImmutableRangeSet(); }
  
  public static <C extends Comparable> ImmutableRangeSet<C> of() { return EMPTY; }
  
  public static <C extends Comparable> ImmutableRangeSet<C> of(Range<C> range) {
    Preconditions.checkNotNull(range);
    if (range.isEmpty())
      return of(); 
    if (range.equals(Range.all()))
      return all(); 
    return new ImmutableRangeSet(ImmutableList.of(range));
  }
  
  static <C extends Comparable> ImmutableRangeSet<C> all() { return ALL; }
  
  public static <C extends Comparable> ImmutableRangeSet<C> copyOf(RangeSet<C> rangeSet) {
    Preconditions.checkNotNull(rangeSet);
    if (rangeSet.isEmpty())
      return of(); 
    if (rangeSet.encloses(Range.all()))
      return all(); 
    if (rangeSet instanceof ImmutableRangeSet) {
      ImmutableRangeSet<C> immutableRangeSet = (ImmutableRangeSet)rangeSet;
      if (!immutableRangeSet.isPartialView())
        return immutableRangeSet; 
    } 
    return new ImmutableRangeSet(ImmutableList.copyOf(rangeSet.asRanges()));
  }
  
  public static <C extends Comparable<?>> ImmutableRangeSet<C> copyOf(Iterable<Range<C>> ranges) { return (new Builder()).addAll(ranges).build(); }
  
  public static <C extends Comparable<?>> ImmutableRangeSet<C> unionOf(Iterable<Range<C>> ranges) { return copyOf(TreeRangeSet.create(ranges)); }
  
  ImmutableRangeSet(ImmutableList<Range<C>> ranges) { this.ranges = ranges; }
  
  private ImmutableRangeSet(ImmutableList<Range<C>> ranges, ImmutableRangeSet<C> complement) {
    this.ranges = ranges;
    this.complement = complement;
  }
  
  public boolean intersects(Range<C> otherRange) {
    int ceilingIndex = SortedLists.binarySearch(this.ranges, 
        
        Range.lowerBoundFn(), otherRange.lowerBound, 
        
        Ordering.natural(), SortedLists.KeyPresentBehavior.ANY_PRESENT, SortedLists.KeyAbsentBehavior.NEXT_HIGHER);
    if (ceilingIndex < this.ranges.size() && ((Range)this.ranges
      .get(ceilingIndex)).isConnected(otherRange) && 
      !((Range)this.ranges.get(ceilingIndex)).intersection(otherRange).isEmpty())
      return true; 
    return (ceilingIndex > 0 && ((Range)this.ranges
      .get(ceilingIndex - 1)).isConnected(otherRange) && 
      !((Range)this.ranges.get(ceilingIndex - 1)).intersection(otherRange).isEmpty());
  }
  
  public boolean encloses(Range<C> otherRange) {
    int index = SortedLists.binarySearch(this.ranges, 
        
        Range.lowerBoundFn(), otherRange.lowerBound, 
        
        Ordering.natural(), SortedLists.KeyPresentBehavior.ANY_PRESENT, SortedLists.KeyAbsentBehavior.NEXT_LOWER);
    return (index != -1 && ((Range)this.ranges.get(index)).encloses(otherRange));
  }
  
  @CheckForNull
  public Range<C> rangeContaining(C value) {
    int index = SortedLists.binarySearch(this.ranges, 
        
        Range.lowerBoundFn(), 
        Cut.belowValue(value), 
        Ordering.natural(), SortedLists.KeyPresentBehavior.ANY_PRESENT, SortedLists.KeyAbsentBehavior.NEXT_LOWER);
    if (index != -1) {
      Range<C> range = (Range)this.ranges.get(index);
      return range.contains(value) ? range : null;
    } 
    return null;
  }
  
  public Range<C> span() {
    if (this.ranges.isEmpty())
      throw new NoSuchElementException(); 
    return Range.create(((Range)this.ranges.get(0)).lowerBound, ((Range)this.ranges.get(this.ranges.size() - 1)).upperBound);
  }
  
  public boolean isEmpty() { return this.ranges.isEmpty(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public void add(Range<C> range) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public void addAll(RangeSet<C> other) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public void addAll(Iterable<Range<C>> other) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public void remove(Range<C> range) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public void removeAll(RangeSet<C> other) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public void removeAll(Iterable<Range<C>> other) { throw new UnsupportedOperationException(); }
  
  public ImmutableSet<Range<C>> asRanges() {
    if (this.ranges.isEmpty())
      return ImmutableSet.of(); 
    return new RegularImmutableSortedSet(this.ranges, Range.rangeLexOrdering());
  }
  
  public ImmutableSet<Range<C>> asDescendingSetOfRanges() {
    if (this.ranges.isEmpty())
      return ImmutableSet.of(); 
    return new RegularImmutableSortedSet(this.ranges.reverse(), Range.rangeLexOrdering().reverse());
  }
  
  public ImmutableRangeSet<C> complement() {
    result = this.complement;
    if (result != null)
      return result; 
    if (this.ranges.isEmpty())
      return this.complement = all(); 
    if (this.ranges.size() == 1 && ((Range)this.ranges.get(0)).equals(Range.all()))
      return this.complement = of(); 
    ComplementRanges complementRanges1 = new ComplementRanges(this);
    return this.complement = new ImmutableRangeSet(complementRanges1, this);
  }
  
  public ImmutableRangeSet<C> union(RangeSet<C> other) { return unionOf(Iterables.concat(asRanges(), other.asRanges())); }
  
  public ImmutableRangeSet<C> intersection(RangeSet<C> other) {
    TreeRangeSet treeRangeSet = TreeRangeSet.create(this);
    treeRangeSet.removeAll(other.complement());
    return copyOf(treeRangeSet);
  }
  
  public ImmutableRangeSet<C> difference(RangeSet<C> other) {
    TreeRangeSet treeRangeSet = TreeRangeSet.create(this);
    treeRangeSet.removeAll(other);
    return copyOf(treeRangeSet);
  }
  
  private ImmutableList<Range<C>> intersectRanges(Range<C> range) {
    int toIndex, fromIndex;
    if (this.ranges.isEmpty() || range.isEmpty())
      return ImmutableList.of(); 
    if (range.encloses(span()))
      return this.ranges; 
    if (range.hasLowerBound()) {
      fromIndex = SortedLists.binarySearch(this.ranges, 
          
          Range.upperBoundFn(), range.lowerBound, SortedLists.KeyPresentBehavior.FIRST_AFTER, SortedLists.KeyAbsentBehavior.NEXT_HIGHER);
    } else {
      fromIndex = 0;
    } 
    if (range.hasUpperBound()) {
      toIndex = SortedLists.binarySearch(this.ranges, 
          
          Range.lowerBoundFn(), range.upperBound, SortedLists.KeyPresentBehavior.FIRST_PRESENT, SortedLists.KeyAbsentBehavior.NEXT_HIGHER);
    } else {
      toIndex = this.ranges.size();
    } 
    int length = toIndex - fromIndex;
    if (length == 0)
      return ImmutableList.of(); 
    return new Object(this, length, fromIndex, range);
  }
  
  public ImmutableRangeSet<C> subRangeSet(Range<C> range) {
    if (!isEmpty()) {
      Range<C> span = span();
      if (range.encloses(span))
        return this; 
      if (range.isConnected(span))
        return new ImmutableRangeSet(intersectRanges(range)); 
    } 
    return of();
  }
  
  public ImmutableSortedSet<C> asSet(DiscreteDomain<C> domain) {
    Preconditions.checkNotNull(domain);
    if (isEmpty())
      return ImmutableSortedSet.of(); 
    Range<C> span = span().canonical(domain);
    if (!span.hasLowerBound())
      throw new IllegalArgumentException("Neither the DiscreteDomain nor this range set are bounded below"); 
    if (!span.hasUpperBound())
      try {
        domain.maxValue();
      } catch (NoSuchElementException e) {
        throw new IllegalArgumentException("Neither the DiscreteDomain nor this range set are bounded above");
      }  
    return new AsSet(this, domain);
  }
  
  boolean isPartialView() { return this.ranges.isPartialView(); }
  
  public static <C extends Comparable<?>> Builder<C> builder() { return new Builder(); }
  
  @J2ktIncompatible
  Object writeReplace() { return new SerializedForm(this.ranges); }
  
  @J2ktIncompatible
  private void readObject(ObjectInputStream stream) throws InvalidObjectException { throw new InvalidObjectException("Use SerializedForm"); }
}
