package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.base.Preconditions;
import com.google.common.primitives.Ints;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.io.InvalidObjectException;
import java.io.Serializable;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.function.ObjIntConsumer;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible(emulated = true)
abstract class AbstractMapBasedMultiset<E> extends AbstractMultiset<E> implements Serializable {
  private Map<E, Count> backingMap;
  
  private long size;
  
  @GwtIncompatible
  @J2ktIncompatible
  private static final long serialVersionUID = -2250766705698539974L;
  
  protected AbstractMapBasedMultiset(Map<E, Count> backingMap) {
    Preconditions.checkArgument(backingMap.isEmpty());
    this.backingMap = backingMap;
  }
  
  void setBackingMap(Map<E, Count> backingMap) { this.backingMap = backingMap; }
  
  public Set<Multiset.Entry<E>> entrySet() { return super.entrySet(); }
  
  Iterator<E> elementIterator() {
    Iterator<Map.Entry<E, Count>> backingEntries = this.backingMap.entrySet().iterator();
    return new Object(this, backingEntries);
  }
  
  Iterator<Multiset.Entry<E>> entryIterator() {
    Iterator<Map.Entry<E, Count>> backingEntries = this.backingMap.entrySet().iterator();
    return new Object(this, backingEntries);
  }
  
  public void forEachEntry(ObjIntConsumer<? super E> action) {
    Preconditions.checkNotNull(action);
    this.backingMap.forEach((element, count) -> action.accept(element, count.get()));
  }
  
  public void clear() {
    for (Count frequency : this.backingMap.values())
      frequency.set(0); 
    this.backingMap.clear();
    this.size = 0L;
  }
  
  int distinctElements() { return this.backingMap.size(); }
  
  public int size() { return Ints.saturatedCast(this.size); }
  
  public Iterator<E> iterator() { return new MapBasedMultisetIterator(this); }
  
  public int count(@CheckForNull Object element) {
    Count frequency = (Count)Maps.safeGet(this.backingMap, element);
    return (frequency == null) ? 0 : frequency.get();
  }
  
  @CanIgnoreReturnValue
  public int add(@ParametricNullness E element, int occurrences) {
    int oldCount;
    if (occurrences == 0)
      return count(element); 
    Preconditions.checkArgument((occurrences > 0), "occurrences cannot be negative: %s", occurrences);
    Count frequency = (Count)this.backingMap.get(element);
    if (frequency == null) {
      oldCount = 0;
      this.backingMap.put(element, new Count(occurrences));
    } else {
      oldCount = frequency.get();
      long newCount = oldCount + occurrences;
      Preconditions.checkArgument((newCount <= 2147483647L), "too many occurrences: %s", newCount);
      frequency.add(occurrences);
    } 
    this.size += occurrences;
    return oldCount;
  }
  
  @CanIgnoreReturnValue
  public int remove(@CheckForNull Object element, int occurrences) {
    int numberRemoved;
    if (occurrences == 0)
      return count(element); 
    Preconditions.checkArgument((occurrences > 0), "occurrences cannot be negative: %s", occurrences);
    Count frequency = (Count)this.backingMap.get(element);
    if (frequency == null)
      return 0; 
    int oldCount = frequency.get();
    if (oldCount > occurrences) {
      numberRemoved = occurrences;
    } else {
      numberRemoved = oldCount;
      this.backingMap.remove(element);
    } 
    frequency.add(-numberRemoved);
    this.size -= numberRemoved;
    return oldCount;
  }
  
  @CanIgnoreReturnValue
  public int setCount(@ParametricNullness E element, int count) {
    int oldCount;
    CollectPreconditions.checkNonnegative(count, "count");
    if (count == 0) {
      Count existingCounter = (Count)this.backingMap.remove(element);
      oldCount = getAndSet(existingCounter, count);
    } else {
      Count existingCounter = (Count)this.backingMap.get(element);
      oldCount = getAndSet(existingCounter, count);
      if (existingCounter == null)
        this.backingMap.put(element, new Count(count)); 
    } 
    this.size += (count - oldCount);
    return oldCount;
  }
  
  private static int getAndSet(@CheckForNull Count i, int count) {
    if (i == null)
      return 0; 
    return i.getAndSet(count);
  }
  
  @GwtIncompatible
  @J2ktIncompatible
  private void readObjectNoData() { throw new InvalidObjectException("Stream data required"); }
}
