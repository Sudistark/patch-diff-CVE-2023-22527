package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.NavigableSet;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.stream.Collector;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible(emulated = true)
public final class Sets {
  @GwtCompatible(serializable = true)
  public static <E extends Enum<E>> ImmutableSet<E> immutableEnumSet(E anElement, E... otherElements) { return ImmutableEnumSet.asImmutable(EnumSet.of(anElement, otherElements)); }
  
  @GwtCompatible(serializable = true)
  public static <E extends Enum<E>> ImmutableSet<E> immutableEnumSet(Iterable<E> elements) {
    if (elements instanceof ImmutableEnumSet)
      return (ImmutableEnumSet)elements; 
    if (elements instanceof Collection) {
      Collection<E> collection = (Collection)elements;
      if (collection.isEmpty())
        return ImmutableSet.of(); 
      return ImmutableEnumSet.asImmutable(EnumSet.copyOf(collection));
    } 
    Iterator<E> itr = elements.iterator();
    if (itr.hasNext()) {
      EnumSet<E> enumSet = EnumSet.of((Enum)itr.next());
      Iterators.addAll(enumSet, itr);
      return ImmutableEnumSet.asImmutable(enumSet);
    } 
    return ImmutableSet.of();
  }
  
  public static <E extends Enum<E>> Collector<E, ?, ImmutableSet<E>> toImmutableEnumSet() { return CollectCollectors.toImmutableEnumSet(); }
  
  public static <E extends Enum<E>> EnumSet<E> newEnumSet(Iterable<E> iterable, Class<E> elementType) {
    EnumSet<E> set = EnumSet.noneOf(elementType);
    Iterables.addAll(set, iterable);
    return set;
  }
  
  public static <E> HashSet<E> newHashSet() { return new HashSet(); }
  
  public static <E> HashSet<E> newHashSet(E... elements) {
    HashSet<E> set = newHashSetWithExpectedSize(elements.length);
    Collections.addAll(set, elements);
    return set;
  }
  
  public static <E> HashSet<E> newHashSet(Iterable<? extends E> elements) {
    return (elements instanceof Collection) ? 
      new HashSet((Collection)elements) : 
      newHashSet(elements.iterator());
  }
  
  public static <E> HashSet<E> newHashSet(Iterator<? extends E> elements) {
    HashSet<E> set = newHashSet();
    Iterators.addAll(set, elements);
    return set;
  }
  
  public static <E> HashSet<E> newHashSetWithExpectedSize(int expectedSize) { return new HashSet(Maps.capacity(expectedSize)); }
  
  public static <E> Set<E> newConcurrentHashSet() { return Platform.newConcurrentHashSet(); }
  
  public static <E> Set<E> newConcurrentHashSet(Iterable<? extends E> elements) {
    Set<E> set = newConcurrentHashSet();
    Iterables.addAll(set, elements);
    return set;
  }
  
  public static <E> LinkedHashSet<E> newLinkedHashSet() { return new LinkedHashSet(); }
  
  public static <E> LinkedHashSet<E> newLinkedHashSet(Iterable<? extends E> elements) {
    if (elements instanceof Collection)
      return new LinkedHashSet((Collection)elements); 
    LinkedHashSet<E> set = newLinkedHashSet();
    Iterables.addAll(set, elements);
    return set;
  }
  
  public static <E> LinkedHashSet<E> newLinkedHashSetWithExpectedSize(int expectedSize) { return new LinkedHashSet(Maps.capacity(expectedSize)); }
  
  public static <E extends Comparable> TreeSet<E> newTreeSet() { return new TreeSet(); }
  
  public static <E extends Comparable> TreeSet<E> newTreeSet(Iterable<? extends E> elements) {
    TreeSet<E> set = newTreeSet();
    Iterables.addAll(set, elements);
    return set;
  }
  
  public static <E> TreeSet<E> newTreeSet(Comparator<? super E> comparator) { return new TreeSet((Comparator)Preconditions.checkNotNull(comparator)); }
  
  public static <E> Set<E> newIdentityHashSet() { return Collections.newSetFromMap(Maps.newIdentityHashMap()); }
  
  @J2ktIncompatible
  @GwtIncompatible
  public static <E> CopyOnWriteArraySet<E> newCopyOnWriteArraySet() { return new CopyOnWriteArraySet(); }
  
  @J2ktIncompatible
  @GwtIncompatible
  public static <E> CopyOnWriteArraySet<E> newCopyOnWriteArraySet(Iterable<? extends E> elements) {
    Collection<? extends E> elementsCollection = (elements instanceof Collection) ? (Collection)elements : Lists.newArrayList(elements);
    return new CopyOnWriteArraySet(elementsCollection);
  }
  
  @J2ktIncompatible
  @GwtIncompatible
  public static <E extends Enum<E>> EnumSet<E> complementOf(Collection<E> collection) {
    if (collection instanceof EnumSet)
      return EnumSet.complementOf((EnumSet)collection); 
    Preconditions.checkArgument(
        !collection.isEmpty(), "collection is empty; use the other version of this method");
    Class<E> type = ((Enum)collection.iterator().next()).getDeclaringClass();
    return makeComplementByHand(collection, type);
  }
  
  @GwtIncompatible
  public static <E extends Enum<E>> EnumSet<E> complementOf(Collection<E> collection, Class<E> type) {
    Preconditions.checkNotNull(collection);
    return (collection instanceof EnumSet) ? 
      EnumSet.complementOf((EnumSet)collection) : 
      makeComplementByHand(collection, type);
  }
  
  @GwtIncompatible
  private static <E extends Enum<E>> EnumSet<E> makeComplementByHand(Collection<E> collection, Class<E> type) {
    EnumSet<E> result = EnumSet.allOf(type);
    result.removeAll(collection);
    return result;
  }
  
  @Deprecated
  public static <E> Set<E> newSetFromMap(Map<E, Boolean> map) { return Collections.newSetFromMap(map); }
  
  public static <E> SetView<E> union(Set<? extends E> set1, Set<? extends E> set2) {
    Preconditions.checkNotNull(set1, "set1");
    Preconditions.checkNotNull(set2, "set2");
    return new Object(set1, set2);
  }
  
  public static <E> SetView<E> intersection(Set<E> set1, Set<?> set2) {
    Preconditions.checkNotNull(set1, "set1");
    Preconditions.checkNotNull(set2, "set2");
    return new Object(set1, set2);
  }
  
  public static <E> SetView<E> difference(Set<E> set1, Set<?> set2) {
    Preconditions.checkNotNull(set1, "set1");
    Preconditions.checkNotNull(set2, "set2");
    return new Object(set1, set2);
  }
  
  public static <E> SetView<E> symmetricDifference(Set<? extends E> set1, Set<? extends E> set2) {
    Preconditions.checkNotNull(set1, "set1");
    Preconditions.checkNotNull(set2, "set2");
    return new Object(set1, set2);
  }
  
  public static <E> Set<E> filter(Set<E> unfiltered, Predicate<? super E> predicate) {
    if (unfiltered instanceof SortedSet)
      return filter((SortedSet)unfiltered, predicate); 
    if (unfiltered instanceof FilteredSet) {
      FilteredSet<E> filtered = (FilteredSet)unfiltered;
      Predicate<E> combinedPredicate = Predicates.and(filtered.predicate, predicate);
      return new FilteredSet((Set)filtered.unfiltered, combinedPredicate);
    } 
    return new FilteredSet((Set)Preconditions.checkNotNull(unfiltered), (Predicate)Preconditions.checkNotNull(predicate));
  }
  
  public static <E> SortedSet<E> filter(SortedSet<E> unfiltered, Predicate<? super E> predicate) {
    if (unfiltered instanceof FilteredSet) {
      FilteredSet<E> filtered = (FilteredSet)unfiltered;
      Predicate<E> combinedPredicate = Predicates.and(filtered.predicate, predicate);
      return new FilteredSortedSet((SortedSet)filtered.unfiltered, combinedPredicate);
    } 
    return new FilteredSortedSet((SortedSet)Preconditions.checkNotNull(unfiltered), (Predicate)Preconditions.checkNotNull(predicate));
  }
  
  @GwtIncompatible
  public static <E> NavigableSet<E> filter(NavigableSet<E> unfiltered, Predicate<? super E> predicate) {
    if (unfiltered instanceof FilteredSet) {
      FilteredSet<E> filtered = (FilteredSet)unfiltered;
      Predicate<E> combinedPredicate = Predicates.and(filtered.predicate, predicate);
      return new FilteredNavigableSet((NavigableSet)filtered.unfiltered, combinedPredicate);
    } 
    return new FilteredNavigableSet((NavigableSet)Preconditions.checkNotNull(unfiltered), (Predicate)Preconditions.checkNotNull(predicate));
  }
  
  public static <B> Set<List<B>> cartesianProduct(List<? extends Set<? extends B>> sets) { return CartesianSet.create(sets); }
  
  @SafeVarargs
  public static <B> Set<List<B>> cartesianProduct(Set... sets) { return cartesianProduct(Arrays.asList(sets)); }
  
  @GwtCompatible(serializable = false)
  public static <E> Set<Set<E>> powerSet(Set<E> set) { return new PowerSet(set); }
  
  public static <E> Set<Set<E>> combinations(Set<E> set, int size) {
    ImmutableMap<E, Integer> index = Maps.indexMap(set);
    CollectPreconditions.checkNonnegative(size, "size");
    Preconditions.checkArgument((size <= index.size()), "size (%s) must be <= set.size() (%s)", size, index.size());
    if (size == 0)
      return ImmutableSet.of(ImmutableSet.of()); 
    if (size == index.size())
      return ImmutableSet.of(index.keySet()); 
    return new Object(size, index);
  }
  
  static int hashCodeImpl(Set<?> s) {
    int hashCode = 0;
    for (Object o : s) {
      hashCode += ((o != null) ? o.hashCode() : 0);
      hashCode = hashCode ^ 0xFFFFFFFF ^ 0xFFFFFFFF;
    } 
    return hashCode;
  }
  
  static boolean equalsImpl(Set<?> s, @CheckForNull Object object) {
    if (s == object)
      return true; 
    if (object instanceof Set) {
      Set<?> o = (Set)object;
      try {
        return (s.size() == o.size() && s.containsAll(o));
      } catch (NullPointerException|ClassCastException ignored) {
        return false;
      } 
    } 
    return false;
  }
  
  public static <E> NavigableSet<E> unmodifiableNavigableSet(NavigableSet<E> set) {
    if (set instanceof ImmutableCollection || set instanceof UnmodifiableNavigableSet)
      return set; 
    return new UnmodifiableNavigableSet(set);
  }
  
  @GwtIncompatible
  public static <E> NavigableSet<E> synchronizedNavigableSet(NavigableSet<E> navigableSet) { return Synchronized.navigableSet(navigableSet); }
  
  static boolean removeAllImpl(Set<?> set, Iterator<?> iterator) {
    boolean changed = false;
    while (iterator.hasNext())
      changed |= set.remove(iterator.next()); 
    return changed;
  }
  
  static boolean removeAllImpl(Set<?> set, Collection<?> collection) {
    Preconditions.checkNotNull(collection);
    if (collection instanceof Multiset)
      collection = ((Multiset)collection).elementSet(); 
    if (collection instanceof Set && collection.size() > set.size())
      return Iterators.removeAll(set.iterator(), collection); 
    return removeAllImpl(set, collection.iterator());
  }
  
  @GwtIncompatible
  public static <K extends Comparable<? super K>> NavigableSet<K> subSet(NavigableSet<K> set, Range<K> range) {
    if (set.comparator() != null && set
      .comparator() != Ordering.natural() && range
      .hasLowerBound() && range
      .hasUpperBound())
      Preconditions.checkArgument(
          (set.comparator().compare(range.lowerEndpoint(), range.upperEndpoint()) <= 0), "set is using a custom comparator which is inconsistent with the natural ordering."); 
    if (range.hasLowerBound() && range.hasUpperBound())
      return set.subSet(range
          .lowerEndpoint(), 
          (range.lowerBoundType() == BoundType.CLOSED), range
          .upperEndpoint(), 
          (range.upperBoundType() == BoundType.CLOSED)); 
    if (range.hasLowerBound())
      return set.tailSet(range.lowerEndpoint(), (range.lowerBoundType() == BoundType.CLOSED)); 
    if (range.hasUpperBound())
      return set.headSet(range.upperEndpoint(), (range.upperBoundType() == BoundType.CLOSED)); 
    return (NavigableSet)Preconditions.checkNotNull(set);
  }
}
