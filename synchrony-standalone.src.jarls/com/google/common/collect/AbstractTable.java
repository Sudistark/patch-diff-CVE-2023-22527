package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.concurrent.LazyInit;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.Spliterator;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible
abstract class AbstractTable<R, C, V> extends Object implements Table<R, C, V> {
  @LazyInit
  @CheckForNull
  private Set<Table.Cell<R, C, V>> cellSet;
  
  @LazyInit
  @CheckForNull
  private Collection<V> values;
  
  public boolean containsRow(@CheckForNull Object rowKey) { return Maps.safeContainsKey(rowMap(), rowKey); }
  
  public boolean containsColumn(@CheckForNull Object columnKey) { return Maps.safeContainsKey(columnMap(), columnKey); }
  
  public Set<R> rowKeySet() { return rowMap().keySet(); }
  
  public Set<C> columnKeySet() { return columnMap().keySet(); }
  
  public boolean containsValue(@CheckForNull Object value) {
    for (Map<C, V> row : rowMap().values()) {
      if (row.containsValue(value))
        return true; 
    } 
    return false;
  }
  
  public boolean contains(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
    Map<C, V> row = (Map)Maps.safeGet(rowMap(), rowKey);
    return (row != null && Maps.safeContainsKey(row, columnKey));
  }
  
  @CheckForNull
  public V get(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
    Map<C, V> row = (Map)Maps.safeGet(rowMap(), rowKey);
    return (V)((row == null) ? null : Maps.safeGet(row, columnKey));
  }
  
  public boolean isEmpty() { return (size() == 0); }
  
  public void clear() { Iterators.clear(cellSet().iterator()); }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
    Map<C, V> row = (Map)Maps.safeGet(rowMap(), rowKey);
    return (V)((row == null) ? null : Maps.safeRemove(row, columnKey));
  }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V put(@ParametricNullness R rowKey, @ParametricNullness C columnKey, @ParametricNullness V value) { return (V)row(rowKey).put(columnKey, value); }
  
  public void putAll(Table<? extends R, ? extends C, ? extends V> table) {
    for (Table.Cell<? extends R, ? extends C, ? extends V> cell : table.cellSet())
      put(cell.getRowKey(), cell.getColumnKey(), cell.getValue()); 
  }
  
  public Set<Table.Cell<R, C, V>> cellSet() {
    Set<Table.Cell<R, C, V>> result = this.cellSet;
    return (result == null) ? (this.cellSet = createCellSet()) : result;
  }
  
  Set<Table.Cell<R, C, V>> createCellSet() { return new CellSet(this); }
  
  abstract Iterator<Table.Cell<R, C, V>> cellIterator();
  
  abstract Spliterator<Table.Cell<R, C, V>> cellSpliterator();
  
  public Collection<V> values() {
    Collection<V> result = this.values;
    return (result == null) ? (this.values = createValues()) : result;
  }
  
  Collection<V> createValues() { return new Values(this); }
  
  Iterator<V> valuesIterator() { return new Object(this, cellSet().iterator()); }
  
  Spliterator<V> valuesSpliterator() { return CollectSpliterators.map(cellSpliterator(), Table.Cell::getValue); }
  
  public boolean equals(@CheckForNull Object obj) { return Tables.equalsImpl(this, obj); }
  
  public int hashCode() { return cellSet().hashCode(); }
  
  public String toString() { return rowMap().toString(); }
}
