package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.primitives.Ints;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.Objects;
import java.util.Spliterator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.function.ToIntFunction;
import java.util.stream.Collector;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtCompatible
public final class Multisets {
  public static <T, E, M extends Multiset<E>> Collector<T, ?, M> toMultiset(Function<? super T, E> elementFunction, ToIntFunction<? super T> countFunction, Supplier<M> multisetSupplier) { return CollectCollectors.toMultiset(elementFunction, countFunction, multisetSupplier); }
  
  public static <E> Multiset<E> unmodifiableMultiset(Multiset<? extends E> multiset) {
    if (multiset instanceof UnmodifiableMultiset || multiset instanceof ImmutableMultiset)
      return multiset; 
    return new UnmodifiableMultiset((Multiset)Preconditions.checkNotNull(multiset));
  }
  
  @Deprecated
  public static <E> Multiset<E> unmodifiableMultiset(ImmutableMultiset<E> multiset) { return (Multiset)Preconditions.checkNotNull(multiset); }
  
  public static <E> SortedMultiset<E> unmodifiableSortedMultiset(SortedMultiset<E> sortedMultiset) { return new UnmodifiableSortedMultiset((SortedMultiset)Preconditions.checkNotNull(sortedMultiset)); }
  
  public static <E> Multiset.Entry<E> immutableEntry(@ParametricNullness E e, int n) { return new ImmutableEntry(e, n); }
  
  public static <E> Multiset<E> filter(Multiset<E> unfiltered, Predicate<? super E> predicate) {
    if (unfiltered instanceof FilteredMultiset) {
      FilteredMultiset<E> filtered = (FilteredMultiset)unfiltered;
      Predicate<E> combinedPredicate = Predicates.and(filtered.predicate, predicate);
      return new FilteredMultiset(filtered.unfiltered, combinedPredicate);
    } 
    return new FilteredMultiset(unfiltered, predicate);
  }
  
  static int inferDistinctElements(Iterable<?> elements) {
    if (elements instanceof Multiset)
      return ((Multiset)elements).elementSet().size(); 
    return 11;
  }
  
  public static <E> Multiset<E> union(Multiset<? extends E> multiset1, Multiset<? extends E> multiset2) {
    Preconditions.checkNotNull(multiset1);
    Preconditions.checkNotNull(multiset2);
    return new Object(multiset1, multiset2);
  }
  
  public static <E> Multiset<E> intersection(Multiset<E> multiset1, Multiset<?> multiset2) {
    Preconditions.checkNotNull(multiset1);
    Preconditions.checkNotNull(multiset2);
    return new Object(multiset1, multiset2);
  }
  
  public static <E> Multiset<E> sum(Multiset<? extends E> multiset1, Multiset<? extends E> multiset2) {
    Preconditions.checkNotNull(multiset1);
    Preconditions.checkNotNull(multiset2);
    return new Object(multiset1, multiset2);
  }
  
  public static <E> Multiset<E> difference(Multiset<E> multiset1, Multiset<?> multiset2) {
    Preconditions.checkNotNull(multiset1);
    Preconditions.checkNotNull(multiset2);
    return new Object(multiset1, multiset2);
  }
  
  @CanIgnoreReturnValue
  public static boolean containsOccurrences(Multiset<?> superMultiset, Multiset<?> subMultiset) {
    Preconditions.checkNotNull(superMultiset);
    Preconditions.checkNotNull(subMultiset);
    for (Multiset.Entry<?> entry : subMultiset.entrySet()) {
      int superCount = superMultiset.count(entry.getElement());
      if (superCount < entry.getCount())
        return false; 
    } 
    return true;
  }
  
  @CanIgnoreReturnValue
  public static boolean retainOccurrences(Multiset<?> multisetToModify, Multiset<?> multisetToRetain) { return retainOccurrencesImpl(multisetToModify, multisetToRetain); }
  
  private static <E> boolean retainOccurrencesImpl(Multiset<E> multisetToModify, Multiset<?> occurrencesToRetain) {
    Preconditions.checkNotNull(multisetToModify);
    Preconditions.checkNotNull(occurrencesToRetain);
    Iterator<Multiset.Entry<E>> entryIterator = multisetToModify.entrySet().iterator();
    boolean changed = false;
    while (entryIterator.hasNext()) {
      Multiset.Entry<E> entry = (Multiset.Entry)entryIterator.next();
      int retainCount = occurrencesToRetain.count(entry.getElement());
      if (retainCount == 0) {
        entryIterator.remove();
        changed = true;
        continue;
      } 
      if (retainCount < entry.getCount()) {
        multisetToModify.setCount(entry.getElement(), retainCount);
        changed = true;
      } 
    } 
    return changed;
  }
  
  @CanIgnoreReturnValue
  public static boolean removeOccurrences(Multiset<?> multisetToModify, Iterable<?> occurrencesToRemove) {
    if (occurrencesToRemove instanceof Multiset)
      return removeOccurrences(multisetToModify, (Multiset)occurrencesToRemove); 
    Preconditions.checkNotNull(multisetToModify);
    Preconditions.checkNotNull(occurrencesToRemove);
    boolean changed = false;
    for (Object o : occurrencesToRemove)
      changed |= multisetToModify.remove(o); 
    return changed;
  }
  
  @CanIgnoreReturnValue
  public static boolean removeOccurrences(Multiset<?> multisetToModify, Multiset<?> occurrencesToRemove) {
    Preconditions.checkNotNull(multisetToModify);
    Preconditions.checkNotNull(occurrencesToRemove);
    boolean changed = false;
    Iterator<? extends Multiset.Entry<?>> entryIterator = multisetToModify.entrySet().iterator();
    while (entryIterator.hasNext()) {
      Multiset.Entry<?> entry = (Multiset.Entry)entryIterator.next();
      int removeCount = occurrencesToRemove.count(entry.getElement());
      if (removeCount >= entry.getCount()) {
        entryIterator.remove();
        changed = true;
        continue;
      } 
      if (removeCount > 0) {
        multisetToModify.remove(entry.getElement(), removeCount);
        changed = true;
      } 
    } 
    return changed;
  }
  
  static boolean equalsImpl(Multiset<?> multiset, @CheckForNull Object object) {
    if (object == multiset)
      return true; 
    if (object instanceof Multiset) {
      Multiset<?> that = (Multiset)object;
      if (multiset.size() != that.size() || multiset.entrySet().size() != that.entrySet().size())
        return false; 
      for (Multiset.Entry<?> entry : that.entrySet()) {
        if (multiset.count(entry.getElement()) != entry.getCount())
          return false; 
      } 
      return true;
    } 
    return false;
  }
  
  static <E> boolean addAllImpl(Multiset<E> self, Collection<? extends E> elements) {
    Preconditions.checkNotNull(self);
    Preconditions.checkNotNull(elements);
    if (elements instanceof Multiset)
      return addAllImpl(self, cast(elements)); 
    if (elements.isEmpty())
      return false; 
    return Iterators.addAll(self, elements.iterator());
  }
  
  private static <E> boolean addAllImpl(Multiset<E> self, Multiset<? extends E> elements) {
    if (elements.isEmpty())
      return false; 
    Objects.requireNonNull(self);
    elements.forEachEntry(self::add);
    return true;
  }
  
  static boolean removeAllImpl(Multiset<?> self, Collection<?> elementsToRemove) {
    Collection<?> collection = (elementsToRemove instanceof Multiset) ? ((Multiset)elementsToRemove).elementSet() : elementsToRemove;
    return self.elementSet().removeAll(collection);
  }
  
  static boolean retainAllImpl(Multiset<?> self, Collection<?> elementsToRetain) {
    Preconditions.checkNotNull(elementsToRetain);
    Collection<?> collection = (elementsToRetain instanceof Multiset) ? ((Multiset)elementsToRetain).elementSet() : elementsToRetain;
    return self.elementSet().retainAll(collection);
  }
  
  static <E> int setCountImpl(Multiset<E> self, @ParametricNullness E element, int count) {
    CollectPreconditions.checkNonnegative(count, "count");
    int oldCount = self.count(element);
    int delta = count - oldCount;
    if (delta > 0) {
      self.add(element, delta);
    } else if (delta < 0) {
      self.remove(element, -delta);
    } 
    return oldCount;
  }
  
  static <E> boolean setCountImpl(Multiset<E> self, @ParametricNullness E element, int oldCount, int newCount) {
    CollectPreconditions.checkNonnegative(oldCount, "oldCount");
    CollectPreconditions.checkNonnegative(newCount, "newCount");
    if (self.count(element) == oldCount) {
      self.setCount(element, newCount);
      return true;
    } 
    return false;
  }
  
  static <E> Iterator<E> elementIterator(Iterator<Multiset.Entry<E>> entryIterator) { return new Object(entryIterator); }
  
  static <E> Iterator<E> iteratorImpl(Multiset<E> multiset) { return new MultisetIteratorImpl(multiset, multiset.entrySet().iterator()); }
  
  static <E> Spliterator<E> spliteratorImpl(Multiset<E> multiset) {
    Spliterator<Multiset.Entry<E>> entrySpliterator = multiset.entrySet().spliterator();
    return CollectSpliterators.flatMap(entrySpliterator, entry -> 
        
        Collections.nCopies(entry.getCount(), entry.getElement()).spliterator(), 0x40 | entrySpliterator
        
        .characteristics() & 0x510, multiset
        
        .size());
  }
  
  static int linearTimeSizeImpl(Multiset<?> multiset) {
    long size = 0L;
    for (Multiset.Entry<?> entry : multiset.entrySet())
      size += entry.getCount(); 
    return Ints.saturatedCast(size);
  }
  
  static <T> Multiset<T> cast(Iterable<T> iterable) { return (Multiset)iterable; }
  
  public static <E> ImmutableMultiset<E> copyHighestCountFirst(Multiset<E> multiset) {
    Entry[] entries = (Entry[])multiset.entrySet().toArray(new Multiset.Entry[0]);
    Arrays.sort(entries, DecreasingCount.INSTANCE);
    return ImmutableMultiset.copyFromEntries(Arrays.asList(entries));
  }
}
