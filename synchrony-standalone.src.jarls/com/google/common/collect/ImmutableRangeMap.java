package com.google.common.collect;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.base.Preconditions;
import com.google.errorprone.annotations.DoNotCall;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.Collector;
import javax.annotation.CheckForNull;

@ElementTypesAreNonnullByDefault
@GwtIncompatible
public class ImmutableRangeMap<K extends Comparable<?>, V> extends Object implements RangeMap<K, V>, Serializable {
  private static final ImmutableRangeMap<Comparable<?>, Object> EMPTY = new ImmutableRangeMap(
      ImmutableList.of(), ImmutableList.of());
  
  private final ImmutableList<Range<K>> ranges;
  
  private final ImmutableList<V> values;
  
  private static final long serialVersionUID = 0L;
  
  public static <T, K extends Comparable<? super K>, V> Collector<T, ?, ImmutableRangeMap<K, V>> toImmutableRangeMap(Function<? super T, Range<K>> keyFunction, Function<? super T, ? extends V> valueFunction) { return CollectCollectors.toImmutableRangeMap(keyFunction, valueFunction); }
  
  public static <K extends Comparable<?>, V> ImmutableRangeMap<K, V> of() { return EMPTY; }
  
  public static <K extends Comparable<?>, V> ImmutableRangeMap<K, V> of(Range<K> range, V value) { return new ImmutableRangeMap(ImmutableList.of(range), ImmutableList.of(value)); }
  
  public static <K extends Comparable<?>, V> ImmutableRangeMap<K, V> copyOf(RangeMap<K, ? extends V> rangeMap) {
    if (rangeMap instanceof ImmutableRangeMap)
      return (ImmutableRangeMap)rangeMap; 
    Map<Range<K>, ? extends V> map = rangeMap.asMapOfRanges();
    ImmutableList.Builder<Range<K>> rangesBuilder = new ImmutableList.Builder<Range<K>>(map.size());
    ImmutableList.Builder<V> valuesBuilder = new ImmutableList.Builder<V>(map.size());
    for (Map.Entry<Range<K>, ? extends V> entry : map.entrySet()) {
      rangesBuilder.add((Range)entry.getKey());
      valuesBuilder.add(entry.getValue());
    } 
    return new ImmutableRangeMap(rangesBuilder.build(), valuesBuilder.build());
  }
  
  public static <K extends Comparable<?>, V> Builder<K, V> builder() { return new Builder(); }
  
  ImmutableRangeMap(ImmutableList<Range<K>> ranges, ImmutableList<V> values) {
    this.ranges = ranges;
    this.values = values;
  }
  
  @CheckForNull
  public V get(K key) {
    int index = SortedLists.binarySearch(this.ranges, 
        
        Range.lowerBoundFn(), 
        Cut.belowValue(key), SortedLists.KeyPresentBehavior.ANY_PRESENT, SortedLists.KeyAbsentBehavior.NEXT_LOWER);
    if (index == -1)
      return null; 
    Range<K> range = (Range)this.ranges.get(index);
    return (V)(range.contains(key) ? this.values.get(index) : null);
  }
  
  @CheckForNull
  public Map.Entry<Range<K>, V> getEntry(K key) {
    int index = SortedLists.binarySearch(this.ranges, 
        
        Range.lowerBoundFn(), 
        Cut.belowValue(key), SortedLists.KeyPresentBehavior.ANY_PRESENT, SortedLists.KeyAbsentBehavior.NEXT_LOWER);
    if (index == -1)
      return null; 
    Range<K> range = (Range)this.ranges.get(index);
    return range.contains(key) ? Maps.immutableEntry(range, this.values.get(index)) : null;
  }
  
  public Range<K> span() {
    if (this.ranges.isEmpty())
      throw new NoSuchElementException(); 
    Range<K> firstRange = (Range)this.ranges.get(0);
    Range<K> lastRange = (Range)this.ranges.get(this.ranges.size() - 1);
    return Range.create(firstRange.lowerBound, lastRange.upperBound);
  }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public final void put(Range<K> range, V value) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public final void putCoalescing(Range<K> range, V value) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public final void putAll(RangeMap<K, ? extends V> rangeMap) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public final void clear() { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public final void remove(Range<K> range) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public final void merge(Range<K> range, @CheckForNull V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) { throw new UnsupportedOperationException(); }
  
  public ImmutableMap<Range<K>, V> asMapOfRanges() {
    if (this.ranges.isEmpty())
      return ImmutableMap.of(); 
    RegularImmutableSortedSet<Range<K>> rangeSet = new RegularImmutableSortedSet<Range<K>>(this.ranges, Range.rangeLexOrdering());
    return new ImmutableSortedMap(rangeSet, this.values);
  }
  
  public ImmutableMap<Range<K>, V> asDescendingMapOfRanges() {
    if (this.ranges.isEmpty())
      return ImmutableMap.of(); 
    RegularImmutableSortedSet<Range<K>> rangeSet = new RegularImmutableSortedSet<Range<K>>(this.ranges.reverse(), Range.rangeLexOrdering().reverse());
    return new ImmutableSortedMap(rangeSet, this.values.reverse());
  }
  
  public ImmutableRangeMap<K, V> subRangeMap(Range<K> range) {
    if (((Range)Preconditions.checkNotNull(range)).isEmpty())
      return of(); 
    if (this.ranges.isEmpty() || range.encloses(span()))
      return this; 
    int lowerIndex = SortedLists.binarySearch(this.ranges, 
        
        Range.upperBoundFn(), range.lowerBound, SortedLists.KeyPresentBehavior.FIRST_AFTER, SortedLists.KeyAbsentBehavior.NEXT_HIGHER);
    int upperIndex = SortedLists.binarySearch(this.ranges, 
        
        Range.lowerBoundFn(), range.upperBound, SortedLists.KeyPresentBehavior.ANY_PRESENT, SortedLists.KeyAbsentBehavior.NEXT_HIGHER);
    if (lowerIndex >= upperIndex)
      return of(); 
    int off = lowerIndex;
    int len = upperIndex - lowerIndex;
    Object object = new Object(this, len, off, range);
    ImmutableRangeMap<K, V> outer = this;
    return new Object(this, object, this.values.subList(lowerIndex, upperIndex), range, outer);
  }
  
  public int hashCode() { return asMapOfRanges().hashCode(); }
  
  public boolean equals(@CheckForNull Object o) {
    if (o instanceof RangeMap) {
      RangeMap<?, ?> rangeMap = (RangeMap)o;
      return asMapOfRanges().equals(rangeMap.asMapOfRanges());
    } 
    return false;
  }
  
  public String toString() { return asMapOfRanges().toString(); }
  
  Object writeReplace() { return new SerializedForm(asMapOfRanges()); }
  
  @J2ktIncompatible
  private void readObject(ObjectInputStream stream) throws InvalidObjectException { throw new InvalidObjectException("Use SerializedForm"); }
}
