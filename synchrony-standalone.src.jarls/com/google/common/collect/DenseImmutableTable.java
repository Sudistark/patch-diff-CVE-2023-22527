package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.errorprone.annotations.Immutable;
import java.util.Map;
import java.util.Objects;
import javax.annotation.CheckForNull;

@Immutable(containerOf = {"R", "C", "V"})
@ElementTypesAreNonnullByDefault
@GwtCompatible
final class DenseImmutableTable<R, C, V> extends RegularImmutableTable<R, C, V> {
  private final ImmutableMap<R, Integer> rowKeyToIndex;
  
  private final ImmutableMap<C, Integer> columnKeyToIndex;
  
  private final ImmutableMap<R, ImmutableMap<C, V>> rowMap;
  
  private final ImmutableMap<C, ImmutableMap<R, V>> columnMap;
  
  private final int[] rowCounts;
  
  private final int[] columnCounts;
  
  private final V[][] values;
  
  private final int[] cellRowIndices;
  
  private final int[] cellColumnIndices;
  
  DenseImmutableTable(ImmutableList<Table.Cell<R, C, V>> cellList, ImmutableSet<R> rowSpace, ImmutableSet<C> columnSpace) {
    V[][] array = (V[][])new Object[rowSpace.size()][columnSpace.size()];
    this.values = array;
    this.rowKeyToIndex = Maps.indexMap(rowSpace);
    this.columnKeyToIndex = Maps.indexMap(columnSpace);
    this.rowCounts = new int[this.rowKeyToIndex.size()];
    this.columnCounts = new int[this.columnKeyToIndex.size()];
    int[] cellRowIndices = new int[cellList.size()];
    int[] cellColumnIndices = new int[cellList.size()];
    for (int i = 0; i < cellList.size(); i++) {
      Table.Cell<R, C, V> cell = (Table.Cell)cellList.get(i);
      R rowKey = (R)cell.getRowKey();
      C columnKey = (C)cell.getColumnKey();
      int rowIndex = ((Integer)Objects.requireNonNull((Integer)this.rowKeyToIndex.get(rowKey))).intValue();
      int columnIndex = ((Integer)Objects.requireNonNull((Integer)this.columnKeyToIndex.get(columnKey))).intValue();
      V existingValue = (V)this.values[rowIndex][columnIndex];
      checkNoDuplicate(rowKey, columnKey, existingValue, cell.getValue());
      this.values[rowIndex][columnIndex] = cell.getValue();
      this.rowCounts[rowIndex] = this.rowCounts[rowIndex] + 1;
      this.columnCounts[columnIndex] = this.columnCounts[columnIndex] + 1;
      cellRowIndices[i] = rowIndex;
      cellColumnIndices[i] = columnIndex;
    } 
    this.cellRowIndices = cellRowIndices;
    this.cellColumnIndices = cellColumnIndices;
    this.rowMap = new RowMap(this, null);
    this.columnMap = new ColumnMap(this, null);
  }
  
  public ImmutableMap<C, Map<R, V>> columnMap() {
    ImmutableMap<C, ImmutableMap<R, V>> columnMap = this.columnMap;
    return ImmutableMap.copyOf(columnMap);
  }
  
  public ImmutableMap<R, Map<C, V>> rowMap() {
    ImmutableMap<R, ImmutableMap<C, V>> rowMap = this.rowMap;
    return ImmutableMap.copyOf(rowMap);
  }
  
  @CheckForNull
  public V get(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
    Integer rowIndex = (Integer)this.rowKeyToIndex.get(rowKey);
    Integer columnIndex = (Integer)this.columnKeyToIndex.get(columnKey);
    return (V)((rowIndex == null || columnIndex == null) ? null : this.values[rowIndex.intValue()][columnIndex.intValue()]);
  }
  
  public int size() { return this.cellRowIndices.length; }
  
  Table.Cell<R, C, V> getCell(int index) {
    int rowIndex = this.cellRowIndices[index];
    int columnIndex = this.cellColumnIndices[index];
    R rowKey = (R)rowKeySet().asList().get(rowIndex);
    C columnKey = (C)columnKeySet().asList().get(columnIndex);
    V value = (V)Objects.requireNonNull(this.values[rowIndex][columnIndex]);
    return cellOf(rowKey, columnKey, value);
  }
  
  V getValue(int index) { return (V)Objects.requireNonNull(this.values[this.cellRowIndices[index]][this.cellColumnIndices[index]]); }
  
  ImmutableTable.SerializedForm createSerializedForm() { return ImmutableTable.SerializedForm.create(this, this.cellRowIndices, this.cellColumnIndices); }
}
