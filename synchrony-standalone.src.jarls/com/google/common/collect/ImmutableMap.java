package com.google.common.collect;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.DoNotCall;
import com.google.errorprone.annotations.DoNotMock;
import com.google.errorprone.annotations.concurrent.LazyInit;
import com.google.j2objc.annotations.RetainedWith;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.util.Collection;
import java.util.EnumMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.Spliterator;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.stream.Collector;
import javax.annotation.CheckForNull;

@DoNotMock("Use ImmutableMap.of or another implementation")
@ElementTypesAreNonnullByDefault
@GwtCompatible(serializable = true, emulated = true)
public abstract class ImmutableMap<K, V> extends Object implements Map<K, V>, Serializable {
  public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(Function<? super T, ? extends K> keyFunction, Function<? super T, ? extends V> valueFunction) { return CollectCollectors.toImmutableMap(keyFunction, valueFunction); }
  
  public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(Function<? super T, ? extends K> keyFunction, Function<? super T, ? extends V> valueFunction, BinaryOperator<V> mergeFunction) { return CollectCollectors.toImmutableMap(keyFunction, valueFunction, mergeFunction); }
  
  public static <K, V> ImmutableMap<K, V> of() { return RegularImmutableMap.EMPTY; }
  
  public static <K, V> ImmutableMap<K, V> of(K k1, V v1) { return ImmutableBiMap.of(k1, v1); }
  
  public static <K, V> ImmutableMap<K, V> of(K k1, V v1, K k2, V v2) { return RegularImmutableMap.fromEntries(new Map.Entry[] { entryOf(k1, v1), entryOf(k2, v2) }); }
  
  public static <K, V> ImmutableMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3) { return RegularImmutableMap.fromEntries(new Map.Entry[] { entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3) }); }
  
  public static <K, V> ImmutableMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
    return RegularImmutableMap.fromEntries(new Map.Entry[] { entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3), entryOf(k4, v4) });
  }
  
  public static <K, V> ImmutableMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
    return RegularImmutableMap.fromEntries(new Map.Entry[] { entryOf(k1, v1), entryOf(k2, v2), entryOf(k3, v3), entryOf(k4, v4), entryOf(k5, v5) });
  }
  
  public static <K, V> ImmutableMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6) {
    return RegularImmutableMap.fromEntries(new Map.Entry[] { entryOf(k1, v1), 
          entryOf(k2, v2), 
          entryOf(k3, v3), 
          entryOf(k4, v4), 
          entryOf(k5, v5), 
          entryOf(k6, v6) });
  }
  
  public static <K, V> ImmutableMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7) {
    return RegularImmutableMap.fromEntries(new Map.Entry[] { entryOf(k1, v1), 
          entryOf(k2, v2), 
          entryOf(k3, v3), 
          entryOf(k4, v4), 
          entryOf(k5, v5), 
          entryOf(k6, v6), 
          entryOf(k7, v7) });
  }
  
  public static <K, V> ImmutableMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8) {
    return RegularImmutableMap.fromEntries(new Map.Entry[] { entryOf(k1, v1), 
          entryOf(k2, v2), 
          entryOf(k3, v3), 
          entryOf(k4, v4), 
          entryOf(k5, v5), 
          entryOf(k6, v6), 
          entryOf(k7, v7), 
          entryOf(k8, v8) });
  }
  
  public static <K, V> ImmutableMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9) {
    return RegularImmutableMap.fromEntries(new Map.Entry[] { entryOf(k1, v1), 
          entryOf(k2, v2), 
          entryOf(k3, v3), 
          entryOf(k4, v4), 
          entryOf(k5, v5), 
          entryOf(k6, v6), 
          entryOf(k7, v7), 
          entryOf(k8, v8), 
          entryOf(k9, v9) });
  }
  
  public static <K, V> ImmutableMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10) {
    return RegularImmutableMap.fromEntries(new Map.Entry[] { entryOf(k1, v1), 
          entryOf(k2, v2), 
          entryOf(k3, v3), 
          entryOf(k4, v4), 
          entryOf(k5, v5), 
          entryOf(k6, v6), 
          entryOf(k7, v7), 
          entryOf(k8, v8), 
          entryOf(k9, v9), 
          entryOf(k10, v10) });
  }
  
  @SafeVarargs
  public static <K, V> ImmutableMap<K, V> ofEntries(Entry... entries) {
    Entry[] entries2 = entries;
    return RegularImmutableMap.fromEntries(entries2);
  }
  
  static <K, V> Map.Entry<K, V> entryOf(K key, V value) { return new ImmutableMapEntry(key, value); }
  
  public static <K, V> Builder<K, V> builder() { return new Builder(); }
  
  public static <K, V> Builder<K, V> builderWithExpectedSize(int expectedSize) {
    CollectPreconditions.checkNonnegative(expectedSize, "expectedSize");
    return new Builder(expectedSize);
  }
  
  static void checkNoConflict(boolean safe, String conflictDescription, Object entry1, Object entry2) {
    if (!safe)
      throw conflictException(conflictDescription, entry1, entry2); 
  }
  
  static IllegalArgumentException conflictException(String conflictDescription, Object entry1, Object entry2) { return new IllegalArgumentException("Multiple entries with same " + conflictDescription + ": " + entry1 + " and " + entry2); }
  
  public static <K, V> ImmutableMap<K, V> copyOf(Map<? extends K, ? extends V> map) {
    if (map instanceof ImmutableMap && !(map instanceof java.util.SortedMap)) {
      ImmutableMap<K, V> kvMap = (ImmutableMap)map;
      if (!kvMap.isPartialView())
        return kvMap; 
    } else if (map instanceof EnumMap) {
      return copyOfEnumMap((EnumMap)map);
    } 
    return copyOf(map.entrySet());
  }
  
  public static <K, V> ImmutableMap<K, V> copyOf(Iterable<? extends Map.Entry<? extends K, ? extends V>> entries) {
    Map.Entry<K, V> onlyEntry;
    Entry[] entryArray = (Entry[])Iterables.toArray(entries, EMPTY_ENTRY_ARRAY);
    switch (entryArray.length) {
      case 0:
        return of();
      case 1:
        onlyEntry = (Map.Entry)Objects.requireNonNull(entryArray[0]);
        return of(onlyEntry.getKey(), onlyEntry.getValue());
    } 
    return RegularImmutableMap.fromEntries(entryArray);
  }
  
  private static <K extends Enum<K>, V> ImmutableMap<K, ? extends V> copyOfEnumMap(EnumMap<?, ? extends V> original) {
    EnumMap<K, V> copy = new EnumMap<K, V>(original);
    for (Map.Entry<K, V> entry : copy.entrySet())
      CollectPreconditions.checkEntryNotNull(entry.getKey(), entry.getValue()); 
    return ImmutableEnumMap.asImmutable(copy);
  }
  
  static final Map.Entry<?, ?>[] EMPTY_ENTRY_ARRAY = new Map.Entry[0];
  
  @LazyInit
  @CheckForNull
  @RetainedWith
  private ImmutableSet<Map.Entry<K, V>> entrySet;
  
  @LazyInit
  @CheckForNull
  @RetainedWith
  private ImmutableSet<K> keySet;
  
  @LazyInit
  @CheckForNull
  @RetainedWith
  private ImmutableCollection<V> values;
  
  @LazyInit
  @CheckForNull
  private ImmutableSetMultimap<K, V> multimapView;
  
  @Deprecated
  @CheckForNull
  @CanIgnoreReturnValue
  @DoNotCall("Always throws UnsupportedOperationException")
  public final V put(K k, V v) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @CheckForNull
  @CanIgnoreReturnValue
  @DoNotCall("Always throws UnsupportedOperationException")
  public final V putIfAbsent(K key, V value) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public final boolean replace(K key, V oldValue, V newValue) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @CheckForNull
  @DoNotCall("Always throws UnsupportedOperationException")
  public final V replace(K key, V value) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public final V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @CheckForNull
  @DoNotCall("Always throws UnsupportedOperationException")
  public final V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @CheckForNull
  @DoNotCall("Always throws UnsupportedOperationException")
  public final V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @CheckForNull
  @DoNotCall("Always throws UnsupportedOperationException")
  public final V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> function) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public final void putAll(Map<? extends K, ? extends V> map) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public final void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @CheckForNull
  @DoNotCall("Always throws UnsupportedOperationException")
  public final V remove(@CheckForNull Object o) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public final boolean remove(@CheckForNull Object key, @CheckForNull Object value) { throw new UnsupportedOperationException(); }
  
  @Deprecated
  @DoNotCall("Always throws UnsupportedOperationException")
  public final void clear() { throw new UnsupportedOperationException(); }
  
  public boolean isEmpty() { return (size() == 0); }
  
  public boolean containsKey(@CheckForNull Object key) { return (get(key) != null); }
  
  public boolean containsValue(@CheckForNull Object value) { return values().contains(value); }
  
  @CheckForNull
  public final V getOrDefault(@CheckForNull Object key, @CheckForNull V defaultValue) {
    V result = (V)get(key);
    if (result != null)
      return result; 
    return defaultValue;
  }
  
  public ImmutableSet<Map.Entry<K, V>> entrySet() {
    ImmutableSet<Map.Entry<K, V>> result = this.entrySet;
    return (result == null) ? (this.entrySet = createEntrySet()) : result;
  }
  
  public ImmutableSet<K> keySet() {
    ImmutableSet<K> result = this.keySet;
    return (result == null) ? (this.keySet = createKeySet()) : result;
  }
  
  UnmodifiableIterator<K> keyIterator() {
    UnmodifiableIterator<Map.Entry<K, V>> entryIterator = entrySet().iterator();
    return new Object(this, entryIterator);
  }
  
  Spliterator<K> keySpliterator() { return CollectSpliterators.map(entrySet().spliterator(), Map.Entry::getKey); }
  
  public ImmutableCollection<V> values() {
    ImmutableCollection<V> result = this.values;
    return (result == null) ? (this.values = createValues()) : result;
  }
  
  public ImmutableSetMultimap<K, V> asMultimap() {
    if (isEmpty())
      return ImmutableSetMultimap.of(); 
    ImmutableSetMultimap<K, V> result = this.multimapView;
    return (result == null) ? (
      this
      .multimapView = new ImmutableSetMultimap(new MapViewOfValuesAsSingletonSets(this, null), size(), null)) : 
      result;
  }
  
  public boolean equals(@CheckForNull Object object) { return Maps.equalsImpl(this, object); }
  
  public int hashCode() { return Sets.hashCodeImpl(entrySet()); }
  
  boolean isHashCodeFast() { return false; }
  
  public String toString() { return Maps.toStringImpl(this); }
  
  @J2ktIncompatible
  Object writeReplace() { return new SerializedForm(this); }
  
  @J2ktIncompatible
  private void readObject(ObjectInputStream stream) throws InvalidObjectException { throw new InvalidObjectException("Use SerializedForm"); }
  
  @CheckForNull
  public abstract V get(@CheckForNull Object paramObject);
  
  abstract ImmutableSet<Map.Entry<K, V>> createEntrySet();
  
  abstract ImmutableSet<K> createKeySet();
  
  abstract ImmutableCollection<V> createValues();
  
  abstract boolean isPartialView();
}
