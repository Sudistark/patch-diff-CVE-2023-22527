package com.google.common.collect;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Equivalence;
import com.google.common.base.Preconditions;
import com.google.common.primitives.Ints;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.errorprone.annotations.concurrent.LazyInit;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicReferenceArray;
import javax.annotation.CheckForNull;

@J2ktIncompatible
@GwtIncompatible
class MapMakerInternalMap<K, V, E extends MapMakerInternalMap.InternalEntry<K, V, E>, S extends MapMakerInternalMap.Segment<K, V, E, S>> extends AbstractMap<K, V> implements ConcurrentMap<K, V>, Serializable {
  static final int MAXIMUM_CAPACITY = 1073741824;
  
  static final int MAX_SEGMENTS = 65536;
  
  static final int CONTAINS_VALUE_RETRIES = 3;
  
  static final int DRAIN_THRESHOLD = 63;
  
  static final int DRAIN_MAX = 16;
  
  final int segmentMask;
  
  final int segmentShift;
  
  final Segment<K, V, E, S>[] segments;
  
  final int concurrencyLevel;
  
  final Equivalence<Object> keyEquivalence;
  
  final InternalEntryHelper<K, V, E, S> entryHelper;
  
  private MapMakerInternalMap(MapMaker builder, InternalEntryHelper<K, V, E, S> entryHelper) {
    this.concurrencyLevel = Math.min(builder.getConcurrencyLevel(), 65536);
    this.keyEquivalence = builder.getKeyEquivalence();
    this.entryHelper = entryHelper;
    int initialCapacity = Math.min(builder.getInitialCapacity(), 1073741824);
    int segmentShift = 0;
    int segmentCount = 1;
    while (segmentCount < this.concurrencyLevel) {
      segmentShift++;
      segmentCount <<= 1;
    } 
    this.segmentShift = 32 - segmentShift;
    this.segmentMask = segmentCount - 1;
    this.segments = newSegmentArray(segmentCount);
    int segmentCapacity = initialCapacity / segmentCount;
    if (segmentCapacity * segmentCount < initialCapacity)
      segmentCapacity++; 
    int segmentSize = 1;
    while (segmentSize < segmentCapacity)
      segmentSize <<= 1; 
    for (int i = 0; i < this.segments.length; i++)
      this.segments[i] = createSegment(segmentSize); 
  }
  
  static <K, V> MapMakerInternalMap<K, V, ? extends InternalEntry<K, V, ?>, ?> create(MapMaker builder) {
    if (builder.getKeyStrength() == Strength.STRONG && builder
      .getValueStrength() == Strength.STRONG)
      return new MapMakerInternalMap(builder, StrongKeyStrongValueEntry.Helper.instance()); 
    if (builder.getKeyStrength() == Strength.STRONG && builder
      .getValueStrength() == Strength.WEAK)
      return new MapMakerInternalMap(builder, StrongKeyWeakValueEntry.Helper.instance()); 
    if (builder.getKeyStrength() == Strength.WEAK && builder
      .getValueStrength() == Strength.STRONG)
      return new MapMakerInternalMap(builder, WeakKeyStrongValueEntry.Helper.instance()); 
    if (builder.getKeyStrength() == Strength.WEAK && builder.getValueStrength() == Strength.WEAK)
      return new MapMakerInternalMap(builder, WeakKeyWeakValueEntry.Helper.instance()); 
    throw new AssertionError();
  }
  
  static <K> MapMakerInternalMap<K, MapMaker.Dummy, ? extends InternalEntry<K, MapMaker.Dummy, ?>, ?> createWithDummyValues(MapMaker builder) {
    if (builder.getKeyStrength() == Strength.STRONG && builder
      .getValueStrength() == Strength.STRONG)
      return new MapMakerInternalMap(builder, StrongKeyDummyValueEntry.Helper.instance()); 
    if (builder.getKeyStrength() == Strength.WEAK && builder
      .getValueStrength() == Strength.STRONG)
      return new MapMakerInternalMap(builder, WeakKeyDummyValueEntry.Helper.instance()); 
    if (builder.getValueStrength() == Strength.WEAK)
      throw new IllegalArgumentException("Map cannot have both weak and dummy values"); 
    throw new AssertionError();
  }
  
  static <K, V, E extends InternalEntry<K, V, E>> WeakValueReference<K, V, E> unsetWeakValueReference() { return UNSET_WEAK_VALUE_REFERENCE; }
  
  static final WeakValueReference<Object, Object, DummyInternalEntry> UNSET_WEAK_VALUE_REFERENCE = new Object();
  
  @LazyInit
  @CheckForNull
  Set<K> keySet;
  
  @LazyInit
  @CheckForNull
  Collection<V> values;
  
  @LazyInit
  @CheckForNull
  Set<Map.Entry<K, V>> entrySet;
  
  private static final long serialVersionUID = 5L;
  
  static int rehash(int h) {
    h += (h << 15 ^ 0xFFFFCD7D);
    h ^= h >>> 10;
    h += (h << 3);
    h ^= h >>> 6;
    h += (h << 2) + (h << 14);
    return h ^ h >>> 16;
  }
  
  @VisibleForTesting
  E copyEntry(E original, E newNext) {
    int hash = original.getHash();
    return (E)segmentFor(hash).copyEntry(original, newNext);
  }
  
  int hash(Object key) {
    int h = this.keyEquivalence.hash(key);
    return rehash(h);
  }
  
  void reclaimValue(WeakValueReference<K, V, E> valueReference) {
    E entry = (E)valueReference.getEntry();
    int hash = entry.getHash();
    segmentFor(hash).reclaimValue(entry.getKey(), hash, valueReference);
  }
  
  void reclaimKey(E entry) {
    int hash = entry.getHash();
    segmentFor(hash).reclaimKey(entry, hash);
  }
  
  @VisibleForTesting
  boolean isLiveForTesting(InternalEntry<K, V, ?> entry) { return (segmentFor(entry.getHash()).getLiveValueForTesting(entry) != null); }
  
  Segment<K, V, E, S> segmentFor(int hash) { return this.segments[hash >>> this.segmentShift & this.segmentMask]; }
  
  Segment<K, V, E, S> createSegment(int initialCapacity) { return this.entryHelper.newSegment(this, initialCapacity); }
  
  @CheckForNull
  V getLiveValue(E entry) {
    if (entry.getKey() == null)
      return null; 
    return (V)entry.getValue();
  }
  
  final Segment<K, V, E, S>[] newSegmentArray(int ssize) { return new Segment[ssize]; }
  
  @VisibleForTesting
  Strength keyStrength() { return this.entryHelper.keyStrength(); }
  
  @VisibleForTesting
  Strength valueStrength() { return this.entryHelper.valueStrength(); }
  
  @VisibleForTesting
  Equivalence<Object> valueEquivalence() { return this.entryHelper.valueStrength().defaultEquivalence(); }
  
  public boolean isEmpty() {
    long sum = 0L;
    Segment[] arrayOfSegment = this.segments;
    for (int i = 0; i < arrayOfSegment.length; i++) {
      if ((arrayOfSegment[i]).count != 0)
        return false; 
      sum += (arrayOfSegment[i]).modCount;
    } 
    if (sum != 0L) {
      for (int i = 0; i < arrayOfSegment.length; i++) {
        if ((arrayOfSegment[i]).count != 0)
          return false; 
        sum -= (arrayOfSegment[i]).modCount;
      } 
      return (sum == 0L);
    } 
    return true;
  }
  
  public int size() {
    Segment[] arrayOfSegment = this.segments;
    long sum = 0L;
    for (int i = 0; i < arrayOfSegment.length; i++)
      sum += (arrayOfSegment[i]).count; 
    return Ints.saturatedCast(sum);
  }
  
  @CheckForNull
  public V get(@CheckForNull Object key) {
    if (key == null)
      return null; 
    int hash = hash(key);
    return (V)segmentFor(hash).get(key, hash);
  }
  
  @CheckForNull
  E getEntry(@CheckForNull Object key) {
    if (key == null)
      return null; 
    int hash = hash(key);
    return (E)segmentFor(hash).getEntry(key, hash);
  }
  
  public boolean containsKey(@CheckForNull Object key) {
    if (key == null)
      return false; 
    int hash = hash(key);
    return segmentFor(hash).containsKey(key, hash);
  }
  
  public boolean containsValue(@CheckForNull Object value) {
    if (value == null)
      return false; 
    Segment[] arrayOfSegment = this.segments;
    long last = -1L;
    for (int i = 0; i < 3; i++) {
      long sum = 0L;
      for (Segment<K, V, E, S> segment : arrayOfSegment) {
        int unused = segment.count;
        AtomicReferenceArray<E> table = segment.table;
        for (int j = 0; j < table.length(); j++) {
          for (E e = (E)(InternalEntry)table.get(j); e != null; e = (E)e.getNext()) {
            V v = (V)segment.getLiveValue(e);
            if (v != null && valueEquivalence().equivalent(value, v))
              return true; 
          } 
        } 
        sum += segment.modCount;
      } 
      if (sum == last)
        break; 
      last = sum;
    } 
    return false;
  }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V put(K key, V value) {
    Preconditions.checkNotNull(key);
    Preconditions.checkNotNull(value);
    int hash = hash(key);
    return (V)segmentFor(hash).put(key, hash, value, false);
  }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V putIfAbsent(K key, V value) {
    Preconditions.checkNotNull(key);
    Preconditions.checkNotNull(value);
    int hash = hash(key);
    return (V)segmentFor(hash).put(key, hash, value, true);
  }
  
  public void putAll(Map<? extends K, ? extends V> m) {
    for (Map.Entry<? extends K, ? extends V> e : m.entrySet())
      put(e.getKey(), e.getValue()); 
  }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V remove(@CheckForNull Object key) {
    if (key == null)
      return null; 
    int hash = hash(key);
    return (V)segmentFor(hash).remove(key, hash);
  }
  
  @CanIgnoreReturnValue
  public boolean remove(@CheckForNull Object key, @CheckForNull Object value) {
    if (key == null || value == null)
      return false; 
    int hash = hash(key);
    return segmentFor(hash).remove(key, hash, value);
  }
  
  @CanIgnoreReturnValue
  public boolean replace(K key, @CheckForNull V oldValue, V newValue) {
    Preconditions.checkNotNull(key);
    Preconditions.checkNotNull(newValue);
    if (oldValue == null)
      return false; 
    int hash = hash(key);
    return segmentFor(hash).replace(key, hash, oldValue, newValue);
  }
  
  @CheckForNull
  @CanIgnoreReturnValue
  public V replace(K key, V value) {
    Preconditions.checkNotNull(key);
    Preconditions.checkNotNull(value);
    int hash = hash(key);
    return (V)segmentFor(hash).replace(key, hash, value);
  }
  
  public void clear() {
    for (Segment<K, V, E, S> segment : this.segments)
      segment.clear(); 
  }
  
  public Set<K> keySet() {
    Set<K> ks = this.keySet;
    return (ks != null) ? ks : (this.keySet = new KeySet(this));
  }
  
  public Collection<V> values() {
    Collection<V> vs = this.values;
    return (vs != null) ? vs : (this.values = new Values(this));
  }
  
  public Set<Map.Entry<K, V>> entrySet() {
    Set<Map.Entry<K, V>> es = this.entrySet;
    return (es != null) ? es : (this.entrySet = new EntrySet(this));
  }
  
  private static <E> ArrayList<E> toArrayList(Collection<E> c) {
    ArrayList<E> result = new ArrayList<E>(c.size());
    Iterators.addAll(result, c.iterator());
    return result;
  }
  
  Object writeReplace() {
    return new SerializationProxy(this.entryHelper
        .keyStrength(), this.entryHelper
        .valueStrength(), this.keyEquivalence, this.entryHelper
        
        .valueStrength().defaultEquivalence(), this.concurrencyLevel, this);
  }
  
  @J2ktIncompatible
  private void readObject(ObjectInputStream in) throws InvalidObjectException { throw new InvalidObjectException("Use SerializationProxy"); }
}
