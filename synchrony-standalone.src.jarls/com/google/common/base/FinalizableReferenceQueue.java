package com.google.common.base;

import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import java.io.Closeable;
import java.lang.ref.PhantomReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.reflect.Method;
import java.util.logging.Level;
import java.util.logging.Logger;

@ElementTypesAreNonnullByDefault
@J2ktIncompatible
@GwtIncompatible
public class FinalizableReferenceQueue implements Closeable {
  private static final Logger logger = Logger.getLogger(FinalizableReferenceQueue.class.getName());
  
  private static final String FINALIZER_CLASS_NAME = "com.google.common.base.internal.Finalizer";
  
  private static final Method startFinalizer;
  
  static  {
    finalizer = loadFinalizer(new FinalizerLoader[] { new SystemLoader(), new DecoupledLoader(), new DirectLoader() });
    startFinalizer = getStartFinalizer(finalizer);
  }
  
  final ReferenceQueue<Object> queue = new ReferenceQueue();
  
  final PhantomReference<Object> frqRef = new PhantomReference(this, this.queue);
  
  final boolean threadStarted;
  
  public FinalizableReferenceQueue() {
    boolean threadStarted = false;
    try {
      startFinalizer.invoke(null, new Object[] { FinalizableReference.class, this.queue, this.frqRef });
      threadStarted = true;
    } catch (IllegalAccessException impossible) {
      throw new AssertionError(impossible);
    } catch (Throwable t) {
      logger.log(Level.INFO, "Failed to start reference finalizer thread. Reference cleanup will only occur when new references are created.", t);
    } 
    this.threadStarted = threadStarted;
  }
  
  public void close() {
    this.frqRef.enqueue();
    cleanUp();
  }
  
  void cleanUp() {
    if (this.threadStarted)
      return; 
    Reference<?> reference;
    while ((reference = this.queue.poll()) != null) {
      reference.clear();
      try {
        ((FinalizableReference)reference).finalizeReferent();
      } catch (Throwable t) {
        logger.log(Level.SEVERE, "Error cleaning up after reference.", t);
      } 
    } 
  }
  
  private static Class<?> loadFinalizer(FinalizerLoader... loaders) {
    for (FinalizerLoader loader : loaders) {
      Class<?> finalizer = loader.loadFinalizer();
      if (finalizer != null)
        return finalizer; 
    } 
    throw new AssertionError();
  }
  
  static Method getStartFinalizer(Class<?> finalizer) {
    try {
      return finalizer.getMethod("startFinalizer", new Class[] { Class.class, ReferenceQueue.class, PhantomReference.class });
    } catch (NoSuchMethodException e) {
      throw new AssertionError(e);
    } 
  }
}
