package com.google.common.base;

import com.google.common.annotations.GwtCompatible;
import com.google.common.annotations.GwtIncompatible;
import com.google.common.annotations.J2ktIncompatible;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

@ElementTypesAreNonnullByDefault
@GwtCompatible(emulated = true)
public final class Splitter {
  private final CharMatcher trimmer;
  
  private final boolean omitEmptyStrings;
  
  private final Strategy strategy;
  
  private final int limit;
  
  private Splitter(Strategy strategy) { this(strategy, false, CharMatcher.none(), 2147483647); }
  
  private Splitter(Strategy strategy, boolean omitEmptyStrings, CharMatcher trimmer, int limit) {
    this.strategy = strategy;
    this.omitEmptyStrings = omitEmptyStrings;
    this.trimmer = trimmer;
    this.limit = limit;
  }
  
  public static Splitter on(char separator) { return on(CharMatcher.is(separator)); }
  
  public static Splitter on(CharMatcher separatorMatcher) {
    Preconditions.checkNotNull(separatorMatcher);
    return new Splitter(new Object(separatorMatcher));
  }
  
  public static Splitter on(String separator) {
    Preconditions.checkArgument((separator.length() != 0), "The separator may not be the empty string.");
    if (separator.length() == 1)
      return on(separator.charAt(0)); 
    return new Splitter(new Object(separator));
  }
  
  @J2ktIncompatible
  @GwtIncompatible
  public static Splitter on(Pattern separatorPattern) { return onPatternInternal(new JdkPattern(separatorPattern)); }
  
  static Splitter onPatternInternal(CommonPattern separatorPattern) {
    Preconditions.checkArgument(
        !separatorPattern.matcher("").matches(), "The pattern may not match the empty string: %s", separatorPattern);
    return new Splitter(new Object(separatorPattern));
  }
  
  @J2ktIncompatible
  @GwtIncompatible
  public static Splitter onPattern(String separatorPattern) { return onPatternInternal(Platform.compilePattern(separatorPattern)); }
  
  public static Splitter fixedLength(int length) {
    Preconditions.checkArgument((length > 0), "The length may not be less than 1");
    return new Splitter(new Object(length));
  }
  
  public Splitter omitEmptyStrings() { return new Splitter(this.strategy, true, this.trimmer, this.limit); }
  
  public Splitter limit(int maxItems) {
    Preconditions.checkArgument((maxItems > 0), "must be greater than zero: %s", maxItems);
    return new Splitter(this.strategy, this.omitEmptyStrings, this.trimmer, maxItems);
  }
  
  public Splitter trimResults() { return trimResults(CharMatcher.whitespace()); }
  
  public Splitter trimResults(CharMatcher trimmer) {
    Preconditions.checkNotNull(trimmer);
    return new Splitter(this.strategy, this.omitEmptyStrings, trimmer, this.limit);
  }
  
  public Iterable<String> split(CharSequence sequence) {
    Preconditions.checkNotNull(sequence);
    return new Object(this, sequence);
  }
  
  private Iterator<String> splittingIterator(CharSequence sequence) { return this.strategy.iterator(this, sequence); }
  
  public List<String> splitToList(CharSequence sequence) {
    Preconditions.checkNotNull(sequence);
    Iterator<String> iterator = splittingIterator(sequence);
    List<String> result = new ArrayList<String>();
    while (iterator.hasNext())
      result.add((String)iterator.next()); 
    return Collections.unmodifiableList(result);
  }
  
  public Stream<String> splitToStream(CharSequence sequence) { return StreamSupport.stream(split(sequence).spliterator(), false); }
  
  public MapSplitter withKeyValueSeparator(String separator) { return withKeyValueSeparator(on(separator)); }
  
  public MapSplitter withKeyValueSeparator(char separator) { return withKeyValueSeparator(on(separator)); }
  
  public MapSplitter withKeyValueSeparator(Splitter keyValueSplitter) { return new MapSplitter(this, keyValueSplitter, null); }
}
