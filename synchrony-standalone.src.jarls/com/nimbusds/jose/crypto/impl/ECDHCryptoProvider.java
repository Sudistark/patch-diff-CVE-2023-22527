package com.nimbusds.jose.crypto.impl;

import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWECryptoParts;
import com.nimbusds.jose.JWEHeader;
import com.nimbusds.jose.jca.JWEJCAContext;
import com.nimbusds.jose.jwk.Curve;
import com.nimbusds.jose.util.Base64URL;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.Set;
import javax.crypto.SecretKey;

public abstract class ECDHCryptoProvider extends BaseJWEProvider {
  public static final Set<JWEAlgorithm> SUPPORTED_ALGORITHMS;
  
  public static final Set<EncryptionMethod> SUPPORTED_ENCRYPTION_METHODS = ContentCryptoProvider.SUPPORTED_ENCRYPTION_METHODS;
  
  private final Curve curve;
  
  private final ConcatKDF concatKDF;
  
  static  {
    algs = new LinkedHashSet();
    algs.add(JWEAlgorithm.ECDH_ES);
    algs.add(JWEAlgorithm.ECDH_ES_A128KW);
    algs.add(JWEAlgorithm.ECDH_ES_A192KW);
    algs.add(JWEAlgorithm.ECDH_ES_A256KW);
    SUPPORTED_ALGORITHMS = Collections.unmodifiableSet(algs);
  }
  
  protected ECDHCryptoProvider(Curve curve) throws JOSEException {
    super(SUPPORTED_ALGORITHMS, ContentCryptoProvider.SUPPORTED_ENCRYPTION_METHODS);
    Curve definedCurve = (curve != null) ? curve : new Curve("unknown");
    if (!supportedEllipticCurves().contains(curve))
      throw new JOSEException(AlgorithmSupportMessage.unsupportedEllipticCurve(definedCurve, 
            supportedEllipticCurves())); 
    this.curve = curve;
    this.concatKDF = new ConcatKDF("SHA-256");
  }
  
  protected ConcatKDF getConcatKDF() { return this.concatKDF; }
  
  public Curve getCurve() { return this.curve; }
  
  protected JWECryptoParts encryptWithZ(JWEHeader header, SecretKey Z, byte[] clearText) throws JOSEException { return encryptWithZ(header, Z, clearText, null); }
  
  protected JWECryptoParts encryptWithZ(JWEHeader header, SecretKey Z, byte[] clearText, SecretKey contentEncryptionKey) throws JOSEException {
    Base64URL encryptedKey;
    SecretKey cek;
    JWEAlgorithm alg = header.getAlgorithm();
    ECDH.AlgorithmMode algMode = ECDH.resolveAlgorithmMode(alg);
    EncryptionMethod enc = header.getEncryptionMethod();
    getConcatKDF().getJCAContext().setProvider(getJCAContext().getMACProvider());
    SecretKey sharedKey = ECDH.deriveSharedKey(header, Z, getConcatKDF());
    if (algMode.equals(ECDH.AlgorithmMode.DIRECT)) {
      cek = sharedKey;
      encryptedKey = null;
    } else if (algMode.equals(ECDH.AlgorithmMode.KW)) {
      if (contentEncryptionKey != null) {
        cek = contentEncryptionKey;
      } else {
        cek = ContentCryptoProvider.generateCEK(enc, getJCAContext().getSecureRandom());
      } 
      encryptedKey = Base64URL.encode(AESKW.wrapCEK(cek, sharedKey, getJCAContext().getKeyEncryptionProvider()));
    } else {
      throw new JOSEException("Unexpected JWE ECDH algorithm mode: " + algMode);
    } 
    return ContentCryptoProvider.encrypt(header, clearText, cek, encryptedKey, getJCAContext());
  }
  
  protected byte[] decryptWithZ(JWEHeader header, SecretKey Z, Base64URL encryptedKey, Base64URL iv, Base64URL cipherText, Base64URL authTag) throws JOSEException {
    SecretKey cek;
    JWEAlgorithm alg = header.getAlgorithm();
    ECDH.AlgorithmMode algMode = ECDH.resolveAlgorithmMode(alg);
    getConcatKDF().getJCAContext().setProvider(getJCAContext().getMACProvider());
    SecretKey sharedKey = ECDH.deriveSharedKey(header, Z, getConcatKDF());
    if (algMode.equals(ECDH.AlgorithmMode.DIRECT)) {
      cek = sharedKey;
    } else if (algMode.equals(ECDH.AlgorithmMode.KW)) {
      if (encryptedKey == null)
        throw new JOSEException("Missing JWE encrypted key"); 
      cek = AESKW.unwrapCEK(sharedKey, encryptedKey.decode(), getJCAContext().getKeyEncryptionProvider());
    } else {
      throw new JOSEException("Unexpected JWE ECDH algorithm mode: " + algMode);
    } 
    return ContentCryptoProvider.decrypt(header, encryptedKey, iv, cipherText, authTag, cek, getJCAContext());
  }
  
  public abstract Set<Curve> supportedEllipticCurves();
}
