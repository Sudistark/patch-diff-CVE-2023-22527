package com.nimbusds.jose.jwk;

import com.nimbusds.jose.Algorithm;
import com.nimbusds.jose.JWEHeader;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.JWSHeader;
import com.nimbusds.jose.util.Base64URL;
import java.util.Set;
import net.jcip.annotations.Immutable;

@Immutable
public class JWKMatcher {
  private final Set<KeyType> types;
  
  private final Set<KeyUse> uses;
  
  private final Set<KeyOperation> ops;
  
  private final Set<Algorithm> algs;
  
  private final Set<String> ids;
  
  private final boolean hasUse;
  
  private final boolean hasID;
  
  private final boolean privateOnly;
  
  private final boolean publicOnly;
  
  private final int minSizeBits;
  
  private final int maxSizeBits;
  
  private final Set<Integer> sizesBits;
  
  private final Set<Curve> curves;
  
  private final Set<Base64URL> x5tS256s;
  
  @Deprecated
  public JWKMatcher(Set<KeyType> types, Set<KeyUse> uses, Set<KeyOperation> ops, Set<Algorithm> algs, Set<String> ids, boolean privateOnly, boolean publicOnly) { this(types, uses, ops, algs, ids, privateOnly, publicOnly, 0, 0); }
  
  @Deprecated
  public JWKMatcher(Set<KeyType> types, Set<KeyUse> uses, Set<KeyOperation> ops, Set<Algorithm> algs, Set<String> ids, boolean privateOnly, boolean publicOnly, int minSizeBits, int maxSizeBits) { this(types, uses, ops, algs, ids, privateOnly, publicOnly, minSizeBits, maxSizeBits, null); }
  
  @Deprecated
  public JWKMatcher(Set<KeyType> types, Set<KeyUse> uses, Set<KeyOperation> ops, Set<Algorithm> algs, Set<String> ids, boolean privateOnly, boolean publicOnly, int minSizeBits, int maxSizeBits, Set<Curve> curves) { this(types, uses, ops, algs, ids, privateOnly, publicOnly, minSizeBits, maxSizeBits, null, curves); }
  
  @Deprecated
  public JWKMatcher(Set<KeyType> types, Set<KeyUse> uses, Set<KeyOperation> ops, Set<Algorithm> algs, Set<String> ids, boolean privateOnly, boolean publicOnly, int minSizeBits, int maxSizeBits, Set<Integer> sizesBits, Set<Curve> curves) { this(types, uses, ops, algs, ids, false, false, privateOnly, publicOnly, minSizeBits, maxSizeBits, sizesBits, curves); }
  
  @Deprecated
  public JWKMatcher(Set<KeyType> types, Set<KeyUse> uses, Set<KeyOperation> ops, Set<Algorithm> algs, Set<String> ids, boolean hasUse, boolean hasID, boolean privateOnly, boolean publicOnly, int minSizeBits, int maxSizeBits, Set<Integer> sizesBits, Set<Curve> curves) { this(types, uses, ops, algs, ids, hasUse, hasID, privateOnly, publicOnly, minSizeBits, maxSizeBits, sizesBits, curves, null); }
  
  public JWKMatcher(Set<KeyType> types, Set<KeyUse> uses, Set<KeyOperation> ops, Set<Algorithm> algs, Set<String> ids, boolean hasUse, boolean hasID, boolean privateOnly, boolean publicOnly, int minSizeBits, int maxSizeBits, Set<Integer> sizesBits, Set<Curve> curves, Set<Base64URL> x5tS256s) {
    this.types = types;
    this.uses = uses;
    this.ops = ops;
    this.algs = algs;
    this.ids = ids;
    this.hasUse = hasUse;
    this.hasID = hasID;
    this.privateOnly = privateOnly;
    this.publicOnly = publicOnly;
    this.minSizeBits = minSizeBits;
    this.maxSizeBits = maxSizeBits;
    this.sizesBits = sizesBits;
    this.curves = curves;
    this.x5tS256s = x5tS256s;
  }
  
  public static JWKMatcher forJWEHeader(JWEHeader jweHeader) { return (new Builder())
      .keyType(KeyType.forAlgorithm(jweHeader.getAlgorithm()))
      .keyID(jweHeader.getKeyID())
      .keyUses(new KeyUse[] { KeyUse.ENCRYPTION, null }).algorithms(new Algorithm[] { jweHeader.getAlgorithm(), null }).build(); }
  
  public static JWKMatcher forJWSHeader(JWSHeader jwsHeader) {
    JWSAlgorithm algorithm = jwsHeader.getAlgorithm();
    if (JWSAlgorithm.Family.RSA.contains(algorithm) || JWSAlgorithm.Family.EC.contains(algorithm))
      return (new Builder())
        .keyType(KeyType.forAlgorithm(algorithm))
        .keyID(jwsHeader.getKeyID())
        .keyUses(new KeyUse[] { KeyUse.SIGNATURE, null }).algorithms(new Algorithm[] { algorithm, null }).x509CertSHA256Thumbprint(jwsHeader.getX509CertSHA256Thumbprint())
        .build(); 
    if (JWSAlgorithm.Family.HMAC_SHA.contains(algorithm))
      return (new Builder())
        .keyType(KeyType.forAlgorithm(algorithm))
        .keyID(jwsHeader.getKeyID())
        .privateOnly(true)
        .algorithms(new Algorithm[] { algorithm, null }).build(); 
    if (JWSAlgorithm.Family.ED.contains(algorithm))
      return (new Builder())
        .keyType(KeyType.forAlgorithm(algorithm))
        .keyID(jwsHeader.getKeyID())
        .keyUses(new KeyUse[] { KeyUse.SIGNATURE, null }).algorithms(new Algorithm[] { algorithm, null }).curves(Curve.forJWSAlgorithm(algorithm))
        .build(); 
    return null;
  }
  
  public Set<KeyType> getKeyTypes() { return this.types; }
  
  public Set<KeyUse> getKeyUses() { return this.uses; }
  
  public Set<KeyOperation> getKeyOperations() { return this.ops; }
  
  public Set<Algorithm> getAlgorithms() { return this.algs; }
  
  public Set<String> getKeyIDs() { return this.ids; }
  
  public boolean hasKeyUse() { return this.hasUse; }
  
  public boolean hasKeyID() { return this.hasID; }
  
  public boolean isPrivateOnly() { return this.privateOnly; }
  
  public boolean isPublicOnly() { return this.publicOnly; }
  
  @Deprecated
  public int getMinSize() { return getMinKeySize(); }
  
  public int getMinKeySize() { return this.minSizeBits; }
  
  @Deprecated
  public int getMaxSize() { return getMaxKeySize(); }
  
  public int getMaxKeySize() { return this.maxSizeBits; }
  
  public Set<Integer> getKeySizes() { return this.sizesBits; }
  
  public Set<Curve> getCurves() { return this.curves; }
  
  public Set<Base64URL> getX509CertSHA256Thumbprints() { return this.x5tS256s; }
  
  public boolean matches(JWK key) {
    if (this.hasUse && key.getKeyUse() == null)
      return false; 
    if (this.hasID && (key.getKeyID() == null || key.getKeyID().trim().isEmpty()))
      return false; 
    if (this.privateOnly && !key.isPrivate())
      return false; 
    if (this.publicOnly && key.isPrivate())
      return false; 
    if (this.types != null && !this.types.contains(key.getKeyType()))
      return false; 
    if (this.uses != null && !this.uses.contains(key.getKeyUse()))
      return false; 
    if (this.ops != null)
      if (!this.ops.contains(null) || key.getKeyOperations() != null)
        if (key.getKeyOperations() == null || !this.ops.containsAll(key.getKeyOperations()))
          return false;   
    if (this.algs != null && !this.algs.contains(key.getAlgorithm()))
      return false; 
    if (this.ids != null && !this.ids.contains(key.getKeyID()))
      return false; 
    if (this.minSizeBits > 0)
      if (key.size() < this.minSizeBits)
        return false;  
    if (this.maxSizeBits > 0)
      if (key.size() > this.maxSizeBits)
        return false;  
    if (this.sizesBits != null && 
      !this.sizesBits.contains(Integer.valueOf(key.size())))
      return false; 
    if (this.curves != null) {
      if (!(key instanceof CurveBasedJWK))
        return false; 
      CurveBasedJWK curveBasedJWK = (CurveBasedJWK)key;
      if (!this.curves.contains(curveBasedJWK.getCurve()))
        return false; 
    } 
    if (this.x5tS256s != null && 
      !this.x5tS256s.contains(key.getX509CertSHA256Thumbprint()))
      return false; 
    return true;
  }
  
  public String toString() {
    StringBuilder sb = new StringBuilder();
    append(sb, "kty", this.types);
    append(sb, "use", this.uses);
    append(sb, "key_ops", this.ops);
    append(sb, "alg", this.algs);
    append(sb, "kid", this.ids);
    if (this.hasUse)
      sb.append("has_use=true "); 
    if (this.hasID)
      sb.append("has_id=true "); 
    if (this.privateOnly)
      sb.append("private_only=true "); 
    if (this.publicOnly)
      sb.append("public_only=true "); 
    if (this.minSizeBits > 0)
      sb.append("min_size=" + this.minSizeBits + " "); 
    if (this.maxSizeBits > 0)
      sb.append("max_size=" + this.maxSizeBits + " "); 
    append(sb, "size", this.sizesBits);
    append(sb, "crv", this.curves);
    append(sb, "x5t#S256", this.x5tS256s);
    return sb.toString().trim();
  }
  
  private static void append(StringBuilder sb, String key, Set<?> values) {
    if (values != null) {
      sb.append(key);
      sb.append('=');
      if (values.size() == 1) {
        Object value = values.iterator().next();
        if (value == null) {
          sb.append("ANY");
        } else {
          sb.append(value.toString().trim());
        } 
      } else {
        sb.append(values.toString().trim());
      } 
      sb.append(' ');
    } 
  }
}
