package com.nimbusds.jose.jwk;

import com.nimbusds.jose.Algorithm;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.util.Base64;
import com.nimbusds.jose.util.Base64URL;
import com.nimbusds.jose.util.ByteUtils;
import com.nimbusds.jose.util.IntegerOverflowException;
import com.nimbusds.jose.util.JSONObjectUtils;
import java.net.URI;
import java.security.GeneralSecurityException;
import java.security.Key;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.UnrecoverableKeyException;
import java.text.ParseException;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import net.jcip.annotations.Immutable;
import net.minidev.json.JSONObject;

@Immutable
public final class OctetSequenceKey extends JWK implements SecretJWK {
  private static final long serialVersionUID = 1L;
  
  private final Base64URL k;
  
  public OctetSequenceKey(Base64URL k, KeyUse use, Set<KeyOperation> ops, Algorithm alg, String kid, URI x5u, Base64URL x5t, Base64URL x5t256, List<Base64> x5c, KeyStore ks) {
    super(KeyType.OCT, use, ops, alg, kid, x5u, x5t, x5t256, x5c, ks);
    if (k == null)
      throw new IllegalArgumentException("The key value must not be null"); 
    this.k = k;
  }
  
  public Base64URL getKeyValue() { return this.k; }
  
  public byte[] toByteArray() { return getKeyValue().decode(); }
  
  public SecretKey toSecretKey() { return toSecretKey("NONE"); }
  
  public SecretKey toSecretKey(String jcaAlg) { return new SecretKeySpec(toByteArray(), jcaAlg); }
  
  public LinkedHashMap<String, ?> getRequiredParams() {
    LinkedHashMap<String, String> requiredParams = new LinkedHashMap<String, String>();
    requiredParams.put("k", this.k.toString());
    requiredParams.put("kty", getKeyType().toString());
    return requiredParams;
  }
  
  public boolean isPrivate() { return true; }
  
  public OctetSequenceKey toPublicJWK() { return null; }
  
  public int size() {
    try {
      return ByteUtils.safeBitLength(this.k.decode());
    } catch (IntegerOverflowException e) {
      throw new ArithmeticException(e.getMessage());
    } 
  }
  
  public JSONObject toJSONObject() {
    JSONObject o = super.toJSONObject();
    o.put("k", this.k.toString());
    return o;
  }
  
  public static OctetSequenceKey parse(String s) throws ParseException { return parse(JSONObjectUtils.parse(s)); }
  
  public static OctetSequenceKey parse(JSONObject jsonObject) throws ParseException {
    if (!KeyType.OCT.equals(JWKMetadata.parseKeyType(jsonObject)))
      throw new ParseException("The key type \"kty\" must be oct", 0); 
    Base64URL k = JSONObjectUtils.getBase64URL(jsonObject, "k");
    try {
      return new OctetSequenceKey(k, 
          JWKMetadata.parseKeyUse(jsonObject), 
          JWKMetadata.parseKeyOperations(jsonObject), 
          JWKMetadata.parseAlgorithm(jsonObject), 
          JWKMetadata.parseKeyID(jsonObject), 
          JWKMetadata.parseX509CertURL(jsonObject), 
          JWKMetadata.parseX509CertThumbprint(jsonObject), 
          JWKMetadata.parseX509CertSHA256Thumbprint(jsonObject), 
          JWKMetadata.parseX509CertChain(jsonObject), null);
    } catch (IllegalArgumentException e) {
      throw new ParseException(e.getMessage(), 0);
    } 
  }
  
  public static OctetSequenceKey load(KeyStore keyStore, String alias, char[] pin) throws KeyStoreException, JOSEException {
    Key key;
    try {
      key = keyStore.getKey(alias, pin);
    } catch (UnrecoverableKeyException|java.security.NoSuchAlgorithmException e) {
      throw new JOSEException("Couldn't retrieve secret key (bad pin?): " + e.getMessage(), e);
    } 
    if (!(key instanceof SecretKey))
      return null; 
    return (new Builder((SecretKey)key))
      .keyID(alias)
      .keyStore(keyStore)
      .build();
  }
  
  public boolean equals(Object o) {
    if (this == o)
      return true; 
    if (!(o instanceof OctetSequenceKey))
      return false; 
    if (!super.equals(o))
      return false; 
    OctetSequenceKey that = (OctetSequenceKey)o;
    return Objects.equals(this.k, that.k);
  }
  
  public int hashCode() { return Objects.hash(new Object[] { Integer.valueOf(super.hashCode()), this.k }); }
}
