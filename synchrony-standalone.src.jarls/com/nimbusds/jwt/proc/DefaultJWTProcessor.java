package com.nimbusds.jwt.proc;

import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWEDecrypter;
import com.nimbusds.jose.JWSHeader;
import com.nimbusds.jose.JWSVerifier;
import com.nimbusds.jose.KeySourceException;
import com.nimbusds.jose.crypto.factories.DefaultJWEDecrypterFactory;
import com.nimbusds.jose.crypto.factories.DefaultJWSVerifierFactory;
import com.nimbusds.jose.proc.BadJOSEException;
import com.nimbusds.jose.proc.BadJWEException;
import com.nimbusds.jose.proc.BadJWSException;
import com.nimbusds.jose.proc.DefaultJOSEObjectTypeVerifier;
import com.nimbusds.jose.proc.JOSEObjectTypeVerifier;
import com.nimbusds.jose.proc.JWEDecrypterFactory;
import com.nimbusds.jose.proc.JWEKeySelector;
import com.nimbusds.jose.proc.JWSKeySelector;
import com.nimbusds.jose.proc.JWSVerifierFactory;
import com.nimbusds.jose.proc.SecurityContext;
import com.nimbusds.jwt.EncryptedJWT;
import com.nimbusds.jwt.JWT;
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.JWTParser;
import com.nimbusds.jwt.PlainJWT;
import com.nimbusds.jwt.SignedJWT;
import java.security.Key;
import java.text.ParseException;
import java.util.List;
import java.util.ListIterator;

public class DefaultJWTProcessor<C extends SecurityContext> extends Object implements ConfigurableJWTProcessor<C> {
  private JOSEObjectTypeVerifier<C> jwsTypeVerifier = DefaultJOSEObjectTypeVerifier.JWT;
  
  private JOSEObjectTypeVerifier<C> jweTypeVerifier = DefaultJOSEObjectTypeVerifier.JWT;
  
  private JWSKeySelector<C> jwsKeySelector;
  
  private JWTClaimsSetAwareJWSKeySelector<C> claimsSetAwareJWSKeySelector;
  
  private JWEKeySelector<C> jweKeySelector;
  
  private JWSVerifierFactory jwsVerifierFactory = new DefaultJWSVerifierFactory();
  
  private JWEDecrypterFactory jweDecrypterFactory = new DefaultJWEDecrypterFactory();
  
  private JWTClaimsSetVerifier<C> claimsVerifier = new DefaultJWTClaimsVerifier();
  
  private JWTClaimsVerifier deprecatedClaimsVerifier = null;
  
  public JOSEObjectTypeVerifier<C> getJWSTypeVerifier() { return this.jwsTypeVerifier; }
  
  public void setJWSTypeVerifier(JOSEObjectTypeVerifier<C> jwsTypeVerifier) { this.jwsTypeVerifier = jwsTypeVerifier; }
  
  public JWSKeySelector<C> getJWSKeySelector() { return this.jwsKeySelector; }
  
  public void setJWSKeySelector(JWSKeySelector<C> jwsKeySelector) { this.jwsKeySelector = jwsKeySelector; }
  
  public JWTClaimsSetAwareJWSKeySelector<C> getJWTClaimsSetAwareJWSKeySelector() { return this.claimsSetAwareJWSKeySelector; }
  
  public void setJWTClaimsSetAwareJWSKeySelector(JWTClaimsSetAwareJWSKeySelector<C> jwsKeySelector) { this.claimsSetAwareJWSKeySelector = jwsKeySelector; }
  
  public JOSEObjectTypeVerifier<C> getJWETypeVerifier() { return this.jweTypeVerifier; }
  
  public void setJWETypeVerifier(JOSEObjectTypeVerifier<C> jweTypeVerifier) { this.jweTypeVerifier = jweTypeVerifier; }
  
  public JWEKeySelector<C> getJWEKeySelector() { return this.jweKeySelector; }
  
  public void setJWEKeySelector(JWEKeySelector<C> jweKeySelector) { this.jweKeySelector = jweKeySelector; }
  
  public JWSVerifierFactory getJWSVerifierFactory() { return this.jwsVerifierFactory; }
  
  public void setJWSVerifierFactory(JWSVerifierFactory factory) { this.jwsVerifierFactory = factory; }
  
  public JWEDecrypterFactory getJWEDecrypterFactory() { return this.jweDecrypterFactory; }
  
  public void setJWEDecrypterFactory(JWEDecrypterFactory factory) { this.jweDecrypterFactory = factory; }
  
  public JWTClaimsSetVerifier<C> getJWTClaimsSetVerifier() { return this.claimsVerifier; }
  
  public void setJWTClaimsSetVerifier(JWTClaimsSetVerifier<C> claimsVerifier) {
    this.claimsVerifier = claimsVerifier;
    this.deprecatedClaimsVerifier = null;
  }
  
  @Deprecated
  public JWTClaimsVerifier getJWTClaimsVerifier() { return this.deprecatedClaimsVerifier; }
  
  @Deprecated
  public void setJWTClaimsVerifier(JWTClaimsVerifier claimsVerifier) {
    this.claimsVerifier = null;
    this.deprecatedClaimsVerifier = claimsVerifier;
  }
  
  private JWTClaimsSet extractJWTClaimsSet(JWT jwt) throws BadJWTException {
    try {
      return jwt.getJWTClaimsSet();
    } catch (ParseException e) {
      throw new BadJWTException(e.getMessage(), e);
    } 
  }
  
  private JWTClaimsSet verifyClaims(JWTClaimsSet claimsSet, C context) throws BadJWTException {
    if (getJWTClaimsSetVerifier() != null) {
      getJWTClaimsSetVerifier().verify(claimsSet, context);
    } else if (getJWTClaimsVerifier() != null) {
      getJWTClaimsVerifier().verify(claimsSet);
    } 
    return claimsSet;
  }
  
  private List<? extends Key> selectKeys(JWSHeader header, JWTClaimsSet claimsSet, C context) throws KeySourceException, BadJOSEException {
    if (getJWTClaimsSetAwareJWSKeySelector() != null)
      return getJWTClaimsSetAwareJWSKeySelector().selectKeys(header, claimsSet, context); 
    if (getJWSKeySelector() != null)
      return getJWSKeySelector().selectJWSKeys(header, context); 
    throw new BadJOSEException("Signed JWT rejected: No JWS key selector is configured");
  }
  
  public JWTClaimsSet process(String jwtString, C context) throws ParseException, BadJOSEException, JOSEException { return process(JWTParser.parse(jwtString), context); }
  
  public JWTClaimsSet process(JWT jwt, C context) throws BadJOSEException, JOSEException {
    if (jwt instanceof SignedJWT)
      return process((SignedJWT)jwt, context); 
    if (jwt instanceof EncryptedJWT)
      return process((EncryptedJWT)jwt, context); 
    if (jwt instanceof PlainJWT)
      return process((PlainJWT)jwt, context); 
    throw new JOSEException("Unexpected JWT object type: " + jwt.getClass());
  }
  
  public JWTClaimsSet process(PlainJWT plainJWT, C context) throws BadJOSEException, JOSEException {
    if (this.jwsTypeVerifier == null)
      throw new BadJOSEException("Plain JWT rejected: No JWS header \"typ\" (type) verifier is configured"); 
    this.jwsTypeVerifier.verify(plainJWT.getHeader().getType(), context);
    throw new BadJOSEException("Unsecured (plain) JWTs are rejected, extend class to handle");
  }
  
  public JWTClaimsSet process(SignedJWT signedJWT, C context) throws BadJOSEException, JOSEException {
    if (this.jwsTypeVerifier == null)
      throw new BadJOSEException("Signed JWT rejected: No JWS header \"typ\" (type) verifier is configured"); 
    this.jwsTypeVerifier.verify(signedJWT.getHeader().getType(), context);
    if (getJWSKeySelector() == null && getJWTClaimsSetAwareJWSKeySelector() == null)
      throw new BadJOSEException("Signed JWT rejected: No JWS key selector is configured"); 
    if (getJWSVerifierFactory() == null)
      throw new JOSEException("No JWS verifier is configured"); 
    JWTClaimsSet claimsSet = extractJWTClaimsSet(signedJWT);
    List<? extends Key> keyCandidates = selectKeys(signedJWT.getHeader(), claimsSet, context);
    if (keyCandidates == null || keyCandidates.isEmpty())
      throw new BadJOSEException("Signed JWT rejected: Another algorithm expected, or no matching key(s) found"); 
    ListIterator<? extends Key> it = keyCandidates.listIterator();
    while (it.hasNext()) {
      JWSVerifier verifier = getJWSVerifierFactory().createJWSVerifier(signedJWT.getHeader(), (Key)it.next());
      if (verifier == null)
        continue; 
      boolean validSignature = signedJWT.verify(verifier);
      if (validSignature)
        return verifyClaims(claimsSet, context); 
      if (!it.hasNext())
        throw new BadJWSException("Signed JWT rejected: Invalid signature"); 
    } 
    throw new BadJOSEException("JWS object rejected: No matching verifier(s) found");
  }
  
  public JWTClaimsSet process(EncryptedJWT encryptedJWT, C context) throws BadJOSEException, JOSEException {
    if (this.jweTypeVerifier == null)
      throw new BadJOSEException("Encrypted JWT rejected: No JWE header \"typ\" (type) verifier is configured"); 
    this.jweTypeVerifier.verify(encryptedJWT.getHeader().getType(), context);
    if (getJWEKeySelector() == null)
      throw new BadJOSEException("Encrypted JWT rejected: No JWE key selector is configured"); 
    if (getJWEDecrypterFactory() == null)
      throw new JOSEException("No JWE decrypter is configured"); 
    List<? extends Key> keyCandidates = getJWEKeySelector().selectJWEKeys(encryptedJWT.getHeader(), context);
    if (keyCandidates == null || keyCandidates.isEmpty())
      throw new BadJOSEException("Encrypted JWT rejected: Another algorithm expected, or no matching key(s) found"); 
    ListIterator<? extends Key> it = keyCandidates.listIterator();
    while (it.hasNext()) {
      JWEDecrypter decrypter = getJWEDecrypterFactory().createJWEDecrypter(encryptedJWT.getHeader(), (Key)it.next());
      if (decrypter == null)
        continue; 
      try {
        encryptedJWT.decrypt(decrypter);
      } catch (JOSEException e) {
        if (it.hasNext())
          continue; 
        throw new BadJWEException("Encrypted JWT rejected: " + e.getMessage(), e);
      } 
      if ("JWT".equalsIgnoreCase(encryptedJWT.getHeader().getContentType())) {
        SignedJWT signedJWTPayload = encryptedJWT.getPayload().toSignedJWT();
        if (signedJWTPayload == null)
          throw new BadJWTException("The payload is not a nested signed JWT"); 
        return process(signedJWTPayload, context);
      } 
      JWTClaimsSet claimsSet = extractJWTClaimsSet(encryptedJWT);
      return verifyClaims(claimsSet, context);
    } 
    throw new BadJOSEException("Encrypted JWT rejected: No matching decrypter(s) found");
  }
}
