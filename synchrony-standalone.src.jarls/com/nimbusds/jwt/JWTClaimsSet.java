package com.nimbusds.jwt;

import com.nimbusds.jose.util.DateUtils;
import com.nimbusds.jose.util.JSONObjectUtils;
import java.io.Serializable;
import java.net.URI;
import java.net.URISyntaxException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import net.jcip.annotations.Immutable;
import net.minidev.json.JSONArray;
import net.minidev.json.JSONObject;

@Immutable
public final class JWTClaimsSet implements Serializable {
  private static final long serialVersionUID = 1L;
  
  private static final String ISSUER_CLAIM = "iss";
  
  private static final String SUBJECT_CLAIM = "sub";
  
  private static final String AUDIENCE_CLAIM = "aud";
  
  private static final String EXPIRATION_TIME_CLAIM = "exp";
  
  private static final String NOT_BEFORE_CLAIM = "nbf";
  
  private static final String ISSUED_AT_CLAIM = "iat";
  
  private static final String JWT_ID_CLAIM = "jti";
  
  private static final Set<String> REGISTERED_CLAIM_NAMES;
  
  private final Map<String, Object> claims;
  
  static  {
    n = new HashSet();
    n.add("iss");
    n.add("sub");
    n.add("aud");
    n.add("exp");
    n.add("nbf");
    n.add("iat");
    n.add("jti");
    REGISTERED_CLAIM_NAMES = Collections.unmodifiableSet(n);
  }
  
  private JWTClaimsSet(Map<String, Object> claims) {
    this.claims = new LinkedHashMap();
    this.claims.putAll(claims);
  }
  
  public static Set<String> getRegisteredNames() { return REGISTERED_CLAIM_NAMES; }
  
  public String getIssuer() {
    try {
      return getStringClaim("iss");
    } catch (ParseException e) {
      return null;
    } 
  }
  
  public String getSubject() {
    try {
      return getStringClaim("sub");
    } catch (ParseException e) {
      return null;
    } 
  }
  
  public List<String> getAudience() {
    List<String> aud;
    Object audValue = getClaim("aud");
    if (audValue instanceof String)
      return Collections.singletonList((String)audValue); 
    try {
      aud = getStringListClaim("aud");
    } catch (ParseException e) {
      return Collections.emptyList();
    } 
    return (aud != null) ? Collections.unmodifiableList(aud) : Collections.emptyList();
  }
  
  public Date getExpirationTime() {
    try {
      return getDateClaim("exp");
    } catch (ParseException e) {
      return null;
    } 
  }
  
  public Date getNotBeforeTime() {
    try {
      return getDateClaim("nbf");
    } catch (ParseException e) {
      return null;
    } 
  }
  
  public Date getIssueTime() {
    try {
      return getDateClaim("iat");
    } catch (ParseException e) {
      return null;
    } 
  }
  
  public String getJWTID() {
    try {
      return getStringClaim("jti");
    } catch (ParseException e) {
      return null;
    } 
  }
  
  public Object getClaim(String name) { return this.claims.get(name); }
  
  public String getStringClaim(String name) throws ParseException {
    Object value = getClaim(name);
    if (value == null || value instanceof String)
      return (String)value; 
    throw new ParseException("The \"" + name + "\" claim is not a String", 0);
  }
  
  public String[] getStringArrayClaim(String name) throws ParseException {
    List<?> list;
    Object value = getClaim(name);
    if (value == null)
      return null; 
    try {
      list = (List)getClaim(name);
    } catch (ClassCastException e) {
      throw new ParseException("The \"" + name + "\" claim is not a list / JSON array", 0);
    } 
    String[] stringArray = new String[list.size()];
    for (int i = 0; i < stringArray.length; i++) {
      try {
        stringArray[i] = (String)list.get(i);
      } catch (ClassCastException e) {
        throw new ParseException("The \"" + name + "\" claim is not a list / JSON array of strings", 0);
      } 
    } 
    return stringArray;
  }
  
  public List<String> getStringListClaim(String name) throws ParseException {
    String[] stringArray = getStringArrayClaim(name);
    if (stringArray == null)
      return null; 
    return Collections.unmodifiableList(Arrays.asList(stringArray));
  }
  
  public URI getURIClaim(String name) throws ParseException {
    String uriString = getStringClaim(name);
    if (uriString == null)
      return null; 
    try {
      return new URI(uriString);
    } catch (URISyntaxException e) {
      throw new ParseException("The \"" + name + "\" claim is not a URI: " + e.getMessage(), 0);
    } 
  }
  
  public Boolean getBooleanClaim(String name) throws ParseException {
    Object value = getClaim(name);
    if (value == null || value instanceof Boolean)
      return (Boolean)value; 
    throw new ParseException("The \"" + name + "\" claim is not a Boolean", 0);
  }
  
  public Integer getIntegerClaim(String name) throws ParseException {
    Object value = getClaim(name);
    if (value == null)
      return null; 
    if (value instanceof Number)
      return Integer.valueOf(((Number)value).intValue()); 
    throw new ParseException("The \"" + name + "\" claim is not an Integer", 0);
  }
  
  public Long getLongClaim(String name) throws ParseException {
    Object value = getClaim(name);
    if (value == null)
      return null; 
    if (value instanceof Number)
      return Long.valueOf(((Number)value).longValue()); 
    throw new ParseException("The \"" + name + "\" claim is not a Number", 0);
  }
  
  public Date getDateClaim(String name) throws ParseException {
    Object value = getClaim(name);
    if (value == null)
      return null; 
    if (value instanceof Date)
      return (Date)value; 
    if (value instanceof Number)
      return DateUtils.fromSecondsSinceEpoch(((Number)value).longValue()); 
    throw new ParseException("The \"" + name + "\" claim is not a Date", 0);
  }
  
  public Float getFloatClaim(String name) throws ParseException {
    Object value = getClaim(name);
    if (value == null)
      return null; 
    if (value instanceof Number)
      return Float.valueOf(((Number)value).floatValue()); 
    throw new ParseException("The \"" + name + "\" claim is not a Float", 0);
  }
  
  public Double getDoubleClaim(String name) throws ParseException {
    Object value = getClaim(name);
    if (value == null)
      return null; 
    if (value instanceof Number)
      return Double.valueOf(((Number)value).doubleValue()); 
    throw new ParseException("The \"" + name + "\" claim is not a Double", 0);
  }
  
  public JSONObject getJSONObjectClaim(String name) throws ParseException {
    Object value = getClaim(name);
    if (value == null)
      return null; 
    if (value instanceof JSONObject)
      return (JSONObject)value; 
    if (value instanceof Map) {
      JSONObject jsonObject = new JSONObject();
      Map<?, ?> map = (Map)value;
      for (Map.Entry<?, ?> entry : map.entrySet()) {
        if (entry.getKey() instanceof String)
          jsonObject.put((String)entry.getKey(), entry.getValue()); 
      } 
      return jsonObject;
    } 
    throw new ParseException("The \"" + name + "\" claim is not a JSON object or Map", 0);
  }
  
  public Map<String, Object> getClaims() { return Collections.unmodifiableMap(this.claims); }
  
  public JSONObject toJSONObject() { return toJSONObject(false); }
  
  public JSONObject toJSONObject(boolean includeClaimsWithNullValues) {
    JSONObject o = new JSONObject();
    for (Map.Entry<String, Object> claim : this.claims.entrySet()) {
      if (claim.getValue() instanceof Date) {
        Date dateValue = (Date)claim.getValue();
        o.put(claim.getKey(), Long.valueOf(DateUtils.toSecondsSinceEpoch(dateValue)));
        continue;
      } 
      if ("aud".equals(claim.getKey())) {
        List<String> audList = getAudience();
        if (audList != null && !audList.isEmpty()) {
          if (audList.size() == 1) {
            o.put("aud", audList.get(0));
            continue;
          } 
          JSONArray audArray = new JSONArray();
          audArray.addAll(audList);
          o.put("aud", audArray);
          continue;
        } 
        if (includeClaimsWithNullValues)
          o.put("aud", null); 
        continue;
      } 
      if (claim.getValue() != null) {
        o.put(claim.getKey(), claim.getValue());
        continue;
      } 
      if (includeClaimsWithNullValues)
        o.put(claim.getKey(), null); 
    } 
    return o;
  }
  
  public String toString() { return toJSONObject().toJSONString(); }
  
  public <T> T toType(JWTClaimsSetTransformer<T> transformer) { return (T)transformer.transform(this); }
  
  public static JWTClaimsSet parse(JSONObject json) throws ParseException {
    Builder builder = new Builder();
    for (String name : json.keySet()) {
      if (name.equals("iss")) {
        builder.issuer(JSONObjectUtils.getString(json, "iss"));
        continue;
      } 
      if (name.equals("sub")) {
        builder.subject(JSONObjectUtils.getString(json, "sub"));
        continue;
      } 
      if (name.equals("aud")) {
        Object audValue = json.get("aud");
        if (audValue instanceof String) {
          List<String> singleAud = new ArrayList<String>();
          singleAud.add(JSONObjectUtils.getString(json, "aud"));
          builder.audience(singleAud);
          continue;
        } 
        if (audValue instanceof List) {
          builder.audience(JSONObjectUtils.getStringList(json, "aud"));
          continue;
        } 
        if (audValue == null)
          builder.audience((String)null); 
        continue;
      } 
      if (name.equals("exp")) {
        builder.expirationTime(new Date(JSONObjectUtils.getLong(json, "exp") * 1000L));
        continue;
      } 
      if (name.equals("nbf")) {
        builder.notBeforeTime(new Date(JSONObjectUtils.getLong(json, "nbf") * 1000L));
        continue;
      } 
      if (name.equals("iat")) {
        builder.issueTime(new Date(JSONObjectUtils.getLong(json, "iat") * 1000L));
        continue;
      } 
      if (name.equals("jti")) {
        builder.jwtID(JSONObjectUtils.getString(json, "jti"));
        continue;
      } 
      builder.claim(name, json.get(name));
    } 
    return builder.build();
  }
  
  public static JWTClaimsSet parse(String s) throws ParseException { return parse(JSONObjectUtils.parse(s)); }
  
  public boolean equals(Object o) {
    if (this == o)
      return true; 
    if (!(o instanceof JWTClaimsSet))
      return false; 
    JWTClaimsSet that = (JWTClaimsSet)o;
    return Objects.equals(this.claims, that.claims);
  }
  
  public int hashCode() { return Objects.hash(new Object[] { this.claims }); }
}
