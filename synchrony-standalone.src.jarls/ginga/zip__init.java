package ginga;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class zip__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__2;
  
  public static final Object const__3;
  
  public static final Var const__4;
  
  public static final Var const__5;
  
  public static final Var const__6;
  
  public static final Keyword const__7;
  
  public static final Var const__8;
  
  public static final ISeq const__9;
  
  public static final Var const__10;
  
  public static final Var const__11;
  
  public static final AFn const__15;
  
  public static final Keyword const__16;
  
  public static final AFn const__17;
  
  public static final Keyword const__18;
  
  public static final Keyword const__19;
  
  public static final AFn const__28;
  
  public static final Keyword const__29;
  
  public static final Var const__30;
  
  public static final Var const__31;
  
  public static final Var const__32;
  
  public static final AFn const__33;
  
  public static final AFn const__34;
  
  public static final Keyword const__35;
  
  public static final AFn const__36;
  
  public static final AFn const__37;
  
  public static final AFn const__38;
  
  public static final AFn const__39;
  
  public static final AFn const__40;
  
  public static final AFn const__41;
  
  public static final AFn const__42;
  
  public static final AFn const__43;
  
  public static final AFn const__44;
  
  public static final AFn const__45;
  
  public static final AFn const__46;
  
  public static final AFn const__47;
  
  public static final AFn const__48;
  
  public static final AFn const__49;
  
  public static final Var const__50;
  
  public static final AFn const__51;
  
  public static final Object const__52;
  
  public static final Var const__53;
  
  public static final ISeq const__54;
  
  public static final AFn const__56;
  
  public static final AFn const__57;
  
  public static final AFn const__60;
  
  public static final AFn const__61;
  
  public static final AFn const__62;
  
  public static final AFn const__63;
  
  public static final AFn const__64;
  
  public static final AFn const__65;
  
  public static final Object const__66;
  
  public static final Var const__67;
  
  public static final ISeq const__68;
  
  public static final AFn const__70;
  
  public static final AFn const__71;
  
  public static final AFn const__82;
  
  public static final AFn const__83;
  
  public static final AFn const__84;
  
  public static final AFn const__85;
  
  public static final AFn const__86;
  
  public static final AFn const__87;
  
  public static final AFn const__88;
  
  public static final AFn const__89;
  
  public static final AFn const__90;
  
  public static final AFn const__91;
  
  public static final AFn const__92;
  
  public static final AFn const__93;
  
  public static final AFn const__94;
  
  public static final AFn const__95;
  
  public static final AFn const__96;
  
  public static final AFn const__97;
  
  public static final AFn const__98;
  
  public static final AFn const__99;
  
  public static final AFn const__100;
  
  public static final AFn const__101;
  
  public static final AFn const__102;
  
  public static final AFn const__103;
  
  public static final Object const__104;
  
  public static final Var const__105;
  
  public static final ISeq const__106;
  
  public static final AFn const__108;
  
  public static final AFn const__109;
  
  public static final AFn const__112;
  
  public static final AFn const__113;
  
  public static final AFn const__114;
  
  public static final AFn const__115;
  
  public static final AFn const__116;
  
  public static final AFn const__117;
  
  public static final Object const__118;
  
  public static final Var const__119;
  
  public static final ISeq const__120;
  
  public static final AFn const__122;
  
  public static final AFn const__123;
  
  public static final AFn const__125;
  
  public static final AFn const__126;
  
  public static final AFn const__127;
  
  public static final AFn const__128;
  
  public static final Var const__129;
  
  public static final AFn const__136;
  
  public static final Var const__137;
  
  public static final AFn const__138;
  
  public static final Var const__139;
  
  public static final AFn const__143;
  
  public static final Var const__144;
  
  public static final AFn const__147;
  
  public static final Var const__148;
  
  public static final AFn const__151;
  
  public static final AFn const__154;
  
  public static final AFn const__157;
  
  public static final Var const__158;
  
  public static final AFn const__161;
  
  public static final Var const__162;
  
  public static final AFn const__165;
  
  public static final Var const__166;
  
  public static final AFn const__169;
  
  public static final Var const__170;
  
  public static final AFn const__173;
  
  public static final Var const__174;
  
  public static final AFn const__177;
  
  public static final Var const__178;
  
  public static final AFn const__181;
  
  public static final Var const__182;
  
  public static final AFn const__185;
  
  public static final Var const__186;
  
  public static final AFn const__189;
  
  public static final Var const__190;
  
  public static final AFn const__193;
  
  public static final Var const__194;
  
  public static final AFn const__197;
  
  public static final Var const__198;
  
  public static final AFn const__201;
  
  public static final Var const__202;
  
  public static final AFn const__205;
  
  public static final Var const__206;
  
  public static final AFn const__209;
  
  public static final Var const__210;
  
  public static final AFn const__213;
  
  public static final Var const__214;
  
  public static final AFn const__217;
  
  public static final Var const__218;
  
  public static final AFn const__221;
  
  public static final Var const__222;
  
  public static final AFn const__225;
  
  public static final Var const__226;
  
  public static final AFn const__229;
  
  public static final Var const__230;
  
  public static final AFn const__233;
  
  public static final Var const__234;
  
  public static final AFn const__237;
  
  public static final Var const__238;
  
  public static final AFn const__241;
  
  public static final Var const__242;
  
  public static final AFn const__245;
  
  public static final Var const__246;
  
  public static final AFn const__249;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new zip.fn__20719());
    const__129.setMeta((IPersistentMap)const__136);
    const__137.setMeta((IPersistentMap)const__138);
    const__139.setMeta((IPersistentMap)const__143);
    const__139.bindRoot(new zip.down_impl());
    const__144.setMeta((IPersistentMap)const__147);
    const__144.bindRoot(new zip.advance_subseqs());
    const__148.setMeta((IPersistentMap)const__151);
    const__148.bindRoot(new zip.finalize_subseqs());
    const__129.setMeta((IPersistentMap)const__154);
    const__129.bindRoot(new zip.from_vector());
    const__137.setMeta((IPersistentMap)const__157);
    const__137.bindRoot(new zip.from_seqable());
    const__158.setMeta((IPersistentMap)const__161);
    const__158.bindRoot(new zip.zipper());
    const__162.setMeta((IPersistentMap)const__165);
    const__162.bindRoot(new zip.traverser());
    const__166.setMeta((IPersistentMap)const__169);
    const__166.bindRoot(new zip.parent_node());
    const__170.setMeta((IPersistentMap)const__173);
    const__170.bindRoot(new zip.next_node());
    const__174.setMeta((IPersistentMap)const__177);
    const__174.bindRoot(new zip.down_end());
    const__178.setMeta((IPersistentMap)const__181);
    const__178.bindRoot(new zip.insert_down());
    const__182.setMeta((IPersistentMap)const__185);
    const__182.bindRoot(new zip.prev_replace_next());
    const__186.setMeta((IPersistentMap)const__189);
    const__186.bindRoot(new zip.replace_down());
    const__190.setMeta((IPersistentMap)const__193);
    const__190.bindRoot(new zip.edit());
    const__194.setMeta((IPersistentMap)const__197);
    const__194.bindRoot(new zip.append_to_parent_STAR_());
    const__198.setMeta((IPersistentMap)const__201);
    const__198.bindRoot(new zip.frames());
    const__202.setMeta((IPersistentMap)const__205);
    const__202.bindRoot(new zip.ancestor_nodes());
    const__206.setMeta((IPersistentMap)const__209);
    const__206.bindRoot(new zip.shift_next_nodes_up());
    const__210.setMeta((IPersistentMap)const__213);
    const__210.bindRoot(new zip.shift_next_nodes_down());
    const__214.setMeta((IPersistentMap)const__217);
    const__214.bindRoot(new zip.split());
    const__218.setMeta((IPersistentMap)const__221);
    const__218.bindRoot(new zip.unwrap_children_next());
    const__222.setMeta((IPersistentMap)const__225);
    const__222.bindRoot(new zip.unwrap_children_prev());
    const__226.setMeta((IPersistentMap)const__229);
    const__226.bindRoot(new zip.unwrap());
    const__230.setMeta((IPersistentMap)const__233);
    const__230.bindRoot(new zip.path());
    const__234.setMeta((IPersistentMap)const__237);
    const__234.bindRoot(new zip.descend_path());
    const__238.setMeta((IPersistentMap)const__241);
    const__238.bindRoot(new zip.top());
    const__242.setMeta((IPersistentMap)const__245);
    const__242.bindRoot(new zip.walk());
    const__246.setMeta((IPersistentMap)const__249);
    const__246.bindRoot(new zip.contextual_walk());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "ginga.zip");
    const__2 = (AFn)Symbol.intern(null, "clojure.core");
    const__3 = RT.classForName("ginga.zip.Traverse");
    const__4 = (Var)RT.var("clojure.core", "alter-meta!");
    const__5 = (Var)RT.var("ginga.zip", "Traverse");
    const__6 = (Var)RT.var("clojure.core", "assoc");
    const__7 = (Keyword)RT.keyword(null, "doc");
    const__8 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__9 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Skip the node at the current location, or return nil if at the end", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), ((IObj)Symbol.intern(null, "down")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Descend into the node at the current location", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), ((IObj)Symbol.intern(null, "end")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Skip to the end", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), ((IObj)Symbol.intern(null, "discard")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Discard the current zipper frame and return the parent\n frame. Similar to (up) except doesn't apply any changes to the parent\n node. Returns nil if at the top.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), ((IObj)Symbol.intern(null, "node")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Get the node at the current location.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), ((IObj)Symbol.intern(null, "top?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return true if this is the to zipper frame and a call to discard or\n up would return nil.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), ((IObj)Symbol.intern(null, "end?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return true if the current location is at the end of this zipper\n frame and a call to (node) or (next) would return nil.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), ((IObj)Symbol.intern(null, "traverse")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a zipper that can only be used for traversing. Useful to\n optimize the case where only traversal is needed.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })) }));
    const__10 = (Var)RT.var("clojure.core", "alter-var-root");
    const__11 = (Var)RT.var("clojure.core", "merge");
    const__15 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "ginga.zip.Traverse"), RT.keyword(null, "on-interface"), RT.classForName("ginga.zip.Traverse") });
    const__16 = (Keyword)RT.keyword(null, "sigs");
    const__17 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "next"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Skip the node at the current location, or return nil if at the end", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Skip the node at the current location, or return nil if at the end" }), RT.keyword(null, "down"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "down")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Descend into the node at the current location", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Descend into the node at the current location" }), RT.keyword(null, "end"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "end")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Skip to the end", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Skip to the end" }), RT.keyword(null, "discard"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "discard")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Discard the current zipper frame and return the parent\n frame. Similar to (up) except doesn't apply any changes to the parent\n node. Returns nil if at the top.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Discard the current zipper frame and return the parent\n frame. Similar to (up) except doesn't apply any changes to the parent\n node. Returns nil if at the top." }), RT.keyword(null, "node"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "node")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Get the node at the current location.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Get the node at the current location." }), 
          RT.keyword(null, "top?"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "top?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return true if this is the to zipper frame and a call to discard or\n up would return nil.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Return true if this is the to zipper frame and a call to discard or\n up would return nil." }), RT.keyword(null, "end?"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "end?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return true if the current location is at the end of this zipper\n frame and a call to (node) or (next) would return nil.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Return true if the current location is at the end of this zipper\n frame and a call to (node) or (next) would return nil." }), RT.keyword(null, "traverse"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "traverse")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a zipper that can only be used for traversing. Useful to\n optimize the case where only traversal is needed.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Return a zipper that can only be used for traversing. Useful to\n optimize the case where only traversal is needed." }) });
    const__18 = (Keyword)RT.keyword(null, "var");
    const__19 = (Keyword)RT.keyword(null, "method-map");
    const__28 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "down"), RT.keyword(null, "down"), RT.keyword(null, "end?"), RT.keyword(null, "end?"), RT.keyword(null, "top?"), RT.keyword(null, "top?"), RT.keyword(null, "node"), RT.keyword(null, "node"), RT.keyword(null, "traverse"), RT.keyword(null, "traverse"), 
          RT.keyword(null, "next"), RT.keyword(null, "next"), RT.keyword(null, "discard"), RT.keyword(null, "discard"), RT.keyword(null, "end"), RT.keyword(null, "end") });
    const__29 = (Keyword)RT.keyword(null, "method-builders");
    const__30 = (Var)RT.var("clojure.core", "intern");
    const__31 = (Var)RT.var("clojure.core", "*ns*");
    const__32 = (Var)RT.var("clojure.core", "with-meta");
    const__33 = (AFn)((IObj)Symbol.intern(null, "next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Skip the node at the current location, or return nil if at the end", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) }));
    const__34 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Skip the node at the current location, or return nil if at the end", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Skip the node at the current location, or return nil if at the end" });
    const__35 = (Keyword)RT.keyword(null, "protocol");
    const__36 = (AFn)((IObj)Symbol.intern(null, "traverse")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a zipper that can only be used for traversing. Useful to\n optimize the case where only traversal is needed.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) }));
    const__37 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "traverse")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a zipper that can only be used for traversing. Useful to\n optimize the case where only traversal is needed.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Return a zipper that can only be used for traversing. Useful to\n optimize the case where only traversal is needed." });
    const__38 = (AFn)((IObj)Symbol.intern(null, "end")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Skip to the end", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) }));
    const__39 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "end")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Skip to the end", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Skip to the end" });
    const__40 = (AFn)((IObj)Symbol.intern(null, "down")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Descend into the node at the current location", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) }));
    const__41 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "down")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Descend into the node at the current location", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Descend into the node at the current location" });
    const__42 = (AFn)((IObj)Symbol.intern(null, "top?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return true if this is the to zipper frame and a call to discard or\n up would return nil.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) }));
    const__43 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "top?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return true if this is the to zipper frame and a call to discard or\n up would return nil.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Return true if this is the to zipper frame and a call to discard or\n up would return nil." });
    const__44 = (AFn)((IObj)Symbol.intern(null, "discard")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Discard the current zipper frame and return the parent\n frame. Similar to (up) except doesn't apply any changes to the parent\n node. Returns nil if at the top.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) }));
    const__45 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "discard")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Discard the current zipper frame and return the parent\n frame. Similar to (up) except doesn't apply any changes to the parent\n node. Returns nil if at the top.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Discard the current zipper frame and return the parent\n frame. Similar to (up) except doesn't apply any changes to the parent\n node. Returns nil if at the top." });
    const__46 = (AFn)((IObj)Symbol.intern(null, "end?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return true if the current location is at the end of this zipper\n frame and a call to (node) or (next) would return nil.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) }));
    const__47 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "end?")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return true if the current location is at the end of this zipper\n frame and a call to (node) or (next) would return nil.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Return true if the current location is at the end of this zipper\n frame and a call to (node) or (next) would return nil." });
    const__48 = (AFn)((IObj)Symbol.intern(null, "node")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Get the node at the current location.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) }));
    const__49 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "node")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Get the node at the current location.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Get the node at the current location." });
    const__50 = (Var)RT.var("clojure.core", "-reset-methods");
    const__51 = (AFn)Symbol.intern(null, "Traverse");
    const__52 = RT.classForName("ginga.zip.Backtrack");
    const__53 = (Var)RT.var("ginga.zip", "Backtrack");
    const__54 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "prev")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Skip the node before the current location, or return nil if at the beginning.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), ((IObj)Symbol.intern(null, "prev-node")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Similar to (-> (prev) (node)) but returns nil if there is no prev node", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })) }));
    const__56 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "ginga.zip.Backtrack"), RT.keyword(null, "on-interface"), RT.classForName("ginga.zip.Backtrack") });
    const__57 = (AFn)RT.map(new Object[] { RT.keyword(null, "prev"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "prev")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Skip the node before the current location, or return nil if at the beginning.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Skip the node before the current location, or return nil if at the beginning." }), RT.keyword(null, "prev-node"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "prev-node")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Similar to (-> (prev) (node)) but returns nil if there is no prev node", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Similar to (-> (prev) (node)) but returns nil if there is no prev node" }) });
    const__60 = (AFn)RT.map(new Object[] { RT.keyword(null, "prev-node"), RT.keyword(null, "prev-node"), RT.keyword(null, "prev"), RT.keyword(null, "prev") });
    const__61 = (AFn)((IObj)Symbol.intern(null, "prev")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Skip the node before the current location, or return nil if at the beginning.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) }));
    const__62 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "prev")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Skip the node before the current location, or return nil if at the beginning.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Skip the node before the current location, or return nil if at the beginning." });
    const__63 = (AFn)((IObj)Symbol.intern(null, "prev-node")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Similar to (-> (prev) (node)) but returns nil if there is no prev node", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) }));
    const__64 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "prev-node")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Similar to (-> (prev) (node)) but returns nil if there is no prev node", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Similar to (-> (prev) (node)) but returns nil if there is no prev node" });
    const__65 = (AFn)Symbol.intern(null, "Backtrack");
    const__66 = RT.classForName("ginga.zip.Edit");
    const__67 = (Var)RT.var("ginga.zip", "Edit");
    const__68 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "remove")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Remove the current node.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), ((IObj)Symbol.intern(null, "insert")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Insert a new node before the current node. The new node will become\n the new current node.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })) })), ((IObj)Symbol.intern(null, "replace")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Replace the node at the current location.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })) })), ((IObj)Symbol.intern(null, "replace-next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> z (replace node) (next))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })) })), ((IObj)Symbol.intern(null, "up")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the parent frame, replacing the current node in the parent\n frame with a new one reflecting all edits that happened in the current\n frame.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), ((IObj)Symbol.intern(null, "prev-remove")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> z (prev) (remove))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), ((IObj)Symbol.intern(null, "insert*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (reduce insert z (reverse nodes))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "nodes")) })) })), ((IObj)Symbol.intern(null, "insert-next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> z (insert node) (next))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })) })), ((IObj)Symbol.intern(null, "up-next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> z (up) (next))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), ((IObj)Symbol.intern(null, "insert-next*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (reduce insert-next z nodes)", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "nodes")) })) })) }));
    const__70 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "ginga.zip.Edit"), RT.keyword(null, "on-interface"), RT.classForName("ginga.zip.Edit") });
    const__71 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "remove"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "remove")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Remove the current node.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Remove the current node." }), RT.keyword(null, "insert"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "insert")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Insert a new node before the current node. The new node will become\n the new current node.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })), RT.keyword(null, "doc"), "Insert a new node before the current node. The new node will become\n the new current node." }), RT.keyword(null, "replace"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "replace")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Replace the node at the current location.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })), RT.keyword(null, "doc"), "Replace the node at the current location." }), RT.keyword(null, "replace-next"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "replace-next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> z (replace node) (next))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })), RT.keyword(null, "doc"), "The same as (-> z (replace node) (next))" }), RT.keyword(null, "up"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "up")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the parent frame, replacing the current node in the parent\n frame with a new one reflecting all edits that happened in the current\n frame.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Return the parent frame, replacing the current node in the parent\n frame with a new one reflecting all edits that happened in the current\n frame." }), 
          RT.keyword(null, "prev-remove"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "prev-remove")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> z (prev) (remove))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "The same as (-> z (prev) (remove))" }), RT.keyword(null, "insert*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "insert*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (reduce insert z (reverse nodes))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "nodes")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "nodes")) })), RT.keyword(null, "doc"), "The same as (reduce insert z (reverse nodes))" }), RT.keyword(null, "insert-next"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "insert-next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> z (insert node) (next))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })), RT.keyword(null, "doc"), "The same as (-> z (insert node) (next))" }), RT.keyword(null, "up-next"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "up-next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> z (up) (next))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "The same as (-> z (up) (next))" }), RT.keyword(null, "insert-next*"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "insert-next*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (reduce insert-next z nodes)", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "nodes")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "nodes")) })), RT.keyword(null, "doc"), "The same as (reduce insert-next z nodes)" }) });
    const__82 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "remove"), RT.keyword(null, "remove"), RT.keyword(null, "insert"), RT.keyword(null, "insert"), RT.keyword(null, "replace"), RT.keyword(null, "replace"), RT.keyword(null, "replace-next"), RT.keyword(null, "replace-next"), RT.keyword(null, "up"), RT.keyword(null, "up"), 
          RT.keyword(null, "prev-remove"), RT.keyword(null, "prev-remove"), RT.keyword(null, "insert*"), RT.keyword(null, "insert*"), RT.keyword(null, "insert-next"), RT.keyword(null, "insert-next"), RT.keyword(null, "up-next"), RT.keyword(null, "up-next"), RT.keyword(null, "insert-next*"), RT.keyword(null, "insert-next*") });
    const__83 = (AFn)((IObj)Symbol.intern(null, "up")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the parent frame, replacing the current node in the parent\n frame with a new one reflecting all edits that happened in the current\n frame.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) }));
    const__84 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "up")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the parent frame, replacing the current node in the parent\n frame with a new one reflecting all edits that happened in the current\n frame.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Return the parent frame, replacing the current node in the parent\n frame with a new one reflecting all edits that happened in the current\n frame." });
    const__85 = (AFn)((IObj)Symbol.intern(null, "replace-next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> z (replace node) (next))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })) }));
    const__86 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "replace-next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> z (replace node) (next))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })), RT.keyword(null, "doc"), "The same as (-> z (replace node) (next))" });
    const__87 = (AFn)((IObj)Symbol.intern(null, "up-next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> z (up) (next))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) }));
    const__88 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "up-next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> z (up) (next))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "The same as (-> z (up) (next))" });
    const__89 = (AFn)((IObj)Symbol.intern(null, "insert")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Insert a new node before the current node. The new node will become\n the new current node.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })) }));
    const__90 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "insert")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Insert a new node before the current node. The new node will become\n the new current node.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })), RT.keyword(null, "doc"), "Insert a new node before the current node. The new node will become\n the new current node." });
    const__91 = (AFn)((IObj)Symbol.intern(null, "replace")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Replace the node at the current location.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })) }));
    const__92 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "replace")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Replace the node at the current location.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })), RT.keyword(null, "doc"), "Replace the node at the current location." });
    const__93 = (AFn)((IObj)Symbol.intern(null, "insert*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (reduce insert z (reverse nodes))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "nodes")) })) }));
    const__94 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "insert*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (reduce insert z (reverse nodes))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "nodes")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "nodes")) })), RT.keyword(null, "doc"), "The same as (reduce insert z (reverse nodes))" });
    const__95 = (AFn)((IObj)Symbol.intern(null, "remove")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Remove the current node.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) }));
    const__96 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "remove")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Remove the current node.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Remove the current node." });
    const__97 = (AFn)((IObj)Symbol.intern(null, "insert-next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> z (insert node) (next))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })) }));
    const__98 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "insert-next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> z (insert node) (next))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })), RT.keyword(null, "doc"), "The same as (-> z (insert node) (next))" });
    const__99 = (AFn)((IObj)Symbol.intern(null, "insert-next*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (reduce insert-next z nodes)", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "nodes")) })) }));
  }
  
  public static void __init1() {
    const__100 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "insert-next*")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (reduce insert-next z nodes)", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "nodes")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "nodes")) })), RT.keyword(null, "doc"), "The same as (reduce insert-next z nodes)" });
    const__101 = (AFn)((IObj)Symbol.intern(null, "prev-remove")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> z (prev) (remove))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) }));
    const__102 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "prev-remove")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> z (prev) (remove))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "The same as (-> z (prev) (remove))" });
    const__103 = (AFn)Symbol.intern(null, "Edit");
    const__104 = RT.classForName("ginga.zip.Nth");
    const__105 = (Var)RT.var("ginga.zip", "Nth");
    const__106 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "nth-next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> (iterate next z) (nth i))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "i")) })) })), ((IObj)Symbol.intern(null, "nth-prev")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> (iterate prev z) (nth i))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "i")) })) })) }));
    const__108 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "ginga.zip.Nth"), RT.keyword(null, "on-interface"), RT.classForName("ginga.zip.Nth") });
    const__109 = (AFn)RT.map(new Object[] { RT.keyword(null, "nth-next"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "nth-next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> (iterate next z) (nth i))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "i")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "i")) })), RT.keyword(null, "doc"), "The same as (-> (iterate next z) (nth i))" }), RT.keyword(null, "nth-prev"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "nth-prev")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> (iterate prev z) (nth i))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "i")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "i")) })), RT.keyword(null, "doc"), "The same as (-> (iterate prev z) (nth i))" }) });
    const__112 = (AFn)RT.map(new Object[] { RT.keyword(null, "nth-prev"), RT.keyword(null, "nth-prev"), RT.keyword(null, "nth-next"), RT.keyword(null, "nth-next") });
    const__113 = (AFn)((IObj)Symbol.intern(null, "nth-prev")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> (iterate prev z) (nth i))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "i")) })) }));
    const__114 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "nth-prev")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> (iterate prev z) (nth i))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "i")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "i")) })), RT.keyword(null, "doc"), "The same as (-> (iterate prev z) (nth i))" });
    const__115 = (AFn)((IObj)Symbol.intern(null, "nth-next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> (iterate next z) (nth i))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "i")) })) }));
    const__116 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "nth-next")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "The same as (-> (iterate next z) (nth i))", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "i")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "i")) })), RT.keyword(null, "doc"), "The same as (-> (iterate next z) (nth i))" });
    const__117 = (AFn)Symbol.intern(null, "Nth");
    const__118 = RT.classForName("ginga.zip.AsZipper");
    const__119 = (Var)RT.var("ginga.zip", "AsZipper");
    const__120 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "as-zipper")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Convert a specialized zipper (VectorZipper) to a normal zipper.\n Useful to work with zipper frames directly instead of using the zipper\n API.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })) }));
    const__122 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "ginga.zip.AsZipper"), RT.keyword(null, "on-interface"), RT.classForName("ginga.zip.AsZipper") });
    const__123 = (AFn)RT.map(new Object[] { RT.keyword(null, "as-zipper"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "as-zipper")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Convert a specialized zipper (VectorZipper) to a normal zipper.\n Useful to work with zipper frames directly instead of using the zipper\n API.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Convert a specialized zipper (VectorZipper) to a normal zipper.\n Useful to work with zipper frames directly instead of using the zipper\n API." }) });
    const__125 = (AFn)RT.map(new Object[] { RT.keyword(null, "as-zipper"), RT.keyword(null, "as-zipper") });
    const__126 = (AFn)((IObj)Symbol.intern(null, "as-zipper")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Convert a specialized zipper (VectorZipper) to a normal zipper.\n Useful to work with zipper frames directly instead of using the zipper\n API.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) }));
    const__127 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "as-zipper")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Convert a specialized zipper (VectorZipper) to a normal zipper.\n Useful to work with zipper frames directly instead of using the zipper\n API.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Convert a specialized zipper (VectorZipper) to a normal zipper.\n Useful to work with zipper frames directly instead of using the zipper\n API." });
    const__128 = (AFn)Symbol.intern(null, "AsZipper");
    const__129 = (Var)RT.var("ginga.zip", "from-vector");
    const__136 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(78), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__137 = (Var)RT.var("ginga.zip", "from-seqable");
    const__138 = (AFn)RT.map(new Object[] { RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(78), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__139 = (Var)RT.var("ginga.zip", "down-impl");
    const__143 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })), RT.keyword(null, "line"), Integer.valueOf(80), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__144 = (Var)RT.var("ginga.zip", "advance-subseqs");
    const__147 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "subseqs"), Symbol.intern(null, "v"), Symbol.intern(null, "prev-i"), Symbol.intern(null, "i")) })), RT.keyword(null, "line"), Integer.valueOf(242), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__148 = (Var)RT.var("ginga.zip", "finalize-subseqs");
    const__151 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "subseqs"), Symbol.intern(null, "v"), Symbol.intern(null, "prev-i"), Symbol.intern(null, "i")) })), RT.keyword(null, "line"), Integer.valueOf(246), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__154 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "v"), Symbol.intern(null, "parent")) })), RT.keyword(null, "line"), Integer.valueOf(345), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__157 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "coll"), Symbol.intern(null, "parent")) })), RT.keyword(null, "line"), Integer.valueOf(348), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__158 = (Var)RT.var("ginga.zip", "zipper");
    const__161 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "root")) })), RT.keyword(null, "line"), Integer.valueOf(351), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__162 = (Var)RT.var("ginga.zip", "traverser");
    const__165 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "root")) })), RT.keyword(null, "line"), Integer.valueOf(354), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__166 = (Var)RT.var("ginga.zip", "parent-node");
    const__169 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "The same as (-> z (up) (node))", RT.keyword(null, "line"), Integer.valueOf(359), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__170 = (Var)RT.var("ginga.zip", "next-node");
    const__173 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "The same as (-> z (next) (node))", RT.keyword(null, "line"), Integer.valueOf(364), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__174 = (Var)RT.var("ginga.zip", "down-end");
    const__177 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "The same as (-> z (down) (end))", RT.keyword(null, "line"), Integer.valueOf(369), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__178 = (Var)RT.var("ginga.zip", "insert-down");
    const__181 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })), RT.keyword(null, "doc"), "The same as (-> z (insert node) (down))", RT.keyword(null, "line"), Integer.valueOf(374), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__182 = (Var)RT.var("ginga.zip", "prev-replace-next");
    const__185 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })), RT.keyword(null, "doc"), "The same as (-> z (prev) (replace node) (next))", RT.keyword(null, "line"), Integer.valueOf(379), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__186 = (Var)RT.var("ginga.zip", "replace-down");
    const__189 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "node")) })), RT.keyword(null, "doc"), "The same as (-> z (replace node) (down))", RT.keyword(null, "line"), Integer.valueOf(384), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__190 = (Var)RT.var("ginga.zip", "edit");
    const__193 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "f")), Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "f"), Symbol.intern(null, "&"), Symbol.intern(null, "args")) })), RT.keyword(null, "doc"), "Call a function with the current node and replace it.", RT.keyword(null, "line"), Integer.valueOf(391), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__194 = (Var)RT.var("ginga.zip", "append-to-parent*");
    const__197 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "nodes")) })), RT.keyword(null, "doc"), "Insert many nodes at the end (append to current parent).", RT.keyword(null, "line"), Integer.valueOf(398), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__198 = (Var)RT.var("ginga.zip", "frames");
  }
  
  public static void __init2() {
    const__201 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Get the individual frames of the zipper {:keys [up nexts prevs]} as a\n  list ordered from deepest to top frame.", RT.keyword(null, "line"), Integer.valueOf(404), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__202 = (Var)RT.var("ginga.zip", "ancestor-nodes");
    const__205 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Returns all ancestor nodes of the current location.", RT.keyword(null, "line"), Integer.valueOf(410), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__206 = (Var)RT.var("ginga.zip", "shift-next-nodes-up");
    const__209 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Remove all `nexts`, traverse `up-next`, and insert the removed\n  `nexts`.", RT.keyword(null, "line"), Integer.valueOf(415), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__210 = (Var)RT.var("ginga.zip", "shift-next-nodes-down");
    const__213 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Remove all `nexts` and descend into `prev-node` with the removed\n  `nexts` appended.", RT.keyword(null, "line"), Integer.valueOf(425), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__214 = (Var)RT.var("ginga.zip", "split");
    const__217 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Splits the parent node in two, the prev-node receiving the prev-nodes, the\n  next-node the next-nodes, and returns the location between them.", RT.keyword(null, "line"), Integer.valueOf(436), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__218 = (Var)RT.var("ginga.zip", "unwrap-children-next");
    const__221 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Remove the current node and insert all children of the current node\n  before the current location.", RT.keyword(null, "line"), Integer.valueOf(448), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__222 = (Var)RT.var("ginga.zip", "unwrap-children-prev");
    const__225 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Like unwrap-children-prev, but inserts the children after the current\n  location.", RT.keyword(null, "line"), Integer.valueOf(456), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__226 = (Var)RT.var("ginga.zip", "unwrap");
    const__229 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Removes the current parent, putting its children in its place,\n  mainting the current location.", RT.keyword(null, "line"), Integer.valueOf(464), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__230 = (Var)RT.var("ginga.zip", "path");
    const__233 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Return a path from the top to the current location.", RT.keyword(null, "line"), Integer.valueOf(475), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__234 = (Var)RT.var("ginga.zip", "descend-path");
    const__237 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z"), Symbol.intern(null, "path")) })), RT.keyword(null, "doc"), "Walk down the given path.", RT.keyword(null, "line"), Integer.valueOf(480), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__238 = (Var)RT.var("ginga.zip", "top");
    const__241 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Walk to the topmost branch, or does nothing if already at the top.", RT.keyword(null, "line"), Integer.valueOf(488), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__242 = (Var)RT.var("ginga.zip", "walk");
    const__245 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "before"), Symbol.intern(null, "end"), Symbol.intern(null, "z")), Tuple.create(Symbol.intern(null, "stop?"), Symbol.intern(null, "before"), Symbol.intern(null, "end"), Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Walks the zipper recursively, applying `before` when before a node\n  and `end` when at the end of a branch. Stops when at the top of the\n  tree.\n\n  The following will just walk the entire tree without doing anything:\n  (walk down up-next z)\n\n  The optional stop? predicate will be applied to the zipper before\n  either before or end are called, and if true, will stop the walk\n  immediately.", RT.keyword(null, "line"), Integer.valueOf(493), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
    const__246 = (Var)RT.var("ginga.zip", "contextual-walk");
    const__249 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "before"), Symbol.intern(null, "end"), Symbol.intern(null, "init"), Symbol.intern(null, "z")), Tuple.create(Symbol.intern(null, "stop?"), Symbol.intern(null, "before"), Symbol.intern(null, "end"), Symbol.intern(null, "init"), Symbol.intern(null, "z")) })), RT.keyword(null, "doc"), "Like walk, but with a context that is given-to/returned-by both\n  before and end as the first argument.", RT.keyword(null, "line"), Integer.valueOf(516), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "ginga/zip.cljc" });
  }
  
  static  {
    __init0();
    __init1();
    __init2();
    Compiler.pushNSandLoader(RT.classForName("ginga.zip__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
