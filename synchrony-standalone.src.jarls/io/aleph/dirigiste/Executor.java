package io.aleph.dirigiste;

import java.util.ArrayList;
import java.util.EnumSet;
import java.util.List;
import java.util.concurrent.AbstractExecutorService;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

public class Executor extends AbstractExecutorService {
  private static AtomicInteger _numExecutors = new AtomicInteger(0);
  
  private final ThreadFactory _threadFactory;
  
  private final BlockingQueue _queue;
  
  private final CopyOnWriteArrayList<Worker> _workers;
  
  private final AtomicInteger _numWorkers;
  
  private final AtomicInteger _incomingTasks;
  
  private final AtomicInteger _rejectedTasks;
  
  private final Controller _controller;
  
  private final EnumSet _metrics;
  
  private final boolean _measureQueueLatency;
  
  private final boolean _measureTaskLatency;
  
  private final boolean _measureTaskArrivalRate;
  
  private final boolean _measureTaskRejectionRate;
  
  private boolean _isShutdown;
  
  private final AtomicReference<Stats.UniformLongReservoir> _queueLatencies;
  
  private final AtomicReference<Stats.UniformLongReservoir> _taskLatencies;
  
  private final AtomicReference<Stats.UniformLongReservoir> _queueLengths;
  
  private final AtomicReference<Stats.UniformDoubleReservoir> _utilizations;
  
  private final AtomicReference<Stats.UniformDoubleReservoir> _taskArrivalRates;
  
  private final AtomicReference<Stats.UniformDoubleReservoir> _taskCompletionRates;
  
  private final AtomicReference<Stats.UniformDoubleReservoir> _taskRejectionRates;
  
  public Executor(ThreadFactory paramThreadFactory, BlockingQueue paramBlockingQueue, Controller paramController, int paramInt, EnumSet<Stats.Metric> paramEnumSet, long paramLong1, long paramLong2, TimeUnit paramTimeUnit) {
    this._workers = new CopyOnWriteArrayList();
    this._numWorkers = new AtomicInteger(0);
    this._incomingTasks = new AtomicInteger(0);
    this._rejectedTasks = new AtomicInteger(0);
    this._isShutdown = false;
    this._queueLatencies = new AtomicReference(new Stats.UniformLongReservoir());
    this._taskLatencies = new AtomicReference(new Stats.UniformLongReservoir());
    this._queueLengths = new AtomicReference(new Stats.UniformLongReservoir());
    this._utilizations = new AtomicReference(new Stats.UniformDoubleReservoir());
    this._taskArrivalRates = new AtomicReference(new Stats.UniformDoubleReservoir());
    this._taskCompletionRates = new AtomicReference(new Stats.UniformDoubleReservoir());
    this._taskRejectionRates = new AtomicReference(new Stats.UniformDoubleReservoir());
    this._stats = Stats.EMPTY;
    this._threadFactory = paramThreadFactory;
    this._queue = paramBlockingQueue;
    this._controller = paramController;
    this._metrics = paramEnumSet;
    this._measureQueueLatency = this._metrics.contains(Stats.Metric.QUEUE_LATENCY);
    this._measureTaskLatency = this._metrics.contains(Stats.Metric.TASK_LATENCY);
    this._measureTaskArrivalRate = this._metrics.contains(Stats.Metric.TASK_ARRIVAL_RATE);
    this._measureTaskRejectionRate = this._metrics.contains(Stats.Metric.TASK_REJECTION_RATE);
    int i = (int)paramTimeUnit.toMillis(paramLong1);
    int j = (int)(paramLong2 / paramLong1);
    Thread thread = new Thread(new Object(this, i, j), "dirigiste-executor-controller-" + _numExecutors.getAndIncrement());
    thread.setDaemon(true);
    thread.start();
    for (byte b = 0; b < Math.max(1, paramInt); b++)
      startWorker(); 
  }
  
  public EnumSet<Stats.Metric> getMetrics() { return this._metrics; }
  
  public Stats getLastStats() { return this._stats; }
  
  public Stats getStats() {
    return new Stats(this._metrics, this._numWorkers
        
        .get(), ((Stats.UniformDoubleReservoir)this._utilizations
        .get()).toArray(), ((Stats.UniformDoubleReservoir)this._taskArrivalRates
        .get()).toArray(), ((Stats.UniformDoubleReservoir)this._taskCompletionRates
        .get()).toArray(), ((Stats.UniformDoubleReservoir)this._taskRejectionRates
        .get()).toArray(), ((Stats.UniformLongReservoir)this._queueLengths
        .get()).toArray(), ((Stats.UniformLongReservoir)this._queueLatencies
        .get()).toArray(), ((Stats.UniformLongReservoir)this._taskLatencies
        .get()).toArray());
  }
  
  public boolean awaitTermination(long paramLong, TimeUnit paramTimeUnit) throws InterruptedException {
    long l1 = paramTimeUnit.toMillis(paramLong);
    long l2 = System.currentTimeMillis();
    for (Worker worker : this._workers) {
      long l = l2 + l1 - System.currentTimeMillis();
      if (l < 0L)
        return false; 
      if (!Worker.access$700(worker).await(l, TimeUnit.MILLISECONDS))
        return false; 
    } 
    return true;
  }
  
  public void executeWithoutRejection(Runnable paramRunnable) throws NullPointerException, InterruptedException {
    Object object;
    if (paramRunnable == null)
      throw new NullPointerException(); 
    if (this._isShutdown)
      throw new RejectedExecutionException("Executor is shutdown!"); 
    if (this._measureTaskArrivalRate)
      this._incomingTasks.incrementAndGet(); 
    if (this._measureTaskLatency || this._measureQueueLatency) {
      long l = System.nanoTime();
      Runnable runnable = paramRunnable;
      object = new Object(this, l, runnable);
    } 
    if (!this._queue.offer(object) || this._workers.isEmpty()) {
      startWorker();
      this._queue.put(object);
    } 
  }
  
  public void execute(Runnable paramRunnable) throws NullPointerException, InterruptedException {
    Object object;
    if (paramRunnable == null)
      throw new NullPointerException(); 
    if (this._isShutdown)
      throw new RejectedExecutionException("Executor is shutdown!"); 
    if (this._measureTaskArrivalRate)
      this._incomingTasks.incrementAndGet(); 
    if (this._measureTaskLatency || this._measureQueueLatency) {
      long l = System.nanoTime();
      Runnable runnable = paramRunnable;
      object = new Object(this, l, runnable);
    } 
    if (!this._queue.offer(object) || this._workers.isEmpty())
      if (startWorker()) {
        try {
          this._queue.put(object);
        } catch (InterruptedException interruptedException) {
          if (this._measureTaskRejectionRate)
            this._rejectedTasks.incrementAndGet(); 
          throw new RejectedExecutionException();
        } 
      } else {
        if (this._measureTaskRejectionRate)
          this._rejectedTasks.incrementAndGet(); 
        throw new RejectedExecutionException();
      }  
  }
  
  public boolean isShutdown() { return this._isShutdown; }
  
  public boolean isTerminated() { return (this._isShutdown && this._workers.isEmpty()); }
  
  public void shutdown() {
    synchronized (this) {
      this._isShutdown = true;
      for (Worker worker : this._workers)
        worker.shutdown(); 
    } 
  }
  
  public List<Runnable> shutdownNow() {
    synchronized (this) {
      this._isShutdown = true;
      ArrayList arrayList = new ArrayList();
      this._queue.drainTo(arrayList);
      for (Worker worker : this._workers) {
        Runnable runnable = worker._runnable;
        worker.shutdown();
        Worker.access$1500(worker).interrupt();
        if (runnable != null)
          arrayList.add(runnable); 
      } 
      return arrayList;
    } 
  }
  
  private Stats updateStats() {
    return new Stats(this._metrics, this._numWorkers
        
        .get(), ((Stats.UniformDoubleReservoir)this._utilizations
        .getAndSet(new Stats.UniformDoubleReservoir())).toArray(), ((Stats.UniformDoubleReservoir)this._taskArrivalRates
        .getAndSet(new Stats.UniformDoubleReservoir())).toArray(), ((Stats.UniformDoubleReservoir)this._taskCompletionRates
        .getAndSet(new Stats.UniformDoubleReservoir())).toArray(), ((Stats.UniformDoubleReservoir)this._taskRejectionRates
        .getAndSet(new Stats.UniformDoubleReservoir())).toArray(), ((Stats.UniformLongReservoir)this._queueLengths
        .getAndSet(new Stats.UniformLongReservoir())).toArray(), ((Stats.UniformLongReservoir)this._queueLatencies
        .getAndSet(new Stats.UniformLongReservoir())).toArray(), ((Stats.UniformLongReservoir)this._taskLatencies
        .getAndSet(new Stats.UniformLongReservoir())).toArray());
  }
  
  private boolean startWorker() {
    int i;
    do {
      i = this._numWorkers.get();
      if (!this._controller.shouldIncrement(i))
        return false; 
    } while (!this._numWorkers.compareAndSet(i, i + 1));
    this._workers.add(new Worker(this));
    return true;
  }
  
  private void startControlLoop(int paramInt1, int paramInt2) {
    boolean bool1 = this._metrics.contains(Stats.Metric.UTILIZATION);
    boolean bool2 = this._metrics.contains(Stats.Metric.TASK_ARRIVAL_RATE);
    boolean bool3 = this._metrics.contains(Stats.Metric.TASK_COMPLETION_RATE);
    boolean bool4 = this._metrics.contains(Stats.Metric.TASK_REJECTION_RATE);
    boolean bool5 = this._metrics.contains(Stats.Metric.QUEUE_LENGTH);
    double d = 1000.0D / paramInt1;
    int i = 0;
    long l = 0L;
    try {
      while (!this._isShutdown) {
        i = (i + true) % paramInt2;
        long l1 = System.currentTimeMillis();
        if (bool5)
          ((Stats.UniformLongReservoir)this._queueLengths.get()).sample(this._queue.size()); 
        if (bool2)
          ((Stats.UniformDoubleReservoir)this._taskArrivalRates.get()).sample(this._incomingTasks.getAndSet(0) * d); 
        if (bool4)
          ((Stats.UniformDoubleReservoir)this._taskRejectionRates.get()).sample(this._rejectedTasks.getAndSet(0) * d); 
        int j = 0;
        byte b = 0;
        double d1 = 0.0D;
        long l2 = 0L;
        if (bool1)
          l2 = System.nanoTime(); 
        for (Worker worker : this._workers) {
          if (worker.isShutdown())
            continue; 
          if (bool1) {
            b++;
            d1 += worker.utilization(l, l2);
          } 
          if (bool3)
            j += Worker.access$500(worker).getAndSet(0); 
        } 
        if (bool1) {
          l = l2;
          ((Stats.UniformDoubleReservoir)this._utilizations.get()).sample(d1 / b);
        } 
        if (bool3)
          ((Stats.UniformDoubleReservoir)this._taskCompletionRates.get()).sample(j * d); 
        if (i == 0) {
          this._stats = updateStats();
          int k = this._controller.adjustment(this._stats);
          synchronized (this) {
            if (this._isShutdown)
              break; 
            if (k < 0 && this._queue.size() == 0) {
              k = Math.min(-k, this._numWorkers.get() - 1);
              for (Worker worker : this._workers) {
                if (k == 0)
                  break; 
                if (worker.shutdown())
                  k--; 
              } 
            } else if (k > 0) {
              for (byte b1 = 0; b1 < k && 
                startWorker(); b1++);
            } 
          } 
        } 
        Thread.sleep(Math.max(0L, paramInt1 - System.currentTimeMillis() - l1));
      } 
    } catch (InterruptedException interruptedException) {}
  }
}
