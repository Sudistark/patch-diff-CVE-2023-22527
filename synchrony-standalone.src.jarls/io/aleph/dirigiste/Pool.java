package io.aleph.dirigiste;

import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.ReentrantLock;

public class Pool<K, V> extends Object implements IPool<K, V> {
  private static AtomicInteger _numPools = new AtomicInteger(0);
  
  private final int _maxQueueSize;
  
  private final IPool.Generator<K, V> _generator;
  
  private final IPool.Controller<K> _controller;
  
  private final double _rateMultiplier;
  
  private final AtomicInteger _numObjects;
  
  private final ReentrantLock _lock;
  
  private final Set<V> _destroyedObjects;
  
  private final ConcurrentHashMap<V, Long> _start;
  
  final ConcurrentHashMap<K, Queue> _queues;
  
  private final ConcurrentHashMap<K, Integer> _queueLockCount;
  
  private final Stats.UniformLongReservoirMap<K> _queueLatencies;
  
  private final Stats.UniformLongReservoirMap<K> _taskLatencies;
  
  private final Stats.UniformLongReservoirMap<K> _queueLengths;
  
  private final Stats.UniformDoubleReservoirMap<K> _utilizations;
  
  private final Stats.UniformDoubleReservoirMap<K> _taskArrivalRates;
  
  private final Stats.UniformDoubleReservoirMap<K> _taskCompletionRates;
  
  private final Stats.UniformDoubleReservoirMap<K> _taskRejectionRates;
  
  Queue queue(K paramK) {
    Queue queue = (Queue)this._queues.get(paramK);
    if (queue == null) {
      queue = new Queue(this, paramK, this._maxQueueSize);
      Queue queue1 = (Queue)this._queues.putIfAbsent(paramK, queue);
      return (queue1 == null) ? queue : queue1;
    } 
    return queue;
  }
  
  private Map<K, Stats> updateStats() {
    Map map1 = this._queueLatencies.toMap();
    Map map2 = this._taskLatencies.toMap();
    Map map3 = this._queueLengths.toMap();
    Map map4 = this._utilizations.toMap();
    Map map5 = this._taskArrivalRates.toMap();
    Map map6 = this._taskCompletionRates.toMap();
    Map map7 = this._taskRejectionRates.toMap();
    HashMap hashMap = new HashMap();
    for (Object object : this._queues.keySet())
      hashMap.put(object, new Stats(
            EnumSet.allOf(Stats.Metric.class), 
            (queue(object)).objects.get(), (double[])map4
            .get(object), (double[])map5
            .get(object), (double[])map6
            .get(object), (double[])map7
            .get(object), (long[])map3
            .get(object), (long[])map1
            .get(object), (long[])map2
            .get(object))); 
    return hashMap;
  }
  
  private void addObject(K paramK) {
    Queue queue = queue(paramK);
    this._lock.lock();
    if (this._controller.shouldIncrement(paramK, queue.objects.get(), this._numObjects.get())) {
      this._numObjects.incrementAndGet();
      queue.objects.incrementAndGet();
      this._lock.unlock();
      try {
        Queue.access$400(queue, this._generator.generate(paramK));
      } catch (Exception exception) {
        this._numObjects.decrementAndGet();
        queue.objects.decrementAndGet();
        throw new RuntimeException(exception);
      } 
    } else {
      this._lock.unlock();
    } 
  }
  
  double getUtilization(int paramInt1, int paramInt2, int paramInt3) {
    if (paramInt3 == 0 && paramInt2 == 0)
      return 0.0D; 
    return 1.0D - (paramInt1 - paramInt2) / Math.max(1.0D, paramInt3);
  }
  
  private void adjust() {
    sample();
    Map map1 = updateStats();
    Map map2 = this._controller.adjustment(map1);
    for (Iterator iterator = map1.entrySet().iterator(); iterator.hasNext(); ) {
      Map.Entry entry = (Map.Entry)iterator.next();
      Object object = entry.getKey();
      if (((Stats)entry.getValue()).getUtilization(1.0D) == 0.0D && ((Queue)this._queues
        .get(object)).objects.get() == 0 && ((Integer)this._queueLockCount
        .getOrDefault(object, Integer.valueOf(0))).intValue() == 0)
        this._queueLockCount.compute(object, (paramObject2, paramInteger) -> {
              if (paramInteger == null || paramInteger.intValue() == 0) {
                ((Queue)this._queues.remove(paramObject1)).shutdown();
                this._queueLatencies.remove(paramObject1);
                this._taskLatencies.remove(paramObject1);
                this._queueLengths.remove(paramObject1);
                this._utilizations.remove(paramObject1);
                this._taskArrivalRates.remove(paramObject1);
                this._taskCompletionRates.remove(paramObject1);
                this._taskRejectionRates.remove(paramObject1);
                return null;
              } 
              return paramInteger;
            }); 
    } 
    ArrayList arrayList = new ArrayList();
    for (Map.Entry entry : map2.entrySet()) {
      int i = ((Integer)entry.getValue()).intValue();
      if (i < 0) {
        Queue queue = queue(entry.getKey());
        for (byte b = 0; b < -i; b++)
          queue.drop(); 
        queue.cleanup();
        continue;
      } 
      if (i > 1)
        for (byte b = 0; b < i; b++)
          arrayList.add(entry.getKey());  
    } 
    Collections.shuffle(arrayList);
    for (Object object : arrayList)
      addObject(object); 
  }
  
  private void sample() {
    for (Map.Entry entry : this._queues.entrySet()) {
      Object object = entry.getKey();
      Queue queue = (Queue)entry.getValue();
      long l1 = queue.completed.getAndSet(0L);
      long l2 = queue.incoming.getAndSet(0L);
      long l3 = queue.rejected.getAndSet(0L);
      int i = queue.objects.get();
      int j = queue.getQueueLength();
      int k = queue.availableObjectsCount();
      double d = getUtilization(k, j, i);
      this._queueLengths.sample(object, j);
      this._utilizations.sample(object, d);
      this._taskArrivalRates.sample(object, l2 * this._rateMultiplier);
      this._taskCompletionRates.sample(object, l1 * this._rateMultiplier);
      this._taskRejectionRates.sample(object, l3 * this._rateMultiplier);
    } 
  }
  
  private void startControlLoop(int paramInt1, int paramInt2) {
    int i = 0;
    try {
      while (!this._isShutdown) {
        i = (i + true) % paramInt2;
        boolean bool = (i == 0) ? 1 : 0;
        long l = System.currentTimeMillis();
        if (!bool)
          sample(); 
        if (this._isShutdown)
          break; 
        if (bool)
          adjust(); 
        Thread.sleep(Math.max(0L, paramInt1 - System.currentTimeMillis() - l));
      } 
    } catch (InterruptedException interruptedException) {}
  }
  
  public Pool(IPool.Generator<K, V> paramGenerator, IPool.Controller<K> paramController, int paramInt, long paramLong1, long paramLong2, TimeUnit paramTimeUnit) {
    this._isShutdown = false;
    this._numObjects = new AtomicInteger(0);
    this._lock = new ReentrantLock();
    this._destroyedObjects = Collections.synchronizedSet(Collections.newSetFromMap(new WeakHashMap()));
    this._start = new ConcurrentHashMap();
    this._queues = new ConcurrentHashMap();
    this._queueLockCount = new ConcurrentHashMap();
    this._queueLatencies = new Stats.UniformLongReservoirMap();
    this._taskLatencies = new Stats.UniformLongReservoirMap();
    this._queueLengths = new Stats.UniformLongReservoirMap();
    this._utilizations = new Stats.UniformDoubleReservoirMap();
    this._taskArrivalRates = new Stats.UniformDoubleReservoirMap();
    this._taskCompletionRates = new Stats.UniformDoubleReservoirMap();
    this._taskRejectionRates = new Stats.UniformDoubleReservoirMap();
    this._generator = paramGenerator;
    this._controller = paramController;
    this._maxQueueSize = paramInt;
    int i = (int)paramTimeUnit.toMillis(paramLong1);
    int j = (int)(paramLong2 / paramLong1);
    this._rateMultiplier = paramTimeUnit.toMillis(1000L) / i;
    Thread thread = new Thread(() -> startControlLoop(paramInt1, paramInt2), "dirigiste-pool-controller-" + _numPools.getAndIncrement());
    thread.setDaemon(true);
    thread.start();
  }
  
  public void acquire(K paramK, IPool.AcquireCallback<V> paramAcquireCallback) {
    long l = System.nanoTime();
    this._queueLockCount.compute(paramK, (paramObject, paramInteger) -> Integer.valueOf((paramInteger == null) ? 1 : (paramInteger.intValue() + 1)));
    Queue queue = queue(paramK);
    IPool.AcquireCallback acquireCallback = paramObject2 -> {
        long l = System.nanoTime();
        this._queueLatencies.sample(paramObject1, l - paramLong);
        this._start.put(paramObject2, Long.valueOf(paramLong));
        paramAcquireCallback.handleObject(paramObject2);
      };
    boolean bool = queue.take(acquireCallback, false);
    if (!bool)
      try {
        addObject(paramK);
      } catch (Throwable throwable) {
        queue.cancelTake(acquireCallback);
        this._queueLockCount.compute(paramK, (paramObject, paramInteger) -> Integer.valueOf(paramInteger.intValue() - 1));
        throw new RuntimeException(throwable);
      }  
  }
  
  public V acquire(K paramK) throws InterruptedException {
    AtomicReference atomicReference = new AtomicReference(null);
    CountDownLatch countDownLatch = new CountDownLatch(1);
    acquire(paramK, paramObject -> {
          paramAtomicReference.set(paramObject);
          paramCountDownLatch.countDown();
        });
    countDownLatch.await();
    return (V)atomicReference.get();
  }
  
  public void release(K paramK, V paramV) {
    long l = System.nanoTime();
    Long long = (Long)this._start.remove(paramV);
    if (long != null) {
      this._taskLatencies.sample(paramK, l - long.longValue());
      queue(paramK).release(paramV);
      this._queueLockCount.compute(paramK, (paramObject, paramInteger) -> Integer.valueOf(paramInteger.intValue() - 1));
    } 
  }
  
  public void dispose(K paramK, V paramV) {
    Queue queue = queue(paramK);
    this._lock.lock();
    this._destroyedObjects.add(paramV);
    int i = Queue.access$500(queue).size();
    Long long = (Long)this._start.remove(paramV);
    this._lock.unlock();
    if (long != null) {
      Queue.access$400(queue, paramV);
    } else {
      queue.cleanup();
    } 
    if (i > 0)
      addObject(paramK); 
    this._queueLockCount.compute(paramK, (paramObject, paramInteger) -> Integer.valueOf(paramInteger.intValue() - 1));
  }
  
  public void shutdown() {
    this._isShutdown = true;
    for (Map.Entry entry : this._queues.entrySet())
      ((Queue)entry.getValue()).shutdown(); 
  }
}
