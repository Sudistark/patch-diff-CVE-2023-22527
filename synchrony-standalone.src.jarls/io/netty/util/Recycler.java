package io.netty.util;

import io.netty.util.concurrent.FastThreadLocal;
import io.netty.util.internal.SystemPropertyUtil;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import org.jetbrains.annotations.VisibleForTesting;

public abstract class Recycler<T> extends Object {
  private static final InternalLogger logger = InternalLoggerFactory.getInstance(Recycler.class);
  
  private static final EnhancedHandle<?> NOOP_HANDLE = new Object();
  
  private static final int DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD = 4096;
  
  private static final int DEFAULT_MAX_CAPACITY_PER_THREAD;
  
  private static final int RATIO;
  
  private static final int DEFAULT_QUEUE_CHUNK_SIZE_PER_THREAD;
  
  private static final boolean BLOCKING_POOL;
  
  private static final boolean BATCH_FAST_TL_ONLY;
  
  private final int maxCapacityPerThread;
  
  private final int interval;
  
  private final int chunkSize;
  
  private final FastThreadLocal<LocalPool<T>> threadLocal;
  
  static  {
    maxCapacityPerThread = SystemPropertyUtil.getInt("io.netty.recycler.maxCapacityPerThread", 
        SystemPropertyUtil.getInt("io.netty.recycler.maxCapacity", 4096));
    if (maxCapacityPerThread < 0)
      maxCapacityPerThread = 4096; 
    DEFAULT_MAX_CAPACITY_PER_THREAD = maxCapacityPerThread;
    DEFAULT_QUEUE_CHUNK_SIZE_PER_THREAD = SystemPropertyUtil.getInt("io.netty.recycler.chunkSize", 32);
    RATIO = Math.max(0, SystemPropertyUtil.getInt("io.netty.recycler.ratio", 8));
    BLOCKING_POOL = SystemPropertyUtil.getBoolean("io.netty.recycler.blocking", false);
    BATCH_FAST_TL_ONLY = SystemPropertyUtil.getBoolean("io.netty.recycler.batchFastThreadLocalOnly", true);
    if (logger.isDebugEnabled())
      if (DEFAULT_MAX_CAPACITY_PER_THREAD == 0) {
        logger.debug("-Dio.netty.recycler.maxCapacityPerThread: disabled");
        logger.debug("-Dio.netty.recycler.ratio: disabled");
        logger.debug("-Dio.netty.recycler.chunkSize: disabled");
        logger.debug("-Dio.netty.recycler.blocking: disabled");
        logger.debug("-Dio.netty.recycler.batchFastThreadLocalOnly: disabled");
      } else {
        logger.debug("-Dio.netty.recycler.maxCapacityPerThread: {}", Integer.valueOf(DEFAULT_MAX_CAPACITY_PER_THREAD));
        logger.debug("-Dio.netty.recycler.ratio: {}", Integer.valueOf(RATIO));
        logger.debug("-Dio.netty.recycler.chunkSize: {}", Integer.valueOf(DEFAULT_QUEUE_CHUNK_SIZE_PER_THREAD));
        logger.debug("-Dio.netty.recycler.blocking: {}", Boolean.valueOf(BLOCKING_POOL));
        logger.debug("-Dio.netty.recycler.batchFastThreadLocalOnly: {}", Boolean.valueOf(BATCH_FAST_TL_ONLY));
      }  
  }
  
  protected Recycler() { this(DEFAULT_MAX_CAPACITY_PER_THREAD); }
  
  protected Recycler(int maxCapacityPerThread) { this(maxCapacityPerThread, RATIO, DEFAULT_QUEUE_CHUNK_SIZE_PER_THREAD); }
  
  @Deprecated
  protected Recycler(int maxCapacityPerThread, int maxSharedCapacityFactor) { this(maxCapacityPerThread, RATIO, DEFAULT_QUEUE_CHUNK_SIZE_PER_THREAD); }
  
  @Deprecated
  protected Recycler(int maxCapacityPerThread, int maxSharedCapacityFactor, int ratio, int maxDelayedQueuesPerThread) { this(maxCapacityPerThread, ratio, DEFAULT_QUEUE_CHUNK_SIZE_PER_THREAD); }
  
  @Deprecated
  protected Recycler(int maxCapacityPerThread, int maxSharedCapacityFactor, int ratio, int maxDelayedQueuesPerThread, int delayedQueueRatio) { this(maxCapacityPerThread, ratio, DEFAULT_QUEUE_CHUNK_SIZE_PER_THREAD); }
  
  protected Recycler(int maxCapacityPerThread, int ratio, int chunkSize) {
    this.threadLocal = new Object(this);
    this.interval = Math.max(0, ratio);
    if (maxCapacityPerThread <= 0) {
      this.maxCapacityPerThread = 0;
      this.chunkSize = 0;
    } else {
      this.maxCapacityPerThread = Math.max(4, maxCapacityPerThread);
      this.chunkSize = Math.max(2, Math.min(chunkSize, this.maxCapacityPerThread >> 1));
    } 
  }
  
  public final T get() {
    T obj;
    if (this.maxCapacityPerThread == 0)
      return (T)newObject(NOOP_HANDLE); 
    LocalPool<T> localPool = (LocalPool)this.threadLocal.get();
    DefaultHandle<T> handle = localPool.claim();
    if (handle == null) {
      handle = localPool.newHandle();
      if (handle != null) {
        obj = (T)newObject(handle);
        handle.set(obj);
      } else {
        obj = (T)newObject(NOOP_HANDLE);
      } 
    } else {
      obj = (T)handle.get();
    } 
    return obj;
  }
  
  @Deprecated
  public final boolean recycle(T o, Handle<T> handle) {
    if (handle == NOOP_HANDLE)
      return false; 
    handle.recycle(o);
    return true;
  }
  
  @VisibleForTesting
  final int threadLocalSize() {
    LocalPool<T> localPool = (LocalPool)this.threadLocal.getIfExists();
    return (localPool == null) ? 0 : (LocalPool.access$400(localPool).size() + LocalPool.access$600(localPool).size());
  }
  
  protected abstract T newObject(Handle<T> paramHandle);
}
