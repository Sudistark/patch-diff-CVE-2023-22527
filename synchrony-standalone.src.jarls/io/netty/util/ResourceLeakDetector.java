package io.netty.util;

import io.netty.util.internal.EmptyArrays;
import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.PlatformDependent;
import io.netty.util.internal.StringUtil;
import io.netty.util.internal.SystemPropertyUtil;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import java.lang.ref.ReferenceQueue;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicReference;

public class ResourceLeakDetector<T> extends Object {
  private static final String PROP_LEVEL_OLD = "io.netty.leakDetectionLevel";
  
  private static final String PROP_LEVEL = "io.netty.leakDetection.level";
  
  private static final Level DEFAULT_LEVEL = Level.SIMPLE;
  
  private static final String PROP_TARGET_RECORDS = "io.netty.leakDetection.targetRecords";
  
  private static final int DEFAULT_TARGET_RECORDS = 4;
  
  private static final String PROP_SAMPLING_INTERVAL = "io.netty.leakDetection.samplingInterval";
  
  private static final int DEFAULT_SAMPLING_INTERVAL = 128;
  
  private static final int TARGET_RECORDS;
  
  static final int SAMPLING_INTERVAL;
  
  private static Level level;
  
  private static final InternalLogger logger = InternalLoggerFactory.getInstance(ResourceLeakDetector.class);
  
  private final Set<DefaultResourceLeak<?>> allLeaks;
  
  private final ReferenceQueue<Object> refQueue;
  
  private final Set<String> reportedLeaks;
  
  private final String resourceType;
  
  private final int samplingInterval;
  
  private static final AtomicReference<String[]> excludedMethods;
  
  static  {
    if (SystemPropertyUtil.get("io.netty.noResourceLeakDetection") != null) {
      disabled = SystemPropertyUtil.getBoolean("io.netty.noResourceLeakDetection", false);
      logger.debug("-Dio.netty.noResourceLeakDetection: {}", Boolean.valueOf(disabled));
      logger.warn("-Dio.netty.noResourceLeakDetection is deprecated. Use '-D{}={}' instead.", "io.netty.leakDetection.level", Level.DISABLED
          
          .name().toLowerCase());
    } else {
      disabled = false;
    } 
    Level defaultLevel = disabled ? Level.DISABLED : DEFAULT_LEVEL;
    String levelStr = SystemPropertyUtil.get("io.netty.leakDetectionLevel", defaultLevel.name());
    levelStr = SystemPropertyUtil.get("io.netty.leakDetection.level", levelStr);
    Level level = Level.parseLevel(levelStr);
    TARGET_RECORDS = SystemPropertyUtil.getInt("io.netty.leakDetection.targetRecords", 4);
    SAMPLING_INTERVAL = SystemPropertyUtil.getInt("io.netty.leakDetection.samplingInterval", 128);
    ResourceLeakDetector.level = level;
    if (logger.isDebugEnabled()) {
      logger.debug("-D{}: {}", "io.netty.leakDetection.level", level.name().toLowerCase());
      logger.debug("-D{}: {}", "io.netty.leakDetection.targetRecords", Integer.valueOf(TARGET_RECORDS));
    } 
    excludedMethods = new AtomicReference(EmptyArrays.EMPTY_STRINGS);
  }
  
  @Deprecated
  public static void setEnabled(boolean enabled) { setLevel(enabled ? Level.SIMPLE : Level.DISABLED); }
  
  public static boolean isEnabled() { return (getLevel().ordinal() > Level.DISABLED.ordinal()); }
  
  public static void setLevel(Level level) { ResourceLeakDetector.level = (Level)ObjectUtil.checkNotNull(level, "level"); }
  
  public static Level getLevel() { return level; }
  
  @Deprecated
  public ResourceLeakDetector(Class<?> resourceType) { this(StringUtil.simpleClassName(resourceType)); }
  
  @Deprecated
  public ResourceLeakDetector(String resourceType) { this(resourceType, 128, Float.MAX_VALUE); }
  
  @Deprecated
  public ResourceLeakDetector(Class<?> resourceType, int samplingInterval, long maxActive) { this(resourceType, samplingInterval); }
  
  public ResourceLeakDetector(Class<?> resourceType, int samplingInterval) { this(StringUtil.simpleClassName(resourceType), samplingInterval, Float.MAX_VALUE); }
  
  @Deprecated
  public ResourceLeakDetector(String resourceType, int samplingInterval, long maxActive) {
    this.allLeaks = Collections.newSetFromMap(new ConcurrentHashMap());
    this.refQueue = new ReferenceQueue();
    this.reportedLeaks = Collections.newSetFromMap(new ConcurrentHashMap());
    this.resourceType = (String)ObjectUtil.checkNotNull(resourceType, "resourceType");
    this.samplingInterval = samplingInterval;
  }
  
  @Deprecated
  public final ResourceLeak open(T obj) { return track0(obj, false); }
  
  public final ResourceLeakTracker<T> track(T obj) { return track0(obj, false); }
  
  public ResourceLeakTracker<T> trackForcibly(T obj) { return track0(obj, true); }
  
  private DefaultResourceLeak track0(T obj, boolean force) {
    Level level = ResourceLeakDetector.level;
    if (!force && level != Level.PARANOID) {
      if (level != Level.DISABLED)
        if (PlatformDependent.threadLocalRandom().nextInt(this.samplingInterval) == 0) {
          reportLeak();
          return new DefaultResourceLeak(obj, this.refQueue, this.allLeaks, getInitialHint(this.resourceType));
        }  
    } else {
      reportLeak();
      return new DefaultResourceLeak(obj, this.refQueue, this.allLeaks, getInitialHint(this.resourceType));
    } 
    return null;
  }
  
  private void clearRefQueue() {
    while (true) {
      DefaultResourceLeak ref = (DefaultResourceLeak)this.refQueue.poll();
      if (ref == null)
        break; 
      ref.dispose();
    } 
  }
  
  protected boolean needReport() { return logger.isErrorEnabled(); }
  
  private void reportLeak() {
    if (!needReport()) {
      clearRefQueue();
      return;
    } 
    while (true) {
      DefaultResourceLeak ref = (DefaultResourceLeak)this.refQueue.poll();
      if (ref == null)
        break; 
      if (!ref.dispose())
        continue; 
      String records = ref.getReportAndClearRecords();
      if (this.reportedLeaks.add(records)) {
        if (records.isEmpty()) {
          reportUntracedLeak(this.resourceType);
        } else {
          reportTracedLeak(this.resourceType, records);
        } 
        LeakListener listener = this.leakListener;
        if (listener != null)
          listener.onLeak(this.resourceType, records); 
      } 
    } 
  }
  
  protected void reportTracedLeak(String resourceType, String records) { logger.error("LEAK: {}.release() was not called before it's garbage-collected. See https://netty.io/wiki/reference-counted-objects.html for more information.{}", resourceType, records); }
  
  protected void reportUntracedLeak(String resourceType) {
    logger.error("LEAK: {}.release() was not called before it's garbage-collected. Enable advanced leak reporting to find out where the leak occurred. To enable advanced leak reporting, specify the JVM option '-D{}={}' or call {}.setLevel() See https://netty.io/wiki/reference-counted-objects.html for more information.", new Object[] { resourceType, "io.netty.leakDetection.level", Level.ADVANCED.name().toLowerCase(), StringUtil.simpleClassName(this) });
  }
  
  @Deprecated
  protected void reportInstancesLeak(String resourceType) {}
  
  protected Object getInitialHint(String resourceType) { return null; }
  
  public void setLeakListener(LeakListener leakListener) { this.leakListener = leakListener; }
  
  public static void addExclusions(Class clz, String... methodNames) {
    String[] newMethods, oldMethods;
    Set<String> nameSet = new HashSet<String>(Arrays.asList(methodNames));
    for (Method method : clz.getDeclaredMethods()) {
      if (nameSet.remove(method.getName()) && nameSet.isEmpty())
        break; 
    } 
    if (!nameSet.isEmpty())
      throw new IllegalArgumentException("Can't find '" + nameSet + "' in " + clz.getName()); 
    do {
      oldMethods = (String[])excludedMethods.get();
      newMethods = (String[])Arrays.copyOf(oldMethods, oldMethods.length + 2 * methodNames.length);
      for (int i = 0; i < methodNames.length; i++) {
        newMethods[oldMethods.length + i * 2] = clz.getName();
        newMethods[oldMethods.length + i * 2 + 1] = methodNames[i];
      } 
    } while (!excludedMethods.compareAndSet(oldMethods, newMethods));
  }
}
