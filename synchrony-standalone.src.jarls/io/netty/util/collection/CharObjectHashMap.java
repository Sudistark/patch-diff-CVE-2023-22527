package io.netty.util.collection;

import io.netty.util.internal.MathUtil;
import java.util.Arrays;
import java.util.Collection;
import java.util.Map;
import java.util.Set;

public class CharObjectHashMap<V> extends Object implements CharObjectMap<V> {
  public static final int DEFAULT_CAPACITY = 8;
  
  public static final float DEFAULT_LOAD_FACTOR = 0.5F;
  
  private static final Object NULL_VALUE = new Object();
  
  private int maxSize;
  
  private final float loadFactor;
  
  private char[] keys;
  
  private V[] values;
  
  private int size;
  
  private int mask;
  
  private final Set<Character> keySet = new KeySet(this, null);
  
  private final Set<Map.Entry<Character, V>> entrySet = new EntrySet(this, null);
  
  private final Iterable<CharObjectMap.PrimitiveEntry<V>> entries = new Object(this);
  
  public CharObjectHashMap() { this(8, 0.5F); }
  
  public CharObjectHashMap(int initialCapacity) { this(initialCapacity, 0.5F); }
  
  public CharObjectHashMap(int initialCapacity, float loadFactor) {
    if (loadFactor <= 0.0F || loadFactor > 1.0F)
      throw new IllegalArgumentException("loadFactor must be > 0 and <= 1"); 
    this.loadFactor = loadFactor;
    int capacity = MathUtil.safeFindNextPositivePowerOfTwo(initialCapacity);
    this.mask = capacity - 1;
    this.keys = new char[capacity];
    V[] temp = (V[])(Object[])new Object[capacity];
    this.values = temp;
    this.maxSize = calcMaxSize(capacity);
  }
  
  private static <T> T toExternal(T value) {
    assert value != null : "null is not a legitimate internal value. Concurrent Modification?";
    return (value == NULL_VALUE) ? null : value;
  }
  
  private static <T> T toInternal(T value) { return (T)((value == null) ? NULL_VALUE : value); }
  
  public V get(char key) {
    int index = indexOf(key);
    return (V)((index == -1) ? null : toExternal(this.values[index]));
  }
  
  public V put(char key, V value) {
    int startIndex = hashIndex(key);
    int index = startIndex;
    do {
      if (this.values[index] == null) {
        this.keys[index] = key;
        this.values[index] = toInternal(value);
        growSize();
        return null;
      } 
      if (this.keys[index] == key) {
        V previousValue = (V)this.values[index];
        this.values[index] = toInternal(value);
        return (V)toExternal(previousValue);
      } 
    } while ((index = probeNext(index)) != startIndex);
    throw new IllegalStateException("Unable to insert");
  }
  
  public void putAll(Map<? extends Character, ? extends V> sourceMap) {
    if (sourceMap instanceof CharObjectHashMap) {
      CharObjectHashMap<V> source = (CharObjectHashMap)sourceMap;
      for (int i = 0; i < source.values.length; i++) {
        V sourceValue = (V)source.values[i];
        if (sourceValue != null)
          put(source.keys[i], sourceValue); 
      } 
      return;
    } 
    for (Map.Entry<? extends Character, ? extends V> entry : sourceMap.entrySet())
      put((Character)entry.getKey(), entry.getValue()); 
  }
  
  public V remove(char key) {
    int index = indexOf(key);
    if (index == -1)
      return null; 
    V prev = (V)this.values[index];
    removeAt(index);
    return (V)toExternal(prev);
  }
  
  public int size() { return this.size; }
  
  public boolean isEmpty() { return (this.size == 0); }
  
  public void clear() {
    Arrays.fill(this.keys, false);
    Arrays.fill(this.values, null);
    this.size = 0;
  }
  
  public boolean containsKey(char key) { return (indexOf(key) >= 0); }
  
  public boolean containsValue(Object value) {
    V v1 = (V)toInternal(value);
    Object[] arrayOfObject;
    int i;
    byte b;
    for (arrayOfObject = this.values, i = arrayOfObject.length, b = 0; b < i; ) {
      V v2 = (V)arrayOfObject[b];
      if (v2 != null && v2.equals(v1))
        return true; 
      b++;
    } 
    return false;
  }
  
  public Iterable<CharObjectMap.PrimitiveEntry<V>> entries() { return this.entries; }
  
  public Collection<V> values() { return new Object(this); }
  
  public int hashCode() {
    int hash = this.size;
    for (char key : this.keys)
      hash ^= hashCode(key); 
    return hash;
  }
  
  public boolean equals(Object obj) {
    if (this == obj)
      return true; 
    if (!(obj instanceof CharObjectMap))
      return false; 
    CharObjectMap other = (CharObjectMap)obj;
    if (this.size != other.size())
      return false; 
    for (int i = 0; i < this.values.length; i++) {
      V value = (V)this.values[i];
      if (value != null) {
        char key = this.keys[i];
        Object otherValue = other.get(key);
        if (value == NULL_VALUE) {
          if (otherValue != null)
            return false; 
        } else if (!value.equals(otherValue)) {
          return false;
        } 
      } 
    } 
    return true;
  }
  
  public boolean containsKey(Object key) { return containsKey(objectToKey(key)); }
  
  public V get(Object key) { return (V)get(objectToKey(key)); }
  
  public V put(Character key, V value) { return (V)put(objectToKey(key), value); }
  
  public V remove(Object key) { return (V)remove(objectToKey(key)); }
  
  public Set<Character> keySet() { return this.keySet; }
  
  public Set<Map.Entry<Character, V>> entrySet() { return this.entrySet; }
  
  private char objectToKey(Object key) { return ((Character)key).charValue(); }
  
  private int indexOf(char key) {
    int startIndex = hashIndex(key);
    int index = startIndex;
    do {
      if (this.values[index] == null)
        return -1; 
      if (key == this.keys[index])
        return index; 
    } while ((index = probeNext(index)) != startIndex);
    return -1;
  }
  
  private int hashIndex(char key) { return hashCode(key) & this.mask; }
  
  private static int hashCode(char key) { return key; }
  
  private int probeNext(int index) { return index + 1 & this.mask; }
  
  private void growSize() {
    this.size++;
    if (this.size > this.maxSize) {
      if (this.keys.length == Integer.MAX_VALUE)
        throw new IllegalStateException("Max capacity reached at size=" + this.size); 
      rehash(this.keys.length << 1);
    } 
  }
  
  private boolean removeAt(int index) {
    this.size--;
    this.keys[index] = Character.MIN_VALUE;
    this.values[index] = null;
    int nextFree = index;
    int i = probeNext(index);
    for (V value = (V)this.values[i]; value != null; value = (V)this.values[i = probeNext(i)]) {
      char key = this.keys[i];
      int bucket = hashIndex(key);
      if ((i < bucket && (bucket <= nextFree || nextFree <= i)) || (bucket <= nextFree && nextFree <= i)) {
        this.keys[nextFree] = key;
        this.values[nextFree] = value;
        this.keys[i] = Character.MIN_VALUE;
        this.values[i] = null;
        nextFree = i;
      } 
    } 
    return (nextFree != index);
  }
  
  private int calcMaxSize(int capacity) {
    int upperBound = capacity - 1;
    return Math.min(upperBound, (int)(capacity * this.loadFactor));
  }
  
  private void rehash(int newCapacity) {
    char[] oldKeys = this.keys;
    V[] oldVals = (V[])this.values;
    this.keys = new char[newCapacity];
    V[] temp = (V[])(Object[])new Object[newCapacity];
    this.values = temp;
    this.maxSize = calcMaxSize(newCapacity);
    this.mask = newCapacity - 1;
    for (int i = 0; i < oldVals.length; i++) {
      V oldVal = oldVals[i];
      if (oldVal != null) {
        char oldKey = oldKeys[i];
        int index = hashIndex(oldKey);
        while (true) {
          if (this.values[index] == null) {
            this.keys[index] = oldKey;
            this.values[index] = oldVal;
            break;
          } 
          index = probeNext(index);
        } 
      } 
    } 
  }
  
  public String toString() {
    if (isEmpty())
      return "{}"; 
    StringBuilder sb = new StringBuilder(4 * this.size);
    sb.append('{');
    boolean first = true;
    for (int i = 0; i < this.values.length; i++) {
      V value = (V)this.values[i];
      if (value != null) {
        if (!first)
          sb.append(", "); 
        sb.append(keyToString(this.keys[i])).append('=').append((value == this) ? "(this Map)" : 
            toExternal(value));
        first = false;
      } 
    } 
    return sb.append('}').toString();
  }
  
  protected String keyToString(char key) { return Character.toString(key); }
}
