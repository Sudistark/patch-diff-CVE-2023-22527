package io.netty.util;

import io.netty.util.internal.ObjectUtil;
import java.util.Arrays;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

public class DefaultAttributeMap implements AttributeMap {
  private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER = AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, "attributes");
  
  private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];
  
  private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, AttributeKey<?> key) {
    int low = 0;
    int high = sortedAttributes.length - 1;
    while (low <= high) {
      int mid = low + high >>> 1;
      DefaultAttribute midVal = sortedAttributes[mid];
      AttributeKey midValKey = DefaultAttribute.access$000(midVal);
      if (midValKey == key)
        return mid; 
      int midValKeyId = midValKey.id();
      int keyId = key.id();
      assert midValKeyId != keyId;
      boolean searchRight = (midValKeyId < keyId);
      if (searchRight) {
        low = mid + 1;
        continue;
      } 
      high = mid - 1;
    } 
    return -(low + 1);
  }
  
  private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy, DefaultAttribute toInsert) {
    int id = DefaultAttribute.access$000(toInsert).id();
    int i;
    for (i = srcLength - 1; i >= 0; i--) {
      DefaultAttribute attribute = sortedSrc[i];
      assert DefaultAttribute.access$000(attribute).id() != id;
      if (DefaultAttribute.access$000(attribute).id() < id)
        break; 
      copy[i + 1] = sortedSrc[i];
    } 
    copy[i + 1] = toInsert;
    int toCopy = i + 1;
    if (toCopy > 0)
      System.arraycopy(sortedSrc, 0, copy, 0, toCopy); 
  }
  
  public <T> Attribute<T> attr(AttributeKey<T> key) {
    DefaultAttribute[] arrayOfDefaultAttribute2, arrayOfDefaultAttribute1;
    ObjectUtil.checkNotNull(key, "key");
    DefaultAttribute newAttribute = null;
    do {
      arrayOfDefaultAttribute1 = this.attributes;
      int index = searchAttributeByKey(arrayOfDefaultAttribute1, key);
      if (index >= 0) {
        DefaultAttribute attribute = arrayOfDefaultAttribute1[index];
        assert attribute.key() == key;
        if (!DefaultAttribute.access$100(attribute))
          return attribute; 
        if (newAttribute == null)
          newAttribute = new DefaultAttribute(this, key); 
        int count = arrayOfDefaultAttribute1.length;
        arrayOfDefaultAttribute2 = (DefaultAttribute[])Arrays.copyOf(arrayOfDefaultAttribute1, count);
        arrayOfDefaultAttribute2[index] = newAttribute;
      } else {
        if (newAttribute == null)
          newAttribute = new DefaultAttribute(this, key); 
        int count = arrayOfDefaultAttribute1.length;
        arrayOfDefaultAttribute2 = new DefaultAttribute[count + 1];
        orderedCopyOnInsert(arrayOfDefaultAttribute1, count, arrayOfDefaultAttribute2, newAttribute);
      } 
    } while (!ATTRIBUTES_UPDATER.compareAndSet(this, arrayOfDefaultAttribute1, arrayOfDefaultAttribute2));
    return newAttribute;
  }
  
  public <T> boolean hasAttr(AttributeKey<T> key) {
    ObjectUtil.checkNotNull(key, "key");
    return (searchAttributeByKey(this.attributes, key) >= 0);
  }
  
  private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {
    DefaultAttribute[] arrayOfDefaultAttribute2;
    DefaultAttribute[] arrayOfDefaultAttribute1;
    do {
      arrayOfDefaultAttribute1 = this.attributes;
      int index = searchAttributeByKey(arrayOfDefaultAttribute1, key);
      if (index < 0)
        return; 
      DefaultAttribute attribute = arrayOfDefaultAttribute1[index];
      assert attribute.key() == key;
      if (attribute != value)
        return; 
      int count = arrayOfDefaultAttribute1.length;
      int newCount = count - 1;
      arrayOfDefaultAttribute2 = (newCount == 0) ? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];
      System.arraycopy(arrayOfDefaultAttribute1, 0, arrayOfDefaultAttribute2, 0, index);
      int remaining = count - index - 1;
      if (remaining <= 0)
        continue; 
      System.arraycopy(arrayOfDefaultAttribute1, index + 1, arrayOfDefaultAttribute2, index, remaining);
    } while (!ATTRIBUTES_UPDATER.compareAndSet(this, arrayOfDefaultAttribute1, arrayOfDefaultAttribute2));
  }
}
