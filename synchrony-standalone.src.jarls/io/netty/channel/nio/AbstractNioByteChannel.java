package io.netty.channel.nio;

import io.netty.buffer.ByteBuf;
import io.netty.channel.AbstractChannel;
import io.netty.channel.Channel;
import io.netty.channel.ChannelConfig;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelMetadata;
import io.netty.channel.ChannelOutboundBuffer;
import io.netty.channel.FileRegion;
import io.netty.channel.socket.SocketChannelConfig;
import io.netty.util.internal.StringUtil;
import java.nio.channels.SelectableChannel;
import java.nio.channels.SelectionKey;

public abstract class AbstractNioByteChannel extends AbstractNioChannel {
  private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);
  
  private static final String EXPECTED_TYPES = " (expected: " + 
    StringUtil.simpleClassName(ByteBuf.class) + ", " + 
    StringUtil.simpleClassName(FileRegion.class) + ')';
  
  private final Runnable flushTask = new Object(this);
  
  private boolean inputClosedSeenErrorOnRead;
  
  protected AbstractNioByteChannel(Channel parent, SelectableChannel ch) { super(parent, ch, 1); }
  
  protected boolean isInputShutdown0() { return false; }
  
  protected AbstractNioChannel.AbstractNioUnsafe newUnsafe() { return new NioByteUnsafe(this); }
  
  public ChannelMetadata metadata() { return METADATA; }
  
  final boolean shouldBreakReadReady(ChannelConfig config) { return (isInputShutdown0() && (this.inputClosedSeenErrorOnRead || !isAllowHalfClosure(config))); }
  
  private static boolean isAllowHalfClosure(ChannelConfig config) {
    return (config instanceof SocketChannelConfig && ((SocketChannelConfig)config)
      .isAllowHalfClosure());
  }
  
  protected final int doWrite0(ChannelOutboundBuffer in) throws Exception {
    Object msg = in.current();
    if (msg == null)
      return 0; 
    return doWriteInternal(in, in.current());
  }
  
  private int doWriteInternal(ChannelOutboundBuffer in, Object msg) throws Exception {
    if (msg instanceof ByteBuf) {
      ByteBuf buf = (ByteBuf)msg;
      if (!buf.isReadable()) {
        in.remove();
        return 0;
      } 
      int localFlushedAmount = doWriteBytes(buf);
      if (localFlushedAmount > 0) {
        in.progress(localFlushedAmount);
        if (!buf.isReadable())
          in.remove(); 
        return 1;
      } 
    } else if (msg instanceof FileRegion) {
      FileRegion region = (FileRegion)msg;
      if (region.transferred() >= region.count()) {
        in.remove();
        return 0;
      } 
      long localFlushedAmount = doWriteFileRegion(region);
      if (localFlushedAmount > 0L) {
        in.progress(localFlushedAmount);
        if (region.transferred() >= region.count())
          in.remove(); 
        return 1;
      } 
    } else {
      throw new Error();
    } 
    return Integer.MAX_VALUE;
  }
  
  protected void doWrite(ChannelOutboundBuffer in) throws Exception {
    int writeSpinCount = config().getWriteSpinCount();
    do {
      Object msg = in.current();
      if (msg == null) {
        clearOpWrite();
        return;
      } 
      writeSpinCount -= doWriteInternal(in, msg);
    } while (writeSpinCount > 0);
    incompleteWrite((writeSpinCount < 0));
  }
  
  protected final Object filterOutboundMessage(Object msg) {
    if (msg instanceof ByteBuf) {
      ByteBuf buf = (ByteBuf)msg;
      if (buf.isDirect())
        return msg; 
      return newDirectBuffer(buf);
    } 
    if (msg instanceof FileRegion)
      return msg; 
    throw new UnsupportedOperationException("unsupported message type: " + 
        StringUtil.simpleClassName(msg) + EXPECTED_TYPES);
  }
  
  protected final void incompleteWrite(boolean setOpWrite) {
    if (setOpWrite) {
      setOpWrite();
    } else {
      clearOpWrite();
      eventLoop().execute(this.flushTask);
    } 
  }
  
  protected final void setOpWrite() {
    SelectionKey key = selectionKey();
    if (!key.isValid())
      return; 
    int interestOps = key.interestOps();
    if ((interestOps & 0x4) == 0)
      key.interestOps(interestOps | 0x4); 
  }
  
  protected final void clearOpWrite() {
    SelectionKey key = selectionKey();
    if (!key.isValid())
      return; 
    int interestOps = key.interestOps();
    if ((interestOps & 0x4) != 0)
      key.interestOps(interestOps & 0xFFFFFFFB); 
  }
  
  protected abstract ChannelFuture shutdownInput();
  
  protected abstract long doWriteFileRegion(FileRegion paramFileRegion) throws Exception;
  
  protected abstract int doReadBytes(ByteBuf paramByteBuf) throws Exception;
  
  protected abstract int doWriteBytes(ByteBuf paramByteBuf) throws Exception;
}
