package io.netty.channel.epoll;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.ByteBufUtil;
import io.netty.buffer.Unpooled;
import io.netty.channel.AbstractChannel;
import io.netty.channel.Channel;
import io.netty.channel.ChannelConfig;
import io.netty.channel.ChannelException;
import io.netty.channel.ChannelMetadata;
import io.netty.channel.ChannelOutboundBuffer;
import io.netty.channel.ChannelPromise;
import io.netty.channel.EventLoop;
import io.netty.channel.socket.SocketChannelConfig;
import io.netty.channel.unix.FileDescriptor;
import io.netty.channel.unix.IovArray;
import io.netty.channel.unix.Socket;
import io.netty.channel.unix.UnixChannel;
import io.netty.channel.unix.UnixChannelUtil;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.concurrent.Future;
import io.netty.util.internal.ObjectUtil;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AlreadyConnectedException;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.UnresolvedAddressException;

abstract class AbstractEpollChannel extends AbstractChannel implements UnixChannel {
  private static final ChannelMetadata METADATA = new ChannelMetadata(false);
  
  protected final LinuxSocket socket;
  
  private ChannelPromise connectPromise;
  
  private Future<?> connectTimeoutFuture;
  
  private SocketAddress requestedRemoteAddress;
  
  protected int flags = Native.EPOLLET;
  
  boolean inputClosedSeenErrorOnRead;
  
  boolean epollInReadyRunnablePending;
  
  AbstractEpollChannel(LinuxSocket fd) { this(null, fd, false); }
  
  AbstractEpollChannel(Channel parent, LinuxSocket fd, boolean active) {
    super(parent);
    this.socket = (LinuxSocket)ObjectUtil.checkNotNull(fd, "fd");
    this.active = active;
    if (active) {
      this.local = fd.localAddress();
      this.remote = fd.remoteAddress();
    } 
  }
  
  AbstractEpollChannel(Channel parent, LinuxSocket fd, SocketAddress remote) {
    super(parent);
    this.socket = (LinuxSocket)ObjectUtil.checkNotNull(fd, "fd");
    this.active = true;
    this.remote = remote;
    this.local = fd.localAddress();
  }
  
  static boolean isSoErrorZero(Socket fd) {
    try {
      return (fd.getSoError() == 0);
    } catch (IOException e) {
      throw new ChannelException(e);
    } 
  }
  
  protected void setFlag(int flag) throws IOException {
    if (!isFlagSet(flag)) {
      this.flags |= flag;
      modifyEvents();
    } 
  }
  
  void clearFlag(int flag) throws IOException {
    if (isFlagSet(flag)) {
      this.flags &= (flag ^ 0xFFFFFFFF);
      modifyEvents();
    } 
  }
  
  boolean isFlagSet(int flag) { return ((this.flags & flag) != 0); }
  
  public final FileDescriptor fd() { return this.socket; }
  
  public boolean isActive() { return this.active; }
  
  public ChannelMetadata metadata() { return METADATA; }
  
  protected void doClose() throws Exception {
    this.active = false;
    this.inputClosedSeenErrorOnRead = true;
    try {
      ChannelPromise promise = this.connectPromise;
      if (promise != null) {
        promise.tryFailure(new ClosedChannelException());
        this.connectPromise = null;
      } 
      Future<?> future = this.connectTimeoutFuture;
      if (future != null) {
        future.cancel(false);
        this.connectTimeoutFuture = null;
      } 
      if (isRegistered()) {
        EventLoop loop = eventLoop();
        if (loop.inEventLoop()) {
          doDeregister();
        } else {
          loop.execute(new Object(this));
        } 
      } 
    } finally {
      this.socket.close();
    } 
  }
  
  void resetCachedAddresses() throws Exception {
    this.local = this.socket.localAddress();
    this.remote = this.socket.remoteAddress();
  }
  
  protected void doDisconnect() throws Exception { doClose(); }
  
  protected boolean isCompatible(EventLoop loop) { return loop instanceof EpollEventLoop; }
  
  public boolean isOpen() { return this.socket.isOpen(); }
  
  protected void doDeregister() throws Exception { ((EpollEventLoop)eventLoop()).remove(this); }
  
  protected final void doBeginRead() throws Exception {
    AbstractEpollUnsafe unsafe = (AbstractEpollUnsafe)unsafe();
    unsafe.readPending = true;
    setFlag(Native.EPOLLIN);
    if (unsafe.maybeMoreDataToRead)
      unsafe.executeEpollInReadyRunnable(config()); 
  }
  
  final boolean shouldBreakEpollInReady(ChannelConfig config) { return (this.socket.isInputShutdown() && (this.inputClosedSeenErrorOnRead || !isAllowHalfClosure(config))); }
  
  private static boolean isAllowHalfClosure(ChannelConfig config) {
    if (config instanceof EpollDomainSocketChannelConfig)
      return ((EpollDomainSocketChannelConfig)config).isAllowHalfClosure(); 
    return (config instanceof SocketChannelConfig && ((SocketChannelConfig)config)
      .isAllowHalfClosure());
  }
  
  final void clearEpollIn() throws Exception {
    if (isRegistered()) {
      EventLoop loop = eventLoop();
      AbstractEpollUnsafe unsafe = (AbstractEpollUnsafe)unsafe();
      if (loop.inEventLoop()) {
        unsafe.clearEpollIn0();
      } else {
        loop.execute(new Object(this, unsafe));
      } 
    } else {
      this.flags &= (Native.EPOLLIN ^ 0xFFFFFFFF);
    } 
  }
  
  private void modifyEvents() throws Exception {
    if (isOpen() && isRegistered())
      ((EpollEventLoop)eventLoop()).modify(this); 
  }
  
  protected void doRegister() throws Exception {
    this.epollInReadyRunnablePending = false;
    ((EpollEventLoop)eventLoop()).add(this);
  }
  
  protected final ByteBuf newDirectBuffer(ByteBuf buf) { return newDirectBuffer(buf, buf); }
  
  protected final ByteBuf newDirectBuffer(Object holder, ByteBuf buf) {
    int readableBytes = buf.readableBytes();
    if (readableBytes == 0) {
      ReferenceCountUtil.release(holder);
      return Unpooled.EMPTY_BUFFER;
    } 
    ByteBufAllocator alloc = alloc();
    if (alloc.isDirectBufferPooled())
      return newDirectBuffer0(holder, buf, alloc, readableBytes); 
    ByteBuf directBuf = ByteBufUtil.threadLocalDirectBuffer();
    if (directBuf == null)
      return newDirectBuffer0(holder, buf, alloc, readableBytes); 
    directBuf.writeBytes(buf, buf.readerIndex(), readableBytes);
    ReferenceCountUtil.safeRelease(holder);
    return directBuf;
  }
  
  private static ByteBuf newDirectBuffer0(Object holder, ByteBuf buf, ByteBufAllocator alloc, int capacity) {
    ByteBuf directBuf = alloc.directBuffer(capacity);
    directBuf.writeBytes(buf, buf.readerIndex(), capacity);
    ReferenceCountUtil.safeRelease(holder);
    return directBuf;
  }
  
  protected static void checkResolvable(InetSocketAddress addr) {
    if (addr.isUnresolved())
      throw new UnresolvedAddressException(); 
  }
  
  protected final int doReadBytes(ByteBuf byteBuf) throws Exception {
    int localReadAmount, writerIndex = byteBuf.writerIndex();
    unsafe().recvBufAllocHandle().attemptedBytesRead(byteBuf.writableBytes());
    if (byteBuf.hasMemoryAddress()) {
      localReadAmount = this.socket.recvAddress(byteBuf.memoryAddress(), writerIndex, byteBuf.capacity());
    } else {
      ByteBuffer buf = byteBuf.internalNioBuffer(writerIndex, byteBuf.writableBytes());
      localReadAmount = this.socket.recv(buf, buf.position(), buf.limit());
    } 
    if (localReadAmount > 0)
      byteBuf.writerIndex(writerIndex + localReadAmount); 
    return localReadAmount;
  }
  
  protected final int doWriteBytes(ChannelOutboundBuffer in, ByteBuf buf) throws Exception {
    if (buf.hasMemoryAddress()) {
      int localFlushedAmount = this.socket.sendAddress(buf.memoryAddress(), buf.readerIndex(), buf.writerIndex());
      if (localFlushedAmount > 0) {
        in.removeBytes(localFlushedAmount);
        return 1;
      } 
    } else {
      ByteBuffer nioBuf = (buf.nioBufferCount() == 1) ? buf.internalNioBuffer(buf.readerIndex(), buf.readableBytes()) : buf.nioBuffer();
      int localFlushedAmount = this.socket.send(nioBuf, nioBuf.position(), nioBuf.limit());
      if (localFlushedAmount > 0) {
        nioBuf.position(nioBuf.position() + localFlushedAmount);
        in.removeBytes(localFlushedAmount);
        return 1;
      } 
    } 
    return Integer.MAX_VALUE;
  }
  
  final long doWriteOrSendBytes(ByteBuf data, InetSocketAddress remoteAddress, boolean fastOpen) throws IOException {
    assert !fastOpen || remoteAddress != null : "fastOpen requires a remote address";
    if (data.hasMemoryAddress()) {
      long memoryAddress = data.memoryAddress();
      if (remoteAddress == null)
        return this.socket.sendAddress(memoryAddress, data.readerIndex(), data.writerIndex()); 
      return this.socket.sendToAddress(memoryAddress, data.readerIndex(), data.writerIndex(), remoteAddress
          .getAddress(), remoteAddress.getPort(), fastOpen);
    } 
    if (data.nioBufferCount() > 1) {
      IovArray array = ((EpollEventLoop)eventLoop()).cleanIovArray();
      array.add(data, data.readerIndex(), data.readableBytes());
      int cnt = array.count();
      assert cnt != 0;
      if (remoteAddress == null)
        return this.socket.writevAddresses(array.memoryAddress(0), cnt); 
      return this.socket.sendToAddresses(array.memoryAddress(0), cnt, remoteAddress
          .getAddress(), remoteAddress.getPort(), fastOpen);
    } 
    ByteBuffer nioData = data.internalNioBuffer(data.readerIndex(), data.readableBytes());
    if (remoteAddress == null)
      return this.socket.send(nioData, nioData.position(), nioData.limit()); 
    return this.socket.sendTo(nioData, nioData.position(), nioData.limit(), remoteAddress
        .getAddress(), remoteAddress.getPort(), fastOpen);
  }
  
  protected void doBind(SocketAddress local) throws Exception {
    if (local instanceof InetSocketAddress)
      checkResolvable((InetSocketAddress)local); 
    this.socket.bind(local);
    this.local = this.socket.localAddress();
  }
  
  protected boolean doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception {
    if (localAddress instanceof InetSocketAddress)
      checkResolvable((InetSocketAddress)localAddress); 
    InetSocketAddress remoteSocketAddr = (remoteAddress instanceof InetSocketAddress) ? (InetSocketAddress)remoteAddress : null;
    if (remoteSocketAddr != null)
      checkResolvable(remoteSocketAddr); 
    if (this.remote != null)
      throw new AlreadyConnectedException(); 
    if (localAddress != null)
      this.socket.bind(localAddress); 
    boolean connected = doConnect0(remoteAddress);
    if (connected)
      this
        .remote = (remoteSocketAddr == null) ? remoteAddress : UnixChannelUtil.computeRemoteAddr(remoteSocketAddr, this.socket.remoteAddress()); 
    this.local = this.socket.localAddress();
    return connected;
  }
  
  boolean doConnect0(SocketAddress remote) throws Exception {
    success = false;
    try {
      boolean connected = this.socket.connect(remote);
      if (!connected)
        setFlag(Native.EPOLLOUT); 
      success = true;
      return connected;
    } finally {
      if (!success)
        doClose(); 
    } 
  }
  
  protected SocketAddress localAddress0() { return this.local; }
  
  protected SocketAddress remoteAddress0() { return this.remote; }
  
  public abstract EpollChannelConfig config();
  
  protected abstract AbstractEpollUnsafe newUnsafe();
}
