package io.netty.channel.group;

import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.util.concurrent.BlockingOperationException;
import io.netty.util.concurrent.DefaultPromise;
import io.netty.util.concurrent.EventExecutor;
import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.GenericFutureListener;
import io.netty.util.concurrent.ImmediateEventExecutor;
import io.netty.util.concurrent.Promise;
import io.netty.util.internal.ObjectUtil;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;

final class DefaultChannelGroupFuture extends DefaultPromise<Void> implements ChannelGroupFuture {
  private final ChannelGroup group;
  
  private final Map<Channel, ChannelFuture> futures;
  
  private int successCount;
  
  private int failureCount;
  
  private final ChannelFutureListener childListener = new Object(this);
  
  DefaultChannelGroupFuture(ChannelGroup group, Collection<ChannelFuture> futures, EventExecutor executor) {
    super(executor);
    this.group = (ChannelGroup)ObjectUtil.checkNotNull(group, "group");
    ObjectUtil.checkNotNull(futures, "futures");
    Map<Channel, ChannelFuture> futureMap = new LinkedHashMap<Channel, ChannelFuture>();
    for (ChannelFuture f : futures)
      futureMap.put(f.channel(), f); 
    this.futures = Collections.unmodifiableMap(futureMap);
    for (ChannelFuture f : this.futures.values())
      f.addListener(this.childListener); 
    if (this.futures.isEmpty())
      setSuccess0(); 
  }
  
  DefaultChannelGroupFuture(ChannelGroup group, Map<Channel, ChannelFuture> futures, EventExecutor executor) {
    super(executor);
    this.group = group;
    this.futures = Collections.unmodifiableMap(futures);
    for (ChannelFuture f : this.futures.values())
      f.addListener(this.childListener); 
    if (this.futures.isEmpty())
      setSuccess0(); 
  }
  
  public ChannelGroup group() { return this.group; }
  
  public ChannelFuture find(Channel channel) { return (ChannelFuture)this.futures.get(channel); }
  
  public Iterator<ChannelFuture> iterator() { return this.futures.values().iterator(); }
  
  public boolean isPartialSuccess() { return (this.successCount != 0 && this.successCount != this.futures.size()); }
  
  public boolean isPartialFailure() { return (this.failureCount != 0 && this.failureCount != this.futures.size()); }
  
  public DefaultChannelGroupFuture addListener(GenericFutureListener<? extends Future<? super Void>> listener) {
    super.addListener(listener);
    return this;
  }
  
  public DefaultChannelGroupFuture addListeners(GenericFutureListener... listeners) {
    super.addListeners(listeners);
    return this;
  }
  
  public DefaultChannelGroupFuture removeListener(GenericFutureListener<? extends Future<? super Void>> listener) {
    super.removeListener(listener);
    return this;
  }
  
  public DefaultChannelGroupFuture removeListeners(GenericFutureListener... listeners) {
    super.removeListeners(listeners);
    return this;
  }
  
  public DefaultChannelGroupFuture await() throws InterruptedException {
    super.await();
    return this;
  }
  
  public DefaultChannelGroupFuture awaitUninterruptibly() throws InterruptedException {
    super.awaitUninterruptibly();
    return this;
  }
  
  public DefaultChannelGroupFuture syncUninterruptibly() throws InterruptedException {
    super.syncUninterruptibly();
    return this;
  }
  
  public DefaultChannelGroupFuture sync() throws InterruptedException {
    super.sync();
    return this;
  }
  
  public ChannelGroupException cause() { return (ChannelGroupException)super.cause(); }
  
  private void setSuccess0() { super.setSuccess(null); }
  
  private void setFailure0(ChannelGroupException cause) { super.setFailure(cause); }
  
  public DefaultChannelGroupFuture setSuccess(Void result) { throw new IllegalStateException(); }
  
  public boolean trySuccess(Void result) { throw new IllegalStateException(); }
  
  public DefaultChannelGroupFuture setFailure(Throwable cause) { throw new IllegalStateException(); }
  
  public boolean tryFailure(Throwable cause) { throw new IllegalStateException(); }
  
  protected void checkDeadLock() {
    EventExecutor e = executor();
    if (e != null && e != ImmediateEventExecutor.INSTANCE && e.inEventLoop())
      throw new BlockingOperationException(); 
  }
}
