package io.netty.channel;

import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import java.net.SocketAddress;

public class CombinedChannelDuplexHandler<I extends ChannelInboundHandler, O extends ChannelOutboundHandler> extends ChannelDuplexHandler {
  private static final InternalLogger logger = InternalLoggerFactory.getInstance(CombinedChannelDuplexHandler.class);
  
  private DelegatingChannelHandlerContext inboundCtx;
  
  private DelegatingChannelHandlerContext outboundCtx;
  
  private I inboundHandler;
  
  private O outboundHandler;
  
  protected CombinedChannelDuplexHandler() { ensureNotSharable(); }
  
  public CombinedChannelDuplexHandler(I inboundHandler, O outboundHandler) {
    ensureNotSharable();
    init(inboundHandler, outboundHandler);
  }
  
  protected final void init(I inboundHandler, O outboundHandler) {
    validate(inboundHandler, outboundHandler);
    this.inboundHandler = inboundHandler;
    this.outboundHandler = outboundHandler;
  }
  
  private void validate(I inboundHandler, O outboundHandler) {
    if (this.inboundHandler != null)
      throw new IllegalStateException("init() can not be invoked if " + CombinedChannelDuplexHandler.class
          .getSimpleName() + " was constructed with non-default constructor."); 
    ObjectUtil.checkNotNull(inboundHandler, "inboundHandler");
    ObjectUtil.checkNotNull(outboundHandler, "outboundHandler");
    if (inboundHandler instanceof ChannelOutboundHandler)
      throw new IllegalArgumentException("inboundHandler must not implement " + ChannelOutboundHandler.class
          
          .getSimpleName() + " to get combined."); 
    if (outboundHandler instanceof ChannelInboundHandler)
      throw new IllegalArgumentException("outboundHandler must not implement " + ChannelInboundHandler.class
          
          .getSimpleName() + " to get combined."); 
  }
  
  protected final I inboundHandler() { return (I)this.inboundHandler; }
  
  protected final O outboundHandler() { return (O)this.outboundHandler; }
  
  private void checkAdded() {
    if (!this.handlerAdded)
      throw new IllegalStateException("handler not added to pipeline yet"); 
  }
  
  public final void removeInboundHandler() {
    checkAdded();
    this.inboundCtx.remove();
  }
  
  public final void removeOutboundHandler() {
    checkAdded();
    this.outboundCtx.remove();
  }
  
  public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
    if (this.inboundHandler == null)
      throw new IllegalStateException("init() must be invoked before being added to a " + ChannelPipeline.class
          .getSimpleName() + " if " + CombinedChannelDuplexHandler.class
          .getSimpleName() + " was constructed with the default constructor."); 
    this.outboundCtx = new DelegatingChannelHandlerContext(ctx, this.outboundHandler);
    this.inboundCtx = new Object(this, ctx, this.inboundHandler);
    this.handlerAdded = true;
    try {
      this.inboundHandler.handlerAdded(this.inboundCtx);
    } finally {
      this.outboundHandler.handlerAdded(this.outboundCtx);
    } 
  }
  
  public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
    try {
      this.inboundCtx.remove();
    } finally {
      this.outboundCtx.remove();
    } 
  }
  
  public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
    assert ctx == DelegatingChannelHandlerContext.access$300(this.inboundCtx);
    if (!this.inboundCtx.removed) {
      this.inboundHandler.channelRegistered(this.inboundCtx);
    } else {
      this.inboundCtx.fireChannelRegistered();
    } 
  }
  
  public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
    assert ctx == DelegatingChannelHandlerContext.access$300(this.inboundCtx);
    if (!this.inboundCtx.removed) {
      this.inboundHandler.channelUnregistered(this.inboundCtx);
    } else {
      this.inboundCtx.fireChannelUnregistered();
    } 
  }
  
  public void channelActive(ChannelHandlerContext ctx) throws Exception {
    assert ctx == DelegatingChannelHandlerContext.access$300(this.inboundCtx);
    if (!this.inboundCtx.removed) {
      this.inboundHandler.channelActive(this.inboundCtx);
    } else {
      this.inboundCtx.fireChannelActive();
    } 
  }
  
  public void channelInactive(ChannelHandlerContext ctx) throws Exception {
    assert ctx == DelegatingChannelHandlerContext.access$300(this.inboundCtx);
    if (!this.inboundCtx.removed) {
      this.inboundHandler.channelInactive(this.inboundCtx);
    } else {
      this.inboundCtx.fireChannelInactive();
    } 
  }
  
  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
    assert ctx == DelegatingChannelHandlerContext.access$300(this.inboundCtx);
    if (!this.inboundCtx.removed) {
      this.inboundHandler.exceptionCaught(this.inboundCtx, cause);
    } else {
      this.inboundCtx.fireExceptionCaught(cause);
    } 
  }
  
  public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
    assert ctx == DelegatingChannelHandlerContext.access$300(this.inboundCtx);
    if (!this.inboundCtx.removed) {
      this.inboundHandler.userEventTriggered(this.inboundCtx, evt);
    } else {
      this.inboundCtx.fireUserEventTriggered(evt);
    } 
  }
  
  public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
    assert ctx == DelegatingChannelHandlerContext.access$300(this.inboundCtx);
    if (!this.inboundCtx.removed) {
      this.inboundHandler.channelRead(this.inboundCtx, msg);
    } else {
      this.inboundCtx.fireChannelRead(msg);
    } 
  }
  
  public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
    assert ctx == DelegatingChannelHandlerContext.access$300(this.inboundCtx);
    if (!this.inboundCtx.removed) {
      this.inboundHandler.channelReadComplete(this.inboundCtx);
    } else {
      this.inboundCtx.fireChannelReadComplete();
    } 
  }
  
  public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {
    assert ctx == DelegatingChannelHandlerContext.access$300(this.inboundCtx);
    if (!this.inboundCtx.removed) {
      this.inboundHandler.channelWritabilityChanged(this.inboundCtx);
    } else {
      this.inboundCtx.fireChannelWritabilityChanged();
    } 
  }
  
  public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {
    assert ctx == DelegatingChannelHandlerContext.access$300(this.outboundCtx);
    if (!this.outboundCtx.removed) {
      this.outboundHandler.bind(this.outboundCtx, localAddress, promise);
    } else {
      this.outboundCtx.bind(localAddress, promise);
    } 
  }
  
  public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {
    assert ctx == DelegatingChannelHandlerContext.access$300(this.outboundCtx);
    if (!this.outboundCtx.removed) {
      this.outboundHandler.connect(this.outboundCtx, remoteAddress, localAddress, promise);
    } else {
      this.outboundCtx.connect(remoteAddress, localAddress, promise);
    } 
  }
  
  public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
    assert ctx == DelegatingChannelHandlerContext.access$300(this.outboundCtx);
    if (!this.outboundCtx.removed) {
      this.outboundHandler.disconnect(this.outboundCtx, promise);
    } else {
      this.outboundCtx.disconnect(promise);
    } 
  }
  
  public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
    assert ctx == DelegatingChannelHandlerContext.access$300(this.outboundCtx);
    if (!this.outboundCtx.removed) {
      this.outboundHandler.close(this.outboundCtx, promise);
    } else {
      this.outboundCtx.close(promise);
    } 
  }
  
  public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
    assert ctx == DelegatingChannelHandlerContext.access$300(this.outboundCtx);
    if (!this.outboundCtx.removed) {
      this.outboundHandler.deregister(this.outboundCtx, promise);
    } else {
      this.outboundCtx.deregister(promise);
    } 
  }
  
  public void read(ChannelHandlerContext ctx) throws Exception {
    assert ctx == DelegatingChannelHandlerContext.access$300(this.outboundCtx);
    if (!this.outboundCtx.removed) {
      this.outboundHandler.read(this.outboundCtx);
    } else {
      this.outboundCtx.read();
    } 
  }
  
  public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
    assert ctx == DelegatingChannelHandlerContext.access$300(this.outboundCtx);
    if (!this.outboundCtx.removed) {
      this.outboundHandler.write(this.outboundCtx, msg, promise);
    } else {
      this.outboundCtx.write(msg, promise);
    } 
  }
  
  public void flush(ChannelHandlerContext ctx) throws Exception {
    assert ctx == DelegatingChannelHandlerContext.access$300(this.outboundCtx);
    if (!this.outboundCtx.removed) {
      this.outboundHandler.flush(this.outboundCtx);
    } else {
      this.outboundCtx.flush();
    } 
  }
}
