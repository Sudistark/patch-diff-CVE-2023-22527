package io.netty.channel.kqueue;

import io.netty.channel.unix.Errors;
import io.netty.channel.unix.FileDescriptor;
import io.netty.channel.unix.Unix;
import io.netty.util.internal.ClassInitializerUtil;
import io.netty.util.internal.NativeLibraryLoader;
import io.netty.util.internal.PlatformDependent;
import io.netty.util.internal.ThrowableUtil;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import java.io.IOException;

final class Native {
  private static final InternalLogger logger = InternalLoggerFactory.getInstance(Native.class);
  
  static final short EV_ADD;
  
  static final short EV_ENABLE;
  
  static final short EV_DISABLE;
  
  static final short EV_DELETE;
  
  static final short EV_CLEAR;
  
  static final short EV_ERROR;
  
  static final short EV_EOF;
  
  static final int NOTE_READCLOSED;
  
  static final int NOTE_CONNRESET;
  
  static final int NOTE_DISCONNECTED;
  
  static final int NOTE_RDHUP;
  
  static final short EV_ADD_CLEAR_ENABLE;
  
  static final short EV_DELETE_DISABLE;
  
  static final short EVFILT_READ;
  
  static final short EVFILT_WRITE;
  
  static final short EVFILT_USER;
  
  static final short EVFILT_SOCK;
  
  private static final int CONNECT_RESUME_ON_READ_WRITE;
  
  private static final int CONNECT_DATA_IDEMPOTENT;
  
  static final int CONNECT_TCP_FASTOPEN;
  
  static final boolean IS_SUPPORTING_TCP_FASTOPEN_CLIENT;
  
  static final boolean IS_SUPPORTING_TCP_FASTOPEN_SERVER;
  
  static  {
    ClassInitializerUtil.tryLoadClasses(Native.class, new Class[] { io.netty.channel.unix.PeerCredentials.class, io.netty.channel.DefaultFileRegion.class, java.nio.channels.FileChannel.class, java.io.FileDescriptor.class });
    try {
      sizeofKEvent();
    } catch (UnsatisfiedLinkError ignore) {
      loadNativeLibrary();
    } 
    Unix.registerInternal(new Object());
    EV_ADD = KQueueStaticallyReferencedJniMethods.evAdd();
    EV_ENABLE = KQueueStaticallyReferencedJniMethods.evEnable();
    EV_DISABLE = KQueueStaticallyReferencedJniMethods.evDisable();
    EV_DELETE = KQueueStaticallyReferencedJniMethods.evDelete();
    EV_CLEAR = KQueueStaticallyReferencedJniMethods.evClear();
    EV_ERROR = KQueueStaticallyReferencedJniMethods.evError();
    EV_EOF = KQueueStaticallyReferencedJniMethods.evEOF();
    NOTE_READCLOSED = KQueueStaticallyReferencedJniMethods.noteReadClosed();
    NOTE_CONNRESET = KQueueStaticallyReferencedJniMethods.noteConnReset();
    NOTE_DISCONNECTED = KQueueStaticallyReferencedJniMethods.noteDisconnected();
    NOTE_RDHUP = NOTE_READCLOSED | NOTE_CONNRESET | NOTE_DISCONNECTED;
    EV_ADD_CLEAR_ENABLE = (short)(EV_ADD | EV_CLEAR | EV_ENABLE);
    EV_DELETE_DISABLE = (short)(EV_DELETE | EV_DISABLE);
    EVFILT_READ = KQueueStaticallyReferencedJniMethods.evfiltRead();
    EVFILT_WRITE = KQueueStaticallyReferencedJniMethods.evfiltWrite();
    EVFILT_USER = KQueueStaticallyReferencedJniMethods.evfiltUser();
    EVFILT_SOCK = KQueueStaticallyReferencedJniMethods.evfiltSock();
    CONNECT_RESUME_ON_READ_WRITE = KQueueStaticallyReferencedJniMethods.connectResumeOnReadWrite();
    CONNECT_DATA_IDEMPOTENT = KQueueStaticallyReferencedJniMethods.connectDataIdempotent();
    CONNECT_TCP_FASTOPEN = CONNECT_RESUME_ON_READ_WRITE | CONNECT_DATA_IDEMPOTENT;
    IS_SUPPORTING_TCP_FASTOPEN_CLIENT = isSupportingFastOpenClient();
    IS_SUPPORTING_TCP_FASTOPEN_SERVER = isSupportingFastOpenServer();
  }
  
  static FileDescriptor newKQueue() { return new FileDescriptor(kqueueCreate()); }
  
  static int keventWait(int kqueueFd, KQueueEventArray changeList, KQueueEventArray eventList, int tvSec, int tvNsec) throws IOException {
    int ready = keventWait(kqueueFd, changeList.memoryAddress(), changeList.size(), eventList
        .memoryAddress(), eventList.capacity(), tvSec, tvNsec);
    if (ready < 0)
      throw Errors.newIOException("kevent", ready); 
    return ready;
  }
  
  private static void loadNativeLibrary() {
    name = PlatformDependent.normalizedOs();
    if (!"osx".equals(name) && !name.contains("bsd"))
      throw new IllegalStateException("Only supported on OSX/BSD"); 
    String staticLibName = "netty_transport_native_kqueue";
    String sharedLibName = staticLibName + '_' + PlatformDependent.normalizedArch();
    ClassLoader cl = PlatformDependent.getClassLoader(Native.class);
    try {
      NativeLibraryLoader.load(sharedLibName, cl);
    } catch (UnsatisfiedLinkError e1) {
      try {
        NativeLibraryLoader.load(staticLibName, cl);
        logger.debug("Failed to load {}", sharedLibName, e1);
      } catch (UnsatisfiedLinkError e2) {
        ThrowableUtil.addSuppressed(e1, e2);
        throw e1;
      } 
    } 
  }
  
  private static boolean isSupportingFastOpenClient() {
    try {
      return (KQueueStaticallyReferencedJniMethods.fastOpenClient() == 1);
    } catch (Exception e) {
      logger.debug("Failed to probe fastOpenClient sysctl, assuming client-side TCP FastOpen cannot be used.", e);
      return false;
    } 
  }
  
  private static boolean isSupportingFastOpenServer() {
    try {
      return (KQueueStaticallyReferencedJniMethods.fastOpenServer() == 1);
    } catch (Exception e) {
      logger.debug("Failed to probe fastOpenServer sysctl, assuming server-side TCP FastOpen cannot be used.", e);
      return false;
    } 
  }
  
  private static native int registerUnix();
  
  private static native int kqueueCreate();
  
  private static native int keventWait(int paramInt1, long paramLong1, int paramInt2, long paramLong2, int paramInt3, int paramInt4, int paramInt5);
  
  static native int keventTriggerUserEvent(int paramInt1, int paramInt2);
  
  static native int keventAddUserEvent(int paramInt1, int paramInt2);
  
  static native int sizeofKEvent();
  
  static native int offsetofKEventIdent();
  
  static native int offsetofKEventFlags();
  
  static native int offsetofKEventFFlags();
  
  static native int offsetofKEventFilter();
  
  static native int offsetofKeventData();
}
