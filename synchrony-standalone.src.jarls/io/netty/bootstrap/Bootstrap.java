package io.netty.bootstrap;

import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.ChannelPromise;
import io.netty.channel.EventLoop;
import io.netty.channel.EventLoopGroup;
import io.netty.resolver.AddressResolver;
import io.netty.resolver.AddressResolverGroup;
import io.netty.util.concurrent.Future;
import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.SocketAddress;

public class Bootstrap extends AbstractBootstrap<Bootstrap, Channel> {
  private static final InternalLogger logger = InternalLoggerFactory.getInstance(Bootstrap.class);
  
  private final BootstrapConfig config = new BootstrapConfig(this);
  
  private ExternalAddressResolver externalResolver;
  
  private Bootstrap(Bootstrap bootstrap) {
    super(bootstrap);
    this.externalResolver = bootstrap.externalResolver;
    this.disableResolver = bootstrap.disableResolver;
    this.remoteAddress = bootstrap.remoteAddress;
  }
  
  public Bootstrap resolver(AddressResolverGroup<?> resolver) {
    this.externalResolver = (resolver == null) ? null : new ExternalAddressResolver(resolver);
    this.disableResolver = false;
    return this;
  }
  
  public Bootstrap disableResolver() {
    this.externalResolver = null;
    this.disableResolver = true;
    return this;
  }
  
  public Bootstrap remoteAddress(SocketAddress remoteAddress) {
    this.remoteAddress = remoteAddress;
    return this;
  }
  
  public Bootstrap remoteAddress(String inetHost, int inetPort) {
    this.remoteAddress = InetSocketAddress.createUnresolved(inetHost, inetPort);
    return this;
  }
  
  public Bootstrap remoteAddress(InetAddress inetHost, int inetPort) {
    this.remoteAddress = new InetSocketAddress(inetHost, inetPort);
    return this;
  }
  
  public ChannelFuture connect() {
    validate();
    SocketAddress remoteAddress = this.remoteAddress;
    if (remoteAddress == null)
      throw new IllegalStateException("remoteAddress not set"); 
    return doResolveAndConnect(remoteAddress, this.config.localAddress());
  }
  
  public ChannelFuture connect(String inetHost, int inetPort) { return connect(InetSocketAddress.createUnresolved(inetHost, inetPort)); }
  
  public ChannelFuture connect(InetAddress inetHost, int inetPort) { return connect(new InetSocketAddress(inetHost, inetPort)); }
  
  public ChannelFuture connect(SocketAddress remoteAddress) {
    ObjectUtil.checkNotNull(remoteAddress, "remoteAddress");
    validate();
    return doResolveAndConnect(remoteAddress, this.config.localAddress());
  }
  
  public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress) {
    ObjectUtil.checkNotNull(remoteAddress, "remoteAddress");
    validate();
    return doResolveAndConnect(remoteAddress, localAddress);
  }
  
  private ChannelFuture doResolveAndConnect(SocketAddress remoteAddress, SocketAddress localAddress) {
    ChannelFuture regFuture = initAndRegister();
    Channel channel = regFuture.channel();
    if (regFuture.isDone()) {
      if (!regFuture.isSuccess())
        return regFuture; 
      return doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());
    } 
    AbstractBootstrap.PendingRegistrationPromise promise = new AbstractBootstrap.PendingRegistrationPromise(channel);
    regFuture.addListener(new Object(this, promise, channel, remoteAddress, localAddress));
    return promise;
  }
  
  private ChannelFuture doResolveAndConnect0(Channel channel, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {
    try {
      AddressResolver<SocketAddress> resolver;
      if (this.disableResolver) {
        doConnect(remoteAddress, localAddress, promise);
        return promise;
      } 
      EventLoop eventLoop = channel.eventLoop();
      try {
        resolver = ExternalAddressResolver.getOrDefault(this.externalResolver).getResolver(eventLoop);
      } catch (Throwable cause) {
        channel.close();
        return promise.setFailure(cause);
      } 
      if (!resolver.isSupported(remoteAddress) || resolver.isResolved(remoteAddress)) {
        doConnect(remoteAddress, localAddress, promise);
        return promise;
      } 
      Future<SocketAddress> resolveFuture = resolver.resolve(remoteAddress);
      if (resolveFuture.isDone()) {
        Throwable resolveFailureCause = resolveFuture.cause();
        if (resolveFailureCause != null) {
          channel.close();
          promise.setFailure(resolveFailureCause);
        } else {
          doConnect((SocketAddress)resolveFuture.getNow(), localAddress, promise);
        } 
        return promise;
      } 
      resolveFuture.addListener(new Object(this, channel, promise, localAddress));
    } catch (Throwable cause) {
      promise.tryFailure(cause);
    } 
    return promise;
  }
  
  private static void doConnect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise connectPromise) {
    Channel channel = connectPromise.channel();
    channel.eventLoop().execute(new Object(localAddress, channel, remoteAddress, connectPromise));
  }
  
  void init(Channel channel) {
    ChannelPipeline p = channel.pipeline();
    p.addLast(new ChannelHandler[] { this.config.handler() });
    setChannelOptions(channel, newOptionsArray(), logger);
    setAttributes(channel, newAttributesArray());
  }
  
  public Bootstrap validate() {
    super.validate();
    if (this.config.handler() == null)
      throw new IllegalStateException("handler not set"); 
    return this;
  }
  
  public Bootstrap clone() { return new Bootstrap(this); }
  
  public Bootstrap clone(EventLoopGroup group) {
    Bootstrap bs = new Bootstrap(this);
    bs.group = group;
    return bs;
  }
  
  public final BootstrapConfig config() { return this.config; }
  
  final SocketAddress remoteAddress() { return this.remoteAddress; }
  
  final AddressResolverGroup<?> resolver() {
    if (this.disableResolver)
      return null; 
    return ExternalAddressResolver.getOrDefault(this.externalResolver);
  }
  
  public Bootstrap() {}
}
