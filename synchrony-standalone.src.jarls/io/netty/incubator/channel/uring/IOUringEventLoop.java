package io.netty.incubator.channel.uring;

import io.netty.channel.EventLoopTaskQueueFactory;
import io.netty.channel.SingleThreadEventLoop;
import io.netty.channel.unix.Errors;
import io.netty.channel.unix.FileDescriptor;
import io.netty.util.collection.IntObjectHashMap;
import io.netty.util.collection.IntObjectMap;
import io.netty.util.concurrent.RejectedExecutionHandler;
import io.netty.util.internal.PlatformDependent;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import java.io.IOException;
import java.util.Queue;
import java.util.concurrent.Executor;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.atomic.AtomicLong;

public final class IOUringEventLoop extends SingleThreadEventLoop {
  private static final InternalLogger logger = InternalLoggerFactory.getInstance(IOUringEventLoop.class);
  
  private final long eventfdReadBuf = PlatformDependent.allocateMemory(8L);
  
  private final IntObjectMap<AbstractIOUringChannel> channels = new IntObjectHashMap(4096);
  
  private final RingBuffer ringBuffer;
  
  private static final long AWAKE = -1L;
  
  private static final long NONE = 9223372036854775807L;
  
  private final AtomicLong nextWakeupNanos = new AtomicLong(-1L);
  
  private final FileDescriptor eventfd;
  
  private final byte[] inet4AddressArray = new byte[4];
  
  private final byte[] inet6AddressArray = new byte[16];
  
  private final IOUringCompletionQueueCallback callback = this::handle;
  
  private final Runnable submitIOTask = () -> getRingBuffer().ioUringSubmissionQueue().submit();
  
  private long prevDeadlineNanos = Float.MAX_VALUE;
  
  private boolean pendingWakeup;
  
  IOUringEventLoop(IOUringEventLoopGroup parent, Executor executor, int ringSize, int iosqeAsyncThreshold, RejectedExecutionHandler rejectedExecutionHandler, EventLoopTaskQueueFactory queueFactory) {
    super(parent, executor, false, newTaskQueue(queueFactory), newTaskQueue(queueFactory), rejectedExecutionHandler);
    IOUring.ensureAvailability();
    this.ringBuffer = Native.createRingBuffer(ringSize, iosqeAsyncThreshold);
    this.eventfd = Native.newBlockingEventFd();
    logger.trace("New EventLoop: {}", toString());
  }
  
  public void submitIO() {
    if (inEventLoop()) {
      getRingBuffer().ioUringSubmissionQueue().submit();
    } else {
      execute(this.submitIOTask);
    } 
  }
  
  private static Queue<Runnable> newTaskQueue(EventLoopTaskQueueFactory queueFactory) {
    if (queueFactory == null)
      return newTaskQueue0(DEFAULT_MAX_PENDING_TASKS); 
    return queueFactory.newTaskQueue(DEFAULT_MAX_PENDING_TASKS);
  }
  
  protected Queue<Runnable> newTaskQueue(int maxPendingTasks) { return newTaskQueue0(maxPendingTasks); }
  
  private static Queue<Runnable> newTaskQueue0(int maxPendingTasks) { return (maxPendingTasks == Integer.MAX_VALUE) ? PlatformDependent.newMpscQueue() : 
      PlatformDependent.newMpscQueue(maxPendingTasks); }
  
  void add(AbstractIOUringChannel ch) {
    if (isShuttingDown())
      throw new RejectedExecutionException("IoEventLoop is shutting down"); 
    logger.trace("Add Channel: {} ", Integer.valueOf(ch.socket.intValue()));
    int fd = ch.socket.intValue();
    if (this.channels.put(fd, ch) == null)
      this.ringBuffer.ioUringSubmissionQueue().incrementHandledFds(); 
  }
  
  void remove(AbstractIOUringChannel ch) {
    logger.trace("Remove Channel: {}", Integer.valueOf(ch.socket.intValue()));
    int fd = ch.socket.intValue();
    AbstractIOUringChannel old = (AbstractIOUringChannel)this.channels.remove(fd);
    if (old != null) {
      this.ringBuffer.ioUringSubmissionQueue().decrementHandledFds();
      if (old != ch) {
        this.channels.put(fd, old);
        assert !ch.isOpen();
      } 
    } 
  }
  
  private void closeAll() {
    logger.trace("CloseAll IOUringEvenloop");
    AbstractIOUringChannel[] localChannels = (AbstractIOUringChannel[])this.channels.values().toArray(new AbstractIOUringChannel[0]);
    for (AbstractIOUringChannel ch : localChannels)
      ch.unsafe().close(ch.unsafe().voidPromise()); 
  }
  
  protected void run() {
    IOUringCompletionQueue completionQueue = this.ringBuffer.ioUringCompletionQueue();
    IOUringSubmissionQueue submissionQueue = this.ringBuffer.ioUringSubmissionQueue();
    addEventFdRead(submissionQueue);
    label49: while (true) {
      try {
        logger.trace("Run IOUringEventLoop {}", this);
        long curDeadlineNanos = nextScheduledTaskDeadlineNanos();
        if (curDeadlineNanos == -1L)
          curDeadlineNanos = Float.MAX_VALUE; 
        this.nextWakeupNanos.set(curDeadlineNanos);
        try {
          if (!hasTasks()) {
            if (curDeadlineNanos != this.prevDeadlineNanos) {
              this.prevDeadlineNanos = curDeadlineNanos;
              submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos), (short)0);
            } 
            if (!completionQueue.hasCompletions()) {
              logger.trace("submitAndWait {}", this);
              submissionQueue.submitAndWait();
            } 
          } 
        } finally {
          if (this.nextWakeupNanos.get() == -1L || this.nextWakeupNanos.getAndSet(-1L) == -1L)
            this.pendingWakeup = true; 
        } 
      } catch (Throwable t) {
        handleLoopException(t);
      } 
      boolean maybeMoreWork = true;
      while (true) {
        try {
          maybeMoreWork = ((completionQueue.process(this.callback) != 0) ? 1 : 0) | runAllTasks();
        } catch (Throwable t) {
          handleLoopException(t);
        } 
        try {
          if (isShuttingDown()) {
            closeAll();
            if (confirmShutdown())
              return; 
            if (!maybeMoreWork)
              maybeMoreWork = (hasTasks() || completionQueue.hasCompletions()); 
          } 
        } catch (Throwable t) {
          handleLoopException(t);
        } 
        if (!maybeMoreWork)
          continue label49; 
      } 
      break;
    } 
  }
  
  void handleLoopException(Throwable t) {
    logger.warn("Unexpected exception in the io_uring event loop", t);
    try {
      Thread.sleep(1000L);
    } catch (InterruptedException interruptedException) {}
  }
  
  private void handle(int fd, int res, int flags, byte op, short data) {
    if (op == Native.IORING_OP_READ && this.eventfd.intValue() == fd) {
      this.pendingWakeup = false;
      addEventFdRead(this.ringBuffer.ioUringSubmissionQueue());
    } else if (op == Native.IORING_OP_TIMEOUT) {
      if (res == Native.ERRNO_ETIME_NEGATIVE)
        this.prevDeadlineNanos = Float.MAX_VALUE; 
    } else {
      AbstractIOUringChannel channel = (AbstractIOUringChannel)this.channels.get(fd);
      if (channel == null)
        return; 
      if (op == Native.IORING_OP_READ || op == Native.IORING_OP_ACCEPT || op == Native.IORING_OP_RECVMSG) {
        handleRead(channel, res, data);
      } else if (op == Native.IORING_OP_WRITEV || op == Native.IORING_OP_WRITE || op == Native.IORING_OP_SENDMSG) {
        handleWrite(channel, res, data);
      } else if (op == Native.IORING_OP_POLL_ADD) {
        handlePollAdd(channel, res, data);
      } else if (op == Native.IORING_OP_POLL_REMOVE) {
        if (res == Errors.ERRNO_ENOENT_NEGATIVE) {
          logger.trace("IORING_POLL_REMOVE not successful");
        } else if (res == 0) {
          logger.trace("IORING_POLL_REMOVE successful");
        } 
        channel.clearPollFlag(data);
        if (!channel.ioScheduled()) {
          remove(channel);
          return;
        } 
      } else if (op == Native.IORING_OP_CONNECT) {
        handleConnect(channel, res);
      } 
      channel.ioUringUnsafe().processDelayedClose();
    } 
  }
  
  private void handleRead(AbstractIOUringChannel channel, int res, int data) { channel.ioUringUnsafe().readComplete(res, data); }
  
  private void handleWrite(AbstractIOUringChannel channel, int res, int data) { channel.ioUringUnsafe().writeComplete(res, data); }
  
  private void handlePollAdd(AbstractIOUringChannel channel, int res, int pollMask) {
    if ((pollMask & Native.POLLOUT) != 0)
      channel.ioUringUnsafe().pollOut(res); 
    if ((pollMask & Native.POLLIN) != 0)
      channel.ioUringUnsafe().pollIn(res); 
    if ((pollMask & Native.POLLRDHUP) != 0)
      channel.ioUringUnsafe().pollRdHup(res); 
  }
  
  private void addEventFdRead(IOUringSubmissionQueue submissionQueue) { submissionQueue.addEventFdRead(this.eventfd.intValue(), this.eventfdReadBuf, 0, 8, (short)0); }
  
  private void handleConnect(AbstractIOUringChannel channel, int res) { channel.ioUringUnsafe().connectComplete(res); }
  
  protected void cleanup() {
    IOUringCompletionQueue completionQueue = this.ringBuffer.ioUringCompletionQueue();
    IOUringSubmissionQueue submissionQueue = this.ringBuffer.ioUringSubmissionQueue();
    if (this.pendingWakeup) {
      Object object = new Object(this);
      completionQueue.process(object);
      while (this.pendingWakeup) {
        completionQueue.ioUringWaitCqe();
        completionQueue.process(object);
      } 
    } 
    closeAll();
    while (!this.channels.isEmpty()) {
      if (!runAllTasks()) {
        submissionQueue.submitAndWait();
        completionQueue.process(this.callback);
      } 
    } 
    try {
      this.eventfd.close();
    } catch (IOException e) {
      logger.warn("Failed to close the event fd.", e);
    } 
    PlatformDependent.freeMemory(this.eventfdReadBuf);
    this.ringBuffer.close();
  }
  
  RingBuffer getRingBuffer() { return this.ringBuffer; }
  
  protected void wakeup(boolean inEventLoop) {
    if (!inEventLoop && this.nextWakeupNanos.getAndSet(-1L) != -1L)
      Native.eventFdWrite(this.eventfd.intValue(), 1L); 
  }
  
  byte[] inet4AddressArray() { return this.inet4AddressArray; }
  
  byte[] inet6AddressArray() { return this.inet6AddressArray; }
}
