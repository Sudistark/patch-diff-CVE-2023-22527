package io.netty.buffer;

import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

final class PoolThreadCache {
  private static final InternalLogger logger = InternalLoggerFactory.getInstance(PoolThreadCache.class);
  
  private static final int INTEGER_SIZE_MINUS_ONE = 31;
  
  final PoolArena<byte[]> heapArena;
  
  final PoolArena<ByteBuffer> directArena;
  
  private final MemoryRegionCache<byte[]>[] smallSubPageHeapCaches;
  
  private final MemoryRegionCache<ByteBuffer>[] smallSubPageDirectCaches;
  
  private final MemoryRegionCache<byte[]>[] normalHeapCaches;
  
  private final MemoryRegionCache<ByteBuffer>[] normalDirectCaches;
  
  private final int freeSweepAllocationThreshold;
  
  private final AtomicBoolean freed;
  
  private final FreeOnFinalize freeOnFinalize;
  
  private int allocations;
  
  PoolThreadCache(PoolArena<byte[]> heapArena, PoolArena<ByteBuffer> directArena, int smallCacheSize, int normalCacheSize, int maxCachedBufferCapacity, int freeSweepAllocationThreshold, boolean useFinalizer) {
    this.freed = new AtomicBoolean();
    ObjectUtil.checkPositiveOrZero(maxCachedBufferCapacity, "maxCachedBufferCapacity");
    this.freeSweepAllocationThreshold = freeSweepAllocationThreshold;
    this.heapArena = heapArena;
    this.directArena = directArena;
    if (directArena != null) {
      this.smallSubPageDirectCaches = createSubPageCaches(smallCacheSize, directArena.numSmallSubpagePools);
      this.normalDirectCaches = createNormalCaches(normalCacheSize, maxCachedBufferCapacity, directArena);
      directArena.numThreadCaches.getAndIncrement();
    } else {
      this.smallSubPageDirectCaches = null;
      this.normalDirectCaches = null;
    } 
    if (heapArena != null) {
      this.smallSubPageHeapCaches = createSubPageCaches(smallCacheSize, heapArena.numSmallSubpagePools);
      this.normalHeapCaches = createNormalCaches(normalCacheSize, maxCachedBufferCapacity, heapArena);
      heapArena.numThreadCaches.getAndIncrement();
    } else {
      this.smallSubPageHeapCaches = null;
      this.normalHeapCaches = null;
    } 
    if ((this.smallSubPageDirectCaches != null || this.normalDirectCaches != null || this.smallSubPageHeapCaches != null || this.normalHeapCaches != null) && freeSweepAllocationThreshold < 1)
      throw new IllegalArgumentException("freeSweepAllocationThreshold: " + freeSweepAllocationThreshold + " (expected: > 0)"); 
    this.freeOnFinalize = useFinalizer ? new FreeOnFinalize(this, null) : null;
  }
  
  private static <T> MemoryRegionCache<T>[] createSubPageCaches(int cacheSize, int numCaches) {
    if (cacheSize > 0 && numCaches > 0) {
      MemoryRegionCache[] arrayOfMemoryRegionCache = new MemoryRegionCache[numCaches];
      for (int i = 0; i < arrayOfMemoryRegionCache.length; i++)
        arrayOfMemoryRegionCache[i] = new SubPageMemoryRegionCache(cacheSize); 
      return arrayOfMemoryRegionCache;
    } 
    return null;
  }
  
  private static <T> MemoryRegionCache<T>[] createNormalCaches(int cacheSize, int maxCachedBufferCapacity, PoolArena<T> area) {
    if (cacheSize > 0 && maxCachedBufferCapacity > 0) {
      int max = Math.min(area.chunkSize, maxCachedBufferCapacity);
      List<MemoryRegionCache<T>> cache = new ArrayList<MemoryRegionCache<T>>();
      for (int idx = area.numSmallSubpagePools; idx < area.nSizes && area.sizeIdx2size(idx) <= max; idx++)
        cache.add(new NormalMemoryRegionCache(cacheSize)); 
      return (MemoryRegionCache[])cache.toArray(new MemoryRegionCache[0]);
    } 
    return null;
  }
  
  static int log2(int val) { return 31 - Integer.numberOfLeadingZeros(val); }
  
  boolean allocateSmall(PoolArena<?> area, PooledByteBuf<?> buf, int reqCapacity, int sizeIdx) { return allocate(cacheForSmall(area, sizeIdx), buf, reqCapacity); }
  
  boolean allocateNormal(PoolArena<?> area, PooledByteBuf<?> buf, int reqCapacity, int sizeIdx) { return allocate(cacheForNormal(area, sizeIdx), buf, reqCapacity); }
  
  private boolean allocate(MemoryRegionCache<?> cache, PooledByteBuf buf, int reqCapacity) {
    if (cache == null)
      return false; 
    boolean allocated = cache.allocate(buf, reqCapacity, this);
    if (++this.allocations >= this.freeSweepAllocationThreshold) {
      this.allocations = 0;
      trim();
    } 
    return allocated;
  }
  
  boolean add(PoolArena<?> area, PoolChunk chunk, ByteBuffer nioBuffer, long handle, int normCapacity, PoolArena.SizeClass sizeClass) {
    int sizeIdx = area.size2SizeIdx(normCapacity);
    MemoryRegionCache<?> cache = cache(area, sizeIdx, sizeClass);
    if (cache == null)
      return false; 
    if (this.freed.get())
      return false; 
    return cache.add(chunk, nioBuffer, handle, normCapacity);
  }
  
  private MemoryRegionCache<?> cache(PoolArena<?> area, int sizeIdx, PoolArena.SizeClass sizeClass) {
    switch (null.$SwitchMap$io$netty$buffer$PoolArena$SizeClass[sizeClass.ordinal()]) {
      case 1:
        return cacheForNormal(area, sizeIdx);
      case 2:
        return cacheForSmall(area, sizeIdx);
    } 
    throw new Error();
  }
  
  void free(boolean finalizer) {
    if (this.freed.compareAndSet(false, true)) {
      int numFreed = free(this.smallSubPageDirectCaches, finalizer) + free(this.normalDirectCaches, finalizer) + free(this.smallSubPageHeapCaches, finalizer) + free(this.normalHeapCaches, finalizer);
      if (numFreed > 0 && logger.isDebugEnabled())
        logger.debug("Freed {} thread-local buffer(s) from thread: {}", Integer.valueOf(numFreed), 
            Thread.currentThread().getName()); 
      if (this.directArena != null)
        this.directArena.numThreadCaches.getAndDecrement(); 
      if (this.heapArena != null)
        this.heapArena.numThreadCaches.getAndDecrement(); 
    } else {
      checkCacheMayLeak(this.smallSubPageDirectCaches, "SmallSubPageDirectCaches");
      checkCacheMayLeak(this.normalDirectCaches, "NormalDirectCaches");
      checkCacheMayLeak(this.smallSubPageHeapCaches, "SmallSubPageHeapCaches");
      checkCacheMayLeak(this.normalHeapCaches, "NormalHeapCaches");
    } 
  }
  
  private static void checkCacheMayLeak(MemoryRegionCache[] caches, String type) {
    for (MemoryRegionCache<?> cache : caches) {
      if (!MemoryRegionCache.access$100(cache).isEmpty()) {
        logger.debug("{} memory may leak.", type);
        return;
      } 
    } 
  }
  
  private static int free(MemoryRegionCache[] caches, boolean finalizer) {
    if (caches == null)
      return 0; 
    int numFreed = 0;
    for (MemoryRegionCache<?> c : caches)
      numFreed += free(c, finalizer); 
    return numFreed;
  }
  
  private static int free(MemoryRegionCache<?> cache, boolean finalizer) {
    if (cache == null)
      return 0; 
    return cache.free(finalizer);
  }
  
  void trim() {
    trim(this.smallSubPageDirectCaches);
    trim(this.normalDirectCaches);
    trim(this.smallSubPageHeapCaches);
    trim(this.normalHeapCaches);
  }
  
  private static void trim(MemoryRegionCache[] caches) {
    if (caches == null)
      return; 
    for (MemoryRegionCache<?> c : caches)
      trim(c); 
  }
  
  private static void trim(MemoryRegionCache<?> cache) {
    if (cache == null)
      return; 
    cache.trim();
  }
  
  private MemoryRegionCache<?> cacheForSmall(PoolArena<?> area, int sizeIdx) {
    if (area.isDirect())
      return cache(this.smallSubPageDirectCaches, sizeIdx); 
    return cache(this.smallSubPageHeapCaches, sizeIdx);
  }
  
  private MemoryRegionCache<?> cacheForNormal(PoolArena<?> area, int sizeIdx) {
    int idx = sizeIdx - area.numSmallSubpagePools;
    if (area.isDirect())
      return cache(this.normalDirectCaches, idx); 
    return cache(this.normalHeapCaches, idx);
  }
  
  private static <T> MemoryRegionCache<T> cache(MemoryRegionCache[] cache, int sizeIdx) {
    if (cache == null || sizeIdx > cache.length - 1)
      return null; 
    return cache[sizeIdx];
  }
}
