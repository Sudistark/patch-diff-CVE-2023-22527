package io.netty.buffer;

import io.netty.util.internal.PlatformDependent;

public final class UnpooledByteBufAllocator extends AbstractByteBufAllocator implements ByteBufAllocatorMetricProvider {
  private final UnpooledByteBufAllocatorMetric metric = new UnpooledByteBufAllocatorMetric(null);
  
  private final boolean disableLeakDetector;
  
  private final boolean noCleaner;
  
  public static final UnpooledByteBufAllocator DEFAULT = new UnpooledByteBufAllocator(
      PlatformDependent.directBufferPreferred());
  
  public UnpooledByteBufAllocator(boolean preferDirect) { this(preferDirect, false); }
  
  public UnpooledByteBufAllocator(boolean preferDirect, boolean disableLeakDetector) { this(preferDirect, disableLeakDetector, PlatformDependent.useDirectBufferNoCleaner()); }
  
  public UnpooledByteBufAllocator(boolean preferDirect, boolean disableLeakDetector, boolean tryNoCleaner) {
    super(preferDirect);
    this.disableLeakDetector = disableLeakDetector;
    this
      .noCleaner = (tryNoCleaner && PlatformDependent.hasUnsafe() && PlatformDependent.hasDirectBufferNoCleanerConstructor());
  }
  
  protected ByteBuf newHeapBuffer(int initialCapacity, int maxCapacity) { return PlatformDependent.hasUnsafe() ? new InstrumentedUnpooledUnsafeHeapByteBuf(this, initialCapacity, maxCapacity) : new InstrumentedUnpooledHeapByteBuf(this, initialCapacity, maxCapacity); }
  
  protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) {
    InstrumentedUnpooledDirectByteBuf instrumentedUnpooledDirectByteBuf;
    if (PlatformDependent.hasUnsafe()) {
      instrumentedUnpooledDirectByteBuf = this.noCleaner ? new InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf(this, initialCapacity, maxCapacity) : new InstrumentedUnpooledUnsafeDirectByteBuf(this, initialCapacity, maxCapacity);
    } else {
      instrumentedUnpooledDirectByteBuf = new InstrumentedUnpooledDirectByteBuf(this, initialCapacity, maxCapacity);
    } 
    return this.disableLeakDetector ? instrumentedUnpooledDirectByteBuf : toLeakAwareBuffer(instrumentedUnpooledDirectByteBuf);
  }
  
  public CompositeByteBuf compositeHeapBuffer(int maxNumComponents) {
    CompositeByteBuf buf = new CompositeByteBuf(this, false, maxNumComponents);
    return this.disableLeakDetector ? buf : toLeakAwareBuffer(buf);
  }
  
  public CompositeByteBuf compositeDirectBuffer(int maxNumComponents) {
    CompositeByteBuf buf = new CompositeByteBuf(this, true, maxNumComponents);
    return this.disableLeakDetector ? buf : toLeakAwareBuffer(buf);
  }
  
  public boolean isDirectBufferPooled() { return false; }
  
  public ByteBufAllocatorMetric metric() { return this.metric; }
  
  void incrementDirect(int amount) { this.metric.directCounter.add(amount); }
  
  void decrementDirect(int amount) { this.metric.directCounter.add(-amount); }
  
  void incrementHeap(int amount) { this.metric.heapCounter.add(amount); }
  
  void decrementHeap(int amount) { this.metric.heapCounter.add(-amount); }
}
