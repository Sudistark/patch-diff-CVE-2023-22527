package io.netty.handler.proxy;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelPipeline;
import io.netty.handler.codec.base64.Base64;
import io.netty.handler.codec.http.DefaultFullHttpRequest;
import io.netty.handler.codec.http.HttpHeaderNames;
import io.netty.handler.codec.http.HttpHeaders;
import io.netty.handler.codec.http.HttpMethod;
import io.netty.handler.codec.http.HttpResponse;
import io.netty.handler.codec.http.HttpResponseStatus;
import io.netty.handler.codec.http.HttpUtil;
import io.netty.handler.codec.http.HttpVersion;
import io.netty.util.AsciiString;
import io.netty.util.CharsetUtil;
import io.netty.util.internal.ObjectUtil;
import java.net.InetSocketAddress;
import java.net.SocketAddress;

public final class HttpProxyHandler extends ProxyHandler {
  private static final String PROTOCOL = "http";
  
  private static final String AUTH_BASIC = "basic";
  
  private final HttpClientCodecWrapper codecWrapper = new HttpClientCodecWrapper(null);
  
  private final String username;
  
  private final String password;
  
  private final CharSequence authorization;
  
  private final HttpHeaders outboundHeaders;
  
  private final boolean ignoreDefaultPortsInConnectHostHeader;
  
  private HttpResponseStatus status;
  
  private HttpHeaders inboundHeaders;
  
  public HttpProxyHandler(SocketAddress proxyAddress) { this(proxyAddress, null); }
  
  public HttpProxyHandler(SocketAddress proxyAddress, HttpHeaders headers) { this(proxyAddress, headers, false); }
  
  public HttpProxyHandler(SocketAddress proxyAddress, HttpHeaders headers, boolean ignoreDefaultPortsInConnectHostHeader) {
    super(proxyAddress);
    this.username = null;
    this.password = null;
    this.authorization = null;
    this.outboundHeaders = headers;
    this.ignoreDefaultPortsInConnectHostHeader = ignoreDefaultPortsInConnectHostHeader;
  }
  
  public HttpProxyHandler(SocketAddress proxyAddress, String username, String password) { this(proxyAddress, username, password, null); }
  
  public HttpProxyHandler(SocketAddress proxyAddress, String username, String password, HttpHeaders headers) { this(proxyAddress, username, password, headers, false); }
  
  public HttpProxyHandler(SocketAddress proxyAddress, String username, String password, HttpHeaders headers, boolean ignoreDefaultPortsInConnectHostHeader) {
    super(proxyAddress);
    this.username = (String)ObjectUtil.checkNotNull(username, "username");
    this.password = (String)ObjectUtil.checkNotNull(password, "password");
    authz = Unpooled.copiedBuffer(username + ':' + password, CharsetUtil.UTF_8);
    try {
      authzBase64 = Base64.encode(authz, false);
    } finally {
      authz.release();
    } 
    try {
      this.authorization = new AsciiString("Basic " + authzBase64.toString(CharsetUtil.US_ASCII));
    } finally {
      authzBase64.release();
    } 
    this.outboundHeaders = headers;
    this.ignoreDefaultPortsInConnectHostHeader = ignoreDefaultPortsInConnectHostHeader;
  }
  
  public String protocol() { return "http"; }
  
  public String authScheme() { return (this.authorization != null) ? "basic" : "none"; }
  
  public String username() { return this.username; }
  
  public String password() { return this.password; }
  
  protected void addCodec(ChannelHandlerContext ctx) throws Exception {
    ChannelPipeline p = ctx.pipeline();
    String name = ctx.name();
    p.addBefore(name, null, this.codecWrapper);
  }
  
  protected void removeEncoder(ChannelHandlerContext ctx) throws Exception { this.codecWrapper.codec.removeOutboundHandler(); }
  
  protected void removeDecoder(ChannelHandlerContext ctx) throws Exception { this.codecWrapper.codec.removeInboundHandler(); }
  
  protected Object newInitialMessage(ChannelHandlerContext ctx) throws Exception {
    InetSocketAddress raddr = (InetSocketAddress)destinationAddress();
    String hostString = HttpUtil.formatHostnameForHttp(raddr);
    int port = raddr.getPort();
    String url = hostString + ":" + port;
    String hostHeader = (this.ignoreDefaultPortsInConnectHostHeader && (port == 80 || port == 443)) ? hostString : url;
    DefaultFullHttpRequest defaultFullHttpRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.CONNECT, url, Unpooled.EMPTY_BUFFER, false);
    defaultFullHttpRequest.headers().set(HttpHeaderNames.HOST, hostHeader);
    if (this.authorization != null)
      defaultFullHttpRequest.headers().set(HttpHeaderNames.PROXY_AUTHORIZATION, this.authorization); 
    if (this.outboundHeaders != null)
      defaultFullHttpRequest.headers().add(this.outboundHeaders); 
    return defaultFullHttpRequest;
  }
  
  protected boolean handleResponse(ChannelHandlerContext ctx, Object response) throws Exception {
    if (response instanceof HttpResponse) {
      if (this.status != null)
        throw new HttpProxyConnectException(exceptionMessage("too many responses"), null); 
      HttpResponse res = (HttpResponse)response;
      this.status = res.status();
      this.inboundHeaders = res.headers();
    } 
    boolean finished = response instanceof io.netty.handler.codec.http.LastHttpContent;
    if (finished) {
      if (this.status == null)
        throw new HttpProxyConnectException(exceptionMessage("missing response"), this.inboundHeaders); 
      if (this.status.code() != 200)
        throw new HttpProxyConnectException(exceptionMessage("status: " + this.status), this.inboundHeaders); 
    } 
    return finished;
  }
}
