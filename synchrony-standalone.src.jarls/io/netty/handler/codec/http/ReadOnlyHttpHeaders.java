package io.netty.handler.codec.http;

import io.netty.handler.codec.CharSequenceValueConverter;
import io.netty.util.AsciiString;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public final class ReadOnlyHttpHeaders extends HttpHeaders {
  private final CharSequence[] nameValuePairs;
  
  public ReadOnlyHttpHeaders(boolean validateHeaders, CharSequence... nameValuePairs) {
    if ((nameValuePairs.length & true) != 0)
      throw newInvalidArraySizeException(); 
    if (validateHeaders)
      validateHeaders(nameValuePairs); 
    this.nameValuePairs = nameValuePairs;
  }
  
  private static IllegalArgumentException newInvalidArraySizeException() { return new IllegalArgumentException("nameValuePairs must be arrays of [name, value] pairs"); }
  
  private static void validateHeaders(CharSequence... keyValuePairs) {
    for (int i = 0; i < keyValuePairs.length; i += 2)
      DefaultHttpHeaders.HttpNameValidator.validateName(keyValuePairs[i]); 
  }
  
  private CharSequence get0(CharSequence name) {
    int nameHash = AsciiString.hashCode(name);
    for (int i = 0; i < this.nameValuePairs.length; i += 2) {
      CharSequence roName = this.nameValuePairs[i];
      if (AsciiString.hashCode(roName) == nameHash && AsciiString.contentEqualsIgnoreCase(roName, name))
        return this.nameValuePairs[i + 1]; 
    } 
    return null;
  }
  
  public String get(String name) {
    CharSequence value = get0(name);
    return (value == null) ? null : value.toString();
  }
  
  public Integer getInt(CharSequence name) {
    CharSequence value = get0(name);
    return (value == null) ? null : Integer.valueOf(CharSequenceValueConverter.INSTANCE.convertToInt(value));
  }
  
  public int getInt(CharSequence name, int defaultValue) {
    CharSequence value = get0(name);
    return (value == null) ? defaultValue : CharSequenceValueConverter.INSTANCE.convertToInt(value);
  }
  
  public Short getShort(CharSequence name) {
    CharSequence value = get0(name);
    return (value == null) ? null : Short.valueOf(CharSequenceValueConverter.INSTANCE.convertToShort(value));
  }
  
  public short getShort(CharSequence name, short defaultValue) {
    CharSequence value = get0(name);
    return (value == null) ? defaultValue : CharSequenceValueConverter.INSTANCE.convertToShort(value);
  }
  
  public Long getTimeMillis(CharSequence name) {
    CharSequence value = get0(name);
    return (value == null) ? null : Long.valueOf(CharSequenceValueConverter.INSTANCE.convertToTimeMillis(value));
  }
  
  public long getTimeMillis(CharSequence name, long defaultValue) {
    CharSequence value = get0(name);
    return (value == null) ? defaultValue : CharSequenceValueConverter.INSTANCE.convertToTimeMillis(value);
  }
  
  public List<String> getAll(String name) {
    if (isEmpty())
      return Collections.emptyList(); 
    int nameHash = AsciiString.hashCode(name);
    List<String> values = new ArrayList<String>(4);
    for (int i = 0; i < this.nameValuePairs.length; i += 2) {
      CharSequence roName = this.nameValuePairs[i];
      if (AsciiString.hashCode(roName) == nameHash && AsciiString.contentEqualsIgnoreCase(roName, name))
        values.add(this.nameValuePairs[i + 1].toString()); 
    } 
    return values;
  }
  
  public List<Map.Entry<String, String>> entries() {
    if (isEmpty())
      return Collections.emptyList(); 
    List<Map.Entry<String, String>> entries = new ArrayList<Map.Entry<String, String>>(size());
    for (int i = 0; i < this.nameValuePairs.length; i += 2)
      entries.add(new AbstractMap.SimpleImmutableEntry(this.nameValuePairs[i].toString(), this.nameValuePairs[i + 1]
            .toString())); 
    return entries;
  }
  
  public boolean contains(String name) { return (get0(name) != null); }
  
  public boolean contains(String name, String value, boolean ignoreCase) { return containsValue(name, value, ignoreCase); }
  
  public boolean containsValue(CharSequence name, CharSequence value, boolean ignoreCase) {
    if (ignoreCase) {
      for (int i = 0; i < this.nameValuePairs.length; i += 2) {
        if (AsciiString.contentEqualsIgnoreCase(this.nameValuePairs[i], name) && 
          AsciiString.contentEqualsIgnoreCase(this.nameValuePairs[i + 1], value))
          return true; 
      } 
    } else {
      for (int i = 0; i < this.nameValuePairs.length; i += 2) {
        if (AsciiString.contentEqualsIgnoreCase(this.nameValuePairs[i], name) && 
          AsciiString.contentEquals(this.nameValuePairs[i + 1], value))
          return true; 
      } 
    } 
    return false;
  }
  
  public Iterator<String> valueStringIterator(CharSequence name) { return new ReadOnlyStringValueIterator(this, name); }
  
  public Iterator<CharSequence> valueCharSequenceIterator(CharSequence name) { return new ReadOnlyValueIterator(this, name); }
  
  public Iterator<Map.Entry<String, String>> iterator() { return new ReadOnlyStringIterator(this, null); }
  
  public Iterator<Map.Entry<CharSequence, CharSequence>> iteratorCharSequence() { return new ReadOnlyIterator(this, null); }
  
  public boolean isEmpty() { return (this.nameValuePairs.length == 0); }
  
  public int size() { return this.nameValuePairs.length >>> 1; }
  
  public Set<String> names() {
    if (isEmpty())
      return Collections.emptySet(); 
    Set<String> names = new LinkedHashSet<String>(size());
    for (int i = 0; i < this.nameValuePairs.length; i += 2)
      names.add(this.nameValuePairs[i].toString()); 
    return names;
  }
  
  public HttpHeaders add(String name, Object value) { throw new UnsupportedOperationException("read only"); }
  
  public HttpHeaders add(String name, Iterable<?> values) { throw new UnsupportedOperationException("read only"); }
  
  public HttpHeaders addInt(CharSequence name, int value) { throw new UnsupportedOperationException("read only"); }
  
  public HttpHeaders addShort(CharSequence name, short value) { throw new UnsupportedOperationException("read only"); }
  
  public HttpHeaders set(String name, Object value) { throw new UnsupportedOperationException("read only"); }
  
  public HttpHeaders set(String name, Iterable<?> values) { throw new UnsupportedOperationException("read only"); }
  
  public HttpHeaders setInt(CharSequence name, int value) { throw new UnsupportedOperationException("read only"); }
  
  public HttpHeaders setShort(CharSequence name, short value) { throw new UnsupportedOperationException("read only"); }
  
  public HttpHeaders remove(String name) { throw new UnsupportedOperationException("read only"); }
  
  public HttpHeaders clear() { throw new UnsupportedOperationException("read only"); }
}
