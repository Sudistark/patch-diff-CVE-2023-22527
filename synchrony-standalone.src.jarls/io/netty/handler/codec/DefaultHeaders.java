package io.netty.handler.codec;

import io.netty.util.HashingStrategy;
import io.netty.util.internal.MathUtil;
import io.netty.util.internal.ObjectUtil;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class DefaultHeaders<K, V, T extends Headers<K, V, T>> extends Object implements Headers<K, V, T> {
  static final int HASH_CODE_SEED = -1028477387;
  
  private final HeaderEntry<K, V>[] entries;
  
  protected final HeaderEntry<K, V> head;
  
  private final byte hashMask;
  
  private final ValueConverter<V> valueConverter;
  
  private final NameValidator<K> nameValidator;
  
  private final ValueValidator<V> valueValidator;
  
  private final HashingStrategy<K> hashingStrategy;
  
  int size;
  
  public DefaultHeaders(ValueConverter<V> valueConverter) { this(HashingStrategy.JAVA_HASHER, valueConverter); }
  
  public DefaultHeaders(ValueConverter<V> valueConverter, NameValidator<K> nameValidator) { this(HashingStrategy.JAVA_HASHER, valueConverter, nameValidator); }
  
  public DefaultHeaders(HashingStrategy<K> nameHashingStrategy, ValueConverter<V> valueConverter) { this(nameHashingStrategy, valueConverter, NameValidator.NOT_NULL); }
  
  public DefaultHeaders(HashingStrategy<K> nameHashingStrategy, ValueConverter<V> valueConverter, NameValidator<K> nameValidator) { this(nameHashingStrategy, valueConverter, nameValidator, 16); }
  
  public DefaultHeaders(HashingStrategy<K> nameHashingStrategy, ValueConverter<V> valueConverter, NameValidator<K> nameValidator, int arraySizeHint) { this(nameHashingStrategy, valueConverter, nameValidator, arraySizeHint, ValueValidator.NO_VALIDATION); }
  
  public DefaultHeaders(HashingStrategy<K> nameHashingStrategy, ValueConverter<V> valueConverter, NameValidator<K> nameValidator, int arraySizeHint, ValueValidator<V> valueValidator) {
    this.valueConverter = (ValueConverter)ObjectUtil.checkNotNull(valueConverter, "valueConverter");
    this.nameValidator = (NameValidator)ObjectUtil.checkNotNull(nameValidator, "nameValidator");
    this.hashingStrategy = (HashingStrategy)ObjectUtil.checkNotNull(nameHashingStrategy, "nameHashingStrategy");
    this.valueValidator = (ValueValidator)ObjectUtil.checkNotNull(valueValidator, "valueValidator");
    this.entries = new HeaderEntry[MathUtil.findNextPositivePowerOfTwo(Math.max(2, Math.min(arraySizeHint, 128)))];
    this.hashMask = (byte)(this.entries.length - 1);
    this.head = new HeaderEntry();
  }
  
  public V get(K name) {
    ObjectUtil.checkNotNull(name, "name");
    int h = this.hashingStrategy.hashCode(name);
    int i = index(h);
    HeaderEntry<K, V> e = this.entries[i];
    V value = null;
    while (e != null) {
      if (e.hash == h && this.hashingStrategy.equals(name, e.key))
        value = (V)e.value; 
      e = e.next;
    } 
    return value;
  }
  
  public V get(K name, V defaultValue) {
    V value = (V)get(name);
    if (value == null)
      return defaultValue; 
    return value;
  }
  
  public V getAndRemove(K name) {
    int h = this.hashingStrategy.hashCode(name);
    return (V)remove0(h, index(h), ObjectUtil.checkNotNull(name, "name"));
  }
  
  public V getAndRemove(K name, V defaultValue) {
    V value = (V)getAndRemove(name);
    if (value == null)
      return defaultValue; 
    return value;
  }
  
  public List<V> getAll(K name) {
    ObjectUtil.checkNotNull(name, "name");
    LinkedList<V> values = new LinkedList<V>();
    int h = this.hashingStrategy.hashCode(name);
    int i = index(h);
    HeaderEntry<K, V> e = this.entries[i];
    while (e != null) {
      if (e.hash == h && this.hashingStrategy.equals(name, e.key))
        values.addFirst(e.getValue()); 
      e = e.next;
    } 
    return values;
  }
  
  public Iterator<V> valueIterator(K name) { return new ValueIterator(this, name); }
  
  public List<V> getAllAndRemove(K name) {
    List<V> all = getAll(name);
    remove(name);
    return all;
  }
  
  public boolean contains(K name) { return (get(name) != null); }
  
  public boolean containsObject(K name, Object value) { return contains(name, fromObject(name, value)); }
  
  public boolean containsBoolean(K name, boolean value) { return contains(name, fromBoolean(name, value)); }
  
  public boolean containsByte(K name, byte value) { return contains(name, fromByte(name, value)); }
  
  public boolean containsChar(K name, char value) { return contains(name, fromChar(name, value)); }
  
  public boolean containsShort(K name, short value) { return contains(name, fromShort(name, value)); }
  
  public boolean containsInt(K name, int value) { return contains(name, fromInt(name, value)); }
  
  public boolean containsLong(K name, long value) { return contains(name, fromLong(name, value)); }
  
  public boolean containsFloat(K name, float value) { return contains(name, fromFloat(name, value)); }
  
  public boolean containsDouble(K name, double value) { return contains(name, fromDouble(name, value)); }
  
  public boolean containsTimeMillis(K name, long value) { return contains(name, fromTimeMillis(name, value)); }
  
  public boolean contains(K name, V value) { return contains(name, value, HashingStrategy.JAVA_HASHER); }
  
  public final boolean contains(K name, V value, HashingStrategy<? super V> valueHashingStrategy) {
    ObjectUtil.checkNotNull(name, "name");
    int h = this.hashingStrategy.hashCode(name);
    int i = index(h);
    HeaderEntry<K, V> e = this.entries[i];
    while (e != null) {
      if (e.hash == h && this.hashingStrategy.equals(name, e.key) && valueHashingStrategy.equals(value, e.value))
        return true; 
      e = e.next;
    } 
    return false;
  }
  
  public int size() { return this.size; }
  
  public boolean isEmpty() { return (this.head == this.head.after); }
  
  public Set<K> names() {
    if (isEmpty())
      return Collections.emptySet(); 
    Set<K> names = new LinkedHashSet<K>(size());
    HeaderEntry<K, V> e = this.head.after;
    while (e != this.head) {
      names.add(e.getKey());
      e = e.after;
    } 
    return names;
  }
  
  public T add(K name, V value) {
    validateName(this.nameValidator, true, name);
    validateValue(this.valueValidator, name, value);
    ObjectUtil.checkNotNull(value, "value");
    int h = this.hashingStrategy.hashCode(name);
    int i = index(h);
    add0(h, i, name, value);
    return (T)thisT();
  }
  
  public T add(K name, Iterable<? extends V> values) {
    validateName(this.nameValidator, true, name);
    int h = this.hashingStrategy.hashCode(name);
    int i = index(h);
    for (V v : values) {
      validateValue(this.valueValidator, name, v);
      add0(h, i, name, v);
    } 
    return (T)thisT();
  }
  
  public T add(K name, V... values) {
    validateName(this.nameValidator, true, name);
    int h = this.hashingStrategy.hashCode(name);
    int i = index(h);
    for (V v : values) {
      validateValue(this.valueValidator, name, v);
      add0(h, i, name, v);
    } 
    return (T)thisT();
  }
  
  public T addObject(K name, Object value) { return (T)add(name, fromObject(name, value)); }
  
  public T addObject(K name, Iterable<?> values) {
    for (Object value : values)
      addObject(name, value); 
    return (T)thisT();
  }
  
  public T addObject(K name, Object... values) {
    for (Object value : values)
      addObject(name, value); 
    return (T)thisT();
  }
  
  public T addInt(K name, int value) { return (T)add(name, fromInt(name, value)); }
  
  public T addLong(K name, long value) { return (T)add(name, fromLong(name, value)); }
  
  public T addDouble(K name, double value) { return (T)add(name, fromDouble(name, value)); }
  
  public T addTimeMillis(K name, long value) { return (T)add(name, fromTimeMillis(name, value)); }
  
  public T addChar(K name, char value) { return (T)add(name, fromChar(name, value)); }
  
  public T addBoolean(K name, boolean value) { return (T)add(name, fromBoolean(name, value)); }
  
  public T addFloat(K name, float value) { return (T)add(name, fromFloat(name, value)); }
  
  public T addByte(K name, byte value) { return (T)add(name, fromByte(name, value)); }
  
  public T addShort(K name, short value) { return (T)add(name, fromShort(name, value)); }
  
  public T add(Headers<? extends K, ? extends V, ?> headers) {
    if (headers == this)
      throw new IllegalArgumentException("can't add to itself."); 
    addImpl(headers);
    return (T)thisT();
  }
  
  protected void addImpl(Headers<? extends K, ? extends V, ?> headers) {
    if (headers instanceof DefaultHeaders) {
      DefaultHeaders<? extends K, ? extends V, T> defaultHeaders = (DefaultHeaders)headers;
      HeaderEntry<? extends K, ? extends V> e = defaultHeaders.head.after;
      if (defaultHeaders.hashingStrategy == this.hashingStrategy && defaultHeaders.nameValidator == this.nameValidator) {
        while (e != defaultHeaders.head) {
          add0(e.hash, index(e.hash), e.key, e.value);
          e = e.after;
        } 
      } else {
        while (e != defaultHeaders.head) {
          add(e.key, e.value);
          e = e.after;
        } 
      } 
    } else {
      for (Map.Entry<? extends K, ? extends V> header : headers)
        add(header.getKey(), header.getValue()); 
    } 
  }
  
  public T set(K name, V value) {
    validateName(this.nameValidator, false, name);
    validateValue(this.valueValidator, name, value);
    ObjectUtil.checkNotNull(value, "value");
    int h = this.hashingStrategy.hashCode(name);
    int i = index(h);
    remove0(h, i, name);
    add0(h, i, name, value);
    return (T)thisT();
  }
  
  public T set(K name, Iterable<? extends V> values) {
    validateName(this.nameValidator, false, name);
    ObjectUtil.checkNotNull(values, "values");
    int h = this.hashingStrategy.hashCode(name);
    int i = index(h);
    remove0(h, i, name);
    for (V v : values) {
      if (v == null)
        break; 
      validateValue(this.valueValidator, name, v);
      add0(h, i, name, v);
    } 
    return (T)thisT();
  }
  
  public T set(K name, V... values) {
    validateName(this.nameValidator, false, name);
    ObjectUtil.checkNotNull(values, "values");
    int h = this.hashingStrategy.hashCode(name);
    int i = index(h);
    remove0(h, i, name);
    for (V v : values) {
      if (v == null)
        break; 
      validateValue(this.valueValidator, name, v);
      add0(h, i, name, v);
    } 
    return (T)thisT();
  }
  
  public T setObject(K name, Object value) {
    V convertedValue = (V)ObjectUtil.checkNotNull(fromObject(name, value), "convertedValue");
    return (T)set(name, convertedValue);
  }
  
  public T setObject(K name, Iterable<?> values) {
    validateName(this.nameValidator, false, name);
    int h = this.hashingStrategy.hashCode(name);
    int i = index(h);
    remove0(h, i, name);
    for (Object v : values) {
      if (v == null)
        break; 
      V converted = (V)fromObject(name, v);
      validateValue(this.valueValidator, name, converted);
      add0(h, i, name, converted);
    } 
    return (T)thisT();
  }
  
  public T setObject(K name, Object... values) {
    validateName(this.nameValidator, false, name);
    int h = this.hashingStrategy.hashCode(name);
    int i = index(h);
    remove0(h, i, name);
    for (Object v : values) {
      if (v == null)
        break; 
      V converted = (V)fromObject(name, v);
      validateValue(this.valueValidator, name, converted);
      add0(h, i, name, converted);
    } 
    return (T)thisT();
  }
  
  public T setInt(K name, int value) { return (T)set(name, fromInt(name, value)); }
  
  public T setLong(K name, long value) { return (T)set(name, fromLong(name, value)); }
  
  public T setDouble(K name, double value) { return (T)set(name, fromDouble(name, value)); }
  
  public T setTimeMillis(K name, long value) { return (T)set(name, fromTimeMillis(name, value)); }
  
  public T setFloat(K name, float value) { return (T)set(name, fromFloat(name, value)); }
  
  public T setChar(K name, char value) { return (T)set(name, fromChar(name, value)); }
  
  public T setBoolean(K name, boolean value) { return (T)set(name, fromBoolean(name, value)); }
  
  public T setByte(K name, byte value) { return (T)set(name, fromByte(name, value)); }
  
  public T setShort(K name, short value) { return (T)set(name, fromShort(name, value)); }
  
  public T set(Headers<? extends K, ? extends V, ?> headers) {
    if (headers != this) {
      clear();
      addImpl(headers);
    } 
    return (T)thisT();
  }
  
  public T setAll(Headers<? extends K, ? extends V, ?> headers) {
    if (headers != this) {
      for (K key : headers.names())
        remove(key); 
      addImpl(headers);
    } 
    return (T)thisT();
  }
  
  public boolean remove(K name) { return (getAndRemove(name) != null); }
  
  public T clear() {
    Arrays.fill(this.entries, null);
    this.head.before = this.head.after = this.head;
    this.size = 0;
    return (T)thisT();
  }
  
  public Iterator<Map.Entry<K, V>> iterator() { return new HeaderIterator(this, null); }
  
  public Boolean getBoolean(K name) {
    V v = (V)get(name);
    try {
      return (v != null) ? Boolean.valueOf(toBoolean(name, v)) : null;
    } catch (RuntimeException ignore) {
      return null;
    } 
  }
  
  public boolean getBoolean(K name, boolean defaultValue) {
    Boolean v = getBoolean(name);
    return (v != null) ? v.booleanValue() : defaultValue;
  }
  
  public Byte getByte(K name) {
    V v = (V)get(name);
    try {
      return (v != null) ? Byte.valueOf(toByte(name, v)) : null;
    } catch (RuntimeException ignore) {
      return null;
    } 
  }
  
  public byte getByte(K name, byte defaultValue) {
    Byte v = getByte(name);
    return (v != null) ? v.byteValue() : defaultValue;
  }
  
  public Character getChar(K name) {
    V v = (V)get(name);
    try {
      return (v != null) ? Character.valueOf(toChar(name, v)) : null;
    } catch (RuntimeException ignore) {
      return null;
    } 
  }
  
  public char getChar(K name, char defaultValue) {
    Character v = getChar(name);
    return (v != null) ? v.charValue() : defaultValue;
  }
  
  public Short getShort(K name) {
    V v = (V)get(name);
    try {
      return (v != null) ? Short.valueOf(toShort(name, v)) : null;
    } catch (RuntimeException ignore) {
      return null;
    } 
  }
  
  public short getShort(K name, short defaultValue) {
    Short v = getShort(name);
    return (v != null) ? v.shortValue() : defaultValue;
  }
  
  public Integer getInt(K name) {
    V v = (V)get(name);
    try {
      return (v != null) ? Integer.valueOf(toInt(name, v)) : null;
    } catch (RuntimeException ignore) {
      return null;
    } 
  }
  
  public int getInt(K name, int defaultValue) {
    Integer v = getInt(name);
    return (v != null) ? v.intValue() : defaultValue;
  }
  
  public Long getLong(K name) {
    V v = (V)get(name);
    try {
      return (v != null) ? Long.valueOf(toLong(name, v)) : null;
    } catch (RuntimeException ignore) {
      return null;
    } 
  }
  
  public long getLong(K name, long defaultValue) {
    Long v = getLong(name);
    return (v != null) ? v.longValue() : defaultValue;
  }
  
  public Float getFloat(K name) {
    V v = (V)get(name);
    try {
      return (v != null) ? Float.valueOf(toFloat(name, v)) : null;
    } catch (RuntimeException ignore) {
      return null;
    } 
  }
  
  public float getFloat(K name, float defaultValue) {
    Float v = getFloat(name);
    return (v != null) ? v.floatValue() : defaultValue;
  }
  
  public Double getDouble(K name) {
    V v = (V)get(name);
    try {
      return (v != null) ? Double.valueOf(toDouble(name, v)) : null;
    } catch (RuntimeException ignore) {
      return null;
    } 
  }
  
  public double getDouble(K name, double defaultValue) {
    Double v = getDouble(name);
    return (v != null) ? v.doubleValue() : defaultValue;
  }
  
  public Long getTimeMillis(K name) {
    V v = (V)get(name);
    try {
      return (v != null) ? Long.valueOf(toTimeMillis(name, v)) : null;
    } catch (RuntimeException ignore) {
      return null;
    } 
  }
  
  public long getTimeMillis(K name, long defaultValue) {
    Long v = getTimeMillis(name);
    return (v != null) ? v.longValue() : defaultValue;
  }
  
  public Boolean getBooleanAndRemove(K name) {
    V v = (V)getAndRemove(name);
    try {
      return (v != null) ? Boolean.valueOf(toBoolean(name, v)) : null;
    } catch (RuntimeException ignore) {
      return null;
    } 
  }
  
  public boolean getBooleanAndRemove(K name, boolean defaultValue) {
    Boolean v = getBooleanAndRemove(name);
    return (v != null) ? v.booleanValue() : defaultValue;
  }
  
  public Byte getByteAndRemove(K name) {
    V v = (V)getAndRemove(name);
    try {
      return (v != null) ? Byte.valueOf(toByte(name, v)) : null;
    } catch (RuntimeException ignore) {
      return null;
    } 
  }
  
  public byte getByteAndRemove(K name, byte defaultValue) {
    Byte v = getByteAndRemove(name);
    return (v != null) ? v.byteValue() : defaultValue;
  }
  
  public Character getCharAndRemove(K name) {
    V v = (V)getAndRemove(name);
    try {
      return (v != null) ? Character.valueOf(toChar(name, v)) : null;
    } catch (RuntimeException ignore) {
      return null;
    } 
  }
  
  public char getCharAndRemove(K name, char defaultValue) {
    Character v = getCharAndRemove(name);
    return (v != null) ? v.charValue() : defaultValue;
  }
  
  public Short getShortAndRemove(K name) {
    V v = (V)getAndRemove(name);
    try {
      return (v != null) ? Short.valueOf(toShort(name, v)) : null;
    } catch (RuntimeException ignore) {
      return null;
    } 
  }
  
  public short getShortAndRemove(K name, short defaultValue) {
    Short v = getShortAndRemove(name);
    return (v != null) ? v.shortValue() : defaultValue;
  }
  
  public Integer getIntAndRemove(K name) {
    V v = (V)getAndRemove(name);
    try {
      return (v != null) ? Integer.valueOf(toInt(name, v)) : null;
    } catch (RuntimeException ignore) {
      return null;
    } 
  }
  
  public int getIntAndRemove(K name, int defaultValue) {
    Integer v = getIntAndRemove(name);
    return (v != null) ? v.intValue() : defaultValue;
  }
  
  public Long getLongAndRemove(K name) {
    V v = (V)getAndRemove(name);
    try {
      return (v != null) ? Long.valueOf(toLong(name, v)) : null;
    } catch (RuntimeException ignore) {
      return null;
    } 
  }
  
  public long getLongAndRemove(K name, long defaultValue) {
    Long v = getLongAndRemove(name);
    return (v != null) ? v.longValue() : defaultValue;
  }
  
  public Float getFloatAndRemove(K name) {
    V v = (V)getAndRemove(name);
    try {
      return (v != null) ? Float.valueOf(toFloat(name, v)) : null;
    } catch (RuntimeException ignore) {
      return null;
    } 
  }
  
  public float getFloatAndRemove(K name, float defaultValue) {
    Float v = getFloatAndRemove(name);
    return (v != null) ? v.floatValue() : defaultValue;
  }
  
  public Double getDoubleAndRemove(K name) {
    V v = (V)getAndRemove(name);
    try {
      return (v != null) ? Double.valueOf(toDouble(name, v)) : null;
    } catch (RuntimeException ignore) {
      return null;
    } 
  }
  
  public double getDoubleAndRemove(K name, double defaultValue) {
    Double v = getDoubleAndRemove(name);
    return (v != null) ? v.doubleValue() : defaultValue;
  }
  
  public Long getTimeMillisAndRemove(K name) {
    V v = (V)getAndRemove(name);
    try {
      return (v != null) ? Long.valueOf(toTimeMillis(name, v)) : null;
    } catch (RuntimeException ignore) {
      return null;
    } 
  }
  
  public long getTimeMillisAndRemove(K name, long defaultValue) {
    Long v = getTimeMillisAndRemove(name);
    return (v != null) ? v.longValue() : defaultValue;
  }
  
  public boolean equals(Object o) {
    if (!(o instanceof Headers))
      return false; 
    return equals((Headers)o, HashingStrategy.JAVA_HASHER);
  }
  
  public int hashCode() { return hashCode(HashingStrategy.JAVA_HASHER); }
  
  public final boolean equals(Headers<K, V, ?> h2, HashingStrategy<V> valueHashingStrategy) {
    if (h2.size() != size())
      return false; 
    if (this == h2)
      return true; 
    for (K name : names()) {
      List<V> otherValues = h2.getAll(name);
      List<V> values = getAll(name);
      if (otherValues.size() != values.size())
        return false; 
      for (int i = 0; i < otherValues.size(); i++) {
        if (!valueHashingStrategy.equals(otherValues.get(i), values.get(i)))
          return false; 
      } 
    } 
    return true;
  }
  
  public final int hashCode(HashingStrategy<V> valueHashingStrategy) {
    int result = -1028477387;
    for (K name : names()) {
      result = 31 * result + this.hashingStrategy.hashCode(name);
      List<V> values = getAll(name);
      for (int i = 0; i < values.size(); i++)
        result = 31 * result + valueHashingStrategy.hashCode(values.get(i)); 
    } 
    return result;
  }
  
  public String toString() { return HeadersUtils.toString(getClass(), iterator(), size()); }
  
  protected void validateName(NameValidator<K> validator, boolean forAdd, K name) { validator.validateName(name); }
  
  protected void validateValue(ValueValidator<V> validator, K name, V value) {
    try {
      validator.validate(value);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Validation failed for header '" + name + "'", e);
    } 
  }
  
  protected HeaderEntry<K, V> newHeaderEntry(int h, K name, V value, HeaderEntry<K, V> next) { return new HeaderEntry(h, name, value, next, this.head); }
  
  protected ValueConverter<V> valueConverter() { return this.valueConverter; }
  
  protected NameValidator<K> nameValidator() { return this.nameValidator; }
  
  protected ValueValidator<V> valueValidator() { return this.valueValidator; }
  
  private int index(int hash) { return hash & this.hashMask; }
  
  private void add0(int h, int i, K name, V value) {
    this.entries[i] = newHeaderEntry(h, name, value, this.entries[i]);
    this.size++;
  }
  
  private V remove0(int h, int i, K name) {
    HeaderEntry<K, V> e = this.entries[i];
    if (e == null)
      return null; 
    V value = null;
    HeaderEntry<K, V> next = e.next;
    while (next != null) {
      if (next.hash == h && this.hashingStrategy.equals(name, next.key)) {
        value = (V)next.value;
        e.next = next.next;
        next.remove();
        this.size--;
      } else {
        e = next;
      } 
      next = e.next;
    } 
    e = this.entries[i];
    if (e.hash == h && this.hashingStrategy.equals(name, e.key)) {
      if (value == null)
        value = (V)e.value; 
      this.entries[i] = e.next;
      e.remove();
      this.size--;
    } 
    return value;
  }
  
  HeaderEntry<K, V> remove0(HeaderEntry<K, V> entry, HeaderEntry<K, V> previous) {
    int i = index(entry.hash);
    HeaderEntry<K, V> firstEntry = this.entries[i];
    if (firstEntry == entry) {
      this.entries[i] = entry.next;
      previous = this.entries[i];
    } else if (previous == null) {
      previous = firstEntry;
      HeaderEntry<K, V> next = firstEntry.next;
      while (next != null && next != entry) {
        previous = next;
        next = next.next;
      } 
      assert next != null : "Entry not found in its hash bucket: " + entry;
      previous.next = entry.next;
    } else {
      previous.next = entry.next;
    } 
    entry.remove();
    this.size--;
    return previous;
  }
  
  private T thisT() { return (T)this; }
  
  private V fromObject(K name, Object value) {
    try {
      return (V)this.valueConverter.convertObject(ObjectUtil.checkNotNull(value, "value"));
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Failed to convert object value for header '" + name + '\'', e);
    } 
  }
  
  private V fromBoolean(K name, boolean value) {
    try {
      return (V)this.valueConverter.convertBoolean(value);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Failed to convert boolean value for header '" + name + '\'', e);
    } 
  }
  
  private V fromByte(K name, byte value) {
    try {
      return (V)this.valueConverter.convertByte(value);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Failed to convert byte value for header '" + name + '\'', e);
    } 
  }
  
  private V fromChar(K name, char value) {
    try {
      return (V)this.valueConverter.convertChar(value);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Failed to convert char value for header '" + name + '\'', e);
    } 
  }
  
  private V fromShort(K name, short value) {
    try {
      return (V)this.valueConverter.convertShort(value);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Failed to convert short value for header '" + name + '\'', e);
    } 
  }
  
  private V fromInt(K name, int value) {
    try {
      return (V)this.valueConverter.convertInt(value);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Failed to convert int value for header '" + name + '\'', e);
    } 
  }
  
  private V fromLong(K name, long value) {
    try {
      return (V)this.valueConverter.convertLong(value);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Failed to convert long value for header '" + name + '\'', e);
    } 
  }
  
  private V fromFloat(K name, float value) {
    try {
      return (V)this.valueConverter.convertFloat(value);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Failed to convert float value for header '" + name + '\'', e);
    } 
  }
  
  private V fromDouble(K name, double value) {
    try {
      return (V)this.valueConverter.convertDouble(value);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Failed to convert double value for header '" + name + '\'', e);
    } 
  }
  
  private V fromTimeMillis(K name, long value) {
    try {
      return (V)this.valueConverter.convertTimeMillis(value);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Failed to convert millsecond value for header '" + name + '\'', e);
    } 
  }
  
  private boolean toBoolean(K name, V value) {
    try {
      return this.valueConverter.convertToBoolean(value);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Failed to convert header value to boolean for header '" + name + '\'');
    } 
  }
  
  private byte toByte(K name, V value) {
    try {
      return this.valueConverter.convertToByte(value);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Failed to convert header value to byte for header '" + name + '\'');
    } 
  }
  
  private char toChar(K name, V value) {
    try {
      return this.valueConverter.convertToChar(value);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Failed to convert header value to char for header '" + name + '\'');
    } 
  }
  
  private short toShort(K name, V value) {
    try {
      return this.valueConverter.convertToShort(value);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Failed to convert header value to short for header '" + name + '\'');
    } 
  }
  
  private int toInt(K name, V value) {
    try {
      return this.valueConverter.convertToInt(value);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Failed to convert header value to int for header '" + name + '\'');
    } 
  }
  
  private long toLong(K name, V value) {
    try {
      return this.valueConverter.convertToLong(value);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Failed to convert header value to long for header '" + name + '\'');
    } 
  }
  
  private float toFloat(K name, V value) {
    try {
      return this.valueConverter.convertToFloat(value);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Failed to convert header value to float for header '" + name + '\'');
    } 
  }
  
  private double toDouble(K name, V value) {
    try {
      return this.valueConverter.convertToDouble(value);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Failed to convert header value to double for header '" + name + '\'');
    } 
  }
  
  private long toTimeMillis(K name, V value) {
    try {
      return this.valueConverter.convertToTimeMillis(value);
    } catch (IllegalArgumentException e) {
      throw new IllegalArgumentException("Failed to convert header value to millsecond for header '" + name + '\'');
    } 
  }
  
  public DefaultHeaders<K, V, T> copy() {
    DefaultHeaders<K, V, T> copy = new DefaultHeaders<K, V, T>(this.hashingStrategy, this.valueConverter, this.nameValidator, this.entries.length);
    copy.addImpl(this);
    return copy;
  }
}
