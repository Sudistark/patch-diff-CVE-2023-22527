package io.netty.handler.ssl;

import io.netty.internal.tcnative.SSLContext;
import io.netty.util.internal.SuppressJava6Requirement;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.cert.X509Certificate;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.Map.Entry;
import java.util.Set;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLSessionContext;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509ExtendedTrustManager;
import javax.net.ssl.X509TrustManager;

public final class ReferenceCountedOpenSslClientContext extends ReferenceCountedOpenSslContext {
  private static final Set<String> SUPPORTED_KEY_TYPES = Collections.unmodifiableSet(new LinkedHashSet(
        Arrays.asList(new String[] { "RSA", "DH_RSA", "EC", "EC_RSA", "EC_EC" })));
  
  private final OpenSslSessionContext sessionContext;
  
  ReferenceCountedOpenSslClientContext(X509Certificate[] trustCertCollection, TrustManagerFactory trustManagerFactory, X509Certificate[] keyCertChain, PrivateKey key, String keyPassword, KeyManagerFactory keyManagerFactory, Iterable<String> ciphers, CipherSuiteFilter cipherFilter, ApplicationProtocolConfig apn, String[] protocols, long sessionCacheSize, long sessionTimeout, boolean enableOcsp, String keyStore, Entry... options) throws SSLException {
    super(ciphers, cipherFilter, toNegotiator(apn), 0, keyCertChain, ClientAuth.NONE, protocols, false, enableOcsp, true, options);
    success = false;
    try {
      this.sessionContext = newSessionContext(this, this.ctx, this.engineMap, trustCertCollection, trustManagerFactory, keyCertChain, key, keyPassword, keyManagerFactory, keyStore, sessionCacheSize, sessionTimeout);
      success = true;
    } finally {
      if (!success)
        release(); 
    } 
  }
  
  public OpenSslSessionContext sessionContext() { return this.sessionContext; }
  
  static OpenSslSessionContext newSessionContext(ReferenceCountedOpenSslContext thiz, long ctx, OpenSslEngineMap engineMap, X509Certificate[] trustCertCollection, TrustManagerFactory trustManagerFactory, X509Certificate[] keyCertChain, PrivateKey key, String keyPassword, KeyManagerFactory keyManagerFactory, String keyStore, long sessionCacheSize, long sessionTimeout) throws SSLException {
    if ((key == null && keyCertChain != null) || (key != null && keyCertChain == null))
      throw new IllegalArgumentException("Either both keyCertChain and key needs to be null or none of them"); 
    keyMaterialProvider = null;
    try {
      try {
        if (!OpenSsl.useKeyManagerFactory()) {
          if (keyManagerFactory != null)
            throw new IllegalArgumentException("KeyManagerFactory not supported"); 
          if (keyCertChain != null)
            setKeyMaterial(ctx, keyCertChain, key, keyPassword); 
        } else {
          OpenSslCachingX509KeyManagerFactory openSslCachingX509KeyManagerFactory;
          if (keyManagerFactory == null && keyCertChain != null) {
            char[] keyPasswordChars = keyStorePassword(keyPassword);
            KeyStore ks = buildKeyStore(keyCertChain, key, keyPasswordChars, keyStore);
            if (ks.aliases().hasMoreElements()) {
              openSslCachingX509KeyManagerFactory = new OpenSslX509KeyManagerFactory();
            } else {
              openSslCachingX509KeyManagerFactory = new OpenSslCachingX509KeyManagerFactory(KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()));
            } 
            openSslCachingX509KeyManagerFactory.init(ks, keyPasswordChars);
            keyMaterialProvider = providerFor(openSslCachingX509KeyManagerFactory, keyPassword);
          } else if (openSslCachingX509KeyManagerFactory != null) {
            keyMaterialProvider = providerFor(openSslCachingX509KeyManagerFactory, keyPassword);
          } 
          if (keyMaterialProvider != null) {
            OpenSslKeyMaterialManager materialManager = new OpenSslKeyMaterialManager(keyMaterialProvider);
            SSLContext.setCertificateCallback(ctx, new OpenSslClientCertificateCallback(engineMap, materialManager));
          } 
        } 
      } catch (Exception e) {
        throw new SSLException("failed to set certificate and key", e);
      } 
      SSLContext.setVerify(ctx, 1, 10);
      try {
        if (trustCertCollection != null) {
          trustManagerFactory = buildTrustManagerFactory(trustCertCollection, trustManagerFactory, keyStore);
        } else if (trustManagerFactory == null) {
          trustManagerFactory = TrustManagerFactory.getInstance(
              TrustManagerFactory.getDefaultAlgorithm());
          trustManagerFactory.init((KeyStore)null);
        } 
        X509TrustManager manager = chooseTrustManager(trustManagerFactory.getTrustManagers());
        setVerifyCallback(ctx, engineMap, manager);
      } catch (Exception e) {
        if (keyMaterialProvider != null)
          keyMaterialProvider.destroy(); 
        throw new SSLException("unable to setup trustmanager", e);
      } 
      OpenSslClientSessionContext context = new OpenSslClientSessionContext(thiz, keyMaterialProvider);
      context.setSessionCacheEnabled(CLIENT_ENABLE_SESSION_CACHE);
      if (sessionCacheSize > 0L)
        context.setSessionCacheSize((int)Math.min(sessionCacheSize, 2147483647L)); 
      if (sessionTimeout > 0L)
        context.setSessionTimeout((int)Math.min(sessionTimeout, 2147483647L)); 
      if (CLIENT_ENABLE_SESSION_TICKET)
        context.setTicketKeys(new OpenSslSessionTicketKey[0]); 
      keyMaterialProvider = null;
      return context;
    } finally {
      if (keyMaterialProvider != null)
        keyMaterialProvider.destroy(); 
    } 
  }
  
  @SuppressJava6Requirement(reason = "Guarded by java version check")
  private static void setVerifyCallback(long ctx, OpenSslEngineMap engineMap, X509TrustManager manager) {
    if (useExtendedTrustManager(manager)) {
      SSLContext.setCertVerifyCallback(ctx, new ExtendedTrustManagerVerifyCallback(engineMap, (X509ExtendedTrustManager)manager));
    } else {
      SSLContext.setCertVerifyCallback(ctx, new TrustManagerVerifyCallback(engineMap, manager));
    } 
  }
}
