package io.netty.handler.ssl;

import io.netty.internal.tcnative.SSL;
import java.util.HashMap;
import java.util.Map;

final class OpenSslClientSessionCache extends OpenSslSessionCache {
  private final Map<HostPort, OpenSslSessionCache.NativeSslSession> sessions = new HashMap();
  
  OpenSslClientSessionCache(OpenSslEngineMap engineMap) { super(engineMap); }
  
  protected boolean sessionCreated(OpenSslSessionCache.NativeSslSession session) {
    assert Thread.holdsLock(this);
    HostPort hostPort = keyFor(session.getPeerHost(), session.getPeerPort());
    if (hostPort == null || this.sessions.containsKey(hostPort))
      return false; 
    this.sessions.put(hostPort, session);
    return true;
  }
  
  protected void sessionRemoved(OpenSslSessionCache.NativeSslSession session) {
    assert Thread.holdsLock(this);
    HostPort hostPort = keyFor(session.getPeerHost(), session.getPeerPort());
    if (hostPort == null)
      return; 
    this.sessions.remove(hostPort);
  }
  
  void setSession(long ssl, String host, int port) {
    boolean reused;
    OpenSslSessionCache.NativeSslSession session;
    HostPort hostPort = keyFor(host, port);
    if (hostPort == null)
      return; 
    synchronized (this) {
      session = (OpenSslSessionCache.NativeSslSession)this.sessions.get(hostPort);
      if (session == null)
        return; 
      if (!session.isValid()) {
        removeSessionWithId(session.sessionId());
        return;
      } 
      reused = SSL.setSession(ssl, session.session());
    } 
    if (reused) {
      if (session.shouldBeSingleUse())
        session.invalidate(); 
      session.updateLastAccessedTime();
    } 
  }
  
  private static HostPort keyFor(String host, int port) {
    if (host == null && port < 1)
      return null; 
    return new HostPort(host, port);
  }
  
  void clear() {
    super.clear();
    this.sessions.clear();
  }
}
