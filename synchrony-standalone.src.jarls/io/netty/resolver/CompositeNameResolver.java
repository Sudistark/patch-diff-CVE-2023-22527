package io.netty.resolver;

import io.netty.util.concurrent.EventExecutor;
import io.netty.util.concurrent.Promise;
import io.netty.util.internal.ObjectUtil;
import java.util.Arrays;
import java.util.List;

public final class CompositeNameResolver<T> extends SimpleNameResolver<T> {
  private final NameResolver<T>[] resolvers;
  
  public CompositeNameResolver(EventExecutor executor, NameResolver... resolvers) {
    super(executor);
    ObjectUtil.checkNotNull(resolvers, "resolvers");
    for (int i = 0; i < resolvers.length; i++)
      ObjectUtil.checkNotNull(resolvers[i], "resolvers[" + i + ']'); 
    if (resolvers.length < 2)
      throw new IllegalArgumentException("resolvers: " + Arrays.asList(resolvers) + " (expected: at least 2 resolvers)"); 
    this.resolvers = (NameResolver[])resolvers.clone();
  }
  
  protected void doResolve(String inetHost, Promise<T> promise) throws Exception { doResolveRec(inetHost, promise, 0, null); }
  
  private void doResolveRec(String inetHost, Promise<T> promise, int resolverIndex, Throwable lastFailure) throws Exception {
    if (resolverIndex >= this.resolvers.length) {
      promise.setFailure(lastFailure);
    } else {
      NameResolver<T> resolver = this.resolvers[resolverIndex];
      resolver.resolve(inetHost).addListener(new Object(this, promise, inetHost, resolverIndex));
    } 
  }
  
  protected void doResolveAll(String inetHost, Promise<List<T>> promise) throws Exception { doResolveAllRec(inetHost, promise, 0, null); }
  
  private void doResolveAllRec(String inetHost, Promise<List<T>> promise, int resolverIndex, Throwable lastFailure) throws Exception {
    if (resolverIndex >= this.resolvers.length) {
      promise.setFailure(lastFailure);
    } else {
      NameResolver<T> resolver = this.resolvers[resolverIndex];
      resolver.resolveAll(inetHost).addListener(new Object(this, promise, inetHost, resolverIndex));
    } 
  }
}
