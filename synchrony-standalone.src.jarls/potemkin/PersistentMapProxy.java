package potemkin;

import clojure.lang.APersistentMap;
import clojure.lang.Associative;
import clojure.lang.IMapEntry;
import clojure.lang.IPersistentCollection;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.IteratorSeq;
import clojure.lang.PersistentHashMap;
import java.util.Iterator;

public class PersistentMapProxy extends APersistentMap {
  private final IMap _map;
  
  private final IPersistentMap _meta;
  
  public PersistentMapProxy(IMap paramIMap) {
    this._map = paramIMap;
    this._meta = null;
  }
  
  public PersistentMapProxy(IMap paramIMap, IPersistentMap paramIPersistentMap) {
    this._map = paramIMap;
    this._meta = paramIPersistentMap;
  }
  
  public IMap innerMap() { return this._map; }
  
  public IPersistentMap meta() { return this._meta; }
  
  public IPersistentMap withMeta(IPersistentMap paramIPersistentMap) { return new PersistentMapProxy(this._map, paramIPersistentMap); }
  
  public int hashCode() { return (this._map instanceof IEquality) ? ((IEquality)this._map).hash() : super.hashCode(); }
  
  public boolean equals(Object paramObject) {
    if (this._map instanceof IEquality) {
      IEquality iEquality = (IEquality)this._map;
      return (paramObject instanceof PersistentMapProxy) ? iEquality.eq(((PersistentMapProxy)paramObject).innerMap()) : iEquality.eq(paramObject);
    } 
    return super.equals(paramObject);
  }
  
  public boolean containsKey(Object paramObject) { return this._map.keySet().contains(paramObject); }
  
  public IMapEntry entryAt(Object paramObject) { return containsKey(paramObject) ? new MapEntry(this, paramObject) : null; }
  
  public IPersistentMap assoc(Object paramObject1, Object paramObject2) { return new PersistentMapProxy(this._map.assoc(paramObject1, paramObject2)); }
  
  public IPersistentMap assocEx(Object paramObject1, Object paramObject2) {
    if (containsKey(paramObject1))
      throw new IllegalStateException("key already contained in map"); 
    return assoc(paramObject1, paramObject2);
  }
  
  public IPersistentMap without(Object paramObject) { return new PersistentMapProxy(this._map.dissoc(paramObject)); }
  
  public Object valAt(Object paramObject) { return this._map.get(paramObject, null); }
  
  public Object valAt(Object paramObject1, Object paramObject2) { return this._map.get(paramObject1, paramObject2); }
  
  public int count() { return this._map.keySet().size(); }
  
  public IPersistentCollection empty() {
    IMap iMap = this._map.empty();
    return (iMap != null) ? new PersistentMapProxy(this._map.empty()) : PersistentHashMap.EMPTY;
  }
  
  public Iterator iterator() {
    Iterator iterator = this._map.keySet().iterator();
    PersistentMapProxy persistentMapProxy = this;
    return new Object(this, iterator, persistentMapProxy);
  }
  
  public ISeq seq() { return IteratorSeq.create(iterator()); }
}
