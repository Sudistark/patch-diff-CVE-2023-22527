package ring.middleware.session.memory;

import clojure.lang.IFn;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.UUID;
import ring.middleware.session.store.SessionStore;

public final class MemoryStore implements SessionStore, IType {
  public final Object session_map;
  
  public static final Var const__0 = (Var)RT.var("clojure.core", "deref"), const__1 = (Var)RT.var("clojure.core", "str"), const__2 = (Var)RT.var("clojure.core", "swap!"), const__3 = (Var)RT.var("clojure.core", "assoc"), const__4 = (Var)RT.var("clojure.core", "dissoc");
  
  public MemoryStore(Object paramObject) { this.session_map = paramObject; }
  
  public static IPersistentVector getBasis() { return Tuple.create(Symbol.intern(null, "session-map")); }
  
  public Object delete_session(Object key) { key = null;
    ((IFn)const__2.getRawRoot()).invoke(this.session_map, const__4.getRawRoot(), key);
    return null; }
  
  public Object write_session(Object key, Object data) {
    Object or__5516__auto__60205 = key = null;
    if (or__5516__auto__60205 != null) {
      if (or__5516__auto__60205 != Boolean.FALSE)
        or__5516__auto__60205 = null; 
    } else {
      or__5516__auto__60205;
    } 
    key = ((IFn)const__1.getRawRoot()).invoke(UUID.randomUUID());
    data = null;
    ((IFn)const__2.getRawRoot()).invoke(this.session_map, const__3.getRawRoot(), key, data);
    return null;
  }
  
  public Object read_session(Object key) { key = null;
    this = null;
    return ((IFn)((IFn)const__0.getRawRoot()).invoke(this.session_map)).invoke(key); }
}
