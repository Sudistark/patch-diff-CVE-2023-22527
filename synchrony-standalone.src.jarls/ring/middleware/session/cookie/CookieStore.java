package ring.middleware.session.cookie;

import clojure.lang.IFn;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.PersistentArrayMap;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import ring.middleware.session.store.SessionStore;

public final class CookieStore implements SessionStore, IType {
  public final Object secret_key;
  
  public final Object options;
  
  public static final Var const__0 = (Var)RT.var("ring.middleware.session.cookie", "unseal"), const__1 = (Var)RT.var("ring.middleware.session.cookie", "seal");
  
  public CookieStore(Object paramObject1, Object paramObject2) { this.secret_key = paramObject1;
    this.options = paramObject2; }
  
  public static IPersistentVector getBasis() { return Tuple.create(Symbol.intern(null, "secret-key"), Symbol.intern(null, "options")); }
  
  public Object delete_session(Object _) { this = null;
    return ((IFn)const__1.getRawRoot()).invoke(this.secret_key, PersistentArrayMap.EMPTY, this.options); }
  
  public Object write_session(Object _, Object data) { data = null;
    this = null;
    return ((IFn)const__1.getRawRoot()).invoke(this.secret_key, data, this.options); }
  
  public Object read_session(Object data) { if (data != null) {
      if (data != Boolean.FALSE) {
        data = null;
        this = null;
      } 
    } else {
      data;
    } 
    return null; }
}
