package synchrony;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class history__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__2;
  
  public static final Var const__3;
  
  public static final AFn const__11;
  
  public static final Var const__12;
  
  public static final AFn const__15;
  
  public static final Var const__16;
  
  public static final AFn const__19;
  
  public static final Var const__20;
  
  public static final AFn const__23;
  
  public static final Var const__24;
  
  public static final AFn const__27;
  
  public static final Var const__28;
  
  public static final AFn const__30;
  
  public static final Object const__31;
  
  public static final Var const__32;
  
  public static final AFn const__35;
  
  public static final Var const__36;
  
  public static final AFn const__39;
  
  public static final Var const__40;
  
  public static final AFn const__43;
  
  public static final Var const__44;
  
  public static final AFn const__47;
  
  public static final Var const__48;
  
  public static final AFn const__51;
  
  public static final Var const__52;
  
  public static final AFn const__55;
  
  public static final Var const__56;
  
  public static final AFn const__59;
  
  public static final Var const__60;
  
  public static final AFn const__63;
  
  public static final Var const__64;
  
  public static final AFn const__68;
  
  public static final Var const__69;
  
  public static final AFn const__72;
  
  public static final Var const__73;
  
  public static final AFn const__76;
  
  public static final Var const__77;
  
  public static final AFn const__80;
  
  public static final Var const__81;
  
  public static final AFn const__84;
  
  public static final Var const__85;
  
  public static final AFn const__88;
  
  public static final Var const__89;
  
  public static final AFn const__92;
  
  public static final Var const__93;
  
  public static final AFn const__96;
  
  public static final Var const__97;
  
  public static final AFn const__100;
  
  public static final Var const__101;
  
  public static final AFn const__104;
  
  public static final Var const__105;
  
  public static final AFn const__108;
  
  public static final Var const__109;
  
  public static final AFn const__112;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new history.fn__37887());
    const__3.setMeta((IPersistentMap)const__11);
    const__3.bindRoot(new history.revision_info());
    const__12.setMeta((IPersistentMap)const__15);
    const__12.bindRoot(new history.qualify_rev());
    const__16.setMeta((IPersistentMap)const__19);
    const__16.bindRoot(new history.unqualify_rev());
    const__20.setMeta((IPersistentMap)const__23);
    const__20.bindRoot(new history.rev_partition());
    const__24.setMeta((IPersistentMap)const__27);
    const__24.bindRoot(new history.stringify_rev());
    const__28.setMeta((IPersistentMap)const__30);
    const__28.bindRoot(const__31);
    const__32.setMeta((IPersistentMap)const__35);
    const__32.bindRoot(new history.stringify_unqualified_rev());
    const__36.setMeta((IPersistentMap)const__39);
    const__36.bindRoot(new history.parse_rev());
    const__40.setMeta((IPersistentMap)const__43);
    const__40.bindRoot(new history.generate_rev());
    const__44.setMeta((IPersistentMap)const__47);
    const__44.bindRoot(new history.tag_master_revision());
    const__48.setMeta((IPersistentMap)const__51);
    const__48.bindRoot(new history.master_revision_QMARK_());
    const__52.setMeta((IPersistentMap)const__55);
    const__52.bindRoot(new history.master_head());
    const__56.setMeta((IPersistentMap)const__59);
    const__56.bindRoot(new history.revisions_by_rev());
    const__60.setMeta((IPersistentMap)const__63);
    const__60.bindRoot(new history.ancestor_revisions());
    const__64.setMeta((IPersistentMap)const__68);
    const__64.bindRoot(new history.cross_contextual_map());
    const__69.setMeta((IPersistentMap)const__72);
    const__69.bindRoot(new history.rebase1());
    const__73.setMeta((IPersistentMap)const__76);
    const__73.bindRoot(new history.rebase());
    const__77.setMeta((IPersistentMap)const__80);
    const__77.bindRoot(new history.split_right());
    const__81.setMeta((IPersistentMap)const__84);
    const__81.bindRoot(new history.compose_mixed());
    const__85.setMeta((IPersistentMap)const__88);
    const__85.bindRoot(new history.reconcile());
    const__89.setMeta((IPersistentMap)const__92);
    const__89.bindRoot(new history.backtrack());
    const__93.setMeta((IPersistentMap)const__96);
    const__93.bindRoot(new history.link());
    const__97.setMeta((IPersistentMap)const__100);
    const__97.bindRoot(new history.path_to_rev());
    const__101.setMeta((IPersistentMap)const__104);
    const__101.bindRoot(new history.revision_sequence());
    const__105.setMeta((IPersistentMap)const__108);
    const__105.bindRoot(new history.merge_divergence());
    const__109.setMeta((IPersistentMap)const__112);
    const__109.bindRoot(new history.merge_revisions());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "synchrony.history");
    const__2 = (AFn)Symbol.intern(null, "clojure.core");
    const__3 = (Var)RT.var("synchrony.history", "revision-info");
    const__11 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(), Tuple.create(Symbol.intern(null, "G__37970")) })), RT.keyword(null, "line"), Integer.valueOf(18), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__12 = (Var)RT.var("synchrony.history", "qualify-rev");
    const__15 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rev"), Symbol.intern(null, "partition")) })), RT.keyword(null, "line"), Integer.valueOf(20), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__16 = (Var)RT.var("synchrony.history", "unqualify-rev");
    const__19 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rev")) })), RT.keyword(null, "line"), Integer.valueOf(23), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__20 = (Var)RT.var("synchrony.history", "rev-partition");
    const__23 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rev")) })), RT.keyword(null, "line"), Integer.valueOf(26), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__24 = (Var)RT.var("synchrony.history", "stringify-rev");
    const__27 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rev")) })), RT.keyword(null, "line"), Integer.valueOf(29), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__28 = (Var)RT.var("synchrony.history", "Rev");
    const__30 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(39), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__31 = RT.classForName("synchrony.history.rev");
    const__32 = (Var)RT.var("synchrony.history", "stringify-unqualified-rev");
    const__35 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rev")) })), RT.keyword(null, "line"), Integer.valueOf(41), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__36 = (Var)RT.var("synchrony.history", "parse-rev");
    const__39 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "str")) })), RT.keyword(null, "line"), Integer.valueOf(44), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__40 = (Var)RT.var("synchrony.history", "generate-rev");
    const__43 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create() })), RT.keyword(null, "line"), Integer.valueOf(50), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__44 = (Var)RT.var("synchrony.history", "tag-master-revision");
    const__47 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "revision")) })), RT.keyword(null, "line"), Integer.valueOf(53), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__48 = (Var)RT.var("synchrony.history", "master-revision?");
    const__51 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "revision")) })), RT.keyword(null, "line"), Integer.valueOf(56), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__52 = (Var)RT.var("synchrony.history", "master-head");
    const__55 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "revisions")) })), RT.keyword(null, "line"), Integer.valueOf(59), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__56 = (Var)RT.var("synchrony.history", "revisions-by-rev");
    const__59 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "revisions")) })), RT.keyword(null, "line"), Integer.valueOf(65), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__60 = (Var)RT.var("synchrony.history", "ancestor-revisions");
    const__63 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "revision-by-rev"), Symbol.intern(null, "rev")) })), RT.keyword(null, "line"), Integer.valueOf(69), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__64 = (Var)RT.var("synchrony.history", "cross-contextual-map");
    const__68 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xop"), Symbol.intern(null, "xs"), Symbol.intern(null, "zs")) })), RT.keyword(null, "doc"), "Calls xop with ([x1 z1], [x1', z2], ..., [x2, z1'], [x2', z2']).", RT.keyword(null, "line"), Integer.valueOf(74), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__69 = (Var)RT.var("synchrony.history", "rebase1");
    const__72 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "local-r"), Symbol.intern(null, "remot-rs")) })), RT.keyword(null, "line"), Integer.valueOf(85), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__73 = (Var)RT.var("synchrony.history", "rebase");
    const__76 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "local-rs"), Symbol.intern(null, "remot-rs")) })), RT.keyword(null, "line"), Integer.valueOf(88), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__77 = (Var)RT.var("synchrony.history", "split-right");
    const__80 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { ((IObj)Tuple.create(Symbol.intern(null, "pred"), Symbol.intern(null, "v"))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "pre"), Tuple.create(((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "vector?"), Symbol.intern(null, "v") }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(92), RT.keyword(null, "column"), Integer.valueOf(10) }))) })) })), RT.keyword(null, "line"), Integer.valueOf(91), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__81 = (Var)RT.var("synchrony.history", "compose-mixed");
    const__84 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rs"), Symbol.intern(null, "mixed-rs")) })), RT.keyword(null, "doc"), "Optimization pass to run before reconcile that will compose all\n  revisions in mixed-rs that are not contained in rs and follow after\n  the last revision that is contained in rs. If there are no mixed-rs\n  revisions contained in rs, will compose all of mixed-rs into a single\n  revision.\n\n  We can't compose mixed-rs that are interleaved with rs (we can only\n  compose the last chunk that's not contained in rs) because composition\n  affects the outcome of a subsequent transformations (happening in\n  reconcile), and we have to reproduce exactly the same transformations\n  that happend on the server (which doesn't involve composition).", RT.keyword(null, "line"), Integer.valueOf(96), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__85 = (Var)RT.var("synchrony.history", "reconcile");
    const__88 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rs"), Symbol.intern(null, "mixed-rs")) })), RT.keyword(null, "doc"), "Given a sequence of revisions A and a sequence of revisions B which\n  may have some of A's revisions mixed in, return A and B transformed\n  against each other with revisions contained in both eliminated.", RT.keyword(null, "line"), Integer.valueOf(119), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__89 = (Var)RT.var("synchrony.history", "backtrack");
    const__92 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "xform"), Symbol.intern(null, "compose-revisions"), Symbol.intern(null, "pick?"), Symbol.intern(null, "inverse"), Symbol.intern(null, "revisions"), Symbol.intern(null, "off")) })), RT.keyword(null, "doc"), "Given a sequence of revisions, pick? revisions from it and transform\n  their inverse against the rest.\n\n  The result is [picked-inversed-revision, not-picked-revisions] such\n  that picked-inversed-revision can be applied on top of the original\n  sequence to undo the picked revisions, and the not-picked-revisions\n  can be applied to the parent of the original sequence (again to undo\n  the picked revisions).\n\n  The algorithm is based on the following properties:\n  1. transforming two concurrent deltas will yield two transformed\n     deltas that can be applied each on to the top of the opposite\n     untransformed delta to yield the identical result,\n  2. the inverse of a delta cancels out the inversed delta,\n\n  The following graphic describes how these properties are used. The first\n  column represents the actualy history with L3it, L2it, L1it being the\n  undo revisions that are generated and the remaining columns show the\n  \"alternate\" history for each undo step that would result in the\n  exact same result as that undo step (indicated with a '*').\n\n  L1------------L1i  L1 and L1i cancel each other out\n  R1            R1t\n  L2-------L2i  |    L2 and L2i cancel each other out\n  R2       R2t  R2tt\n  L3---L3i |    |    L3 and L3i cancel each other out (cancel out property)\n  R3   R3t R3tt R3ttt\n  L3it-*   |    |\n  L2itt----*    |\n  L1ittt--------* (identical result property)\n\n  L1i   is L1 inversed,\n  R1t   is R1 transformed against L1,\n  R2tt  is R1 transformed against L1 and L2,\n  L1it  is L1 inversed then transformed etc.\n  ", RT.keyword(null, "line"), Integer.valueOf(132), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__93 = (Var)RT.var("synchrony.history", "link");
    const__96 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "parent"), Symbol.intern(null, "revisions")) })), RT.keyword(null, "line"), Integer.valueOf(183), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__97 = (Var)RT.var("synchrony.history", "path-to-rev");
  }
  
  public static void __init1() {
    const__100 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rev"), Symbol.intern(null, "revisions")) })), RT.keyword(null, "line"), Integer.valueOf(191), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__101 = (Var)RT.var("synchrony.history", "revision-sequence");
    const__104 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "to-rev"), Symbol.intern(null, "revisions")), Tuple.create(Symbol.intern(null, "from-rev"), Symbol.intern(null, "to-rev"), Symbol.intern(null, "revisions")) })), RT.keyword(null, "line"), Integer.valueOf(196), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__105 = (Var)RT.var("synchrony.history", "merge-divergence");
    const__108 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "revisions"), Symbol.intern(null, "left-parent"), Symbol.intern(null, "dest-head")) })), RT.keyword(null, "doc"), "Returns the revisions that diverge from the given revision on the\n  destination branch.\n\n  Assumes the given parent (if it is not on the destination branch) has\n  also been merged. Revisions having a parent that isn't either 1. a\n  revision on the destination branch, or 2. merged into the destination\n  branch, are not supported.\n\n  The revisions argument must include the parent of the merge and any\n  later revisions up to dest-head.\n\n  When merging revision, two merge revisions are created, the left and\n  right merge revisions. The right merge revision advances the\n  destination branch to account for all revisions that happened on the\n  source branch, the left merge revision advances the source branch to\n  account for all revisions that happened on the destination branch. The\n  state of the entity at both merge revisions is identical. The left\n  merge revision is necessary to transform any subsequent revision\n  descending from the given revision in a later merge.\n\n  If A is the destination branch and B is the source branch, then the\n  graph might look like this where LM and RM are the left-merge and\n  right-merge revisions respectively.\n\n          (A)\n         /   \\\n        /     \\\n      (B)_ _  (A)\n      /  \\ \\/  \\\n     /    \\/\\___\\\n    /   (LM)     (RM)\n  (B)______         \\\n     \\    \\________(A)\n      \\   /\\________\\\n      (LM)            (RM)\n\n  Notice:\n\n  - RM is part of the destination branch A but LM isn't part of the\n    source branch B (LM is only used for transforming subsequent B\n    revisions),\n  - each corresponding LM and RM have the same two parents, one B parent\n    and one A parent (but LM will have the B parent as the 1st\n    parent and RM will have the A parent as the 1st parent.\n  ", RT.keyword(null, "line"), Integer.valueOf(212), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
    const__109 = (Var)RT.var("synchrony.history", "merge-revisions");
    const__112 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "revisions"), Symbol.intern(null, "revision"), Symbol.intern(null, "dest-head"), Symbol.intern(null, "left-rev"), Symbol.intern(null, "right-rev")) })), RT.keyword(null, "line"), Integer.valueOf(301), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history.cljc" });
  }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("synchrony.history__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
