package synchrony;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class history_store__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__2;
  
  public static final Object const__3;
  
  public static final Var const__4;
  
  public static final Var const__5;
  
  public static final Var const__6;
  
  public static final Keyword const__7;
  
  public static final Var const__8;
  
  public static final ISeq const__9;
  
  public static final Var const__10;
  
  public static final Var const__11;
  
  public static final AFn const__15;
  
  public static final Keyword const__16;
  
  public static final AFn const__17;
  
  public static final Keyword const__18;
  
  public static final Keyword const__19;
  
  public static final AFn const__29;
  
  public static final Keyword const__30;
  
  public static final Var const__31;
  
  public static final Var const__32;
  
  public static final Var const__33;
  
  public static final AFn const__34;
  
  public static final AFn const__35;
  
  public static final Keyword const__36;
  
  public static final AFn const__37;
  
  public static final AFn const__38;
  
  public static final AFn const__39;
  
  public static final AFn const__40;
  
  public static final AFn const__41;
  
  public static final AFn const__42;
  
  public static final AFn const__43;
  
  public static final AFn const__44;
  
  public static final AFn const__45;
  
  public static final AFn const__46;
  
  public static final AFn const__47;
  
  public static final AFn const__48;
  
  public static final AFn const__49;
  
  public static final AFn const__50;
  
  public static final AFn const__51;
  
  public static final AFn const__52;
  
  public static final Var const__53;
  
  public static final AFn const__54;
  
  public static final Var const__55;
  
  public static final AFn const__63;
  
  public static final Var const__64;
  
  public static final AFn const__67;
  
  public static final Var const__68;
  
  public static final AFn const__71;
  
  public static final Var const__72;
  
  public static final AFn const__76;
  
  public static final Var const__77;
  
  public static final AFn const__79;
  
  public static final AFn const__83;
  
  public static final Var const__84;
  
  public static final AFn const__86;
  
  public static final AFn const__88;
  
  public static final Var const__89;
  
  public static final AFn const__92;
  
  public static final Var const__93;
  
  public static final AFn const__96;
  
  public static final Var const__97;
  
  public static final AFn const__100;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new history_store.fn__38991());
    const__55.setMeta((IPersistentMap)const__63);
    const__55.bindRoot(new history_store.make_part());
    const__64.setMeta((IPersistentMap)const__67);
    const__64.bindRoot(new history_store.event_ref());
    const__68.setMeta((IPersistentMap)const__71);
    const__68.bindRoot(new history_store.event());
    const__72.setMeta((IPersistentMap)const__76);
    const__72.bindRoot(new history_store.get_part());
    const__77.setMeta((IPersistentMap)const__79);
    const__77.bindRoot(const__83);
    const__84.setMeta((IPersistentMap)const__86);
    const__84.bindRoot(const__88);
    const__89.setMeta((IPersistentMap)const__92);
    const__89.bindRoot(new history_store.duplicate_key_error());
    const__93.setMeta((IPersistentMap)const__96);
    const__93.bindRoot(new history_store.provisioning_exceeded_error());
    const__97.setMeta((IPersistentMap)const__100);
    const__97.bindRoot(new history_store.create_in_memory_store());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "synchrony.history-store");
    const__2 = (AFn)Symbol.intern(null, "clojure.core");
    const__3 = RT.classForName("synchrony.history_store.Store");
    const__4 = (Var)RT.var("clojure.core", "alter-meta!");
    const__5 = (Var)RT.var("synchrony.history-store", "Store");
    const__6 = (Var)RT.var("clojure.core", "assoc");
    const__7 = (Keyword)RT.keyword(null, "doc");
    const__8 = (Var)RT.var("clojure.core", "assert-same-protocol");
    const__9 = (ISeq)PersistentList.create(Arrays.asList(new Object[] { ((IObj)Symbol.intern(null, "get-head-info!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns a map of {:keys [max-part next-ref]} where max-part is the\n    result of get-max-part and next-ref is an event-ref {:keys [origin\n    sequence]} that can be used to store the next event.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id")) })) })), ((IObj)Symbol.intern(null, "delete-entity!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Remove all event data.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db-store"), Symbol.intern(null, "entity-id")) })) })), ((IObj)Symbol.intern(null, "get-max-part-id!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the id of the partition with the highest part-id for the\n    given entity-id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id")) })) })), ((IObj)Symbol.intern(null, "put-events!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Append events atomically to the log (all or nothing)\n\n  - entity-id a string identifier allowing multiple independent histories\n\n  - part-id a numeric counter (>= 0) identifying a partition in the\n    given history\n\n  - sequence a numeric counter (>= 0) identifying the event offset in\n    the given partition\n\n    Used to ensure consistency when there are (potentially) multiple\n    writers. Each writer can only write if they have seen the events\n    written by other writers.\n\n  - id-event-alist an association list of [event-id event] where\n    event-id is a string identifier uniquely identifying the event\n\n  - returns the serialized size of the given events\n\n    The serialized size of all events written to a partition is tracked\n    by the caller and the part-id is increased once enough events have\n    been written to a partition.\n\n  Using any other values results in undefined behavior. In particular,\n  using higher values for either partition or sequence may result in\n  an unrecoverable history.\n\n  [entity-id, part-id, sequence] and [entity-id, event-id] are unique\n  constraints and a (duplicate-key-error) will be thrown if a duplicated\n  event is persisted.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "part-id"), Symbol.intern(null, "sequence"), Symbol.intern(null, "id-event-alist")) })) })), ((IObj)Symbol.intern(null, "get-part!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a synchrony.history/part record for the given entity-id and part-id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "part-id")) })) })), ((IObj)Symbol.intern(null, "get-part-id-having-event-id!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Deprecated: Return part id given an entity id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "event-id")) })) })), ((IObj)Symbol.intern(null, "get-max-part!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a synchrony.history/part record for the partition with the\n    highest part-id for the given entity-id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id")) })) })), ((IObj)Symbol.intern(null, "get-part-having-event-id!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a synchrony.history/part record for the partition holding the\n    event with the given event-id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "event-id")) })) })), ((IObj)Symbol.intern(null, "delete-part!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Remove all event data from a partition.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db-store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "part")) })) })) }));
    const__10 = (Var)RT.var("clojure.core", "alter-var-root");
    const__11 = (Var)RT.var("clojure.core", "merge");
    const__15 = (AFn)RT.map(new Object[] { RT.keyword(null, "on"), Symbol.intern(null, "synchrony.history_store.Store"), RT.keyword(null, "on-interface"), RT.classForName("synchrony.history_store.Store"), RT.keyword(null, "doc"), "An interface to an append-only size-partitioned event log." });
    const__16 = (Keyword)RT.keyword(null, "sigs");
    const__17 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "get-head-info!"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-head-info!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns a map of {:keys [max-part next-ref]} where max-part is the\n    result of get-max-part and next-ref is an event-ref {:keys [origin\n    sequence]} that can be used to store the next event.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id")) })), RT.keyword(null, "doc"), "Returns a map of {:keys [max-part next-ref]} where max-part is the\n    result of get-max-part and next-ref is an event-ref {:keys [origin\n    sequence]} that can be used to store the next event." }), RT.keyword(null, "delete-entity!"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "delete-entity!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Remove all event data.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db-store"), Symbol.intern(null, "entity-id")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db-store"), Symbol.intern(null, "entity-id")) })), RT.keyword(null, "doc"), "Remove all event data." }), RT.keyword(null, "get-max-part-id!"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-max-part-id!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the id of the partition with the highest part-id for the\n    given entity-id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id")) })), RT.keyword(null, "doc"), "Return the id of the partition with the highest part-id for the\n    given entity-id." }), RT.keyword(null, "put-events!"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "put-events!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Append events atomically to the log (all or nothing)\n\n  - entity-id a string identifier allowing multiple independent histories\n\n  - part-id a numeric counter (>= 0) identifying a partition in the\n    given history\n\n  - sequence a numeric counter (>= 0) identifying the event offset in\n    the given partition\n\n    Used to ensure consistency when there are (potentially) multiple\n    writers. Each writer can only write if they have seen the events\n    written by other writers.\n\n  - id-event-alist an association list of [event-id event] where\n    event-id is a string identifier uniquely identifying the event\n\n  - returns the serialized size of the given events\n\n    The serialized size of all events written to a partition is tracked\n    by the caller and the part-id is increased once enough events have\n    been written to a partition.\n\n  Using any other values results in undefined behavior. In particular,\n  using higher values for either partition or sequence may result in\n  an unrecoverable history.\n\n  [entity-id, part-id, sequence] and [entity-id, event-id] are unique\n  constraints and a (duplicate-key-error) will be thrown if a duplicated\n  event is persisted.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "part-id"), Symbol.intern(null, "sequence"), Symbol.intern(null, "id-event-alist")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "part-id"), Symbol.intern(null, "sequence"), Symbol.intern(null, "id-event-alist")) })), RT.keyword(null, "doc"), "Append events atomically to the log (all or nothing)\n\n  - entity-id a string identifier allowing multiple independent histories\n\n  - part-id a numeric counter (>= 0) identifying a partition in the\n    given history\n\n  - sequence a numeric counter (>= 0) identifying the event offset in\n    the given partition\n\n    Used to ensure consistency when there are (potentially) multiple\n    writers. Each writer can only write if they have seen the events\n    written by other writers.\n\n  - id-event-alist an association list of [event-id event] where\n    event-id is a string identifier uniquely identifying the event\n\n  - returns the serialized size of the given events\n\n    The serialized size of all events written to a partition is tracked\n    by the caller and the part-id is increased once enough events have\n    been written to a partition.\n\n  Using any other values results in undefined behavior. In particular,\n  using higher values for either partition or sequence may result in\n  an unrecoverable history.\n\n  [entity-id, part-id, sequence] and [entity-id, event-id] are unique\n  constraints and a (duplicate-key-error) will be thrown if a duplicated\n  event is persisted." }), RT.keyword(null, "get-part!"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-part!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a synchrony.history/part record for the given entity-id and part-id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "part-id")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "part-id")) })), RT.keyword(null, "doc"), "Return a synchrony.history/part record for the given entity-id and part-id." }), 
          RT.keyword(null, "get-part-id-having-event-id!"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-part-id-having-event-id!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Deprecated: Return part id given an entity id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "event-id")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "event-id")) })), RT.keyword(null, "doc"), "Deprecated: Return part id given an entity id." }), RT.keyword(null, "get-max-part!"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-max-part!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a synchrony.history/part record for the partition with the\n    highest part-id for the given entity-id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id")) })), RT.keyword(null, "doc"), "Return a synchrony.history/part record for the partition with the\n    highest part-id for the given entity-id." }), RT.keyword(null, "get-part-having-event-id!"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-part-having-event-id!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a synchrony.history/part record for the partition holding the\n    event with the given event-id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "event-id")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "event-id")) })), RT.keyword(null, "doc"), "Return a synchrony.history/part record for the partition holding the\n    event with the given event-id." }), RT.keyword(null, "delete-part!"), RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "delete-part!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Remove all event data from a partition.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db-store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "part")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db-store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "part")) })), RT.keyword(null, "doc"), "Remove all event data from a partition." }) });
    const__18 = (Keyword)RT.keyword(null, "var");
    const__19 = (Keyword)RT.keyword(null, "method-map");
    const__29 = (AFn)RT.map(new Object[] { 
          RT.keyword(null, "get-head-info!"), RT.keyword(null, "get-head-info!"), RT.keyword(null, "delete-entity!"), RT.keyword(null, "delete-entity!"), RT.keyword(null, "get-max-part-id!"), RT.keyword(null, "get-max-part-id!"), RT.keyword(null, "put-events!"), RT.keyword(null, "put-events!"), RT.keyword(null, "get-part!"), RT.keyword(null, "get-part!"), 
          RT.keyword(null, "get-part-id-having-event-id!"), RT.keyword(null, "get-part-id-having-event-id!"), RT.keyword(null, "get-max-part!"), RT.keyword(null, "get-max-part!"), RT.keyword(null, "get-part-having-event-id!"), RT.keyword(null, "get-part-having-event-id!"), RT.keyword(null, "delete-part!"), RT.keyword(null, "delete-part!") });
    const__30 = (Keyword)RT.keyword(null, "method-builders");
    const__31 = (Var)RT.var("clojure.core", "intern");
    const__32 = (Var)RT.var("clojure.core", "*ns*");
    const__33 = (Var)RT.var("clojure.core", "with-meta");
    const__34 = (AFn)((IObj)Symbol.intern(null, "get-part-having-event-id!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a synchrony.history/part record for the partition holding the\n    event with the given event-id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "event-id")) })) }));
    const__35 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-part-having-event-id!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a synchrony.history/part record for the partition holding the\n    event with the given event-id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "event-id")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "event-id")) })), RT.keyword(null, "doc"), "Return a synchrony.history/part record for the partition holding the\n    event with the given event-id." });
    const__36 = (Keyword)RT.keyword(null, "protocol");
    const__37 = (AFn)((IObj)Symbol.intern(null, "get-part!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a synchrony.history/part record for the given entity-id and part-id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "part-id")) })) }));
    const__38 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-part!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a synchrony.history/part record for the given entity-id and part-id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "part-id")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "part-id")) })), RT.keyword(null, "doc"), "Return a synchrony.history/part record for the given entity-id and part-id." });
    const__39 = (AFn)((IObj)Symbol.intern(null, "get-part-id-having-event-id!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Deprecated: Return part id given an entity id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "event-id")) })) }));
    const__40 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-part-id-having-event-id!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Deprecated: Return part id given an entity id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "event-id")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "event-id")) })), RT.keyword(null, "doc"), "Deprecated: Return part id given an entity id." });
    const__41 = (AFn)((IObj)Symbol.intern(null, "put-events!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Append events atomically to the log (all or nothing)\n\n  - entity-id a string identifier allowing multiple independent histories\n\n  - part-id a numeric counter (>= 0) identifying a partition in the\n    given history\n\n  - sequence a numeric counter (>= 0) identifying the event offset in\n    the given partition\n\n    Used to ensure consistency when there are (potentially) multiple\n    writers. Each writer can only write if they have seen the events\n    written by other writers.\n\n  - id-event-alist an association list of [event-id event] where\n    event-id is a string identifier uniquely identifying the event\n\n  - returns the serialized size of the given events\n\n    The serialized size of all events written to a partition is tracked\n    by the caller and the part-id is increased once enough events have\n    been written to a partition.\n\n  Using any other values results in undefined behavior. In particular,\n  using higher values for either partition or sequence may result in\n  an unrecoverable history.\n\n  [entity-id, part-id, sequence] and [entity-id, event-id] are unique\n  constraints and a (duplicate-key-error) will be thrown if a duplicated\n  event is persisted.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "part-id"), Symbol.intern(null, "sequence"), Symbol.intern(null, "id-event-alist")) })) }));
    const__42 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "put-events!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Append events atomically to the log (all or nothing)\n\n  - entity-id a string identifier allowing multiple independent histories\n\n  - part-id a numeric counter (>= 0) identifying a partition in the\n    given history\n\n  - sequence a numeric counter (>= 0) identifying the event offset in\n    the given partition\n\n    Used to ensure consistency when there are (potentially) multiple\n    writers. Each writer can only write if they have seen the events\n    written by other writers.\n\n  - id-event-alist an association list of [event-id event] where\n    event-id is a string identifier uniquely identifying the event\n\n  - returns the serialized size of the given events\n\n    The serialized size of all events written to a partition is tracked\n    by the caller and the part-id is increased once enough events have\n    been written to a partition.\n\n  Using any other values results in undefined behavior. In particular,\n  using higher values for either partition or sequence may result in\n  an unrecoverable history.\n\n  [entity-id, part-id, sequence] and [entity-id, event-id] are unique\n  constraints and a (duplicate-key-error) will be thrown if a duplicated\n  event is persisted.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "part-id"), Symbol.intern(null, "sequence"), Symbol.intern(null, "id-event-alist")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "part-id"), Symbol.intern(null, "sequence"), Symbol.intern(null, "id-event-alist")) })), RT.keyword(null, "doc"), "Append events atomically to the log (all or nothing)\n\n  - entity-id a string identifier allowing multiple independent histories\n\n  - part-id a numeric counter (>= 0) identifying a partition in the\n    given history\n\n  - sequence a numeric counter (>= 0) identifying the event offset in\n    the given partition\n\n    Used to ensure consistency when there are (potentially) multiple\n    writers. Each writer can only write if they have seen the events\n    written by other writers.\n\n  - id-event-alist an association list of [event-id event] where\n    event-id is a string identifier uniquely identifying the event\n\n  - returns the serialized size of the given events\n\n    The serialized size of all events written to a partition is tracked\n    by the caller and the part-id is increased once enough events have\n    been written to a partition.\n\n  Using any other values results in undefined behavior. In particular,\n  using higher values for either partition or sequence may result in\n  an unrecoverable history.\n\n  [entity-id, part-id, sequence] and [entity-id, event-id] are unique\n  constraints and a (duplicate-key-error) will be thrown if a duplicated\n  event is persisted." });
    const__43 = (AFn)((IObj)Symbol.intern(null, "get-max-part!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a synchrony.history/part record for the partition with the\n    highest part-id for the given entity-id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id")) })) }));
    const__44 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-max-part!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return a synchrony.history/part record for the partition with the\n    highest part-id for the given entity-id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id")) })), RT.keyword(null, "doc"), "Return a synchrony.history/part record for the partition with the\n    highest part-id for the given entity-id." });
    const__45 = (AFn)((IObj)Symbol.intern(null, "get-head-info!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns a map of {:keys [max-part next-ref]} where max-part is the\n    result of get-max-part and next-ref is an event-ref {:keys [origin\n    sequence]} that can be used to store the next event.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id")) })) }));
    const__46 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-head-info!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Returns a map of {:keys [max-part next-ref]} where max-part is the\n    result of get-max-part and next-ref is an event-ref {:keys [origin\n    sequence]} that can be used to store the next event.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id")) })), RT.keyword(null, "doc"), "Returns a map of {:keys [max-part next-ref]} where max-part is the\n    result of get-max-part and next-ref is an event-ref {:keys [origin\n    sequence]} that can be used to store the next event." });
    const__47 = (AFn)((IObj)Symbol.intern(null, "get-max-part-id!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the id of the partition with the highest part-id for the\n    given entity-id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id")) })) }));
    const__48 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "get-max-part-id!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Return the id of the partition with the highest part-id for the\n    given entity-id.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "store"), Symbol.intern(null, "entity-id")) })), RT.keyword(null, "doc"), "Return the id of the partition with the highest part-id for the\n    given entity-id." });
    const__49 = (AFn)((IObj)Symbol.intern(null, "delete-entity!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Remove all event data.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db-store"), Symbol.intern(null, "entity-id")) })) }));
    const__50 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "delete-entity!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Remove all event data.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db-store"), Symbol.intern(null, "entity-id")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db-store"), Symbol.intern(null, "entity-id")) })), RT.keyword(null, "doc"), "Remove all event data." });
    const__51 = (AFn)((IObj)Symbol.intern(null, "delete-part!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Remove all event data from a partition.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db-store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "part")) })) }));
    const__52 = (AFn)RT.map(new Object[] { RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "delete-part!")).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "doc"), "Remove all event data from a partition.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db-store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "part")) })) })), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "db-store"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "part")) })), RT.keyword(null, "doc"), "Remove all event data from a partition." });
    const__53 = (Var)RT.var("clojure.core", "-reset-methods");
    const__54 = (AFn)Symbol.intern(null, "Store");
    const__55 = (Var)RT.var("synchrony.history-store", "make-part");
    const__63 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "id"), Symbol.intern(null, "events")) })), RT.keyword(null, "line"), Integer.valueOf(66), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history_store.clj" });
    const__64 = (Var)RT.var("synchrony.history-store", "event-ref");
    const__67 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "partition"), Symbol.intern(null, "sequence")) })), RT.keyword(null, "line"), Integer.valueOf(79), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history_store.clj" });
    const__68 = (Var)RT.var("synchrony.history-store", "event");
    const__71 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "event-ref"), Symbol.intern(null, "data")) })), RT.keyword(null, "line"), Integer.valueOf(84), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history_store.clj" });
    const__72 = (Var)RT.var("synchrony.history-store", "get-part");
    const__76 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "size"), Symbol.intern(null, "deserialize"), Symbol.intern(null, "state"), Symbol.intern(null, "entity-id"), Symbol.intern(null, "part-id")) })), RT.keyword(null, "line"), Integer.valueOf(87), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history_store.clj" });
    const__77 = (Var)RT.var("synchrony.history-store", "duplicate-key-info");
    const__79 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(96), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history_store.clj" });
    const__83 = (AFn)RT.map(new Object[] { RT.keyword(null, "type"), RT.keyword(null, "duplicate-key"), RT.keyword(null, "message"), "duplicate key" });
    const__84 = (Var)RT.var("synchrony.history-store", "provisioning-exceeded-info");
    const__86 = (AFn)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(100), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history_store.clj" });
    const__88 = (AFn)RT.map(new Object[] { RT.keyword(null, "type"), RT.keyword(null, "provisioning-exceeded"), RT.keyword(null, "message"), "provisioning exceeded" });
    const__89 = (Var)RT.var("synchrony.history-store", "duplicate-key-error");
    const__92 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "entity-id"), Symbol.intern(null, "event-id")), Tuple.create(Symbol.intern(null, "entity-id"), Symbol.intern(null, "event-id"), Symbol.intern(null, "cause")) })), RT.keyword(null, "line"), Integer.valueOf(104), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history_store.clj" });
    const__93 = (Var)RT.var("synchrony.history-store", "provisioning-exceeded-error");
    const__96 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "entity-id")), Tuple.create(Symbol.intern(null, "entity-id"), Symbol.intern(null, "cause")) })), RT.keyword(null, "line"), Integer.valueOf(112), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history_store.clj" });
    const__97 = (Var)RT.var("synchrony.history-store", "create-in-memory-store");
  }
  
  public static void __init1() { const__100 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "&"), Tuple.create(RT.map(new Object[] { RT.keyword(null, "keys"), Tuple.create(Symbol.intern(null, "serialize"), Symbol.intern(null, "deserialize"), Symbol.intern(null, "size")), RT.keyword(null, "or"), RT.map(new Object[] { Symbol.intern(null, "serialize"), Symbol.intern(null, "identity"), Symbol.intern(null, "deserialize"), Symbol.intern(null, "identity"), Symbol.intern(null, "size"), ((IObj)PersistentList.create(Arrays.asList(new Object[] { Symbol.intern(null, "constantly"), Long.valueOf(1L) }))).withMeta((IPersistentMap)RT.map(new Object[] { RT.keyword(null, "line"), Integer.valueOf(195), RT.keyword(null, "column"), Integer.valueOf(45) })) }), RT.keyword(null, "as"), Symbol.intern(null, "opts") }))) })), RT.keyword(null, "line"), Integer.valueOf(192), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/history_store.clj" }); }
  
  static  {
    __init0();
    __init1();
    Compiler.pushNSandLoader(RT.classForName("synchrony.history_store__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
