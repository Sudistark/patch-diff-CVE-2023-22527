package synchrony.operation;

import clojure.lang.AFn;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IPersistentMap;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.concurrent.Callable;

public class inverse__init {
  public static final Var const__0;
  
  public static final AFn const__1;
  
  public static final AFn const__2;
  
  public static final Var const__3;
  
  public static final AFn const__11;
  
  public static final Var const__12;
  
  public static final AFn const__15;
  
  public static final Var const__16;
  
  public static final AFn const__19;
  
  public static final Var const__20;
  
  public static final Object const__21;
  
  public static final Var const__22;
  
  public static final AFn const__25;
  
  public static final Var const__26;
  
  public static final AFn const__29;
  
  public static final Var const__30;
  
  public static final AFn const__33;
  
  public static final Var const__34;
  
  public static final AFn const__37;
  
  public static final Var const__38;
  
  public static final Keyword const__39;
  
  public static final Var const__40;
  
  public static final AFn const__43;
  
  public static final Var const__44;
  
  public static final AFn const__47;
  
  public static final Keyword const__48;
  
  public static void load() {
    LockingTransaction.runInTransaction((Callable)new inverse.fn__37805());
    const__3.setMeta((IPersistentMap)const__11);
    const__3.bindRoot(new inverse.inverse_seq());
    const__12.setMeta((IPersistentMap)const__15);
    const__12.bindRoot(new inverse.inverse_one());
    const__16.setMeta((IPersistentMap)const__19);
    const__16
























      
      .bindRoot(((IFn)const__20.getRawRoot()).invoke(const__21));
    const__22.setMeta((IPersistentMap)const__25);
    const__22.bindRoot(new inverse.inverse_map());
    const__26.setMeta((IPersistentMap)const__29);
    const__26.bindRoot(new inverse.inverse_rec());
    const__30.setMeta((IPersistentMap)const__33);
    const__30.bindRoot(new inverse.inverse_impl());
    const__34.setMeta((IPersistentMap)const__37);
    const__34.bindRoot(new inverse.dom_inserts());
    const__40.setMeta((IPersistentMap)const__43);
    const__40.bindRoot(new inverse.clj_insert());
    const__44.setMeta((IPersistentMap)const__47);
    const__44.bindRoot(new inverse.any_inserts());
  }
  
  public static void __init0() {
    const__0 = (Var)RT.var("clojure.core", "in-ns");
    const__1 = (AFn)Symbol.intern(null, "synchrony.operation.inverse");
    const__2 = (AFn)Symbol.intern(null, "clojure.core");
    const__3 = (Var)RT.var("synchrony.operation.inverse", "inverse-seq");
    const__11 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rec"), Symbol.intern(null, "ctx"), Symbol.intern(null, "ops"), Symbol.intern(null, "node"), Symbol.intern(null, "i")) })), RT.keyword(null, "line"), Integer.valueOf(14), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/operation/inverse.cljc" });
    const__12 = (Var)RT.var("synchrony.operation.inverse", "inverse-one");
    const__15 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rec"), Symbol.intern(null, "ctx"), Symbol.intern(null, "op"), Symbol.intern(null, "node")) })), RT.keyword(null, "line"), Integer.valueOf(23), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/operation/inverse.cljc" });
    const__16 = (Var)RT.var("synchrony.operation.inverse", "not-found-value");
    const__19 = (AFn)RT.map(new Object[] { RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), Integer.valueOf(27), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/operation/inverse.cljc" });
    const__20 = (Var)RT.var("ginga.core", "make-array");
    const__21 = Long.valueOf(0L);
    const__22 = (Var)RT.var("synchrony.operation.inverse", "inverse-map");
    const__25 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "rec"), Symbol.intern(null, "zget"), Symbol.intern(null, "ctx"), Symbol.intern(null, "m"), Symbol.intern(null, "node")) })), RT.keyword(null, "line"), Integer.valueOf(29), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/operation/inverse.cljc" });
    const__26 = (Var)RT.var("synchrony.operation.inverse", "inverse-rec");
    const__29 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { RT.vector(new Object[] { 
                    Symbol.intern(null, "srec"), Symbol.intern(null, "mrec"), Symbol.intern(null, "pget"), Symbol.intern(null, "zget"), Symbol.intern(null, "zkeys"), Symbol.intern(null, "zcount"), Symbol.intern(null, "zinsert"), Symbol.intern(null, "zinserts"), Symbol.intern(null, "ctx"), Symbol.intern(null, "ops"), 
                    Symbol.intern(null, "i"), Symbol.intern(null, "node"), Symbol.intern(null, "op") }) })), RT.keyword(null, "line"), Integer.valueOf(42), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/operation/inverse.cljc" });
    const__30 = (Var)RT.var("synchrony.operation.inverse", "inverse-impl");
    const__33 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { RT.vector(new Object[] { Symbol.intern(null, "zget"), Symbol.intern(null, "zkeys"), Symbol.intern(null, "zcount"), Symbol.intern(null, "zinsert"), Symbol.intern(null, "zinserts"), Symbol.intern(null, "delta"), Symbol.intern(null, "tree") }) })), RT.keyword(null, "line"), Integer.valueOf(113), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/operation/inverse.cljc" });
    const__34 = (Var)RT.var("synchrony.operation.inverse", "dom-inserts");
    const__37 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "nodes"), Symbol.intern(null, "start"), Symbol.intern(null, "end")) })), RT.keyword(null, "line"), Integer.valueOf(146), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/operation/inverse.cljc" });
    const__38 = (Var)RT.var("synchrony.operation.inverse", "inverse");
    const__39 = (Keyword)RT.keyword(null, "dom");
    const__40 = (Var)RT.var("synchrony.operation.inverse", "clj-insert");
    const__43 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "v")), Tuple.create(Symbol.intern(null, "v"), Symbol.intern(null, "retain-op")) })), RT.keyword(null, "line"), Integer.valueOf(157), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/operation/inverse.cljc" });
    const__44 = (Var)RT.var("synchrony.operation.inverse", "any-inserts");
    const__47 = (AFn)RT.map(new Object[] { RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(new Object[] { Tuple.create(Symbol.intern(null, "insert"), Symbol.intern(null, "zsubvec"), Symbol.intern(null, "nodes"), Symbol.intern(null, "start"), Symbol.intern(null, "end")) })), RT.keyword(null, "line"), Integer.valueOf(174), RT.keyword(null, "column"), Integer.valueOf(1), RT.keyword(null, "file"), "synchrony/operation/inverse.cljc" });
    const__48 = (Keyword)RT.keyword(null, "clj");
  }
  
  static  {
    __init0();
    Compiler.pushNSandLoader(RT.classForName("synchrony.operation.inverse__init").getClassLoader());
    try {
      load();
    } finally {
      Var.popThreadBindings();
    } 
  }
}
