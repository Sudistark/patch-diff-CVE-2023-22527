package synchrony.operation.materialize_impl;

import clojure.lang.IFn;
import clojure.lang.IPersistentVector;
import clojure.lang.IType;
import clojure.lang.Numbers;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Util;
import clojure.lang.Var;

public final class VecEditor implements EditVec, IType {
  public final Object item;
  
  public final Object subvecs;
  
  public final Object i;
  
  private static Class __cached_class__0;
  
  public static final Var const__0 = (Var)RT.var("synchrony.operation.materialize-impl", "root-editor"), const__1 = (Var)RT.var("clojure.core", "assoc"), const__2 = (Var)RT.var("clojure.core", "conj"), const__3 = (Var)RT.var("clojure.core", "subvec"), const__5 = (Var)RT.var("clojure.core", "seq"), const__6 = (Var)RT.var("clojure.core", "with-meta"), const__7 = (Var)RT.var("clojure.core", "into"), const__8 = (Var)RT.var("clojure.core", "cat"), const__9 = (Var)RT.var("clojure.core", "meta");
  
  public VecEditor(Object paramObject1, Object paramObject2, Object paramObject3) { this.item = paramObject1;
    this.subvecs = paramObject2;
    this.i = paramObject3; }
  
  public static IPersistentVector getBasis() { return Tuple.create(Symbol.intern(null, "item"), Symbol.intern(null, "subvecs"), Symbol.intern(null, "i")); }
  
  public Object vec_finalize() {
    if (((IFn)const__5.getRawRoot()).invoke(this.subvecs) != null) {
      if (((IFn)const__5.getRawRoot()).invoke(this.subvecs) != Boolean.FALSE)
        this = null; 
    } else {
      ((IFn)const__5.getRawRoot()).invoke(this.subvecs);
    } 
    return this.item;
  }
  
  public Object vec_delete(Object offset, Object length, Object op) { offset = null;
    length = null;
    return new VecEditor(this.item, ((IFn)const__2.getRawRoot()).invoke(this.subvecs, ((IFn)const__3.getRawRoot()).invoke(this.item, this.i, offset)), Numbers.add(offset, length)); }
  
  public Object vec_insert_vals(Object offset, Object insert_items, Object op) { insert_items = null;
    offset = null;
    return new VecEditor(this.item, ((IFn)const__2.getRawRoot()).invoke(this.subvecs, ((IFn)const__3.getRawRoot()).invoke(this.item, this.i, offset), insert_items), offset); }
  
  public Object vec_insert(Object offset, Object insert_item) { insert_item = null;
    offset = null;
    return new VecEditor(this.item, ((IFn)const__2.getRawRoot()).invoke(this.subvecs, ((IFn)const__3.getRawRoot()).invoke(this.item, this.i, offset), Tuple.create(insert_item)), offset); }
  
  public Object vec_replace(Object offset, Object new_item) { offset = null;
    new_item = null;
    return new VecEditor(((IFn)const__1.getRawRoot()).invoke(this.item, offset, new_item), this.subvecs, this.i); }
  
  public Object vec_subeditor(Object offset, Object item) { item = null;
    if (Util.classOf(item) != __cached_class__0)
      if (!(item instanceof RootEditor)) {
        __cached_class__0 = Util.classOf(item);
      } else {
        return ((RootEditor)item).root_editor();
      }  
    this = null; }
}
